tFontName163,
   g_pszAltFontName164,
   g_pszAltFontName165,
   g_pszAltFontName166,
   g_pszAltFontName167,
   g_pszAltFontName168,
   g_pszAltFontName169,
   g_pszAltFontName170,
   g_pszAltFontName171,
   g_pszAltFontName172,
   g_pszAltFontName173,
   g_pszAltFontName174,
   g_pszAltFontName175,
   g_pszAltFontName176,
   g_pszAltFontName177,
   g_pszAltFontName178,
   g_pszAltFontName179,
   g_pszAltFontName180,
   g_pszAltFontName181,
   g_pszAltFontName182,
   g_pszAltFontName183,
   g_pszAltFontName184,
   g_pszAltFontName185,
   g_pszAltFontName186,
   g_pszAltFontName187,
   g_pszAltFontName188,
   g_pszAltFontName189,
   g_pszAltFontName190,
   g_pszAltFontName191,
   g_pszAltFontName192,
   g_pszAltFontName193,
   g_pszAltFontName194,
   g_pszAltFontName195,
   g_pszAltFontName196,
   g_pszAltFontName197,
   g_pszAltFontName198,
   g_pszAltFontName199,
   g_pszAltFontName200,
   g_pszAltFontName201,
   g_pszAltFontName202,
   g_pszAltFontName203,
   g_pszAltFontName204,
   g_pszAltFontName205,
   g_pszAltFontName206,
   g_pszAltFontName207,
   g_pszAltFontName208,
   g_pszAltFontName209,
};

const TCHAR * const pszAltFontNamesAlt[] = 
{
   g_pszAltFontName196,
   g_pszAltFontName028,
   g_pszAltFontName027,
   g_pszAltFontName024,
   g_pszAltFontName025,
   g_pszAltFontName023,
   g_pszAltFontName030,
   g_pszAltFontName021,
   g_pszAltFontName022,
   g_pszAltFontName029,
   g_pszAltFontName026,
   g_pszAltFontName041,
   g_pszAltFontName042,
   g_pszAltFontName039,
   g_pszAltFontName040,
   g_pszAltFontName037,
   g_pszAltFontName035,
   g_pszAltFontName036,
   g_pszAltFontName044,
   g_pszAltFontName034,
   g_pszAltFontName033,
   g_pszAltFontName007,
   g_pszAltFontName008,
   g_pszAltFontName005,
   g_pszAltFontName003,
   g_pszAltFontName004,
   g_pszAltFontName010,
   g_pszAltFontName002,
   g_pszAltFontName001,
   g_pszAltFontName009,
   g_pszAltFontName006,
   g_pszAltFontName043,
   g_pszAltFontName038,
   g_pszAltFontName020,
   g_pszAltFontName019,
   g_pszAltFontName016,
   g_pszAltFontName017,
   g_pszAltFontName015,
   g_pszAltFontName032,
   g_pszAltFontName013,
   g_pszAltFontName014,
   g_pszAltFontName011,
   g_pszAltFontName012,
   g_pszAltFontName031,
   g_pszAltFontName018,
   g_pszAltFontName191,
   g_pszAltFontName192,
   g_pszAltFontName201,
   g_pszAltFontName178,
   g_pszAltFontName181,
   g_pszAltFontName182,
   g_pszAltFontName203,
   g_pszAltFontName200,
   g_pszAltFontName202,
   g_pszAltFontName189,
   g_pszAltFontName190,
   g_pszAltFontName197,
   g_pszAltFontName160,
   g_pszAltFontName176,
   g_pszAltFontName175,
   g_pszAltFontName185,
   g_pszAltFontName186,
   g_pszAltFontName187,
   g_pszAltFontName188,
   g_pszAltFontName194,
   g_pszAltFontName193,
   g_pszAltFontName118,
   g_pszAltFontName119,
   g_pszAltFontName117,
   g_pszAltFontName114,
   g_pszAltFontName115,
   g_pszAltFontName116,
   g_pszAltFontName088,
   g_pszAltFontName089,
   g_pszAltFontName087,
   g_pszAltFontName084,
   g_pszAltFontName085,
   g_pszAltFontName086,
   g_pszAltFontName081,
   g_pszAltFontName082,
   g_pszAltFontName083,
   g_pszAltFontName078,
   g_pszAltFontName079,
   g_pszAltFontName080,
   g_pszAltFontName075,
   g_pszAltFontName076,
   g_pszAltFontName077,
   g_pszAltFontName074,
   g_pszAltFontName072,
   g_pszAltFontName073,
   g_pszAltFontName109,
   g_pszAltFontName110,
   g_pszAltFontName108,
   g_pszAltFontName105,
   g_pszAltFontName106,
   g_pszAltFontName107,
   g_pszAltFontName111,
   g_pszAltFontName112,
   g_pszAltFontName113,
   g_pszAltFontName102,
   g_pszAltFontName103,
   g_pszAltFontName104,
   g_pszAltFontName099,
   g_pszAltFontName100,
   g_pszAltFontName101,
   g_pszAltFontName093,
   g_pszAltFontName094,
   g_pszAltFontName095,
   g_pszAltFontName092,
   g_pszAltFontName090,
   g_pszAltFontName091,
   g_pszAltFontName096,
   g_pszAltFontName097,
   g_pszAltFontName098,
   g_pszAltFontName069,
   g_pszAltFontName070,
   g_pszAltFontName071,
   g_pszAltFontName068,
   g_pszAltFontName066,
   g_pszAltFontName067,
   g_pszAltFontName127,
   g_pszAltFontName128,
   g_pszAltFontName129,
   g_pszAltFontName132,
   g_pszAltFontName131,
   g_pszAltFontName130,
   g_pszAltFontName133,
   g_pszAltFontName120,
   g_pszAltFontName121,
   g_pszAltFontName122,
   g_pszAltFontName125,
   g_pszAltFontName124,
   g_pszAltFontName123,
   g_pszAltFontName126,
   g_pszAltFontName177,
   g_pszAltFontName183,
   g_pszAltFontName179,
   g_pszAltFontName180,
   g_pszAltFontName195,
   g_pszAltFontName206,
   g_pszAltFontName207,
   g_pszAltFontName208,
   g_pszAltFontName209,
   g_pszAltFontName173,
   g_pszAltFontName174,
   g_pszAltFontName199,
   g_pszAltFontName184,
   g_pszAltFontName171,
   g_pszAltFontName164,
   g_pszAltFontName162,
   g_pszAltFontName167,
   g_pszAltFontName166,
   g_pszAltFontName170,
   g_pszAltFontName163,
   g_pszAltFontName168,
   g_pszAltFontName169,
   g_pszAltFontName165,
   g_pszAltFontName161,
   g_pszAltFontName198,
   g_pszAltFontName172,
   g_pszAltFontName057,
   g_pszAltFontName157,
   g_pszAltFontName149,
   g_pszAltFontName153,
   g_pszAltFontName148,
   g_pszAltFontName156,
   g_pszAltFontName151,
   g_pszAltFontName150,
   g_pszAltFontName154,
   g_pszAltFontName155,
   g_pszAltFontName152,
   g_pszAltFontName147,
   g_pszAltFontName159,
   g_pszAltFontName143,
   g_pszAltFontName144,
   g_pszAltFontName059,
   g_pszAltFontName058,
   g_pszAltFontName134,
   g_pszAltFontName048,
   g_pszAltFontName136,
   g_pszAltFontName137,
   g_pszAltFontName049,
   g_pszAltFontName050,
   g_pszAltFontName135,
   g_pszAltFontName146,
   g_pszAltFontName060,
   g_pszAltFontName061,
   g_pszAltFontName062,
   g_pszAltFontName063,
   g_pszAltFontName054,
   g_pszAltFontName055,
   g_pszAltFontName045,
   g_pszAltFontName046,
   g_pszAltFontName065,
   g_pszAltFontName064,
   g_pszAltFontName138,
   g_pszAltFontName000,
   g_pszAltFontName056,
   g_pszAltFontName158,
   g_pszAltFontName145,
   g_pszAltFontName052,
   g_pszAltFontName047,
   g_pszAltFontName053,
   g_pszAltFontName051,
   g_pszAltFontName205,
   g_pszAltFontName204,
   g_pszAltFontName139,
   g_pszAltFontName140,
   g_pszAltFontName141,
   g_pszAltFontName142,
};

//+----------------------------------------------------------------------------
//
//  Function:   CompareStringFunction
//
//  Synopsis:   Comparison function used by the bsearch call in the function
//              AlternateFontName.  Note that we call StrCmpIC, so the only
//              variation we recognize is case in the ASCII range.  We *do
//              not*, for example, treat narrow and wide variations or kana
//              variations as equivalent.
//
//-----------------------------------------------------------------------------

int __cdecl
CompareStringFunction( const void * v0, const void * v1)
{
    return StrCmpIC( *(wchar_t **)v0, *(wchar_t **)v1 );
}

//+----------------------------------------------------------------------------
//
//  Function:   AlternateFontName
//
//  Synopsis:   Fonts often have two names associated with them, an ASCII
//              name and a Native name.  This is most often true on Asian
//              systems.  GDI, however, is not smart enough to recognize
//              alternate names as equivalent.  We therefore have a hard-
//              coded table (courtesy of the Office group) to help GDI out.
//
//  Returns:    Alternate font name, or NULL, if none is known.
//
//-----------------------------------------------------------------------------

const wchar_t *
AlternateFontName( const wchar_t * pszName )
{
    wchar_t **pszNameT = (wchar_t **)bsearch( (const void *)&pszName,
                                          (const void *)&pszAltFontNames,
                                          sizeof(pszAltFontNames) / sizeof(wchar_t *),
                                          sizeof(wchar_t *),
                                          CompareStringFunction );
    return pszNameT
            ? pszAltFontNamesAlt[pszNameT - pszAltFontNames]
            : NULL;
}

const wchar_t *
AlternateFontNameIfAvailable( const wchar_t * pszName )
{
    wchar_t **pszNameT = (wchar_t **)bsearch( (const void *)&pszName,
                                          (const void *)&pszAltFontNames,
                                          sizeof(pszAltFontNames) / sizeof(wchar_t *),
                                          sizeof(wchar_t *),
                                          CompareStringFunction );
    return pszNameT
            ? pszAltFontNamesAlt[pszNameT - pszAltFontNames]
            : pszName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmlapp\app.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       app.cxx
//
//  Contents:   application functionality.
//
//  Created:    02/20/98    philco   
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_FACTORY_HXX_
#define X_FACTORY_HXX_
#include "factory.hxx"
#endif

#ifndef X_SERVER_HXX_
#define X_SERVER_HXX_
#include "server.hxx"
#endif

#ifndef X_APP_HXX_
#define X_APP_HXX_
#include "app.hxx"
#endif

#ifndef X_APPRC_H_
#define X_APPRC_H_
#include "apprc.h"
#endif

#ifndef X_URLMON_H_
#define X_URLMON_H_
#include "urlmon.h"
#endif

#ifndef X_REGKEY_HXX_
#define X_REGKEY_HXX_
#include "regkey.hxx"
#endif

#ifndef X_PEERS_HXX_
#define X_PEERS_HXX_
#include "peers.hxx"
#endif

#ifndef X_COREDISP_H_
#define X_COREDISP_H_
#include "coredisp.h"
#endif

#ifndef X_FUNCSIG_HXX_
#define X_FUNCSIG_HXX_
#include "funcsig.hxx"
#endif

#ifndef X_MISC_HXX_
#define X_MISC_HXX_
#include "misc.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

// this is defined in winuser.h for WINVER >= 0x0500
// We need this to compile
#if(WINVER < 0x0500)
#define WS_EX_LAYOUTRTL         0x00400000L // Right to left mirroring
#endif /* WINVER >= 0x0500 */

DeclareTag(tagHTAWndMsg, "HTA", "HtmlApp Windows Messages")
DeclareTagEx(tagHTAWndAssert, "HTA", "HtmlApp IsWindow Asserts ",TRUE)

CHTMLApp::CHTMLApp()
{
    // Default window styles
    _dwStyle = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN;
    _dwStyleEx   = WS_EX_APPWINDOW;
    _windowState = SW_NORMAL;

    _fShowInTaskBar = TRUE;
    _fContextMenu   = TRUE;

    // Set defaults for pending move/resize operations
    _pMovePending.x = _pMovePending.y = LONG_MIN;
    _pSizePending.cx = _pSizePending.cy = LONG_MIN;
}

ULONG
CHTMLApp::SubRelease()
{
    if (--_ulAllRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        _ulAllRefs = ULREF_IN_DESTRUCTOR;
        return 0;
    }
    return _ulAllRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::Register
//
//  Synopsis:   Creates registry entries under various keys for this app
//
//----------------------------------------------------------------------------

HRESULT CHTMLApp::Register()
{
    HRESULT hr = S_OK;
    CRegKey key, subKey, serverKey;
    TCHAR aryAppPath[MAX_PATH+1];
    TCHAR arydefIcon[MAX_PATH+3];
    long lRet = ERROR_SUCCESS;
    
    // Remove any previous registration information
    Unregister();
    
    GetModuleFileName(_hinst, aryAppPath, MAX_PATH);

    // append icon resource ID to app path
    _tcscpy(arydefIcon, aryAppPath);
    _tcscat(arydefIcon, SZ_REG_DEF_ICON_ID);

    // Update file extension
    lRet = key.Create(HKEY_CLASSES_ROOT, SZ_REG_FILE_EXT);
    TESTREG(lRet);
    key.SetValue(SZ_REG_PROGID, NULL);
    key.SetValue(SZ_REG_CONTENT_TYPE, TEXT("Content Type"));

    // Update file association actions
    lRet= key.Create(HKEY_CLASSES_ROOT, SZ_REG_PROGID);
    TESTREG(lRet);
    key.SetValue(SZ_REG_FILE_READABLE_STRING, NULL);

    // Add a key to indicate the default icon for this file type
    lRet = subKey.Create(key, TEXT("DefaultIcon"));
    TESTREG(lRet);
    subKey.SetValue(arydefIcon, NULL);
        
    // Add a shell action key
    lRet = subKey.Create(key, TEXT("Shell\\Open\\Command"));
    TESTREG(lRet);

    TCHAR aryOpenCmd[MAX_PATH+4];
    _tcscpy(aryOpenCmd, aryAppPath);
    _tcscat(aryOpenCmd, TEXT(" \"%1\" %*"));
    subKey.SetValue(aryOpenCmd, NULL);

    // Register COM server information
    lRet = key.Open(HKEY_CLASSES_ROOT, TEXT("clsid"));
    TESTREG(lRet);

    // add our clsid
    lRet = subKey.Create(key, SZ_SERVER_CLSID);
    TESTREG(lRet);
    subKey.SetValue(SZ_REG_FILE_READABLE_STRING, NULL);

    // Now add all the other server goo
    lRet = serverKey.Create(subKey, TEXT("DefaultIcon"));
    TESTREG(lRet);
    serverKey.SetValue(arydefIcon, NULL);

    lRet = serverKey.Create(subKey, TEXT("LocalServer32"));
    TESTREG(lRet);
    serverKey.SetValue(aryAppPath, NULL);

    lRet = serverKey.Create(subKey, TEXT("Version"));
    TESTREG(lRet);            
    serverKey.SetValue(SZ_APPLICATION_VERSION, NULL);

    lRet = serverKey.Create(subKey, TEXT("ProgID"));
    TESTREG(lRet);            
    serverKey.SetValue(SZ_REG_PROGID, NULL);

    // Update content-type information
    lRet = key.Open(HKEY_CLASSES_ROOT, TEXT("MIME\\Database\\Content Type"));
    TESTREG(lRet);

    lRet = subKey.Create(key, SZ_REG_CONTENT_TYPE);
    TESTREG(lRet);
    subKey.SetValue(SZ_SERVER_CLSID, TEXT("CLSID"));                    
    subKey.SetValue(SZ_REG_FILE_EXT, TEXT("Extension"));                    

Cleanup:
    if (lRet != ERROR_SUCCESS)
    {
        // On failure, don't leave an inconsistent registry state
        Unregister();  
        hr = E_FAIL;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::Unregister
//
//  Synopsis:   Removes registry entries under various keys for this app.
//
//----------------------------------------------------------------------------

HRESULT CHTMLApp::Unregister()
{
    HRESULT hr = S_OK;
    CRegKey key;
    long lRet = ERROR_SUCCESS;
    
    lRet = key.Open(HKEY_CLASSES_ROOT, NULL);
    if (lRet == ERROR_SUCCESS)
    {
        key.RecurseDeleteKey(SZ_REG_FILE_EXT);
        key.RecurseDeleteKey(SZ_REG_PROGID);
    }
    
    lRet = key.Open(HKEY_CLASSES_ROOT, TEXT("clsid"));
    if (lRet == ERROR_SUCCESS)
        key.RecurseDeleteKey(SZ_SERVER_CLSID);

    lRet = key.Open(HKEY_CLASSES_ROOT, TEXT("MIME\\Database\\Content Type"));
    if (lRet == ERROR_SUCCESS)
        key.RecurseDeleteKey(SZ_REG_CONTENT_TYPE);

    if (lRet != ERROR_SUCCESS)
        hr = E_FAIL;

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::RegisterWindowClasses
//
//  Synopsis:   Registers window class for app's frame.
//
//----------------------------------------------------------------------------

HRESULT CHTMLApp::RegisterWindowClasses()
{
    WNDCLASS wc = {0};

    wc.lpfnWndProc   = WndProc;                                                                            
    wc.hInstance     = _hinst;
    wc.lpszMenuName  = MAKEINTRESOURCE(IDR_PADMENU);
    wc.lpszClassName = SZ_APPLICATION_WNDCLASS;
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);

    if (!RegisterClass(&wc))
    {
        return E_FAIL;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::Init
//
//  Synopsis:   One-time initialization 
//
//----------------------------------------------------------------------------

HRESULT CHTMLApp::Init(HINSTANCE hInst, LPTSTR lpszCmdLine, int nCmdShow)
{
    HRESULT hr = S_OK;

    _hinst = hInst;
    _windowState = nCmdShow;
    _cstrCmdLine.Set(lpszCmdLine);
    
    hr = THR(OleInitialize(NULL));

    // Need to remember whether this succeeded.  If it fails, don't
    // call OleUninitialize when the app shuts down.
    if (SUCCEEDED(hr))
        _fOLEInitialized = TRUE;

    TEST(hr);

    // The window must be created before CServerObject::Load is called
    // so that there will be a window for calls to GetViewRect.
    //
    hr = CreateAppWindow();
    TEST(hr);
        
    // COM will pass "/Embedding" as the command line if we are
    // launched via that means.  Register our class factory in 
    // this case.
    if (_tcsiequal(_cstrCmdLine, _T("/Embedding")) ||
        _tcsiequal(_cstrCmdLine, _T("-Embedding")))
    {
        _cstrCmdLine.Free();  // command line shouldn't contain embedding switch.
        _Factory.Register();
    }
    else if (_tcsiequal(_cstrCmdLine, _T("/Register")) ||
        _tcsiequal(_cstrCmdLine, _T("-Register")))
    {
        Register();
        hr = E_FAIL;  // Used to indicate the app should exit immediately
        goto Cleanup;        
    }
    else if (_tcsiequal(_cstrCmdLine, _T("/Unregister")) ||
        _tcsiequal(_cstrCmdLine, _T("-Unregister")))
    {
        Unregister();
        hr = E_FAIL;  // Used to indicate the app should exit immediately
        goto Cleanup;        
    }
    else
    {
        // We are being launched from the command line, or as the result of a
        // file extension association.  The command line argument should contain
        // an URL.

        IMoniker *pMk = NULL;
        
        hr = CreateHTAMoniker(&pMk);
        
        TEST(hr);
        
        hr = _Factory.CreateInstance(NULL, IID_IPersistMoniker, (void **)&_pServer);
        TEST(hr);

        _pServer->Load(TRUE, pMk, NULL, 0);

        ReleaseInterface(((IPersistMoniker *)_pServer));
        _pServer = NULL;
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::Passivate
//
//  Synopsis:   General cleanup that occurs before dtor
//
//----------------------------------------------------------------------------

void CHTMLApp::Passivate()
{
    // general app cleanup
    
    // Then passivate the subobjects
    _Client.Passivate();
    _Frame.Passivate();
    _Factory.Passivate();

    if (_pServer)
    {
        Assert(!_pServer->GetRefs());
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::Terminate
//
//  Synopsis:   Called when app terminates.
//
//----------------------------------------------------------------------------

HRESULT CHTMLApp::Terminate()
{
    HRESULT hr = S_OK;
    
    Passivate();
    
    if (_pServer)
    {
        ReleaseInterface(((IPersistMoniker *)_pServer));
        _pServer = NULL;
    }

    if (_aAppName)
    {
        ::GlobalDeleteAtom(_aAppName);
        _aAppName = NULL;
    }

    if (_fOLEInitialized)
        OleUninitialize();

    // If there is a hidden parent window, destroy it now.
    if (_hwndParent)
       DestroyWindow(_hwndParent);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::Run
//
//  Synopsis:   Message pump
//
//----------------------------------------------------------------------------

void CHTMLApp::Run()
{
    MSG msg;
    
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (S_FALSE == _Frame.TranslateKeyMsg(&msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::CreateHTAMoniker
//
//  Synopsis:   Creates an URL moniker based on the command line provided by
//              the system.
//
//  Notes:      This function is invoked only when an HTA is launched from a
//              command line or by the shell.
//----------------------------------------------------------------------------

HRESULT CHTMLApp::CreateHTAMoniker(IMoniker ** ppm)
{
    HRESULT hr = S_OK;
    CStr cstrPath;

    Assert(ppm);

    // Make a copy, remove command-line arguments and quotes.
    cstrPath.Set(_cstrCmdLine);
    PathRemoveArgs(cstrPath);
    PathUnquoteSpaces(cstrPath);
    
#ifndef UNICODE
    // Convert ansi URL to Unicode
    WCHAR awch[pdlUrlLen];
    UnicodeFromMbcs(awch, pdlUrlLen, cstrPath);
    hr = ::CreateURLMoniker(NULL, awch, ppm);
#else
    hr = ::CreateURLMoniker(NULL, cstrPath, ppm);
#endif

    TEST(hr);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::RunHTMLApplication
//
//  Synopsis:   Given a moniker, creates the frame window and an instance of 
//              trident.  Loads the moniker and activates Trident as a doc object.
//
//----------------------------------------------------------------------------

HRESULT CHTMLApp::RunHTMLApplication(IMoniker *pMk)
{
	HRESULT hr = S_OK;

	// A moniker is required.  Otherwise, what would we load?
	if (!pMk)
	{
		hr = E_POINTER;
		goto Cleanup;
	}
	
    hr = THR(_Client.Create(CLSID_HTADoc));
    TEST(hr);
    
    hr = THR(_Client.Load(pMk));
    TEST(hr);
    
    // We must activate the document here otherwise
    // modal dialogs such as VBScript's MsgBox won't work.
    //
    IGNORE_HR(_Client.Show());

Cleanup:
	RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::GetViewRect
//
//  Synopsis:   Provides the current client rect.
//
//----------------------------------------------------------------------------

void CHTMLApp::GetViewRect(OLERECT *prc)
{
#if DBG == 1 
if ( IsTagEnabled(tagHTAWndAssert))
{
    Assert(::IsWindow(_hwnd));
}   
#endif

    if (prc)
    {
        ::GetClientRect(_hwnd, prc);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::Resize
//
//  Synopsis:   Resizes the doc object to fill the new size of our frame window.
//
//----------------------------------------------------------------------------

void CHTMLApp::Resize()
{
    _Frame.Resize();
    _Client.Resize(); 
}


HRESULT CHTMLApp::Pending_moveTo(long x, long y)
{
    Assert(!IsWindow(_hwnd) || !IsWindowVisible(_hwnd));
    
    _pMovePending.x = x;
    _pMovePending.y = y;

    return S_OK;
}

HRESULT CHTMLApp::Pending_moveBy(long x, long y)
{
    HRESULT hr = E_PENDING;
    
    Assert(!IsWindow(_hwnd) || !IsWindowVisible(_hwnd));
    
    // Can't move by a relative amount until we have a non-default rect.
    if (_pMovePending.x != LONG_MIN && _pMovePending.y != LONG_MIN)
    {
        _pMovePending += CSize(x, y);
        hr = S_OK;
    }
    
    return hr;
}

HRESULT CHTMLApp::Pending_resizeTo(long x, long y)
{
    Assert(!IsWindow(_hwnd) || !IsWindowVisible(_hwnd));
    
    _pSizePending.SetSize(x, y);

    return S_OK;
}

HRESULT CHTMLApp::Pending_resizeBy(long x, long y)
{
    HRESULT hr = E_PENDING;
    
    Assert(!IsWindow(_hwnd) || !IsWindowVisible(_hwnd));
    
    // Can't resize by a relative amount until we have a non-default rect.
    if (_pSizePending.cx != LONG_MIN && _pSizePending.cy != LONG_MIN)
    {
        _pSizePending += CSize(x, y);
        hr = S_OK;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::CreateAppWindow
//
//  Synopsis:   Creates the application's frame window
//
//----------------------------------------------------------------------------

HRESULT CHTMLApp::CreateAppWindow()
{
    HRESULT hr = S_OK;

    // This method should only be called one time.
    Assert(!::IsWindow(_hwnd));
    
    if (::IsWindow(_hwnd))
        goto Error;
        
    // Register our window class
    hr = THR(RegisterWindowClasses());
    TEST(hr);

    // Create a hidden window to parent the app. This is necessary so
    // that if the user specifies showInTaskBar="no", the taskbar icon
    // will not be displayed.
    //
    _hwndParent = CreateWindowEx(
        0,
        SZ_APPLICATION_WNDCLASS,
        _T(""),
        0,
        0, 0, 0, 0,
        NULL,
        NULL,
        _hinst,
        this);

    Assert(::IsWindow(_hwndParent));
    
    if (!_hwndParent)
        goto Error;
       
    // We set this extended style here rather than in the CHTMLApp constructor
    // where the other styles are initialized because the g_fMirroredBidiLayout
    // is not initialized by then
    // If the following two lines change, update it for the html dialogs 
    // as well (..\htmldlg\htmldlg.cxx - CHTMLDlg::Activate)
    if (g_fMirroredBidiLayout)
        _dwStyleEx |= WS_EX_LAYOUTRTL;

    // Create main application window.
    _hwnd = CreateWindowEx(
            _dwStyleEx,
            _cstrAppName ? _cstrAppName : SZ_APPLICATION_WNDCLASS,
            _T(""),
            _dwStyle,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            _hwndParent,
            NULL,
            _hinst,
            this);

#if DBG == 1 
if ( IsTagEnabled(tagHTAWndAssert))
{
    Assert(::IsWindow(_hwnd));
}
#endif

    if (!_hwnd)
        goto Error;

    // Morph to a popup style...
    _dwStyle |= WS_POPUP;
    ::SetWindowLong(_hwnd, GWL_STYLE, _dwStyle);
    ::SetWindowPos(_hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER);
    
    // If we are running on NT5, then we need to tell the window that we are
    // interested in UIState messages.  This should only be called once per top
    // level window
    if (g_dwPlatformID == VER_PLATFORM_WIN32_NT && g_dwPlatformVersion >= 0x00050000)
    {
        SendMessage(_hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, 0), 0);
    }

Cleanup:
    RRETURN(hr);

Error:
    hr = E_FAIL;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::ShowFrameWindow
//
//  Synopsis:   Shows the application's frame window (setting initial size/position if
//              appropriate
//
//----------------------------------------------------------------------------

void CHTMLApp::ShowFrameWindow()
{
#if DBG == 1 
if ( IsTagEnabled(tagHTAWndAssert))
{
    Assert(::IsWindow(_hwnd));
}   
#endif
    
    // There will be a pending move if script has already called MoveTo before
    // this window was shown.
    if ((_pMovePending.x != LONG_MIN) && (_pMovePending.y != LONG_MIN))
    {
        // Move to new location.
        SetWindowPos(_hwnd,
                 NULL, 
                 _pMovePending.x, 
                 _pMovePending.y, 
                 0, 
                 0, 
                 SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE );

        // Being paranoid here...  not strictly necessary.
        _pMovePending.x = _pMovePending.y = LONG_MIN;
    }
    
    // There will be a pending size if script has already called resizeTo before
    // this window was shown.
    if ((_pSizePending.cx != LONG_MIN) && (_pSizePending.cy != LONG_MIN))
    {
        // resize according to pending information.
        SetWindowPos(_hwnd,
                 NULL, 
                 0, 
                 0, 
                 _pSizePending.cx, 
                 _pSizePending.cy, 
                 SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE );

        // Being paranoid here...  not strictly necessary.
        _pSizePending.cx = _pSizePending.cy = LONG_MIN;
    }


    ShowWindow(_hwnd, _windowState);
    UpdateWindow(_hwnd); 
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::SetTitle
//
//  Synopsis:   Sets the caption for frame window.
//
//----------------------------------------------------------------------------

void CHTMLApp::SetTitle(TCHAR * pchTitle)
{
    TCHAR szBuf[512];

#if DBG == 1 
if ( IsTagEnabled(tagHTAWndAssert))
{
    Assert(IsWindow(_hwnd));
}   
#endif

    GetWindowText(_hwnd, szBuf, ARRAY_SIZE(szBuf));
    if (!_tcsequal(szBuf, pchTitle))
    {
        SetWindowText(_hwnd, pchTitle);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::SetAttributes
//
//  Synopsis:   Retrieves application attributes from the behavior.
//
//----------------------------------------------------------------------------

void CHTMLApp::SetAttributes(CAppBehavior *pApp)
{
    CDoc *  pDoc; 
    HRESULT hr;

    // Get these directly from the attribute array.
    _fSingleInstance = pApp->GetAAsingleInstance();
    _cstrAppName.Set(pApp->GetAAapplicationName());

    // Handle single instance behavior
    if (_fSingleInstance && PriorInstance())
    {
        _fLoaded = TRUE;  // Needed so that FinalInit won't be called in CClient::Exec
        
        ::PostQuitMessage(0);
        return;  
    }

    // Computed values
    _dwStyle = pApp->GetStyles();
    _dwStyleEx |= pApp->GetExtendedStyles();
    
    _fShowInTaskBar  = pApp->GetAAshowInTaskBar();
    _fContextMenu    = pApp->GetAAcontextMenu();
    
    _windowState = pApp->GetAAwindowState();
    _cstrAppIcon.Set(pApp->GetAAicon());
    _cstrAppVersion.Set(pApp->GetAAversion());

    Assert(_Client._pUnk);
    
    hr = THR(_Client._pUnk->QueryInterface(CLSID_HTMLDocument, (void**)&pDoc));

    if (SUCCEEDED(hr))
    {
        // Set IDocHostUIHandler Flags
        //
        // Note that the default values of navigable and scrollFlat are 
        // different than the other properties. They are "no" by default.
        //
        if (pApp->GetAAnavigable())  // Allow inplace navigation of top-level content
        {
            pDoc->_dwFlagsHostInfo |= DOCHOSTUIFLAG_ENABLE_INPLACE_NAVIGATION;
            _dwHostInfo |= DOCHOSTUIFLAG_ENABLE_INPLACE_NAVIGATION;
        }

        if (pApp->GetAAscrollFlat())  
        {
            pDoc->_dwFlagsHostInfo |= DOCHOSTUIFLAG_FLAT_SCROLLBAR;
            _dwHostInfo |= DOCHOSTUIFLAG_FLAT_SCROLLBAR;
        }

        if (!pApp->GetAAinnerBorder())
        {
            pDoc->_dwFlagsHostInfo |= DOCHOSTUIFLAG_NO3DBORDER;
            _dwHostInfo |= DOCHOSTUIFLAG_NO3DBORDER;
        }

        if (!pApp->GetAAscroll())
        {
            pDoc->_dwFlagsHostInfo |= DOCHOSTUIFLAG_SCROLL_NO;
            _dwHostInfo |= DOCHOSTUIFLAG_SCROLL_NO;
        }

        if (!pApp->GetAAselection())  // Acts like a dialog: no selection
        {
            pDoc->_dwFlagsHostInfo |= DOCHOSTUIFLAG_DIALOG;
            _dwHostInfo |= DOCHOSTUIFLAG_DIALOG;
        }
    }

    FinalInit();
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::FinalInit
//
//  Synopsis:   Performs final initialization operations such as checking 
//              for other instances of the application if singleInstance
//              is set and showing the window.
//
//----------------------------------------------------------------------------

void CHTMLApp::FinalInit()
{
    HICON   hIcon = NULL;
    HRESULT hr;
    CDoc *  pDoc; 

    Assert(_Client._pUnk);
    
    hr = THR(_Client._pUnk->QueryInterface(CLSID_HTMLDocument, (void**)&pDoc));

    if (hr)
        return;

    pDoc->UpdateTitle();
    
    if (_cstrAppIcon)
    {
        hIcon = ::ExtractIcon(_hinst, _cstrAppIcon, 0);
    }

    // If we don't have a custom icon (or it couldn't be loaded), use the
    // default windows application icon.
    if ((HICON)1 == hIcon || NULL == hIcon)
    {
        hIcon = ::LoadIcon(NULL, IDI_APPLICATION);
    }

    if (hIcon)
    {
#if DBG == 1 
if ( IsTagEnabled(tagHTAWndAssert))
{
        Assert(::IsWindow(_hwndParent));
        Assert(::IsWindow(_hwnd));
}   
#endif
    

        // Set the big icon for the parent so that the icon is displayed in 
        // the ALT+TAB dialog. Set the small icon for the displayed window
        // so that the icon will be displayed in the title bar.
        //
        ::SendMessage(_hwndParent, WM_SETICON, (WPARAM)ICON_BIG, (LPARAM)hIcon);
        ::SendMessage(_hwnd, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM)hIcon);
    }

    // If the user has specified showInTaskBar="no", 
    // do not show the icon on the taskbar.
    //
    if (!_fShowInTaskBar)
    {
        _dwStyleEx &= ~WS_EX_APPWINDOW;
    }

    // Apply final window styles before showing the frame window
    ::SetWindowLong(_hwnd, GWL_STYLE, _dwStyle);
    ::SetWindowLong(_hwnd, GWL_EXSTYLE, _dwStyleEx);
    ::SetWindowPos(_hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER);

    // Save the application name in the window property table associated for this window.
    // This is used in PriorInstance() for the singleInstance functionality.
    //
    _aAppName = GlobalAddAtom((LPTSTR)_cstrAppName);
    ::SetProp(_hwndParent, (LPCTSTR)_aAppName, (HANDLE)_hwndParent ? _hwndParent : _hwnd);


    ShowFrameWindow();

    _fLoaded = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::PriorInstance
//
//  Synopsis:   Searches for another window that has a class name matching the
//              application name attribute for this instance.  Returns TRUE if
//              such a window is found.  Also brings that window (and any associated
//              popups) to the foreground.
//
//----------------------------------------------------------------------------

BOOL CHTMLApp::PriorInstance()
{
    BOOL  fPriorInstance = FALSE;
    TCHAR szClassName[MAX_PATH];
    HWND  hwndNext;

    // Only check for a prior instance if we aren't already loaded.
    // This prevents us from being shut down in the case of a refresh.
    // Also, we need an application name to determine if a prior 
    // instance is running
    //
    if (_fLoaded || !_cstrAppName)
    {
        goto Cleanup;
    }

    // Look for any other HTA windows that have the same application
    // name as this one. The application name is stored in the window
    // properties table for the HTA window.
    //
    hwndNext = ::FindWindow(SZ_APPLICATION_WNDCLASS, NULL);

    while (hwndNext)
    {
        memset(szClassName, 0, sizeof(szClassName));
        
        if (!::GetClassName(hwndNext, szClassName, ARRAY_SIZE(szClassName)))
        {
            goto Cleanup;
        }

        if (!StrCmp(szClassName, SZ_APPLICATION_WNDCLASS))
        {
            if (::GetProp(hwndNext, (LPCTSTR)GlobalFindAtom((LPTSTR)_cstrAppName)))
            {
                HWND hwndChild = ::GetLastActivePopup(hwndNext);

                // If previous instance is minimized, restore it.
                if (::IsIconic(hwndNext))
                {
                    ::ShowWindow(hwndNext, SW_RESTORE);
                }

                // Bring the previous instance (or its last popup window) to the foreground.
                ::SetForegroundWindow(hwndChild);

                // Previous instance was running...
                fPriorInstance = TRUE;
                break;
            }
        }

        hwndNext = ::GetWindow(hwndNext, GW_HWNDNEXT);
    }

Cleanup:
    return fPriorInstance;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::HandleClose
//
//  Synopsis:   Handles closing the application.  Causes onBeforeUnload to be fired.
//
//----------------------------------------------------------------------------

void
CHTMLApp::HandleClose(HWND hwnd)
{
#if DBG == 1 
if ( IsTagEnabled(tagHTAWndAssert))
{
    Assert(IsWindow(hwnd) && (_hwnd == hwnd));
}   
#endif

    CVariant varOut;

    _Client.SendCommand(NULL, OLECMDID_ONUNLOAD, OLECMDEXECOPT_PROMPTUSER, NULL, &varOut);
    if ((V_VT(&varOut) == VT_BOOL) && (V_BOOL(&varOut)) != VARIANT_TRUE)
        return;

    DestroyWindow(hwnd);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLApp::WndProc
//
//  Synopsis:   WndProc for the frame.
//
//----------------------------------------------------------------------------

LRESULT CHTMLApp::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
    case WM_CLOSE:
        TraceTag((tagHTAWndMsg, "WM_CLOSE"));
        theApp.HandleClose(hwnd);
        break;
        
    case WM_SYSCOMMAND:
        TraceTag((tagHTAWndMsg, "WM_SYSCOMMAND"));

        if (wParam == SC_CLOSE)
            theApp.HandleClose(hwnd);
        else
            return DefWindowProc(hwnd, msg, wParam, lParam);
        break;
        
    case WM_DESTROY:
        TraceTag((tagHTAWndMsg, "WM_DESTROY"));
        PostQuitMessage(0);
        break;

    case WM_SIZE:
        TraceTag((tagHTAWndMsg, "WM_SIZE"));
        theApp.Resize();
        break;

    case WM_ACTIVATE:
        {
            // Activate or Deactivate the document.  This is needed 
            // in order to make focus adornments work correctly on 
            // Win9x and NT4
            //
            TraceTag((tagHTAWndMsg, "WM_ACTIVATE"));
            
            CDoc*   pDoc; 
            HRESULT hr;
            IOleInPlaceActiveObject* pActiveObj;
            
            if (theApp._Client._pUnk)
            {
                hr = THR(theApp._Client._pUnk->QueryInterface(CLSID_HTMLDocument, (void**)&pDoc));
                if (SUCCEEDED(hr))
                {
                    hr = pDoc->QueryInterface(IID_IOleInPlaceActiveObject, (void**)&pActiveObj);
                    if (SUCCEEDED(hr))
                    {
                        pActiveObj->OnFrameWindowActivate((WA_INACTIVE == LOWORD(wParam)) ? FALSE : TRUE);
                        ReleaseInterface(pActiveObj);
                    }
                }
            }
        }
        break;
        
    case WM_QUERYNEWPALETTE:
    case WM_PALETTECHANGED:
        if (msg == WM_QUERYNEWPALETTE)
        {
            TraceTag((tagHTAWndMsg, "WM_QUERYNEWPALETTE"));
        }
        else
        {
            TraceTag((tagHTAWndMsg, "WM_PALETTECHANGED"));
        }
                                
        return theApp._Client.DelegateMessage(msg, wParam, lParam);
        break;

    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\intl\intlcore\multilang.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1999 - 2000.
//
//  File:       multilang.cxx
//
//  Contents:   MLang wrapper.
//
//----------------------------------------------------------------------------

#ifndef X_INTLCORE_HXX_
#define X_INTLCORE_HXX_
#include "intlcore.hxx"
#endif

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifdef UNIX
// Unix MIDL doesn't output this.
extern "C" const CLSID CLSID_CMultiLanguage;
#endif

const wchar_t * const g_pszArialUnicodeMS = L"Arial Unicode MS";

//+----------------------------------------------------------------------------
//
//  g_asidCPBit
//
//  Code page bit to windows codepage mapping.
//
//-----------------------------------------------------------------------------

const UINT g_aCPCPBit[32] =
{
    /* FS_LATIN1        0x00000001 */ CP_1252,
    /* FS_LATIN2        0x00000002 */ CP_1250,
    /* FS_CYRILLIC      0x00000004 */ CP_1251,
    /* FS_GREEK         0x00000008 */ CP_1253,
    /* FS_TURKISH       0x00000010 */ CP_1254,
    /* FS_HEBREW        0x00000020 */ CP_1255,
    /* FS_ARABIC        0x00000040 */ CP_1256,
    /* FS_BALTIC        0x00000080 */ CP_1257,
    /* FS_VIETNAMESE    0x00000100 */ CP_1258,
    /* FS_UNKNOWN       0x00000200 */ 0,
    /* FS_UNKNOWN       0x00000400 */ 0,
    /* FS_UNKNOWN       0x00000800 */ 0,
    /* FS_UNKNOWN       0x00001000 */ 0,
    /* FS_UNKNOWN       0x00002000 */ 0,
    /* FS_UNKNOWN       0x00004000 */ 0,
    /* FS_UNKNOWN       0x00008000 */ 0,
    /* FS_THAI          0x00010000 */ CP_THAI,
    /* FS_JISJAPAN      0x00020000 */ CP_JPN_SJ,
    /* FS_CHINESESIMP   0x00040000 */ CP_CHN_GB,
    /* FS_WANSUNG       0x00080000 */ CP_KOR_5601,
    /* FS_CHINESETRAD   0x00100000 */ CP_TWN,
    /* FS_JOHAB         0x00200000 */ CP_1361,
    /* FS_UNKNOWN       0x00400000 */ 0,
    /* FS_UNKNOWN       0x00800000 */ 0,
    /* FS_UNKNOWN       0x01000000 */ 0,
    /* FS_UNKNOWN       0x02000000 */ 0,
    /* FS_UNKNOWN       0x04000000 */ 0,
    /* FS_UNKNOWN       0x08000000 */ 0,
    /* FS_UNKNOWN       0x10000000 */ 0,
    /* FS_UNKNOWN       0x20000000 */ 0,
    /* FS_UNKNOWN       0x40000000 */ 0,
    /* FS_SYMBOL        0x80000000 */ CP_SYMBOL,
};

#if DBG == 1
//+----------------------------------------------------------------------------
//
//  Debugging only functions.
//  Accessed only by mshtmpad to support lifetime control API.
//
//-----------------------------------------------------------------------------

void MLangUnload()
{
    mlang().Unload();
}

BOOL IsMLangLoaded()
{
    return mlang().IsLoaded();
}
#endif

//+----------------------------------------------------------------------------
// MLang wrapper object
//-----------------------------------------------------------------------------

CMLang g_MLang;

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::CMLang
//
//  Synopsis:   Initializes MLang wrapper object.
//
//-----------------------------------------------------------------------------

CMLang::CMLang()
{
    _pMultiLanguage  = NULL;
    _pMultiLanguage2 = NULL;
    _pMLangFontLink  = NULL;
    _pMLangFontLink2 = NULL;

    _dwInstalledLangPacks = 0;

    _cs.Init();
}

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::CMLang
//
//  Synopsis:   Deinitializes MLang wrapper object.
//
//-----------------------------------------------------------------------------

CMLang::~CMLang()
{
    // TODO (grzegorz): Enable these asserts when ref counting in TLS is fixed.
//    Assert(_pMultiLanguage == NULL);
//    Assert(_pMultiLanguage2 == NULL);
//    Assert(_pMLangFontLink == NULL);
//    Assert(_pMLangFontLink2 == NULL);
}

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::EnsureObjects
//
//  Synopsis:   Make sure MLang is loaded.
//
//-----------------------------------------------------------------------------

#if DBG == 1
void CMLang::EnsureObjects()
{
    if (!_pMultiLanguage) CreateObjects();
}
#endif

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::CreateObjects
//
//  Synopsis:   Create MLang object and QI required interfaces.
//
//-----------------------------------------------------------------------------

void CMLang::CreateObjects()
{
    CGuard<CCriticalSection> guard(_cs);

    // Need to check again after locking objects.
    if (!_pMultiLanguage)
    {
        HRESULT hr;

        hr = CoInitialize(NULL);
        if (SUCCEEDED(hr))
        {
            hr = THR(CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, 
                IID_IMultiLanguage, (void**)&_pMultiLanguage));

            if (SUCCEEDED(hr))
            {
                IGNORE_HR(_pMultiLanguage->QueryInterface(IID_IMultiLanguage2, (void **)&_pMultiLanguage2));

                IGNORE_HR(_pMultiLanguage->QueryInterface(IID_IMLangFontLink,  (void **)&_pMLangFontLink));

                IGNORE_HR(_pMultiLanguage->QueryInterface(IID_IMLangFontLink2, (void **)&_pMLangFontLink2));
            }
            CoUninitialize();
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::DestroyObjects
//
//  Synopsis:   Release all MLang interfaces
//
//-----------------------------------------------------------------------------

void CMLang::DestroyObjects()
{
    CGuard<CCriticalSection> guard(_cs);

    if (_pMultiLanguage)
    {
        _pMultiLanguage->Release();
        _pMultiLanguage = NULL;
    }
    if (_pMultiLanguage2)
    {
        _pMultiLanguage2->Release();
        _pMultiLanguage2 = NULL;
    }
    if (_pMLangFontLink)
    {
        _pMLangFontLink->Release();
        _pMLangFontLink = NULL;
    }
    if (_pMLangFontLink2)
    {
        _pMLangFontLink2->Release();
        _pMLangFontLink2 = NULL;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::FetchInstalledLangPacks
//
//  Synopsis:   Retrieve information about installed lang packs.
//
//-----------------------------------------------------------------------------

void CMLang::FetchInstalledLangPacks()
{
    DWORD dwInstalledLangPacks = 0;

    EnsureObjects();

    if (_pMultiLanguage2)
    {
        HRESULT hr;
        MIMECPINFO mimeCpInfo;
        UINT cp;

        unsigned long i = 0;
        while (i < ARRAY_SIZE(g_aCPCPBit))
        {
            cp = g_aCPCPBit[i];
            if (cp != 0)
            {
                hr = THR(_pMultiLanguage2->GetCodePageInfo(cp, MLGetUILanguage(), &mimeCpInfo));

                if (SUCCEEDED(hr) && (MIMECONTF_VALID & mimeCpInfo.dwFlags))
                {
                    dwInstalledLangPacks |= (1 << i);
                }
            }
            ++i;
        }
    }

    {
        CGuard<CCriticalSection> guard(_cs);
        if (0 == _dwInstalledLangPacks)
            _dwInstalledLangPacks = dwInstalledLangPacks;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::GetTextCodePages
//
//  Synopsis:   Determine the codepage coverage of requested text.
//
//  Arguments:  [dwPriorityCodePages] - set of code pages caller is interested in
//              [pch]  - text buffer to analyze
//              [pcch] - [in]  size of the text buffer
//                       [out] number of characters analyzed
//
//  Returns:    Codepage coverage as a bit field (FS_*, see wingdi.h).
//              dwPriorityCodePages in case of error.
//
//-----------------------------------------------------------------------------

DWORD CMLang::GetTextCodePages(
    DWORD dwPriorityCodePages,  // [in]
    const wchar_t * pch,        // [in]
    long * pcch)                // [in, out]
{
    Assert(pch && *pch);
    Assert(pcch && (*pcch > 0));

    EnsureObjects();

    if (!_pMLangFontLink)
        return dwPriorityCodePages;

    HRESULT hr;
    DWORD dwRet;
    DWORD dwCodePages = DWORD(-1);
    long cchToCheck = *pcch;

    while (cchToCheck)
    {
        hr = _pMLangFontLink->GetCharCodePages(*pch, &dwRet);
        if (FAILED(hr))
            return (dwCodePages & dwPriorityCodePages);

        // GetCharCodePages for some characters returns 0. In this case for compatibility
        // reasons we need to have the same behavior as MLang's GetStrCodePages, so we
        // set codepages bits to 1.
        if (!dwRet)
            dwRet = (DWORD)~0;

        dwRet &= dwPriorityCodePages;
        if (dwCodePages == DWORD(-1))
        {
            dwCodePages = dwRet;
        }
        else if (dwCodePages != dwRet)
        {
            break;
        }
        --cchToCheck;
        ++pch;
    }

    *pcch -= cchToCheck;

    return (dwCodePages & dwPriorityCodePages);
}

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::GetFontScripts
//
//  Synopsis:   Determine the script coverage of requested font family.
//
//  Arguments:  [pszFontFamilyName] - font family name
//
//  Returns:    Scripts coverage as a bit field (see unisid.hxx).
//              sidsNotSet in case of error.
//
//-----------------------------------------------------------------------------

SCRIPT_IDS CMLang::GetFontScripts(
    const wchar_t * pszFontFamilyName)  // [in]
{
    SCRIPT_IDS sids = sidsNotSet;

    EnsureObjects();

    //
    // FUTURE (grzegorz) At this point we should use IMLangFontLink3::GetFontScritps()
    // Since this interface is not implemented yet we use IMLangFontLink3::GetScriptFontInfo()
    // to get sids supported by the font.
    //

    if (!_pMLangFontLink2)
        return sids;

    HRESULT hr;
    SCRIPT_ID sid;
    UINT uFont;
    UINT csfi = 32;     // Initial buffer size
    SCRIPTFONTINFO * lpPreFail;
    SCRIPTFONTINFO * psfi = (SCRIPTFONTINFO *)HeapAlloc(GetProcessHeap(), 0, sizeof(SCRIPTFONTINFO) * csfi);
    if (psfi == NULL)
        goto Cleanup;

    //
    // We can skip sidDefault and sidMerge (they are artificial sids)
    // To improve perf we can start with sidAsciiLatin and then enumerate 
    // rest of sids.
    // NOTE: sidLatin implies sidAsciiLatin, so we can skip it.
    //

    sid = sidAsciiLatin;
    while (sid != sidLim)
    {
        BOOL fFixedPitch = FALSE; // First check variable pitch fonts
        BOOL fAtFont = (pszFontFamilyName[0] == L'@');

        do
        {
            UINT cFonts = 0;
            hr = THR(_pMLangFontLink2->GetScriptFontInfo(sid, fFixedPitch ? SCRIPTCONTF_FIXED_FONT : 0, &cFonts, NULL));

            if (SUCCEEDED(hr) && cFonts)
            {
                if (cFonts > csfi)
                {
                    csfi = ((cFonts / csfi) + 1) * csfi;
                    lpPreFail =  psfi;
#pragma prefast(suppress:308, "noise")
                    psfi = (SCRIPTFONTINFO *)HeapReAlloc(GetProcessHeap(), 0, (void *)psfi, sizeof(SCRIPTFONTINFO) * csfi);
                    if (psfi == NULL)
                    {
                        psfi =  lpPreFail;
                        goto Cleanup;
                    }
                }
                hr = THR(_pMLangFontLink2->GetScriptFontInfo(sid, fFixedPitch ? SCRIPTCONTF_FIXED_FONT : 0, &cFonts, psfi));

                if (SUCCEEDED(hr))
                {
                    for (uFont = 0; uFont < cFonts; uFont++)
                    {
                        if (0 == _wcsicmp(pszFontFamilyName, psfi[uFont].wszFont))
                        {
                            sids = psfi[uFont].scripts;
                            break;
                        }
                        else if (fAtFont)
                        {
                            if (0 == _wcsicmp(pszFontFamilyName + 1, psfi[uFont].wszFont))
                            {
                                sids = psfi[uFont].scripts;
                                break;
                            }
                        }
                    }
                }
            }

            fFixedPitch = !fFixedPitch;
        } while (fFixedPitch && sids == sidsNotSet);

        if (sids != sidsNotSet)
            break;

        if (sid == sidAsciiLatin)
            sid = sidAsciiSym;
        else if (sid == sidAsciiSym)
            sid = sidGreek;
        else
            ++sid;
    }
Cleanup:
    if (psfi)
        HeapFree(GetProcessHeap(), 0, (void *)psfi);

    return sids;
}

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::ValidateCodePage
//
//  Synopsis:   Validate codepage using MLang, optionally do IOD.
//
//  Arguments:  [cpSystem]    - system default codepage
//              [cp]          - requested code page
//              [hwnd]        - window handle for UI feedback
//              [fUserSelect] - selected by the user?
//              [fSilent]     - silent mode?
//
//  Returns:    S_OK if codepage is valid.
//
//-----------------------------------------------------------------------------

HRESULT CMLang::ValidateCodePage(
    UINT cpSystem,
    UINT cp, 
    HWND hwnd, 
    BOOL fUserSelect, 
    BOOL fSilent)
{
    //
    // When _pMultiLanguage2 is NULL it's not a success,
    // but we don't want to fail.
    //
    HRESULT hr = S_OK;

    //
    // CP_1252 is always valid codepage.
    // Latin 1 (CP_ISO_8859_1) is always valid on Wester European systems.
    // Unicode and utf-8 are always valid.
    //
    if (   cp == CP_1252 
        || (cp == CP_ISO_8859_1 && cpSystem == CP_1252)
        || cp == CP_UCS_2
        || cp == CP_UTF_8)
    {
        return hr;
    }

    EnsureObjects();

    if (_pMultiLanguage2)
    {
        DWORD dwfIODControl = 0;
        dwfIODControl |= fSilent ? CPIOD_PEEK : 0;
        dwfIODControl |= fUserSelect ? CPIOD_FORCE_PROMPT : 0;

        hr = THR(_pMultiLanguage2->ValidateCodePageEx(cp, hwnd, dwfIODControl));
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::IsConvertible
//
//  Synopsis:   Decides if conversion is possible.
//
//  Arguments:  [cpSrcEncoding] - source encoding
//              [cpDstEncoding] - destination encoding
//
//  Returns:    S_OK if conversion is possible.
//
//-----------------------------------------------------------------------------

HRESULT CMLang::IsConvertible(
    UINT cpSrcEncoding, 
    UINT cpDstEncoding)
{
    // Auto select is always convertible to Unicode
    if (cpSrcEncoding == CP_AUTO && cpDstEncoding == CP_UCS_2)
        return S_OK;

    EnsureObjects();
    return _pMultiLanguage ? _pMultiLanguage->IsConvertible(cpSrcEncoding, cpDstEncoding) : E_NOINTERFACE;
}

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::ScriptAppropriateFaceName
//
//  Synopsis:   Queries MLANG for fonts that supports a particular script.
//
//  Arguments:  [sid]          - script id
//              [pchPropName]  - pointer to array containing proportional font 
//                               name appropriate for the script.
//                               assuming size = LF_FACESIZE.
//              [pchFixedName] - pointer to array containing fixed pitch font 
//                               name appropriate for the script. 
//                               assuming size = LF_FACESIZE.
//
//  Returns:    S_OK if successful.
//
//-----------------------------------------------------------------------------

HRESULT CMLang::ScriptAppropriateFaceName(
    SCRIPT_ID sid,          // [in]
    wchar_t * pchPropName,  // [out]
    wchar_t * pchFixedName) // [out]
{
    Assert(pchPropName && pchFixedName);
    pchFixedName[0] = pchPropName[0] = 0;

    HRESULT hr = E_FAIL;

    EnsureObjects();

    //
    // First enum scripts using the IEnumScript interface.
    // Keep this method for compatibility.
    //
    if (_pMultiLanguage2)
    {
        UINT cScripts;

        hr = THR(_pMultiLanguage2->GetNumberOfScripts(&cScripts));

        if (SUCCEEDED(hr))
        {
            ULONG c;
            SCRIPTINFO si;
            IEnumScript * pEnumScript;

            hr = THR(_pMultiLanguage2->EnumScripts(SCRIPTCONTF_SCRIPT_USER, 0, &pEnumScript));

            if (SUCCEEDED(hr))
            {
                while (cScripts--)
                {
                    hr = THR(pEnumScript->Next(1, &si, &c));

                    if (FAILED(hr) || !c)
                    {
                        break;
                    }

                    if (si.ScriptId == sid)
                    {
                        if (si.wszProportionalFont[0])
                        {
                            // Make sure we don't overflow static buffer
                            Assert(wcslen(si.wszProportionalFont) < LF_FACESIZE);
                            si.wszProportionalFont[LF_FACESIZE - 1] = 0;

                            wcscpy(pchPropName, si.wszProportionalFont);
                        }
                        if (si.wszFixedWidthFont[0])
                        {
                            // Make sure we don't overflow static buffer
                            Assert(wcslen(si.wszFixedWidthFont) < LF_FACESIZE);
                            si.wszFixedWidthFont[LF_FACESIZE - 1] = 0;

                            wcscpy(pchFixedName, si.wszFixedWidthFont);
                        }
                        break;
                    }
                }
                pEnumScript->Release();
            }
        }
        hr = S_OK;  // Ignore any errors and allow to use more accurate method.
    }

    //
    // If script enumeration failed to find fonts for the sid, use another more 
    // accurate method using GetScriptFontInfo.
    //
    // If script enumeration was succesful and the sid is sidAsciiLatin, 
    // we will trust MLang and we are done. 
    // If sid != sidAsciiLatin don't trust MLang and check results usign 
    // GetScriptFontInfo, which returs fonts array for the sid. Then check
    // if script enumeration result much. If yes, then return proposed font.
    // If not return first available font for the sid.
    //
    if (   (   sid != sidAsciiLatin 
            || pchPropName[0]
            || pchFixedName[0]
           )
        && _pMLangFontLink2)
    {
        //
        // We are requesting any available font for specified sid.
        // There are 4 possible situations:
        //
        // 1) There is exactly one font available for specified sid 
        //    and pitch. We will pick it up.
        //
        // 2) There are more then one fonts available for specified sid 
        //    and pitch. We will pick up font proposed by script enumeration
        //    if exists or the first one returned by MLang.
        //
        // 3) There is no match for specified sid and pitch. In this case
        //    we ignore pich and try to find a match using only sid.
        //
        // 4) There is no match for specified sid and pitch or for sid only. 
        //    In this case cannot do much - use system font.
        //

        SCRIPTFONTINFO * psfiFixed = NULL;
        SCRIPTFONTINFO * psfiProp  = NULL;
        UINT cFixedFonts = 0;
        UINT cPropFonts = 0;
        UINT iFont;
        bool fEnumFailed;

        // Get first available proportional font
        hr = THR(_pMLangFontLink2->GetScriptFontInfo(sid, SCRIPTCONTF_PROPORTIONAL_FONT, &cPropFonts, NULL));
        if (SUCCEEDED(hr) && cPropFonts != 0)
        {
            psfiProp = new SCRIPTFONTINFO [cPropFonts];
            hr = THR(_pMLangFontLink2->GetScriptFontInfo(sid, SCRIPTCONTF_PROPORTIONAL_FONT, &cPropFonts, psfiProp));
        }

        // Get first available fixed font
        hr = THR(_pMLangFontLink2->GetScriptFontInfo(sid, SCRIPTCONTF_FIXED_FONT, &cFixedFonts, NULL));
        if (SUCCEEDED(hr) && cFixedFonts != 0)
        {
            psfiFixed = new SCRIPTFONTINFO [cFixedFonts];
            hr = THR(_pMLangFontLink2->GetScriptFontInfo(sid, SCRIPTCONTF_FIXED_FONT, &cFixedFonts, psfiFixed));
        }

        //
        // Check if proposed by script enumeration font name covers the sid.
        //
        fEnumFailed = true;
        if (pchPropName[0] && psfiProp)
        {
            const wchar_t * pchAltName = AlternateFontName(pchPropName);
            for (iFont = 0; iFont < cPropFonts; iFont++)
            {
                if (0 == _wcsicmp(pchPropName, psfiProp[iFont].wszFont))
                {
                    fEnumFailed = false;
                    break;
                }
                if (pchAltName)
                {
                    if (0 == _wcsicmp(pchAltName, psfiProp[iFont].wszFont))
                    {
                        // Make sure we don't overflow static buffer
                        Assert(wcslen(pchAltName) < LF_FACESIZE);
                        wcsncpy(pchPropName, pchAltName, LF_FACESIZE);
                        pchPropName[LF_FACESIZE - 1] = 0;

                        fEnumFailed = false;
                        break;
                    }
                }
            }
        }

        // If script enumeration failed use first availabe font.
        // HACKHACK (grzegorz): Because "Arial Unicode MS" has weird text metrics 
        // prefer to use another font, if available.
        if (fEnumFailed)
        {
            SCRIPTFONTINFO * psfi = cPropFonts ? psfiProp : (cFixedFonts ? psfiFixed : NULL);
            iFont = 0;
            if (psfi)
            {
                UINT cFonts = cPropFonts ? cPropFonts : (cFixedFonts ? cFixedFonts : 0);
                if (cFonts > 1 && 0 == _wcsicmp(g_pszArialUnicodeMS, psfi[iFont].wszFont))
                    ++iFont;

                // Make sure we don't overflow static buffer
                Assert(wcslen(psfi[iFont].wszFont) < LF_FACESIZE);
                psfi[iFont].wszFont[LF_FACESIZE - 1] = 0;
                wcscpy(pchPropName, psfi[iFont].wszFont);
            }
            else
            {
                pchPropName[0] = 0;
            }
        }

        //
        // Check if proposed by script enumeration font name covers the sid.
        //
        fEnumFailed = true;
        if (pchFixedName[0] && psfiFixed)
        {
            const TCHAR * pchAltName = AlternateFontName(pchFixedName);
            for (iFont = 0; iFont < cFixedFonts; iFont++)
            {
                if (0 == _wcsicmp(pchFixedName, psfiFixed[iFont].wszFont))
                {
                    fEnumFailed = false;
                    break;
                }
                if (pchAltName)
                {
                    if (0 == _wcsicmp(pchAltName, psfiFixed[iFont].wszFont))
                    {
                        // Make sure we don't overflow static buffer
                        Assert(wcslen(pchAltName) < LF_FACESIZE);
                        wcsncpy(pchFixedName, pchAltName, LF_FACESIZE);
                        pchFixedName[LF_FACESIZE - 1] = 0;

                        fEnumFailed = false;
                        break;
                    }
                }
            }
        }

        // If script enumeration failed use first availabe font.
        // HACKHACK (grzegorz): Because "Arial Unicode MS" has weird text metrics 
        // prefer to use another font, if available.
        if (fEnumFailed)
        {
            SCRIPTFONTINFO * psfi = cFixedFonts ? psfiFixed : (cPropFonts ? psfiProp : NULL);
            iFont = 0;
            if (psfi)
            {
                UINT cFonts = cFixedFonts ? cFixedFonts : (cPropFonts ? cPropFonts : 0);
                if (cFonts > 1 && 0 == _wcsicmp(g_pszArialUnicodeMS, psfi[iFont].wszFont))
                    ++iFont;

                // Make sure we don't overflow static buffer
                Assert(wcslen(psfi[iFont].wszFont) < LF_FACESIZE);
                psfi[iFont].wszFont[LF_FACESIZE - 1] = 0;
                wcscpy(pchFixedName, psfi[iFont].wszFont);
            }
            else
            {
                pchFixedName[0] = 0;
            }
        }

        delete [] psfiProp;
        delete [] psfiFixed;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CMLang::LCIDFromString
//
//  Synopsis:   Map a locale string (rfc 1766) to locale id.
//
//  Arguments:  [pszLcid] - locale string (rfc 1766)
//
//  Returns:    0 in case of failure.
//
//-----------------------------------------------------------------------------

LCID CMLang::LCIDFromString(
    wchar_t * pszLcid)
{
    LCID lcid = 0;

    EnsureObjects();

    if (pszLcid && _pMultiLanguage)
    {
        THR(_pMultiLanguage->GetLcidFromRfc1766(&lcid, pszLcid));
    }

    return lcid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\intl\intlcore\fontcoverage.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       fontcoverage.cxx
//
//  Contents:   Font face script coverage helpers.
//
//----------------------------------------------------------------------------

#ifndef X_INTLCORE_HXX_
#define X_INTLCORE_HXX_
#include "intlcore.hxx"
#endif

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//+----------------------------------------------------------------------------
//
//  Function:   EFF_GetFontSignature (EnumFontFamiliesEx callback)
//
//  Synopsis:   Fill font signature and set TrueType flag.
//
//  Returns:    FALSE to immediately stop enumeration.
//
//-----------------------------------------------------------------------------

struct FSBAG {
    FONTSIGNATURE * pfs;
    BOOL * pfTrueType;
};

#pragma warning(disable : 4100)
static int CALLBACK EFF_GetFontSignature(
    ENUMLOGFONTEX * lpelfe,   // [in]
    NEWTEXTMETRICEX * lpntme, // [in]
    DWORD FontType,           // [in]
    LPARAM lParam)            // [in]
{
    FSBAG * pfsbag = (FSBAG *)lParam;

    *pfsbag->pfTrueType = (0 != (TRUETYPE_FONTTYPE & FontType));

    if (*pfsbag->pfTrueType)
    {
        memcpy(pfsbag->pfs, &lpntme->ntmFontSig, sizeof(FONTSIGNATURE));
    }

    return FALSE;
}
#pragma warning(default : 4100)

//+----------------------------------------------------------------------------
//
//  Function:   GetFontSignature
//
//  Synopsis:   Retrieve font signature from font name.
//
//  Returns:    TRUE font has been found. Doen't mean that font signature 
//              has been successfully retrieved. FS is vaild only in case 
//              of True Type font.
//
//-----------------------------------------------------------------------------

BOOL GetFontSignature(
    const wchar_t * pszFontFamilyName, // [in]
    BYTE bCharSet,                     // [in]
    FONTSIGNATURE * pfs,               // [out]
    BOOL * pfTrueType)                 // [out]
{
    HDC hdcScreen = GetDC(NULL);

    LOGFONT lf;
    lf.lfCharSet = bCharSet;
    lf.lfPitchAndFamily = 0;
    StrCpyNW(lf.lfFaceName, pszFontFamilyName, LF_FACESIZE);

    FSBAG fsbag;
    fsbag.pfs = pfs;
    fsbag.pfTrueType = pfTrueType;

    BOOL fRet = (0 == EnumFontFamiliesEx(hdcScreen, &lf, FONTENUMPROC(EFF_GetFontSignature), 
        LPARAM(&fsbag), 0));

    if (!fRet)
    {
        // Ignore charset
        lf.lfCharSet = DEFAULT_CHARSET;
        fRet = (0 == EnumFontFamiliesEx(hdcScreen, &lf, FONTENUMPROC(EFF_GetFontSignature), 
            LPARAM(&fsbag), 0));
    }

    ReleaseDC(NULL, hdcScreen);

    return fRet;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetFontScriptsFromFontSignature
//
//  Synopsis:   Compute the SCRIPT_IDS information based on the Unicode
//              subrange coverage of the TrueType font.
//
//  Returns:    Scripts coverage as a bit field (see unisid.hxx).
//
//-----------------------------------------------------------------------------

static SCRIPT_ID s_asidUnicodeSubRangeScriptMapping[] =
{
    sidAsciiLatin, sidLatin,      sidLatin,      sidLatin,        // 128-131
    sidLatin,      sidLatin,      0,             sidGreek,        // 132-135
    sidGreek,      sidCyrillic,   sidArmenian,   sidHebrew,       // 136-139
    sidHebrew,     sidArabic,     sidArabic,     sidDevanagari,   // 140-143
    sidBengali,    sidGurmukhi,   sidGujarati,   sidOriya,        // 144-147
    sidTamil,      sidTelugu,     sidKannada,    sidMalayalam,    // 148-151
    sidThai,       sidLao,        sidGeorgian,   sidGeorgian,     // 152-155
    sidHangul,     sidLatin,      sidGreek,      0,               // 156-159
    0,             0,             0,             0,               // 160-163
    0,             0,             0,             0,               // 164-167
    0,             0,             0,             0,               // 168-171
    0,             0,             0,             0,               // 172-175
    sidHan,        sidKana,       sidKana,       sidBopomofo,     // 176-179
    sidHangul,     0,             0,             0,               // 180-183
    sidHangul,     sidHangul,     sidHangul,     sidHan,          // 184-187
    0,             sidHan,        0,             0,               // 188-191
    0,             0,             0,             0,               // 192-195
    0,             0,             sidHangul,     0,               // 196-199
};

SCRIPT_IDS GetFontScriptsFromFontSignature(
    const FONTSIGNATURE * pfs)  // [in]
{
    SCRIPT_IDS sids = sidsNotSet;
    
    SCRIPT_ID sid;
    unsigned long i;
    DWORD dwUsbBits;
    bool fHangul = false;

    dwUsbBits = pfs->fsUsb[0];
    if (dwUsbBits)
    {
        for (i = 0; i < 32; i++)
        {
            if (dwUsbBits & 1)
            {
                sid = s_asidUnicodeSubRangeScriptMapping[i];
                if (sid)
                {
                    sids |= ScriptBit(sid);
                }
            }

            dwUsbBits >>= 1;
        }
    }

    dwUsbBits = pfs->fsUsb[1];
    if (dwUsbBits)
    {
        fHangul = (0 != (dwUsbBits & 0x01000000)); // USR#56 = 32 + 24

        for (i = 32; i < 64; i++)
        {
            if (dwUsbBits & 1)
            {
                sid = s_asidUnicodeSubRangeScriptMapping[i];
                if (sid)
                {
                    sids |= ScriptBit(sid);
                }
            }

            dwUsbBits >>= 1;
        }
    }

    dwUsbBits = pfs->fsUsb[2];
    if (dwUsbBits)
    {
        // Hack for half-width Kana; Half-width Kana characters fall in
        // U+FFxx Halfwidth and Fullwidth Forms (Unicode Subrange #68),
        // but the subrange contains a mixture of Hangul/Alphanumeric/Kana
        // characters.  To work around this, we claim the font supports
        // half-width kana if it claims to support Unicode Subrange #68,
        // but not #56 (Hangul)

        if (!fHangul && (dwUsbBits & 0x00000010)) // USR#68 = 64 + 4
        {
            sids |= ScriptBit(sidHalfWidthKana);
        }

        for (i = 64; i < ARRAY_SIZE(s_asidUnicodeSubRangeScriptMapping); i++)
        {
            if (dwUsbBits & 1)
            {
                sid = s_asidUnicodeSubRangeScriptMapping[i];
                if (sid)
                {
                    sids |= ScriptBit(sid);
                }
            }

            dwUsbBits >>= 1;
        }
    }

    //
    // Do some additional tweaking
    //

    if (sids)
    {
        if (sids & ScriptBit(sidAsciiLatin))
        {
            // HACKHACK (cthrash) This is a hack. We want to be able to
            // turn off, via CSS, this bit.  This will allow FE users
            // to pick a Latin font for their punctuation.  For now,
            // we just will basically never fontlink for sidAsciiSym
            // because virtually no font is lacking sidAsciiLatin
            // coverage.

            sids |= ScriptBit(sidAsciiSym);
        }

        sids |= ScriptBit(sidEUDC);
    }

    return sids;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetScriptsFromCharset
//
//  Synopsis:   Compute the SCRIPT_IDS information based on charset.
//              Used for non-TrueType fonts.
//
//  Returns:    Scripts coverage as a bit field (see unisid.hxx).
//
//-----------------------------------------------------------------------------

const SCRIPT_IDS s_asidsTable[] =
{
    #define SIDS_BASIC_LATIN 0
    ScriptBit(sidDefault) |
    ScriptBit(sidAsciiLatin) |
    ScriptBit(sidAsciiSym) |
    ScriptBit(sidLatin) |
    ScriptBit(sidCurrency) |
    ScriptBit(sidEUDC),

    #define SIDS_CYRILLIC 1
    ScriptBit(sidAsciiLatin) |
    ScriptBit(sidAsciiSym) |
    ScriptBit(sidCyrillic) |
    ScriptBit(sidEUDC),

    #define SIDS_GREEK 2
    ScriptBit(sidAsciiLatin) |
    ScriptBit(sidAsciiSym) |
    ScriptBit(sidGreek) |
    ScriptBit(sidEUDC),

    #define SIDS_HEBREW 3
    ScriptBit(sidAsciiLatin) |
    ScriptBit(sidAsciiSym) |
    ScriptBit(sidHebrew) |
    ScriptBit(sidEUDC),

    #define SIDS_ARABIC 4
    ScriptBit(sidAsciiLatin) |
    ScriptBit(sidAsciiSym) |
    ScriptBit(sidArabic) |
    ScriptBit(sidEUDC),

    #define SIDS_THAI 5
    ScriptBit(sidAsciiLatin) |
    ScriptBit(sidAsciiSym) |
    ScriptBit(sidThai) |
    ScriptBit(sidEUDC),

    #define SIDS_JAPANESE 6
    ScriptBit(sidAsciiLatin) |
    ScriptBit(sidAsciiSym) |
    ScriptBit(sidKana) |
    ScriptBit(sidHalfWidthKana) |
    ScriptBit(sidHan) |
    ScriptBit(sidEUDC),

    #define SIDS_CHINESE 7
    ScriptBit(sidAsciiLatin) |
    ScriptBit(sidAsciiSym) |
    ScriptBit(sidKana) |
    ScriptBit(sidBopomofo) |
    ScriptBit(sidHan) |
    ScriptBit(sidEUDC),

    #define SIDS_HANGUL 8
    ScriptBit(sidAsciiLatin) |
    ScriptBit(sidAsciiSym) |
    ScriptBit(sidHangul) |
    ScriptBit(sidKana) |
    ScriptBit(sidHan) |
    ScriptBit(sidEUDC),

    #define SIDS_ALL 9
    sidsAll
};

const BYTE s_asidsIndex[256] =
{
    SIDS_BASIC_LATIN,    //   0 ANSI_CHARSET
    SIDS_ALL,            //   1 DEFAULT_CHARSET
    SIDS_ALL,            //   2 SYMBOL_CHARSET
    SIDS_ALL,            //   3 
    SIDS_ALL,            //   4 
    SIDS_ALL,            //   5 
    SIDS_ALL,            //   6 
    SIDS_ALL,            //   7 
    SIDS_ALL,            //   8 
    SIDS_ALL,            //   9 
    SIDS_ALL,            //  10 
    SIDS_ALL,            //  11 
    SIDS_ALL,            //  12 
    SIDS_ALL,            //  13 
    SIDS_ALL,            //  14 
    SIDS_ALL,            //  15 
    SIDS_ALL,            //  16 
    SIDS_ALL,            //  17 
    SIDS_ALL,            //  18 
    SIDS_ALL,            //  19 
    SIDS_ALL,            //  20 
    SIDS_ALL,            //  21 
    SIDS_ALL,            //  22 
    SIDS_ALL,            //  23 
    SIDS_ALL,            //  24 
    SIDS_ALL,            //  25 
    SIDS_ALL,            //  26 
    SIDS_ALL,            //  27 
    SIDS_ALL,            //  28 
    SIDS_ALL,            //  29 
    SIDS_ALL,            //  30 
    SIDS_ALL,            //  31 
    SIDS_ALL,            //  32 
    SIDS_ALL,            //  33 
    SIDS_ALL,            //  34 
    SIDS_ALL,            //  35 
    SIDS_ALL,            //  36 
    SIDS_ALL,            //  37 
    SIDS_ALL,            //  38 
    SIDS_ALL,            //  39 
    SIDS_ALL,            //  40 
    SIDS_ALL,            //  41 
    SIDS_ALL,            //  42 
    SIDS_ALL,            //  43 
    SIDS_ALL,            //  44 
    SIDS_ALL,            //  45 
    SIDS_ALL,            //  46 
    SIDS_ALL,            //  47 
    SIDS_ALL,            //  48 
    SIDS_ALL,            //  49 
    SIDS_ALL,            //  50 
    SIDS_ALL,            //  51 
    SIDS_ALL,            //  52 
    SIDS_ALL,            //  53 
    SIDS_ALL,            //  54 
    SIDS_ALL,            //  55 
    SIDS_ALL,            //  56 
    SIDS_ALL,            //  57 
    SIDS_ALL,            //  58 
    SIDS_ALL,            //  59 
    SIDS_ALL,            //  60 
    SIDS_ALL,            //  61 
    SIDS_ALL,            //  62 
    SIDS_ALL,            //  63 
    SIDS_ALL,            //  64 
    SIDS_ALL,            //  65 
    SIDS_ALL,            //  66 
    SIDS_ALL,            //  67 
    SIDS_ALL,            //  68 
    SIDS_ALL,            //  69 
    SIDS_ALL,            //  70 
    SIDS_ALL,            //  71 
    SIDS_ALL,            //  72 
    SIDS_ALL,            //  73 
    SIDS_ALL,            //  74 
    SIDS_ALL,            //  75 
    SIDS_ALL,            //  76 
    SIDS_BASIC_LATIN,    //  77 MAC_CHARSET
    SIDS_ALL,            //  78 
    SIDS_ALL,            //  79 
    SIDS_ALL,            //  80 
    SIDS_ALL,            //  81 
    SIDS_ALL,            //  82 
    SIDS_ALL,            //  83 
    SIDS_ALL,            //  84 
    SIDS_ALL,            //  85 
    SIDS_ALL,            //  86 
    SIDS_ALL,            //  87 
    SIDS_ALL,            //  88 
    SIDS_ALL,            //  89 
    SIDS_ALL,            //  90 
    SIDS_ALL,            //  91 
    SIDS_ALL,            //  92 
    SIDS_ALL,            //  93 
    SIDS_ALL,            //  94 
    SIDS_ALL,            //  95 
    SIDS_ALL,            //  96 
    SIDS_ALL,            //  97 
    SIDS_ALL,            //  98 
    SIDS_ALL,            //  99 
    SIDS_ALL,            // 100 
    SIDS_ALL,            // 101 
    SIDS_ALL,            // 102 
    SIDS_ALL,            // 103 
    SIDS_ALL,            // 104 
    SIDS_ALL,            // 105 
    SIDS_ALL,            // 106 
    SIDS_ALL,            // 107 
    SIDS_ALL,            // 108 
    SIDS_ALL,            // 109 
    SIDS_ALL,            // 110 
    SIDS_ALL,            // 111 
    SIDS_ALL,            // 112 
    SIDS_ALL,            // 113 
    SIDS_ALL,            // 114 
    SIDS_ALL,            // 115 
    SIDS_ALL,            // 116 
    SIDS_ALL,            // 117 
    SIDS_ALL,            // 118 
    SIDS_ALL,            // 119 
    SIDS_ALL,            // 120 
    SIDS_ALL,            // 121 
    SIDS_ALL,            // 122 
    SIDS_ALL,            // 123 
    SIDS_ALL,            // 124 
    SIDS_ALL,            // 125 
    SIDS_ALL,            // 126 
    SIDS_ALL,            // 127 
    SIDS_JAPANESE,       // 128 SHIFTJIS_CHARSET
    SIDS_HANGUL,         // 129 HANGEUL_CHARSET
    SIDS_HANGUL,         // 130 JOHAB_CHARSET
    SIDS_ALL,            // 131 
    SIDS_ALL,            // 132 
    SIDS_ALL,            // 133 
    SIDS_CHINESE,        // 134 GB2312_CHARSET
    SIDS_ALL,            // 135 
    SIDS_CHINESE,        // 136 CHINESEBIG5_CHARSET
    SIDS_ALL,            // 137 
    SIDS_ALL,            // 138 
    SIDS_ALL,            // 139 
    SIDS_ALL,            // 140 
    SIDS_ALL,            // 141 
    SIDS_ALL,            // 142 
    SIDS_ALL,            // 143 
    SIDS_ALL,            // 144 
    SIDS_ALL,            // 145 
    SIDS_ALL,            // 146 
    SIDS_ALL,            // 147 
    SIDS_ALL,            // 148 
    SIDS_ALL,            // 149 
    SIDS_ALL,            // 150 
    SIDS_ALL,            // 151 
    SIDS_ALL,            // 152 
    SIDS_ALL,            // 153 
    SIDS_ALL,            // 154 
    SIDS_ALL,            // 155 
    SIDS_ALL,            // 156 
    SIDS_ALL,            // 157 
    SIDS_ALL,            // 158 
    SIDS_ALL,            // 159 
    SIDS_ALL,            // 160 
    SIDS_GREEK,          // 161 GREEK_CHARSET
    SIDS_BASIC_LATIN,    // 162 TURKISH_CHARSET
    SIDS_BASIC_LATIN,    // 163 VIETNAMESE_CHARSET
    SIDS_ALL,            // 164 
    SIDS_ALL,            // 165 
    SIDS_ALL,            // 166 
    SIDS_ALL,            // 167 
    SIDS_ALL,            // 168 
    SIDS_ALL,            // 169 
    SIDS_ALL,            // 170 
    SIDS_ALL,            // 171 
    SIDS_ALL,            // 172 
    SIDS_ALL,            // 173 
    SIDS_ALL,            // 174 
    SIDS_ALL,            // 175 
    SIDS_ALL,            // 176 
    SIDS_HEBREW,         // 177 HEBREW_CHARSET
    SIDS_ARABIC,         // 178 ARABIC_CHARSET
    SIDS_ALL,            // 179 
    SIDS_ALL,            // 180 
    SIDS_ALL,            // 181 
    SIDS_ALL,            // 182 
    SIDS_ALL,            // 183 
    SIDS_ALL,            // 184 
    SIDS_ALL,            // 185 
    SIDS_BASIC_LATIN,    // 186 BALTIC_CHARSET
    SIDS_ALL,            // 187 
    SIDS_ALL,            // 188 
    SIDS_ALL,            // 189 
    SIDS_ALL,            // 190 
    SIDS_ALL,            // 191 
    SIDS_ALL,            // 192 
    SIDS_ALL,            // 193 
    SIDS_ALL,            // 194 
    SIDS_ALL,            // 195 
    SIDS_ALL,            // 196 
    SIDS_ALL,            // 197 
    SIDS_ALL,            // 198 
    SIDS_ALL,            // 199 
    SIDS_ALL,            // 200 
    SIDS_ALL,            // 201 
    SIDS_ALL,            // 202 
    SIDS_ALL,            // 203 
    SIDS_CYRILLIC,       // 204 RUSSIAN_CHARSET
    SIDS_ALL,            // 205 
    SIDS_ALL,            // 206 
    SIDS_ALL,            // 207 
    SIDS_ALL,            // 208 
    SIDS_ALL,            // 209 
    SIDS_ALL,            // 210 
    SIDS_ALL,            // 211 
    SIDS_ALL,            // 212 
    SIDS_ALL,            // 213 
    SIDS_ALL,            // 214 
    SIDS_ALL,            // 215 
    SIDS_ALL,            // 216 
    SIDS_ALL,            // 217 
    SIDS_ALL,            // 218 
    SIDS_ALL,            // 219 
    SIDS_ALL,            // 220 
    SIDS_ALL,            // 221 
    SIDS_THAI,           // 222 THAI_CHARSET
    SIDS_ALL,            // 223 
    SIDS_ALL,            // 224 
    SIDS_ALL,            // 225 
    SIDS_ALL,            // 226 
    SIDS_ALL,            // 227 
    SIDS_ALL,            // 228 
    SIDS_ALL,            // 229 
    SIDS_ALL,            // 230 
    SIDS_ALL,            // 231 
    SIDS_ALL,            // 232 
    SIDS_ALL,            // 233 
    SIDS_ALL,            // 234 
    SIDS_ALL,            // 235 
    SIDS_ALL,            // 236 
    SIDS_ALL,            // 237 
    SIDS_BASIC_LATIN,    // 238 EASTEUROPE_CHARSET
    SIDS_ALL,            // 239 
    SIDS_ALL,            // 240 
    SIDS_ALL,            // 241 
    SIDS_ALL,            // 242 
    SIDS_ALL,            // 243 
    SIDS_ALL,            // 244 
    SIDS_ALL,            // 245 
    SIDS_ALL,            // 246 
    SIDS_ALL,            // 247 
    SIDS_ALL,            // 248 
    SIDS_ALL,            // 249 
    SIDS_ALL,            // 250 
    SIDS_ALL,            // 251 
    SIDS_ALL,            // 252 
    SIDS_ALL,            // 253 
    SIDS_ALL,            // 254 
    SIDS_ALL             // 255 OEM_CHARSET
};

SCRIPT_IDS GetScriptsFromCharset(
    BYTE bCharSet)
{
    return s_asidsTable[s_asidsIndex[bCharSet]];
}

//+----------------------------------------------------------------------------
//
//  Function:   GetFontScriptCoverage
//
//  Synopsis:   Compute the SCRIPT_IDS information based on font family name
//              and charset.
//
//  Returns:    Scripts coverage as a bit field (see unisid.hxx).
//
//-----------------------------------------------------------------------------

SCRIPT_IDS GetFontScriptCoverage(
    const wchar_t * pszFontFamilyName,
    BYTE bCharset,
    UINT cp)
{
    SCRIPT_IDS sids = sidsAll;
    SCRIPT_IDS sidsAlt;
    FONTSIGNATURE fs;
    BOOL fTrueType;

    if (!GetFontSignature(pszFontFamilyName, bCharset, &fs, &fTrueType))
        return sids;

    if (fTrueType)
    {
        sids = GetFontScriptsFromFontSignature(&fs);

        //
        // ScriptIDsFromFontSignature() doesn't return complete sids coverage, especially
        // for new fonts.
        // Using IMLangFontLink* interfaces get sids coverage in a different way, which is
        // not a perfect way either.
        // Finally get a union of them.
        //
        // PERF (grzegorz): For Latin1 pages don't load MLang to verify script coverage,
        //                  when asking for ANSI font.
        //
        if (   (bCharset == ANSI_CHARSET)
            && IsLatin1Codepage(cp)
            && !(sids & 0x000000fffffffc00))
        {
            sidsAlt = sids | ScriptBit(sidUserDefined);
#if DBG == 1
            SCRIPT_IDS sidsDbg;
            sidsDbg = mlang().GetFontScripts(pszFontFamilyName);
            Assert((sidsDbg ==  0) || ((sidsDbg | sids) == sidsAlt));
#endif
        }
        else
        {
            sidsAlt = mlang().GetFontScripts(pszFontFamilyName);
        }

        //
        // HACKHACK (grzegorz) MLang may return sidLatin even if the font doesn't cover
        // Latin codepoints. But don't apply this hack in case of hacked fonts, where
        // font signature is 0 (sid == 0).
        //
        if (sids != 0)
            sidsAlt &= ~ScriptBit(sidLatin);

        sids |= sidsAlt;
    }
    else
    {
        sids = GetScriptsFromCharset(bCharset);
    }

    return sids;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetFontScriptCoverage
//
//  Synopsis:   Compute the SCRIPT_IDS information based on font family name
//              and charset.
//
//  Returns:    Scripts coverage as a bit field (see unisid.hxx).
//
//-----------------------------------------------------------------------------

SCRIPT_IDS GetFontScriptCoverage(
    const wchar_t * pszFontFamilyName,
    HDC hdc,
    HFONT hfont,
    BOOL fTrueType,
    BOOL fFSOnly)
{
    SCRIPT_IDS sids = sidsAll;
    SCRIPT_IDS sidsAlt;
    FONTSIGNATURE fs;
    HFONT hfontOld;
    BYTE bCharset;

    hfontOld = (HFONT)SelectObject(hdc, hfont);
    bCharset = (BYTE)GetTextCharsetInfo(hdc, &fs, 0);
    SelectObject(hdc, hfontOld);

    if (fTrueType)
    {
        sids = GetFontScriptsFromFontSignature(&fs);

        if (!fFSOnly)
        {
            //
            // ScriptIDsFromFontSignature() doesn't return complete sids coverage, especially
            // for new fonts.
            // Using IMLangFontLink* interfaces get sids coverage in a different way, which is
            // not a perfect way either.
            // Finally get a union of them.
            //
            sidsAlt = mlang().GetFontScripts(pszFontFamilyName);

            //
            // HACKHACK (grzegorz) MLang may return sidLatin even if the font doesn't cover
            // Latin codepoints. But don't apply this hack in case of hacked fonts, where
            // font signature is 0 (sid == 0).
            //
            if (sids != 0)
                sidsAlt &= ~ScriptBit(sidLatin);

            sids |= sidsAlt;
        }
    }
    else
    {
        sids = GetScriptsFromCharset(bCharset);
    }

    return sids;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\intl\intlcore\unipart.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998 - 2000.
//
//  File: unipart.cxx
//
//  This is a generated file.  Do not modify by hand.
//
//----------------------------------------------------------------------------

#ifndef X_INTLCORE_HXX_
#define X_INTLCORE_HXX_
#include "intlcore.hxx"
#endif

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//  Generating script: unipart_make_cxx.pl
//  Generated on Mon Dec  4 18:56:31 2000


const CHAR_CLASS acc_00[256] = // U+00xx
{
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NSF_,NSBB,NOF_,NSBS,NSBB,NOBN,NOBN, // 00 - 0F
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBS,NOBS,NOBS,NOF_, // 10 - 1F
    NSBL,NQFP,NQMP,NOEA,NPTA,NQEP,NONA,NAPA,NOPP,NCPP,NONP,NOEP,NCSA,NHYP,NPEP,NSLS, // 20 - 2F
    NDEA,NDEA,NDEA,NDEA,NDEA,NDEA,NDEA,NDEA,NDEA,NDEA,NOCP,NOCA,NONA,NONP,NONA,NQFA, // 30 - 3F
    NONA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA, // 40 - 4F
    NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NOPP,NPNA,NCPP,NONA,NONA, // 50 - 5F
    NONA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA, // 60 - 6F
    NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NLLA,NOPA,NONA,NCPA,NONA,NOBN, // 70 - 7F
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBS,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN, // 80 - 8F
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN, // 90 - 9F
    NBSP,ASNW,NQEW,NPEW,ASEW,NPEW,NONW,ASNW,ASNW,NONW,ASAN,NOQW,NONW,ASYW,NONW,ASNW, // A0 - AF
    AQEW,ASEW,ASAE,ASAE,ASNW,NOLW,ASNW,ASNW,ASNW,ASAE,ASAN,NCQW,ASNW,ASNW,ASNW,ASNW, // B0 - BF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // C0 - CF
    ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ASNW,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_, // D0 - DF
    ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,ALA_,ALA_,ALA_,NLA_,ALA_,ALA_,NLA_,NLA_, // E0 - EF
    ALA_,NLA_,ALA_,ALA_,NLA_,NLA_,NLA_,ASNW,ALA_,ALA_,ALA_,NLA_,ALA_,NLA_,ALA_,NLA_  // F0 - FF
};

const CHAR_CLASS acc_01[256] = // U+01xx
{
    ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 00 - 0F
    NLA_,ALA_,ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_,NLA_,NLA_,NLA_,NLA_, // 10 - 1F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_, // 20 - 2F
    NLA_,ALA_,ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_, // 30 - 3F
    ALA_,ALA_,ALA_,NLA_,ALA_,NLA_,NLA_,NLA_,ALA_,ALA_,ALA_,ALA_,ALA_,ALA_,NLA_,NLA_, // 40 - 4F
    NLA_,NLA_,ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 50 - 5F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_, // 60 - 6F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 70 - 7F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 80 - 8F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 90 - 9F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // A0 - AF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // B0 - BF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_,NLA_, // C0 - CF
    ALA_,ALA_,ALA_,NLA_,ALA_,NLA_,ALA_,NLA_,ALA_,NLA_,ALA_,NLA_,ALA_,NLA_,NLA_,NLA_, // D0 - DF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // E0 - EF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_  // F0 - FF
};

const CHAR_CLASS acc_02[256] = // U+02xx
{
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 00 - 0F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 10 - 1F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 20 - 2F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 30 - 3F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 40 - 4F
    ALA_,ALA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_, // 50 - 5F
    NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 60 - 6F
    NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 70 - 7F
    NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 80 - 8F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 90 - 9F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // A0 - AF
    NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NPNW,NPNW,NPLW,NPLW,NPLW,NPLW,NPLW, // B0 - BF
    NPLW,NPLW,NPNW,NPNW,NPNW,NPNW,ALQN,ALQ_,NPNW,ALQ_,ALQ_,ALQ_,NPNW,ALQ_,NPNW,NPNW, // C0 - CF
    APLW,NPLW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,ALQ_,ALQ_,ALQ_,ALQ_,NLQN,ALQ_,NPNW,NPNW, // D0 - DF
    NLQ_,NLQ_,NLQ_,NLQ_,NLQ_,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPLW,NPNW, // E0 - EF
    NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW,NPNW  // F0 - FF
};

const CHAR_CLASS acc_03[256] = // U+03xx
{
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 00 - 0F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 10 - 1F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 20 - 2F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 30 - 3F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 40 - 4F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 50 - 5F
    NQCC,NQCC,NQCC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC,NLQC, // 60 - 6F
    NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGQ_,NGQN,NGQN,NGQN,NGQN,NGQN, // 70 - 7F
    NGQN,NGQN,NGQN,NGQN,NGQN,NGQN,NGR_,NGQN,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 80 - 8F
    NGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_, // 90 - 9F
    AGR_,AGR_,NGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // A0 - AF
    NGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_, // B0 - BF
    AGR_,AGR_,NGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,AGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // C0 - CF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // D0 - DF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // E0 - EF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_  // F0 - FF
};

const CHAR_CLASS acc_04[256] = // U+04xx
{
    NCY_,ACY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 00 - 0F
    ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_, // 10 - 1F
    ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_, // 20 - 2F
    ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_, // 30 - 3F
    ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_,ACY_, // 40 - 4F
    NCY_,ACY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 50 - 5F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 60 - 6F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 70 - 7F
    NCY_,NCY_,NCYP,NCYC,NCYC,NCYC,NCYC,NCYC,NCYP,NCYP,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 80 - 8F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 90 - 9F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // A0 - AF
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // B0 - BF
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // C0 - CF
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // D0 - DF
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // E0 - EF
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_  // F0 - FF
};

const CHAR_CLASS acc_05[256] = // U+05xx
{
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 00 - 0F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 10 - 1F
    NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_,NCY_, // 20 - 2F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_, // 30 - 3F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_, // 40 - 4F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAQL,NAQL,NAQL,NAQL,NAQL,NAQL,NAQL, // 50 - 5F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_, // 60 - 6F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_, // 70 - 7F
    NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NPAR,NAQN,NAQL,NAQL,NAQL,NAQL,NAQL, // 80 - 8F
    NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC, // 90 - 9F
    NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC, // A0 - AF
    NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHBC,NHB_,NHBC, // B0 - BF
    NHB_,NHBC,NHBC,NHB_,NHBC,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_, // C0 - CF
    NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_, // D0 - DF
    NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_, // E0 - EF
    NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_,NHB_  // F0 - FF
};

const CHAR_CLASS acc_06[256] = // U+06xx
{
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NASR,NAAR,NAAR,NAAR, // 00 - 0F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 10 - 1F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 20 - 2F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 30 - 3F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAC,NAAC,NAAC,NAAC,NAAC, // 40 - 4F
    NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC, // 50 - 5F
    NAAD,NAAD,NAAD,NAAD,NAAD,NAAD,NAAD,NAAD,NAAD,NAAD,NAEW,NAAD,NAAD,NAAR,NAAR,NAAR, // 60 - 6F
    NAAC,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 70 - 7F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 80 - 8F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // 90 - 9F
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // A0 - AF
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // B0 - BF
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR, // C0 - CF
    NAAR,NAAR,NAAR,NAAR,NAAR,NAAR,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC, // D0 - DF
    NAAC,NAAC,NAAC,NAAC,NAAC,NAAR,NAAR,NAAC,NAAC,NANW,NAAC,NAAC,NAAC,NAAC,NAAC,NAAC, // E0 - EF
    NAED,NAED,NAED,NAED,NAED,NAED,NAED,NAED,NAED,NAED,NAAR,NAAR,NAAR,NAAR,NAAR,NAAR  // F0 - FF
};

const CHAR_CLASS acc_07[256] = // U+07xx
{
    NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYP,NSYW, // 00 - 0F
    NSY_,NSYC,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_, // 10 - 1F
    NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_,NSY_, // 20 - 2F
    NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC, // 30 - 3F
    NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSYC,NSY_,NSY_,NSY_,NSY_,NSY_, // 40 - 4F
    XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA, // 50 - 5F
    XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA, // 60 - 6F
    XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA,XNWA, // 70 - 7F
    NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_, // 80 - 8F
    NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_, // 90 - 9F
    NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTNC,NTNC,NTNC,NTNC,NTNC,NTNC,NTNC,NTNC,NTNC,NTNC, // A0 - AF
    NTNC,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_,NTN_, // B0 - BF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // C0 - CF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // D0 - DF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // E0 - EF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_  // F0 - FF
};

const CHAR_CLASS acc_09[256] = // U+09xx
{
    NHI_,NHIC,NHIC,NHIC,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_, // 00 - 0F
    NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_, // 10 - 1F
    NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_, // 20 - 2F
    NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHIC,NHI_,NHIC,NHIC, // 30 - 3F
    NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHI_,NHI_, // 40 - 4F
    NHI_,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHIC,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_, // 50 - 5F
    NHI_,NHI_,NHIC,NHIC,NHIN,NHIN,NHID,NHID,NHID,NHID,NHID,NHID,NHID,NHID,NHID,NHID, // 60 - 6F
    NHIN,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_,NHI_, // 70 - 7F
    NBE_,NBEC,NBEC,NBEC,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_, // 80 - 8F
    NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_, // 90 - 9F
    NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_, // A0 - AF
    NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBEC,NBE_,NBEC,NBEC, // B0 - BF
    NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBE_,NBE_, // C0 - CF
    NBE_,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBEC,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_, // D0 - DF
    NBE_,NBE_,NBEC,NBEC,NBE_,NBE_,NBED,NBED,NBED,NBED,NBED,NBED,NBED,NBED,NBED,NBED, // E0 - EF
    NBE_,NBE_,NBET,NBET,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_,NBE_  // F0 - FF
};

const CHAR_CLASS acc_0A[256] = // U+0Axx
{
    NGM_,NGMC,NGMC,NGMC,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_, // 00 - 0F
    NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_, // 10 - 1F
    NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_, // 20 - 2F
    NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGMC,NGM_,NGMC,NGMC, // 30 - 3F
    NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGM_,NGM_, // 40 - 4F
    NGM_,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGMC,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_, // 50 - 5F
    NGM_,NGM_,NGMC,NGMC,NGM_,NGM_,NGMD,NGMD,NGMD,NGMD,NGMD,NGMD,NGMD,NGMD,NGMD,NGMD, // 60 - 6F
    NGMC,NGMC,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_,NGM_, // 70 - 7F
    NGJ_,NGJC,NGJC,NGJC,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_, // 80 - 8F
    NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_, // 90 - 9F
    NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_, // A0 - AF
    NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJC,NGJ_,NGJC,NGJC, // B0 - BF
    NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJ_,NGJ_, // C0 - CF
    NGJ_,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJC,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_, // D0 - DF
    NGJ_,NGJ_,NGJC,NGJC,NGJ_,NGJ_,NGJD,NGJD,NGJD,NGJD,NGJD,NGJD,NGJD,NGJD,NGJD,NGJD, // E0 - EF
    NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_,NGJ_  // F0 - FF
};

const CHAR_CLASS acc_0B[256] = // U+0Bxx
{
    NOR_,NORC,NORC,NORC,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_, // 00 - 0F
    NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_, // 10 - 1F
    NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_, // 20 - 2F
    NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NORC,NOR_,NORC,NORC, // 30 - 3F
    NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NOR_,NOR_, // 40 - 4F
    NOR_,NORC,NORC,NORC,NORC,NORC,NORC,NORC,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_, // 50 - 5F
    NOR_,NOR_,NORC,NORC,NOR_,NOR_,NORD,NORD,NORD,NORD,NORD,NORD,NORD,NORD,NORD,NORD, // 60 - 6F
    NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_,NOR_, // 70 - 7F
    NTA_,NTAC,NTAC,NTAC,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_, // 80 - 8F
    NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_, // 90 - 9F
    NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_, // A0 - AF
    NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTAC,NTA_,NTAC,NTAC, // B0 - BF
    NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTA_,NTA_, // C0 - CF
    NTA_,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTAC,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_, // D0 - DF
    NTA_,NTA_,NTAC,NTAC,NTA_,NTA_,NTAD,NTAD,NTAD,NTAD,NTAD,NTAD,NTAD,NTAD,NTAD,NTAD, // E0 - EF
    NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_,NTA_  // F0 - FF
};

const CHAR_CLASS acc_0C[256] = // U+0Cxx
{
    NTE_,NTEC,NTEC,NTEC,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_, // 00 - 0F
    NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_, // 10 - 1F
    NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_, // 20 - 2F
    NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTEC,NTE_,NTEC,NTEC, // 30 - 3F
    NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTE_,NTE_, // 40 - 4F
    NTE_,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTEC,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_, // 50 - 5F
    NTE_,NTE_,NTEC,NTEC,NTE_,NTE_,NTED,NTED,NTED,NTED,NTED,NTED,NTED,NTED,NTED,NTED, // 60 - 6F
    NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_,NTE_, // 70 - 7F
    NKD_,NKDC,NKDC,NKDC,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_, // 80 - 8F
    NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_, // 90 - 9F
    NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_, // A0 - AF
    NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKDC,NKD_,NKDC,NKDC, // B0 - BF
    NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKD_,NKD_, // C0 - CF
    NKD_,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKDC,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_, // D0 - DF
    NKD_,NKD_,NKDC,NKDC,NKD_,NKD_,NKDD,NKDD,NKDD,NKDD,NKDD,NKDD,NKDD,NKDD,NKDD,NKDD, // E0 - EF
    NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_,NKD_  // F0 - FF
};

const CHAR_CLASS acc_0D[256] = // U+0Dxx
{
    NMA_,NMAC,NMAC,NMAC,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_, // 00 - 0F
    NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_, // 10 - 1F
    NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_, // 20 - 2F
    NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMAC,NMA_,NMAC,NMAC, // 30 - 3F
    NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMA_,NMA_, // 40 - 4F
    NMA_,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMAC,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_, // 50 - 5F
    NMA_,NMA_,NMAC,NMAC,NMA_,NMA_,NMAD,NMAD,NMAD,NMAD,NMAD,NMAD,NMAD,NMAD,NMAD,NMAD, // 60 - 6F
    NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_,NMA_, // 70 - 7F
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_, // 80 - 8F
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_, // 90 - 9F
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_, // A0 - AF
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_, // B0 - BF
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSIC,NSI_,NSI_,NSI_,NSI_,NSIC, // C0 - CF
    NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC,NSIC, // D0 - DF
    NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_, // E0 - EF
    NSI_,NSI_,NSIC,NSIC,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_,NSI_  // F0 - FF
};

const CHAR_CLASS acc_0E[256] = // U+0Exx
{
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 00 - 0F
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 10 - 1F
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 20 - 2F
    NTH_,NTHC,NTH_,NTH_,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHT, // 30 - 3F
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTHC,NTH_, // 40 - 4F
    NTHD,NTHD,NTHD,NTHD,NTHD,NTHD,NTHD,NTHD,NTHD,NTHD,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 50 - 5F
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 60 - 6F
    NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_,NTH_, // 70 - 7F
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_, // 80 - 8F
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_, // 90 - 9F
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_, // A0 - AF
    NLO_,NLOC,NLO_,NLO_,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLO_,NLO_,NLO_, // B0 - BF
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC,NLOC, // C0 - CF
    NLOD,NLOD,NLOD,NLOD,NLOD,NLOD,NLOD,NLOD,NLOD,NLOD,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_, // D0 - DF
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_, // E0 - EF
    NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_,NLO_  // F0 - FF
};

const CHAR_CLASS acc_0F[256] = // U+0Fxx
{
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTIC,NTI_,NTI_,NTI_, // 00 - 0F
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTIC,NTIC,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // 10 - 1F
    NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID,NTID, // 20 - 2F
    NTID,NTID,NTID,NTID,NTI_,NTIC,NTI_,NTIC,NTI_,NTIC,NTIN,NTIN,NTIN,NTIN,NTIC,NTIC, // 30 - 3F
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // 40 - 4F
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // 50 - 5F
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // 60 - 6F
    NTI_,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC, // 70 - 7F
    NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC, // 80 - 8F
    NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC, // 90 - 9F
    NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC, // A0 - AF
    NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTIC,NTI_,NTI_, // B0 - BF
    NTIC,NTIC,NTIC,NTIC,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // C0 - CF
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // D0 - DF
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_, // E0 - EF
    NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_,NTI_  // F0 - FF
};

const CHAR_CLASS acc_10[256] = // U+10xx
{
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 00 - 0F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 10 - 1F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBUC,NBUC,NBUC,NBUC, // 20 - 2F
    NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC,NBUC, // 30 - 3F
    NBUD,NBUD,NBUD,NBUD,NBUD,NBUD,NBUD,NBUD,NBUD,NBUD,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 40 - 4F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBUC,NBUC,NBUC,NBUC,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 50 - 5F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 60 - 6F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 70 - 7F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 80 - 8F
    NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_,NBU_, // 90 - 9F
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_, // A0 - AF
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_, // B0 - BF
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_, // C0 - CF
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_, // D0 - DF
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_, // E0 - EF
    NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGE_,NGEQ,NGE_,NGE_,NGE_,NGE_  // F0 - FF
};

const CHAR_CLASS acc_13[256] = // U+13xx
{
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 00 - 0F
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 10 - 1F
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 20 - 2F
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 30 - 3F
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 40 - 4F
    NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_,NET_, // 50 - 5F
    NET_,NETP,NETP,NETP,NETP,NETP,NETP,NETP,NETP,NETD,NETD,NETD,NETD,NETD,NETD,NETD, // 60 - 6F
    NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NETD,NET_,NET_,NET_, // 70 - 7F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 80 - 8F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 90 - 9F
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_, // A0 - AF
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_, // B0 - BF
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_, // C0 - CF
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_, // D0 - DF
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_, // E0 - EF
    NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_,NCH_  // F0 - FF
};

const CHAR_CLASS acc_16[256] = // U+16xx
{
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 00 - 0F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 10 - 1F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 20 - 2F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 30 - 3F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 40 - 4F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 50 - 5F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 60 - 6F
    NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_,NCA_, // 70 - 7F
    NOGS,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_, // 80 - 8F
    NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOG_,NOGN,NOGN,NOG_,NOG_,NOG_, // 90 - 9F
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_, // A0 - AF
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_, // B0 - BF
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_, // C0 - CF
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_, // D0 - DF
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_, // E0 - EF
    NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_,NRU_  // F0 - FF
};

const CHAR_CLASS acc_17[256] = // U+17xx
{
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 00 - 0F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 10 - 1F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 20 - 2F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 30 - 3F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 40 - 4F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 50 - 5F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 60 - 6F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 70 - 7F
    NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_, // 80 - 8F
    NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_, // 90 - 9F
    NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_, // A0 - AF
    NKH_,NKH_,NKH_,NKH_,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC, // B0 - BF
    NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC,NKHC, // C0 - CF
    NKHC,NKHC,NKHC,NKHC,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKHT,NKH_,NKH_,NKH_,NKH_, // D0 - DF
    NKHD,NKHD,NKHD,NKHD,NKHD,NKHD,NKHD,NKHD,NKHD,NKHD,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_, // E0 - EF
    NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_,NKH_  // F0 - FF
};

const CHAR_CLASS acc_18[256] = // U+18xx
{
    NMON,NMON,NMON,NMON,NMON,NMON,NMON,NMON,NMON,NMON,NMON,NMOB,NMOB,NMOB,NMOB,NMOB, // 00 - 0F
    NMOD,NMOD,NMOD,NMOD,NMOD,NMOD,NMOD,NMOD,NMOD,NMOD,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 10 - 1F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 20 - 2F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 30 - 3F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 40 - 4F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 50 - 5F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 60 - 6F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 70 - 7F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 80 - 8F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // 90 - 9F
    NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_,NMOC,NMO_,NMO_,NMO_,NMO_,NMO_,NMO_, // A0 - AF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // B0 - BF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // C0 - CF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // D0 - DF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // E0 - EF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_  // F0 - FF
};

const CHAR_CLASS acc_1E[256] = // U+1Exx
{
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 00 - 0F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 10 - 1F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 20 - 2F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 30 - 3F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 40 - 4F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 50 - 5F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 60 - 6F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 70 - 7F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 80 - 8F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 90 - 9F
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // A0 - AF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,ALA_,ALA_, // B0 - BF
    ALA_,ALA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // C0 - CF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // D0 - DF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // E0 - EF
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_  // F0 - FF
};

const CHAR_CLASS acc_1F[256] = // U+1Fxx
{
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 00 - 0F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 10 - 1F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 20 - 2F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 30 - 3F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 40 - 4F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 50 - 5F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 60 - 6F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 70 - 7F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 80 - 8F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // 90 - 9F
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_, // A0 - AF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGRN,NGR_,NGRN, // B0 - BF
    NGRN,NGRN,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGRN,NGRN,NGRN, // C0 - CF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGRN,NGRN,NGRN, // D0 - DF
    NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGRN,NGRN,NGRN, // E0 - EF
    NGRN,NGRN,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGR_,NGRN,NGRN,NGRN  // F0 - FF
};

const CHAR_CLASS acc_20[256] = // U+20xx
{
    NWBL,NWBL,NWBL,NWBL,NWBL,NWBL,NWBL,NQCS,NWBL,NWBL,NWBL,NWZW,NPZW,NPZW,NPFL,NPF_, // 00 - 0F
    AHYW,NPNW,NHYW,AHYW,AISW,ASNW,ASNW,NONW,AOQW,ARQW,NCQW,NOQW,AOQW,ACQW,NCQW,NOQW, // 10 - 1F
    ASNW,ASNW,NOCW,NONW,NISW,AISW,AISW,AHPW,NSBS,NSBB,NOSP,NOSP,NOSP,NOSP,NOSP,NBSS, // 20 - 2F
    AQEW,NQEW,AQEW,AQEW,NQEW,AQNW,NQNW,NQNW,NONW,NOQW,NCQW,ASNW,NSSW,NONW,NONW,NONW, // 30 - 3F
    NONW,NONW,NONW,NONW,NSSW,NOPW,NCPW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NOBN, // 50 - 5F
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN, // 60 - 6F
    NSEN,NSEN,NSEN,NSEN,ASAE,NSEN,NSEN,NSEN,NSEN,NSEN,NSET,NSET,NSNW,NSNW,NSNW,ASAN, // 70 - 7F
    NSEN,ASAE,ASAE,ASAE,ASAE,NSEN,NSEN,NSEN,NSEN,NSEN,NSET,NSET,NSNW,NSNW,NSNW,NSNW, // 80 - 8F
    NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW,NSNW, // 90 - 9F
    NOEW,NPEW,NPEW,NOEW,NPEW,NOEW,NOEW,NQEW,NOEW,HPEW,NPEH,NPEV,NOEW,NOEW,NOEW,NOEW, // A0 - AF
    NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW, // B0 - BF
    NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW,NOEW, // C0 - CF
    NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO, // D0 - DF
    NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO, // E0 - EF
    NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO,NOCO  // F0 - FF
};

const CHAR_CLASS acc_21[256] = // U+21xx
{
    NONW,NONW,NOLW,AQNW,NONW,ASNW,NONW,NOLW,NONW,AQNW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 00 - 0F
    NOLW,NOLW,NOLW,ASRN,NONW,NOLW,APNW,NONW,NONW,NOLW,NOLW,NOLW,NOLW,NOLW,NONW,NONW, // 10 - 1F
    NONW,ASNW,ASNW,NONW,NOLW,NONW,AQLW,NONW,NOLW,NONW,NOLW,ASRN,NOLW,NOLW,NOEW,NOLW, // 20 - 2F
    NOLW,NOLW,NONW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NONW,NONW,NONW,NONW,NONW,NONW, // 30 - 3F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,NONW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,ASNW,ASNW,ASNW,NONW, // 50 - 5F
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,NOLW,NOLW,NOLW,NOLW, // 60 - 6F
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 70 - 7F
    NOLW,NOLW,NOLW,NOLW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 80 - 8F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW, // B0 - BF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // C0 - CF
    NONW,NONW,ASNW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_22[256] = // U+22xx
{
    ASNW,NONW,ASNW,ASNW,NONW,NONW,NONW,ASNW,ASNW,NONW,NONW,ASNW,NONW,NONW,NONW,ASNW, // 00 - 0F
    NONW,ASNW,NOEW,NOEW,NONW,ASNW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW,ASNW,ASNW,ASNW, // 10 - 1F
    ASNW,NONW,NONW,ASNW,NONW,ASNW,NONW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,NONW,ASNW,NONW, // 20 - 2F
    NONW,NONW,NONW,NONW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,ASNW,ASNW,NONW,NONW, // 30 - 3F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 50 - 5F
    ASNW,ASNW,NONW,NONW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,ASNW,ASNW,NONW,NONW,ASNW,ASNW, // 60 - 6F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 70 - 7F
    NONW,NONW,ASNW,ASNW,NONW,NONW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 80 - 8F
    NONW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    NONW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW, // B0 - BF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // C0 - CF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_23[256] = // U+23xx
{
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 00 - 0F
    NONW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 10 - 1F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 20 - 2F
    NONW,NONW,NONW,NONW,NONW,NONW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 30 - 3F
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 40 - 4F
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 50 - 5F
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // 60 - 6F
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NONW,NONW,NONW,NONW,NONW, // 70 - 7F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 80 - 8F
    NONW,NONW,NONW,NONW,NONW,NOLW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // B0 - BF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // C0 - CF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_24[256] = // U+24xx
{
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 00 - 0F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 10 - 1F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 20 - 2F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 30 - 3F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 50 - 5F
    ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN, // 60 - 6F
    ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN, // 70 - 7F
    ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN, // 80 - 8F
    ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASEN,ASRN,ASRN,ASRN,ASRN, // 90 - 9F
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN, // A0 - AF
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // B0 - BF
    NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW,NOLW, // C0 - CF
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN, // D0 - DF
    ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,ASRN,NOEN,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_25[256] = // U+25xx
{
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 00 - 0F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 10 - 1F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 20 - 2F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 30 - 3F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW, // 40 - 4F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 50 - 5F
    ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 60 - 6F
    ASNW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 70 - 7F
    NONW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW, // 80 - 8F
    NONW,NONW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    ASNW,ASNW,NONW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,ASNW,ASNW,NONW,NONW,ASNW,ASNW,NONW,NONW,NONW,NONW,ASNW,ASNW,NONW,NONW, // B0 - BF
    ASNW,ASNW,NONW,NONW,NONW,NONW,ASNW,ASNW,ASNW,NONW,NONW,ASNW,NONW,NONW,ASNW,ASNW, // C0 - CF
    ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,ASNW,ASNW,ASNW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_26[256] = // U+26xx
{
    NONW,NONW,NONW,NONW,NONW,ASNW,ASNW,NONW,NONW,ASNW,NONW,NONW,NONW,NONW,ASNW,ASNW, // 00 - 0F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,NONW,ASNW,NONW, // 10 - 1F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 20 - 2F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 30 - 3F
    ASNW,NONW,ASNW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 50 - 5F
    ASNW,ASNW,NONW,ASNW,ASNW,ASNW,NONW,ASNW,ASNW,ASNW,ASNW,NONW,ASNW,ASNW,NONW,ASNW, // 60 - 6F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 70 - 7F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 80 - 8F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // B0 - BF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // C0 - CF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_27[256] = // U+27xx
{
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 00 - 0F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 10 - 1F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 20 - 2F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,ASNW,NONW,NONW, // 30 - 3F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 40 - 4F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 50 - 5F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 60 - 6F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 70 - 7F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 80 - 8F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // 90 - 9F
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // A0 - AF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // B0 - BF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // C0 - CF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // D0 - DF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW  // F0 - FF
};

const CHAR_CLASS acc_2E[256] = // U+2Exx
{
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 00 - 0F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 10 - 1F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 20 - 2F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 30 - 3F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 40 - 4F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 50 - 5F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 60 - 6F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 70 - 7F
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // 80 - 8F
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // 90 - 9F
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // A0 - AF
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // B0 - BF
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // C0 - CF
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // D0 - DF
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // E0 - EF
    WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_  // F0 - FF
};

const CHAR_CLASS acc_30[256] = // U+30xx
{
    WSP_,WC__,WPE_,WOI_,WOI_,WIM_,WOIL,WOIL,WOP_,WCP_,WOP_,WCP_,WOP_,WCP_,WOP_,WCP_, // 00 - 0F
    WOP_,WCP_,WOI_,WOI_,WOB_,WCB_,WOP_,WCP_,WOP_,WCP_,WOP_,WCP_,WSS_,WOQ_,WCQ_,WCQ_, // 10 - 1F
    WOI_,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIC,WOIC,WOIC,WOIC,WOIC,WOIC, // 20 - 2F
    WOI_,WOIL,WOIL,WOIL,WOIL,WOIL,WOI_,WOI_,WOIL,WOIL,WOIL,WOI_,WOI_,WOI_,WOI_,WOI_, // 30 - 3F
    WHI_,WHS_,WHI_,WHS_,WHI_,WHS_,WHI_,WHS_,WHI_,WHS_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_, // 40 - 4F
    WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_, // 50 - 5F
    WHI_,WHI_,WHI_,WHS_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_, // 60 - 6F
    WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_, // 70 - 7F
    WHI_,WHI_,WHI_,WHS_,WHI_,WHS_,WHI_,WHS_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHS_,WHI_, // 80 - 8F
    WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WHI_,WKSC,WKSC,WKSM,WKSM,WHIM,WHIM,WHI_, // 90 - 9F
    WKA_,WKS_,WKA_,WKS_,WKA_,WKS_,WKA_,WKS_,WKA_,WKS_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_, // A0 - AF
    WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_, // B0 - BF
    WKA_,WKA_,WKA_,WKS_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_, // C0 - CF
    WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_, // D0 - DF
    WKA_,WKA_,WKA_,WKS_,WKA_,WKS_,WKA_,WKS_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKS_,WKA_, // E0 - EF
    WKA_,WKA_,WKA_,WKA_,WKA_,WKS_,WKS_,WKA_,WKA_,WKA_,WKA_,WKC_,WKS_,WKIM,WKIM,WKA_  // F0 - FF
};

const CHAR_CLASS acc_31[256] = // U+31xx
{
    NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_, // 00 - 0F
    NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_, // 10 - 1F
    NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_, // 20 - 2F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 30 - 3F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 40 - 4F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 50 - 5F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 60 - 6F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 70 - 7F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 80 - 8F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 90 - 9F
    NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_, // A0 - AF
    NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_,NBO_, // B0 - BF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // C0 - CF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // D0 - DF
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // E0 - EF
    WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_,WKA_  // F0 - FF
};

const CHAR_CLASS acc_32[256] = // U+32xx
{
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 00 - 0F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 10 - 1F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 20 - 2F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 30 - 3F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 40 - 4F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 50 - 5F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 60 - 6F
    WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_,WHG_, // 70 - 7F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 80 - 8F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 90 - 9F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // A0 - AF
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // B0 - BF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // C0 - CF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // D0 - DF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // E0 - EF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL  // F0 - FF
};

const CHAR_CLASS acc_33[256] = // U+33xx
{
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 00 - 0F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 10 - 1F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 20 - 2F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 30 - 3F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 40 - 4F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 50 - 5F
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 60 - 6F
    WCI_,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // 70 - 7F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 80 - 8F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // 90 - 9F
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // A0 - AF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // B0 - BF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // C0 - CF
    WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL,WOIL, // D0 - DF
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_, // E0 - EF
    WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_,WCI_  // F0 - FF
};

const CHAR_CLASS acc_A4[256] = // U+A4xx
{
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 00 - 0F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 10 - 1F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 20 - 2F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 30 - 3F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 40 - 4F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 50 - 5F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 60 - 6F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 70 - 7F
    WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_,WYI_, // 80 - 8F
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // 90 - 9F
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // A0 - AF
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // B0 - BF
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // C0 - CF
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // D0 - DF
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN, // E0 - EF
    WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN,WYIN  // F0 - FF
};

const CHAR_CLASS acc_D8[256] = // U+D8xx
{
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // 00 - 0F
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // 10 - 1F
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // 20 - 2F
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // 30 - 3F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 40 - 4F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 50 - 5F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 60 - 6F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 70 - 7F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 80 - 8F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // 90 - 9F
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // A0 - AF
    WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_,WHT_, // B0 - BF
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // C0 - CF
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // D0 - DF
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_, // E0 - EF
    NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_,NHS_  // F0 - FF
};

const CHAR_CLASS acc_FB[256] = // U+FBxx
{
    NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_,NLA_, // 00 - 0F
    NLA_,NLA_,NLA_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NAR_,NHBR,NHBC,NHBR, // 10 - 1F
    NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBW,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR, // 20 - 2F
    NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR, // 30 - 3F
    NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR,NHBR, // 40 - 4F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 50 - 5F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 60 - 6F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 70 - 7F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 80 - 8F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 90 - 9F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // A0 - AF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // B0 - BF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // C0 - CF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // D0 - DF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // E0 - EF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS  // F0 - FF
};

const CHAR_CLASS acc_FD[256] = // U+FDxx
{
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 00 - 0F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 10 - 1F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 20 - 2F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NANW,NANW, // 30 - 3F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 40 - 4F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 50 - 5F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 60 - 6F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 70 - 7F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 80 - 8F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 90 - 9F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // A0 - AF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // B0 - BF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // C0 - CF
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN, // D0 - DF
    NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN,NOBN, // E0 - EF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS  // F0 - FF
};

const CHAR_CLASS acc_FE[256] = // U+FExx
{
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 00 - 0F
    XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_,XNW_, // 10 - 1F
    APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO,APCO, // 20 - 2F
    WOI_,WOI_,WOI_,WOI_,WOI_,WOP5,WCP5,WOP5,WCP5,WOP5,WCP5,WOP5,WCP5,WOP5,WCP5,WOP5, // 30 - 3F
    WCP5,WOP5,WCP5,WOP5,WCP5,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_,WOI_, // 40 - 4F
    WC5S,WC5_,WPE5,WOI_,WOC6,WOC5,WQE5,WQE5,WOI_,WOP5,WCP5,WOP5,WCP5,WOP5,WCP5,WOIT, // 50 - 5F
    WOI_,WOI_,WOIT,WOIT,WOI_,WOI_,WOI_,WOI_,WOI_,WPR_,WQO_,WOI_,WOI_,WOI_,WOI_,WOI_, // 60 - 6F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 70 - 7F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 80 - 8F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // 90 - 9F
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // A0 - AF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // B0 - BF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // C0 - CF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // D0 - DF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS, // E0 - EF
    NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NAAS,NQCW  // F0 - FF
};

const CHAR_CLASS acc_FF[256] = // U+FFxx
{
    XNW_,WQE_,WOI_,WOIT,WPR_,WQO_,WOI_,WOI_,WOB_,WCB_,WOI_,WOIT,WCS_,WOIT,WPES,WOIS, // 00 - 0F
    WD__,WD__,WD__,WD__,WD__,WD__,WD__,WD__,WD__,WD__,WOCS,WOC_,WOI_,WOI_,WOI_,WQE_, // 10 - 1F
    WOI_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_, // 20 - 2F
    WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WOB_,WOI_,WCB_,WOI_,WOI_, // 30 - 3F
    WOI_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_, // 40 - 4F
    WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WLA_,WOP_,WOI_,WCP_,WOI_,XNW_, // 50 - 5F
    XNW_,HPE_,HOP_,HCP_,HCO_,NKCC,NKA_,NKSL,NKSL,NKSL,NKSL,NKSL,NKSL,NKSL,NKSL,NKSL, // 60 - 6F
    NKSL,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_, // 70 - 7F
    NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_, // 80 - 8F
    NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKA_,NKS_,NKS_, // 90 - 9F
    NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_, // A0 - AF
    NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_, // B0 - BF
    NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_, // C0 - CF
    NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,NHG_,XNW_,XNW_,XNW_, // D0 - DF
    WQO_,WPR_,WOI_,WOI_,WOI_,WPR_,WPR_,XNW_,NOI_,NOI_,NOI_,NOI_,NOI_,NOI_,NOI_,XNW_, // E0 - EF
    NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NONW,NOBN,NOBN,NOBN,NOBN,NONW,NOBN,NOBN  // F0 - FF
};

const CHAR_CLASS * const pccUnicodeClass[256] =
{
    acc_00, acc_01, acc_02, acc_03, acc_04, acc_05, acc_06, acc_07,  // 00 - 07
    __XNW_, acc_09, acc_0A, acc_0B, acc_0C, acc_0D, acc_0E, acc_0F,  // 08 - 0F
    acc_10, __WHG_, __NET_, acc_13, __NCA_, __NCA_, acc_16, acc_17,  // 10 - 17
    acc_18, __XNW_, __XNW_, __XNW_, __XNW_, __XNW_, acc_1E, acc_1F,  // 18 - 1F
    acc_20, acc_21, acc_22, acc_23, acc_24, acc_25, acc_26, acc_27,  // 20 - 27
    __NBR_, __NONW, __NONW, __XNW_, __XNW_, __XNW_, acc_2E, __WOI_,  // 28 - 2F
    acc_30, acc_31, acc_32, acc_33, __WID_, __WID_, __WID_, __WID_,  // 30 - 37
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 38 - 3F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 40 - 47
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 48 - 4F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 50 - 57
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 58 - 5F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 60 - 67
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 68 - 6F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 70 - 77
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 78 - 7F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 80 - 87
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 88 - 8F
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 90 - 97
    __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_, __WID_,  // 98 - 9F
    __WYI_, __WYI_, __WYI_, __WYI_, acc_A4, __XNW_, __XNW_, __XNW_,  // A0 - A7
    __XNW_, __XNW_, __XNW_, __XNW_, __WHG_, __WHG_, __WHG_, __WHG_,  // A8 - AF
    __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_,  // B0 - B7
    __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_,  // B8 - BF
    __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_,  // C0 - C7
    __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_,  // C8 - CF
    __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_, __WHG_,  // D0 - D7
    acc_D8, __NHS_, __NHS_, __NHS_, __LS__, __LS__, __LS__, __LS__,  // D8 - DF
    __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA,  // E0 - E7
    __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA,  // E8 - EF
    __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA, __WPUA,  // F0 - F7
    __WPUA, __WID_, __WID_, acc_FB, __NAAS, acc_FD, acc_FE, acc_FF   // F8 - FF
};

//+----------------------------------------------------------------------------
//
//  Function:   CharClassFromChSlow
//
//  Synopsis:   Given a character return a Unicode character class.  This
//              character class implies other properties, such as script id,
//              breaking class, etc.
//
//      Note:   pccUnicodeClass is a hack table.  For every Unicode page for
//              which every codepoint is the same value, the table entry is
//              the charclass itself.  Otherwise we have a pointer to a table
//              of charclass.
//
//-----------------------------------------------------------------------------

CHAR_CLASS CharClassFromChSlow(
    wchar_t wch) // [in]
{
    const CHAR_CLASS * const pcc = pccUnicodeClass[wch>>8];
    const UINT_PTR icc = UINT_PTR(pcc);

    return (CHAR_CLASS)(icc < 256 ? icc : pcc[wch & 0xff]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmlapp\apprc2.h ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       apprc2.h
//
//  Created:    02/20/98    philco
//-------------------------------------------------------------------------


//
// Custom Resource types
//

#define FILERESOURCE    1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmlapp\apprc.h ===
#define IDR_APPICON						101
#define IDF_LARGE_ICON					101

#define IDR_SMALLCON					102
#define IDF_SMALL_ICON					102

#define IDR_PADMENU						103

#define IDI_APPICON		                501
#define IDI_APPSMALLICON                502

#define IDS_UNEXPECTED                  1000
#define IDS_CANTNOW                     1001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmlapp\factory.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       factory.cxx
//
//  Contents:   class factory
//
//  Created:    02/20/98    philco
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_FACTORY_HXX_
#define X_FACTORY_HXX_
#include "factory.hxx"
#endif

#ifndef X_SERVER_HXX_
#define X_SERVER_HXX_
#include "server.hxx"
#endif

IMPLEMENT_SUBOBJECT_IUNKNOWN(CHTAClassFactory, CHTMLApp, HTMLApp, _Factory)

EXTERN_C const GUID CLSID_HTMLApplication;

CHTAClassFactory::CHTAClassFactory()
    : _dwRegCookie(0)
{
}

void CHTAClassFactory::Passivate()
{
    // If we registered a class factory, revoke it now.
    if (_dwRegCookie)
    {
        CoRevokeClassObject(_dwRegCookie);
    }
}

HRESULT CHTAClassFactory::Register()
{
    HRESULT hr = THR(CoRegisterClassObject(CLSID_HTMLApplication, this, CLSCTX_LOCAL_SERVER, REGCLS_SINGLEUSE, &_dwRegCookie));
    RRETURN(hr);
}

HRESULT CHTAClassFactory::QueryInterface(REFIID riid, void ** ppv)
{
    if (!ppv)
        return E_POINTER;

    *ppv = NULL;

    if (riid == IID_IUnknown || riid == IID_IClassFactory)
        *ppv = (IClassFactory *)this;

    if (*ppv)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

HRESULT CHTAClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void ** ppv)
{
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CServerObject *pServer = new CServerObject(HTMLApp());
    if (!pServer)
        return E_OUTOFMEMORY;

    return (pServer->QueryInterface(riid, ppv));
}

HRESULT CHTAClassFactory::LockServer(BOOL fLock)
{
    // Keep a combined ref/lock count.  No need to distinguish in the case.
    if (fLock)
    {
        AddRef();
    }
    else
    {
        Release();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmlapp\frame.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       frame.cxx
//
//  Contents:   Implementation of frame object
//
//  Created:    02/20/98    philco
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_APP_HXX_
#define X_APP_HXX_
#include "app.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

IMPLEMENT_SUBOBJECT_IUNKNOWN(CHTMLAppFrame, CHTMLApp, HTMLApp, _Frame)

CHTMLAppFrame::CHTMLAppFrame()
    : _pActiveObj(NULL)
{
}

void CHTMLAppFrame::Passivate()
{
}

void CHTMLAppFrame::Resize()
{
    // Note:  We provide the client area rectangle because:
    //
    //  1.  No frame-level adornments are allowed.
    //  2.  No status bar is implemented.
    //
    //  if either condition changes, we should revist this code so that the
    //  appropriate area is excluded from this rect.
    //
    
    if (_pActiveObj)
    {
        RECT rc;
        HTMLApp()->GetViewRect(&rc);
        _pActiveObj->ResizeBorder( &rc, this, TRUE);
    }
}

HRESULT
CHTMLAppFrame::TranslateKeyMsg(MSG * pMsg)
{
    HRESULT hr = S_FALSE;

    // Only allow keyboard messages to be translated
    if (_pActiveObj && ((pMsg->message >= WM_KEYFIRST) && (pMsg->message <= WM_KEYLAST)))
    {
        hr = _pActiveObj->TranslateAccelerator(pMsg);
    }
    
    RRETURN1(hr, S_FALSE);
}

HRESULT CHTMLAppFrame::QueryInterface(REFIID riid, void ** ppv)
{
    if (!ppv)
        return E_POINTER;

    *ppv = NULL;

    if (riid == IID_IOleInPlaceFrame ||
        riid == IID_IOleWindow ||
        riid == IID_IUnknown)
    {
        *ppv = (IOleInPlaceFrame *) this;
    }
    else if (riid == IID_IOleInPlaceUIWindow)
    {
        *ppv = (IOleInPlaceUIWindow *) this;
    }

    if (*ppv)
    {
        AddRef();
        return S_OK;
    }
    
    RRETURN(E_NOINTERFACE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::GetWindow
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::GetWindow(HWND * phWnd)
{
    *phWnd = HTMLApp()->_hwnd;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::ContextSensitiveHelp
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::ContextSensitiveHelp(BOOL fEnterMode)
{
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::GetBorder
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::GetBorder(LPOLERECT prcBorder)
{
    HTMLApp()->GetViewRect(prcBorder);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::RequestBorderSpace
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::RequestBorderSpace(LPCBORDERWIDTHS pbw)
{
    RRETURN(INPLACE_E_NOTOOLSPACE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::SetBorderSpace
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::SetBorderSpace(LPCBORDERWIDTHS pbw)
{
    RRETURN(INPLACE_E_NOTOOLSPACE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::SetActiveObject
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::SetActiveObject(
        LPOLEINPLACEACTIVEOBJECT    pActiveObj,
        LPCTSTR                     pstrObjName)
{
    ReplaceInterface(&_pActiveObj, pActiveObj);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::InsertMenus
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS pmgw)
{        
    
    pmgw->width[0] = pmgw->width[2] = pmgw->width[4] = 0;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::SetMenu
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND 
hwndActiveObject)
{
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::RemoveMenus
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::RemoveMenus(HMENU hmenuShared)
{
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::SetStatusText
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::SetStatusText(LPCTSTR szStatusText)
{
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::EnableModeless
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::EnableModeless(BOOL fEnable)
{
    //  TODO: should probably disable ourselves?
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLAppFrame::TranslateAccelerator
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLAppFrame::TranslateAccelerator(LPMSG pmsg, WORD wID)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmlapp\client.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       olesite.cxx
//
//  Contents:   implementation of client object
//
//  Created:    02/20/98    philco
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_APP_HXX_
#define X_APP_HXX_
#include "app.hxx"
#endif

#ifndef X_CLIENT_HXX_
#define X_CLIENT_HXX_
#include "client.hxx"
#endif

#ifndef X_PRIVCID_H_
#define X_PRIVCID_H_
#include "privcid.h"
#endif

#ifndef X_MISC_HXX_
#define X_MISC_HXX_
#include "misc.hxx"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include "shell.h"
#endif

IMPLEMENT_SUBOBJECT_IUNKNOWN(CClient, CHTMLApp, HTMLApp, _Client)

//+---------------------------------------------------------------------------
//
//  Member:     CClient::CClient
//
//  Synopsis:   Initializes data members
//
//----------------------------------------------------------------------------
CClient::CClient()
    : _pUnk(NULL), _pIoo(NULL), _pView(NULL)
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CClient::~CClient
//
//  Synopsis:   
//
//----------------------------------------------------------------------------
CClient::~CClient()
{
    Assert(!_pUnk);
    Assert(!_pIoo);
    Assert(!_pView);
}

//+------------------------------------------------------------------------
//
//  Member:     CClient::QueryObjectInterface
//
//  Synopsis:   Query the control for an interface.
//              The purpose of this function is to reduce code size.
//
//  Arguments:  iid     Interface to query for
//              ppv     Returned interface
//
//-------------------------------------------------------------------------

HRESULT
CClient::QueryObjectInterface(REFIID iid, void **ppv)
{
    if (_pUnk)
        return _pUnk->QueryInterface(iid, ppv);
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CClient::Passivate
//
//  Synopsis:   Called when app is shutting down.
//
//----------------------------------------------------------------------------
void CClient::Passivate()
{
    IOleInPlaceObject *pIP = NULL;

    // InplaceDeactivate the contained object
    QueryObjectInterface(IID_IOleInPlaceObject, (void **)&pIP);
    if (pIP)
    {
        pIP->InPlaceDeactivate();
        ReleaseInterface(pIP);
    }

    // ISSUE:  is this the right flag to send?
    if (_pIoo)
        _pIoo->Close(OLECLOSE_NOSAVE);
        
    ClearInterface(&_pIoo);
    ClearInterface(&_pView);
    ClearInterface(&_pDT);
    ClearInterface(&_pUnk);
}


//+---------------------------------------------------------------------------
//
//  Member:     CClient::Show
//
//  Synopsis:   Causes the docobject to show itself in our client area
//
//----------------------------------------------------------------------------

HRESULT CClient::Show()
{
    HRESULT hr = S_OK;
    
    if (_pIoo)
    {
        RECT rc;
        App()->GetViewRect(&rc);
        hr = _pIoo->DoVerb(OLEIVERB_SHOW, NULL, this, 0, App()->_hwnd, &rc);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CClient::Resize
//
//  Synopsis:   Resizes this object (usually as a result of the frame windo
//              changing size).
//
//----------------------------------------------------------------------------

void CClient::Resize()
{
    if (_pView)
    {
        RECT rc;
        App()->GetViewRect(&rc);
        _pView->SetRect(&rc);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CClient::Create
//
//  Synopsis:   Creates COM object instance
//
//----------------------------------------------------------------------------

HRESULT CClient::Create(REFCLSID clsid)
{
    HRESULT hr;
        
    hr = THR(CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&_pUnk));
    if (hr)
        goto Cleanup;
        
    hr = QueryObjectInterface(IID_IOleObject, (void **)&_pIoo);

    // Fall through.  Check hr if new code is added here.
    
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CClient::Load
//
//  Synopsis:   In addition to loading, set's the client site.
//
//----------------------------------------------------------------------------

HRESULT CClient::Load(IMoniker *pMk)
{
    HRESULT hr = S_OK;
	IPersistMoniker *pIpm = NULL;

    if (!_pUnk)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    // TODO:  move to its own fn (and check OLEMISC for order)??
    if (_pIoo)
        _pIoo->SetClientSite(this);

	QueryObjectInterface(IID_IPersistMoniker, (void **)&pIpm);
	if (pIpm)
	{
		hr = THR(pIpm->Load(TRUE, pMk, NULL, 0));
		ReleaseInterface(pIpm);
	}

    TEST(hr);

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CClient::SendCommand
//
//  Synopsis:   Sends an Exec command to the hosted object.
//
//----------------------------------------------------------------------------

HRESULT
CClient::SendCommand(
        const GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    HRESULT                 hr;
    IOleCommandTarget *     pCmdTarget = NULL;
    
    hr = THR_NOTRACE(QueryObjectInterface(
        IID_IOleCommandTarget,
        (void **)&pCmdTarget));

    if (hr)
        goto Cleanup;
        
    hr = THR_NOTRACE(pCmdTarget->Exec(pguidCmdGroup,
            nCmdID,
            nCmdexecopt,
            pvarargIn,
            pvarargOut));

Cleanup:
    ReleaseInterface(pCmdTarget);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CClient::GetService
//
//  Synopsis:   Retrieves a service from the hosted object.
//
//----------------------------------------------------------------------------

HRESULT
CClient::GetService(
        REFGUID guidService,
        REFIID  riid,
        void ** ppObj)
{
    HRESULT                 hr;
    IServiceProvider *      pServiceProvider = NULL;
    
    Assert(ppObj);
    
    hr = THR_NOTRACE(QueryObjectInterface(
        IID_IServiceProvider,
        (void **)&pServiceProvider));

    if (hr)
        goto Cleanup;
        
    hr = THR_NOTRACE(pServiceProvider->QueryService(guidService,
            riid,
            ppObj));

Cleanup:
    ReleaseInterface(pServiceProvider);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CClient::DelegateMessage
//
//  Synopsis:   Delegates messages to the contained instance of Trident.
//
//----------------------------------------------------------------------------

LRESULT
CClient::DelegateMessage(UINT msg, WPARAM wParam, LPARAM lParam)
{
    IOleInPlaceObject * pAO = NULL;
    LRESULT lRes = 0;
    
    if (_pView)
    {
        HRESULT hr;
        HWND hwnd;
        
        hr = _pView->QueryInterface(IID_IOleInPlaceObject, (void **) &pAO);
        if (hr)
            goto Cleanup;

        hr = pAO->GetWindow(&hwnd);
        if (hr)
            goto Cleanup;
            
        Assert(::IsWindow(hwnd));
        lRes = ::SendMessage(hwnd, msg, wParam, lParam);
    }
    
Cleanup:
    ReleaseInterface(pAO);
    return lRes;
}

BOOL
CClient::SelfDragging(void)
{
    BOOL fSelfDrag = FALSE;
    CVariant var;

    SendCommand(&CGID_ShellDocView, SHDVID_ISDRAGSOURCE, 0, NULL, &var);

    // if the return variant is VT_I4 and non-zero, it is a self-drag.
    if ((V_VT(&var) == VT_I4) && (V_I4(&var)))
        fSelfDrag = TRUE;

    return fSelfDrag;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClient::Frame
//
//  Synopsis:   Returns a pointer to the app's frame object
//
//----------------------------------------------------------------------------

CHTMLAppFrame * CClient::Frame()
{
    return &App()->_Frame;
}


//+---------------------------------------------------------------------------
//
//  Member:     CClient::App
//
//  Synopsis:   Returns a pointer to the application object.
//
//----------------------------------------------------------------------------

CHTMLApp * CClient::App()
{
    return HTMLApp();
}    

LPCTSTR CClient::GetAppName()
{
    return App()->GetAppName();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmlapp\peerfact.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       factory.cxx
//
//  Contents:   class factory
//
//  Created:    02/20/98    philco
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_APP_HXX_
#define X_APP_HXX_
#include "app.hxx"
#endif

#ifndef X_FACTORY_HXX_
#define X_FACTORY_HXX_
#include "factory.hxx"
#endif

#ifndef X_PEERFACT_HXX_
#define X_PEERFACT_HXX_
#include "peerfact.hxx"
#endif

#ifndef X_PEERS_HXX_
#define X_PEERS_HXX_
#include "peers.hxx"
#endif

BOOL CBehaviorFactory::_fCreated = FALSE;

IMPLEMENT_SUBOBJECT_IUNKNOWN(CBehaviorFactory, CHTMLApp, HTMLApp, _PeerFactory)

CBehaviorFactory::CBehaviorFactory()
{
}

HRESULT CBehaviorFactory::QueryInterface(REFIID riid, void ** ppv)
{
    if (!ppv)
        return E_POINTER;

    *ppv = NULL;

    if (riid == IID_IUnknown || riid == IID_IElementBehaviorFactory)
        *ppv = (IElementBehaviorFactory *)this;

    if (*ppv)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

// IElementBehaviorFactory methods
HRESULT CBehaviorFactory::FindBehavior(BSTR bstrName, BSTR bstrUrl,
            IElementBehaviorSite * pSite, IElementBehavior ** ppPeer)
{
    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;
    
    // We don't hand out more than a single instance of the application behavior.
    if (_fCreated)
        goto Cleanup;
        
    if (bstrName && (0 == StrCmpICW(bstrName, L"Application")))
    {
        CAppBehavior *pApp = new CAppBehavior;

        if (!pApp)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        
        hr = pApp->QueryInterface(IID_IElementBehavior, (void **)ppPeer);

        // This object should have a refcount of one when this function returns, otherwise
        // it will never get to zero.  CBase contributes an initial refcount of 1, the QI
        // (if successful) increments the refcount to 2.  We need to release one of them now.
        if (SUCCEEDED(hr))
            pApp->Release();

        _fCreated = TRUE;
    }

Cleanup:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmlapp\main.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       main.cxx
//
//  Contents:   WinMain and associated functions.
//
//  Created:    02/20/98    philco
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_APP_HXX_
#define X_APP_HXX_
#include "app.hxx"
#endif

CHTMLApp theApp;

LPTSTR
GetCmdLine()
{
    #ifdef UNICODE
        LPTSTR pszCmdLine = GetCommandLine();
    #else
        // for multibyte should make it unsigned
        BYTE * pszCmdLine = (BYTE *)GetCommandLine();
    #endif

    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    return (LPTSTR) pszCmdLine;
}

STDAPI
RunHTMLApplication(
        HINSTANCE hinst,
        HINSTANCE hPrevInst,
        LPSTR szCmdLine,
        int nCmdShow)
{
    HRESULT hr = S_OK;
    LPTSTR lpszCmdLine = GetCmdLine();

    hr = theApp.Init(hinst, lpszCmdLine, nCmdShow);
    if (hr)
        goto Cleanup;

    theApp.Run();

Cleanup:
    hr = theApp.Terminate();
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmldlg\dlgmodel.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       dlgmodel.cxx
//
//  Contents:   Implementation of the object model for html based dialogs
//
//  History:    08-22-96  AnandRa   Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

#ifndef X_MARKUP_HXX_
#define X_MARKUP_HXX_
#include "markup.hxx"
#endif

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::close
//
//  Synopsis:   close the dialog
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::close()
{
    PostMessage(_hwnd, WM_CLOSE, 0, 0);
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::hide
//
//  Synopsis:   Allows a trusted dialog to be hidden.  This is currently used
//  by print preview after we print and before we are done spooling.  we return
//  control to the parent window.
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::onDialogHide()
{
    HRESULT     hr = S_OK;

    // since 'no' is the default it is safe to just set/reset it
    if (!_fTrusted)
    {
        if (_enumfHide==HTMLDlgFlagYes)
        {
            _enumfHide = HTMLDlgFlagNo;  
            hr = S_OK;
        }
        else
        {
            hr = CTL_E_METHODNOTAPPLICABLE;
        }
        goto Cleanup;
    }

    // modeless windows will close on their own or when the parent document
    // navigates away (or closes).  
    //
    // ISSUE: we may want to remove our _hwnd from the parent document's _aryActiveModelessWindow... 
    // if we can figure out how to access it.
    //
    // modal, are not going to be modal after this call and are going to 
    // have to close themselves, since we have no means by which to add
    // _hwnd to the parentDoc's _aryActiveModelessWindow.

    if (!_fIsModeless)
    {
        // if hide is Yes, enable parent window (TRUE), else disable parent (FALSE)
        ::EnableWindow(_hwndTopParent, (_enumfHide==HTMLDlgFlagYes));
    }

        // don't deavitive or transition, just hide.
    hr = THR(Show( (_enumfHide==HTMLDlgFlagYes) ? SW_HIDE : SW_SHOW));

Cleanup:
    return hr;
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::get_dialogArguments
//
//  Synopsis:   Get the argument
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::get_dialogArguments(VARIANT * pvar)
{
    HRESULT hr = E_FAIL;

    if(!pvar)
        goto Cleanup;
     
    hr = VariantClear(pvar);
    if(hr)
        goto Cleanup;

    if(AccessAllowed())
        hr = VariantCopy(pvar, &_varArgIn);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::get_menuArguments
//
//  Synopsis:   Get the argument (same as dialogArguments, but
//              renamed for neatness)
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::get_menuArguments(VARIANT * pvar)
{
    HRESULT hr = E_FAIL;

    if(!pvar)
        goto Cleanup;
     
    hr = VariantClear(pvar);
    if(hr)
        goto Cleanup;

    if(AccessAllowed())
        hr = VariantCopy(pvar, &_varArgIn);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::get_returnValue
//
//  Synopsis:   Get the return value
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::get_returnValue(VARIANT * pvar)
{
    RRETURN(SetErrorInfo(VariantCopy(pvar, &_varRetVal)));
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::put_returnValue
//
//  Synopsis:   Set the return value
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::put_returnValue(VARIANT var)
{
    RRETURN(SetErrorInfo(VariantCopy(&_varRetVal, &var)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmldlg\dlgframe.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       dlgsite.cxx
//
//  Contents:   Implementation of the frame for hosting html dialogs
//
//  History:    06-14-96  AnandRa   Created
//
//  Notes:      This frame does not supply a real frame window if
//              it is acting as a property page.  If it's acting as 
//              a dialog, then it does.
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

DeclareTag(tagHTMLDlgFrameMethods, "HTML Dialog Frame", "Methods on the html dialog frame")

IMPLEMENT_SUBOBJECT_IUNKNOWN(CHTMLDlgFrame, CHTMLDlg, HTMLDlg, _Frame);


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::QueryInterface
//
//  Synopsis:   Per IUnknown
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IOleInPlaceFrame ||
        iid == IID_IOleWindow ||
        iid == IID_IOleInPlaceUIWindow ||
        iid == IID_IUnknown)
    {
        *ppv = (IOleInPlaceFrame *) this;
        AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::GetWindow
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::GetWindow(HWND * phWnd)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleWindow::GetWindow"));
    
    *phWnd = HTMLDlg()->_hwnd;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::ContextSensitiveHelp
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleWindow::ContextSensitiveHelp"));
    
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::GetBorder
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::GetBorder(LPOLERECT prcBorder)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleInPlaceUIWindow::GetBorder"));

#ifndef WIN16    
    HTMLDlg()->GetViewRect(prcBorder);
#else
    RECTL rcBorder;
    HTMLDlg()->GetViewRect(&rcBorder);
    CopyRect(prcBorder, &rcBorder);
#endif
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::RequestBorderSpace
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::RequestBorderSpace(LPCBORDERWIDTHS pbw)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleInPlaceUIWindow::RequestBorderSpace"));
    
    RRETURN(INPLACE_E_NOTOOLSPACE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::SetBorderSpace
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::SetBorderSpace(LPCBORDERWIDTHS pbw)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleInPlaceUIWindow::SetBorderSpace"));
    
    RRETURN(INPLACE_E_NOTOOLSPACE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::SetActiveObject
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::SetActiveObject(
        LPOLEINPLACEACTIVEOBJECT    pActiveObj,
        LPCTSTR                     pstrObjName)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleInPlaceUIWindow::SetActiveObject"));
    
    ReplaceInterface(&HTMLDlg()->_pInPlaceActiveObj, pActiveObj);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::InsertMenus
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS pmgw)
{        
    TraceTag((tagHTMLDlgFrameMethods, "IOleInPlaceFrame::InsertMenus"));
    
    pmgw->width[0] = pmgw->width[2] = pmgw->width[4] = 0;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::SetMenu
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleInPlaceFrame::SetMenu"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::RemoveMenus
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::RemoveMenus(HMENU hmenuShared)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleInPlaceFrame::RemoveMenus"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::SetStatusText
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::SetStatusText(LPCTSTR szStatusText)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleInPlaceFrame::SetStatusText"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::EnableModeless
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::EnableModeless(BOOL fEnable)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleInPlaceFrame::EnableModeless"));
    
    //  TODO: (anandra) should probably disable ourselves?
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgFrame::TranslateAccelerator
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgFrame::TranslateAccelerator(LPMSG pmsg, WORD wID)
{
    TraceTag((tagHTMLDlgFrameMethods, "IOleInPlaceFrame::TranslateAccelerator"));
    
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmldlg\dlgsink.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       dlgsink.cxx
//
//  Contents:   Implementation of the dlg sinks + extender
//
//  History:    06-25-96  AnandRa   Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

#ifndef X_COMMIT_HXX_
#define X_COMMIT_HXX_
#include "commit.hxx"
#endif

#ifndef X_COREDISP_H_
#define X_COREDISP_H_
#include <coredisp.h>
#endif


DeclareTag(tagHTMLDlgExtenderMethods, "HTML Dialog Xtender", "Methods on the html dialog Xtender")

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgExtender::CHTMLDlgExtender
//
//  Synopsis:   constructor
//
//----------------------------------------------------------------------------

CHTMLDlgExtender::CHTMLDlgExtender(
    CHTMLDlg *      pDlg, 
    IHTMLElement *  pHTMLElement, 
    DISPID          dispid)
{
    HRESULT         hr = S_OK;
    CVariant        var;

    TraceTag((tagHTMLDlgExtenderMethods, "constructor"));

    _pDlg = pDlg;
    _pHTMLElement = pHTMLElement;
    _pHTMLElement->AddRef();
    _dispid = dispid;
    _ulRefs = 1;

    if (S_OK == hr)
        hr = THR_NOTRACE(GetDispProp(
                                    _pHTMLElement, 
                                    DISPID_A_VALUE, 
                                    g_lcidUserDefault, 
                                    &var, 
                                    NULL));

    _ExchangeValueBy = (S_OK == hr) ? EXCHANGEVALUEBY_VALUE : EXCHANGEVALUEBY_INNERTEXT;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgExtender::~CHTMLDlgExtender
//
//  Synopsis:   destructor
//
//----------------------------------------------------------------------------

CHTMLDlgExtender::~CHTMLDlgExtender()
{
    TraceTag((tagHTMLDlgExtenderMethods, "destructor"));

    _pHTMLElement->Release();
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgExtender::QueryInterface
//
//  Synopsis:   Per IUnknown.
//
//----------------------------------------------------------------------------

HRESULT
CHTMLDlgExtender::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown || iid == IID_IPropertyNotifySink)
    {
        *ppv = (IPropertyNotifySink *) this;
    }
    else
    {
        *ppv = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgExtender::Value_PropPageToObject
//
//----------------------------------------------------------------------------

HRESULT
CHTMLDlgExtender::Value_PropPageToObject ()
{
    HRESULT     hr = S_OK;
    CVariant    var;
    CExcepInfo  ei;

    switch (_ExchangeValueBy)
    {

    case EXCHANGEVALUEBY_VALUE:

        hr = THR(::GetDispProp(
                _pHTMLElement,
                DISPID_A_VALUE,
                g_lcidUserDefault,
                &var,
                &ei));
        if (hr)
        {
            hr = THR(::GetDispProp(
                    _pHTMLElement,
                    DISPID_VALUE,
                    g_lcidUserDefault,
                    &var,
                    &ei));
            if (hr)
                goto Cleanup;
        }

        break;

    case EXCHANGEVALUEBY_INNERTEXT:

        hr = S_OK;
        goto Cleanup;
    }

    hr = THR(_pDlg->_pEngine->SetProperty(_dispid, &var));
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgExtender::Value_ObjectToPropPage
//
//----------------------------------------------------------------------------

HRESULT
CHTMLDlgExtender::Value_ObjectToPropPage ()
{
    HRESULT                 hr;
    CVariant                varValue;
    CVariant                varText;
    CExcepInfo              ei;
    IHTMLControlElement *   pControlElement = NULL;

    Assert (_pDlg && _pDlg->_pEngine);

    hr = THR(_pDlg->_pEngine->GetProperty(_dispid, &varValue));
    if (hr)
        goto Cleanup;

    switch (_ExchangeValueBy)
    {

    case EXCHANGEVALUEBY_VALUE:

        hr = THR(::SetDispProp(
                _pHTMLElement,
                DISPID_A_VALUE,
                g_lcidUserDefault,
                &varValue,
                &ei));
        if (hr)
        {
            hr = THR(::SetDispProp(
                _pHTMLElement,
                DISPID_VALUE,
                g_lcidUserDefault,
                &varValue,
                &ei));
            if (hr)
                goto Cleanup;
        }

        break;

    case EXCHANGEVALUEBY_INNERTEXT:

        hr = THR(VariantChangeTypeEx(&varText, &varValue, g_lcidUserDefault, 0, VT_BSTR));
        if (hr)
            goto Cleanup;

        hr = THR(_pHTMLElement->put_innerText(V_BSTR(&varText)));
        if (hr)
            goto Cleanup;

        break;

    default:
        Assert (0);
        break;
    }

Cleanup:
    ReleaseInterface (pControlElement);

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgExtender::OnChanged
//
//  Synopsis:   per IPropertyNotifySink.
//
//----------------------------------------------------------------------------

HRESULT
CHTMLDlgExtender::OnChanged(DISPID dispid)
{
    TraceTag((tagHTMLDlgExtenderMethods, "IPropertyNotifySink::OnChanged dispid:%d", dispid));

    //
    // Just look for the value property changing.  If this does
    // occur, then we have a dirty page.  Additionally, look to see
    // if this is occuring when the page is first being initialized.
    // Skip this prop change if so.
    //

    if ((DISPID_VALUE == dispid || DISPID_A_VALUE == dispid) && !_pDlg->_fInitializing)
    {
        _pDlg->OnPropertyChange(this);
    }
    
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgExtender::OnRequestEdit
//
//  Synopsis:   per IPropertyNotifySink.
//
//----------------------------------------------------------------------------

HRESULT
CHTMLDlgExtender::OnRequestEdit(DISPID dispid)
{
    TraceTag((tagHTMLDlgExtenderMethods, "IPropertyNotifySink::OnRequestEdit dispid:%d", dispid));
    
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     CDlgDocPNS::QueryInterface
//
//  Synopsis:   Per IUnknown.
//
//----------------------------------------------------------------------------

IMPLEMENT_FORMS_SUBOBJECT_IUNKNOWN(CDlgDocPNS, CHTMLDlg, _PNS)

STDMETHODIMP
CDlgDocPNS::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown || iid == IID_IPropertyNotifySink)
    {
        *ppv = (IPropertyNotifySink *) this;
    }
    else
    {
        *ppv = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDlgDocPNS::OnChanged
//
//  Synopsis:   
//
//----------------------------------------------------------------------------

STDMETHODIMP CDlgDocPNS::OnChanged(DISPID dispid)
{

    RRETURN(_pDlg->OnPropertyChange(dispid, 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmlapp\regkey.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       regkey.cxx
//
//  Contents:   implementation of non-inline CRegKey functions
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_REGKEY_HXX_
#define X_REGKEY_HXX_
#include "regkey.hxx"
#endif

/////////////////////////////////////////////////////////////////////////////
// CRegKey

LONG CRegKey::Close()
{
	LONG lRes = ERROR_SUCCESS;
	if (m_hKey != NULL)
	{
		lRes = RegCloseKey(m_hKey);
		m_hKey = NULL;
	}
	return lRes;
}

LONG CRegKey::Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
	LPTSTR lpszClass, DWORD dwOptions, REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
	_ASSERTE(hKeyParent != NULL);
	DWORD dw;
	HKEY hKey = NULL;
	LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
		lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
	if (lpdwDisposition != NULL)
		*lpdwDisposition = dw;
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		m_hKey = hKey;
	}
	return lRes;
}

LONG CRegKey::Open(HKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
	_ASSERTE(hKeyParent != NULL);
	HKEY hKey = NULL;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		_ASSERTE(lRes == ERROR_SUCCESS);
		m_hKey = hKey;
	}
	return lRes;
}

LONG CRegKey::QueryValue(DWORD& dwValue, LPCTSTR lpszValueName)
{
	DWORD dwType = NULL;
	DWORD dwCount = sizeof(DWORD);
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)&dwValue, &dwCount);
	_ASSERTE((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
	_ASSERTE((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
	return lRes;
}

LONG CRegKey::QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* 
pdwCount)
{
	_ASSERTE(pdwCount != NULL);
	DWORD dwType = NULL;
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)szValue, pdwCount);
	_ASSERTE((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
			 (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));
	return lRes;
}

LONG WINAPI CRegKey::SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR 
lpszValue, LPCTSTR lpszValueName)
{
	_ASSERTE(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(hKeyParent, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

LONG CRegKey::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR 
lpszValueName)
{
	_ASSERTE(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(m_hKey, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

LONG CRegKey::SetValue(DWORD dwValue, LPCTSTR lpszValueName)
{
	_ASSERTE(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_DWORD,
		(BYTE * const)&dwValue, sizeof(DWORD));
}

HRESULT CRegKey::SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	_ASSERTE(lpszValue != NULL);
	_ASSERTE(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ,
		(BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR));
}

//RecurseDeleteKey is necessary because on NT RegDeleteKey doesn't work if the
//specified key has subkeys
LONG CRegKey::RecurseDeleteKey(LPCTSTR lpszKey)
{
	CRegKey key;
	LONG lRes = key.Open(m_hKey, lpszKey);
	if (lRes != ERROR_SUCCESS)
		return lRes;
	FILETIME time;
	TCHAR szBuffer[256];
	DWORD dwSize = 256;
	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
		&time)==ERROR_SUCCESS)
	{
		lRes = key.RecurseDeleteKey(szBuffer);
		if (lRes != ERROR_SUCCESS)
			return lRes;
		dwSize = 256;
	}
	key.Close();
	return DeleteSubKey(lpszKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmlapp\peers.cxx ===
#include "headers.hxx"

#ifndef X_APP_HXX_
#define X_APP_HXX_
#include "app.hxx"
#endif

#ifndef X_PEERS_HXX_
#define X_PEERS_HXX_
#include "peers.hxx"
#endif

#ifndef X_COREDISP_H_
#define X_COREDISP_H_
#include "coredisp.h"
#endif

#ifndef X_FUNCSIG_HXX_
#define X_FUNCSIG_HXX_
#include "funcsig.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include <dispex.h>
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

// ISSUE: TODO: Can we fix this somewhat evil inclusion due to
// CMarkup needing CLayoutContext?
#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "..\..\site\layout\layout.hxx"
#endif

#ifndef X_MARKUP_HXX_
#define X_MARKUP_HXX_
#include "markup.hxx"
#endif

#define _cxx_
#include "htmlapp.hdl"

MtDefine(HTA, Behaviors, "HTA")
MtDefine(CAppBehavior, HTA, "CAppBehavior")

const CBase::CLASSDESC CAppBehavior::s_classdesc =
{
    &CLSID_HTMLAppBehavior,         // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLAppBehavior,          // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

//+-------------------------------------------------------------------------
//
//  Method:     CBaseBehavior::QueryInterface
//
//  Synopsis:   Per IUnknown
//
//--------------------------------------------------------------------------
STDMETHODIMP
CBaseBehavior::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    if (!ppv)
        return E_POINTER;

    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS(this, IElementBehavior)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
        RRETURN(super::PrivateQueryInterface(iid, ppv));
}

//+-------------------------------------------------------------------------
//
//  Method:     CBaseBehavior::Passivate
//
//  Synopsis:   Called when object's refcount goes to zero.
//
//--------------------------------------------------------------------------
void
CBaseBehavior::Passivate()
{
    // Object is going away.  Notify factory that it can now create another.
    // Needed in the case where an HTA is refreshed.

    theApp._PeerFactory.BehaviorDestroyed();    
    super::Passivate();
}

//+-------------------------------------------------------------------------
//
//  Method:     CBaseBehavior::Init
//
//  Synopsis:   Per IElementBehavior
//
//--------------------------------------------------------------------------
STDMETHODIMP
CBaseBehavior::Init(IElementBehaviorSite *pSite)
{
    HRESULT hr = E_INVALIDARG;

    if (pSite != NULL)
    {
        _pSite = pSite;
        _pSite->AddRef();
        hr = S_OK;
    }
    return hr;  
}

//+-------------------------------------------------------------------------
//
//  Method:     CBaseBehavior::Notify
//
//  Synopsis:   Per IElementBehavior
//
//--------------------------------------------------------------------------
STDMETHODIMP CBaseBehavior::Notify(LONG lNotify, VARIANT * pVarNotify)
{
    RRETURN(S_OK);
}



//+-------------------------------------------------------------------------
//
//  Method:     CBaseBehavior::CBaseBehavior
//              CBaseBehavior::~CBaseBehavior
//
//  Synopsis:   Constructor/Destructor for app behavior.
//
//--------------------------------------------------------------------------
CAppBehavior::CAppBehavior()
{
    // Load the commandline into the attribute array.
    SetAAcommandLine(theApp.cmdLine()); 
}

CAppBehavior::~CAppBehavior()
{
    if (_pBitsCtx)
    {
        _pBitsCtx->SetProgSink(NULL);
        _pBitsCtx->Disconnect();
        _pBitsCtx->Release();
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CBaseBehavior::QueryInterface
//
//  Synopsis:   Per IUnknown
//
//--------------------------------------------------------------------------
STDMETHODIMP
CAppBehavior::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_TEAROFF_DISPEX(this, NULL)
    QI_HTML_TEAROFF(this, IHTMLAppBehavior, NULL)
    QI_HTML_TEAROFF(this, IHTMLAppBehavior2, NULL)
    QI_HTML_TEAROFF(this, IHTMLAppBehavior3, NULL)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN (super::PrivateQueryInterface(iid, ppv));
}

//+-------------------------------------------------------------------------
//
//  Method:     CAppBehavior::Init
//
//  Synopsis:   Per IElementBehavior
//
//  Notes:      Initialization function for APPLICATION tag
//--------------------------------------------------------------------------
STDMETHODIMP
CAppBehavior::Init(IElementBehaviorSite *pSite)
{
    HRESULT hr = super::Init(pSite);
    IHTMLElement *pElement = NULL;
    CDoc * pDoc;
    const TCHAR * pchUrl;

    if (_pSite)
    {
        hr = _pSite->GetElement(&pElement);
        if (SUCCEEDED(hr))
        {
            CPtrBagVTableAggregate::CIterator vTableIterator(GetStringTableAggregate());
        
            for(vTableIterator.Start(VTABLEDESC_BELONGSTOPARSE); !vTableIterator.End(); vTableIterator.Next())
            {
                const VTABLEDESC *pVTblDesc = vTableIterator.Item();
                const PROPERTYDESC *pPropDesc = pVTblDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOPARSE);
                Assert(pPropDesc);

                VARIANT attrValue;
                VariantInit(&attrValue);

                if (pPropDesc->pstrName)
                {
                    hr = GetAttrValue(pElement, pPropDesc->pstrName, &attrValue);
                    if (SUCCEEDED(hr))
                    {
                        pPropDesc->HandleLoadFromHTMLString(this, attrValue.bstrVal, 0);
                        VariantClear(&attrValue);
                    }
                }
            }
            ReleaseInterface(pElement);
        }
    }

    pchUrl = GetAAicon();
    if (!pchUrl || !*pchUrl)
        goto Cleanup;

    hr = THR(theApp._Client._pUnk->QueryInterface(
            CLSID_HTMLDocument,
            (void **) &pDoc));
    if (hr)
        goto Cleanup;

    // Notify the app that we are starting an async property download so it
    // can ignore the IDM_PARSECOMPLETE exec command if it comes in before 
    // this download is complete.
    theApp.Wait(TRUE);

    Assert(!_pBitsCtx);

    // Get the bits context
    // NB: (jbeda) It should be okay to pass FALSE for fPendingRoot
    //     here because we switch markup for identity behaviors
    hr = THR(pDoc->NewDwnCtx(DWNCTX_FILE, GetAAicon(),
                NULL, (CDwnCtx **) &_pBitsCtx, FALSE));        // TODO (lmollico): should we pass pElement?
    if (hr || !_pBitsCtx)
    {
        theApp.Wait(FALSE);
        goto Cleanup;
    }

    // if bits already got, call the callback
    if (_pBitsCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
        OnDwnChan();
    else    // register the callback
    {
        // NOTE (lmollico): we shouldn't use _pBitsCtx here
        _pBitsCtx->SetProgSink(CMarkup::GetProgSinkHelper(pDoc->PrimaryMarkup()));
        _pBitsCtx->SetCallback(OnDwnChanCallback, this);
        _pBitsCtx->SelectChanges(DWNCHG_COMPLETE, 0, TRUE);
    }

    return S_OK;
Cleanup:
    theApp.SetAttributes(this);
    return S_OK;
}


void CAppBehavior::OnDwnChan()
{
    HRESULT hr;
    ULONG ulState = _pBitsCtx->GetState();

    if (ulState & DWNLOAD_COMPLETE)
    {
        TCHAR * pchFile;

        hr = _pBitsCtx->GetFile(&pchFile);
        if (hr)
            goto Cleanup;

        SetAAicon(pchFile);     // TODO (lmollico): we should use a private member string instead
        MemFreeString(pchFile);
    }

Cleanup:
    if (ulState & (DWNLOAD_COMPLETE | DWNLOAD_STOPPED | DWNLOAD_ERROR))
    {
        _pBitsCtx->SetProgSink(NULL);
        theApp.Wait(FALSE);
        theApp.SetAttributes(this);
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CAppBehavior::InvokeEx
//
//  Synopsis:   Per IDispatchEx
//
//  Notes:      Override of CBase implementation.  Filters out all dispids
//              except those generated by this behavior.
//--------------------------------------------------------------------------
STDMETHODIMP
CAppBehavior::InvokeEx(DISPID id, LCID lcid, WORD wFlags,
                      DISPPARAMS *pdp, VARIANT *pvarRes,
                      EXCEPINFO *pei, IServiceProvider *pspCaller)
{
    if (id == DISPID_CAppBehavior_commandLine)
        RRETURN(super::InvokeEx(id, lcid, wFlags, pdp, pvarRes, pei, pspCaller));
    else
        RRETURN_NOTRACE(DISP_E_MEMBERNOTFOUND);
}

//+-------------------------------------------------------------------------
//
//  Method:     CAppBehavior::GetDispID
//
//  Synopsis:   Per IDispatchEx
//
//  Notes:      Override of CBase implementation.  Filters out all properties
//              except those generated by this behavior.
//--------------------------------------------------------------------------
STDMETHODIMP
CAppBehavior::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    if (!StrCmpIC(bstrName, TEXT("commandLine")))
        return DISP_E_UNKNOWNNAME;
    else    
        RRETURN(super::GetDispID(bstrName, grfdex, pid));
}

//+-------------------------------------------------------------------------
//
//  Method:     CAppBehavior::GetStyles
//
//  Synopsis:   Returns window styles reflecting values specified in APPLICATION
//              tag attributes (or default values if not specified).
//
//--------------------------------------------------------------------------
DWORD
CAppBehavior::GetStyles()
{
    DWORD dwStyle = WS_OVERLAPPED | 
                    GetAAcaption() | 
                    GetAAsysMenu() | 
                    GetAAborder() | 
                    GetAAminimizeButton() | 
                    GetAAmaximizeButton();

    if (GetAAcaption() == HTMLCaptionFlagNo || GetAAborder() == HTMLBorderNone)
    {
        // The only way to get a captionless or borderless window is to turn 
        // off the caption and everything that goes along with it.  It must
        // also be a POPUP window, but we morph it later.
        dwStyle &= ~(WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX);
    }

    return dwStyle;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAppBehavior::GetExtendedStyles
//
//  Synopsis:   Returns extended window styles reflecting values specified in
//              APPLICATION tag attributes (or default values if not specified).
//
//--------------------------------------------------------------------------
DWORD CAppBehavior::GetExtendedStyles()
{
    DWORD dwStyleEx = GetAAborderStyle();
    return dwStyleEx;
}

//+---------------------------------------------------------------------------
//
//  Member:     GetAttrValue
//
//  Synopsis:   Given an element and attribute name, retrieves the current
//              value of that element.
//
//----------------------------------------------------------------------------
STDMETHODIMP
GetAttrValue(IHTMLElement *pElement, const TCHAR * pchAttrName, VARIANT *pVarOut)
{
    VARIANT attrName;
    HRESULT hr = S_OK;

    if (!pElement || !pVarOut)
        return E_POINTER;
        
    V_VT(&attrName) = VT_BSTR;
    V_BSTR(&attrName) = SysAllocString(pchAttrName);
    if ( !V_BSTR(&attrName) )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    hr = pElement->getAttribute(attrName.bstrVal, 0, pVarOut);
    VariantClear(&attrName);

    // If this attribute doesn't exist, clear the variant and return a failure code.
    if (V_VT(pVarOut) == VT_NULL)
    {
        VariantClear(pVarOut);
        hr = E_FAIL;
    }
Cleanup:        
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmldlg\dlgsite.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       dlgsite.cxx
//
//  Contents:   Implementation of the site for hosting html dialogs
//
//  History:    06-14-96  AnandRa   Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

#ifndef X_OPTSHOLD_HXX_
#define X_OPTSHOLD_HXX_
#include "optshold.hxx"
#endif

#ifndef __mshtmcid_h__
#include "mshtmcid.h"       // for IDM_IME_ENABLE_RECONVERSION
#endif


#define SID_SOmWindow IID_IHTMLWindow2

// TODO need to move the CMDID_SCRIPTSITE_HTMLDLGTRUST definition from formkrnl.hxx
// to a header file visible here or include formkrnl.hxx here
#define CMDID_SCRIPTSITE_HTMLDLGTRUST 1

DeclareTag(tagHTMLDlgSiteMethods, "HTML Dialog Site", "Methods on the html dialog site")

IMPLEMENT_SUBOBJECT_IUNKNOWN(CHTMLDlgSite, CHTMLDlg, HTMLDlg, _Site);

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::QueryInterface
//
//  Synopsis:   Per IUnknown
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IOleClientSite ||
        iid == IID_IUnknown)
    {
        *ppv = (IOleClientSite *) this;
    }
    else if (iid == IID_IOleInPlaceSite ||
             iid == IID_IOleWindow)
    {
        *ppv = (IOleInPlaceSite *) this;
    }
    else if (iid == IID_IOleControlSite)
    {
        *ppv = (IOleControlSite *) this;
    }
    else if (iid == IID_IDispatch)
    {
        *ppv = (IDispatch *) this;
    }
    else if (iid == IID_IServiceProvider)
    {
        *ppv = (IServiceProvider *)this;
    }
    else if (iid == IID_ITargetFrame)
    {
        *ppv = (ITargetFrame *)this;
    }
    else if (iid == IID_ITargetFrame2)
    {
        *ppv = (ITargetFrame2 *)this;
    }
    else if (iid == IID_IDocHostUIHandler)
    {
        *ppv = (IDocHostUIHandler *)this;
    }
    else if (iid == IID_IOleCommandTarget)
    {
        *ppv = (IOleCommandTarget *)this;
    }
    else if (iid == IID_IInternetSecurityManager)
    {
        *ppv = (IInternetSecurityManager *) this ;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::SaveObject
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::SaveObject()
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleClientSite::SaveObject"));
    
    // TODO: (anandra) Possibly call the apply method?
    return S_OK;    // Fail silently
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::GetMoniker
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::GetMoniker(
        DWORD dwAssign,
        DWORD dwWhichMoniker,
        LPMONIKER * ppmk)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleClientSite::GetMoniker"));

    //lookatme
    *ppmk = NULL;
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::GetContainer
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::GetContainer(LPOLECONTAINER * ppContainer)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleClientSite::GetContainer"));
    
    *ppContainer = NULL;
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::ShowObject
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::ShowObject()
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleClientSite::ShowObject"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::OnShowWindow
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::OnShowWindow(BOOL fShow)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleClientSite::OnShowWindow"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::RequestNewObjectLayout
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::RequestNewObjectLayout( )
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleClientSite::RequestNewObjectLayout"));
    
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::GetWindow
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::GetWindow(HWND * phwnd)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleWindow::GetWindow"));

    *phwnd = HTMLDlg()->_hwnd;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::ContextSensitiveHelp
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleWindow::ContextSensitiveHelp"));
    
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::CanInPlaceActivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::CanInPlaceActivate()
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleInPlaceSite::CanInPlaceActivate"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::OnInPlaceActivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::OnInPlaceActivate()
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleInPlaceSite::OnInPlaceActivate"));
    
    HRESULT     hr;

    hr = THR(HTMLDlg()->_pOleObj->QueryInterface(
            IID_IOleInPlaceObject,
            (void **) &HTMLDlg()->_pInPlaceObj));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::OnUIActivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::OnUIActivate( )
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleInPlaceSite::OnUIActivate"));
    
    // Clean up any of our ui.
    IGNORE_HR(HTMLDlg()->_Frame.SetMenu(NULL, NULL, NULL));

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::GetWindowContext
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::GetWindowContext(
        LPOLEINPLACEFRAME  *    ppFrame,
        LPOLEINPLACEUIWINDOW  * ppDoc,
        LPOLERECT               prcPosRect,
        LPOLERECT               prcClipRect,
        LPOLEINPLACEFRAMEINFO   pFI)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleInPlaceSite::GetWindowContext"));
    
    *ppFrame = &HTMLDlg()->_Frame;
    (*ppFrame)->AddRef();

    *ppDoc = NULL;

#ifndef WIN16
    HTMLDlg()->GetViewRect(prcPosRect);
#else
    RECTL rcView;
    HTMLDlg()->GetViewRect(&rcView);
    CopyRect(prcPosRect, &rcView);
#endif
    *prcClipRect = *prcPosRect;

    pFI->fMDIApp = FALSE;
    pFI->hwndFrame = HTMLDlg()->_hwnd;
    pFI->haccel = NULL;
    pFI->cAccelEntries = 0;

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::Scroll
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::Scroll(OLESIZE scrollExtent)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleInPlaceSite::Scroll"));
    
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::OnUIDeactivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::OnUIDeactivate(BOOL fUndoable)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleInPlaceSite::OnUIDeactivate"));
    
    // Set focus back to the frame.
    SetFocus(HTMLDlg()->_hwnd);

    // Clean up any of our ui.
    IGNORE_HR(HTMLDlg()->_Frame.SetMenu(NULL, NULL, NULL));

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::OnInPlaceDeactivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::OnInPlaceDeactivate( )
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleInPlaceSite::OnInPlaceDeactivate"));
    
    ClearInterface(&HTMLDlg()->_pInPlaceObj);
    ClearInterface(&HTMLDlg()->_pInPlaceActiveObj);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::DiscardUndoState
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::DiscardUndoState( )
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleInPlaceSite::DiscardUndoState"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::DeactivateAndUndo
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::DeactivateAndUndo( )
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleInPlaceSite::DeactivateAndUndo"));
    
    RRETURN(THR(HTMLDlg()->_pInPlaceObj->UIDeactivate()));
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::OnPosRectChange
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::OnPosRectChange(LPCOLERECT prcPosRect)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleInPlaceSite::OnPosRectChange"));
    
    Assert(FALSE);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::OnControlInfoChanged
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::OnControlInfoChanged()
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleControlSite::OnControlInfoChanged"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::LockInPlaceActive
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::LockInPlaceActive(BOOL fLock)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleControlSite::LockInPlaceActive"));
    
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::GetExtendedControl
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::GetExtendedControl(IDispatch **ppDispCtrl)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleControlSite::GetExtendedControl"));
    
    RRETURN(HTMLDlg()->QueryInterface(IID_IDispatch, (void **)ppDispCtrl));
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::TransformCoords
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::TransformCoords(
    POINTL* pptlHimetric,
    POINTF* pptfContainer,
    DWORD dwFlags)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleControlSite::TransformCoords"));
    
    //lookatme
    // This tells the object that we deal entirely with himetric
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::TranslateAccelerator
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::TranslateAccelerator(LPMSG lpmsg, DWORD grfModifiers)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleControlSite::TranslateAccelerator"));

    HRESULT hr;
    
    //
    // Pass this on up to the property frame thru the page site, if one
    // exists.
    //

    if (HTMLDlg()->_pPageSite)
    {
        hr = THR(HTMLDlg()->_pPageSite->TranslateAccelerator(lpmsg));
    }
    else
    {
        hr = S_FALSE;
    }

    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::OnFocus
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::OnFocus(BOOL fGotFocus)
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleControlSite::OnFocus"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlgSite::ShowPropertyFrame
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::ShowPropertyFrame()
{
    TraceTag((tagHTMLDlgSiteMethods, "IOleControlSite::ShowPropertyFrame"));
    
    // To disallow control showing prop-pages
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::GetTypeInfo
//
//  Synopsis:   per IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::GetTypeInfo(UINT itinfo, ULONG lcid, ITypeInfo ** ppTypeInfo)
{
    TraceTag((tagHTMLDlgSiteMethods, "IDispatch::GetTypeInfo"));
    
    RRETURN(E_NOTIMPL);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::GetTypeInfoCount
//
//  Synopsis:   per IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::GetTypeInfoCount(UINT * pctinfo)
{
    TraceTag((tagHTMLDlgSiteMethods, "IDispatch::GetTypeInfoCount"));
    
    *pctinfo = 0;
    RRETURN(E_NOTIMPL);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::GetIDsOfNames
//
//  Synopsis:   per IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::GetIDsOfNames(
    REFIID riid, 
    LPOLESTR * rgszNames, 
    UINT cNames, 
    LCID lcid, 
    DISPID * rgdispid)
{
    TraceTag((tagHTMLDlgSiteMethods, "IDispatch::GetIDsOfNames"));
    
    RRETURN(E_NOTIMPL);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::Invoke
//
//  Synopsis:   per IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::Invoke(
    DISPID dispidMember, 
    REFIID riid, 
    LCID lcid, 
    WORD wFlags,
    DISPPARAMS * pdispparams, 
    VARIANT * pvarResult,
    EXCEPINFO * pexcepinfo, 
    UINT * puArgErr)
{
    TraceTag((tagHTMLDlgSiteMethods, "IDispatch::Invoke"));
    
    HRESULT     hr = DISP_E_MEMBERNOTFOUND;

    if (wFlags & DISPATCH_PROPERTYGET)
    {
        if (!pvarResult)
        {
            hr = E_POINTER;
            goto Cleanup;
        }
        
        VariantInit(pvarResult);

        switch (dispidMember)
        {
        case DISPID_AMBIENT_SHOWHATCHING:
        case DISPID_AMBIENT_SHOWGRABHANDLES:
            //
            // We don't want the ui-active control to show standard ole
            // hatching or draw grab handles.
            //

            V_VT(pvarResult) = VT_BOOL;
            V_BOOL(pvarResult) = (VARIANT_BOOL)0;
            hr = S_OK;
            break;
            
        case DISPID_AMBIENT_LOCALEID:
            hr = S_OK;
            V_VT(pvarResult) = VT_I4;
            V_I4(pvarResult) = HTMLDlg()->_lcid;
            break;
        }
    }
    
Cleanup:    
    return hr;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::QueryService
//
//  Synopsis:   per IServiceProvider
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::QueryService(REFGUID sid, REFIID iid, LPVOID * ppv)
{
    HRESULT hr;

    if (NULL != HTMLDlg()->_pHostServiceProvider)
    {
        hr = HTMLDlg()->_pHostServiceProvider->QueryService(sid, iid, ppv);
        
        if (!hr)
        {
            return hr;
        }
    }

    if (sid == IID_ITargetFrame || sid == IID_ITargetFrame2)
    {
        hr = THR_NOTRACE(QueryInterface(iid, ppv));
    }
    else if (sid == IID_IHTMLDialog)
    {
        hr = THR(HTMLDlg()->QueryInterface(iid, ppv));
    }
    else if ( sid == IID_IInternetSecurityManager)
    {
        //
        // marka - if we are in a trusted Dialog
        // We then provide our own custom security manager (that allows everything)
        // otherwise - we don't provide this service. 
        //
        if ( HTMLDlg()->_fTrusted )
            hr = THR_NOTRACE( QueryInterface( iid, ppv ));
        else
        {    
            *ppv = NULL;
            hr = E_NOINTERFACE;
        }                
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::GetFrameOptions
//
//  Synopsis:   per ITargetFrame
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::GetFrameOptions(DWORD *pdwFlags)
{
    *pdwFlags = HTMLDlg()->_dwFrameOptions;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::GetFrameMargins
//
//  Synopsis:   per ITargetFrame
//              Dialogs return 0 frame margins for compat w/ <= IE5.0
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::GetFrameMargins(DWORD *pdwWidth, DWORD *pdwHeight)
{
    if ( !pdwWidth || !pdwHeight )
        return E_POINTER;

    *pdwWidth = 0;
    *pdwHeight = 0;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::QueryStatus
//
//  Synopsis:   per IOleCommandTarget
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::QueryStatus(
                const GUID * pguidCmdGroup,
                ULONG cCmds,
                MSOCMD rgCmds[],
                MSOCMDTEXT * pcmdtext)
{
    return OLECMDERR_E_UNKNOWNGROUP ;
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::Exec
//
//  Synopsis:   per IOleCommandTarget
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::Exec(
                const GUID * pguidCmdGroup,
                DWORD nCmdID,
                DWORD nCmdexecopt,
                VARIANTARG * pvarargIn,
                VARIANTARG * pvarargOut)
{
    HRESULT  hr = S_OK;

    if(!pguidCmdGroup)
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;
        goto Cleanup;
    }


    if(CLSID_HTMLDialog == *pguidCmdGroup)
    {
        // we should only get this message
        // when onload is fired.  It uses nCmdID == 0
        // so any other command is an error.
        Assert(nCmdID == 0);

        if(HTMLDlg()->_fAutoExit)
        {
            HTMLDlg()->close();
        }
        else
        {
            hr = OLECMDERR_E_NOTSUPPORTED;
        }
    }
    else if (CGID_ScriptSite == *pguidCmdGroup)
    {
        switch (nCmdID)
        {
        case CMDID_SCRIPTSITE_HTMLDLGTRUST:
            if (!pvarargOut)
            {
                hr = E_POINTER;
                goto Cleanup;
            }
    
            V_VT(pvarargOut) = VT_BOOL;
            V_BOOL(pvarargOut) = HTMLDlg()->_fTrusted;

            break;

        default:
            hr = OLECMDERR_E_NOTSUPPORTED;
            break;
        }
    }
    else
        hr = OLECMDERR_E_UNKNOWNGROUP;


Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::GetHostInfo
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::GetHostInfo(DOCHOSTUIINFO * pInfo)
{
    HRESULT hr = S_OK;
    DWORD   dwInherit = 0;
    
    Assert(pInfo);

    if (pInfo->cbSize < sizeof(DOCHOSTUIINFO)) 
        return E_INVALIDARG;

    //
    // HACKHACK: We need to inherit IME reconversion flag
    // from the main host 
    // We cannot QI IDocHostUIHandler from main host since
    // it is not marshallable
    //
    if (VT_DISPATCH == V_VT(&(HTMLDlg()->_varArgIn)))
    {
        IDispatch            *pDisp = NULL;
        IHTMLOptionsHolder   *pOptions  = NULL;
        IHTMLDocument2       *pDoc2 = NULL;
        IOleCommandTarget    *pCmdTarget = NULL;

        //
        // _varArgIn points to the main CDoc instance
        //
        pDisp = V_DISPATCH(&(HTMLDlg()->_varArgIn));
        if (pDisp)
        {
            hr = THR(pDisp->QueryInterface(IID_IHTMLOptionsHolder, (void **)&pOptions));
            if (pOptions)
            {
                Assert(SUCCEEDED(hr));
                hr = THR(pOptions->get_document(&pDoc2));
            }
            else 
            {
                hr = THR(pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc2));
            }

            if (pDoc2 && SUCCEEDED(THR(pDoc2->QueryInterface(IID_IOleCommandTarget, (void **)&pCmdTarget))))
            {
                OLECMD  rgCmds[] = { {IDM_IME_ENABLE_RECONVERSION, 0} };
                hr = pCmdTarget->QueryStatus(&CGID_MSHTML, 
                                            1,
                                            rgCmds,
                                            NULL
                                            );
                if (SUCCEEDED(hr))
                {
                    dwInherit = (rgCmds[0].cmdf == MSOCMDSTATE_UP) ? DOCHOSTUIFLAG_IME_ENABLE_RECONVERSION : 0;
                }
            }

            ReleaseInterface(pDoc2);
            ReleaseInterface(pOptions);
            ReleaseInterface(pCmdTarget);
        }
    }

    pInfo->dwFlags = DOCHOSTUIFLAG_DIALOG | dwInherit;
    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::GetExternal
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::GetExternal(IDispatch **ppDisp)
{
    HRESULT hr;

    if (!ppDisp)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = THR(HTMLDlg()->QueryInterface(IID_IDispatch, (void **)ppDisp));
    }

    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::TranslateUrl
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::TranslateUrl(
    DWORD dwTranslate, 
    OLECHAR *pchURLIn, 
    OLECHAR **ppchURLOut)
{
    HRESULT hr;

    if (!ppchURLOut)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppchURLOut = NULL;
        hr = S_OK;
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::FilterDataObject
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlgSite::FilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
    HRESULT     hr;

    if (!ppDORet)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppDORet = NULL;
        hr = S_OK;
    }
   
    RRETURN(hr);
}


//+=======================================================================
//
//
// IInternetSecurityManager Methods
//
// marka - CHTMLDlgSite now implements an IInternetSecurityManager
// this is to BYPASS the normal Security settings for a trusted HTML Dialog in a "clean" way
//
// QueryService - for IID_IInternetSecurity Manager - will return that interface
// if we are a _trusted Dialog. Otherwise we fail this QueryService and use the "normal"
// security manager.
//
// RATIONALE:
//
//    - Moving dialog code to mshtmled.dll requires implementing COptionsHolder as an
//      embedded object. Hence if we were honoring the user's Security Settings - if they had 
//    ActiveX turned off - they could potentially break dialogs.
//
//  - If you're in a "trusted" HTML dialog (ie invoked via C-code), your potential to do
//      anything "unsafe" is infinite - so why not allow all security actions ?
//
//
//
//==========================================================================


//+------------------------------------------------------------------------
//
//  Member:     CHtmlDlgSite::SetSecuritySite
//
//    Implementation of IInternetSecurityManager::SetSecuritySite
//
//  Synopsis:   Sets the Security Site Manager
//
//
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::SetSecuritySite( IInternetSecurityMgrSite *pSite )
{
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlDlgSite::GetSecuritySite
//
//    Implementation of IInternetSecurityManager::GetSecuritySite
//
//  Synopsis:   Returns the Security Site Manager
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::GetSecuritySite( IInternetSecurityMgrSite **ppSite )
{
    *ppSite = NULL;
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlDlgSite::MapURLToZone
//
//    Implementation of IInternetSecurityManager::MapURLToZone
//
//  Synopsis:   Returns the ZoneIndex for a given URL
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::MapUrlToZone(
                        LPCWSTR     pwszUrl,
                        DWORD*      pdwZone,
                        DWORD       dwFlags
                    )
{
    return INET_E_DEFAULT_ACTION;
}
                    
//+------------------------------------------------------------------------
//
//  Member:     CHtmlDlgSite::ProcessURLAction
//
//    Implementation of IInternetSecurityManager::ProcessURLAction
//
//  Synopsis:   Query the security manager for a given action
//              and return the response.  This is basically a true/false
//              or allow/disallow return value.
//
//                (marka) We assume that for HTML Dialogs - a Security Manager is *ONLY*
//                created if we are in a Trusted Dialog ( see QueryService above)
//
//                Hence we then allow *ALL* actions
//
//                (michdav - Windows 556900) We don't actually allow all
//                actions. If there is a frame with security="restricted", we
//                have to respect that.  In addition, IFrames also use the
//                default security manager unless they have
//                "application='yes'". This puts dialogs in line with HTA
//                content. This affects all trusted dialogs, including those
//                used by editing.
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::ProcessUrlAction(
                        LPCWSTR     pwszUrl,
                        DWORD       dwAction,
                        BYTE*   pPolicy,    // output buffer pointer
                        DWORD   cbPolicy,   // output buffer size
                        BYTE*   pContext,   // context (used by the delegation routines)
                        DWORD   cbContext,  // size of the Context
                        DWORD   dwFlags,    // See enum PUAF for details.
                        DWORD   dwReserved)
{

    // Normal HTML dialogs: Allow everything in trusted scenarios; need to
    // return special code for Java permissions.  Note we can't allow Java if
    // the size of the context is smaller than a DWORD, since allowable values
    // are all DWORDs.

    if (dwFlags & PUAF_ENFORCERESTRICTED || (!(dwFlags & PUAF_TRUSTED)))
        return INET_E_DEFAULT_ACTION;
    else if (cbPolicy == sizeof(DWORD))
        *(DWORD*)pPolicy = ( (dwAction == URLACTION_JAVA_PERMISSIONS) ? URLPOLICY_JAVA_HIGH : URLPOLICY_ALLOW );
    else if (cbPolicy == sizeof(WORD))
        *(WORD*)pPolicy = URLPOLICY_ALLOW;
    else // BYTE or unknown type
        *pPolicy = URLPOLICY_ALLOW;

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::GetSecurityID
//
//    Implementation of IInternetSecurityManager::GetSecurityID
//
//  Synopsis:   Retrieves the Security Identification of the given URL
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::GetSecurityId( 
            LPCWSTR pwszUrl,
            BYTE __RPC_FAR *pbSecurityId,
            DWORD __RPC_FAR *pcbSecurityId,
            DWORD_PTR dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::SetZoneMapping
//
//    Implementation of IInternetSecurityManager::SetZoneMapping
//
//  Synopsis:   Sets the mapping of a Zone
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::SetZoneMapping  (
                    DWORD   dwZone,        // absolute zone index
                    LPCWSTR lpszPattern,   // URL pattern with limited wildcarding
                    DWORD   dwFlags       // add, change, delete
)
{
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::QueryCustomPolicy
//
//    Implementation of IInternetSecurityManager::QueryCustomPolicy
//
//  Synopsis:   Retrieves the custom policy associated with the URL and
//                specified key in the given context
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::QueryCustomPolicy (
                        LPCWSTR     pwszUrl,
                        REFGUID     guidKey,
                        BYTE**  ppPolicy,   // pointer to output buffer pointer
                        DWORD*  pcbPolicy,  // pointer to output buffer size
                        BYTE*   pContext,   // context (used by the delegation routines)
                        DWORD   cbContext,  // size of the Context
                        DWORD   dwReserved )
 {
    return INET_E_DEFAULT_ACTION;
 }
                        
//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlgSite::GetZoneMappings
//
//    Implementation of IInternetSecurityManager::GetZoneMapping
//
//  Synopsis:   Sets the mapping of a Zone
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlgSite::GetZoneMappings (
                    DWORD   dwZone,        // absolute zone index
                    IEnumString  **ppenumString,   // output buffer size
                    DWORD   dwFlags        // reserved, pass 0
)
{
    return INET_E_DEFAULT_ACTION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmlapp\server.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       server.cxx
//
//  Contents:   implementation of server object
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_SERVER_HXX_
#define X_SERVER_HXX_
#include "server.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include "mshtmhst.h"
#endif

#ifndef X_MISC_HXX_
#define X_MISC_HXX_
#include "misc.hxx"
#endif

CServerObject::CServerObject(CHTMLApp *pApp)
    : _pApp(pApp), _ulRefs(0)
{
}

HRESULT CServerObject::QueryInterface(REFIID riid, void ** ppv)
{
    if (!ppv)
        return E_POINTER;

    *ppv = NULL;

    if (riid == IID_IUnknown || riid == IID_IPersistMoniker)
    {
        *ppv = (IPersistMoniker *)this;
    }
    else if (riid == IID_IOleObject)
    {
        *ppv = (IOleObject *)this;
    }

    if (*ppv)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

HRESULT CServerObject::GetClassID(CLSID *pClsid)
{
    return CLSIDFromString(SZ_SERVER_CLSID, pClsid);
}

HRESULT CServerObject::IsDirty()
{
    return E_NOTIMPL;
}

HRESULT CServerObject::Load(BOOL fFullyAvailable, IMoniker * pmk, LPBC pbc, DWORD grfMode)
{
    HRESULT hr = THR(_pApp->RunHTMLApplication(pmk));
    RRETURN(hr);
}

HRESULT CServerObject::Save(IMoniker * pmk, LPBC pbc, BOOL fRemember)
{
    return E_NOTIMPL;
}

HRESULT CServerObject::SaveCompleted(IMoniker * pmk, LPBC pbc)
{
    return E_NOTIMPL;
}

HRESULT CServerObject::GetCurMoniker(IMoniker ** ppmk)
{
    return E_NOTIMPL;
}


// IOleObject methods

HRESULT CServerObject::SetClientSite(IOleClientSite *)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::GetClientSite(IOleClientSite **)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::SetHostNames(LPCOLESTR, LPCOLESTR)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::Close(DWORD)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::SetMoniker(DWORD , IMoniker *)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::GetMoniker(DWORD, DWORD, IMoniker **)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::InitFromData(IDataObject *, BOOL, DWORD)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::GetClipboardData(DWORD, IDataObject **)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::DoVerb(LONG, LPMSG, IOleClientSite *, LONG, HWND, LPCOLERECT)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::EnumVerbs(IEnumOLEVERB **)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::Update()
{
    return E_NOTIMPL;
}


HRESULT CServerObject::IsUpToDate()
{
    return E_NOTIMPL;
}


HRESULT CServerObject::GetUserClassID(CLSID *)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::GetUserType(DWORD, LPOLESTR *)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::SetExtent(DWORD, SIZEL *)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::GetExtent(DWORD, SIZEL *)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::Advise(IAdviseSink *, DWORD *)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::Unadvise(DWORD)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::EnumAdvise(IEnumSTATDATA **)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::GetMiscStatus(DWORD, DWORD *)
{
    return E_NOTIMPL;
}


HRESULT CServerObject::SetColorScheme(LOGPALETTE  *pLogpal)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmlapp\site.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       client.cxx
//
//  Contents:   implementation of OLE site.
//
//  Created:    02/20/98    philco
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_APP_HXX_
#define X_APP_HXX_
#include "app.hxx"
#endif

#ifndef X_MISC_HXX_
#define X_MISC_HXX_
#include "misc.hxx"
#endif

#ifndef X_MSHTMCID_H_
#define X_MSHTMCID_H_
#include "mshtmcid.h"
#endif

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h"
#endif

#ifndef X_FRMSITE_H_
#define X_FRMSITE_H_
#include "frmsite.h"
#endif

#ifndef X_THEMEHLP_H_
#define X_THEMEHLP_H_
#include "themehlp.hxx"
#endif

#define SID_SElementBehaviorFactory IID_IElementBehaviorFactory

EXTERN_C UINT  DragQueryFileWrapW(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch);

//+-------------------------------------------------------------------------
//
//  Method:     CClient::QueryInterface
//
//  Synopsis:   Per IUnknown
//
//--------------------------------------------------------------------------

HRESULT CClient::QueryInterface(REFIID riid, void ** ppv)
{
    if (!ppv)
        return E_POINTER;

    *ppv = NULL;

    if (riid == IID_IUnknown || riid == IID_IOleClientSite)
        *ppv = (IOleClientSite *)this;
    else if (riid == IID_IOleCommandTarget)
        *ppv = (IOleCommandTarget *) this;
    else if (riid == IID_IOleWindow)
        *ppv = (IOleWindow *) this;
    else if (riid == IID_IOleInPlaceSite)
        *ppv = (IOleInPlaceSite *) this;
    else if (riid == IID_IOleDocumentSite)
        *ppv = (IOleDocumentSite *) this;
    else if (riid == IID_IAdviseSink)
        *ppv = (IAdviseSink *) this;
    else if (riid == IID_IServiceProvider)
        *ppv = (IServiceProvider *) this;
    else if (riid == IID_IInternetSecurityManager)
        *ppv = (IInternetSecurityManager *) this ;
    else if (riid == IID_IDocHostUIHandler)
        *ppv = (IDocHostUIHandler *) this ;
    else if (riid == IID_IDocHostShowUI)
        *ppv = (IDocHostShowUI *) this ;
    else if (riid == IID_IHTMLOMWindowServices)
        *ppv = (IHTMLOMWindowServices *) this;
    else if (riid == IID_IDropTarget)
        *ppv = (IDropTarget *) this;
    
    if (*ppv)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


/* IOleClientSite methods */

//+-------------------------------------------------------------------------
//
//  Method:     CClient::SaveObject
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

HRESULT CClient::SaveObject()
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::GetMoniker
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

HRESULT CClient::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR * ppmk)
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::GetContainer
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

HRESULT CClient::GetContainer(LPOLECONTAINER FAR * ppContainer)
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::ShowObject
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

HRESULT CClient::ShowObject()
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnShowWindow
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

HRESULT CClient::OnShowWindow(BOOL fShow)
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::RequestNewObjectLayout
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

HRESULT CClient::RequestNewObjectLayout()
{
    return E_NOTIMPL;
}


HRESULT CClient::QueryStatus(const GUID * pguidCmdGroup, ULONG cCmds,
        MSOCMD rgCmds[], MSOCMDTEXT * pcmdtext)
{
    if (pguidCmdGroup != NULL)
        return (OLECMDERR_E_UNKNOWNGROUP);

    MSOCMD *    pCmd;
    INT         c;
    HRESULT     hr = S_OK;

    // Loop through each command in the ary, setting the status of each.
    for (pCmd = rgCmds, c = cCmds; --c >= 0; pCmd++)
    {
        // By default command status is NOT SUPPORTED.
        pCmd->cmdf = 0;

        switch (pCmd->cmdID)
        {
        case OLECMDID_ALLOWUILESSSAVEAS:
            pCmd->cmdf = MSOCMDSTATE_UP;
            break;
        }
    }

    RRETURN(hr);
}

HRESULT CClient::Exec(const GUID * pguidCmdGroup, DWORD nCmdID,
        DWORD nCmdexecopt, VARIANTARG * pvarargIn, VARIANTARG * pvarargOut)
{
    HRESULT hr = S_OK;

    if ( ! pguidCmdGroup )
    {
        switch (nCmdID)
        {
        case OLECMDID_SETTITLE:
            if (pvarargIn && V_VT(pvarargIn) == VT_BSTR)
            {
                App()->SetTitle(V_BSTR(pvarargIn));
            }
            else
            {
                hr = OLECMDERR_E_NOTSUPPORTED;
            }
            break;

        case OLECMDID_CLOSE:
            App()->Close();
            break;
            
        default:
            hr = OLECMDERR_E_NOTSUPPORTED;
            break;
        }
    }
    else if (pguidCmdGroup && IsEqualGUID(CGID_MSHTML,*pguidCmdGroup ))
    {
        switch (nCmdID)
        {
            case IDM_PARSECOMPLETE:

                // Document is fully parsed. Show the application window.
                //
                if (!theApp.isLoaded() && !theApp.isBusy())
                {
                    theApp.FinalInit();
                }
                
                break;
                
            default:
                hr = OLECMDERR_E_NOTSUPPORTED;
                break;
        }
    }
    else
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;
    }

    RRETURN(hr);
}


/* IOleWindow methods */

//+-------------------------------------------------------------------------
//
//  Method:     CClient::GetWindow
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

HRESULT CClient::GetWindow(HWND FAR *lpHwnd)
{
    HRESULT hr = S_OK;
    
    if (!lpHwnd)
        return E_POINTER;
    
    *lpHwnd = App()->_hwnd;
    
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::ContextSensitiveHelp
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

HRESULT CClient::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}


/* IOleInPlaceSite methods */

//+-------------------------------------------------------------------------
//
//  Method:     CClient::CanInPlaceActivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

HRESULT CClient::CanInPlaceActivate()
{
    HRESULT hr = S_OK;
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnInPlaceActivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

HRESULT CClient::OnInPlaceActivate()
{
    HRESULT hr = S_OK;
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnUIActivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

HRESULT CClient::OnUIActivate()
{
    HRESULT hr = S_OK;
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::GetWindowContext
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

HRESULT CClient::GetWindowContext(
                    LPOLEINPLACEFRAME FAR* lplpFrame,
                    LPOLEINPLACEUIWINDOW FAR* lplpDoc,
                    LPOLERECT lprcPosRect,
                    LPOLERECT lprcClipRect,
                    LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    HRESULT hr = S_OK;

    CHTMLAppFrame *pFrame = Frame();
    Assert(pFrame);
    
    *lplpFrame = (LPOLEINPLACEFRAME)pFrame;
    *lplpDoc = (LPOLEINPLACEUIWINDOW)pFrame;

    App()->GetViewRect(lprcPosRect);
    *lprcClipRect = *lprcPosRect;

    // Nothing much interesting in this struct.  We don't have any
    // menus or accelerators.
    Assert(lpFrameInfo->cb >= sizeof(OLEINPLACEFRAMEINFO));
    lpFrameInfo->fMDIApp = FALSE ;
    lpFrameInfo->hwndFrame = App()->_hwnd ;
    lpFrameInfo->haccel = 0 ;
    lpFrameInfo->cAccelEntries = 0 ;

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::Scroll
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

HRESULT CClient::Scroll(OLESIZE scrollExtent)
{
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnUIActivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

HRESULT CClient::OnUIDeactivate(BOOL fUndoable)
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnInPlaceDeactivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

HRESULT CClient::OnInPlaceDeactivate()
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::DiscardUndoState
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

HRESULT CClient::DiscardUndoState()
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::DeactivateAndUndo
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

HRESULT CClient::DeactivateAndUndo()
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnPosRectChange
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

HRESULT CClient::OnPosRectChange(LPCOLERECT lprcPosRect)
{
    return E_NOTIMPL;
}

                    
/* IOleDocumentSite methods */

//+-------------------------------------------------------------------------
//
//  Method:     CClient::ActivateMe
//
//  Synopsis:   Per IOleDocumentSite
//
//--------------------------------------------------------------------------

HRESULT CClient::ActivateMe(IOleDocumentView * pViewToActivate)
{
    HRESULT hr = S_OK;
    
    // TODO: if pViewToActivate is null, call CreateView.
    ReleaseInterface(_pView);

    _pView = pViewToActivate;
    if (_pView)
    {
        // We're going to hold on to this, so AddRef it.
        _pView->AddRef();

        hr = _pView->SetInPlaceSite(this);
        TEST(hr);
        
        hr = _pView->UIActivate(TRUE);
        TEST(hr);
        
        hr = _pView->Show(TRUE);
        TEST(hr);
    }
    
Cleanup:

    RRETURN(hr);
}


/* IAdviseSink methods */

//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnDataChange
//
//  Synopsis:   Per IAdviseSink
//
//--------------------------------------------------------------------------

void CClient::OnDataChange(FORMATETC * pFormatetc, STGMEDIUM * pmedium)
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnViewChange
//
//  Synopsis:   Per IAdviseSink
//
//--------------------------------------------------------------------------

void CClient::OnViewChange(DWORD dwAspect, long lindex)
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnRename
//
//  Synopsis:   Per IAdviseSink
//
//--------------------------------------------------------------------------

void CClient::OnRename(LPMONIKER pmk)
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnSave
//
//  Synopsis:   Per IAdviseSink
//
//--------------------------------------------------------------------------

void CClient::OnSave()
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::OnClose
//
//  Synopsis:   Per IAdviseSink
//
//--------------------------------------------------------------------------

void CClient::OnClose()
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CClient::QueryService
//
//  Synopsis:   Per IServiceProvider
//
//--------------------------------------------------------------------------

HRESULT CClient::QueryService(REFGUID guidService, REFIID riid, void ** ppv)
{
    HRESULT hr = E_FAIL;

    if (!ppv)
        return E_POINTER;

    *ppv = NULL;
    
    if (IsEqualGUID(guidService, SID_SElementBehaviorFactory))
    {
        *ppv = &App()->_PeerFactory;
        ((IUnknown *)*ppv)->AddRef();
        hr = S_OK;
    }
    else if (IsEqualGUID(guidService, IID_IInternetSecurityManager) ||
             IsEqualGUID(guidService, IID_IHTMLOMWindowServices))
    {
        hr = QueryInterface(riid, ppv);
    }

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CClient::SetSecuritySite
//
//  Synopsis:   Per IInternetSecurityManager
//
//-------------------------------------------------------------------------

HRESULT
CClient::SetSecuritySite(IInternetSecurityMgrSite *pSite)
{
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CClient::GetSecuritySite
//
//  Synopsis:   Per IInternetSecurityManager
//
//-------------------------------------------------------------------------

HRESULT
CClient::GetSecuritySite(IInternetSecurityMgrSite **ppSite)
{
    *ppSite = NULL;
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CClient::MapURLToZone
//
//  Synopsis:   Per IInternetSecurityManager
//
//-------------------------------------------------------------------------

HRESULT
CClient::MapUrlToZone(LPCWSTR pwszUrl, DWORD* pdwZone, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}
                    
//+------------------------------------------------------------------------
//
//  Member:     CClient::ProcessURLAction
//
//  Synopsis:   Per IInternetSecurityManager.  Return URLPOLICY_ALLOW for
//              most actions if this comes from a trusted source.  Security is 
//              disabled in this context.
//
//-------------------------------------------------------------------------

HRESULT
CClient::ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE* pPolicy, DWORD cbPolicy,
                          BYTE* pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved)
{
    DWORD dwPolicy = URLPOLICY_ALLOW;
    DWORD *pdw = (DWORD *)pPolicy;
    HRESULT hr = S_OK;
    
    // If this is not coming from a trusted source, do default.
    if (!(dwFlags & PUAF_TRUSTED))
    {
        return INET_E_DEFAULT_ACTION;
    }
    
    // Policies are DWORD values, so we need at least 4 bytes.
    if (cbPolicy < sizeof(DWORD))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    switch(dwAction)
    {
        case URLACTION_CREDENTIALS_USE:
        case URLACTION_AUTHENTICATE_CLIENT:
        case URLACTION_JAVA_PERMISSIONS:
        case URLACTION_CHANNEL_SOFTDIST_PERMISSIONS:
            {
                IInternetSecurityManager *pism = NULL;
                hr = CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER,
                                      IID_IInternetSecurityManager, (void**)&pism);
                if (SUCCEEDED(hr) && pism)
                {
                    hr = pism->ProcessUrlAction(pwszUrl,
                                                dwAction,
                                                pPolicy,
                                                cbPolicy,
                                                pContext,
                                                cbContext,
                                                dwFlags,
                                                dwReserved);
                    pism->Release();
                    return hr;
                }
            }
            break;
    }

    if (dwPolicy != URLPOLICY_ALLOW)
        hr = S_FALSE;
        
    // we know pPolicy points to a buffer that can contain a DWORD. I'd really like to use:
    // *((DWORD *)pPolicy) = dwPolicy;   but that is illegal in C++.  Can't cast the left
    // side of an assignment.

    *pdw = dwPolicy;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CClient::GetSecurityID
//
//  Synopsis:   Per IInternetSecurityManager
//
//-------------------------------------------------------------------------

HRESULT
CClient::GetSecurityId(LPCWSTR pwszUrl, BYTE __RPC_FAR *pbSecurityId,
                       DWORD __RPC_FAR *pcbSecurityId, DWORD_PTR dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CClient::SetZoneMapping
//
//  Synopsis:   Per IInternetSecurityManager
//
//-------------------------------------------------------------------------

HRESULT
CClient::SetZoneMapping  (DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CClient::QueryCustomPolicy
//
//  Synopsis:   Per IInternetSecurityManager
//
//-------------------------------------------------------------------------

HRESULT
CClient::QueryCustomPolicy (LPCWSTR pwszUrl, REFGUID guidKey, BYTE** ppPolicy,
                            DWORD* pcbPolicy, BYTE* pContext, DWORD cbContext,
                            DWORD dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}
                        
//+------------------------------------------------------------------------
//
//  Member:     CClient::GetZoneMappings
//
//  Synopsis:   Per IInternetSecurityManager
//
//-------------------------------------------------------------------------

HRESULT
CClient::GetZoneMappings (DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT
CClient::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
    HRESULT hr = S_OK;

    Assert(pInfo);
    if (pInfo->cbSize < sizeof(DOCHOSTUIINFO))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pInfo->dwFlags = theApp.GetHostInfoFlags();
    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;

    pInfo->pchHostCss = (OLECHAR *)CoTaskMemAlloc(sizeof(SZ_APPLICATION_BEHAVIORCSS)+1);
    if ( !pInfo->pchHostCss )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    pInfo->pchHostNS = (OLECHAR *)CoTaskMemAlloc(sizeof(SZ_APPLICATION_BEHAVIORNAMESPACE)+1);
    if ( !pInfo->pchHostNS )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    StrCpyW(pInfo->pchHostCss, SZ_APPLICATION_BEHAVIORCSS);
    StrCpyW(pInfo->pchHostNS, SZ_APPLICATION_BEHAVIORNAMESPACE);

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CClient::ShowContextMenu
//
//  Synopsis:   Called by Trident when its about to show its context menu.
//
//  Returns:    S_OK to disable context menu
//              S_FALSE to allow Trident to show its context menu
//
//-------------------------------------------------------------------------
HRESULT
CClient::ShowContextMenu(DWORD dwID, POINT * pptPosition,
                         IUnknown * pcmdtReserved,
                         IDispatch * pDispatchObjectHit)
{
    if (!theApp.contextMenu())
       return S_OK;

    return S_FALSE;
}

HRESULT
CClient::GetExternal(IDispatch ** ppDisp)
{
    if (!ppDisp)
        return E_POINTER;

    *ppDisp = NULL;
    return S_OK;
}

HRESULT
CClient::ShowMessage(HWND hwnd, LPOLESTR lpstrText, LPOLESTR lpstrCaption,
            DWORD dwType, LPOLESTR lpstrHelpFile, DWORD dwHelpContext, LRESULT *plResult)
{
    TCHAR szBuf[512];
    int iReturn = GetWindowText(App()->_hwnd, szBuf, ARRAY_SIZE(szBuf));

    // GetWindowText will return zero if there is no window text, or upon failure.  Rather
    // than have a blank title for this message box, default to "HTML Application".
    
    ULONG_PTR dwfTheme = 0;
    
    if (IsAppThemed())    
    {           
        SHActivateContext(&dwfTheme);
    }    

    if (iReturn)
        iReturn = MessageBox(hwnd, lpstrText, szBuf, dwType);
    else
        iReturn = MessageBox(hwnd, lpstrText, _T("HTML Application"), dwType);

    if (dwfTheme != 0)
        SHDeactivateContext(dwfTheme);

    if (plResult)
        *plResult = iReturn;
        
    return (iReturn ? S_OK : S_FALSE);
}


//==================================================================
//  method implementatiosn for IHTMLOMWindowServices
//
//  this interface is used by the hta to implement the window sevices
//  that COmWindow delagates to. e.g .moveTo, resizeby
//
//==================================================================


//+-----------------------------------------------------
//      per IHTMLOMWindowServices
//-------------------------------------------------------
HRESULT
CClient::moveTo(long x, long y)
{
    HRESULT  hr;
    RECT     rect;
    HWND     hwnd= App()->_hwnd;
    
    // If the main window hasn't been created yet (or hasn't yet been made visible) - 
    // remember the new size and apply it when the window is made visible.
    if (!IsWindow(hwnd) || !IsWindowVisible(hwnd))
    {
        hr = App()->Pending_moveTo(x,y);
        goto Cleanup;
    }

    if (!GetWindowRect(hwnd, &rect))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // adjust to the requested position
    rect.bottom = rect.bottom-rect.top + y;
    rect.right  = rect.right-rect.left + x;
    rect.top = y;
    rect.left = x;

    // now we've the go-ahead to actually set the position
    hr = (SetWindowPos(hwnd,
                 NULL, 
                 rect.left, 
                 rect.top, 
                 rect.right-rect.left, 
                 rect.bottom-rect.top, 
                 SWP_NOZORDER | SWP_SHOWWINDOW )) ? 
            S_OK : E_FAIL;

Cleanup:
    return hr;
}

//+-----------------------------------------------------
//      per IHTMLOMWindowServices
//-------------------------------------------------------
HRESULT
CClient::moveBy(long x, long y)
{
    HRESULT  hr;
    RECT     rect;
    HWND     hwnd= App()->_hwnd;

    // If the main window hasn't been created yet (or hasn't yet been made visible) - 
    // remember the new size and apply it when the window is made visible.
    if (!IsWindow(hwnd) || !IsWindowVisible(hwnd))
    {
        hr = App()->Pending_moveBy(x,y);
        goto Cleanup;
    }

    // If the window has been created, but we can't get the rect, something
    // is badly wrong.  Fail this call.
    if (!GetWindowRect(hwnd, &rect))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // adjust to the requested position
    rect.bottom += y;
    rect.right  += x;
    rect.top += y;
    rect.left += x;

    // do we actually need to even move?
    hr = (SetWindowPos(hwnd,
                 NULL, 
                 rect.left, 
                 rect.top, 
                 rect.right-rect.left, 
                 rect.bottom-rect.top, 
                 SWP_NOZORDER | SWP_SHOWWINDOW )) ? 
            S_OK : E_FAIL;

Cleanup:
    return hr;
}

//+-----------------------------------------------------
//      per IHTMLOMWindowServices
//-------------------------------------------------------
HRESULT
CClient::resizeTo(long x, long y)
{
    HRESULT  hr;
    RECT     rect;
    HWND     hwnd= App()->_hwnd;

    // If the main window hasn't been created yet (or hasn't yet been made visible) - 
    // remember the new size and apply it when the window is made visible.
    if (!IsWindow(hwnd) || !IsWindowVisible(hwnd))
    {
        hr = App()->Pending_resizeTo(x,y);
        goto Cleanup;
    }

    // get the current window rect
    if (!GetWindowRect(hwnd, &rect))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // adjust to the requested Size 
    rect.bottom = rect.top + y;
    rect.right  = rect.left + x;

    // set our new size
    hr = (SetWindowPos(hwnd,
                 NULL, 
                 rect.left, 
                 rect.top, 
                 rect.right-rect.left, 
                 rect.bottom-rect.top, 
                 SWP_NOZORDER | SWP_SHOWWINDOW )) ? 
            S_OK : E_FAIL;

Cleanup:
    return hr;
}

//+-----------------------------------------------------
//      per IHTMLOMWindowServices
//-------------------------------------------------------
HRESULT
CClient::resizeBy(long x, long y)
{
    HRESULT hr;
    RECT    rect;
    HWND    hwnd = App()->_hwnd;

    // If the main window hasn't been created yet (or hasn't yet been made visible) - 
    // remember the new size and apply it when the window is made visible.
    if (!IsWindow(hwnd) || !IsWindowVisible(hwnd))
    {
        hr = App()->Pending_resizeBy(x,y);
        goto Cleanup;
    }


    // If the window has been created, but we can't get the rect, something
    // is badly wrong.  Fail this call.
    if (!GetWindowRect(hwnd, &rect))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // adjust to the requested Size 
    rect.bottom += y;
    rect.right  += x;

    // set our new size
    hr = (SetWindowPos(hwnd,
                 NULL, 
                 rect.left, 
                 rect.top, 
                 rect.right-rect.left, 
                 rect.bottom-rect.top, 
                 SWP_NOZORDER | SWP_SHOWWINDOW )) ? 
            S_OK : E_FAIL;

Cleanup:
    return hr;
}

HRESULT
CClient::DragEnter(
            LPDATAOBJECT pDataObj,
            DWORD grfKeyState,
            POINTL pt,
            LPDWORD pdwEffect)
{
    Assert(_pDT && pDataObj && pdwEffect);
    
    _pDT->DragEnter(pDataObj, grfKeyState, pt, pdwEffect);
    
    if (*pdwEffect == DROPEFFECT_NONE && DropAllowed(pt))    
    {
        *pdwEffect = DROPEFFECT_LINK;
    }
    
    return S_OK;
}

HRESULT
CClient::DragOver(DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect)
{
    Assert(_pDT && pdwEffect);
    
    _pDT->DragOver(grfKeyState, pt, pdwEffect);
    
    if (*pdwEffect == DROPEFFECT_NONE && DropAllowed(pt))    
    {
        *pdwEffect = DROPEFFECT_LINK;
    }
    
    return S_OK;
}

HRESULT
CClient::DragLeave(void)
{
    return _pDT->DragLeave();
}


HRESULT
CClient::Drop(LPDATAOBJECT pDataObj,
            DWORD grfKeyState,
            POINTL pt,
            LPDWORD pdwEffect)
{
    Assert(pDataObj && pdwEffect);

    HRESULT hr = S_OK;

    IEnumFORMATETC *pFormatEtc = NULL;
    IHTMLWindow2   *pOMWindow2 = NULL;
    
    if (DropAllowed(pt))
    {
        hr = pDataObj->EnumFormatEtc(DATADIR_GET, &pFormatEtc);

        if (OK(hr))
        {
            ULONG cEltFetched = 0;
            FORMATETC fmtetcEnum;
            while(SUCCEEDED(pFormatEtc->Next(1, &fmtetcEnum, &cEltFetched)) && (cEltFetched > 0))
            {
                if (fmtetcEnum.cfFormat == CF_HDROP || fmtetcEnum.cfFormat == g_rgFETC[iUniformResourceLocator].cfFormat)
                {
                    STGMEDIUM stgmed;

                    hr = THR(pDataObj->GetData(&fmtetcEnum, &stgmed));
                    if(OK(hr))
                    {
                        HDROP hdrop = (HDROP)GlobalLock(stgmed.hGlobal);

                        if (NULL != hdrop)
                        {
                            TCHAR szUrl[_MAX_PATH + 1];
                            ZeroMemory(szUrl, ARRAY_SIZE(szUrl));

                            if (fmtetcEnum.cfFormat == CF_HDROP)
                            {
                                // Only take the first filename (in case of multi-select files)
#if !defined(_AMD64_) && !defined(_IA64_)
                                DragQueryFile(hdrop, 0, (LPTSTR) szUrl, ARRAY_SIZE(szUrl));
#else
                                DragQueryFileWrapW(hdrop, 0, szUrl, ARRAY_SIZE(szUrl));
#endif
                                // if this is an internet shortcut (*.url), need to retrieve the URL
                                if (!StrCmpI(PathFindExtension(szUrl), _T(".URL")))
                                {
                                    IPersistFile *ppf = NULL;
                                    if (SUCCEEDED(CoCreateInstance(CLSID_InternetShortcut, NULL, 
                                        CLSCTX_ALL, IID_IPersistFile, (void **) &ppf)))
                                    {
                                        if (SUCCEEDED(ppf->Load(szUrl, STGM_READ)))
                                        {
                                            IUniformResourceLocatorW *pUrl;
                                            LPTSTR pszUrl = NULL;
                                            if (SUCCEEDED(ppf->QueryInterface(IID_IUniformResourceLocator,
                                                (void **) &pUrl)))
                                            {
                                                hr = pUrl->GetURL(&pszUrl);
                                                StrCpyN(szUrl, pszUrl, ARRAY_SIZE(szUrl));
                                                CoTaskMemFree(pszUrl);
                                                ReleaseInterface(pUrl);
                                            }
                                        }
                                        ReleaseInterface(ppf);
                                    }
                                }
                            }
                            else
                            {
                                // hdrop points to an ANSI string.  Need to convert to UNICODE.
                                MultiByteToWideChar(CP_ACP, 0, (LPCSTR)hdrop, _MAX_PATH, szUrl, _MAX_PATH);
                            }

                            GlobalUnlock(hdrop);

                            // Trident will never get a DragLeave call since we navigate away here.
                            _pDT->DragLeave();
                            
                            // And away we go...
                            hr = WindowObjectFromPoint(pt, &pOMWindow2);

                            if (OK(hr) && pOMWindow2)
                                hr = pOMWindow2->navigate(szUrl);
                        }
                        ReleaseStgMedium(&stgmed);
                    }
                    goto Cleanup;
                }
            }
        }
    }
    
    // Give trident a chance to handle the drop
    if (_pDT)
        hr = THR(_pDT->Drop(pDataObj, grfKeyState, pt, pdwEffect));

Cleanup:
    ReleaseInterface(pFormatEtc);
    ReleaseInterface(pOMWindow2);
    RRETURN(hr);
}


BOOL CClient::DropAllowed(POINTL pt)
{
    IHTMLElement *pOMElement = NULL;   // Not used here, but required by ElementIsFrame().
    BOOL fRet = FALSE;
    
    // Always allow drops onto frame/iframe elements.  Otherwise, allow only if top-level 
    // navigation is permitted and this isn't a self-drag.
    if (ElementIsFrame(pt, &pOMElement) || 
            (!SelfDragging() && App()->GetHostInfoFlags() & DOCHOSTUIFLAG_ENABLE_INPLACE_NAVIGATION))
    {
        fRet = TRUE;
    }

    ReleaseInterface(pOMElement);
    return fRet;
}


BOOL
CClient::ElementIsFrame(POINTL pt, IHTMLElement **ppOMElement)
{
    IHTMLDocument2 *pOMDocument = NULL;
    IHTMLElement   *pOMElement = NULL;
    IHTMLElement   *pFrameBase2 = NULL;
    BOOL    fRet = FALSE;
    HRESULT hr;
    CPoint cpt(pt.x, pt.y);
    
    Assert(ppOMElement);
    
    hr = THR(GetService(SID_SContainerDispatch, IID_IHTMLDocument2, (void **)&pOMDocument));
    if (hr)
        goto Cleanup;

    // Need to convert to client coordinate system
    ScreenToClient(App()->_hwnd, &cpt);
    
    hr = THR(pOMDocument->elementFromPoint(cpt.x, cpt.y, &pOMElement));
    if (hr)
        goto Cleanup;

    // If this element implements IHTMLFrameBase2, it is either a frame or iframe.
    if (pOMElement && SUCCEEDED(pOMElement->QueryInterface(IID_IHTMLFrameBase2, (void **)&pFrameBase2)))
    {
        ReplaceInterface(ppOMElement, pOMElement);
        fRet = TRUE;
    }

Cleanup:
    ReleaseInterface(pOMDocument);
    ReleaseInterface(pOMElement);
    ReleaseInterface(pFrameBase2);
    return fRet;
}


HRESULT
CClient::WindowObjectFromPoint(POINTL pt, IHTMLWindow2 **ppOMWindow2)
{
    IHTMLDocument2  *pOMDocument = NULL;
    IHTMLElement    *pOMElement = NULL;
    IHTMLFrameBase2 *pFrameBase2 = NULL;
    HRESULT hr = E_FAIL;
    
    Assert(ppOMWindow2);
    
    if (ElementIsFrame(pt, &pOMElement))
    {
        Assert(pOMElement);
        // dropped either a frame or iframe.  Get that window object.
        if (SUCCEEDED(pOMElement->QueryInterface(IID_IHTMLFrameBase2, (void **)&pFrameBase2)))
            hr = THR(pFrameBase2->get_contentWindow(ppOMWindow2));
    }
    else
    {
        hr = THR(GetService(SID_SContainerDispatch, IID_IHTMLDocument2, (void **)&pOMDocument));
        Assert(pOMDocument);

        if (SUCCEEDED(hr) && pOMDocument)
        {
            // dropped on top-level content.  Get that window object.
            hr = THR(pOMDocument->get_parentWindow(ppOMWindow2));
        }
    }

    ReleaseInterface(pOMDocument);
    ReleaseInterface(pOMElement);
    ReleaseInterface(pFrameBase2);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmldlg\makefile.inc ===
!include $(ROOT)\commonmk.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmldlg\htmldlg.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       htmldlg.cxx
//
//  Contents:   Implementation of the dlg xobject for hosting html dialogs
//
//  History:    06-14-96  AnandRa   Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_ROSTM_HXX_
#define X_ROSTM_HXX_
#include "rostm.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_COMMIT_HXX_
#define X_COMMIT_HXX_
#include "commit.hxx"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include "dispex.h"
#endif

#ifndef X_COREDISP_H_
#define X_COREDISP_H_
#include <coredisp.h>
#endif

#ifndef X_OPTSHOLD_HXX_
#define X_OPTSHOLD_HXX_
#include "optshold.hxx"
#endif

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#include <shellapi.h>
#endif

#ifndef X_MULTIMON_H_
#define X_MULTIMON_H_
#include "multimon.h"
#endif

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

#ifndef X_RESPROT_HXX_
#define X_RESPROT_HXX_
#include "resprot.hxx"
#endif

#ifndef X_FUNCSIG_HXX_
#define X_FUNCSIG_HXX_
#include "funcsig.hxx"
#endif

#ifdef UNIX
#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include <mshtmlrc.h>
#endif

#include <mainwin.h>

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#define WINCOMMCTRLAPI
#include <commctrl.h>
#endif

#include "unixmodeless.hxx"
#endif

// TODO: (anandra) Try to get rid of all this stuff below.

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_MARKUP_HXX_
#define X_MARKUP_HXX_
#include "markup.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"    // for MAKEUNITVALUE macro.
#endif

#ifndef X_CFPF_HXX_
#define X_CFPF_HXX_
#include "cfpf.hxx"     // for propdesc components
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"    // for CSSParser
#endif

#ifndef X_HTIFACE_H_
#define X_HTIFACE_H_
#include "htiface.h"    // for FRAMEOPTIONS_FOO
#endif

#ifndef X_MSHTMCID_H_
#define X_MSHTMCID_H_
#include "mshtmcid.h"
#endif

#ifndef X_PUTIL_HXX_
#define X_PUTIL_HXX_
#include "putil.hxx"    // For firing print template events
#endif

#define MAX_NUM_ZONES_ICONS         12

HICON g_arhiconZones[MAX_NUM_ZONES_ICONS] = {0};

#define DIALOG_MIN_WIDTH    100     // in pixel
#define DIALOG_MIN_HEIGHT   100     // in pixel

// 220 is the width used in browser, we should in ssync with it
#define DIALOG_ZONE_WIDTH   220     // in pixel
#define DIALOG_STATUS_MIN   50      // in pixel

// True if we run on unicode operating system
extern BOOL g_fUnicodePlatform;


// Needs this for the IElementCollection interface
#ifndef X_COLLECT_H_
#define X_COLLECT_H_
#include <collect.h>
#endif

#define _cxx_
#include "htmldlg.hdl"

// this is defined in winuser.h for WINVER >= 0x0500
// We need this to compile
#if(WINVER < 0x0500)
#define WS_EX_LAYOUTRTL         0x00400000L // Right to left mirroring
#endif /* WINVER >= 0x0500 */

DeclareTag(tagHTMLDlgMethods, "HTML Dialog", "Methods on the html dialog")
DeclareTag(tagHTMLDlgHack, "HTML Dialog Hack", "Look for dlg in file system")
MtDefine(Dialogs, Mem, "Dialogs")
MtDefine(CHTMLDlg, Dialogs, "CHTMLDlg")
MtDefine(CHTMLDlg_aryDispObjs_pv, CHTMLDlg, "CHTMLDlg::_aryDispObjs::_pv")
MtDefine(CHTMLDLG_aryXObjs_pv, CHTMLDlg, "CHTMLDlg::_aryXObjs::_pv")
MtDefine(CHTMLPropPageCF, Dialogs, "CHTMLPropPageCF")
MtDefine(CHTMLDlgExtender, Dialogs, "CHTMLDlgExtender")
MtDefine(CHTMLDlgFrame, Dialogs, "CHTMLDlgFrame")

HRESULT CreateResourceMoniker(HINSTANCE hInst, TCHAR *pchRID, IMoniker **ppmk);
CODEPAGE CodePageFromString (TCHAR * pch, BOOL fLookForWordCharset);

HRESULT InternalModelessDialog(HTMLDLGINFO * pdlgInfo );

#ifdef _MAC
#ifdef __cplusplus
extern "C" {
#endif
WINBASEAPI BOOL WINAPI AfxTerminateThread(HANDLE hThread, DWORD dwExitCode);
#ifdef __cplusplus
}
#endif
#endif // _MAC


const CBase::CLASSDESC CHTMLDlg::s_classdesc =
{
    &CLSID_HTMLDialog,              // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLDialog,               // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};


//+------------------------------------------------------------------------
//
//  Member:     CHTMLPropPageCF::CHTMLPropPageCF
//
//  Synopsis:   ctor of class factory
//
//-------------------------------------------------------------------------

CHTMLPropPageCF::CHTMLPropPageCF(IMoniker *pmk) : CDynamicCF()
{
    Assert(pmk);
    _pmk = pmk;
    _pmk->AddRef();   
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLPropPageCF::~CHTMLPropPageCF
//
//  Synopsis:   dtor of class factory
//
//-------------------------------------------------------------------------

CHTMLPropPageCF::~CHTMLPropPageCF()
{
    if (_pmk)
        _pmk->Release();
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPropPageCF::CreateInstance
//
//  Synopsis:   per IClassFactory
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPropPageCF::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT                 hr;
    HTMLDLGINFO             dlginfo;    

    CEnsureThreadState ets;
    hr = ets._hr;
    if (FAILED(hr))
        goto Cleanup;

    Assert(_pmk);
   
    dlginfo.pmk             = _pmk;
    dlginfo.fPropPage       = TRUE;

    hr = THR(CHTMLDlg::CreateHTMLDlgIndirect(pUnkOuter, &dlginfo, riid, ppv));
    if (hr)
        goto Cleanup;

Cleanup:    
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CreateHTMLDlgIndirect
//
//  Synopsis:   static ctor
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlg::CreateHTMLDlgIndirect(
    IUnknown *pUnkOuter,
    HTMLDLGINFO *pdlginfo,
    REFIID riid,
    void **ppv)
{
    HRESULT     hr;
    CHTMLDlg *  pDlg = new CHTMLDlg(pUnkOuter, TRUE, NULL);

    if (!pDlg)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pDlg->Create(pdlginfo));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pDlg->PrivateQueryInterface(riid, ppv));
    if (hr)
        goto Cleanup;

Cleanup:
    if (pDlg)
    {
        pDlg->PrivateRelease();
    }
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg
//
//  Synopsis:   ctor
//
//-------------------------------------------------------------------------

CHTMLDlg::CHTMLDlg(IUnknown *pUnkOuter, BOOL fTrusted, IUnknown *pUnkHost)
         : CBase(), _aryDispObjs(Mt(CHTMLDlg_aryDispObjs_pv)), _aryXObjs(Mt(CHTMLDLG_aryXObjs_pv))
{
    TraceTag((tagHTMLDlgMethods, "constructing CHTMLDlg"));

    if (pUnkHost)
    {
        pUnkHost->QueryInterface(IID_IServiceProvider, (void **)&_pHostServiceProvider);
    }

    _aryXObjs.SetSize(0);

    // nonpropdesc member defaults. should match the pdl file
    _lDefaultFontSize = 16;
    _enumfScroll     = HTMLDlgFlagYes;
    _enumEdge        = HTMLDlgEdgeRaised;
    _enumfStatus     = HTMLDlgFlagNotSet;
    _enumfResizeable = HTMLDlgFlagNo;
    _enumfUnadorned  = HTMLDlgFlagNo;
    _enumfHide       = HTMLDlgFlagNo;
    
    _fTrusted    = fTrusted;
}


//+------------------------------------------------------------------------
//
//  Member:     ~CHTMLDlg
//
//  Synopsis:   dtor
//
//-------------------------------------------------------------------------

CHTMLDlg::~CHTMLDlg( )
{
    TraceTag((tagHTMLDlgMethods, "destroying CHTMLDlg"));

    Assert(_aryDispObjs.Size() == 0);
    Assert(_aryXObjs.Size() == 0);
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::Create
//
//  Synopsis:   Creation function the primary task here is to process the
//          dialog info structure in order to initialize the propdesc and
//          other member variables.  If we got here from formsSetmodalDialog
//          then the propdesc has already been set and most of the info-struct
//          is empty.
//
//  Arguments:  pdlginfo    Struct containing creation info
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlg::Create(HTMLDLGINFO * pdlginfo )
{
    HRESULT              hr;
    IBindCtx *           pBCtx = NULL;
    IPersistMoniker *    pPMk = NULL;
    IStream *            pStm = NULL;
    TCHAR *              pchUrl = NULL;
    TCHAR *              pchOptions;

    // Retrieve the options string.
    pchOptions = (pdlginfo->pvarOptions && VT_BSTR == V_VT(pdlginfo->pvarOptions)) ?
        V_BSTR(pdlginfo->pvarOptions) : NULL;

    if (!pdlginfo->pmk)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    else
    {
       
        _pOriginalMoniker = pdlginfo->pmk;
        _pOriginalMoniker->AddRef();
    }

    // create the doc
    hr = THR(CoCreateInstance(CLSID_HTMLDocument,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IUnknown,
                              (void **) &_pUnkObj));

    if (hr)
        goto Cleanup;

    // Set various bits on the doc: trust, printing, "in dialog" etc.
    // This must be called before setting the client site!
    hr = THR(SetFlagsOnDoc(pdlginfo));
    if (hr)
        goto Cleanup;

    // process and store incoming options
    _fPropPageMode  = pdlginfo->fPropPage;
    _fIsModeless    = pdlginfo->fModeless;
    _fVerifyRect    = (!_fTrusted) || (pdlginfo->dwFlags & HTMLDLG_VERIFY);

    hr = THR(DefaultMembers());
    if (hr)
        goto Cleanup;

    // parse the options string
    if (pchOptions && *pchOptions )
    {
        // we need an attr array to parse into.  The parser has changed.
        if (!_pAA)
        {
            _pAA = new CAttrArray;
            if ( !_pAA )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }

        CCSSParser ps(
            NULL,
            &_pAA,
            FALSE,
            FALSE, // there's no markup which we could access
            eSingleStyle,
            BaseDesc() ? BaseDesc()->_apHdlDesc : &CStyle::s_apHdlDescs,
            this);

        ps.Open();
        ps.Write( pchOptions, lstrlen( pchOptions ) );
        ps.Close();

        AAINDEX aaindex = FindAAIndex(DISPID_UNKNOWN, CAttrValue::AA_Expression);
        if (aaindex != AA_IDX_UNKNOWN)
        {
            //Expressions in showModalDialog style sheet (sFeatures) are blocked.
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    _dwFrameOptions = (_enumfScroll ? FRAMEOPTIONS_SCROLL_AUTO :
                                      FRAMEOPTIONS_SCROLL_NO) |
                       (_enumEdge);

    // Set the Window Style flag:
    _dwWS = GetAAborder() | WS_SYSMENU |
            (_enumfMin  ? WS_MINIMIZEBOX    : 0) |
            (_enumfMax  ? WS_MAXIMIZEBOX    : 0);

    _dwWSEx = WS_EX_DLGMODALFRAME | 
              ((!!_enumfHelp) ? WS_EX_CONTEXTHELP : 0);

    hr = THR(_pUnkObj->QueryInterface(IID_IOleObject, (void **) &_pOleObj));
    if (hr)
        goto Cleanup;

    hr = THR(_pOleObj->SetClientSite(&_Site));
    if (hr)
        goto Cleanup;

    hr = THR(CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, &pBCtx, 0));
    if (hr)
        goto Cleanup;

    if (pdlginfo->pMarkup)
    {
        CStr    cstrBindCtxUrl;

        cstrBindCtxUrl.Set((TCHAR *) CMarkup::GetUrl(pdlginfo->pMarkup));

        hr = THR( AddBindContextParam(pBCtx, &cstrBindCtxUrl));
        if (hr)
            goto Cleanup;
    }

    //
    // In proppage mode, just go sync because the design of IPropertyPage
    // and IPropertyPageSite are not suited for aync operation.
    //

    if (_fPropPageMode)
    {
        //
        // Special case res: and just extract stream right here.  Urlmon
        // returns a failure if you do a synchronous
        // bind to something which does not return a file.  (anandra)
        //
        hr = THR(pdlginfo->pmk->GetDisplayName(pBCtx, NULL, &pchUrl));
        if (hr)
            goto Cleanup;

        if (!StrCmpNIC(_T("res:"), pchUrl, 4))
        {
            CStr    cstrResName;
            CStr    cstrResType;
            CStr    cstrRID;
            hr = THR(CResProtocol::DoParseAndBind(
                    pchUrl,
                    cstrResName,
                    cstrResType,
                    cstrRID,
                    &pStm,
                    NULL));
        }
        else
        {
            hr = THR(pdlginfo->pmk->BindToStorage(
                    pBCtx,
                    NULL,
                    IID_IStream,
                    (void **)&pStm));
        }
        if (hr)
            goto Cleanup;

        hr = THR(LoadDocSynchronous(pStm, pchUrl));
        if (hr)
            goto Cleanup;
    }
    else
    {
        // asynchronous moniker binding
        hr = THR(_pUnkObj->QueryInterface(IID_IPersistMoniker, (void **)&pPMk));
        if (hr)
            goto Cleanup;

        hr = THR(pPMk->Load(TRUE, pdlginfo->pmk, pBCtx, STGM_READ));
        if (hr)
            goto Cleanup;
    }

    //Connect a Property Notify sink to the document so that we can catch property changes
    // which we might be interested in
    hr = THR(ConnectSink(
            _pOleObj,
            IID_IPropertyNotifySink,
            &_PNS,
            &_PNS._dwCookie));
    if (hr)
        goto Cleanup;


    // if our caller wants an initialization callback,
    // let 'em have it....
    if (   pdlginfo->dwFlags & HTMLDLG_INIT_WITH_CALLBACK
        && pdlginfo->pfnInit != NULL)
    {
        (*(pdlginfo->pfnInit))(this, pdlginfo->_cvarInitData);
    }

    _PNS._pDlg = this;

Cleanup:
    if (pchUrl)
        CoTaskMemFree(pchUrl);

    ReleaseInterface(pBCtx);
    ReleaseInterface(pPMk);
    ReleaseInterface(pStm);
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::Passivate
//
//  Synopsis:   1st stage destruction
//
//-------------------------------------------------------------------------

void
CHTMLDlg::Passivate()
{        
    if (_fPropPageMode)  
        OnClose();        
    
    if ( IsPrintingDialog() )
        FirePrintTemplateEvent(IDM_FIRE_PRINTTEMPLATEDOWN);

    //Release _pUnkObj before the VariantClear to work around OLE fault
    //Bug #69805
    ClearInterface(&_pUnkObj);
    VariantClear(&_varArgIn);

    ClearInterface(&_pOleObj);
    ClearInterface(&_pInPlaceObj);
    ClearInterface(&_pInPlaceActiveObj);
    ClearInterface(&_pPageSite);
    ClearInterface(&_pHostServiceProvider);
    ClearInterface(&_pOriginalMoniker);

    super::Passivate();
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::GetViewRect
//
//  Synopsis:   Get the rectangular extent of the window.
//
//-------------------------------------------------------------------------

void
CHTMLDlg::GetViewRect(RECT *prc)
{
    *prc = _rcView;
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::OnClose
//
//  Synopsis:   Handle the WM_CLOSE message
//
//-------------------------------------------------------------------------

LRESULT
CHTMLDlg::OnClose()
{
    TraceTag((tagHTMLDlgMethods, "OnClose"));

    HRESULT hr = THR(Deactivate());
    
    if (S_FALSE == hr)
    {
        return 0;
    }

    if (_hwndTopParent)
    {
        //
        // Re-enable the top level parent window upon
        // destruction.
        //

        ::EnableWindow(_hwndTopParent, TRUE);
    }

    Terminate();

    return 0;
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::OnDestroy
//
//  Synopsis:   Handle the WM_DESTROY message
//
//-------------------------------------------------------------------------

LRESULT
CHTMLDlg::OnDestroy()
{
    TraceTag((tagHTMLDlgMethods, "OnDestroy"));

    _hwnd = NULL;

    return 0;
}


LRESULT
CHTMLDlg::OnActivate(WORD wFlags)
{
    TraceTag((tagHTMLDlgMethods, "OnActivate"));

    if (_pInPlaceActiveObj)
    {
        IGNORE_HR(_pInPlaceActiveObj->OnFrameWindowActivate(wFlags != WA_INACTIVE));
    }
    return 0;
}


LRESULT
CHTMLDlg::OnWindowPosChanged(RECT *prc)
{
    TraceTag((tagHTMLDlgMethods, "OnWindowPosChanged"));

    SIZEL       sizel;
    RECT        rcStatus;
    CUnitValue  cuvParam;
    CDoc* pDoc = NULL ;

    if (_hwndStatus)
    {
        GetWindowRect(_hwndStatus, &rcStatus);
        prc->bottom += rcStatus.top - rcStatus.bottom;
    }

    sizel.cx = HimetricFromHPix(prc->right - prc->left);
    sizel.cy = HimetricFromHPix(prc->bottom - prc->top);

    Assert( _pUnkObj && _pOleObj );
    
    if ( S_OK == _pUnkObj->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc) && 
         pDoc && ! pDoc->IsShut() &&
         _pOleObj )
    {
        IGNORE_HR(_pOleObj->SetExtent(DVASPECT_CONTENT, &sizel));
    }   
    
    if (_pInPlaceObj)
    {
        IGNORE_HR(_pInPlaceObj->SetObjectRects(ENSUREOLERECT(prc), ENSUREOLERECT(prc)));
    }

    _rcView = *prc;

    if (_hwndStatus)
        MoveStatusWindow();

    // and don't forget the dialogTop, left, width and height properties.
    //---------------------------------------------------------------------
    GetWindowRect(_hwnd, &rcStatus);
    cuvParam.SetValue (rcStatus.top, CUnitValue::UNIT_PIXELS);
    SetAAdialogTop(cuvParam);

    cuvParam.SetValue ( rcStatus.left, CUnitValue::UNIT_PIXELS);
    SetAAdialogLeft(cuvParam);

    cuvParam.SetValue ( rcStatus.right-rcStatus.left, CUnitValue::UNIT_PIXELS);
    SetAAdialogWidth(cuvParam);

    cuvParam.SetValue ( rcStatus.bottom-rcStatus.top, CUnitValue::UNIT_PIXELS);
    SetAAdialogHeight(cuvParam);

    return 0;
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::GetDoc
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlg::GetDoc(IHTMLDocument2 ** ppDoc)
{
    Assert (ppDoc);

    RRETURN (THR(_pUnkObj->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc)));
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::InitValues
//
//  Synopsis:   Given the objects populate the dialog with values
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlg::InitValues()
{
    IHTMLElementCollection *    pElements = NULL;
    IEnumVARIANT *              pEnumVar = NULL;
    IUnknown *              pUnk = NULL;
    IHTMLElement *              pHTMLElement = NULL;
    BSTR                        bstrID = NULL;
    HRESULT                     hr = S_OK;
    VARIANT                     var;
    IHTMLDocument2 *            pDoc = NULL;

    VariantInit(&var);

    //
    // First get a list of all elements thru an enumerator
    //

    hr = THR(GetDoc (&pDoc));
    if (hr)
        goto Cleanup;

    hr = THR(pDoc->get_all(&pElements));
    if (hr)
        goto Cleanup;

    // avoid casts of the type -> (BaseClass **)&DerivedClass. -
    //hr = THR(pElements->get__newEnum((IUnknown **)&pEnumVar));
    hr = THR(pElements->get__newEnum(&pUnk));
    if (hr)
        goto Cleanup;

    pEnumVar = (IEnumVARIANT *)pUnk;
    //
    // Iterate thru elements, looking for ID attributes that start
    // with _*.  The * signifies which attribute name to
    // load in it.  E.g. _Align will load the Align attribute
    // into the field.
    //

    while (S_OK == (hr = pEnumVar->Next(1, &var, NULL)))
    {
        Assert(V_VT(&var) == VT_DISPATCH);

        hr = THR_NOTRACE(V_DISPATCH(&var)->QueryInterface(
                IID_IHTMLElement,
                (void **)&pHTMLElement));
        if (hr)
            goto LoopCleanup;

        // get id
        hr = THR(pHTMLElement->get_id(&bstrID));

        // if id begins with '_'
        if (S_OK == hr && bstrID && _T('_') == bstrID[0])
        {
            hr = THR(ConnectElement(pHTMLElement, bstrID + 1));
            if (hr)
                goto LoopCleanup;
        }

LoopCleanup:
        FormsFreeString(bstrID);
        bstrID = NULL;
        ClearInterface(&pHTMLElement);
        VariantClear(&var);
    }

    hr = S_OK;

Cleanup:
    ReleaseInterface(pElements);
    ReleaseInterface(pEnumVar);
    ReleaseInterface(pDoc);
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::SetValue
//
//  Synopsis:   Set the value of some control element.
//
//  Arguments:  pCtrl       The control element to set
//              bstrID      ID to look for
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlg::ConnectElement(IHTMLElement * pHTMLElement, BSTR bstrID)
{
    HRESULT             hr = S_OK;
    DISPID              dispid;
    CHTMLDlgExtender *  pExtender = NULL;

    //
    // The underlying assumption here is that given an attribute,
    // the dispid of this attribute is the same across all objects
    // for this dialog.
    //

    //
    // find out dispid of the property
    //

    hr = THR(_aryDispObjs[0]->GetIDsOfNames(
            IID_NULL,
            &bstrID,
            1,
            _lcid,
            &dispid));
    if (hr)
        goto Cleanup;

    //
    // create, hookup and update extender
    //

    pExtender = new CHTMLDlgExtender(this, pHTMLElement, dispid);
    if (!pExtender)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pExtender->Value_ObjectToPropPage());
    if (hr)
        goto Error;

    hr = THR(::ConnectSink(
            pHTMLElement,
            IID_IPropertyNotifySink,
            pExtender,
            &pExtender->_dwCookie));
    if (hr)
        goto Error;

    hr = THR(_aryXObjs.Append(pExtender));
    if (hr)
        goto Error;

Cleanup:

    RRETURN(hr);

Error:
    delete pExtender;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::UpdateValues
//
//  Synopsis:   Update dialog with values based on the commit engine
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlg::UpdateValues()
{
    HRESULT             hr = S_OK;
    long                c;
    CHTMLDlgExtender ** ppExtender;

    if (!_fPropPageMode)
        goto Cleanup;

    for (c = _aryXObjs.Size(), ppExtender = _aryXObjs; c > 0; c--, ppExtender++)
    {
        hr = THR((*ppExtender)->Value_ObjectToPropPage());
        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::SetDirty
//
//  Synopsis:   Set the dirty property and if necessary call on the pagesite.
//
//  Arguments:  dw      As per IPropertyPageSite::OnStatusChange
//
//-------------------------------------------------------------------------

void
CHTMLDlg::SetDirty(DWORD dw)
{
    _fDirty = (dw & PROPPAGESTATUS_DIRTY) != 0;
    if (_pPageSite)
    {
        _pPageSite->OnStatusChange(dw | PROPPAGESTATUS_DIRTY);
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::OnPropertyChange
//
//  Synopsis:   Receive an on property change for some dispid
//              and propagate value down to commit engine.
//
//  Arguments:  pExtend      Extender info on the control
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlg::OnPropertyChange(CHTMLDlgExtender *pExtender)
{
    HRESULT     hr = S_OK;

    hr = THR(pExtender->Value_PropPageToObject());
    if (hr)
        goto Cleanup;

    SetDirty(PROPPAGESTATUS_DIRTY);

Cleanup:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::GetDocumentTitle
//
//  Synopsis:   Retrieve the document's title in a bstr
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlg::GetDocumentTitle(BSTR *pbstr)
{
    HRESULT             hr;
    IHTMLDocument2 *    pDoc = NULL;

    hr = THR(GetDoc (&pDoc));
    if (hr)
        goto Cleanup;

    hr = THR(pDoc->get_title(pbstr));

Cleanup:
    ReleaseInterface (pDoc);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::PrivateQueryInterface
//
//  Synopsis:   per IPrivateUnknown
//
//-------------------------------------------------------------------------

HRESULT
CHTMLDlg::PrivateQueryInterface(REFIID iid, void **ppv)
{
    HRESULT hr = S_OK;

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS2(this, IPropertyPage, IPropertyPage2)
        QI_INHERITS(this, IPropertyPage2)
        QI_TEAROFF(this, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF2(this, IProvideClassInfo, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF2(this, IProvideClassInfo2, IProvideMultipleClassInfo, NULL)
        QI_HTML_TEAROFF(this, IHTMLDialog2, NULL)

        default:
            //
            // Check for the primary dispatch interface first
            //

            if (iid == IID_IHTMLDialog)
            {
                hr = THR(CreateTearOffThunk(this, (void *)s_apfnpdIHTMLDialog, NULL, ppv, (void *)(CHTMLDlg::s_ppropdescsInVtblOrderIHTMLDialog)));
                if (hr)
                    goto Cleanup;
            }
            else if (iid == CLSID_HTMLDialog)
            {
                *ppv = this;
                goto Cleanup;
            }
            break;
    }

    if (!*ppv)
    {
        hr = E_NOINTERFACE;
    }
    else
    {
        ((IUnknown *)*ppv)->AddRef();
        hr = S_OK;
    }

Cleanup:
    RRETURN_NOTRACE(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::SetPageSite
//
//  Synopsis:   per IPropertyPage
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::SetPageSite(IPropertyPageSite *pPageSite)
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::SetPageSite"));
    IServiceProvider *  pSP = NULL;
    IDispatch *         pDisp = NULL;

    HRESULT hr = S_OK;

    if (_pPageSite && pPageSite)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    ReplaceInterface(&_pPageSite, pPageSite);

    if (!pPageSite)
    {
        if (_pOleObj)
        {
            hr = THR(_pOleObj->Close(OLECLOSE_NOSAVE));
            if (hr)
                goto Cleanup;
        }
        ClearInterface(&_pOleObj);
    }
    else
    {
        hr = THR(_pPageSite->GetLocaleID(&_lcid));
        if (hr)
            goto Cleanup;

        // query the IPageSite for the SID_SHTMLProperyPageArg service,        
        if (_pPageSite->QueryInterface(IID_IServiceProvider,
            (void **)&pSP))               
            goto Cleanup;
                    
        if (pSP->QueryService(SID_SHTMLProperyPageArg,        
            IID_IDispatch, (void **)&pDisp))       
            goto Cleanup;
        else
        {
        
            hr = VariantClear(&_varArgIn);
            if (hr)
                goto Cleanup;

            V_VT(&_varArgIn) = VT_DISPATCH;
            V_DISPATCH(&_varArgIn) = pDisp;
            pDisp->AddRef();
            }
     }

Cleanup:              
     ReleaseInterface(pDisp);     
     ReleaseInterface(pSP);    
     RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::Activate
//
//  Synopsis:   per IPropertyPage
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::Activate(HWND hwndParent, LPCRECT prc, BOOL fModal)
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::Activate"));

    HRESULT     hr = S_OK;
    HDC         hdc;
    TEXTMETRIC  tmMetrics;
    TCHAR     * pszBuf;
    DWORD       dwStyle = 0;

    if (!prc)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    _fInitializing = TRUE;
    _fActive = TRUE;

    //
    // Create a frame window if we're not in the property page mode.
    // I.e. This is a standard html dialog.
    //

    if (!_fPropPageMode)
    {
        HWND    hwndTemp;

        if (!GetWndClassAtom(WNDCLASS_DIALOG))
        {
            HICON hIconSm;

            // NOTE (lmollico): icons are in mshtml.dll

            hIconSm = (HICON)LoadImage( g_hInstCore,                    
                                        MAKEINTRESOURCE(RES_ICO_HTML),
                                        IMAGE_ICON,
                                        GetSystemMetrics(SM_CXSMICON),
                                        GetSystemMetrics(SM_CYSMICON),
                                        LR_SHARED );

            hr = THR(RegisterWindowClass(
                    WNDCLASS_DIALOG,
                    HTMLDlgWndProc,
                    CS_DBLCLKS,
                    NULL,
                    NULL,
                    hIconSm));
            if (hr)
                goto Cleanup;
        }

        pszBuf = (TCHAR *)(DWORD_PTR)GetWndClassAtom(WNDCLASS_DIALOG);

        // Every dialog gets these window styles:
        dwStyle = WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_POPUP;
        
        // if not trusted, or adornment is desired, add these styles:
        if (!_fTrusted || !_enumfUnadorned)
        {
            dwStyle |= ((!!_enumfResizeable) ? (WS_OVERLAPPED|WS_THICKFRAME) : 0) |
                        WS_CAPTION | _dwWS;
        }

        // Turn off extra window styles for unadorned dialogs.
        if (_fTrusted && _enumfUnadorned)
            _dwWSEx = 0;
            
        // If the following two lines change, update it for the HTA's
        // as well (..\htmlapp\app.cxx - CHTMLApp::CreateAppWindow)
        if (g_fMirroredBidiLayout)
            _dwWSEx |= WS_EX_LAYOUTRTL;

        _hwnd = CreateWindowEx(
#ifndef UNIX
                _dwWSEx,
#else
                _dwWSEx | WS_EX_TOPMOST | (fModal ? WS_EX_MWMODAL_POPUP : 0),
#endif
                pszBuf,
                _T(""),
                dwStyle,
                prc->left,
                prc->top,
                prc->right - prc->left,
                prc->bottom - prc->top,
                hwndParent,
                NULL,
                g_hInstCore,
                this);

        if (!_hwnd)
        {
            hr = GetLastWin32Error();
            goto Cleanup;
        }

        // Use the Status flag to determine whether to put this in or not.
        // trusted defaults to off, untrusted defaults to on
        if ((!_fTrusted && !!_enumfStatus) ||
            (_fTrusted && _enumfStatus==HTMLDlgFlagYes))
        {
            // Create the status window.
            _hwndStatus = CreateWindowEx(
                    0,                       // no extended styles
                    STATUSCLASSNAME,         // name of status window class
                    (LPCTSTR) NULL,          // no text when first created
                    WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS ,   // creates a child window
                    CW_USEDEFAULT, CW_USEDEFAULT,
                    CW_USEDEFAULT, CW_USEDEFAULT,
                    _hwnd,                   // handle to parent window
                    (HMENU) 0,               // child window identifier
                    g_hInstCore,             // handle to application instance
                    NULL);                   // no window creation data
            if (!_hwndStatus)
            {
                hr = GetLastWin32Error();
                goto Cleanup;
            }

            DividePartsInStatusWindow();
            // we will set URL and Zone info latre, when actual navigation happens (in OnReadyStateChange)
            // this will allow to account for possible redirections.
        }

        //
        // Compute top-level parent and disable this window
        // because we want to function as a modal dialog
        //

        // we are looking for first window in parent chain which is not
        // child

        hwndTemp = _hwndTopParent = hwndParent;
        while (::GetWindowLong(hwndTemp, GWL_STYLE) & WS_CHILD)
        {
            hwndTemp = GetParent(hwndTemp);
            if (!hwndTemp)
                break;
            _hwndTopParent = hwndTemp;
        }

        if (fModal)
            EnableWindow(_hwndTopParent, FALSE);

        GetClientRect(_hwnd, &_rcView);
    }
    else
    {
        Assert(V_VT(&_varArgIn) == VT_DISPATCH && V_DISPATCH(&_varArgIn));

        //
        // Ensure that we have a commit holder and engine
        //

        hr = THR(EnsureCommitHolder((DWORD_PTR)hwndParent, &_pHolder));
        if (hr)
            goto Cleanup;

        hr = THR(_pHolder->GetEngine(_aryDispObjs.Size(), _aryDispObjs, &_pEngine));
        if (hr)
            goto Cleanup;

        //
        // Initialize the array of binding information
        //

        hr = THR(InitValues());
        if (hr)
            goto Cleanup;

        _hwnd = hwndParent;
        _rcView = *prc;
    }

    _fInitializing = FALSE;

    Assert(_hwnd);

    hdc = GetDC(_hwnd);
    if (hdc)
    {
        if (GetTextMetrics(hdc, &tmMetrics))
            _lDefaultFontSize = tmMetrics.tmHeight;
        ReleaseDC(_hwnd, hdc);
    }

    //
    // Only do a show if in proppage mode or if we've already gone interactive
    //

    if (_fPropPageMode || _fInteractive)
    {
        Show((_enumfHide==HTMLDlgFlagNo) ? SW_SHOW : SW_HIDE);
    }

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::Deactivate
//
//  Synopsis:   per IPropertyPage
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::Deactivate()
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::Deactivate"));

    HRESULT             hr = S_OK;
    long                i;
    CHTMLDlgExtender ** ppExtend;
    CVariant            varBool;
    IOleCommandTarget * pCommandTarget = NULL;

    if (!_pInPlaceObj)
        goto Cleanup;

    // give events a chance to fire.
    hr = THR_NOTRACE(_pInPlaceObj->QueryInterface(
                        IID_IOleCommandTarget,
                        (void **)&pCommandTarget));
    if (hr)
        goto Cleanup;

    hr = pCommandTarget->Exec(
            (GUID *)&CGID_MSHTML,
            OLECMDID_ONUNLOAD,
            MSOCMDEXECOPT_DONTPROMPTUSER,
            NULL,
            &varBool);

    if ((V_VT(&varBool) == VT_BOOL && !V_BOOL(&varBool)))
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    if (_pInPlaceActiveObj)
    {
        hr = THR(_pInPlaceObj->UIDeactivate());
        if (hr)
            goto Cleanup;
        ClearInterface(&_pInPlaceActiveObj);
    }

    if (_pInPlaceObj)
    {
        hr = THR(_pInPlaceObj->InPlaceDeactivate());
        if (hr)
            goto Cleanup;
        ClearInterface(&_pInPlaceObj);
    }
    // disconnect the Prop Notify Sink
    if (_PNS._dwCookie && _pOleObj)
    {
        DisconnectSink(_pOleObj, IID_IPropertyNotifySink, &_PNS._dwCookie);
        Assert(_PNS._dwCookie == 0);
    }

    if (_pOleObj)
    {
        hr = THR(_pOleObj->Close(OLECLOSE_NOSAVE));
        if (hr)
            goto Cleanup;
        ClearInterface(&_pOleObj);
    }

    _aryDispObjs.ReleaseAll();

    for (i = _aryXObjs.Size(), ppExtend = _aryXObjs; i > 0; i--, ppExtend++)
    {
        DisconnectSink(
            (*ppExtend)->_pHTMLElement,
            IID_IPropertyNotifySink,
            &((*ppExtend)->_dwCookie));
    }
    _aryXObjs.ReleaseAll();

    if (_pHolder)
    {
        _pHolder->Release();
        _pHolder = NULL;
    }
    _pEngine = NULL;

Cleanup:
    ReleaseInterface(pCommandTarget);
    RRETURN1(hr,S_FALSE);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::GetPageInfo
//
//  Synopsis:   per IPropertyPage
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::GetPageInfo(PROPPAGEINFO *ppageinfo)
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::GetPageInfo"));

    HRESULT     hr;
    BSTR        bstrTitle = NULL;
    long        cb;

    Assert(ppageinfo->cb == sizeof(PROPPAGEINFO));

    hr = THR(GetDocumentTitle(&bstrTitle));
    if (hr)
        goto Cleanup;

    // Convert this bstr into a tchar *
    cb = FormsStringByteLen(bstrTitle);
    if (!cb)
    {
        ppageinfo->pszTitle = NULL;
    }
    else
    {
        ppageinfo->pszTitle = (TCHAR *)CoTaskMemAlloc(cb + sizeof(TCHAR));
        if (!ppageinfo->pszTitle)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        memcpy(ppageinfo->pszTitle, bstrTitle, cb);
        ppageinfo->pszTitle[cb / sizeof(TCHAR)] = 0;
    }

    ppageinfo->size.cx = GetWidth();
    ppageinfo->size.cy = GetHeight();
    ppageinfo->pszDocString = NULL;
    ppageinfo->pszHelpFile = NULL;
    ppageinfo->dwHelpContext = 0;

Cleanup:
    FormsFreeString(bstrTitle);
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::SetObjects
//
//  Synopsis:   per IPropertyPage
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::SetObjects(ULONG cUnk, IUnknown **ppUnks)
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::SetObjects"));

    long                    i;
    IUnknown **             ppUnk;
    IDispatch *             pDisp;
    IServiceProvider *      pSP = NULL;
    IDispatch *             pService = NULL;
    BOOL                    fHaveServiceProvider;
    HRESULT                 hr = S_OK;

    Assert((_aryDispObjs.Size() == 0 && cUnk) ||
           (_aryDispObjs.Size() > 0 && !cUnk));

    //
    // First release any existing objects.
    //

    _aryDispObjs.ReleaseAll();
    
    //
    // Check if the page site provided the SID_SHTMLProperyPageArg service
    //
    fHaveServiceProvider = (V_VT(&_varArgIn) == VT_DISPATCH && V_DISPATCH(&_varArgIn));            

    //
    // Cache a ptr to the object's dispatch
    //

    hr = THR(_aryDispObjs.EnsureSize(cUnk));
    if (hr)
        goto Cleanup;

    for (i = cUnk, ppUnk = ppUnks; i > 0; i--, ppUnk++)
    {
        hr = THR((*ppUnk)->QueryInterface(IID_IDispatch, (void **)&pDisp));
        if (hr)
            goto Error;

        hr = THR(_aryDispObjs.Append(pDisp));
        if (hr)
        {
            ReleaseInterface(pDisp);
            goto Error;
        }

        // cache the first service provider that provides us
        // with the SID_SHTMLProperyPageArg service                                               
        if (!fHaveServiceProvider &&                
            !(*ppUnk)->QueryInterface(IID_IServiceProvider, (void**)&pSP) &&
            !pSP->QueryService(SID_SHTMLProperyPageArg, IID_IDispatch, (void **)&pService))                
        {
            fHaveServiceProvider = TRUE;
            VariantClear(&_varArgIn);
            V_VT(&_varArgIn) = VT_DISPATCH;
            V_DISPATCH(&_varArgIn) = pService;
            V_DISPATCH(&_varArgIn)->AddRef();
        }
        ClearInterface(&pService);
        ClearInterface(&pSP);       
    }

Cleanup:
    RRETURN(hr);

Error:
    _aryDispObjs.ReleaseAll();
    goto Cleanup;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::Show
//
//  Synopsis:   per IPropertyPage
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::Show(UINT nCmdShow)
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::Show"));

    HRESULT hr = S_OK;

    _fInitializing = TRUE;

    if (!_fPropPageMode)
    {
        if(!_fKeepHidden)
        {
            ::ShowWindow(_hwnd, nCmdShow);
        }
    }

    if (SW_SHOW == nCmdShow || SW_SHOWNORMAL == nCmdShow || SW_SHOWNA == nCmdShow)
    {
        if (!_fInteractive)
        {
            //
            // Cause a SetExtent to occur on the object.  No need to do this
            // if already interactive because SetExtent has already happened
            // in that case.
            //

            OnWindowPosChanged(&_rcView);
        }

        hr = THR(_pOleObj->DoVerb(
                OLEIVERB_UIACTIVATE,
                NULL,
                &_Site,
                0,
                _hwnd,
                ENSUREOLERECT(&_rcView)));
        if (hr)
            goto Cleanup;

        // The dialog is often a sibling of the app that raised it, but it usually
        // wants to be visible over it, so bring it to the top. (Bug #102125)
        Assert( _hwnd );
        if (!_fKeepHidden)
            ::BringWindowToTop( _hwnd );

        hr = THR(UpdateValues());
        if (hr)
            goto Cleanup;

    }
    else
    {
        Assert(SW_HIDE == nCmdShow);

        hr = THR(_pOleObj->DoVerb(
                OLEIVERB_HIDE,
                NULL,
                &_Site,
                0,
                _hwnd,
                ENSUREOLERECT(&_rcView)));
        if (hr)
            goto Cleanup;
    }

    // We're not done initializing unless we're done with the layout
    if (nCmdShow != SW_HIDE)
    {
        hr = THR(EnsureLayout());
        if (hr)
            goto Cleanup;
    }

    _fInitializing = FALSE;

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::Move
//
//  Synopsis:   per IPropertyPage
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::Move(LPCRECT prc)
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::Move"));

    Assert(_fPropPageMode);

    OnWindowPosChanged((RECT *)prc);

    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::IsPageDirty
//
//  Synopsis:   per IPropertyPage
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::IsPageDirty()
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::IsPageDirty"));

    RRETURN (S_FALSE);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::Apply
//
//  Synopsis:   per IPropertyPage, a no-op in browse mode
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::Apply()
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::Apply"));
     
    RRETURN(S_OK);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::Help
//
//  Synopsis:   per IPropertyPage
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::Help(LPCOLESTR bstrHelpDir)
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::Help"));

    RRETURN(E_NOTIMPL);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::TranslateAccelerator
//
//  Synopsis:   per IPropertyPage
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::TranslateAccelerator(LPMSG lpmsg)
{
    TraceTag((tagHTMLDlgMethods, "IPropertyPage::TranslateAccelerator"));

    HRESULT         hr = S_FALSE;

    if (!_pInPlaceObj)
        goto Cleanup;

    if (_pInPlaceActiveObj)
    {
        hr = THR(_pInPlaceActiveObj->TranslateAccelerator(lpmsg));
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::EditProperty
//
//  Synopsis:   per IPropertyPage2
//
//---------------------------------------------------------------------------
//lookatme
HRESULT
CHTMLDlg::EditProperty(DISPID dispid)
{
    HRESULT hr = S_OK;
#ifdef NEVER
    IControls *     pCtrls;
    IEnumControl *  pEnum = NULL;
    IControl *      pCtrl;
    CPPXObject *    pPPXO;
    DISPID          dispidCtrl;
    VARIANT         var;

    if (dispid == DISPID_UNKNOWN)
        return E_FAIL;

    hr = THR(_pForm->GetControls(&pCtrls));
    if (hr)
        goto Cleanup;

    hr = THR(pCtrls->Enum(&pEnum));
    if (hr)
        goto Cleanup;

    while (!(hr = pEnum->Next(1, &pCtrl, NULL)))
    {
        hr = THR(pCtrl->QueryInterface(g_iidPPXObject, (void **) &pPPXO));
        if (hr)
            continue;

        pPPXO->GetControlSource(&dispidCtrl);
        pPPXO->Release();
        if (dispidCtrl == dispid)
        {
            V_VT(&var) = VT_BOOL;
            V_BOOL(&var) = -1;
            hr = THR(pCtrl->SetFocus(var));
            pCtrl->Release();
            goto Cleanup;
        }

        pCtrl->Release();
    }

    hr = E_FAIL;

  Cleanup:
    ReleaseInterface(pCtrls);
    ReleaseInterface(pEnum);

    RRETURN(hr);
#endif
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlg::Invoke
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlg::Invoke(
        DISPID dispidMember,
        REFIID,
        LCID lcid,
        WORD wFlags,
        DISPPARAMS * pdispparams,
        VARIANT * pvarResult,
        EXCEPINFO * pexcepinfo,
        UINT *)
{
    RRETURN(InvokeEx(dispidMember, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, NULL));
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlg::GetIDsOfNames
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLDlg::GetIDsOfNames(REFIID,
                     LPOLESTR *  rgszNames,
                     UINT,
                     LCID,
                     DISPID *    rgdispid)
{
    RRETURN(GetDispID(rgszNames[0], fdexFromGetIdsOfNames, rgdispid));
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLDlg::GetDispID, IDispatchEx
//
//  Synopsis:   First try GetIDsOfNames, then try expando version.
//
//--------------------------------------------------------------------------

HRESULT
CHTMLDlg::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    RRETURN(THR_NOTRACE(super::GetInternalDispID(bstrName,
                                              pid,
                                              grfdex,
                                              NULL,
                                              NULL)));
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::GetNextDispID
//
//  Synopsis:   per IDispatchEx, use the window's properties (as usable ing GINEx
//              and ::invoke) when that returns S_FALS then use CBase's for std
//              dialog and expando
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::GetNextDispID(DWORD grfdex,
                        DISPID id,
                        DISPID *prgid)
{
    HRESULT     hr;

    // if the id is in the range of the htmldlg properties get the dialog's properties
    // ISSUE (carled) expandos do not work properly, and this has to be by-design.
    if ((id >= STDPROPID_XOBJ_LEFT  && id <= STDPROPID_XOBJ_HEIGHT) ||
        (id >= DISPID_HTMLDLG && id < DISPID_HTMLDLGMODEL) ||
        id == DISPID_STARTENUM)
    {
        hr = THR(super::GetNextDispID(grfdex, id, prgid));

        if (hr == S_FALSE)
        {
            // we've exhausted the dialog's properties
            id = DISPID_STARTENUM;
        }
        else
            goto Cleanup;
    }

    *prgid = DISPID_UNKNOWN;
    hr = S_FALSE;

Cleanup:
    RRETURN1(hr, S_FALSE);
}


HRESULT
CHTMLDlg::InvokeEx(DISPID dispidMember,
                   LCID lcid,
                   WORD wFlags,
                   DISPPARAMS * pdispparams,
                   VARIANT * pvarResult,
                   EXCEPINFO * pexcepinfo,
                   IServiceProvider *pSrvProvider)
{

    TraceTag((tagHTMLDlgMethods, "IDispatch::Invoke"));

    RRETURN(THR_NOTRACE(super::InvokeEx(dispidMember,
                                     lcid,
                                     wFlags,
                                     pdispparams,
                                     pvarResult,
                                     pexcepinfo,
                                     pSrvProvider)));
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::HTMLDlgWndProc
//
//  Synopsis:   Window procedure
//
//---------------------------------------------------------------------------
LRESULT CALLBACK
CHTMLDlg::HTMLDlgWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    CHTMLDlg * pDlg = (CHTMLDlg *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if (!pDlg && wm != WM_NCCREATE && wm != WM_CREATE)
        goto Cleanup;

    switch (wm)
    {
    case WM_ERASEBKGND:
        if(pDlg->_pUnkObj)
            return TRUE;
        break;

#ifndef WINCE
    case WM_NCCREATE:
#else
    case WM_CREATE:
#endif // !WINCE
        pDlg = (CHTMLDlg *) ((LPCREATESTRUCT) lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pDlg);

        pDlg->_hwnd = hwnd;
        pDlg->AddRef();
#ifndef WINCE
        break;

    case WM_CREATE:
        HMENU   hMenu;

        hMenu = GetSystemMenu(hwnd, FALSE);
        if (hMenu)
        {
            if (!pDlg->_enumfMin)
                RemoveMenu(hMenu, SC_MINIMIZE, MF_BYCOMMAND);

            if (!pDlg->_enumfMax)
                RemoveMenu(hMenu, SC_MAXIMIZE, MF_BYCOMMAND);

            if (!pDlg->_enumfResizeable)
                RemoveMenu(hMenu, SC_SIZE, MF_BYCOMMAND);

            if (!pDlg->_enumfMin && !pDlg->_enumfMax)
                RemoveMenu(hMenu, SC_RESTORE, MF_BYCOMMAND);
        }
#endif // !WINCE
        break;

#ifndef WINCE
    case WM_NCDESTROY:
#else
    case WM_DESTROY:
#endif // !WINCE
        SetWindowLongPtr(hwnd, GWLP_USERDATA, 0);
        pDlg->_hwnd = NULL;
        pDlg->Release();
#ifndef WINCE
        break;

    case WM_DESTROY:
#endif // !WINCE
        return pDlg->OnDestroy();
        break;

    case WM_CLOSE:
        return pDlg->OnClose();
        break;

    case WM_WINDOWPOSCHANGED:
        if (   !IsIconic(hwnd) 
            && !(SWP_NOSIZE & ((WINDOWPOS *) lParam)->flags ))
        {
            RECT    rc;

            GetClientRect(hwnd, &rc);
            pDlg->OnWindowPosChanged(&rc);

        }
        return 0;

    case WM_ACTIVATE:
        return pDlg->OnActivate(LOWORD(wParam));

    case WM_PALETTECHANGED:
    case WM_QUERYNEWPALETTE:
        {
            HWND hwndDoc;

            if (pDlg->_pInPlaceObj)
            {
                pDlg->_pInPlaceObj->GetWindow(&hwndDoc);
                return SendMessage(hwndDoc, wm, wParam, lParam);
            }
        }
        break;
    }

Cleanup:
    return DefWindowProc(hwnd, wm, wParam, lParam);
}



//+-------------------------------------------------------------------------
//
//  member:CHTMLDlg::Terminate () - 
//
//  Synopsis: for Modeless dialogs this needs to shut down the thread and 
//      for modal it just needs to destroy the window.
//
//--------------------------------------------------------------------------

HRESULT
CHTMLDlg::Terminate ()
{     
    if (!_fIsModeless)
    {
        if (_fPropPageMode)
            _hwnd = NULL;
        else
        {
            HWND hwnd = _hwnd;
            _hwnd = NULL;
            DestroyWindow(hwnd);
        }
    }
    else
    {
        Assert(!_fPropPageMode);

        HANDLE  hThread = GetCurrentThread();
        HWND    hwndCurrent = _hwnd;
        _hwnd = NULL;

#ifdef NO_MARSHALLING
        g_Modeless.Remove(this);
#endif

        // release the ref that the thread has on the CModelessDlg
        Release();

        // now destory the hwnd. we cached it in case the above release
        // DTor's *this*
        DestroyWindow(hwndCurrent);

#ifndef NO_MARSHALLING
        OleUninitialize();

        if (hThread)
        {
            DWORD dwExitCode;

            if (GetExitCodeThread(hThread, &dwExitCode) &&
                dwExitCode == STILL_ACTIVE)
            {
                CloseHandle(hThread);
                ExitThread(0);
            }
        }
#endif
    }
    return S_OK; 
}

//---------------------------------------------------------------------------
//
//  Member:     InternalShowModalDialog
//
//  Synopsis:   Internal helper to show the modal html dialog.
//
//  Arguments:  hwndParent      Window to parent to
//              pMk             Moniker to dialog page
//              pVarIn          argument
//              pVarOut         The return value from the dialog.
//
//---------------------------------------------------------------------------
HRESULT 
InternalShowModalDialog( HTMLDLGINFO * pdlgInfo, CHTMLDlg ** ppDlgRet)
{
    HRESULT             hr = S_OK;
    CHTMLDlg *          pDlg = NULL;
    RECT                rc;
    MSG                 msg;
    BOOL                fTrusted;

    // ReleaseCapture to cancel any drag-drop operation
    // TODO (lmollico): This call should be in EnableModeless in shdocvw instead
    ::ReleaseCapture();

    // decode the trusted flag
    fTrusted = (pdlgInfo->dwFlags & HTMLDLG_DONTTRUST) ? FALSE : TRUE;

    // First create the dialog
    pDlg = new CHTMLDlg(NULL, fTrusted, pdlgInfo->punkHost);
    if (!pDlg)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Now set appropriate binding info
    if (pdlgInfo->pvarArgIn)
    {
        hr = THR(VariantCopy (&pDlg->_varArgIn, pdlgInfo->pvarArgIn));
        if (hr)
            goto Cleanup;
    }

    pDlg->_lcid = g_lcidUserDefault;
    pDlg->_fKeepHidden = pdlgInfo->dwFlags & HTMLDLG_NOUI ? TRUE : FALSE;
    pDlg->_fAutoExit = pdlgInfo->dwFlags & HTMLDLG_AUTOEXIT ? TRUE : FALSE;

    hr = THR(pDlg->Create(pdlgInfo));

    if (hr)
        goto Cleanup;

    rc.left   = pDlg->GetLeft();
    rc.top    = pDlg->GetTop();
    rc.right  = rc.left + pDlg->GetWidth();
    rc.bottom = rc.top  + pDlg->GetHeight();

    if (pDlg->_fVerifyRect)
    {
        // Dialog width and heght each have a minimum size and no bigger than screen size
        // and the dialog Must be all on the screen
        // We need to pass a hwndParent that is used for multimonitor systems to determine
        // which monitor to use for restricting the dialog
        pDlg->VerifyDialogRect(&rc, pdlgInfo->hwndParent);
    }

    hr = THR(pDlg->Activate(pdlgInfo->hwndParent, &rc, TRUE));
    if (hr)
        goto Cleanup;

    if (pdlgInfo->pOptionsHolder)
    {
        pdlgInfo->pOptionsHolder->SetParentHWnd(pDlg->_hwnd);
    }

    // Finally push a message loop and give messages to the dialog

    if (!pDlg->_fIsModeless)
    {
        // this is the expected code path 
        while (pDlg->_hwnd)
        {
            ::GetMessage(&msg, NULL, 0, 0);

            if (msg.message < WM_KEYFIRST ||
                msg.message > WM_KEYLAST  ||
                THR(pDlg->TranslateAccelerator(&msg)) != S_OK)
            {
                ::TranslateMessage(&msg);
                ::DispatchMessage(&msg);
            }
        }

        if (pdlgInfo->pvarArgOut)
        {
            hr = THR(VariantCopy(pdlgInfo->pvarArgOut, &pDlg->_varRetVal));
            if (hr)
                goto Cleanup;

            // if the _varRetVal is the dlg's window then the dlg
            // is keeping a ref count on itself and will never release
            // therefore we need to Clear that now. in this case the
            // dlg.returnValue property will subsequently return
            // VT_EMPTY/NULL from pvarArgOut.
            if ( (V_VT(&pDlg->_varRetVal) == VT_DISPATCH ||
                  V_VT(&pDlg->_varRetVal) == VT_UNKNOWN) )
            {
                CHTMLDlg *pRetTest = NULL;

                hr = THR_NOTRACE(
                    V_UNKNOWN(&pDlg->_varRetVal)->QueryInterface(CLSID_HTMLDialog,
                              (void**)&pRetTest));
                if (!hr && pRetTest==pDlg)
                {
                    VariantClear(&pDlg->_varRetVal);
                }
                hr = S_OK;
            }
        }
    }

    if (ppDlgRet)
    {
        // this case only happens when a HTMLDialogEx call wants a modal dialog
        // on its own thread
        *ppDlgRet = pDlg;
        pDlg = NULL;
        hr = S_OK;
    }

Cleanup:
    if (pDlg)
        pDlg->Release();

    RRETURN(hr);
}

HRESULT 
InternalShowModalDialog( HTMLDLGINFO * pdlgInfo )
{
    return InternalShowModalDialog( pdlgInfo, NULL);
}

//---------------------------------------------------------------------------
//
//  Member:     ShowModalDialog
//
//  Synopsis:   Show an html dialog given a resource to load from.
//
//  Arguments:  hwndParent      Window to parent to
//              pMk             Moniker to dialog page
//              pVarIn          argument
//              pVarOut         The return value from the dialog.
//
//---------------------------------------------------------------------------

STDAPI
ShowModalDialog(HWND        hwndParent,
                IMoniker *  pMk,
                VARIANT *   pvarArgIn,
                TCHAR *     pchOptions,
                VARIANT *   pvarArgOut)
{
    HRESULT hr;
    HTMLDLGINFO dlginfo;
    VARIANT     varOptionStr;

    hr = THR(OleInitialize(NULL));
    if (FAILED(hr))
        goto Cleanup;

    dlginfo.hwndParent = hwndParent;
    dlginfo.pmk = pMk;
    dlginfo.pvarArgIn = pvarArgIn;

    dlginfo.pvarOptions = &varOptionStr;
    V_BSTR(dlginfo.pvarOptions) = pchOptions;       // fake the variant.
    V_VT(dlginfo.pvarOptions) = VT_BSTR;

    dlginfo.pvarArgOut = pvarArgOut;
    dlginfo.fModeless = FALSE;

    // show modal and trusted dialog.
    hr = THR(InternalShowModalDialog( &dlginfo ));

    OleUninitialize();

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     ShowHTMLDialog
//
//  Synopsis:   Just like ShowModalDialog, but with a prettier name.
//
//  Arguments:  hwndParent      Window to parent to
//              pMk             Moniker to dialog page
//              pVarIn          argument
//              pVarOut         The return value from the dialog.
//
//---------------------------------------------------------------------------

STDAPI
ShowHTMLDialog(HWND        hwndParent,
                IMoniker *  pMk,
                VARIANT *   pvarArgIn,
                TCHAR *     pchOptions,
                VARIANT *   pvarArgOut)
{
    HRESULT hr;

    hr = THR(ShowModalDialog(
        hwndParent,
        pMk,
        pvarArgIn,
        pchOptions,
        pvarArgOut));

    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
// the ex function is what showHTMLDialog should have been.  it takes
// flags to determine if this dialog is to be modal or not (one stop shopping)
//
//----------------------------------------------------------------------------
STDAPI
ShowHTMLDialogEx(HWND        hwndParent,
                 IMoniker *  pMk,
                 DWORD       dwDialogFlags,
                 VARIANT *   pvarArgIn,
                 TCHAR *     pchOptions,
                 VARIANT *   pvarArgOut)
{
    HRESULT     hr = S_OK;
    HTMLDLGINFO dlginfo;
    CVariant    cvarOptions;


    CoInitialize(NULL);

    V_VT(&cvarOptions) = VT_BSTR;
    V_BSTR(&cvarOptions) = SysAllocString(pchOptions);

    dlginfo.hwndParent  = hwndParent;
    dlginfo.pmk         = pMk;
    dlginfo.pvarArgIn   = pvarArgIn;
    dlginfo.pvarOptions = &cvarOptions;
    dlginfo.fModeless   = (dwDialogFlags & HTMLDLG_MODAL) ? FALSE : TRUE;
    // ISSUE (KTam): Why are we filtering flags out before passing them on?
    dlginfo.dwFlags     = dwDialogFlags & ( HTMLDLG_NOUI | HTMLDLG_PRINT_TEMPLATE | HTMLDLG_VERIFY);

    if (dwDialogFlags & HTMLDLG_MODELESS)
    {
        IHTMLWindow2 * pWin = NULL;

        dlginfo.ppDialog    = (pvarArgOut ? &pWin : NULL);

        hr = InternalModelessDialog( &dlginfo );

        if (pvarArgOut)
        {
            // transfer ref to out arg
            V_VT(pvarArgOut) = VT_UNKNOWN;
            V_UNKNOWN(pvarArgOut) = pWin;
        }
    }
    else if (dwDialogFlags & HTMLDLG_MODAL)
    {
        dlginfo.pvarArgOut = pvarArgOut;

        hr = THR(InternalShowModalDialog( &dlginfo ));
    }


    CoUninitialize();

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     ShowModelessHTMLDialog
//
//  Synopsis:   like the window::createModelessDialog, this creates and brings up
//              a modeless version of the HTMLDialog.  This function is the api 
//              implementation rather then the OM.
//
//  Arguments:  hwndParent      Window to parent to
//              pMk             Moniker to dialog page
//              pVarIn          argument
//              pVarOut         The return value from the dialog.
//
//---------------------------------------------------------------------------

STDAPI
ShowModelessHTMLDialog(HWND       hwndParent,
                       IMoniker * pMK,
                       VARIANT  * pvarArgIn,
                       VARIANT  * pvarOptions,
                       IHTMLWindow2 ** ppDialog)
{
    HRESULT     hr;
    HTMLDLGINFO dlginfo;

    dlginfo.hwndParent = hwndParent;
    dlginfo.pmk = pMK;
    dlginfo.pvarArgIn = pvarArgIn;
    dlginfo.pvarOptions = pvarOptions;
    dlginfo.ppDialog = ppDialog;
    dlginfo.fModeless = TRUE;

    hr = InternalModelessDialog( &dlginfo );

    RRETURN( hr );
}

//---------------------------------------------------------------------------
//
//  Member:     ShowModalDialogHelper
//
//  Synopsis:   A helper used by internal forms code to call the
//              html dialog api.
//
//  Arguments:  pBase       -   Pointer to associated CBase instance.
//              pchHTML         HTML name - resource name or Url
//              pDisp           The IDispatch to work on
//              pvarArgOut      The return value from the dialog.
//              pcoh            COptionsHolder (if any) passed down
//              dwFlags         Option flags
//
// HTMLDLG_NOUI             0x1     // run the dialog but don't show it
// HTMLDLG_RESOURCEURL      0x2     // create the moniker for a resource
// HTMLDLG_AUTOEXIT         0x4     // exit immediatly after running script
// HTMLDLG_DONTTRUST        0x8     // don't trust the moniker passed in
//
//---------------------------------------------------------------------------

HRESULT
ShowModalDialogHelper(
                      CMarkup *pMarkup,
                      TCHAR *pchHTML,
                      IDispatch *pDisp,
                      COptionsHolder * pcoh,
                      VARIANT *pvarArgOut,
                      DWORD   dwFlags)
{
    HRESULT         hr;
    CVariant        varArgIn;
    IMoniker *      pmk = NULL;
    HWND            hwndParent;
    BOOL            fTrusted;

    V_VT(&varArgIn) = VT_DISPATCH;
    V_DISPATCH(&varArgIn) = pDisp;
    pDisp->AddRef();

    if(dwFlags & HTMLDLG_RESOURCEURL)
    {
#if DBG == 1
        if (IsTagEnabled(tagHTMLDlgHack))
        {
            TCHAR   achTemp[MAX_PATH];
            TCHAR * pch;

            _tcscpy(achTemp, _T("file://"));
            Verify(GetModuleFileName(g_hInstCore, achTemp + 7, MAX_PATH - 7));
            pch = _tcsrchr(achTemp, _T('\\'));
            _tcscpy(pch + 1, pchHTML);
            hr = THR(CreateURLMoniker(NULL, achTemp, &pmk));
        }
        else
#endif
        hr = THR(CreateResourceMoniker(
                GetResourceHInst(),
                pchHTML,
                &pmk));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(CreateURLMoniker(NULL, pchHTML, &pmk));
        if(hr)
            goto Cleanup;
    }

    fTrusted = (dwFlags & HTMLDLG_DONTTRUST) ? FALSE : TRUE ;

    {
        CDoc * pDoc = pMarkup->Doc();
        CDoEnableModeless   dem(pDoc, pMarkup->GetWindowedMarkupContextWindow());

        hwndParent = dem._hwnd;

        if (hwndParent)
        {
            HTMLDLGINFO dlginfo;

            dlginfo.hwndParent = hwndParent;
            dlginfo.pmk        = pmk;
            dlginfo.fModeless  = FALSE;
            dlginfo.pvarArgIn  = &varArgIn;
            dlginfo.pvarArgOut = pvarArgOut;
            dlginfo.pOptionsHolder = pcoh;
            dlginfo.dwFlags = dwFlags;
            dlginfo.pMarkup = pMarkup;
            hr = THR(InternalShowModalDialog( &dlginfo ));
        }
    }
    
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pmk);
    RRETURN(hr);
}



//+----------------------------------------------------------
//
//  member : VerifyDialogRect()
//
//  Synopsis : for security type reasons we do not want the
//      dialogs to get relocated (via script or bad styles)
//      offscreen.  similarly we want a minimum size (which was
//      set in the pdl
//
//  parameters : pRect is an In/Out parameter.
//               hwndRef - HWND that is used to obtain current monitor
//                      on multimonitor systems
//-----------------------------------------------------------
void
CHTMLDlg::VerifyDialogRect(RECT * pRect, HWND hwndRef)
{
    long     dlgWidth  = pRect->right - pRect->left;
    long     dlgHeight = pRect->bottom - pRect->top;

    Assert(IsWindow(hwndRef));

    HMONITOR        curMonitor;
    MONITORINFO     monitorInfo;

    // Get the current monitor
    curMonitor = MonitorFromWindow(hwndRef, MONITOR_DEFAULTTONEAREST);

    monitorInfo.cbSize = sizeof(monitorInfo);

    Verify(GetMonitorInfo(curMonitor, &monitorInfo));

    long    lLeftMonitor     = monitorInfo.rcMonitor.left;
    long    lTopMonitor      = monitorInfo.rcMonitor.top;
    long    lWidthMonitor    = monitorInfo.rcMonitor.right - monitorInfo.rcMonitor.left;
    long    lHeightMonitor   = monitorInfo.rcMonitor.bottom - monitorInfo.rcMonitor.top;

    // make sure width is no larger than screen
    dlgWidth  = min(max(dlgWidth, (long)DIALOG_MIN_WIDTH), lWidthMonitor);
    dlgHeight = min(max(dlgHeight, (long)DIALOG_MIN_HEIGHT ), lHeightMonitor);

    // Always keep whole dialog visable
    pRect->left = max(pRect->left, (long) lLeftMonitor);
    pRect->top  = max(pRect->top, (long) lTopMonitor);

    if ( (pRect->left + dlgWidth) > lLeftMonitor + lWidthMonitor)
    {
        pRect->left = lLeftMonitor + lWidthMonitor - dlgWidth;
    }
    if ( (pRect->top + dlgHeight) > lTopMonitor + lHeightMonitor )
    {
        pRect->top = lTopMonitor + lHeightMonitor - dlgHeight;
    }

    pRect->right  = pRect->left + dlgWidth;
    pRect->bottom = pRect->top  + dlgHeight;
}


void
CHTMLDlg::MoveStatusWindow()
{
    RECT    rcStatus;
    RECT    rc;

    Assert(_hwndStatus);

    GetClientRect(_hwnd, &rc);
    GetWindowRect(_hwndStatus, &rcStatus);

    MoveWindow(
            _hwndStatus,
            0,
            rc.bottom - (rcStatus.bottom - rcStatus.top),
            rc.right - rc.left,
            rc.bottom,
            TRUE);

    DividePartsInStatusWindow();
}


void
CHTMLDlg::DividePartsInStatusWindow()
{
    RECT        rc;
    UINT        cxZone;

    Assert(_hwndStatus);
    GetClientRect(_hwndStatus, &rc);

    cxZone = (rc.right > (DIALOG_ZONE_WIDTH + DIALOG_STATUS_MIN) )
            ? DIALOG_ZONE_WIDTH: (rc.right /2);

    INT aWidths[] = {rc.right - cxZone, -1 };

    // Create 2 parts: URL text, zone information
    SendMessage(_hwndStatus, SB_SETPARTS, 2, (LPARAM)aWidths);
}


//+=========================================================
HRESULT
CHTMLDlg::toString(BSTR* String)
{
    RRETURN(super::toString(String));
};

void
CHTMLDlg::CacheZonesIcons()
{
    IInternetZoneManager * pizm = NULL;
    DWORD dwZoneCount = 0;

    // Create ZoneManager
    CoInternetCreateZoneManager(NULL, &pizm, 0);

    if (pizm)
    {
        DWORD dwZoneEnum;

        if (SUCCEEDED(pizm->CreateZoneEnumerator(&dwZoneEnum, &dwZoneCount, 0)))
        {
            for (int nIndex=0; (DWORD)nIndex < dwZoneCount; nIndex++)
            {
                DWORD           dwZone;
                ZONEATTRIBUTES  za = {sizeof(ZONEATTRIBUTES)};
                WORD            iIcon=0;
                HICON           hIcon = NULL;

                pizm->GetZoneAt(dwZoneEnum, nIndex, &dwZone);

                // get the zone attributes for this zone
                pizm->GetZoneAttributes(dwZone, &za);

                // Zone icons are in two formats.
                // wininet.dll#1200 where 1200 is the res id.
                // or foo.ico directly pointing to an icon file.
                // search for the '#'
                LPWSTR pwsz = StrChrW(za.szIconPath, L'#');

                if (pwsz)
                {
                    // if we found it, then we have the foo.dll#00001200 format
                    pwsz[0] = L'\0';
                    iIcon = (WORD)StrToIntW(pwsz+1);
                    ExtractIconExW(za.szIconPath,(UINT)(-1*iIcon), NULL, &hIcon, 1 );
                }
                else
                    hIcon = (HICON)ExtractAssociatedIconW(g_hInstCore, za.szIconPath, (LPWORD)&iIcon);

                if (nIndex < MAX_NUM_ZONES_ICONS)
                     g_arhiconZones[nIndex] = hIcon;

            }
            pizm->DestroyZoneEnumerator(dwZoneEnum);
        }
    }

    ReleaseInterface(pizm);
}


//+-------------------------------------------------------------------------
//
//  Function:   DeinitHTMLDialogs
//
//  Synopsis:   Clears global created by find dialogs "memory"
//
//--------------------------------------------------------------------------

void
DeinitHTMLDialogs()
{
    extern  BSTR    g_bstrFindText;
    FormsFreeString(g_bstrFindText);
    g_bstrFindText = NULL;
}

HRESULT GetCallerIDispatch(IServiceProvider *pSP, IDispatch ** ppID);
HRESULT GetSIDOfDispatch(IDispatch *pDisp, BYTE *pbSID, DWORD *pcbSID, BOOL *pfDomainExist = NULL);

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::AccessAllowed()
//
//  Synopsis:   Checks if the dialog did not leave the original URL domain 
//              (via redirection or META-REFRESH for example). This is to prevent
//              security hole when dialogArguments and other values get cached during
//              cross-domain redirection and can be used by gullable target html dialog.
//
//---------------------------------------------------------------------------

BOOL
CHTMLDlg::AccessAllowed()
{
    HRESULT hr;
    BOOL     retVal = FALSE;
    CDoc    *pDoc;
    CMarkup *pDlgMarkup;
    LPTSTR   pchUrl = NULL;
    AAINDEX     aaindex;
    IUnknown *pUnk;
    IServiceProvider *pSP = NULL;
    IDispatch *pDisp = NULL;
    BYTE    abSID1[MAX_SIZE_SECURITY_ID];
    DWORD   cbSID1 = ARRAY_SIZE(abSID1);
    BYTE    abSID2[MAX_SIZE_SECURITY_ID];
    DWORD   cbSID2 = ARRAY_SIZE(abSID2);
    extern DWORD g_dwAppCompat;

    if(!_pUnkObj || !_pOriginalMoniker)
        goto Cleanup;

    if (g_dwAppCompat)
    {
        //get dialog's primary markup
        if(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc))
            goto Cleanup;

        pDlgMarkup = pDoc->PrimaryMarkup();
        if(!pDlgMarkup)
            goto Cleanup;

        //get original URL that was passed into createXXXDialog(...)
        if(_pOriginalMoniker->GetDisplayName(NULL, NULL, &pchUrl))
            goto Cleanup;

        //check access - no access would mean that we left appropriate
        retVal = pDlgMarkup->AccessAllowed(pchUrl);
    }
    else
    {
        aaindex = FindAAIndex(
                DISPID_INTERNAL_INVOKECONTEXT, CAttrValue::AA_Internal);

        if (aaindex == AA_IDX_UNKNOWN)
        {
            retVal = TRUE;
            goto Cleanup;
        }

        // Note: Command routing can fail here if we return an error because
        // command execution halts unless we return OLECMDERR_E_NOTSUPPORTED.
        if (FAILED(GetUnknownObjectAt(aaindex, &pUnk)) || pUnk == NULL)
            goto Cleanup;

        hr = pUnk->QueryInterface(IID_IServiceProvider, (void**)&pSP);
        pUnk->Release();
        if (FAILED(hr) || !pSP)
            goto Cleanup;

        hr = GetCallerIDispatch(pSP, &pDisp);
        pSP->Release();
        if (FAILED(hr) || !pDisp)
            goto Cleanup;

        hr = GetSIDOfDispatch(pDisp, abSID1, &cbSID1);
        pDisp->Release();
        if (FAILED(hr))
            goto Cleanup;

        //get original URL that was passed into createXXXDialog(...)
        if(_pOriginalMoniker->GetDisplayName(NULL, NULL, &pchUrl))
            goto Cleanup;

        if (FAILED(THR(TLS(windowInfo.pSecMgr)->GetSecurityId(
                            pchUrl, abSID2, &cbSID2, NULL))))
            goto Cleanup;

        //check access - no access would mean that we left appropriate
        retVal = (cbSID1 == cbSID2 && !memcmp(abSID1, abSID2, cbSID1));
    }

Cleanup:

    if(pchUrl)
        CoTaskMemFree(pchUrl);

    return retVal;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::OnReadyStateChange
//
//  Synopsis:   Handle changes in readystate of document
//
//---------------------------------------------------------------------------

void
CHTMLDlg::OnReadyStateChange()
{
    HRESULT     hr;
    CVariant    Var;
    IDispatch * pDisp = NULL;
    long        lReadyState;
    LPTSTR      pszTitle  = NULL;
    BSTR        bstrTitle = NULL;

    if (_fPropPageMode) // Readystate changes are not interesting if proppage
        goto Cleanup;

    hr = THR(_pUnkObj->QueryInterface(IID_IDispatch, (void **)&pDisp));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(GetDispProp(
            pDisp,
            DISPID_READYSTATE,
            g_lcidUserDefault,
            &Var,
            NULL));
    if (hr)
        goto Cleanup;

    //
    // Look for either VT_I4 or VT_I2
    //

    if (V_VT(&Var) == VT_I4)
    {
        lReadyState = V_I4(&Var);
    }
    else if (V_VT(&Var) == VT_I2)
    {
        lReadyState = V_I2(&Var);
    }
    else
    {
        Assert(0 && "Bad VT for readystate");
        goto Cleanup;
    }

    //readyState goes back to loaded or unloaded when redirection or HTTP-EQUIV="Refresh" happens
    //should reset interactive flag to update all things later again.
    if (lReadyState < READYSTATE_INTERACTIVE)
        _fInteractive = FALSE;

    if (lReadyState >= READYSTATE_INTERACTIVE && !_fInteractive)
    {
        HTMLDlgCenter        attrCenter;

        _fInteractive = TRUE;

        BOOL        fRightToLeft = FALSE;
        CDoc      * pDoc;

        hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc));
        if (hr)
            goto Cleanup;

        Assert(pDoc);
        Assert(pDoc->_pWindowPrimary);
        Assert(pDoc->_pWindowPrimary->Document());
        
        pDoc->_pWindowPrimary->Document()->GetDocDirection(&fRightToLeft);
        
        // if the document is RTL change the window's extended style 
        // so the caption is right aligned.
        if(fRightToLeft)
        {
            LONG lExStyle = GetWindowLong(_hwnd, GWL_EXSTYLE);
            // (paulnel) We need to conditionally set WS_EX_LAYOUTRTL here. Due to the way
            //           it is designed we do not want to set WS_EX_RIGHT or WS_EX_RTLREADING
            //           if we have mirrored support.
            //           The document takes care of WS_EX_LEFTSCROLLBAR | WS_EX_RTLREADING
            //           internally.
            if(!g_fMirroredBidiLayout)
                lExStyle |= WS_EX_RIGHT | WS_EX_RTLREADING;
            else
                lExStyle |= WS_EX_LAYOUTRTL;
            SetWindowLong(_hwnd, GWL_EXSTYLE, lExStyle);
        }

        //
        // Set the title of the window to be the document's title
        //

        hr = THR(GetDocumentTitle(&bstrTitle));
        if (!hr)
        {
            if (!_fTrusted)
            {
                hr = Format(FMT_OUT_ALLOC,
                            &pszTitle,
                            0,
                            _T("<0s><1i>"),
                            bstrTitle,
                            GetResourceHInst(), IDS_WEBPAGEDIALOG);
                if (hr)
                    goto Cleanup;
            }
            SetWindowText(_hwnd, _fTrusted ? bstrTitle : pszTitle);
        }

        // Update Status Bar to reflect correct URL and Zone
        {
            const TCHAR * pchUrl = pDoc->GetPrimaryUrl();

            Assert(pchUrl);

            // Set URL text
            SendMessage(_hwndStatus, SB_SETTEXT, 0, (LPARAM) pchUrl);

            IInternetZoneManager * pizm = NULL;
            IInternetSecurityManager * pism = NULL;

            CoInternetCreateSecurityManager(NULL, &pism, 0);
            CoInternetCreateZoneManager(NULL, &pizm, 0);

            if (pism && pizm)
            {
                DWORD dwZone = 0;
                ZONEATTRIBUTES za = {sizeof(za)};
                HICON hIcon = NULL;

                pism->MapUrlToZone(pchUrl, &dwZone, 0);
                pizm->GetZoneAttributes(dwZone, &za);

                if(!g_arhiconZones[0])
                {
                    CacheZonesIcons();
                }
                hIcon = g_arhiconZones[dwZone];

                // Set zone information
                SendMessage(_hwndStatus, SB_SETTEXTW, 1, (LPARAM)za.szDisplayName);

                if (hIcon)
                    SendMessage(_hwndStatus, SB_SETICON, 1, (LPARAM)hIcon);
            }
            ReleaseInterface(pizm);
            ReleaseInterface(pism);

        }
        
        // handle setting the Center value
        attrCenter = GetAAcenter();
        if (HTMLDlgCenterParent == attrCenter || HTMLDlgCenterDesktop == attrCenter)
        {
            HWND        hwndParent;
            CUnitValue  cuvParam;
            RECT        r;

            hwndParent = (HTMLDlgCenterParent == attrCenter && _hwndTopParent) ?
                        _hwndTopParent : GetDesktopWindow();

            Assert (hwndParent);
            GetWindowRect (hwndParent, &r);

            //
            //  check if left/top value has been set to no default value,
            //  if so, do not move to center.
            //

            if (!_pAA || _pAA->FindAAIndex(s_propdescCHTMLDlgdialogLeft.a.GetDispid(),
                                  CAttrValue::AA_Attribute) == AA_IDX_UNKNOWN)
            {
                cuvParam.SetValue (r.left + (r.right - r.left - GetWidth()) / 2, CUnitValue::UNIT_PIXELS);
                SetAAdialogLeft(cuvParam);
            }

            if (!_pAA || _pAA->FindAAIndex(s_propdescCHTMLDlgdialogTop.a.GetDispid(),
                                  CAttrValue::AA_Attribute) == AA_IDX_UNKNOWN)
            {
                cuvParam.SetValue (r.top  + (r.bottom - r.top - GetHeight()) / 2, CUnitValue::UNIT_PIXELS);
                SetAAdialogTop(cuvParam);
            }
        }
        OnPropertyChange(STDPROPID_XOBJ_WIDTH, 0, (PROPERTYDESC *)&s_propdescCHTMLDlgdialogWidth);

        //
        // If Activate has already been called, go ahead and do a show now.
        //

        if (_fActive)
        {
            Show(SW_SHOW);
        }
    }

Cleanup:
    delete pszTitle;
    FormsFreeString(bstrTitle);
    ReleaseInterface(pDisp);
}












//
// Do NOT under any circumstances move this part above.  We don't
// want to contaminate any other part of the dialog with private
// knowledge of the document. (anandra)
//

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::OnPropertyChange
//
//  Synopsis:   Set the return value
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    Assert( !ppropdesc || ppropdesc->GetDispid() == dispid );
    //Assert( !ppropdesc || ppropdesc->GetdwFlags() == dwFlags );

    if (!_fPropPageMode)
    {
        //
        // If we're in dialog mode, then let the top/left/width/height change
        // trigger a resize of the frame window.
        //

        switch (dispid)
        {
        case DISPID_READYSTATE:
            OnReadyStateChange();
            break;

        case STDPROPID_XOBJ_WIDTH:
        case STDPROPID_XOBJ_HEIGHT:
        case STDPROPID_XOBJ_TOP:
        case STDPROPID_XOBJ_LEFT:
        case DISPID_A_FONT :
        case DISPID_A_FONTSIZE :
        case DISPID_A_FONTWEIGHT :
        case DISPID_A_FONTFACE :
        case DISPID_A_FONTSTYLE :
        case DISPID_A_FONTVARIANT :
            {
                // invalidate the HTML element's CFPF since getCascaded* needs to
                // pick up this change.
                CElement *pHtml = GetHTML();
                if (pHtml)
                    pHtml->GetFirstBranch()->VoidCachedInfo();

                RECT rect;

                rect.top    = GetTop();
                rect.left   = GetLeft();
                rect.bottom = rect.top + GetHeight();
                rect.right  = rect.left + GetWidth();

                // We need to pass a _hwnd that is used for multimonitor systems to determine
                // which monitor to use for restricting the dialog
                if (_fVerifyRect)
                    VerifyDialogRect(&rect, _hwndTopParent);

                MoveWindow(_hwnd,
                           rect.left,
                           rect.top,
                           rect.right-rect.left,
                           rect.bottom-rect.top,
                           TRUE);
                if ((!_fTrusted && !!_enumfStatus) ||
                    (_fTrusted && _enumfStatus==HTMLDlgFlagYes))
                {
                    MoveStatusWindow();
                }

                // we also want to invalidate the caches on the doc at this point...
            }
            break;

        case DISPID_CHTMLDlg_dialogHide:
            return THR(onDialogHide());
            break;
        }
    }

    RRETURN(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
}


//
//   Get*()  helper functions. These are responsible for
//      returning the appropriate value for the property
//   GetFontSize() returns the size in TWIPS
//
//   Height, Width, Top, Left, and Font (size)
//
//===========================================================

CElement *
CHTMLDlg::GetHTML()
{
    HRESULT    hr;
    CDoc     * pDoc;
    CElement * pElemRet = NULL;

    hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc));
    if (hr)
        goto Cleanup;
    
    if (pDoc && pDoc->PrimaryMarkup())
    {
        pElemRet = pDoc->PrimaryMarkup()->GetHtmlElement();
    }

Cleanup:
    return pElemRet;
}

long
CHTMLDlg::GetFontSize(CElement * pHTML)
{
    long   lFontSize = 0;

    if (!pHTML)
        pHTML = GetHTML();

    if (pHTML)
    {
        lFontSize = pHTML->GetFirstBranch()->GetParaFormat()->_lFontHeightTwips;

        if (lFontSize <=0)
        {
            lFontSize = _lDefaultFontSize*20;
            goto Cleanup;
        }
    }

Cleanup:
    return lFontSize;
}


long
CHTMLDlg::GetTop()
{
    CElement * pElem = GetHTML();

    if (pElem)
    {
        CUnitValue cuvTop = GetAAdialogTop();
        long       lTwipsFontHeight = GetFontSize(pElem);

        if (cuvTop.GetUnitType()==CUnitValue::UNIT_NULLVALUE)
            cuvTop.SetRawValue(s_propdescCHTMLDlgdialogTop.a.ulTagNotPresentDefault);

        return cuvTop.YGetPixelValue(NULL, 100, lTwipsFontHeight);
    }

    return 0;
}

long
CHTMLDlg::GetLeft()
{
    CElement * pElem = GetHTML();

    if (pElem)
    {
        CUnitValue cuvLeft = GetAAdialogLeft();
        long       lTwipsFontHeight = GetFontSize(pElem);

        if (cuvLeft.GetUnitType()==CUnitValue::UNIT_NULLVALUE)
            cuvLeft.SetRawValue(s_propdescCHTMLDlgdialogLeft.a.ulTagNotPresentDefault);

        return cuvLeft.XGetPixelValue(NULL, 100, lTwipsFontHeight);
    }

    return 0;
}

long
CHTMLDlg::GetWidth()
{
    CElement * pElem = GetHTML();

    if (pElem)
    {
        CUnitValue cuvWidth = pElem->GetFirstBranch()->GetCascadedwidth();
        long       lTwipsFontHeight = GetFontSize(pElem);

        if (cuvWidth.GetUnitType()==CUnitValue::UNIT_NULLVALUE)
            cuvWidth.SetRawValue(s_propdescCHTMLDlgdialogWidth.a.ulTagNotPresentDefault);

        return cuvWidth.XGetPixelValue(NULL, 100, lTwipsFontHeight);
    }

    return 0;
}

long
CHTMLDlg::GetHeight()
{
    CElement * pElem = GetHTML();

    if (pElem)
    {
        CUnitValue cuvHeight = pElem->GetFirstBranch()->GetCascadedheight();
        long       lTwipsFontHeight = GetFontSize(pElem);

        if (cuvHeight.GetUnitType()==CUnitValue::UNIT_NULLVALUE)
            cuvHeight.SetRawValue(s_propdescCHTMLDlgdialogHeight.a.ulTagNotPresentDefault);

        return cuvHeight.YGetPixelValue(NULL, 100, lTwipsFontHeight);
    }

    return 0;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::LoadDocSynchronous
//
//  Synopsis:   Load the inner document synchronously.  Lovely hack, huh?
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::LoadDocSynchronous(IStream *pStm, TCHAR *pchUrl)
{
    HRESULT     hr;
    CDoc *      pDoc;
    TCHAR *     pchCodePage = NULL;
    CODEPAGE    cp = 0;

    Assert(_pUnkObj);

    hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc));
    if (hr)
        goto Cleanup;

    //
    // Again, just a reminder that the only reason this call
    // exists is to force the doc to have a valid base url set in
    // the synchronous load case.  Since we use IPersistStreamInit
    // to load, the doc will never know how to resolve relative
    // references unless we do this or a base tag exists in
    // the html.  We don't want to force everyone to have a base
    // tag, hence this hack.
    //

    hr = THR(pDoc->SetUrl(pDoc->PrimaryMarkup(), pchUrl));
    if (hr)
        goto Cleanup;

    if (_fPropPageMode)
    {
        //
        // In proppage mode, just go load up the codepage from the
        // resource dll and convert it to a dwCodePage.  Use this
        // to prime the parser.  This is acceptable because we don't
        // expose any mechanism for third parties to create property
        // pages using trident.
        //

        hr = THR(Format(
                FMT_OUT_ALLOC,
                &pchCodePage,
                0,
                MAKEINTRESOURCE(IDS_CODEPAGE)));
        if (hr)
            goto Cleanup;

        cp = CodePageFromString(pchCodePage, FALSE);
    }

    hr = THR(pDoc->LoadFromStream(pStm, TRUE, cp));
    if (hr)
        goto Cleanup;

Cleanup:
    delete pchCodePage;
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::SetFlagsOnDoc
//
//  Synopsis:   Set various CDoc flags, including _fInTrustedHTMLDlg
//              (based on the trusted state of the dialog).
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::SetFlagsOnDoc(HTMLDLGINFO * pdlginfo)
{
    HRESULT hr;
    CDoc *  pDoc;

    Assert(_pUnkObj);

    hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc));
    if (hr)
        goto Cleanup;

    pDoc->_fInTrustedHTMLDlg = _fTrusted;

    // Also set the flag that indicates that the document is a dialog
    // We need to set this so the size is applyed correctly
    pDoc->_fInHTMLDlg = TRUE;
    pDoc->_fInHTMLPropPage = pdlginfo->fPropPage;

    // Also set the flags on the doc indicating whether we're a print template,
    // and whether we're previewing.
    if ( pdlginfo->dwFlags & HTMLDLG_PRINT_TEMPLATE )
    {
        CMarkup *pMarkup = pDoc->PrimaryMarkup();
        
        // Ensure security manager for printing.  This must happen before
        // the CDoc of the dialog has IOleSite::SetClientSite() called on it,
        // otherwise the when the printing security manager calls SetSecuritySite(),
        // it will hook up to the dialog's implementation of IInternetSecurityManager,
        // which is precisely what we want to avoid.  (KTam)
        pDoc->EnsureSecurityManager( TRUE );
        pDoc->_fIsPrintTemplate = TRUE;
        if ( pdlginfo->dwFlags & HTMLDLG_NOUI )
        {
            pDoc->_fIsPrintWithNoUI = TRUE;
        }

        if (pMarkup)
        {
            pMarkup->SetPrintTemplate(TRUE);
            pMarkup->SetPrintTemplateExplicit(TRUE);
        }

        // If we're in a print dialog, we need to fire an event
        // back on the browse doc that we have finished building
        // the print template.
        FirePrintTemplateEvent(IDM_FIRE_PRINTTEMPLATEUP);
    }
    
    // don't fire webOC ewents for documents created this way 
    // this is undone in CMarkup::OnLoadStatusDone
    pDoc->_fDontFireWebOCEvents = TRUE;

Cleanup:
    RRETURN(hr);
}

extern const TCHAR *s_aachPrintType[];


HRESULT
CHTMLDlg::FirePrintTemplateEvent(DWORD nCmdId)
{
    HRESULT             hr;
    CDoc                * pDoc          = NULL;
    IHTMLEventObj2      * pevDlgArgs    = NULL;
    IOleCommandTarget   * pioct         = NULL;
    BSTR                bstrTarget      = NULL;
    BSTR                bstrPrintType   = NULL;
    VARIANT             var;
    int                 i;

    VariantInit(&var);

    // Our dialogArguments should be an IHTMLEventObj2 
    if (    V_VT(&_varArgIn) != VT_UNKNOWN
        ||  !V_UNKNOWN(&_varArgIn)           )
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = V_UNKNOWN(&_varArgIn)->QueryInterface(IID_IHTMLEventObj2, (void**)&pevDlgArgs);
    if (hr)
        goto Cleanup;
    Assert(pevDlgArgs);

    //  We should only fire print events for printing.
    //  PageSetup is a print template, but we should not fire an event for it.

    //  Find out what kind of print template we are...
    bstrPrintType = SysAllocString(_T("__IE_PrintType"));
    if (!bstrPrintType)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pevDlgArgs->getAttribute(bstrPrintType, 0, &var);
    if (    hr
        ||  V_VT(&var) != VT_BSTR
        || !V_BSTR(&var)        )
    {
        hr = S_OK;
        goto Cleanup;
    }

    // Lookup the string in our table
    for (i=0; (i < PRINTTYPE_LAST) && (_tcsicmp(s_aachPrintType[i], V_BSTR(&var)) != 0); i++);

    if (    i != PRINTTYPE_PREVIEW
        &&  i != PRINTTYPE_PRINT
        &&  i != PRINTTYPE_PRINTNOUI)
    {
        goto Cleanup;
    }

    //
    // (greglett) If we could directly store a reference to the host and use it (rather than IOCT),
    //            that would be k3wl.  Remember, though, that we may be on another thread...
    //
    
    // Get a reference to the browse doc, if one exists.
    bstrTarget = SysAllocString(_T("__IE_BrowseDocument"));
    if (!bstrTarget)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pevDlgArgs->getAttribute(bstrTarget, 0, &var);
    if (    hr
        ||  V_VT(&var) != VT_UNKNOWN
        || !V_UNKNOWN(&var)        )
    {
        hr = S_OK;
        goto Cleanup;
    }

    

    // Get an IOCT reference to the browse doc...
    hr = V_UNKNOWN(&var)->QueryInterface(IID_IOleCommandTarget, (void **)&pioct);
    if (hr)
        goto Cleanup;
    Assert(pioct);
    VariantClear(&var);

    // Get the Primary IHTMLWindow2 to send with the event
    hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc));
    if (hr)
        goto Cleanup;
    Assert(pDoc);
    Assert(pDoc->_pWindowPrimary);

    
    // Send the browse doc notification that it should fire the event.
    // Pass it the window of the dlg as an argument.
    V_VT(&var) = VT_UNKNOWN;
    V_UNKNOWN(&var) = (IUnknown *)(IHTMLWindow2*)pDoc->_pWindowPrimary;
    hr = pioct->Exec(&CGID_MSHTML, nCmdId, 0, &var, 0);
    VariantInit(&var);  // DONT clear.

Cleanup:
    SysFreeString(bstrPrintType);
    SysFreeString(bstrTarget);
    ReleaseInterface(pevDlgArgs);
    ReleaseInterface(pioct);
    RRETURN(hr);
}


//+--------------------------------------------------------------------------
//
//  Member:     CHTMLDlg::EnsureLayout
//
//  Synopsis:   Ensure view is ready before clearing _fInitializing
//
//---------------------------------------------------------------------------

HRESULT
CHTMLDlg::EnsureLayout()
{
    HRESULT hr;
    CDoc *  pDoc;

    Assert(_pUnkObj);

    hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc));
    if (hr)
        goto Cleanup;

    pDoc->GetView()->EnsureView(LAYOUT_SYNCHRONOUS);

Cleanup:
    RRETURN(hr);
    
}

BOOL
CHTMLDlg::IsPrintingDialog()
{
    BOOL    bRet = FALSE;

    if (_pUnkObj)
    {
        CDoc *  pDoc;

        HRESULT hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc));
        if (hr)
            goto Cleanup;
        bRet = pDoc->IsPrintDialog();
    }

Cleanup:
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmldlg\unixmodeless.cxx ===
//+------------------------------------------------------------------------
//
//  File:       unixmodeless.cxx
//
//  Contents:   unix function handling modeless dialog messages
//
//  History:
//
//-------------------------------------------------------------------------

#ifdef NO_MARSHALLING
#include <unixmodeless.hxx>

CUnixModeless g_Modeless;

extern "C"
HRESULT TranslateModelessAccelerator(MSG* pmsg, HWND hWnd)
{
    HWND hTarget = (hWnd ? hWnd : pmsg->hwnd);

    if (hTarget)
    {
        for (CHTMLDlg* pdlg = g_Modeless.GetFirstDlg(); pdlg; ) 
        {
            if (hTarget == pdlg->_hwnd || (hWnd ? 0 : IsChild(pdlg->_hwnd, hTarget)))
            {
                return pdlg->TranslateAccelerator(pmsg);
            } 
            pdlg = g_Modeless.GetNextDlg();
        }
    }
    return S_FALSE;  
}

CUnixModeless::CUnixModeless()
{
    m_iUsed = m_iSize = m_iCurrent = 0;
    m_pHead = NULL;
}

CUnixModeless::~CUnixModeless()
{
    if (m_pHead)
    {
        free(m_pHead);
    }
}

BOOL CUnixModeless::Append(CHTMLDlg* pdlg)
{
    if (m_iUsed==m_iSize)
    {
	    void* p=realloc((void*)m_pHead, sizeof(CHTMLDlg*) * (m_iSize+10));
        if(!p)
        {
            return FALSE;
        } 
	    m_pHead = (CHTMLDlg**)p;
        m_iSize += 10;
    }
    m_pHead[m_iUsed] = pdlg;
    m_iUsed++;
    return TRUE;
} 

BOOL CUnixModeless::Remove(CHTMLDlg* pdlg)
{
    for(int i=0; i<m_iUsed; i++)
    {
        if (pdlg == m_pHead[i])
        {
            for (int j=i; j<m_iUsed-1; j++) // Remove this HWND...
            {
                m_pHead[j] = m_pHead[j+1];
            }
            if (m_iCurrent && m_iCurrent == i)
            {
                m_iCurrent--; // So that GetNext can point to correct HWND
            }
            m_iUsed --;
            return TRUE;
        }
    }
    return FALSE;
}

CHTMLDlg* CUnixModeless::GetFirstDlg()
{
    m_iCurrent = 0;
    return (m_pHead ? m_pHead[0] : NULL);
}

CHTMLDlg* CUnixModeless::GetNextDlg()
{
    if (m_iCurrent + 1 < m_iUsed)
    {
        return m_pHead[ ++m_iCurrent ];
    }
    return NULL;
}            

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\include\empty.cxx ===
#include <headers.hxx>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmldlg\modeless.cxx ===
//=============================================================================
//
//  File  : modeless.cxx
//
//  Sysnopsis : modeless dialog helper functinos and support classes
//
//=============================================================================
#include "headers.hxx"

#if defined(UNIX) 
#include "window.hxx"
#endif

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

#ifndef X_OPTSHOLD_HXX_
#define X_OPTSHOLD_HXX_
#include "optshold.hxx"
#endif

#ifndef X_COREDISP_H_
#define X_COREDISP_H_
#include <coredisp.h>
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_MARKUP_HXX_
#define X_MARKUP_HXX_
#include "markup.hxx"
#endif

#ifdef NO_MARSHALLING

#include "unixmodeless.cxx"

#endif

//----------------------------------------------------------
// CTOR
//----------------------------------------------------------
CThreadDialogProcParam::CThreadDialogProcParam(IMoniker * pmk,
                                               VARIANT  * pvarArgIn) :
        _ulRefs(1), 
        _pMarkup(NULL)
{
    if (pvarArgIn)
        _varParam.Copy(pvarArgIn);

    Assert(pmk);
    _pmk = pmk;
    _pmk->AddRef(); 
}

//----------------------------------------------------------
// DTOR
//----------------------------------------------------------
CThreadDialogProcParam::~CThreadDialogProcParam ()
{
    ClearInterface (&_pmk);
    if (_pMarkup)
    {
        _pMarkup->Release();
        _pMarkup = NULL;
    }
}

//---------------------------------------------------------
//---------------------------------------------------------
HRESULT
CThreadDialogProcParam::get_parameters(VARIANT * pvar)
{
    if (!pvar)
        return E_POINTER;

    return VariantCopy(pvar, &_varParam);
}

//---------------------------------------------------------
//---------------------------------------------------------
HRESULT
CThreadDialogProcParam::get_optionString (VARIANT * pvar)
{
    if (!pvar)
        return E_POINTER;

    return VariantCopy(pvar, &_varOptions);
}

//---------------------------------------------------------
//---------------------------------------------------------
HRESULT
CThreadDialogProcParam::get_moniker(IUnknown ** ppUnk)
{
    if (!ppUnk)
        return E_POINTER;

    *ppUnk = NULL;

    if (_pmk)
    {
        HRESULT hr = _pmk->QueryInterface(IID_IUnknown, (void**)ppUnk);
        return hr;
    }
    else
        return S_FALSE;
}

//---------------------------------------------------------
//---------------------------------------------------------
HRESULT
CThreadDialogProcParam::get_document(IUnknown ** ppUnk)
{
    if (!ppUnk)
        return E_POINTER;

    *ppUnk = NULL;
    
    return(!_pMarkup) ? S_FALSE :
                    (_pMarkup->Window()->Document()->QueryInterface(IID_IUnknown, (void**)ppUnk));
    
}
//---------------------------------------------------------
//---------------------------------------------------------
HRESULT
CThreadDialogProcParam::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
    if (!ppv)
        return E_POINTER;

    *ppv = NULL; 

    if (iid == IID_IUnknown)
        *ppv = (IUnknown*)this;
    else if (iid == IID_IHTMLModelessInit)
        *ppv = (IHTMLModelessInit*)this;
    else if (iid== IID_IDispatch)
        *ppv = (IDispatch *)this;

    if (*ppv)
    {
       ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
     return E_NOINTERFACE;
}

//==========================================================
//  Forward declarations & Helper functions
//==========================================================
DWORD WINAPI CALLBACK ModelessThreadProc( void * pv);
HRESULT               ModelessThreadInit( ThreadProcParam * pParam, 
                                          CHTMLDlg ** ppDlg);
HRESULT CreateModelessDialog(IHTMLModelessInit * pMI, 
                             IMoniker * pMoniker,
                             DWORD      dwFlags,
                             HWND       hwndParent,
                             CHTMLDlg **ppDialog);

HRESULT InternalShowModalDialog( HTMLDLGINFO * pdlgInfo, CHTMLDlg ** ppDlgRet );

//+---------------------------------------------------------
//
//  Helper function : InternalModelessDialog
//
//  Synopsis: spin off a thread, and cause the dialog to be brought up
//
//----------------------------------------------------------
HRESULT
InternalModelessDialog( HTMLDLGINFO * pdlgInfo )
{
    HRESULT         hr = S_OK;
    THREAD_HANDLE   hThread = NULL;
    EVENT_HANDLE    hEvent = NULL;
    LPSTREAM        pStm = NULL;
    LPSTREAM        pStmParam = NULL;
    DWORD           idThread;
    ThreadProcParam tppBundle;

    // we are pushing a msgLoop, make sure this sticks around
    if (pdlgInfo->pMarkup)
        pdlgInfo->pMarkup->AddRef();

    if (pdlgInfo->ppDialog)
         *(pdlgInfo->ppDialog) = NULL;
         
    CThreadDialogProcParam *ptpp = new CThreadDialogProcParam(pdlgInfo->pmk, pdlgInfo->pvarArgIn);
    if (!ptpp)
        return E_OUTOFMEMORY;

#ifndef NO_MARSHALLING
    hEvent = CreateEventA(NULL, FALSE, FALSE, NULL);
    if (hEvent == NULL)
    {
        delete ptpp;
        RRETURN(GetLastWin32Error());
    }
#endif

    // populate more of the ThreadProc sturcture
    //------------------------------------------
    if (pdlgInfo->pvarOptions)
        ptpp->_varOptions.Copy(pdlgInfo->pvarOptions);

    if (pdlgInfo->pMarkup)
    {
        ptpp->_pMarkup = pdlgInfo->pMarkup;
        pdlgInfo->pMarkup->AddRef();
    }

#ifndef NO_MARSHALLING
    // now put the threadprocParam into a marshallable place
    //------------------------------------------------------
    hr = THR(CoMarshalInterThreadInterfaceInStream(
                    IID_IHTMLModelessInit,
                    (LPUNKNOWN)ptpp,
                    &pStmParam ));
    if (hr)
        goto Cleanup;

    // Create the new thread
    //-----------------------
    tppBundle._hEvent = hEvent;
    tppBundle._pParamStream = pStmParam;
    tppBundle._ppStm = &pStm;
    tppBundle._hwndDialog = NULL;
    tppBundle._pMK = pdlgInfo->pmk;
    tppBundle._dwFlags = pdlgInfo->dwFlags;
    tppBundle._hwndParent = pdlgInfo->hwndParent;
    tppBundle._fModal = !pdlgInfo->fModeless;

    hThread = CreateThread(NULL, 
                           0,
                           ModelessThreadProc, 
                           &tppBundle, 
                           0, 
                           &idThread);
    if (hThread == NULL)
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }
#else //no_marshalling
    ptpp->AddRef();
    tppBundle._hEvent = NULL;
    tppBundle._pParamStream = (LPSTREAM)ptpp;
    tppBundle._ppStm = &pStm;
    tppBundle._hwndDialog = NULL;
    tppBundle._pMK = pdlgInfo->pmk;
    tppBundle._dwFlags = pdlgInfo->dwFlags;
    tppBundle._hwndParent = pdlgInfo->hwndParent;
    tppBundle._fModal = !pdlgInfo->fModeless;

    ModelessThreadProc((void*) &tppBundle); 
#endif //no_marshalling
    {
        // the modeless dialog may have a statusbar window.
        // In this case, the activate() of the dialog and the CreateWindowEX for the status
        // window will thread block with the primary thread .  Instead of just
        // doing a WaitForSIngleEvent, we want to keep our message loop spining,
        // but we don't really want much to happen.  If there is a parentDoc (script
        // rasied dlg) then we make it temporarily modal while the modeless dialog is 
        // initialized and raised.  In the case of an API call, we do our best, but
        // let the message pump spin.

#ifndef NO_MARSHALLING
        // the faster this is the faster the dialog comes up
        while (WaitForSingleObject(hEvent, 0) != WAIT_OBJECT_0)
        {
            MSG  msg;

            if (GetMessage(&msg, NULL, 0, 0))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
#endif
    }

    // and finally deal with the return IHTMLWindow2 pointer
    //-------------------------------------------------
    if (pStm && pdlgInfo->ppDialog)
    {
#ifndef NO_MARSHALLING
        hr = THR(CoGetInterfaceAndReleaseStream(pStm, 
                                            IID_IHTMLWindow2, 
                                            (void **) (pdlgInfo->ppDialog)));
#else
        hr = S_OK;
        *(pdlgInfo->ppDialog) = (IHTMLWindow2*)pStm;
#endif

        //
        // don't add print templates to this list, we WANT the spooling 
        // to continue even if the main document gets navigated away, or 
        // closed.
        //
        if (   pdlgInfo->pMarkup 
            && tppBundle._hwndDialog
            && !(pdlgInfo->dwFlags & HTMLDLG_PRINT_TEMPLATE))
        {
            HWND * pHwnd;
            Assert(pdlgInfo->pMarkup->Document()->Window());
            pHwnd = pdlgInfo->pMarkup->Document()->Window()->_aryActiveModeless.Append();
            if (pHwnd)
                *pHwnd = tppBundle._hwndDialog;
        }
    }
    
Cleanup:

#ifndef NO_MARSHALLING
    CloseEvent(hEvent);
#endif

    ptpp->Release();
    if (pdlgInfo->pMarkup)
        pdlgInfo->pMarkup->Release();

    if(hThread)
    {
        CloseHandle(hThread);
    }

    RRETURN( hr );
}

//+--------------------------------------------------------------------------
//
//  Function : ModlessThreadProc - 
//
//  Synopsis : responsible for the thread administation
//
//--------------------------------------------------------------------------

DWORD WINAPI CALLBACK
ModelessThreadProc( void * pv )
{
    HRESULT    hr;
    MSG        msg;
    CHTMLDlg * pDlg = NULL;

    ITypeLib * pMSHTMLTypeLib = NULL;

#ifndef NO_MARSHALLING
    hr = THR(OleInitialize(NULL));
    if (FAILED(hr))
        goto Cleanup;
#else
    CDoc* pDoc = NULL;
#endif


    // This is an attempt to force the MSHTML.TLB to stay cached 

    // TODO: Version independent and/or localized version of loading the type library is needed

    if (FAILED(LoadTypeLib(TEXT("MSHTML.TLB"),&pMSHTMLTypeLib)))
    {
        // If we have not loaded the type library then we haven't cached the file.
        Assert(0);
    }

    // Nop or start a message Q
    PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);

    // post ourselves a message to initialize
    PostThreadMessage(GetCurrentThreadId(), WM_USER+1, (LPARAM)pv, 0);

    // process message queue:
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (msg.hwnd ==NULL && msg.message==WM_USER+1)
        {
            // do my initialization work here...
            hr = ModelessThreadInit((ThreadProcParam *)msg.wParam,
                                     &pDlg);
#ifdef NO_MARSHALLING
            if (hr)
                break;
            else
            {
                pDoc = (CDoc *)((ThreadProcParam*)msg.wParam)->_hEvent;
            }
#endif
        }
        else
        {
            if (msg.message < WM_KEYFIRST ||
                msg.message > WM_KEYLAST  ||
                ( pDlg &&
                  THR(pDlg->TranslateAccelerator(&msg)) != S_OK))
            {
               // Process all messages in the message queue.
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

#ifdef NO_MARSHALLING
            if (pDoc && pDoc->LoadStatus() >= LOADSTATUS_PARSE_DONE)
            {
                break;
            }
#endif
        }
    }

Cleanup:

    // This is an attempt to force the MSHTML.TLB to stay cached
    
    if (pMSHTMLTypeLib)
    {
        pMSHTMLTypeLib->Release();
    }

    return (0);
}


//+-------------------------------------------------------------------------
//
//  Function:   ModelessThreadInit
//
//  Synopsis:   Creates a new modeless dialog on this new thread
//
//--------------------------------------------------------------------------

HRESULT 
ModelessThreadInit(ThreadProcParam * pParam, CHTMLDlg ** ppDlg)
{
    CHTMLDlg          * pDlg = NULL;
    EVENT_HANDLE        hEvent= pParam->_hEvent;
    HRESULT             hr;
    IHTMLModelessInit * pMI = NULL;

    Assert (ppDlg);
    *ppDlg = NULL;

#ifndef NO_MARSHALLING
    // get the initialization interface from the marshalling place
    //------------------------------------------------------------------
    hr = THR(CoGetInterfaceAndReleaseStream(pParam->_pParamStream, 
                                            IID_IHTMLModelessInit, 
                                            (void**) & pMI));

#else
    hr = S_OK;
    pMI = (IHTMLModelessInit*)pParam->_pParamStream;
#endif

   if (hr)
        goto Cleanup;

    // Create the dialog
    //------------------------------------------------
    if (pParam->_fModal)
    {
        HTMLDLGINFO dlginfo;
        CVariant    cvarTransfer;
        CVariant    cvarArgs;

        dlginfo.hwndParent = pParam->_hwndParent;
        dlginfo.pmk        = pParam->_pMK;
        dlginfo.fModeless  = TRUE;
        dlginfo.fPropPage  = FALSE;
        dlginfo.dwFlags    = pParam->_dwFlags;
        dlginfo.pvarArgIn  = &cvarArgs;

        pMI->get_parameters( dlginfo.pvarArgIn);

        hr = pMI->get_optionString( &cvarTransfer );
        if (hr==S_OK )
        {
            if (V_VT(&cvarTransfer)==VT_BSTR )
                dlginfo.pvarOptions = &cvarTransfer;
        }

        // show modal and trusted dialog.
        hr = THR(InternalShowModalDialog( &dlginfo, &pDlg ));
    }
    else
    {
        hr = THR(CreateModelessDialog(pMI, 
                                      pParam->_pMK, 
                                      pParam->_dwFlags, 
                                      pParam->_hwndParent, 
                                      &pDlg));
    }
    if (hr)
        goto Cleanup;

    *ppDlg = pDlg;

#ifdef NO_MARSHALLING
    g_Modeless.Append(pDlg);
#endif

    // we need to return a window parameter. to do this we check
    // for a strm pointer in the init-structure, and if it is there
    // then we use it to marshal the ITHMLWindow2 into. The caller 
    //  thread will unmarshal from here and release the stream.
    if (pParam->_ppStm && pDlg)
    {
        CDoc     * pDoc = NULL;

        hr = THR(pDlg->_pUnkObj->QueryInterface(CLSID_HTMLDocument, 
                                            (void **)&pDoc));
        if (SUCCEEDED(hr) && pDoc) //  && pDoc->_pPrimaryMarkup)
        {

#ifndef NO_MARSHALLING
            hr = THR(CoMarshalInterThreadInterfaceInStream(
                        IID_IUnknown,
                        (IUnknown *)(IPrivateUnknown *)pDoc->_pWindowPrimary,
                        pParam->_ppStm));
#else
            hr = S_OK;
            pDoc->_pWindowPrimary->AddRef();
            *pParam->_ppStm = (LPSTREAM)((IHTMLWindow2*)pDoc->_pWindowPrimary);
            pParam->_hEvent = (EVENT_HANDLE)pDoc;
#endif

            if (hr==S_OK)
                pParam->_hwndDialog = pDlg->_hwnd;
        }
    }

Cleanup:
#ifndef NO_MARSHALLING
    if (hEvent)
        SetEvent(hEvent);
#endif

    ReleaseInterface (pMI);

    if (hr)
    {
        if (pDlg)
        {
            pDlg->Release();
            *ppDlg = NULL;
        }

#ifndef NO_MARSHALLING
        OleUninitialize();
#endif
    }

    RRETURN(hr);
}


//+-----------------------------------------------------------------
//
//  Method : CreateModelessDialog
//
//  Synopsis : does the actual creation of hte modeless dialog. this
//      code parallels the logic in internalShowModalDialog.
//
//------------------------------------------------------------------

HRESULT 
CreateModelessDialog(IHTMLModelessInit * pMI, 
                     IMoniker * pMoniker,
                     DWORD      dwFlags,
                     HWND       hwndParent,
                     CHTMLDlg **ppDialog) 
{
    HRESULT        hr;
    HTMLDLGINFO    dlginfo;
    CHTMLDlg     * pDlg = NULL;
    RECT           rc;
    TCHAR        * pchOptions = NULL;
    CVariant       cvarTransfer;

    Assert(ppDialog);
    Assert(pMI);
    Assert(pMoniker);

    // set the nonpropdesc options, these should match the defaults
    //------------------------------------------------------------
    dlginfo.fPropPage  = FALSE;
    dlginfo.pmk        = pMoniker;
    dlginfo.hwndParent = hwndParent;
    dlginfo.fModeless  = TRUE;
    dlginfo.dwFlags    = dwFlags;

    // Actually create the dialog
    //---------------------------
    pDlg = new CHTMLDlg(NULL, !(dwFlags & HTMLDLG_DONTTRUST), NULL);
    if (!pDlg)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Now set appropriate binding info and other dialog member variables
    //-------------------------------------------------------------------
    hr = pMI->get_parameters( &(pDlg->_varArgIn));
    if (hr)
    {
        VariantInit(&(pDlg->_varArgIn));
    }

    pDlg->_lcid = g_lcidUserDefault;
    pDlg->_fKeepHidden = dwFlags & HTMLDLG_NOUI ? TRUE : FALSE;
    pDlg->_fAutoExit = dwFlags & HTMLDLG_AUTOEXIT ? TRUE : FALSE;

    hr = pMI->get_optionString( &cvarTransfer );
    if (hr==S_OK )
    {
        pchOptions = (V_VT(&cvarTransfer)==VT_BSTR ) ? V_BSTR(&cvarTransfer) : NULL;
    }

    if (pchOptions)
        dlginfo.pvarOptions = &cvarTransfer;
    
    hr = THR(pDlg->Create(&dlginfo));
    if (hr)
        goto Cleanup;

    rc.left   = pDlg->GetLeft();
    rc.top    = pDlg->GetTop();
    rc.right  = rc.left + pDlg->GetWidth();
    rc.bottom = rc.top  + pDlg->GetHeight();

    if (pDlg->_fVerifyRect)
    {
        // Dialog width and heght each have a minimum size and no bigger than screen size
        // and the dialog Must be all on the screen
        // We need to pass a hwndParent that is used for multimonitor systems to determine
        // which monitor to use for restricting the dialog
        pDlg->VerifyDialogRect(&rc, dlginfo.hwndParent);
    }

    hr = THR(pDlg->Activate(dlginfo.hwndParent, &rc, FALSE));

    *ppDialog = pDlg;

Cleanup:
    if (hr && pDlg)
    {
        pDlg->Release();
        *ppDialog = NULL;
    }

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmldlg\popframe.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       popframe.cxx
//
//  Contents:   Implementation of the frame for hosting html popup
//
//  History:    05-28-99  YinXIE   Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_HTMLPOP_HXX_
#define X_HTMLPOP_HXX_
#include "htmlpop.hxx"
#endif

DeclareTag(tagHTMLPopupFrameMethods, "HTML Dialog Frame", "Methods on the html dialog frame")

IMPLEMENT_SUBOBJECT_IUNKNOWN(CHTMLPopupFrame, CHTMLPopup, HTMLPopup, _Frame);


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::QueryInterface
//
//  Synopsis:   Per IUnknown
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IOleInPlaceFrame ||
        iid == IID_IOleWindow ||
        iid == IID_IOleInPlaceUIWindow ||
        iid == IID_IUnknown)
    {
        *ppv = (IOleInPlaceFrame *) this;
        AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::GetWindow
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::GetWindow(HWND * phWnd)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleWindow::GetWindow"));
    
    *phWnd = HTMLPopup()->_hwnd;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::ContextSensitiveHelp
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleWindow::ContextSensitiveHelp"));
    
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::GetBorder
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::GetBorder(LPOLERECT prcBorder)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleInPlaceUIWindow::GetBorder"));

#ifndef WIN16    
    HTMLPopup()->GetViewRect(prcBorder);
#else
    RECTL rcBorder;
    HTMLPopup()->GetViewRect(&rcBorder);
    CopyRect(prcBorder, &rcBorder);
#endif
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::RequestBorderSpace
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::RequestBorderSpace(LPCBORDERWIDTHS pbw)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleInPlaceUIWindow::RequestBorderSpace"));
    
    RRETURN(INPLACE_E_NOTOOLSPACE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::SetBorderSpace
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::SetBorderSpace(LPCBORDERWIDTHS pbw)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleInPlaceUIWindow::SetBorderSpace"));
    
    RRETURN(INPLACE_E_NOTOOLSPACE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::SetActiveObject
//
//  Synopsis:   Per IOleInPlaceUIWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::SetActiveObject(
        LPOLEINPLACEACTIVEOBJECT    pActiveObj,
        LPCTSTR                     pstrObjName)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleInPlaceUIWindow::SetActiveObject"));
    
    ReplaceInterface(&HTMLPopup()->_pInPlaceActiveObj, pActiveObj);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::InsertMenus
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS pmgw)
{        
    TraceTag((tagHTMLPopupFrameMethods, "IOleInPlaceFrame::InsertMenus"));
    
    pmgw->width[0] = pmgw->width[2] = pmgw->width[4] = 0;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::SetMenu
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleInPlaceFrame::SetMenu"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::RemoveMenus
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::RemoveMenus(HMENU hmenuShared)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleInPlaceFrame::RemoveMenus"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::SetStatusText
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::SetStatusText(LPCTSTR szStatusText)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleInPlaceFrame::SetStatusText"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::EnableModeless
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::EnableModeless(BOOL fEnable)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleInPlaceFrame::EnableModeless"));
    
    //  TODO: (anandra) should probably disable ourselves?
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupFrame::TranslateAccelerator
//
//  Synopsis:   Per IOleInPlaceFrame
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupFrame::TranslateAccelerator(LPMSG pmsg, WORD wID)
{
    TraceTag((tagHTMLPopupFrameMethods, "IOleInPlaceFrame::TranslateAccelerator"));
    
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmldlg\popsite.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       popsite.cxx
//
//  Contents:   Implementation of the site for hosting html popups
//
//  History:    05-28-99  YinXIE   Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_HTMLPOP_HXX_
#define X_HTMLPOP_HXX_
#include "htmlpop.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#define SID_SOmWindow IID_IHTMLWindow2

// to a header file visible here or include formkrnl.hxx here
#define CMDID_SCRIPTSITE_HTMLPOPTRUST 1

DeclareTag(tagHTMLPopupSiteMethods, "HTML Popup Site", "Methods on the html popup site")

IMPLEMENT_SUBOBJECT_IUNKNOWN(CHTMLPopupSite, CHTMLPopup, HTMLPopup, _Site);

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::QueryInterface
//
//  Synopsis:   Per IUnknown
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IOleClientSite ||
        iid == IID_IUnknown)
    {
        *ppv = (IOleClientSite *) this;
    }
    else if (iid == IID_IOleInPlaceSite ||
             iid == IID_IOleWindow)
    {
        *ppv = (IOleInPlaceSite *) this;
    }
    else if (iid == IID_IOleControlSite)
    {
        *ppv = (IOleControlSite *) this;
    }
    else if (iid == IID_IDispatch)
    {
        *ppv = (IDispatch *) this;
    }
    else if (iid == IID_IServiceProvider)
    {
        *ppv = (IServiceProvider *)this;
    }
    else if (iid == IID_ITargetFrame)
    {
        *ppv = (ITargetFrame *)this;
    }
    else if (iid == IID_ITargetFrame2)
    {
        *ppv = (ITargetFrame2 *)this;
    }
    else if (iid == IID_IDocHostUIHandler)
    {
        *ppv = (IDocHostUIHandler *)this;
    }
    else if (iid == IID_IOleCommandTarget)
    {
        *ppv = (IOleCommandTarget *)this;
    }
    else if (iid == IID_IInternetSecurityManager)
    {
        *ppv = (IInternetSecurityManager *) this ;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::SaveObject
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::SaveObject()
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleClientSite::SaveObject"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::GetMoniker
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::GetMoniker(
        DWORD dwAssign,
        DWORD dwWhichMoniker,
        LPMONIKER * ppmk)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleClientSite::GetMoniker"));

    //lookatme
    *ppmk = NULL;
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::GetContainer
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::GetContainer(LPOLECONTAINER * ppContainer)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleClientSite::GetContainer"));
    
    *ppContainer = NULL;
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::ShowObject
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::ShowObject()
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleClientSite::ShowObject"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::OnShowWindow
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::OnShowWindow(BOOL fShow)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleClientSite::OnShowWindow"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::RequestNewObjectLayout
//
//  Synopsis:   Per IOleClientSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::RequestNewObjectLayout( )
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleClientSite::RequestNewObjectLayout"));
    
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::GetWindow
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::GetWindow(HWND * phwnd)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleWindow::GetWindow"));

    *phwnd = NULL;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::ContextSensitiveHelp
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleWindow::ContextSensitiveHelp"));
    
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::CanInPlaceActivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::CanInPlaceActivate()
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleInPlaceSite::CanInPlaceActivate"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::OnInPlaceActivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::OnInPlaceActivate()
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleInPlaceSite::OnInPlaceActivate"));
    
    HRESULT     hr;

    hr = THR(HTMLPopup()->_pOleObj->QueryInterface(
            IID_IOleInPlaceObject,
            (void **) &HTMLPopup()->_pInPlaceObj));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::OnUIActivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::OnUIActivate( )
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleInPlaceSite::OnUIActivate"));
    
    // Clean up any of our ui.
    // IGNORE_HR(HTMLPopup()->_Frame.SetMenu(NULL, NULL, NULL));

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::GetWindowContext
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::GetWindowContext(
        LPOLEINPLACEFRAME  *    ppFrame,
        LPOLEINPLACEUIWINDOW  * ppDoc,
        LPOLERECT               prcPosRect,
        LPOLERECT               prcClipRect,
        LPOLEINPLACEFRAMEINFO   pFI)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleInPlaceSite::GetWindowContext"));
    
    *ppFrame = &HTMLPopup()->_Frame;
    (*ppFrame)->AddRef();

    *ppDoc = NULL;

#ifndef WIN16
    HTMLPopup()->GetViewRect(prcPosRect);
#else
    RECTL rcView;
    HTMLPopup()->GetViewRect(&rcView);
    CopyRect(prcPosRect, &rcView);
#endif
    *prcClipRect = *prcPosRect;

    pFI->fMDIApp = FALSE;
    pFI->hwndFrame = HTMLPopup()->_hwnd;
    pFI->haccel = NULL;
    pFI->cAccelEntries = 0;

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::Scroll
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::Scroll(OLESIZE scrollExtent)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleInPlaceSite::Scroll"));
    
    RRETURN(E_NOTIMPL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::OnUIDeactivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::OnUIDeactivate(BOOL fUndoable)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleInPlaceSite::OnUIDeactivate"));

    HTMLPopup()->ClearPopupInParentDoc();

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::OnInPlaceDeactivate
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::OnInPlaceDeactivate( )
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleInPlaceSite::OnInPlaceDeactivate"));
    
    ClearInterface(&HTMLPopup()->_pInPlaceObj);
    ClearInterface(&HTMLPopup()->_pInPlaceActiveObj);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::DiscardUndoState
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::DiscardUndoState( )
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleInPlaceSite::DiscardUndoState"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::DeactivateAndUndo
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::DeactivateAndUndo( )
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleInPlaceSite::DeactivateAndUndo"));
    
    RRETURN(THR(HTMLPopup()->_pInPlaceObj->UIDeactivate()));
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::OnPosRectChange
//
//  Synopsis:   Per IOleInPlaceSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::OnPosRectChange(LPCOLERECT prcPosRect)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleInPlaceSite::OnPosRectChange"));
    
    Assert(FALSE);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::OnControlInfoChanged
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::OnControlInfoChanged()
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleControlSite::OnControlInfoChanged"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::LockInPlaceActive
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::LockInPlaceActive(BOOL fLock)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleControlSite::LockInPlaceActive"));
    
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::GetExtendedControl
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::GetExtendedControl(IDispatch **ppDispCtrl)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleControlSite::GetExtendedControl"));
    
    RRETURN(HTMLPopup()->QueryInterface(IID_IDispatch, (void **)ppDispCtrl));
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::TransformCoords
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::TransformCoords(
    POINTL* pptlHimetric,
    POINTF* pptfContainer,
    DWORD dwFlags)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleControlSite::TransformCoords"));
    
    //lookatme
    // This tells the object that we deal entirely with himetric
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::TranslateAccelerator
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::TranslateAccelerator(LPMSG lpmsg, DWORD grfModifiers)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleControlSite::TranslateAccelerator"));

    return S_FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::OnFocus
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::OnFocus(BOOL fGotFocus)
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleControlSite::OnFocus"));
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLPopupSite::ShowPropertyFrame
//
//  Synopsis:   Per IOleControlSite
//
//--------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::ShowPropertyFrame()
{
    TraceTag((tagHTMLPopupSiteMethods, "IOleControlSite::ShowPropertyFrame"));
    
    // To disallow control showing prop-pages
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::GetTypeInfo
//
//  Synopsis:   per IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::GetTypeInfo(UINT itinfo, ULONG lcid, ITypeInfo ** ppTypeInfo)
{
    TraceTag((tagHTMLPopupSiteMethods, "IDispatch::GetTypeInfo"));
    
    RRETURN(E_NOTIMPL);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::GetTypeInfoCount
//
//  Synopsis:   per IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::GetTypeInfoCount(UINT * pctinfo)
{
    TraceTag((tagHTMLPopupSiteMethods, "IDispatch::GetTypeInfoCount"));
    
    *pctinfo = 0;
    RRETURN(E_NOTIMPL);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::GetIDsOfNames
//
//  Synopsis:   per IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::GetIDsOfNames(
    REFIID riid, 
    LPOLESTR * rgszNames, 
    UINT cNames, 
    LCID lcid, 
    DISPID * rgdispid)
{
    TraceTag((tagHTMLPopupSiteMethods, "IDispatch::GetIDsOfNames"));
    
    RRETURN(E_NOTIMPL);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::Invoke
//
//  Synopsis:   per IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::Invoke(
    DISPID dispidMember, 
    REFIID riid, 
    LCID lcid, 
    WORD wFlags,
    DISPPARAMS * pdispparams, 
    VARIANT * pvarResult,
    EXCEPINFO * pexcepinfo, 
    UINT * puArgErr)
{
    TraceTag((tagHTMLPopupSiteMethods, "IDispatch::Invoke"));
    
    HRESULT     hr = DISP_E_MEMBERNOTFOUND;

    if (wFlags & DISPATCH_PROPERTYGET)
    {
        if (!pvarResult)
        {
            hr = E_POINTER;
            goto Cleanup;
        }
        
        VariantInit(pvarResult);

        switch (dispidMember)
        {
        case DISPID_AMBIENT_SHOWHATCHING:
        case DISPID_AMBIENT_SHOWGRABHANDLES:
            //
            // We don't want the ui-active control to show standard ole
            // hatching or draw grab handles.
            //

            V_VT(pvarResult) = VT_BOOL;
            V_BOOL(pvarResult) = (VARIANT_BOOL)0;
            hr = S_OK;
            break;
            
        }
    }
    
Cleanup:    
    return hr;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::QueryService
//
//  Synopsis:   per IServiceProvider
//
//---------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::QueryService(REFGUID sid, REFIID iid, LPVOID * ppv)
{
    HRESULT hr;

    if (sid == IID_IHTMLPopup)
    {
        hr = THR(HTMLPopup()->QueryInterface(iid, ppv));
    }
    else if (!HTMLPopup()->_pWindowParent)
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    else
    {
        hr = THR(HTMLPopup()->_pWindowParent->Document()->QueryService(sid, iid, ppv));
    }

    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::GetFrameOptions
//
//  Synopsis:   per ITargetFrame
//
//---------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::GetFrameOptions(DWORD *pdwFlags)
{
    //*pdwFlags = HTMLPopup()->_dwFrameOptions;
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::QueryStatus
//
//  Synopsis:   per IOleCommandTarget
//
//---------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::QueryStatus(
                const GUID * pguidCmdGroup,
                ULONG cCmds,
                MSOCMD rgCmds[],
                MSOCMDTEXT * pcmdtext)
{
    return OLECMDERR_E_UNKNOWNGROUP ;
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::Exec
//
//  Synopsis:   per IOleCommandTarget
//
//---------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::Exec(
                const GUID * pguidCmdGroup,
                DWORD nCmdID,
                DWORD nCmdexecopt,
                VARIANTARG * pvarargIn,
                VARIANTARG * pvarargOut)
{
    HRESULT  hr = S_OK;

    if(!pguidCmdGroup)
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;
        goto Cleanup;
    }

    hr = OLECMDERR_E_UNKNOWNGROUP;


Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::GetHostInfo
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::GetHostInfo(DOCHOSTUIINFO * pInfo)
{
    Assert(pInfo);
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_OK;

    if (pInfo->cbSize < sizeof(DOCHOSTUIINFO))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        IDocHostUIHandler * pHostUIHandler = NULL;

        if (HTMLPopup()->_pWindowParent)
            pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

        if (pHostUIHandler)
        {
            hr =  THR(pHostUIHandler->GetHostInfo(pInfo));
        }
        else
        {
            pInfo->dwFlags = DOCHOSTUIFLAG_DIALOG;
            pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;
            hr =  S_OK;
        }
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::ShowUI
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::ShowUI(DWORD dwID, IOleInPlaceActiveObject * pActiveObject, IOleCommandTarget * pCommandTarget, IOleInPlaceFrame * pFrame, IOleInPlaceUIWindow * pDoc)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_OK;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->ShowUI(dwID, pActiveObject, pCommandTarget, pFrame, pDoc));
    }
    
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::HideUI
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::HideUI(void)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_OK;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->HideUI());
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::UpdateUI
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::UpdateUI(void)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_OK;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->UpdateUI());
    }

    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::EnableModeless
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::EnableModeless(BOOL fEnable)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_OK;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->EnableModeless(fEnable));
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::OnDocWindowActivate
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::OnDocWindowActivate(BOOL fActivate)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_OK;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->OnDocWindowActivate(fActivate));
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::OnFrameWindowActivate
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::OnFrameWindowActivate(BOOL fActivate)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_OK;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->OnFrameWindowActivate(fActivate));
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::ResizeBorder
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow * pUIWindow, BOOL fRameWindow)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_OK;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->ResizeBorder(prcBorder, pUIWindow, fRameWindow));
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::ShowContextMenu
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::ShowContextMenu(DWORD dwID, POINT * pptPosition, IUnknown * pcmdtReserved, IDispatch * pDispatchObjectHit)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_FALSE;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->ShowContextMenu(dwID, pptPosition, pcmdtReserved, pDispatchObjectHit));
    }

    RRETURN1(hr, S_FALSE);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::TranslateAccelerator
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::TranslateAccelerator(LPMSG lpMsg, const GUID * pguidCmdGroup, DWORD nCmdID)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_FALSE;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->TranslateAccelerator(lpMsg, pguidCmdGroup, nCmdID));
    }

    RRETURN1(hr, S_FALSE);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::GetOptionKeyPath
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::GetOptionKeyPath(LPOLESTR * ppchKey, DWORD dw)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_FALSE;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->GetOptionKeyPath(ppchKey, dw));
    }

    RRETURN1(hr, S_FALSE);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::GetDropTarget
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------
STDMETHODIMP
CHTMLPopupSite::GetDropTarget(IDropTarget * pDropTarget, IDropTarget ** ppDropTarget)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_FALSE;
    IDocHostUIHandler * pHostUIHandler = NULL;

    if (HTMLPopup()->_pWindowParent)
        pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

    if (pHostUIHandler)
    {
        hr = THR(pHostUIHandler->GetDropTarget(pDropTarget, ppDropTarget));
    }

    RRETURN1(hr, S_FALSE);
}
//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::GetExternal
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::GetExternal(IDispatch **ppDisp)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_OK;

    if (!ppDisp)
    {
        hr = E_POINTER;
    }
    else
    {
        IDocHostUIHandler * pHostUIHandler = NULL;

        if (HTMLPopup()->_pWindowParent)
            pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

        if (pHostUIHandler)
        {
            hr = THR(pHostUIHandler->GetExternal(ppDisp));
        }
        else
        {
            hr = THR(HTMLPopup()->QueryInterface(IID_IDispatch, (void **)ppDisp));
        }
    }

    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::TranslateUrl
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::TranslateUrl(
    DWORD dwTranslate, 
    OLECHAR *pchURLIn, 
    OLECHAR **ppchURLOut)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT hr = S_OK;

    if (!ppchURLOut)
    {
        hr = E_POINTER;
    }
    else
    {
        IDocHostUIHandler * pHostUIHandler = NULL;

        if (HTMLPopup()->_pWindowParent)
            pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

        if (pHostUIHandler)
        {
            hr = THR(pHostUIHandler->TranslateUrl(dwTranslate, pchURLIn, ppchURLOut));
        }
        else
        {
            *ppchURLOut = NULL;
            hr = S_OK;
        }
    }
    
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::FilterDataObject
//
//  Synopsis:   per IDocHostUIHandler
//
//---------------------------------------------------------------------------

STDMETHODIMP
CHTMLPopupSite::FilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
    Assert(!HTMLPopup()->_pWindowParent || HTMLPopup()->_pWindowParent->Doc());

    HRESULT     hr = S_OK;
    
    if (!ppDORet)
    {
        hr = E_POINTER;
    }
    else
    {
        IDocHostUIHandler * pHostUIHandler = NULL;

        if (HTMLPopup()->_pWindowParent)
            pHostUIHandler = HTMLPopup()->_pWindowParent->Doc()->_pHostUIHandler;

        if (pHostUIHandler)
        {
            hr = THR(pHostUIHandler->FilterDataObject(pDO, ppDORet));
        }
        else
        {
            *ppDORet = NULL;
            hr = S_OK;
        }
    }
   
    RRETURN(hr);
}


//+=======================================================================
//
//
// IInternetSecurityManager Methods
//
// marka - CHTMLPopupSite now implements an IInternetSecurityManager
// this is to BYPASS the normal Security settings for a trusted HTML Popup in a "clean" way
//
// QueryService - for IID_IInternetSecurity Manager - will return that interface
// if we are a _trusted Popup. Otherwise we fail this QueryService and use the "normal"
// security manager.
//
// RATIONALE:
//
//    - Moving popup code to mshtmled.dll requires implementing COptionsHolder as an
//      embedded object. Hence if we were honoring the user's Security Settings - if they had 
//    ActiveX turned off - they could potentially break popups.
//
//  - If you're in a "trusted" HTML popup (ie invoked via C-code), your potential to do
//      anything "unsafe" is infinite - so why not allow all security actions ?
//
//
//
//==========================================================================


//+------------------------------------------------------------------------
//
//  Member:     CHtmlPopupSite::SetSecuritySite
//
//    Implementation of IInternetSecurityManager::SetSecuritySite
//
//  Synopsis:   Sets the Security Site Manager
//
//
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::SetSecuritySite( IInternetSecurityMgrSite *pSite )
{
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlPopupSite::GetSecuritySite
//
//    Implementation of IInternetSecurityManager::GetSecuritySite
//
//  Synopsis:   Returns the Security Site Manager
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::GetSecuritySite( IInternetSecurityMgrSite **ppSite )
{
    *ppSite = NULL;
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlPopupSite::MapURLToZone
//
//    Implementation of IInternetSecurityManager::MapURLToZone
//
//  Synopsis:   Returns the ZoneIndex for a given URL
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::MapUrlToZone(
                        LPCWSTR     pwszUrl,
                        DWORD*      pdwZone,
                        DWORD       dwFlags
                    )
{
    return INET_E_DEFAULT_ACTION;
}
                    
//+------------------------------------------------------------------------
//
//  Member:     CHtmlPopupSite::ProcessURLAction
//
//    Implementation of IInternetSecurityManager::ProcessURLAction
//
//  Synopsis:   Query the security manager for a given action
//              and return the response.  This is basically a true/false
//              or allow/disallow return value.
//
//                (marka) We assume that for HTML Popups - a Security Manager is *ONLY*
//                created if we are in a Trusted Popup ( see QueryService above)
//
//                Hence we then allow *ALL* actions
//
//
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::ProcessUrlAction(
                        LPCWSTR     pwszUrl,
                        DWORD       dwAction,
                        BYTE*   pPolicy,    // output buffer pointer
                        DWORD   cbPolicy,   // output buffer size
                        BYTE*   pContext,   // context (used by the delegation routines)
                        DWORD   cbContext,  // size of the Context
                        DWORD   dwFlags,    // See enum PUAF for details.
                        DWORD   dwReserved)
{
    if (cbPolicy == sizeof(DWORD))
        *(DWORD*)pPolicy = URLPOLICY_ALLOW;
    else if (cbPolicy == sizeof(WORD))
        *(WORD*)pPolicy = URLPOLICY_ALLOW;
    else // BYTE or unknown type
        *pPolicy = URLPOLICY_ALLOW;
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::GetSecurityID
//
//    Implementation of IInternetSecurityManager::GetSecurityID
//
//  Synopsis:   Retrieves the Security Identification of the given URL
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::GetSecurityId( 
            LPCWSTR pwszUrl,
            BYTE __RPC_FAR *pbSecurityId,
            DWORD __RPC_FAR *pcbSecurityId,
            DWORD_PTR dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::SetZoneMapping
//
//    Implementation of IInternetSecurityManager::SetZoneMapping
//
//  Synopsis:   Sets the mapping of a Zone
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::SetZoneMapping  (
                    DWORD   dwZone,        // absolute zone index
                    LPCWSTR lpszPattern,   // URL pattern with limited wildcarding
                    DWORD   dwFlags       // add, change, delete
)
{
    return INET_E_DEFAULT_ACTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::QueryCustomPolicy
//
//    Implementation of IInternetSecurityManager::QueryCustomPolicy
//
//  Synopsis:   Retrieves the custom policy associated with the URL and
//                specified key in the given context
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::QueryCustomPolicy (
                        LPCWSTR     pwszUrl,
                        REFGUID     guidKey,
                        BYTE**  ppPolicy,   // pointer to output buffer pointer
                        DWORD*  pcbPolicy,  // pointer to output buffer size
                        BYTE*   pContext,   // context (used by the delegation routines)
                        DWORD   cbContext,  // size of the Context
                        DWORD   dwReserved )
 {
    return INET_E_DEFAULT_ACTION;
 }
                        
//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopupSite::GetZoneMappings
//
//    Implementation of IInternetSecurityManager::GetZoneMapping
//
//  Synopsis:   Sets the mapping of a Zone
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopupSite::GetZoneMappings (
                    DWORD   dwZone,        // absolute zone index
                    IEnumString  **ppenumString,   // output buffer size
                    DWORD   dwFlags        // reserved, pass 0
)
{
    return INET_E_DEFAULT_ACTION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\htmldlg\htmlpop.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       htmlpop.cxx
//
//  Contents:   Implementation of the CHtmlPopup
//
//  History:    05-27-99  YinXIE   Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif


#ifndef X_SITEGUID_H_
#define X_SITEGUID_H_
#include "siteguid.h"
#endif

#ifndef X_ROSTM_HXX_
#define X_ROSTM_HXX_
#include "rostm.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_COMMIT_HXX_
#define X_COMMIT_HXX_
#include "commit.hxx"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include "dispex.h"
#endif

#ifndef X_COREDISP_H_
#define X_COREDISP_H_
#include <coredisp.h>
#endif

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#include <shellapi.h>
#endif

#ifndef X_MULTIMON_H_
#define X_MULTIMON_H_
#include <multimon.h>
#endif

#ifndef X_HTMLPOP_HXX_
#define X_HTMLPOP_HXX_
#include "htmlpop.hxx"
#endif

#ifndef X_FUNCSIG_HXX_
#define X_FUNCSIG_HXX_
#include "funcsig.hxx"
#endif

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#define WINCOMMCTRLAPI
#include <commctrl.h>
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_MARKUP_HXX_
#define X_MARKUP_HXX_
#include "markup.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"    // for MAKEUNITVALUE macro.
#endif

#ifndef X_CFPF_HXX_
#define X_CFPF_HXX_
#include "cfpf.hxx"     // for propdesc components
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"    // for CSSParser
#endif

// True if we run on unicode operating system
extern BOOL g_fUnicodePlatform;

#define _cxx_
#include "htmlpop.hdl"

DeclareTag(tagHTMLPopupMethods, "HTML Popup", "Methods on the html popup")
MtDefine(Popup, Mem, "Popup")
MtDefine(CHTMLPopup, Popup, "CHTMLPopup")
MtDefine(CHTMLPopupFactory, Popup, "CHTMLPopupFactory")

const CBase::CLASSDESC CHTMLPopup::s_classdesc =
{
    &CLSID_HTMLPopup,               // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLPopup,                // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};


MtDefine(CHTMLPopup_s_aryStackPopup_pv, CHTMLPopup, "CHTMLPopup::_aryStackPopup::_pv");

HHOOK CHTMLPopup::s_hhookMouse = 0;

// REVIEW alexmog: this calls a global constructor. Can we avoid it?
CStackAryPopup CHTMLPopup::s_aryStackPopup;

typedef HMONITOR (WINAPI* PFNMONITORFROMPOINT)(POINT, DWORD);
typedef BOOL     (WINAPI* PFNGETMONITORINFO)(HMONITOR, LPMONITORINFO);

PFNMONITORFROMPOINT g_pfnMonitorFromPoint = NULL;
PFNGETMONITORINFO   g_pfnGetMonitorInfo = NULL;
BOOL                g_fMutlimonInitialized = FALSE;

BOOL
InitMultimonFuncs()
{
    if (g_fMutlimonInitialized)
        return g_pfnGetMonitorInfo != NULL;

    g_pfnGetMonitorInfo = (PFNGETMONITORINFO)GetProcAddress(GetModuleHandleA("user32"), "GetMonitorInfoA");
    if (g_pfnGetMonitorInfo != NULL)
    {
        g_pfnMonitorFromPoint = (PFNMONITORFROMPOINT)GetProcAddress(GetModuleHandleA("user32"), "MonitorFromPoint");
        if (g_pfnMonitorFromPoint == NULL)
        {
            g_pfnGetMonitorInfo = NULL;
        }
    }

    g_fMutlimonInitialized = TRUE;
    return g_pfnGetMonitorInfo != NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   PopupMouseProc
//
//  Synopsis:   
//--------------------------------------------------------------------------

static LRESULT CALLBACK 
PopupMouseProc(int  nCode, WPARAM  wParam, LPARAM  lParam)
{
    if (nCode < 0)  /* do not process the message */
        goto Cleanup;

    if (nCode == HC_ACTION)
    {
        Assert(CHTMLPopup::s_aryStackPopup.Size());
        MOUSEHOOKSTRUCT *   pmh = (MOUSEHOOKSTRUCT *) lParam;
        int i;

        if (    wParam != WM_LBUTTONDOWN
            &&  wParam != WM_MBUTTONDOWN
            &&  wParam != WM_RBUTTONDOWN
            &&  wParam != WM_NCLBUTTONDOWN
            &&  wParam != WM_NCMBUTTONDOWN
            &&  wParam != WM_NCRBUTTONDOWN
            )
            goto Cleanup;

        for (i = CHTMLPopup::s_aryStackPopup.Size() - 1; i >= 0; i --)
        {
            if (PtInRect(&CHTMLPopup::s_aryStackPopup[i]->_rcView, pmh->pt))
                break;

            CHTMLPopup::s_aryStackPopup[i]->hide();
        }
    }

Cleanup:
    return CallNextHookEx(CHTMLPopup::s_hhookMouse, nCode, wParam, lParam);
}


CBase *
CreateHTMLPopup(IUnknown *pUnkOuter)
{
    return new CHTMLPopup(pUnkOuter);
}

CHTMLPopupFactory g_cfHTMLPopup   (CreateHTMLPopup);

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopup
//
//  Synopsis:   ctor
//
//-------------------------------------------------------------------------

CHTMLPopup::CHTMLPopup(IUnknown *pUnkOuter) //, BOOL fTrusted, IUnknown *pUnkHost)
         : CBase()
{
    TraceTag((tagHTMLPopupMethods, "constructing CHTMLPopup"));
    _fIsOpen = FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     ~CHTMLPopup
//
//  Synopsis:   dtor
//
//-------------------------------------------------------------------------

CHTMLPopup::~CHTMLPopup( )
{
    Assert(!s_hhookMouse);
    TraceTag((tagHTMLPopupMethods, "destroying CHTMLPopup"));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopup::hide
//
//  Synopsis:   Show Window
//
//  Arguments:
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopup::hide()
{
    HRESULT hr = S_OK;
    CDoc *pDoc = NULL;

    if (!_fIsOpen || !_pOleObj)
        goto Cleanup;

    hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void**)&pDoc));
    if (FAILED(hr) || _pWindowParent->Doc()->_pDocPopup != pDoc)
        goto Cleanup;

    hr = THR(_pOleObj->DoVerb(
            OLEIVERB_HIDE,
            NULL,
            &_Site,
            0,
            0, //GetDesktopWindow(),
            ENSUREOLERECT(&_rcView)));

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopup::Show
//
//  Synopsis:   Show Window
//
//  Arguments: 
//
//      x,y,w,h:    position and size of the window
//      pElement:   IUnknown of the element, optional, if none, position abs
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopup::show( long x, long y, long w, long h, VARIANT *pElement)
{
    HRESULT         hr = S_OK;
    SIZEL           sizel;
    CDoc           *pDocPopup = NULL;
    RECT            rcDesktop;
    BOOL            fPosRelative =      pElement->vt == VT_UNKNOWN 
                                    ||  pElement->vt == VT_DISPATCH;

    HMONITOR        hMonitor;
    MONITORINFO     mi;
    IOleWindow     *pIOleWnd = NULL;

    if (!_pUnkObj)
    {
        hr = THR(CreatePopupDoc());
        if (FAILED(hr))
            goto Cleanup;
    }

    Assert(_pOleObj);
    Assert(_pWindowParent && _pWindowParent->Doc());

    if (!_pWindowParent->Doc()->InPlace())
        goto Cleanup;

    hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void**)&pDocPopup));
    if (FAILED(hr))
        goto Cleanup;

    //
    // if there is a popup window on the parant doc, hide it
    //

    if (_pWindowParent->Doc()->_pDocPopup && pDocPopup != _pWindowParent->Doc()->_pDocPopup)
    {
        IGNORE_HR(_pWindowParent->Doc()->_pDocPopup->DoVerb(OLEIVERB_HIDE,
                                    NULL,
                                    _pWindowParent->Doc()->_pDocPopup->_pClientSite,
                                    0,
                                    NULL,
                                    NULL));
    }

    sizel.cx = HimetricFromHPix(w);
    sizel.cy = HimetricFromVPix(h);

    IGNORE_HR(_pOleObj->SetExtent(DVASPECT_CONTENT, &sizel));

    if (fPosRelative && pElement->punkVal)
    {
        CElement*       pElem = NULL;
        CRect           rc;
        GetWindowRect(_pWindowParent->Doc()->InPlace()->_hwnd, &rc);

        x = x + rc.left;
        y = y + rc.top;

        hr = THR(pElement->punkVal->QueryInterface(CLSID_CElement, (void**)&pElem));
        if (FAILED(hr))
            goto Cleanup;
        hr = THR(pElem->GetBoundingRect(&rc, RFE_SCREENCOORD));
        if (FAILED(hr))
            goto Cleanup;
        x = x + rc.left;
        y = y + rc.top;
    }

    if (InitMultimonFuncs())
    {
        hMonitor   = g_pfnMonitorFromPoint(CPoint(x, y), MONITOR_DEFAULTTONEAREST);
        mi.cbSize  = sizeof(mi);
        g_pfnGetMonitorInfo(hMonitor, &mi);
        rcDesktop = mi.rcMonitor;
    }
    else
    {
        GetWindowRect(GetDesktopWindow(), &rcDesktop);
    }

    //
    // if the popup window goes out of desktop window space
    // display it inside
    //

    if (x < rcDesktop.left)
    {
        x = rcDesktop.left;
    }
    if (y < rcDesktop.top)
    {
        y = rcDesktop.top;
    }
    if (x + w > rcDesktop.right)
    {
        x = rcDesktop.right - w;
    }

    if (y + h > rcDesktop.bottom)
    {
        y = rcDesktop.bottom - h;
    }

    _rcView.left = x;
    _rcView.top  = y;

    _rcView.right   = x + w;
    _rcView.bottom  = y + h;

    if (    _fIsOpen
        &&  _pWindowParent->Doc()->_pDocPopup
        &&  _pWindowParent->Doc()->_pDocPopup == pDocPopup)
    {
        pDocPopup->SetObjectRects(ENSUREOLERECT(&_rcView), ENSUREOLERECT(&_rcView));
    }
    else
    {
        _pWindowParent->Doc()->_pDocPopup = pDocPopup;

        hr = THR(_pOleObj->DoVerb(
                        OLEIVERB_SHOW,
                        NULL,
                        &_Site,
                        0,
                        0, //GetDesktopWindow(),
                        ENSUREOLERECT(&_rcView)));

        if (FAILED(hr))
            goto Cleanup;
    }

    hr = THR(_pUnkObj->QueryInterface(IID_IOleWindow, (void **)&pIOleWnd));

    if (FAILED(hr))
        goto Cleanup;

    IGNORE_HR(pIOleWnd->GetWindow(&_hwnd));

    ReleaseInterface(pIOleWnd);

    if (!s_hhookMouse)
    {
        s_hhookMouse = SetWindowsHookEx( WH_MOUSE,
                                        PopupMouseProc,
                                        (HINSTANCE) NULL, GetCurrentThreadId());
    }

    if (!_fIsOpen)
    {
        s_aryStackPopup.Append(this);

        _fIsOpen = TRUE;
    }

Cleanup:
    RRETURN(hr);
}

HRESULT CHTMLPopup::CreatePopupDoc()
{
    HRESULT             hr    = S_OK;
    IPersistMoniker     *pPMk = NULL;
    IMoniker            *pMk  = NULL;
    IPersistStreamInit  *pPSI = NULL;


    TCHAR               *pBaseUrl;
    CElement            *pElementBase = NULL;
    BOOL                fDefault;
    CDoc                *pDocPopup = NULL;
    
    IHTMLElement        *pIBody = NULL;
    IHTMLStyle          *pIStyleBody = NULL;
    IHTMLDocument2      *pIDoc2 = NULL;

    Assert(_pWindowParent && _pWindowParent->Doc());

    hr = THR(CoCreateInstance(CLSID_HTMLPopupDoc,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IUnknown,
                                  (void **) &_pUnkObj));

    if (FAILED(hr))
        goto Cleanup;

    //
    //  initialize CBase members
    //

    hr = THR(DefaultMembers());
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(_pUnkObj->QueryInterface(IID_IOleObject, (void **) &_pOleObj));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(_pOleObj->SetClientSite(&_Site));
    if (FAILED(hr))
        goto Cleanup;

    hr = _pUnkObj->QueryInterface(IID_IPersistStreamInit,(void**)&pPSI);
    if (FAILED(hr))
        goto Cleanup;

    hr = pPSI->InitNew();
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(CMarkup::GetBaseUrl(
                                 _pWindowParent->Markup(),
                                 &pBaseUrl,
                                 pElementBase,
                                 &fDefault,
                                 NULL));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void**)&pDocPopup));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(_pUnkObj->QueryInterface(IID_IHTMLDocument2, (void**)&pIDoc2));
    if (FAILED(hr))
        goto Cleanup;

    pDocPopup->_pPopupParentWindow = _pWindowParent;
    pDocPopup->SetPrimaryUrl(pBaseUrl);
    pDocPopup->PrimaryMarkup()->UpdateSecurityID();

    //
    // set the default style on the body
    //

    hr = pIDoc2->get_body(&pIBody);
    if (FAILED(hr))
        goto Cleanup;

    if (!pIBody)
        goto Cleanup;

    hr = pIBody->get_style(&pIStyleBody);
    if (FAILED(hr))
       goto Cleanup;

    hr = pIStyleBody->put_border(_T("0"));
    if (FAILED(hr))
       goto Cleanup;

    hr = pIStyleBody->put_margin(_T("0"));
    if (FAILED(hr))
       goto Cleanup;

    hr = pIStyleBody->put_padding(_T("0"));
    if (FAILED(hr))
       goto Cleanup;

    hr = pIStyleBody->put_overflow(_T("hidden"));
    if (FAILED(hr))
       goto Cleanup;

Cleanup:
    ClearInterface(&pIDoc2);
    ClearInterface(&pIBody);
    ClearInterface(&pIStyleBody);
    ClearInterface(&pMk);
    ClearInterface(&pPMk);
    ClearInterface(&pPSI);
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopup::Passivate
//
//  Synopsis:   1st stage destruction
//
//-------------------------------------------------------------------------

void
CHTMLPopup::Passivate()
{
    if (_fIsOpen && _pOleObj)
    {
        hide();
    }

    if (!_pWindowParent->IsShuttingDown())
    {
        CDoc *pDoc = NULL;
        HRESULT hr = S_OK;
        hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void**)&pDoc));
        if (SUCCEEDED(hr) && pDoc == _pWindowParent->Doc()->_pDocPopup)
        {
            _pWindowParent->Doc()->_pDocPopup = NULL;
        }
    }
    ClearInterface(&_pOleObj);
    ClearInterface(&_pUnkObj);
    _pWindowParent->Release();
    _pWindowParent = NULL;

    super::Passivate();
}


//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopup::GetViewRect
//
//  Synopsis:   Get the rectangular extent of the window.
//
//-------------------------------------------------------------------------

void
CHTMLPopup::GetViewRect(RECT *prc)
{
    *prc = _rcView;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopup::get_document
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopup::get_document(IHTMLDocument ** ppDoc)
{
    HRESULT hr = S_OK;
    CDoc   *pDocPopup = NULL;

    Assert (ppDoc);

    *ppDoc = NULL;

    //
    // if there is no doc create the doc
    //

    if (!_pUnkObj)
    {
        hr = THR(CreatePopupDoc());

        if (FAILED(hr))
            goto Cleanup;
    }

    Assert(_pUnkObj);

    hr = THR(_pUnkObj->QueryInterface(CLSID_HTMLDocument, (void**)&pDocPopup));
    if (FAILED(hr))
        goto Cleanup;

    if (!pDocPopup->PrimaryMarkup()->AccessAllowed(_pWindowParent->Markup()))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    hr = THR(_pUnkObj->QueryInterface(IID_IHTMLDocument, (void**)ppDoc));

Cleanup:

    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopup::get_isOpen
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopup::get_isOpen(VARIANT_BOOL * pfIsOpen)
{
    *pfIsOpen = _fIsOpen ? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLPopup::PrivateQueryInterface
//
//  Synopsis:   per IPrivateUnknown
//
//-------------------------------------------------------------------------

HRESULT
CHTMLPopup::PrivateQueryInterface(REFIID iid, void **ppv)
{
    HRESULT hr = S_OK;

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF(this, IHTMLPopup, NULL)

        default:
            if (iid == CLSID_HTMLPopup)
            {
                *ppv = this;
                goto Cleanup;
            }
            break;
    }

    if (!*ppv)
    {
        hr = E_NOINTERFACE;
    }
    else
    {
        ((IUnknown *)*ppv)->AddRef();
        hr = S_OK;
    }

Cleanup:
    RRETURN_NOTRACE(hr);
}

void
CHTMLPopup::ClearPopupInParentDoc()
{
    if (!_fIsOpen)
        return;

    _fIsOpen = FALSE;

    if (_pWindowParent && _pWindowParent->Doc())
    {
        _pWindowParent->Doc()->_pDocPopup = NULL;
    }

    if (s_hhookMouse)
    {
        int iSizeStack = s_aryStackPopup.Size();
        int i;

        Assert(iSizeStack);

        for (i = iSizeStack - 1; i >= 0; i --)
        {
            // BOOL fFound = s_aryStackPopup[i] == this;


            if (s_aryStackPopup[i] == this)
            {
                s_aryStackPopup.Delete(i);
                break;
            }
        }

        if (!s_aryStackPopup.Size())
        {
            UnhookWindowsHookEx(s_hhookMouse);
            s_hhookMouse = NULL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\include\othrdisp.h ===
/**************************************************************************************


  (rgardner) This file is obsolete - please put all changes in COREDISP.H
  It will be delfile'd shortly in a cleanup pass
                                                

 **************************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\include\framet.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       framet.h
//
//  Contents:   Frame Targeting function prototypes, definitions, etc.
//
//----------------------------------------------------------------------------


#ifndef __FRAMET_H__
#define __FRAMET_H__

#ifndef X_EXDISP_H_
#define X_EXDISP_H_
#include <exdisp.h>
#endif

interface IBrowserBand;
class     CDwnBindInfo;

// PLEASE PROPOGATE ANY CHANGES TO THESE ENUMS TO \mshtml\iextag\httpwfh.h
enum TARGET_TYPE
{
    TARGET_FRAMENAME,  // Normal frame target
    TARGET_SELF,       // Current window
    TARGET_PARENT,     // Parent of the current window.
    TARGET_BLANK,      // New window
    TARGET_TOP,        // Top-level window
    TARGET_MAIN,       // Main window if in search band, self otherwise.
    TARGET_SEARCH,     // Open and navigate in search band.
    TARGET_MEDIA,      // Open and navigate in media band.
};

struct TARGETENTRY
{
    TARGET_TYPE eTargetType;
    LPCOLESTR   pszTargetName;
};

static const TARGETENTRY targetTable[] =
{
    { TARGET_SELF,     _T("_self")    },
    { TARGET_PARENT,   _T("_parent")  },
    { TARGET_TOP,      _T("_top")     },
    { TARGET_MAIN,     _T("_main")    },
    { TARGET_SEARCH,   _T("_search")  },
    { TARGET_BLANK,    _T("_blank")   },
    { TARGET_MEDIA,    _T("_media")   },
    { TARGET_SELF,     NULL           }
};

TARGET_TYPE GetTargetType(LPCOLESTR pszTargetName);

// Function Prototypes
HRESULT GetTargetWindow(IHTMLWindow2  * pWindow,
                        LPCOLESTR       pszTargetName,
                        BOOL          * pfIsCurProcess,
                        IHTMLWindow2 ** ppTargetWindow);
                        
HRESULT FindWindowInContext(IHTMLWindow2  * pWindow,
                            LPCOLESTR       pszTargetName,
                            IHTMLWindow2  * pWindowCtx,
                            IHTMLWindow2 ** ppTargetWindow);
                            
HRESULT SearchChildrenForWindow(IHTMLWindow2  * pWindow,
                                LPCOLESTR       pszTargetName,
                                IHTMLWindow2  * pWindowCtx,
                                IHTMLWindow2 ** ppTargetWindow);
                                
HRESULT SearchParentForWindow(IHTMLWindow2  * pWindow,
                              LPCOLESTR       pszTargetName,
                              IHTMLWindow2 ** ppTargetWindow);
                              
HRESULT SearchBrowsersForWindow(LPCOLESTR       pszTargetName,
                                IWebBrowser2  * pThisBrwsr,
                                IHTMLWindow2 ** ppTargetWindow);
                             
HRESULT OpenInNewWindow(const TCHAR    * pchUrl,
                        const TCHAR    * pchTarget,
                        CDwnBindInfo *    pDwnBindInfo,
                        IBindCtx       * pBindCtx,
                        COmWindowProxy * pWindow,
                        BOOL             fReplace,
                        IHTMLWindow2  ** ppHTMLWindow2);
                        
HRESULT GetWindowByType(TARGET_TYPE     eTargetType,
                        IHTMLWindow2  * pWindow,
	                    IHTMLWindow2 ** ppTargHTMLWindow,
                        IWebBrowser2 ** ppTopWebOC);

HRESULT GetMainWindow(IHTMLWindow2  * pWindow,
                      IHTMLWindow2 ** ppTargHTMLWindow,
                      IWebBrowser2 ** ppTopWebOC);

HRESULT NavigateInBand(IHTMLDocument2 * pDocument,
                       IHTMLWindow2   * pOpenerWindow,
                       REFCLSID         clsid,
                       LPCTSTR          pszOriginalUrl,
                       LPCTSTR          pszExpandedUrl,
                       IHTMLWindow2  ** ppBandWindow);
                        
HRESULT GetBandWindow(IBrowserBand  * pBrowserBand,
                      IHTMLWindow2 ** ppBandWindow);

HRESULT GetBandCmdTarget(IHTMLDocument2     * pDocument,
                         IOleCommandTarget ** ppCmdTarget);

HRESULT GetDefaultSearchUrl(IBrowserBand * pBrowserBand,
                            BSTR         * pbstrUrl);

#endif  // __FRAMET_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\include\othrguid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       othrguid.h
//
//  History:    06-Jun-96   anandra     Created
//
//  Contents:   extern references for site guids and manifest constants
//              for dispids
//
//----------------------------------------------------------------------------

//
// Reserve 10000 GUID entries beginning 3050f160-98b5-11cf-bb82-00aa00bdce0b
// and ending at 30c38c70-98b5-11cf-bb82-00aa00bdce0b.
//
// See the next available GUID in ...\src\guids.txt
// Check procedure for using next available GUID with F3 procedures handbook
//

#ifndef __OTHRGUID_H__
#define __OTHRGUID_H__

// Use PUBLIC_GUID for GUIDs used outside FORMS3.DLL.
// Use PRIVATE_GUID for all other GUIDS.

#ifndef PUBLIC_GUID
#define PUBLIC_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif

#ifndef PRIVATE_GUID
#define PRIVATE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif



// Property Pages
#ifndef NO_PROPERTY_PAGE
PRIVATE_GUID(CLSID_CBackgroundPropertyPage,     0x3050f232, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PRIVATE_GUID(CLSID_CCDGenericPropertyPage,      0x3050f17f, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PRIVATE_GUID(CLSID_CCDAnchorPropertyPage,       0x3050f1fc, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PRIVATE_GUID(CLSID_CInlineStylePropertyPage,    0x3050f296, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PRIVATE_GUID(CLSID_CAnchorBrowsePropertyPage,   0x3050f3BB, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PRIVATE_GUID(CLSID_CImageBrowsePropertyPage,    0x3050f3B3, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PRIVATE_GUID(CLSID_CDocBrowsePropertyPage,      0x3050f3B4, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
#endif // NO_PROPERTY_PAGE
PRIVATE_GUID(SID_SHTMLProperyPageArg,           0x3050f404, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

PRIVATE_GUID(CLSID_CDwnBindInfo,                0x3050f3c2, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PRIVATE_GUID(  IID_IDwnBindInfo,                0x3050f3c3, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

PRIVATE_GUID(IID_IHistoryBindInfo,              0x3050f403, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

PUBLIC_GUID(SID_GetCaller,                      0x4717cc40, 0xbcb9, 0x11d0, 0x93, 0x36, 0x00, 0xa0, 0xc9, 0x0d, 0xca, 0xa9)
PUBLIC_GUID(CGID_ScriptSite,                    0x3050f3f1, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PRIVATE_GUID(CGID_DownloadObjectBindContext,    0x3050f3df, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PRIVATE_GUID(SID_QIClientSite,                  0x3050f803, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

PUBLIC_GUID(CLSID_JSProtocol,                   0x3050f3B2, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PUBLIC_GUID(CLSID_ResProtocol,                  0x3050f3bc, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PUBLIC_GUID(CLSID_MailtoProtocol,               0x3050f3da, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PUBLIC_GUID(CLSID_ViewSourceProtocol,           0x3050f400, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PUBLIC_GUID(CLSID_AboutProtocol,                0x3050f406, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PUBLIC_GUID(CLSID_SysimageProtocol,             0x76E67A63, 0x06E9, 0x11D2, 0xA8, 0x40, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82)

PRIVATE_GUID(CLSID_CHook,                       0x3050f500, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

PRIVATE_GUID(CGID_JavaParambagCompatHack,       0x3050F405, 0x98B5, 0x11CF, 0xBB, 0x82, 0x00, 0xAA, 0x00, 0xBD, 0xCE, 0x0B)

////////////////////////////////////////////////////////////////////////////////
//
// Scriptoid handlers:
//
////////////////////////////////////////////////////////////////////////////////

// {5AAF51B1-B1F0-11d1-B6AB-00A0C90833E9}
PUBLIC_GUID(CLSID_CCSSFilterHandler,            0x5aaf51b1, 0xb1f0, 0x11d1, 0xb6, 0xab, 0x0, 0xa0, 0xc9, 0x8, 0x33, 0xe9)
// {5AAF51B2-B1F0-11d1-B6AB-00A0C90833E9}
PUBLIC_GUID(CLSID_CPeerHandler,                 0x5aaf51b2, 0xb1f0, 0x11d1, 0xb6, 0xab, 0x0, 0xa0, 0xc9, 0x8, 0x33, 0xe9)
// {5AAF51B3-B1F0-11d1-B6AB-00A0C90833E9}
PUBLIC_GUID(CLSID_CHiFiUses,                    0x5aaf51b3, 0xb1f0, 0x11d1, 0xb6, 0xab, 0x0, 0xa0, 0xc9, 0x8, 0x33, 0xe9)
// {3050f4f0-98b5-11cf-bb82-00aa00bdce0b}
PUBLIC_GUID(CLSID_CSvrOMUses,                   0x3050f4f0, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

PRIVATE_GUID(IID_IScriptletHandler,             0xa001a870, 0xa7df, 0x11d1, 0x89, 0xbe, 0x00, 0x60, 0x08, 0xc3, 0xfb, 0xfc)
PRIVATE_GUID(IID_IScriptletHandlerConstructor,  0xa3d52a50, 0xb7ff, 0x11d1, 0xa3, 0x5a, 0x00, 0x60, 0x08, 0xc3, 0xfb, 0xfc)
PRIVATE_GUID(SID_ScriptletSite,                 0x22a98050, 0xa65d, 0x11d1, 0x89, 0xbe, 0x00, 0x60, 0x08, 0xc3, 0xfb, 0xfc)
PRIVATE_GUID(IID_IScriptletError,               0xdf9f3d20, 0xa670, 0x11d1, 0x89, 0xbe, 0x00, 0x60, 0x08, 0xc3, 0xfb, 0xfc)
PRIVATE_GUID(IID_IScriptletSite,                0xc5f21c30, 0xa7df, 0x11d1, 0x89, 0xbe, 0x00, 0x60, 0x08, 0xc3, 0xfb, 0xfc)

PUBLIC_GUID(CLSID_HTADoc,		                0x3050f5c8, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)
PUBLIC_GUID(CLSID_HTMLPopupDoc,	                0x3050f67D, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

// Service ID that handlers ask for on the scriptlet object to get at the
// internal IDispatchEx namespace.
PUBLIC_GUID(SID_ScriptletDispatch,              0x66289210, 0x6b18, 0x11d1, 0x8c, 0xac, 0x0, 0xa0, 0xc9, 0xf, 0xff, 0xc0)
PRIVATE_GUID(SID_SServerOM,                     0x3050f4f1, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

// shdocvw guids
PRIVATE_GUID(SID_STopFrameBrowser, 0xa9227c3c, 0x7f8e, 0x11d0, 0x8c, 0xb0, 0x0,  0xa0, 0xc9, 0x2d, 0xbf, 0xe8);
PRIVATE_GUID(IID_IBrowserService,  0x02ba3b52, 0x0547, 0x11d1, 0xb8, 0x33, 0x0,  0xc0, 0x4f, 0xc9, 0xb3, 0x1f);
PRIVATE_GUID(IID_ITravelLogEx,     0x3050f679, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0,  0xaa, 0x00, 0xbd, 0xce, 0x0b);
PRIVATE_GUID(IID_ITravelLogClient, 0x3050f67a, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0,  0xaa, 0x00, 0xbd, 0xce, 0x0b);
PRIVATE_GUID(IID_ITridentService,  0x3050f801, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0,  0xaa, 0x00, 0xbd, 0xce, 0x0b);
PRIVATE_GUID(IID_ITridentService2, 0xf62d9369, 0x75ef, 0x4578, 0x88, 0x56, 0x23, 0x28, 0x02, 0xc7, 0x64, 0x68);
PRIVATE_GUID(CLSID_SearchBand,     0x30d02401, 0x6a81, 0x11d0, 0x82, 0x74, 0x0,  0xc0, 0x4f, 0xd5, 0xae, 0x38);
PRIVATE_GUID(CLSID_MediaBand,      0x32683183, 0x48a0, 0x441b, 0xa3, 0x42, 0x7c, 0x2a, 0x44, 0x0a, 0x94, 0x78);
PRIVATE_GUID(SID_SProxyBrowser,    0x20C46561, 0x8491, 0x11CF, 0x96, 0x0C, 0x0,  0x80, 0xC7, 0xF4, 0xEE, 0x85);
PRIVATE_GUID(IID_IBrowserBand,     0x6b707a1c, 0x744f, 0x11d2, 0x86, 0xb9, 0x0,  0xc0, 0x4f, 0x8e, 0xea, 0x99);
PRIVATE_GUID(SID_SExplorerToolbar, 0x8455f0c1, 0x158f, 0x11d0, 0x89, 0xae, 0x0,  0xa0, 0xc9, 0x0a, 0x90, 0xac);
PRIVATE_GUID(IID_ISearchItems,     0x830abff0, 0xafd9, 0x11d1, 0xb9, 0xf1, 0x0,  0xa0, 0xc9, 0x8b, 0xc5, 0x47);
PRIVATE_GUID(CGID_DocHostCmdPriv,  0x000214D4, 0x0000, 0x0000, 0xc0, 0x00, 0x0,  0x00, 0x00, 0x00, 0x00, 0x46);
PRIVATE_GUID(IID_IWebBrowserPriv,  0x3050f804, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0,  0xaa, 0x00, 0xbd, 0xce, 0x0b);

PRIVATE_GUID(IID_IInitViewLinkedWebOC,0xe787f2c0,0x3d21,0x4d98,0x85,0xc8,0xa0,0x38,0x19,0x5b,0xa6,0x49);

//ATL 
DEFINE_GUID(IID_IAxWinHostWindow,  0xb6ea2050, 0x48a,  0x11d1, 0x82, 0xb9, 0x0, 0xc0, 0x4f, 0xb9, 0x94, 0x2e);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\include\otherrc.h ===
To be removed

//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       otherrc.h
//
//  Contents:   Resource identifiers for Form project.
//
//----------------------------------------------------------------------------
//
//  Resource identifier ranges.
//  See corerc.h for a complete listing of ranges used in Forms3.
//
//  05000 - 07999    Other miscellaneous
//
//----------------------------------------------------------------------------

#ifndef __OTHERRC_H__
#define __OTHERRC_H__

#define IDC_STATIC              -1      // all static controls, lifted from AFXRES.H


//----------------------------------------------------------------------------
//
// Strings (50xx)
//
//----------------------------------------------------------------------------

#define IDS_PROPERTYOPENPICTURE     5010
#define IDS_PROPERTYOPENMOUSEICON   5011


//----------------------------------------------------------------------------
//
// Generic property page (52xx)
//
//----------------------------------------------------------------------------

#define IDD_GENERICPAGE             5202
#define IDC_PROPNAME                5204
#define IDE_PROPVALUE               5208
#define IDB_APPLY                   5209
#define IDB_OPENDLG                 5210
#define IDS_PPG_GENERIC             5211
#define IDS_PPG_INLINE_STYLE        5212

//----------------------------------------------------------------------------
//
// HTML dialog (53xx)
//
//----------------------------------------------------------------------------

#define IDS_WEBPAGEDIALOG           5301
#define IDS_CODEPAGE                5302

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\include\webocutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       webocutil.h
//
//  Contents:   WebBrowser control utility functions
//
//----------------------------------------------------------------------------

#ifndef __WEBOCUTIL_H__
#define __WEBOCUTIL_H__

#ifndef X_EXDISPID_H_
#define X_EXDISPID_H_
#include "exdispid.h"
#endif

class CBase;

// Function Prototypes
HRESULT GetParentWebOC(IHTMLWindow2  * pWindow,
                       IWebBrowser2 ** ppWebBrowser);

HRESULT GetWebOCWindow(IWebBrowser2  * pWebBrowser,
                       BOOL            fGetWindowObject,
                       IHTMLWindow2 ** ppWindow);

void InvokeSink(IConnectionPoint * pConnPt,
                DISPID             dispidEvent,
                DISPPARAMS       * pDispParams);

void InvokeEventV(IConnectionPoint * pConnPt,
                  CBase            * pFrameSite,
                  DISPID             dispidEvent, 
                  int                cArgs,
                  ...);
                  
HRESULT FormatUrlForDisplay(LPCTSTR lpszIn,
                            LPTSTR  lpszOut,
                            LPDWORD pcchOut);

HRESULT FormatUrl(LPCTSTR lpszUrl,    LPCTSTR lpszLocation,
                  LPTSTR  lpszUrlOut, DWORD   cchUrl);

HRESULT GetWebOCDocument(IUnknown * pUnk, IDispatch ** pDispatch);
          
HRESULT NavigateWebOCWithBindCtx(IWebBrowser2 * pWebBrowser,
                                 VARIANT      * pvarUrl,
                                 VARIANT      * pvarFlags,
                                 VARIANT      * pvarFrameName,
                                 VARIANT      * pvarPostData,
                                 VARIANT      * pvarHeaders,
                                 IBindCtx     * pBindCtx,
                                 LPCTSTR        pchLocation);
#endif  // __WEBOCUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\misc\browsersvc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 2000
//
//  File    : browsersvc.cxx
//
//  Contents: IBrowserService interface implementation.
//
//  Author  : Scott Roberts (scotrobe)  01/18/2000
//
//----------------------------------------------------------------------------

#include "headers.hxx"

// Prototypes
//
HRESULT PidlFromUrl(LPCTSTR pszUrl, LPITEMIDLIST * ppidl);
UINT    GetUrlScheme(const TCHAR * pchUrlIn);
HRESULT IEParseDisplayNameWithBCW(UINT uiCP,      LPCWSTR pwszPath,
                                  IBindCtx * pbc, LPITEMIDLIST * ppidlOut);
#ifndef DLOAD1
LPITEMIDLIST SHSimpleIDListFromPathPriv(LPCTSTR pszPath);
#endif

DeclareTag(tagIBrowserService, "IBrowserService implementation", "Trace WebOC Events")

#define NOTIMPL_METHOD(base, fn, FN, args) \
    HRESULT base::fn args \
    { \
        AssertSz(0, FN " should not have been called."); \
        return E_NOTIMPL; \
    }
    
// NOTIMPL_METHOD_NUM works with returns values
// that accept a number - int, long, DWORD, etc.
//
#define NOTIMPL_METHOD_NUM(base, fn, FN, ret, args) \
    ret base::fn args \
    { \
        AssertSz(0, FN " should not have been called."); \
        return 0; \
    }

// Tearoff Table Declaration
//
BEGIN_TEAROFF_TABLE(CDocument, IBrowserService)
    TEAROFF_METHOD(CDocument, GetParentSite, getparentsite, (IOleInPlaceSite** ppipsite))
    TEAROFF_METHOD(CDocument, SetTitle, settitle, (IShellView* psv, LPCWSTR pszName))
    TEAROFF_METHOD(CDocument, GetTitle, gettitle, (IShellView* psv, LPWSTR pszName, DWORD cchName))
    TEAROFF_METHOD(CDocument, GetOleObject, getoleobject, (IOleObject** ppobjv))
    TEAROFF_METHOD(CDocument, GetTravelLog, gettravellog, (ITravelLog** pptl))
    TEAROFF_METHOD(CDocument, ShowControlWindow, showcontrolwindow, (UINT id, BOOL fShow))
    TEAROFF_METHOD(CDocument, IsControlWindowShown, iscontrolwindowshown, (UINT id, BOOL *pfShown))
    TEAROFF_METHOD(CDocument, IEGetDisplayName, iegetdisplayname, (LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags))
    TEAROFF_METHOD(CDocument, IEParseDisplayName, ieparsedisplayname, (UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut))
    TEAROFF_METHOD(CDocument, DisplayParseError, displayparseerror, (HRESULT hres, LPCWSTR pwszPath))
    TEAROFF_METHOD(CDocument, NavigateToPidl, navigatetopidl, (LPCITEMIDLIST pidl, DWORD grfHLNF))
    TEAROFF_METHOD(CDocument, SetNavigateState, setnavigatestate, (BNSTATE bnstate))
    TEAROFF_METHOD(CDocument, GetNavigateState, getnavigatestate, (BNSTATE * pbnstate))
    TEAROFF_METHOD(CDocument, NotifyRedirect, notifyredirect, (IShellView* psv, LPCITEMIDLIST pidl, BOOL * pfDidBrowse))
    TEAROFF_METHOD(CDocument, UpdateWindowList, updatewindowlist, ())
    TEAROFF_METHOD(CDocument, UpdateBackForwardState, updatebackforwardstate, ())
    TEAROFF_METHOD(CDocument, SetFlags, setflags, (DWORD dwFlags, DWORD dwFlagMask))
    TEAROFF_METHOD(CDocument, GetFlags, getflags, (DWORD *pdwFlags))
    TEAROFF_METHOD(CDocument, CanNavigateNow, cannavigatenow, ())

    TEAROFF_METHOD(CDocument, GetPidl, getpidl, (LPITEMIDLIST *ppidl))

    TEAROFF_METHOD(CDocument, SetReferrer, setreferrer, (LPITEMIDLIST pidl))
    TEAROFF_METHOD_(CDocument, GetBrowserIndex, getbrowserindex, DWORD, ())
    TEAROFF_METHOD(CDocument, GetBrowserByIndex, getbrowserbyindex, (DWORD dwID, IUnknown **ppunk))
    TEAROFF_METHOD(CDocument, GetHistoryObject, gethistoryobject, (IOleObject **ppole, IStream **pstm, IBindCtx **ppbc))
    TEAROFF_METHOD(CDocument, SetHistoryObject, sethistoryobject, (IOleObject *pole, BOOL fIsLocalAnchor))
    TEAROFF_METHOD(CDocument, CacheOLEServer, cacheoleserver, (IOleObject *pole))
    TEAROFF_METHOD(CDocument, GetSetCodePage, getsetcodepage, (VARIANT* pvarIn, VARIANT* pvarOut))
    TEAROFF_METHOD(CDocument, OnHttpEquiv, onhttpequiv, (IShellView* psv, BOOL fDone, VARIANT* pvarargIn, VARIANT* pvarargOut))
    TEAROFF_METHOD(CDocument, GetPalette, getpalette, (HPALETTE * hpal ))
    TEAROFF_METHOD(CDocument, RegisterWindow, registerwindow, (BOOL fUnregister, int swc))
END_TEAROFF_TABLE()

NOTIMPL_METHOD(CDocument, GetParentSite, "GetParentSite", (IOleInPlaceSite** ppipsite)) 
NOTIMPL_METHOD(CDocument, SetTitle, "SetTitle", (IShellView* psv, LPCWSTR pszName))
NOTIMPL_METHOD(CDocument, GetTitle, "GetTitle", (IShellView* psv, LPWSTR pszName, DWORD cchName))
NOTIMPL_METHOD(CDocument, GetOleObject, "GetOleObject", (IOleObject** ppobjv))
NOTIMPL_METHOD(CDocument, GetTravelLog, "GetTravelLog", (ITravelLog** pptl))
NOTIMPL_METHOD(CDocument, ShowControlWindow, "ShowControlWindow", (UINT id, BOOL fShow))
NOTIMPL_METHOD(CDocument, IsControlWindowShown, "IsControlWindowShown", (UINT id, BOOL *pfShown))
NOTIMPL_METHOD(CDocument, IEGetDisplayName, "IEGetDisplayName", (LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags))
NOTIMPL_METHOD(CDocument, IEParseDisplayName, "IEParseDisplayName", (UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut))
NOTIMPL_METHOD(CDocument, DisplayParseError, "DisplayParseError", (HRESULT hres, LPCWSTR pwszPath))
NOTIMPL_METHOD(CDocument, NavigateToPidl, "NavigateToPidl", (LPCITEMIDLIST pidl, DWORD grfHLNF))
NOTIMPL_METHOD(CDocument, SetNavigateState, "SetNavigateState", (BNSTATE bnstate))
NOTIMPL_METHOD(CDocument, GetNavigateState, "GetNavigateState", (BNSTATE * pbnstate))
NOTIMPL_METHOD(CDocument, NotifyRedirect, "NotifyRedirect", (IShellView * psv, LPCITEMIDLIST pidl, BOOL * pfDidBrowse))
NOTIMPL_METHOD(CDocument, UpdateWindowList, "UpdateWindowList", ())
NOTIMPL_METHOD(CDocument, UpdateBackForwardState, "UpdateBackForwardState", ())
NOTIMPL_METHOD(CDocument, SetFlags, "SetFlags", (DWORD dwFlags, DWORD dwFlagMask))
NOTIMPL_METHOD(CDocument, GetFlags, "GetFlags", (DWORD * pdwFlags))
NOTIMPL_METHOD(CDocument, CanNavigateNow, "CanNavigateNow", ())
NOTIMPL_METHOD(CDocument, SetReferrer, "SetReferrer", (LPITEMIDLIST pidl))
NOTIMPL_METHOD_NUM(CDocument, GetBrowserIndex, "GetBrowserIndex", DWORD, ())
NOTIMPL_METHOD(CDocument, GetBrowserByIndex, "GetBrowserByIndex", (DWORD dwID, IUnknown **ppunk))
NOTIMPL_METHOD(CDocument, GetHistoryObject, "GetHistoryObject", (IOleObject **ppole, IStream **pstm, IBindCtx **ppbc))
NOTIMPL_METHOD(CDocument, SetHistoryObject, "SetHistoryObject", (IOleObject *pole, BOOL fIsLocalAnchor))
NOTIMPL_METHOD(CDocument, CacheOLEServer, "CacheOLEServer", (IOleObject *pole))
NOTIMPL_METHOD(CDocument, GetSetCodePage, "GetSetCodePage", (VARIANT* pvarIn, VARIANT* pvarOut))
NOTIMPL_METHOD(CDocument, OnHttpEquiv, "OnHttpEquiv", (IShellView* psv, BOOL fDone, VARIANT* pvarargIn, VARIANT* pvarargOut))
NOTIMPL_METHOD(CDocument, GetPalette, "GetPalette", (HPALETTE * hpal ))
NOTIMPL_METHOD(CDocument, RegisterWindow, "RegisterWindow", (BOOL fUnregister, int swc))

//+-------------------------------------------------------------------------
//
//  Method   : GetPidl
//
//  Synopsis : Returns the current URL in ITEMIDLIST (pidl) format.
//
//  Output   : ppidl - the pidl that contains the current URL.
//
//--------------------------------------------------------------------------

HRESULT
CDocument::GetPidl(LPITEMIDLIST * ppidl)
{
    HRESULT hr = S_OK;
    BSTR    bstrUrl;

    if (!ppidl)
        return E_POINTER;

    hr = get_URLUnencoded(&bstrUrl);
    if (hr)
        goto Cleanup;

    hr = PidlFromUrl(bstrUrl, ppidl);

Cleanup:
    SysFreeString(bstrUrl);
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method   : PidlFromUrl
//
//  Synopsis : Converts an URL to a PIDL. This method handles the case
//             where IEParseDisplayNameWithBCW fails because it can't 
//             handle URLs with fragment identifiers (#, ?, etc.)
//
//  Input    : cstrUrl - the URL to convert to a PIDL.
//  Output   : ppdil   - the pidl.
//
//--------------------------------------------------------------------------

HRESULT
PidlFromUrl(LPCTSTR pszUrl, LPITEMIDLIST * ppidl)
{
    HRESULT hr = IEParseDisplayNameWithBCW(CP_ACP, pszUrl, NULL, ppidl);
    if (hr)
        goto Cleanup;

    // IEParseDisplayNameWithBCW will return a null pidl if 
    // the URL has any kind of fragment identifier at the
    // end - #, ? =, etc.
    //    
    if (!*ppidl) 
    {
        TCHAR szPath[INTERNET_MAX_URL_LENGTH];
        DWORD cchBuf = ARRAY_SIZE(szPath);

        // If it's a FILE URL, convert it to a path.
        // Otherwise, if it's not a file URL or if it is
        // and the conversion fails, just copy the given URL
        // to szPath so it can be easily converted to a Pidl.
        //
        if ( (GetUrlScheme(pszUrl) != URL_SCHEME_FILE)
          || SUCCEEDED(PathCreateFromUrl(pszUrl, szPath, &cchBuf, 0)))
        {
            StrCpyN(szPath, pszUrl, ARRAY_SIZE(szPath));
        }

#ifndef DLOAD1
        *ppidl = SHSimpleIDListFromPathPriv(szPath);
#else
        *ppidl = SHSimpleIDListFromPath(szPath);
#endif
        if (!*ppidl)
            hr = E_FAIL;
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\misc\frameweboc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 2000
//
//  File    : frameweboc.cxx
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_FRAMEWEBOC_HXX_
#define X_FRAMEWEBOC_HXX_
#include "frameweboc.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_HTIFACE_H_
#define X_HTIFACE_H_
#include "htiface.h"
#endif

#ifndef X_PERHIST_H_
#define X_PERHIST_H_
#include "perhist.h"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_OBJSAFE_H_
#define X_OBJSAFE_H_
#include "objsafe.h"
#endif

#ifndef X_URLHIST_H_
#define X_URLHIST_H_
#include "urlhist.h"
#endif

extern BOOL OLECMDIDFromIDM(int idm, ULONG *pulCmdID);

MtDefine(CFrameWebOC, ObjectModel, "CFrameWebOC");

HRESULT
CWindow::EnsureFrameWebOC()
{
    HRESULT hr = S_OK;

    if (!_pFrameWebOC)
    {
        _pFrameWebOC = new CFrameWebOC(this);
        if (!_pFrameWebOC)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}

const CONNECTION_POINT_INFO CFrameWebOC::s_acpi[] =
{
    CPI_ENTRY(IID_IDispatch, DISPID_A_EVENTSINK)
    CPI_ENTRY(DIID_DWebBrowserEvents, DISPID_A_EVENTSINK)
    CPI_ENTRY(DIID_DWebBrowserEvents2, DISPID_A_EVENTSINK)
    CPI_ENTRY_NULL
};

const CBase::CLASSDESC CFrameWebOC::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    s_acpi,                         // _pcpi
    0,                              // _dwFlags
    &IID_IWebBrowser2,               // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

CFrameWebOC::CFrameWebOC(CWindow * pWindow)
{
    _pWindow = pWindow;
    _pWindowForReleasing = pWindow;
    
    if (pWindow)
    {
        pWindow->SubAddRef();
    }
    else
    {
        AssertSz(0,"Someone is passing NULL to the constructor of CFrameWebOC");
    }
}

CFrameWebOC::~CFrameWebOC()
{
    if (_pWindowForReleasing != NULL)
    {
        _pWindowForReleasing->SubRelease();
        _pWindowForReleasing = NULL;
    }
}

HRESULT
CFrameWebOC::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
#if DBG==1
    char *pchIIDName = NULL;
#endif

    *ppv = NULL;

    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    switch (iid.Data1)
    {
    QI_INHERITS2(this, IUnknown, IWebBrowser2)
    QI_TEAROFF_DISPEX(this, NULL)
    QI_INHERITS(this,  IWebBrowser2)
    QI_INHERITS2(this, IWebBrowser, IWebBrowser2)
    QI_INHERITS2(this, IWebBrowserApp, IWebBrowser2)
    QI_TEAROFF(this,  IHlinkFrame, NULL)
    QI_TEAROFF(this,  ITargetFrame, NULL)
    QI_TEAROFF(this,  IServiceProvider, NULL)
    QI_TEAROFF(this,  IPersistHistory, NULL)
    QI_TEAROFF2(this, IPersist, IPersistHistory, NULL)
    QI_TEAROFF(this, IOleCommandTarget, NULL)
    QI_TEAROFF(this, IExternalConnection, NULL)
    QI_TEAROFF(this, IProvideClassInfo2, NULL)
    QI_TEAROFF2(this, IProvideClassInfo, IProvideClassInfo2, NULL)
    QI_TEAROFF(this, IOleWindow, NULL)
    QI_CASE(IConnectionPointContainer)
    {
        *((IConnectionPointContainer **)ppv) =
                new CConnectionPointContainer(this, NULL);

        if (!*ppv)
            RRETURN(E_OUTOFMEMORY);
        
        SetFrameWebOCEventsShouldFire();
        break;
    }

    // NOTE: If we had implemented the FrameWebOC in the early days of NativeFrames
    // then this itf would be important for shdocvw frame targetting. However,
    // we have worked around this problem in shdocvw, and hence we should never
    // implement this itf on this object.
    QI_CASE(ITargetFramePriv)
    {
        RRETURN(E_NOINTERFACE);
        break;
    }

#if DBG==1 
#define QI_CRASH(itfName1__, itfName2__) case Data1_##itfName1__: if (iid == IID_##itfName1__) {pchIIDName = #itfName1__;goto handle_##itfName2__;} else break; 
    QI_CRASH(IDataObject, IViewObject2)
    QI_CRASH(IInternetSecurityMgrSite, IViewObject2)
    QI_CRASH(IObjectSafety, IViewObject2)
    QI_CRASH(IOleControl, IViewObject2)
    QI_CRASH(IOleInPlaceActiveObject, IViewObject2)
    QI_CRASH(IOleInPlaceObject, IViewObject2)
    QI_CRASH(IOleObject, IViewObject2)
    QI_CRASH(IPersistPropertyBag, IViewObject2)
    QI_CRASH(IPersistStorage, IViewObject2)
    QI_CRASH(IPersistStream, IViewObject2)
    QI_CRASH(IPersistStreamInit, IViewObject2)
    QI_CRASH(ITargetEmbedding, IViewObject2)
    QI_CRASH(ITargetFrame2, IViewObject2)
    QI_CRASH(ITargetNotify, IViewObject2)
    QI_CRASH(IUrlHistoryNotify, IViewObject2)
    QI_CRASH(IViewObject, IViewObject2)
    case Data1_IViewObject2:
    {
        if (iid == IID_IViewObject2)
        {
            pchIIDName = "IViewObject2";
            
handle_IViewObject2:

            if (pchIIDName)
            {
                char mes[2000];
                mes[0] = 0;
                strcat(mes, "Need to implement interface: ");
                strcat(mes, pchIIDName);
                AssertSz(0, &mes[0]);
            }
        }
        break;
    }
#undef QI_CRASH
#endif // DBG==1
    }
    
    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}

//
// IDispatch[Ex] methods
//
//========================================================

HRESULT
CFrameWebOC::FrameOCGetDispid(  REFIID      riid,
                             LPOLESTR  * rgszNames,
                             UINT        cNames,
                             LCID        lcidParam,
                             DISPID    * rgdispid)
{
    HRESULT hr = E_INVALIDARG;
    BSTR    bstrName = NULL;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    if (!IsEqualIID(riid, IID_NULL) || !rgdispid)
        goto Cleanup;

    bstrName = SysAllocString(rgszNames[0]);
    if ( bstrName )
    {
        hr = GetWebOCDispID(bstrName, fdexFromGetIdsOfNames, rgdispid);
    
        if (hr == DISP_E_MEMBERNOTFOUND)
            hr = super::GetIDsOfNames(riid, rgszNames, cNames, lcidParam, rgdispid);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
Cleanup:
    SysFreeString(bstrName);
    return hr;
}

HRESULT
CFrameWebOC::FrameOCInvoke(DISPID       dispidMember,
                    REFIID       riid,
                    LCID         lcid,
                    WORD         wFlags,
                    DISPPARAMS * pdispparams,
                    VARIANT    * pvarResult,
                    EXCEPINFO  * pexcepinfo,
                    UINT       * puRet)
{
    HRESULT  hr = E_INVALIDARG;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    if (!IsEqualIID(riid, IID_NULL))
        goto Cleanup;

    hr = InvokeWebOC(this, dispidMember, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, NULL);
    if (FAILED(hr))
    {
        hr = super::Invoke(dispidMember, riid, lcid, wFlags, 
                           pdispparams, pvarResult, pexcepinfo, puRet);
    }
    
Cleanup:
    return hr;
}



HRESULT
CFrameWebOC::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    RRETURN(GetWebOCDispID(bstrName, (grfdex & fdexNameCaseSensitive), pid));
}

HRESULT
CFrameWebOC::InvokeEx(DISPID dispidMember,
                      LCID lcid,
                      WORD wFlags,
                      DISPPARAMS * pdispparams,
                      VARIANT * pvarResult,
                      EXCEPINFO * pexcepinfo,
                      IServiceProvider * pSrvProvider)
{
    HRESULT hr = E_FAIL;
    
    FRAME_WEBOC_PASSIVATE_CHECK(hr);
        
    hr = InvokeWebOC(this, dispidMember, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, pSrvProvider);

    RRETURN(hr);
}


BEGIN_TEAROFF_TABLE(CFrameWebOC, IDispatchEx)
    //  IDispatch methods
    TEAROFF_METHOD(CFrameWebOC, super::GetTypeInfoCount, super::gettypeinfocount, (unsigned int *))
    TEAROFF_METHOD(CFrameWebOC, super::GetTypeInfo, super::gettypeinfo, (unsigned int, unsigned long, ITypeInfo **))
    TEAROFF_METHOD(CFrameWebOC, FrameOCGetDispid, FrameOCGetDispid, (REFIID, LPOLESTR *, unsigned int, LCID, DISPID *))
    TEAROFF_METHOD(CFrameWebOC, FrameOCInvoke, FrameOCInvoke, (DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, unsigned int *))
    //  IDispatchEx methods
    TEAROFF_METHOD(CFrameWebOC, GetDispID, getdispid, (BSTR,DWORD,DISPID*))
    TEAROFF_METHOD(CFrameWebOC, InvokeEx, invokeex, (DISPID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,IServiceProvider*))
    TEAROFF_METHOD(CFrameWebOC, super::DeleteMemberByName, super::deletememberbyname, (BSTR,DWORD))
    TEAROFF_METHOD(CFrameWebOC, super::DeleteMemberByDispID, super::deletememberbydispid, (DISPID))
    TEAROFF_METHOD(CFrameWebOC, super::GetMemberProperties, super::getmemberproperties, (DISPID,DWORD,DWORD*))
    TEAROFF_METHOD(CFrameWebOC, super::GetMemberName, super::getmembername, (DISPID,BSTR*))
    TEAROFF_METHOD(CFrameWebOC, super::GetNextDispID, super::getnextdispid, (DWORD,DISPID,DISPID*))
    TEAROFF_METHOD(CFrameWebOC, super::GetNameSpaceParent, super::getnamespaceparent, (IUnknown**))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CFrameWebOC, IHlinkFrame)
    TEAROFF_METHOD(CFrameWebOC, SetBrowseContext, setbrowsecontext, (IHlinkBrowseContext * pihlbc))
    TEAROFF_METHOD(CFrameWebOC, GetBrowseContext, getbrowsecontext, (IHlinkBrowseContext ** ppihlbc))
    TEAROFF_METHOD(CFrameWebOC, Navigate, navigate, (DWORD grfHLNF, LPBC pbc, IBindStatusCallback * pibsc, IHlink * pihlNavigate))
    TEAROFF_METHOD(CFrameWebOC, OnNavigate, onnavigate, (DWORD grfHLNF, IMoniker * pimkTarget,
                                                     LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName, DWORD dwreserved))
    TEAROFF_METHOD(CFrameWebOC, UpdateHlink, updatehlink, (ULONG uHLID, IMoniker * pimkTarget,
                                                       LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CFrameWebOC, ITargetFrame)
    TEAROFF_METHOD(CFrameWebOC, SetFrameName, setframename, (LPCWSTR pszFrameName))
    TEAROFF_METHOD(CFrameWebOC, GetFrameName, getframename, (LPWSTR * ppszFrameName))
    TEAROFF_METHOD(CFrameWebOC, GetParentFrame, getparentframe, (IUnknown ** ppunkParent))
    TEAROFF_METHOD(CFrameWebOC, FindFrame, findframe, (LPCWSTR pszTargetName,
                                                   IUnknown * ppunkContextFrame,
                                                   DWORD dwFlags,
                                                   IUnknown ** ppunkTargetFrame))
    TEAROFF_METHOD(CFrameWebOC, SetFrameSrc, setframesrc, (LPCWSTR pszFrameSrc))
    TEAROFF_METHOD(CFrameWebOC, GetFrameSrc, getframesrc, (LPWSTR * ppszFrameSrc))
    TEAROFF_METHOD(CFrameWebOC, GetFramesContainer, getframescontainer, (IOleContainer ** ppContainer))
    TEAROFF_METHOD(CFrameWebOC, SetFrameOptions, setframeoptions, (DWORD dwFlags))
    TEAROFF_METHOD(CFrameWebOC, GetFrameOptions, getframeoptions, (DWORD * pdwFlags))
    TEAROFF_METHOD(CFrameWebOC, SetFrameMargins, setframemargins, (DWORD dwWidth, DWORD dwHeight))
    TEAROFF_METHOD(CFrameWebOC, GetFrameMargins, getframemargins, (DWORD * pdwWidth, DWORD * pdwHeight))
    TEAROFF_METHOD(CFrameWebOC, RemoteNavigate, remotenavigate, (ULONG cLength, ULONG * pulData))
    TEAROFF_METHOD(CFrameWebOC, OnChildFrameActivate, onchildframeactivate, (IUnknown * pUnkChildFrame))
    TEAROFF_METHOD(CFrameWebOC, OnChildFrameDeactivate, onchildframedeactivate, (IUnknown * pUnkChildFrame))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CFrameWebOC, IServiceProvider)
    TEAROFF_METHOD(CFrameWebOC, QueryService, queryservice, (REFGUID guidService, REFIID riid, void ** ppvObject))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CFrameWebOC, IPersistHistory)
    // IPersist methods
    TEAROFF_METHOD(CFrameWebOC, GetClassID, getclassid, (LPCLSID lpClassID))
    // IPersistHistory methods
    TEAROFF_METHOD(CFrameWebOC, LoadHistory, loadhistory, (IStream *pStream, IBindCtx *pbc))
    TEAROFF_METHOD(CFrameWebOC, SaveHistory, savehistory, (IStream *pStream))
    TEAROFF_METHOD(CFrameWebOC, SetPositionCookie, setpositioncookie, (DWORD dwCookie))
    TEAROFF_METHOD(CFrameWebOC, GetPositionCookie, getpositioncookie, (DWORD *pdwCookie))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CFrameWebOC, IOleCommandTarget)
    TEAROFF_METHOD(CFrameWebOC,  QueryStatus, querystatus, (GUID * pguidCmdGroup, ULONG cCmds, MSOCMD rgCmds[], MSOCMDTEXT * pcmdtext))
    TEAROFF_METHOD(CFrameWebOC,  Exec, exec, (GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG * pvarargIn, VARIANTARG * pvarargOut))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CFrameWebOC, IExternalConnection)
    TEAROFF_METHOD(CFrameWebOC, AddConnection, addconnection, ( DWORD extConn, DWORD dwReserved))
    TEAROFF_METHOD(CFrameWebOC, ReleaseConnection, releaseconnection, ( DWORD extConn, DWORD dwReserved, BOOL fLastReleaseCloses))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CFrameWebOC, IProvideClassInfo2)
    TEAROFF_METHOD(CFrameWebOC, GetClassInfo, getclassinfo, (ITypeInfo ** ppTI))
    TEAROFF_METHOD(CFrameWebOC, GetGUID, getguid, (DWORD dwGuidKind, GUID * pGUID))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CFrameWebOC, IOleWindow)
    TEAROFF_METHOD(CFrameWebOC, GetWindow, getwindow, (HWND * lphwnd))
    TEAROFF_METHOD(CFrameWebOC, ContextSensitiveHelp, contextsensitivehelp, (BOOL fEnterMode))
END_TEAROFF_TABLE()
            
#define DELEGATE_METHOD(klass, fn, args1, args2)\
    HRESULT\
    klass::fn##args1\
    {\
        RRETURN(_pWindow->##fn##args2);\
    }\

// IPersist methods
DELEGATE_METHOD(CFrameWebOC, GetClassID, (LPCLSID lpClassID), (lpClassID))

// IPersistHistory methods
DELEGATE_METHOD(CFrameWebOC, LoadHistory, (IStream *pStream, IBindCtx *pbc), (pStream, pbc))
DELEGATE_METHOD(CFrameWebOC, SaveHistory, (IStream *pStream), (pStream))
DELEGATE_METHOD(CFrameWebOC, SetPositionCookie, (DWORD dwCookie), (dwCookie))
DELEGATE_METHOD(CFrameWebOC, GetPositionCookie, (DWORD *pdwCookie), (pdwCookie))

//
// This array MUST be kept in sorted order. The
// binary search in GetWebOCDispID() depends on it
//
// NOTE : FOR COMPAT WITH 50 and earlier, the dispidID must be consistent
// with what was in the typelib for the WebOC
//
typedef struct {
    const TCHAR  * pchName;
    DISPID         dispidID;
} mapNameToDispID ;

static mapNameToDispID g_rgWebOCDispIDs[] = {
     _T("AddressBar"),         WEBOC_DISPID_ADDRESSBAR,
     _T("Application"),        WEBOC_DISPID_APPLICATION ,
     _T("Busy"),               WEBOC_DISPID_BUSY ,
     _T("ClientToWindow"),     WEBOC_DISPID_CLIENTTOWINDOW ,
     _T("Container"),          WEBOC_DISPID_CONTAINER,
     _T("Document"),           WEBOC_DISPID_DOCUMENT,
     _T("ExecWB"),             WEBOC_DISPID_EXECWB,
     _T("FullName"),           WEBOC_DISPID_FULLNAME,
     _T("FullScreen"),         WEBOC_DISPID_FULLSCREEN,
     _T("GetProperty"),        WEBOC_DISPID_GETPROPERTY,
     _T("GoBack"),             WEBOC_DISPID_GOBACK,
     _T("GoForward"),          WEBOC_DISPID_GOFORWARD,
     _T("GoHome"),             WEBOC_DISPID_GOHOME,
     _T("GoSearch"),           WEBOC_DISPID_GOSEARCH,
     _T("Height"),             WEBOC_DISPID_HEIGHT,
     _T("HWND"),               WEBOC_DISPID_HWND,
     _T("Left"),               WEBOC_DISPID_LEFT,
     _T("LocationName"),       WEBOC_DISPID_LOCATIONNAME,
     _T("LocationURL"),        WEBOC_DISPID_LOCATIONURL,
     _T("MenuBar"),            WEBOC_DISPID_MENUBAR,
     _T("Name"),               WEBOC_DISPID_NAME,
     _T("Navigate"),           WEBOC_DISPID_NAVIGATE,
     _T("Navigate2"),          WEBOC_DISPID_NAVIGATE2,
     _T("Offline"),            WEBOC_DISPID_OFFLINE,
     _T("Parent"),             WEBOC_DISPID_PARENT,
     _T("Path"),               WEBOC_DISPID_PATH,
     _T("PutProperty"),        WEBOC_DISPID_PUTPROPERTY,
     _T("QueryStatusWB"),      WEBOC_DISPID_QUERYSTATUSWB,
     _T("Quit"),               WEBOC_DISPID_QUIT,
     _T("ReadyState"),         WEBOC_DISPID_READYSTATE,
     _T("Refresh"),            WEBOC_DISPID_REFRESH,
     _T("Refresh2"),           WEBOC_DISPID_REFRESH2,
     _T("RegisterAsBrowser"),  WEBOC_DISPID_REGISTERASBROWSER,
     _T("RegisterAsDropTarget"),  WEBOC_DISPID_REGISTERASDROPTARGET,
     _T("Resizable"),          WEBOC_DISPID_RESIZABLE,
     _T("ShowBrowserBar"),     WEBOC_DISPID_SHOWBROWSERBAR,
     _T("Silent"),             WEBOC_DISPID_SILENT,
     _T("StatusBar"),          WEBOC_DISPID_STATUSBAR,
     _T("StatusText"),         WEBOC_DISPID_STATUSTEXT,
     _T("Stop"),               WEBOC_DISPID_STOP,
     _T("TheaterMode"),        WEBOC_DISPID_THEATERMODE,
     _T("ToolBar"),            WEBOC_DISPID_TOOLBAR,
     _T("Top"),                WEBOC_DISPID_TOP,
     _T("TopLevelContainer"),  WEBOC_DISPID_TOPLEVELCONTAINER,
     _T("Type"),               WEBOC_DISPID_TYPE,
     _T("Visible"),            WEBOC_DISPID_VISIBLE,
     _T("Width"),              WEBOC_DISPID_WIDTH,
};

//+-------------------------------------------------------------------------
//
//  Method   : GetWebOCDispID
//
//  Synopsis : Returns the DISPID of the specified WebOC method.
//
//  Input    : bstrName       - the name of the WebOC method.
//             fCaseSensitive - TRUE if the check should be case sensitive.
//
//  Output   : pDispID  - the DISPID of the WebOC method.
//
//--------------------------------------------------------------------------

HRESULT
GetWebOCDispID(BSTR bstrName, BOOL fCaseSensitive, DISPID * pDispID)
{
    int  nCmp;
    LONG i;
    LONG l = 0;
    LONG r = ARRAY_SIZE(g_rgWebOCDispIDs) - 1;

    Assert(pDispID);

    *pDispID = NULL;

    STRINGCOMPAREFN pfnCompareString = fCaseSensitive ? StrCmpC : StrCmpIC;

    // Binary Search
    //
    while (r >= l)
    {
        i = (r + l) / 2;
        nCmp = pfnCompareString(bstrName, g_rgWebOCDispIDs[i].pchName);

        if (0 == nCmp)  // Found it
        {
            *pDispID = g_rgWebOCDispIDs[i].dispidID; // WEBOC_DISPIDBASE + i;
            return S_OK;
        }

        if (nCmp < 0)
            r = i - 1;
        else
            l = i + 1;
    }

    return DISP_E_UNKNOWNNAME;
}

VARIANT *DerefVariant(VARIANT *pVarIn)
{
    VARIANT *pVar = pVarIn;

    if ((VT_VARIANT|VT_BYREF) == V_VT(pVarIn))
        pVar = V_VARIANTREF(pVarIn);

    Assert(pVar);
    return pVar;
}

//+-------------------------------------------------------------------------
//
//  Method   : InvokeWebOC
//
//  Synopsis : Invokes the WebOC method for the given DISPID.
//
//--------------------------------------------------------------------------

HRESULT
InvokeWebOC(CFrameWebOC * pFrameWebOC,
            DISPID        dispidMember,
            LCID          lcid,
            WORD          wFlags,
            DISPPARAMS *  pDispParams,
            VARIANT    *  pvarResult,
            EXCEPINFO  *  pExcepInfo,
            IServiceProvider * pSrvProvider)
{
    HRESULT hr = E_FAIL;
    VARIANT *pVar0 = NULL;
    VARIANT varI4;
    
    if (pDispParams && pDispParams->cArgs > 0)
    {
        pVar0 = DerefVariant(&pDispParams->rgvarg[pDispParams->cArgs - 1]);
        if (VT_I2 == V_VT(pVar0))
        {
            VariantInit(&varI4);
            if (!VariantChangeType(&varI4, pVar0, 0, VT_I4))
                pVar0 = &varI4;
        }
    }

    switch(dispidMember)
    {
    case WEBOC_DISPID_ADDRESSBAR:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_AddressBar(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                Assert(pVar0);
                hr = pFrameWebOC->put_AddressBar(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_APPLICATION:

        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_DISPATCH;
            hr = pFrameWebOC->get_Application(&pvarResult->pdispVal);
        }

        break;

    case WEBOC_DISPID_BUSY:

        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_BOOL;
            hr = pFrameWebOC->get_Busy(&pvarResult->boolVal);
        }

        break;

    case WEBOC_DISPID_CLIENTTOWINDOW:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pDispParams || pDispParams->cArgs < 2)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            VARIANT *pVar1 = DerefVariant(&pDispParams->rgvarg[pDispParams->cArgs - 2]);
;
            Assert(pVar0);
            Assert(pVar1);
            if (V_VT(pVar1) != VT_I4 && V_VT(pVar0) != VT_I4)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->ClientToWindow(reinterpret_cast<int*>(&(pVar0->lVal)),
                                                 reinterpret_cast<int*>(&(pVar1->lVal)));
            }
        }

        break;

    case WEBOC_DISPID_CONTAINER:     
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_DISPATCH;
            hr = pFrameWebOC->get_Container(&pvarResult->pdispVal);
        }

        break;

    case WEBOC_DISPID_DOCUMENT:          
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_DISPATCH;
            hr = pFrameWebOC->get_Document(&pvarResult->pdispVal);
        }

        break;

    case WEBOC_DISPID_EXECWB:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pDispParams || pDispParams->cArgs < 2)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else 
        {
            VARIANT *pVar1 = DerefVariant(&pDispParams->rgvarg[pDispParams->cArgs - 2]);
       
            Assert(pVar0);
            Assert(pVar1);

            if (V_VT(pVar0) != VT_I4 || V_VT(pVar1) != VT_I4)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                CVariant      cvarIn;
                VARIANT     * pvarOut = NULL;
                OLECMDID      nCmdID      = static_cast<OLECMDID>(V_I4(pVar0)); 
                OLECMDEXECOPT nCmdExecOpt = static_cast<OLECMDEXECOPT>(V_I4(pVar1));
                VARIANT *pVar2;

                switch(pDispParams->cArgs)
                {
                case 4:
                    pvarOut = &pDispParams->rgvarg[pDispParams->cArgs - 4];
                    // Intentional fall-through

                case 3:
                    pVar2 = DerefVariant(&pDispParams->rgvarg[pDispParams->cArgs - 3]);
                    VariantCopy(&cvarIn, pVar2);
                    // Intentional fall-through

                default:
                    break;
                }

                hr = pFrameWebOC->ExecWB(nCmdID, nCmdExecOpt, &cvarIn, pvarOut);
            }
        }

        break;

    case WEBOC_DISPID_FULLNAME:
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_BSTR;
            hr = pFrameWebOC->get_FullName(&pvarResult->bstrVal);
        }
        break;

    case WEBOC_DISPID_FULLSCREEN:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_FullScreen(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_FullScreen(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_GETPROPERTY:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult || !pDispParams || pDispParams->cArgs == 0)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else if (V_VT(pVar0) != VT_BSTR)
        {
            hr = DISP_E_BADVARTYPE;
        }
        else
        {
            hr = pFrameWebOC->GetProperty(V_BSTR(pVar0), pvarResult);
        }

        break;

    case WEBOC_DISPID_GOBACK:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
            hr = pFrameWebOC->GoBack();
        }

        break;

    case WEBOC_DISPID_GOFORWARD:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
            hr = pFrameWebOC->GoForward();
        }

        break;

    case WEBOC_DISPID_GOHOME:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
            hr = pFrameWebOC->GoHome();
        }

        break;

    case WEBOC_DISPID_GOSEARCH:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
            hr = pFrameWebOC->GoSearch();
        }

        break;

    case WEBOC_DISPID_HEIGHT:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_I4;
                hr = pFrameWebOC->get_Height(&pvarResult->lVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_I4)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_Height(V_I4(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_HWND:
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
#ifdef _WIN64
           V_VT(pvarResult) = VT_I8;
           hr = pFrameWebOC->get_HWND((LONG_PTR*) &pvarResult->llVal);                        
#else
           V_VT(pvarResult) = VT_I4;
           hr = pFrameWebOC->get_HWND(&pvarResult->lVal);            
#endif
        }

        break;

    case WEBOC_DISPID_LEFT:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_I4;
                hr = pFrameWebOC->get_Left(&pvarResult->lVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_I4)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_Left(V_I4(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_LOCATIONNAME:
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_BSTR;
            hr = pFrameWebOC->get_LocationName(&pvarResult->bstrVal);
        }

        break;

    case WEBOC_DISPID_LOCATIONURL:
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_BSTR;
            hr = pFrameWebOC->get_LocationURL(&pvarResult->bstrVal);
        }

        break;

    case WEBOC_DISPID_MENUBAR:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_MenuBar(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_MenuBar(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_NAME:
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_BSTR;
            hr = pFrameWebOC->get_Name(&pvarResult->bstrVal);
        }

        break;

    case WEBOC_DISPID_NAVIGATE:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (  !pDispParams
                || 0 == pDispParams->cArgs
                || VT_EMPTY == V_VT(pVar0))
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else if (V_VT(pVar0) != VT_BSTR)
        {
            hr = DISP_E_BADVARTYPE;
        }
        else
        {
            CVariant cvarFlags;
            CVariant cvarFrameName;
            CVariant cvarPostData;
            CVariant cvarHeaders;
            VARIANT *pvar = pDispParams->rgvarg;
            VARIANT *prefVar;

            switch(pDispParams->cArgs)
            {
            case 5:
                prefVar = DerefVariant(pvar);
                VariantCopy(&cvarHeaders, prefVar);
                pvar++;
                // Intentional fall-through

            case 4:
                prefVar = DerefVariant(pvar);
                VariantCopy(&cvarPostData, prefVar);
                pvar++;
                // Intentional fall-through

            case 3:
                prefVar = DerefVariant(pvar);
                VariantCopy(&cvarFrameName, prefVar);
                pvar++;
                // Intentional fall-through

            case 2:
                prefVar = DerefVariant(pvar);
                VariantCopy(&cvarFlags, prefVar);
                pvar++;
                break;

            default:
                break;
            }

            hr = pFrameWebOC->Navigate(V_BSTR(pVar0), &cvarFlags, &cvarFrameName, &cvarPostData, &cvarHeaders);
        }

        break;

    case WEBOC_DISPID_NAVIGATE2:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (  !pDispParams
                || 0 == pDispParams->cArgs
                || VT_EMPTY == V_VT(pVar0))
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            CVariant cvarFlags;
            CVariant cvarFrameName;
            CVariant cvarPostData;
            CVariant cvarHeaders;
            VARIANT *pvar = pDispParams->rgvarg;
            VARIANT *prefVar;

            switch(pDispParams->cArgs)
            {
            case 5:
                prefVar = DerefVariant(pvar);
                VariantCopy(&cvarHeaders, prefVar);
                pvar++;
                // Intentional fall-through

            case 4:
                prefVar = DerefVariant(pvar);
                VariantCopy(&cvarPostData, prefVar);
                pvar++;
                // Intentional fall-through

            case 3:
                prefVar = DerefVariant(pvar);
                VariantCopy(&cvarFrameName, prefVar);
                pvar++;
                // Intentional fall-through

            case 2:
                prefVar = DerefVariant(pvar);
                VariantCopy(&cvarFlags, prefVar);
                pvar++;
                break;

            default:
                break;
            }

            hr = pFrameWebOC->Navigate2(pVar0, &cvarFlags, &cvarFrameName, &cvarPostData, &cvarHeaders);
        }

        break;

    case WEBOC_DISPID_OFFLINE:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_Offline(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_Offline(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_PARENT:
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_DISPATCH;
            hr = pFrameWebOC->get_Parent(&pvarResult->pdispVal);
        }

        break;

    case WEBOC_DISPID_PATH:
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_BSTR;
            hr = pFrameWebOC->get_Path(&pvarResult->bstrVal);
        }

        break;

    case WEBOC_DISPID_PUTPROPERTY:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pDispParams || pDispParams->cArgs < 2)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else if (V_VT(pVar0) != VT_BSTR)
        {
            hr = DISP_E_BADVARTYPE;
        }
        else
        {
            hr = pFrameWebOC->PutProperty(V_BSTR(pVar0), pDispParams->rgvarg[pDispParams->cArgs - 2]);
        }
        break;

    case WEBOC_DISPID_QUERYSTATUSWB:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult || !pDispParams || pDispParams->cArgs == 0)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else if (V_VT(pVar0) != VT_I4)
        {
            hr = DISP_E_BADVARTYPE;
        }
        else
        {
            OLECMDID nCmdID = static_cast<OLECMDID>(V_I4(pVar0)); 
            V_VT(pvarResult) = VT_I4;
            hr = pFrameWebOC->QueryStatusWB(nCmdID, reinterpret_cast<OLECMDF*>(&pvarResult->lVal));
        }

        break;

    case WEBOC_DISPID_QUIT:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
            hr = pFrameWebOC->Quit();
        }

        break;

    case WEBOC_DISPID_READYSTATE:
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_I4;
            hr = pFrameWebOC->get_ReadyState(reinterpret_cast<READYSTATE*>(&pvarResult->lVal));
        }

        break;

    case WEBOC_DISPID_REFRESH:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
            hr = pFrameWebOC->Refresh();
        }

        break;

    case WEBOC_DISPID_REFRESH2:
        if (wFlags & DISPATCH_METHOD)
        {
            // The parameter is optional.
            //
            hr = pFrameWebOC->Refresh2(pVar0);
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_REGISTERASBROWSER:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_RegisterAsBrowser(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_RegisterAsBrowser(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_REGISTERASDROPTARGET:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_RegisterAsDropTarget(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_RegisterAsDropTarget(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_RESIZABLE:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_Resizable(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_Resizable(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_SHOWBROWSERBAR:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (  !pDispParams
                || 0 == pDispParams->cArgs
                || VT_EMPTY == V_VT(pVar0))
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            CVariant cvarShow;
            CVariant cvarSize;
            VARIANT *pvar = pDispParams->rgvarg;
            VARIANT *prefVar;

            switch(pDispParams->cArgs)
            {
            case 3:
                prefVar = DerefVariant(pvar);
                VariantCopy(&cvarSize, prefVar);
                pvar++;
                // Intentional fall-through

            case 2:
                prefVar = DerefVariant(pvar);
                VariantCopy(&cvarShow, prefVar);
                pvar++;
                // Intentional fall-through

            default:
                break;
            }

            hr = pFrameWebOC->ShowBrowserBar(pVar0, &cvarShow, &cvarSize);
        }

        break;

    case WEBOC_DISPID_SILENT:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_Silent(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_Silent(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_STATUSBAR:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_StatusBar(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_StatusBar(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_STATUSTEXT:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BSTR;
                hr = pFrameWebOC->get_StatusText(&pvarResult->bstrVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BSTR)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_StatusText(V_BSTR(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_STOP:
        if (!(wFlags & DISPATCH_METHOD))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
            hr = pFrameWebOC->Stop();
        }
        break;

    case WEBOC_DISPID_THEATERMODE:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_TheaterMode(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_TheaterMode(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_TOOLBAR:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_I4;
                hr = pFrameWebOC->get_ToolBar(reinterpret_cast<int*>(&pvarResult->lVal));
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_I4)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_ToolBar(static_cast<int>(V_I4(pVar0)));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_TOP:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_I4;
                hr = pFrameWebOC->get_Top(&pvarResult->lVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_I4)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_Top(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_TOPLEVELCONTAINER:
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_BOOL;
            hr = pFrameWebOC->get_TopLevelContainer(&pvarResult->boolVal);
        }

        break;

    case WEBOC_DISPID_TYPE:
        if (!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else if (!pvarResult)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
        }
        else
        {
            V_VT(pvarResult) = VT_BSTR;
            hr = pFrameWebOC->get_Type(&pvarResult->bstrVal);
        }

        break;

    case WEBOC_DISPID_VISIBLE:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_BOOL;
                hr = pFrameWebOC->get_Visible(&pvarResult->boolVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_BOOL)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_Visible(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    case WEBOC_DISPID_WIDTH:
        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else
            {
                V_VT(pvarResult) = VT_I4;
                hr = pFrameWebOC->get_Width(&pvarResult->lVal);
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pDispParams || pDispParams->cArgs == 0)
            {
                hr = DISP_E_PARAMNOTOPTIONAL;
            }
            else if (V_VT(pVar0) != VT_I4)
            {
                hr = DISP_E_BADVARTYPE;
            }
            else
            {
                hr = pFrameWebOC->put_Width(V_BOOL(pVar0));
            }
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        break;

    default:
        hr = THR(pFrameWebOC->_pWindow->Document()->InvokeEx(dispidMember, lcid, wFlags, pDispParams,
                                pvarResult, pExcepInfo, pSrvProvider));
        break;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : QueryService
//
//  Interface : IServiceProvider
//
//  Synopsis  : Per IServiceProvider::QueryService.
//
//--------------------------------------------------------------------------

HRESULT
CFrameWebOC::QueryService(REFGUID guidService,
                          REFIID  riid,
                          void ** ppvObject)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_NOINTERFACE;

    if (   IsEqualGUID(guidService, SID_STopFrameBrowser)
        || IsEqualGUID(guidService, SID_STopLevelBrowser))
    {
        return Doc()->QueryService(guidService, riid, ppvObject);
    }
    else if (IsEqualGUID(guidService, SID_SWebBrowserApp))
    {
        return PrivateQueryInterface(riid, ppvObject);
    }

    return E_NOINTERFACE;
}

// IOleCommandTarget methods
HRESULT CFrameWebOC::QueryStatus(GUID * pguidCmdGroup,
                    ULONG cCmds,
                    MSOCMD rgCmds[],
                    MSOCMDTEXT * pcmdtext)
{
    Assert(IsCmdGroupSupported(pguidCmdGroup));
    Assert(cCmds == 1);

    MSOCMD * pCmd = NULL;
    HRESULT hr = S_OK;
    UINT        uPropName;
    VARTYPE     vt = VT_EMPTY;
    int         c;
    int         idm;
    GUID *      pguidControl;
    ULONG       ulCmdID;
    CFrameSite *pFrameSite = NULL;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);

    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);
        
    if (_pWindow->IsPassivated())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pFrameSite = _pWindow->GetFrameSite();
    
    for (pCmd = rgCmds, c = cCmds; --c >= 0; pCmd++)
    {
        Assert(!pCmd->cmdf);

        // Disable Office documents in frameset from showing/hiding toolbars.
        if (pguidCmdGroup == NULL && pCmd->cmdID == OLECMDID_HIDETOOLBARS)
        {
            pCmd->cmdID = MSOCMDSTATE_DISABLED;
            continue;
        }

        idm = IDMFromCmdID(pguidCmdGroup, pCmd->cmdID);

        uPropName = 0;

        switch (idm)
        {
        case IDM_FONTNAME:
            uPropName = IDS_DISPID_FONTNAME;
            vt = VT_BSTR;
            break;

        case IDM_FONTSIZE:
            uPropName = IDS_DISPID_FONTSIZE;
            vt = VT_CY;
            break;

        case IDM_SUPERSCRIPT:
            uPropName = IDS_DISPID_FONTSUPERSCRIPT;
            vt = VT_BOOL;
            break;

        case IDM_SUBSCRIPT:
            uPropName = IDS_DISPID_FONTSUBSCRIPT;
            vt = VT_BOOL;
            break;

        case IDM_BOLD:
            uPropName = IDS_DISPID_FONTBOLD;
            vt = VT_BOOL;
            break;

        case IDM_ITALIC:
            uPropName = IDS_DISPID_FONTITAL;
            vt = VT_BOOL;
            break;

        case IDM_UNDERLINE:
            uPropName = IDS_DISPID_FONTUNDER;
            vt = VT_BOOL;
            break;

        case IDM_BACKCOLOR:
            uPropName = IDS_DISPID_BACKCOLOR;
            vt = VT_I4;
            break;

        case IDM_FORECOLOR:
            if (pFrameSite)
            {
                // TODO (jenlc)
                // this is just a transition code, will be changed later for
                // QueryStatus/Exec architecture rework.
                //
                CVariant varargOut;
                DISPID     dispidProp;
                HRESULT    hr;

                dispidProp = DISPID_A_COLOR;
                vt         = VT_I4;
                V_VT(&varargOut) = VT_I4;
                hr = THR_NOTRACE(pFrameSite->ExecSetGetKnownProp(NULL, &varargOut, dispidProp, vt));
                pCmd->cmdf = (hr) ? (MSOCMDSTATE_DISABLED) : (MSOCMDSTATE_UP);
            }
            break;
            
        case IDM_BORDERCOLOR:
            uPropName = IDS_DISPID_BORDERCOLOR;
            vt = VT_I4;
            break;

        case IDM_JUSTIFYLEFT:
        case IDM_JUSTIFYCENTER:
        case IDM_JUSTIFYRIGHT:
        case IDM_JUSTIFYGENERAL:
        case IDM_JUSTIFYFULL:
            uPropName = IDS_DISPID_TEXTALIGN;
            vt = VT_I4;
            break;

        case IDM_FLAT:
        case IDM_RAISED:
        case IDM_SUNKEN:
            uPropName = IDS_DISPID_SPECIALEFFECT;
            vt = VT_I4;
            break;

        default:
            //
            // Do a reverse lookup to try and match into the standard cmd set.
            //
            if (OLECMDIDFromIDM(idm, &ulCmdID))
            {
                pguidControl = NULL;
                pCmd->cmdID = ulCmdID;
            }
            else
            {
                pguidControl = pguidCmdGroup;
            }

            if (  !pguidControl
                || pguidControl == (GUID *)&CGID_MSHTML
               )
            {
                hr = THR(_pWindow->Document()->QueryStatus(pguidCmdGroup, 1, pCmd, pcmdtext));

                // NOTE: hr should be ignored, because we _have_ to process all
                // the cmd's in the array. We will return only the last hr.
                continue;
            }
        }

        if(uPropName && pFrameSite)
        {
            Assert(vt != VT_EMPTY);
            hr = THR_NOTRACE(pFrameSite->QueryStatusProperty(pCmd, uPropName, vt));
        }
        
        if(   (   hr == S_OK
               || hr == OLECMDERR_E_NOTSUPPORTED
              )
           && !pCmd->cmdf
           && pFrameSite
          )
        {
            hr = THR_NOTRACE(pFrameSite->QueryStatus(pguidCmdGroup, 1, pCmd, pcmdtext));
        }
    }

Cleanup:
    RRETURN_NOTRACE(hr);
}

HRESULT CFrameWebOC::Exec(GUID * pguidCmdGroup,
                          DWORD nCmdID,
                          DWORD nCmdexecopt,
                          VARIANTARG * pvarargIn,
                          VARIANTARG * pvarargOut)
{
    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));

    HRESULT         hr = OLECMDERR_E_NOTSUPPORTED;
    UINT            uPropName;
    VARTYPE         vt = VT_EMPTY;
    DWORD           dwValue;
    int             idm;
    DISPID          dispidProp;
    CParentUndoUnit *pCPUU = NULL;
    GUID *          pguidControl;
    ULONG           ulCmdID;
    CFrameSite *    pFrameSite = NULL;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
        
    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);
            
    if (_pWindow->IsPassivated())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pFrameSite = _pWindow->GetFrameSite();
    if (!pFrameSite)
        goto Cleanup;
    
    // Disable Office documents in frameset from showing/hiding toolbars.
    if (pguidCmdGroup == NULL && nCmdID == OLECMDID_HIDETOOLBARS)
    {
        RRETURN(OLECMDERR_E_DISABLED);
    }

    idm = IDMFromCmdID(pguidCmdGroup, nCmdID);

    // If the idm represents an undoable property change, open
    // a parent undo unit.

#ifndef NO_EDIT
    if (idm != IDM_UNDO && idm != IDM_REDO)
    {
        pCPUU = pFrameSite->OpenParentUnit(this, IDS_UNDOPROPCHANGE);
    }
#endif // NO_EDIT
    
    switch (idm)
    {
    case IDM_FONTNAME:
        uPropName = IDS_DISPID_FONTNAME;
        vt = VT_BSTR;
        goto ExecSetGetProperty;

    case IDM_FONTSIZE:
    {
        CVariant varTemp;
        CY      cy;

        V_VT(&varTemp) = VT_CY;
        // Need to do convert from long (twips) to CURRENCY for font size
        if (pvarargIn)
        {
            cy.Lo = V_I4(pvarargIn)/20 * 10000;
            cy.Hi = 0;
            V_CY(&varTemp) = cy;
        }

        hr = THR_NOTRACE(pFrameSite->ExecSetGetProperty(
                                            pvarargIn ? &varTemp: NULL,
                                            pvarargOut ? &varTemp : NULL ,
                                            IDS_DISPID_FONTSIZE,
                                            VT_CY));

        if (!hr && pvarargOut)
        {
            V_VT(pvarargOut) = VT_I4;
            cy = V_CY(&varTemp);
            V_I4(pvarargOut) = cy.Lo /10000*20;
        }
        goto Cleanup;
    }

    case IDM_SUPERSCRIPT:
        uPropName = IDS_DISPID_FONTSUPERSCRIPT;
        goto ExecToggleCmd;

    case IDM_SUBSCRIPT:
        uPropName = IDS_DISPID_FONTSUBSCRIPT;
        goto ExecToggleCmd;

    case IDM_BOLD:
        uPropName = IDS_DISPID_FONTBOLD;
        goto ExecToggleCmd;

    case IDM_ITALIC:
        uPropName = IDS_DISPID_FONTITAL;
        goto ExecToggleCmd;

    case IDM_UNDERLINE:
        uPropName = IDS_DISPID_FONTUNDER;
        goto ExecToggleCmd;

    case IDM_BACKCOLOR:
        uPropName = IDS_DISPID_BACKCOLOR;
        vt = VT_I4;
        goto ExecSetGetProperty;

    case IDM_FORECOLOR:
        dispidProp = DISPID_A_COLOR;
    // for this color we need to swap
        if (pvarargIn)
        {
            CColorValue cvValue;
            CVariant varColor;

            hr = THR(varColor.CoerceVariantArg(pvarargIn, VT_I4));
            if (hr)
                goto Cleanup;

            cvValue.SetFromRGB(V_I4(&varColor));

            V_I4(pvarargIn) = (DWORD)cvValue.GetRawValue();
            V_VT(pvarargIn) = VT_I4;
        }
        vt = VT_I4;
        goto ExecKnownDispidProperty;

    case IDM_BORDERCOLOR:
        uPropName = IDS_DISPID_BORDERCOLOR;
        vt = VT_I4;
        goto ExecSetGetProperty;

    case IDM_RAISED:
        uPropName = IDS_DISPID_SPECIALEFFECT;
        dwValue = fmBorderStyleRaised;
        goto ExecSetPropertyCmd;

    case IDM_SUNKEN:
        uPropName = IDS_DISPID_SPECIALEFFECT;
        dwValue = fmBorderStyleSunken;
        goto ExecSetPropertyCmd;

    default:
        //
        // Do a reverse lookup to try and match into the standard cmd set.
        //
        if (OLECMDIDFromIDM(idm, &ulCmdID))
        {
            pguidControl = NULL;
        }
        else
        {
            pguidControl = pguidCmdGroup;
            ulCmdID = nCmdID;
        }


        if (   !pguidCmdGroup
            || IsEqualGUID(CGID_MSHTML, *pguidCmdGroup)
           )
        {
            OPTIONSETTINGS *pos = Doc()->_pOptionSettings;

            if ((   idm == IDM_IMAGE
                 || (   (   idm == IDM_PASTE
                         || idm == IDM_CUT
                         || idm == IDM_COPY
                        )
                     && (   !pos
                         || !pos->fAllowCutCopyPaste
                        )
                    )
                )
                && !AccessAllowed()
               )
            {
                hr = E_ACCESSDENIED;
                goto Cleanup;
            }
            
            hr = THR(_pWindow->Document()->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));
        }
        break;
    }

    if (OLECMDERR_E_NOTSUPPORTED == hr)
    {
        hr = THR(pFrameSite->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));
    }
    
    goto Cleanup;

ExecKnownDispidProperty:
    Assert(vt != VT_EMPTY);
    hr = THR_NOTRACE(pFrameSite->ExecSetGetKnownProp(pvarargIn,pvarargOut,dispidProp, vt));
    goto Cleanup;

ExecSetGetProperty:
    Assert(vt != VT_EMPTY);
    hr = THR_NOTRACE(pFrameSite->ExecSetGetProperty(pvarargIn,pvarargOut,uPropName,vt));
    goto Cleanup;

ExecToggleCmd:
    hr = THR_NOTRACE(pFrameSite->ExecToggleCmd(uPropName));
    goto Cleanup;

ExecSetPropertyCmd:
    hr = THR_NOTRACE(pFrameSite->ExecSetPropertyCmd(uPropName, dwValue));
    goto Cleanup;

Cleanup:
#ifndef NO_EDIT
    if (pFrameSite)
       pFrameSite->CloseParentUnit(pCPUU, hr);
#endif // NO_EDIT
    
    RRETURN_NOTRACE(hr);
}

//+---------------------------------------------------------------
//
// Member:      CFrameWebOC::AccessAllowed
//
// Synopsis:    Return TRUE if it's ok to access the object model
//              of the dispatch passed in.
//
//---------------------------------------------------------------

BOOL
CFrameWebOC::AccessAllowed()
{
    Assert(!_pWindow->IsPassivated());

    FRAME_WEBOC_PASSIVATE_CHECK(FALSE);
    
    FRAME_WEBOC_VERIFY_WINDOW(FALSE);
    
    if (_pWindow->_pWindowParent)
        return _pWindow->Markup()->AccessAllowed(_pWindow->_pWindowParent->Markup());
    else
        return FALSE;
}


//+---------------------------------------------------------------
//
//   Member : AddConnection, IExternalConnection
//
//----------------------------------------------------------------
HRESULT
CFrameWebOC::AddConnection(DWORD extconn, DWORD reserved)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (extconn & EXTCONN_STRONG)
    {
        return PrivateAddRef();
    }

    //
    // TODO: Change return 0 to return S_OK
    //
    return 0;
}
        

//+---------------------------------------------------------------
//
//  Member : ReleaseConnection, IExternalConnection
//
//----------------------------------------------------------------
HRESULT
CFrameWebOC::ReleaseConnection( DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    //
    // TODO: Change return 0 to return S_OK
    //
    if (!(extconn & EXTCONN_STRONG))
    {
        return 0;
    }

    // in 5.0 releaseConnection only closed the topLevel OC, and then only if it 
    // was hidden.
    // 
    // since we *know* that as a framewebOC we are not the top level, there is nothing
    // that we need to do here.
    /*  code for shdocvw iedisp.cpp:
    _cLocks--;

    if (   _cLocks == 0
        && fLastReleaseCloses)
    {
        VARIANT_BOOL fVisible;
        get_Visible(&fVisible);
        if (!fVisible)
        {
            HWND hwnd = _GetHWND();
            //
            // Notice that we close it only if that's the top level browser
            // to avoid closing a hidden WebBrowserOC by mistake.
            //
            if (hwnd && _psbTop == _psb && !IsNamedWindow(hwnd, c_szShellEmbedding))
            {
                // The above test is necessary but not sufficient to determine if the item we're looking
                // at is the browser frame or the WebBrowserOC.
                TraceMsg(TF_SHDAUTO, "CIEFrameAuto::ReleaseConnection posting WM_CLOSE to %x", hwnd);
                PostMessage(hwnd, WM_CLOSE, 0, 0);
            }
        }
    }
    */
    return PrivateRelease();
}


//+---------------------------------------------------------------------------
//
//  Member:     CFrameWebOC:GetClassInfo
//
//  Synopsis:   Returns the control's coclass typeinfo.
//
//  Arguments:  ppTI    Resulting typeinfo.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFrameWebOC::GetClassInfo(ITypeInfo ** ppTI)
{
    HRESULT hr = E_FAIL;
    IProvideClassInfo2 *pPCI2 = NULL;
    IWebBrowser2 *pTopWebOC;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);
    
    if (_pWindow->IsPassivated())
        goto Cleanup;
    
    pTopWebOC = Doc()->_pTopWebOC;
    if (pTopWebOC)
    {
        hr = THR(pTopWebOC->QueryInterface(IID_IProvideClassInfo2, (void**)&pPCI2));
        if (hr)
            goto Cleanup;
        hr = THR(pPCI2->GetClassInfo(ppTI));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pPCI2);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CBase:GetGUID
//
//  Synopsis:   Returns some type of requested guid
//
//  Arguments:  dwGuidKind      The type of guid requested
//              pGUID           Resultant
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFrameWebOC::GetGUID(DWORD dwGuidKind, GUID *pGUID)
{
    HRESULT hr = E_FAIL;
    IProvideClassInfo2 *pPCI2 = NULL;
    IWebBrowser2 *pTopWebOC;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);
        
    if (_pWindow->IsPassivated())
        goto Cleanup;

    pTopWebOC = Doc()->_pTopWebOC;
    if (pTopWebOC)
    {
        hr = THR(pTopWebOC->QueryInterface(IID_IProvideClassInfo2, (void**)&pPCI2));
        if (hr)
            goto Cleanup;
        hr = THR(pPCI2->GetGUID(dwGuidKind, pGUID));
        if (hr)
            goto Cleanup;
    }
Cleanup:
    ReleaseInterface(pPCI2);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFrameWebOC::GetWindow
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CFrameWebOC::GetWindow(HWND * phwnd)
{
    HRESULT hr = S_OK;

    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    if (!phwnd)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    *phwnd = Doc()->GetHWND();

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CFrameWebOC::DetachFromWindow
//
//  Synopsis:   Window is passivating or otherwise invalid
//
//--------------------------------------------------------------------------

void CFrameWebOC::DetachFromWindow()
{
    _pWindow = NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFrameWebOC::ContextSensitiveHelp
//
//  Synopsis:   Per IOleWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CFrameWebOC::ContextSensitiveHelp(BOOL fEnterMode)
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\misc\framet.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       framet.cxx
//
//  Contents:   Frame Targeting Support
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_FRAMET_H_
#define X_FRAMET_H_
#include "framet.h"
#endif

#ifndef X_HTIFACE_H_
#define X_HTIFACE_H_
#include "htiface.h"
#endif

#ifndef X_HLINK_H_
#define X_HLINK_H_
#include "hlink.h"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_WEBOCUTIL_H_
#define X_WEBOCUTIL_H_
#include "webocutil.h"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

LONG   g_lNoNameWindowCounter;

#define SID_SOmWindow IID_IHTMLWindow2

DeclareTag(tagFrameT, "FrameT", "Frame targeting methods")

//+--------------------------------------------------------------------------------------
//
//  Function  : GetTargetWindow
//  
//  Synopsis  : This method calls FindWindowInContext() to search the current process
//              for the specified target window. If the target window cannot be found
//              in the current process, SearchHostsForWindow() is called to search
//              other processes for the target window.
//
//  Input     : pWindow            - the window to search.
//              pszTargetName      - the name of the window to locate.
//  Ouput     : pfIsCurProcess     - TRUE if the window was found in the current process.
//              ppTargetWindow     - the IHTMLWindow2 of the found window or
//                                   NULL if the window is not found.//
//  Returns   : S_OK if found, OLE error code otherwise.
//---------------------------------------------------------------------------------------

HRESULT
GetTargetWindow(IHTMLWindow2  * pWindow,
                LPCOLESTR       pszTargetName, 
                BOOL          * pfIsCurProcess,
                IHTMLWindow2 ** ppTargetWindow)
{
    HRESULT hr;
    IHTMLDocument2   * pDocument   = NULL;
    IServiceProvider * pSvcPrvdr   = NULL;
    IWebBrowser2     * pWebBrowser = NULL;
    
    Assert(pWindow);
    Assert(pszTargetName);
    Assert(*pszTargetName);
    Assert(pfIsCurProcess);
    Assert(ppTargetWindow);

    *ppTargetWindow = NULL;
    *pfIsCurProcess = FALSE;

    hr = FindWindowInContext(pWindow, pszTargetName, pWindow, ppTargetWindow);

    if (!hr)
    {
        *pfIsCurProcess = TRUE;
    }
    else  // Not found
    {
        Assert(!*ppTargetWindow);
       
        *pfIsCurProcess = FALSE;
        
        // Get the WebOC of the parent.
        //
        IGNORE_HR(GetParentWebOC(pWindow, &pWebBrowser));
        
        // pWebBrowser can be NULL
        //
        hr = SearchBrowsersForWindow(pszTargetName, pWebBrowser, ppTargetWindow);
    }
    
    ReleaseInterface(pDocument);
    ReleaseInterface(pSvcPrvdr);
    ReleaseInterface(pWebBrowser);

    TraceTag((tagFrameT, "FrameT: GetTargetWindow returning 0x%X", hr));
    RRETURN1(hr, S_FALSE);
}

//+--------------------------------------------------------------------------------------
//
//  Function  : FindWindowInContext
//  
//  Synopsis  : This method searches the current process for the specified target
//              window. It first calls SearchChildrenForWindow() to search all
//              children of the current window for the target window name.
//              (SearchChildrenForWindow() checks the given window first before
//              searching the children.) If the target window name is not found in 
//              the current window or its children, SearchParentForWindow() is 
//              called to search the parent window and all of its children 
//              for the target window. SearchParentForWindow() recursively calls
//              this function in order to search all children and parent windows
//              until all windows in this process have been searched or the
//              window has been found.
//              The context window is used to indicate a window (and its children)
//              that has already been searched. SearchChildrenForWindow() will not
//              search a child window whose window matches the context window.
//
//  Input     : pWindow        - the window to search.
//              pszTargetName  - the name of the window to locate.
//              pWindowCtx     - context window. This is the IHTMLWindow2 of a 
//                               window that has already been searched (including its
//                               children).
//  Ouput     : ppTargetWindow - the IHTMLWindow2 of the found window or
//                               NULL if the window is not found.
//
//  Returns   : S_OK if found, OLE error code otherwise.
//---------------------------------------------------------------------------------------

HRESULT
FindWindowInContext(IHTMLWindow2  * pWindow,
                    LPCOLESTR       pszTargetName,
                    IHTMLWindow2  * pWindowCtx,
                    IHTMLWindow2 ** ppTargetWindow)
{
    HRESULT hr;

    Assert(pWindow);
    Assert(pszTargetName);
    Assert(*pszTargetName);
    Assert(ppTargetWindow);

    hr = SearchChildrenForWindow(pWindow, pszTargetName, pWindowCtx, ppTargetWindow);

    // Don't search the parent if we found the window.
    //
    if (hr)
    {
        hr = SearchParentForWindow(pWindow, pszTargetName, ppTargetWindow);
    }
    
    TraceTag((tagFrameT, "FrameT: FindWindowInContext returning 0x%X", hr));
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function  : SearchChildrenForWindow
//
//  Synopsis  : Returns the window with the given name. This method first
//              checks to see if the name of the given window matches
//              pszTargetName. If it does not, it performs a depth-first
//              search of all the children of the given window for the given
//              target window name. (See FindWindowInContext for more info
//              about the context window.)
//
//  Input     : pWindow        - the window whose children should be searched.
//              pszTargetName  - the name of the window to locate.
//              pWindowCtx     - context window. This is the IHTMLWindow2 of a 
//                               window that has already been searched (including its
//                               children).
//  Ouput     : ppTargetWindow - the IHTMLWindow2 of the found window or
//                               NULL if the window is not found.
//
//  Returns   : S_OK if found, OLE error code otherwise.
//-----------------------------------------------------------------------------

HRESULT
SearchChildrenForWindow(IHTMLWindow2  * pWindow,
                        LPCOLESTR       pszTargetName,
                        IHTMLWindow2  * pWindowCtx,
                        IHTMLWindow2 ** ppTargetWindow)
{
    HRESULT        hr = E_FAIL;
    HRESULT        hr2;
    long           cFrames;
    long           nItem;
    BSTR           bstrName = NULL;
    VARIANT        varItem;
    VARIANT        varFrame;
    IHTMLWindow2 * pFrameWindow = NULL;
    IHTMLFramesCollection2 * pFrames = NULL;

    Assert(pWindow);
    Assert(pszTargetName);
    Assert(*pszTargetName);
    Assert(ppTargetWindow);

    VariantInit( &varItem );
    VariantInit( &varFrame );
    
    hr2 = pWindow->get_name(&bstrName);

    // Note that get_name returns the name
    // even though access is denied. E_ACCESSDENIED
    // is returned in the case of cross-browser targeting.
    //
    if (hr2 && hr2 != E_ACCESSDENIED)
    {
        goto Cleanup;
    }
        
    if (pszTargetName && bstrName && !StrCmpW(pszTargetName, bstrName))
    {
        *ppTargetWindow = pWindow;
        (*ppTargetWindow)->AddRef();

        hr = S_OK;
        goto Cleanup;
    }
    else
    {
        // Do not set hr to the return value of any method except
        // SearchChildrenForWindow. The return value from this method
        // must only reflect whether or not the window was found.
        //
        if (pWindow->get_frames(&pFrames))
        {
            goto Cleanup;
        }
            
        if (pFrames->get_length(&cFrames))
        {
            goto Cleanup;
        }

        V_VT(&varItem) = VT_I4;
        
        // Depth-first search of children via frames collection
        //
        for (nItem = 0; nItem < cFrames; nItem++)
        {
            V_I4(&varItem) = nItem;
                
            if (pFrames->item(&varItem, &varFrame))
            {
               goto LoopCleanup; // Error retrieving item at index nItem.
            }

            if (VT_DISPATCH == V_VT(&varFrame) && V_DISPATCH(&varFrame))
            {
                if (V_DISPATCH(&varFrame)->QueryInterface(IID_IHTMLWindow2,
                                                          (void**) &pFrameWindow))
                {
                    goto LoopCleanup;
                }

                {
                    COmWindowProxy * pOmWindowProxy;

                    if (    S_OK == pFrameWindow->QueryInterface(CLSID_HTMLWindowProxy, (void **) &pOmWindowProxy)
                        &&  pOmWindowProxy->_pCWindow)
                    {
                        pOmWindowProxy->_pCWindow->AddRef();
                        pFrameWindow->Release();
                        pFrameWindow = pOmWindowProxy->_pCWindow;
                    }
                }

                if (!IsSameObject(pWindowCtx, pFrameWindow))
                {
                    hr = SearchChildrenForWindow(pFrameWindow,
                                                 pszTargetName,
                                                 NULL,
                                                 ppTargetWindow);
                }

LoopCleanup:
                VariantClear(&varFrame);
                ClearInterface(&pFrameWindow);
                
                // Found it!!
                if (S_OK == hr)
                    goto Cleanup;
            }
        }
    }

Cleanup:
    VariantClear(&varItem);
    SysFreeString(bstrName);    
    ReleaseInterface(pFrames);
    
    TraceTag((tagFrameT, "FrameT: SearchChildrenForWindow returning 0x%X", hr));
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function  : SearchParentForWindow
//
//  Synopsis  : Searches the parent window (and its children) of the given 
//              window for the window with the specified target window name.
//
//  Input     : pWindow        - the window whose parent should be searched.
//              pszTargetName  - the name of the window to locate.
//  Ouput     : ppTargetWindow - the IHTMLWindow2 of the found window or
//                               NULL if the window is not found.
//
//  Returns   : S_OK if found, OLE error code otherwise.
//-----------------------------------------------------------------------------

HRESULT
SearchParentForWindow(IHTMLWindow2  * pWindow,
                      LPCOLESTR       pszTargetName,
                      IHTMLWindow2 ** ppTargetWindow)
{
    HRESULT        hr = E_FAIL;
    IHTMLWindow2 * pWindowParent = NULL;

    Assert(pWindow);
    Assert(pszTargetName);
    Assert(*pszTargetName);
    Assert(ppTargetWindow);
    
    if (pWindow->get_parent(&pWindowParent))
    {
        goto Cleanup;
    }

    // The parent of the top window is the window itself - check identity
    //
    if (!IsSameObject(pWindow, pWindowParent))
    {
        // Call FindWindowInContext on the parent window 
        // passing in this window as the context.
        //
        hr = FindWindowInContext(pWindowParent,
                                 pszTargetName,
                                 pWindow,
                                 ppTargetWindow);
    }
        
Cleanup:
    ReleaseInterface(pWindowParent);
    
    TraceTag((tagFrameT, "FrameT: SearchParentForWindow returning 0x%X", hr));
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Function  : SearchBrowsersForWindow
//
//  Synopsis  : Searches all browser windows (that are registered with 
//              ShellWindows) for the given target name. 
//              This method uses the ShellWindows enumeration to locate 
//              registered shell windows. When a shell window is found,
//              the IWebBrowser2 interface ptr of the shell window is
//              retrieved. If the shell window implements IWebBrowser2,
//              the IHTMLWindow2 pointer of the top-level window object is 
//              retrieved and then FindWindowInContext is called to search
//              all child windows for the target window name. This process 
//              is performed for all registered shell windows on the system.
//
//  Input     : pszTargetName  - the name of the window to locate.
//              pThisBrwsr     - the IWebBrowser2 of the the current browser.
//  Output    : ppTargetWindow - the IHTMLWindow2  of the found window or
//                               NULL if the window is not found.
//
//  Returns   : S_OK if found, OLE error code otherwise.
//
//--------------------------------------------------------------------------

HRESULT
SearchBrowsersForWindow(LPCOLESTR       pszTargetName,
                        IWebBrowser2  * pThisBrwsr,
                        IHTMLWindow2 ** ppTargetWindow)
{
    HRESULT         hr;
    VARIANT         VarResult;
    BOOL            fDone = FALSE;
    IShellWindows * pShellWindows = NULL;
    IUnknown      * pUnkEnum      = NULL;
    IEnumVARIANT  * pEnumVariant  = NULL;
    IWebBrowser2  * pWebBrowser   = NULL;
    IHTMLWindow2  * pTargWindow   = NULL;
    
    Assert(pszTargetName);
    Assert(*pszTargetName);
    Assert(ppTargetWindow);
    
    hr = CoCreateInstance(CLSID_ShellWindows,
                          NULL,
                          CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER,
                          IID_IShellWindows,
                          (void**)&pShellWindows);
    if (hr)
        goto Cleanup;

    hr = pShellWindows->_NewEnum(&pUnkEnum);
    if (hr)
        goto Cleanup;

    hr = pUnkEnum->QueryInterface(IID_IEnumVARIANT, (LPVOID *)&pEnumVariant);
    
    if (hr)
        goto Cleanup;

    VariantInit(&VarResult);
    
    // Search all ShellWindows for the target window.
    //
    while (!fDone && S_OK == hr)
    {
        hr = pEnumVariant->Next(1, &VarResult, NULL);
        if (hr)
            goto LoopCleanup;
            
        if (VT_DISPATCH == V_VT(&VarResult) && V_DISPATCH(&VarResult))
        {
            // Get the IWebBrowser2 of the browser so that we
            // can find the top level window object. This QI
            // will fail if we aren't in the browser (e.g., HTA).
            //
            if (V_DISPATCH(&VarResult)->QueryInterface(IID_IWebBrowser2,
                                                       (void**)&pWebBrowser))
            {
                goto LoopCleanup;
            }
            
            // We don't want to search any shell windows more than once.
            //
            if (!IsSameObject(pWebBrowser, pThisBrwsr))
            {
                // Get the top window object of the host.
                //
                if (S_OK == GetWebOCWindow(pWebBrowser, TRUE, &pTargWindow))
                {
                    // Search the top window and its children for the target window.
                    //
                    if (S_OK == FindWindowInContext(pTargWindow,
                                             pszTargetName,
                                             pTargWindow,
                                             ppTargetWindow))
                    // Found it!!
                    {
                        fDone = TRUE;
                    }
                }
            }
        }

LoopCleanup:
        ClearInterface(&pWebBrowser);
        ClearInterface(&pTargWindow);
        VariantClear(&VarResult);
        
    }  // while
                    
Cleanup:
    ReleaseInterface(pUnkEnum);
    ReleaseInterface(pEnumVariant);
    ReleaseInterface(pShellWindows);

    // Do not release pTargWindow. It's not AddRef'ed

    TraceTag((tagFrameT, "FrameT: SearchBrowsersForWindow returning 0x%X", hr));
    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method    : GenerateUniqueWindowName
//
//  Synopsis  : Creates a unique window name.  
//
//--------------------------------------------------------------------------

HRESULT
GenerateUniqueWindowName(TCHAR ** ppchUniqueWindowName)
{
    InterlockedIncrement(&g_lNoNameWindowCounter);

    // Choose a name the user isn't likely to type.
    RRETURN(Format(FMT_OUT_ALLOC, ppchUniqueWindowName, 0, _T("_No__Name:<0d>"), g_lNoNameWindowCounter));
}


//+--------------------------------------------------------------------------------------
//
//  Method    : ShellExecURL
//
//  Synopsis  : Opens the specified URL in a new *default browser* window.
//              **This code has been copied from \nt\shell\shdocvw\iedisp.cpp
//              **Refer to the HLinkFrameNavigateNHL() function for more info.
//              We' are punting the FILE: case for IE 4 unless the extension
//              is .htm or .html (all that Netscape 3.0 registers for) we'll go 
//              with ShellExecute if IE is not the default browser.  
//              NOTE: this means POST will not be supported and pszTargetFrame will be 
//              ignored we don't shellexecute FILE: url's because URL.DLL doesn't give 
//              a security warning for .exe's etc.
//
//----------------------------------------------------------------------------------------

HRESULT ShellExecURL(const TCHAR    * pchUrl)
{
    HINSTANCE   hinstRet;
    TCHAR     * pszExt = NULL;
    BOOL        bSafeToExec = TRUE;
    
    //Initialize to E_FAIL, will be set to S_OK only if we ShellExecute successfully
    HRESULT     hr = E_FAIL;

    if (URL_SCHEME_FILE == GetUrlScheme(pchUrl))
    {
        TCHAR szContentType[MAX_PATH] = _T("");
        DWORD dwSize = MAX_PATH;

        bSafeToExec = FALSE;
        // Get Content type.
        pszExt = PathFindExtension(pchUrl);
        HRESULT hLocal;

        hLocal = AssocQueryString(0, ASSOCSTR_CONTENTTYPE, pszExt, NULL, szContentType, &dwSize);
        if (SUCCEEDED(hLocal))
        {
            bSafeToExec = ( 0 == _tcsicmp(szContentType, _T("text/html")) );
        }
    }

    if (bSafeToExec)
    {
        hinstRet = ShellExecute(NULL, NULL, pchUrl, NULL, NULL, SW_SHOWNORMAL);
        hr = ((UINT_PTR)hinstRet) <= 32 ? E_FAIL:S_OK;
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Method    : OpenInNewWindow
//
//  Synopsis  : Opens the specified URL in a new browser window..  
//
//--------------------------------------------------------------------------

BOOL IsIEDefaultBrowser();

HRESULT
OpenInNewWindow(const TCHAR    * pchUrl,
                const TCHAR    * pchTarget,
                CDwnBindInfo   * pDwnBindInfo,
                IBindCtx       * pBindCtx,
                COmWindowProxy * pWindow,
                BOOL             fReplace,
                IHTMLWindow2  ** ppHTMLWindow2)
{
    Assert(pchUrl);
    Assert(pBindCtx);

    HRESULT hr;

    TCHAR             * pchUniqueWindowName = NULL;
    ITargetNotify2    * pNotify = NULL;
    ITargetFramePriv  * pTargFrmPriv = NULL;
    CWindow           * pCWindow  =  NULL;
    IWebBrowser2      * pTopWebOC =  NULL;

    if (!pWindow || !pWindow->Window() || !pWindow->Window()->Doc())
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        hr = E_FAIL;
        goto Cleanup;
    }
    else
    {
        pCWindow  = pWindow->Window();
        pTopWebOC = pCWindow->Doc()->_pTopWebOC;
    }

    if (ppHTMLWindow2)
        *ppHTMLWindow2 = NULL;

    // If we don't have a window name, then we can pass in a generic name to make 
    // it possible for shdocvw to track this window later. However, we don't have
    // to search for an existing window, if the name is empty or "_blank"

    if (!pchTarget || !*pchTarget || (*pchTarget && !StrCmpW(pchTarget, _T("_blank"))))
    {
        // If the name passed was "_blank", then free the bstr we received and reuse it 
        // for the unique name we will get from shdocvw.
        hr = THR(GenerateUniqueWindowName(&pchUniqueWindowName));
        if (hr)
            goto Cleanup;
    }

    Assert(pCWindow);

    if (pTopWebOC)
    {
        hr = pTopWebOC->QueryInterface(IID_ITargetFramePriv, (void**)&pTargFrmPriv);
        if (hr)
            goto Cleanup;
    }
    else
    {
        // We come thru here only for direct Trident hosts and if the host did not
        // implement the IHLinkFrame interface. We need to launch the default browser
        // for all cases except window.open since we need to set the opener property for
        // the window.open case.

        // If we are not in a window.open call, call ShellExecute so that we launch the default browser
        // If we determine it's not safe to launch the url, we will create IE by default 
        // (behavior since IE 4)
        if (!(pCWindow->_fOpenInProgress) && !(pCWindow->Doc()->_fInHTMLDlg || pCWindow->Doc()->IsHostedInHTA()) && !IsIEDefaultBrowser())
        {
            hr = THR(ShellExecURL(pchUrl));
            return hr;
        }

        // If this is a window.open call, will fall thru to this
        // to create a new IE window
#ifdef NO_MARSHALLING
        hr = THR(CoCreateInternetExplorer(IID_ITargetFramePriv,
                                          CLSCTX_LOCAL_SERVER,
                                          (void**)&pTargFrmPriv));
#else  // NO_MARSHALLING
        hr = THR(CoCreateInstance(CLSID_InternetExplorer,
                                  NULL,
                                  CLSCTX_LOCAL_SERVER,
                                  IID_ITargetFramePriv,
                                  (void**)&pTargFrmPriv));        
#endif  
        if (hr)
            goto Cleanup;
    }

    pTopWebOC = NULL;  // This ptr should not be released.

    // Register the notification handler on an ITargetNotify2. It does not matter
    // which window's implementation, since the ITargetNotify2::OnCreate only works 
    // with parameters

    hr = THR(pCWindow->QueryInterface(IID_ITargetNotify2, (void**)&pNotify));
    if (hr)
        goto Cleanup;

    hr = THR(pBindCtx->RegisterObjectParam(TARGET_NOTIFY_OBJECT_NAME, pNotify));
    Assert(SUCCEEDED(hr));

    // Do stuff with the URL...
    const TCHAR * pszFindLoc;

    // Separate the base URL from the location (hash)
    pszFindLoc = StrChrW(pchUrl, '#');

    if (pszFindLoc)
    {
        const TCHAR * pszTemp = StrChrW(pszFindLoc, '/');
        if (!pszTemp)
            pszTemp = StrChrW(pszFindLoc, '\\');

        // no delimiters past this # marker... we've found a location.
        // break out
        if (pszTemp)
            pszFindLoc = NULL;
    }

    TCHAR szBaseURL[pdlUrlLen+1];
    TCHAR szLocation[pdlUrlLen+1];

    if (pszFindLoc)
    {
        // StrCpyNW alway null terminates to we need to copy len+1
        StrCpyNW(szBaseURL, pchUrl, (int) (pszFindLoc - pchUrl + 1));
        StrCpyNW(szLocation, pszFindLoc, pdlUrlLen);
    }
    else
    {
        StrCpyNW(szBaseURL, pchUrl, pdlUrlLen);
        szLocation[0] = 0;
    }

    hr = pTargFrmPriv->NavigateHack(HLNF_OPENINNEWWINDOW | (fReplace ? HLNF_CREATENOHISTORY : 0),
                                    pBindCtx,
                                    pDwnBindInfo,
                                    pchUniqueWindowName ? pchUniqueWindowName : pchTarget,
                                    szBaseURL,
                                    pszFindLoc ? szLocation : NULL);
    if (hr)
        goto Cleanup;

    if (pCWindow->_pOpenedWindow)
    {
        DISPPARAMS dispparams = g_Zero.dispparams;
        CVariant   cvarWindow;

        //
        // this window might not implement IHTMLWindow2, thus we ignore the HR
        //

        hr = pCWindow->_pOpenedWindow->Invoke(DISPID_WINDOWOBJECT,
                                              IID_NULL,
                                              0,
                                              DISPATCH_PROPERTYGET,
                                              &dispparams,
                                              &cvarWindow,
                                              NULL,
                                              NULL);

        if (hr)
        {
            //hacking around for the non webview folder view case
            V_DISPATCH(&cvarWindow) = pCWindow->_pOpenedWindow;
            V_VT(&cvarWindow) = VT_DISPATCH;
            
            // protect against the auto release of the variant variable.
            pCWindow->_pOpenedWindow->AddRef();

            hr = S_OK;
        }

        if (ppHTMLWindow2)
        {

            IGNORE_HR((V_DISPATCH(&cvarWindow))->QueryInterface(IID_IHTMLWindow2, (void**)ppHTMLWindow2));
        }
    }

Cleanup:
    // take the information off of the bind context, since the bind context
    // will be released by the callers of this function
    pBindCtx->RevokeObjectParam(TARGET_NOTIFY_OBJECT_NAME);
    pBindCtx->RevokeObjectParam(KEY_BINDCONTEXTPARAM);
    pBindCtx->RevokeObjectParam(SZ_DWNBINDINFO_OBJECTPARAM);

    // Clean the buffer variable _pOpenedWindow for following uses.
    // No need to clean the callback flag, since it gets reset on each call.
    
    if (pCWindow)
    {
        ClearInterface(&pCWindow->_pOpenedWindow);
    }

    ReleaseInterface(pTargFrmPriv);
    ReleaseInterface(pNotify);

    if(pchUniqueWindowName)
    {
        MemFreeString(pchUniqueWindowName);
    }

    TraceTag((tagFrameT, "FrameT: OpenInNewWindow returning 0x%X", hr));
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method    : GetWindowByType
//
//  Synopsis  : Returns the window for the given target type.  
//
//  Input     : eTargetType      - the type of window to retrieve.
//              pWindow          - the window to use to find the target.
//  Output    : ppTargHTMLWindow - the IHTMLWindow2 of the target window.
//              ppTopWebOC       - the WebOC of the top-level browser. This
//                                 is set if there is a failure retrieving
//                                 the main window.
//
//  Returns   : S_OK    - window found.
//              S_FALSE - open new browser window.
//              OLE error code - error or window not found.
//
//--------------------------------------------------------------------------

HRESULT
GetWindowByType(TARGET_TYPE     eTargetType,
                IHTMLWindow2  * pWindow,
                IHTMLWindow2 ** ppTargHTMLWindow,
                IWebBrowser2 ** ppTopWebOC)
{
    HRESULT hr = S_OK;
    
    Assert(pWindow);
    Assert(ppTargHTMLWindow);

    *ppTargHTMLWindow = NULL;
    
    switch(eTargetType)
    {
        case TARGET_SELF:
            hr = pWindow->get_self(ppTargHTMLWindow);
            break;
            
        case TARGET_PARENT:
            hr = pWindow->get_parent(ppTargHTMLWindow);
            break;
            
        case TARGET_TOP:
            hr = pWindow->get_top(ppTargHTMLWindow);
            break;
        case TARGET_MAIN:
            hr = GetMainWindow(pWindow, ppTargHTMLWindow, ppTopWebOC);
            break;

        // TARGET_BLANK is the same as open in new window.
        // Therefore, return S_FALSE to cause a new browser
        // window to be opened.
        //
        case TARGET_BLANK:
            hr = S_FALSE;
            break;
            
        case TARGET_SEARCH:  // Handled in FollowHyperlink
        case TARGET_MEDIA:   // Handled in FollowHyperlink
        default:
            hr = E_FAIL;
            break;
    }

    TraceTag((tagFrameT, "FrameT: GetWindowByType returning 0x%X", hr));
    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method    : GetMainWindow
//
//  Synopsis  : Returns the IHTMLWindow2 of the main browser window.  
//
//  Input     : pWindow          - the window to use to find the target.
//  Output    : ppTargHTMLWindow - the IHTMLWindow2 of the target window.
//              ppTopWebOC       - the WebOC of the top-level browser. This
//                                 is set if there is a failure retrieving
//                                 the main window.
//
//  Returns   : S_OK if successful; OLE error code otherwise..
//
//--------------------------------------------------------------------------

HRESULT
GetMainWindow(IHTMLWindow2  * pWindow,
              IHTMLWindow2 ** ppTargHTMLWindow,
              IWebBrowser2 ** ppTopWebOC)
{
    HRESULT hr;
    IHTMLDocument2   * pDocument   = NULL;
    IWebBrowser2     * pWebBrowser = NULL;
    IShellBrowser    * pShlBrowser = NULL;

    Assert(pWindow);
    Assert(ppTargHTMLWindow);

    *ppTargHTMLWindow = NULL;
    
    hr = pWindow->get_document(&pDocument);
    if (hr)
        goto Cleanup;
        
    // Check to see if we are in a band object
    //
    hr = IUnknown_QueryService(pDocument,
                               SID_SProxyBrowser,
                               IID_IShellBrowser,
                               (void**)&pShlBrowser);

    // If we are in a band object, get the WebOC of its host.
    // Otherwise, just return the current window.
    //
    if (!hr)
    {
        // Get the top-level browser object.
        //
        hr = IUnknown_QueryService(pShlBrowser,
                                   SID_SWebBrowserApp,
                                   IID_IWebBrowser2,
                                   (void**)&pWebBrowser);
        if (hr)
            goto Cleanup;

        hr = GetWebOCWindow(pWebBrowser, FALSE, ppTargHTMLWindow);

        // If there was a failure retrieving the window, we call
        // IWebBrowser2::Navigate on the main window instead.
        // This can happen if the main window contains a non-html file.
        //
        if (hr && ppTopWebOC)
        {
            *ppTopWebOC = pWebBrowser;
            pWebBrowser = NULL;  // Don't release.
        }
    }
    else  // Not in a band
    {
        hr = pWindow->get_self(ppTargHTMLWindow);
    }
    

Cleanup:
    ReleaseInterface(pDocument);
    ReleaseInterface(pWebBrowser);
    ReleaseInterface(pShlBrowser);
    
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method    : NavigateInBand
//
//  Synopsis  : Navigates to a URL in the specified browser band.  
//
//  Input     : pDocument      - the current document. This is needed in order
//                               to access the top-level browser.
//              clsid          - the clsid of the band to open and navigate.
//              pszOriginalUrl - The original (unexpanded) URL. If this URL
//                               is empty, the band will be opened but
//                               not navigated.
//              pszExpandedUrl - the URL to navigate to.
//
//  Output    : ppBandWindow   - the IHTMLWindow2 of the band.
//
//  Returns   : S_OK if successful; OLE error code otherwise..
//
//-----------------------------------------------------------------------------

HRESULT
NavigateInBand(IHTMLDocument2 * pDocument,
               IHTMLWindow2   * pOpenerWindow,
               REFCLSID         clsid,
               LPCTSTR          pszOriginalUrl,
               LPCTSTR          pszExpandedUrl,
               IHTMLWindow2  ** ppBandWindow)
{
    HRESULT  hr;
    VARIANT  varClsid = {0};  // Don't use CVariant. See Cleanup for details.
    CVariant cvarBandUnk;
    CVariant cvarUrl(VT_BSTR);
    IOleCommandTarget * pCmdTarget  = NULL;
    IBrowserBand      * pBrowserBand = NULL;

    Assert(pDocument);
    Assert(clsid != CLSID_NULL);
    Assert(pszOriginalUrl);
    Assert(pszExpandedUrl);

    hr = GetBandCmdTarget(pDocument, &pCmdTarget);
    if (hr)
        goto Cleanup;

    // Show the band
    //
    V_VT(&varClsid) = VT_BSTR;
    
    hr = StringFromCLSID(clsid, &V_BSTR(&varClsid));
    if (hr)
        goto Cleanup;

    hr = pCmdTarget->Exec(&CGID_ShellDocView,
                          SHDVID_SHOWBROWSERBAR,
                          1,
                          &varClsid,
                          NULL);
    if (hr)
        goto Cleanup;
        
    hr = pCmdTarget->Exec(&CGID_ShellDocView,
                          SHDVID_GETBROWSERBAR,
                          NULL,
                          NULL, 
                          &cvarBandUnk);

    if (hr || (VT_UNKNOWN != V_VT(&cvarBandUnk)) || (NULL == V_UNKNOWN(&cvarBandUnk)))
    {
        goto Cleanup;
    }
    
    hr = V_UNKNOWN(&cvarBandUnk)->QueryInterface(IID_IBrowserBand, (LPVOID*)&pBrowserBand);
    if (hr)
        goto Cleanup;
        
    // If the original URL is empty, we need
    // to navigate to the default search page.
    // Get the default search URL.
    //
    if (!*pszOriginalUrl
        && S_FALSE == IUnknown_Exec(pBrowserBand, &CLSID_SearchBand, SBID_HASPIDL, 0, NULL, NULL))
    {
        GetDefaultSearchUrl(pBrowserBand, &V_BSTR(&cvarUrl));
    }
    else
    {
        if (!*pszOriginalUrl)
        {
            V_BSTR(&cvarUrl) = SysAllocString(TEXT(""));
        }
        else
        {
            V_BSTR(&cvarUrl) = SysAllocString(pszExpandedUrl);
        }
    }

    if (NULL == V_BSTR(&cvarUrl))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pCmdTarget->Exec(&CGID_ShellDocView,
                          SHDVID_NAVIGATEBBTOURL,
                          NULL,
                          &cvarUrl,
                          NULL);
    
    if (hr)
        goto Cleanup;

    // Get the the band window if one is needed
    // (i.e., ppBandWindow != NULL. This is usually
    // the case when we are called as the result of 
    // a call to window.open().
    //
    if (ppBandWindow)
    {
        hr = GetBandWindow(pBrowserBand, ppBandWindow);

        if (!hr && pOpenerWindow)
        {
            // Set the opener window
            //
            CVariant cvarOpener(VT_DISPATCH);

            hr = pOpenerWindow->QueryInterface(IID_IDispatch, (void**)&V_DISPATCH(&cvarOpener));
            if (hr)
                goto Cleanup;

            hr = (*ppBandWindow)->put_opener(cvarOpener);
        }
    }

Cleanup:
    ReleaseInterface(pCmdTarget);
    ReleaseInterface(pBrowserBand);

    // Do not VariantClear varClsid. The BSTR in varClsid
    // must be freed using CoTaskMemFree since it was 
    // allocated by StringFromCLSID using CoTaskMemAlloc.
    // Using VariantClear causes a crash in ntdll.
    // CVariant uses VariantClear. That is why VARIANT
    // is used instead.
    //
    CoTaskMemFree(V_BSTR(&varClsid));

    TraceTag((tagFrameT, "FrameT: NavigateInBand returning 0x%X", hr));
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method    : GetBandWindow
//
//  Synopsis  : Retrieves the IHTMLWindow2 of a band. This method assumes that
//              the band has already been opened.
//
//  Input     : pBrowserBand - the IBrowserBand of the band.
//  Output    : ppBandWindow - the IHTMLWindow2 of the band.
//
//-----------------------------------------------------------------------------

HRESULT
GetBandWindow(IBrowserBand  * pBrowserBand,
              IHTMLWindow2 ** ppBandWindow)
{
    HRESULT  hr;
    IWebBrowser2     * pBandWebOC = NULL;
    IDispatch        * pDispatch  = NULL;
    IHTMLDocument2   * pDocument  = NULL;
    ITargetFramePriv * pFramePriv = NULL;

    Assert(pBrowserBand);
    Assert(ppBandWindow);
    Assert(!*ppBandWindow);

    *ppBandWindow = NULL;
    
    hr = pBrowserBand->GetObjectBB(IID_IWebBrowser2, (LPVOID*)&pBandWebOC);
    if (hr)
        goto Cleanup;

    hr = pBandWebOC->get_Document(&pDispatch);
    if (hr)
        goto Cleanup;

    // get_Document will return hr == S_OK with a NULL
    // IDispatch if the document has not yet been navigated.
    // If get_Document returns an IDispatch, get the window
    // from the returned ptr, otherwise, retrieve the
    // ITargetFramePriv of the band and get the window
    // from ITargetFramePriv.
    //
    if (pDispatch)
    {
        hr = pDispatch->QueryInterface(IID_IHTMLDocument2, (void**)&pDocument);
        if (hr)
            goto Cleanup;
        
        hr = pDocument->get_parentWindow(ppBandWindow);
    }
    else
    {
        hr = pBandWebOC->QueryInterface(IID_ITargetFramePriv, (void**)&pFramePriv);
        if (hr)
            goto Cleanup;

        hr = IUnknown_QueryService(pFramePriv,
                                   SID_SOmWindow,
                                   IID_IHTMLWindow2,
                                   (void**)ppBandWindow);
    }

Cleanup:
    ReleaseInterface(pBandWebOC);
    ReleaseInterface(pDispatch);
    ReleaseInterface(pDocument);
    ReleaseInterface(pFramePriv);

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method    : GetBandCmdTarget
//
//  Synopsis  : Retrieves the IOleCommandTarget of a band. 
//
//  Input     : pDocument   - the current document. 
//  Output    : ppCmdTarget - the IOleCommandTarget of the band.
//
//-----------------------------------------------------------------------------

HRESULT
GetBandCmdTarget(IHTMLDocument2     * pDocument,
                 IOleCommandTarget ** ppCmdTarget)
{
    HRESULT hr;
    IServiceProvider * pSvcPrvdr   = NULL;
    IShellBrowser    * pShlBrowser = NULL;

    Assert(pDocument);
    Assert(ppCmdTarget);

    // Get the top-level browser object.
    //
    hr = pDocument->QueryInterface(IID_IServiceProvider, (void**)&pSvcPrvdr);
    if (hr)
        goto Cleanup;

    // Check to see if we are in a band object. If we are, get its 
    // IShellBrowser. If not, retrieve the IShellBrowser of the 
    // current browser window.
    //
    hr = pSvcPrvdr->QueryService(SID_SProxyBrowser,
                                 IID_IShellBrowser,
                                 (void**)&pShlBrowser);

    if (hr != S_OK) // Not in band object
    {
        hr = pSvcPrvdr->QueryService(SID_SShellBrowser,
                                     IID_IShellBrowser,
                                     (void**)&pShlBrowser);
        if (hr)
            goto Cleanup;
    }

    // Get the IOleCommandTarget of the shell browser
    // in order to show and navigate the band.
    //
    hr = pShlBrowser->QueryInterface(IID_IOleCommandTarget, (void**)ppCmdTarget);

Cleanup:
    ReleaseInterface(pSvcPrvdr);
    ReleaseInterface(pShlBrowser);

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method    : GetDefaultSearchUrl
//
//  Synopsis  : Retrieves the default search url to be loaded into the 
//              search band.
//
//  Input     : pBrowserBand - the IBrowserBand of the band.
//  Output    : pbstrUrl     - the default search URL.
//
//-----------------------------------------------------------------------------

HRESULT
GetDefaultSearchUrl(IBrowserBand * pBrowserBand,
                    BSTR         * pbstrUrl)
{
    HRESULT hr;
    TCHAR   szSearchUrl[INTERNET_MAX_URL_LENGTH];
    ISearchItems * pSearchItems = NULL;

    Assert(pBrowserBand);
    Assert(pbstrUrl);

    *pbstrUrl = NULL;

    hr = IUnknown_QueryService(pBrowserBand,
                               SID_SExplorerToolbar,
                               IID_ISearchItems,
                               (void**)&pSearchItems);
    if (hr)
        goto Cleanup;

    // Get the default search url
    
    hr = pSearchItems->GetDefaultSearchUrl(szSearchUrl, ARRAY_SIZE(szSearchUrl));
    if (hr)
        goto Cleanup;

    *pbstrUrl = SysAllocString(szSearchUrl);

Cleanup:
    ReleaseInterface(pSearchItems);

    RRETURN(hr);
}

//+--------------------------------------------------------------------------
//
//  Function  : GetTargetType
//
//  Synopsis  : Returns the type of target window for the given target name.
//
//  Input     : pszTargetName - the target window name.
//
//  Returns   : TARGET_TYPE corresponding to the give window name.
//
//---------------------------------------------------------------------------

TARGET_TYPE 
GetTargetType(LPCOLESTR pszTargetName)
{
    const TARGETENTRY * pEntry = targetTable;

    if (!pszTargetName || pszTargetName[0] != '_')
    {
        goto Cleanup;
    }
        
    while (pEntry->pszTargetName)
    {
        // Remember: magic names are case-sensitive.
        //
        if (!StrCmpW(pszTargetName, pEntry->pszTargetName))
        {
            return pEntry->eTargetType;
        }
        
        pEntry++;
    }

Cleanup:
    // Treat unknown magic targets as regular
    // frame name for NETSCAPE compatibility.
    //
    return TARGET_FRAMENAME;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\misc\otherid.c ===
/*
   formid.c

   Please do not use any single line comments before the inclusion of w4warn.h!
*/

#define INITGUID
#include <w4warn.h>
#ifdef WIN16
#include <windows.h>
#else
#include <windef.h>
#endif
#include <basetyps.h>

#define PRIVATE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)
#include <othrguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\misc\hlinkfrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       hlinkfrm.h
//
//  Contents:   IHlinkFrame implementation for the CWindow class.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef _X_FRMSITE_H_
#define _X_FRMSITE_H_
#include "frmsite.h"
#endif

#ifndef X_FRAMEWEBOC_HXX_
#define X_FRAMEWEBOC_HXX_
#include "frameweboc.hxx"
#endif

DeclareTag(tagHlinkFrame, "CWindow::IHlinkFrame", "Trace IHlinkFrame Methods")
DeclareTag(tagTargetFrame, "CWindow::ITargetFrame", "Trace ITargetFrame Methods")


#define SZ_HTMLLOADOPTIONS_OBJECTPARAM  _T("__HTMLLOADOPTIONS")

#define ReturnTraceNotImpl(str) \
{ \
    TraceTag((tagHlinkFrame, str)); \
    return E_NOTIMPL; \
}

#define HDR_LANGUAGE     TEXT("Accept-Language:")
#define CRLF             TEXT("\x0D\x0A")

HRESULT
CFrameWebOC::SetBrowseContext(IHlinkBrowseContext * pihlbc)
{
    ReturnTraceNotImpl("SetBrowseContext");
}

HRESULT
CFrameWebOC::GetBrowseContext(IHlinkBrowseContext ** ppihlbc)
{
    ReturnTraceNotImpl("GetBrowseContext");
}

HRESULT
CFrameWebOC::Navigate(DWORD grfHLNF,
                      LPBC  pbc,
                      IBindStatusCallback * pibsc,
                      IHlink * pihlNavigate)
{
    HRESULT    hr = E_FAIL;
    IMoniker * pmkTarget = NULL;
    IBindCtx * pbcLocal  = NULL;
    LPOLESTR   pstrUrl   = NULL;
    BSTR       bstrUrl   = NULL;
    BSTR       bstrShortcut  = NULL;
    LPOLESTR   pstrLocation  = NULL;
    LPOLESTR   pstrFrameName = NULL;
    BSTR       bstrFrameName = NULL;
    BSTR       bstrLocation = NULL;
    DWORD      dwFlags = DOCNAVFLAG_DOCNAVIGATE;

    TraceTag((tagHlinkFrame, "Navigate"));

    // We may need to support grfHLNF, pbc, pibsc, and pihlNavigate)
    //
    if (pihlNavigate && ((IHlink *)-1) != pihlNavigate)
    {
        IGNORE_HR(pihlNavigate->GetTargetFrameName(&pstrFrameName));

        //
        // Note that we are discarding "relative" portion.
        //
        hr = pihlNavigate->GetMonikerReference(HLINKGETREF_ABSOLUTE, &pmkTarget, &pstrLocation);
        if (hr)
            goto Cleanup;

        if (pbc) 
        {
            IUnknown         * pUnk = NULL;
            IHtmlLoadOptions * pHtmlLoadOptions  = NULL;

            pbcLocal = pbc;
            pbcLocal->AddRef();

            //
            // at this point extract information from the BindCtx that was passed in.
            // currently (bug 98431) the internet shortcut is the only one required.
            //
            // NOTE, ProcessHTMLLoadOptions deals with other LoadOption values.
            //  they are not yet implemented here.
            //
            pbcLocal->GetObjectParam(SZ_HTMLLOADOPTIONS_OBJECTPARAM, &pUnk);

            if (pUnk)
            {
                pUnk->QueryInterface(IID_IHtmlLoadOptions, (void **)&pHtmlLoadOptions);

                if (pHtmlLoadOptions)
                {
                    TCHAR    achCacheFile[MAX_PATH];
                    ULONG    cchCacheFile = ARRAY_SIZE(achCacheFile);

                    // now determine if this is a shortcut-initiated load
                    hr = THR(pHtmlLoadOptions->QueryOption(HTMLLOADOPTION_INETSHORTCUTPATH,
                                                           &achCacheFile,
                                                           &cchCacheFile));
                    if (   hr == S_OK
                        && cchCacheFile)
                    {
                        bstrShortcut  = SysAllocString(achCacheFile);
                    }
                }
            }

            ReleaseInterface(pHtmlLoadOptions);
            ReleaseInterface(pUnk);
        }
        else 
        {
            hr = CreateBindCtx(0, &pbcLocal);
            if (hr)
                goto Cleanup;
        }

        hr = pmkTarget->GetDisplayName(pbcLocal, NULL, &pstrUrl);
        if (hr)
            goto Cleanup;

        bstrUrl       = SysAllocString(pstrUrl);
        bstrFrameName = SysAllocString(pstrFrameName);
        bstrLocation = SysAllocString(pstrLocation);

        if (grfHLNF & HLNF_OPENINNEWWINDOW)
            dwFlags |= DOCNAVFLAG_OPENINNEWWINDOW;

        DWORD grfBINDF;
        BINDINFO binfo = {0};
        SAFEARRAY * psaPostData = NULL;
        VARIANT vaPostData = {0};
        VARIANT vaHeaders = {0};
        IHttpNegotiate *pinegotiate;
        BSTR bstrHeaders = NULL;

        binfo.cbSize = sizeof(binfo);

        if( pibsc && SUCCEEDED(pibsc->GetBindInfo(&grfBINDF, &binfo)))
        {
            if(binfo.stgmedData.tymed == TYMED_HGLOBAL && binfo.stgmedData.hGlobal && binfo.cbstgmedData) 
            {
                // make a SAFEARRAY for post data
                psaPostData = SafeArrayCreateVector(VT_UI1, 0, binfo.cbstgmedData);
                if (psaPostData)
                {
                    memcpy(psaPostData->pvData, binfo.stgmedData.hGlobal, binfo.cbstgmedData);                
                    V_VT(&vaPostData) = VT_ARRAY | VT_UI1;
                    V_ARRAY(&vaPostData) = psaPostData;
                }
            }
            
        }

        if ( pibsc && SUCCEEDED(pibsc->QueryInterface(IID_IHttpNegotiate, (LPVOID *)&pinegotiate)) )
        {
            WCHAR *pwzAdditionalHeaders = NULL;

            hr=pinegotiate->BeginningTransaction(NULL, NULL, 0, &pwzAdditionalHeaders);
            if (SUCCEEDED(hr) && pwzAdditionalHeaders)
            {

                LPTSTR pszNext;
                LPTSTR pszLine;
                LPTSTR pszLast;

                pszLine = pwzAdditionalHeaders;
                pszLast = pwzAdditionalHeaders + lstrlen(pwzAdditionalHeaders);
                while (pszLine < pszLast)
                {
                    pszNext = StrStrI(pszLine, CRLF);
                    if (pszNext == NULL)
                    {
                        // All Headers must be terminated in CRLF!
                        pszLine[0] = '\0';
                        break;
                    }
                    pszNext += 2;
                    if (!StrCmpNI(pszLine,HDR_LANGUAGE,16))
                    {
                        MoveMemory(pszLine, pszNext, ((pszLast - pszNext) + 1)*sizeof(TCHAR));
                        break;
                    }
                    pszLine = pszNext;
                }
                // Don't include empty headers
                if (pwzAdditionalHeaders[0] == '\0')
                {
                    CoTaskMemFree(pwzAdditionalHeaders);
                    pwzAdditionalHeaders = NULL;
                }

            }


            if (pwzAdditionalHeaders && pwzAdditionalHeaders[0])
            {
                bstrHeaders = SysAllocString(pwzAdditionalHeaders);
                V_VT(&vaHeaders) = VT_BSTR;
                V_BSTR(&vaHeaders) = bstrHeaders;
            }

            pinegotiate->Release();
            CoTaskMemFree(pwzAdditionalHeaders);
        }


        hr = _pWindow->SuperNavigate(bstrUrl,
                                     bstrLocation,
                                     bstrShortcut,
                                     bstrFrameName,
                                     &vaPostData,
                                     &vaHeaders,
                                     dwFlags);
        if (psaPostData)
        {
            SafeArrayDestroy(psaPostData); 
        }

        if (bstrHeaders)
        {
            SysFreeString(bstrHeaders);
        }

        ReleaseBindInfo(&binfo);
    }

Cleanup:
    ReleaseInterface(pmkTarget);
    ReleaseInterface(pbcLocal);

    TaskFreeString(pstrUrl);
    TaskFreeString(pstrLocation);
    TaskFreeString(pstrFrameName);

    SysFreeString(bstrUrl);
    SysFreeString(bstrFrameName);
    SysFreeString(bstrShortcut);
    SysFreeString(bstrLocation);

    return hr;
}

HRESULT
CFrameWebOC::OnNavigate(DWORD      grfHLNF,
                        IMoniker * pimkTarget,
                        LPCWSTR    pwzLocation,
                        LPCWSTR    pwzFriendlyName,
                        DWORD      dwreserved)
{
    ReturnTraceNotImpl("OnNavigate");
}

HRESULT
CFrameWebOC::UpdateHlink(ULONG      uHLID,
                         IMoniker * pimkTarget,
                         LPCWSTR    pwzLocation,
                         LPCWSTR    pwzFriendlyName)
{
    ReturnTraceNotImpl("UpdateHlink");
}

HRESULT
CFrameWebOC::SetFrameName(LPCWSTR pszFrameName)
{
    HRESULT hr = E_FAIL;
    BSTR bstrName = NULL;
    
    TraceTag((tagTargetFrame, "SetFrameName"));

    FRAME_WEBOC_PASSIVATE_CHECK(hr);
    
    FRAME_WEBOC_VERIFY_WINDOW(hr);

    bstrName = SysAllocString(pszFrameName);
    
    if (bstrName)
    {
        hr = _pWindow->put_name(bstrName);
    }

    SysFreeString(bstrName);
    RRETURN(hr);
}

HRESULT
CFrameWebOC::GetFrameName(LPWSTR * ppszFrameName)
{
    HRESULT hr = E_FAIL;
    BSTR bstrName = NULL;

    TraceTag((tagTargetFrame, "GetFrameName"));

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);
    
    hr = _pWindow->get_name(&bstrName);
    if (hr)
        goto Cleanup;
    
    hr = TaskAllocString(bstrName, ppszFrameName);

Cleanup:
    SysFreeString(bstrName);
    RRETURN(hr);
}

HRESULT
CFrameWebOC::GetParentFrame(IUnknown ** ppunkParent)
{
    HRESULT hr = E_FAIL;
    IHTMLWindow2 * pHTMLWindow = NULL;
    TraceTag((tagTargetFrame, "GetParentFrame"));

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);
    
    hr = _pWindow->get_parent(&pHTMLWindow);
    if (hr)
        goto Cleanup;

    hr = pHTMLWindow->QueryInterface(IID_IUnknown, (void **) ppunkParent);

Cleanup:
    ReleaseInterface(pHTMLWindow);
    RRETURN(hr);
}

HRESULT
CFrameWebOC::FindFrame(LPCWSTR pszTargetName,
                       IUnknown * ppunkContextFrame,
                       DWORD dwFlags,
                       IUnknown ** ppunkTargetFrame)
{
    HRESULT             hr                      = E_FAIL;
    COmWindowProxy *    pTargetOmWindowProxy;
    IHTMLWindow2   *    pTargetHTMLWindow       = NULL;
    IWebBrowser2    *   pWebBrowser             = NULL;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);
    
    TraceTag((tagTargetFrame, "FindFrame"));

    if (!ppunkTargetFrame)
        goto Cleanup;

    *ppunkTargetFrame = NULL;

    hr = _pWindow->FindWindowByName(pszTargetName, &pTargetOmWindowProxy, &pTargetHTMLWindow);
    if (hr)
        goto Cleanup;

    if (pTargetHTMLWindow)
    {
        IServiceProvider * pServiceProvider;
        hr = THR(pTargetHTMLWindow->QueryInterface(IID_IServiceProvider, (void **) &pServiceProvider));
        if (hr)
            goto Cleanup;
        hr = THR(pServiceProvider->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void **) &pWebBrowser));
        ReleaseInterface(pServiceProvider);
    }  
    else if (pTargetOmWindowProxy)
    {
        hr = THR(pTargetOmWindowProxy->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void **) &pWebBrowser));
    }
    if (hr)
        goto Cleanup;
    hr = THR(pWebBrowser->QueryInterface(IID_IUnknown, (void **) ppunkTargetFrame));

Cleanup:
    ReleaseInterface(pWebBrowser);
    ReleaseInterface(pTargetHTMLWindow);

    // Return E_FAIL if a matching frame is not found
    return (S_OK == hr) ? S_OK : E_FAIL;
}

HRESULT
CFrameWebOC::SetFrameSrc(LPCWSTR pszFrameSrc)
{
    HRESULT hr = E_FAIL;
    BSTR bstrSrc = NULL;
    IHTMLFrameBase * pHTMLFrameBase = NULL;

    TraceTag((tagTargetFrame, "SetFrameSrc"));

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);

    bstrSrc = SysAllocString(pszFrameSrc);
    
    if (bstrSrc)
    {
        hr = _pWindow->get_frameElement(&pHTMLFrameBase);
        if (!pHTMLFrameBase)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = pHTMLFrameBase->put_src(bstrSrc);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pHTMLFrameBase);
    SysFreeString(bstrSrc);
    RRETURN(hr);
}

HRESULT
CFrameWebOC::GetFrameSrc(LPWSTR * ppszFrameSrc)
{
    HRESULT hr = E_FAIL;
    BSTR bstrSrc = NULL;
    IHTMLFrameBase * pHTMLFrameBase = NULL;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);

    TraceTag((tagTargetFrame, "GetFrameSrc"));

    hr = _pWindow->get_frameElement(&pHTMLFrameBase);

    if (!pHTMLFrameBase)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pHTMLFrameBase->get_src(&bstrSrc);
    if (hr)
        goto Cleanup;
    
    hr = TaskAllocString(bstrSrc, ppszFrameSrc);

Cleanup:
    ReleaseInterface(pHTMLFrameBase);
    SysFreeString(bstrSrc);
    RRETURN(hr);
}

HRESULT
CFrameWebOC::GetFramesContainer(IOleContainer ** ppContainer)
{
    TraceTag((tagTargetFrame, "GetFramesContainer"));

    return E_NOTIMPL;
}

HRESULT
CFrameWebOC::SetFrameOptions(DWORD dwFlags)
{
    TraceTag((tagTargetFrame, "SetFrameOptions"));

    return E_NOTIMPL;
}

HRESULT
CFrameWebOC::GetFrameOptions(DWORD * pdwFlags)
{
    TraceTag((tagTargetFrame, "GetFrameOptions"));

    return E_NOTIMPL;
}

HRESULT
CFrameWebOC::SetFrameMargins(DWORD dwWidth, DWORD dwHeight)
{
    TraceTag((tagTargetFrame, "SetFrameMargins"));

    return E_NOTIMPL;
}

HRESULT
CFrameWebOC::GetFrameMargins(DWORD * pdwWidth, DWORD * pdwHeight)
{
    TraceTag((tagTargetFrame, "GetFrameMargins"));

    return E_NOTIMPL;
}

HRESULT
CFrameWebOC::RemoteNavigate(ULONG cLength, ULONG * pulData)
{
    TraceTag((tagTargetFrame, "RemoteNavigate"));

    return E_FAIL;
}

HRESULT
CFrameWebOC::OnChildFrameActivate(IUnknown * pUnkChildFrame)
{
    TraceTag((tagTargetFrame, "OnChildFrameActivate"));

    return S_OK;
}

HRESULT
CFrameWebOC::OnChildFrameDeactivate(IUnknown * pUnkChildFrame)
{
    TraceTag((tagTargetFrame, "OnChildFrameDeactivate"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\misc\othridpr.c ===
/*
   formidpr.c

   Please do not use any single line comments before the inclusion of w4warn.h!
*/

#define INITGUID
#include <w4warn.h>
#ifdef WIN16
#include <windows.h>
#else
#include <windef.h>
#endif
#include <basetyps.h>

#define PUBLIC_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)

#include <othrguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\moniker\shelprot.cxx ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\misc\webocutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       webocutil.cxx
//
//  Contents:   WebBrowser control utility functions
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_WEBOCUTIL_H_
#define X_WEBOCUTIL_H_
#include "webocutil.h"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#define MAX_ARGS  10

#define SID_SOmWindow IID_IHTMLWindow2
//+-------------------------------------------------------------------------
//
//  Method    : GetParentWebOC
//
//  Synopsis  : Retrieves the parent IWebBrowser2 of the given window.
//
//  Input     : pWindow      - the given window.
//  Output    : ppWebBrowser - the parent IWebBrowser2 of the given window.
//
//  Returns   : S_OK if successful; OLE error code otherwise..
//
//--------------------------------------------------------------------------

HRESULT
GetParentWebOC(IHTMLWindow2 * pWindow, IWebBrowser2 ** ppWebBrowser)
{
    HRESULT hr;
    IHTMLDocument2 * pDocument   = NULL;

    Assert(pWindow);
    Assert(ppWebBrowser);

    hr = pWindow->get_document(&pDocument);
    if (hr)
        goto Cleanup;
        
    // Get the parent browser object.
    //
    hr = IUnknown_QueryService(pDocument, 
                               SID_SWebBrowserApp,
                               IID_IWebBrowser2,
                               (void**)ppWebBrowser);
    if (hr)
        goto Cleanup;
        
Cleanup:
    ReleaseInterface(pDocument);

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Function  : GetWebOCWindow
//
//  Synopsis  : Returns the IHTMLWindow2 window object of the given 
//              IWebBrowser2 interface.
//
//  Input     : pWebBrowser      - the IWebBrowser2 interface to use
//                                 to retrieve the window object.
//              fGetWindowObject - TRUE indicates that the IHTMLWindow2
//                                 returned should be a CWindow object.
//  Output    : ppWindow         - the retrieved window object.
//
//  Returns   : S_OK if found, OLE error code otherwise.
//
//--------------------------------------------------------------------------

HRESULT
GetWebOCWindow(IWebBrowser2  * pWebBrowser,
               BOOL            fGetWindowObject,
               IHTMLWindow2 ** ppWindow)
{
    HRESULT hr;
    IDispatch      * pDispatch = NULL;
    IHTMLDocument2 * pDocument = NULL;
    DISPPARAMS     dispparams  = g_Zero.dispparams;
    CVariant       var;

    Assert(pWebBrowser);
    Assert(ppWindow);

    hr = pWebBrowser->get_Document(&pDispatch);

    // The WebOC sometimes returns hr = S_OK
    // with a null IDispatch.
    //
    if (!pDispatch)
        hr = E_FAIL;

    if (hr)
        goto Cleanup;

    // If the object we got back is a Trident document , then proceed to get
    // its window and use it.
    // Otherwise, we are most likely dealing with a shell window and we should 
    // get IHTMLWindow2 pointer from that window using a QueryService call.
    //
    hr = pDispatch->QueryInterface(IID_IHTMLDocument2, (void**)&pDocument);
    if (!hr)
    {
        hr = pDocument->get_parentWindow(ppWindow);
        if (hr)
            goto Cleanup;

        if (fGetWindowObject)
        {
            hr = (*ppWindow)->Invoke(DISPID_WINDOWOBJECT,
                                     IID_NULL,
                                     0,
                                     DISPATCH_PROPERTYGET,
                                     &dispparams,
                                     &var,
                                     NULL,
                                     NULL);
            (*ppWindow)->Release();
            if (hr)
                goto Cleanup;

            hr = (V_DISPATCH(&var))->QueryInterface(IID_IHTMLWindow2, (void**)ppWindow);
         }
    }
    else
    {
        hr = IUnknown_QueryService(pWebBrowser, SID_SOmWindow, IID_IHTMLWindow2, (void**)ppWindow);
    }

Cleanup:
    ReleaseInterface(pDispatch);
    ReleaseInterface(pDocument);

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method    : InvokeSink
//
//  Synopsis  : Enums the event sink for the given connection points and
//              calls Invoke for each sink.
//
//  Input     : pConnPt     - the connection point whose sinks should
//                            be enumerated and invoked.
//              dispidEvent - the dispid of the event to send to Invoke.
//              pDispParams - the parameters to send to invoke.
//
//  Returns   : S_OK if successful; OLE error code otherwise..
//
//--------------------------------------------------------------------------

void
InvokeSink(IConnectionPoint * pConnPt,
           DISPID             dispidEvent,
           DISPPARAMS       * pDispParams)
{
    HRESULT     hr;
    CONNECTDATA cd = {0};
    ULONG       cFetched;
    IEnumConnections * pEnumConn = NULL;
    IDispatch        * pDispConn = NULL;

    Assert(pConnPt);
    Assert(pDispParams);
    
    hr = pConnPt->EnumConnections(&pEnumConn);
    if (hr)
        goto Cleanup;

    hr = pEnumConn->Next(1, &cd, &cFetched);
    
    while (S_OK == hr)
    {
        Assert(1 == cFetched);
        Assert(cd.pUnk);

        hr = cd.pUnk->QueryInterface(IID_IDispatch, (void**)&pDispConn);
        if (hr)
            goto Cleanup;

        pDispConn->Invoke(dispidEvent,
                          IID_NULL,
                          LOCALE_USER_DEFAULT,
                          DISPATCH_METHOD,
                          pDispParams,
                          NULL,
                          NULL,
                          NULL);
        ClearInterface(&pDispConn);
        ClearInterface(&cd.pUnk);
        
        hr = pEnumConn->Next(1, &cd, &cFetched);
    }

Cleanup:
    ReleaseInterface(pEnumConn);
    ReleaseInterface(pDispConn);
    ReleaseInterface(cd.pUnk);
}

//+-------------------------------------------------------------------------
//
//  Method   : InvokeEventV
//
//  Synopsis : Invokes the given event sink. This function takes a variable
//             number of arguments and will pack them into a DISPARAMS
//             structure before invoking the event sink.
//
//  Input    : pConnPt     - the connection point to invoke. (Must be NULL
//                           if pBase is set.)
//             pBase       - the object to use for firing events. (Must be
//                           NULL if pConnPt is set.)
//             dispidEvent - the event to fire
//             cArgs       - the number of arguments to send with the event.
//             ...         - variable list of arguments to send with the
//                           event. This argument list must contain the 
//                           type of data preceding each data item.
//
//--------------------------------------------------------------------------

void
InvokeEventV(IConnectionPoint * pConnPt,
             CBase            * pBase,
             DISPID             dispidEvent, 
             int                cArgs,
             ...)
{
    HRESULT    hr;
    DISPPARAMS dispParams = g_Zero.dispparams;
    VARIANTARG rgvarArgList[MAX_ARGS] = {0};

#ifdef DBG
    if (!pConnPt)
        Assert(pBase);
    else
        Assert(!pBase);
#endif
 
    va_list vaArgList;
    va_start(vaArgList, cArgs);

    hr = THR(SHPackDispParamsV(&dispParams, rgvarArgList, cArgs, vaArgList));

    va_end(vaArgList);

    if (!hr)
    {
        if (pConnPt)
        {
            InvokeSink(pConnPt, dispidEvent, &dispParams);
        }
        else 
        {
            pBase->InvokeEvent(dispidEvent, DISPID_UNKNOWN,
                               NULL, NULL, &dispParams);
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Method   : FormatUrlForDisplay
//
//  Synopsis : Formats an URL for display purposes.
//
//  Input    : lpszIn  - the URL to format.
//  Output   : lpszOut - the formatted URL.
//
//--------------------------------------------------------------------------

HRESULT
FormatUrlForDisplay(LPCTSTR lpszIn,
                    LPTSTR  lpszOut,
                    LPDWORD pcchOut)
{
    HRESULT hr;

    Assert(lpszIn);
    Assert(lpszOut);

    if (GetUrlScheme(lpszIn) == URL_SCHEME_FILE)
    {
        hr = THR(PathCreateFromUrl(lpszIn, lpszOut, pcchOut, 0));
    }
    else
    {
        hr = THR(UrlUnescape(const_cast<LPTSTR>(lpszIn), lpszOut, pcchOut, 0));
    }
    
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method   : FormatUrl
//
//  Synopsis : Formats an URL for display or parsing.
//
//  Input    : lpszUrl      - the URL to format.
//             lpszLocation - the bookmark location name.
//  Output   : lpszUrl     - the formatted URL.
//
//--------------------------------------------------------------------------

HRESULT
FormatUrl(LPCTSTR lpszUrl,    LPCTSTR lpszLocation,
          LPTSTR  lpszUrlOut, DWORD   cchUrl)
{
    HRESULT hr;
    DWORD   cchOut = cchUrl;
    
    Assert(lpszUrl);
    Assert(lpszUrlOut);

    hr = FormatUrlForDisplay(lpszUrl, lpszUrlOut, &cchOut);
    if (hr)
        goto Cleanup;

    if (lpszLocation && *lpszLocation
        && (cchOut + _tcslen(lpszLocation) + 2) < cchUrl)
    {
        if (*lpszLocation != _T('#'))
        {
            lpszUrlOut[cchOut]   = _T('#');
            lpszUrlOut[++cchOut] = 0;
        }

        _tcscat(lpszUrlOut, lpszLocation);
    }

Cleanup:
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method   : GetWebOCDocument
//
//  Synopsis : Returns the IDispatch of the Document contained in the
//             given WebOC instance..
//
//  Input    : pUnk      - the IUnknown of the WebOC.
//  Output   : pDispatch - the IDispatch of the document.
//
//--------------------------------------------------------------------------

HRESULT GetWebOCDocument(IUnknown * pUnk, IDispatch ** ppDispatch)
{
    HRESULT hr;
    IWebBrowser2 * pWebOC = NULL;

    Assert(pUnk);
    Assert(ppDispatch);

    hr = pUnk->QueryInterface(IID_IWebBrowser2, (void**)&pWebOC);
    if (hr)
        goto Cleanup;

    hr = pWebOC->get_Document(ppDispatch);

    // get_Document can return S_OK with a NULL IDispatch.
    //
    if (S_OK == hr && !*ppDispatch)
    {
        hr = E_FAIL;
    }

Cleanup:
    ReleaseInterface(pWebOC);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member   : NavigateWebOCWithBindCtx
//
//  Synopsis : Navigates the WebOC using the given bind context.
//
//----------------------------------------------------------------------------

HRESULT
NavigateWebOCWithBindCtx(IWebBrowser2 * pWebBrowser,
                         VARIANT      * pvarUrl,
                         VARIANT      * pvarFlags,
                         VARIANT      * pvarFrameName,
                         VARIANT      * pvarPostData,
                         VARIANT      * pvarHeaders,
                         IBindCtx     * pBindCtx,
                         LPCTSTR        pchLocation)
{
    Assert(pWebBrowser);

    HRESULT hr;
    BSTR    bstrLocation = NULL;
    IWebBrowserPriv * pWebBrowserPriv = NULL;

    hr = pWebBrowser->QueryInterface(IID_IWebBrowserPriv, (void**)&pWebBrowserPriv);
    if (hr)
        goto Cleanup;

    hr = FormsAllocString(pchLocation, &bstrLocation);
    if (hr)
        goto Cleanup;

    hr = pWebBrowserPriv->NavigateWithBindCtx(pvarUrl, pvarFlags, pvarFrameName,
                                              pvarPostData, pvarHeaders, pBindCtx, bstrLocation);

Cleanup:
    ReleaseInterface(pWebBrowserPriv);
    FormsFreeString(bstrLocation);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\moniker\mailprot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       mailprot.cxx
//
//  Contents:   Implementation of the mailto protocol
//
//  History:    04-26-97    Yin XIE     Created
//              06-20-97    Yin XIE     Added cc;bcc;body;to
//              06-29-97    Yin XIE     Added non MAPI mail client support
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_MAPI_H_
#define X_MAPI_H_
#include <mapi.h>
#endif

#ifndef X_MAILPROT_HXX_
#define X_MAILPROT_HXX_
#include "mailprot.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#include <shellapi.h>  // for the definition of ShellExecuteA (for AXP)
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_INTLCORE_HXX_
#define X_INTLCORE_HXX_
#include <intlcore.hxx>
#endif

#define URL_KEYWL_MAILTO      7           // length of "mailto:"

MtDefine(CMailtoProtocol, Protocols, "CMailtoProtocol")
MtDefine(CMailtoProtocolPostData, CMailtoProtocol, "CMailtoProtocol::_postData")
MtDefine(CMailtoProtocolRecips, CMailtoProtocol, "CMailtoProtocol mailmsg.lpRecips")
MtDefine(CMailtoProtocolNoteText, CMailtoProtocol, "CMailtoProtocol mailmsg.lpszNoteText")
MtDefine(CMailtoProtocolFileDesc, CMailtoProtocol, "CMailtoProtocol MapiFileDesc")
MtDefine(CMailtoProtocolMbfwc, CMailtoProtocol, "CMailtoProtocol::MultiByteFromWideChar")
MtDefine(CMailtoFactory, Protocols, "CMailtoFactory")

//+---------------------------------------------------------------------------
//
//  Function:   CreateMailtoProtocol
//
//  Synopsis:   Creates a resource Async Pluggable protocol
//
//  Arguments:  pUnkOuter   Controlling IUnknown
//
//----------------------------------------------------------------------------

CBase * 
CreateMailtoProtocol(IUnknown *pUnkOuter)
{
    return new CMailtoProtocol(pUnkOuter);
}

const CBase::CLASSDESC CMailtoProtocol::s_classdesc =
{
    &CLSID_MailtoProtocol,          // _pclsid
};

//+---------------------------------------------------------------------------
//
//  Mailto Class Factory
//
//+---------------------------------------------------------------------------

CMailtoFactory g_cfMailtoProtocol   (CreateMailtoProtocol);

// IOInetProtocolInfo methods
HRESULT
CMailtoFactory::QueryInfo(LPCWSTR         pwzUrl,
                          QUERYOPTION     QueryOption,
                          DWORD           dwQueryFlags,
                          LPVOID          pBuffer,
                          DWORD           cbBuffer,
                          DWORD *         pcbBuf,
                          DWORD           dwReserved)
{
    HRESULT hr = INET_E_DEFAULT_ACTION;

    switch ( QueryOption )
    {
    case QUERY_CAN_NAVIGATE:

        // Need at least a DWORD
        if (cbBuffer < 4)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (pcbBuf)
        {
            *pcbBuf = 4; // 4 bytes needed for DWORD
        }

        *((DWORD *)pBuffer) = 0; // make sure we return false (0) for mailto prot.
        hr = S_OK;
        break;

    default:
        hr = THR(super::QueryInfo(
                pwzUrl,
                QueryOption,
                dwQueryFlags,
                pBuffer,
                cbBuffer,
                pcbBuf,
                dwReserved));
        break;
    }

Cleanup:
    RRETURN1(hr, INET_E_DEFAULT_ACTION);
}


//+---------------------------------------------------------------------------
//
//  Method:     CMailtoProtocol::CMailtoProtocol
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CMailtoProtocol::CMailtoProtocol(IUnknown *pUnkOuter) : super(pUnkOuter)
{
}


//+---------------------------------------------------------------------------
//
//  Method:     CMailtoProtocol::~CMailtoProtocol
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CMailtoProtocol::~CMailtoProtocol()
{
}

//+---------------------------------------------------------------------------
//
//  Method:     CMailtoProtocol::Start
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CMailtoProtocol::Start(
    LPCWSTR pchUrl, 
    IInternetProtocolSink *pTrans, 
    IInternetBindInfo *pOIBindInfo,
    DWORD grfSTI, 
    HANDLE_PTR dwReserved)
{
    HRESULT         hr = NOERROR;
#ifdef  NEVER
    TCHAR           ach[pdlUrlLen];
#endif
    DWORD           dwSize;
    
    Assert(!_pProtSink && pOIBindInfo && pTrans && !_cstrURL);

    if ( !(grfSTI & PI_PARSE_URL))
    {
        ReplaceInterface(&_pProtSink, pTrans);
        ReplaceInterface(&_pOIBindInfo, pOIBindInfo);
    }

    _bindinfo.cbSize = sizeof(BINDINFO);
    hr = THR(pOIBindInfo->GetBindInfo(&_grfBindF, &_bindinfo));

    if ((_grfBindF & BINDF_NO_UI) || (_grfBindF & BINDF_SILENTOPERATION))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(pOIBindInfo->GetBindString(BINDSTRING_POST_DATA_MIME, &_pszMIMEType, 1, &dwSize));
    // It can fail, but _pszMIMEType will be NULL.
    Assert( !hr || (hr && _pszMIMEType == NULL));

    _cp = _bindinfo.dwCodePage ? _bindinfo.dwCodePage : g_cpDefault;

#ifdef  NEVER
    //
    //  no need to unescape the URL at all
    // 

    //
    // First get the basic url.  Unescape it first.
    //
    hr = THR(CoInternetParseUrl(pchUrl, PARSE_ENCODE, 0, ach, ARRAY_SIZE(ach), &dwSize, 0));
    if (hr)
        goto Cleanup;
    
    hr = THR(_cstrURL.Set(ach));
    if (hr)
        goto Cleanup;

#endif
    hr = THR(_cstrURL.Set(pchUrl));
    if (hr)
        goto Cleanup;

    //
    // Now append any extra data if needed.
    //
    
    if (_bindinfo.szExtraInfo)
    {
        hr = THR(_cstrURL.Append(_bindinfo.szExtraInfo));
        if (hr)
            goto Cleanup;
    }
    
    switch (_bindinfo.dwBindVerb)
    {
    case    BINDVERB_POST:
        void *pData;
        _cPostData = _bindinfo.cbstgmedData;

        if (!_cPostData)
            break;

        _postData = (BYTE *)MemAlloc(Mt(CMailtoProtocolPostData), _cPostData);

        Assert(_bindinfo.stgmedData.tymed == TYMED_HGLOBAL);

        pData = GlobalLock(_bindinfo.stgmedData.hGlobal);
        if (pData)
        {
            memcpy(_postData, pData, _cPostData);
            GlobalUnlock(_bindinfo.stgmedData.hGlobal);
        }
        else
        {
            _cPostData = 0;
        }
        break;
    default:
        _cPostData = 0;
    }

    _grfSTI = grfSTI;

    //
    // If forced to go async, return E_PENDING now, and
    // perform binding when we get the Continue.
    //
    
    if (grfSTI & PI_FORCE_ASYNC)
    {
        PROTOCOLDATA    protdata;

        hr = E_PENDING;
        protdata.grfFlags = PI_FORCE_ASYNC;
        protdata.dwState = BIND_ASYNC;
        protdata.pData = NULL;
        protdata.cbData = 0;

        _pProtSink->Switch(&protdata);
    }
    else
    {
        hr = THR(ParseAndBind());
    }

Cleanup:
    RRETURN(hr);
}

// keep to,cc,bcc at begining, because we use this in loop
static const MAILTOURLSTRUCT   aURLInfo[]=
{
    {_T("to="),      3,    _T(" ")},
    {_T("cc="),      3,    _T(" ")},
    {_T("bcc="),     4,    _T(" ")},
    {_T("subject="), 8,    NULL},
    {_T("body="),    5,    NULL},
};

TCHAR *
CMailtoProtocol::GetNextRecipient(TCHAR * lptszRecipients)
{
    // get ride of all the spaces first,
    while (*lptszRecipients && *lptszRecipients == _T(' '))
        lptszRecipients++;

    while (*lptszRecipients && *lptszRecipients != _T(' ') && *lptszRecipients != _T(';'))
        lptszRecipients++;

    if (*lptszRecipients)
        return (lptszRecipients);

    return(NULL);
}

HRESULT
CMailtoProtocol::ParseMailToAttr()
{
    HRESULT hr = S_OK;
    int     i = 0;
    int     l = 0;
    TCHAR * pch = NULL;
    TCHAR * pch2 = NULL;

    //
    // The url is of the following syntax:
    // mailto:<email address>?subject=<subject>
    //
    
    Assert(_tcsnipre(TEXT("mailto:"), URL_KEYWL_MAILTO, _cstrURL, -1));

    for (i=0; i<mailtoAttrNUM; i++)
    {
        hr = THR(_aCStrAttr[i].Set(0));
        if (hr)
            goto Cleanup;
    }

    // parse recipients

    pch  = _tcschr(_cstrURL, _T('?'));
    if (pch)
    {
        hr = THR(_aCStrAttr[mailtoAttrTO].Set(_cstrURL+URL_KEYWL_MAILTO, pch-_cstrURL-URL_KEYWL_MAILTO));
    }
    else
    {
        hr = THR(_aCStrAttr[mailtoAttrTO].Set(_cstrURL+URL_KEYWL_MAILTO));
    }
    if (hr)
        goto Cleanup;

    if (!_aCStrAttr[mailtoAttrTO].IsNull() && _aCStrAttr[mailtoAttrTO].Length())
    {
        // append seperator to allow "to:"
        hr  = THR(_aCStrAttr[mailtoAttrTO].Append(aURLInfo[mailtoAttrTO].lptszSep, 1));
        if (hr)
            goto Cleanup;
    }

    // parse attributes

    while (pch)
    {
        pch++;
        for (i = 0; i < mailtoAttrNUM; i ++)
        {
            if (_tcsnipre(aURLInfo[i].lptszAttr, aURLInfo[i].attrLen, pch, -1))
            {
                pch     = _tcschr(pch, _T('='));
                if (!pch)
                    break;

                pch2    = _tcschr(pch, _T('&'));
                if (!pch2)
                {
                    // if no more subject, the next item is the end of URL
                    l = _tcslen(pch) - 1;
                }
                else
                {
                    l = pch2 - pch - 1;    
                }

                if (l <= 0)
                    break;

                hr  = THR(_aCStrAttr[i].Append(++pch, l));
                if (hr)
                    goto Cleanup;

                // append the seperator, if needed

                if (aURLInfo[i].lptszSep)
                {
                    hr  = THR(_aCStrAttr[i].Append(aURLInfo[i].lptszSep, 1));
                    if (hr)
                        goto Cleanup;
                }
                break;
            }
        }

        if (!pch || !*pch)
        {
            // we are at the end of URL
            // let's break
            break;
        }
        pch = _tcschr(pch, _T('&'));
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CMailtoProtocol::ParseAndBind
//
//  Synopsis:   Actually perform the binding & execution of script.
//
//----------------------------------------------------------------------------

HRESULT
CMailtoProtocol::ParseAndBind()
{
    CLock           Lock(this);

    HRESULT         hr = S_OK;

    TCHAR *         pch = NULL;

#ifndef UNIX
    HMODULE         hMail = 0;

    TCHAR           aSubject[pdlUrlLen];
#endif

    TCHAR           aRecips[pdlUrlLen];
    TCHAR *         pRecipsPtr[] = {NULL, NULL, NULL};
    int             pRecipsNum[] = {0, 0, 0};
    char            *aBuffer=NULL;
    LPTSTR          pEnd = 0;

    UINT            nRecips = 0;
    UINT            cUnicode = 0;
    UINT            cAnsi = 0;
    UINT            l = 0;

    int             i;

    LPMAPISENDMAIL pfnSendMail = 0;

#ifndef UNIX
    MapiMessage	    mapimsg;
    memset(&mapimsg, 0 , sizeof(mapimsg));

    // speed up mail client launch
    if (!_cPostData)
    {
        hr = RunMailClient();
        if (!_fAborted && _pProtSink)
        {
            _bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
            _pProtSink->ReportData(_bscf, 1, 1);
            _pProtSink->ReportResult(hr, 0, 0);
        }
        goto Cleanup;
    }
#endif

    hr = THR(ParseMailToAttr());
    if (hr)
        goto Cleanup;

    l = pdlUrlLen; 
    pch = aRecips;
    for (i = mailtoAttrTO; i <= mailtoAttrBCC; i++)
    {
        pRecipsPtr[i] = pch;
        cUnicode = _aCStrAttr[i].Length();
        if (cUnicode > l)
        {
            // if too big, truncate
            _tcsncpy(pch, (LPTSTR)_aCStrAttr[i], l-1);
            pch[l-1] = 0;
            pEnd = pch + l;
        }
        else if (cUnicode > 0)
        {
            _tcscpy(pch, (LPTSTR)_aCStrAttr[i]);
            pEnd = pch + cUnicode;
        }
        else
        {
            break;
        }

        while (pch < pEnd)
        {
            pch = GetNextRecipient(pch);
            if (!pch)
                break;
            // if found seperator, and the mail address is good
            *pch = 0;
            pch ++;
            nRecips ++;
            pRecipsNum[i] ++;
        }

        pch = pEnd;
    }

#ifndef UNIX
    if (nRecips)
    {
        mapimsg.lpRecips = (MapiRecipDesc *)MemAlloc(Mt(CMailtoProtocolRecips), nRecips * sizeof(MapiRecipDesc));
        memset(mapimsg.lpRecips, 0 , nRecips * sizeof(MapiRecipDesc));
        if (!mapimsg.lpRecips)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    for (i = mailtoAttrTO; i <= mailtoAttrBCC; i++)
    {
        if (pRecipsNum[i])
        {
            hr = THR(SetMAPIRecipients(&mapimsg, pRecipsPtr[i],
                                                pRecipsNum[i], i));

            if (FAILED(hr))
                goto Cleanup;
            mapimsg.nRecipCount += pRecipsNum[i];
        }
    }

    if (_pszMIMEType && StrCmpIC(_pszMIMEType, CFSTR_MIME_TEXT ) == 0)
    {   
        // This is always 8-bit ASCII because that is what
        // text/plain MIME encoding is!
        LPSTR pszText = (LPSTR) MemAlloc(Mt(CMailtoProtocolNoteText), _cPostData + 1);
        if (pszText)
        {
            memcpy(pszText, _postData, _cPostData);
            pszText[_cPostData] = 0; // terminate.
            mapimsg.lpszNoteText = pszText;
        }
        else
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    else
    {
        hr = THR(SetMAPIAttachement(&mapimsg));

        if (FAILED(hr))
            goto Cleanup;
    }

    cUnicode = _aCStrAttr[mailtoAttrSUBJECT].Length();
    if (!cUnicode && _postData)
    {
        // there is no subject, let's add the default one
        LoadString(GetResourceHInst(), IDS_MAILTO_DEFAULTSUBJECT,
                                aSubject, ARRAY_SIZE(aSubject));
        hr  = THR(_aCStrAttr[mailtoAttrSUBJECT].Set(aSubject));
        if (hr)
            goto Cleanup;
        cUnicode = _aCStrAttr[mailtoAttrSUBJECT].Length();
    }
    if (cUnicode)
    {
        hr = THR(MultiByteFromWideChar((WCHAR *)_aCStrAttr[mailtoAttrSUBJECT],
                                        cUnicode, &aBuffer, &cAnsi));

        if (FAILED(hr))
            goto Cleanup;

        mapimsg.lpszSubject = aBuffer;
        mapimsg.lpszConversationID = aBuffer;
    }

    // KB: Netscape ignore body attribute when there is post data
    // 
    if (!_cPostData || 
       (_pszMIMEType && StrCmpIC(_pszMIMEType, CFSTR_MIME_TEXT ) != 0) )
    {   
        cUnicode = _aCStrAttr[mailtoAttrBODY].Length();
        if (cUnicode)
        {
            hr = THR(MultiByteFromWideChar((WCHAR *)_aCStrAttr[mailtoAttrBODY],
                                            cUnicode, &aBuffer, &cAnsi));

            if (FAILED(hr))
                goto Cleanup;

            mapimsg.lpszNoteText = aBuffer;
        }
    }

    if (_cPostData)
    {
        // for performance reason, we prefer command line
        // we only load the DLLs when this is a form submission
        // and there is a postdata
        hr = LoadMailProvider(&hMail);
        if (FAILED(hr))
            goto Cleanup;
    }

    if (hMail)
    {
        pfnSendMail = (LPMAPISENDMAIL)GetProcAddress(hMail, "MAPISendMail");

        if (!pfnSendMail)
            goto Cleanup;
    }
#endif // !UNIX

    if (!_fAborted && _pProtSink)
    {
        _bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
        _pProtSink->ReportData(_bscf, 1, 1);
        _pProtSink->ReportResult(hr, 0, 0);
    }

#ifndef UNIX
    if (hMail)
    {
        // this is going to generate memory leak
        DbgMemoryTrackDisable(TRUE);

        pfnSendMail(0,
                    (ULONG)HandleToLong(GetActiveWindow()),
                    &mapimsg,
                    _cPostData ? MAPI_LOGON_UI : (MAPI_LOGON_UI | MAPI_DIALOG),
                    0);
        DbgMemoryTrackDisable(FALSE);
    }
    else
    {
        // need to execute Shell command
        // no form submission supported
        hr = RunMailClient();
    }
#else
    hr = LaunchUnixClient(aRecips, nRecips);
#endif // !UNIX

Cleanup:
    for (i=0; i<mailtoAttrNUM; i++)
    {
        _aCStrAttr[i].Free();
    }

    _cstrURL.Free();

#ifndef UNIX
    ReleaseMAPIMessage(&mapimsg);
    if (hMail)
    {
        FreeLibrary(hMail);
    }
#endif // !UNIX

    if (_postData)
    {
        MemFree(_postData);
        _postData=NULL;
        _cPostData = 0;
    }

    if (_pszMIMEType)
    {
        CoTaskMemFree(_pszMIMEType);
        _pszMIMEType = NULL;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CMailtoProtocol::RunMailClient
//
//  Synopsis:   Load mail client in case we can not support form submission
//
//  Returns:    HMODULE
//
//-------------------------------------------------------------------------

HRESULT CMailtoProtocol::RunMailClient()
{
    HRESULT     hr = E_FAIL;
    char        *lpszShellCmd=0;
    UINT        cAnsi = 0;
    HINSTANCE   hinst=0;
    TCHAR       aCaption[64];
    TCHAR       aText[128];

    hr = THR(MultiByteFromWideChar((WCHAR *)_cstrURL, _tcslen(_cstrURL),
                                    &lpszShellCmd, &cAnsi));
    if (FAILED(hr))
        goto Cleanup;
    hinst = ShellExecuteA(  GetActiveWindow(),
                            NULL,
                            lpszShellCmd,
                            NULL,
                            NULL,
                            SW_SHOWNORMAL);

    if ((DWORD_PTR) hinst <= 32)
    {
        hr = GetLastWin32Error();

        if (hr)
        {
            LoadString(GetResourceHInst(), IDS_MESSAGE_BOX_TITLE, aCaption, 64);
            LoadString(GetResourceHInst(), IDS_MAILTO_MAILCLIENTNOTFOUND,
                                            aText, 128);
            MessageBox(
                    GetActiveWindow(),
                    aText,
                    aCaption,  
                    MB_OK | MB_TASKMODAL
                    );
        }
    }
    else
    {
        hr = S_OK;
    }

Cleanup:

    if (lpszShellCmd)
        MemFree(lpszShellCmd);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CMailtoProtocol::LoadMailProvider
//
//  Synopsis:   Load mail provider MAPI DLL
//
//  Returns:    HMODULE
//
//-------------------------------------------------------------------------

HRESULT CMailtoProtocol::LoadMailProvider(HMODULE *pHMod)
{
    HRESULT hr = S_OK;
    TCHAR   szMAPIDLL[MAX_PATH];
    TCHAR   aBuffer[MAX_PATH];
    DWORD   cb = MAX_PATH;
    HKEY    hkey;
    LONG    lSuccess;
    BOOL    fReadFromHKCU = TRUE;

    *pHMod = NULL;

    lSuccess = RegQueryValue(HKEY_CURRENT_USER,
                            TEXT("Software\\Clients\\Mail"),
                            szMAPIDLL,
                            (LONG *)&cb);

    if (lSuccess != ERROR_SUCCESS || cb <= sizeof(TCHAR))
    {
        fReadFromHKCU = FALSE;
        cb = MAX_PATH;
        lSuccess = RegQueryValue(HKEY_LOCAL_MACHINE,
                            TEXT("Software\\Clients\\Mail"),
                            szMAPIDLL,
                            (LONG *)&cb);
    }

    if (lSuccess != ERROR_SUCCESS)
        goto Cleanup;

    _tcscpy(aBuffer, TEXT("Software\\Clients\\Mail\\"));
    _tcscat(aBuffer, szMAPIDLL);

    lSuccess = RegOpenKeyEx(fReadFromHKCU
                                    ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE,
                                aBuffer, NULL, KEY_QUERY_VALUE, &hkey);

    if (lSuccess != ERROR_SUCCESS)
        goto Cleanup;

    cb = MAX_PATH;
    lSuccess = RegQueryValueEx(hkey, TEXT("DLLPath"), 0, NULL, (LPBYTE)szMAPIDLL, &cb);

    RegCloseKey(hkey);
    if (lSuccess != ERROR_SUCCESS)
        goto Cleanup;

    cb = ExpandEnvironmentStrings(szMAPIDLL, aBuffer, MAX_PATH);
    if (!cb || (cb > MAX_PATH))
        goto Cleanup;

    *pHMod = LoadLibraryEx(aBuffer, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CMailtoProtocol::SetMAPIRecipients
//
//  Synopsis:   set recipients in MAPIMessage
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT CMailtoProtocol::SetMAPIRecipients(MapiMessage *pmm, LPTSTR lpszRecips, UINT uiNumRecips, int iClass)
{
    HRESULT         hr = S_OK;
    TCHAR           *pNextRecip=0;
    int             i=0, l= uiNumRecips + pmm->nRecipCount;
    UINT            cAnsi = MAX_PATH;

    Assert(l);

    Assert(     iClass==mailtoAttrTO
            ||  iClass==mailtoAttrBCC
            ||  iClass==mailtoAttrCC);

    pNextRecip = lpszRecips;

    for (i = pmm->nRecipCount; i < l; i++)
    {
        hr = THR(MultiByteFromWideChar((WCHAR *)pNextRecip,
                    _tcslen(pNextRecip), &pmm->lpRecips[i].lpszName, &cAnsi));
        if (FAILED(hr))
            goto Cleanup;

        // NOTE (yinxie)
        // Setting address seems to cause MAPI32 to put quote around the
        // well formed adress which causes mail provider to fail the delivery
        // BUG 43627 - need to understand better how to set this field.
        /* comment this out, outlook does not work with address set
        hr = THR(MultiByteFromWideChar((WCHAR *)pNextRecip,
                    _tcslen(pNextRecip), &pmm->lpRecips[i].lpszAddress,&cAnsi));
        if (FAILED(hr))
            goto Cleanup;
        */

        switch(iClass)
        {
        case    mailtoAttrTO:
            pmm->lpRecips[i].ulRecipClass = MAPI_TO;
            break;
        case    mailtoAttrCC:
            pmm->lpRecips[i].ulRecipClass = MAPI_CC;
            break;
        case    mailtoAttrBCC:
            pmm->lpRecips[i].ulRecipClass = MAPI_BCC;
            break;
        }

        pNextRecip = pNextRecip + _tcslen(pNextRecip) + 1;
    }

Cleanup:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CMailtoProtocol::SetMAPIAttachement
//
//  Synopsis:   set attachement in MAPIMessage
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT CMailtoProtocol::SetMAPIAttachement(MapiMessage *pmm)
{
    HRESULT     hr = E_FAIL;
    HANDLE      hFile=INVALID_HANDLE_VALUE;
    TCHAR       achTempPath[MAX_PATH];
    UINT        cb = 0;
    ULONG       lcb = 0;
    MapiFileDesc    *pMFD=0;

    if (!_cPostData)
    {
        hr = S_OK;
        goto Cleanup;
    }
    if (!GetTempPath( MAX_PATH, achTempPath ))
        goto Cleanup;
    if (!GetTempFileName( achTempPath, TEXT("ATT"), 0, _achTempFileName ))
        goto Cleanup;

#ifdef  NEVER
    // this is not very safe, let's hold on this.
    TCHAR       *pch=0;
    pch = _tcschr(_achTempFileName, _T('.'));
    _tcscpy(pch, TEXT(".ATT"));
#endif

    hFile = CreateFile(
                        _achTempFileName,
                        GENERIC_READ|GENERIC_WRITE,     // access rights
                        0,                              // share mode
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile==INVALID_HANDLE_VALUE)
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

    if (!WriteFile(hFile, _postData, _cPostData, &lcb, NULL))
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }
    Assert(_cPostData == lcb);

    pMFD = (MapiFileDesc *)MemAlloc(Mt(CMailtoProtocolFileDesc), sizeof(MapiFileDesc));
    if (!pMFD)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    memset(pMFD, 0 , sizeof(MapiRecipDesc));

    pmm->lpFiles = pMFD;
    pmm->nFileCount = 1;

    hr = THR(MultiByteFromWideChar((WCHAR *)_achTempFileName,
                                    _tcslen(_achTempFileName),
                                    &pMFD->lpszPathName,
                                    &cb));
    if (FAILED(hr))
        goto Cleanup;

    pMFD->lpszFileName = "POSTDATA.ATT";
    pMFD->nPosition = (UINT) -1;                // OS will figure out where to start

Cleanup:
    if (hFile!=INVALID_HANDLE_VALUE)
    {
        if (!CloseHandle(hFile))
        {
            hr = E_FAIL;
        }
    }
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CMailtoProtocol::ReleaseMAPIMessage
//
//  Synopsis:   release memory allocations in MAPIMessage
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

void CMailtoProtocol::ReleaseMAPIMessage(MapiMessage *pmm)
{
    if (!pmm)
        return;
    if (pmm->lpFiles)
    {
        if (pmm->lpFiles->lpszPathName)
        {
            DeleteFile(_achTempFileName);
            MemFree(pmm->lpFiles->lpszPathName);
        }
        MemFree(pmm->lpFiles);
    }
    if (pmm->lpRecips)
    {
        for (int i=0; i < (int)pmm->nRecipCount; i++)
        {
            if (pmm->lpRecips[i].lpszAddress)
            {
                MemFree(pmm->lpRecips[i].lpszAddress);
            }
            if (pmm->lpRecips[i].lpszName)
            {
                MemFree(pmm->lpRecips[i].lpszName);
            }
        }
        MemFree(pmm->lpRecips);
    }
    if (pmm->lpszSubject)
        MemFree(pmm->lpszSubject);
    if (pmm->lpszNoteText)
        MemFree(pmm->lpszNoteText);
}


//+------------------------------------------------------------------------
//
//  Function:   CMailtoProtocol::MultiByteFromWideChar
//
//  Synopsis:   unicode to multibyte conversion
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CMailtoProtocol::MultiByteFromWideChar(WCHAR *lpwcsz, UINT cwc, LPSTR *lppsz, UINT *pcb)
{
    HRESULT hr = S_OK;

    // allocate a buffer which is twice as big as the unicode one (should always enough)
    *pcb = (cwc << 1) + 2;
    *lppsz = (LPSTR)MemAlloc(Mt(CMailtoProtocolMbfwc), *pcb);
    if (!*lppsz)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    {
        DWORD dwState = 0;
        CODEPAGE cp = (_cp == CP_UTF_7) ? CP_UTF_8 : _cp;

        hr = THR(mlang().ConvertStringFromUnicode(&dwState, cp, lpwcsz, &cwc, *lppsz, pcb));
    }

    if (FAILED(hr))
    {
        *pcb = WideCharToMultiByte(CP_ACP, 0, lpwcsz, cwc, *lppsz, *pcb, NULL, NULL);
        if (!*pcb)
        {
            hr = E_FAIL;
        }
    }

Cleanup:

    if (FAILED(hr))
    {
        if (*lppsz)
        {
            MemFree(*lppsz);
            *lppsz = NULL;
        }
    }
    else
    {
        hr = S_OK;
        (*lppsz)[*pcb] = 0;
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\misc\weboc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 2000
//
//  File    : weboc.h
//
//  Contents: WebOC interface implementations and other WebOC helpers.
//
//  Author  : Scott Roberts (scotrobe)
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_WEBOC_HXX_
#define X_WEBOC_HXX_
#include "weboc.hxx"
#endif

#ifndef X_WEBOCUTIL_H_
#define X_WEBOCUTIL_H_
#include "webocutil.h"
#endif

#ifndef X_FRAMEWEBOC_HXX_
#define X_FRAMEWEBOC_HXX_
#include "frameweboc.hxx"
#endif

#ifndef X_EXDISPID_H_
#define X_EXDISPID_H_
#include "exdispid.h"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_ROOTELEMENT_HXX_
#define X_ROOTELEMENT_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_ROOTELEMENT_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

DeclareTag(tagWebOCNavEvents, "WebOC Navigation Events", "Trace WebOC Navigation Events")
DeclareTag(tagWebOCEvents, "WebOC Non-Navigation Events", "Trace WebOC Non-Navigation Events")
ExternTag(tagSecurityContext);
#define DELEGATE_WB_METHOD(base, docptr, fn, args, nargs) \
    HRESULT base::fn args \
    { \
        if (_pWindow->IsPassivated()) \
            return E_FAIL; \
        Assert(docptr); \
        IWebBrowser2 * pTopWebOC = docptr->_pTopWebOC;\
        if (pTopWebOC) \
            return pTopWebOC->fn nargs; \
        return E_FAIL; \
    }
    
//+-------------------------------------------------------------------------
//
//  Method   : NavigateComplete2
//
//  Synopsis : Fires the NavigateComplete2 event to all DWebBrowserEvents2
//             connection points and the FrameNavigateComplete event to all
//             the DWebBrowserEvents connection points of the WebOC.
//
//  Input    : pWindowProxy - the current window's proxy.
//
//--------------------------------------------------------------------------

void
CWebOCEvents::NavigateComplete2(COmWindowProxy * pWindowProxy) const
{ 
    Assert(pWindowProxy);
    Assert(pWindowProxy->Markup());

    DWORD    dwFlags = 0;
    CDoc   * pDoc    = pWindowProxy->Markup()->Doc();
    CVariant cvarWindow(VT_UNKNOWN);
    BOOL     fPrimaryMarkup = pWindowProxy->Markup()->IsPrimaryMarkup();

    if (   pDoc->_fDontFireWebOCEvents
        || pDoc->_fPopupDoc
        || pDoc->_fViewLinkedInWebOC
        || pDoc->_fInObjectTag
        || pDoc->_fInWebOCObjectTag
        || pWindowProxy->Window()->_fCreateDocumentFromUrl)
    {
        return;
    }

    TraceTag((tagWebOCNavEvents, "NavigateComplete2"));
    TraceTag((tagSecurityContext, "NavigateComplete2"));

    // Fire the event to the parent first and then the top-level object.
    //
    if (!fPrimaryMarkup)
    {
        FrameNavigateComplete2(pWindowProxy);
    }

    if (pDoc->_pTridentSvc)
    {
        if (pDoc->_fDontUpdateTravelLog)
            dwFlags |= NAVDATA_DONTUPDATETRAVELLOG;

        if (!fPrimaryMarkup)
            dwFlags |= NAVDATA_FRAMEWINDOW;

        if (pWindowProxy->Window()->_fNavFrameCreation)
           dwFlags |= NAVDATA_FRAMECREATION;

        if (pWindowProxy->Window()->_fRestartLoad)
           dwFlags |= NAVDATA_RESTARTLOAD;

        pDoc->_pTridentSvc->FireNavigateComplete2(pWindowProxy, dwFlags);
    }
}

//+-------------------------------------------------------------------------
//
//  Method   : FrameNavigateComplete2
//
//  Synopsis : Fires the NavigateComplete2 to all DWebBrowserEvents2 
//             connection points and the FrameNavigateComplete event
//             to all the DWebBrowserEvents connection points of WebOC 
//             sinks for a frame.
//
//  Input    : pWindowProxy - the current window's proxy.
//
//--------------------------------------------------------------------------

void
CWebOCEvents::FrameNavigateComplete2(COmWindowProxy * pWindowProxy) const
{
    Assert(pWindowProxy);

    HRESULT        hr;
    CVariant       cvarUrl;
    CMarkup      * pMarkup     = pWindowProxy->Markup();
    IWebBrowser2 * pWebBrowser = NULL;

    Assert(pMarkup);

    Assert(!pMarkup->IsPrimaryMarkup());
    Assert(!pMarkup->Doc()->_fDontFireWebOCEvents);
    Assert(!pMarkup->Doc()->_fPopupDoc);
    Assert(!pMarkup->Doc()->_fViewLinkedInWebOC);
    Assert(!pMarkup->Doc()->_fInWebOCObjectTag);
    
    if (   !pWindowProxy->Window()->_pFrameWebOC 
        || !pWindowProxy->Window()->_pFrameWebOC->ShouldFireFrameWebOCEvents())
    {
        return;
    }

    hr = pWindowProxy->QueryService(SID_SWebBrowserApp,
                                    IID_IWebBrowser2,
                                    (void**)&pWebBrowser);
    if (hr)
        goto Cleanup;

    FormatUrlForEvent(CMarkup::GetUrl(pMarkup),
                      CMarkup::GetUrlLocation(pMarkup),
                      &cvarUrl);

    // Fire the IE4+ event.
    //
    InvokeEventV(NULL,
                 pWindowProxy->Window()->_pFrameWebOC,
                 DISPID_NAVIGATECOMPLETE2, 2,
                 VT_DISPATCH, pWebBrowser,
                 VT_VARIANT|VT_BYREF, &cvarUrl);

    // Fire the IE3 event.
    //
    InvokeEventV(NULL,
                 pWindowProxy->Window()->_pFrameWebOC,
                 DISPID_FRAMENAVIGATECOMPLETE, 1,
                 VT_VARIANT|VT_BYREF, &cvarUrl);

Cleanup:
    ReleaseInterface(pWebBrowser);
}


//+-------------------------------------------------------------------------
//
//  Method   : DocumentComplete
//
//  Synopsis : Fires the DocumentComplete event to all DWebBrowserEvents2
//             connection points of the WebOC.
//
//  Input    : pWindowProxy - the current window's proxy.
//             lpszUrl      - the URL to which we just navigated.
//             lpszLocation - the bookmark location name.
//
//--------------------------------------------------------------------------

void
CWebOCEvents::DocumentComplete(COmWindowProxy * pWindowProxy,
                               LPCTSTR lpszUrl,
                               LPCTSTR lpszLocation /* = NULL */) const
{
    Assert(pWindowProxy);
    Assert(pWindowProxy->Markup());
    Assert(lpszUrl);

    HRESULT        hr = S_OK;
    CVariant       cvarUrl;
    IWebBrowser2 * pWebBrowser    = NULL;
    CDoc         * pDoc           = pWindowProxy->Markup()->Doc();
    BOOL           fPrimaryMarkup = pWindowProxy->Markup()->IsPrimaryMarkup();

    // Quick return
    if (   pDoc->_fDontFireWebOCEvents
        || pDoc->_fPopupDoc
        || pDoc->_fViewLinkedInWebOC
        || pDoc->_fInWebOCObjectTag
        || pWindowProxy->Window()->_fCreateDocumentFromUrl)
    {
        return;
    }
        
    TraceTag((tagWebOCNavEvents, "DocumentComplete: Url - %ls Location - %ls",
              lpszUrl, lpszLocation));

    // If this is the top-level window, we must pass the IDispatch of
    // the top-level WebOC with the DocumentComplete event.
    //
    if (!fPrimaryMarkup)
    {
        FormatUrlForEvent(lpszUrl, lpszLocation, &cvarUrl);

        // If this is a frame, we must use the IWebBrowser2 of the
        // CFrameWebOC of the window when firing the event, whether
        // the event is fired to the frame sinks or to the top-level 
        // sinks below.
        //
        hr = pWindowProxy->QueryService(SID_SWebBrowserApp,
                                        IID_IWebBrowser2,
                                        (void**)&pWebBrowser);
        if (hr)
            goto Cleanup;

        if (   pWindowProxy->Window()->_pFrameWebOC
            && pWindowProxy->Window()->_pFrameWebOC->ShouldFireFrameWebOCEvents())
        {
            // Fire the event to any direct frame sinks
            //
            InvokeEventV(NULL,
                         pWindowProxy->Window()->_pFrameWebOC,
                         DISPID_DOCUMENTCOMPLETE, 2,
                         VT_DISPATCH, pWebBrowser,
                         VT_VARIANT|VT_BYREF, &cvarUrl);
        }
    }

    if (pDoc->_pTridentSvc)
    {
        pDoc->_pTridentSvc->FireDocumentComplete(pWindowProxy,
                                                 fPrimaryMarkup ? 0 : NAVDATA_FRAMEWINDOW);
    }

Cleanup:
    ReleaseInterface(pWebBrowser);
}

//+-------------------------------------------------------------------------
//
//  Method   : BeforeNavigate2
//
//  Synopsis : Fires the BeforeNavigate2 event to all DWebBrowserEvents2
//             connection points and the FrameBeforeNavigate event to all
//             the DWebBrowserEvents connection points of the WebOC. This
//             method assumes that it is being called in a frame.
//
//  Input    : pWindowProxy  - the current window's proxy.
//             lpszUrl       - the URL to which we are navigating.
//             lpszLocation  - the bookmark location name.
//             lpszFrameName - the target frame name.
//             pPostData     - post data to send with the event.
//             cbPostData    - post data size
//             lpszHeaders   - headers to send with the event.
//  Output   : pfCancel      - TRUE if the operation should be canceled.
//
//--------------------------------------------------------------------------

void
CWebOCEvents::BeforeNavigate2(COmWindowProxy * pWindowProxy,
                              BOOL    * pfCancel,
                              LPCTSTR   lpszUrl,
                              LPCTSTR   lpszLocation,  /* = NULL  */
                              LPCTSTR   lpszFrameName, /* = NULL  */ 
                              BYTE    * pPostData,     /* = NULL  */
                              DWORD     cbPostData,    /* = 0     */
                              LPCTSTR   lpszHeaders,   /* = NULL  */
                              BOOL      fPlayNavSound  /* = FALSE */) const
{
    Assert(pWindowProxy);
    Assert(pWindowProxy->Markup());
    Assert(pfCancel);
    Assert(lpszUrl);
    Assert(*lpszUrl);

    HRESULT        hr;
    CDoc         * pDoc        = pWindowProxy->Markup()->Doc();
    IWebBrowser2 * pWebBrowser = NULL;
    DWORD          cchOut      = INTERNET_MAX_URL_LENGTH;
    TCHAR          szEvtUrl[INTERNET_MAX_URL_LENGTH];
    DWORD          cchUrl = _tcslen(lpszUrl);

    TraceTag((tagWebOCNavEvents, "BeforeNavigate2: Url - %ls Location - %ls",
              lpszUrl, lpszLocation));

    // Quick return
    if (   pDoc->_fDontFireWebOCEvents
        || pDoc->_fPopupDoc
        || pDoc->_fViewLinkedInWebOC
        || pDoc->_fInWebOCObjectTag
        || pWindowProxy->Window()->_fCreateDocumentFromUrl)
    {
        return;
    }

    *pfCancel = FALSE;

    _tcsncpy(szEvtUrl, lpszUrl, ARRAY_SIZE(szEvtUrl) - 1);

    if (lpszLocation && *lpszLocation
        && (cchUrl + _tcslen(lpszLocation) + 2) < ARRAY_SIZE(szEvtUrl))
    {
        if (*lpszLocation != _T('#'))
        {
            szEvtUrl[cchUrl]   = _T('#');
            szEvtUrl[++cchUrl] = 0;
        }

        _tcscat(szEvtUrl, lpszLocation);
    }

    // For compat (see #102943 -- breaks Encarta), we need to canonicalize the url.
    // This will convert some protocols to lower-case). 
    if (FAILED(UrlCanonicalize(szEvtUrl, szEvtUrl, &cchOut, URL_ESCAPE_SPACES_ONLY)))
        goto Cleanup;

    // Fire the event to the parent first and then the top-level object.
    //
    if (!pWindowProxy->Markup()->IsPrimaryMarkup())
    {
        // If this is a frame, we must use the IWebBrowser2 of the
        // CFrameWebOC of the window when firing the event, whether
        // the event is fired to the frame sinks or to the top-level 
        // sinks below.
        //
        hr = pWindowProxy->QueryService(SID_SWebBrowserApp,
                                        IID_IWebBrowser2,
                                        (void**)&pWebBrowser);
        if (hr)
            goto Cleanup;

        if (    pWindowProxy->Window()->_pFrameWebOC
            &&  pWindowProxy->Window()->_pFrameWebOC->ShouldFireFrameWebOCEvents())
        {
            FrameBeforeNavigate2(pWindowProxy, pWebBrowser, szEvtUrl, 0,
                                 lpszFrameName, pPostData, cbPostData, lpszHeaders, pfCancel);

            if (*pfCancel)
                goto Cleanup;
        }
    }

    if (pDoc->_pTridentSvc)
    {
        // Fire the event to the top-level object.
        //
        pDoc->_pTridentSvc->FireBeforeNavigate2(pWebBrowser, szEvtUrl, 0, lpszFrameName,
                                                pPostData, cbPostData, lpszHeaders, fPlayNavSound, pfCancel);
    }

Cleanup:
    ReleaseInterface(pWebBrowser);
}

//+-------------------------------------------------------------------------
//
//  Method   : FrameBeforeNavigate2
//
//  Synopsis : Fires the BeforeNavigate2 event to all DWebBrowserEvents2
//             connection points and the FrameBeforeNavigate event to all
//             the DWebBrowserEvents connection points of the frame. This
//             method assumes that it is being called in a frame.
//
//  Input    : pWindowProxy  - the current window's proxy.
//             pDispWindow   - the IDispatch of the current window.
//             cvarUrl       - the URL to which we are navigating.
//             cvarLocation  - the bookmark location name.
//             cvarFrameName - the target frame name.
//             cvarPostData  - post data to send with the event.
//             cvarHeaders   - headers to send with the event.
//  Output   : pfCancel      - TRUE if the operation should be canceled.
//
//--------------------------------------------------------------------------

void
CWebOCEvents::FrameBeforeNavigate2(COmWindowProxy * pWindowProxy,
                                   IWebBrowser2   * pWebBrowser,
                                   LPCTSTR          lpszUrl,
                                   DWORD            dwFlags,
                                   LPCTSTR          lpszFrameName,
                                   BYTE           * pPostData,
                                   DWORD            cbPostData,
                                   LPCTSTR          lpszHeaders,
                                   BOOL           * pfCancel) const
{
    Assert(pWindowProxy);

    CWindow  *  pWindow = pWindowProxy->Window();
    CVariant    cvarUrl(VT_BSTR);
    CVariant    cvarFrameName(VT_BSTR);
    CVariant    cvarFlags(VT_I4);
    CVariant    cvarHeaders(VT_BSTR);
    CVariant    cvarPostData(VT_VARIANT | VT_BYREF);
    VARIANT     varPostDataArray;
    SAFEARRAY * psaPostData = NULL;

    Assert(pWindowProxy->Markup());
    Assert(!pWindowProxy->Markup()->IsPrimaryMarkup());
    Assert(pWebBrowser);
    Assert(pfCancel);

    Assert(!pWindowProxy->Markup()->Doc()->_fDontFireWebOCEvents);
    Assert(!pWindowProxy->Markup()->Doc()->_fPopupDoc);
    Assert(!pWindowProxy->Markup()->Doc()->_fViewLinkedInWebOC);
    Assert(!pWindowProxy->Markup()->Doc()->_fInWebOCObjectTag);

    if (   !pWindow->_pFrameWebOC
        || !pWindow->_pFrameWebOC->ShouldFireFrameWebOCEvents())
    {
        return;
    }

    *pfCancel = FALSE;

    V_BSTR(&cvarUrl) = SysAllocString(lpszUrl);
    V_BSTR(&cvarFrameName) = SysAllocString(lpszFrameName);

    V_I4(&cvarFlags) = dwFlags;

    if (lpszHeaders && *lpszHeaders)
    {
        V_BSTR(&cvarHeaders) = SysAllocString(lpszHeaders);    
    }

    V_VT(&varPostDataArray)    = VT_ARRAY | VT_UI1;
    psaPostData = SafeArrayCreateVector(VT_UI1, 0, cbPostData);
    V_ARRAY(&varPostDataArray) = psaPostData;

    if (!psaPostData)
        goto Cleanup;

    memcpy(psaPostData->pvData, pPostData, cbPostData);

    V_VARIANTREF(&cvarPostData) = &varPostDataArray;

    InvokeEventV(NULL,
                 pWindow->_pFrameWebOC,
                 DISPID_BEFORENAVIGATE2, 7,
                 VT_DISPATCH, pWebBrowser,
                 VT_VARIANT | VT_BYREF, &cvarUrl,
                 VT_VARIANT | VT_BYREF, &cvarFlags,
                 VT_VARIANT | VT_BYREF, &cvarFrameName,
                 VT_VARIANT | VT_BYREF, &cvarPostData,
                 VT_VARIANT | VT_BYREF, &cvarHeaders,
                 VT_BOOL    | VT_BYREF, pfCancel);

    if (*pfCancel)
        goto Cleanup;

    // Fire the IE3 FrameBeforeNavigate event.
    //
    InvokeEventV(NULL,
                 pWindow->_pFrameWebOC,
                 DISPID_FRAMEBEFORENAVIGATE, 6,
                 VT_BSTR, V_BSTR(&cvarUrl),
                 VT_I4,   V_I4(&cvarFlags),
                 VT_BSTR, V_BSTR(&cvarFrameName),
                 VT_VARIANT | VT_BYREF, &varPostDataArray, // cvarPostDataArray instead of cvarPostData for compatibility
                 VT_BSTR, V_BSTR(&cvarHeaders),
                 VT_BOOL | VT_BYREF, pfCancel);

Cleanup:
    if (V_ARRAY(&varPostDataArray))
    {
        SafeArrayDestroy(V_ARRAY(&varPostDataArray));  // CVariant won't destroy the safearray.

        // Don't VariantClear varPostDataArray
    }
}

//+---------------------------------------------------------------------------
//
//  Method   : FireDownloadEvents
//
//  Synopsis : Fires the DownloadBegin and DownloadComplete events. 
//
//  Input    : pWindowProxy  - the current window's proxy.
//
//----------------------------------------------------------------------------

void
CWebOCEvents::FireDownloadEvents(COmWindowProxy    * pWindowProxy,
                                 DOWNLOADEVENTTYPE   eDLEventType) const
{
    Assert(pWindowProxy);
    CMarkup * pMarkup = pWindowProxy->Markup();

    Assert(pMarkup);

    // Quick return
    if (   pMarkup->Doc()->_fDontFireWebOCEvents
        || pMarkup->Doc()->_fPopupDoc
        || pMarkup->Doc()->_fViewLinkedInWebOC
        || pMarkup->Doc()->_fInWebOCObjectTag
        || pWindowProxy->Window()->_fCreateDocumentFromUrl)
    {
        return;
    }

    // Fire the event to the parent first and then the top-level object.
    //
    FireFrameDownloadEvent(pWindowProxy, eFireDownloadBegin);
    FireFrameDownloadEvent(pWindowProxy, eFireDownloadComplete);

    if (pMarkup->Doc()->_pTopWebOC && pMarkup->Doc()->_pTridentSvc)
    {
        switch(eDLEventType)
        {
        case eFireBothDLEvents:
        case eFireDownloadBegin:
            pMarkup->Doc()->_pTridentSvc->FireDownloadBegin();

            TraceTag((tagWebOCNavEvents, "DownloadBegin"));

            if (eDLEventType != eFireBothDLEvents)
            {
                break;
            }
            // else intentional fall-through

        case eFireDownloadComplete:
            pMarkup->Doc()->_pTridentSvc->FireDownloadComplete();

            TraceTag((tagWebOCNavEvents, "DownloadComplete"));
            break;

        default:
            Assert(0);
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Method   : FireFrameDownloadEvents
//
//  Synopsis : Fires the DownloadBegin if fBegin is TRUE or the 
//             DownloadComplete event if fBegin is FALSE. 
//
//  Input    : pWindowProxy  - the current window's proxy.
//             fBegin        - TRUE for DownloadBegin and FALSE for
//                             DownloadComplete
//
//----------------------------------------------------------------------------

void
CWebOCEvents::FireFrameDownloadEvent(COmWindowProxy    * pWindowProxy,
                                     DOWNLOADEVENTTYPE   eDLEventType) const
{
    Assert(pWindowProxy);
    CMarkup * pMarkup = pWindowProxy->Markup();

    Assert(pMarkup);

    // Quick return
    if (    !pWindowProxy->Window()->_pFrameWebOC    
        ||  !pWindowProxy->Window()->_pFrameWebOC->ShouldFireFrameWebOCEvents()
        ||  pMarkup->IsPrimaryMarkup())
    {
        return;
    }

    switch(eDLEventType)
    {
    case eFireBothDLEvents:
    case eFireDownloadBegin:
        InvokeEventV(NULL, pWindowProxy->Window()->_pFrameWebOC, DISPID_DOWNLOADBEGIN, 0);
        TraceTag((tagWebOCNavEvents, "DownloadBegin for Frame Sink"));

        if (eDLEventType != eFireBothDLEvents)
        {
            break;
        }
        // else intentional fall-through

    case eFireDownloadComplete:
        InvokeEventV(NULL, pWindowProxy->Window()->_pFrameWebOC, DISPID_DOWNLOADCOMPLETE, 0);
        TraceTag((tagWebOCNavEvents, "DownloadComplete for Frame Sink"));
        break;

    default:
        Assert(0);
        break;
    }
}

//+-------------------------------------------------------------------------
//
//  Method   : NavigateError
//
//  Synopsis : Fires the NavigateError event to all DWebBrowserEvents2
//             connection points of the WebOC.
//
//  Input    : pMarkup  - the current markup.
//             hrReason - the binding or WinInet error.
//
//--------------------------------------------------------------------------

void
CWebOCEvents::NavigateError(CMarkup * pMarkup, HRESULT hrReason) const
{
    Assert(!IsBadReadPtr(pMarkup, sizeof(CMarkup)));
    Assert(hrReason != S_OK);

    if (pMarkup && pMarkup->Doc()->_pTridentSvc)
    {
        ITridentService2 * pTridentSvc2;

        HRESULT hr = pMarkup->Doc()->_pTridentSvc->QueryInterface(IID_ITridentService2,
                                                                  (void**)&pTridentSvc2);
        if (S_OK == hr)
        {
            BOOL             fCancel        = FALSE;
            BSTR             bstrFrameName  = NULL;
            BSTR             bstrUrl        = SysAllocString(CMarkup::GetUrl(pMarkup));

            IHTMLWindow2   * pHTMLWindow    = NULL;
            COmWindowProxy * pWindowPending = pMarkup->GetWindowPending();

            Assert(bstrUrl && *bstrUrl);

            if (pWindowPending)
            {
                Assert(!IsBadReadPtr(pWindowPending->Window(), sizeof(CWindow)));
                Assert(!IsBadReadPtr(pWindowPending->Markup(), sizeof(CMarkup)));

                pWindowPending->Window()->get_name(&bstrFrameName);

                // If this is a frame, we pass the IHTMLWindow2
                // ptr of the frame to the FireNavigateError method.
                // Otherwise, we pass NULL in which case the IDispatch
                // passed to the event handler will be the IDispatch
                // of the top-level browser object.
                // 
                if (  pWindowPending->Markup()
                   && !pWindowPending->Markup()->IsPrimaryMarkup())
                {
                    pHTMLWindow = pWindowPending->_pWindow;
                    Assert(!IsBadReadPtr(pHTMLWindow, sizeof(IHTMLWindow2)));

                    pHTMLWindow->AddRef();
                }
            }
            else
            {
                Assert(pMarkup->Window());
                bstrFrameName=SysAllocString(pMarkup->Window()->Window()->_cstrName);
            }

            pTridentSvc2->FireNavigateError(pHTMLWindow, bstrUrl, bstrFrameName,
                                            hrReason, &fCancel);
            pTridentSvc2->Release();

            SysFreeString(bstrUrl);
            SysFreeString(bstrFrameName);
            ReleaseInterface(pHTMLWindow);
        }
    }
}

//+-----------------------------------------------------------------------------
//
//  Method   : WindowClosing
//
//  Synopsis : Fires the WindowClosing event. 
//
//  Input    : pTopWebOC - the top-level WebBrowser control.
//             fIsChild  - TRUE if the window is a child window.
//  Output   : pfCancel  - TRUE is the closing of the window should be canceled.
//
//------------------------------------------------------------------------------

void
CWebOCEvents::WindowClosing(IWebBrowser2 * pTopWebOC,
                            BOOL           fIsChild,
                            BOOL         * pfCancel) const
{
    Assert(pfCancel);

    *pfCancel = FALSE;

    if (pTopWebOC)
    {
        IConnectionPoint * pConnPtTopWB2 = NULL;

        HRESULT hr = GetWBConnectionPoints(pTopWebOC, NULL, &pConnPtTopWB2);

        if (S_OK == hr)
        {
            InvokeEventV(pConnPtTopWB2, NULL, DISPID_WINDOWCLOSING, 2,
                         VT_BOOL, fIsChild,
                         VT_BOOL | VT_BYREF, pfCancel);

            pConnPtTopWB2->Release();
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Method   : FrameProgressChange
//
//  Synopsis : Fires the ProgressChange event to all direct frame sinks 
//             of DWebBrowserEvents2
//
//  Input    : pWindowProxy  - the current window's proxy.
//             dwProgressVal - the current progress value. These values
//                             are based on the current state in 
//                             CDwnBindData::OnProgress.
//             dwMaxVal      - the maximum that dwProgressVal can be.
//
//--------------------------------------------------------------------------

void
CWebOCEvents::FrameProgressChange(COmWindowProxy * pWindowProxy,
                                  DWORD            dwProgressVal,
                                  DWORD            dwMaxVal) const
{
    Assert(pWindowProxy);

    CMarkup * pMarkup = pWindowProxy->Markup();

    Assert(pMarkup);
    Assert(!pMarkup->IsPrimaryMarkup());

    if (   pMarkup->Doc()->_fDontFireWebOCEvents
        || pMarkup->Doc()->_fPopupDoc
        || pMarkup->Doc()->_fViewLinkedInWebOC
        || pMarkup->Doc()->_fInWebOCObjectTag
        || pWindowProxy->Window()->_fCreateDocumentFromUrl)
    {
        return;
    }

    DWORD dwProgress = (_dwProgressMax/dwMaxVal) * dwProgressVal;

    if (   pWindowProxy->Window()->_pFrameWebOC
        && pWindowProxy->Window()->_pFrameWebOC->ShouldFireFrameWebOCEvents())
    {
        TraceTag((tagWebOCEvents, "FrameProgressChange: dwProgress - %ld dwProgressMax - %ld",
                  dwProgress, _dwProgressMax));

        InvokeEventV(NULL,
                     pWindowProxy->Window()->_pFrameWebOC,
                     DISPID_PROGRESSCHANGE,
                     2,
                     VT_I4, dwProgress,
                     VT_I4, _dwProgressMax);
    }
}

//+-------------------------------------------------------------------------
//
//  Method   : FrameTitleChange
//
//  Synopsis : Fires the TitleChange event to all direct 
//             DWebBrowserEvents2 frame sinks.
//
//  Input    : pWindowProxy - the current window's proxy.
//
//--------------------------------------------------------------------------

void
CWebOCEvents::FrameTitleChange(COmWindowProxy * pWindowProxy) const
{
    if (pWindowProxy)
    {
        CMarkup * pMarkup = pWindowProxy->Markup();

        Assert(pMarkup);

        if (    pMarkup->Doc()->_fDontFireWebOCEvents
            ||  pMarkup->IsPrimaryMarkup()
            ||  !pWindowProxy->Window()->_pFrameWebOC
            ||  !pWindowProxy->Window()->_pFrameWebOC->ShouldFireFrameWebOCEvents()
            ||  pMarkup->Doc()->_fPopupDoc
            ||  pMarkup->Doc()->_fViewLinkedInWebOC
            ||  pMarkup->Doc()->_fInWebOCObjectTag
            ||  pWindowProxy->Window()->_fCreateDocumentFromUrl)
        {
            return;
        }

        // Get the title
        //
        CTitleElement * pTitleElement = pMarkup->GetTitleElement();

        if (pTitleElement && pTitleElement->Length())
        {
            BSTR    bstrTitle = NULL;
            LPCTSTR lpszTitle = pTitleElement->GetTitle();

            if (NULL == lpszTitle)
            {
                bstrTitle = SysAllocString(_T(""));
            }
            else
            {
                bstrTitle = SysAllocString(lpszTitle);
            }

            InvokeEventV(NULL, pWindowProxy->Window()->_pFrameWebOC, DISPID_TITLECHANGE, 1,
                         VT_BSTR, bstrTitle);

            SysFreeString(bstrTitle);
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Method   : FrameStatusTextChange
//
//  Synopsis : Fires the StatusTextChange event to all direct
//             DWebBrowserEvents2 frame sinks.
//
//  Input    : pWindowProxy - the current window's proxy.
//
//--------------------------------------------------------------------------

void
CWebOCEvents::FrameStatusTextChange(COmWindowProxy * pWindowProxy,
                                    LPCTSTR          lpszStatusText) const
{
    if (pWindowProxy)
    {
        CMarkup * pMarkup = pWindowProxy->Markup();
        BSTR      bstrStatusText = NULL;

        if (    pMarkup->Doc()->_fDontFireWebOCEvents
            ||  pMarkup->IsPrimaryMarkup()
            ||  !pWindowProxy->Window()->_pFrameWebOC
            ||  !pWindowProxy->Window()->_pFrameWebOC->ShouldFireFrameWebOCEvents()
            ||  pMarkup->Doc()->_fPopupDoc
            ||  pMarkup->Doc()->_fViewLinkedInWebOC
            ||  pMarkup->Doc()->_fInWebOCObjectTag
            ||  pWindowProxy->Window()->_fCreateDocumentFromUrl)
        {
            return;
        }

        Assert(pMarkup);

        if (NULL == lpszStatusText)
        {
            bstrStatusText = SysAllocString(_T(""));
        }
        else
        {
            bstrStatusText = SysAllocString(lpszStatusText);
        }

        InvokeEventV(NULL, pWindowProxy->Window()->_pFrameWebOC, DISPID_STATUSTEXTCHANGE, 1,
                     VT_BSTR, bstrStatusText);

        SysFreeString(bstrStatusText);
    }
}

//+-------------------------------------------------------------------------
//
//  Method    : GetWBConnectionPoints
//
//  Synopsis  : Retrieves the DWebBrowserEvents and/or the
//              DWebBrowserEvents2 connections points of the given
//              WebBrowser interface. 
//
//  Input     : pTopWebOC    - the top-level WebBrowser object.
//  Output    : ppConnPtWBE  - the DWebBrowserEvents connection point.
//              ppConnPtWBE2 - the DWebBrowserEvents2 connection point.
//
//  Returns   : S_OK if successful; OLE error code otherwise..
//
//--------------------------------------------------------------------------

HRESULT
CWebOCEvents::GetWBConnectionPoints(IWebBrowser2      * pWebBrowser,
                                    IConnectionPoint ** ppConnPtWBE,
                                    IConnectionPoint ** ppConnPtWBE2) const
{
    HRESULT hr;
    IConnectionPointContainer * pConnPtCont = NULL;

    Assert(pWebBrowser);
    Assert(ppConnPtWBE || ppConnPtWBE2);  // Must pass one.

    // Get the connection points for
    // DWebBrowserEvents and DWebBrowserEvents2
    //
    hr = pWebBrowser->QueryInterface(IID_IConnectionPointContainer, (void**)&pConnPtCont);
    if (hr)
        goto Cleanup;

    if (ppConnPtWBE)
    {
        hr = pConnPtCont->FindConnectionPoint(DIID_DWebBrowserEvents, ppConnPtWBE);
        if (hr)
            goto Cleanup;
    }

    if (ppConnPtWBE2)
    {
        hr = pConnPtCont->FindConnectionPoint(DIID_DWebBrowserEvents2, ppConnPtWBE2);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pConnPtCont);
    
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method   : FormatUrlForEvent
//
//  Synopsis : Formats an URL for use in a WebOC event.
//
//  Input    : lpszUrl      - the URL to format.
//             lpszLocation - the bookmark location name.
//  Output   : pcvarUrl     - the formatted URL.
//
//--------------------------------------------------------------------------

void
CWebOCEvents::FormatUrlForEvent(LPCTSTR    lpszUrl,
                                LPCTSTR    lpszLocation,
                                CVariant * pcvarUrl)
{
    HRESULT hr;
    TCHAR   szOut[INTERNET_MAX_URL_LENGTH];
    
    Assert(lpszUrl);
    Assert(pcvarUrl);

    hr = FormatUrl(lpszUrl, lpszLocation, szOut, ARRAY_SIZE(szOut));

    if (S_OK == hr)
        lpszUrl = szOut;

    V_VT(pcvarUrl)   = VT_BSTR;
    V_BSTR(pcvarUrl) = SysAllocString(lpszUrl);
}

// IWebBrowser2, IWebBrowserApp, and IWebBrowser
// method implementations.
//

STDMETHODIMP
CFrameWebOC::GoBack()
{
    IOmHistory * pHistory = NULL;
    HRESULT hr = E_FAIL;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    if (!_pWindow)
    {
        goto Cleanup;
    }

    hr = _pWindow->get_history(&pHistory);

    if (hr)
    {
        goto Cleanup;
    }

    pHistory->back(NULL);

Cleanup:

    ReleaseInterface(pHistory);
    RRETURN(SetErrorInfo(hr));
}

STDMETHODIMP
CFrameWebOC::GoForward()
{
    IOmHistory * pHistory = NULL;
    HRESULT hr = E_FAIL;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    if (!_pWindow)
    {
        goto Cleanup;
    }

    hr = _pWindow->get_history(&pHistory);

    if (hr)
    {
        goto Cleanup;
    }

    pHistory->forward(NULL);

Cleanup:

    ReleaseInterface(pHistory);
    RRETURN(SetErrorInfo(hr));
}

STDMETHODIMP
CFrameWebOC::GoHome()
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    return GoStdLocation(eHomePage, _pWindow);
}

STDMETHODIMP
CFrameWebOC::GoSearch()
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    return GoStdLocation(eSearchPage, _pWindow);
}

STDMETHODIMP
CFrameWebOC::Navigate(BSTR bstrUrl,
                      VARIANT * pvarFlags,
                      VARIANT * pvarFrameName,
                      VARIANT * pvarPostData,
                      VARIANT * pvarHeaders)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    if (_pWindow)
    {
        DWORD dwFlags = DOCNAVFLAG_DOCNAVIGATE ; 
        
        //
        // marka - I've added some of the flags that we have equivalents for
        // we don't have equivalents for write/read to cache
        // 
        if ( pvarFlags )
        {
            DWORD dwInFlags = 0 ;
            
            if (pvarFlags->vt == VT_I4)
            {
                dwInFlags = pvarFlags->lVal;
            }
            else if (pvarFlags->vt == VT_I2)
            {
                dwInFlags = pvarFlags->iVal;
            }

            if (dwInFlags & navOpenInNewWindow)
            {
                dwFlags |= DOCNAVFLAG_OPENINNEWWINDOW ;
            }        
            
            if (dwInFlags & navNoHistory)
            {
                dwFlags |= DOCNAVFLAG_DONTUPDATETLOG;
            }
        }
        
        BSTR    bstrFramename = NULL;
        if(pvarFrameName)
        {
            bstrFramename = ((V_VT(pvarFrameName) == VT_BSTR) ? V_BSTR(pvarFrameName) : NULL);
        }
        
        RRETURN(_pWindow->SuperNavigate(bstrUrl,
                                        NULL,
                                        NULL,
                                        bstrFramename,
                                        pvarPostData,
                                        pvarHeaders,
                                        dwFlags));
    }

    RRETURN(E_FAIL);
}
                  
STDMETHODIMP
CFrameWebOC::Refresh()
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    CVariant cvarLevel(VT_I4);

    V_I4(&cvarLevel) = OLECMDIDF_REFRESH_NO_CACHE;
    
    RRETURN(Refresh2(&cvarLevel));
}

STDMETHODIMP
CFrameWebOC::Refresh2(VARIANT * pvarLevel)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    long lLevel = OLECMDIDF_REFRESH_NO_CACHE;
    
    if (pvarLevel)
    {
        VARTYPE vt = V_VT(pvarLevel);
        if (VT_I4 == vt)
            lLevel = V_I4(pvarLevel);
        else if (VT_I2 == vt)
            lLevel = (long)V_I2(pvarLevel);
    }
    
    RRETURN(GWPostMethodCall(_pWindow->_pMarkup->Window(),
            ONCALL_METHOD(COmWindowProxy, ExecRefreshCallback, execrefreshcallback),
                          lLevel, FALSE,
                          "COmWindowProxy::ExecRefreshCallback"));
}

STDMETHODIMP
CFrameWebOC::Stop()
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    Assert(_pWindow->_pMarkup);
    return _pWindow->_pMarkup->ExecStop(FALSE, FALSE);
}

STDMETHODIMP
CFrameWebOC::get_Document(IDispatch ** ppDisp)
{
    HRESULT hr;
    IHTMLDocument2 * pHTMLDocument = NULL;

    Assert(ppDisp);

    *ppDisp = NULL;

    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (IsPassivated() || IsPassivating())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = _pWindow->get_document(&pHTMLDocument);
    if (hr)
        goto Cleanup;

    hr = pHTMLDocument->QueryInterface(IID_IDispatch, (void **) ppDisp);

Cleanup:
    ReleaseInterface(pHTMLDocument);
    return hr;
}

CFrameSite *
CWindow::GetFrameSite()
{
    if (Doc()->_fViewLinkedInWebOC && IsPrimaryWindow())
    {
        COmWindowProxy * pOmWindowProxy = Doc()->GetOuterWindow();

        if (pOmWindowProxy)
            return pOmWindowProxy->Window()->GetFrameSite();
    }

    {
        CRootElement * pRoot = _pMarkup->Root();
        CElement * pMasterElement;

        if (pRoot == NULL)
            return NULL;

        if (!pRoot->HasMasterPtr())
            return NULL;

        pMasterElement = pRoot->GetMasterPtr();
        if (    pMasterElement->Tag() != ETAG_IFRAME
            &&  pMasterElement->Tag() != ETAG_FRAME)
            return NULL;

        return DYNCAST(CFrameSite, pMasterElement);
    }
}

COmWindowProxy *
CWindow::GetInnerWindow()
{
    IDispatch * pDispatch = NULL;
    CMarkup * pMarkup = NULL;
    HRESULT hr;

    Assert(_punkViewLinkedWebOC);

    hr = GetWebOCDocument(_punkViewLinkedWebOC, &pDispatch);
    if (hr)
        goto Cleanup;

    hr = pDispatch->QueryInterface(CLSID_CMarkup, (void **) &pMarkup);
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pDispatch);

    if (pMarkup)
        return pMarkup->Window();
    else
        return NULL;
}

HRESULT
SetPositionAbsolute(CElement * pElement, CStyle ** ppStyle)
{
    HRESULT hr;
    CAttrArray **ppAA;
    BSTR bstrAbsolute = SysAllocString(_T("absolute"));

    if (!pElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!bstrAbsolute)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pElement->GetStyleObject(ppStyle);
    if (hr)
       goto Cleanup;

    ppAA = (*ppStyle)->GetAttrArray();
    if (!ppAA)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = (*ppStyle)->put_StringHelper(bstrAbsolute, &s_propdescCStyleposition.a, ppAA);

Cleanup:
    SysFreeString(bstrAbsolute);
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//  Method   : get_Left
//
//  Synopsis : Get the left of the current weboc
//
//  Output   : The left of the current weboc.
//--------------------------------------------------------------------------

HRESULT
CWindow::get_Left(long * plLeft)
{
    CElement * pElement = GetFrameSite();
    CLayout * pLayout;

    if (!pElement)
        return E_FAIL;

    pLayout = pElement->GetUpdatedLayout();
    if (!pLayout)
        return E_FAIL;

    *plLeft = g_uiDisplay.DocPixelsFromDeviceX(pLayout->GetPositionLeft());

    return S_OK;
}

STDMETHODIMP
CFrameWebOC::get_Left(long * plLeft)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_FAIL;
    return _pWindow->get_Left(plLeft);
}

//+-------------------------------------------------------------------------
//  Method   : put_Left
//
//  Synopsis : Put the left of the current weboc
//
//  Output   : The left of the current weboc.
//--------------------------------------------------------------------------

HRESULT
CWindow::put_Left(long lLeft)
{
    HRESULT hr;
    CStyle * pStyle;

    hr = SetPositionAbsolute(GetFrameSite(), &pStyle);
    if (hr)
        goto Cleanup;

    hr = pStyle->put_pixelLeft(g_uiDisplay.DeviceFromDocPixelsX(lLeft));
    
Cleanup:
    RRETURN(hr);
}

STDMETHODIMP
CFrameWebOC::put_Left(long lLeft)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_FAIL;
    return _pWindow->put_Left(lLeft);
}

//+-------------------------------------------------------------------------
//  Method   : get_Top
//
//  Synopsis : Get the top of the current weboc
//
//  Output   : The top of the current weboc.
//--------------------------------------------------------------------------

HRESULT
CWindow::get_Top(long * plTop)
{
    CElement * pElement = GetFrameSite();
    CLayout * pLayout;

    if (!pElement)
        return E_FAIL;

    pLayout = pElement->GetUpdatedLayout();
    if (!pLayout)
        return E_FAIL;

    *plTop = pLayout->GetPositionTop();

    return S_OK;
}

STDMETHODIMP
CFrameWebOC::get_Top(long * plTop)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_FAIL;
    return _pWindow->get_Top(plTop);
}

//+-------------------------------------------------------------------------
//  Method   : put_Top
//
//  Synopsis : Put the top of the current weboc.
//
//  Output   : The top of the current weboc.
//--------------------------------------------------------------------------

HRESULT
CWindow::put_Top(long lTop)
{
    HRESULT hr;
    CStyle * pStyle;

    hr = SetPositionAbsolute(GetFrameSite(), &pStyle);
    if (hr)
        goto Cleanup;

    hr = pStyle->put_pixelTop(lTop);
    
Cleanup:
    RRETURN(hr);
}

STDMETHODIMP
CFrameWebOC::put_Top(long lTop)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_FAIL;
    
    return _pWindow->put_Top(lTop);
}

//+-------------------------------------------------------------------------
//  Method   : get_Width
//
//  Synopsis : Get the width of the current weboc
//
//  Output   : The width of the current weboc.
//--------------------------------------------------------------------------

HRESULT
CWindow::get_Width(long * plWidth)
{
    CElement * pElement = GetFrameSite();
    CLayout * pLayout;

    if (!pElement)
        return E_FAIL;

    pLayout = pElement->GetUpdatedLayout();
    if (!pLayout)
        return E_FAIL;

    *plWidth = g_uiDisplay.DocPixelsFromDeviceX(pLayout->GetWidth());

    return S_OK;
}

STDMETHODIMP
CFrameWebOC::get_Width(long * plWidth)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_FAIL;
    return _pWindow->get_Width(plWidth);
}

//+-------------------------------------------------------------------------
//  Method   : put_Width
//
//  Synopsis : Put the width of the current weboc.
//
//  Output   : The width of the current weboc.
//--------------------------------------------------------------------------

HRESULT
CWindow::put_Width(long lWidth)
{
    HRESULT hr;
    CStyle * pStyle;
    CElement * pElement = GetFrameSite();

    if (!pElement)
        return E_FAIL;

    hr = pElement->GetStyleObject(&pStyle);
    if (hr)
       goto Cleanup;

    hr = pStyle->put_pixelWidth(g_uiDisplay.DeviceFromDocPixelsX(lWidth));
    
Cleanup:
    RRETURN(hr);
}

STDMETHODIMP
CFrameWebOC::put_Width(long lWidth)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_FAIL;
    return _pWindow->put_Width(lWidth);
}

//+-------------------------------------------------------------------------
//  Method   : get_Height
//
//  Synopsis : Get the height of the current weboc
//
//  Output   : The height of the current weboc.
//--------------------------------------------------------------------------

HRESULT
CWindow::get_Height(long * plHeight)
{
    CElement * pElement = GetFrameSite();
    CLayout * pLayout;

    if (!pElement)
        return E_FAIL;

    pLayout = pElement->GetUpdatedLayout();
    if (!pLayout)
        return E_FAIL;

    *plHeight = g_uiDisplay.DocPixelsFromDeviceY(pLayout->GetHeight());

    return S_OK;
}

STDMETHODIMP
CFrameWebOC::get_Height(long * plHeight)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_FAIL;
    return _pWindow->get_Height(plHeight);
}

//+-------------------------------------------------------------------------
//
//  Method   : put_Height
//
//  Synopsis : Put the height of the current weboc.
//
//  Output   : The height of the current weboc.
//
//  First implementation mwatt
//--------------------------------------------------------------------------

HRESULT
CWindow::put_Height(long lHeight)
{
    HRESULT hr;
    CStyle * pStyle;
    CElement * pElement = GetFrameSite();

    if (!pElement)
        return E_FAIL;

    hr = pElement->GetStyleObject(&pStyle);
    if (hr)
       goto Cleanup;

    hr = pStyle->put_pixelHeight(g_uiDisplay.DeviceFromDocPixelsY(lHeight));
    
Cleanup:
    RRETURN(hr);
}

STDMETHODIMP
CFrameWebOC::put_Height(long lHeight)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_FAIL;
    return _pWindow->put_Height(lHeight);
}

STDMETHODIMP 
CFrameWebOC::get_LocationName(BSTR * pbstrLocationName)
{
    HRESULT  hr = E_FAIL;
    LPOLESTR lpszLocationName = NULL;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    hr = _pWindow->GetTitle(&lpszLocationName);
    if (hr)
        goto Cleanup;

    *pbstrLocationName = SysAllocString(lpszLocationName);

Cleanup:

    if (lpszLocationName)
    {
        CoTaskMemFree(lpszLocationName);
    }
    
    return hr;
}

STDMETHODIMP
CFrameWebOC::get_LocationURL(BSTR * pbstrLocationURL)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_FAIL;
    Assert(pbstrLocationURL);
    *pbstrLocationURL = SysAllocString(CMarkup::GetUrl(_pWindow->_pMarkup));
    
    return (*pbstrLocationURL ? S_OK : E_FAIL);
}

STDMETHODIMP
CFrameWebOC::get_Busy(VARIANT_BOOL * pvfBusy)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (_pWindow->IsPassivated())
        return E_FAIL;
  
    *pvfBusy = _pWindow->_pMarkup->GetLoaded() ? VARIANT_FALSE
                                     : VARIANT_TRUE;
    
    return S_OK;
}

STDMETHODIMP
CFrameWebOC::get_HWND(LONG_PTR* plHWND)
{
    Assert(plHWND);
    *plHWND = NULL;
    
    return E_FAIL;
}

// Copied from shell\lib\varutilw.cpp
LPCTSTR
VariantToStrCast(const VARIANT *pvar)
{
    LPCTSTR psz = NULL;

    if (pvar->vt == (VT_BYREF | VT_VARIANT) && pvar->pvarVal)
        pvar = pvar->pvarVal;

    if (pvar->vt == VT_BSTR)
        psz = pvar->bstrVal;
    return psz;
}

STDMETHODIMP
CFrameWebOC::Navigate2(VARIANT * pvarUrl,
                       VARIANT * pvarFlags,
                       VARIANT * pvarFrameName,
                       VARIANT * pvarPostData,
                       VARIANT * pvarHeaders)
{
    HRESULT         hr = E_FAIL;
    CMarkup *       pMarkupNew  = NULL;
    const TCHAR *   pszUrl      = NULL;
    
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);
    
    if (_pWindow->IsPassivated())
    {
        goto Cleanup;
    }

    if (pvarUrl)
    {
        pszUrl = VariantToStrCast(pvarUrl);
    }

    if (pszUrl)
    {
        hr = Navigate(BSTR(pszUrl),
                      pvarFlags,
                      pvarFrameName,
                      pvarPostData,
                      pvarHeaders);
        goto Cleanup;
    }

    // Trying to navigate to a pidl or something that we don't know how
    // to navigate to. Viewlink to WebOC and delegate the navigation to it.
    hr = Doc()->CreateMarkup(&pMarkupNew, NULL, NULL, FALSE, _pWindow->_pWindowProxy);
    if (hr)
        goto Cleanup;
    _pWindow->ClearMetaRefresh();
    hr = pMarkupNew->ViewLinkWebOC(pvarUrl, pvarFlags, pvarFrameName, pvarPostData, pvarHeaders);

Cleanup:
    RRETURN(hr);
}

STDMETHODIMP
CFrameWebOC::get_Parent(IDispatch ** ppDisp)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
    
    if (!ppDisp)
        return E_POINTER;

    *ppDisp = NULL;

    if (_pWindow->IsPassivated())
        return E_FAIL;

    // If we are in a frame, we return the IDispatch of the containing window object.
    // Otherwise, delegate to the top-level WebOC if there is one.
    //
    if (_pWindow->_pWindowParent)
    {
        HRESULT hr;
        IHTMLWindow2   * pHTMLWindow   = NULL;
        IHTMLDocument2 * pHTMLDocument = NULL;

        hr = _pWindow->get_parent(&pHTMLWindow);
        if (hr)
            goto Cleanup;

        hr = DYNCAST(CWindow, pHTMLWindow)->get_document(&pHTMLDocument);
        if (hr)
            goto Cleanup;

        hr = pHTMLDocument->QueryInterface(IID_IDispatch, (void **) ppDisp);

    Cleanup:
        ReleaseInterface(pHTMLWindow);
        ReleaseInterface(pHTMLDocument);
        return hr;
    }
    else
    {
        IWebBrowser2 * pTopWebOC = Doc()->_pTopWebOC;

        if (pTopWebOC)
            return pTopWebOC->get_Parent(ppDisp);

        return E_FAIL;
    }
}

STDMETHODIMP 
CFrameWebOC::get_Container(IDispatch ** ppDisp)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);

    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
        
    // Container property is same as the parent unless 
    // there is no parent. In either case, delegate to get_Parent.
    //
    return get_Parent(ppDisp);
}

STDMETHODIMP
CFrameWebOC::get_TopLevelContainer(VARIANT_BOOL * pBool)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);

    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
        
    if (!pBool)
        return E_POINTER;

    *pBool = VARIANT_FALSE;

    if (_pWindow->IsPassivated())
        return E_FAIL;

    // If we are in a frame, return FALSE. Otherwise,
    // delegate to the top-level WebOC object.
    //
    if (!_pWindow->_pWindowParent)
    {
        IWebBrowser2 * pTopWebOC = Doc()->_pTopWebOC;

        if (pTopWebOC)
            return pTopWebOC->get_TopLevelContainer(pBool);
    }

    return S_OK;
}

STDMETHODIMP
CFrameWebOC::get_ReadyState(READYSTATE * plReadyState)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);

    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);
        
    if (!plReadyState)
        return E_POINTER;

    *plReadyState = (READYSTATE) _pWindow->Document()->GetDocumentReadyState();

    return S_OK;
}

//+-------------------------------------------------------------------
//
// For 5.0 compat, this code was transplanted from shv.ocx
//
//--------------------------------------------------------------------
STDMETHODIMP 
CFrameWebOC::ExecWB ( OLECMDID cmdID, OLECMDEXECOPT cmdexecopt, VARIANT * pvaIn, VARIANT * pvaOut)
{
    HRESULT    hr = E_FAIL;
    BSTR       bstrUrl = NULL;
    CElement * pElement = NULL;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW(E_FAIL);

    pElement = _pWindow->GetFrameSite();
    
    if ( pElement->IsDesignMode() )
        goto Cleanup;

    // If the optional argument pvargin is not specified make it VT_EMPTY.
    if (   pvaIn 
        && (V_VT(pvaIn) == VT_ERROR) 
        && (V_ERROR(pvaIn) == DISP_E_PARAMNOTFOUND))
    {
        V_VT(pvaIn) = VT_EMPTY;
        V_I4(pvaIn) = 0;
    }

    // If the optional argument pvargin is not specified make it VT_EMPTY.
    if (   pvaOut 
        && (V_VT(pvaOut) == VT_ERROR) 
        && (V_ERROR(pvaOut) == DISP_E_PARAMNOTFOUND))
    {
        V_VT(pvaOut) = VT_EMPTY;
        V_I4(pvaOut) = 0;
    }

    if (   cmdID == OLECMDID_PASTE
        || cmdID == OLECMDID_COPY
        || cmdID == OLECMDID_CUT
        || cmdID == OLECMDID_PRINT)
    {
        if (SUCCEEDED(get_LocationURL(&bstrUrl)))
        {
            DWORD dwPolicy = 0;
            DWORD dwContext = 0;

            hr = ZoneCheckUrlEx(bstrUrl, &dwPolicy, sizeof(dwPolicy), &dwContext, sizeof(dwContext),
                           URLACTION_SCRIPT_SAFE_ACTIVEX, 0, NULL);
            if (FAILED(hr))
            {
                hr = S_OK;
                goto Cleanup;
            }

            if (GetUrlPolicyPermissions(dwPolicy) != URLPOLICY_ALLOW)
            {
                if (cmdID == OLECMDID_PRINT)
                {
                    // (if the UI-less- request flag is set we need to unset it.)
                    if (cmdexecopt == OLECMDEXECOPT_DONTPROMPTUSER)
                        cmdexecopt = OLECMDEXECOPT_DODEFAULT;
                }
                else
                {
                    hr = S_OK;
                    goto Cleanup;
                }
            }
            else if (cmdID != OLECMDID_PRINT)
            {
                hr = ZoneCheckUrlEx(bstrUrl, &dwPolicy, sizeof(dwPolicy), &dwContext, sizeof(dwContext),
                               URLACTION_SCRIPT_PASTE, 0, NULL);

                if (FAILED(hr) || GetUrlPolicyPermissions(dwPolicy) != URLPOLICY_ALLOW)
                {
                    hr = S_OK;
                    goto Cleanup;
                }
            }
        }
    }

    // now pass along the call into our Doc (not to the topOC)
    if (_pWindow->Document())
        hr = _pWindow->Document()->Exec(NULL, cmdID, cmdexecopt, pvaIn, pvaOut); 

Cleanup:
    if (bstrUrl)
        SysFreeString(bstrUrl);

    return hr;
}

STDMETHODIMP 
CFrameWebOC::QueryStatusWB (OLECMDID cmdID, OLECMDF * pcmdf)
{
    CElement * pElement = _pWindow->GetFrameSite();
    OLECMD     rgcmd;
    HRESULT    hr = E_FAIL;

    FRAME_WEBOC_PASSIVATE_CHECK_WITH_CLEANUP(E_FAIL);
    
    FRAME_WEBOC_VERIFY_WINDOW_WITH_CLEANUP(E_FAIL);
        
    if (pElement->IsDesignMode())
        goto Cleanup;

    rgcmd.cmdID = cmdID;
    rgcmd.cmdf = *pcmdf;

    if (_pWindow->Document())
        hr = _pWindow->Document()->QueryStatus(NULL, 1, &rgcmd, NULL);

    *pcmdf = (OLECMDF) rgcmd.cmdf;
    
Cleanup:
    return hr;
}

// These methods maintain a status variable but not action is taken as defined by the current design

#ifndef BOOL_TO_VARIANTBOOL
#define BOOL_TO_VARIANTBOOL(b) ((b) ? VARIANT_TRUE : VARIANT_FALSE)
#endif

#ifndef VARIANTBOOL_TO_BOOL
#define VARIANTBOOL_TO_BOOL(vb) ((vb == VARIANT_FALSE) ? FALSE : TRUE)
#endif

HRESULT  
CFrameWebOC::ClientToWindow(int * pcx, int * pcy)
{
    // For compatibility with IE5, we return E_FAIL;
    return E_FAIL;
}

HRESULT  
CFrameWebOC::get_Visible(VARIANT_BOOL * pvfVisible)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    if (pvfVisible==NULL) 
       return E_INVALIDARG;

    *pvfVisible = BOOL_TO_VARIANTBOOL(_fVisible);
    return S_OK;
}

HRESULT  
CFrameWebOC::put_Visible(VARIANT_BOOL vfVisible)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    _fVisible = VARIANTBOOL_TO_BOOL(vfVisible);
    return S_OK;
}

HRESULT  
CFrameWebOC::get_StatusBar(VARIANT_BOOL * pvfStatusBar)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
            
    if (pvfStatusBar==NULL) 
       return E_INVALIDARG; 

    *pvfStatusBar = BOOL_TO_VARIANTBOOL(_fStatusBar);
    return S_OK;
}

HRESULT  
CFrameWebOC::put_StatusBar(VARIANT_BOOL vfStatusBar)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    _fStatusBar = VARIANTBOOL_TO_BOOL(vfStatusBar);
    return S_OK;
}

HRESULT  
CFrameWebOC::get_StatusText(BSTR * pbstrStatusText)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    if (pbstrStatusText==NULL) 
       return E_INVALIDARG;

    pbstrStatusText = NULL;
    return E_FAIL;
}

HRESULT  
CFrameWebOC::put_StatusText(BSTR bstrStatusText)
{
    return E_FAIL;
}

HRESULT  
CFrameWebOC::get_ToolBar(int * pnToolBar)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
            
    if (pnToolBar==NULL) 
       return E_INVALIDARG;

    *pnToolBar = BOOL_TO_VARIANTBOOL(_fToolBar);
    return S_OK;
}

HRESULT  
CFrameWebOC::put_ToolBar(int nToolBar)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    _fToolBar = BOOL_TO_VARIANTBOOL(nToolBar);
    return S_OK;
}

HRESULT  
CFrameWebOC::get_MenuBar(VARIANT_BOOL * pvfMenuBar)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
            
    if (pvfMenuBar==NULL) 
       return E_INVALIDARG;

    *pvfMenuBar = BOOL_TO_VARIANTBOOL(!_fMenuBar);
    return S_OK;
}

HRESULT  
CFrameWebOC::put_MenuBar(VARIANT_BOOL vfMenuBar)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    _fMenuBar = !(VARIANTBOOL_TO_BOOL(vfMenuBar));
    return S_OK;
}

HRESULT  
CFrameWebOC::get_FullScreen(VARIANT_BOOL *pvfFullScreen)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
            
    if (pvfFullScreen==NULL) 
       return E_INVALIDARG;

    *pvfFullScreen = BOOL_TO_VARIANTBOOL(_fFullScreen);
    return S_OK;
}

HRESULT  
CFrameWebOC::put_FullScreen(VARIANT_BOOL vfFullScreen)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
            
    _fFullScreen = VARIANTBOOL_TO_BOOL(vfFullScreen);
    return S_OK;
}

HRESULT  
CFrameWebOC::get_TheaterMode(VARIANT_BOOL * pvfTheaterMode)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
            
    if (pvfTheaterMode==NULL) 
       return E_INVALIDARG;

    *pvfTheaterMode = BOOL_TO_VARIANTBOOL(_fTheaterMode);
    return S_OK;
}

HRESULT  
CFrameWebOC::put_TheaterMode(VARIANT_BOOL vfTheaterMode)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
    
    _fTheaterMode = VARIANTBOOL_TO_BOOL(vfTheaterMode);
    return S_OK;
}

HRESULT  
CFrameWebOC::get_AddressBar(VARIANT_BOOL * pvfAddressBar)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
        
    if (pvfAddressBar==NULL) 
       return E_INVALIDARG;

    *pvfAddressBar = BOOL_TO_VARIANTBOOL(_fAddressBar);
    return S_OK;
}

HRESULT  
CFrameWebOC::put_AddressBar(VARIANT_BOOL vfAddressBar)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
            
    _fAddressBar = VARIANTBOOL_TO_BOOL(vfAddressBar);
    return S_OK;
}

HRESULT  
CFrameWebOC::get_Resizable(VARIANT_BOOL * pvfResizable)
{
    // For compatibility with IE5, we return E_NOTIMPL;
    return E_NOTIMPL;
}

HRESULT 
CFrameWebOC::put_Resizable(VARIANT_BOOL vfResizable)
{
    return E_NOTIMPL;
}


HRESULT
CFrameWebOC::get_RegisterAsBrowser(VARIANT_BOOL * pfRegister)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
            
    *pfRegister = BOOL_TO_VARIANTBOOL(_fShouldRegisterAsBrowser);

    return S_OK;
}

HRESULT
CFrameWebOC::put_RegisterAsBrowser(VARIANT_BOOL fRegister)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
            
    _fShouldRegisterAsBrowser = VARIANTBOOL_TO_BOOL(fRegister);

    return S_OK;
}

HRESULT 
CFrameWebOC::get_Application(IDispatch** ppDisp)
{
    FRAME_WEBOC_PASSIVATE_CHECK(E_FAIL);
            
    (*ppDisp) = this;
    AddRef();

    return S_OK;
}

HRESULT
CFrameWebOC::Quit()
{
    return E_FAIL;
}

DELEGATE_WB_METHOD(CFrameWebOC, Doc(), get_Type, (BSTR * pbstrType), (pbstrType))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), PutProperty, (BSTR bstrProperty, VARIANT varValue), (bstrProperty, varValue))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), GetProperty, (BSTR bstrProperty, VARIANT * pvarValue), (bstrProperty, pvarValue))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), get_Name, (BSTR * pbstrName), (pbstrName))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), get_FullName, (BSTR * pbstrFullName), (pbstrFullName))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), get_Path, (BSTR * pbstrPath), (pbstrPath))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), ShowBrowserBar, (VARIANT * pvarClsid, VARIANT * pvarShow, VARIANT * pvarSize),
                                                   (pvarClsid, pvarShow, pvarSize))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), get_Offline, (VARIANT_BOOL * pvfOffline), (pvfOffline))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), put_Offline, (VARIANT_BOOL vfOffline), (vfOffline))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), get_Silent, (VARIANT_BOOL * pvfSilent), (pvfSilent))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), put_Silent, (VARIANT_BOOL vfSilent), (vfSilent))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), get_RegisterAsDropTarget, (VARIANT_BOOL * pvfRegister), (pvfRegister))
DELEGATE_WB_METHOD(CFrameWebOC, Doc(), put_RegisterAsDropTarget, (VARIANT_BOOL vfRegister), (vfRegister))

// Helper Functions
//

//+-------------------------------------------------------------------------
//
//  Method   : GetStdLocation
//
//  Synopsis : Retrieves the URL of the given standard location type.
//
//  Input    : eLocation - the standard location.
//  Output   : bstrUrl   - the URL of the standard location.
//
//--------------------------------------------------------------------------

HRESULT
GetStdLocation(STDLOCATION eLocation, BSTR * bstrUrl)
{
    HRESULT hr = E_FAIL;
    LPCTSTR lpszName = NULL;
    WCHAR   szPath[INTERNET_MAX_URL_LENGTH];
    DWORD   cbSize = sizeof(szPath);
    DWORD   dwType;
    HKEY    hkey = NULL;

    Assert(bstrUrl);

    // We are currently retrieving the home page from 
    // HKCU. If the user hasn't set a home
    // page yet, we must get the home page from 
    // HKEY_LOCAL_MACHINE: "Default_Page_URL" or "Start Page".
    //
    switch(eLocation)
    {
        case eHomePage:
            lpszName = _T("Start Page");
            break;

        case eSearchPage:
            lpszName = _T("Search Page");
            break;
            
        default:
            goto Cleanup;
    }
    
    hr = RegOpenKey(HKEY_CURRENT_USER,
                    _T("Software\\Microsoft\\Internet Explorer\\Main"),
                    &hkey);
    if (hr)
        goto Cleanup;

    hr = RegQueryValueEx(hkey, lpszName,
                         0, &dwType, (LPBYTE)szPath, &cbSize);
    if (hr)
        goto Cleanup;

    *bstrUrl = SysAllocString(szPath);
    
Cleanup:    
    if (hkey)
        RegCloseKey(hkey);

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method   : GoStdLocation
//
//  Synopsis : Navigates to a standard location - home, search, etc.
//
//  Input    : eLocation - the standard location.
//  Output   : pWindow   - the window to use when navigating.
//
//--------------------------------------------------------------------------

HRESULT
GoStdLocation(STDLOCATION eLocation, CWindow * pWindow)
{
    HRESULT hr;
    BSTR    bstrUrl = NULL;

    Assert(pWindow);
    
    hr = GetStdLocation(eLocation, &bstrUrl);   
    if (hr)
        goto Cleanup;

    hr = pWindow->navigate(bstrUrl);

Cleanup:
    SysFreeString(bstrUrl);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\moniker\abtprot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       abtprot.cxx
//
//  Contents:   Implementation of the about protocol
//
//  History:    07-23-97    krisma     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_ABTPROT_HXX_
#define X_ABTPROT_HXX_
#include "abtprot.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_ROSTM_HXX_
#define X_ROSTM_HXX_
#include "rostm.hxx"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#include <shellapi.h>  // for the definition of ShellExecuteA (for AXP)
#endif

MtDefine(Protocols, Mem, "Protocols")
MtDefine(CAboutProtocol, Protocols, "CAboutProtocol")

// Some Static strings that we use to read from the registry
static TCHAR szAboutKey[] = 
    _T("SOFTWARE\\Microsoft\\Internet Explorer\\AboutURLs");

extern BOOL g_fInIexplorer;
extern BOOL g_fInExplorer;

//+---------------------------------------------------------------------------
//
//  Function:   CreateAboutProtocol
//
//  Synopsis:   Creates an about Async Pluggable protocol
//
//  Arguments:  pUnkOuter   Controlling IUnknown
//
//----------------------------------------------------------------------------

CBase * 
CreateAboutProtocol(IUnknown *pUnkOuter)
{
    return new CAboutProtocol(pUnkOuter);
}

CAboutProtocolCF   g_cfAboutProtocol(CreateAboutProtocol);


#define GetStdLocationORD   150
typedef HRESULT (APIENTRY* PFNGETSTDLOCATION)(LPTSTR pszPath, DWORD cchPath, UINT id);

HRESULT GetShellStdLocation(LPTSTR lpszBuffer, DWORD cchBuffer, DWORD dwID)
{
    HRESULT hres = E_FAIL;
    HINSTANCE hinst;

    if (0 < cchBuffer)
        *lpszBuffer = 0;
        
    hinst = LoadLibrary(TEXT("shdocvw.dll"));
    if (hinst)
    {
        PFNGETSTDLOCATION pfn = (PFNGETSTDLOCATION)GetProcAddress(hinst, MAKEINTRESOURCEA(GetStdLocationORD));

        if (pfn)
        {
            hres = pfn(lpszBuffer, cchBuffer, dwID);
        }
        FreeLibrary(hinst);
    }

    return hres;
}

HRESULT
CAboutProtocolCF::QueryInfo(
    LPCWSTR       pwzUrl, 
    QUERYOPTION   QueryOption,
    DWORD         dwQueryFlags,
    LPVOID        pvBuffer,
    DWORD         cbBuffer,
    DWORD  *      pcbBuffer,
    DWORD         dwReserved)
{
    HRESULT     hr;
    HKEY        hkey = NULL;
    TCHAR *     szRegValue;
    LONG        lRegErrorValue;
    TCHAR       szBuffer[pdlUrlLen];
    DWORD       dwType;
    DWORD       cbData = sizeof(szBuffer);
    DWORD       dwRetval;

    //
    // Before resolving through registry, see if the \1 part forces the URL to be unsecure
    //

    if (QueryOption == QUERY_IS_SECURE && !HasSecureContext(pwzUrl))
    {
        dwRetval = FALSE;
        goto ReturnDword;
    }

    szRegValue = _tcschr(pwzUrl, ':');

    szRegValue += 1;
    
    lRegErrorValue = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, szAboutKey, NULL, KEY_READ,
        &hkey);
    if (lRegErrorValue != ERROR_SUCCESS)
    {
        hr = INET_E_DEFAULT_ACTION;
        goto Cleanup;
    }

    lRegErrorValue = SHQueryValueEx(hkey, szRegValue, NULL, &dwType, (LPBYTE)szBuffer, &cbData);
    if (lRegErrorValue == ERROR_SUCCESS)
    {
        // If the value is in the registry as a DWORD then it must be a special Shell location.  Map the ID to the URL
        // by passing it to GetStdLocation.
        if (dwType == REG_DWORD)
        {
            if (FAILED(GetShellStdLocation(szBuffer, ARRAY_SIZE(szBuffer), *((LPDWORD)szBuffer))))
            {
                hr = INET_E_DEFAULT_ACTION;
                goto Cleanup;
            }
        }
        hr = THR(CoInternetQueryInfo(szBuffer, QueryOption, dwQueryFlags, pvBuffer, cbBuffer, pcbBuffer, dwReserved));
    }
    else
    {
        switch (QueryOption)
        {
        case QUERY_USES_NETWORK:
        case QUERY_IS_CACHED:
            dwRetval = FALSE;
            goto ReturnDword;
            
        case QUERY_IS_SECURE:
            dwRetval = TRUE;
            goto ReturnDword;
            
        default:
            hr = INET_E_DEFAULT_ACTION;
            break;
        }
    }

Cleanup:
    if (hkey)
        RegCloseKey(hkey);
    RRETURN1(hr, INET_E_DEFAULT_ACTION);

ReturnDword:
    if (!pvBuffer || cbBuffer < sizeof(DWORD))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (pcbBuffer)
    {
        *pcbBuffer = sizeof(DWORD);
    }
    
    *(DWORD *)pvBuffer = dwRetval;
    hr = S_OK;

    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Method:     CAboutProtocolCF::ParseUrl
//
//  Synopsis:   per IInternetProtocolInfo. Reads new URL from 
//              registry and replaces the about: URL.
//
//----------------------------------------------------------------------------

HRESULT
CAboutProtocolCF::ParseUrl(
    LPCWSTR     pwzUrl,
    PARSEACTION ParseAction,
    DWORD       dwFlags,
    LPWSTR      pwzResult,
    DWORD       cchResult,
    DWORD *     pcchResult,
    DWORD       dwReserved)
{
    CStr        cstr;
    HRESULT     hr = INET_E_DEFAULT_ACTION;
    HKEY        hkey = NULL;
    TCHAR      *szRegValue;
    TCHAR      *pchSourceUrl = NULL;
    LONG        lRegErrorValue;
    DWORD       dwType;

    if (!pcchResult || !pwzResult)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    if (ParseAction == PARSE_CANONICALIZE)
    {
        static TCHAR       szBuffer[pdlUrlLen];
        DWORD       cbData = sizeof(szBuffer);

        //
        // Search for an embedded \1.  If it's found, then strip it
        // out because that's the source url of this protocol.
        //
        pchSourceUrl = _tcschr(pwzUrl, _T('\1'));
        hr = pchSourceUrl ? 
                THR(cstr.Set(pwzUrl, pchSourceUrl - pwzUrl)) : 
                THR(cstr.Set(pwzUrl));

        szRegValue = _tcschr(cstr, ':');
        szRegValue += 1;

        //
        //  Special case for about:blank so
        //  we don't lose security info
        //
        if (!_tcsicmp(_T("blank"), szRegValue))
        {
            hr = THR(super::ParseUrl(
                pwzUrl,
                ParseAction,
                dwFlags,
                pwzResult,
                cchResult,
                pcchResult,
                dwReserved));
            goto Cleanup;
        }


        lRegErrorValue = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, szAboutKey, NULL, KEY_READ,
            &hkey);
        if (lRegErrorValue != ERROR_SUCCESS)
        {
            hr=INET_E_DEFAULT_ACTION;
            goto Cleanup;
        }

        lRegErrorValue = SHQueryValueEx(
            hkey, szRegValue, NULL, &dwType, (LPBYTE)szBuffer, &cbData);
        if (lRegErrorValue == ERROR_SUCCESS)
        {
            // If the value is in the registry as a DWORD then it must be a special Shell location.  Map the ID to the URL
            // by passing it to GetStdLocation.
            if (dwType == REG_DWORD)
            {
                if (FAILED(GetShellStdLocation(szBuffer, ARRAY_SIZE(szBuffer), *((LPDWORD)szBuffer))))
                {
                    hr = INET_E_DEFAULT_ACTION;
                    goto Cleanup;
                }
            }
        }
        else
        {
            //
            //  If the registry value does not exist, procede as 
            //  normal (write the string to the document).
            //
            //  [kusumav] 03/07/2002 - Disabled about protocol except for ones we register
            //  We now navigate to about:NavigationCanceled for any about URL except
            //  the ones in HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\AboutURLs
            //  This is the first place where we block non-blessed about urls.
            //  If we don't find the NavigationCanceled key, then our protocol handler will
            //  be called and we return E_ACCESSDENIED in the Start method which will 
            //  effectively block whatever slips through this check
            //
            //
            lRegErrorValue = SHQueryValueEx(
                hkey, L"NavigationCanceled", NULL, &dwType, (LPBYTE)szBuffer, &cbData);
            
            if ((!g_fInExplorer && !g_fInIexplorer) || (lRegErrorValue != ERROR_SUCCESS && (dwType != REG_SZ)))
            {
                hr = THR(super::ParseUrl(
                    pwzUrl,
                    ParseAction,
                    dwFlags,
                    pwzResult,
                    cchResult,
                    pcchResult,
                    dwReserved));
                goto Cleanup;
            }
        }
        
        *pcchResult = cchResult;
        hr = UrlCanonicalize(szBuffer, pwzResult, pcchResult, dwFlags);

    }
    else if (ParseAction == PARSE_SECURITY_URL)
    {
        hr = THR(UnwrapSpecialUrl(pwzUrl, cstr));
        if (hr)
            goto Cleanup;
        
        *pcchResult = cstr.Length() + 1;
        if (cstr.Length() + 1 > cchResult)
        {
            // Not enough room, so fill in *pcchResult with size we need
            hr = S_FALSE;
            goto Cleanup;
        }

        _tcscpy(pwzResult, cstr);
    }
    else
    {
        hr = THR_NOTRACE(super::ParseUrl(
            pwzUrl,
            ParseAction,
            dwFlags,
            pwzResult,
            cchResult,
            pcchResult,
            dwReserved));
    }
    
Cleanup:
    if (hkey)
        RegCloseKey(hkey);

    RRETURN2(hr, INET_E_DEFAULT_ACTION, S_FALSE);
}


const CBase::CLASSDESC CAboutProtocol::s_classdesc =
{
    &CLSID_AboutProtocol,             // _pclsid
};


//+---------------------------------------------------------------------------
//
//  Method:     CAboutProtocol::CAboutProtocol
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CAboutProtocol::CAboutProtocol(IUnknown *pUnkOuter) : super(pUnkOuter)
{
}


//+---------------------------------------------------------------------------
//
//  Method:     CAboutProtocol::~CAboutProtocol
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CAboutProtocol::~CAboutProtocol()
{
}


//+---------------------------------------------------------------------------
//
//  Method:     CAboutProtocol::Start
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CAboutProtocol::Start(
    LPCWSTR pchUrl, 
    IInternetProtocolSink *pTrans, 
    IInternetBindInfo *pOIBindInfo,
    DWORD grfSTI, 
    HANDLE_PTR dwReserved)
{
    HRESULT         hr = NOERROR;
    TCHAR           ach[pdlUrlLen];
    DWORD           dwSize;
    
    Assert(!_pProtSink && pOIBindInfo && pTrans && !_cstrURL);

    if ( !(grfSTI & PI_PARSE_URL))
    {
        if ((g_fInExplorer || g_fInIexplorer) && _tcsicmp(_T("about:blank"), pchUrl))
        {
            // Block all about urls. Return E_ACCESSDENIED instead of E_FAIL
            // since Trident doesn't handle all errors, it will handle this one correctly
            // We will never come to this codepath for the blessed about urls 
            // since we map them to res:// urls in our ParseAndBind method above
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }
        ReplaceInterface(&_pProtSink, pTrans);
        ReplaceInterface(&_pOIBindInfo, pOIBindInfo);
    }

    _bindinfo.cbSize = sizeof(BINDINFO);
    hr = THR(pOIBindInfo->GetBindInfo(&_grfBindF, &_bindinfo));

    //
    // First get the basic url.  Unescape it first.
    //

    hr = THR(CoInternetParseUrl(pchUrl, PARSE_ENCODE, 0, ach, ARRAY_SIZE(ach), &dwSize, 0));
    if (hr)
        goto Cleanup;
    
    hr = THR(_cstrURL.Set(ach));
    if (hr)
        goto Cleanup;

    //
    // Now append any extra data if needed.
    //
    
    if (_bindinfo.szExtraInfo)
    {
        hr = THR(_cstrURL.Append(_bindinfo.szExtraInfo));
        if (hr)
            goto Cleanup;
    }

    _grfSTI = grfSTI;

    //
    // If forced to go async, return E_PENDING now, and
    // perform binding when we get the Continue.
    //
    
    if (grfSTI & PI_FORCE_ASYNC)
    {
        PROTOCOLDATA    protdata;

        hr = E_PENDING;
        protdata.grfFlags = PI_FORCE_ASYNC;
        protdata.dwState = BIND_ASYNC;
        protdata.pData = NULL;
        protdata.cbData = 0;

        _pProtSink->Switch(&protdata);
    }
    else
    {
        hr = THR(ParseAndBind());
    }


Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CAboutProtocol::ParseAndBind
//
//  Synopsis:   Actually perform the binding & execution of script.
//
//----------------------------------------------------------------------------

void
CAboutProtocol::_ReportData(ULONG cb)
{
    _bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
    _pProtSink->ReportData(_bscf, cb, cb);
}

HRESULT
CAboutProtocol::ParseAndBind()
{
    HRESULT         hr = S_OK;
    TCHAR *         pch = NULL;
    TCHAR *         pchBuf = NULL;
    CStr            cstrBuf;
    ULONG           cb = NULL;
    CROStmOnBuffer *prostm = NULL;
    HINSTANCE       hInst = NULL;

    //
    // The url is of the following syntax:
    // about:<name>
    //
    
    Assert(_tcsnipre(_T("about:"), 6, _cstrURL, -1));

    //
    // Do the binding.
    //

    pch = _tcschr(_cstrURL, ':');
    if (!pch)
    {
        hr = MK_E_SYNTAX;
        goto Cleanup;
    }

    pch++;

    {
        TCHAR szBuf[] = _T(" <HTML>");
        szBuf[0] = NATIVE_UNICODE_SIGNATURE;

        hr = THR(cstrBuf.Set(szBuf));
    }

    if (hr)
        goto Cleanup;

    //
    //  Special case for about:blank. Just show a blank page.
    //
    if (_tcsicmp(_T("blank"), pch))
    {
        hr = THR(cstrBuf.Append(pch));
        if (hr)
            goto Cleanup;
    }

    hr = THR(cstrBuf.Append(_T("</HTML>")));
    if (hr)
        goto Cleanup;

    pchBuf = cstrBuf;
    cb = (cstrBuf.Length() + 1) * sizeof(TCHAR);

    hr = THR(_pProtSink->ReportProgress(
            BINDSTATUS_MIMETYPEAVAILABLE, 
            _T("text/html")));
    if (hr)
        goto Cleanup;

    Assert(pchBuf);
    
    // cb includes the null terminator
    
    prostm = new CROStmOnBuffer;
    if (!prostm)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(prostm->Init((BYTE *)pchBuf, cb));
    if (hr)
        goto Cleanup;

    _pStm = (IStream *)prostm;
    _pStm->AddRef();
        
Cleanup:
    if (!_fAborted)
    {
        if (!hr)
        {
            _ReportData(cb);
        }
        if (_pProtSink)
        {
            _pProtSink->ReportResult(hr, 0, 0);
        }
    }
    
    if (hInst)
    {
        FreeLibrary(hInst);
    }
    if (prostm)
    {
        prostm->Release();
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\moniker\unixprot.cxx ===
#include "headers.hxx"
#ifndef X_INETREG_H_
#define X_INETREG_H_
#include "inetreg.h"
#endif

#ifndef X_MLANG_H_
#define X_MLANG_H_
#include <mlang.h>
#endif

#ifndef X_MAPI_H_
#define X_MAPI_H_
#include <mapi.h>
#endif

#ifndef X_MAILPROT_HXX_
#define X_MAILPROT_HXX_
#include "mailprot.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#include <shellapi.h>  // for the definition of ShellExecuteA (for AXP)
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#define URL_KEYWL_MAILTO      7           // length of "mailto:"
#define MAILTO_OPTION         TEXT(" mailto ")

#define OE_MAIL_COMMAND_KEY TEXT("Software\\Clients\\Mail\\Outlook Express\\shell\\open\\command")
#define OE_URL_COMMAND_NAME TEXT("URLCommand")
#define MAILTO_URL_HEADER TEXT("mailto:")
#define IE_HOME_ENVIRONMENT TEXT("MWDEV")

HRESULT _UnixLaunchOE(TCHAR *pszRecips, UINT nRecips)
{
    HRESULT     hr = S_OK;
    TCHAR       *tszCommand = NULL;
    TCHAR       tszIEHome[MAX_PATH];
    DWORD       cchIEHome;
    DWORD       cchCommand;
    DWORD       dwDisposition;
    TCHAR       *pchPos;
    BOOL        bMailed;
    STARTUPINFO stInfo;
    HKEY        hkey = NULL;
    int         i;

    cchIEHome = GetEnvironmentVariable(IE_HOME_ENVIRONMENT, tszIEHome, MAX_PATH);
    if (cchIEHome)
    {
        _tcscat(tszIEHome, TEXT("/bin"));
    }
    else
    {
        return E_FAIL;
    }

    hr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, OE_MAIL_COMMAND_KEY, 0, NULL, 0, KEY_READ, NULL, &hkey, &dwDisposition);
    if (hr != ERROR_SUCCESS) 
    {
        goto Cleanup;
    }

    hr = RegQueryValueEx(hkey, OE_URL_COMMAND_NAME, NULL, NULL, (LPBYTE)NULL, &cchCommand);
    if (hr != ERROR_SUCCESS)
    {
        goto Cleanup;
    }
    cchCommand += _tcslen(tszIEHome) + _tcslen(MAILTO_URL_HEADER) + _tcslen(pszRecips) + 1;
    tszCommand = new TCHAR[cchCommand];

    _tcscpy(tszCommand, tszIEHome);
    _tcscat(tszCommand, TEXT("/"));
    dwDisposition = _tcslen(tszCommand);

    hr = RegQueryValueEx(hkey, OE_URL_COMMAND_NAME, NULL, NULL, (LPBYTE)(&tszCommand[dwDisposition]), &cchCommand);
    if (hr != ERROR_SUCCESS)
    {
        goto Cleanup;
    }
    _tcscat(tszCommand, MAILTO_URL_HEADER);

    for (i = 1; i < nRecips; i ++)
        *(pszRecips + _tcslen(pszRecips)) = TEXT(';');
    _tcscat(tszCommand, pszRecips);


    memset(&stInfo, 0, sizeof(stInfo));
    stInfo.cb = sizeof(stInfo);
    bMailed = CreateProcess(NULL, tszCommand, NULL, NULL, FALSE, DETACHED_PROCESS, NULL, NULL, &stInfo, NULL);

Cleanup:
    if ( hkey != NULL )
        RegCloseKey(hkey);

    if (tszCommand)
        delete(tszCommand);

    return hr;
}

HRESULT
CMailtoProtocol::LaunchUnixClient(TCHAR *aRecips, UINT nRecips)
{
    HRESULT         hr = S_OK;

    TCHAR           tszCommand[pdlUrlLen];
    TCHAR           tszExpandedCommand[pdlUrlLen];
    UINT            nCommandSize;
    int             i;
    HKEY    hkey = NULL;
    DWORD   dw;
    TCHAR *pchPos;
     BOOL bMailed;
    STARTUPINFO stInfo;

    DWORD dwType;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwUseOEMail;

    hr = SHGetValue(IE_USE_OE_MAIL_HKEY, IE_USE_OE_MAIL_KEY, IE_USE_OE_MAIL_VALUE, 
                    &dwType, (void*)&dwUseOEMail, &dwSize);
    if ((hr) && (dwType != REG_DWORD))
    {
        // The default value for mail is FALSE
        dwUseOEMail = FALSE;
    }
    if (dwUseOEMail)
    {
        return _UnixLaunchOE(aRecips, nRecips);
    }

    tszCommand[0] = 0;

    hr = RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_MAILCLIENTS, 0, NULL, 0, KEY_READ, NULL, &hkey, &dw);
    if (hr != ERROR_SUCCESS)
        goto Cleanup;
    dw = pdlUrlLen;
    hr = RegQueryValueEx(hkey, REGSTR_PATH_CURRENT, NULL, NULL, (LPBYTE)tszCommand, &dw);
    if (hr != ERROR_SUCCESS)
    {
        RegCloseKey(hkey);
        goto Cleanup;
    }

    dw = ExpandEnvironmentStrings(tszCommand, tszExpandedCommand, pdlUrlLen);
    if (!dw)
     {
        _tcscpy(tszExpandedCommand, tszCommand);
     }
    _tcscpy(tszCommand, TEXT("X "));
    _tcscat(tszCommand, tszExpandedCommand);
    for (i = _tcslen(tszCommand); i > 0; i--)
	if (tszCommand[i] == '/')
	{
	    tszCommand[i] = '\0';
	    break;
	}
    _tcscat(tszCommand, MAILTO_OPTION);
    nCommandSize = _tcslen(tszCommand);
    for (i = 1; i < nRecips; i ++)
	*(aRecips + _tcslen(aRecips)) = ' ';
    _tcscat(tszCommand, aRecips);

    memset(&stInfo, 0, sizeof(stInfo));
    stInfo.cb = sizeof(stInfo);
    bMailed = CreateProcess(tszExpandedCommand, tszCommand, NULL, NULL, FALSE, DETACHED_PROCESS, NULL, NULL, &stInfo, NULL);
 
Cleanup:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\proppage\allpage.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       allpage.cxx
//
//  Contents:   Generic TypeInfo-based property page
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#if DBG==1    

#ifndef X_PROPUTIL_HXX_
#define X_PROPUTIL_HXX_
#include "proputil.hxx"
#endif

#ifndef X_ALLPAGE_HXX_
#define X_ALLPAGE_HXX_
#include "allpage.hxx"
#endif

#ifndef X_ELEMENT_H_
#define X_ELEMENT_H_
#include "element.h"  // for IElement->GetSTYLE(..)
#endif

extern HRESULT CreateStreamOnFile(
        LPCTSTR lpstrFile,
        DWORD dwSTGM,
        LPSTREAM * ppstrm);


#define WM_DEFERUPADTE  WM_APP + 1   // This is only used in AllPage
#define WM_CBSELCHANGED  WM_APP + 2   // This is only used in AllPage

const CBase::CLASSDESC CAllPage::s_classdesc = { 0 };

DeclareTag(tagAsyncPict, "AllPage", "Async Picture Loading")

MtDefine(CAllPage, Dialogs, "CAllPage")
MtDefine(CAllPage_aryObjs_pv, CAllPage, "CAllPage::_aryObjs::_pv")
MtDefine(CAllPageParseValue_pchString, Dialogs, "CAllPage::ParseValue pchString")

//+------------------------------------------------------------------------
//
//  Function:   CreateGenericPropertyPage
//
//  Synopsis:   Creates a new generic page.  Called from the generic
//              page's class factory
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CreateGenericPropertyPage(
        IUnknown * pUnkOuter,
        IUnknown **ppUnk)
{
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    *ppUnk = new CAllPage(FALSE, IDS_PPG_GENERIC);
    return *ppUnk ? S_OK : E_OUTOFMEMORY;
}

HRESULT
CreateInlineStylePropertyPage(
        IUnknown * pUnkOuter,
        IUnknown **ppUnk)
{
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    *ppUnk = new CAllPage(TRUE, IDS_PPG_INLINE_STYLE);
    return *ppUnk ? S_OK : E_OUTOFMEMORY;
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::CAllPage
//
//  Synopsis:   Constructor
//
//-------------------------------------------------------------------------
CAllPage::CAllPage(BOOL fStyle, UINT idrTitleString)
    : _aryObjs(Mt(CAllPage_aryObjs_pv))
{
    _fStyle = fStyle;
    _idrTitleString = idrTitleString;
    _hWndPage = NULL;
    _hWndEdit = NULL;
    _hWndButton = NULL;
    _hWndList = NULL;
    _dyEdit = 0;
    _pPageSite = NULL;
    _pEngine = NULL;
    _pHolder = NULL;
    _emode = EMODE_Edit;

    _fDirty =
    _fInUpdateEditor =
    _fInApply = FALSE;

#ifndef NO_EDIT
    _pUndoMgr = &g_DummyUndoMgr;
#endif // NO_EDIT
#ifdef _MAC
    _hfontDlg = CreateFont(9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        FF_DONTCARE, _T("Geneva"));
#endif
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::~CAllPage
//
//  Synopsis:   Destructor
//
//-------------------------------------------------------------------------

void
CAllPage::Passivate()
{
    Deactivate();
    ClearInterface(&_pPageSite);
    ClearInterface(&_pUndoMgr);
    ReleaseObjects();
    CBase::Passivate();
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::~CAllPage
//
//  Synopsis:   Destructor
//
//-------------------------------------------------------------------------

CAllPage::~CAllPage( )
{
    ReleaseInterface(_pUndoMgr);
    ReleaseObjects();

#ifdef _MAC
    DeleteObject (_hfontDlg);
#endif
}


STDMETHODIMP_(ULONG)
CAllPage::AddRef( )
{
    return PrivateAddRef();
}


STDMETHODIMP_(ULONG)
CAllPage::Release( )
{
    return PrivateRelease();
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::QueryInterface
//
//  Synopsis:   The generic page supports the following interfaces:
//
//                  IUnknown
//                  IPropertyPage
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown ||
        iid == IID_IPropertyPage)
    {
        *ppv = (IPropertyPage *) this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::SetPageSite
//
//  Synopsis:   Replaces the current page site, which might be NULL
//
//  Arguments:  [pPageSite]     New page site
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::SetPageSite(IPropertyPageSite * pPageSite)
{
    if (_pPageSite && pPageSite)
        RRETURN(E_UNEXPECTED);

    ReplaceInterface(&_pPageSite, pPageSite);
    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::Activate
//
//  Synopsis:   Creates the window for this page.
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::Activate(
        HWND hWndParent,
        const RECT * prc,
        BOOL fModal)
{
    RECT    rc;
    HRESULT hr;

    Assert(_hWndPage == NULL);

    //
    // Verify that we have a commit holder
    //

    hr = THR(EnsureCommitHolder((DWORD_PTR)hWndParent, &_pHolder));
    if (hr)
        goto Cleanup;

    //
    // Now let commit engine know about objects
    //

    hr = THR(_pHolder->GetEngine(_aryObjs.Size(), _aryObjs, &_pEngine));
    if (hr)
        goto Cleanup;

    _hWndPage = CreateDialogParam(
                    GetResourceHInst(),
                    MAKEINTRESOURCE(IDD_GENERICPAGE),
                    hWndParent,
                    PageWndProc,
                    (LPARAM) this);
    if (!_hWndPage)
        RRETURN(HRESULT_FROM_WIN32(GetLastError()));


    _emode = EMODE_Edit;

    ::GetWindowRect(_hWndEdit, &rc);
    _dyEdit = rc.bottom - rc.top;

    Verify(!Move(prc));
    hr = THR(UpdatePage());
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::Deactivate
//
//  Synopsis:   Destroys the window for the page
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::Deactivate( )
{
    if (_hWndPage)
    {
        Verify(DestroyWindow(_hWndPage));
        _hWndPage = NULL;
        Assert(!_hWndPage);
    }

    if (_pHolder)
    {
        _pHolder->Release();
        _pHolder = NULL;
    }
    _pEngine = NULL;


    return S_OK;
}



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::GetPageInfo
//
//  Synopsis:   Returns page description information
//
//  Arguments:  [pppi]
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::GetPageInfo(LPPROPPAGEINFO pppi)
{
    HRESULT hr;
    DWORD   dw;
    TCHAR   szTitle[FORMS_BUFLEN + 1];

#if DBG == 1
    //
    // This function should fail if pppi->cb != sizeof(PROPPAGEINFO),
    // but we ignore it because the CDK  property frame does not set
    // this member.
    //
    if (pppi->cb != sizeof(PROPPAGEINFO))
    {
        TraceTag((tagWarning, "PROPPAGEINFO with bad cb (CDK prop frame known to do this)"));
#if 0
        RRETURN(E_FAIL);
#endif  // 0
    }
#endif  // DBG == 1

    memset(
            (BYTE *) pppi + sizeof(ULONG),
            0,
            sizeof(PROPPAGEINFO) - sizeof(ULONG));



    if (!LoadString(GetResourceHInst(), _idrTitleString, szTitle, FORMS_BUFLEN))
        return HRESULT_FROM_WIN32(GetLastError());

    dw = GetDialogBaseUnits();
    pppi->size.cx = 171 * LOWORD(dw) / 4;
    pppi->size.cy = 90 * HIWORD(dw) / 8;

    hr = TaskAllocString(szTitle, &pppi->pszTitle);
    if (hr)
        goto Error;

    // pppi->pszDocString not filled in
    // pppi->pszHelpFile not filled in
    // pppi->dwHelpContext not filled in

Cleanup:
    RRETURN(hr);

Error:
    TaskFreeString(pppi->pszTitle);
    goto Cleanup;
}



HRESULT
CAllPage::UpdatePage( )
{
    if (_hWndList)
    {
        SendMessage(_hWndList, WM_SETREDRAW, FALSE, 0);
        SendMessage(_hWndList, LB_RESETCONTENT, 0, 0);
    }

    UpdateList();

    if (_hWndList)
    {
        SendMessage(_hWndList, WM_SETREDRAW, TRUE, 0);
    }

    UpdateEditor(NULL);
    UpdateEngine();

    return S_OK;
}



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::SetObjects
//
//  Synopsis:   Releases the old set of objects, and makes a new set
//              current.  The TypeInfo's for the objects are examined, a
//              shared subset of properties is determined, then the
//              common values for these properties are retrieved.
//
//  Arguments:  [cObjects]
//              [apUnk]
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::SetObjects(ULONG cObjects, IUnknown ** apUnk)
{
    HRESULT         hr;
    int             i;
    IUnknown  **    ppUnk     = NULL;
    IDispatch **    ppDisp    = NULL;

    if (TLS(prop.fModalDialogUp))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  Flush the new values to the existing objects first.
    //

    if (_fDirty)
    {
        Apply();
    }

    ReleaseObjects();

    hr = THR(_aryObjs.EnsureSize(cObjects));
    if (hr)
        goto Error;

    for (i = 0, ppUnk = apUnk, ppDisp = _aryObjs;
         i < (int) cObjects;
         ppUnk++, ppDisp++)
    {

        if (_fStyle)
        {
            IHTMLStyle *pStyle;

            hr = THR((*ppUnk)->QueryInterface(IID_IHTMLElement, (void **) ppDisp));
            if (hr)
            {
                ClearInterface(ppDisp);
                goto Error;
            }

            hr = THR(  (  (IHTMLElement*)  *ppDisp)->get_style(&pStyle));
            ClearInterface(ppDisp);
            if (hr)
            {
                goto Error;
            }
            *ppDisp = pStyle;
        }
        else
        {
            hr = THR((*ppUnk)->QueryInterface(IID_IDispatch, (void **) ppDisp));
        }

        //ISSUE: TODO: --This looks fishy.  Shouldn't this be if(hr) ???
        if (!hr)
        {
            //if this fails we still want to the other object's pages
            //  or a blank page
            _aryObjs.SetSize(++i);
        }
        hr = S_OK;
    }


Cleanup:
    RRETURN(hr);

Error:
    ReleaseObjects();
    goto Cleanup;
}



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::Show
//
//  Synopsis:   Shows the property page
//
//  Arguments:  [nCmdShow]
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::Show(UINT nCmdShow)
{
    ShowWindow(_hWndPage, nCmdShow);
    return S_OK;
}



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::Move
//
//  Synopsis:   Moves the property page window.  The child windows are
//              repositioned to match.
//
//  Arguments:  [prc]
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::Move(const RECT * prc)
{
    MoveWindow(
            _hWndPage,
            prc->left,
            prc->top,
            prc->right - prc->left,
            prc->bottom - prc->top,
            TRUE);

    return S_OK;
}



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::IsPageDirty
//
//  Synopsis:   Returns S_OK if this page is dirty, S_FALSE otherwise.
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::IsPageDirty( )
{
    return (_fDirty) ? S_OK : S_FALSE;
}



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::Apply
//
//  Synopsis:   Applies any pending changes from the page.  The UI is
//              updated to pick up the new value.
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::Apply( )
{
    HRESULT     hr;

    if (!_fDirty || _fInApply)
        return S_OK;

    _fInApply = TRUE;

    hr = THR(_pEngine->Commit());
    if (hr)
        goto Cleanup;

    SetDirty(FALSE);

Cleanup:
    _fInApply = FALSE;
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::OnButtonClick
//
//  Synopsis:   Called when ... Button is clicked. It opens Font/Picture
//              Dialog.
//
//  Returns:    None
//
//-------------------------------------------------------------------------
#ifndef NO_PROPERTY_PAGE
void
CAllPage::OnButtonClick(void)
{
    Assert(_pDPDCur);

    TLS(prop.fModalDialogUp) = TRUE;

    if (_pDPDCur->fSpecialCaseFont)
    {
        BOOL fRet;

        OpenFontDialog(
                this,
                _hWndEdit,
                _aryObjs.Size(),
                (IUnknown **)(IDispatch **) _aryObjs,
                &fRet);
        if (fRet)
        {
            // Open change font/ForeColor proeprty, update edit box
            UpdateEditor(_pDPDCur);
        }
    }
    else if (_pDPDCur->fSpecialCaseColor)
    {
        OpenColorDialog();
    }
    else
    {
        OpenPictureDialog(_pDPDCur->fSpecialCaseMouseIcon);
    }

    TLS(prop.fModalDialogUp) = FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::OpenPictureDialog
//
//  Synopsis:   Opens Picture Dialog. If successful, Update edit box
//              and save the change
//
//  Returns:    None
//
//-------------------------------------------------------------------------

void
CAllPage::OpenPictureDialog(BOOL fMouseIcon)
{
    HRESULT hr = E_FAIL;
    TCHAR achFile[MAX_PATH];

    achFile[0] = 0;

    hr = THR(FormsGetFileName(
			      FALSE, // indicates OpenFileName
                    _hWndPage,
                    fMouseIcon  ? IDS_PROPERTYOPENMOUSEICON
                                : IDS_PROPERTYOPENPICTURE,
                    achFile,
                    ARRAY_SIZE(achFile), (LPARAM)0));

    if (!hr)
    {
        // Update edit box and save the change
        SetWindowText(_hWndEdit, achFile);
        _fDirty = 1;
        Apply();
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::OpenColorDialog
//
//  Synopsis:   Opens Color Dialog. If successful, Update edit box
//              and save the change
//
//  Returns:    None
//
//-------------------------------------------------------------------------

void
CAllPage::OpenColorDialog()
{
    HRESULT     hr;
    BOOL        fRet;
    CHOOSECOLOR cc;
    COLORREF    aclr[16];
    int         i;
    VARIANT     var;

    //
    // initialize CHOOSECOLOR structure
    //

    memset((void *)&cc, 0, sizeof(CHOOSECOLOR));

    for (i = ARRAY_SIZE(aclr) - 1; i >= 0; i--)
    {
        aclr[i] = RGB(255, 255, 255);
    }

    VariantInit(&var);

    // Find the current color
    hr = THR_NOTRACE(GetCommonPropertyValue(
            _pDPDCur->dispid,
            _aryObjs.Size(),
            _aryObjs,
            &var));

    // If there is common color, set it as default selection
    if (hr == S_OK)
    {
        Assert(V_VT(&var) == VT_I4);
        cc.rgbResult = ColorRefFromOleColor(V_I4(&var));
        // set it be the first custom color
        aclr[0] = cc.rgbResult;
    }

    cc.lStructSize      = sizeof(CHOOSECOLOR);
    cc.hwndOwner        = _hWndPage;
    cc.hInstance        = NULL;     // no template; this is ignored
    cc.Flags            = CC_RGBINIT;
    cc.lpCustColors     = aclr;
    cc.lpfnHook         = NULL;
    cc.lpTemplateName   = NULL;


    fRet = ChooseColor(&cc);

    if (fRet)
    {

        V_VT(&var) = VT_I4;
        V_I4(&var) = cc.rgbResult;

#ifndef NO_EDIT
        CParentUndoUnit * pCPUU;

        pCPUU = OpenParentUnit(this, IDS_UNDOPROPCHANGE);
#endif // NO_EDIT
        hr = THR(SetCommonPropertyValue(
                _pDPDCur->dispid,
                _aryObjs.Size(),
                _aryObjs,
                &var));

        // ISSUE: Is this still being called? New ShowLastErrorInfo
        // requires CDoc or CElement pointer.
        // ShowLastErrorInfo(NULL, hr);       
        Assert(FALSE);
#ifndef NO_EDIT
        hr = CloseParentUnit(pCPUU, hr);
#endif // NO_EDIT
    }
}
#endif // NO_PROPERTY_PAGE



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::Help
//
//  Synopsis:   NYI
//
//  Arguments:  [szHelpDir]
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::Help(LPCTSTR szHelpDir)
{
    RRETURN(E_NOTIMPL);
}





//+------------------------------------------------------------------------
//
//  Member:     CAllPage::TranslateAccelerator
//
//  Synopsis:   Handles the keyboard interface for the page.
//
//  Arguments:  [pmsg]      Message to translate
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CAllPage::TranslateAccelerator(LPMSG pmsg)
{
    if (_hWndPage && (pmsg->hwnd == _hWndPage || IsChild(_hWndPage, pmsg->hwnd)))
    {
        HRESULT     hr;

        if (pmsg->hwnd == _hWndList || IsChild(_hWndList, pmsg->hwnd))
        {
            hr = THR(_pPageSite->TranslateAccelerator(pmsg));
            if (hr != S_FALSE)
                return hr;
        }

        if (pmsg->message == WM_KEYDOWN &&
            pmsg->wParam == VK_DELETE && pmsg->hwnd == _hWndEdit )
        {
            // We use delete key to set NULL picture
            if (_pDPDCur && _pDPDCur->fSpecialCasePicture)
            {
                // Delete key is used to NULL picture
                SetWindowText(_hWndEdit, _T("NULL"));
                _fDirty = 1;
                Apply();
            }
        }
    }
    else if (pmsg->message == WM_KEYDOWN &&
             pmsg->wParam == VK_TAB &&
             GetKeyState(VK_CONTROL) >= 0)
    {
        HWND    hWndFoc;
        BOOL    fPrev = !!(GetKeyState(VK_SHIFT) & 0x8000);

        hWndFoc = GetNextDlgTabItem(
            _hWndPage,
            fPrev ? _hWndEdit : _hWndList,
            fPrev);

        if (hWndFoc)
        {
            SetFocus(hWndFoc);
            return S_OK;
        }
    }

    return S_FALSE;
}




//+------------------------------------------------------------------------
//
//  Member:     CAllPage::ReleaseObjects
//
//  Synopsis:   Releases the current set of objects.  Also releases the
//              current set of property descriptors and cached values.
//
//-------------------------------------------------------------------------

void
CAllPage::ReleaseObjects( )
{
    _aryObjs.ReleaseAll();

    ReleaseVars();
}



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::ReleaseVars
//
//  Synopsis:   Releases the current set of property descriptors and
//              cached values.
//
//-------------------------------------------------------------------------

void
CAllPage::ReleaseVars( )
{
    _pDPDCur = NULL;
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::UpdateList
//
//  Synopsis:   Update the owner-draw listbox with the property names.
//              Note that even though we do all the drawing for the list,
//              we still pass in strings, so that we can use the listbox
//              window's prefix matching.
//
//-------------------------------------------------------------------------

void
CAllPage::UpdateList( )
{
    int             i;
    DPD *           pDPD;
    int             index;
    CDataAry<DPD> * paryDPD;

    if (!_hWndPage)
        return;

    paryDPD = _pEngine->GetDPDs();

    for (i = 0, pDPD = *paryDPD;
         i < paryDPD->Size();
         i++, pDPD++)
    {
        // Do not display member not found property or read-only property
        if (pDPD->fMemberNotFound || pDPD->fReadOnly)
        {
            continue;
        }

        // If an item with the same name already exists in the list,
        // skip adding the duplicate
        // (Even though it refers to a different property, only the
        //  first instance seen "wins" and should be exposed)
        index = (int) SendMessage(
                            _hWndList,
                            LB_FINDSTRINGEXACT,
                            (WPARAM) -1,
                            (LPARAM) pDPD->bstrName);
        if (index != LB_ERR)
        {
            continue;
        }

        // Add the item to the list
        index = (int) SendMessage(
                            _hWndList,
                            LB_ADDSTRING,
                            0,
                            (LPARAM) pDPD->bstrName);
        if (index == LB_ERR)
            continue;

        SendMessage(_hWndList, LB_SETITEMDATA, (WPARAM) index, (LPARAM) i);
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::UpdateEngine
//
//  Synopsis:   Updates the engine based on the current prop value.
//
//-------------------------------------------------------------------------

void
CAllPage::UpdateEngine()
{
    HRESULT     hr;
    VARIANT     var;

    VariantInit(&var);

    if (_pDPDCur)
    {
        hr = THR(ParseValue(&var));
        if (hr)
            goto Cleanup;

        _pEngine->SetProperty(_pDPDCur->dispid, &var);
    }

    if (_hWndPage)
    {
        Assert(_hWndList);
        InvalidateRect(_hWndList, (GDIRECT *)NULL, FALSE);
    }

Cleanup:
    VariantClear(&var);
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::UpdateEditor
//
//  Synopsis:   Updates the editor window to match the currently selected
//              property.  This may require creating a new editor window,
//              filling any drop-down list, and always includes updating
//              the window's value.
//
//  Arguments:  [pDPDSource]    The source of the property update.
//                              If non-NULL, then the editor is assumed
//                              to match the property in all ways
//                              except the property value.
//
//-------------------------------------------------------------------------

void
CAllPage::UpdateEditor(DPD * pDPDSource)
{
    DPD *       pDPD;
    int         i, j;
    BOOL        fEnableEditor;
    EMODE       emode;
    DWORD       dwStyle;
    RECT        rcEdit;
    RECT        rcButton;
    EVAL *      pEVAL;
    HFONT       hFont;
    VARIANT     var;
    LPTSTR      szValue;
    TCHAR       ach[FORMS_BUFLEN + 1];
    LPTSTR      szValueEnum;
    TCHAR       achEnum[FORMS_BUFLEN + 1];
    CDataAry<DPD> *paryDPD = _pEngine->GetDPDs();

    _fInUpdateEditor = TRUE;

    pDPD = pDPDSource;
    if (!pDPD)
    {
        i = SendMessage(_hWndList, LB_GETCURSEL, 0, 0);
        if (i != LB_ERR)
        {
            j = SendMessage(_hWndList, LB_GETITEMDATA, i, 0);

            Assert(j >= 0);
            // ISSUE: ChrisF: remove assert on Julia's advise
            // but don't understand it !
            Assert(j < paryDPD->Size());

            pDPD = &(*paryDPD)[j];
        }
    }

    if (pDPD == NULL)
    {
        szValue = _T("");
        emode = EMODE_Edit;

        fEnableEditor = FALSE;
    }
    else
    {
        fEnableEditor = FormatValue(
                            &pDPD->var,
                            pDPD,
                            ach,
                            ARRAY_SIZE(ach),
                            &szValue);

        // Find out what the mode should be
        if (fEnableEditor && pDPD->pAryEVAL != NULL)
        {
            if (pDPD->fSpecialCaseColor)
            {
                emode = EMODE_ComboButton;
            }
            else
            {
                emode = EMODE_StaticCombo;
            }
        }
        else if(pDPD->fSpecialCasePicture || pDPD->fSpecialCaseFont )
        {
            emode = EMODE_EditButton;
        }
        else
        {
            emode = EMODE_Edit;
        }

    }

    ::GetWindowRect(_hWndEdit, &rcEdit);
    ScreenToClient(_hWndPage, (LPPOINT) &rcEdit.left);
    ScreenToClient(_hWndPage, (LPPOINT) &rcEdit.right);

    if (_hWndButton)
    {
        ::GetWindowRect(_hWndButton, &rcButton);
        ScreenToClient(_hWndPage, (LPPOINT) &rcButton.right);
        rcEdit.right = rcButton.right;
    }

    if (emode != _emode)
    {
        Assert(!pDPDSource);

        //
        // Destory old windows
        //

        SetWindowPos(
                _hWndEdit,
                NULL,
                0, 0, 0, 0,
                SWP_HIDEWINDOW | SWP_NOMOVE |
                    SWP_NOSIZE | SWP_NOZORDER | SWP_NOREDRAW);

        Verify(DestroyWindow(_hWndEdit));
        _hWndEdit = NULL;

        if (_hWndButton)
        {
            SetWindowPos(
                    _hWndButton,
                    NULL,
                    0, 0, 0, 0,
                    SWP_HIDEWINDOW | SWP_NOMOVE |
                        SWP_NOSIZE | SWP_NOZORDER | SWP_NOREDRAW);

            Verify(DestroyWindow(_hWndButton));
            _hWndButton = NULL;
        }

        //
        // Create new windows
        //
        if ((emode == EMODE_EditButton) || (emode == EMODE_ComboButton))
        {
            if (emode == EMODE_EditButton)
            {
                // Create read-only edit widnow
                dwStyle = WS_CHILD | WS_BORDER | WS_TABSTOP | ES_READONLY;
            }
            else
            {
                // Create dropdown combo widnow
                dwStyle = WS_CHILD | WS_BORDER | WS_TABSTOP | WS_VSCROLL |
                            CBS_AUTOHSCROLL | CBS_DROPDOWN;
            }

            _hWndEdit = CreateWindowEx(
                    WS_EX_CLIENTEDGE,
                    (emode == EMODE_EditButton)
#ifndef WIN16
                        ? _T("EDIT")
#else
                        ? "EDIT32"
#endif
                        : _T("COMBOBOX"),
                    szValue,
                    dwStyle,
                    rcEdit.left,
                    rcEdit.top,
                    rcEdit.right - rcEdit.left - _dyEdit,
                    _dyEdit,
                    _hWndPage,
                    (HMENU) IDE_PROPVALUE,
                    g_hInstCore,
                    NULL);

            // Create button
            dwStyle = WS_CHILD | WS_BORDER | WS_TABSTOP
                        | BS_PUSHBUTTON;

            _hWndButton = CreateWindowEx(
                    WS_EX_CLIENTEDGE,
                    _T("BUTTON") ,
                    _T("..."), //szValue,
                    dwStyle,
                    rcEdit.right - _dyEdit,
                    rcEdit.top,
                    _dyEdit,
                    _dyEdit,
                    _hWndPage,
                    (HMENU) IDB_OPENDLG,
                    g_hInstCore,
                    NULL);
        }
        else
        {
            if (emode == EMODE_Edit)
            {
                dwStyle = WS_CHILD | WS_BORDER | WS_TABSTOP | ES_AUTOHSCROLL;
            }
            else if (emode == EMODE_StaticCombo)
            {
                dwStyle = WS_CHILD | WS_BORDER | WS_TABSTOP | WS_VSCROLL |
                            CBS_AUTOHSCROLL | CBS_DROPDOWNLIST;
            }
            else
            {
                // For emode == EMODE_EditCombo
                dwStyle = WS_CHILD | WS_BORDER | WS_TABSTOP | WS_VSCROLL |
                            CBS_AUTOHSCROLL | CBS_DROPDOWN;
            }

            _hWndEdit = CreateWindowEx(
                    WS_EX_CLIENTEDGE,
                    (emode == EMODE_Edit)
#ifndef WIN16
                        ? _T("EDIT")
#else
                        ? "EDIT32"
#endif
                        : _T("COMBOBOX"),
                    szValue,
                    dwStyle,
                    rcEdit.left,
                    rcEdit.top,
                    rcEdit.right - rcEdit.left,
                    _dyEdit,
                    _hWndPage,
                    (HMENU) IDE_PROPVALUE,
                    g_hInstCore,
                    NULL);
        }

        hFont = (HFONT) SendMessage(_hWndList, WM_GETFONT, 0, 0);
        SendMessage(_hWndEdit, WM_SETFONT, (WPARAM) hFont, FALSE);

        _emode = emode;
    }

    if (!pDPDSource && IsComboMode(emode))
    {
        while (SendMessage(_hWndEdit, CB_DELETESTRING, 0, 0) > 0)
            ;

        VariantInit(&var);

        for (i = pDPD->pAryEVAL->Size(), pEVAL = *pDPD->pAryEVAL;
             i > 0;
             i--, pEVAL++)
        {
            var.vt = VT_I4;
            V_I4(&var) = pEVAL->value;

            FormatValue(
                    &var,
                    pDPD,
                    achEnum,
                    ARRAY_SIZE(achEnum),
                    &szValueEnum);

            SendMessage(_hWndEdit, CB_ADDSTRING, 0, (LPARAM) szValueEnum);

            //  Resize the dropdown appropriately

            SetWindowPos(
                    _hWndEdit,
                    NULL,
                    0, 0, 0, 0,
                    SWP_HIDEWINDOW | SWP_NOMOVE | SWP_NOZORDER |
                        SWP_NOSIZE | SWP_NOREDRAW);

            SetWindowPos(
                    _hWndEdit,
                    NULL,
                    0,
                    0,
                    (emode == EMODE_ComboButton)
                        ? rcEdit.right - rcEdit.left - _dyEdit
                        : rcEdit.right - rcEdit.left,
                    _dyEdit + HIWORD(GetDialogBaseUnits()) *
		    min((int)8, pDPD->pAryEVAL->Size()) + 2,    // IEUNIX : (long) -> (int) due to Size() change
                    SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOREDRAW);
        }
    }

    if (emode != EMODE_EditCombo && emode != EMODE_ComboButton )
    {
        SendMessage(
                _hWndEdit,
                IsComboMode(emode) ? CB_SELECTSTRING : WM_SETTEXT,
                0,
                (LPARAM) szValue);
    }
    else
    {
        // For EMODE_EditCombo, if value is in list, select it
        // Otherwise, set user defined value into editbox
        if (CB_ERR == SendMessage(
                _hWndEdit,
                 CB_SELECTSTRING ,
                0,
                (LPARAM) szValue))
        {
            SendMessage(
                    _hWndEdit,
                    WM_SETTEXT,
                    0,
                    (LPARAM) szValue);

        }
    }

    EnableWindow(_hWndEdit, fEnableEditor);
    ShowWindow(_hWndEdit, SW_SHOWNA);

    if (_hWndButton)
    {
        EnableWindow(_hWndButton, fEnableEditor);
        ShowWindow(_hWndButton, SW_SHOWNA);
    }

    _pDPDCur = pDPD;

    _fInUpdateEditor = FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CAllPage::IsComboMode
//
//  Synopsis:   Check if emode is for combo
//
//  Arguments:  EMDOE emode
//
//  Returns:    BOOL
//
//-------------------------------------------------------------------------

BOOL
CAllPage::IsComboMode(EMODE emode)
{
    if (emode == EMODE_EditCombo || emode == EMODE_StaticCombo ||
            emode == EMODE_ComboButton)
        return TRUE;
    else
        return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CAllPage::NameOfType
//
//  Synopsis:   Hard-wired lookup of type name based on VT
//
//  Arguments:  [pDPD]
//
//  Returns:    TCHAR *
//
//-------------------------------------------------------------------------

TCHAR *
CAllPage::NameOfType(DPD * pDPD)
{
    int     i;

    //  This page will not ship, and therefore does not need to
    //    be localized

    static struct tagTYPEANDNAME
    {
        VARTYPE vt;
        TCHAR * szName;
    }
    s_VarTypes[] =
    {
        VT_I2,          _T("I2"),
        VT_I4,          _T("I4"),
        VT_R4,          _T("R4"),
        VT_R8,          _T("R8"),
        VT_BOOL,        _T("BOOL"),
        VT_ERROR,       _T("ERROR"),
        VT_CY,          _T("CY"),
        VT_DATE,        _T("DATE"),
        VT_BSTR,        _T("BSTR"),
        VT_UNKNOWN,     _T("UNKNOWN"),
        VT_DISPATCH,    _T("DISPATCH"),
        VT_VARIANT,     _T("VARIANT"),
        VT_USERDEFINED, _T("USERDEF"),
        VT_FILETIME,    _T("FILETIME"),
        VT_NULL,        _T("NULL"),
        VT_PTR,         _T("POINTER"),
        0,              _T("error"),
    };

    for (i = 0; i < ARRAY_SIZE(s_VarTypes) - 1; i++)
    {
        if (pDPD->vt == s_VarTypes[i].vt)
            break;
    }

    return s_VarTypes[i].szName;
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::FormatValue
//
//  Synopsis:   Formats a value for display, either in the summary list
//              or in the editor.
//
//  Arguments:  [pvar]      Value to format
//              [pDPD]      Property descriptor
//              [ach]       Buffer to use if necessary
//              [cch]       ditto
//              [ppstr]     String pointer returned in *ppstr
//
//  Returns:    BOOL; FALSE if the editor window should be disabled.
//
//-------------------------------------------------------------------------

BOOL
CAllPage::FormatValue(
        VARIANT * pvar,
        DPD * pDPD,
        TCHAR * ach,
        int cch,
        TCHAR ** ppstr)
{
    int     i;
    EVAL *  pEVAL;
    TCHAR * pstrFriendly;
    TCHAR * pstr;
    int     value;
    HRESULT hr;
    BSTR    bstr    = NULL;

    if (pDPD->fMemberNotFound)
    {
        *ppstr = _T("");
        return FALSE;
    }

    if (pDPD->fSpecialCaseFont)
    {
        IFont *     pFont   = NULL;
        CY          cy;
        BOOL        fBold;
        BOOL        fItalic;
        BOOL        fUnderline;
        BOOL        fStrikethrough;

        if (pvar->vt == VT_UNKNOWN || pvar->vt == VT_DISPATCH)
        {
            IGNORE_HR(V_UNKNOWN(pvar)->QueryInterface(
                    IID_IFont,
                    (void **) &pFont));
        }

        if (pFont)
        {
            pFont->get_Name(&bstr);
            pFont->get_Size(&cy);
            pFont->get_Bold(&fBold);
            pFont->get_Italic(&fItalic);
            pFont->get_Underline(&fUnderline);
            pFont->get_Strikethrough(&fStrikethrough);

            Assert(cy.Hi == 0);

            Format( 0,
                    ach, cch,
                    _T("<0d>pt <1s><2s><3s><4s><5s>"),
                    (long) ((cy.Lo + 5000) / 10000),
                    bstr ? bstr: _T(""),
                    (fBold) ? _T(", Bold") : _T(""),
                    (fItalic) ? _T(", Italic") : _T(""),
                    (fUnderline) ? _T(", Underline") : _T(""),
                    (fStrikethrough) ? _T(", Strikethrough") : _T(""));

            *ppstr = ach;

            FormsFreeString(bstr);
            pFont->Release();
        }
        else
        {
            *ppstr = _T("(Error)");
        }
    }
    else if (pDPD->fSpecialCasePicture)
    {
        SHORT sPicType = PICTYPE_NONE;

        //
        // Because VB does not accept NULL value for picture property,
        // there is Empty picture with PICTTYPE_NONE type, so need
        // distingish it from real picture.
        //
        if (V_DISPATCH(&(pDPD->var)))
        {
            IPicture *  pPicture = NULL;
            if (!V_DISPATCH(&(pDPD->var))->QueryInterface(
                    IID_IPicture,
                    (void **) &pPicture))
            {
                pPicture->get_Type(&sPicType);
            }
            ReleaseInterface(pPicture);
        }

        if (sPicType == PICTYPE_NONE)
        {
            *ppstr = _T("(None)");
        }
        else
        {
            *ppstr = _T("(Picture)");
        }
    }
    else if (pDPD->pAryEVAL)
    {
        pstrFriendly = _T("Unknown");

        switch (pvar->vt)
        {
        case VT_BOOL:
        case VT_I2:
            value = V_I2(pvar);
            break;

        case VT_I4:
            value = V_I4(pvar);
            break;

        default:
            *ppstr = _T("Type mismatch");
            return FALSE;
        }

        for (i = pDPD->pAryEVAL->Size(), pEVAL = *pDPD->pAryEVAL;
             i > 0;
             i--, pEVAL++)
        {
            if (pEVAL->value == value)
            {
                pstrFriendly = pEVAL->bstr;
                break;
            }
        }

        Format(
                0,
                ach, cch,
                (pDPD->fSpecialCaseColor) ?
                    _T("<0x> - <1s>") :
                    _T("<0d> - <1s>"),
                (long)value,
                pstrFriendly);

        *ppstr = ach;
    }
    else
    {
        *ppstr = ach;

        switch (pvar->vt)
        {
        case VT_BSTR:
            *ppstr = V_BSTR(pvar);
            if (!*ppstr)
                *ppstr = _T("");
            break;

        case VT_I2:
            _ltot(V_I2(pvar), ach, 10);
            break;

        case VT_I4:
            _ltot(V_I4(pvar), ach, 10);
            break;

        case VT_R4:
            hr = THR(VarBstrFromR4(
                            V_R4(pvar),
                            g_lcidUserDefault,
                            0,
                            &bstr));
            if (hr)
            {
                *ppstr = _T("");
            }
            else
            {
                _tcsncpy(ach, bstr, cch);
                FormsFreeString(bstr);
            }
            break;

        case VT_R8:
            hr = THR(VarBstrFromR8(
                            V_R8(pvar),
                            g_lcidUserDefault,
                            0,
                            &bstr));
            if (hr)
            {
                *ppstr = _T("");
            }
            else
            {
                _tcsncpy(ach, bstr, cch);
                FormsFreeString(bstr);
            }
            break;

        case VT_CY:
#ifdef NEVER
            _ltot((int) (V_CY(pvar).int64 / 10000), ach, 10);
            pstr = _tcschr(ach, 0);
            _ltot((int) (V_CY(pvar).int64 % 10000) / 100 + 100, pstr, 10);
#endif // NEVER
            Assert(V_CY(pvar).Hi == 0);

            _ltot((int) (V_CY(pvar).Lo / 10000), ach, 10);
            pstr = _tcschr(ach, 0);
            _ltot((int) (V_CY(pvar).Lo % 10000) / 100 + 100, pstr, 10);

            *pstr = _T('.');
            break;

        case VT_BOOL:
            if (V_BOOL(pvar))
                *ppstr = _T("True");
            else
                *ppstr = _T("False");
            break;

        case VT_NULL:
            *ppstr = _T("");
            break;

        default:
            *ppstr = _T("");
            return FALSE;
        }
    }

    return TRUE;
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::ParseValue
//
//  Synopsis:   Parses the value currently in the editing window, based
//              on the property descriptor last used to fill in the
//              editor.
//
//  Arguments:  [pvar]      Parsed value returned in *pvar.  Note that
//                          pvar->vt may not match _pDPDCur->vt; this
//                          method relies on normal OLE Automation practice
//                          to coerce the value to its final type.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

#if defined(DEBUG) && !defined(MAC) 
STDAPI OleLoadPicturePath( LPOLESTR szUrl, LPUNKNOWN punkCaller, DWORD dwFlags,
                           OLE_COLOR clrBackgnd, REFIID, LPVOID * );
#endif

HRESULT
CAllPage::ParseValue(VARIANT * pvar)
{
    HRESULT     hr;
    int         i;
    int         cch;
    int         cch2;
    FONTDESC    fd;
    TCHAR *     pch;
    TCHAR *     pch2;
    TCHAR *     pchN;
    TCHAR *     pchString = NULL;

    if (_emode != EMODE_StaticCombo )
    {
        cch = SendMessage(_hWndEdit, WM_GETTEXTLENGTH, 0, 0);
        pchString = new(Mt(CAllPageParseValue_pchString)) TCHAR[cch + 1];
        if (pchString == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        SendMessage(
                _hWndEdit,
                WM_GETTEXT,
                cch + 1,
                (LPARAM) pchString);

        hr = E_INVALIDARG;

        if (_pDPDCur->fSpecialCaseFont)
        {
            pch = _tcsstr(pchString, _T("pt"));
            if (pch)
            {
                memset(&fd, 0, sizeof(FONTDESC));

                fd.cbSizeofstruct = sizeof(FONTDESC);
                fd.sWeight = 400;
                fd.sCharset = DEFAULT_CHARSET;

                *pch = 0;
#if !defined(_MAC) && !defined(UNIX)
                fd.cySize.int64 = _ttol(pchString) * 10000;
#else
                IGNORE_HR(ttol_with_error(pchString, (long *) &fd.cySize.Lo));
                fd.cySize.Lo *= 10000;
                fd.cySize.Hi = 0;
#endif
                pch += 2;
                pch += _tcsspn(pch, _T(" "));

                pch2 = _tcschr(pch, _T(','));
                if (pch2)
                    *pch2 = 0;

                fd.lpstrName = pch;

                while (pch2)
                {
                    pch2++;
                    pch2 += _tcsspn(pch2, _T(" "));
                    pchN  = _tcschr(pch2, _T(','));
                    cch2  = pchN ? pchN - pch2 : _tcslen(pch2);

                    if (_tcsnipre(_T("bold"), 4, pch2, cch2))
                    {
                        fd.sWeight = 700;
                    }
                    else if (_tcsnipre(_T("ital"), 4, pch2, cch2))
                    {
                        fd.fItalic = TRUE;
                    }
                    else if (_tcsnipre(_T("under"), 5, pch2, cch2))
                    {
                        fd.fUnderline = TRUE;
                    }
                    else if (_tcsnipre(_T("strike"), 6, pch2, cch2))
                    {
                        fd.fStrikethrough = TRUE;
                    }

                    pch2 = pchN;
                }

                hr = THR(OleCreateFontIndirect(
                        &fd,
                        IID_IFont,
                        (void **) &V_UNKNOWN(pvar)));
                if (!hr)
                    pvar->vt = VT_UNKNOWN;
            }
        }
        else if (_pDPDCur->fSpecialCasePicture)
        {
            IStream *   pStm;

            if (StrCmpIC(pchString, _T("NULL")) == 0)
            {
                pvar->vt = VT_UNKNOWN;
                V_UNKNOWN(pvar) = NULL;
                hr = S_OK;
            }
            else
            {
#if defined(DEBUG) && !defined(_MAC) && !defined(WINCE)
#define OPCTPATH_DEFAULTS    0 // SYNC | AUTHORTIME | OPAQUE
#define OPCTPATH_ASYCHRONOUS 1
#define OPCTPATH_RUNTIME     2
#define OPCTPATH_RESERVED1   4
                if (IsTagEnabled(tagAsyncPict))
                {
                    // exercise async picture loading thru the new API
                    pStm = pStm;
                    pch2 = new TCHAR[cch + 6];
                    if (pch2 == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Cleanup;
                    }
                    _tcscpy(pch2, _T("FILE:"));
                    _tcscat(pch2, pchString);

                    hr = THR(OleLoadPicturePath(
                            pch2,
                            NULL,
                            OPCTPATH_ASYCHRONOUS,
                            (OLE_COLOR)RGB(255,0,0),
                            IID_IPicture,
                            (void **) &V_UNKNOWN(pvar)));
                    delete[] pch2;
                    if (!hr)
                        pvar->vt = VT_UNKNOWN;
                }
                else
#endif // defined(DEBUG) && !defined(_MAC) && !defined(WINCE)
                {
                    hr = THR(CreateStreamOnFile(
                            pchString,
                            STGM_SHARE_DENY_WRITE,
                            &pStm));
                    if (!hr)
                    {
                        hr = THR(OleLoadPicture(
                                pStm,
                                0,
                                FALSE,
                                IID_IPicture,
                                (void **) &V_UNKNOWN(pvar)));
                        if (!hr)
                            pvar->vt = VT_UNKNOWN;

                        pStm->Release();
                    }
                }
            }
        }
        else if (_pDPDCur->fSpecialCaseColor)
        {
            // NULL string is not allowed for color value
            if (!*pchString)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            V_I4(pvar) = _tcstoul(pchString, NULL, 16);
            if (V_I4(pvar) != ULONG_MAX)
            {
                pvar->vt = VT_I4;
                hr = S_OK;
            }
        }
        else
        {
            // If property value is numberic, and there is nothing in editbox
            // set default value be 0.
            if (!_tcslen(pchString) && ( (_pDPDCur->vt == VT_I2) ||
                    (_pDPDCur->vt == VT_I4) || (_pDPDCur->vt == VT_R4) ||
                    (_pDPDCur->vt == VT_R8) ))
            {
                hr = THR(FormsAllocString(_T("0"), &V_BSTR(pvar)));
            }
            else
            {
                hr = THR(FormsAllocString(pchString, &V_BSTR(pvar)));
            }
            if (!hr)
            {
                pvar->vt = VT_BSTR;
            }
        }
    }
    else
    {
        //
        //  This assumes that the combobox edit field is read-only
        //  (ie, the combobox is CBS_DROPDOWNLIST).
        //
        i = SendMessage(_hWndEdit, CB_GETCURSEL, 0, 0);
        if (i == CB_ERR)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            pvar->vt = VT_I4;
            Assert(_pDPDCur && _pDPDCur->pAryEVAL);
            V_I4(pvar) = (*_pDPDCur->pAryEVAL)[i].value;

            hr = S_OK;
        }
    }

Cleanup:
    if ( pchString )
        delete[] pchString;
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::DrawItem
//
//  Synopsis:   Renders a line in the owner-draw listbox.
//
//  Arguments:  [pdis]
//
//-------------------------------------------------------------------------

void
CAllPage::DrawItem(DRAWITEMSTRUCT * pdis)
{
    DPD *       pDPD;
    DWORD       dw;
    int         cch;
    int         dxName;
    GDIRECT     rc;
    LPTSTR      szValue;
    TCHAR       ach[FORMS_BUFLEN + 1];
    CDataAry<DPD> *paryDPD = _pEngine->GetDPDs();
    ULONG       cElem = paryDPD->Size();
#ifdef _MAC
    HFONT       hfontOld=NULL;
#endif

    HPEN        hPen = NULL;
    HPEN        hPenOld = NULL;

    //
    // See if there's anything in the array.  If not then skip to exit
    // code, as the only thing that can happen here is to draw the
    // focus rect.
    //

    if (!cElem)
        goto ExitCode;

    dw = GetDialogBaseUnits();
    cch = (pdis->rcItem.right - pdis->rcItem.left) / LOWORD(dw);

    dxName = LOWORD(dw) * cch * 4 / 10;

    if (pdis->itemState & ODS_SELECTED)
    {
        SetTextColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        SetBkColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
    }
    else
    {
        SetTextColor(pdis->hDC, GetSysColor(COLOR_WINDOWTEXT));
        SetBkColor(pdis->hDC, GetSysColor(COLOR_WINDOW));
    }

    Assert(cElem > pdis->itemData);
    pDPD = &(*paryDPD)[pdis->itemData];

    if (pDPD->fMemberNotFound)
    {
        SetTextColor(pdis->hDC, GetSysColor(COLOR_GRAYTEXT));
    }
#ifdef _MAC
    if (_hfontDlg)
        hfontOld = (HFONT)SelectObject(pdis->hDC, _hfontDlg);
#endif
    rc = pdis->rcItem;
    rc.right = rc.left + dxName;

    ExtTextOut(
            pdis->hDC,
            rc.left  + 1,
            rc.top + 1,
            ETO_OPAQUE,
            &rc,
            pDPD->bstrName,
            FormsStringLen(pDPD->bstrName),
            NULL);

    // Create Grey Color Pen
    hPen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_GRAYTEXT));
    hPenOld = (HPEN) SelectObject(pdis->hDC, hPen);

    // Draw vertical grid line
    MoveToEx(pdis->hDC, rc.right, rc.top, (POINT *)NULL);
    LineTo(pdis->hDC, rc.right, rc.bottom);

    rc.left = rc.right + 1;
    rc.right = pdis->rcItem.right;

    if (pDPD->fNoMatch)
    {
        szValue = _T("(mixed)");
    }
    else if (pDPD->fMemberNotFound)
    {
        szValue = _T("(not found)");
    }
    else
    {
        FormatValue(
                &pDPD->var,
                pDPD,
                ach,
                ARRAY_SIZE(ach),
                &szValue);
    }

    ExtTextOut(
            pdis->hDC,
            rc.left  + 1,
            rc.top + 1,
            ETO_OPAQUE,
            &rc,
            szValue,
            _tcslen(szValue),
            NULL);

    // Draw horizontal grid line
    MoveToEx(pdis->hDC, pdis->rcItem.left, pdis->rcItem.bottom - 1, (POINT *)NULL);
    LineTo(pdis->hDC, pdis->rcItem.right, pdis->rcItem.bottom -1);

ExitCode:
    if (pdis->itemState & ODS_FOCUS)
        DrawFocusRect(pdis->hDC, &pdis->rcItem);
#ifdef _MAC
    if (hfontOld)
        SelectObject(pdis->hDC, hfontOld);
#endif

    SelectObject(pdis->hDC, hPenOld);
    DeleteObject(hPen);
}



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::SetDirty
//
//  Synopsis:   Changes the dirty status for the page.
//
//  Arguments:  [dw]        Combination of PROPPAGESTATUS_* values
//
//-------------------------------------------------------------------------

void
CAllPage::SetDirty(DWORD dw)
{
    _fDirty = (dw & PROPPAGESTATUS_DIRTY) != 0;
#ifndef PRODUCT_96
    _pPageSite->OnStatusChange(dw | PROPPAGESTATUS_DIRTY);
#endif
}



//+------------------------------------------------------------------------
//
//  Member:     CAllPage::OnSize
//
//  Synopsis:   Called when the page changes size; the size of child
//              control is adjusted to match.
//
//-------------------------------------------------------------------------

void
CAllPage::OnSize( )
{
    RECT    rc;
    RECT    rcList;
    RECT    rcEdit;
    int     cy;
    CDataAry<DPD> *paryDPD = _pEngine->GetDPDs();

    GetClientRect(_hWndPage, &rc);

    ::GetWindowRect(_hWndList, &rcList);
    ScreenToClient(_hWndPage, (LPPOINT) &rcList.left);
    ScreenToClient(_hWndPage, (LPPOINT) &rcList.right);

    ::GetWindowRect(_hWndEdit, &rcEdit);
    ScreenToClient(_hWndPage, (LPPOINT) &rcEdit.left);
    ScreenToClient(_hWndPage, (LPPOINT) &rcEdit.right);

    MoveWindow(
            _hWndList,
            rcList.left,
            rcList.top,
            (rc.right - rc.left) - 2 * rcList.left,
            (rc.bottom - rc.top) - rcList.top - rcEdit.top,
            TRUE);

    //  Since the columns are proportionately sized, we need to
    //    invalidate on the size done above

    Assert(_hWndList);
    InvalidateRect(_hWndList, (GDIRECT *)NULL, FALSE);

    // Now move on to resizing the editor
    cy = rcEdit.bottom - rcEdit.top;    //(it equals _dyEdit)
    if (IsComboMode(_emode))
    {
        DPD *   pDPD = NULL;
        int     i;
        int     j;

        // If this is in combo box mode then add the size of the list
        // to the y axis
        i = SendMessage(_hWndList, LB_GETCURSEL, 0, 0);
        if (i != LB_ERR)
        {
            j = SendMessage(_hWndList, LB_GETITEMDATA, i, 0);

            Assert((j >= 0) && (j < paryDPD->Size()));
            pDPD = &(*paryDPD)[j];
        }

        Assert(NULL != pDPD);
        // Allow a max of 8 items on the combo box.
        cy += HIWORD(GetDialogBaseUnits()) * min((int)8, pDPD->pAryEVAL->Size()) + 2;
    }

    if (!_hWndButton)
    {
        MoveWindow(
                _hWndEdit,
                rcEdit.left,
                rcEdit.top,
                (rc.right - rc.left) - rcList.left - rcEdit.left,
                cy,
                TRUE);
    }
    else
    {
        MoveWindow(
                _hWndEdit,
                rcEdit.left,
                rcEdit.top,
                (rc.right - rc.left) - rcList.left - rcEdit.left - _dyEdit,
                cy,
                TRUE);

        MoveWindow(
                _hWndButton,
                rc.right- rc.left - rcList.left - _dyEdit,
                rcEdit.top,
                _dyEdit,
                _dyEdit,
                TRUE);
    }

    //  Combo boxes do not invalidate correctly when resized, so
    //    we need to force the invalidation manually

    Assert(_hWndEdit);
    RedrawWindow(
            _hWndEdit,
            (GDIRECT *)NULL,
            NULL,
            RDW_ERASE | RDW_FRAME | RDW_INVALIDATE | RDW_ALLCHILDREN);
}


//+------------------------------------------------------------------------
//
//  Member:     CAllPage::Refresh
//
//  Synopsis:   Clear old values and update new values in both listbox and
//              Edit window. If dispid is DISPID_UNKNOW, update everything,
//              otherwise, update specify proprety.
//
//  Arguments:  [dispid]
//
//-------------------------------------------------------------------------

HRESULT
CAllPage::Refresh(DISPID dispid)
{
    UpdateEditor(NULL);

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Function:   PageWndProc
//
//  Synopsis:   Page window proc.
//
//  Arguments:  [hWnd]
//              [msg]
//              [wParam]
//              [lParam]
//
//  Returns:    long
//
//-------------------------------------------------------------------------

INT_PTR CALLBACK
PageWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CAllPage *  pAllPg = (CAllPage *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    switch (msg)
    {
#ifdef _MAC
    case WM_MACINTOSH:
        switch (LOWORD(wParam))
        {
            case WLM_SETMENUBAR:
            // dont change the menu bar
                return TRUE;
        }
        break;
#endif
    case WM_INITDIALOG:
        SetWindowLongPtr(hWnd, GWLP_USERDATA, lParam);

        pAllPg = (CAllPage *)lParam;
        pAllPg->_hWndEdit = GetDlgItem(hWnd, IDE_PROPVALUE);
        pAllPg->_hWndList = GetDlgItem(hWnd, IDC_PROPNAME);

        if (pAllPg->_hWndList)
        {
            // NOTE: we could put a Verify() around this line, but it may fail
            // if "no-one" has the focus currently.
            ::SetFocus(pAllPg->_hWndList);
        }
        break;

#ifndef WINCE
    case WM_NCDESTROY:
#else
    case WM_DESTROY:
#endif
        pAllPg->_hWndPage =
        pAllPg->_hWndEdit =
        pAllPg->_hWndButton =
        pAllPg->_hWndList = NULL;
        break;

    case WM_DRAWITEM:
        pAllPg->DrawItem((DRAWITEMSTRUCT *) lParam);
        return TRUE;

    case WM_SIZE:
        pAllPg->OnSize();
        break;

   case WM_SHOWWINDOW:
        // Only do something if the message is sent because of
        // a call to the ShowWindow function;
        if (! (int)lParam)
        {
            if (wParam)
            {
                IGNORE_HR(pAllPg->UpdatePage());
            }
            else
            {
                pAllPg->ReleaseVars();
            }
        }
        break;

    case WM_DEFERUPADTE:
        if (IsWindowVisible(hWnd))
        {
            pAllPg->Refresh(0);
        }
        break;

    case WM_CBSELCHANGED:
        pAllPg->UpdateEngine();
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_ID(wParam, lParam) == IDC_PROPNAME)
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case LBN_SELCHANGE:
                pAllPg->UpdateEditor(NULL);
                pAllPg->UpdateEngine();
                break;

            case LBN_DBLCLK:
                if (pAllPg->_pDPDCur)
                {
                    switch (pAllPg->_emode)
                    {
                    case CAllPage::EMODE_Edit:
                        // set focus to the edit window and select all to start typing
                        SetFocus(pAllPg->_hWndEdit);
                        SendMessage(pAllPg->_hWndEdit, EM_SETSEL, 0, -1);
                        break;

                    case CAllPage::EMODE_StaticCombo:
                    case CAllPage::EMODE_EditCombo:
                        // advance the combo list to the next enum element, wrapping around 0
                        {
                            long cnt = SendMessage(pAllPg->_hWndEdit, CB_GETCOUNT, 0, 0);
                            long sel = SendMessage(pAllPg->_hWndEdit, CB_GETCURSEL, 0, 0);
                            if (sel != CB_ERR)
                            {
                                if (++sel >= cnt)
                                    sel = 0;
                                SendMessage(pAllPg->_hWndEdit, CB_SETCURSEL, sel, 0);
                                goto ComboSelectChanged;
                            }
                        }
                        break;

                    case CAllPage::EMODE_EditButton:
                    case CAllPage::EMODE_ComboButton:
                        // do the button action (bring up the picker)
                        pAllPg->OnButtonClick();
                        break;
                    }
                }
                break;
            }
        }
        else if (GET_WM_COMMAND_ID(wParam, lParam) == IDE_PROPVALUE &&
                 !pAllPg->_fInUpdateEditor)
        {
            if (pAllPg->_emode == CAllPage::EMODE_Edit)
            {
                switch (GET_WM_COMMAND_CMD(wParam, lParam))
                {
                case EN_CHANGE:
                    pAllPg->UpdateEngine();
                    pAllPg->SetDirty(PROPPAGESTATUS_DIRTY);
                    break;
                }
            }
            else
            {
                switch (GET_WM_COMMAND_CMD(wParam, lParam))
                {
                case CBN_EDITCHANGE:
                    pAllPg->UpdateEngine();
                    pAllPg->SetDirty(PROPPAGESTATUS_DIRTY);
                    break;

ComboSelectChanged:
                case CBN_SELCHANGE:
                    pAllPg->SetDirty(PROPPAGESTATUS_DIRTY | PROPPAGESTATUS_VALIDATE);
                    PostMessage(pAllPg->_hWndPage, WM_CBSELCHANGED, 0, 0);
                    break;
                }
            }
        }
        else if (GET_WM_COMMAND_ID(wParam, lParam) == IDB_APPLY)
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case BN_CLICKED:
                pAllPg->Apply();
                break;
            }
        }
        else if (GET_WM_COMMAND_ID(wParam, lParam) == IDB_OPENDLG)
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case BN_CLICKED:
                pAllPg->OnButtonClick();
                break;
            }
        }
        break;
    }

    return FALSE;
}


#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\moniker\simgprot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       resprot.cxx
//
//  Contents:   Implementation of the sysimage protocol
//
//  History:    06-15-98    dli     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_RESPROT_HXX_
#define X_RESPROT_HXX_
#include "simgprot.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_ROSTM_HXX_
#define X_ROSTM_HXX_
#include "rostm.hxx"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#include <shellapi.h>  // for the definition of ShellExecuteA (for AXP)
#endif

#ifndef X_SHLWAPIP_H_
#define X_SHLWAPIP_H_
#include "shlwapip.h"  // for the definition of Shell_GetCachedImageIndexWrap
#endif

// The following data structures are standard icon file structures
typedef struct tagICONDIRENTRY
{
    BYTE    cx;
    BYTE    cy;
    BYTE    nColors;
    BYTE    iUnused;
    WORD    xHotSpot;
    WORD    yHotSpot;
    DWORD   cbDIB;
    DWORD   offsetDIB;
} ICONDIRENTRY;

typedef struct tagICONDIR
{
    WORD iReserved;
    WORD iResourceType;
    WORD cresIcons;
} ICONDIR;


MtDefine(CSysimageProtocol, Protocols, "CSysimageProtocol")
MtDefine(CSysimageProtocolDoParseAndBind_pb, Protocols, "CSysimageProtocol::DoParseAndBind pb")
MtDefine(CSysimageProtocolDoParseAndBind_pbMask, Protocols, "CSysimageProtocol::DoParseAndBind pbMask")

//+---------------------------------------------------------------------------
//
//  Function:   CreateSysimageProtocol
//
//  Synopsis:   Creates a resource Async Pluggable protocol
//
//  Arguments:  pUnkOuter   Controlling IUnknown
//
//----------------------------------------------------------------------------

CBase * 
CreateSysimageProtocol(IUnknown *pUnkOuter)
{
    return new CSysimageProtocol(pUnkOuter);
}

CSysimageProtocolCF   g_cfSysimageProtocol(CreateSysimageProtocol);

//+---------------------------------------------------------------------------
//
//  Method:     CrackSysimageUrl
//
//  Synopsis:   Breaks res: URL into its component strings.
//              NOTE: pcstrSysimageType is allowed to be NULL.
//                    The caller needs only to pass in CStr*'s for the
//                    components they want.
//
//
//  Arguments:  pchURL          Url of the following syntax:
//
//              sysimage://<filename>[,icon index]>[/<small> | <large>]
//
//              pcstrModule     CStr to hold <dll name and location> or the sys_image_list_index
//                              The path may not contain '/' characters
//              pcstrSysimageType    CStr to hold <resource type>
//              pcstrRID        CStr to hold <resource id>
//
//----------------------------------------------------------------------------

HRESULT
CrackSysimageUrl(const TCHAR* pchURL, CStr* pcstrModule, CStr* pcstrSize, CStr* pcstrSelected)
{
    HRESULT         hr = S_OK;
    TCHAR *         pch = NULL;
    TCHAR *         pchNext = NULL;
    TCHAR           achURL[pdlUrlLen];
    DWORD           cchURL;
    //    BOOL            bGetIndex = FALSE;
            
    Assert (pchURL && _tcsnipre(_T("sysimage:"), 9, pchURL, -1));

    if (pcstrSize)
        hr = THR(pcstrSize->Set(_T("")));

    if (pcstrSelected)
        hr = THR(pcstrSelected->Set(_T("")));
    

    // Unescape the URL.
    hr = THR(CoInternetParseUrl(
            pchURL,
            PARSE_ENCODE,
            0,
            achURL,
            ARRAY_SIZE(achURL),
            &cchURL,
            0));
    if (hr)
        goto Cleanup;

    pch = _tcschr(achURL, _T(':'));
    if (!pch)
    {
        goto SyntaxError;
    }

    if (!(_tcsnipre(_T("://"), 3, pch, -1)))
    {
        goto SyntaxError;
    }

    pch += 3;

    //
    // Now look for the executable name
    //

    // we currently do not support index, yet
    //    pchNext = _tcschr(pch, _T(','));
    //    if (!pchNext)
    //    {
    pchNext = _tcschr(pch, _T('/'));
    if (!pchNext)
        goto SyntaxError;
    //    }
    //    else
    //        bGetIndex = TRUE;

    if (pcstrModule)
    {
        hr = THR(pcstrModule->Set(pch, pchNext - pch));
        if (hr)
            goto Cleanup;
    }


    // skip the '/'
    pchNext++;
    
    if (pcstrSize)
    {
        hr = THR(pcstrSize->Set(pchNext));
        if (hr)
            goto Cleanup;
    }

 /*  Add this in when we support index
  if (pchNext)
    {
        // Yes
        //
        // We've found a second '/', which means that the URL
        // contains the <small> | <large> indicator
        //
        if (pcstrSize)
        {
            hr = THR(pcstrSize->Set(pch, pchNext - pch));
            if (hr)
                goto Cleanup;
        }

        // Do we need the selected info?
        if (pcstrSelected)
        {
            // Yes, search for the next '/'
            pch = pchNext + 1;
            pchNext = _tcschr(pch, _T('/'));

            // Found one
            if (pchNext)
            {
                hr = THR(pcstrSize->Set(pch, pchNext - pch));
                if (hr)
                    goto Cleanup;
            }
        }
    }*/

Cleanup:
    RRETURN(hr);

SyntaxError:
    hr = MK_E_SYNTAX;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSysimageProtocolCF::ParseUrl
//
//  Synopsis:   per IInternetProtocolInfo
//
//----------------------------------------------------------------------------

#define FILEPROT_PREFIX_LEN 7

HRESULT
CSysimageProtocolCF::ParseUrl(
    LPCWSTR     pwzUrl,
    PARSEACTION ParseAction,
    DWORD       dwFlags,
    LPWSTR      pwzResult,
    DWORD       cchResult,
    DWORD *     pcchResult,
    DWORD       dwReserved)
{
    HRESULT hr = INET_E_DEFAULT_ACTION;

    if (!pcchResult || !pwzResult)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (ParseAction == PARSE_SECURITY_URL)
    {
        CStr            cstrModule;
        DWORD           cchNewUrlLen;
        TCHAR           achFullResourceName [pdlUrlLen];
        
        *pcchResult = FILEPROT_PREFIX_LEN;

        hr = THR(CrackSysimageUrl (pwzUrl, &cstrModule, NULL, NULL));
        if (hr)
            goto Cleanup;
        
#ifndef WIN16
        {
            CStrIn  strinResName ((LPWSTR)cstrModule);
            CStrOut stroutFile (achFullResourceName, pdlUrlLen);
            char *  pstrFileName;

            cchNewUrlLen = ::SearchPathA (NULL,
                                          strinResName,
                                          NULL,
                                          pdlUrlLen,
                                          stroutFile,
                                          &pstrFileName);
        }
#else
        {
            char *  pstrFileName;
            cchNewUrlLen = ::SearchPathA (NULL,
                                          cstrModule,
                                          NULL,
                                          pdlUrlLen,
                                          achFullResourceName,
                                          &pstrFileName);
        }
#endif // WIN16

        //
        // The returned path is now stored as a TCHAR in achFullResourceName.
        //

        if (!cchNewUrlLen)
        {
            hr = MK_E_SYNTAX;
            goto Cleanup;
        }

        *pcchResult += cchNewUrlLen + 1; // total mem needed includes \0 terminator

        if (*pcchResult > pdlUrlLen)
        {
            hr = MK_E_SYNTAX;
            goto Cleanup;
        }

        if (*pcchResult > cchResult)
        {
            hr = S_FALSE;
            goto Cleanup;
        }

        _tcsncpy(pwzResult, _T("file://"), FILEPROT_PREFIX_LEN);
        _tcscpy(pwzResult + FILEPROT_PREFIX_LEN, achFullResourceName);

        Assert (_tcslen(pwzResult) + 1 == *pcchResult);
    }
    else
    {
        hr = THR_NOTRACE(super::ParseUrl(
                                         pwzUrl,
                                         ParseAction,
                                         dwFlags,
                                         pwzResult,
                                         cchResult,
                                         pcchResult,
                                         dwReserved));
    }

Cleanup:
    RRETURN2(hr, INET_E_DEFAULT_ACTION, S_FALSE);
}


const CBase::CLASSDESC CSysimageProtocol::s_classdesc =
{
    &CLSID_SysimageProtocol,             // _pclsid
};


//+---------------------------------------------------------------------------
//
//  Method:     CSysimageProtocol::CSysimageProtocol
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CSysimageProtocol::CSysimageProtocol(IUnknown *pUnkOuter) : super(pUnkOuter)
{
    TCHAR szWindows[MAX_PATH];
    SHFILEINFO sfi = {0};
    GetWindowsDirectory(szWindows, ARRAY_SIZE(szWindows));
    _himglSmall = (HIMAGELIST)SHGetFileInfo(szWindows, 0, &sfi, sizeof(sfi), SHGFI_SYSICONINDEX | SHGFI_SMALLICON);
    _himglLarge = (HIMAGELIST)SHGetFileInfo(szWindows, 0, &sfi, sizeof(sfi), SHGFI_SYSICONINDEX | SHGFI_LARGEICON);
}


//+---------------------------------------------------------------------------
//
//  Method:     CSysimageProtocol::~CSysimageProtocol
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CSysimageProtocol::~CSysimageProtocol()
{
}


//+---------------------------------------------------------------------------
//
//  Method:     CSysimageProtocol::Start
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CSysimageProtocol::Start(
    LPCWSTR pchUrl, 
    IInternetProtocolSink *pTrans, 
    IInternetBindInfo *pOIBindInfo,
    DWORD grfSTI, 
    HANDLE_PTR dwReserved)
{
    HRESULT         hr = NOERROR;
    DWORD           dwSize;
    TCHAR *pchBuf = new TCHAR[pdlUrlLen];

    if (pchBuf == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    Assert(!_pProtSink && pOIBindInfo && pTrans && !_cstrURL);

    if ( !(grfSTI & PI_PARSE_URL))
    {
        ReplaceInterface(&_pProtSink, pTrans);
        ReplaceInterface(&_pOIBindInfo, pOIBindInfo);
    }

    _bindinfo.cbSize = sizeof(BINDINFO);
    hr = THR(pOIBindInfo->GetBindInfo(&_grfBindF, &_bindinfo));

    //
    // First get the basic url.  Unescape it first.
    //

    hr = THR(CoInternetParseUrl(pchUrl, PARSE_ENCODE, 0, pchBuf, pdlUrlLen, &dwSize, 0));
    if (hr)
        goto Cleanup;

    hr = THR(_cstrURL.Set(pchBuf));
    if (hr)
        goto Cleanup;

    //
    // Now append any extra data if needed.
    //

    if (_bindinfo.szExtraInfo)
    {
        hr = THR(_cstrURL.Append(_bindinfo.szExtraInfo));
        if (hr)
            goto Cleanup;
    }

    _grfSTI = grfSTI;

    //
    // If forced to go async, return E_PENDING now, and
    // perform binding when we get the Continue.
    //

    if (grfSTI & PI_FORCE_ASYNC)
    {
        PROTOCOLDATA    protdata;

        hr = E_PENDING;
        protdata.grfFlags = PI_FORCE_ASYNC;
        protdata.dwState = BIND_ASYNC;
        protdata.pData = NULL;
        protdata.cbData = 0;

        _pProtSink->Switch(&protdata);
    }
    else
    {
        hr = THR(ParseAndBind());
    }


Cleanup:
    if (pchBuf != NULL)
        delete pchBuf;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CSysimageProtocol::ParseAndBind
//
//  Synopsis:   Actually perform the binding & execution of script.
//
//----------------------------------------------------------------------------

HRESULT
CSysimageProtocol::ParseAndBind()
{
    RRETURN(DoParseAndBind(_cstrURL, _cstrModule, _cstrSize, _cstrSelected, &_pStm, this));
}


void
CSysimageProtocol::_ReportData(ULONG cb)
{
    _bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
    _pProtSink->ReportData(_bscf, cb, cb);
}


//+---------------------------------------------------------------------------
//
//  Method:     CSysimageProtocol::DoParseAndBind
//
//  Synopsis:   Static helper to actually perform the binding of protocol.
//
//  Arguments:  pchURL          Url to bind to [needed]
//              cstrRID         Resource id extracted from url [needed]
//              cstrModule     Resource dll name extracted from url [needed]
//              ppStm           Stream of data from resource [needed]
//              pProt           Protocol object that's involved [optional]
//
//----------------------------------------------------------------------------

HRESULT
CSysimageProtocol::DoParseAndBind(
    TCHAR *pchURL, 
    CStr &cstrModule,
    CStr &cstrSize,
    CStr &cstrSelected,                                  
    IStream **ppStm,
    CSysimageProtocol *pProt)
{
    HRESULT         hr = S_OK;
    TCHAR *         pchBuf = NULL;
    CROStmOnBuffer *prostm = NULL;
    ULONG           cbmi=0;
    ULONG           cb=0;
    ULONG           cbM=0;
    BYTE *          pb = NULL;
    BYTE *          pbMask = NULL;
//    TCHAR *         pch = NULL;
    SHFILEINFO      sfi = {0};
    DWORD           dwShgfi = 0;
    UNALIGNED void * pvdBitsXOR = NULL;
    UNALIGNED void * pvdBitsAND = NULL;
    HDC             hdcT  = NULL;
    UNALIGNED BITMAPINFO *    pbmi = NULL;
    BITMAPINFO *    pbmiMask = NULL;
    ICONDIR *       pifh = NULL;
    ICONINFO        iconinfo = {0};
    BITMAP          bm = {0};
    BITMAP          bmMask = {0};
    DWORD           cbDib;
    DWORD           cbMask;
    UNALIGNED ICONDIRENTRY *  pide;
    int             nColors = 0;
    TCHAR           achFullModuleName [MAX_PATH];
    TCHAR        *  pstrFileName;
    int             iIconIndex = 0;
    
    // for icon # feature
    // int             iModuleIndex;

    hr = THR(CrackSysimageUrl (pchURL, &cstrModule, &cstrSize, &cstrSelected));
    if (hr)
        goto Cleanup;

    // got to have a real module to load icon from
    Assert((TCHAR *)cstrModule);

    if (cstrModule.Length() >= MAX_PATH)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // determine the icon size to load 
    dwShgfi = SHGFI_ICON | SHGFI_SHELLICONSIZE;
    if (cstrSize.Length())
    {
        if (_tcsequal(cstrSize, _T("small")))
            dwShgfi |= SHGFI_SMALLICON;
        if (_tcsequal(cstrSize, _T("large")))
            dwShgfi |= SHGFI_LARGEICON;
    }

    iIconIndex = PathParseIconLocation(cstrModule);
    
    // get the full path of the module, in case of failure, use the windows directory
    if (0 == SearchPath(NULL, cstrModule, NULL, MAX_PATH, achFullModuleName, &pstrFileName))
    {
        GetWindowsDirectory(achFullModuleName, ARRAY_SIZE(achFullModuleName));
        iIconIndex = 0;
    }
    
    // get the icon
    if (iIconIndex != 0)
    {
        iIconIndex = Shell_GetCachedImageIndexWrap(achFullModuleName, iIconIndex, 0);
        sfi.hIcon = ImageList_GetIcon((dwShgfi & SHGFI_SMALLICON) ? pProt->_himglSmall : pProt->_himglLarge, iIconIndex, 0);
    }
    else
        SHGetFileInfo((TCHAR *)achFullModuleName, 0, &sfi, sizeof(sfi), dwShgfi);

    if (!sfi.hIcon)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // get icon info
    if (!GetIconInfo(sfi.hIcon, &iconinfo) && iconinfo.fIcon)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // get bitmap information on this icon 
    if (!GetObject(iconinfo.hbmColor, sizeof(bm), &bm) || !GetObject(iconinfo.hbmMask, sizeof(bmMask), &bmMask))
    {
    hr = E_FAIL;
        goto Cleanup;
    }

    // if this the most efficient way to round up to 4?
    cbDib = (bm.bmWidthBytes + 3) / 4 * 4 * bm.bmHeight;
    cbMask = (bmMask.bmWidthBytes + 3) / 4 * 4 * bm.bmHeight;

    // Compute the number of colors using BitsPixel only if BitsPixel is no
    // greater than 8 
    if (bm.bmBitsPixel <= 8)
        nColors = 1 << bm.bmBitsPixel;

    // Allocate the maximum possible memory 
    cbmi = sizeof( BITMAPINFOHEADER ) + nColors * sizeof( RGBQUAD );
    cb = cbDib + cbMask + cbmi + sizeof(ICONDIR) + sizeof(ICONDIRENTRY);

    pb = new(Mt(CSysimageProtocolDoParseAndBind_pb)) BYTE [cb];
    
    if (!pb)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    cbM = sizeof(BITMAPINFOHEADER) + (2 * sizeof(RGBQUAD)); // we need two quads for 1 bit color     	 
    pbMask = new(Mt(CSysimageProtocolDoParseAndBind_pbMask)) BYTE [cbM];
    
    if (!pbMask)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    pbmiMask = (BITMAPINFO *) pbMask;

    // zero initialize
    ZeroMemory(pb, cb);
    ZeroMemory(pbMask, cbM);
    
    // Set up the icon file header
    pifh = (ICONDIR *)pb;
    pifh->iReserved = 0;
    pifh->iResourceType = 1;
    pifh->cresIcons = 1;

    // ICONDIRENTRY
    pide = (UNALIGNED ICONDIRENTRY *)(pb + sizeof(ICONDIR)); 
    pide->cx = bm.bmWidth;
    pide->cy = bm.bmHeight;
    pide->nColors = (BYTE)nColors;
    pide->cbDIB = cbDib;
    pide->offsetDIB = sizeof(ICONDIR) + sizeof(ICONDIRENTRY);

    // BITMAPINFOHEADER
    pbmi = (UNALIGNED BITMAPINFO *)(pb + sizeof(ICONDIR) + sizeof(ICONDIRENTRY));
    pbmi->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth         = bm.bmWidth;
    pbmi->bmiHeader.biHeight         = bm.bmHeight;
    pbmi->bmiHeader.biPlanes         = 1;
    pbmi->bmiHeader.biBitCount       = bm.bmBitsPixel;

    pvdBitsXOR = (UNALIGNED void *)(pb + sizeof(ICONDIR) + sizeof(ICONDIRENTRY) + cbmi);
    hdcT = CreateCompatibleDC(NULL);
    {
        // we have to cook up an aligned BITMAPINFO and lpvoid for GetDIBits to fill, then copy the results over
        BITMAPINFO  *   pbmiTemp = NULL;
        void        *   pvdBitsXORTemp = NULL;

        pbmiTemp = (BITMAPINFO *)MemAlloc( Mt(CSysimageProtocolDoParseAndBind_pb), cbmi );
        if( !pbmiTemp )
        {
            hr = E_OUTOFMEMORY;
            goto Error1;
        }

        pvdBitsXORTemp = MemAlloc( Mt(CSysimageProtocolDoParseAndBind_pb), cbDib );
        if( !pvdBitsXORTemp )
        {
            hr = E_OUTOFMEMORY;
            goto Error1;
        }

        // Set up our temporary aligned copies of people
        memcpy( pbmiTemp, pbmi, cbmi );
        ZeroMemory( pvdBitsXORTemp, cbDib );

        if (!GetDIBits(hdcT, iconinfo.hbmColor, 0, bm.bmHeight, pvdBitsXORTemp, pbmiTemp, DIB_RGB_COLORS))
        {
            hr = S_FALSE;
            goto Error1;
        }

        // Copy the results back
        memcpy( pbmi, pbmiTemp, cbmi );
        memcpy( pvdBitsXOR, pvdBitsXORTemp, cbDib );

Error1:
        MemFree( pbmiTemp );
        MemFree( pvdBitsXORTemp );
        if( hr )
        {
            hr = ( hr == S_FALSE ) ? S_OK : hr;
            goto Cleanup;
        }
    }
    
    pvdBitsAND = (BYTE *)pvdBitsXOR + cbDib;
    *pbmiMask = *pbmi;
    pbmiMask->bmiHeader.biBitCount = 1;
    {
        // we have to cook up an aligned BITMAPINFO and lpvoid for GetDIBits to fill, then copy the results over
        BITMAPINFO  *   pbmiMaskTemp = NULL;
        void        *   pvdBitsANDTemp = NULL;

        pbmiMaskTemp = (BITMAPINFO *)MemAlloc( Mt(CSysimageProtocolDoParseAndBind_pb), cbM );
        if( !pbmiMaskTemp )
        {
            hr = E_OUTOFMEMORY;
            goto Error2;
        }

        pvdBitsANDTemp = MemAlloc( Mt(CSysimageProtocolDoParseAndBind_pb), cbMask );
        if( !pvdBitsANDTemp )
        {
            hr = E_OUTOFMEMORY;
            goto Error2;
        }

        // Set up our temporary aligned copies of people
        memcpy( pbmiMaskTemp, pbmiMask, cbM );
        ZeroMemory( pvdBitsANDTemp, cbMask );

        if (!GetDIBits(hdcT, iconinfo.hbmMask, 0, bmMask.bmHeight, pvdBitsANDTemp, pbmiMaskTemp, DIB_RGB_COLORS))
        {
            hr = S_FALSE;
            goto Error2;
        }

        // Copy the results back
        memcpy( pbmiMask, pbmiMaskTemp, cbM );
        memcpy( pvdBitsAND, pvdBitsANDTemp, cbMask );

Error2:
        MemFree( pbmiMaskTemp );
        MemFree( pvdBitsANDTemp );
        if( hr )
        {
            hr = ( hr == S_FALSE ) ? S_OK : hr;
            goto Cleanup;
        }
    }

    // set the height to be twice the real image height, this is icon file standard
    pbmi->bmiHeader.biHeight = bm.bmHeight * 2;

    // tell URLMON we have an ICON image
    pchBuf = (TCHAR *)pb;
    hr = THR(pProt->_pProtSink->ReportProgress(BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE, TEXT("image/x-icon")));
    if (hr)
        goto Cleanup;

    // cb includes the null terminator
    prostm = new CROStmOnBuffer;
    if (!prostm)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(prostm->Init((BYTE *)pchBuf, cb));
    if (hr)
        goto Cleanup;

    *ppStm = (IStream *)prostm;
    (*ppStm)->AddRef();

Cleanup:
    if (pProt)
    {
        if (!pProt->_fAborted)
        {
            if (!hr && cb > 0)
            {   
                pProt->_ReportData(cb);
            }
            if (pProt->_pProtSink)
            {
                pProt->_pProtSink->ReportResult(hr, 0, 0);
            }
        }
    }

    if (hdcT)
        DeleteDC(hdcT);

    if (prostm)
    {
        prostm->Release();
    }

    delete [] pb;
    delete [] pbMask;
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\proppage\commit.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Micros oft Corporation, 1996
//
//  File:       commit.cxx
//
//  Contents:   Implementation of the proppage commit engine
//
//  History:    07-05-96  AnandRa   Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_COMMIT_HXX_
#define X_COMMIT_HXX_
#include "commit.hxx"
#endif

#ifndef X_PROPUTIL_HXX_
#define X_PROPUTIL_HXX_
#include "proputil.hxx"
#endif

MtDefine(EnsureCommitHolder_paryHolder, Dialogs, "EnsureCommitHolder paryHolder")
MtDefine(EnsureCommitHolder_paryHolder_pv, Dialogs, "EnsureCommitHolder paryHolder::_pv")
MtDefine(CCommitHolder, Dialogs, "CCommitHolder")
MtDefine(CCommitHolder_aryEngine_pv, CCommitHolder, "CCommitHolder::_aryEngine::_pv")
MtDefine(CCommitEngine, Dialogs, "CCommitEngine")
MtDefine(CCommitEngine_aryObjs_pv, CCommitEngine, "CCommitEngine::_aryObjs::_pv")
MtDefine(CCommitEngine_aryDPD_pv, CCommitEngine, "CCommitEngine::_aryDPD::_pv")
MtDefine(CCommitEngine_dpdBool_pAryEVAL, CCommitEngine, "CCommitEngine::_dpdBool.pAryEVAL")
MtDefine(CCommitEngine_dpdBool_pAryEVAL_pv, CCommitEngine, "CCommitEngine::_dpdBool.pAryEVAL_pv")
MtDefine(CCommitEngine_dpdColor_pAryEVAL, CCommitEngine, "CCommitEngine::_dpdColor.pAryEVAL")
MtDefine(CCommitEngine_dpdColor_pAryEVAL_pv, CCommitEngine, "CCommitEngine::_dpdColor.pAryEVAL_pv")
MtDefine(CCommitEngineParseUserDefined_pDPD_pAryEVAL, Dialogs, "CCommitEngine::ParseUserDefined pDPD->pAryEVAL")
MtDefine(CCommitEngineParseUserDefined_pDPD_pAryEVAL_pv, Dialogs, "CCommitEngine::ParseUserDefined pDPD->pAryEVAL::_pv")

void    
DeinitCommitHolder(THREADSTATE *pts)
{
    if (pts->prop.paryCommitHolder)
    {
        delete pts->prop.paryCommitHolder;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     EnsureCommitHolder
//
//  Synopsis:   Creator of commit holder
//
//  Arguments:  dwID    Some identification of the object
//                      requesting the ensure.  This id is the same
//                      across all objects wanting to link to the 
//                      same commit holder.
//
//  Notes:      Property pages that want to sync contents need to call
//              this function very early on.  This is because some frames
//              may delay calling functions such as SetObjects and
//              Activate until late.  Typically this is done as soon
//              as the pagesite is set on the proppage.
//
//-------------------------------------------------------------------------

HRESULT 
EnsureCommitHolder(DWORD_PTR dwID, CCommitHolder **ppHolder)
{
    HRESULT                     hr = S_OK;
    CPtrAry<CCommitHolder *> *  paryHolder = TLS(prop.paryCommitHolder);
    CCommitHolder *             pHolderNew = NULL;
    long                        i;

    if (!paryHolder)
    {
        paryHolder = new(Mt(EnsureCommitHolder_paryHolder)) CPtrAry<CCommitHolder *>(Mt(EnsureCommitHolder_paryHolder_pv));
        if (!paryHolder)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        TLS(prop.paryCommitHolder) = paryHolder;
    }
    
    Assert(paryHolder);

    //
    // Check the global holders first and see if the id's match.
    // If so, then we can bail out right here.
    //

    for (i = 0; i < paryHolder->Size(); i++)
    {
        if ((*paryHolder)[i]->_dwID == dwID)
        {
            (*paryHolder)[i]->AddRef();
            *ppHolder = (*paryHolder)[i];
            goto Cleanup;
        }
    }

    //
    // If we're here then either there is no holder in global memory or
    // there is a global holder but someone wants to 
    // create another holder.  Either way, we can just forget about
    // the existing global commit holder.
    //
    
    pHolderNew = new CCommitHolder(dwID);
    if (!pHolderNew)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    hr = THR(paryHolder->Append(pHolderNew));
    if (hr)
        goto Error;
        
    *ppHolder = pHolderNew;
    
Cleanup:
    RRETURN(hr);

Error:
    delete pHolderNew;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitHolder::CCommitHolder
//
//  Synopsis:   ctor
//
//-------------------------------------------------------------------------

CCommitHolder::CCommitHolder(DWORD_PTR dwID)
    : _aryEngine(Mt(CCommitHolder_aryEngine_pv))
{
    _aryEngine.SetSize(0);
    _ulRefs = 1;
    _dwID = dwID;
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitHolder::~CCommitHolder
//
//  Synopsis:   dtor
//
//-------------------------------------------------------------------------

CCommitHolder::~CCommitHolder()
{
    CPtrAry<CCommitHolder *> *  paryHolder = TLS(prop.paryCommitHolder);
    long                        i;
    
    Assert(paryHolder);

    for (i = 0; i < _aryEngine.Size(); i++)
    {
        delete _aryEngine[i];
    }
    
    _aryEngine.DeleteAll();
    paryHolder->DeleteByValue(this);
}


//+---------------------------------------------------------------------------
//
//  Member:     CCommitHolder::AddRef
//
//  Synopsis:   Ref counting
//
//----------------------------------------------------------------------------

ULONG
CCommitHolder::AddRef()
{
    return ++_ulRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCommitHolder::Release
//
//  Synopsis:   Ref counting
//
//----------------------------------------------------------------------------

void
CCommitHolder::Release()
{
    if (--_ulRefs == 0)
    {
        delete this;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitHolder::GetEngine
//
//  Synopsis:   Get a commit engine based on objects being set.
//
//  Arguments:  cObj        Count of objects
//              ppDisp      Array of dispatch ptrs
//              ppEngine    Engine that is returned.
//
//-------------------------------------------------------------------------

HRESULT
CCommitHolder::GetEngine(
    long cObj, 
    IDispatch **ppDisps, 
    CCommitEngine **ppEngine)
{
    CCommitEngine **    ppEng = NULL;
    long                i;
    IUnknown *          pUnk = NULL;
    IUnknown *          pUnkObj = NULL;
    long                cEngObjs;
    HRESULT             hr = S_OK;
    
    Assert( ppEngine != NULL );
    *ppEngine = NULL;  // for safety.

    // 
    // First search among existing engines to see if one fits the bill
    //

    for (i = _aryEngine.Size(), ppEng = _aryEngine; i > 0; i--, ppEng++)
    {
        cEngObjs = (*ppEng)->_aryObjs.Size();
        if (cEngObjs > 0)
        {
            //
            // It is sufficient to just check only the first dispatch
            // coming in because some set of objects can only be
            // in one commit engine.  
            //
            
            Verify(!(*ppEng)->_aryObjs[0]->QueryInterface(
                IID_IUnknown, 
                (void **)&pUnk));
            Verify(!(*ppDisps)->QueryInterface(IID_IUnknown, (void **)&pUnkObj));
            if (pUnk == pUnkObj)
            {
                //
                // Yay!  We found a match, bail out.
                //
                
                *ppEngine = *ppEng;
                goto Cleanup;
            }
        }
        ClearInterface(&pUnk);
        ClearInterface(&pUnkObj);
    }

    //
    // The fact that we got here implies that no suitable commit engine
    // was found.  So create one up and return it.
    //

    Assert(!*ppEngine);
    *ppEngine = new CCommitEngine();
    if (!*ppEngine)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    hr = THR(_aryEngine.Append(*ppEngine));
    if (hr)
        goto Error;

    hr = THR((*ppEngine)->SetObjects(cObj, ppDisps));
    if (hr)
        goto Error;
        
Cleanup:
    ClearInterface(&pUnk);
    ClearInterface(&pUnkObj);
    RRETURN(hr);

Error:
    if (_aryEngine.Find(*ppEngine) != -1)
        _aryEngine.DeleteByValue(*ppEngine);
    delete *ppEngine;
    *ppEngine = NULL;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     DPD::AppendEnumValue
//
//  Synopsis:   Adds a new enumerated value to the list maintained by
//              this property descriptor.
//
//  Arguments:  [pstr]      Friendly name
//              [value]     Value
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
DPD::AppendEnumValue(TCHAR * pstr, int value)
{
    HRESULT hr;
    EVAL    eval;

    Assert(pAryEVAL);
    Assert(fOwnEVAL);

    hr = THR(FormsAllocString(pstr, &eval.bstr));
    if (!hr)
    {
        eval.value = value;

        hr = THR(pAryEVAL->AppendIndirect(&eval));
        if (hr)
            FormsFreeString(eval.bstr);
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     DPD::Free
//
//  Synopsis:   Frees any resources attached to this property descriptor
//
//-------------------------------------------------------------------------

void
DPD::Free( )
{
    int     i;
    EVAL *  pEVAL;

    FormsFreeString(bstrName);
    bstrName = NULL;
    FormsFreeString(bstrType);
    bstrType = NULL;

    VariantClear(&var);
    if (fOwnEVAL && pAryEVAL)
    {
        for (i = pAryEVAL->Size(), pEVAL = *pAryEVAL;
             i > 0;
             i--, pEVAL++)
        {
            FormsFreeString(pEVAL->bstr);
        }

        delete pAryEVAL;
        pAryEVAL = NULL;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::CCommitEngine
//
//  Synopsis:   ctor
//
//-------------------------------------------------------------------------

CCommitEngine::CCommitEngine()
    : _aryObjs(Mt(CCommitEngine_aryObjs_pv)),
      _aryDPD(Mt(CCommitEngine_aryDPD_pv))
{
    long    i;
    
    //  TODO: May want to do this in SetObjects, so we can return errors...

    static EVALINIT s_aevalBool[] =
    {
        { _T("True"), -1 },
        { _T("False"), 0 },
    };

    static EVALINIT s_aevalColor[] =
    {
        { _T("Scrollbar"), OLECOLOR_FROM_SYSCOLOR(0) },
        { _T("Background"), OLECOLOR_FROM_SYSCOLOR(1) },
        { _T("Active Caption"), OLECOLOR_FROM_SYSCOLOR(2) },
        { _T("Inactive Caption"), OLECOLOR_FROM_SYSCOLOR(3) },
        { _T("Menu"), OLECOLOR_FROM_SYSCOLOR(4) },
        { _T("Window"), OLECOLOR_FROM_SYSCOLOR(5) },
        { _T("Window Frame"), OLECOLOR_FROM_SYSCOLOR(6) },
        { _T("Menu Text"), OLECOLOR_FROM_SYSCOLOR(7) },
        { _T("Window Text"), OLECOLOR_FROM_SYSCOLOR(8) },
        { _T("Caption Text"), OLECOLOR_FROM_SYSCOLOR(9) },
        { _T("Active Border"), OLECOLOR_FROM_SYSCOLOR(10) },
        { _T("Inactive Border"), OLECOLOR_FROM_SYSCOLOR(11) },
        { _T("App Work Space"), OLECOLOR_FROM_SYSCOLOR(12) },
        { _T("Highlight"), OLECOLOR_FROM_SYSCOLOR(13) },
        { _T("Highlight Text"), OLECOLOR_FROM_SYSCOLOR(14) },
        { _T("Button Face"), OLECOLOR_FROM_SYSCOLOR(15) },
        { _T("Button Shadow"), OLECOLOR_FROM_SYSCOLOR(16) },
        { _T("Gray Text"), OLECOLOR_FROM_SYSCOLOR(17) },
        { _T("Button Text"), OLECOLOR_FROM_SYSCOLOR(18) },
        { _T("Inactive Caption Text"), OLECOLOR_FROM_SYSCOLOR(19) },
        { _T("Button Highlight"), OLECOLOR_FROM_SYSCOLOR(20) },
        { _T("3D Dark"), OLECOLOR_FROM_SYSCOLOR(21) },
        { _T("3D Light"), OLECOLOR_FROM_SYSCOLOR(22) },
        { _T("Info Text"), OLECOLOR_FROM_SYSCOLOR(23) },
        { _T("Info Background"), OLECOLOR_FROM_SYSCOLOR(24) },
    };

    _aryObjs.SetSize(0);
    _aryDPD.SetSize(0);
    memset(&_dpdBool, 0, sizeof(DPD));
    _dpdBool.pAryEVAL = new(Mt(CCommitEngine_dpdBool_pAryEVAL)) CDataAry<EVAL>(Mt(CCommitEngine_dpdBool_pAryEVAL_pv));
    _dpdBool.fOwnEVAL = TRUE;

    for (i = 0; i < ARRAY_SIZE(s_aevalBool); i++)
    {
        IGNORE_HR(_dpdBool.AppendEnumValue(
                s_aevalBool[i].pstr,
                s_aevalBool[i].value));
    }

    memset(&_dpdColor, 0, sizeof(DPD));
    _dpdColor.pAryEVAL = new(Mt(CCommitEngine_dpdColor_pAryEVAL)) CDataAry<EVAL>(Mt(CCommitEngine_dpdColor_pAryEVAL_pv));
    _dpdColor.fOwnEVAL = TRUE;

    for (i = 0; i < ARRAY_SIZE(s_aevalColor); i++)
    {
        IGNORE_HR(_dpdColor.AppendEnumValue(
                s_aevalColor[i].pstr,
                s_aevalColor[i].value));
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::~CCommitEngine
//
//  Synopsis:   dtor
//
//-------------------------------------------------------------------------

CCommitEngine::~CCommitEngine()
{
    ReleaseObjects();
    _dpdBool.Free();
    _dpdColor.Free();
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::SetObjects
//
//  Synopsis:   Set the objects for this commit engine
//
//  Arguments:  cObj        Count of objects
//              ppDisp      Array of dispatch ptrs
//
//-------------------------------------------------------------------------

HRESULT
CCommitEngine::SetObjects(long cObj, IDispatch **ppDisps)
{
    long        i;
    IDispatch **ppDisp;
    HRESULT     hr;
    
    if (_aryObjs.Size() != 0)
    {
#if DBG == 1
        //
        // The incoming objects better be the same as the ones
        // we have.
        //

        IDispatch **    ppDisp2;
        IUnknown *      pUnk;
        IUnknown *      pUnk2;
        
        Assert(cObj == _aryObjs.Size());
        for (i = cObj, ppDisp = _aryObjs, ppDisp2 = ppDisps;
                i > 0; i--, ppDisp++, ppDisp2++)
        {
            Verify(!(*ppDisp)->QueryInterface(IID_IUnknown, (void **)&pUnk));
            Verify(!(*ppDisp2)->QueryInterface(IID_IUnknown, (void **)&pUnk2));
            Assert(pUnk == pUnk2);
            ReleaseInterface(pUnk);
            ReleaseInterface(pUnk2);
        }
#endif

        return S_OK;
    }

    //
    // First cache a ptr to the dispatches handed in
    //
   
    hr = THR(_aryObjs.EnsureSize(cObj));
    if (hr)
        goto Cleanup;
        
    for (i = cObj, ppDisp = ppDisps; i > 0; i--, ppDisp++)
    {
        hr = THR(_aryObjs.Append(*ppDisp));
        if (hr)
            goto Error;

        (*ppDisp)->AddRef();
    }

    //
    // Now interrogate the dispatches to fill up the property
    // descriptor list.
    //
    
    hr = THR(CreatePropertyDescriptor());
    if (hr)
        goto Error;

    UpdateValues();
        
Cleanup:
    RRETURN(hr);

Error:
    _aryObjs.ReleaseAll();
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::ReleaseObjects
//
//  Synopsis:   Frees the objects for this commit engine
//
//-------------------------------------------------------------------------

HRESULT
CCommitEngine::ReleaseObjects()
{
    _aryObjs.ReleaseAll();
    RRETURN(ReleasePropertyDescriptor());
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::Commit
//
//  Synopsis:   Commit any dirty properties into the object(s) below.
//
//-------------------------------------------------------------------------

HRESULT
CCommitEngine::Commit()
{
    long        i;
    DPD *       pDPD;
    HRESULT     hr = S_OK;
    
    for (i = _aryDPD.Size(), pDPD = _aryDPD; i > 0; i--, pDPD++)
    {
        if (pDPD->fReadOnly)
            continue;

        if (pDPD->fDirty)
        {
            if ( pDPD -> fSpecialCaseUnitMeasurement )
            {
                hr = THR(SetCommonSubObjectPropertyValue(
                        pDPD->dispid,
                        3, // Should be dispid of unit meas sub-object Text property
                        _aryObjs.Size(),
                        _aryObjs,
                        &(pDPD->var)));
            }
            else
            {
                hr = THR(SetCommonPropertyValue(
                        pDPD->dispid,
                        _aryObjs.Size(),
                        _aryObjs,
                        &(pDPD->var)));
            }
            if (hr)
                goto Cleanup;

            pDPD->fDirty = 0;
        }
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::GetProperty
//
//  Synopsis:   Get the value of some property
//
//  Arguments:  dispid      Dispid to query
//              pvar        Resultant variant
//
//-------------------------------------------------------------------------

HRESULT
CCommitEngine::GetProperty(DISPID dispid, VARIANT *pvar)
{
    long        i;
    DPD *       pDPD;
    HRESULT     hr = S_OK;

    //
    // First find property descriptor
    //
    
    for (i = _aryDPD.Size(), pDPD = _aryDPD; i > 0; i--, pDPD++)
    {
        if (pDPD->dispid == dispid)
            break;
    }

    if (i <= 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Now get property
    //

    VariantInit(pvar);
    hr = THR(VariantCopy(pvar, &(pDPD->var)));
    
Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::SetProperty
//
//  Synopsis:   Set the value of some property
//
//  Arguments:  dispid      Dispid to query
//              pvar        Variant coming in
//
//-------------------------------------------------------------------------

HRESULT
CCommitEngine::SetProperty(DISPID dispid, VARIANT *pvar)
{
    long        i;
    DPD *       pDPD;
    HRESULT     hr = S_OK;
    
    //
    // First find property descriptor
    //
    
    for (i = _aryDPD.Size(), pDPD = _aryDPD; i > 0; i--, pDPD++)
    {
        if (pDPD->dispid == dispid)
            break;
    }

    if (i <= 0 || pDPD->fReadOnly)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Now set property and mark as dirty
    //

    VariantClear(&(pDPD->var));
    hr = THR(VariantCopy(&(pDPD->var), pvar));
    if (hr)
        goto Cleanup;

    pDPD->fDirty = 1;
    
Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::CreatePropertyDescriptor
//
//  Synopsis:   Create property descriptor list based on set objects
//
//-------------------------------------------------------------------------

HRESULT
CCommitEngine::CreatePropertyDescriptor()
{
    BSTR                        bstr;
    DPD *                       pDPD = NULL;
    DPD *                       pDPD2;
    UINT                        ucNames;
    int                         i, j, k;
    ULONG                       iTI, cTI;
    IDispatch **                ppDisp;
    IProvideMultipleClassInfo * pPMCI   = NULL;
    ITypeInfo *                 pTI     = NULL;
    TYPEATTR *                  pTA     = NULL;
    VARDESC *                   pVD     = NULL;
    FUNCDESC *                  pFD     = NULL;
    HRESULT                     hr      = S_OK;
    BOOL                        fGot;
    BOOL                        fReadOnly = FALSE;

    Assert(_aryDPD.Size() == 0);

    for (i = 0, ppDisp = _aryObjs;
         i < _aryObjs.Size();
         i++, ppDisp++)
    {
        // Determine if the object supports multiple ITypeInfos
        hr = THR_NOTRACE((*ppDisp)->QueryInterface(
                                       IID_IProvideMultipleClassInfo,
                                       (void **)&pPMCI));
        if (!hr)
        {
            hr = THR(pPMCI->GetMultiTypeInfoCount(&cTI));
            if (hr)
                goto Error;
        }
        else
        {
            cTI = 1;
        }

        // If this is not the first object (in the selection), mark each property
        // as "not seen" so those which are not common between all objects may
        // be removed
        if (i > 0)
        {
            for (k = _aryDPD.Size(), pDPD = _aryDPD;
                 k > 0;
                 k--, pDPD++)
            {
                pDPD->fVisit = FALSE;
            }
        }

        // For each ITypeInfo, retrieve the appropriate members
        for (iTI=0; iTI < cTI; iTI++)
        {
            // If the object supports multiple ITypeInfos, retrieve the ITypeInfo by index
            if (pPMCI)
            {
                ITypeInfo * pTICoClass;

                hr = THR(pPMCI->GetInfoOfIndex(iTI,
                                               MULTICLASSINFO_GETTYPEINFO,
                                               &pTICoClass,
                                               NULL, NULL, NULL, NULL));
                if (hr)
                {
                    hr = S_OK;
                    continue;
                }

                hr = THR(GetTypeInfoFromCoClass(pTICoClass, FALSE, &pTI, NULL));
                ReleaseInterface(pTICoClass);
                if (hr)
                    goto Error;
            }

            // Otherwise, obtain the ITypeInfo available through IDispatch
            else
            {
                Assert(cTI == 1);
                Assert(iTI == 0);
                hr = THR((*ppDisp)->GetTypeInfo(0, g_lcidUserDefault, &pTI));
                if (hr)
                {
                    hr = S_OK;
                    continue;
                }
            }

            hr = THR(pTI->GetTypeAttr(&pTA));
            if (hr)
                goto Error;

            if ((pTA->cVars == 0) && (pTA->cFuncs == 0))
                continue;

            // If this is on the first object (in the selection), ensure the array
            // is large enough to hold all the elements
            // (If the object supports multiple ITypeInfos, the array will be grown
            //  by the amount each ITypeInfo contributes)
            if (i == 0)
            {
                int cDPD = _aryDPD.Size();

                hr = THR(_aryDPD.EnsureSize(cDPD + pTA->cVars + pTA->cFuncs));
                if (hr)
                    goto Error;

                pDPD = (DPD *)_aryDPD + cDPD;
            }

            // First, obtain all property descriptions
            for (j = 0; j < pTA->cVars; j++)
            {
                hr = THR(pTI->GetVarDesc(j, &pVD));
                if (hr)
                    goto Error;

                // Do not display non-browsable, or hidden properties
                if (!(pVD->wVarFlags & (VARFLAG_FNONBROWSABLE |
                                        VARFLAG_FHIDDEN)))
                {
                    hr = THR(pTI->GetNames(pVD->memid, &bstr, 1, &ucNames));
                    if (hr)
                        goto Error;

                    if (i == 0)
                    {
                        memset(pDPD, 0, sizeof(DPD));

                        pDPD->dispid = pVD->memid;
                        pDPD->vt = (VARENUM) pVD->elemdescVar.tdesc.vt;
                        pDPD->bstrName = bstr;
                        pDPD->fReadOnly = (pVD->wVarFlags & VARFLAG_FREADONLY) ?
                                (TRUE) : (FALSE);
                        VariantInit(&pDPD->var);

                        if (pDPD->vt == VT_BOOL)
                        {
                            pDPD->pAryEVAL = _dpdBool.pAryEVAL;
                        }
                        else if (pDPD->vt == VT_USERDEFINED || pDPD->vt == VT_PTR)
                        {
                            hr = THR(ParseUserDefined(pTI, pVD, pDPD, TRUE));
                            if (hr)
                            {
                                pDPD->Free();
                                goto Cleanup;
                            }
                        }
                        else if (pDPD->vt == VT_UNKNOWN)
                        {
                            hr = THR ( ParseUnknown(pTI, pDPD) );
                            if ( hr )
                            {
                                pTI->ReleaseVarDesc(pVD);
                                continue;
                            }
                        }

                        pDPD++;
                        _aryDPD.SetSize(_aryDPD.Size() + 1);
                    }
                    else
                    {
                        for (k = _aryDPD.Size(), pDPD = _aryDPD;
                             k > 0;
                             k--, pDPD++)
                        {
                            if (pDPD->dispid == pVD->memid &&
                                pDPD->vt == (VARENUM) pVD->elemdescVar.tdesc.vt &&
                                !FormsStringCmp(pDPD->bstrName, bstr))
                            {
                                pDPD->fVisit = TRUE;
                                break;
                            }
                        }

                        FormsFreeString(bstr);
                    }
                }
                pTI->ReleaseVarDesc(pVD);
                pVD = NULL;
            }

            // Next, obtain all property function descriptions
            for ( ; j < pTA->cVars + pTA->cFuncs; j++)
            {
                hr = THR(pTI->GetFuncDesc(j - pTA->cVars, &pFD));
                if (hr)
                    goto Error;

                fReadOnly = (pFD->invkind == INVOKE_PROPERTYGET) ?
                        (TRUE) : (FALSE);
                fGot = FALSE;

                // Do We have a sub-object
				if (!(pFD->wFuncFlags & 
                        (FUNCFLAG_FRESTRICTED|FUNCFLAG_FNONBROWSABLE|FUNCFLAG_FHIDDEN)) &&
					pFD->funckind == FUNC_DISPATCH &&
					pFD->invkind  == INVOKE_PROPERTYGET &&
					pFD->elemdescFunc.tdesc.vt == VT_PTR &&
					pFD->elemdescFunc.tdesc.lptdesc->vt == VT_USERDEFINED )
                {
                    fGot = TRUE;
                }
                else if// Do not display non-browsable or hidden properties
                    ((pFD->invkind == INVOKE_PROPERTYPUT   ||
                        pFD->invkind == INVOKE_PROPERTYGET ||
                        pFD->invkind == INVOKE_PROPERTYPUTREF ) &&
                        !(pFD->wFuncFlags & (FUNCFLAG_FNONBROWSABLE |
                                         FUNCFLAG_FHIDDEN)))
                {
                    DISPID  dispid = pFD->memid;

                    pTI->ReleaseFuncDesc(pFD);
                    pFD = NULL;

                    // Locate the "get" method for the property
                    hr = FindReadPropFuncDesc(
                                    pTI,
                                    dispid,
                                    j - pTA->cVars + 1,
                                    pTA->cFuncs,
                                    &pFD);
                    // If no "get" method exists, skip the property
                    if (!hr)
                    {
                        fGot = TRUE;
                    }
                }

                if ( fGot )
                {
                    hr = THR(pTI->GetNames(pFD->memid, &bstr, 1, &ucNames));
                    if (hr)
                        goto Error;

                    if (i == 0)
                    {
                        memset(pDPD, 0, sizeof(DPD));

                        pDPD->dispid = pFD->memid;
                        pDPD->fReadOnly = fReadOnly;
#if 1
                        pDPD->vt = (VARENUM) pFD->elemdescFunc.tdesc.vt;
#else
                        if(pFD->funckind == FUNC_PUREVIRTUAL)
                        {
                            pDPD->vt = (VARENUM) pFD->lprgelemdescParam->tdesc.lptdesc->vt;
                        }
                        else
                        {
                            pDPD->vt = (VARENUM) pFD->elemdescFunc.tdesc.vt;
                        }
#endif
                        pDPD->bstrName = bstr;
                        VariantInit(&pDPD->var);

                        if (pDPD->dispid == DISPID_FONT)
                            i = 0;

                        if (pDPD->vt == VT_BOOL)
                        {
                            pDPD->pAryEVAL = _dpdBool.pAryEVAL;
                        }
                        else if (pDPD->vt == VT_USERDEFINED || pDPD->vt == VT_PTR)
                        {
                            hr = THR(ParseUserDefined(pTI, pFD, pDPD, FALSE));
                            if (hr)
                            {
                                pDPD->Free();
                                goto Cleanup;
                            }
                        }
                        else if (pDPD->vt == VT_UNKNOWN)
                        {
                            ParseUnknown(pTI, pDPD);
                        }

                        pDPD++;
                        _aryDPD.SetSize(_aryDPD.Size() + 1);
                    }
                    else
                    {
                        for (k = _aryDPD.Size(), pDPD = _aryDPD;
                             k > 0;
                             k--, pDPD++)
                        {
                            if (pDPD->dispid == pFD->memid &&
                                pDPD->vt == (VARENUM) pFD->elemdescFunc.tdesc.vt &&
                                !FormsStringCmp(pDPD->bstrName, bstr))
                            {
                                pDPD->fVisit = TRUE;
                                break;
                            }
                        }

                        FormsFreeString(bstr);
                    }
                }

                pTI->ReleaseFuncDesc(pFD);
                pFD = NULL;
            }

            pTI->ReleaseTypeAttr(pTA);
            pTA = NULL;

            ClearInterface(&pTI);
        }

        // Remove entries which do not occur on all objects in the selection
        if (i > 0)
        {
            for (k = _aryDPD.Size(), pDPD2 = pDPD = _aryDPD;
                 k > 0;
                 k--, pDPD++)
            {
                if (pDPD->fVisit)
                {
                    if (pDPD != pDPD2)
                        memcpy(pDPD2, pDPD, sizeof(DPD));

                    pDPD2++;
                }
                else
                {
                    pDPD->Free();
                    _aryDPD.SetSize(_aryDPD.Size() - 1);
                }
            }
        }

        ClearInterface(&pPMCI);
    }

Cleanup:
    if (pTA)
        pTI->ReleaseTypeAttr(pTA);
    if (pVD)
        pTI->ReleaseVarDesc(pVD);
    if (pFD)
        pTI->ReleaseFuncDesc(pFD);
    ReleaseInterface(pTI);
    ReleaseInterface(pPMCI);

    RRETURN(hr);

Error:
    ReleasePropertyDescriptor();
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::ParseUserDefined
//
//  Synopsis:   Parses a user-defined type in an object's TypeInfo.  Called
//              from ExamineObjects.
//
//  Arguments:  [pTIObject]     Object's TypeInfo
//              [pVDObject]     VARDESC for user-defined prop
//              [pDPD]          Descriptor to fill in
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CCommitEngine::ParseUserDefined(
        ITypeInfo * pTIObject,
        void * pv,
        DPD * pDPD,
        BOOL fVar)
{
    HRESULT             hr;
    TYPEDESC *          ptdesc;
    ITypeInfo *         pTI     = NULL;
    TYPEATTR *          pTA     = NULL;
    VARDESC *           pVD     = NULL;
    BSTR                bstr    = NULL;
    CDataAry<EVAL> *    pAryEVAL;
    int                 i;
    EVAL                eval;

//#ifndef _MAC
#if 1
    ptdesc = fVar ? &((VARDESC *) pv)->elemdescVar.tdesc :
                    &((FUNCDESC *) pv)->elemdescFunc.tdesc;
    if (ptdesc->vt == VT_PTR)
#else
    ptdesc = fVar ? &((VARDESC *) pv)->elemdescVar.tdesc :
                    &((FUNCDESC *) pv)->lprgelemdescParam->tdesc;
    while (ptdesc->vt == VT_PTR)

#endif
    {
        ptdesc = ptdesc->lptdesc;
        pDPD->fIndirect = TRUE;
    }
    if (ptdesc->vt != VT_USERDEFINED)
        return S_OK;

    hr = THR(pTIObject->GetRefTypeInfo(
            ptdesc->hreftype,
            &pTI));
    if (hr)
        goto Cleanup;

    hr = THR(pTI->GetTypeAttr(&pTA));
    if (hr)
        goto Cleanup;

    //
    // Skip aliases here except for the color
    //

    while (TKIND_ALIAS == pTA->typekind && pTA->guid != GUID_COLOR
        && pTA->tdescAlias.vt == VT_USERDEFINED && pTA->tdescAlias.hreftype != NULL)
    {
        ITypeInfo * pTIAlias = NULL;
        
        Assert(pTA->tdescAlias.vt == VT_USERDEFINED);
        
        hr = THR(pTI->GetRefTypeInfo(pTA->tdescAlias.hreftype, &pTIAlias));
        if (hr)
            goto Cleanup;

        pTI->ReleaseTypeAttr(pTA);
        
        hr = THR(pTIAlias->GetTypeAttr(&pTA));

        ReleaseInterface(pTI);
        pTI = pTIAlias;
        if (hr)
            goto Cleanup;
    }
        
    hr = THR(pTI->GetDocumentation(-1, &bstr, NULL, NULL, NULL));
    if (hr)
        goto Cleanup;

    Assert(pDPD->bstrType == NULL);
    pDPD->bstrType = bstr;
    bstr = NULL;

    switch (pTA->typekind)
    {
    case TKIND_ENUM:
        {
            pAryEVAL = pDPD->pAryEVAL = new(Mt(CCommitEngineParseUserDefined_pDPD_pAryEVAL)) CDataAry<EVAL>(Mt(CCommitEngineParseUserDefined_pDPD_pAryEVAL_pv));
            if (!pAryEVAL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            pDPD->fOwnEVAL = TRUE;

            for (i = 0; i < pTA->cVars; i++)
            {
                hr = THR(pTI->GetVarDesc(i, &pVD));
                if (hr)
                    goto Cleanup;
                Assert(pVD->varkind == VAR_CONST);

                hr = THR(pTI->GetDocumentation(pVD->memid, NULL, &bstr, NULL, NULL));
                if (hr)
                    goto Cleanup;
#ifdef _MAC
                // ISSUE: pTI->GetDocumentation returns a bogus BSTR that is not
                //      NULL terminated and with a byteswapped length.  Temporarily
                //      we get around this by making our own BSTR...
                UINT len = SysStringLen(bstr);
                if(len > 256)  // we don't have any helpstrings bigger than 256 bytes
                {
                    eval.bstr = SysAllocStringLen(bstr,len));
                    SysFreeString(bstr);
                }
                else
                {
                    eval.bstr = bstr;
                }
#else

                eval.bstr = bstr;
#endif
                eval.value = V_I4(pVD->lpvarValue);

                hr = THR(pAryEVAL->AppendIndirect(&eval));
                if (hr)
                    goto Cleanup;

                bstr = NULL;

                pTI->ReleaseVarDesc(pVD);
                pVD = NULL;
            }
        }
        break;

    case TKIND_DISPATCH:
        IGNORE_HR( ParseUnknown(pTI, pDPD));
        break;

    case TKIND_ALIAS:
        if (pTA->guid == GUID_COLOR)
        {
            pDPD->fSpecialCaseColor = TRUE;
            pDPD->pAryEVAL = _dpdColor.pAryEVAL;
        }
        break;
    }

Cleanup:
    if (pTA)
        pTI->ReleaseTypeAttr(pTA);
    if (pVD)
        pTI->ReleaseVarDesc(pVD);
    ReleaseInterface(pTI);
    FormsFreeString(bstr);

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CCommitEngine::ParseUnknown
//
//  Synopsis:   Tests for support of IPicture/IFont.
//
//--------------------------------------------------------------------------

HRESULT
CCommitEngine::ParseUnknown(ITypeInfo *pTypeInfo, DPD * pDPD)
{
    ITypeLib *pTypeLib = NULL;
    ITypeInfo *pInterfaceInfo = NULL;
    HRESULT hr = S_OK;
    USHORT uFound = 1; // Find the first matching name
    MEMBERID memID; // Not used
    TYPEATTR *pTypeAttr = NULL;
    UINT nTypeInfoIndex;

    switch (pDPD->dispid)
    {
    case DISPID_FONT:
        pDPD->fSpecialCaseFont = TRUE;
        break;

    case DISPID_MOUSEICON:
        pDPD->fSpecialCaseMouseIcon = TRUE;
        // Intentional fallthrough.
    case DISPID_PICTURE:
        pDPD->fSpecialCasePicture = TRUE;
        break;

    default:
        // The pDPD->bstrType contains the arg name for the property
        // go to the typelibrary, find the interface type info corresponding
        // to this name, and see if its IID is the unit measurement subobject
        for (int i = 0; i < 1; i++)
        {
            hr = pTypeInfo->GetContainingTypeLib ( &pTypeLib, &nTypeInfoIndex );
            if ( hr || !pTypeLib )
                break;

            hr = pTypeLib->FindName ( pDPD->bstrType, 0, 
                &pInterfaceInfo, &memID, &uFound );
            if ( hr || !pInterfaceInfo )
                break;

            hr = pInterfaceInfo->GetTypeAttr ( &pTypeAttr );
        }

        if ( !hr )
            hr = S_FALSE;
        break;
    }

// Cleanup:
    if ( pInterfaceInfo && pTypeAttr )
        pInterfaceInfo->ReleaseTypeAttr ( pTypeAttr );
    ReleaseInterface ( pInterfaceInfo ); 
    ReleaseInterface ( pTypeLib ); 
    RRETURN1 ( hr, S_FALSE );
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::FindReadPropFuncDesc
//
//  Synopsis:   Find FUNCDESC for get property with specified DISPID
//              This is helper function for ExamineObjects().
//
//-------------------------------------------------------------------------
HRESULT
CCommitEngine::FindReadPropFuncDesc(
        ITypeInfo * pTI,
        DISPID      dispid,
        int         iStart,         // Start search point for optimis
        int         iCount,         // Total number of functions in TypeInfo
        FUNCDESC **  ppFD)
{
    HRESULT     hr = E_FAIL;
    int         i;

    //
    // Start at the current location and move forward to the end,
    // If not found, start at the beginning of the FUNCDESCs and search to
    // the current location
    //

    for (i = iStart; i < iCount; i++)
    {
        hr = THR(pTI->GetFuncDesc(i, ppFD));
        if (hr)
            goto Cleanup;

        if ((*ppFD)->invkind == INVOKE_PROPERTYGET &&
                (*ppFD)->memid == dispid)

        {
            // Find the funcion desc for the read property
            return S_OK;
        }
        pTI->ReleaseFuncDesc(*ppFD);
        *ppFD = NULL;
    }

    for (i = 0; i < iStart; i++)
    {
        hr = THR(pTI->GetFuncDesc(i, ppFD));
        if (hr)
            goto Cleanup;

        if ((*ppFD)->invkind == INVOKE_PROPERTYGET &&
                (*ppFD)->memid == dispid)

        {
            // Find the funcion desc for the read property
            return S_OK;
        }
        pTI->ReleaseFuncDesc(*ppFD);
        *ppFD = NULL;
    }

Cleanup:
    pTI->ReleaseFuncDesc(*ppFD);
    *ppFD = NULL;
    RRETURN_NOTRACE(E_FAIL);
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::ReleasePropertyDescriptor
//
//  Synopsis:   Release the created property descriptor list
//
//-------------------------------------------------------------------------

HRESULT
CCommitEngine::ReleasePropertyDescriptor()
{
    long    i;
    DPD *   pDPD;

    for (i = _aryDPD.Size(), pDPD = _aryDPD; i > 0; i--, pDPD++)
    {
        pDPD->Free();
    }
    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CCommitEngine::UpdateValues
//
//  Synopsis:   Fill in values into _aryDPD
//
//-------------------------------------------------------------------------

void
CCommitEngine::UpdateValues()
{
    HRESULT     hr;
    int         i;
    DPD *       pDPD;
    
    for (i = _aryDPD.Size(), pDPD = _aryDPD;
         i > 0;
         i--, pDPD++)
    {
        Assert(pDPD->var.vt == VT_EMPTY);

        // Clear down the current value
        VariantClear(&pDPD->var);

        hr = THR_NOTRACE(GetCommonPropertyValue(
                pDPD->dispid,
                _aryObjs.Size(),
                _aryObjs,
                &pDPD->var));

        if (hr == S_FALSE)
        {
            pDPD->fNoMatch = TRUE;
            pDPD->fMemberNotFound = FALSE;
        }
        else
        {
            pDPD->fNoMatch = FALSE;
            pDPD->fMemberNotFound = (BOOL) hr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\other\moniker\resprot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       resprot.cxx
//
//  Contents:   Implementation of the resource protocol
//
//  History:    02-12-97    AnandRa     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_RESPROT_HXX_
#define X_RESPROT_HXX_
#include "resprot.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_ROSTM_HXX_
#define X_ROSTM_HXX_
#include "rostm.hxx"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#ifndef X_FATSTG_HXX_
#define X_FATSTG_HXX_
#include "fatstg.hxx"
#endif

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#include <shellapi.h>  // for the definition of ShellExecuteA (for AXP)
#endif

extern HRESULT CreateStreamOnFile(
        LPCTSTR lpstrFile,
        DWORD dwSTGM,
        LPSTREAM * ppstrm);

#if DBG==1
#define TID GetCurrentThreadId()
#endif

MtDefine(CResProtocol, Protocols, "CResProtocol")
MtDefine(CResProtocolDoParseAndBind_pb, Protocols, "CResProtocol::DoParseAndBind pb")
MtDefine(CViewSourceProtocol, Protocols, "CViewSourceProtocol")

//+---------------------------------------------------------------------------
//
//  Function:   CreateResProtocol
//
//  Synopsis:   Creates a resource Async Pluggable protocol
//
//  Arguments:  pUnkOuter   Controlling IUnknown
//
//----------------------------------------------------------------------------

CBase * 
CreateResProtocol(IUnknown *pUnkOuter)
{
    return new CResProtocol(pUnkOuter);
}

CResProtocolCF   g_cfResProtocol(CreateResProtocol);


//+---------------------------------------------------------------------------
//
//  Method:     CrackResUrl
//
//  Synopsis:   Breaks res: URL into its component strings.
//              NOTE: pcstrResName and pcstrRID are allowed to be NULL.
//                    The caller needs only to pass in CStr*'s for the
//                    components they want.
//
//
//  Arguments:  pchURL          Url of the following syntax:
//
//              res://<dll name and location>[/<resource type>]/<resource id>
//
//              pcstrResName    CStr to hold <dll name and location>
//                              The path may not contain '/' characters
//              pcstrResType    CStr to hold <resource type>
//              pcstrRID        CStr to hold <resource id>
//
//----------------------------------------------------------------------------

HRESULT
CrackResUrl(const TCHAR* pchURL, CStr* pcstrResName, CStr* pcstrResType, CStr* pcstrRID)
{
    HRESULT         hr = S_OK;
    TCHAR *         pch = NULL;
    TCHAR *         pchNext = NULL;
    TCHAR           achURL[pdlUrlLen];
    DWORD           cchURL;

    Assert (pchURL && _tcsnipre(_T("res:"), 4, pchURL, -1));

    //
    // NOTENOTE: pchstrResName, pcstrResType, and pcstrRID are
    //           allowed to be NULL!
    //

    // Unescape the URL.
    hr = THR(CoInternetParseUrl(
            pchURL,
            PARSE_ENCODE,
            0,
            achURL,
            ARRAY_SIZE(achURL),
            &cchURL,
            0));
    if (hr)
        goto Cleanup;

    pch = _tcschr(achURL, _T(':'));
    if (!pch)
    {
        goto SyntaxError;
    }

    if (!(_tcsnipre(_T("://"), 3, pch, -1)))
    {
        goto SyntaxError;
    }

    pch += 3;

    //
    // Now look for the dll name.  Basically find the next '/'.
    // Everything to the left of this is the dll name.
    //

    pchNext = _tcschr(pch, _T('/'));
    if (!pchNext)
    {
        goto SyntaxError;
    }

    if (pcstrResName)
    {
        hr = THR(pcstrResName->Set(pch, pchNext - pch));
        if (hr)
            goto Cleanup;
    }

    pch = pchNext + 1;
    pchNext = _tcschr(pch, _T('/'));

    if (pchNext)
    {
        //
        // We've found a second '/', which means that the URL
        // contains both a resource-ID and resource type.
        //

        if (pcstrResType)
        {
            hr = THR(pcstrResType->Set(pch, pchNext - pch));
            if (hr)
                goto Cleanup;

            LONG lTemp;
            HRESULT hr2 = THR_NOTRACE(ttol_with_error(*pcstrResType, &lTemp));

            if (SUCCEEDED(hr2))
            {
                // 
                // Only accept numbers that are max 16 bits.  FindResource
                // can only accept such numbers.  
                //

                if (lTemp & 0xFFFF0000)
                    goto SyntaxError;
                    
                hr = pcstrResType->Set(_T("#"));
                if (hr)
                    goto Cleanup;

                hr = pcstrResType->Append(pch, pchNext - pch);
                if (hr)
                    goto Cleanup;
            }
            else if (hr2 != E_INVALIDARG)
            {
                hr = hr2;
                goto Cleanup;
            }
        }

        pch = pchNext + 1;
    }
    else if (pcstrResType)
    {
        hr = THR(pcstrResType->Set(_T("")));
    }

    if (pcstrRID)
    {
        LONG lTemp;
        HRESULT hr2 = THR_NOTRACE(ttol_with_error(pch, &lTemp));
        if (SUCCEEDED(hr2))
        {
            // 
            // Only accept numbers that are max 16 bits.  FindResource
            // can only accept such numbers.  
            //

            if (lTemp & 0xFFFF0000)
                goto SyntaxError;
                
            hr = THR(pcstrRID->Set(_T("#")));
            if (hr)
                goto Cleanup;
                
            hr = THR(pcstrRID->Append(pch));
            if (hr)
                goto Cleanup;
        }
        else if (hr2 == E_INVALIDARG)
        {
            hr = THR(pcstrRID->Set(pch));
            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = hr2;
            goto Cleanup;
        }
    }


Cleanup:
    RRETURN(hr);

SyntaxError:
    hr = MK_E_SYNTAX;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocolCF::ParseUrl
//
//  Synopsis:   per IInternetProtocolInfo
//
//----------------------------------------------------------------------------

#define FILEPROT_PREFIX_LEN 7

HRESULT
CResProtocolCF::ParseUrl(
    LPCWSTR     pwzUrl,
    PARSEACTION ParseAction,
    DWORD       dwFlags,
    LPWSTR      pwzResult,
    DWORD       cchResult,
    DWORD *     pcchResult,
    DWORD       dwReserved)
{
    HRESULT hr = INET_E_DEFAULT_ACTION;

    if (!pcchResult || !pwzResult)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (ParseAction == PARSE_SECURITY_URL)
    {
        CStr            cstrResName;
        DWORD           cchNewUrlLen;
        TCHAR           achFullResourceName [pdlUrlLen];

        *pcchResult = FILEPROT_PREFIX_LEN;

        hr = THR(CrackResUrl (pwzUrl, &cstrResName, NULL, NULL));
        if (hr)
            goto Cleanup;

#ifndef WIN16
        {
            CStrIn  strinResName ((LPWSTR)cstrResName);
            CStrOut stroutFile (achFullResourceName, pdlUrlLen);
            char *  pstrFileName;

            cchNewUrlLen = ::SearchPathA (NULL,
                                          strinResName,
                                          NULL,
                                          pdlUrlLen,
                                          stroutFile,
                                          &pstrFileName);
        }
#else
        {
            char *  pstrFileName;
            cchNewUrlLen = ::SearchPathA (NULL,
                                          cstrResName,
                                          NULL,
                                          pdlUrlLen,
                                          achFullResourceName,
                                          &pstrFileName);
        }
#endif // WIN16

        //
        // The returned path is now stored as a TCHAR in achFullResourceName.
        //

        if (!cchNewUrlLen)
        {
            hr = MK_E_SYNTAX;
            goto Cleanup;
        }

        *pcchResult += cchNewUrlLen + 1; // total mem needed includes \0 terminator

        if (*pcchResult > pdlUrlLen)
        {
            hr = MK_E_SYNTAX;
            goto Cleanup;
        }

        if (*pcchResult > cchResult)
        {
            hr = S_FALSE;
            goto Cleanup;
        }

        _tcsncpy(pwzResult, _T("file://"), FILEPROT_PREFIX_LEN);
        _tcscpy(pwzResult + FILEPROT_PREFIX_LEN, achFullResourceName);

        Assert (_tcslen(pwzResult) + 1 == *pcchResult);
    }
    else
    {
        hr = THR_NOTRACE(super::ParseUrl(
            pwzUrl,
            ParseAction,
            dwFlags,
            pwzResult,
            cchResult,
            pcchResult,
            dwReserved));
    }

Cleanup:
    RRETURN2(hr, INET_E_DEFAULT_ACTION, S_FALSE);
}


const CBase::CLASSDESC CResProtocol::s_classdesc =
{
    &CLSID_ResProtocol,             // _pclsid
};


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::QueryInfo
//
//  Synopsis:   for QUERY_IS_SAFE
//
//----------------------------------------------------------------------------
HRESULT
CResProtocolCF::QueryInfo(
    LPCWSTR       pwzUrl, 
    QUERYOPTION   QueryOption,
    DWORD         dwQueryFlags,
    LPVOID        pvBuffer,
    DWORD         cbBuffer,
    DWORD  *      pcbBuffer,
    DWORD         dwReserved)
{
    //
    // intercept is-safe
    //

    if (QueryOption == QUERY_IS_SAFE)
    {
        if (!pvBuffer || cbBuffer < sizeof(DWORD))
            return E_FAIL;

        if (pcbBuffer)
            *pcbBuffer = sizeof(DWORD);
        
        *(DWORD *)pvBuffer = TRUE;
        return S_OK;
    }
    else
    {
        RRETURN(super::QueryInfo(
                pwzUrl,
                QueryOption,
                dwQueryFlags,
                pvBuffer,
                cbBuffer,
                pcbBuffer,
                dwReserved));
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::CResProtocol
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CResProtocol::CResProtocol(IUnknown *pUnkOuter) : super(pUnkOuter)
{
}


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::~CResProtocol
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CResProtocol::~CResProtocol()
{
}


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::Start
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CResProtocol::Start(
    LPCWSTR pchUrl, 
    IInternetProtocolSink *pTrans, 
    IInternetBindInfo *pOIBindInfo,
    DWORD grfSTI, 
    HANDLE_PTR dwReserved)
{
    HRESULT         hr = NOERROR;
    TCHAR           ach[pdlUrlLen];
    DWORD           dwSize;

    Assert(!_pProtSink && pOIBindInfo && pTrans && !_cstrURL);

    if ( !(grfSTI & PI_PARSE_URL))
    {
        ReplaceInterface(&_pProtSink, pTrans);
        ReplaceInterface(&_pOIBindInfo, pOIBindInfo);
    }

    _bindinfo.cbSize = sizeof(BINDINFO);
    hr = THR(pOIBindInfo->GetBindInfo(&_grfBindF, &_bindinfo));

    //
    // First get the basic url.  Unescape it first.
    //

    hr = THR(CoInternetParseUrl(pchUrl, PARSE_ENCODE, 0, ach, ARRAY_SIZE(ach), &dwSize, 0));
    if (hr)
        goto Cleanup;

    hr = THR(_cstrURL.Set(ach));
    if (hr)
        goto Cleanup;

    //
    // Now append any extra data if needed.
    //

    if (_bindinfo.szExtraInfo)
    {
        hr = THR(_cstrURL.Append(_bindinfo.szExtraInfo));
        if (hr)
            goto Cleanup;
    }

    _grfSTI = grfSTI;

    //
    // If forced to go async, return E_PENDING now, and
    // perform binding when we get the Continue.
    //

    if (grfSTI & PI_FORCE_ASYNC)
    {
        PROTOCOLDATA    protdata;

        hr = E_PENDING;
        protdata.grfFlags = PI_FORCE_ASYNC;
        protdata.dwState = BIND_ASYNC;
        protdata.pData = NULL;
        protdata.cbData = 0;

        _pProtSink->Switch(&protdata);
    }
    else
    {
        hr = THR(ParseAndBind());
    }


Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::ParseAndBind
//
//  Synopsis:   Actually perform the binding & execution of script.
//
//----------------------------------------------------------------------------

HRESULT
CResProtocol::ParseAndBind()
{
    RRETURN(DoParseAndBind(_cstrURL, _cstrResName, _cstrResType, _cstrRID, &_pStm, this));
}


void
CResProtocol::_ReportData(ULONG cb)
{
    _bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
    _pProtSink->ReportData(_bscf, cb, cb);
}


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::DoParseAndBind
//
//  Synopsis:   Static helper to actually perform the binding of protocol.
//
//  Arguments:  pchURL          Url to bind to [needed]
//              cstrRID         Resource id extracted from url [needed]
//              cstrResName     Resource dll name extracted from url [needed]
//              ppStm           Stream of data from resource [needed]
//              pProt           Protocol object that's involved [optional]
//
//----------------------------------------------------------------------------

HRESULT
CResProtocol::DoParseAndBind(
    TCHAR *pchURL, 
    CStr &cstrResName,
    CStr &cstrResType,
    CStr &cstrRID,
    IStream **ppStm,
    CResProtocol *pProt)
{
    HRESULT         hr = S_OK;
    TCHAR *         pchBuf = NULL;
    ULONG           cb = 0;
    CROStmOnBuffer *prostm = NULL;
    HINSTANCE       hInst = NULL;
    BYTE *          pb = NULL;
    IBindCtx *      pBCtx = NULL;
    TCHAR *         pchMime = NULL;
    
    hr = THR(CrackResUrl (pchURL, &cstrResName, &cstrResType, &cstrRID));
    if (hr)
        goto Cleanup;

    //
    // Do the binding.
    //

    Assert((TCHAR *)cstrResName && (TCHAR *)cstrRID);

    if (cstrResName.Length() >= MAX_PATH)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    hInst = LoadLibraryEx(
                cstrResName, 
                NULL, 
                DONT_RESOLVE_DLL_REFERENCES | LOAD_LIBRARY_AS_DATAFILE);
    if (!hInst)
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

    if (cstrResType.Length())
    {
        pchBuf = (TCHAR *)GetResource(
            hInst,
            cstrRID,
            cstrResType,
            &cb);
    }
    else
    {
        pchBuf = (TCHAR *)GetResource(
            hInst,
            cstrRID,
            MAKEINTRESOURCE(RT_HTML),
            &cb);
        //
        //  dialog resource type may be RT_FILE
        //
        if (!pchBuf)
        {
            pchBuf = (TCHAR *)GetResource(
                hInst,
                cstrRID,
                MAKEINTRESOURCE(RT_FILE),
                &cb);
        }
    }

    if (!pchBuf)
    {
        hr = GetLastWin32Error();
        goto Cleanup;
            
    }
    
    Assert(pchBuf);

    // ISSUE - res: bitmap hack (t-chrisr)
    //
    // We want to be able to load bitmaps from resource files.  The problem is
    // that resource files don't store bitmaps quite like .bmp files store bitmaps
    // (resource files lack the BITMAPFILEHEADER header).  So we'll construct a
    // "real" bitmap here.
    //
    // <HACK>

    if (_tcsequal(cstrResType, _T("#2")))
    {
        BITMAPFILEHEADER  bmfh;
        PBITMAPINFOHEADER pbmih = NULL;
        PBITMAPCOREHEADER pbmch = NULL;
        DWORD             dwClrTblSize = 0;
        DWORD             dwClrUsed;
        DWORD             dwCompression;
        WORD              wBitCount;
        WORD              wPlanes;

        pbmih = (PBITMAPINFOHEADER)pchBuf;
        if (pbmih->biSize == sizeof(BITMAPINFOHEADER))
        {
            dwClrUsed     = pbmih->biClrUsed;
            dwCompression = pbmih->biCompression;
            wBitCount     = pbmih->biBitCount;
            wPlanes       = pbmih->biPlanes;
        }
        else if (pbmih->biSize == sizeof(BITMAPCOREHEADER))
        {
            pbmch = (PBITMAPCOREHEADER)pchBuf;

            dwClrUsed     = 0;
            dwCompression = BI_RGB;
            wBitCount     = pbmch->bcBitCount;
            wPlanes       = pbmch->bcPlanes;
        }
        else
        {
            // we don't have a bitmap that we understand
            goto EndHack;
        }

        //
        // Calculate the size of the bitmap's color table
        //

        if (wBitCount <= 8)
        {
            dwClrTblSize = dwClrUsed ? dwClrUsed : (1 << wBitCount);
            dwClrTblSize *= sizeof(RGBQUAD);
        }
        else if ((dwCompression == BI_BITFIELDS) &&
            ((wBitCount == 16) || (wBitCount == 32)))
        {
            dwClrTblSize = 3 * sizeof(DWORD);
        }


        //
        // Fabricate the missing header.  Remember, pbmih might
        // really be a PBITMAPCOREHEADER.  But pbmih->biSize will
        // always be the right size, either way.
        //

#ifdef BIG_ENDIAN
        bmfh.bfType = (WORD)0x424D;         // 0x42 = "B", 0x4D = "M"
#else
        bmfh.bfType = (WORD)0x4D42;         // 0x42 = "B", 0x4D = "M"
#endif
        bmfh.bfSize = sizeof(bmfh) + cb;
        bmfh.bfReserved1 = 0;
        bmfh.bfReserved2 = 0;
        bmfh.bfOffBits = sizeof(bmfh) + pbmih->biSize + dwClrTblSize;

        //
        // Put this sandwich together and make it be pchBuf
        //
        pb = new(Mt(CResProtocolDoParseAndBind_pb)) BYTE [bmfh.bfSize];
        if (!pb)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        MemSetName((pb, "Resprot Bitmap Buffer"));

        memcpy (pb, &bmfh, sizeof(bmfh));
        memcpy (pb + sizeof(bmfh), pchBuf, cb);

        pchBuf = (TCHAR *)pb;
        cb = bmfh.bfSize;
    }
    // </HACK>

EndHack:
    //
    // Try and retrieve a mime type from the resource name and
    // report that if available.
    //

    hr = THR(CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, &pBCtx, 0));
    if (hr)
        goto Cleanup;
        
    if (pProt &&
        OK(THR(FindMimeFromData(
            pBCtx, 
            pProt->_cstrURL, 
            NULL, 0, NULL, 0, &pchMime, 0))))
    {
        hr = THR(pProt->_pProtSink->ReportProgress(
                BINDSTATUS_MIMETYPEAVAILABLE,
                pchMime));
        if (hr)
            goto Cleanup;
    }
    
    // cb includes the null terminator

    prostm = new CROStmOnBuffer;
    if (!prostm)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(prostm->Init((BYTE *)pchBuf, cb));
    if (hr)
        goto Cleanup;

    *ppStm = (IStream *)prostm;
    (*ppStm)->AddRef();

Cleanup:
    if (pProt)
    {
        if (!pProt->_fAborted)
        {
            if (!hr)
            {
                pProt->_ReportData(cb);
            }
            if (pProt->_pProtSink)
            {
                pProt->_pProtSink->ReportResult(hr, 0, 0);
            }
        }
    }

    if (hInst)
    {
        FreeLibrary(hInst);
    }
    if (prostm)
    {
        prostm->Release();
    }
    ReleaseInterface(pBCtx);
    delete [] pb;
    CoTaskMemFree(pchMime);
    
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CreateResourceMoniker
//
//  Synopsis:   Creates a new moniker based off a resource file & rid
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT 
CreateResourceMoniker(
    HINSTANCE hInst, 
    TCHAR *pchRID, 
    IMoniker **ppmk)
{
    HRESULT         hr = S_OK;
    TCHAR           ach[pdlUrlLen];
    
    _tcscpy(ach, _T("res://"));

    if (!GetModuleFileName(
            hInst, 
            ach + _tcslen(ach), 
            pdlUrlLen - _tcslen(ach) - 1))
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

#ifdef UNIX
    {
        TCHAR* p = _tcsrchr(ach, _T('/'));
        if (p)
	{
            int iLen = _tcslen(++p);
            memmove(ach + 6, p, sizeof(TCHAR) * iLen);
            ach[6 + iLen] = _T('\0');
	}
    }
#endif

    _tcscat(ach, _T("/"));
    _tcscat(ach, pchRID);

    hr = THR(CreateURLMoniker(NULL, ach, ppmk));
    if (hr)
        goto Cleanup;
    
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateViewSourceProtocol
//
//  Synopsis:   Creates a view-source: Async Pluggable protocol
//
//  Arguments:  pUnkOuter   Controlling IUnknown
//
//----------------------------------------------------------------------------

CBase * 
CreateViewSourceProtocol(IUnknown *pUnkOuter)
{
    return new CViewSourceProtocol(pUnkOuter);
}


CViewSourceProtocolCF   g_cfViewSourceProtocol(CreateViewSourceProtocol);

const CBase::CLASSDESC CViewSourceProtocol::s_classdesc =
{
    &CLSID_ViewSourceProtocol,             // _pclsid
};

// IOInetProtocolInfo methods
HRESULT CViewSourceProtocolCF::QueryInfo(LPCWSTR         pwzUrl,
                                         QUERYOPTION     QueryOption,
                                         DWORD           dwQueryFlags,
                                         LPVOID          pBuffer,
                                         DWORD           cbBuffer,
                                         DWORD *         pcbBuf,
                                         DWORD           dwReserved)
{
    HRESULT hr = INET_E_DEFAULT_ACTION;

    switch (QueryOption)
    {
    case QUERY_CAN_NAVIGATE:

        // Need at least a DWORD
        if (cbBuffer < sizeof(DWORD))
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (pcbBuf)
        {
            *pcbBuf = sizeof(DWORD); // 4 bytes needed for DWORD
        }

        *((DWORD *)pBuffer) = 0; // make sure we return false (0) for view-source prot.
        hr = S_OK;
        break;

    default:
        hr = THR(super::QueryInfo(
                pwzUrl,
                QueryOption,
                dwQueryFlags,
                pBuffer,
                cbBuffer,
                pcbBuf,
                dwReserved));
        break;
    }

Cleanup:
    RRETURN1(hr, INET_E_DEFAULT_ACTION);
}

HRESULT DisplaySource(LPCTSTR tszSourceName)
{
    // Attempt to read a registry key

    HKEY    hKeyEditor = NULL;
    long    lRet;
    TCHAR   tszEditorName[MAX_PATH];
    LPCTSTR tszDefaultEditorName = _T("notepad");
    long    dwSize = sizeof(tszEditorName);
    SHELLEXECUTEINFO ei = {0};
    BOOL    fSuccess;

    lRet = RegOpenKeyExA(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Internet Explorer\\View Source Editor", 0, KEY_READ, &hKeyEditor);
    if(lRet == ERROR_SUCCESS)
    {
        lRet = RegQueryValue(hKeyEditor, _T("Editor Name"), tszEditorName, &dwSize);
        RegCloseKey(hKeyEditor);
    }

    // If key doesn't exist, fails to open or query fails, open default editor

    if(lRet != ERROR_SUCCESS)
    {
        _tcscpy(tszEditorName, tszDefaultEditorName);
    }

    // If named editor fails to execute, open default editor   

    // (rodc) Disable leak tracking because ShellExecute leaks.

    ei.cbSize = sizeof(ei);
    ei.lpVerb = _T("open");
    ei.lpFile = tszEditorName;
    ei.lpParameters = tszSourceName;
    ei.nShow = SW_SHOWNORMAL;

    DbgMemoryTrackDisable(TRUE);
    fSuccess = ShellExecuteEx(&ei);
    DbgMemoryTrackDisable(FALSE);

    if (!fSuccess)
    {
        ei.lpFile = tszDefaultEditorName;

        DbgMemoryTrackDisable(TRUE);
        fSuccess = ShellExecuteEx(&ei);
        DbgMemoryTrackDisable(FALSE);

        if (!fSuccess)
            RRETURN( GetLastWin32Error());
    }

    return S_OK;
}

HRESULT CopySource(IStream *pStmSrc, IStream *pStmDest)
{
    STATSTG statStm;
    BYTE abBuf[4096];   // copy in chunks of 4K
    ULONG cb = 0;
    ULONG cbCopied = 0;
    LONG cbToCopy;
    BYTE *pbStart;
    BYTE *pbEnd;
    BYTE bLast = 0;
    HRESULT hr;

    hr = pStmSrc->Stat(&statStm, STATFLAG_NONAME);
    if (hr)
        goto Cleanup;

#ifdef UNIX
    cb = statStm.cbSize.LowPart;  // get size of bit stream
#else
    cb = statStm.cbSize.u.LowPart;  // get size of bit stream
#endif
    while (cbCopied < cb)
    {
        cbCopied += sizeof(abBuf);
        // bytes to be copied is 4K or remainder (if last chunk)
        if (cbCopied > cb)
            cbToCopy= cb % sizeof(abBuf);
        else
            cbToCopy= sizeof(abBuf);

        hr = pStmSrc->Read(abBuf, (ULONG)cbToCopy, NULL);
        if (hr)
            goto Cleanup;

        pbStart = pbEnd = abBuf;

        while(cbToCopy > 0)
        {
            // keep going until CR, LF (i.e end of line) or End of current chunk
            while (*pbEnd != '\r' && *pbEnd != '\n' && pbEnd-pbStart<cbToCopy)
                pbEnd++;

            // write out what we have so far
            hr = THR(pStmDest->Write(pbStart, pbEnd-pbStart, NULL));
            if (hr)
                goto Cleanup;

            // if first byte of new chunk is not LF, clear the last byte. so 
            // that there is no confusion if tht last byte of previous chunk
            // was a CR
            if (pbStart != pbEnd)
                bLast = 0;

            if (pbEnd-pbStart == cbToCopy)  // bailout if at end of 4K chunk
                break;

            // If LF is found and previous char is CR, 
            // then we don't write, Otherwise, write CR & LF to temp file.

            if (!(*pbEnd == '\n' && bLast == '\r')) 
            {
                hr = THR(pStmDest->Write("\r\n", 2, NULL));
                if (hr)
                    goto Cleanup;
            }

            bLast = *pbEnd; // remember last char (CR or LF)
            cbToCopy -= (LONG)(pbEnd - pbStart + 1); // adjust bytes to be copied
            pbStart = ++pbEnd;  // adjust pts to start of new line
        }
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------------
//
//  Method:     CViewSourceProtocol::OnDwnChan
//
//-------------------------------------------------------------------------

void CViewSourceProtocol::OnDwnChan()
{
    ULONG       ulState = _pBitsCtx->GetState();
    IStream *   pStm = NULL;
    IStream *   pStmFile = NULL;
    TCHAR achFileName[MAX_PATH];
    HRESULT hr = S_OK;
    
    if (ulState & DWNLOAD_COMPLETE)
    {
        _pBitsCtx->GetStream(&pStm);
        if (pStm)
        {
            achFileName[0] = 0;
            if (!CreateUrlCacheEntry(_cstrURL, 0, NULL, achFileName, 0))
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            hr = THR(CreateStreamOnFile(
                     achFileName,
                     STGM_READWRITE | STGM_SHARE_DENY_WRITE | STGM_CREATE,
                     &pStmFile));

            if (hr)
                goto Cleanup;

            hr = CopySource(pStm, pStmFile);    // insert CR\LF if reqd.
            if (hr)
                goto Cleanup;

            hr = CloseStreamOnFile(pStmFile);
            if (hr)
                goto Cleanup;

            FILETIME fileTime;
            fileTime.dwLowDateTime = 0;
            fileTime.dwHighDateTime = 0;
            if (!CommitUrlCacheEntry(_cstrURL,
                                     achFileName,
                                     fileTime,
                                     fileTime,
                                     NORMAL_CACHE_ENTRY,
                                     NULL,
                                     0,
                                     NULL,
                                     0))
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            hr = DisplaySource(achFileName);
        }
        goto Cleanup;
    }
    else if (ulState & DWNLOAD_ERROR)
    {
        goto Cleanup;
    }

    return;

Cleanup:
    if (!_fAborted)
    {
        if (_pBitsCtx)
        {
            // if aborted, kill the bits ctx if started
            _pBitsCtx->Disconnect();
            _pBitsCtx->Release();
            _pBitsCtx = NULL;
        }

        // tell urlmon that we are done
        if (!hr && _pProtSink)
        {
            _bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
            _pProtSink->ReportData(_bscf, 0, 0);
        }
        if (_pProtSink)
        {
            _pProtSink->ReportResult(hr, 0, 0);
        }
    }

    ReleaseInterface(pStm);
    ReleaseInterface(pStmFile);
}

//+---------------------------------------------------------------------------
//
//  Method:     CViewSourceProtocol::ParseAndBind
//
//  Synopsis:   Actually get the source stream and display it in notepad.
//
//----------------------------------------------------------------------------

HRESULT CViewSourceProtocol::ParseAndBind()
{
    HRESULT         hr = S_OK;
    TCHAR *         pchSourceUrl = NULL;
    DWNLOADINFO     dwnloadinfo = {0};
    URL_COMPONENTS  uc;
    TCHAR           achPath[pdlUrlLen];

    // skip protocol part
    pchSourceUrl = _tcschr(_cstrURL, ':');
    if (!pchSourceUrl)
    {
        hr = MK_E_SYNTAX;
        goto Cleanup;
    }

    // Go past the :
    pchSourceUrl++;

    memset(&uc, 0, sizeof(uc));

    uc.dwStructSize = sizeof(uc);
    uc.lpszUrlPath = achPath;
    uc.dwUrlPathLength = ARRAY_SIZE(achPath);

    // Only file://, http:// and https:// supported
    if (pchSourceUrl && InternetCrackUrl(pchSourceUrl, _tcslen(pchSourceUrl), 0, &uc))
    {
        switch (uc.nScheme)
        {
            case INTERNET_SCHEME_HTTP:
            case INTERNET_SCHEME_HTTPS:
                dwnloadinfo.pDwnDoc = new CDwnDoc();
    
                if (dwnloadinfo.pDwnDoc)
                    dwnloadinfo.pDwnDoc->SetRefresh(IncrementLcl());
    
                dwnloadinfo.pchUrl = pchSourceUrl;

                Assert(!_pBitsCtx);

                // Get the bits context
                hr = THR(::NewDwnCtx(DWNCTX_BITS, TRUE, &dwnloadinfo, (CDwnCtx **)&_pBitsCtx));
                if (hr)
                    break;

                if (_pBitsCtx)
                {
                    // if bits already got, call the callback
                    if (_pBitsCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR))
                        OnDwnChan();
                    else    // register the callback
                    {
                        _pBitsCtx->SetCallback(OnDwnChanCallback, this);
                        _pBitsCtx->SelectChanges(DWNCHG_COMPLETE, 0, TRUE);
                    }
                }

                if (dwnloadinfo.pDwnDoc)
                    dwnloadinfo.pDwnDoc->Release();
            
                RRETURN(hr);

            // just display file if file:// protocol
            case INTERNET_SCHEME_FILE:
                hr = DisplaySource(uc.lpszUrlPath);
                // fall through

            default:
                break;
        }
    }
        
Cleanup:
    // tell urlmon that we are done
    if (!_fAborted)
    {
        if (!hr && _pProtSink)
        {
            _bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
            _pProtSink->ReportData(_bscf, 0, 0);
        }
        if (_pProtSink)
        {
            _pProtSink->ReportResult(hr, 0, 0);
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CViewSourceProtocol::Abort
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT CViewSourceProtocol::Abort(HRESULT hrReason, DWORD dwOptions)
{
    if (_pBitsCtx)
    {
        _pBitsCtx->Disconnect();
        _pBitsCtx->Release();
        _pBitsCtx = NULL;
    }

    return super::Abort(hrReason, dwOptions);
}

//+---------------------------------------------------------------------------
//
//  Method:     CViewSourceProtocol::Passivate
//
//  Synopsis:   1st stage dtor. Need to override so that the BitsCtx can be
//              killed if started and then aborted before OnDwnChan CB is called
//
//----------------------------------------------------------------------------

void
CViewSourceProtocol::Passivate()
{
    if (_pBitsCtx)
    {
        _pBitsCtx->Disconnect();
        _pBitsCtx->Release();
        _pBitsCtx = NULL;
    }
    
    super::Passivate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\project.inc ===
# project.inc - project specific settings

SITE_INC_DIRS = $(SRCROOT)\site\include $(SRCROOT)\core\include 
SITE_INC_DIRS = $(SITE_INC_DIRS) $(SRCROOT)\f3\include $(SDKDIR) 
SITE_INC_DIRS = $(SITE_INC_DIRS) $(TOOLSINCLUDE) $(TOOLSMISCINCLUDE) 
SITE_INC_DIRS = $(SITE_INC_DIRS) $(BLDROOT)\types $(SRCROOT)\core\types 
SITE_INC_DIRS = $(SITE_INC_DIRS) $(SRCROOT)\f3\types $(SRCROOT)\f3\ocx96
SITE_INC_DIRS = $(SITE_INC_DIRS) $(SRCROOT)\site\types
SITE_INC_DIRS = $(SITE_INC_DIRS) $(SRCROOT)\other\include
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\accanch.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccAnch.Cxx
//
//  Contents:   Accessible Anchor object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCANCH_HXX_
#define X_ACCANCH_HXX_
#include "accanch.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif


//----------------------------------------------------------------------------
//  CAccAnchor
//  
//  DESCRIPTION:    
//      The anchor accessible object constructor
//
//  PARAMETERS:
//      Pointer to the anchor element 
//----------------------------------------------------------------------------
CAccAnchor::CAccAnchor( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );
    
    //initialize the instance variables
    SetRole( ROLE_SYSTEM_LINK );
}


//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      If the title is not empty, returns the title
//      else, returns the inner text of the anchor, which is the name seen for the 
//      anchor. 
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccAnchor::GetAccName( BSTR* pbstrName )
{
    HRESULT hr = S_OK;

    // validate out parameter
     if ( !pbstrName )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrName = NULL;

    //get the title or the label for the anchor.
    hr = GetTitleorLabel(pbstrName);

    if (hr || !*pbstrName)
    {
        hr = THR( _pElement->get_innerText( pbstrName ) );
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccValue
//  
//  DESCRIPTION:
//      Returns the href of the anchor, which is stored in the CHyperLink
//  
//  PARAMETERS:
//      pbstrValue   :   BSTR pointer to receive the value
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccAnchor::GetAccValue( BSTR* pbstrValue )
{
    HRESULT hr;

    // validate out parameter
     if ( !pbstrValue )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrValue = NULL;

    hr = THR( (DYNCAST(CAnchorElement,_pElement))->get_href( pbstrValue ) );

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      Returns the inner text of the anchor, which is the name seen for the 
//      anchor. Actually, this is the same function with the GetAccName for the
//      anchor element, so it calls GetAccName()
//  
//  PARAMETERS:
//      pbstrDescription    :   BSTR pointer to receive the description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccAnchor::GetAccDescription( BSTR* pbstrDescription )
{
    RRETURN( GetAccName(pbstrDescription) );
}

//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      always STATE_SYSTEM_LINKED
//      if not visible, then STATE_SYSTEM_INVISIBLE
//      if document has the focus, then STATE_SYSTEM_FOCUSABLE
//      if this is the active element. then STATE_SYSTEM_FOCUSED
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccAnchor::GetAccState( VARIANT *pvarState)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = _pElement->Doc();
    
    // validate out parameter
    if ( !pvarState )
    {
        hr = E_POINTER;       
        goto Cleanup;
    }
    
    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = STATE_SYSTEM_LINKED;
    
    if ( IsFocusable(_pElement) )
        V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;
    
    if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus() )
        V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;
    
    if (!_pElement->IsVisible(FALSE))
        V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;

    if ( (DYNCAST( CAnchorElement, _pElement))->IsVisited() )
        V_I4( pvarState ) |= STATE_SYSTEM_TRAVERSED;
        
Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccDefaultAction
//  
//  DESCRIPTION:
//  Returns the default action for  an anchor element, in a string. The default
//  action string is "jump"
//
//  PARAMETERS:
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccAnchor::GetAccDefaultAction( BSTR* pbstrDefaultAction )
{
    HRESULT hr = S_OK;

    if ( !pbstrDefaultAction )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDefaultAction = SysAllocString( _T("Jump") );

    if ( !(*pbstrDefaultAction) )
        hr = E_OUTOFMEMORY;
   
Cleanup:
   RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\accarea.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccArea.Cxx
//
//  Contents:   Accessible Area object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCAREA_HXX_
#define X_ACCAREA_HXX_
#include "accarea.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

ExternTag(tagAcc);

//----------------------------------------------------------------------------
//  CAccArea
//  
//  DESCRIPTION:    
//      The area accessible object constructor
//
//  PARAMETERS:
//      Pointer to the area element 
//----------------------------------------------------------------------------
CAccArea::CAccArea( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );
    
    //initialize the instance variables
    SetRole( ROLE_SYSTEM_LINK );
}

//----------------------------------------------------------------------------
//  get_accParent
//  
//  DESCRIPTION:
//      Area elements have map elements as their parents in the tree. The map
//  elements have the body as their parent. In the accessibility code, the parent
//  for an area must be the image that contains that area, since the map element
//  is not supported and the area is really associated with the image and not the
//  body.
//  
//  Since there is no way for us to learn which area is associated with which 
//
//----------------------------------------------------------------------------
STDMETHODIMP    
CAccArea::get_accParent(IDispatch ** ppdispParent)
{
    HRESULT             hr;
    CTreeNode *         pNode = NULL;
    CTreeNode *         pParentNode = NULL;
    CCollectionCache *  pCollectionCache;
    long                lSize, l;
    CAccBase *          pAccParent = NULL;
    CMarkup *           pMarkup = NULL;


    TraceTag((tagAcc, "CAccArea::get_accParent"));      

    if ( !ppdispParent )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppdispParent = NULL;

    //
    // get to the element's node
    //
    pNode = _pElement->GetFirstBranch();

    // We have to have a tree node that is in the tree when we reach here
    if ( !pNode || pNode->IsDead())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // get the parent node.
    pParentNode = pNode->Parent();

    AssertSz( ( pParentNode->Tag()== ETAG_MAP ), 
                    "How can we not have a MAP Parent for an AREA?? !?!" );

    pMarkup = _pElement->GetMarkupPtr();

    // there has to be a MAP parent for an area.
    if ( !pParentNode || 
        ( pParentNode->Tag()!= ETAG_MAP ) || 
        !pMarkup)       // we can not count on the fact that we are in a markup at anytime.
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // We have the MAP element that contains the area, now find an image that 
    // is associated with this map.
    hr = THR( pMarkup->EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION) );
    if ( hr )
        goto Cleanup;
        
    pCollectionCache = pMarkup->CollectionCache();

    // Get the size of the doc's elements collection (0).
    lSize = pCollectionCache->SizeAry(CMarkup::ELEMENT_COLLECTION);

    for ( l=0; l< lSize; l++ )
    {
        CElement * pElemCandidate;

        WHEN_DBG( pElemCandidate = NULL; )

        hr = THR( pCollectionCache->GetIntoAry( CMarkup::ELEMENT_COLLECTION, l, &pElemCandidate ));
        if (hr)
            goto Cleanup;

        Assert( pElemCandidate );
        
        // if this element is an image and 
        // the image is associated with the map that is this area's parent, then we return
        // the element as the parent.
        if ( pElemCandidate->Tag() == ETAG_IMAGE) 
        {
            CMapElement * pMap;

            DYNCAST( CImgElement, pElemCandidate)->EnsureMap();

            pMap = DYNCAST( CImgElement, pElemCandidate)->GetMap();

            if ( (CElement *)pMap == pParentNode->Element() )
            {
                // get the accessible object of the image element 
                pAccParent = GetAccObjOfElement( pElemCandidate );

                if ( pAccParent )
                {
                    hr = THR(pAccParent->QueryInterface(IID_IDispatch, (void**)ppdispParent));
                }
                else
                    hr = E_OUTOFMEMORY;

                // return with the success code and the value for the parent
                goto Cleanup;
            }
        }
    }

    // if we did not return from the loop, it means that we could not find 
    // an image that contains this area. Return S_FALSE and NULL pointer for 
    // the parent value.
    hr = S_FALSE;

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      Returns the title
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccArea::GetAccName( BSTR* pbstrName)
{
    HRESULT hr = S_OK;

    // validate out parameter
     if ( !pbstrName )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrName = NULL;
    
    //get the title or the label for the area.
    hr = GetTitleorLabel(pbstrName);

    // if there is no title or label may be we can use the alt text
    // if there is alt text on the area tag.
    if (!*pbstrName || hr)
    {
        TCHAR * pchString;

        pchString = (LPTSTR) (DYNCAST(CAreaElement, _pElement))->GetAAalt();

        if (pchString)
        {
            hr = FormsAllocString( pchString, pbstrName);
        }
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccValue
//  
//  DESCRIPTION:
//      Returns the href of the area, which is stored in the CHyperLink
//  
//  PARAMETERS:
//      pbstrValue   :   BSTR pointer to receive the value
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccArea::GetAccValue( BSTR* pbstrValue)
{
    HRESULT hr;

    // validate out parameter
    if ( !pbstrValue )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrValue = NULL;

    hr = THR( (DYNCAST(CAreaElement,_pElement))->get_href( pbstrValue ) );

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      If the area has a shape, then appends the shape string to the string:
//      "link region type:"
//      The shape string can be "RECT", "CIRCLE" or "POLY"
//  
//  PARAMETERS:
//      pbstrDescription    :   BSTR pointer to receive the description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccArea::GetAccDescription( BSTR* pbstrDescription)
{
    HRESULT hr;
    CStr    strShape;
    CStr    strBase;

    // validate out parameter
    if ( !pbstrDescription )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrDescription = NULL;

    //get the shape string
    hr = THR( ((CAreaElement *)_pElement)->GetshapeHelper(&strShape));
    if ( hr )
        goto Cleanup;

    //if there was a shape string, then prepare the return string
    if ( strShape.Length() > 0 )
    {
        hr = THR( strBase.Set(_T("link region type: ")));
        if ( hr )
            goto Cleanup;

        hr = THR (strBase.Append( strShape ) );
        if ( hr )
            goto Cleanup;

        hr = THR(strBase.AllocBSTR(pbstrDescription));
    }

Cleanup:
    RRETURN( hr );

}


//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      always STATE_SYSTEM_LINKED
//      if not visible, then STATE_SYSTEM_INVISIBLE
//      if document has the focus, then STATE_SYSTEM_FOCUSABLE
//      if this is the active element. then STATE_SYSTEM_FOCUSED
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccArea::GetAccState( VARIANT *pvarState)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = _pElement->Doc();

    // validate out parameter
     if ( !pvarState )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = STATE_SYSTEM_LINKED;
    
    if ( IsFocusable(_pElement) )
        V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;
    
    if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus())
        V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;
    
    if ( !_pElement->IsVisible(FALSE) )
        V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccDefaultAction
//  
//  DESCRIPTION:
//  Returns the default action for  an area element, in a string. The default
//  action string is "jump"
//
//  PARAMETERS:
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccArea::GetAccDefaultAction( BSTR* pbstrDefaultAction)
{
    HRESULT hr = S_OK;

    if ( !pbstrDefaultAction )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDefaultAction = SysAllocString( _T("Jump") );

    if (!(*pbstrDefaultAction) )
        hr = E_OUTOFMEMORY;
   
Cleanup:
   RRETURN( hr );
}


//+------------------------------------------------------------------
//
//  Member : accLocation
//
//  Synopsis : virtual override. this method deals wit hteh specific 
//      positioning informatio nof areas. beause they are not in the 
//      tree/runs the same way as other elements all we really need to 
//      do here is get the offset properties and return that.  In addition
//      this is all the proxy did, so we will be consistent.
//-------------------------------------------------------------------
STDMETHODIMP 
CAccArea::accLocation(  long* pxLeft, long* pyTop, 
                        long* pcxWidth, long* pcyHeight, 
                        VARIANT varChild)
{
    HRESULT         hr;
    RECT            rectBound;
    CDoc *          pDoc = _pElement->Doc();
    IAccessible *   pAccImg = NULL;
   
    TraceTag((tagAcc, "CAccArea::accLocation, childid=%d", V_I4(&varChild)));  
    WHEN_DBG(rectBound.left = rectBound.top = rectBound.bottom = rectBound.right = 0);

    // validate out parameter
    if ( !pxLeft || !pyTop || !pcxWidth || !pcyHeight )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    //reset out parameters
    *pxLeft = *pyTop =  *pcxWidth = *pcyHeight = 0;
    
    // unpack varChild, and validate the child id against child array limits.
    hr = THR(ValidateChildID(&varChild));
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) != CHILDID_SELF )
    {
        hr = E_NOTIMPL;
        goto Cleanup;
    }

    // we need to be in the active tree.
    if ( _pElement->IsInMarkup() && pDoc && pDoc->GetView()->IsActive() )
    {
        RECT rectImg = g_Zero.rc;       // left, top, bottom, right will map to
                                        // left, top, width, height for location of image

        // get the location relative to the top of the image the area is associated with
        DYNCAST(CAreaElement, _pElement)->GetBoundingRect(&rectBound);

        // get the image's coordinates to calculate the screen location.
        hr = THR(get_accParent((IDispatch **)&pAccImg));
        if (hr)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        Assert( pAccImg );

        // varChild has to contain CHILDID_SELF, otherwise we would not be here.
        hr = THR(pAccImg->accLocation( &rectImg.left, &rectImg.top, 
                                       &rectImg.bottom, &rectImg.right, varChild));
        if (hr)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        // add the image coordinates to the area coordinates to get the screen coordinates
        *pyTop = rectBound.top + rectImg.top;
        *pxLeft = rectBound.left + rectImg.left;
        *pcxWidth = rectBound.right - rectBound.left;
        *pcyHeight = rectBound.bottom - rectBound.top;
    }

Cleanup:
    TraceTag((tagAcc, "CAccArea::accLocation, Location reported as left=%d top=%d width=%d height=%d, hr=%d", 
                rectBound.left,
                rectBound.top,
                rectBound.right - rectBound.left,
                rectBound.bottom - rectBound.top,
                hr));
    ReleaseInterface(pAccImg);
    RRETURN( hr ); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\accbhave.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccBhave.Cxx
//
//  Contents:   Accessible implementation for binary behaviors
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCBHAVE_HXX_
#define X_ACCBHAVE_HXX_
#include "accbhave.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_ACCWINDOW_HXX_
#define X_ACCWINDOW_HXX_
#include "accwind.hxx"
#endif

ExternTag(tagAcc);

//----------------------------------------------------------------------------
//  CAccBehavior::CAccBehavior
//----------------------------------------------------------------------------
CAccBehavior::CAccBehavior( CElement * pElementParent, BOOL fDelegate )
: CAccElement(pElementParent)
{
    if (fDelegate)
    {
        // As the default role, we give the behavior the role that we would
        // give for an ActiveX control. However, the behavior has the right to 
        // change that, since we delegate the get_accRole call. 
        // (See get_accRole implementation for details )
        SetRole(ROLE_SYSTEM_CLIENT);
    }
    else
    {
        SetRole(ROLE_SYSTEM_GROUPING);
    }

    _fDelegate = fDelegate;
    _pSubElement = NULL;
}

//----------------------------------------------------------------------------
//  CAccBehavior::~CAccBehavior
//----------------------------------------------------------------------------
CAccBehavior::~CAccBehavior()
{
    if (_pSubElement)
        _pSubElement->SubRelease();
}

//----------------------------------------------------------------------------
//  EnsureSubElement
//  
//  Ensures that the CAccBehavior::_pSubElement is set properly.
//----------------------------------------------------------------------------
HRESULT
CAccBehavior::EnsureSubElement()
{

    if (_pSubElement)
        return S_OK;

    // get the sub element
    Assert(_pElement->HasSlavePtr());

    CElement * pSubElement = _pElement->GetSlavePtr();
    CMarkup * pMarkup = pSubElement->GetMarkupPtr();

    Assert(pSubElement);
    Assert(pSubElement->Tag() == ETAG_ROOT);

    // Find out if the slave markup has been created by DOM or has 
    // been parsed in from a URL.
    // if the markup has a rootparse context or has the loaded flag
    // set, then it has been parsed. In that case, the slave element
    // is not the root but the BODY tag of the document fragment.
    if (pMarkup->GetRootParseCtx() || pMarkup->GetLoaded())
    {
        pSubElement = pMarkup->GetElementClient();
    }

    Assert((pSubElement->Tag() == ETAG_ROOT) || 
            (pSubElement->Tag() == ETAG_BODY));

    _pSubElement = pSubElement;

    _pSubElement->SubAddRef();

    return S_OK;
}

#define IMPLEMENT_DELEGATE_TO_BEHAVIOR(meth)                                    \
    IAccessible * pAccPtr;                                                      \
                                                                                \
    Assert(_pElement->HasPeerHolder());                                         \
                                                                                \
    hr = THR(_pElement->GetPeerHolder()->QueryPeerInterfaceMulti                \
                            (IID_IAccessible,                                   \
                             (void **)&pAccPtr,                                 \
                             FALSE));                                           \
                                                                                \
    if (S_OK == hr)                                                             \
    {                                                                           \
        Assert(pAccPtr);                                                        \
        hr = THR(pAccPtr->meth);                                                \
        pAccPtr->Release();                                                     \
    }                                                                           \
    else                                                                        \
    {                                                                           \
        hr = E_NOTIMPL;                                                         \
    }                                                                       


//----------------------------------------------------------------------------
//  get_accParent
//
//  Delegate to the behavior first to see if it wants to expose its own tree 
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::get_accParent(IDispatch ** ppdispParent)
{
    HRESULT     hr = E_FAIL;

    if (!ppdispParent)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppdispParent = NULL;

    // delegate to the behavior
    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accParent(ppdispParent))

        // if we get an error that indicates that the behavior does not support the 
        // call, we execute our own version.
    }

    // GetAccParent handles the no markup scenario.
    if (hr)
    {
        CAccBase  * pBase = NULL;

        //
        // We are using the _pElement instead of the _pSubElement here since we want to 
        // walk on the parent tree.
        hr = GetAccParent( _pElement, &pBase);
        if (hr)
            goto Cleanup;

        hr = THR(pBase->QueryInterface(IID_IDispatch, (void**)ppdispParent));
    }
  
Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  get_accChildCount
//
//  DESCRIPTION:
//      if the behavior that is being represented here supports IAccessible,
//      we delegate the call to that behavior. Otherwise we return 0.
//
//  PARAMETERS:
//      pChildCount :   address of the parameter to receive the child count
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::get_accChildCount(long* pChildCount)
{
    HRESULT hr = S_OK;

    if ( !pChildCount )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accChildCount(pChildCount))

        // if we get an error that indicates that the behavior does not support the 
        // IAccessible or the method has a problem running, we return S_OK and a child
        // count of zero.
        if (hr)
        {
            *pChildCount = 0;   //there are no children    
            hr = S_OK;
        }  
    }
    else
    {
        // cache check.
        // since the IsCacheValid checks for the Doc() too, we don't have to
        // check for Doc being there here... 
        // Also, if there is a last child and the child count is zero, then it
        // means that we made a partial walk before and we should count the
        // children now
        if ( !IsCacheValid() || ((_lLastChild != 0) && (_lChildCount == 0)))
        {
            CWindow * pAccWind = GetAccWnd();

            if (!pAccWind)
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            CMarkupPointer *    pBegin = &( pAccWind->_pAccWindow->_elemBegin );
            CMarkupPointer *    pEnd = &( pAccWind->_pAccWindow->_elemEnd );
        
            // get markup limits for this element
            hr = THR(GetSubMarkupLimits( _pSubElement, pBegin, pEnd));
            if ( hr )
                goto Cleanup;
        
            // count the children within the limits provided
            hr = THR( GetChildCount( pBegin, pEnd, &_lChildCount));
        }

        *pChildCount = _lChildCount;
    }

    TraceTag((tagAcc, "CAccBehavior::get_accChildCount, childcnt=%d hr=%d", 
                *pChildCount, hr));

Cleanup:
    RRETURN( hr );
}

//-----------------------------------------------------------------------
//  get_accChild()
//
//  DESCRIPTION:
//      if the behavior that is being represented here supports IAccessible,
//      we delegate the call to that behavior. Otherwise we return an error, since
//      this tag type can not have any children.
//
//  PARAMETERS:
//      varChild    :   Child information
//      ppdispChild :   Address of the variable to receive the child 
//
//  RETURNS:
//
//      E_INVALIDARG | S_OK | S_FALSE
//
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::get_accChild( VARIANT varChild, IDispatch ** ppdispChild )
{
    HRESULT      hr;

    // validate out parameter
    if ( !ppdispChild )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *ppdispChild = NULL;        //reset the return value.

    hr = ValidateChildID(&varChild);
    if (hr)
        goto Cleanup;

    if (_fDelegate)
    {
        if ((V_VT(&varChild) == VT_I4) && (V_I4(&varChild) == CHILDID_SELF))
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accChild(varChild, ppdispChild))

        // If the behavior does not implement this method, behave like 
        // there are no children. 
        if (E_NOTIMPL == hr)
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = super::get_accChild(varChild, ppdispChild);
    }

Cleanup:
    TraceTag((tagAcc, "CAccBehavior::get_accChild, childid=%d requested, hr=0x%x", 
                        V_I4(&varChild),
                        hr));  

    //S_FALSE is valid when there are no children
    //E_NOINTERFACE is valid for text children
    RRETURN2( hr, S_FALSE, E_NOINTERFACE);    
}


//----------------------------------------------------------------------------
//  accLocation()
//  
//  DESCRIPTION:
//      Returns the coordinates of the element relative to the top left corner 
//      of the client window.
//      To do that, we are getting the CLayout pointer from the element
//      and calling the GetRect() method on that class, using the global coordinate
//      system. This returns the coordinates relative to the top left corner of
//      the screen. 
//      We then convert these screen coordinates to client window coordinates.
//      
//      If the childid is not CHILDID_SELF, then tries to delegate the call to the 
//      behavior, and returns E_NOINTERFACE if the behavior does not support 
//      IAccessible.
//  
//  PARAMETERS:
//        pxLeft    :   Pointers to long integers to receive coordinates of
//        pyTop     :   the rectangle.
//        pcxWidth  :
//        pcyHeight :
//        varChild  :   VARIANT containing child information. 
//
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::accLocation(  long* pxLeft, long* pyTop, 
                            long* pcxWidth, long* pcyHeight, 
                            VARIANT varChild)
{
    HRESULT     hr;
    CRect       rectElement;
   
    // validate out parameter
    if ( !pxLeft || !pyTop || !pcxWidth || !pcyHeight )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    //reset out parameters
    *pxLeft = *pyTop =  *pcxWidth = *pcyHeight = 0;

    if (_fDelegate)
    {
        if ( V_I4(&varChild) == CHILDID_SELF )
        {
            // call super's implementation here..... 
            hr = super::accLocation( pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
        }
        else 
        {
            // we pass the error that is actually coming from the behavior, since this location is
            // only hit when the behavior actually reported that it had children.
            IMPLEMENT_DELEGATE_TO_BEHAVIOR(accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild))
        }
    }
    else
    {
        // delegate to the element to handle
        hr = super::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
    }

Cleanup:

    TraceTag((tagAcc, "CAccBehavior::accLocation, childid=%d hr=0x%x", 
                V_I4(&varChild),
                hr));  

    RRETURN1( hr, S_FALSE ); 
}

//----------------------------------------------------------------------------
//  accNavigate
//  
//  DESCRIPTION:
//      Delegate to the behavior if it implements the IAccessible. Otherwise
//      not implemented.
//      
//----------------------------------------------------------------------------
STDMETHODIMP
CAccBehavior::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    HRESULT hr = E_NOTIMPL;

    if ( !pvarEndUpAt )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    V_VT( pvarEndUpAt ) = VT_EMPTY;

    // if we are not delegating to a behavior, handle all navigation in 
    // the super
    if (_fDelegate)
    {
        // if we are delegating, we still handle the next/previous for the element
        // itself on the super. Other methods are delegated to the behavior.
        if ((V_VT(&varStart) == VT_I4) && 
            (V_I4(&varStart) == CHILDID_SELF) && 
            ((navDir == NAVDIR_NEXT) || (navDir == NAVDIR_PREVIOUS)))
        {
            hr = THR(super::accNavigate(navDir, varStart, pvarEndUpAt));
        }
        else
        {
            // for any of the children, and for first and last child navigation calls
            // delegate to the behavior object's implementation of IAccessible.
            IMPLEMENT_DELEGATE_TO_BEHAVIOR(accNavigate(navDir, varStart, pvarEndUpAt))        
        }
    }
    else
    {
        hr = THR(super::accNavigate(navDir, varStart, pvarEndUpAt));
    }
        
Cleanup:
    TraceTag((tagAcc, "CAccBehavior::accNavigate, start=%d, direction=%d", 
                V_I4(&varStart),
                navDir));  

    RRETURN1( hr, S_FALSE );
}

//-----------------------------------------------------------------------
//  accHitTest()
//  
//  DESCRIPTION :   Since the window already have checked the coordinates
//                  and decided that the document contains the point, this
//                  function does not do any point checking. 
//                  If the behavior implements IAccessible, then the call is 
//                  delegated to the behavior. Otherwise CHILDID_SELF is 
//                  returned.
//                  
//  PARAMETERS  :
//      xLeft, yTop         :   (x,y) coordinates 
//      pvarChildAtPoint    :   VARIANT pointer to receive the acc. obj.
//
//  RETURNS:    
//      S_OK | E_INVALIDARG | 
//-----------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{
    HRESULT     hr;

    if (!pvarChildAtPoint)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    VariantInit(pvarChildAtPoint);

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(accHitTest(xLeft,yTop,pvarChildAtPoint))

        // if the behavior does not want to implement this method, act like this 
        // is a single block.
        if (E_NOTIMPL == hr)
        {
            V_VT( pvarChildAtPoint ) = VT_I4;
            V_I4( pvarChildAtPoint ) = CHILDID_SELF;
        
            hr = S_OK;
        }
    }
    else
    {
        hr = CAccElement::accHitTest( xLeft, yTop, pvarChildAtPoint);
    }

Cleanup:
    TraceTag((tagAcc, "CAccBehavior::accHitTest, point(%d,%d), hr=0x%x", 
                xLeft, yTop, hr));  

    RRETURN(hr);
}    

//----------------------------------------------------------------------------
//  accDoDefaultAction
//  
//  DESCRIPTION:
//
//  PARAMETERS:
//      varChild            :   VARIANT child information
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::accDoDefaultAction(VARIANT varChild)
{   
    HRESULT     hr = S_OK;

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(accDoDefaultAction(varChild))
    }

    // If the behavior does not implement this, we scroll the element into focus
    // if the childID was CHILDID_SELF.
    if ((E_NOTIMPL == hr) || !_fDelegate)
    {
        if ((V_VT(&varChild) == VT_I4) && 
            (V_I4(&varChild) == CHILDID_SELF))
        {
            hr = THR(ScrollIn_Focus(_pElement));
        }
        else if (!_fDelegate)
        {
            hr = super::accDoDefaultAction(varChild);
        }
    }

    TraceTag((tagAcc, "CAccBehavior::accDoDefaultAction, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//  get_accName
//  
//  DESCRIPTION:
//      If the behavior implements IAccessible, then call that implementation
//      otherwise return the title, if there is one.
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccBehavior::get_accName(VARIANT varChild,  BSTR* pbstrName )
{
    HRESULT hr = S_OK;
    TCHAR * pchString = NULL;

    // validate out parameter
    if ( !pbstrName )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrName = NULL;

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accName(varChild, pbstrName))
    }

    if ((E_NOTIMPL == hr) || !_fDelegate)
    {
        // Try to return the title of the element 
        if ((V_VT(&varChild) == VT_I4) && 
            (V_I4(&varChild) == CHILDID_SELF))
        {
            hr = S_OK;

            //get the title 
            pchString = (LPTSTR) _pElement->GetAAtitle();
    
            if ( pchString )
            {
                *pbstrName = SysAllocString( pchString );
        
                if ( !(*pbstrName) )
                    hr = E_OUTOFMEMORY;
            }
        }
        else if (!_fDelegate)
        {
            hr = super::get_accName( varChild, pbstrName);
        }
    }
    
Cleanup:
    TraceTag((tagAcc, "CAccBehavior::get_accName, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//  get_accValue
//  
//  DESCRIPTION:
//      Delegates to the behavior. If there is no implementation on the 
//      behavior then E_NOINTERFACE
//  
//  PARAMETERS:
//      pbstrValue   :   BSTR pointer to receive the value
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccBehavior::get_accValue(VARIANT varChild,  BSTR* pbstrValue )
{
    HRESULT hr = E_NOTIMPL;

    // validate out parameter
    if ( !pbstrValue )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrValue = NULL;

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accValue(varChild, pbstrValue))
    }
    else
    {
        hr = super::get_accValue(varChild, pbstrValue);
    }

Cleanup:
    TraceTag((tagAcc, "CAccBehavior::get_accValue, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

    RRETURN2( hr, S_FALSE, E_NOTIMPL );
}

//----------------------------------------------------------------------------
//  get_accDefaultAction
//  
//  DESCRIPTION:
//  If the behavior supports the IAccessible, the behavior is called. 
//  Otherwise the default action for OBJECT tags, which is "select" is returned.
//
//  PARAMETERS:
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::get_accDefaultAction(VARIANT varChild,  BSTR* pbstrDefaultAction )
{
    HRESULT hr = S_OK;

    if ( !pbstrDefaultAction )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDefaultAction = NULL;

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accDefaultAction(varChild, pbstrDefaultAction ))
    }

    if ((E_NOTIMPL == hr) || !_fDelegate)
    {
        // if the behavior returns an error, return "Select" as the default action...
        if ((V_VT(&varChild) == VT_I4) && 
            (V_I4(&varChild) == CHILDID_SELF))
        {
            hr = S_OK;

            // TODO :  resource string
            *pbstrDefaultAction = SysAllocString( _T("Select") );

            if ( !(*pbstrDefaultAction) )
                hr = E_OUTOFMEMORY;
        }
        else if (!_fDelegate)
        {
            hr = super::get_accDefaultAction( varChild, pbstrDefaultAction);
        }
    }

Cleanup:
    TraceTag((tagAcc, "CAccBehavior::get_accDefaultAction, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

   RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//  get_accState
//  
//  DESCRIPTION:
//      
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccBehavior::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    HRESULT hr = S_OK;

    // validate out parameter
    if ( !pvarState )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accState( varChild, pvarState))
    }

    // Do the best we can, if the behavior does not support this.
    if ((E_NOTIMPL == hr) || !_fDelegate)
    {
        if ((V_VT(&varChild) == VT_I4) && 
            (V_I4(&varChild) == CHILDID_SELF))
        {
            hr = S_OK;

            CDoc *  pDoc = _pElement->Doc();

            V_I4( pvarState ) = 0;

            if ( _pElement->GetReadyState() != READYSTATE_COMPLETE )
                V_I4( pvarState ) |= STATE_SYSTEM_UNAVAILABLE;
    
            if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus() )
                V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;
    
            if ( !_pElement->IsVisible(FALSE) )
                V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;
        }
        else if (!_fDelegate)
        {
            hr = super::get_accState(varChild, pvarState);
        }
    }
    
Cleanup:
    TraceTag((tagAcc, "CAccBehavior::get_accState, childid=%d, state=0x%x, hr=0x%x", 
                V_I4(&varChild), V_I4( pvarState ), hr));  

    RRETURN2( hr, S_FALSE, E_NOTIMPL );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP
CAccBehavior::get_accDescription(VARIANT varChild, BSTR * pbstrDescription )
{
    HRESULT hr;

    if ( !pbstrDescription )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDescription = NULL;

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accDescription(varChild, pbstrDescription))
    }
    else
    {
        hr = super::get_accDescription(varChild, pbstrDescription);
    }

Cleanup:
    TraceTag((tagAcc, "CAccBehavior::get_accDescription, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

    RRETURN2( hr, S_FALSE, E_NOTIMPL );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP
CAccBehavior::get_accKeyboardShortcut( VARIANT varChild, BSTR* pbstrKeyboardShortcut)
{
    HRESULT hr;

    if (!pbstrKeyboardShortcut)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrKeyboardShortcut = NULL;

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accKeyboardShortcut(varChild, pbstrKeyboardShortcut))
    }
    else
    {
        hr = THR(GetAccKeyboardShortcut(pbstrKeyboardShortcut));
    }

Cleanup:
    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::get_accFocus(VARIANT * pvarFocusChild)
{
    HRESULT hr;

    if (!pvarFocusChild)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    VariantInit(pvarFocusChild);

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accFocus(pvarFocusChild))
    }
    else
    {
        CDoc * pDoc = GetElement()->Doc();

        // Is the active element the view master or the primary 
        // element client of the viewlinked markup ?
        if ((_pElement == pDoc->_pElemCurrent) ||
            (GetElement() == pDoc->_pElemCurrent))
        {
            V_VT( pvarFocusChild ) = VT_I4;
            V_I4( pvarFocusChild ) = CHILDID_SELF;
            hr = S_OK;
        }
        else
        {
            hr = super::get_accFocus(pvarFocusChild);
        }
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP
CAccBehavior::get_accSelection(VARIANT * pvarSelectedChildren)
{
    HRESULT hr = E_NOTIMPL;

    // clean the return value 
    if (!pvarSelectedChildren)
    {   
        hr = E_POINTER;
        goto Cleanup;
    }

    VariantInit(pvarSelectedChildren);

    if(_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accSelection(pvarSelectedChildren))
    }
    else
    {
        super::get_accSelection(pvarSelectedChildren);
    }

Cleanup:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::accSelect( long flagsSel, VARIANT varChild)
{
    HRESULT hr = E_NOTIMPL;

    // if the element itself is being asked to take focus, 
    // then no need to delegate.
    if ((V_I4(&varChild) == CHILDID_SELF) && 
        (V_VT(&varChild) == VT_I4))
    {
        if (flagsSel & SELFLAG_TAKEFOCUS)
            hr = THR(ScrollIn_Focus(_pElement));
    }
    else
    {
        if (_fDelegate)
        {
            IMPLEMENT_DELEGATE_TO_BEHAVIOR( accSelect( flagsSel, varChild))
        }
        else
        {
            hr = super::accSelect( flagsSel, varChild);
        }
    }

    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    HRESULT hr=S_OK;

    TraceTag((tagAcc, "CAccBehavior::get_accRole, childid=%d", 
                V_I4(&varChild)));  

    if (!pvarRole)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // clear the out parameter
    V_VT( pvarRole ) = VT_EMPTY;

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(get_accRole(varChild, pvarRole))
    }

    //
    // If the behavior is not capable of reporting a role, 
    // or we are not hooked to a binary behavior,
    // then return the default role that was set in the constructor.
    //
    if ((E_NOTIMPL == hr) || !_fDelegate)
    {
        if ((V_VT(&varChild) == VT_I4) && 
            (V_I4(&varChild) == CHILDID_SELF))
        {
            // pack role into out parameter
            V_VT( pvarRole ) = VT_I4;
            V_I4( pvarRole ) = GetRole();
            hr = S_OK;
        }
        else if (!_fDelegate)
        {
            hr = super::get_accRole(varChild, pvarRole);
        }
    }

Cleanup:
    RRETURN2(hr, S_FALSE, E_NOTIMPL);
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::put_accValue( VARIANT varChild, BSTR bstrValue )
{
    HRESULT hr = E_NOTIMPL;

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(put_accValue(varChild, bstrValue))
    }

    RRETURN1( hr, S_FALSE );
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBehavior::put_accName( VARIANT varChild, BSTR bstrName )
{
    HRESULT hr = E_NOTIMPL;

    if (_fDelegate)
    {
        IMPLEMENT_DELEGATE_TO_BEHAVIOR(put_accName(varChild, bstrName))
    }

    RRETURN2( hr, S_FALSE, E_NOTIMPL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\accbase.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccBase.Cxx
//
//  Contents:   Accessible base object implementation
//
//----------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCBASE_HXX_
#define X_ACCBASE_HXX_
#include "accbase.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

MtDefine(CAccBase, ObjectModel, "CAccBase")

//+----------------------------------------------------------------
//
//  member : classdesc
//
//  Synopsis : CBase Class Descriptor Structure
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CAccBase::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IAccessible,               // _piidDispinterface
    NULL,                           // _apHdlDesc
};


//----------------------------------------------------------------------------
//  IUnknown Interface Implementation
//----------------------------------------------------------------------------

//-----------------------------------------------------------------------
//  CAccBase::QueryInterface()
//
//  DESCRIPTION:
//
//      Standard QI implementation : the CAccBase object implements
//      IDispatch and IAccessible.
//
//  PARAMETERS:
//
//      riid        REFIID of requested interface.
//      ppv         pointer to interface in.
//
//  RETURNS:
//
//      E_NOINTERFACE | NOERROR.
//
//  TODO    : Add IEnumVariant.
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccBase::PrivateQueryInterface(REFIID riid, void ** ppv)
{
    HRESULT hr = S_OK;
    
    if ( !ppv )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
  
    if (riid == IID_IUnknown)
    {
        *ppv = (IUnknown *)((IPrivateUnknown *)this);
    }
    else if (riid == IID_IDispatch) 
    {
        *ppv = (IDispatch *)((IAccessible *)this);
    }
    else if ( riid == IID_IAccessible )
    {
        *ppv = (IAccessible *)this;
    }
    /*
    else if ( riid == IID_IEnumVARIANT )
    {
        // Get the enumerator for this instance. We don't
        // keep a reference for the enumerator, so we
        // don't have to AddRef it below.

        // BOLLOCKS - Breaks COM Rules
        hr = THR( GetEnumerator( (IEnumVARIANT **)ppv ) );
    }
    */
    else if ( riid == IID_IServiceProvider )
    {
        *ppv = (IServiceProvider *)this;
    }
    else
    {
        //Delegate the call to the super;
        hr = THR( super::PrivateQueryInterface( riid, ppv));
        goto Cleanup;
    }

    //AddRef if the pointer is being returned.
    if ( *ppv /*&& (riid != IID_IEnumVARIANT)*/)
    {
        ((LPUNKNOWN) *ppv)->AddRef();
    }

Cleanup:
    RRETURN1( hr, E_NOINTERFACE);
}

//+---------------------------------------------------------------------------
//  GetTypeInfoCount
//  
//  DESCRIPTION:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBase::GetTypeInfoCount( UINT *pctInfo )
{
    // check the out parameter
    if ( !pctInfo )
    {
        RRETURN( E_POINTER );
    }
    
    //set the type information count
    *pctInfo = 1;

    RRETURN( S_OK );
}


//+---------------------------------------------------------------------------
//  GetTypeInfoCount
//  
//  DESCRIPTION:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBase::GetTypeInfo(  unsigned int iTInfo,
                        LCID ,
                        ITypeInfo FAR* FAR* ppTInfo)
{   
    HRESULT     hr = S_OK;

    if ( iTInfo )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    if ( !ppTInfo )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    hr = THR( EnsureAccTypeInfo( ppTInfo ) );
    
Cleanup:    
    RRETURN( hr ); 
}

//+---------------------------------------------------------------------------
//  GetIDsOfNames
//  
//  DESCRIPTION:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBase::GetIDsOfNames(    REFIID riid,
                            OLECHAR FAR* FAR* rgszNames,
                            unsigned int cNames,
                            LCID,
                            DISPID FAR* rgDispId)
{
    HRESULT     hr;
    ITypeInfo * pAccTypeInfo = NULL;
    
    hr = THR( EnsureAccTypeInfo( &pAccTypeInfo ) );
    if ( hr )
        RRETURN( hr );

    Assert( pAccTypeInfo );
    
    RRETURN( DispGetIDsOfNames( pAccTypeInfo, 
                                rgszNames, 
                                cNames, 
                                rgDispId));
}

//+---------------------------------------------------------------------------
//  Invoke
//  
//  DESCRIPTION:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBase::Invoke(   DISPID dispIdMember,
                    REFIID riid,
                    LCID,
                    WORD wFlags,
                    DISPPARAMS FAR* pDispParams,
                    VARIANT FAR* pVarResult,
                    EXCEPINFO FAR* pExcepInfo,
                    unsigned int FAR* puArgErr)
{
    HRESULT     hr;
    ITypeInfo * pAccTypeInfo = NULL;

    hr = THR( EnsureAccTypeInfo( &pAccTypeInfo ) );
    if ( hr )
        RRETURN( hr );

    Assert( pAccTypeInfo );

    RRETURN( DispInvoke(    DYNCAST( IAccessible, this),           
                            pAccTypeInfo,   
                            dispIdMember,   
                            wFlags,         
                            pDispParams,    
                            pVarResult,     
                            pExcepInfo,     
                            puArgErr) );
}


//----------------------------------------------------------------------------
//  DESCRIPTION :   
//          Not supported
//
//  PARAMETERS:
//      varChild     :   VARIANT containing the child ID
//      pbstrHelp    :   pointer to the BSTR to receive data.
//
//  RETURNS:
//      DISP_E_MEMBERNOTFOUND
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBase::get_accHelp(VARIANT varChild, BSTR* pbstrHelp)
{
    if ( pbstrHelp )
        *pbstrHelp = NULL;
        
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//  DESCRIPTION :   
//          Not supported
//
//  PARAMETERS:
//      pbstrHelpFile   :   Path for the help file.
//      varChild        :   VARIANT containing the child ID
//      pidTopic        :   address of the long to receive data
//
//  RETURNS:
//      DISP_E_MEMBERNOTFOUND
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBase::get_accHelpTopic(BSTR* pbstrHelpFile, VARIANT varChild, long* pidTopic)
{
    if ( pidTopic )
        *pidTopic = NULL;
        
    return E_NOTIMPL;
}


//----------------------------------------------------------------------------
//  DESCRIPTION :   
//          NYI
//
//  PARAMETERS:
//      varChild     :   VARIANT containing the child ID
//      pbstrValue   :   value bstr
//
//  RETURNS:
//      DISP_E_MEMBERNOTFOUND
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBase::put_accName(VARIANT varChild, BSTR bstrName)
{   
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//
//  IOleWindow implementation
//
//----------------------------------------------------------------------------
STDMETHODIMP    
CAccBase::GetWindow( HWND* phwnd )
{
    HRESULT hr = S_OK;
    
    if ( !phwnd )
    {
        hr = E_POINTER;
    }
    else
    { 
        Assert( GetAccWnd()->Doc()->State() >= OS_INPLACE );
        
        //get the window handle from the document.
        *phwnd = GetAccWnd()->Doc()->GetHWND();
        if ( !(*phwnd) )
            hr = E_FAIL;
    }

    RRETURN( hr );
}


STDMETHODIMP
CAccBase::ContextSensitiveHelp( BOOL fEnterMode )
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//
//
//      HELPER FUNCTIONS 
//
//----------------------------------------------------------------------------


//+---------------------------------------------------------------------------
//  ValidateChildID()
//
//  DESCRIPTION:
//      Validates the child id that is passed in in a variant variable. This is 
//      used only on in-parameters so that is it a safe operation to change it
//      and dereference in place.
//----------------------------------------------------------------------------
HRESULT 
CAccBase::ValidateChildID( VARIANT *pVar )
{
    HRESULT hr = S_OK;
    
    Assert(pVar);

    switch ( V_VT( pVar ) )
    {
        case VT_VARIANT | VT_BYREF:
            VariantCopy( pVar, pVar->pvarVal );
            hr = ValidateChildID( pVar );
            break;

        case VT_ERROR:
            if ( pVar->scode != DISP_E_PARAMNOTFOUND )
            {
                hr = E_INVALIDARG;
                break;
            }
          // Treat this as a VT_EMPTY

        case VT_EMPTY:
            V_VT(pVar ) = VT_I4;
            V_I4( pVar ) = CHILDID_SELF;
            break;

        case VT_I4:
            if ( V_I4( pVar ) < 0 )
                hr = E_INVALIDARG;
            break;

        default:
            hr = E_INVALIDARG;
    }

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//  GetAccParent
//  
//  DESCRIPTION:
//      Non-virtual helper that returns the accessible parent object for a 
//      CElement.
//      Although this function works with elements, it is still placed in the
//      base class, since the frames also have element parents, although they
//      are themselves accessible window objects.
//  
//  PARAMETERS:
//      pElem       :   CElement which we want the accessible parent of.
//      pAccParent  :   Pointer to the accessible parent object to be returned.
//  
//  RETURNS:
//      S_OK | E_POINTER | E_OUTOFMEMORY | E_FAIL
//----------------------------------------------------------------------------
HRESULT
CAccBase::GetAccParent( CElement * pElem,  CAccBase ** ppAccParent)
{
    HRESULT     hr = S_OK;
    CTreeNode * pNode = NULL;
    CTreeNode * pParentNode = NULL;
    
    if ( !ppAccParent )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppAccParent = NULL;

    //
    // get to the element's node
    //
    pNode = pElem->GetFirstBranch();

    // We have to have a tree node that is in the tree when we reach here
    if ( !pNode || pNode->IsDead())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // initialize for the loop
    pParentNode = pNode;

    //
    // loop until we find a parent node, that is connected to an 
    // HTML element that is a supported in the accessibility world.
    //
    // use do/while since the element passed with pElem may not be supported.
    do 
    {
        pParentNode = pParentNode->Parent();
    }
    while ( pParentNode && 
            (pParentNode->Tag() != ETAG_ROOT) && 
            !IsSupportedElement( pParentNode->Element()));

    if ( !pParentNode )
    {
        hr = S_FALSE;   // according to the spec, this is what we should return
        goto Cleanup;
    }
    else
    {
        // We have hit a valid element, but if it is a BODY tag, then we 
        // may be in a viewlink that is not a frame/iframe
        // 
        // In that case, the parent is the master element.
        //

        // If we hit a BODY tag and the master is a GENERIC tag, then use that tag
        // as the parent.
        CRootElement * pRoot = pParentNode->GetMarkup()->Root();

        if ((pParentNode->Tag() == ETAG_BODY) && 
            (pRoot->HasMasterPtr()) && 
            (pRoot->GetMasterPtr()->Tag() == ETAG_GENERIC))
        {
            pParentNode = pRoot->GetMasterPtr()->GetFirstBranch();
        }
        else if (pParentNode->Tag() == ETAG_ROOT)
        {
            // If we hit the root and that kicked us out of the loop, then use its
            // master if it has one.
            // Otherwise, we have reached the top without finding anything.
            //
            if (pParentNode->Element()->HasMasterPtr())
            {
                pParentNode = pParentNode->Element()->GetMasterPtr()->GetFirstBranch();
            }
            else
            {
                hr = S_FALSE;
                goto Cleanup;
            }
        }
        
        Assert(IsSupportedElement(pParentNode->Element()));
    }

    //
    // Since we have found the node for the supported element parent,
    // we can now create the accessible object for that element.
    //
    *ppAccParent = GetAccObjOfElement( pParentNode->Element() );

    if ( !(*ppAccParent)) 
        hr = E_OUTOFMEMORY;

Cleanup:
    RRETURN1( hr, S_FALSE );
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
HRESULT 
CAccBase::EnsureAccTypeInfo( ITypeInfo ** ppTI )
{
    HRESULT     hr = S_OK;
    CDoc *      pRootDoc = NULL;
    ITypeLib *  pTLib = NULL;
    
    // only called by internal methods
    Assert( ppTI );

    pRootDoc = GetAccWnd()->Doc();
    
    // if the root document already has a cached ITypeInfo for IAccessible
    if ( pRootDoc && pRootDoc->_pAccTypeInfo )
    {
        *ppTI = pRootDoc->_pAccTypeInfo;
    }
    else
    {
        OLECHAR     szFile[] = _T("OLEACC.DLL");
        
        // get the type information pointer from OLEACC
        hr = THR(LoadTypeLib( szFile, &pTLib));
        if ( hr )
            goto Cleanup;

        Assert( pTLib );

        // get the type information for the IID_IAccessible 
        hr = THR( pTLib->GetTypeInfoOfGuid( IID_IAccessible, ppTI));
        if ( hr )
            goto Cleanup;

        // it is implied with the 'if' above that we will have a valid *ppTI
        Assert( *ppTI );
        
        // cache the pointer if the call was successfull
        if ( pRootDoc )
            pRootDoc->_pAccTypeInfo = *ppTI;
    }
    
Cleanup:
    // we can release the pTLib, since we are holding on to the type
    // information from the same type library
    ReleaseInterface( pTLib );
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\accbtn.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccBtn.Cxx
//
//  Contents:   Accessible object for the INPUT buttons( BUTTON, RESET, SUBMIT)
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCBTN_HXX_
#define X_ACCBTN_HXX_
#include "accbtn.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif


//-----------------------------------------------------------------------
//  CAccBtn::CAccBtn()
//
//  DESCRIPTION:
//      Contructor. 
//
//  PARAMETERS:
//      pElementParent  :   Address of the CElement that hosts this 
//                          object.
//----------------------------------------------------------------------
CAccButton::CAccButton( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );

    //initialize the instance variables
    SetRole( ROLE_SYSTEM_PUSHBUTTON );
}

//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      If the title is not empty return it. Otherwise return the object.value 
//      for tag==INPUT and object.innertext for tag==BUTTON
//      
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccButton::GetAccName( BSTR* pbstrName)
{
    HRESULT hr = S_OK;
    CStr    strValue;

    // validate out parameter
    if ( !pbstrName )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrName = NULL;

    if ( _pElement->Tag() == ETAG_INPUT )
    {
        hr = THR( DYNCAST(CInput, _pElement)->GetValueHelper( &strValue ) );
        if ( hr )
            goto Cleanup;

        hr = THR( strValue.AllocBSTR( pbstrName ) );
    }
    else
    {
        hr = THR( _pElement->get_innerText( pbstrName ) );
    }

    //get the title 
    if ( !( *pbstrName ) )
        hr = GetTitleorLabel(pbstrName);


Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      If the title is not empty return it. Otherwise return the object.value 
//      for tag==INPUT and object.innertext for tag==BUTTON
//  
//  PARAMETERS:
//      pbstrDescription    :   BSTR pointer to receive the description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccButton::GetAccDescription( BSTR* pbstrDescription)
{
    HRESULT hr = S_OK;
    CStr    strValue;

    // validate out parameter
    if ( !pbstrDescription )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDescription = NULL;

    // the description is the Title if there is a value for:
    //     NAME:{if <input type=button > return Value or "" .
    //           for <BUTTON> tag return the inner text }
    // otherwise, it is ""
    if ( _pElement->Tag() == ETAG_INPUT )
    {
        hr = THR( DYNCAST(CInput, _pElement)->GetValueHelper( &strValue ) );
    }
    else
    {
        hr = THR( _pElement->get_innerText( pbstrDescription ) );
    }

    // we'll have one or the other, but never both
    if ( *pbstrDescription)
    {
        SysFreeString(*pbstrDescription);
        *pbstrDescription = NULL;
        hr = GetTitle( pbstrDescription );
    }
    else if (!strValue.IsNull())
    {
        hr = GetTitle( pbstrDescription );
    }

Cleanup:
    RRETURN1( hr, S_FALSE );
}


//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      always STATE_SYSTEM_LINKED
//      if not visible, then STATE_SYSTEM_INVISIBLE
//      if document has the focus, then STATE_SYSTEM_FOCUSABLE
//      if this is the active element. then STATE_SYSTEM_FOCUSED
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccButton::GetAccState(  VARIANT *pvarState)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = _pElement->Doc();

    // validate out parameter
     if ( !pvarState )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;
    
    if ( !_pElement->IsEnabled() )
        V_I4( pvarState ) |= STATE_SYSTEM_UNAVAILABLE;
    else
    {
        if ( IsFocusable(_pElement) )
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;
    
        if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus()) 
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;

        if ( !_pElement->IsVisible(FALSE) )
            V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;
    
        if (( _pElement->Tag()==ETAG_INPUT ) && 
            ( (DYNCAST(CInput, _pElement))->GetAAtype() == htmlInputSubmit) )
        {
            V_I4( pvarState ) |= STATE_SYSTEM_DEFAULT;
        }
    }

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccDefaultAction
//  
//  DESCRIPTION:
//  Returns the default action, which is "Press"
//
//  PARAMETERS:
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccButton::GetAccDefaultAction( BSTR* pbstrDefaultAction)
{
    HRESULT hr = S_OK;

    if ( !pbstrDefaultAction )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDefaultAction = SysAllocString( _T("Press") );

    if (!(*pbstrDefaultAction) )
        hr = E_OUTOFMEMORY;
   
Cleanup:
   RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\acccheck.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccCheck.Cxx
//
//  Contents:   Accessible Checkbox object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCCHECK_HXX_
#define X_ACCCHECK_HXX_
#include "acccheck.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

//----------------------------------------------------------------------------
//  CAccCheckbox
//  
//  DESCRIPTION:    
//      The checkbox accessible object constructor
//
//  PARAMETERS:
//      Pointer to the checkbox element 
//----------------------------------------------------------------------------
CAccCheckbox::CAccCheckbox( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );
    
    //initialize the instance variables
    SetRole( ROLE_SYSTEM_CHECKBUTTON );
}

//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      Returns the label, if not the title.
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccCheckbox::GetAccName( BSTR* pbstrName)
{
    HRESULT hr;

    // validate out parameter
    if ( !pbstrName )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrName = NULL;

    hr = THR( GetLabelorTitle(pbstrName) );

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      Returns the label, if not, the title
//  
//  PARAMETERS:
//      pbstrDescription   :   BSTR pointer to receive the Description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccCheckbox::GetAccDescription( BSTR* pbstrDescription)
{
    HRESULT hr=S_OK;

    // validate out parameter
    if ( !pbstrDescription )
    {   
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDescription = NULL;

    if (HasLabel())
        hr = THR( GetTitle( pbstrDescription ) );

Cleanup:
    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      if not visible, then STATE_SYSTEM_INVISIBLE
//      if document has the focus, then STATE_SYSTEM_FOCUSABLE
//      if this is the active element. then STATE_SYSTEM_FOCUSED
//      if it is not enabled then STATE_SYSTEM_UNAVAILABLE
//      if checked then STATE_SYSTEM_CHECKED
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccCheckbox::GetAccState( VARIANT *pvarState)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bChecked = FALSE;
    CDoc *          pDoc = _pElement->Doc();

    // validate out parameter
    if ( !pvarState )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;
    
    if ( !_pElement->IsEnabled() )
        V_I4( pvarState ) |= STATE_SYSTEM_UNAVAILABLE;
    else
    {
        if ( IsFocusable(_pElement) )
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;
    
        if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus()) 
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;

        if ( !_pElement->IsVisible(FALSE) )
            V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;
    
        hr = THR( (DYNCAST( CInput, _pElement))->GetChecked(&bChecked) ) ;
        if ( hr )
            goto Cleanup;
    
        //check explicitly for FALSE since this is a VARIANT_BOOL.
        if ( bChecked != VB_FALSE )
            V_I4( pvarState ) |= STATE_SYSTEM_CHECKED;
    }

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccDefaultAction
//  
//  DESCRIPTION:
//      Returns the default action for a checkbox. The default action is either
//      "check" or "uncheck", depending on the state of the checkbox
//
//  PARAMETERS:
//      varChild            :   VARIANT child information
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccCheckbox::GetAccDefaultAction( BSTR* pbstrDefaultAction)
{
    HRESULT         hr;
    VARIANT_BOOL    bChecked = FALSE;

    if ( !pbstrDefaultAction )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDefaultAction = NULL;

    hr = THR( (DYNCAST( CInput, _pElement))->GetChecked(&bChecked) ) ;
    if ( hr )
        goto Cleanup;

    //check explicitly for FALSE since this is a VARIANT_BOOL.
    if ( bChecked != VB_FALSE )
    {
        *pbstrDefaultAction = SysAllocString( _T("Uncheck") );
    }
    else
    {
        *pbstrDefaultAction = SysAllocString( _T("Check") );
    }

    if (!(*pbstrDefaultAction) )
        hr = E_OUTOFMEMORY;
   
Cleanup:
   RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\accbody.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccBody.Cxx
//
//  Contents:   Accessible object for the Body Element 
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_ACCBODY_HXX_
#define X_ACCBODY_HXX_
#include "accbody.hxx"
#endif

#ifndef X_ACCWIND_HXX_
#define X_ACCWIND_HXX_
#include "accwind.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

ExternTag(tagAcc);

extern HRESULT EnsureAccWindow(CWindow * pWindow);

//-----------------------------------------------------------------------
//  CAccBody::CAccBody()
//
//  DESCRIPTION:
//      Contructor. 
//
//  PARAMETERS:
//      pElementParent  :   Address of the CElement that hosts this 
//                          object.
//----------------------------------------------------------------------
CAccBody::CAccBody( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );

    //initialize the instance variables
    SetRole(ROLE_SYSTEM_PANE);
}

//-----------------------------------------------------------------------
//  get_accParent
//
//  DESCRIPTION    :
//          Return the window object related to the document that contains
//          the body tag.
//          The implementation of this method is fairly simple and different
//          from the CAccBase::get_accParent implementation. The reason is 
//          that we know for a that the body can be only parented by the
//          document itself.
//-----------------------------------------------------------------------
STDMETHODIMP 
CAccBody::get_accParent( IDispatch ** ppdispParent )
{
    HRESULT hr = S_OK;

    if ( !ppdispParent )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppdispParent = NULL;

    // If the document has not been questioned for its accessible object
    // yet. This could happen if the hit test started at a windowed child.

    //
    // !! <<<< READTHIS BEFORE MAKING CHANGES HERE >>>> 
    // The accbody is created for both FRAMESET and BODY tags that are the primary
    // client of the window. The frameset elements that are not at the top level are
    // ignored. This is IE4 and IE5 compat requirement for MSAA1.x. DO NOT CHANGE! 
    // (FerhanE)

    CWindow * pWindow;

    pWindow = _pElement->GetCWindowPtr();
    hr = EnsureAccWindow(pWindow);
    if (hr)
        goto Cleanup;

    Assert(pWindow->_pAccWindow);

    hr = THR( pWindow->_pAccWindow->QueryInterface(IID_IDispatch, (void**)ppdispParent));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//  get_accSelection
//  
//  DESCRIPTION:
//      The CAccBody is a special case for this method, since it also can
//      represent a frameset. 
//      If the object represents a frameset, then the call is delegated to the 
//      frame that has the focus.
//      Otherwise, the call is delegated to the CAccElement implementation of this
//      method, since CAccElement is the base class for the CAccBOdy, and the body
//      element is treated as any other.
//      
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBody::get_accSelection(VARIANT * pvarSelectedChildren)
{
    HRESULT     hr = S_OK;
    CElement *  pClient = NULL;
    CAccBase *  pAccChild = NULL;
    CDoc *      pDoc = _pElement->Doc();

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if ( _pElement->Tag() == ETAG_BODY )
    {
        hr = THR( CAccElement::get_accSelection( pvarSelectedChildren ) );
        goto Cleanup;
    }

    // the element is a frameset.

    // get the active frame and delegate the call. This function handles
    // recursive frames too.
    if ( pDoc )
    {
        CFrameElement *  pFrameActive;

        // Get the active frame element in this frameset tag's markup.
        hr = THR(pDoc->GetActiveFrame(&pFrameActive, _pElement->GetMarkupPtr()));
        if (hr)
            goto Cleanup;

        if (pFrameActive)
        {
            // We have a frame element that is active, and a child of this frameset.
            // Delegate the call to the active frame's document's element client.
            Assert(pFrameActive->_pWindow->Markup());
            pClient = pFrameActive->_pWindow->Markup()->GetElementClient();
        
            Assert( pClient );
    
            pAccChild = GetAccObjOfElement( pClient );
            if ( !pAccChild )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            hr = THR( pAccChild->get_accSelection( pvarSelectedChildren ) );
        }
        else
        {
            // return no selection
            VariantClear(pvarSelectedChildren);
        }
    }

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  DESCRIPTION:
//      Returns the document title
//      
//
//  PARAMETERS:
//      pbstrName   :   address of the pointer to receive the URL BSTR
//
//  RETURNS:    
//      E_INVALIDARG | S_OK | 
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccBody::GetAccName( BSTR* pbstrName)
{
    HRESULT     hr = S_OK;
    CMarkup *   pMarkup;

    // validate out parameter
    if ( !pbstrName )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrName = NULL;
    
    pMarkup = _pElement->GetMarkupPtr();
    if (!pMarkup)
        goto Cleanup;

    TraceTag((tagAcc, "CAccBody::GetAccName, %s", (CMarkup::GetUrl(pMarkup))));

    hr = THR(pMarkup->Document()->get_title(pbstrName));

Cleanup:
    RRETURN(hr);
}

//-----------------------------------------------------------------------
//  DESCRIPTION :   
//      Return the value for the document object, this is the URL of the 
//      document if the child id is CHILDID_SELF. 
//
//  PARAMETERS:
//      pbstrValue  :   pointer to the BSTR to receive the value.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//-----------------------------------------------------------------------
STDMETHODIMP 
CAccBody::GetAccValue( BSTR* pbstrValue )
{
    HRESULT     hr = S_OK;
    CMarkup *   pMarkup;

    if ( !pbstrValue )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *pbstrValue = NULL;

    pMarkup = _pElement->GetMarkupPtr();
    if (!pMarkup)
        goto Cleanup;

    TraceTag((tagAcc, "CAccBody::GetAccName, %s", (CMarkup::GetUrl(pMarkup))));

    hr = THR(pMarkup->Document()->get_URL(pbstrValue));

Cleanup:
    RRETURN( hr );
}


//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
STDMETHODIMP 
CAccBody::GetAccState( VARIANT *pvarState)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = _pElement->Doc();

    // validate out parameter
     if ( !pvarState )
     {
        hr = E_POINTER;
        goto Cleanup;
     }
     
    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;
    
    if ( _pElement->GetReadyState() != READYSTATE_COMPLETE )
        V_I4( pvarState ) = STATE_SYSTEM_UNAVAILABLE;
    else 
        V_I4( pvarState ) = STATE_SYSTEM_READONLY;
    
    if ( IsFocusable(_pElement) )
        V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;

    if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus()) 
        V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;    

Cleanup:
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\accedit.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccEdit.Cxx
//
//  Contents:   Accessible editbox object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCEDIT_HXX_
#define X_ACCEDIT_HXX_
#include "accedit.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_TEXTAREA_HXX_
#define X_TEXTAREA_HXX_
#include "textarea.hxx"
#endif

//----------------------------------------------------------------------------
//  CAccEdit
//  
//  DESCRIPTION:    
//      The editbox accessible object constructor
//
//  PARAMETERS:
//      Pointer to the editbox element 
//----------------------------------------------------------------------------
CAccEdit::CAccEdit( CElement* pElementParent, BOOL bIsPassword )
:CAccElement( pElementParent)
{
    Assert( pElementParent );
    
    //initialize the instance variables
    SetRole( ROLE_SYSTEM_TEXT );

    // is this edit control of type input password.
    _bIsPassword = bIsPassword;
}


//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      Returns the label text or the title
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccEdit::GetAccName( BSTR* pbstrName )
{
    HRESULT hr = S_OK;

    // validate out parameter
     if ( !pbstrName )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrName = NULL;

    hr = THR( GetLabelorTitle(pbstrName) );    

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccValue
//  
//  DESCRIPTION:
//      Returns the value of the edit box.
//  
//  PARAMETERS:
//      pbstrValue   :   BSTR pointer to receive the value
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccEdit::GetAccValue( BSTR* pbstrValue)
{
    HRESULT hr = S_OK;
    CStr    str;

    // validate out parameter
    if ( !pbstrValue )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrValue = NULL;

    // if not a password element, then return the information
    if ( !_bIsPassword )
    {
        if (_pElement->Tag() != ETAG_TEXTAREA)
        {
            hr = THR( (DYNCAST( CInput, _pElement))->GetValueHelper( &str ) );
        }
        else
        {
            hr = THR((DYNCAST(CTextArea, _pElement))->GetValueHelper( &str ));
        }
        
        if ( hr ) 
            goto Cleanup;

        //even if the value that is returned is NULL, we want to return it..
        hr = str.AllocBSTR(pbstrValue);
    }
    else
        hr = E_ACCESSDENIED;    // password's can not be read by outsiders.
    
Cleanup:
    RRETURN( hr );
}



//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      Returns the title if there is no label, otherwise ""
//  
//  PARAMETERS:
//      pbstrDescription   :   BSTR pointer to receive the Description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccEdit::GetAccDescription( BSTR* pbstrDescription)
{
    HRESULT hr=S_OK;

    // validate out parameter
    if ( !pbstrDescription )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrDescription = NULL;

    if (HasLabel())
        hr = THR( GetTitle( pbstrDescription ) );

Cleanup:
    RRETURN1( hr, S_FALSE );
}


//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      if not visible, then STATE_SYSTEM_INVISIBLE
//      if document has the focus, then STATE_SYSTEM_FOCUSABLE
//      if this is the active element. then STATE_SYSTEM_FOCUSED
//      if it is not enabled then STATE_SYSTEM_UNAVAILABLE
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccEdit::GetAccState( VARIANT *pvarState)
{
    HRESULT hr =S_OK;
    CDoc *  pDoc = _pElement->Doc();

    // validate out parameter
    if ( !pvarState )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;
    
    if ( !_pElement->IsEnabled() )
        V_I4( pvarState ) |= STATE_SYSTEM_UNAVAILABLE;
    else
    {  
        if ( IsFocusable(_pElement) )
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;

        if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus()) 
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;
    }

    if ( !_pElement->IsVisible(FALSE) )
        V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;

    if ( _bIsPassword )
        V_I4( pvarState ) |= STATE_SYSTEM_PROTECTED;

Cleanup:
    RRETURN( hr );
}


HRESULT
CallInvoke(CElement * pElement, OLECHAR* pszMethod, BSTR bstrValue)
{
    HRESULT             hr;
    IDispatch          *pDispatch = NULL;
    DISPID              dispid;
    DISPPARAMS          params;
    VARIANTARG          var;

    hr = pElement->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    if ( hr )
    {
        goto Cleanup;
    }

    hr = pDispatch->GetIDsOfNames(IID_NULL, &pszMethod, 1, LCID_SCRIPTING, &dispid);
    if ( hr )
    {
        goto Cleanup;
    }

    V_BSTR(&var) = bstrValue;
    V_VT(&var) = VT_BSTR;

    params.rgdispidNamedArgs = NULL;
    params.cNamedArgs = 0;
    params.rgvarg = &var;
    params.cArgs = 1;
    
    hr = pDispatch->Invoke(dispid, IID_NULL, LCID_SCRIPTING, DISPATCH_PROPERTYPUT, 
                            &params, NULL, NULL, NULL);
    if ( hr )
    {
        goto Cleanup;
    }

    hr = S_OK;
Cleanup:
    ReleaseInterface(pDispatch);
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP
CAccEdit::PutAccValue( BSTR bstrValue )
{
    HRESULT hr = S_OK;

    // move the element into focus.
    hr = THR( ScrollIn_Focus( _pElement ) );
    if ( hr )
        goto Cleanup;

    hr = THR( CallInvoke(_pElement, _T("value"), bstrValue) );

Cleanup:
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\accelem.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccElem.Cxx
//
//  Contents:   Accessible element implementation
//
//----------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCELEM_HXX_
#define X_ACCELEM_HXX_
#include "accelem.hxx"
#endif

#ifndef X_ACCWIND_HXX_
#define X_ACCWIND_HXX_
#include "accwind.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_SELECOBJ_HXX_
#define X_SELECOBJ_HXX_
#include "selecobj.hxx"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

MtDefine(CAccElementaccLocation_aryRects_pv, Locals, "CAccElement::accLocation aryRects::_pv")
MtDefine(CAccElementget_accSelection_aryVariants_pv, Locals, "CAccElement::get_accSelection aryVariants::_pv")
DeclareTag(tagAcc, "Accessibility", "IAccessible Methods");

//
//we have some test code in the accLocation that needs this.
//
#if DBG==1
#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif
MtExtern(CFlowLayoutGetChildElementTopLeft_aryRects_pv);
#endif

extern HRESULT EnsureAccWindow( CWindow * pWindow );

//-----------------------------------------------------------------------
//  CAccElement::GetAccWnd()
//
//  Returns the window object that has the accessible window attached to it.
//  In the process, it also ensures that there will be an accessible window
//  object. In case there is not one, returns NULL.
//
//-----------------------------------------------------------------------
CWindow * 
CAccElement::GetAccWnd()
{
    CWindow *pWindow = _pElement->GetCWindowPtr();
    if (EnsureAccWindow(pWindow))
    {
        return NULL;
    }
    return pWindow;
}



//-----------------------------------------------------------------------
//  CAccElem::CAccElem()
//
//  DESCRIPTION:
//      Contructor. 
//
//  PARAMETERS:
//      pElementParent  CElement pointer to the element which this
//                      accessible class hangs from. 
//                      If this parameter is NOT provided.
// ----------------------------------------------------------------------
CAccElement::CAccElement( CElement* pElementParent ) 
: CAccBase(), _lastChild( pElementParent->Doc() )
{
    Assert( pElementParent );
    
    _pElement = pElementParent;         //cache the pointer

    //only if the element pointer is valid
    if ( _pElement )
    {
        //if this element already has an accessibility object.
        if ( _pElement->HasAccObjPtr() )
        {
            //this should never happen.
            AssertSz( FALSE, 
                      "The newly created acc obj was already listed in lookaside list" );
        
            _pElement->DelAccObjPtr();
        }

        _pElement->SetAccObjPtr(this);
    }
}

//----------------------------------------------------------------------------
//  CAccElement::~CAccElement()
//  
//  DESCRIPTION:
//      Destructor
//----------------------------------------------------------------------------
CAccElement::~CAccElement()
{
    //Since this destructor only gets called after the element deletes the 
    //lookaside pointer, we don't have to delete the lookaside pointer here.
    _pElement = NULL;    
}

//+---------------------------------------------------------------------------
//  PrivateAddRef
//  
//  DESCRIPTION
//      We overwrite the CBase implementation to be able to delegate the call 
//      to the element that we are connected to.
//----------------------------------------------------------------------------
ULONG
CAccElement::PrivateAddRef()
{
    Assert( _pElement );
    return _pElement->AddRef();
}

//+---------------------------------------------------------------------------
//  PrivateRelease

//  DESCRIPTION
//      We overwrite the CBase implementation to be able to delegate the call 
//      to the element that we are connected to.
//----------------------------------------------------------------------------
ULONG
CAccElement::PrivateRelease()
{
    Assert( _pElement );
    return _pElement->Release();
}


//----------------------------------------------------------------------------
//
//  IAccessible Interface Implementation.
//
//----------------------------------------------------------------------------

//-----------------------------------------------------------------------
//  get_accParent()
//
//  DESCRIPTION:
//
//      Element implementation of the IAccessible::get_accParent method.
//      If the accessible object already has an accessible parent, that 
//      parent is returned. Otherwise the accessible element tree is 
//      walked and the parent is found.
//
//  PARAMETERS:
//
//      ppdispParent    :   address of the variable that will receive the
//                          parent pointer.
//
//  RETURNS:
//
//      E_POINTER | S_OK
//
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accParent(IDispatch ** ppdispParent)
{
    HRESULT     hr;
    CAccBase  * pBase = NULL;

    // GetAccParent handles the no markup scenario.

    hr = GetAccParent( _pElement, &pBase);
    if (hr)
        goto Cleanup;

    hr = THR(pBase->QueryInterface(IID_IDispatch, (void**)ppdispParent));
  
Cleanup:
    RRETURN( hr );
}

//-----------------------------------------------------------------------
//  CAccElement::get_accChildCount()
//
//  DESCRIPTION:
//          Returns the number of accessible children that the object has.
//
//  PARAMETERS:
//
//      pChildCount :   Address of the variable to receive the child count
//
//  RETURNS:
//
//      E_INVALIDARG | S_OK
//
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accChildCount(long* pChildCount)
{
    HRESULT             hr = S_OK;
    
    if ( !pChildCount )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pChildCount = 0;

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if ( CanHaveChildren() )
    {
        // cache check.
        // since the IsCacheValid checks for the Doc() too, we don't have to
        // check for Doc being there here... 
        // Also, if there is a last child and the child count is zero, then it
        // means that we made a partial walk before and we should count the
        // children now
        if ( !IsCacheValid() || ((_lLastChild != 0) && (_lChildCount == 0)))
        {
            CWindow * pAccWind = GetAccWnd();
            
            _lChildCount = 0;       // reset cached value

            if (!pAccWind)
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            CMarkupPointer *    pBegin = &( pAccWind->_pAccWindow->_elemBegin );
            CMarkupPointer *    pEnd = &( pAccWind->_pAccWindow->_elemEnd );

            // get markup limits for this element
            hr = THR( GetMarkupLimits( _pElement, pBegin, pEnd) );
            if ( hr )
                goto Cleanup;
            
            hr = THR( GetChildCount( pBegin, pEnd, &_lChildCount));
        }

        *pChildCount = _lChildCount;
    } 

    TraceTag((tagAcc, "CAccElement::get_accChildCount, role=%d, childcnt=%d hr=%d", GetRole(), _lChildCount, hr));

Cleanup:
    RRETURN( hr );
}

//-----------------------------------------------------------------------
//  CAccElement::get_accChild()
//
//  DESCRIPTION:
//          Returns the number of accessible children that the object has.
//          The implementation here is called by all derived implementations
//          since it checks the parameters and performs initial work.
//
//  PARAMETERS:
//      varChild    :   Child information
//      ppdispChild :   Address of the variable to receive the child 
//
//  RETURNS:
//
//      E_INVALIDARG | S_OK | S_FALSE
//
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accChild( VARIANT varChild, IDispatch ** ppdispChild )
{
    HRESULT          hr;
    CAccBase *       pAccChild = NULL;

    TraceTag((tagAcc, "CAccElement::get_accChild, role=%d, childid=%d requested", 
                        GetRole(), 
                        V_I4(&varChild)));  

    // validate out parameter
    if ( !ppdispChild )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *ppdispChild = NULL;        //reset the return value.

    // markup existence check is done in GetChildFromID which is called below.

    // unpack varChild, and validate the child id 
    hr = THR(ValidateChildID(&varChild));
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        //the object itself is not its own child
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    else 
    {
        //if there are no children, this function returns S_FALSE.
        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, NULL) );
        if ( hr ) 
            goto Cleanup;

        if ( !pAccChild )
        {
            //if the child is text, then the client has to talk to 
            //the parent object to get to that child. So we have to
            //return an invalid return value to tell the client
            //that this acc obj. is the object to talk to for this 
            //child.
            hr = E_NOINTERFACE;

            TraceTag((tagAcc, 
                        "CAccElement::get_accChild, role=%d, childid=%d, text child indication returned", 
                        GetRole(), 
                        V_I4(&varChild)));  
        }
        else 
        {
            //assign return value.
            *ppdispChild = (IDispatch *)pAccChild;            

            //AddRef since this is going outside 
            pAccChild->AddRef();

            TraceTag((tagAcc, 
                        "CAccElement::get_accChild, role=%d, childid=%d, accChild=0x%x", 
                        GetRole(), 
                        V_I4(&varChild),
                        pAccChild));
        }
    }

Cleanup:
    //S_FALSE is valid when there is no children
    //E_NOINTERFACE is valid for text children
    RRETURN2( hr, S_FALSE, E_NOINTERFACE);
}

//----------------------------------------------------------------------------
//  get_accName()
//
//  DESCRIPTION:
//  CAccElement class implementation of the get_accName. 
//  This method is not implemented in any of the derived classes. 
//  The derived classes implement the GetAccName() instead, to make 
//  the code simpler.
//  This implementation handles all child related checks, to let the 
//  GetAccName to only worry about the value to be returned, for the 
//  object that it is implemented on.
//
//  PARAMETERS:
//      varChild    :   Child information
//      pbstrName   :   pointer to the bstr to receive the name
//
//  RETURNS:    
//      E_INVALIDARG | S_OK | 
//----------------------------------------------------------------------------
STDMETHODIMP
CAccElement::get_accName(VARIANT varChild, BSTR* pbstrName)
{
    HRESULT                 hr;
    CAccBase *              pAccChild = NULL;
    CMarkupPointer *        pMarkupText = NULL;
    MARKUP_CONTEXT_TYPE     context;
    long                    lchCnt =-1;

    TraceTag((tagAcc, "CAccElement::get_accName, role=%d, childid=%d", 
                GetRole(), 
                V_I4(&varChild)));  

    // validate out parameter
     if ( !pbstrName )
     {
        hr= E_POINTER;
        goto Cleanup;
     }

    *pbstrName = NULL;

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        //call this instance's GetAccName implementation
        hr = THR( GetAccName(pbstrName) );
    }
    else
    {
        CWindow * pWindow = GetAccWnd();

        if (!pWindow)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        //
        // get the child CElement/CMarkupPointer. If the child id 
        // is invalid, the GetChildFromID will return with an err.
        //
        pMarkupText = &( pWindow->_pAccWindow->_elemBegin );

        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, pMarkupText) );
        if ( hr ) 
            goto Cleanup;

        if ( !pAccChild )
        {
            // the markup pointer is actually pointing after the text now. 
            // get the number of characters available for reading.
            hr = THR( pMarkupText->Left( TRUE, &context, NULL, &lchCnt, NULL, NULL) );
            if ( hr )
                goto Cleanup;

            Assert( context == CONTEXT_TYPE_Text );   //just checking.. !

            //allocate buffer
            hr = FormsAllocStringLen ( NULL, lchCnt, pbstrName );
            if ( hr )
                goto Cleanup;

            //read text
            hr = THR( pMarkupText->Right( TRUE, &context, NULL, &lchCnt, *pbstrName, NULL));
            if ( hr )
            {
                // release the BSTR and reset the pointer if we have failed to get
                // the text from tree services.
                FormsFreeString( *pbstrName );
                *pbstrName = NULL;
            }    
        }
        else 
        {
            V_I4( &varChild ) = CHILDID_SELF;
            
            //call child's get_accName implementation
            hr = THR( pAccChild->get_accName( varChild, pbstrName) );
        }
    }

Cleanup:

    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  DESCRIPTION:
//  CAccElement class implementation of the get_accValue. This method is not 
//  implemented in any of the derived classes. The derived classes implement
//  the GetAccValue() instead, to make the code simpler.
//
//  PARAMETERS:
//      varChild    :   Child information
//      pbstrValue  :   pointer to the bstr to receive the value
//
//  RETURNS:    
//      E_INVALIDARG | S_OK | 
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accValue(VARIANT varChild, BSTR* pbstrValue)
{
    HRESULT         hr;
    CAccBase *      pAccChild = NULL;

    TraceTag((tagAcc, "CAccElement::get_accValue, role=%d, childid=%d", 
                GetRole(), 
                V_I4(&varChild)));  

    // validate out parameter
     if ( !pbstrValue )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrValue = NULL;

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        //call this instance's implementation
        hr = THR( GetAccValue(pbstrValue) );
    }
    else
    {
        //
        // get the child CElement/CMarkupPointer. If the child id 
        // is invalid, the GetChildFromID will return with an err.
        //
        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, NULL) );
        if ( hr ) 
            goto Cleanup;

        if ( !pAccChild )
        {
            //if the parent is anchor, then anchor's value, otherwise
            //not implemented
            if ( GetElement()->Tag() == ETAG_A )
            {
                //call instance's implementation
                hr = THR( GetAccValue(pbstrValue) );
            }
            else
            {
                hr = E_NOTIMPL;
            }
        }
        else 
        {
            V_I4( &varChild ) = CHILDID_SELF;
            
            //call child's GetAccName implementation
            hr = THR( pAccChild->get_accValue( varChild, pbstrValue) );
        }
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  DESCRIPTION:
//  CAccElement class implementation of the get_accDescription. This method is not 
//  implemented in any of the derived classes. The derived classes implement
//  the GetAccDescription() instead, to make the code simpler.
//
//  PARAMETERS:
//      varChild    :   Child information
//      pbstrDescription  :   pointer to the bstr to receive the description
//
//  RETURNS:    
//      E_INVALIDARG | S_OK | 
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accDescription(VARIANT varChild, BSTR* pbstrDescription)
{
    HRESULT         hr;
    CAccBase *      pAccChild = NULL;

    TraceTag((tagAcc, "CAccElement::get_accDescription, role=%d, childid=%d", 
                GetRole(), 
                V_I4(&varChild)));  

    // validate out parameter
     if ( !pbstrDescription )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrDescription = NULL;

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        //call this instance's implementation
        hr = THR( GetAccDescription(pbstrDescription) );
    }
    else
    {
        //
        // get the child CElement/CMarkupPointer. If the child id 
        // is invalid, the GetChildFromID will return with an err.
        //
        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, NULL) );
        if ( hr ) 
            goto Cleanup;

        if ( !pAccChild )
        {
            // child is text.
            hr = E_NOTIMPL;
        }
        else 
        {
            V_I4( &varChild ) = CHILDID_SELF;

            //call child's implementation
            hr = THR( pAccChild->get_accDescription( varChild, pbstrDescription) );
        }
    }

Cleanup:
    RRETURN2( hr, S_FALSE, E_NOTIMPL);
}

//-----------------------------------------------------------------------
//  CAccElement::get_accRole()
//
//  DESCRIPTION:
//          Returns the accessibility role of the object.
//
//  PARAMETERS:
//
//      varChild    :   Variant that contains the child information
//      pvarRole    :   Address of the variant to receive the role information
//
//  RETURNS:
//
//      E_INVALIDARG | S_OK
//
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    HRESULT         hr ;      
    long            lRetRole = 0;
    CAccBase *      pAccChild = NULL;

    TraceTag((tagAcc, "CAccElement::get_accRole, role=%d, childid=%d", 
                GetRole(), 
                V_I4(&varChild)));  

    // validate the out parameter
    if ( !pvarRole )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // clear the out parameter
    V_VT( pvarRole ) = VT_EMPTY;

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        lRetRole = GetRole();   //this acc. objects role
    }
    else 
    {
        //
        // get the child CElement/CMarkupPointer. If the child id 
        // is invalid, the GetChildFromID will return with an err.
        //
        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, NULL) );
        if ( hr ) 
            goto Cleanup;

        if ( !pAccChild )
        {
            lRetRole = ROLE_SYSTEM_TEXT;
        }
        else 
        {
            //call child's implementation
            lRetRole = pAccChild->GetRole();
        }
    }
       
    if ( hr == S_OK )
    {
        // pack role into out parameter
        V_VT( pvarRole ) = VT_I4;
        V_I4( pvarRole ) = lRetRole;
    }
    
Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  get_accState()
//
//  DESCRIPTION:
//  CAccElement class implementation of the get_accState. This method is not 
//  implemented in any of the derived classes. The derived classes implement
//  the GetAccState() instead, to make the code simpler.
//
//  PARAMETERS:
//      varChild    :   Child information
//      pvarState   :   pointer to the VARIANT to receive the state information
//
//  RETURNS:    
//      E_INVALIDARG | S_OK | 
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    HRESULT             hr;
    CAccBase *          pAccChild = NULL;
    CMarkupPointer *    pTextBegin = NULL;
    CMarkupPointer *    pTextEnd = NULL;
    MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;
    htmlSelection       selectionType;
    IDispatch *         pDispRange = NULL;

    CMarkup * pMarkup = _pElement->GetMarkupPtr();

    if (pMarkup == NULL || pMarkup->Document() == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    else
    {
        CSelectionObject selectionObject(pMarkup->Document());


        TraceTag((tagAcc, "CAccElement::get_accState, role=%d, childid=%d", 
                 GetRole(), 
                 V_I4(&varChild)));  

        // validate out parameter
        if ( !pvarState )
        {
            hr = E_POINTER;
            goto Cleanup;
        }

        // reset the out parameter
        V_VT( pvarState ) = VT_EMPTY;
    
        // unpack varChild 
        hr = THR( ValidateChildID(&varChild) );
        if ( hr )
            goto Cleanup;

        if ( V_I4(&varChild) == CHILDID_SELF )
        {   

            hr = THR( GetAccState(pvarState) );

            // a pane is always visible.
            if (ROLE_SYSTEM_PANE != GetRole())
            {
                CLayout *           pLayout;
                CStackDataAry <RECT,4>     aryRects( Mt(CAccElementaccLocation_aryRects_pv) );
                CRect               rectElement;
                CDoc *              pDoc = GetElement()->Doc();

                // bodies and framesets should be treated like any other element
                // get the closest layout.
                pLayout = GetElement()->GetUpdatedNearestLayout();
                if ( !pLayout )
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }

                // get the region 
                if (ETAG_AREA != GetElement()->Tag())
                {
                    pLayout->RegionFromElement( GetElement(), &aryRects, &rectElement, RFE_SCREENCOORD);

                    //rectElem needs to be adjusted if we are in a frame
                    if (   !rectElement.IsEmpty()
                        && _pElement->GetWindowedMarkupContext())
                    {
                        POINT ptOrg;
                        CMarkup  *pwmc = _pElement->GetWindowedMarkupContext();

                        pwmc->GetElementClient()->GetClientOrigin(&ptOrg);

                        rectElement.OffsetRect(-ptOrg.x, -ptOrg.y);
                    }
                }
                else if (GetElement()->IsInMarkup() && pDoc && pDoc->GetView()->IsActive())
                {
                    DYNCAST(CAreaElement, GetElement())->GetBoundingRect(&rectElement);
                }
                else
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }

                // if the element is out of the client area, it is not visible.
                if (!IsVisibleRect(&rectElement))
                {                    
                    V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE; 

                    if (GetElement() && GetElement()->IsVisible(FALSE))
                    {
                        V_I4( pvarState ) |= STATE_SYSTEM_OFFSCREEN;
                    }
                }
            }
        }
        else
        {
            CWindow * pWindow = GetAccWnd();
            
            if (!pWindow)
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            //
            // get the child CElement/CMarkupPointer. If the child id 
            // is invalid, the GetChildFromID will return with an err.
            //
            pTextBegin = &(pWindow->_pAccWindow->_elemBegin);

            hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, pTextBegin) );
            if ( hr ) 
               goto Cleanup;

            if ( !pAccChild )
            {
                CAccBase *  pParentA = (GetElement()->Tag() == ETAG_A) ? this : GetParentAnchor();

                //if we are an anchor, assume its state
                if (pParentA)
                {
                    hr = THR( DYNCAST(CAccElement, pParentA)->GetAccState( pvarState ) );
                    if ( hr )
                        goto Cleanup;
                }
                else 
                {
                    V_VT( pvarState ) = VT_I4;
                    V_I4( pvarState ) = 0;
                }
            
                if ( fBrowserWindowHasFocus() )
                    V_I4( pvarState ) |= STATE_SYSTEM_SELECTABLE;

                CTreeNode * pParentNode = NULL;
                if (_pElement->IsNoScope())
                {
                    CTreeNode * pNode = _pElement->GetFirstBranch();
                    if (pNode)
                    {
                        pParentNode = pNode->Parent();
                    }
                }
                else
                {
                    pParentNode = pTextBegin->CurrentScope();
                }

                if (!pParentNode)
                {
                    Assert(FALSE);
                    hr = E_FAIL;
                    goto Cleanup;
                }
                
                //READONLY only if not editable
                BOOL fEditable = pParentNode->Element()->IsEditable(/*fCheckContainerOnly*/FALSE);
                
                if (!fEditable)
                    V_I4( pvarState ) |= STATE_SYSTEM_READONLY;
                
                if (!pParentNode->Element()->IsVisible(FALSE))
                    V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;

                // pTextBegin is already pointing to the end of the text. 
                pTextEnd = &(pWindow->_pAccWindow->_elemEnd);

                hr = THR( pTextEnd->MoveToPointer( pTextBegin ) );
                if ( hr )
                    goto Cleanup;

                //move the pointer to mark the beginning of the child.
                hr = THR( pTextBegin->Left( TRUE, &context, NULL, NULL, NULL, NULL) );
                if ( hr )
                    goto Cleanup;

                // Is text selected ? If any text that is inside this text child is selected, then
                // we consider this text child as selected.
                hr = THR( selectionObject.GetType( &selectionType ) );

                if ( (selectionType != htmlSelectionNone) && GetElement()->Doc() ) 
                {
                    CMarkupPointer      selBegin( GetElement()->Doc() );
                    CMarkupPointer      selEnd( GetElement()->Doc() );
                    CAutoRange *        pRange = NULL;

                    // Get the range that is selected from the selection object
                    hr = THR( selectionObject.createRange(&pDispRange) );
                    if ( hr )
                        goto Cleanup;

                    // The selection range is always there, even if there is no selection
                    Assert( pDispRange );

                    hr = THR( pDispRange->QueryInterface( CLSID_CRange, (void **)&pRange ) );
                    if ( hr )
                        goto Cleanup;

                    Assert( pRange );

                    // place the left and right markups to the txtrange left and right
                    hr  = THR( pRange->GetLeftAndRight( &selBegin, &selEnd ) );
                    if ( hr )
                        goto Cleanup;

                    Assert( context == CONTEXT_TYPE_Text );

                    // if the selection is NOT totally out of this element, then the state
                    // has to be STATE_SYSTEM_SELECTED.
       
                    // if there is a selection, it should somehow be inside or overlapping with the
                    // text area. 
                    // 
                    if ( selEnd.IsRightOf( pTextBegin ) && selBegin.IsLeftOf( pTextEnd ) )
                        V_I4( pvarState ) |= STATE_SYSTEM_SELECTED; //hr is S_OK here.
                }

                //visibility of the text depends on the following two things to be TRUE
                // Is the closest element parent of the text visible?
                // Is the text within the client window coordinates ?
                //
                if (!IsTextVisible(pTextBegin, pTextEnd))
                {
                    V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE; 
                    if (pParentNode->Element()->IsVisible(FALSE))
                        V_I4( pvarState ) |= STATE_SYSTEM_OFFSCREEN; 
                }
            }
            else 
            {
                V_I4( &varChild ) = CHILDID_SELF;

                //call child's implementation
                hr = THR( pAccChild->get_accState(varChild, pvarState) );
            }
        }
}
Cleanup:
    ReleaseInterface( pDispRange );

    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  get_accKeyboardShortCut
//  
//  DESCRIPTION :   
//          Returns the keyboard shortcut if there is one.
//
//  PARAMETERS:
//      varChild                :   VARIANT containing the child ID
//      pbstrKeyboardShortcut   :   address of the bstr to receive data
//
//  RETURNS:
//      E_POINTER | S_OK | E_NOTIMPL | E_OUTOFMEMORY
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accKeyboardShortcut(VARIANT varChild, BSTR* pbstrKeyboardShortcut)
{
    HRESULT         hr;
    CAccBase *      pAccChild = NULL;

    TraceTag((tagAcc, "CAccElement::get_accKeyboardShortcut, role=%d, childid=%d", 
                GetRole(), 
                V_I4(&varChild)));  

    // validate out parameter
     if ( !pbstrKeyboardShortcut )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrKeyboardShortcut = NULL;

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        switch (GetElement()->Tag())
        {
            case ETAG_INPUT:
            case ETAG_BUTTON:
            case ETAG_A:
            case ETAG_SELECT:
                hr = THR(GetAccKeyboardShortcut(pbstrKeyboardShortcut));
                if (hr)
                    goto Cleanup;
                break;
                
            default:
                hr = S_OK;
                break;
        }
    }
    else
    {
        //
        // get the child CElement/CMarkupPointer. If the child id 
        // is invalid, the GetChildFromID will return with an err.
        //
        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, NULL) );
        if ( hr ) 
            goto Cleanup;

        if ( !pAccChild )
        {
            //no keyboard shortcuts for plain text, unless we (or a parent is an
            // anchor)
            CAccBase * pParentA = (GetElement()->Tag() == ETAG_A) ? this : GetParentAnchor();
            CVariant   varChildSelf;

            V_VT(&varChildSelf) = VT_I4;
            V_I4(&varChildSelf) = CHILDID_SELF;

            //if we are an anchor, assume its state
            hr = (!pParentA) ? S_OK :
                THR( pParentA->get_accKeyboardShortcut(varChildSelf, pbstrKeyboardShortcut) );
        }
        else 
        {
            // call child's implementation of this method. We don't have a helper here,
            // since the CHILDID_SELF case above has all the smarts and code.
            // varChild already is of type VT_I4, so only set the value.
            V_I4( &varChild ) = CHILDID_SELF;
            hr = THR( pAccChild->get_accKeyboardShortcut(varChild, pbstrKeyboardShortcut) );
        }
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  get_accFocus
//
//  DESCRIPTION :   Gets the active element on the current document and 
//                  checks if this acc object's element is the same one.
//
//  PARAMETERS:
//      pvarFocusChild  :   address of VARIANT to receive the focused child info
//
//  RETURNS:
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accFocus(VARIANT * pvarFocusChild)
{
    HRESULT         hr = S_OK;
    CElement *      pElemFocus = NULL;
    CAccBase *      pAccFocus = NULL;
    IDispatch *     pAccParent = NULL;
   
    TraceTag((tagAcc, "CAccElement::get_accFocus, role=%d, childid=%d", GetRole()));  

    if ( !pvarFocusChild )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    V_VT( pvarFocusChild ) = VT_EMPTY;

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //using GetAccDoc saves us from reimplementing this on window.
    pElemFocus = GetElement()->Doc()->_pElemCurrent;

    //is the active element this one?
    if ( GetElement() == pElemFocus )
    {
        V_VT( pvarFocusChild ) = VT_I4;
        V_I4( pvarFocusChild ) = CHILDID_SELF;
        goto Cleanup;
    }
    else
    {
        // if this object is the accessible parent of the element that
        // has the focus, then return the acc object for that element
        
// ???? - look into area's & images when the area has the focus
        pAccFocus = GetAccObjOfElement(pElemFocus);
        if ( !pAccFocus )
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        // Get the parent accessible object for the element that has the 
        // focus. We have to call through interface, since the pAccFocus element
        // can be a body or a frame set.
        hr = THR( pAccFocus->get_accParent( &pAccParent ) );
        if ( hr )
            goto Cleanup;

        Assert( pAccParent );

        // if these two objects are the same, then this acc object instance
        // is the parent for the acc object that is attached to the element
        // that currently has the focus. We return the acc object for the 
        // element that has the focus
        if ( pAccParent == DYNCAST( IAccessible, this) )  
        {
            V_VT( pvarFocusChild ) = VT_DISPATCH;
            V_DISPATCH( pvarFocusChild ) = pAccFocus;
            pAccFocus->AddRef();
        }
        else
        {
            V_VT(pvarFocusChild) = VT_EMPTY;
        }
    }
    
Cleanup:    
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//  get_accSelection
//  
//  DESCRIPTION:
//      This is the method implementation for all HTML elements except for the
//      body/frameset tags. The body/frameset implementation delegates the call
//      to the frame that has the focus.
//      This method returns an acc object, or a pointer to the IEnumVariant
//      that represents an array of acc. objects, that is/are intersecting with
//      the selection on the page.
//      
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accSelection(VARIANT * pvarSelectedChildren)
{
    HRESULT             hr;

    CMarkup * pMarkup = _pElement->GetMarkupPtr();
    htmlSelection       selectionType;
    IDispatch *         pDispRange = NULL;  

    if (pMarkup == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    else
    {
        CSelectionObject    selectionObject(pMarkup->Document());

        TraceTag((tagAcc, "CAccElement::get_accSelection, role=%d, childid=%d", GetRole()));  

        if ( !pvarSelectedChildren )
        {
            hr = E_POINTER;
            goto Cleanup;
        }

        // default the return value to no selection.
        V_VT(pvarSelectedChildren) = VT_EMPTY;  

        // we can not return selected children , if there are no children.
        if ( !CanHaveChildren() )
        {
            hr = S_OK;
            goto Cleanup;
        }

        // Is text selected ? If any text that is inside this text child is selected, then
        // we consider this text child as selected.
        hr = THR( selectionObject.GetType( &selectionType ) );
    
        if (hr)
            goto Cleanup;

        if ( (selectionType != htmlSelectionNone) && GetElement()->Doc() ) 
        {
            CAutoRange *        pRange = NULL;
            MARKUP_CONTEXT_TYPE context;
            CMarkupPointer      selStart( GetElement()->Doc() );
            CMarkupPointer      selEnd( GetElement()->Doc() );
            CMarkupPointer      elemStart( GetElement()->Doc() );
            CMarkupPointer      elemEnd( GetElement()->Doc() );
            long                cChildBase = 0;              

//Note: [FerhanE]
//          Using the range object is very expensive for us, since it 
//          is created using markups and we have to ask for them again.
//          However, since the editing and selection live out of the native code base, 
//          we have to use interface calls.
        
            // Get the range that is selected from the selection object
            hr = THR( selectionObject.createRange(&pDispRange) );
            if ( hr )
                goto Cleanup;

            // if there is no selection, there is nothing to do, we have already 
            // set the return value to VT_EMPTY by clearing the out parameter.
            if ( !pDispRange )
                goto Cleanup;
   
            hr = THR( pDispRange->QueryInterface( CLSID_CRange, (void **)&pRange ) );
            if ( hr )
                goto Cleanup;

            Assert( pRange );

            // place the left and right markups to the txtrange left and right
            hr  = THR( pRange->GetLeftAndRight( &selStart, &selEnd ) );
            if ( hr )
                goto Cleanup;

            // move the pSelStart pointer to the closest tag to its left, 
            // to ease our lives for child counting. Any child that is partially
            // selected is assumed to be selected.
            hr = THR( selStart.Left( FALSE, &context, NULL, NULL, NULL, NULL ));
            if (hr) 
                goto Cleanup;

            if ( context == CONTEXT_TYPE_Text )
            {   
                hr = THR( selStart.Left( TRUE, &context, NULL, NULL, NULL, NULL ) );
                if ( hr ) 
                    goto Cleanup;
            }
    
            // place markups to beginning and end of the element too.
            hr = THR( GetMarkupLimits(GetElement(), &elemStart, &elemEnd) );
            if ( hr ) 
                goto Cleanup;

            // Check if the selection is completely out of this element's scope.
            if ( selStart.IsRightOf( &elemEnd ) || selEnd.IsLeftOf( &elemStart ) )
                goto Cleanup;       //hr is S_OK here.
        
            // If the selection starts before the element, we should make it start
            // with the element, to ease our calculations later.
            if ( selStart.IsLeftOf( &elemStart ) )
            {
                // Move the selection pointer to the start of element
                hr = THR( selStart.MoveToPointer( &elemStart ) );
                if ( hr )
                    goto Cleanup;
            }

            // If the selection ends after the element, make it end with the element
            // to ease calculations.
            if ( elemEnd.IsLeftOf( &selEnd ) )
            {
                // Move the selection pointer to the end of element
                hr = THR( selEnd.MoveToPointer( &elemEnd ) );
                if ( hr )
                    goto Cleanup;
            }

            // Count the number of children from the beginning of the element's scope,
            // until the selection starts.
            hr = THR( GetChildCount( &elemStart, &selStart, &cChildBase) );
            if ( hr ) 
                goto Cleanup;

            // GetChildCount moves the pElemStart in the markup stream as it counts children.
            // If the pElemStart is further than the selStart in the markup stream, then it means
            // that the selection starts in a supported element. We should move the selection begin
            // point to the beginning of that element and decrement the child count.
            if ( selStart.IsLeftOf( &elemStart)  )
            {   
                CTreeNode * pNode = NULL;

                pNode = selStart.CurrentScope();

                while ( !IsSupportedElement(pNode->Element()) 
    #if DBG ==1 
                        && ( GetElement() != pNode->Element() )   //security check
    #endif                
                      )
                {
                    pNode = pNode->Parent();
                }
        
                //security check continues
                Assert( GetElement() != pNode->Element() );

                // move the selection start to the beginning of the supported element
                hr = THR( selStart.MoveAdjacentToElement( pNode->Element(), ELEM_ADJ_BeforeBegin));
                if ( hr )
                    goto Cleanup;
        
                //decrement the child base, since we took a step backwards.
                cChildBase--;
            }

            // count and retrieve the children starting from the selStart position, 
            // upto and incuding the element that contains the selEnd position
            hr = THR( GetSelectedChildren( cChildBase, 
                                            &selStart, &selEnd, 
                                            pvarSelectedChildren ));
        }
    }

Cleanup:
    ReleaseInterface( pDispRange );
    
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  get_accDefaultAction
//
//  DESCRIPTION:
//      CAccElement implementation for the get_accDefaultAction method. Each
//      object that is derived from this class overwrites this method's helper
//      function GetAccDefaultAction. This implementation is only responsible for
//      manipulating the child id and processing the call in case the child
//      id that is passed refers to text.
//      
//  PARAMETERS:
//      varChild            :   VARIANT that contains the child information
//      pbstrDefaultAction  :   Address of the BSTR to receive the default 
//                              action string.
//      
//  RETURNS:
//          S_OK | E_INVALIDARG | E_POINTER    
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::get_accDefaultAction(VARIANT varChild, BSTR* pbstrDefaultAction)
{
    HRESULT         hr;
    CAccBase *      pAccChild = NULL;

    TraceTag((tagAcc, "CAccElement::get_accDefaultAction, role=%d, childid=%d", 
                GetRole(), 
                V_I4(&varChild)));  

    // validate out parameter
     if ( !pbstrDefaultAction )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrDefaultAction = NULL;

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        //call this instance's GetAccDefaultAction implementation
        hr = THR( GetAccDefaultAction(pbstrDefaultAction) );
    }
    else
    {
        //
        // get the child CElement/CMarkupPointer. If the child id 
        // is invalid, the GetChildFromID will return with an err.
        //
        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, NULL) );
        if ( hr ) 
            goto Cleanup;

        if ( !pAccChild )
        {
            //if the text is inside an anchor, then it reflects
            //anchors default action
            if ( GetElement()->Tag() ==ETAG_A )
            {
                hr = THR( GetAccDefaultAction(pbstrDefaultAction) );
            }
            else
            {
                //there is no default action for text.
                hr = E_NOTIMPL;
            }
        }
        else 
        {
            V_I4( &varChild ) = CHILDID_SELF;

            //call child's GetAccDefaultAction implementation
            hr = THR( pAccChild->get_accDefaultAction( varChild, pbstrDefaultAction) );
        }
    }

Cleanup:
    RRETURN( hr );

}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::accSelect( long flagsSel, VARIANT varChild)
{
    HRESULT             hr;
    CAccBase *          pAccChild = NULL;
    CAccBase *          pAccParent = NULL;
    CElement *          pElemFocus = GetElement();

    TraceTag((tagAcc, "CAccElement::accSelect, role=%d, childid=%d, flagsSel=0x%x", 
                GetRole(), 
                V_I4(&varChild),
                flagsSel));  

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // validate the child,
    hr = THR( ValidateChildID( &varChild ));
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {   
        // if the element is an IMG 
        if ( GetElement()->Tag() == ETAG_IMG )
        {
            // we can call the helper, since we know that the 
            // element is not a body/frameset
            hr = GetAccParent( GetElement(), &pAccParent);
            if ( hr )
                goto Cleanup;

            Assert( pAccParent );

            //  If the parent acc. obj is an anchor, call
            //  the standard implementation. otherwise E_NOTIMPL
            if ( pAccParent->GetElement()->Tag() != ETAG_A )
            {
                hr =E_NOTIMPL;
                goto Cleanup;
            }

            pElemFocus = pAccParent->GetElement();
            
            //fall through if the parent is anchor.
        }

        // For all elements, including the body/frameset, the behavior is to
        // set the focus to itself
        if ( flagsSel & SELFLAG_TAKEFOCUS )
        {
            hr = ScrollIn_Focus( pElemFocus );
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        CWindow * pWindow = GetAccWnd();

        if (!pWindow)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        CMarkupPointer *    ptrBegin = &( pWindow->_pAccWindow->_elemBegin );

        // Find the child indicated with the ID.
        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, ptrBegin) );
        if ( hr ) 
            goto Cleanup;

        if ( pAccChild )
        {
            // Go through the interface method, to support frames
            V_I4( &varChild ) = CHILDID_SELF;
            
            hr = pAccChild->accSelect(flagsSel, varChild);
        }
        else
        {
            //text 
            
            // the child is a text block.
            switch ( flagsSel )
            {
                // set focus to the parent element.
                case SELFLAG_TAKEFOCUS:
                    hr = ScrollIn_Focus(GetElement());
                    break;

                case SELFLAG_TAKESELECTION:
                    IMarkupPointer  * pIMarkup;
                    MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;

                    hr = THR(ptrBegin->Left(TRUE, &context, NULL, NULL, NULL, NULL));
                    if (hr)
                        goto Cleanup;

                    hr = THR( ptrBegin->QueryInterface( IID_IMarkupPointer, 
                                                                (void**)&pIMarkup ));
                    if ( hr )
                        goto Cleanup;
                        
                    hr = THR( SelectText( GetElement(), pIMarkup ) );

                    // Release the instance we got from the QI call.
                    ReleaseInterface( pIMarkup );
                    
                    break;
            }
        }
    }
    
Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  accLocation()
//  
//  DESCRIPTION:
//      Returns the coordinates of the element relative to the top left corner 
//      of the client window.
//      To do that, we are getting the CLayout pointer from the element
//      and calling the GetRect() method on that class, using the global coordinate
//      system. This returns the coordinates relative to the top left corner of
//      the screen. 
//      We then convert these screen coordinates to client window coordinates.
//  
//  PARAMETERS:
//        pxLeft    :   Pointers to long integers to receive coordinates of
//        pyTop     :   the rectangle.
//        pcxWidth  :
//        pcyHeight :
//        varChild  :   VARIANT containing child information. 
//
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::accLocation(   long* pxLeft, long* pyTop, 
                            long* pcxWidth, long* pcyHeight, 
                            VARIANT varChild)
{
    HRESULT             hr;
    CLayout *           pLayout = NULL;
    CRect               rectElement;
    CRect               rectWnd;
    HWND                hWnd;
    CAccBase *          pAccChild = NULL;
    MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;
    CMarkupPointer *    pBegin = NULL;
    CMarkupPointer *    pEnd = NULL;
    CStackDataAry <RECT, 4>     aryRects( Mt(CAccElementaccLocation_aryRects_pv) );


    TraceTag((tagAcc, "CAccElement::accLocation, role=%d, childid=%d", 
                GetRole(), 
                V_I4(&varChild)));  

    // validate out parameter
    if ( !pxLeft || !pyTop || !pcxWidth || !pcyHeight )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // reset out parameters
    *pxLeft = *pyTop =  *pcxWidth = *pcyHeight = 0;

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    // unpack varChild, and validate the child id 
    hr = THR(ValidateChildID(&varChild));
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        // bodies and framesets should be treated like any other element
        // get the closest layout.
        pLayout = _pElement->GetUpdatedNearestLayout();
        if ( !pLayout )
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        // get the region 
        pLayout->RegionFromElement( _pElement, &aryRects, &rectElement, RFE_SCREENCOORD);

        // we fall into the offset calculation code placed after the 'if'.
    }
    else 
    {
        CWindow * pWindow = GetAccWnd();

        if (!pWindow)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        // get the child CElement/CMarkupPointer. If the child id 
        // is invalid, the GetChildFromID will return with an err.
        //
        pBegin = &(pWindow->_pAccWindow->_elemBegin );

        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, pBegin) );
        if ( hr ) 
            goto Cleanup;

        // If there is an accessible child, delegate the call, otherwise get the 
        // location for the text child.
        if ( pAccChild )
        {
            // call child's implementation of this method. We don't have a helper here,
            // since the CHILDID_SELF case above has all the smarts and code.
            V_I4( &varChild ) = CHILDID_SELF;

            // Delegate to the accessible child.
            hr = THR( pAccChild->accLocation( pxLeft, pyTop, 
                                              pcxWidth, pcyHeight, 
                                              varChild ) );

            // We are done here, skipping over the offset calculation
            goto Cleanup;
        }
        else        
        {
            pEnd = &(pWindow->_pAccWindow->_elemEnd );

            hr = THR( pEnd->MoveToPointer( pBegin ) );
            if ( hr ) 
                goto Cleanup;

            // move the begin pointer to where it should be
            hr = THR( pBegin->Left( TRUE, &context, (CTreeNode **) NULL, NULL, NULL, NULL ) );
            if ( hr )
                goto Cleanup;

            Assert( context == CONTEXT_TYPE_Text );

            hr = THR( _pElement->Doc()->RegionFromMarkupPointers(pBegin, 
                                                                    pEnd,
                                                                    &aryRects, 
                                                                    &rectElement,
                                                                    TRUE));
            if ( hr ) 
                goto Cleanup;
        }
    }

    // Offset calculation...

    // the window handle may come back NULL, if the window is not in place activated

    hWnd = _pElement->Doc()->GetHWND();

    if ( !hWnd )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if ( !GetWindowRect( hWnd, &rectWnd) )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    *pxLeft = rectElement.left + rectWnd.left;
    *pyTop = rectElement.top + rectWnd.top;
    *pcxWidth = rectElement.right - rectElement.left;
    *pcyHeight = rectElement.bottom - rectElement.top;

    TraceTag((tagAcc, "CAccElement::accLocation, Location reported as left=%d top=%d width=%d height=%d", 
                rectElement.left + rectWnd.left,
                rectElement.top + rectWnd.top,
                rectElement.right - rectElement.left,
                rectElement.bottom - rectElement.top));

Cleanup:
    RRETURN( hr );    
}


//----------------------------------------------------------------------------
//  accNavigate
//
//  DESCRIPTION:
//      Provides navigation for the accessible children of the accessible object
//      it is called on.
//      The navigation is provided according to the schema below:
//      
//                          start=self      start = id
//      NAVDIR_NEXT     :   err                 OK
//      NAVDIR_PREV     :   err                 OK
//      NAVDIR_FIRST    :   OK                  err
//      NAVDIR_LAST     :   OK                  err
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    HRESULT                 hr;
    CAccBase *              pAccChild = NULL;
    long                    lIndex = 0;
    long                    lChildIdx = 0;
    CAccElement *           pAccObj = this;


    TraceTag((tagAcc, "CAccElement::accNavigate, role=%d, start=%d, direction=%d", 
                GetRole(), 
                V_I4(&varStart),
                navDir));  

    if ( !pvarEndUpAt )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // unpack varChild, and validate the child id against child array limits.
    hr = THR(ValidateChildID(&varStart));
    if ( hr )
        goto Error;

    switch ( navDir )
    {
        case NAVDIR_FIRSTCHILD:
        case NAVDIR_LASTCHILD:
            // An acc object can only return its own first and last children.
            if ( V_I4(&varStart) != CHILDID_SELF )
            {
                hr = E_INVALIDARG;
                goto Error;
            }

            if ( navDir == NAVDIR_FIRSTCHILD )
                lIndex = 1;                 //get the first child
            else        
                lIndex = -1;                //get the last child
            break;

        case NAVDIR_PREVIOUS:
        case NAVDIR_NEXT:
            // check the varStart. 
            // If the varStart is pointing to the self, then we have to delegate
            // the call to this element's accessible parent.
            // Otherwise, we have to return the child that is being asked from us.
            if ( V_I4(&varStart) == CHILDID_SELF )
            {
                 // If we are in a pane, since a window can have only one pane child
                // the navigation should fail, regardless of the direction.
                if (ROLE_SYSTEM_PANE == GetRole())
                {
                    Assert( (ETAG_BODY == _pElement->Tag())||
                            (ETAG_FRAMESET == _pElement->Tag()) );

                    hr = S_FALSE;       // no error, just no more children
                    goto Error;
                }

                // get the accessible parent element, we know for sure that the parent
                // is an element here, since we are not a pane. So casting is OK.
                hr = THR(GetAccParent(_pElement, (CAccBase **)&pAccObj));
                if (hr)
                     goto Error;

                // get the index of the element.
                hr = THR(pAccObj->GetNavChildId(navDir, _pElement, &lIndex));
                if (hr)
                    goto Error;
            }
            else
            {
                // the upper limit checks for the validity of indexes for these navdirs
                // are left to the GetChildFromID call below.
                if ( navDir == NAVDIR_PREVIOUS )
                {
                    //we can not go left from the first child
                    if ( V_I4(&varStart) == 1 )
                    {   
                        hr = S_FALSE;
                        goto Error;
                    }

                    // Get the index of the previous child
                    lIndex = V_I4(&varStart) - 1;
                }
                else    //NAVDIR_NEXT
                {
                    lIndex = V_I4(&varStart) + 1;
                }
            }
            break;

        // we don't support any other navigation commands
        default:
            hr = E_INVALIDARG;
            goto Error;
    }

    // get the child
    hr = THR( pAccObj->GetChildFromID( lIndex, &pAccChild, NULL, &lChildIdx) );
    if ( hr )
    {
        // FIRST and LAST can only return S_FALSE, if there are no children.
        // NEXT and PREVIOUS can return E_INVALIDARG, which indicates that the
        // index we passed to the function was out of limits. In that case, 
        // spec asks us to return S_FALSE, and an empty variant.
        if ( hr == E_INVALIDARG )
            hr = S_FALSE;       
            
        goto Error;
    }

    // Prepare the return value according to the type of the data received
    // Either a child id or a pointer to the accessible child to be returned.
    if ( pAccChild )
    {
        IDispatch * pDispChild;

        //the child did have an accessible object
        hr = pAccChild->QueryInterface( IID_IDispatch, (void **)&pDispChild);
        if (hr) 
            goto Cleanup;

        V_VT( pvarEndUpAt ) = VT_DISPATCH;
        V_DISPATCH( pvarEndUpAt ) = pDispChild;
    }
    else
    {
        Assert ((lIndex == -1) || (lIndex == lChildIdx));

        //return the child id
        V_VT( pvarEndUpAt ) = VT_I4;
        V_I4( pvarEndUpAt ) = lChildIdx;
    }

Cleanup:
    RRETURN1( hr, S_FALSE );
Error:
    V_VT( pvarEndUpAt ) = VT_EMPTY;
    RRETURN1( hr, S_FALSE );
}

//-----------------------------------------------------------------------
//  accHitTest()
//  
//  DESCRIPTION :   Since the window already have checked the coordinates
//                  and decided that the document contains the point, this
//                  function does not do any point checking. 
//                  
//  PARAMETERS  :
//      xLeft, yTop         :   (x,y) coordinates 
//      pvarChildAtPoint    :   VARIANT pointer to receive the acc. obj.
//
//  RETURNS:    
//      S_OK | E_INVALIDARG | 
//-----------------------------------------------------------------------
STDMETHODIMP 
CAccElement::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{
    HRESULT         hr = E_FAIL;
    CTreeNode *     pElemNode = NULL;
    CTreeNode *     pHitNode = NULL;
    CTreeNode *     pTreeWalker = NULL;
    CTreeNode *     pLastSupported = NULL;
    CAccBase  *     pAccObj = NULL;
    ELEMENT_TAG     elementTag;

    POINT       pt = {xLeft, yTop};
    HTC         htc;
    CMessage    msg;

    TraceTag((tagAcc, "CAccElement::accHitTest, role=%d", GetRole()));  

    if ( !pvarChildAtPoint )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    V_VT( pvarChildAtPoint ) = VT_EMPTY;
    V_I4( pvarChildAtPoint ) = 0;
    
    //get this element's node
    pElemNode = GetElement()->GetFirstBranch();
    if ( !pElemNode )
        goto Cleanup;       //the node was not in the tree.

    // make sure that the window that contains the document is in-place
    // activated.
    if ( !GetElement()->Doc()->GetHWND() )
        goto Cleanup;   //the document is not inplace activated

    //convert the (x,y) coordinates that we receive to client coordinates
    if ( !ScreenToClient( GetElement()->Doc()->GetHWND(), &pt) )
        goto Cleanup;
    
    msg.pt = pt;

    // Get the node that got the hit
    htc = GetElement()->Doc()->HitTestPoint( &msg, &pHitNode, HT_VIRTUALHITTEST);

    // if the hit node is in a slave tree, we have to get to the master tree
    // and the master tree element,
    // the view links are to be handled differently.
    if (pHitNode->Element()->HasMasterPtr())
    {
        CElement * pElemMaster = pHitNode->Element()->GetMasterPtr();

        // For Trident V3, only identity behaviors can have view links,
        // and identity behaviors can only be attached to custom tags.
        // If the master does not have an identity peer holder, it can
        // not be a view link, so it has to be an intrinsics control.
        // Otherwise, it is a view link we are dealing with.
        if (!pElemMaster->HasIdentityPeerHolder())
        {
            pHitNode = pElemMaster->GetFirstBranch();
        }
        else
        {
            // we some how hit the top level node on a viewlink markup
            // what do we return now?
            Assert(0);
        }
    }

    // Is there a tree built and ready?
    if ( pHitNode->Tag() == ETAG_ROOT )
        goto Cleanup;

    if (GetElement()->Tag() ==ETAG_IMG )
    {
        pHitNode->Element()->SubDivisionFromPt(msg.ptContent, 
                                               &msg.lSubDivision);

        // We are an area was hit so just return it.  if there is an error
        // bail and fall through to return the img
        hr = HitTestArea(&msg, pHitNode, pvarChildAtPoint);
        if (SUCCEEDED( hr ))
            goto Cleanup;
    }

    hr = S_OK;                              //Reset the return value

    // If the point was not inside of this document, return VT_EMPTY
    if ( htc == HTC_NO )
    {
        V_VT( pvarChildAtPoint ) = VT_EMPTY;       
        goto Cleanup;
    }
   
    // if we have already on the node that this object's element is connected, then
    // move on to child calculation part
    //
    // Compare elements instaad of nodes, to avoid problems with overlapping
    //
    // stert from the node that got hit, move up until you find a supported element
    // that is an immediage acc. child of this acc. object.
    pTreeWalker = pHitNode;

    if ( pHitNode->Element() != GetElement())
    {
        CMarkup *   pMarkupElement = _pElement->GetMarkupPtr();

        if (pMarkupElement == NULL)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        
        long        lElementIndex = _pElement->GetSourceIndex();
        long        lWalkerIndex = 0;

        do
        {
            // if the parent node is a suported element's node, move the 
            // hit node to that node. 
            // In the case that we are hittesting an element behavior, if there
            // is already a last supported element, then we may need to return that. 
            // However, if we change the last supported to the element client of the 
            // behavior's slave markup, we lose that information. So, we only update 
            // the last supported node information if there was not already a supported
            // element found in the hit test route within the slave markup.
            if ( IsSupportedElement( pTreeWalker->Element()) )
            {
                // If this is not an element behavior, just update.
                // If it is an element behavior, only update if we don't have 
                // a last supported element.
                if (!_pElement->HasIdentityPeerHolder() || !pLastSupported)
                {
                    pLastSupported = pTreeWalker;
                }
            }

            // Walk up the tree
            pTreeWalker = pTreeWalker->Parent();

            // if we hit the root, then climb up to the next markup that contains us.
            if (pTreeWalker->Tag() == ETAG_ROOT)
            {
                if (pTreeWalker->Element()->HasMasterPtr())
                {
                    pTreeWalker = pTreeWalker->Element()->GetMasterPtr()->GetFirstBranch();
                }
                else
                    break;      // we have hit the root on a non-viewlink markup, hit should be out of scope
            }
           
            lWalkerIndex = pTreeWalker->Element()->GetSourceIndex();
        }
        while ( (pTreeWalker->Element() != _pElement) &&                // hit is on us
                ((pMarkupElement != pTreeWalker->GetMarkup()) ||        // If we are in the same markup, then we should
                 (lWalkerIndex >= lElementIndex)));                     // be checking an element that has a larger source index...
    }
    // else they are equal, drop to the last else case below

    if ( pTreeWalker->Tag() == ETAG_ROOT ||
                ((pTreeWalker->GetMarkup() ==  _pElement->GetMarkup()) && 
                 (pTreeWalker->Element()->GetSourceIndex() < _pElement->GetSourceIndex()))) 
    {
        // this case means the hit was OUTSIDE of our scope 
        V_VT( pvarChildAtPoint ) = VT_EMPTY;       
        goto Cleanup;
    }
    else if (pLastSupported && (pLastSupported->Element() != GetElement()) )
    {
        // hit in our scope, and the hit is on a supported child
        // return this child 

        pAccObj = GetAccObjOfElement( pLastSupported->Element() );
        if ( !pAccObj )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        V_VT( pvarChildAtPoint )  = VT_DISPATCH;
        V_DISPATCH( pvarChildAtPoint ) = pAccObj;

        pAccObj->AddRef();

    }
    
    if (!pAccObj)
    {
        // hit in our scope, and the hit is on a text node
        // or the hit was on us directly
        //
        // If there were no supported elements below us, we have to find the child id
        // from the current element
        if ( !pLastSupported )
            pLastSupported = pElemNode;

        // We have to return ourselves as the acc object if we are
        // connected to a noscope tag, since it can not have any
        // text content.
        // buttons need to be handled here, even though they can contain
        //   html.  This is primarily due to proxy compat.
        // Also if the hit was not on any content, the cp comes back -1
        // and that requires us to return CHILDID_SELF for the acc object.
        elementTag = pLastSupported->Tag();
    
        if ( !CanHaveChildren()              ||  // can not have children
            (msg.resultsHitTest._cpHit < 0 ) ||  // 
            msg.resultsHitTest._fWantArrow   )   // arrow means we are not on text
        {
            V_VT( pvarChildAtPoint )  = VT_I4;
            V_I4 ( pvarChildAtPoint ) = CHILDID_SELF;
            goto Cleanup;
        }

        // We know for a fact now, that the element that is represented
        // by this acc object was hit, and the hit was on content.
        // We should now find the child that was hit.

        // since this element can have children, we have to find out
        // which one of its children the pointer was on.
        // we can return with the information we get from this 
        // function, since it will fill the VARIANT for us.
        //
        hr = THR( GetHitChildID( GetElement(), &msg, pvarChildAtPoint) );
    }


Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  accDoDefaultAction
//  
//  DESCRIPTION:
//  Does different things per tag:
//      The implementation for the tags OBJECT/EMBED and PLUGIN is in the 
//      AccObject class implementation.
//
//  PARAMETERS:
//      varChild            :   VARIANT child information
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::accDoDefaultAction(VARIANT varChild)
{   
    HRESULT     hr;
    CAccBase *  pParent = NULL;
    CAccBase *  pAccChild = NULL;

    TraceTag((tagAcc, "CAccElement::accDoDefaultAction, role=%d, childid=%d", 
                GetRole(), 
                V_I4(&varChild)));  

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        switch ( GetElement()->Tag() )
        {
            case ETAG_INPUT:
                switch( DYNCAST(CInput, GetElement())->GetAAtype())
                {
                    case htmlInputButton:
                    case htmlInputReset:
                    case htmlInputCheckbox:
                    case htmlInputImage:
                    case htmlInputRadio:
                    case htmlInputSubmit:
                    case htmlInputFile:
                        hr = THR( ScrollIn_Focus_Click( GetElement() ) );
                        break;

                    case htmlInputPassword: //E_NOTIMPL.
                    case htmlInputText:
                    case htmlInputTextarea:
                        hr = E_NOTIMPL;
                        break;
                }
                break;

            case ETAG_SELECT:
            case ETAG_BUTTON:
            case ETAG_A:
            case ETAG_AREA:
                hr = THR( ScrollIn_Focus_Click( GetElement() ) );
                break;
          
            case ETAG_FRAMESET:
            case ETAG_BODY:
            case ETAG_MARQUEE:
            case ETAG_TABLE:
            case ETAG_TD:
            case ETAG_TH:
                hr = E_NOTIMPL;
                break;

            case ETAG_IMG:  //if your acc.parent is anchor, ask your parent
            default:        //text nodes and IMG are the same
//
// TODO: - what if anchor around table around image???  is sniffing 1 level enough (ferhane)
//
                hr = THR( GetAccParent( GetElement(), &pParent ));
                if ( hr )
                    break;

                Assert( pParent );

                //there is no need to change varChild, since it
                //contains the CHILDID_SELF anyway...
                hr = THR( pParent->accDoDefaultAction(varChild) );
                break;
        }
    }
    else 
    {
        // find that object and call its API implementation, passing 
        // CHILDID_SELF as the child information.
        //
        // get the child CElement/CMarkupPointer. If the child id 
        // is invalid, the GetChildFromID will return with an err.
        //
        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, NULL) );
        if ( hr ) 
            goto Cleanup;

        if ( !pAccChild )
        {
            //if the text is inside an anchor, then the 
            //anchor behavior is used.
            if ( GetElement()->Tag() == ETAG_A )
            {
                hr = THR( ScrollIn_Focus_Click( GetElement() ) );
            }
            else
            {
                //no default action for plain text.
                hr = E_NOTIMPL;
            }
        }
        else 
        {
            // call child's implementation of this method. We don't have a helper for this
            // method, since the CHILDID_SELF case above has all the smarts and code.
            V_VT( &varChild ) = VT_I4;
            V_I4( &varChild ) = CHILDID_SELF;

            hr = THR( pAccChild->accDoDefaultAction( varChild ) );
        }
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  put_accValue
//  
//  DESCRIPTION :   
//          Sets the value property of the accessible object. Only the edit box
//          and password accessible objects support this method, all others 
//          return an error.
//          
//  PARAMETERS:
//      varChild     :   VARIANT containing the child ID
//      pbstrValue   :   value bstr
//
//  RETURNS:
//      DISP_E_MEMBERNOTFOUND
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::put_accValue(VARIANT varChild, BSTR bstrValue)
{
    HRESULT         hr;
    CAccBase *      pAccChild = NULL;

    // validate parameter
    if ( !bstrValue )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!_pElement->HasMarkupPtr())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        //call this instance's implementation
        hr = THR( PutAccValue(bstrValue) );
    }
    else
    {
        // get the child CElement/CMarkupPointer. If the child id 
        // is invalid, the GetChildFromID will return with an err.
        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, NULL) );
        if ( hr ) 
            goto Cleanup;

        if ( pAccChild )
        {
            V_I4( &varChild ) = CHILDID_SELF;
            
            //call child's implementation
            hr = THR( pAccChild->put_accValue( varChild, bstrValue) );
        }
        else 
            hr = E_NOTIMPL;
    }

Cleanup:
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//  GetChildFromID()
//
//  DESCRIPTION:
//      Return the child object that is indicated with the child id that is 
//      passed.
//      The object returned is either a CElement pointer or a CMarkupPointer 
//      pointer.
//      If the child refers to a text block, a CMarkupPointer * is placed
//      after the text block and returned.
//      If the child refers to a tag that is supported ( determined by calling
//      the IsSupportedElement() helper from inside AccStepRight() ) then a
//      pointer to the CElement is returned. 
//      The accessible object decides how to use the information.
//      
//  
//  PARAMETERS:
//      lChildId    :   ID of the child that is being asked for. If this parameter
//                      is (-1) then the last accessible child of this element is 
//                      returned.
//      plType      :   Address of the long to receive the child type.
//                      Valid child types are the members of the childType
//                      enumeration in the CAccElement class
//      ppAccChild  :   Address of the pointer to receive the accessible child
//                      object. The parameter can be NULL, indicating that the caller
//                      does not want it.
//      ppMarkupPtr :   Address (CMarkupPointer *) variable. The parameter
//                      can be NULL, indicating that the caller does not want it
//      plChildCnt  :   The address of the variable to receive the ID of this child.
//                      Using this parameter, the caller can both determine the total
//                      number of children and get the last one at the same time. The
//                      parameter is optional and defaults to NULL.
//----------------------------------------------------------------------------
HRESULT
CAccElement::GetChildFromID(    long                lChildId, 
                                CAccBase **         ppAccChild, 
                                CMarkupPointer *    pMarkupPtrBegin,
                                long *              plChildCnt /*= NULL */)
{
    HRESULT             hr= S_OK;
    CMarkupPointer *    pelemBegin = NULL;
    CMarkupPointer *    pelemEnd = NULL;
    CTreeNode *         pElemNode = NULL;
    long                lChildCnt =0;
    MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;
    CWindow *           pWindow = GetAccWnd();

    //if the lChildId is <0 then go till the end of the scope
    BOOL                bGotoTheEnd = (lChildId < 0) ? TRUE : FALSE; 

    // we should never pass in CHILDID_SELF to this method.
    Assert( lChildId != 0 );

    if ( ppAccChild )
        *ppAccChild = NULL;

    // if the element is not in a markup, we are hosed.
    if (!GetElement()->HasMarkupPtr())
    {
        hr = E_FAIL;
        
        if (plChildCnt)
            *plChildCnt = NULL;

        goto Cleanup;
    }

    if (!pWindow)       // could not get an accwnd.
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // CAUTION CAUTION CAUTION ! ! !
    //          This function uses the markup pointer that is passed in as a parameter
    //          to walk on the HTML stream using the tree services core functions.
    //          There are two cached CMarkupPointer instances on the CAccWindow to 
    //          avoid the constant create/destroy of these pointers. This function uses
    //          the _elemEnd to mark the end of the element, so it can determine when
    //          to stop. 
    //          The pointer that is passed in MUST NOT BE the end pointer, since that
    //          would cause immediate satisfaction of condition in the <while> below
    //          and return the wrong child.
    //          Hence the assert. (ferhane)
    AssertSz( pWindow->_pAccWindow && pMarkupPtrBegin != &( pWindow->_pAccWindow->_elemEnd ), 
                            "The markup pointer this function relies on being static is passed in as volatile. BUG!");

    if (GetElement()->Tag() == ETAG_IMAGE)
    {
        CImgElement *pImg = DYNCAST(CImgElement, GetElement());

        // handle areas under an image. in this case the childID is the 
        // subdivision of the image as a 1 based index.
        if (pImg && pImg->EnsureAndGetMap())
        {
            CAreaElement *  pArea = NULL;

            IGNORE_HR(pImg->GetMap()->GetAreaContaining(lChildId-1, 
                                                        &pArea));
            if (pArea)
            {
                *ppAccChild = GetAccObjOfElement( pArea );
                lChildCnt = lChildId;
                hr = S_OK;
                goto Cleanup;
            }
        }
    }

    if ( !CanHaveChildren() )
        return S_FALSE;             // No Children

    // Either use my local markup pointer, or the one I'm handed.
    // This is the pointer to be moved around in the markup stream
    if ( pMarkupPtrBegin )
    {
        pelemBegin = pMarkupPtrBegin;
    }
    else
    {
        pelemBegin = &( pWindow->_pAccWindow->_elemBegin );
    }

    // did we have a cached child, and is the cache still valid? 
    if ( IsCacheValid() && ( lChildId >= _lLastChild ) )
    {
        // move the beginning pointer to where the cached pointer is
        pelemBegin->MoveToPointer( &_lastChild );

        // set the current child count to the current index
        lChildCnt = _lLastChild;

        // if we are accessing the same child, just get the context information
        // and return.
        if ( lChildId == _lLastChild )
        {
            // Check left to see what the last child was
            hr = THR( pelemBegin->Left( FALSE, &context, &pElemNode, NULL, NULL, NULL) );
            if ( hr ) 
                goto Cleanup;

            // we have the context and pElemNode values, go to return routine...
            goto Return;
        }
    }
    else
    {
        // the cache was not valid, reset variables.

        _lLastChild = 0;   // invalidate the cache.
        _lTreeVersion = 0;
    }

    // if the last child is zero, either we reset it above, or there was no cache.
    // either way, we have to start from the very beginning.
    if ( _lLastChild == 0 )
    {
        // mark the beginning of the element
        hr = THR( pelemBegin->MoveAdjacentToElement( GetElement(), ELEM_ADJ_AfterBegin));
        if (hr)
            goto Cleanup;
    }

    // set the end markup pointer to the end of the element, so
    // that we can stop.
    pelemEnd = &(pWindow->_pAccWindow->_elemEnd);

    hr = THR( pelemEnd->MoveAdjacentToElement( GetElement(), ELEM_ADJ_BeforeEnd));
    if ( hr )
        goto Cleanup;

    //now, start walking to the right, until you hit child that is being 
    //asked, or the end of the scope for this element
    while ( bGotoTheEnd || ( lChildCnt < lChildId ) )
    {
        // we have reached the end of the scope of this element. If we have
        // the bGotoTheEnd set to TRUE, then we actually want the last child
        // which we just jumped over. 
        // Otherwise we have reached here without finding the child id that 
        // was passed and the child id is invalid
        if ( pelemBegin->IsEqualTo( pelemEnd ) )
        {
            // If the last child was being asked, there is nothing wrong,
            // break out and continue.
            if ( bGotoTheEnd )
                break;
            else
            {
                //[FerhanE]
                // Different from the proxy, we return E_INVALIDARG for all child
                // needing calls if we don't have a child. That is the same return
                // code we return if we have an invalid child id.
                if (lChildCnt)
                {
                    // there were children counted, so a bad value must have been passed in
                    hr = E_INVALIDARG;
                }
                else
                {
                    // return ourselves. since no children were counted, and we left
                    // our scope. This can happen hittesting and Iframe.
                    *ppAccChild= this;
                    hr = S_OK;
                    goto Cleanup;
                }
            }
        }

        //Take us out if the index was invalid or there were no children.
        if ( hr )               
            goto Cleanup;


        //get what is to our right
        hr = THR( pelemBegin->Right( TRUE, &context, &pElemNode, NULL, NULL, NULL));
        if ( hr )
            goto Cleanup;

        switch ( context )
        {
#if DBG==1            
            case CONTEXT_TYPE_None:     
                //if there was nothing on this side at all,
                AssertSz(FALSE, "We have hit the root..");
                break;

            case CONTEXT_TYPE_ExitScope://don't care ...
                break;
#endif

            case CONTEXT_TYPE_EnterScope:
                //check the element to see if it is a supported element
                if ( IsSupportedElement( pElemNode->Element() ) )
                {
                    //go to the end of this element, since we will handle it as a container
                    hr = THR( pelemBegin->MoveAdjacentToElement( pElemNode->Element(), ELEM_ADJ_AfterEnd));
                    if ( hr )
                        goto Cleanup;

                    lChildCnt++;      
                }
                //don't do anything if it is not a supported element.
                break;  
            
            //we jumped over text or noscope
            case CONTEXT_TYPE_NoScope:
                if ( !IsSupportedElement( pElemNode->Element() ))
                    break;
            
            case CONTEXT_TYPE_Text:
                lChildCnt++;
                break;
        }
    }

    // if we don't have any children
    // we better leave before reaching here, 
    Assert( lChildCnt );

    // place the cache pointer to where the walker is
    hr = THR( _lastChild.MoveToPointer( pelemBegin ) );
    if ( hr )
        goto Cleanup;                

Return:
    //if the block was a text block, we return the markup pointer
    //otherwise return the acc object for the element that we passed over.
    if ((( context == CONTEXT_TYPE_EnterScope ) || 
              ( context == CONTEXT_TYPE_NoScope    ) ||
              ( context == CONTEXT_TYPE_ExitScope )) && 
             ( ppAccChild ))
    {
        
        // if the element is a supported element, return the element,
        // however, if the call was for a last child, the last tag
        // may belong to a non-supported element.
        if (bGotoTheEnd && !IsSupportedElement(pElemNode->Element()))
        {
            context = CONTEXT_TYPE_None;

            // until we find an element 
            while ((context != CONTEXT_TYPE_Text) && 
                    !IsSupportedElement(pElemNode->Element()))
            {
                // we use the _lastChild, since we also want to be able to preserve the
                // location in case we return text.
                hr = THR( _lastChild.Left( TRUE, &context, &pElemNode, NULL, NULL, NULL));
                if (hr)
                    goto Cleanup;
            }

            // reverse the last move, so that we are pointing to the end of the last child
            hr = THR( _lastChild.Right( TRUE, &context, &pElemNode, NULL, NULL, NULL));
            if (hr)
                goto Cleanup;

            if (context == CONTEXT_TYPE_Text)
                goto Cleanup;
        }
 
        //get the accessible object for that element.
        *ppAccChild = GetAccObjOfElement( pElemNode->Element() );
        if ( !(*ppAccChild))
            hr = E_OUTOFMEMORY;
    }
    
Cleanup:
    //set the return child count.
    if ( plChildCnt && !hr )
        *plChildCnt = lChildCnt;

    // invalidate the cache if there was an error.
    if ( hr )
    {
        _lLastChild = 0;
        _lTreeVersion = 0;
    }
    else
    {
        _lTreeVersion = GetElement()->GetMarkupPtr()->GetMarkupTreeVersion();
        _lLastChild = lChildCnt;                       // last child we accessed.
    }
   
    RRETURN( hr );
}

//-----------------------------------------------------------------------
//  GetLabelText
//-----------------------------------------------------------------------
HRESULT
CAccElement::GetLabelText( BSTR * pbstrOutput)
{
    HRESULT hr = S_OK;

    //get the associated label element if there is one
    CLabelElement * pLabel = GetLabelElement();

    if( pLabel)
    {
        hr = THR( pLabel->get_innerText( pbstrOutput ) );

        // If the user explicitly wanted to have a label with no text then
        // we should honor it. 
        // But for backward (IE4.01) compatability we need to test the length
        if (!SysStringLen(*pbstrOutput))
        {
            SysFreeString(*pbstrOutput);
            *pbstrOutput = NULL;
        }
    }

    RRETURN(hr);
}

//-----------------------------------------------------------------------
//  GetLabelOrTitle
//-----------------------------------------------------------------------
HRESULT 
CAccElement::GetLabelorTitle( BSTR* pbstrOutput )
{
    HRESULT         hr=S_OK;

    if (!pbstrOutput)
        return S_FALSE;

    *pbstrOutput = NULL;

    hr = GetLabelText(pbstrOutput);
    if (hr)
        goto Cleanup;

    if (!*pbstrOutput)
    {
        //get the title for the checkbox
        hr = GetTitle(pbstrOutput);
        if (FAILED(hr) || !*pbstrOutput)
            hr = E_NOTIMPL;
    }
Cleanup:
    RRETURN1(hr, S_FALSE);
}

//-----------------------------------------------------------------------
//  GetTitleorLabel
//-----------------------------------------------------------------------
HRESULT 
CAccElement::GetTitleorLabel( BSTR* pbstrOutput )
{
    HRESULT         hr=S_OK;

    Assert(pbstrOutput);

    //get the title for the checkbox
    hr = GetTitle(pbstrOutput);
    if (hr || !*pbstrOutput)
    {
        hr = GetLabelText(pbstrOutput);
    }

    RRETURN1( hr, S_FALSE );
}

//-----------------------------------------------------------------------
//  GetTitle
//-----------------------------------------------------------------------
HRESULT
CAccElement::GetTitle( BSTR* pbstrOutput )
{
    HRESULT hr = S_OK;
    TCHAR* pchString=NULL;

    Assert(pbstrOutput);
    Assert(!*pbstrOutput);

    //get the title 
    pchString = (LPTSTR) GetElement()->GetAAtitle();
    if ( pchString )
    {
        *pbstrOutput = SysAllocString( pchString );
        if ( !(*pbstrOutput) )
            hr = E_OUTOFMEMORY;
    }
    else
        hr = S_FALSE;

    RRETURN1( hr, S_FALSE );
}

//-----------------------------------------------------------------------
//  HasLabel - this helper function is necessaryt to support the accDescription
//      methods.  The way that description works is that it returns what
//      the name doesn't.  So if there is a label, accName returns it and 
//      accDesc shoule return the title.  If there is no label, then accName 
//      returns the title and accDescription is left returning nothing.
//          the wrinkle in this is that there not only has to be a label but
//      the label needs to actually have text . i.e. <label for=idFoo></label>
//      doesn't count.
//-----------------------------------------------------------------------
BOOL
CAccElement::HasLabel()
{
    BSTR            bstrOutput = NULL;
    CLabelElement * pLabel;
    BOOL            fRet = FALSE;

    pLabel = GetLabelElement();

    if (!pLabel)
        goto Cleanup;

    if (FAILED( pLabel->get_innerText( &bstrOutput ) ))
        goto Cleanup;

    if (bstrOutput)
    {
        fRet = !!SysStringLen(bstrOutput);

        SysFreeString(bstrOutput);
    }

Cleanup:
    return fRet;
}

//+-------------------------------------------------------------------------
//
// HitTestArea - helper function for accHitTest.  This is called when an
//  image with a map is hittested over an area (subdivision).  its job is 
//  to return the accElemetn of hte area that was hit.
//
//---------------------------------------------------------------------------
HRESULT
CAccElement::HitTestArea(CMessage *pMsg,    
                         CTreeNode *pHitNode,
                         VARIANT * pvarChildAtPoint)
{
    HRESULT      hr = E_FAIL;
    CImgElement *pImg = DYNCAST(CImgElement, pHitNode->Element());

    Assert(pvarChildAtPoint && V_VT(pvarChildAtPoint)==VT_EMPTY);

    if (pImg && pImg->GetMap())
    {
        CAreaElement *  pArea = NULL;

        IGNORE_HR(pImg->GetMap()->GetAreaContaining(pMsg->lSubDivision, 
                                                    &pArea));
        if (pArea)
        {
            CAccBase  *pAccObj = GetAccObjOfElement( pArea );
            if ( pAccObj )
            {
                V_VT( pvarChildAtPoint )  = VT_DISPATCH;
                V_DISPATCH( pvarChildAtPoint ) = pAccObj;
    
                pAccObj->AddRef();
    
                hr = S_OK;
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

//+----------------------------------------------------
//
//  GetAnchorParent() - helper function that walks up the 
//      accesssible parent chain looking to see if there is
//      an anchor in scope above us.  If there is return it
//      so that it's properties can be used.  If there isn't
//      return NULL
//
//-----------------------------------------------------
CAccBase *
CAccElement::GetParentAnchor()
{
    CAccBase * pParent = NULL;
    CAccBase * pCurrent = this;
    BOOL       fDone = FALSE;

    while (!fDone && pCurrent)
    {
        if (S_OK != GetAccParent( pCurrent->GetElement(), &pParent ) )
        {
            fDone = TRUE;
            pParent = NULL;
        }
        else 
        {
            Assert( pParent);

            if (pParent->GetElement())
            {
                switch ( pParent->GetElement()->Tag())
                {
                case ETAG_A:
                    // bingo, retun this puppy
                    fDone = TRUE;
                    break;

                case ETAG_TABLE:
                case ETAG_TD:
                case ETAG_TH:
                case ETAG_BODY:
                    // anchors don't propogate through tables.
                    // ..and other good stopping criteria
                    pParent = NULL;
                    fDone = TRUE;
                    break;

                }
                pCurrent = pParent;
            }
            else
            {
                // we have hit a frame or a viewlink boundary...
                pParent = NULL;
                fDone = TRUE;
            }
        }
    }

    return pParent;
}



//+------------------------------------------------------
//
//   BOOL fBrowserWindowHasFocus() - 
//  Another helper function for determining when we can
//  specify the STATE_SYSTEM_SELECTABLE for text.  For
//  proxy compatablity this is when the forground focus
//  window is ours.
//-------------------------------------------------------
BOOL
CAccElement::fBrowserWindowHasFocus()
{
    HWND hwndCurrent = GetElement()->Doc()->GetHWND();
    HWND hwndTarget = GetForegroundWindow();

    while(hwndCurrent)
    {
        if(hwndTarget == hwndCurrent)
            break;
    
        hwndCurrent = ::GetParent(hwndCurrent);
    }

    //--------------------------------------------------
    // no focused window means that neither this 
    // window or any of its parent chain has the focus.
    // **NOTE** this handles uninitialized frames also.
    //--------------------------------------------------
    return !! hwndCurrent;
}

//+---------------------------------------------------------------------------
//  GetSelectedChildren
//  
//  DESCRIPTION: Returns accessible children that reside between two markup 
//          pointers. 
//          bForceEnumerator flag is used to force creation of an IEnumVariant 
//          implementation. If the flag is FALSE, and there is only one child
//          then the only child is returned in the return variant. Otherwise
//          the return variant contains the IEnumVariant pointer.
//          cChildBase contains the offset child id, for the child that starts
//          at the location marked with pStart. This is needed for text children.
//  
//  PARAMETERS:
//      cChildBase          :   Child id offset
//      pStart              :   Starting point within the markup
//      pEnd                :   Ending point within the markup
//      pvarSelectedChildren:   Return variant that receives a child or enumeration
//      bForceEnumerator    :   If TRUE, an enumerator is created even if there 
//                              is only one child in the markup region.
//
//----------------------------------------------------------------------------
HRESULT
CAccElement::GetSelectedChildren(   long cChildBase, 
                                    CMarkupPointer *pStart, 
                                    CMarkupPointer * pEnd, 
                                    VARIANT * pvarSelectedChildren,
                                    BOOL    bForceEnumerator )
{
    HRESULT                     hr = S_OK;
    long                        lCounter = 0;
    long                        lOldCounter = 0;
    CTreeNode *                 pElemNode = NULL;
    VARIANT                     varCurrent;
    MARKUP_CONTEXT_TYPE         context;
    CAccBase *                  pAccChild = NULL;
    CDataAry <VARIANT> *        pary = NULL;

    Assert( pStart );
    Assert( pEnd );
    Assert( pvarSelectedChildren );
    
    varCurrent.vt = VT_EMPTY;
    varCurrent.lVal = 0;

    pary = new(Mt(CAccElementget_accSelection_aryVariants_pv)) 
                        CDataAry<VARIANT>(Mt(CAccElementget_accSelection_aryVariants_pv));
    if ( !pary )
        RRETURN( E_OUTOFMEMORY );

    // Until the start pointer reaches or passes the end location
    while ( pStart->IsLeftOf( pEnd )  )
    {
        hr = THR( pStart->Right( TRUE, &context, &pElemNode, 
                                            NULL, NULL, NULL));
        if ( hr )
            goto Cleanup;

        switch ( context )
        {
#if DBG==1            
            case CONTEXT_TYPE_None:     
                //if there was nothing on this side at all,
                AssertSz(FALSE, "We have hit the root..");
                break;
            case CONTEXT_TYPE_ExitScope://don't care ...
                break;
#endif
            case CONTEXT_TYPE_EnterScope:
                Assert( pElemNode );
                
                // check the element to see if it is a supported element
                if ( IsSupportedElement( pElemNode->Element() ) )
                {
                    // go to the end of this element, 
                    // since we will handle it as a container
                    hr = THR( pStart->MoveAdjacentToElement( pElemNode->Element(), 
                                                                ELEM_ADJ_AfterEnd));
                    if ( hr )
                        goto Cleanup;

                    lCounter++;
                }
                //don't do anything if it is not a supported element.
                break;  
                
            //we jumped over text or noscope
            case CONTEXT_TYPE_NoScope:
                Assert( pElemNode );
                if ( !IsSupportedElement( pElemNode->Element() ))
                    break;
                //else 
                //  fall through to increment the counter.
                
            case CONTEXT_TYPE_Text:
                lCounter++;      
                break;
        }

        // if we passed a valid accessible child, then the counter must have been incremented
        if ( lOldCounter != lCounter )
        {
            VariantInit( &varCurrent );
            
            if ( context == CONTEXT_TYPE_Text )
            {   
                V_VT( &varCurrent ) = VT_I4;
                V_I4( &varCurrent ) = lCounter + cChildBase;
            }
            else
            {
                IDispatch * pDispTmp;

                V_VT( &varCurrent ) = VT_DISPATCH;

                pAccChild = GetAccObjOfElement( pElemNode->Element() );
                if ( !pAccChild )
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                // increment the ref count and do the casting at the same time.
                hr = THR( pAccChild->QueryInterface( IID_IDispatch, (void**)&pDispTmp));
                if ( hr )
                    goto Cleanup;
                    
                Assert( pDispTmp );

                V_DISPATCH( &varCurrent ) = pDispTmp;
            }

            //append the record to the list, and reset the variant
            hr = THR(pary->EnsureSize(lCounter));
            if (hr)
                goto Cleanup;

            // no need to addref the variant's IDispatch content, since we will dispose 
            // of the varCurrent's contents. AddRef is done above with the QI call.
            hr = THR( pary->AppendIndirect( &varCurrent, NULL ) );
            if ( hr )
                goto Cleanup;

            // reset the check condition.
            lOldCounter = lCounter;
        }
    }
    if ( bForceEnumerator  || (lCounter > 1 ) )   
    {
        // create the enumerator using the CDataAry contents and return the 
        // IEnumVariant * in the return VARIANT.
        hr = THR(pary->EnumVARIANT(VT_VARIANT, 
                                    (IEnumVARIANT **) &V_DISPATCH(pvarSelectedChildren), 
                                    FALSE,  // don't copy the array being enumerated use the one we gave
                                    TRUE)); // delete enumeration when no one is left to use .
        if (hr)
            goto Cleanup;

        V_VT( pvarSelectedChildren ) = VT_DISPATCH;
        
        //we don't delete the pary, since its contents are being used by the enumerator...!
        pary = NULL;
    }
    else if ( lCounter == 1 )
    {
        // we copy ourselves, and not use VariantCopy, since the value is already
        // addref ed if it is a dispatch ptr.
        memcpy( pvarSelectedChildren, &varCurrent, sizeof(VARIANT));
    }
    else    //no children, and bForceEnumerator is FALSE, return VT_EMPTY.
    {
        V_VT( pvarSelectedChildren ) = VT_EMPTY;
    }

Cleanup:
    delete  pary;
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//  GetEnumerator
//
//  DESCRIPTION:
//      Create and return a pointer to the enumerator object for this 
//----------------------------------------------------------------------------
HRESULT 
CAccElement::GetEnumerator( IEnumVARIANT ** ppEnum)
{
    HRESULT             hr;
    CMarkupPointer      markupStart( GetElement()->Doc() );
    CMarkupPointer      markupEnd( GetElement()->Doc() );
    VARIANT             varResult;

    // only called internally.
    Assert( ppEnum );

    *ppEnum = NULL;

    // get the limits for the element 
    hr = THR( GetMarkupLimits( GetElement(), &markupStart, &markupEnd ) );
    if ( hr )
        goto Cleanup;    

    // get an array of children of this element.
    // Even if there are no children, varResult contains the enumerator, 
    // since we pass TRUE for the last parameter( bForceEnumerator )
    hr = THR( GetSelectedChildren( 0, &markupStart, &markupEnd, &varResult, TRUE ) );
    if ( hr )
        goto Cleanup;

    // We've got to receive an enumerator here.
    Assert( V_VT(&varResult) == VT_DISPATCH );

    // return the enumerator object.
    *ppEnum = (IEnumVARIANT *)V_DISPATCH( &varResult );
    
Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//  GetLabelParent
//  
//  DESCRIPTION:
//      REturns the CLabelElement parent for the element this accessible object
//      is associated with. 
//
//      Return value can be NULL.
//----------------------------------------------------------------------------
CLabelElement *
CAccElement::GetLabelElement()
{
    CTreeNode * pNode;
    CLabelElement * pLabel = GetElement()->GetLabel();

    // does this element have a label associated with it.
    // if so, return it.
    if (pLabel)
        goto Cleanup;

    // may be the element does not have a label associated
    // but is wrapped with one.
    pNode = GetElement()->GetFirstBranch();

    if ( !pNode || pNode->IsDead() )
        goto Cleanup;

    pNode = pNode->Parent();

    // if we have a parent, then check if it is actually 
    // a label element,
    if (pNode && (pNode->Tag() == ETAG_LABEL) )
        pLabel = DYNCAST( CLabelElement, pNode->Element());

Cleanup:
    return pLabel;
}


BOOL 
CAccElement::IsVisibleRect( CRect * pRectRegion )
{
    HRESULT     hr;
    CElement *  pElemClient;
    long        clientWidth;
    long        clientHeight;

    Assert(GetElement()->HasMarkupPtr());

    // get the document's primary element client and ask it where its scroll
    // positions are.
    pElemClient = CMarkup::GetElementClientHelper(GetElement()->GetMarkupPtr());

    // if there is no primary element client, NOT VISIBLE
    if (!pElemClient)
        goto Invisible;

    hr = THR(pElemClient->get_clientWidth(&clientWidth));
    if (hr)
        goto Visible;

    hr = THR(pElemClient->get_clientHeight(&clientHeight));
    if (hr)
        goto Visible;

    // if the bounding rectangle of the text is containing the scroll area, 
    // or it has one of its corners inside it, the text is visible.
    // it is easier to check the invisible condition
    if ((pRectRegion->left > clientWidth) || 
        (pRectRegion->top > clientHeight) ||
        (pRectRegion->bottom < 0) ||
        (pRectRegion->right < 0) )
        goto Invisible;

Visible:
    return TRUE;
Invisible:
    return FALSE;
}

//+---------------------------------------------------------------------------
//  IsTextVisible
//
//----------------------------------------------------------------------------
BOOL
CAccElement::IsTextVisible(CMarkupPointer * pTextBegin, CMarkupPointer * pTextEnd)
{
    HRESULT             hr;
    CTreeNode *         pParentNode;
    CStackDataAry <RECT,4>     aryRects( Mt(CAccElementaccLocation_aryRects_pv) );
    CRect               rectRegion;
    CDoc *              pDoc = GetElement()->Doc();

    //get the closest HTML element parent 
    pParentNode = pTextEnd->CurrentScope(MPTR_SHOWSLAVE);

    if (pParentNode)
    {
        // if the parent element is not visible, then it does not matter if we 
        // are in the view or not.
        if (!pParentNode->Element()->IsVisible(TRUE))
            goto Cleanup;

        // is the text inside the client window coordinates
        hr = THR( pDoc->RegionFromMarkupPointers( pTextBegin, 
                                                    pTextEnd,
                                                    &aryRects, 
                                                    &rectRegion ));

        if ( hr || IsVisibleRect(&rectRegion))
            return TRUE;
    }

Cleanup:
    return FALSE;
}

//----------------------------------------------------------------------------
//  Function    :   GetNavChildId
//  Description :   Given a child element of this element, returns the index
//                  of its sibling in the direction indicated by the navigation
//                  direction parameter.
//----------------------------------------------------------------------------
HRESULT
CAccElement::GetNavChildId( long navDir, CElement * pChildElement, long * pChildId)
{
    HRESULT             hr;
    CMarkupPointer *    pBegin;
    CMarkupPointer *    pEnd;
    long                lChildId = 0;
    long                lCachedChildId = 0;
    long                lIndex = 0;

    CWindow * pWindow = GetAccWnd();
    
    if (!pWindow)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pBegin = &( pWindow->_pAccWindow->_elemBegin );
    pEnd = &( pWindow->_pAccWindow->_elemEnd );
    
    // place a markup pointer before the beginning of the child element
    hr = THR( pEnd->MoveAdjacentToElement(pChildElement, ELEM_ADJ_BeforeBegin) );
    if (hr)
        goto Cleanup;
 
    // if there is a cached location pointer and 
    // if this element is on the right or on top of the cached location
    if ( IsCacheValid() && 
            !pEnd->IsLeftOf(&_lastChild))
    {
        // move the beginning pointer to where the cached pointer is
        pBegin->MoveToPointer( &_lastChild );

        // The cached child id will change on the parent side when we walk to 
        // find this element in the stream. We must backup.
        lCachedChildId = _lLastChild;
    }
    else
    {
        //place a pointer to the beginning of this element
        hr = THR( pBegin->MoveAdjacentToElement( GetElement(),ELEM_ADJ_AfterBegin ) );
        if (hr) 
            goto Cleanup;

        // invalidate the cache of the parent, 
        // we will have to walk from the start anyway.
        _lLastChild = 0;
        _lTreeVersion = 0;
    }
    
    // find child element's child id
    hr = GetChildCount( pBegin, pEnd, &lChildId);
    if(hr)
        goto Cleanup;

    // since we have counted the children up to the child element, it is +1
    // to the total number of children that are before it.
    lChildId = lCachedChildId + lChildId + 1;
    
    // If we need to go to the next element, we could actually benefit from the 
    // cache on the parent element
    if ( navDir == NAVDIR_NEXT )
    {
        CMarkup * pMarkup;

        // place the cached markup pointer to the end of this child.
        hr = THR( _lastChild.MoveAdjacentToElement( pChildElement, ELEM_ADJ_AfterEnd ));
        if (hr)
            goto Cleanup;

        _lLastChild = lChildId;

        pMarkup = GetElement()->GetMarkupPtr();

        if (pMarkup)
        {
            _lTreeVersion = pMarkup->GetMarkupTreeVersion();
        }
        else
        {
            _lTreeVersion = 0;
        }

        // the child id we will ask for from the parent
        lIndex = lChildId + 1;
    }
    else if (lChildId == 1)
    {
        // if NAVDIR_PREVIOUS, then we MUST be at least the second child.
        hr = S_FALSE;
    }
    else
    {
        // the child id we will ask for from the parent
        lIndex = lChildId - 1;
    }

Cleanup:
    *pChildId = lIndex;

    // convert all other error codes to S_FALSE too.
    if (hr)
        hr = S_FALSE;

    RRETURN1(hr, S_FALSE);
}

//----------------------------------------------------------------------------
//  Helper to get the access key for an element.
//
//----------------------------------------------------------------------------
HRESULT 
CAccElement::GetAccKeyboardShortcut(BSTR * pbstrKeyboardShortcut)
{
    CStr    accessString;
    CStr    sString;    
    HRESULT hr;

    // get the actual key combination value
    hr = THR (accessString.Set(GetElement()->GetAAaccessKey()));
    if (hr)
        goto Cleanup;

    // if there is an access key string
    if (accessString.Length() > 0)
    {
        // we want all keyboard shortcut values to contain 'Alt+' 
        hr = THR(sString.Set( _T("Alt+")));
        if ( hr )
            goto Cleanup;
        
        hr = THR(sString.Append(accessString));
        if (hr)
            goto Cleanup;
            
        hr = THR(sString.AllocBSTR( pbstrKeyboardShortcut ) );
        if (hr)
            goto Cleanup;
    }
    
Cleanup:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//  Function    :   IServiceProvider::QueryService
//
//  Description :   Function that provides access to other objects that are 
//                  related to this accessible object, but do not have the
//                  same COM identity.
//
//                  Service requests that are supported are:
//                  IID_IHTMLElement
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccElement::QueryService(  REFGUID guidService, REFIID riid, void ** ppvObject)
{
    HRESULT hr;

    if (!ppvObject)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (IsEqualGUID(guidService, IID_IHTMLElement))
    {
        hr = THR(_pElement->QueryInterface(riid, ppvObject));
    }
    else
    {
        hr = E_NOINTERFACE;
    }

Cleanup:
    RRETURN1( hr, E_NOINTERFACE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\accfile.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-2000
//
//  File:       AccFile.Cxx
//
//  Contents:   Accessible <input type=file> object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCFILE_HXX_
#define X_ACCFILE_HXX_
#include "accfile.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif


//----------------------------------------------------------------------------
//  CAccInputFile
//  
//  DESCRIPTION:    
//      The input type=file accessible object constructor
//
//  PARAMETERS:
//      Pointer to the input element 
//----------------------------------------------------------------------------
CAccInputFile::CAccInputFile(CElement* pElementParent)
:CAccEdit(pElementParent, FALSE)
{
    Assert(pElementParent);
    
    //initialize the instance variables
    SetRole(ROLE_SYSTEM_TEXT);
}


//----------------------------------------------------------------------------
//  GetAccDefaultAction
//  
//  DESCRIPTION:
//  Returns the default action, which is "Browse for file to upload"
//
//  PARAMETERS:
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccInputFile::GetAccDefaultAction(BSTR* pbstrDefaultAction)
{
    HRESULT hr = S_OK;

    if (!pbstrDefaultAction)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDefaultAction = SysAllocString( _T("Browse for file to upload") );

    if (!(*pbstrDefaultAction))
        hr = E_OUTOFMEMORY;
   
Cleanup:
   RRETURN(hr);
}


//----------------------------------------------------------------------------
//  GetAccValue
//  
//  DESCRIPTION:
//      Returns the value of the input type=file box.
//  
//  PARAMETERS:
//      pbstrValue   :   BSTR pointer to receive the value
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccInputFile::GetAccValue(BSTR* pbstrValue)
{
    HRESULT hr = S_OK;
    CStr    str;

    // validate out parameter
    if (!pbstrValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrValue = NULL;

	// get value from InputFile    
    hr = THR((DYNCAST(CInput, _pElement))->GetValueHelper(&str));
    if (hr) 
        goto Cleanup;

    //even if the value that is returned is NULL, we want to return it..
    hr = str.AllocBSTR(pbstrValue);
    
Cleanup:
    RRETURN(hr);
}



//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      Returns "browse for file to upload"
//  
//  PARAMETERS:
//      pbstrDescription   :   BSTR pointer to receive the Description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccInputFile::GetAccDescription(BSTR* pbstrDescription)
{
    HRESULT hr = S_OK;

    // validate out parameter
    if (!pbstrDescription)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrDescription = SysAllocString(_T("Browse for file to upload"));
	
Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\accimg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccImg.Cxx
//
//  Contents:   Accessible Image object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCIMG_HXX_
#define X_ACCIMG_HXX_
#include "accimg.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_ELABEL_HXX
#define X_ELABEL_HXX
#include "elabel.hxx"
#endif

ExternTag(tagAcc);

//----------------------------------------------------------------------------
//  CAccImage
//  
//  DESCRIPTION:    
//      The image accessible object constructor
//
//  PARAMETERS:
//      Pointer to the image element 
//----------------------------------------------------------------------------
CAccImage::CAccImage( CElement* pElementParent )
:CAccElement(pElementParent)
{
    long lRole;
    
    Assert( pElementParent );
    
    //initialize the instance variables    
    if ( (DYNCAST( CImgElement, _pElement))->GetAAdynsrc() )
    {
        lRole = ROLE_SYSTEM_ANIMATION;
    }
    else
        lRole  = ROLE_SYSTEM_GRAPHIC;

    SetRole( lRole );
}

//----------------------------------------------------------------------------
//  get_accChildCount
//  
//  An image's child count is the number of areas that are connected to this 
//  image, through map objects.
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccImage::get_accChildCount(long* pChildCount)
{
    if ( !pChildCount )
        RRETURN( E_POINTER );

    TraceTag((tagAcc, "CAccImage::get_accChildCount"));  

    RRETURN( DYNCAST( CImgElement, _pElement)->GetSubDivisionCount ( pChildCount ) );
}

//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      If the title is not empty, returns the title
//      else, if there is alt text returns the alt text . 
//      else, not implemented
//
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccImage::GetAccName( BSTR* pbstrName )
{
    HRESULT hr = S_OK;
    TCHAR * pchString = NULL;

    // validate out parameter
     if ( !pbstrName )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrName = NULL;

    //get the title for the image
    pchString = (LPTSTR) _pElement->GetAAtitle();

    //if there is no title, get the alt. text
    if ( !pchString)
        pchString = (LPTSTR) (DYNCAST(CImgElement, _pElement))->GetAAalt();

    //if no title, and no alt. text.then walk up the accParent chain
    // and look for an anchor.  if there is one use its Name
    if ( !pchString )
    {
        CAccBase * pParent = GetParentAnchor();

        hr = (pParent) ? DYNCAST(CAccElement, pParent)->GetAccName(pbstrName) : E_NOTIMPL;
    }

    if ( !*pbstrName)
    {
        //if we have something in the pchString, use it.
        if (pchString)
        {
            *pbstrName = SysAllocString( pchString );
            if ( !(*pbstrName) )
                hr = E_OUTOFMEMORY;
        }
        else 
        {
            hr = THR(GetLabelText(pbstrName));
        }
    }
    
Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccValue
//  
//  DESCRIPTION:
//      If the parent is an anchor, delegate to the anchor. If not,
//      then if there is dynsrc return that, if not,
//      then if there is src return that.
//      Since the constructor checks for the dynsrc to determine the role, we
//      check the role here.
//  
//  PARAMETERS:
//      pbstrValue   :   BSTR pointer to receive the value
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccImage::GetAccValue( BSTR* pbstrValue)
{
    HRESULT     hr = S_OK;
    CAccBase *  pParent = NULL;
    TCHAR *     pchString = NULL;
    TCHAR       cBuf[pdlUrlLen];
    TCHAR *     pchNewUrl = cBuf;
    CDoc *      pDoc = _pElement->Doc();

    // validate out parameter
    if ( !pbstrValue )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrValue = NULL;

    //get the parent and see if it is an anchor.
    pParent = GetParentAnchor();

    //if parent is an anchor, delegate the call.
    if (pParent )
    {
        hr = THR( DYNCAST(CAccElement, pParent)->GetAccValue( pbstrValue ));
    }
    else
    {
        //check if there is dynsrc.
        if ( _lRole == ROLE_SYSTEM_ANIMATION )
        {
            pchString = (LPTSTR) (DYNCAST( CImgElement, _pElement))->GetAAdynsrc();
        }
        else
        {
            pchString = (LPTSTR) (DYNCAST( CImgElement, _pElement))->GetAAsrc();
        }

        if (!pchString)
        {
            hr = E_NOTIMPL;
            goto Cleanup;
        }

        // Return fully expanded URL
        if ( pDoc )
            hr = THR(CMarkup::ExpandUrl(NULL, pchString, ARRAY_SIZE(cBuf), pchNewUrl, _pElement));
        if (hr || (pchNewUrl == NULL))
            goto Cleanup;

        //we have something in the pchString, use it.
        *pbstrValue = SysAllocString( pchNewUrl );
        if ( !(*pbstrValue) )
            hr = E_OUTOFMEMORY;
    }

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      If the title is not empty, returns the title
//      else, if there is alt text returns the alt text . 
//      else, not implemented
//
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccImage::GetAccDescription( BSTR* pbstrDescription)
{
    HRESULT hr = S_OK;
    TCHAR * pchString = NULL;

    // validate out parameter
     if ( !pbstrDescription )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrDescription = NULL;


    // if there is a title then the alt goes into descption,
    // otherwise the desc is ""
    if (_pElement->GetAAtitle())
    {
        //get the alt. text
        pchString = (LPTSTR) (DYNCAST(CImgElement, _pElement))->GetAAalt();

        if ( pchString )
        {   
            *pbstrDescription = SysAllocString( pchString );
            if ( !(*pbstrDescription) )
                hr = E_OUTOFMEMORY;
        }
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      if not visible, then STATE_SYSTEM_INVISIBLE
//      if object is not complete, then STATE_SYSTEM_UNAVAILABLE
//      adds the parents state to these, if the parent is an anchor.
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccImage::GetAccState( VARIANT *pvarState )
{
    HRESULT    hr=S_OK;
    CAccBase * pParent = NULL;
    VARIANT    varChild;

    // validate out parameter
    if ( !pvarState )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
     
    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;


    pParent = GetParentAnchor();
    
    //if parent is an anchor, get its values as well.
    if ( pParent )
    {
        V_I4(&varChild)=CHILDID_SELF; 
        V_VT(&varChild)=VT_I4;
        hr = THR( pParent->get_accState( varChild, pvarState ) );
        if ( hr )
            goto Cleanup;
    }
    
    if ( !_pElement->IsVisible(FALSE) )
        V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;
    
    if ( !(DYNCAST( CImgElement, _pElement))->GetAAcomplete() )
        V_I4( pvarState ) |= STATE_SYSTEM_UNAVAILABLE;

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccDefaultAction
//  
//  DESCRIPTION:
//  Returns the default action. If the parent is anchor, returns "jump"
//  otherwise, not implemented.
//
//  PARAMETERS:
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccImage::GetAccDefaultAction( BSTR* pbstrDefaultAction)
{
    HRESULT    hr = S_OK;
    CAccBase * pParent = NULL;

    if ( !pbstrDefaultAction )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pParent = GetParentAnchor();
    
    //if there is an ancestor anchor, then the default action is its default action
    // TODO - resourceString
    if ( pParent )
    {
        *pbstrDefaultAction = SysAllocString( _T("Jump") );

        if (!*pbstrDefaultAction )
            hr = E_OUTOFMEMORY;
    }
    else
        hr = E_NOTIMPL;
   
Cleanup:
   RRETURN( hr );
}

//----------------------------------------------------------------------------
//  accDoDefaultAction
//  
//  DESCRIPTION:
//  If the parent is anchor then calls the parent, otherwise returns E_NOTIMPL
//
//  PARAMETERS:
//      varChild            :   VARIANT child information
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccImage::accDoDefaultAction(VARIANT varChild)
{
    HRESULT      hr;
    CAccBase * pParent = NULL;

    hr = THR( ValidateChildID( &varChild ) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) != CHILDID_SELF )
        goto Cleanup;

    pParent = GetParentAnchor();

    //if ancestor anchor, then the default action is its default action
    hr = (pParent) ? THR( pParent->accDoDefaultAction( varChild ) ) : 
                     E_NOTIMPL;
   
Cleanup:
   RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\accinimg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccInImg.Cxx
//
//  Contents:   Accessible INPUT TYPE=IMAGE object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCINIMG_HXX_
#define X_ACCINIMG_HXX_
#include "accinimg.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_ELABEL_HXX
#define X_ELABEL_HXX
#include "elabel.hxx"
#endif


//----------------------------------------------------------------------------
//  CAccInputImg
//  
//  DESCRIPTION:    
//      The input image accessible object constructor
//
//  PARAMETERS:
//      Pointer to the input image element 
//----------------------------------------------------------------------------
CAccInputImg::CAccInputImg( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );
    
    //initialize the instance variables
    SetRole( ROLE_SYSTEM_PUSHBUTTON );
}


//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      If the title is not empty, returns the title
//      else, returns alt text if exists, otherwise
//      returns E_NOTIMPL
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccInputImg::GetAccName( BSTR* pbstrName )
{
    HRESULT hr = S_OK;
    TCHAR * pchString = NULL;

    // validate out parameter
    if ( !pbstrName )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrName = NULL;

    //get the title for the input image 
    pchString = (LPTSTR) _pElement->GetAAtitle();        
    if ( !pchString )
    {
        //get the alt
        pchString = (LPTSTR) (DYNCAST( CInput, _pElement))->GetAAalt();
    }
    
    if ( pchString )
    { 
        *pbstrName = SysAllocString( pchString );
        if ( !(*pbstrName) )
            hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = THR(GetLabelText(pbstrName));
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccValue
//  
//  DESCRIPTION:
//      if there is dynsrc return that, if not,
//      then return src
//  
//  PARAMETERS:
//      pbstrValue   :   BSTR pointer to receive the value
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccInputImg::GetAccValue( BSTR* pbstrValue)
{
    HRESULT     hr = S_OK;
    TCHAR *     pchString = NULL;
    TCHAR       cBuf[pdlUrlLen];
    TCHAR *     pchNewUrl = cBuf;
    CDoc *      pDoc = _pElement->Doc();

    // validate out parameter
    if ( !pbstrValue )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrValue = NULL;

    pchString = (LPTSTR) (DYNCAST(CInput, _pElement))->GetAAdynsrc();
    if ( !pchString )
    {
        pchString = (LPTSTR) (DYNCAST(CInput, _pElement))->GetAAsrc();
    }

    //did we get something in the pchString?
    if ( !pchString )
    {
        hr = E_NOTIMPL;
        goto Cleanup;
    }

    // Return fully expanded URL
    if ( pDoc )
        hr = THR(CMarkup::ExpandUrl(NULL, pchString, ARRAY_SIZE(cBuf), pchNewUrl, _pElement));

    if (hr || (pchNewUrl == NULL))
        goto Cleanup;

    *pbstrValue = SysAllocString( pchNewUrl );
    if ( !(*pbstrValue) )
        hr = E_OUTOFMEMORY;

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      If the title is not empty, returns the title
//      else, returns alt text if exists, otherwise
//      returns E_NOTIMPL
//  
//  PARAMETERS:
//      pbstrDescription   :   BSTR pointer to receive the Description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccInputImg::GetAccDescription( BSTR* pbstrDescription)
{
    HRESULT hr = S_OK;
    TCHAR * pchString = NULL;

    // validate out parameter
    if ( !pbstrDescription )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDescription = NULL;

    // if there is a title then the alt goes into descption,
    // otherwise the desc is ""
    if (_pElement->GetAAtitle())
    {
        //get the alt. text
        pchString = (LPTSTR) (DYNCAST( CInput, _pElement))->GetAAalt();

        if ( pchString )
        {   
            *pbstrDescription = SysAllocString( pchString );
            if ( !(*pbstrDescription) )
                hr = E_OUTOFMEMORY;
        }
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      if not complete, then STATE_SYSTEM_UNAVAILABLE
//      if not visible, then STATE_SYSTEM_INVISIBLE
//      if document has the focus, then STATE_SYSTEM_FOCUSABLE
//      if this is the active element. then STATE_SYSTEM_FOCUSED
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccInputImg::GetAccState( VARIANT *pvarState )
{
    HRESULT hr =S_OK;
    CDoc *  pDoc = _pElement->Doc();

    // validate out parameter
     if ( !pvarState )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;
    
    if ( IsFocusable(_pElement) )
        V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;
    
    if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus()) 
        V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;
    
    if ( !_pElement->IsVisible(FALSE) )
        V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;
    
    if ( ! (DYNCAST(CInput, _pElement))->GetAAcomplete() )
        V_I4( pvarState ) |= STATE_SYSTEM_UNAVAILABLE;


Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccDefaultAction
//  
//  DESCRIPTION:
//  Returns the default action, which is "Press"
//
//  PARAMETERS:
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccInputImg::GetAccDefaultAction( BSTR* pbstrDefaultAction)
{
    HRESULT hr = S_OK;

    if ( !pbstrDefaultAction )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrDefaultAction = SysAllocString( _T("Press") );

    if (!(*pbstrDefaultAction) )
        hr = E_OUTOFMEMORY;
   
Cleanup:
   RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\accframe.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccFrame.Cxx
//
//  Contents:   Accessible Frame object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCFRAME_HXX_
#define X_ACCFRAME_HXX_
#include "accframe.hxx"
#endif

#ifndef X_ACCELEM_HXX_
#define X_ACCELEM_HXX_
#include "accelem.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

ExternTag(tagAcc);

extern HRESULT EnsureAccWindow( CWindow * pWindow );
MtDefine(CAccFrameaccLocation_aryRects_pv, Locals, "CAccFrame::accLocation aryRects::_pv")


//+---------------------------------------------------------------------------
//
//  CAccFrame Constructor
//
//----------------------------------------------------------------------------
CAccFrame::CAccFrame( CWindow * pWndInner, CElement * pFrameElement)
: CAccWindow( pWndInner )
{
    _pFrameElement = pFrameElement;

    SetRole( ROLE_SYSTEM_CLIENT );
}

//----------------------------------------------------------------------------
//  accLocation
//
//  DESCRIPTION: Returns the coordinates of the frame relative to the 
//              root document coordinates
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccFrame::accLocation(   long* pxLeft, long* pyTop, 
                           long* pcxWidth, long* pcyHeight, 
                           VARIANT varChild)
{
    HRESULT hr;
    RECT    rectPos = {0};
    RECT    rectRoot = {0};
    CStackDataAry <RECT, 4> aryRects( Mt(CAccFrameaccLocation_aryRects_pv) );
    CLayout *       pLayout;
    CDoc    *       pDoc;

    Assert( pxLeft && pyTop && pcxWidth && pcyHeight );
    TraceTag((tagAcc, "CAccFrame::accLocation, childid=%d", V_I4(&varChild)));  

    if ( !pxLeft || !pyTop || !pcxWidth || !pcyHeight )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pxLeft = *pyTop = *pcxWidth = *pcyHeight = 0;

    // unpack varChild
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4( &varChild ) != CHILDID_SELF )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // get the root document coordinates
    pLayout = _pFrameElement->GetUpdatedNearestLayout();
    if ( !pLayout )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // get the region 
    pLayout->RegionFromElement( _pFrameElement, &aryRects, &rectPos, RFE_SCREENCOORD);

    pDoc = _pWindow->Doc();

    // get the containing Win32 window's coordinates.
    if (!pDoc ||
        !pDoc->GetHWND( ) || 
        !::GetWindowRect( pDoc->GetHWND( ), &rectRoot ) )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    *pxLeft = rectPos.left + rectRoot.left;
    *pyTop =  rectPos.top + rectRoot.top;
    *pcxWidth = rectPos.right - rectPos.left;
    *pcyHeight = rectPos.bottom - rectPos.top;
    
Cleanup:    
    TraceTag((tagAcc, "CAccFrame::accLocation, Location reported as left=%d top=%d width=%d height=%d, hr=%d", 
                rectPos.left - rectRoot.left,
                rectPos.top - rectRoot.top,
                rectPos.right - rectPos.left - rectRoot.left,
                rectPos.bottom - rectPos.top - rectRoot.top,
                hr));
    RRETURN( hr );
}

STDMETHODIMP 
CAccFrame::get_accParent(IDispatch ** ppdispParent)
{
    HRESULT         hr;
    CAccElement *   pAccParent;


    TraceTag((tagAcc, "CAccFrame::get_accParent"));  

    if (!ppdispParent)
        RRETURN(E_POINTER);

    hr = THR(GetParentOfFrame(&pAccParent));
    if (hr)
        goto Cleanup;

    // Reference count and cast at the same time.
    hr  = THR( pAccParent->QueryInterface( IID_IDispatch, (void **)ppdispParent ) );

Cleanup:
    RRETURN( hr );
}

STDMETHODIMP 
CAccFrame::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    HRESULT         hr;

    TraceTag((tagAcc, "CAccFrame::accNavigate navdir=%d varStart=%d",
                navDir,
                V_I4(&varStart)));  

    if ( !pvarEndUpAt )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    V_VT( pvarEndUpAt ) = VT_EMPTY;

    switch ( navDir )
    {
        case NAVDIR_FIRSTCHILD:
        case NAVDIR_LASTCHILD:
            // delegate to the super, since this is standard window operation
            RRETURN( super::accNavigate(navDir, varStart, pvarEndUpAt) );
            break;

        case NAVDIR_PREVIOUS:
        case NAVDIR_NEXT:
            // if we are a frame/iframe document, then we should try to get to other 
            // elements that are possibly next to us. 

            if (CHILDID_SELF == V_I4(&varStart) && 
                (!_pWindow->_pMarkup->IsPrimaryMarkup()))
            {
                CAccElement *   pAccParent; // we know that we are a frame. the parent
                                            //  MUST be an element.
                CAccBase *      pAccChild = NULL;
                long            lIndex = 0;
                long            lChildIdx = 0;

                // get the parent document's body element accessible object.
                // We know that the parent is an element, since we are a frame.
                // Casting is OK.
                hr = THR(GetParentOfFrame(&pAccParent));
                if (hr)
                    goto Cleanup;

                hr = THR( pAccParent->GetNavChildId( navDir, _pFrameElement, &lIndex));
                if (hr) 
                    goto Cleanup;

                // now, ask the parent to return the child with that index, and return
                // that child as the sibling.
                hr = THR( pAccParent->GetChildFromID( lIndex, &pAccChild, NULL, &lChildIdx) );
                if ( hr )
                {
                    // NEXT and PREVIOUS can return E_INVALIDARG, which indicates that the
                    // index we passed to the function was out of limits. In that case, 
                    // spec asks us to return S_FALSE, and an empty variant.
                    if ( hr == E_INVALIDARG )
                        hr = S_FALSE;       
            
                    goto Cleanup;
                }

                // Prepare the return value according to the type of the data received
                // Either a child id or a pointer to the accessible child to be returned.
                if ( pAccChild )
                {
                    IDispatch * pDispChild;

                    //the child did have an accessible object

                    hr = pAccChild->QueryInterface( IID_IDispatch, (void **)&pDispChild);
                    if (hr) 
                        goto Cleanup;

                    V_VT( pvarEndUpAt ) = VT_DISPATCH;
                    V_DISPATCH( pvarEndUpAt ) = pDispChild;
                }
                else
                {
                    Assert((lIndex == -1) | (lIndex == lChildIdx));

                    //return the child id
                    V_VT( pvarEndUpAt ) = VT_I4;
                    V_I4( pvarEndUpAt ) = lChildIdx;
                }
            }
            else
                hr = S_FALSE;   // There is only one child for a frame, which is its pane
            break;

        default:
            hr = E_INVALIDARG;
            break;
    }

Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
CAccFrame::GetParentOfFrame( CAccElement ** ppAccParent )
{
    HRESULT     hr = E_FAIL;

    Assert( ppAccParent );

    if (!_pFrameElement->HasMarkupPtr())
        goto Cleanup;

    // an IFRAME can have another element as its parent
    if ( _pFrameElement->Tag() == ETAG_IFRAME)
        hr = THR(GetAccParent(_pFrameElement, (CAccBase **)ppAccParent));
    else
    {
        Assert(_pFrameElement->Tag() == ETAG_FRAME);

        // for a FRAME tag, since there may be nested framesets and we don't want to expose them,
        // we should get the root document's primary element client and return the accessible 
        // object for that element.

        // get the parent doc.
        CWindow * pParentWindow;

        pParentWindow = _pFrameElement->GetMarkupPtr()->Window()->Window();

        Assert(pParentWindow);

        // if the parent window does not have an acc. obj, create one
        if (!pParentWindow->_pAccWindow)
        {
            // Since both hittesting and top-down traversal hits the top
            // level window object first, it is impossible to not have
            // a top level accessible object, unless this frame is moved
            // from one document to the other, and the new document was 
            // not hit by MSAA yet. Understand how we got here. (FerhanE)
            AssertSz( 0, "How did we get here ?");
            
            hr = EnsureAccWindow(pParentWindow);
            if (hr)
                goto Cleanup;
        }

        hr = THR(pParentWindow->_pAccWindow->GetClientAccObj( (CAccBase **)ppAccParent ));
    }

Cleanup: 
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\accradio.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccRadio.Cxx
//
//  Contents:   Accessible radio button object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCRADIO_HXX_
#define X_ACCRADIO_HXX_
#include "accradio.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif


//----------------------------------------------------------------------------
//  CAccRadio
//  
//  DESCRIPTION:    
//      The radio button accessible object constructor
//
//  PARAMETERS:
//      Pointer to the radio button element 
//----------------------------------------------------------------------------
CAccRadio::CAccRadio( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );
    
    //initialize the instance variables
    SetRole( ROLE_SYSTEM_RADIOBUTTON );
}


//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      Returns the label, if not the title.
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccRadio::GetAccName( BSTR* pbstrName )
{
    HRESULT hr;
 
    // validate out parameter
    if ( !pbstrName )
    {
        hr= E_POINTER;
        goto Cleanup;
    }

    *pbstrName = NULL;

    hr = THR( GetLabelorTitle( pbstrName ) );

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      Returns the label, if not, the title
//  
//  PARAMETERS:
//      pbstrDescription   :   BSTR pointer to receive the Description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccRadio::GetAccDescription( BSTR* pbstrDescription)
{
    HRESULT hr=S_OK;

    // validate out parameter
    if ( !pbstrDescription )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDescription = NULL;

    if (HasLabel())
        hr = THR( GetTitle( pbstrDescription ) );

Cleanup:
    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      if not visible, then STATE_SYSTEM_INVISIBLE
//      if document has the focus, then STATE_SYSTEM_FOCUSABLE
//      if this is the active element. then STATE_SYSTEM_FOCUSED
//      if it is not enabled then STATE_SYSTEM_UNAVAILABLE
//      if checked then STATE_SYSTEM_CHECKED
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccRadio::GetAccState( VARIANT *pvarState )
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bChecked = FALSE;
    CDoc *          pDoc = _pElement->Doc();

    // validate out parameter
    if ( !pvarState )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    
    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;
    
    if ( !_pElement->IsEnabled() )
        V_I4( pvarState ) |= STATE_SYSTEM_UNAVAILABLE;
    else
    {    
        if ( IsFocusable(_pElement) )
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;
    
        if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus()) 
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;
    
        if ( !_pElement->IsVisible(FALSE) )
            V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;
    
        hr = THR( (DYNCAST(CInput, _pElement))->GetChecked(&bChecked) ) ;
        if ( hr )
            goto Cleanup;
    
        if ( bChecked != VB_FALSE )
            V_I4( pvarState ) |= STATE_SYSTEM_CHECKED;
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetAccDefaultAction
//  
//  DESCRIPTION:
//      Returns the default action for a radio button, "select"
//
//  PARAMETERS:
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccRadio::GetAccDefaultAction( BSTR* pbstrDefaultAction)
{
    HRESULT hr = S_OK;

    if ( !pbstrDefaultAction )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDefaultAction = SysAllocString( _T("Check") );

    if (!(*pbstrDefaultAction) )
        hr = E_OUTOFMEMORY;
   
Cleanup:
   RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\accsel.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccSel.Cxx
//
//  Contents:   Accessible Select object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCSEL_HXX_
#define X_ACCSEL_HXX_
#include "accsel.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_ESELECT_HXX_
#define X_ESELECT_HXX_
#include "eselect.hxx"
#endif

extern DYNLIB g_dynlibOLEACC;

ExternTag(tagAcc);

//----------------------------------------------------------------------------
//  CAccSelect
//  
//  DESCRIPTION:    
//      The Select accessible object constructor
//
//  PARAMETERS:
//      Pointer to the select element 
//----------------------------------------------------------------------------
CAccSelect::CAccSelect( CElement* pElementParent )
:CAccObject(pElementParent)
{
    Assert( pElementParent );

    //Only lists can have more than one selection, and only lists can have a size
    //larger than one.
    if ( ( (DYNCAST(CSelectElement, pElementParent))->GetAAmultiple() == -1 ) ||
         ( (DYNCAST(CSelectElement, pElementParent))->GetAAsize() > 1 ))
    {
        SetRole( ROLE_SYSTEM_LIST );
    }
    else
    {
        SetRole( ROLE_SYSTEM_COMBOBOX );
    }
}

CAccSelect::~CAccSelect( )
{
    //if we used the select object's IAccessible interface,
    //release it.
    if ( _pAccObject )
        _pAccObject->Release();
}

//-----------------------------------------------------------------------
//  get_accChild()
//
//  DESCRIPTION:
//      If this is a listbox, we work around the OLEACC bug using a hack. Otherwise
//      we delegate to the object with the IAccessible implementation.
//
//  PARAMETERS:
//      varChild    :   Child information
//      ppdispChild :   Address of the variable to receive the child 
//
//  RETURNS:
//
//      E_INVALIDARG | S_OK | S_FALSE
//
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccSelect::get_accChild( VARIANT varChild, IDispatch ** ppdispChild )
{
    HRESULT hr;

    // validate out parameter
    if ( !ppdispChild )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppdispChild = NULL;        //reset the return value.

    if ((ROLE_SYSTEM_LIST == GetRole()) && 
        (V_I4(&varChild) > 0))
    {
        V_VT(&varChild) = VT_I4;
        V_I4(&varChild) = -1 * V_I4(&varChild);
    }
        
    if ( EnsureAccObject())
    {
        hr = THR( _pAccObject->get_accChild( varChild, ppdispChild) );
    }
    else 
        hr = S_FALSE;
    
Cleanup:
    TraceTag((tagAcc, "CAccSelect::get_accChild, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

    RRETURN1( hr, S_FALSE );    //S_FALSE is valid when there is no children
}

//----------------------------------------------------------------------------
//  get_accDescription
//  
//  DESCRIPTION:
//      Returns the string "Select Element"
//  
//  PARAMETERS:
//      pbstrDescription   :   BSTR pointer to receive the description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccSelect::get_accDescription(VARIANT varChild, BSTR* pbstrDescription )
{
    HRESULT hr = S_OK;

    if ( !pbstrDescription )
        return E_POINTER;

    *pbstrDescription = NULL;

    if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->get_accDescription( varChild, pbstrDescription) );
    }
    else
    {
        //[FerhanE] The proxy returns "Uninitialized Select Element"
        //          I am not sure why, ask... ! ! !
        *pbstrDescription = SysAllocString( _T("Select Element") );
        
        if ( !(*pbstrDescription) )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    TraceTag((tagAcc, "CAccSelect::get_accDescription, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//  get_accState
//  
//  DESCRIPTION:
//      if not visible, then STATE_SYSTEM_INVISIBLE
//      if document has the focus, then STATE_SYSTEM_FOCUSABLE
//      if this is the active element. then STATE_SYSTEM_FOCUSED
//      if it is not enabled then STATE_SYSTEM_UNAVAILABLE
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccSelect::get_accState(VARIANT varChild, VARIANT *pvarState )
{
    HRESULT hr;

    // validate out parameter
     if ( !pvarState )
        RRETURN (E_POINTER);
 
    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;
    
    if ((V_VT(&varChild) == VT_I4) && 
        (V_I4(&varChild) == CHILDID_SELF))
    {
        hr = CAccElement::get_accState(varChild, pvarState);
    }
    else
    {
        if ( EnsureAccObject())
        {
            hr = THR( _pAccObject->get_accState( varChild, pvarState) );
        }
        else 
        {
            hr = S_FALSE;
        }
    }


    TraceTag((tagAcc, "CAccSelect::get_accState, childid=%d state=0x%x", 
                V_I4(&varChild), V_I4( pvarState )));  

    RRETURN1(hr, S_FALSE);
}


//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
BOOL
CAccSelect::EnsureAccObject( )
{
    HWND    hwndCombo = NULL;
    long    lObjId;

    if ( _pAccObject )
        return TRUE;

    //does it have a window of its own?
    hwndCombo = (DYNCAST( CSelectElement, _pElement))->GetHwnd();
    
    // if the select does not have a window of its own, there is no point trying 
    // to get an accessible object from it, since it is not UI activated yet.
    if ( !hwndCombo )
        return FALSE;

    // there is a window for this object, get the
    // IAccessible from the window

    if ( GetRole() == ROLE_SYSTEM_LIST )
    {
        lObjId = OBJID_WINDOW;
    }
    else
    {
        lObjId = OBJID_CLIENT;
    }

    //this call may return S_FALSE
    if (S_OK != (THR( CreateStdAccObj( hwndCombo, 
                                       lObjId, 
                                       (void **)&_pAccObject ) )))
       return FALSE;

    // Without this line, we used to crash, TEST ! ! !
    _pAccObject->AddRef();

    return TRUE;
}

//+---------------------------------------------------------------------------
//  CreateStdAccObj
//  
//  DESCRIPTION:
//      Wrapper function for the OLEACC API CreateStdAccessibleObject
//
//----------------------------------------------------------------------------
HRESULT
CAccSelect::CreateStdAccObj( HWND hWnd, long lObjId, void ** ppAccObj )
{
    HRESULT hr;
    
    static DYNPROC s_dynprocCreateStdAccObj =
            { NULL, &g_dynlibOLEACC, "CreateStdAccessibleObject" };

    // Load up the CreateStdAccessibleObject pointer.
    hr = THR(LoadProcedure(&s_dynprocCreateStdAccObj));
    if (hr)
        goto Cleanup;

    hr = THR ((*(LRESULT (APIENTRY *)(HWND, DWORD, REFIID, void**))
                s_dynprocCreateStdAccObj.pfn)( hWnd, lObjId, 
                                               IID_IAccessible, ppAccObj) );
                                               
    // if the window is not UI active, the return value is E_FAIL.
    // if we still have a pointer, then we can return S_OK
    if ( (hr == E_FAIL) && (*ppAccObj) )
        hr = S_OK;

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
CAccSelect::GetAccState(VARIANT* pvarState )
{
    CDoc * pDoc = _pElement->Doc();

    // validate out parameter
     if ( !pvarState )
        return ( E_POINTER );
 
    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;
    
    if ( !_pElement->IsEnabled() )
        V_I4( pvarState ) |= STATE_SYSTEM_UNAVAILABLE;
    
    if ( IsFocusable(_pElement) )
        V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;
    
    if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus() )
        V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;
    
    if ( !_pElement->IsVisible(FALSE) )
        V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;

    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\acctab.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccTab.Cxx
//
//  Contents:   Accessible object for a (generic) element that has a tabstop, but
//              would otherwise be unsupported 
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCTAB_HXX_
#define X_ACCTAB_HXX_
#include "acctab.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif


//-----------------------------------------------------------------------
//  CAccTabStopped::CAccTabStopped()
//
//  DESCRIPTION:
//      Contructor. 
//
//  PARAMETERS:
//      pElementParent  :   Address of the CElement that hosts this 
//                          object.
//----------------------------------------------------------------------
CAccTabStopped::CAccTabStopped( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );

    //initialize the instance variables, since this is sort of 
    // a generic element, we would like to set a role that aprximates
    // the role that this element is playing on the page. Note that 
    // none of the tags listed below are specified in the supported
    // element list.
    switch (pElementParent->Tag())
    {
    case ETAG_LI:
    case ETAG_OL:
    case ETAG_UL:
    case ETAG_DD:
    case ETAG_DL:
    case ETAG_DT:
        SetRole( ROLE_SYSTEM_LISTITEM );
        break;

    case ETAG_HR:
        SetRole( ROLE_SYSTEM_SEPARATOR );
        break;

    case ETAG_DIV:
    case ETAG_SPAN:
        SetRole( ROLE_SYSTEM_GROUPING );
        break;

    default:
        SetRole( ROLE_SYSTEM_TEXT );
        break;
    }
}

CAccLabel::CAccLabel( CElement* pElementParent )
:CAccTabStopped(pElementParent)
{
    SetRole( ROLE_SYSTEM_STATICTEXT );
}

//----------------------------------------------------------------------------
//  helper : GetAccName
//  
//  DESCRIPTION:
//      If the title is not empty return it. Otherwise return the innerText value 
//  
//----------------------------------------------------------------------------
STDMETHODIMP
CAccTabStopped::GetAccName( BSTR* pbstrName)
{
    HRESULT hr = S_OK;

    // validate out parameter
    if ( !pbstrName )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrName = NULL;

    hr = GetTitleorLabel(pbstrName);
    if (hr || !*pbstrName)
    {
        hr = THR( _pElement->get_innerText( pbstrName ) );
    }
    

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  helper : GetAccDescription
//  
//  DESCRIPTION:
//      If the title is not empty return the innerText, else return nothing 
//  
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccTabStopped::GetAccDescription( BSTR* pbstrDescription)
{
    HRESULT hr = S_OK;
    BOOL    fNeedText;

    // validate out parameter
    if ( !pbstrDescription )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDescription = NULL;

    // check for the title attribute, then toss the string
    hr = GetTitle( pbstrDescription );
    fNeedText = (hr == S_OK && *pbstrDescription);

    SysFreeString(*pbstrDescription);
    *pbstrDescription = NULL;
    hr = S_OK;

    // if we had a title, return the innerText, else nothing
    if (fNeedText)
    {
        hr = THR( _pElement->get_innerText( pbstrDescription ) );
    }


Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  member : GetAccState
//  
//  DESCRIPTION:
//      always STATE_SYSTEM_Focusable 
//      if not visible, then STATE_SYSTEM_INVISIBLE
//      if this is the active element. then STATE_SYSTEM_FOCUSED
//  
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccTabStopped::GetAccState(VARIANT *pvarState)
{
    HRESULT hr = S_OK;
    CAccBase * pParentA =NULL;
    CDoc *  pDoc = _pElement->Doc();

    // validate out parameter
     if ( !pvarState )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

     // first, if we have an anchor parent set our state to its state
    pParentA = GetParentAnchor();

    //if we have  an anchor, assume its state
    if (pParentA)
    {
        hr = THR( DYNCAST(CAccElement, pParentA)->GetAccState( pvarState ) );
    }
    else 
    {
        V_VT( pvarState ) = VT_I4;
        V_I4( pvarState ) = 0;        
    
        if ( !_pElement->IsEnabled() )
            V_I4( pvarState ) |= STATE_SYSTEM_UNAVAILABLE;
        else
        {
            if ( IsFocusable(_pElement) )
                V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;
    
            if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus()) 
                V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;

            if (!_pElement->IsVisible(FALSE))
                V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;
        }
    }

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  helper : GetAccValue
//  
//  DESCRIPTION:
//      If the parent is an anchor, delegate to the anchor. If not, Nothing.
//  
//----------------------------------------------------------------------------
STDMETHODIMP
CAccTabStopped::GetAccValue( BSTR* pbstrValue)
{
    HRESULT     hr = S_OK;
    CAccBase *  pParentA = NULL;

    // validate out parameter
    if ( !pbstrValue )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrValue = NULL;

    //get the parent and see if it is an anchor.
    pParentA = GetParentAnchor();

    //if parent is an anchor, delegate the call. otherwise return S_OK and
    // a NULL string
    if (pParentA )
    {
        hr = THR( DYNCAST(CAccElement, pParentA)->GetAccValue( pbstrValue ));
    }

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  member : get_accKeyboardShortCut
//  
//  DESCRIPTION :   
//          Returns the keyboard shortcut if there is one.
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccTabStopped::get_accKeyboardShortcut(VARIANT varChild, BSTR* pbstrKeyboardShortcut)
{
    HRESULT         hr;
    CAccBase *      pAccChild = NULL;
    CStr            accessString;
    CStr            sString;    

    // validate out parameter
     if ( !pbstrKeyboardShortcut )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrKeyboardShortcut = NULL;
    
    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        // get the actual key combination value
        hr = THR (accessString.Set( _pElement->GetAAaccessKey() ) );
        if ( hr )
            goto Cleanup;

        // if there is an access key string
        if ( accessString.Length() > 0 )
        {
            // we want all keyboard shortcut values to contain 'Alt+' 
            hr = THR( sString.Set( _T("Alt+") ) );
            if ( hr )
                goto Cleanup;
            
            hr = THR( sString.Append( accessString ) );
            if ( hr )
                goto Cleanup;
                
            hr = THR( sString.AllocBSTR( pbstrKeyboardShortcut ) );
        }                
    }
    else
    {
        //
        // get the child CElement/CMarkupPointer. If the child id 
        // is invalid, the GetChildFromID will return with an err.
        //
        hr = THR( GetChildFromID( V_I4(&varChild), &pAccChild, NULL) );
        if ( hr ) 
            goto Cleanup;

        if ( !pAccChild )
        {
            //no keyboard shortcuts for plain text, unless a parent is an anchor
            CAccBase * pParentA = GetParentAnchor();
            CVariant   varChildSelf;

            V_VT(&varChildSelf) = VT_I4;
            V_I4(&varChildSelf) = CHILDID_SELF;

            //delegate this call 
            hr = (!pParentA) ? S_OK :
                THR( pParentA->get_accKeyboardShortcut(varChildSelf, pbstrKeyboardShortcut) );
        }
        else 
        {
            // call child's implementation of this method. 
            V_I4( &varChild ) = CHILDID_SELF;
            hr = THR( pAccChild->get_accKeyboardShortcut(varChild, pbstrKeyboardShortcut) );
        }
    }

Cleanup:
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\accmarq.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccMarq.Cxx
//
//  Contents:   Accessible Marquee object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCMARQ_HXX_
#define X_ACCMARQ_HXX_
#include "accmarq.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif


//----------------------------------------------------------------------------
//  CAccMarquee
//  
//  DESCRIPTION:    
//      The marquee accessible object constructor
//
//  PARAMETERS:
//      Pointer to the marquee element 
//----------------------------------------------------------------------------
CAccMarquee::CAccMarquee( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );
    
    //initialize the instance variables
    SetRole( ROLE_SYSTEM_ANIMATION );
}


//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      If the title is not empty, returns the title,
//      otherwise returns the innertext
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccMarquee::GetAccName( BSTR* pbstrName )
{
    HRESULT hr;

    // validate out parameter
    if ( !pbstrName )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrName = NULL;

    hr = THR( GetTitleorLabel( pbstrName ) );
    if ( FAILED(hr) )
        goto Cleanup;
    
    if ( !(*pbstrName))
        hr = THR( _pElement->get_innerText( pbstrName ) );

Cleanup:
    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      If the title is not empty, returns the title,
//      otherwise returns the innertext
//  
//  PARAMETERS:
//      pbstrDescription   :   BSTR pointer to receive the Description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccMarquee::GetAccDescription( BSTR* pbstrDescription)
{
    HRESULT hr;

    // validate out parameter
    if ( !pbstrDescription )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pbstrDescription = NULL;

    
    // if there is a title, then then inner text is reported
    // as the description.  If there isn't a title, then the 
    // description is blank.
    hr = GetTitle( pbstrDescription );
    if (hr)
        goto Cleanup;  // includeing S_FALSE

    if ( *pbstrDescription)
    {
        SysFreeString(*pbstrDescription);
        *pbstrDescription = NULL;
        hr = THR( _pElement->get_innerText( pbstrDescription ) );
    }

    
Cleanup:
    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      always STATE_SYSTEM_MARQUEED
//      if not visible, then STATE_SYSTEM_INVISIBLE
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccMarquee::GetAccState( VARIANT *pvarState )
{
    HRESULT         hr = S_OK;

    // validate out parameter
     if ( !pvarState )
     {
         hr = E_POINTER;
         goto Cleanup;
     }
        
    V_VT( pvarState ) = VT_I4;    
    V_I4( pvarState ) = STATE_SYSTEM_MARQUEED;
    
    if ( !_pElement->IsVisible(FALSE) )
        V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;

Cleanup:
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\accobj.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccAnch.Cxx
//
//  Contents:   Accessible Anchor object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCOBJ_HXX_
#define X_ACCOBJ_HXX_
#include "accobj.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_PLUGINST_HXX_
#define X_PLUGINST_HXX_
#include "pluginst.hxx"
#endif

#ifndef WIN16
extern DYNLIB g_dynlibOLEACC;
#endif // !WIN16


ExternTag(tagAcc);

CAccObject::CAccObject( CElement* pElementParent )
:CAccElement( pElementParent )
{
    //reset the _pAccObject pointer.
    _pAccObject = NULL;

    //initialize the instance variables
    SetRole( ROLE_SYSTEM_CLIENT );
}

CAccObject::~CAccObject()
{
    if ( _pAccObject )
        _pAccObject->Release();
}

//-----------------------------------------------------------------------
//  CAccObject::PrivateQueryInterface()
//
//  DESCRIPTION:
//
//      Standard QI implementation : the CAccBase object implements
//      IDispatch and IAccessible. CAccObject only delegates the IEnumVariant
//      request to the object that it represents.
//
//  PARAMETERS:
//
//      riid        REFIID of requested interface.
//      ppv         pointer to interface in.
//
//  RETURNS:
//
//      E_NOINTERFACE | NOERROR.
//
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccObject::PrivateQueryInterface(REFIID riid, void ** ppv)
{
    HRESULT hr = S_OK;
    
    if ( !ppv )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
  
    if (riid == IID_IEnumVARIANT)
    {
//NOTE: (ferhane)
//          If the object does not support IEnumVariant, then we should
//          return E_NOINTERFACE, since our enumerator can not really know
//          what the object's implementation would be like.

        // if there is an object that is represented, then delegate
        if ( EnsureAccObject()) 
        {
            hr = THR( _pAccObject->QueryInterface( riid, ppv ) );
        }
        else
            hr = E_NOINTERFACE;
    }
    else if (riid == IID_IOleWindow)
    {
        *ppv = (IOleWindow *)this;
        ((LPUNKNOWN) *ppv)->AddRef();
    }
    else
    {
        //Delegate the call to the super;
        hr = THR( super::PrivateQueryInterface( riid, ppv));
        goto Cleanup;
    }

Cleanup:
    RRETURN1( hr, E_NOINTERFACE);
}


//----------------------------------------------------------------------------
//  get_accChildCount
//
//  DESCRIPTION:
//      if the object that is being represented here supports IAccessible,
//      we delegate the call to that object. Otherwise we return 0.
//
//  PARAMETERS:
//      pChildCount :   address of the parameter to receive the child count
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccObject::get_accChildCount(long* pChildCount)
{
    HRESULT hr = S_OK;
    
    if ( !pChildCount )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pChildCount = 0;   //there are no children

    // if the objec that is being represented here supports IAccessible,
    // we delegate the call to that object. Otherwise we return 0.
    if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->get_accChildCount( pChildCount ) );
    }

    TraceTag((tagAcc, "CAccObject::get_accChildCount, childcnt=%d hr=%d", 
                *pChildCount, hr));

Cleanup:
    RRETURN( hr );
}

//-----------------------------------------------------------------------
//  get_accChild()
//
//  DESCRIPTION:
//      if the object that is being represented here supports IAccessible,
//      we delegate the call to that object. Otherwise we return an error, since
//      this tag type can not have any children.
//
//  PARAMETERS:
//      varChild    :   Child information
//      ppdispChild :   Address of the variable to receive the child 
//
//  RETURNS:
//
//      E_INVALIDARG | S_OK | S_FALSE
//
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccObject::get_accChild( VARIANT varChild, IDispatch ** ppdispChild )
{
    HRESULT      hr = S_FALSE;

    // validate out parameter
    if ( !ppdispChild )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppdispChild = NULL;        //reset the return value.

    if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->get_accChild( varChild, ppdispChild) );
    }


Cleanup:
    TraceTag((tagAcc, "CAccObject::get_accChild, childid=%d requested, hr=0x%x", 
                        V_I4(&varChild),
                        hr));  

    RRETURN1( hr, S_FALSE );    //S_FALSE is valid when there is no children
}

//----------------------------------------------------------------------------
//  accLocation()
//  
//  DESCRIPTION:
//      Returns the coordinates of the element relative to the top left corner 
//      of the client window.
//      To do that, we are getting the CLayout pointer from the element
//      and calling the GetRect() method on that class, using the global coordinate
//      system. This returns the coordinates relative to the top left corner of
//      the screen. 
//      We then convert these screen coordinates to client window coordinates.
//      
//      If the childid is not CHILDID_SELF, then tries to delegate the call to the 
//      object itself, and returns E_NOINTERFACE if the object does not support 
//      IAccessible
//  
//  PARAMETERS:
//        pxLeft    :   Pointers to long integers to receive coordinates of
//        pyTop     :   the rectangle.
//        pcxWidth  :
//        pcyHeight :
//        varChild  :   VARIANT containing child information. 
//
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccObject::accLocation(  long* pxLeft, long* pyTop, 
                          long* pcxWidth, long* pcyHeight, 
                          VARIANT varChild)
{
    HRESULT     hr;
    CRect       rectElement;
   
    // validate out parameter
    if ( !pxLeft || !pyTop || !pcxWidth || !pcyHeight )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    //reset out parameters
    *pxLeft = *pyTop =  *pcxWidth = *pcyHeight = 0;
    
    // unpack varChild, and validate the child id against child array limits.
    hr = THR(ValidateChildID(&varChild));
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        // call super's implementation here..... 
        hr = CAccElement::accLocation( pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
    }
    else 
    {
        if ( EnsureAccObject()) 
        {
            hr = THR( _pAccObject->accLocation( pxLeft, pyTop, pcxWidth, 
                                                pcyHeight, varChild) );
        }
        else
            hr = E_NOTIMPL;
    }

Cleanup:

    TraceTag((tagAcc, "CAccObject::accLocation, childid=%d hr=0x%x", 
                V_I4(&varChild),
                hr));  

    RRETURN1( hr, S_FALSE ); 
}


//----------------------------------------------------------------------------
//  accNavigate
//  
//  DESCRIPTION:
//      Delegate to the object if it implements the IAccessible. Otherwise
//      not implemented.
//      
//----------------------------------------------------------------------------
STDMETHODIMP
CAccObject::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    HRESULT hr = E_NOTIMPL;

    if ( !pvarEndUpAt )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    V_VT( pvarEndUpAt ) = VT_EMPTY;
    
    if ( EnsureAccObject()) 
        hr = THR( _pAccObject->accNavigate(navDir, varStart, pvarEndUpAt) );

Cleanup:
    TraceTag((tagAcc, "CAccObject::accNavigate, start=%d, direction=%d", 
                V_I4(&varStart),
                navDir));  
    RRETURN( hr );
}


//-----------------------------------------------------------------------
//  accHitTest()
//  
//  DESCRIPTION :   Since the window already have checked the coordinates
//                  and decided that the document contains the point, this
//                  function does not do any point checking. 
//                  If the object implements IAccessible, then the call is 
//                  delegated to the object. Otherwise CHILDID_SELF is 
//                  returned.
//                  
//  PARAMETERS  :
//      xLeft, yTop         :   (x,y) coordinates 
//      pvarChildAtPoint    :   VARIANT pointer to receive the acc. obj.
//
//  RETURNS:    
//      S_OK | E_INVALIDARG | 
//-----------------------------------------------------------------------
STDMETHODIMP 
CAccObject::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{
    HRESULT     hr;

    if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->accHitTest( xLeft, yTop, pvarChildAtPoint));
    }
    else
    {
        if ( !pvarChildAtPoint )
        {
            hr = E_POINTER;
            goto Cleanup;
        }
        
        V_VT( pvarChildAtPoint ) = VT_I4;
        V_I4( pvarChildAtPoint ) = CHILDID_SELF;
        
        hr = S_OK;
    }

Cleanup:
    TraceTag((tagAcc, "CAccObject::accHitTest, point(%d,%d), hr=0x%x", 
                xLeft, yTop, hr));  

    RRETURN1( hr, S_FALSE );
}    

//----------------------------------------------------------------------------
//  accDoDefaultAction
//  
//  DESCRIPTION:
//
//  PARAMETERS:
//      varChild            :   VARIANT child information
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccObject::accDoDefaultAction(VARIANT varChild)
{   
    HRESULT     hr;

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( EnsureAccObject()) 
    {
        hr = THR(_pAccObject->accDoDefaultAction(varChild));
    }
    else
    {
        if ( V_I4(&varChild) == CHILDID_SELF )
        {
            hr = THR( ScrollIn_Focus( _pElement ) );                
        }
        else
            hr = E_NOTIMPL;
    }

Cleanup:
    TraceTag((tagAcc, "CAccObject::accDoDefaultAction, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  get_accName
//  
//  DESCRIPTION:
//      If the object implements IAccessible, then calls that implementation
//      otherwise returns the title
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccObject::get_accName(VARIANT varChild,  BSTR* pbstrName )
{
    HRESULT hr = S_OK;

    // validate out parameter
    if ( !pbstrName )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrName = NULL;

    if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->get_accName( varChild, pbstrName) ); 
    }

    //
    // The delegation could not answer the query try to find substitution.
    //
    if (hr || !*pbstrName)
    {
        //
        // Try to get the label or the title for this element.
        //
        hr = THR( GetLabelorTitle(pbstrName) );        
    }

Cleanup:
    TraceTag((tagAcc, "CAccObject::get_accName, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//  get_accValue
//  
//  DESCRIPTION:
//      Returns the src if the element is an EMBED. Otherwise delegates to the
//      object. If there is no implementation on the object then E_NOINTERFACE
//  
//  PARAMETERS:
//      pbstrValue   :   BSTR pointer to receive the value
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccObject::get_accValue(VARIANT varChild,  BSTR* pbstrValue )
{
    HRESULT hr = E_NOTIMPL;
    TCHAR * pchString = NULL;

    // validate out parameter
    if ( !pbstrValue )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrValue = NULL;

    if ( _pElement->Tag() == ETAG_EMBED )
    {
        pchString = (TCHAR *)(DYNCAST( CPluginSite, _pElement ))->GetAAsrc();

        if ( pchString )
        {
            *pbstrValue = SysAllocString( pchString );
            
            if ( !(*pbstrValue) )
                hr = E_OUTOFMEMORY;

            hr = S_OK;
        }
    }
    else 
    {
        if ( EnsureAccObject()) 
            hr = THR( _pAccObject->get_accValue( varChild, pbstrValue) );            
    }

Cleanup:
    TraceTag((tagAcc, "CAccObject::get_accValue, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

    RRETURN1( hr, S_FALSE );
}


//----------------------------------------------------------------------------
//  get_accDefaultAction
//  
//  DESCRIPTION:
//  If the object supports the IAccessible, the object is called. Otherwise, 
//  teturns the default action for  an object, which is 
//
//  PARAMETERS:
//      pbstrDefaultAction  :   BSTR pointer to receive the default action str.
//  
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccObject::get_accDefaultAction(VARIANT varChild,  BSTR* pbstrDefaultAction )
{
    HRESULT hr = S_OK;

    if ( !pbstrDefaultAction )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDefaultAction = NULL;

    if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->get_accDefaultAction( varChild, pbstrDefaultAction) );
    }
    else
    {
        // Todo: resource string
        *pbstrDefaultAction = SysAllocString( _T("Select") );

        if ( !(*pbstrDefaultAction) )
            hr = E_OUTOFMEMORY;
    }
   
Cleanup:
    TraceTag((tagAcc, "CAccObject::get_accDefaultAction, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  

   RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//  get_accState
//  
//  DESCRIPTION:
//      
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccObject::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = _pElement->Doc();

    // validate out parameter
    if ( !pvarState )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;

    if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->get_accState(varChild, pvarState));
    }
    else
    {
       
        V_I4( pvarState ) = 0;

        if ( _pElement->GetReadyState() != READYSTATE_COMPLETE )
            V_I4( pvarState ) |= STATE_SYSTEM_UNAVAILABLE;
        
        if ( IsFocusable(_pElement) )
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSABLE;
        
        if ( pDoc && (pDoc->_pElemCurrent == _pElement) && pDoc->HasFocus() )
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED;
        
        if ( !_pElement->IsVisible(FALSE) )
            V_I4( pvarState ) |= STATE_SYSTEM_INVISIBLE;
    }
    
Cleanup:
    TraceTag((tagAcc, "CAccObject::get_accState, childid=%d, state=0x%x, hr=0x%x", 
                V_I4(&varChild), V_I4( pvarState ), hr));  
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP
CAccObject::get_accDescription(VARIANT varChild, BSTR * pbstrDescription )
{
    HRESULT hr;

    if ( !pbstrDescription )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrDescription = NULL;

    if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->get_accDescription( varChild, pbstrDescription));
    }
    else
    {
        hr = S_OK;
        
        if ( _pElement->Tag() == ETAG_OBJECT )
        {
            *pbstrDescription = SysAllocString( _T("PLUGIN: type=Object") );
        }
        else
        {
            *pbstrDescription = SysAllocString( _T("PLUGIN: type=Embed") );
            
            if ( !(*pbstrDescription) )
                hr = E_OUTOFMEMORY;
        }
    }

Cleanup:
    TraceTag((tagAcc, "CAccObject::get_accDescription, childid=%d, hr=0x%x", 
                V_I4(&varChild), hr));  
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP
CAccObject::get_accKeyboardShortcut( VARIANT varChild, BSTR* pbstrKeyboardShortcut)
{
    HRESULT hr  = E_NOTIMPL;

    // If the call is for the tag itself, we handle it. If the call is 
    // for a child, then the control handles it.
    if ((V_VT(&varChild) == VT_I4) && 
        (V_I4(&varChild) == CHILDID_SELF))
    {
        hr = THR(CAccElement::get_accKeyboardShortcut( varChild, pbstrKeyboardShortcut));
    }
    else if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->get_accKeyboardShortcut(varChild, pbstrKeyboardShortcut) );
    }

    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccObject::get_accFocus(VARIANT * pvarFocusChild)
{
    HRESULT hr  = E_NOTIMPL;

    if ( EnsureAccObject()) 
        hr = THR( _pAccObject->get_accFocus(pvarFocusChild) );

    RRETURN( hr );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP
CAccObject::get_accSelection(VARIANT * pvarSelectedChildren)
{
    HRESULT hr  = E_NOTIMPL;

    if ( EnsureAccObject()) 
        hr = THR( _pAccObject->get_accSelection(pvarSelectedChildren) );

    RRETURN1( hr, S_FALSE );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccObject::accSelect( long flagsSel, VARIANT varChild)
{
    HRESULT hr  = E_NOTIMPL;

    // If the call is for the tag itself, we handle it. If the call is 
    // for a child, then the control handles it.
    if ((V_VT(&varChild) == VT_I4) && 
        (V_I4(&varChild) == CHILDID_SELF))
    {
        hr = THR(CAccElement::accSelect(flagsSel, varChild));
    }
    else if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->accSelect( flagsSel, varChild) );
    }

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccObject::put_accName( VARIANT varChild, BSTR bstrName )
{
    HRESULT hr  = E_NOTIMPL;

    if ( EnsureAccObject()) 
        hr = THR( _pAccObject->put_accName(varChild, bstrName));

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccObject::put_accValue( VARIANT varChild, BSTR bstrValue )
{
    HRESULT hr  = E_NOTIMPL;

    if ( EnsureAccObject()) 
        hr = THR( _pAccObject->put_accValue(varChild, bstrValue));

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
BOOL  
CAccObject::EnsureAccObject( )
{
    HWND        hwndControl = NULL;
    HRESULT     hr;
    
    if (_pAccObject)
        return TRUE;
        
    // If the tag was an embed tag, there is no way that it
    // can support IAccessible


    // RJG -- I believe this is not True

    if ( _pElement->Tag() != ETAG_EMBED )
    {
        IDispatch * pDisp = NULL;

        //HACKHACK: FerhanE: It is common for sites to contain APPLET tags that don't have 
        //                   a codebase at all. When we try to talk to these controls, the
        //                   trust dialogs are shown and this bothers the screen readers.
        //                   We check for an applet tag having a codebase attribute and if
        //                   it does not have one, we don't try to delegate to the control
        //                   or to the OLEACC at all. IEBug:36140
        //
        if ((_pElement->Tag() == ETAG_APPLET) && 
            !(DYNCAST( CObjectElement, _pElement))->GetAAcodeBase() && 
            !(DYNCAST( CObjectElement, _pElement))->GetAAcode())
        {
            return FALSE;
        }

        // get the IDispatch pointer to the COM object that is
        // inside the OBJECT/PLUGIN tag
        (DYNCAST( CObjectElement, _pElement))->get_object( &pDisp );

        if (pDisp)
        {
            hr = THR_NOTRACE(pDisp->QueryInterface( IID_IAccessible, (void **)&_pAccObject));

            // WebView control in the active desktop returns a value in the _pAccobject, although
            // it returns an error code.
            if (hr)
                _pAccObject = NULL;

            // Release the pDisp, so that we have a single reference on the
            // object if we have the _pAccObject. 
            // In case, we don't get a valid _pAccObject, this call serves
            // as a cleanup call...
            pDisp->Release();
        }
    }
    
    // if we don't have an IAccessible after checking with the component, 
    // try to delegate to the OLEACC for windowed controls. There is nothing we can do
    // for windowless controls.
    hwndControl = _pElement->GetHwnd();

    if (!_pAccObject && hwndControl && IsWindow(hwndControl))
    {
        static DYNPROC  s_dynprocAccessibleObjectFromWindow = { NULL, &g_dynlibOLEACC, "AccessibleObjectFromWindow"};

        // Load up the LresultFromObject pointer.
        hr = THR(LoadProcedure(&s_dynprocAccessibleObjectFromWindow));
        
        if (S_OK == hr)
        {
            hr = THR((*(HRESULT (APIENTRY *)(HWND, DWORD, REFIID, void**))
                        s_dynprocAccessibleObjectFromWindow.pfn)(   hwndControl, 
                                                                    OBJID_WINDOW, 
                                                                    IID_IAccessible,
                                                                    (void **)&_pAccObject));
            if (S_OK != hr)
            {
                _pAccObject = NULL;  // double check for the correct return value.
            }
        }
    }
       
    return !!_pAccObject;
}

//----------------------------------------------------------------------------
//
//  IOleWindow implementation
//
//----------------------------------------------------------------------------
STDMETHODIMP    
CAccObject::GetWindow( HWND* phwnd )
{
    HRESULT hr = S_OK;
    
    if ( !phwnd )
    {
        hr = E_POINTER;
    }
    else
    {   
        // if there is a window handle for the control.
        *phwnd = _pElement->GetHwnd();

        // by design, for windowless objects.
        if (!(*phwnd))
            hr = E_FAIL;
    }

    RRETURN( hr );
}

STDMETHODIMP
CAccObject::ContextSensitiveHelp( BOOL fEnterMode )
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//  get_accRole
//  
//  DESCRIPTION:
//      If the object implements IAccessible, then calls that implementation
//      otherwise returns ROLE_SYSTEM_CLIENT
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccObject::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    HRESULT hr = S_OK;

    // validate out parameter
    if ( !pvarRole )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    V_VT( pvarRole ) = VT_EMPTY;

    if ( EnsureAccObject()) 
    {
        hr = THR( _pAccObject->get_accRole( varChild, pvarRole) ); 
    }
    else
    {
        // return the role information we have for the element, since
        // this code is only hit when a select does not have a current selection
        V_VT(pvarRole) = VT_I4;
        V_I4(pvarRole) = GetRole();
    }
    
Cleanup:
    TraceTag((tagAcc, "CAccSelect::get_accRole, childid=%d role=%d, hr=0x%x", 
                V_I4(&varChild), V_I4( pvarRole ),  hr));  
    
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\accwind.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccWind.Cxx
//
//  Contents:   Accessible Window object implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCWIND_HXX_
#define X_ACCWIND_HXX_
#include "accwind.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif


extern DYNLIB g_dynlibOLEACC;

MtDefine(CAccWindowGetEnumerator_aryVariants_pv, Locals, "CAccWindow::GetEnumerator aryVariants::_pv")

//-----------------------------------------------------------------------
//  CAccWindow::CAccWindow()
//
//  DESCRIPTION:
//      Contructor. 
//
//  PARAMETERS:
//      pDocParent  :   The CAccWindow contains a pointer to the document 
//                      that it is related to. This parameter contains the
//                      address of the CDoc class.
// ----------------------------------------------------------------------
CAccWindow::CAccWindow( CWindow * pWndInner )
:_elemBegin(pWndInner->Doc()), _elemEnd(pWndInner->Doc())
{
    Assert( pWndInner );

    _pWindow = pWndInner;

    SetRole( ROLE_SYSTEM_CLIENT );
}

//----------------------------------------------------------------------------
//  CAccWindow::~CAccWindow()
//  
//  DESCRIPTION:
//      Destructor
//----------------------------------------------------------------------------
CAccWindow::~CAccWindow()
{
    Assert(_pWindow);
  
    //reset the window object so it can answer later requests 
    //for acc. objects. This is important if the client releases the
    //accwindow without unloading the document, and later asks for another
    //acc object on the window. Since the CWindow has no notion of 
    //reference counting the acc. object, the object has to do that

    _pWindow->_pAccWindow = NULL;  
    _pWindow = NULL;
}


//+---------------------------------------------------------------------------
//  PrivateAddRef
//  
//  DESCRIPTION
//      We overwrite the CBase implementation to be able to delegate the call 
//      to the document that we are connected to.
//----------------------------------------------------------------------------
ULONG
CAccWindow::PrivateAddRef()
{
    Assert( _pWindow );
    return _pWindow->PrivateAddRef();
}

//+---------------------------------------------------------------------------
//  PrivateRelease

//  DESCRIPTION
//      We overwrite the CBase implementation to be able to delegate the call 
//      to the document that we are connected to.
//----------------------------------------------------------------------------
ULONG
CAccWindow::PrivateRelease()
{
    Assert( _pWindow );
    return _pWindow->PrivateRelease();
}


//----------------------------------------------------------------------------
//  get_accParent
//  
//  DESCRIPTION:
//      Returns a pointer to the parent accessible object
//      
//      If there is no parent, then set the out parameter to NULL and 
//      return S_FALSE
//      This implementation is only for the top level windows. The frame
//      windows overwrite this method and handle it themselves.
//
//  PARAMETERS:
//      ppdispParent    :   Address of the variable to receive the parent
//                          accessible object pointer.
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::get_accParent(IDispatch ** ppdispParent)
{
    HRESULT hr;
    HWND    hWndParent = NULL;

    // check and reset the out parameter
    if ( !ppdispParent )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppdispParent = NULL;

    // Is this the object that represents the root document?
    if (_pWindow->_pMarkup->IsPrimaryMarkup())
    {
        //get the window handle for this document's window.
        hWndParent = _pWindow->Doc()->GetHWND();

        if ( !hWndParent )
            goto Error;
        
        //get the parent window.
        hWndParent = GetParent( hWndParent );
        if ( !hWndParent )
            goto Error;

        //get the accessible object for the parent window.
        hr = AccObjFromWindow( hWndParent, (void **)ppdispParent );
    }
    else
        goto Error;
                                                    
Cleanup:
    RRETURN(hr );

Error:
    RRETURN( E_FAIL );
}

//----------------------------------------------------------------------------
//  get_accChildCount
//  
//  DESCRIPTION:
//      Get the child count for the accessible window object. This count is 
//      always one.
//      Returns E_FAIL if there is a problem getting to the child.
//      
//  PARAMETERS:
//      pChildCount :   Address of the long integer to receive the child count
//
//  RETURNS:
//      S_OK  | E_FAIL | E_POINTER
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::get_accChildCount(long* pChildCount)
{
    HRESULT     hr;
    CAccBase *  pAccChild = NULL;

    if ( !pChildCount )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // the following function will initialize the child's acc object,
    // in addition to making sure that we have the only child of the window
    hr = THR( GetClientAccObj( &pAccChild) );
    
    // if no error, there is always one child for a window, set and return
    *pChildCount = (hr) ? 0 : 1;

Cleanup:    
    RRETURN (hr );

}

//----------------------------------------------------------------------------
//  get_accChild
//  
//  DESCRIPTION:
//      Retrieves the one and only possible child for the acc. window object
//
//  PARAMETERS:
//      varChild    :   VARIANT that contains the child index information
//      ppdispChild :   pointer to the dispatch pointer to receive the child
//                      object interface pointer
//  RETURNS:
//      E_POINTER | S_OK | E_INVALIDARG | E_FAIL        
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::get_accChild(VARIANT varChild, IDispatch ** ppdispChild)
{
    HRESULT     hr;
    CAccBase *  pAccChild = NULL;
    
    // validate out parameter
    if ( !ppdispChild )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *ppdispChild = NULL;

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;    

    // get the only child's accessible object
    hr = THR( GetClientAccObj( &pAccChild) );
    if ( hr )
        goto Cleanup;

    Assert( pAccChild );

    //increment reference count before giving out.
    pAccChild->AddRef();

    // TODO: this should eventually be a  QI (tearoffs)
    *ppdispChild = (IDispatch *) pAccChild;
    
Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  DESCRIPTION:
//        
//      Returns the URL of the document for IE3 compatibility.
//
//
//  PARAMETERS:
//      pbstrName   :   address of the pointer to receive the URL BSTR
//
//  RETURNS:    
//      E_INVALIDARG | S_OK | 
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::get_accName( VARIANT varChild, BSTR* pbstrName)
{
    HRESULT     hr;
    CAccBase *  pAccChild = NULL;

    // validate out parameter
     if ( !pbstrName )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrName = NULL;

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        hr = THR(_pWindow->Document()->get_URL(pbstrName));
    }
    else if ( V_I4(&varChild) == 1 )
    {   
        // get the window's only child's acc. object
        hr = THR( GetClientAccObj( &pAccChild ) );
        if ( hr )   
            goto Cleanup;

        //set the parameters and delegate the call
        //to the child
        V_I4( &varChild ) = CHILDID_SELF;
        
        hr = THR( pAccChild->get_accName( varChild, pbstrName ) );
    }
    else
    {
        // the child id passed is invalid
        hr = E_INVALIDARG;
    }
    
Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  get_accValue
//  
//  DESCRIPTION:
//      NOT IMPLEMENTED BY THIS OBJECT
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::get_accValue(VARIANT varChild, BSTR* pbstrValue)
{
    return ( E_NOTIMPL );
}

//----------------------------------------------------------------------------
//  get_accDescription
//
//  DESCRIPTION :   
//      Returns the description text for the Window Acc. object. 
//
//  PARAMETERS:
//      pbstrDescription    :   pointer to the BSTR to receive data.
//
//  RETURNS:
//      S_OK | E_POINTER | E_OUTOFMEMORY | E_FAIL | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::get_accDescription( VARIANT varChild, BSTR* pbstrDescription)
{
    HRESULT     hr;
    CAccBase *  pAccChild = NULL;

    // validate out parameter
     if ( !pbstrDescription )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        // TODO : This is here for backward compatibility. We may want to change the
        // contents of this BSTR. Also add this to the resourcestrings.
        *pbstrDescription = SysAllocString( _T("MSAAHTML Registered Handler") );

        if ( !*pbstrDescription )
            hr = E_OUTOFMEMORY;

    }
    else if ( V_I4(&varChild) == 1 )
    {   
        // get the acc. window's one and only child
        hr = THR( GetClientAccObj( &pAccChild ) );
        if ( hr )   
            goto Cleanup;

        //set the parameters and delegate the call
        //to the child
        V_I4( &varChild ) = CHILDID_SELF;
        
        hr = THR( pAccChild->get_accDescription( varChild, pbstrDescription ) );
    }
    else
    {
        // the child id passed is invalid
        hr = E_INVALIDARG;
    }

Cleanup:
    RRETURN( hr );    
}

//-----------------------------------------------------------------------
//  get_accRole()
//
//  DESCRIPTION:
//          Returns the accessibility role of the object.
//
//  PARAMETERS:
//
//      varChild    :   Variant that contains the child information
//      pvarRole    :   Address of the variant to receive the role information
//
//  RETURNS:
//
//      E_INVALIDARG | S_OK
//
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    HRESULT         hr ;      
    long            lRetRole = 0;
    CAccBase *      pAccChild = NULL;

    // validate the out parameter
    if ( !pvarRole )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // clear the out parameter
    V_VT( pvarRole ) = VT_EMPTY;

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        lRetRole = GetRole();   //this acc. objects role
    }
    else if ( V_I4(&varChild) == 1 )
    {
        // get the only acc child possible and delegate
        hr = THR( GetClientAccObj( &pAccChild ) );
        if ( hr || pAccChild == NULL)   // Possible to leave the pointer NULL.
            goto Cleanup;

        //call child's implementation
        lRetRole = pAccChild->GetRole();
    }
       
    if ( hr == S_OK )
    {
        // pack role into out parameter
        V_VT( pvarRole ) = VT_I4;
        V_I4( pvarRole ) = lRetRole;
    }
    
Cleanup:
    RRETURN( hr );
}

// ----------------------------------------------------------------------
//  DESCRIPTION:
//          Returns the accessibility state of the object.
//
//  PARAMETERS:
//
//      pvarState:   Address of the variant to receive the state information
//
//  RETURNS:
//
//      E_INVALIDARG | S_OK | E_POINTER | E_FAIL
//
// ----------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::get_accState( VARIANT varChild, VARIANT *pvarState)
{
    HRESULT     hr;
    CAccBase *  pAccChild = NULL;

    // validate the out parameter
    if ( !pvarState )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //reset the out parameter.
    V_VT( pvarState ) = VT_EMPTY;

    // unpack varChild 
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    if ( V_I4(&varChild) == CHILDID_SELF )
    {
        V_VT( pvarState ) = VT_I4;

        //always focusable
        V_I4( pvarState ) = STATE_SYSTEM_FOCUSABLE;  

        //if the client site has the focus, 
        if (_pWindow->Doc()->GetFocus())
            V_I4( pvarState ) |= STATE_SYSTEM_FOCUSED; 
    }
    else if ( V_I4(&varChild) == 1 )
    {   
        // get the only acc child possible and delegate
        hr = THR( GetClientAccObj( &pAccChild ) );
        if ( hr )   
            goto Cleanup;

        //set the parameters and delegate the call
        //to the child
        V_I4( &varChild ) = CHILDID_SELF;
        
        hr = THR( pAccChild->get_accState( varChild, pvarState ) );
    }
    else
    {
        // the child id passed is invalid
        hr = E_INVALIDARG;
    }

Cleanup:
    RRETURN( hr );    
}

//----------------------------------------------------------------------------
//  get_accKeyboardShortcut
//
//  DESCRIPTION:
//      NOT IMPLEMENTED ON THIS OBJECT
//----------------------------------------------------------------------------
STDMETHODIMP
CAccWindow::get_accKeyboardShortcut(VARIANT varChild, BSTR* pbstrKeyboardShortcut)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//  get_accFocus
//
//  DESCRIPTION:
//      Returns the object that has the focus, inside the document that the 
//      window hosts.
//  
//  PARAMETERS:
//      pvarFocusChild  :   pointer to the VARIANT to receive the child that has
//                          the focus.
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::get_accFocus(VARIANT * pvarFocusChild)
{
    HRESULT     hr = S_OK;
    CElement *  pElemFocus = NULL;
    CAccBase *  pAccChild = NULL;
    
    if ( !pvarFocusChild )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    V_VT( pvarFocusChild ) = VT_EMPTY;

    pElemFocus = _pWindow->Doc()->_pElemCurrent;

    //if no element has the focus, then return S_OK,
    //and VT_EMPTY in the out parameter
    if ( !pElemFocus )
        goto Cleanup;

    //an element has the focus, we have to return its
    //accessible object.
    pAccChild = GetAccObjOfElement( pElemFocus );

    if ( !pAccChild )
    {   
        hr = E_FAIL;
        goto Cleanup;
    }

    V_VT( pvarFocusChild ) = VT_DISPATCH;
    V_DISPATCH( pvarFocusChild ) = pAccChild;

    //increment reference count before handing the pointer out.
    pAccChild->AddRef();
       
Cleanup:
    RRETURN( hr );
}


STDMETHODIMP 
CAccWindow::get_accSelection(VARIANT * pvarSelectedChildren)
{
    return E_NOTIMPL;
}

                                                    
//----------------------------------------------------------------------------
//  get_accDefaultAction
//
//  DESCRIPTION:
//      NOT IMPLEMENTED ON THIS OBJECT
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::get_accDefaultAction(VARIANT varChild, BSTR* pbstrDefaultAction)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//  accSelect
//  
//  DESCRIPTION: IAccessible::accSelect implementation for the accessible window
//                  object. Always sets the focus on the element client of the 
//                  CDoc.
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::accSelect( long flagsSel, VARIANT varChild)
{
    HRESULT     hr;
    CElement *  pClient = NULL;

    if ( flagsSel != SELFLAG_TAKEFOCUS )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // unpack varChild
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    // Window can only answer for itself and its element client.
    if ((V_I4( &varChild ) != CHILDID_SELF ) && 
        (V_I4( &varChild ) != 1) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    // always focus on the element client.
    pClient = CMarkup::GetElementClientHelper(_pWindow->_pMarkup);
    if ( !pClient )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( pClient->focus() );

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  accLocation
//  
//  DESCRIPTION :   
//      The window is the top level accessibility object and its location is 
//      relative to the top left corner of the screen. This method gets the
//      window that sites the document and gets its coordinates using a Win32
//      call. 
//  
//      The pane and the window objects return the same location.
//      
//  PARAMETERS:
//      pxLeft
//      pyTop       : (x,y) Coordinates of the left top window
//      pcxWidth    : Width of the window
//      pcxHeight   : Height of the window
//      varChild    : Child ID.
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::accLocation(   long* pxLeft, long* pyTop, 
                           long* pcxWidth, long* pcyHeight, 
                           VARIANT varChild)
{
    HRESULT hr;
    RECT    rectPos = { 0 };
    CDoc *  pDoc = _pWindow->Doc();

//      There is no indication that a client may want to
//      get partial location information and we should be flexible 
//      in respect to that. For simplicity and perf reasons, we are
//      assuming that all four parameters will be provided.
//      This may change, if we decide to be more flexible and let 
//      an arbitrary out parameter to be ignored.
//
    Assert( pxLeft && pyTop && pcxWidth && pcyHeight );

    if ( !pxLeft || !pyTop || !pcxWidth || !pcyHeight )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pxLeft = *pyTop = *pcxWidth = *pcyHeight = 0;

    // unpack varChild
    hr = THR( ValidateChildID(&varChild) );
    if ( hr )
        goto Cleanup;

    // Since the element client also calls this method, we can accept 
    // both CHILDID_SELF and 1 as valid child id values.
    if ((V_I4( &varChild ) != CHILDID_SELF ) && 
        (V_I4( &varChild ) != 1 ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // for the window, the location is relative to the screen's coordinates
    // the same location is used for the pane (body/frameset) that it contains too.
    // If the window is not inplave activated, ( frames ) then the _pDoc->GetHWND
    // will return NULL. 
    if (!pDoc || 
        !pDoc->GetHWND() || 
        !::GetWindowRect( pDoc->GetHWND( ), &rectPos ) )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
        
    *pxLeft = rectPos.left;
    *pyTop =  rectPos.top;
    *pcxWidth = rectPos.right - rectPos.left;
    *pcyHeight = rectPos.bottom - rectPos.top;
    
Cleanup:    
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  accNavigate
//  
//  DESCRIPTION:
//      Provides navigation for children. Since the window accessible object
//      can have only one child, NAVDIR_NEXT and NAVDIR_PREVIOUS are not valid.
//      The valid navigation directions are NAVDIR_FIRST and NAVDIR_LAST and
//      they both return the same accessible object, which is connected to the
//      element client of the document.
//
//  PARAMETERS:
//      navDir      :   Navigation direction information ( first, last, next, previous)
//      varStart    :   Starting child id.
//      pvarEndUpAt :   Destionation child ID
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    HRESULT         hr;
    CAccBase *      pAccChild = NULL;

    if ( !pvarEndUpAt )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    V_VT( pvarEndUpAt ) = VT_EMPTY;

    // unpack varChild, and validate the child id against child array limits.
    hr = THR(ValidateChildID(&varStart));
    if ( hr )
        goto Cleanup;    

    switch ( navDir )
    {
        case NAVDIR_FIRSTCHILD:
        case NAVDIR_LASTCHILD:
            // An acc object can only return its own first and last children.
            if ( V_I4(&varStart) != CHILDID_SELF )
            {
                hr = E_INVALIDARG;
                break;
            }
            
            //Retrieve the accessible child object
            hr = THR( GetClientAccObj( &pAccChild ) );
            if ( hr ) 
                break;

            Assert( pAccChild );

            //set the return parameter to our only child
            V_VT( pvarEndUpAt ) = VT_DISPATCH;
            V_DISPATCH( pvarEndUpAt ) = DYNCAST( IDispatch, pAccChild);

            //increment ref count.
            pAccChild->AddRef();
            break;

        case NAVDIR_PREVIOUS:
        case NAVDIR_NEXT:
            // We know that we are not a frame.
            // Since there is only one child and we can not go 
            // left or right from that child, it does not matter what
            // values we get. We will always return S_FALSE as the return
            // value, complying with the spec in this area.
            hr = S_FALSE;

            break;

        default:
            hr = E_INVALIDARG;
            break;
    }

Cleanup:
    RRETURN1( hr, S_FALSE );
}


//----------------------------------------------------------------------------
//
//  DESCRIPTION :   
//
//      Determine if the hit was in this object's client area.
//
//  PARAMETERS:
//      xLeft
//      yTop    :   (x,y) coordinates of the point relative to the top left
//                          of the screen.
//      pvarChildAtPoint:   pointer to VARIANT to receive the information about
//                          the child that contains the point. 
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{   
    HRESULT     hr = S_OK;
    RECT        rectPos = {0};
    CAccBase *  pAccChild = NULL;
    
    if (!pvarChildAtPoint)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // reset out parameter, this is also the proper return value if the hit
    // point was not inside this window
    V_VT(pvarChildAtPoint) = VT_EMPTY;
    
    //for the window, the location is relative to the screen's coordinates
    //the same location is used for the pane (body/frameset) that it contains too.
    //_pDoc->GetHWND() may return NULL, if the window is not inplace activated.

    // if this is the top level markup then get the window location 
    // otherwise, this is a frame and we should get the frame location.
    if ( _pWindow->_pMarkup->IsPrimaryMarkup() )
    {
        CDoc * pDoc = _pWindow->Doc();

        if ( !pDoc->GetHWND() || 
             !::GetWindowRect( pDoc->GetHWND(), &rectPos ) )
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        if (hr)
            goto Cleanup;
    }
    else
    {
        CVariant    varChild(VT_I4);
        long        lWidth;
        long        lHeight;

        // this is a frame, and we should get the frame location.
        hr = accLocation( &rectPos.left, &rectPos.top, &lWidth, &lHeight, varChild);
        if (hr)
            goto Cleanup;

        rectPos.right = rectPos.left + lWidth;
        rectPos.bottom = rectPos.top + lHeight;
    }
    
    //if (x, y) is inside us, 
    if ( ((rectPos.left < xLeft) && (rectPos.right > xLeft)) && 
         ((rectPos.top  < yTop) && (rectPos.bottom > yTop)) )
    {
        hr = THR( GetClientAccObj( &pAccChild ) );
        if ( hr )
            goto Cleanup;

        //set the out parameter and return
        V_VT( pvarChildAtPoint ) = VT_DISPATCH;
        V_DISPATCH( pvarChildAtPoint ) = pAccChild;

        pAccChild->AddRef();    //increment the reference count
    }

    //else, the out parameter contains VT_EMPTY and return code is S_OK
    
Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  accDoDefaultAction
//
//  DESCRIPTION:
//      NOT IMPLEMENTED ON THIS OBJECT
//----------------------------------------------------------------------------
STDMETHODIMP
CAccWindow::accDoDefaultAction( VARIANT varChild )
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//  GetClientAccObj
//
//  DESCRIPTION:
//      Gets the accessible object for the element client of the window.
//----------------------------------------------------------------------------
HRESULT 
CAccWindow::GetClientAccObj( CAccBase ** ppAccChild )
{
    HRESULT             hr = S_OK;
    ELEMENT_TAG         elemTag;
    CElement *          pClient = NULL;
    Assert( ppAccChild );

    // We used to think that windows only had one child, which was the client, which was either a body or a frame.
    // However, in a viewlinked webOC situation, the window is linked directly to the root of another markup.
    // That root has, as a child, the object that is the webOC. It also has an HTML tag that contains a BODY. 
    // We want to return the OBJECT instead of the BODY as the child of the root element so that we can get
    // information from the webOC.
    
    if (_pWindow->_punkViewLinkedWebOC)
    {
        CMarkupPointer  *   pelemBegin = &_elemBegin;
        CMarkupPointer  *   pelemEnd = &_elemEnd;
        MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;

#if DBG == 1
        CMarkup * pdbgMarkup = _pWindow->Markup();
        Assert(pdbgMarkup);
        CTreeNode * pdbgNode = pdbgMarkup->RootNode();
        Assert(pdbgNode);
        CElement * pdbgElement = pdbgNode->Element();
        Assert(pdbgElement);
#endif
        
        CTreeNode * pElemNode = _pWindow->Markup()->RootNode();

        hr = GetSubMarkupLimits(pElemNode->Element(), pelemBegin, pelemEnd);

        while( !pelemBegin->IsEqualTo(pelemEnd) && pElemNode->Element()->Tag() != ETAG_OBJECT)
        {
            hr = THR( pelemBegin->Right(TRUE, &context, &pElemNode, NULL, NULL, NULL) );
            if (hr)
                goto Cleanup;
        }
        
        // we shouldn't run off the end without hitting the object
        Assert(pElemNode->Element()->Tag() == ETAG_OBJECT);
        *ppAccChild = GetAccObjOfElement(pElemNode->Element());
    }
    else
    {
        pClient = CMarkup::GetElementClientHelper(_pWindow->_pMarkup);

        if ( !pClient )
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        // We must have either a frameset or a body tag.
        elemTag = pClient->Tag();

        if ((elemTag != ETAG_FRAMESET) && 
            (elemTag != ETAG_BODY) )
        {
            // something weird happened, and the client is 
            // neither a frameset nor a body
            Assert(0 && "strange tree: window with no body or frameset");
            hr = E_FAIL;
            goto Cleanup;
        }

        // Get the accessible object for the element.
        *ppAccChild = GetAccObjOfElement( pClient );
        if (*ppAccChild == NULL)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    // make sure that we have something going back.
    Assert( *ppAccChild );

Cleanup:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//  put_accValue
//  
//  DESCRIPTION :   
//          Sets the value property of the accessible object. This method is not
//          supported on accessible objects that are derived from the CAccWindow
//
//  PARAMETERS:
//      varChild     :   VARIANT containing the child ID
//      bstrValue    :   value bstr
//
//  RETURNS:
//      E_NOTIMPL
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::put_accValue(VARIANT varChild, BSTR bstrValue)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//  AccObjFromWinwow
//
//  DESCRIPTION:
//      Helper function that wraps the code that is needed to call the OLEACC
//      API AccessibleObjectFromWindow
//
//  PARAMETERS:
//      hWnd    :   Window handle to get the acc. object for.
//      ppAccObj:   Address of the pointer to receive the address of the acc.obj.
//----------------------------------------------------------------------------
HRESULT
CAccWindow::AccObjFromWindow( HWND hWnd, void ** ppAccObj )
{
    HRESULT hr;
    
    static DYNPROC s_dynprocAccObjFromWindow =
            { NULL, &g_dynlibOLEACC, "AccessibleObjectFromWindow" };

    // Load up the AccessibleObjectFromWindow pointer.
    hr = THR(LoadProcedure(&s_dynprocAccObjFromWindow));
    if (hr)
        goto Cleanup;

    hr = THR ((*(LRESULT (APIENTRY *)(HWND, DWORD, REFIID, void**))
                s_dynprocAccObjFromWindow.pfn)( hWnd, OBJID_CLIENT, 
                                                IID_IAccessible, ppAccObj) );
Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//  GetEnumerator
//
//  DESCRIPTION:    Fills the return parameter with the address of the 
//                  implementation for the IEnumVARIANT.
//                  Since the window object has only one child and that child
//                  is the element client of the document, the list contains
//                  only one item.
//                  The return value can not be E_NOINTERFACE, since the window
//                  always has a single child.
//  RETURNS:
//          S_OK | E_POINTER | E_OUTOFMEMORY
//----------------------------------------------------------------------------
HRESULT
CAccWindow::GetEnumerator( IEnumVARIANT** ppEnum)
{
    HRESULT                     hr;
    CDataAry <VARIANT> *        pary = NULL;
    CAccBase *                  pAccChild = NULL;
    VARIANT                     varTmp;
    IDispatch *                 pDispTmp;

    VariantInit( &varTmp );

    if ( !ppEnum )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEnum = NULL;

    pary = new(Mt(CAccWindowGetEnumerator_aryVariants_pv)) 
                    CDataAry<VARIANT>(Mt(CAccWindowGetEnumerator_aryVariants_pv));
    if ( !pary )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // This is the window, so it has ony one child.
    // Get the child, and append it to the child list.
    hr = THR( GetClientAccObj( &pAccChild ));
    if ( hr )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // increment the ref count and do the casting at the same time. 
    hr = THR( pAccChild->QueryInterface( IID_IDispatch, (void**)&pDispTmp));
    if ( hr )
        goto Cleanup;

    Assert( pDispTmp );    // we must have our value

    V_DISPATCH(&varTmp) = pDispTmp;
    V_VT( &varTmp ) = VT_DISPATCH;      // set the type.

    // append the variant to the list.
    hr = THR(pary->EnsureSize(1));
    if (hr)
        goto Cleanup;

    hr = THR( pary->AppendIndirect( &varTmp, NULL ) );
    if ( hr )
        goto Cleanup;

    hr = THR(pary->EnumVARIANT(VT_VARIANT, 
                                ppEnum, 
                                FALSE,  // don't copy the array being enumerated use the one we gave
                                TRUE)); // delete enumeration when no one is left to use .

Cleanup:
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  Function    :   PrivateQueryInterface
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::PrivateQueryInterface(REFIID riid, void ** ppv)
{
    if ( riid == IID_IOleWindow )
    {
        *ppv = (IOleWindow *)this;
        ((LPUNKNOWN) *ppv)->AddRef();
        return S_OK;
    }
    else
    {
        return super::PrivateQueryInterface(riid,ppv);
    }
}

//----------------------------------------------------------------------------
//      Function    :   EnsureAccWindow
//      
//      Description :   Helper function that ensures the window object passed in
//                      has an accessible window attached to it.
//      
//      Returns     :   S_OK if successfull, errorcode otherwise.
//----------------------------------------------------------------------------
HRESULT
EnsureAccWindow( CWindow * pWindow )
{
    HRESULT hr = S_OK;
    CMarkup * pMarkup;
    CAccBase * pAccObj = NULL;

    if (pWindow)
        pMarkup = pWindow->_pMarkup;
    else
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    if (!pMarkup)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // if we already have an accwindow don't do anything.
    if (pWindow->_pAccWindow)
        goto Cleanup;

    // If this window is the window for the primary markup, then the CAccWindow
    // will be attached to the primary window. Otherwise a CAccFrame will be 
    // created and attached to the element that is containing the  window on the parent document
    if (pMarkup->IsPrimaryMarkup())
    {
        pAccObj = new CAccWindow(pWindow);
    }
    else
    {
        CRootElement * pElemRoot = pMarkup->Root();
        CElement * pElemMaster;

        // get the element on the parent markup
        Assert(pElemRoot->HasMasterPtr());

        if (!((CElement *)pElemRoot)->HasMasterPtr())
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        pElemMaster = ((CElement *)pElemRoot)->GetMasterPtr();

        //If the pElemMaster->Tag() is not a frame tag, navigate
        //up searching for the Frame one.
        while ((pElemMaster->Tag() != ETAG_FRAME) && (pElemMaster->Tag() != ETAG_IFRAME))
        {            
            pMarkup = pElemMaster->GetWindowedMarkupContext();
            pElemRoot =  pMarkup->Root();
            
            if (!((CElement *)pElemRoot)->HasMasterPtr())
            {
                if (pMarkup->IsPrimaryMarkup())
                {
                    pAccObj = new CAccWindow(pWindow);
                    goto Setaccwindowpointer;
                }
                else
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }
            }
            
            pElemMaster = ((CElement *)pElemRoot)->GetMasterPtr();
            if (!pElemMaster)
            {
                hr = E_FAIL;
                goto Cleanup;
            }
        }

        // this may change with view link support
        Assert((pElemMaster->Tag() == ETAG_FRAME) ||
                (pElemMaster->Tag() == ETAG_IFRAME));

        pAccObj = GetAccObjOfElement(pElemMaster);
    }
    
Setaccwindowpointer:
    Assert(pAccObj);
    
    if (pAccObj)
        pWindow->_pAccWindow = (CAccWindow *)pAccObj;
    else
        hr = E_OUTOFMEMORY;

Cleanup:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//  Function    :   IServiceProvider::QueryService
//
//  Description :   Function that provides access to other objects that are 
//                  related to this accessible object, but do not have the
//                  same COM identity.
//
//                  Service requests that are supported are:
//                  IID_IHTMLWindow2
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CAccWindow::QueryService(  REFGUID guidService, REFIID riid, void ** ppvObject)
{
    HRESULT hr;

    if (!ppvObject)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (IsEqualGUID(guidService, IID_IHTMLWindow2))
    {
        hr = THR(_pWindow->QueryInterface(riid, ppvObject));
    }
    else
    {
        hr = E_NOINTERFACE;
    }

Cleanup:
    RRETURN1( hr, E_NOINTERFACE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\attr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       attr.cxx
//
//  Contents:   CAttrValue, CAttrArray
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

MtDefine(CAttrArray, Elements, "CAttrArray")
MtDefine(CAttrArray_pv, CAttrArray, "CAttrArray::_pv")
MtDefine(CAttrValue_pch, CAttrArray, "CAttrValue::_varValue::_pch")
MtDefine(CAttrValue_dbl, CAttrArray, "CAttrValue::_pdblVal")
MtDefine(CAttrValue_var, CAttrArray, "CAttrValue::_pvarVal")
MtDefine(CAttrArrayHeader, CAttrArray, "CAttrValue::_pAAHeader")

DeclareTag(tagPersistDefaultValues, "AttrArray", "Store default values in attr array")

//$WIN64: Win64 doesn't need to allocate for doubles since uVal is already 8 bytes wide

static const DWORD dwUnsetOther=0;
static const DWORD dwUnsetColor = VALUE_UNDEF;

#define DESTROY_DEFAULT 1

#if DESTROY_DEFAULT
static BOOL
IsDefaultValue ( const PROPERTYDESC *pPropertyDesc, VARIANT *pvt )
{
    DWORD dwValue;
    if ( V_VT(pvt)!=VT_I4)
    {
        return FALSE;
    }
    dwValue = (DWORD)pPropertyDesc->ulTagNotPresentDefault;
    return dwValue == (DWORD)V_I4(pvt) ? TRUE : FALSE;
}
#endif

//+------------------------------------------------------------------------
//
//  Member:     CAttrValue::Free
//
//  Synopsis:   Free's memory used by this AV
//
//-------------------------------------------------------------------------
void
CAttrValue::Free()
{
    switch (GetAVType())
    {
    case VT_LPWSTR:
        delete[] GetLPWSTR();
        break;

    case VT_BSTR:
        FormsFreeString(GetBSTR());
        break;

    case VT_ATTRARRAY:
        delete GetAA();
        break;

    case VT_R8:
        delete GetDoublePtr();
        break;

    case VT_UNKNOWN:
    case VT_DISPATCH:
        ReleaseInterface(GetpUnkVal());
        break;

    case VT_VARIANT:
        VariantClear(GetVariant());
        delete GetVariant();
        break;

    case VT_AAHEADER:
        delete GetAAHeader();
        break;
    }

    SetAVType(VT_EMPTY);
}

void CAttrValue::SetAAType(AATYPE aaType) 
{
    WORD extraBits = AA_Extra_Empty;

    if (aaType == AA_StyleAttribute)
    {
         extraBits |= AA_Extra_Style;
         aaType = AA_Attribute;
    }

    _wFlags._aaType = aaType;
    _wFlags._aaExtraBits = extraBits;
}


//+------------------------------------------------------------------------
//
//  Member:     CAttrValue::CompareWith
//
//  Synopsis:   Is this the attr value we want?
//
//				0 = exact match
//				1 = greater than
//			   -1 = less than
//
//-------------------------------------------------------------------------
int
CAttrValue::CompareWith ( DISPID dispID, AATYPE aaType )
{
    DISPID dispIdTmp = GetDISPID();

    if ( dispID < dispIdTmp )
        return -1;
    else if ( dispID > dispIdTmp )
        return 1;
    else
    {
        if ( aaType == AAType() )
            return 0;
        else if ( aaType < AAType() )
            return -1;
        else 
            return 1;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CAttrValue::Copy
//
//  Synopsis:   Make this AV the same as input AV
//
//-------------------------------------------------------------------------
HRESULT
CAttrValue::Copy(const CAttrValue *pAV)
{
    HRESULT hr = S_OK;
    VARIANT varNew;
    Assert(pAV);

    // Tidy up existing
    Free();

    _pPropertyDesc = pAV->_pPropertyDesc;
    _dispid = pAV->_dispid;
    _wFlags = pAV->_wFlags;

    // Copy in new
    pAV->GetAsVariantNC(&varNew);
    hr = THR(InitVariant(&varNew, TRUE));

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CAttrValue::CopyEmpty
//
//  Synopsis:   Copy everything about input AV except the value
//
//-------------------------------------------------------------------------
void
CAttrValue::CopyEmpty(const CAttrValue *pAV)
{
    Assert(pAV);

    // Tidy up existing
    Free();

    _pPropertyDesc = pAV->_pPropertyDesc;
    _dispid = pAV->_dispid;
    _wFlags = pAV->_wFlags;

    // Set as empty
    SetAVType(VT_EMPTY);
}

HRESULT
CAttrValue::InitVariant (const VARIANT *pvarNew, BOOL fIsCloning)
{
    LPTSTR lpNew;
    LPTSTR lpAlloc;
    BSTR bstrVal = NULL;
    HRESULT hr = S_OK;
    VARTYPE avType = V_VT(pvarNew);

    SetAVType(VT_EMPTY);
    switch (avType)
    {
    case VT_LPWSTR:
        {
            lpNew = (LPTSTR)(V_BYREF(pvarNew));
            if (lpNew)
            {
                lpAlloc = new(Mt(CAttrValue_pch)) TCHAR [ _tcslen ( lpNew ) + 1 ];
                if (!lpAlloc)
                    hr = E_OUTOFMEMORY;
                else
                {
                    SetLPWSTR(lpAlloc);
                    MemSetName((GetLPWSTR(), "CAttrValue string"));
                    _tcscpy (lpAlloc, lpNew);
                }
            }
            else
                SetLPWSTR(NULL);
        }
        break;

    case VT_ATTRARRAY:
        if (fIsCloning)
        {
            // Make a complete Copy
            CAttrArray *pCloneFromAttrArray = (CAttrArray *)V_BYREF(pvarNew);
            if (pCloneFromAttrArray)
            {
                CAttrArray *pNewAttrArray = NULL;
                hr = THR(pCloneFromAttrArray->Clone(&pNewAttrArray));
                if (!hr)
                    SetAA(pNewAttrArray);
            }
            else
                SetAA(NULL);
        }
        else
        {
            // Just initialising
            SetAA((CAttrArray *)V_BYREF(pvarNew));
        }
        break;

    case VT_UNKNOWN:
    case VT_DISPATCH:
        if (V_UNKNOWN(pvarNew))
            V_UNKNOWN(pvarNew)->AddRef();
        // fall through to VT_PTR

    case VT_INT_PTR:
    case VT_PTR:
        SetPointer(V_BYREF(pvarNew), avType);
        break;

    case VT_R4:
    case VT_I4:
        SetLong(V_I4(pvarNew), avType);
        break;

    case VT_INT:
        SetInt(V_INT(pvarNew), avType);
        break;

    case VT_I2:
    case VT_BOOL:
        SetShort(V_I2(pvarNew), avType);
        break;

    case VT_R8:
        hr = THR(SetDouble(V_R8(pvarNew)));
        break;

    case VT_BSTR:
        hr = THR(FormsAllocString(V_BSTR(pvarNew), &bstrVal));
        if (hr)
            goto Cleanup;

        SetBSTR(bstrVal);
        break;

    case VT_EMPTY:
    case VT_NULL:
        SetAVType(avType);
        break;

    default:
        hr = THR(SetVariant(pvarNew));
        break;
    }

Cleanup:
    RRETURN (hr);
}

HRESULT
CAttrValue::SetDouble (double dblVal)
{
    HRESULT hr = S_OK;
    VARTYPE avType = VT_EMPTY;

    uVal._pdblVal = new(Mt(CAttrValue_dbl)) double;
    if (!uVal._pdblVal)
        hr = E_OUTOFMEMORY;
    else
    {
        *(uVal._pdblVal) = dblVal;
        avType = VT_R8;
    }

    SetAVType(avType);
    return hr;
}

HRESULT
CAttrValue::SetVariant (const VARIANT *pvar)
{
    HRESULT hr = S_OK;
    VARTYPE avType = VT_EMPTY;

    uVal._pvarVal = new(Mt(CAttrValue_var)) VARIANT;
    if (!uVal._pvarVal)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    V_VT(uVal._pvarVal) = VT_EMPTY;
    hr = VariantCopy(uVal._pvarVal, (VARIANT *)pvar);
    if (hr)
        goto Cleanup;

    avType = VT_VARIANT;

Cleanup:
    if (hr && uVal._pvarVal)
        delete uVal._pvarVal;

    SetAVType(avType);
    return hr;
}

void
CAttrValue::GetAsVariantNC(VARIANT *pvar) const
{
  	VARTYPE avType = GetAVType();
    V_VT(pvar) = avType;
    switch(avType)
    {
    case VT_EMPTY:
    case VT_NULL:
        break;

    case VT_I2:
    case VT_BOOL:
        V_BOOL(pvar) = GetiVal();
        break;

    case VT_R4:
    case VT_I4:
        V_I4(pvar) = GetlVal();
        break;

    case VT_I8:
    case VT_R8:
        V_R8(pvar) = GetDouble();
        break;

    case VT_VARIANT:
        memcpy(pvar, GetVariant(), sizeof(VARIANT));
        break;

    default:
        V_BYREF(pvar) = GetPointerVal();
        break;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CAttrValue::GetIntoVariant
//
//  Synopsis:   Initialize the variant and copy the attribute value into it
//
//-------------------------------------------------------------------------
HRESULT
CAttrValue::GetIntoVariant (VARIANT *pvar) const
{
    HRESULT hr = S_OK;

  	V_VT(pvar) = VT_EMPTY;
    switch (GetAVType())
    {
    case VT_LPWSTR:
    case VT_BSTR:
        hr = THR(FormsAllocString(GetString(), &V_BSTR(pvar)));
        if (hr)
            goto Cleanup;

        V_VT(pvar) = VT_BSTR;
        break;

    case VT_UNKNOWN:
    case VT_DISPATCH:
        if (GetpUnkVal())
            GetpUnkVal()->AddRef();
        
        V_UNKNOWN(pvar) = GetpUnkVal();
      	V_VT(pvar) = GetAVType();
        break;

    case VT_VARIANT:
        pvar->vt = VT_EMPTY;
        hr = VariantCopy(pvar, GetVariant());
        break;

    default:
        GetAsVariantNC(pvar);
        break;
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CAttrValue::GetIntoString
//
//  Synopsis:   Massage the AttrValue into a string - if we need to alloc
//              a BSTR for this, so be it - the caller is responsible for
//              freeing it.
//
//-------------------------------------------------------------------------
HRESULT
CAttrValue::GetIntoString(BSTR *pbStr, LPCTSTR *ppStr) const
{
    HRESULT hr = S_OK;

    Assert(pbStr);

    *pbStr = NULL;

    switch (GetAVType())
    {
    case VT_LPWSTR:
        *ppStr = GetLPWSTR();
        break;

    case VT_BSTR:
        *ppStr = (LPTSTR)GetBSTR();
        break;

    default:
        {
            VARIANT varDest;
            VARIANT varSrc;
            varDest.vt = VT_EMPTY;
            GetAsVariantNC(&varSrc);
            hr = THR(VariantChangeTypeSpecial(&varDest, &varSrc, VT_BSTR));
            if (hr)
            {
                if (hr == DISP_E_TYPEMISMATCH)
                    hr = S_FALSE;
                goto Cleanup;
            }
            *ppStr = (LPTSTR)V_BSTR(&varDest);
            *pbStr = V_BSTR(&varDest);
        }
        break;
    }
Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Method: GetIntoDispatchableVariant
//
//  Synopsis: Stores the AttrValue into a representation suitable
//      for setting the property in IDispatch.  Stores it into a variant
//      because sometimes an VT_LPWSTR is appropriate (ie, enum), somtimes
//      a BSTR is appropriate (UnitValue/Color) and sometimes it's just a 
//      plain old number
//
//      [Variant *]         pVar        -   Variant to store into
//      [PROPERTYDESC *]    pPropDesc   -   PropDesc for AttrValue
//
//+----------------------------------------------------------------------------
void
CAttrValue::GetIntoDispatchableVariant( VARIANT * pVar, const PROPERTYDESC * pPropDesc )
{
    Assert( pVar && pPropDesc );

    BOOL fHasValue = GetAVType() != VT_NULL && GetAVType() != VT_EMPTY;

    V_VT(pVar) = VT_NULL;

    if( fHasValue)
    {
        if (pPropDesc->pfnHandleProperty == PROPERTYDESC::HandleEnumProperty )
        {
            ENUMDESC * pEnumDesc = pPropDesc->GetEnumDescriptor();

            Assert( pEnumDesc );

            pVar->vt = VT_LPWSTR;
            pVar->byref = (void *)( const_cast<TCHAR *>( pEnumDesc->StringPtrFromEnum( GetLong() ) ) );
        }
        else if (pPropDesc->pfnHandleProperty == PROPERTYDESC::HandleUnitValueProperty)
        {
            TCHAR ach[30];
            CUnitValue uv( GetLong() );

            uv.FormatBuffer( ach, ARRAY_SIZE(ach), pPropDesc );

            if( SUCCEEDED( FormsAllocString( ach, &V_BSTR(pVar) ) ) )
                pVar->vt = VT_BSTR;
        }
        else if(pPropDesc->pfnHandleProperty == PROPERTYDESC::HandleColorProperty)
        {
            TCHAR ach[64];
            CColorValue cv(GetLong());

            cv.FormatBuffer(ach, ARRAY_SIZE(ach), pPropDesc);

            if(SUCCEEDED(FormsAllocString(ach, &V_BSTR(pVar))))
                pVar->vt = VT_BSTR;
        }
    }
    else
    {
        GetIntoVariant( pVar );
    }
}
    


//+------------------------------------------------------------------------
//
//  Member:     CAttrValue::Compare
//
//  Synopsis:   Compare 2 AttributeValues.  TRUE means they are the same
//              FALSE means they are different
//
//-------------------------------------------------------------------------
BOOL
CAttrValue::Compare(const CAttrValue *pAV) const
{
    Assert(pAV);

    if ( pAV -> GetDISPID() != GetDISPID() || pAV->AAType() != AAType() )
        return FALSE;

    switch ( GetAVType() )
    {
    case VT_DISPATCH:
    case VT_UNKNOWN:
        switch ( pAV->GetAVType() )
        {
            case VT_DISPATCH:
            case VT_UNKNOWN:
                {
                    LPUNKNOWN lpUnk1 = NULL;
                    LPUNKNOWN lpUnk2 = NULL;
                    HRESULT hr;
                    LPUNKNOWN lpUnk = (IUnknown *)pAV->GetpUnkVal();
                    hr  = lpUnk -> QueryInterface ( IID_IUnknown, (LPVOID *)&lpUnk1 );
                    if ( !hr )
                    {
                        lpUnk = (IUnknown *)GetpUnkVal();
                        hr  = lpUnk -> QueryInterface ( IID_IUnknown, (LPVOID *)&lpUnk2 );
                        if ( !hr )
                        {
                            if ( lpUnk1 == lpUnk2 )
                            {
                                ReleaseInterface ( lpUnk1 );
                                ReleaseInterface ( lpUnk2 );
                                return TRUE;
                            }
                        }
                    }
                    ReleaseInterface ( lpUnk1 );
                    ReleaseInterface ( lpUnk2 );
                }
                break;

            default:
                break;
        }
        break;

    case VT_BSTR:
        break;

    case VT_LPWSTR:
        switch ( pAV->GetAVType() )
        {
        case VT_LPWSTR:
            if ( GetLPWSTR() == NULL || pAV->GetLPWSTR() == NULL )
            {
                if ( GetLPWSTR() == NULL && pAV->GetLPWSTR() == NULL )
                {
                    return TRUE;
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                // N.B. Need to confirm case sensitivity here.
                return StrCmpC( GetLPWSTR(), pAV->GetLPWSTR() ) == 0 ? TRUE : FALSE;
            }
            break;

        default:
            break;
        }
        break;

    case VT_ATTRARRAY:
        return GetAA()->Compare ( pAV->GetAA(), NULL );

    default:
        switch ( pAV->GetAVType() )
        {
        case VT_LPWSTR:
        case VT_BSTR:
        case VT_DISPATCH:
        case VT_UNKNOWN:
            break;

        default:
            if ( pAV->GetAVType() != GetAVType() )
                return FALSE;
            switch ( pAV->GetAVType() )
            {
            case VT_I4:
                return pAV->GetLong() == GetLong();
            case VT_I2:
                return pAV->GetShort() == GetShort();
            case VT_R4:
                return pAV->GetFloat() == GetFloat();
            case VT_R8:
                return pAV->GetDouble() == GetDouble();
            case VT_PTR:
                return pAV->GetPointer() == GetPointer();
            default:
                break;
            }
            break;
        }
        break;
    }
    return FALSE;
}


//+------------------------------------------------------------------------
//
//  CAttrArray code follows:
//
//-------------------------------------------------------------------------

CAttrArray::CAttrArray() : CDataAry<CAttrValue>(Mt(CAttrArray_pv))
{
    _dwChecksum = 0;
}


//+------------------------------------------------------------------------
//
//  Member:     CAttrValue::Clone()
//
//  Synopsis:   Clone this CAttrArray
//
//-------------------------------------------------------------------------
HRESULT
CAttrArray::Clone(CAttrArray **ppAA) const
{
    HRESULT hr = S_OK;
    DISPID dispid;
    const PROPERTYDESC *pSrcDesc;
    BOOL fCopyNextInternal = FALSE;

    int z,nCount;
    CAttrValue *pAV, *pAV2;

    Assert(ppAA);

    *ppAA = new CAttrArray;
    if (!*ppAA)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    MemSetName((*ppAA, "cloned CAttrArray:%s", MemGetName((void *)this)));

    hr = THR( (*ppAA)->EnsureSize(Size()));
    if (hr)
        goto Cleanup;

    for (pAV2 = (CAttrValue*) *(*ppAA),
        pAV = (CAttrValue*) *(CAttrArray *)this,
        z=0, nCount = 0; z<Size(); ++z, ++pAV)
    {
        // Don't copy internals
        if ((pAV->AAType() != CAttrValue::AA_Internal) || fCopyNextInternal)
        {
            // don't copy uniqueID
            dispid = pAV->GetDISPID();
            if (DISPID_CElement_uniqueName == dispid)
                continue;

            pAV2->SetAVType(VT_EMPTY);
            hr = THR(pAV2->Copy(pAV));
            if (hr)
                goto Cleanup;
            ++pAV2; nCount++;

            // if onfoo event property the dispatch ptr to script code will be the next one in AA, copy it too
            pSrcDesc = pAV->GetPropDesc();
            fCopyNextInternal = pSrcDesc && (pSrcDesc->GetPPFlags() & PROPPARAM_SCRIPTLET);

            // Internals don't add to the checksum, so skip it if we are going to
            // copy the next internal.
            if (fCopyNextInternal)
            {
                if (    z + 1 < Size() 
                    &&  (pAV+1)->GetDISPID() == dispid 
                    &&  (pAV+1)->AAType() == CAttrValue::AA_Internal)
                   continue;
                else
                {
                   fCopyNextInternal = FALSE;
                }
            }
    
            (*ppAA)->_dwChecksum += ((DWORD)dispid)<<1;
        }

    }
    (*ppAA)->SetSize(nCount);

    pAV = (CAttrValue*) *(CAttrArray *)this;
    if (pAV && pAV->GetAVType() == CAttrValue::VT_AAHEADER)
    {
        CAttrArrayHeader *pSrcAAHeader = pAV->GetAAHeader();
        if (pSrcAAHeader != NULL)
        {
            InlineEvts *pEventsToHook = pAV->GetEventsToHook();
            pAV2 = (*ppAA)->EnsureHeader(TRUE);
            if (pAV2 != NULL && pEventsToHook != NULL)
            {
                InlineEvts *pEventsClone = new InlineEvts();
                if (! pEventsClone)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                *pEventsClone = *pEventsToHook;
                pAV2->SetEventsToHook(pEventsClone);
            }
        }
    }


Cleanup:
    if (hr)
    {
        delete *ppAA;
    }
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CAttrValue::Merge()
//
//  Synopsis:   Merge this AttrArray in to the target.
//
//  Arguments:  ppAATarget      The target attr array to merge into
//              pTarget
//              pAAUndo         AttrArray to save old values
//              pAASync         AttrArray to store forward diff
//              fFromUndo       if TRUE, merge *everything*
//              fCopyID         merge the name/id also
//
//-------------------------------------------------------------------------
HRESULT
CAttrArray::Merge( CAttrArray **ppAATarget, 
                   CBase *pTarget, 
                   CAttrArray *pAAUndo, 
                   CAttrArray *pAASync /* = NULL */, 
                   BOOL fFromUndo /* = FALSE */, 
                   BOOL fCopyID /* = FALSE */) const
{
    HRESULT hr = S_OK;
    int z, nSizeTarget = 0, nCompare;
    BOOL fFind, fAlloced = FALSE, fCopyNextInternal = FALSE;
    CAttrValue *pAVSource, *pAVTarget, *pAVTargetBase;
    AAINDEX aaIndex;
    const PROPERTYDESC *pTargetDesc;
    const PROPERTYDESC *pSrcDesc;
    const TCHAR *pchName = NULL;
    DISPID dispid;

    Assert(ppAATarget);

    if ( !(*ppAATarget) )
    {
        *ppAATarget = new CAttrArray;
        if (!*ppAATarget)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        fAlloced = TRUE;
    }

    nSizeTarget = (*ppAATarget)->Size();

    // Only look for existing attr values if there are any!
    fFind = nSizeTarget > 0;

    MemSetName((*ppAATarget, "merged CAttrArray:%s", MemGetName((void *)this)));

    hr = THR((*ppAATarget)->EnsureSize(Size()+nSizeTarget));
    if (hr)
        goto Cleanup;

    pAVTarget = pAVTargetBase = (CAttrValue*) *(*ppAATarget);

    for (pAVSource = (CAttrValue*) *(CAttrArray *)this,
         z=0 ; z<Size(); ++z, ++pAVSource)
    {
        dispid = pAVSource->GetDISPID();

        // don't copy id or name or uniqueID
        if (    !fFromUndo
            &&  (   !fCopyID 
                &&  (   (DISPID_CElement_id == dispid) 
                    ||  (STDPROPID_XOBJ_NAME == dispid)) 
                ||  (DISPID_CElement_uniqueName == dispid)))
            continue;

        // Don't copy internals, nested AAs, attached events or expressions
        if (    fFromUndo
            ||  (   pAVSource->AAType() != CAttrValue::AA_Internal
                &&  pAVSource->AAType() != CAttrValue::AA_AttrArray
                &&  pAVSource->AAType() != CAttrValue::AA_AttachEvent
                &&  pAVSource->AAType() != CAttrValue::AA_Expression ) )
        {
            Assert(fFromUndo ||
                   pAVSource->AAType() == CAttrValue::AA_Attribute ||
                   pAVSource->AAType() == CAttrValue::AA_Expando ||
                   pAVSource->IsStyleAttribute() || 
                   pAVSource->AAType() == CAttrValue::AA_UnknownAttr ||
                   pAVSource->AAType() == CAttrValue::AA_DOMAttribute);

NEXT:
            // if at end of target AA, nothing left to compare, use common code path for nComape == -1
            fFind = fFind && ((pAVTarget - pAVTargetBase) < nSizeTarget);
            // if non-empty target, does src prop exist in target AA?
            nCompare = (fFind) ? pAVTarget->CompareWith(dispid, pAVSource->AAType()) : -1;
            switch (nCompare)  // yes
            {
            case  0: // yes, found one
            case -1: // no, src < target, or at end of target, time to insert appropriately into target
                    
                    pSrcDesc = pAVSource->GetPropDesc();

                    // if src and target elem are of same type OR src prop exists in target AA,
                    // just copy the new value, else ...
                    if (pTarget && nCompare && !fFromUndo)
                    {
                        // ... if not in common attribute range or not an expando\unknown, skip
                        if ((pAVSource->AAType() != CAttrValue::AA_Expando) &&
                            (pAVSource->AAType() != CAttrValue::AA_UnknownAttr) && 
                            (dispid >= 0))
                            break;

                        // ... does src prop have a propdesc ?
                        if (pSrcDesc)
                        {
                            // Yes, check to see if target supports prop name
                            pchName = pSrcDesc->pstrName;
                            pTargetDesc = pTarget->FindPropDescForName(pchName);
                    
                            // skip this src prop if only name is same in target, but not the whole property
                            if (!pTargetDesc ||
                                ((pSrcDesc != pTargetDesc) && 
                                 (pSrcDesc->GetDispid() != pTargetDesc->GetDispid())))
                                break;
                        }
                        // No, just copy (could be expando, unknwon attr or name\id)
                    }

COPYNEXTINTERNAL:                    
                    if( pAASync )
                    {
                        CAttrValue avTemp;

                        avTemp.SetAVType(VT_EMPTY);
                        if( SUCCEEDED( avTemp.Copy(pAVSource) ) &&
                            SUCCEEDED( pAASync->AppendIndirect( &avTemp ) ) )
                        {
                            // pAASync owns it now
                            avTemp.SetAVType(VT_EMPTY);
                        }
                    }

                    // destination element supports the property or it is an expando on the src,
                    // just insert new value if target is non-empty and src prop doesn't exist in it.
                    if (fFind && nCompare)
                    {
                        CAttrValue  tempAV;

                        // Setup CAttrValue to empty value so Copy won't free.
                        tempAV.SetAVType(VT_EMPTY);

                        // Need to allocate the value of the expando.
                        hr = THR(tempAV.Copy(pAVSource));

                        // get insertion point
                        aaIndex = pAVTarget - pAVTargetBase;
                        // if expando prop, it will already be in the doc's atom table, so don't bother adding again.
                        hr = THR((*ppAATarget)->InsertIndirect(aaIndex, &tempAV));

                        // Set back to empty, as owner is now ppAATarget, not tempAV.
                        tempAV.SetAVType(VT_EMPTY);
                    }
                    else
                    {
                        // empty target, or target at end of AA, or non-empty target with src prop value existing
                        // in it; just copy as src is already sorted 
                        
                        // if src has an expando, it will already be in the doc's atom table, so don't bother
                        // adding again.

                        // Need to set this here as pAVTarget always points to new, not necessarily zeroed out memory,
                        // so, need to protect from crashing in Free inside Copy.
                        if (nCompare)
                            pAVTarget->SetAVType(VT_EMPTY);

                        // For Undo, save the old value.
                        if (pAAUndo && !nCompare)
                        {
                            HRESULT     hrUndo;

                            hrUndo = THR( pAAUndo->AppendIndirect( pAVTarget ) );

                            // Undo AttrArray owns this now
                            pAVTarget->SetAVType(VT_EMPTY);
                        }

                        // The next CAV in target had better be the script dispatch code
                        Assert(nCompare ||
                               !fCopyNextInternal || 
                               ((pAVTarget->GetDISPID() == dispid) && (pAVTarget->AAType() == CAttrValue::AA_Internal)));

                        // If we are comming from undo and we have an exact match
                        // and our source has AVType == VT_EMPTY, remove the entry
                        // from the target array
                        if (fFromUndo && !nCompare && pAVSource->GetAVType() == VT_EMPTY)
                        {
                            // get insertion point
                            aaIndex = pAVTarget - pAVTargetBase;

                            // Fix up the checksum for the attr array
                            if (pAVTarget->AAType() != CAttrValue::AA_Internal)
                                (*ppAATarget)->_dwChecksum -= ((DWORD)pAVTarget->GetDISPID())<<1;

                            pAVTarget->Free();

                            // Delete will not realloc the array
                            (*ppAATarget)->Delete( aaIndex );

                            // The target array is one smaller
                            nSizeTarget--;

                            // Back off pAVTarget so we can move it forward below
                            pAVTarget--;
                        }
                        else
                        {
                            hr = THR(pAVTarget->Copy(pAVSource));
                        }
                    }

                    if (hr)
                        goto Cleanup;

                    if (nCompare)
                    {
                        if (pAVSource->AAType() != CAttrValue::AA_Internal)
                            (*ppAATarget)->_dwChecksum += ((DWORD)dispid)<<1;
                        nSizeTarget++;
                        (*ppAATarget)->SetSize(nSizeTarget);

                        // For Undo, store a VT_EMPTY to mark that we must
                        // remove this attr value
                        if (pAAUndo)
                        {
                            HRESULT     hrUndo;
                            CAttrValue *pAVUndo;

                            hrUndo = THR( pAAUndo->AppendIndirect( NULL, &pAVUndo ) );
                            if (!hrUndo)
                            {
                                pAVUndo->SetAVType( VT_EMPTY );
                                pAVUndo->CopyEmpty( pAVSource );
                            }
                        }
                    }
                    pAVTarget++;

                    // if onfoo event property the dispatch ptr to script code will be the next one in AA, copy it too
                    fCopyNextInternal = pSrcDesc && (pSrcDesc->GetPPFlags() & PROPPARAM_SCRIPTLET);
                    if (fCopyNextInternal)
                    {
                        pSrcDesc = NULL;
                        pAVSource++; z++;
                        if (    z < Size() 
                            &&  pAVSource->GetDISPID() == dispid 
                            &&  pAVSource->AAType() == CAttrValue::AA_Internal)
                           goto COPYNEXTINTERNAL;
                    }

                    break;

            case 1: // no, src > target, continue

                    pAVTarget++;
                    goto NEXT;
            }
        }
    }

Cleanup:

    if (hr && fAlloced)
    {
        delete *ppAATarget;
        *ppAATarget = NULL;
    }
    else if (*ppAATarget)
    {
        Assert((*ppAATarget)->Size() <= (nSizeTarget));
        hr = THR((*ppAATarget)->Grow(nSizeTarget));
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CAttrValue::CopyExpandos
//
//  Synopsis:   Add expandos of given attrarray to current attrarray
//
//-------------------------------------------------------------------------

HRESULT
CAttrArray::CopyExpandos(CAttrArray *pAA)
{
    HRESULT      hr = S_OK;
    CAttrValue * pAV2;

    Assert(pAA);

    pAV2 = (CAttrValue*) *pAA;

    for (int i = 0; i < pAA->Size(); i++, pAV2++)
    {
        // Copy all expandos
        if ( pAV2->AAType() == CAttrValue::AA_Expando)
        {
            VARIANT varVal;
            pAV2->GetAsVariantNC(&varVal);
            hr = THR(Set(pAV2->GetDISPID(), NULL, &varVal, CAttrValue::AA_Expando));
            if(hr)
                break;
        }
    }

    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Member:     CAttrArray::Compare
//
//  Synopsis:   We are already sorted, and have cache cookies!
//              TRUE means same, FALSE means different
//
//-------------------------------------------------------------------------

BOOL
CAttrArray::Compare ( CAttrArray * pAAThat, DISPID * pdispIDOneDifferent ) const
{
    int nThisSize = this ? Size() : 0;
    int nThatSize = pAAThat ? pAAThat->Size() : 0;
    const CAttrValue * pAVThis, * pAVThat;
    BOOL fFoundOneAttrValueDifferent = FALSE;

    //
    // If both arrays are empty, or identical, then they are the same.
    //

    if ((nThatSize == 0 && nThisSize == 0) || (this == pAAThat))
        return TRUE;

    //
    // A quick check of the CRC's for each array will immediatly tell
    // us if thay are different (but no the same).  Note that if we also
    // want to know if one attr is differnt we can't do this quick check.
    //

    if (!pdispIDOneDifferent && (!pAAThat || (pAAThat->GetChecksum() != this->GetChecksum())))
        return FALSE;

    DISPID pdispIDDummy;
    DISPID & dispIDOneDifferent =
        pdispIDOneDifferent ? * pdispIDOneDifferent : pdispIDDummy;
    
    dispIDOneDifferent = DISPID_UNKNOWN;

    pAVThis = this    ? * (CAttrArray *)this    : (const CAttrValue *) NULL;
    pAVThat = pAAThat ? * pAAThat : (const CAttrValue *) NULL;

    for ( ; ; )
    {
        //
        // Skip all internal attrs
        //
        
        while (nThisSize && pAVThis->AAType() == CAttrValue::AA_Internal)
            nThisSize--, pAVThis++;

        while (nThatSize && pAVThat->AAType() == CAttrValue::AA_Internal)
            nThatSize--, pAVThat++;

        //
        // Have we reached the end of one of the arrays?
        //

        if (nThisSize == 0 || nThatSize == 0)
        {
            if (nThisSize != nThatSize)
                dispIDOneDifferent = DISPID_UNKNOWN;
            
            return nThisSize == nThatSize && !fFoundOneAttrValueDifferent;
        }

        //
        // We now have the next non-internal attr for each array, compare them
        //

        if (pAVThat->GetDISPID() != pAVThis->GetDISPID())
        {
            dispIDOneDifferent = DISPID_UNKNOWN;
            return FALSE;
        }

        //
        // See if the attr value is different
        //

        if (!pAVThis->Compare( pAVThat ))
        {
            if (fFoundOneAttrValueDifferent)
                dispIDOneDifferent = DISPID_UNKNOWN;
                
            if (!pdispIDOneDifferent || fFoundOneAttrValueDifferent)
                return FALSE;

            fFoundOneAttrValueDifferent = TRUE;
            dispIDOneDifferent = pAVThis->GetDISPID();
        }

        //
        // One to the next attr ...
        //

        pAVThis++, nThisSize--;
        pAVThat++, nThatSize--;
    }
}



//+------------------------------------------------------------------------
//
//  Member:     CAttrArray::HasAnyAttribute
//
//  Synopsis:   Returns TRUE when the AttrArray contains an attribute
//              or an expando (if the flag is set)
//
//-------------------------------------------------------------------------

BOOL 
CAttrArray::HasAnyAttribute(BOOL fCountExpandosToo)
{
    CAttrValue * pAV;
    CAttrValue::AATYPE aaType;

    for(int i = 0; i < Size(); i++)
    {
        pAV = ((CAttrValue *)*this) + i;
        aaType = pAV->AAType();
        if(  aaType == CAttrValue::AA_Attribute ||
            (fCountExpandosToo && aaType == CAttrValue::AA_Expando) )
            return TRUE;
    }

    return FALSE;
}
//+------------------------------------------------------------------------
//
//  Member:     CAttrArray::HasExpandos
//
//  Synopsis:   Returns TRUE when the AttrArray contains an attribute
//              or an expando (if the flag is set)
//
//-------------------------------------------------------------------------

BOOL 
CAttrArray::HasExpandos()
{
    CAttrValue * pAV;
    CAttrValue::AATYPE aaType;

    for(int i = 0; i < Size(); i++)
    {
        pAV = ((CAttrValue *)*this) + i;
        aaType = pAV->AAType();
        if( aaType == CAttrValue::AA_Expando )
            return TRUE;
    }

    return FALSE;
}


void
CAttrArray::Clear(CAttrArray * pAAUndo)
{
    long        i;
    CAttrValue *pAV;
    DISPID      dispid;
    HRESULT     hrUndo;

    _dwChecksum = _dwChecksum & 1;

    for (i = 0, pAV = (CAttrValue *)*this; i < Size(); pAV = ((CAttrValue *)*this) + i)
    {
        if (pAV->AAType() == CAttrValue::AA_Internal)
        {
            i++;
            continue;
        }

        // preserve identity.
        dispid = pAV->GetDISPID();
        if ((DISPID_CElement_id == dispid) ||
            (STDPROPID_XOBJ_NAME == dispid) ||
            (DISPID_CElement_uniqueName == dispid))
        {
            i++;
            _dwChecksum += ((DWORD)dispid)<<1;
            continue;
        }

        hrUndo = S_OK;

        if (pAAUndo)
            hrUndo = THR( pAAUndo->AppendIndirect( pAV ) );

        if (!pAAUndo || hrUndo)
            pAV->Free();

        Delete(i);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CAttrArray::Free
//
//  Synopsis:   Frees all members
//
//-------------------------------------------------------------------------

void
CAttrArray::Free()
{
    long        i;
    CAttrValue *pAV;

    _dwChecksum = 0;

    for (i = Size(), pAV = (CAttrValue *)*this; i > 0; i--, pAV++)
    {
        pAV->Free();
    }
    DeleteAll();
}


//+------------------------------------------------------------------------
//
//  Member:     CAttrArray::FreeSpecial
//
//  Synopsis:   Frees all members except so-called members with special 
//              dispids.  This exclusive list consists of the dispids
//              we reserve for special purposes (like event sinks and
//              prop notify sinks).
//
//  Notes:      This type of Free is called when the doc unloads.
//
//-------------------------------------------------------------------------

void
CAttrArray::FreeSpecial()
{
    long            i;
    CAttrValue *    pAV;

    _dwChecksum = 0;
    SetGINCache(DISPID_UNKNOWN, NULL, FALSE);

    //
    // This complex loop is needed because we're deleting out of the
    // array while iterating over it.
    //
    
    for (i = 0, pAV = (CAttrValue *)*this; 
         i < Size(); 
         pAV = ((CAttrValue *)*this) + i)
    {
        if (pAV->GetDISPID() != DISPID_A_PROPNOTIFYSINK &&
            pAV->GetDISPID() != DISPID_A_EVENTSINK &&
            pAV->GetDISPID() != DISPID_AAHEADER &&
            pAV->GetDISPID() != DISPID_INTERNAL_INVOKECONTEXT )
        {
            pAV->Free();
            Delete(i);
        }
        else
        {
            i++;

            if (pAV->AAType() != CAttrValue::AA_Internal)
                _dwChecksum += (pAV->GetDISPID())<<1;
        }
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CAttrArray::Find
//
//  Synopsis:   Find CAttrValue given _dispID
//
//              The paaIdx is the index to start searching at if this value
//              is AA_IDX_UNKNOWN, then find first occurance.  If something
//              else then find the next occurance beyond AAINDEX which matches
//              thedispID.  The index of the CAttrValue returned is set in
//              paaIdx (this pointer can be NULL, if so then Find will always
//              return the first occurance of thedispID).
//
//-------------------------------------------------------------------------

CAttrValue*
CAttrArray::Find(
    DISPID              thedispID, 
    CAttrValue::AATYPE  aaType, 
    AAINDEX *           paaIdx,
    BOOL                fAllowMultiple)
{
    CAttrValue *    pAVBase;
    CAttrValue *    pAV;
    AAINDEX         aaIndx;
    
    if ( aaType == CAttrValue::AA_StyleAttribute )
    {
        aaType = CAttrValue::AA_Attribute;
    }

    if (paaIdx == NULL)
    {
        aaIndx = AA_IDX_UNKNOWN;
        paaIdx = &aaIndx;
    }

    // If thedispID is DISPID_UNKNOWN and *paaIdx is AA_IDX_UNKNOWN then
    // we're looking for the first occurance of the aaType.  Which we can
    // search linearly.

    // Yes, find first occurance.
    if (thedispID == DISPID_UNKNOWN)
    {
        int nCount;
        if ( !Size() )
            goto NotFound;

        // Linear search
        for ( nCount = *paaIdx + 1, pAV = ((CAttrValue*)*this) + nCount;
              nCount < Size();
              nCount++, pAV++ )
        {
            // We check with a bitwise & on the aatype so that the style and
            // attribute types are picked up
            if ( pAV->AAType() == aaType )
            {
                *paaIdx = nCount;
                thedispID = pAV->GetDISPID();
                goto UpdateCache;
            }
        }

NotFound:
        *paaIdx = AA_IDX_UNKNOWN;
    }
    else
    {
        int  nPos, nMin, nMax, nCompare;

        Assert(*paaIdx == AA_IDX_UNKNOWN);
        
        // Binary search
        pAVBase = (CAttrValue*)*this;

        //
        // Check cache first, but only if not accounting for multiple
        // entries of the same dispid.
        //
        
        for ( nPos = 0, nCompare = 0, nMin = 0, nMax = Size(); nMin < nMax ; )
        {
            nPos = (nMax + nMin) / 2;
            pAV = pAVBase + nPos;

            // Check sort order based on (DISPID,AATYPE) pair
            nCompare = pAV->CompareWith ( thedispID, aaType );

            if ( nCompare == 0 )
            {
                *paaIdx = pAV - pAVBase;
                goto UpdateCache;
            }
            else if ( nCompare < 0 )
            {
                nMax = nPos;
            }
            else
            {
                nMin = nPos + 1;
            }
        }
        // Calculate the insertion point for a new (DISPID,AATYPE)
        if ( nCompare == +1 )
        {
            *paaIdx = (AAINDEX)++nPos;        
        }
        else
        {
            *paaIdx = (AAINDEX)nPos;
        }
    }
    // Didn't find it
    return NULL;

UpdateCache:
    Assert(thedispID != DISPID_UNKNOWN && *paaIdx != AA_IDX_UNKNOWN);

    //
    // If multiple entries for the same dispid are allowed, then 
    // return the very first one.
    //
    
    if (fAllowMultiple)
    {

        ULONG   ulPos;
        
        for (ulPos = *paaIdx, pAV = ((CAttrValue*)*this) + ulPos;
             ;
             ulPos--, pAV--)
        {
            //
            // Catch the case when we're iterating down and we  
            // extend beyond the beginning or a change in dispid occurs  
            // AND we need to return the first instance of the dispid.
            //
            
            if (ulPos == AA_IDX_UNKNOWN || 
                pAV->GetDISPID() != thedispID ||
                pAV->AAType() != aaType ||
                ulPos >= (ULONG)Size())
            {
                ulPos++;
                pAV++;
                break;
            }
        }

        *paaIdx = (AAINDEX)ulPos;
    }
    
    return pAV;
}


BOOL
CAttrArray::FindString ( CAttrArray *pAA, const PROPERTYDESC *pPropertyDesc, LPCTSTR *ppStr )
{
    if ( pAA && pAA->FindString ( pPropertyDesc->GetDispid(), ppStr, CAttrValue::AA_Attribute ) )
        return TRUE;

    *ppStr = (LPTSTR)pPropertyDesc->ulTagNotPresentDefault;
    return FALSE;
}

BOOL
CAttrArray::FindString ( DISPID dispID, LPCTSTR *ppStr,
    CAttrValue::AATYPE aaType  ,
    const PROPERTYDESC **ppPropertyDesc )
{
    Assert(ppStr);

    CAttrValue *pAV = Find ( dispID, aaType );
    if ( pAV )
    {
        *ppStr = pAV->GetLPWSTR();
        if ( ppPropertyDesc )
            *ppPropertyDesc = pAV->GetPropDesc();
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


BOOL
CAttrArray::FindSimple ( CAttrArray *pAA, const PROPERTYDESC *pPropertyDesc, DWORD *pdwValue )
{
    if ( pAA && pAA->FindSimple ( pPropertyDesc->GetDispid(), pdwValue, CAttrValue::AA_Attribute ) )
        return TRUE;

    *pdwValue = (DWORD)pPropertyDesc->ulTagNotPresentDefault;
    return FALSE;
}

BOOL
CAttrArray::FindSimple ( DISPID dispID, DWORD *pdwValue,
    CAttrValue::AATYPE aaType ,
    const PROPERTYDESC **ppPropertyDesc )
{
    Assert(pdwValue);

    CAttrValue *pAV = Find ( dispID, aaType );
    if ( pAV )
    {
        *pdwValue = (DWORD)pAV->GetLong();
        if ( ppPropertyDesc )
            *ppPropertyDesc = pAV->GetPropDesc();
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL
CAttrArray::FindSimpleInt4AndDelete( DISPID dispID, DWORD *pdwValue,
    CAttrValue::AATYPE aaType ,
    const PROPERTYDESC **ppPropertyDesc )
{
    AAINDEX aaIdx = AA_IDX_UNKNOWN;
    Assert(pdwValue);

    CAttrValue *pAV = Find ( dispID, aaType, &aaIdx );
    if ( pAV )
    {
        *pdwValue = (DWORD)pAV->GetLong();
        if ( ppPropertyDesc )
            *ppPropertyDesc = pAV->GetPropDesc();
        Destroy( aaIdx );
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL
CAttrArray::FindSimpleAndDelete( DISPID dispID,
    CAttrValue::AATYPE aaType ,
    const PROPERTYDESC **ppPropertyDesc )
{
    AAINDEX aaIdx = AA_IDX_UNKNOWN;

    CAttrValue *pAV = Find ( dispID, aaType, &aaIdx );
    if ( pAV )
    {
        Assert ( pAV->GetAVType() == VT_LPWSTR );
        if ( ppPropertyDesc )
            *ppPropertyDesc = pAV->GetPropDesc();
        Destroy( aaIdx );
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


HRESULT
CAttrArray::SetAt (AAINDEX aaIdx, VARIANT *pvarNew)
{
    CAttrValue *pAV = *this;
    HRESULT hr = E_FAIL;

    if (aaIdx != AA_IDX_UNKNOWN && aaIdx < ULONG(Size()))
    {
        // Change an existing one
        // CRC doesn't change cos we didn't add a new dispid
        (pAV + aaIdx)->Free();

        // Copy in new VARIANT
        hr = THR((pAV + aaIdx)->InitVariant ( pvarNew ));
    }

    RRETURN(hr);
}



HRESULT
CAttrArray::Set (
    DISPID dispID,
    const PROPERTYDESC *pProp,
    VARIANT *pvarNew,
    CAttrValue::AATYPE aaType,
    WORD wFlags,
    BOOL fAllowMultiple)
{
    // For changing non-unique values the SetAt function must be used. This Set
    // routine allows for adding both unique and non-unique and changing unique
    // only values.
    HRESULT hr = S_OK;
    CAttrValue avNew;
    CAttrValue *pAV;
    AAINDEX aaIdx = AA_IDX_UNKNOWN;

    Assert ( pvarNew );
    Assert ( dispID != DISPID_UNKNOWN );
    Assert ((pProp && (pProp->GetDispid() == dispID)) || !pProp);

    // If we don't find the attribute, aaIdx will be set to the insertion point
    pAV = Find(dispID, aaType, &aaIdx ) ;

    if ((aaType == CAttrValue::AA_UnknownAttr) &&
        (wFlags & CAttrValue::AA_Extra_DefaultValue) &&
        !pAV)
    {
        Assert(aaIdx != AA_IDX_UNKNOWN);
        CAttrValue *pAVPrev = FindAt(aaIdx-1);
        // NOTE (sramani): when (& if) DESTROY_DEFAULT is turned off these if
        // conditions can be turned into asserts.
        if (pAVPrev &&
            pAVPrev->GetDISPID() == dispID &&
            pAVPrev->AAType() == CAttrValue::AA_Attribute)
            pAVPrev->SetDefault(TRUE);
    }

    // Add a new one if not found or if we don't want a unique one.  If a multiple
    // one needs to be change then use the CBase helpers ChangeAt functions.
    if (!pAV || fAllowMultiple)
    {
#if DESTROY_DEFAULT // explicitly store default values
        // Need a new one
        if ( pProp && IsDefaultValue ( pProp, pvarNew ) && !(wFlags & CAttrValue::AA_Extra_RuntimeStyle) &&
            ( aaType == CAttrValue::AA_StyleAttribute || 
              !( TLS(fPersistDefaultValues) WHEN_DBG( || IsTagEnabled(tagPersistDefaultValues) ) ) ) )
        {
            // Don't bother
            goto Cleanup;
        }
#endif
        avNew.SetAAType ( aaType );

        // if the AAType warrants a propdesc, but pProp == NULL,
        // as might be the case when storing a CFuncPtr *, store in _dispid
        if (pProp)
            avNew.SetPropDesc(pProp);
        else
            avNew.SetDISPID(dispID);

        hr = THR ( avNew.InitVariant ( pvarNew ) );
        if ( hr )
            goto Cleanup;

        avNew.SetImportant( wFlags & CAttrValue::AA_Extra_Important );
        avNew.SetImplied( wFlags & CAttrValue::AA_Extra_Implied );
        avNew.SetTridentSink( wFlags & CAttrValue::AA_Extra_TridentEvent );
        avNew.SetOldEventStyle( wFlags & CAttrValue::AA_Extra_OldEventStyle );
        avNew.SetExpression( FALSE );

        hr = THR(InsertIndirect( aaIdx, &avNew ));
        if ( hr )
            goto Cleanup;

        if(aaType != CAttrValue::AA_Internal)
            _dwChecksum += ((DWORD)dispID)<<1;
        else if (dispID == DISPID_INTERNAL_CSTYLEPTRCACHE || dispID == DISPID_INTERNAL_CRUNTIMESTYLEPTRCACHE)
            SetStylePtrCachePossible();
    }
    else
    {
#if DESTROY_DEFAULT // explicitly store default values
        // Change an existing one
        if ( pProp && IsDefaultValue ( pProp, pvarNew ) && !(wFlags & CAttrValue::AA_Extra_RuntimeStyle) &&
            ( aaType == CAttrValue::AA_StyleAttribute ||
              !( TLS(fPersistDefaultValues) WHEN_DBG( || IsTagEnabled(tagPersistDefaultValues) ) ) ) )
        {
            // We're setting the attribute to its default value -
            // remove it from the attr array
            Destroy ( pAV-((CAttrValue*)*this) );
            goto Cleanup;
        }
#endif
        // Copy in new VARIANT
        pAV->Free();
        pAV->SetAAType ( aaType );
        pAV->SetImportant( wFlags & CAttrValue::AA_Extra_Important );
        pAV->SetImplied( wFlags & CAttrValue::AA_Extra_Implied );
        pAV->SetTridentSink( wFlags & CAttrValue::AA_Extra_TridentEvent );
        pAV->SetOldEventStyle( wFlags & CAttrValue::AA_Extra_OldEventStyle );
        pAV->SetExpression(FALSE);
        hr = THR(pAV->InitVariant ( pvarNew ));
    }

Cleanup:
    RRETURN(hr);
}


/* static */
HRESULT
CAttrArray::Set(
    CAttrArray **ppAA,
    DISPID dispID,
    VARIANT *pvarNew,
    const PROPERTYDESC *pProp /* = NULL */,
    CAttrValue::AATYPE aaType /* = CAttrValue::AA_Attribute */,
    WORD wFlags,
    BOOL fAllowMultiple)
{
    HRESULT hr = S_OK;

    Assert(ppAA);
    if (!*ppAA)
    {
        *ppAA = new CAttrArray;
        if (!*ppAA)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    hr = THR((*ppAA)->Set ( dispID, pProp, pvarNew, aaType, wFlags, fAllowMultiple));
Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CAttrArray::Destroy
//
//  Synopsis:   Destroys attribute referenced by supplied index
//
//-------------------------------------------------------------------------
void
CAttrArray::Destroy(int iIndex)
{
    CAttrValue *pAV;

    Assert(iIndex>=0);
    Assert(iIndex<Size());

    pAV = ((CAttrValue*) *this) + iIndex;

    // Remove DISPID from checksum
    if (pAV->AAType() != CAttrValue::AA_Internal)
        _dwChecksum -= ((DWORD)pAV->GetDISPID())<<1;

    pAV->Free();
    Delete(iIndex);
}


//+------------------------------------------------------------------------
//
//  Member:     CAttrArray::SetSimple
//
//  Synopsis:   Static function that lets you store a simple types into
//              an AttrArray.  This creates both the AttrArray and AttrValue
//              if needed.  The caller still needs to call consolidate, as
//              the insertion may have messed up the sort order.
//
//-------------------------------------------------------------------------
HRESULT
CAttrArray::SetSimple(CAttrArray **ppAA, const PROPERTYDESC *pPropertyDesc, DWORD dwSimple, WORD wFlags )
{
    VARIANT varNew;
    DWORD dwPPFlags = pPropertyDesc->GetPPFlags();
    CAttrValue::AATYPE aaType;

    varNew.vt = VT_I4;
    varNew.lVal = (long)dwSimple;

    if ( dwPPFlags & PROPPARAM_STYLISTIC_PROPERTY )
    {
        aaType = CAttrValue::AA_StyleAttribute;
    }
    else
    {
        aaType = CAttrValue::AA_Attribute;
    }

    RRETURN ( CAttrArray::Set (ppAA, pPropertyDesc->GetDispid(), &varNew, pPropertyDesc, aaType, wFlags ) );
}

//+------------------------------------------------------------------------
//
//  Member:     CAttrArray::SetString
//
//  Synopsis:   Static function that lets you store a TCHAR* into
//              an AttrArray.  This creates both the AttrArray and AttrValue
//              if needed.  The caller still needs to call consolidate, as
//              the insertion may have messed up the sort order and has
//              not converted the input to a cookie
//
//-------------------------------------------------------------------------
HRESULT
CAttrArray::SetString(CAttrArray **ppAA, const PROPERTYDESC *pPropertyDesc, LPCTSTR pch,
    BOOL fIsUnknown /* = FALSE */, WORD wFlags /*=0*/ )
{
    VARIANT varNew;
    DWORD dwPPFlags = pPropertyDesc->GetPPFlags();
    CAttrValue::AATYPE aaType;

    varNew.vt = VT_LPWSTR;
    varNew.byref = (LPVOID)pch;

    if ( fIsUnknown )
    {
        aaType = CAttrValue::AA_UnknownAttr;
    }
    else
    {
        if ( dwPPFlags & PROPPARAM_CUSTOMENUM )
        {
            aaType = CAttrValue::AA_CustomProperty;
        }
        else if ( dwPPFlags & PROPPARAM_STYLISTIC_PROPERTY )
        {
            aaType = CAttrValue::AA_StyleAttribute;
        }
        else
        {
            aaType = CAttrValue::AA_Attribute;
        }
    }
    RRETURN ( CAttrArray::Set (ppAA, pPropertyDesc->GetDispid(), &varNew, pPropertyDesc, aaType, wFlags ) );
}



HRESULT
CAttrArray::GetSimpleAt(AAINDEX aaIdx, DWORD *pdwValue)
{
    HRESULT             hr = DISP_E_MEMBERNOTFOUND;
    const CAttrValue   *pAV;

    Assert(pdwValue);
    Assert(this);

    // Any attr array?
    pAV = FindAt(aaIdx);
    // Found AttrValue?
    if (pAV)
    {
        *pdwValue = (DWORD)pAV->GetLong();
        hr = S_OK;
    }

    RRETURN(hr);
}

AAINDEX
CAttrArray::FindAAIndex(
    DISPID              dispID, 
    CAttrValue::AATYPE  aaType, 
    AAINDEX             aaLastOne,
    BOOL                fAllowMultiple)
{
    return (Find(dispID, aaType, &aaLastOne, fAllowMultiple)) ? 
        aaLastOne : 
        AA_IDX_UNKNOWN;
}




CAttrValue *
CAttrArray::EnsureHeader(BOOL fCreate)
{
    CAttrValue *pAV = (CAttrValue*)*this;

    if (Size() && (pAV->GetAVType() == CAttrValue::VT_AAHEADER))
        return pAV;

    if (fCreate)
    {
        if (SetHeader())
            goto Cleanup;

        return (CAttrValue*)*this;
    }

Cleanup:
    return NULL;
}

HRESULT
CAttrArray::SetHeader()
{
    HRESULT hr = S_OK;
    CAttrValue avNew;
    CAttrArrayHeader *pAAHeader = new CAttrArrayHeader;
    if (!pAAHeader)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    avNew.SetDISPID(DISPID_AAHEADER);
#ifdef _MAC
    avNew.SetAAType(CAttrValue::AA_Internal);
#else
    avNew.SetAAType(CAttrValue::AATYPE::AA_Internal);
#endif
    avNew.SetAAHeader(pAAHeader);
    avNew.SetCachedDispid(DISPID_UNKNOWN);
    avNew.SetCachedVTblDesc(NULL);
    avNew.SetEventsToHook(NULL);

    hr = THR(InsertIndirect(0, &avNew));

Cleanup:
    if (hr && pAAHeader)
        delete pAAHeader;

    return hr;
}

DISPID CAttrArray::GetCachedDispidGIN()
{
    CAttrValue *pAV = EnsureHeader(FALSE);
    return pAV ? pAV->GetCachedDispid() : DISPID_UNKNOWN;
}

const VTABLEDESC *CAttrArray::GetCachedVTableDesc()
{
    CAttrValue *pAV = EnsureHeader(FALSE);
    return pAV ? pAV->GetCachedVTblDesc() : NULL;
}

void CAttrArray::SetGINCache(DISPID dispid, const VTABLEDESC *pVTblDesc, BOOL fCreate /*= TRUE*/)
{
    CAttrValue *pAV = EnsureHeader(fCreate);
    if (!pAV)
        return;

    Assert(pAV->GetAAHeader());
    pAV->SetCachedDispid(dispid);
    pAV->SetCachedVTblDesc(pVTblDesc);
}

const VTABLEDESC * CAttrArray::FindInGINCache(DISPID dispid)
{ 
    // First, look in the normal GIN cache
    if(dispid == GetCachedDispidGIN())
        return GetCachedVTableDesc();
    else if (dispid == DISPID_CWindow_document)
        return COmWindowProxy::s_COmWindowProxyDocument;
    else
        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\avundo.cxx ===
//+---------------------------------------------------------------------
//
//   File:      avundo.cxx
//
//  Contents:   AttrValue Undo support
//
//  Classes:    CUndoAttrValueSimpleChange
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef NO_EDIT // {

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_AVUNDO_HXX_
#define X_AVUNDO_HXX_
#include "avundo.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

MtDefine(CUndoAttrValueSimpleChange, Undo, "CUndoAttrValueSimpleChange")
MtDefine(CUndoPropChangeNotification, Undo, "CUndoPropChangeNotification")
MtDefine(CUndoPropChangeNotificationPlaceHolder, Undo, "CUndoPropChangeNotificationPlaceHolder")
MtDefine(CMergeAttributesUndoUnit, Undo, "CMergeAttributesUndoUnit")

//+---------------------------------------------------------------------------
//
//  CUndoAttrValueSimpleChange Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CUndoAttrValueSimpleChange::Init, public
//
//  Synopsis:   Initializes the undo unit for simple AttrValue change.
//
//  Arguments:  [dispidProp]   -- Dispid of property
//              [varProp]      -- unit value of property
//              [fInlineStyle]
//              [aaType]
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoAttrValueSimpleChange::Init(
    DISPID             dispid,
    VARIANT &          varProp,
    BOOL               fInlineStyle,
    CAttrValue::AATYPE aaType)
{
    HRESULT hr;

    TraceTag((tagUndo, "CUndoAttrValueSimpleChange::Init"));

    hr = THR( super::Init( dispid, &varProp ) );

    _fInlineStyle = fInlineStyle;
    _aaType = aaType;

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoAttrValueSimpleChange::Do, public
//
//  Synopsis:   Performs the undo of the property change.
//
//  Arguments:  [pUndoManager] -- Pointer to Undo Manager
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoAttrValueSimpleChange::PrivateDo(IOleUndoManager *pUndoManager)
{
    HRESULT       hr;
    DWORD         dwCookie = 0;
    CUnitValue    uvOldValue;
    CUnitValue    uvCurValue;
    CAttrArray *  pAttrArray;
    CElement *    pElement = DYNCAST( CElement, _pBase );

    TraceTag((tagUndo, "CUndoAttrValueSimpleChange::Do"));

    //
    // The redo unit should be put on the stack in this call to Invoke()
    // unless we need to disable it.
    //
    if (!pUndoManager)
    {
        _pBase->BlockNewUndoUnits(&dwCookie);
    }

    Assert( _varData.vt == VT_I4 );

    uvOldValue.SetRawValue( _varData.lVal );

    pAttrArray = _fInlineStyle
                 ? pElement->GetInLineStyleAttrArray()
                 : *pElement->GetAttrArray();

    Assert( pAttrArray );

    uvCurValue.SetNull();

    if ( pAttrArray )
    {
        pAttrArray->GetSimpleAt( pAttrArray->FindAAIndex(
            _dispid, CAttrValue::AA_Attribute ),
            (DWORD *)&uvCurValue );
    }

    {
        BOOL fTreeSync;
        VARIANT vtProp;

        vtProp.vt = VT_I4;
        vtProp.lVal = uvCurValue.GetRawValue();
        pElement->QueryCreateUndo( TRUE, FALSE, &fTreeSync);

        if( fTreeSync )
        {
            PROPERTYDESC * pPropDesc;
            CBase        * pBase = pElement; 

            if( _fInlineStyle )
            {
                CStyle * pStyle;

                pElement->GetStyleObject( &pStyle );
                pBase = (CBase *)pStyle;
            }

            // NOTE (JHarding): This may be slow if we don't hit the GetIDsOfNames cache
            IGNORE_HR( pBase->FindPropDescFromDispID( _dispid, &pPropDesc, NULL, NULL ) );
            Assert( pPropDesc );

            if( pPropDesc )
            {
                CUnitValue  uvNew( V_I4(&_varData) );
                TCHAR       achOld[30];
                TCHAR       achNew[30];

                if( SUCCEEDED( uvCurValue.FormatBuffer( achOld, ARRAY_SIZE(achOld), pPropDesc ) ) &&
                    SUCCEEDED( uvNew.FormatBuffer( achNew, ARRAY_SIZE(achNew), pPropDesc ) ) )
                {
                    VARIANT     vtNew;
                    VARIANT     vtOld;

                    if( !achNew[0] )
                    {
                        // No new value
                        V_VT(&vtNew) = VT_NULL;
                    }
                    else
                    {
                        vtNew.vt = VT_LPWSTR;
                        vtNew.byref = achNew;
                    }
                    if( !achOld[0] )
                    {
                        // No old value
                        V_VT(&vtOld) = VT_NULL;
                    }
                    else
                    {
                        vtOld.vt = VT_LPWSTR;
                        vtOld.byref = achOld;
                    }

                    // Log the change
                    pBase->LogAttributeChange( _dispid, &vtOld, &vtNew );
                }
            }
        }

        IGNORE_HR( pElement->CreateUndoAttrValueSimpleChange(
            _dispid, vtProp, _fInlineStyle, _aaType ) );
    }

    if (uvOldValue.IsNull())
    {
        DWORD dwOldValue;

        Verify( pAttrArray->FindSimpleInt4AndDelete( _dispid, &dwOldValue ) );

        Assert( dwOldValue == (DWORD)uvCurValue.GetRawValue() );

        hr = S_OK;
    }
    else
    {
        hr = THR(CAttrArray::AddSimple( &pAttrArray, _dispid,
                                        *(DWORD*)&uvOldValue, _aaType ));
    }

    if (!pUndoManager)
    {
        _pBase->UnblockNewUndoUnits(dwCookie);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  CUndoPropChangeNotification Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CUndoPropChangeNotification::Do, public
//
//  Synopsis:   Performs the undo of the property change.
//
//  Arguments:  [pUndoManager] -- Pointer to Undo Manager
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoPropChangeNotification::PrivateDo(IOleUndoManager *pUndoManager)
{
    HRESULT    hr;
    DWORD      dwCookie = 0;
    CElement * pElement = DYNCAST( CElement, _pBase );

    TraceTag((tagUndo, "CUndoPropChangeNotification::Do"));

    //
    // The redo unit should be put on the stack in this call to Invoke()
    // unless we need to disable it.
    //
    if (!pUndoManager)
    {
        _pBase->BlockNewUndoUnits(&dwCookie);
    }

    // For Redo, create the opposite object.

    hr = THR( pElement->CreateUndoPropChangeNotification( _dispid,
                                                          _dwFlags,
                                                          !_fPlaceHolder ) );

    // Fire the event, shall we?

    if (!_fPlaceHolder)
    {
        pElement->OnPropertyChange( _dispid, _dwFlags );
    }

    if (!pUndoManager)
    {
        _pBase->UnblockNewUndoUnits(dwCookie);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  CUndoPropChangeNotificationPlaceHolder Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CUndoPropChangeNotificationPlaceHolder ctor
//
//  Synopsis:   if fPost is true, it handles the ParentUndoUnit creation,
//              and (along with the dtor) CUndoPropChangeNotification posting.
//
//  Arguments:  fPost -- whether we should bother with this or not
//              pElement -- element against which we should notify upon undo
//              dispid -- dispid for notification
//              dwFlags -- flags for notification
//
//----------------------------------------------------------------------------

CUndoPropChangeNotificationPlaceHolder::CUndoPropChangeNotificationPlaceHolder(
    BOOL          fPost,
    CElement *    pElement,
    DISPID        dispid,
    DWORD         dwFlags ) : CUndoPropChangeNotification( pElement )
{
    _hr = S_FALSE;

    if (fPost && pElement->QueryCreateUndo(TRUE,FALSE))
    {
        CDoc *  pDoc = pElement->Doc();

        _pPUU = pDoc->OpenParentUnit( pDoc, IDS_UNDOGENERICTEXT );

        CUndoPropChangeNotification::Init( dispid, dwFlags, FALSE );

        IGNORE_HR( pElement->CreateUndoPropChangeNotification(
            dispid, dwFlags, FALSE ) );

        _fPost = TRUE;
    }
    else
    {
        _pPUU = NULL;
        _fPost = FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoPropChangeNotificationPlaceHolder dtor
//
//  Synopsis:   if _fPost was true at construction time, we post the
//              CUndoPropChangeNotification object and close the parent unit
//
//----------------------------------------------------------------------------

CUndoPropChangeNotificationPlaceHolder::~CUndoPropChangeNotificationPlaceHolder()
{
    if (_fPost)
    {
        CElement * pElement = DYNCAST( CElement, _pBase );
        IGNORE_HR( pElement->CreateUndoPropChangeNotification( _dispid,
            _dwFlags, TRUE ) );

        pElement->Doc()->CloseParentUnit( _pPUU, _hr );
    }
}

//+---------------------------------------------------------------------------
//
//  CMergeAttributesUndo Implementation
//
//----------------------------------------------------------------------------

CMergeAttributesUndo::CMergeAttributesUndo( CElement * pElement )
    : CUndoHelper( pElement->Doc() )
{
    Assert(pElement);
    CElement::SetPtr( &_pElement, pElement );

    _pAA = NULL;
    _pAAStyle = NULL;
    _fWasNamed = FALSE;
    _fCopyId = FALSE;
    _fRedo = FALSE;
    _fClearAttr = FALSE;
    _fPassElTarget = FALSE;

    _fAcceptingUndo = CUndoHelper::AcceptingUndo();
}

CMergeAttributesUndo::~CMergeAttributesUndo()
{
    CElement::ReleasePtr( _pElement ); 
    delete _pAA;
    delete _pAAStyle;
}

IOleUndoUnit * 
CMergeAttributesUndo::CreateUnit()
{
    CMergeAttributesUndoUnit * pUU;

    Assert( _fAcceptingUndo );

    TraceTag((tagUndo, "CMergeAttributesUndo::CreateUnit"));

    pUU = new CMergeAttributesUndoUnit( _pElement );

    if (pUU)
    {
        pUU->SetData( _pAA, _pAAStyle, _fWasNamed, _fCopyId, _fRedo, _fClearAttr, _fPassElTarget );
        _pAA = NULL;
        _pAAStyle = NULL;
    }

    return pUU;
}


//+---------------------------------------------------------------------------
//
//  CMergeAttributesUndoUnit Implementation
//
//----------------------------------------------------------------------------

CMergeAttributesUndoUnit::CMergeAttributesUndoUnit(CElement * pElement)
    : CUndoUnitBase( pElement, IDS_UNDOPROPCHANGE )
{
    CElement::SetPtr( &_pElement, pElement );
    _pAA = NULL;
    _pAAStyle = NULL;
    _fWasNamed = FALSE;
    _fCopyId = FALSE;
    _fRedo = FALSE;
    _fClearAttr = FALSE;
    _fPassElTarget = FALSE;
}

CMergeAttributesUndoUnit::~CMergeAttributesUndoUnit()
{
    CElement::ReleasePtr( _pElement ); 
    delete _pAA;
    delete _pAAStyle;
}

void 
CMergeAttributesUndoUnit::SetData( 
    CAttrArray * pAA, 
    CAttrArray * pAAStyle, 
    BOOL fWasNamed, 
    BOOL fCopyId, 
    BOOL fRedo,
    BOOL fClearAttr,
    BOOL fPassElTarget )
{
    Assert( !_pAA && !_pAAStyle );

    _pAA = pAA;
    _pAAStyle = pAAStyle;
    _fWasNamed = fWasNamed;
    _fCopyId = fCopyId;
    _fRedo = fRedo;
    _fClearAttr = fClearAttr;
    _fPassElTarget = fPassElTarget;
}

HRESULT 
CMergeAttributesUndoUnit::PrivateDo(IOleUndoManager *pUndoManager)
{
    HRESULT              hr = S_OK;
    CAttrArray *         pAttrUndo = NULL;
    CAttrArray *         pAttrSync = NULL;
    CAttrArray *         pAttrStyleUndo = NULL;
    CAttrArray *         pAttrStyleSync = NULL;
    BOOL                 fCreateUndo;
    BOOL                 fTreeSync;

    CMergeAttributesUndo Redo( _pElement );

    // If we have _pAAStyle then we must have _pAA
    Assert( !_pAAStyle || _pAA );

    // We should never have a style AA when clearing
    Assert( !_fClearAttr || !_pAAStyle );

    Redo.SetWasNamed( _pElement->_fIsNamed );
    Redo.SetCopyId( _fCopyId );
    Redo.SetClearAttr( _fClearAttr );
    Redo.SetPassElTarget( _fPassElTarget );

    if(!_fRedo)
        Redo.SetRedo();

    fCreateUndo = _pElement->QueryCreateUndo( TRUE, FALSE, &fTreeSync );
    if( _pAA && ( fCreateUndo || fTreeSync ) )
    {
        pAttrUndo       = new CAttrArray();
        pAttrStyleUndo  = new CAttrArray();
        if( !pAttrUndo || !pAttrStyleUndo )
        {
            // If we couldn't make these two arrays, we're hosed.
            fTreeSync = FALSE;
            fCreateUndo = FALSE;

            delete pAttrUndo;
            delete pAttrStyleUndo;
        }

        if( fTreeSync )
        {
            pAttrSync      = new CAttrArray();
            pAttrStyleSync = new CAttrArray();

            if( !pAttrSync || !pAttrStyleSync )
            {
                // If we couldn't make these two arrays, tree sync is hosed
                fTreeSync = FALSE;

                delete pAttrSync;
                delete pAttrStyleSync;
            }
        }
    }

    if (_pAA)
    {
        CAttrArray     **ppAATo = _pElement->GetAttrArray();

        if (_fClearAttr && _fRedo)
        {
            (*ppAATo)->Clear( pAttrUndo );

            if( pAttrSync )
            {
                // Meaning all new values are "not set"
                delete pAttrSync;
                pAttrSync = NULL;
            }
        }
        else
        {
            CElement * pelTarget = (_fRedo && _fPassElTarget) ? _pElement : NULL;

            hr = THR( _pAA->Merge( ppAATo, pelTarget, pAttrUndo, pAttrSync, !_fRedo, _fCopyId ) );
            if (hr)
                goto Cleanup;
        }

        if (!_fClearAttr)
        {
            _pElement->SetEventsShouldFire();

            // If the From has is a named element then the element is probably changed.
            if (_fWasNamed != _pElement->_fIsNamed)
            {
                _pElement->_fIsNamed = _fWasNamed;
                // Inval all collections affected by a name change
                _pElement->DoElementNameChangeCollections();
            }

            if (_pAAStyle && _pAAStyle->Size())
            {
                CAttrArray **   ppInLineStyleAATo;

                ppInLineStyleAATo = _pElement->CreateStyleAttrArray(DISPID_INTERNAL_INLINESTYLEAA);
                if (!ppInLineStyleAATo)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                hr = THR(_pAAStyle->Merge(ppInLineStyleAATo, NULL, pAttrStyleUndo, pAttrStyleSync, !_fRedo));
                if (hr)
                    goto Cleanup;
            }
        }

        if( fTreeSync )
        {
            CStyle * pStyle = NULL;

            // Only get the style object if there were style attrs merged
            if( pAttrStyleUndo->Size() )
                IGNORE_HR( _pElement->GetStyleObject( &pStyle ) );

            IGNORE_HR( _pElement->LogAttrArray( NULL, pAttrUndo, pAttrSync ) );
            IGNORE_HR( _pElement->LogAttrArray( pStyle, pAttrStyleUndo, pAttrStyleSync ) );

            delete pAttrSync;
            delete pAttrStyleSync;
        }

        if( fCreateUndo )
        {
            Redo.SetAA( pAttrUndo );
            Redo.SetAAStyle( pAttrStyleUndo );
        }
        else
        {
            delete pAttrUndo;
            delete pAttrStyleUndo;
        }
    }

    hr = THR(_pElement->OnPropertyChange(DISPID_UNKNOWN, ELEMCHNG_REMEASUREINPARENT|ELEMCHNG_CLEARCACHES|ELEMCHNG_REMEASUREALLCONTENTS));
    if (hr)
        goto Cleanup;

    IGNORE_HR( Redo.CreateAndSubmit() );

Cleanup:
    RRETURN(hr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\breaker.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_BREAKER_HXX_
#define X_BREAKER_HXX_
#include "breaker.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

//+---------------------------------------------------------------------------
//
//  Member:     LineBreakCompat
//
//  Notes:      Ported from IE4.  Simulates the presence of block break
//              chars.
//
//----------------------------------------------------------------------------

MtDefine(CLineBreakCompat_Misc, Tree, "Misc CLineBreakCompat arrays")

CLineBreakCompat::CLineBreakCompat ( )
  : _aryStackBS           ( Mt( CLineBreakCompat_Misc ) ),
    _aryRunEvents         ( Mt( CLineBreakCompat_Misc ) ),
    _aryBreaks            ( Mt( CLineBreakCompat_Misc ) ),
    _aryTableBreakCharIds ( Mt( CLineBreakCompat_Misc ) )
{
    _pMarkup = NULL;
    _fWantEndingBreak = FALSE;
}

HRESULT
CLineBreakCompat::Init ( CTreePos * ptp )
{
    HRESULT hr = S_OK;
    CTreeNode * pNode;
    CStackDataAry < CBlockScope, 32 > aryStackBS ( Mt( Mem ) );
    int i;

    _pMarkup = ptp->GetMarkup();

    _lMarkupContentsVersion = _pMarkup->GetMarkupContentsVersion();
            
    _aryStackBS.SetSize( 0 );
    _aryTableBreakCharIds.SetSize( 0 );

    //
    // Move back to a chunk of text
    //
    
    for ( _ptpPrevBreak = NULL, _ptpWalk = ptp ; ; _ptpWalk = _ptpWalk->PreviousTreePos() )
    {
        if (!_ptpWalk)
        {
            _ptpPrevBreak = _pMarkup->FirstTreePos();
            _ptpWalk = _ptpPrevBreak->NextTreePos();
            _ptpNextBreak = _ptpWalk;
            break;
        }
        else if (_ptpWalk->IsText() && _ptpWalk->Cch())
        {
            _ptpPrevBreak = _ptpWalk;
            _ptpNextBreak = _ptpWalk;
            break;
        }
    }

    _textInScope = TIS_NONE;
    _nNextTableBreakId = -1;
    _pElementLastBlockBreak = NULL;
    _fInTable = FALSE;
    _BreakPending.Clear();

    //
    // Prime block stack
    //

    for ( pNode = _ptpWalk->GetBranch() ; pNode ; pNode = pNode->Parent() )
    {
        CElement * pElement = pNode->Element();
        CFlowLayout * pFlowLayoutAbove = pElement->GetFlowLayout(GUL_USEFIRSTLAYOUT);   // FIRSTLAYOUT okay so long as MULTI_FORMAT is disabled
        
        if (pFlowLayoutAbove && pFlowLayoutAbove->IsElementBlockInContext( pElement ))
        {
            CBlockScope * pbsNew;
            
            hr = THR( aryStackBS.AppendIndirect( NULL, & pbsNew ) );
            
            if (hr)
                goto Cleanup;

            pbsNew->pNodeBlock = pNode;
            pbsNew->fVirgin = FALSE;
        }
    }

    for ( i = aryStackBS.Size() - 1 ; i >= 0 ; i-- )
    {
        hr = THR( _aryStackBS.AppendIndirect( & aryStackBS [ i ], NULL ) );
        
        if (hr)
            goto Cleanup;
    }

    if (aryStackBS.Size() > 0)
        _aryStackBS[ aryStackBS.Size() - 1 ].fVirgin = TRUE;

Cleanup:

    RRETURN( hr );
}

void
CLineBreakCompat::SetWantPendingBreak ( BOOL fWant )
{
    _fWantEndingBreak = fWant;
    _pMarkup = NULL;
}

HRESULT
CLineBreakCompat::QueryBreaks ( CMarkupPointer * pPointer, DWORD * pdwBreaks )
{
    HRESULT     hr;
    CTreePos *  ptp;
    long        ich;
    CTreePosGap tpg;

    ptp = pPointer->GetNormalizedReference( ich );

    //
    // Here can be no breaks between chars.
    //

    if (ptp->IsText())
    {
        if (ich > 0 && ich < ptp->Cch())
        {
            *pdwBreaks = 0;
            return S_OK;
        }

        hr = THR( tpg.MoveTo( ptp, ich == 0 ? TPG_LEFT : TPG_RIGHT ) );
    }
    else
        hr = THR( tpg.MoveTo( ptp, TPG_RIGHT ) );

    if (!hr)
        hr = THR( QueryBreaks( & tpg, pdwBreaks ) );

    RRETURN( hr );
}

HRESULT
CLineBreakCompat::QueryBreaks ( CTreePosGap * ptpg, DWORD * pdwBreaks )
{
    HRESULT    hr = S_OK;
    CTreePos * ptp;
    int        i;
    int        nAttempts;
    BOOL       fReset;

    Assert( pdwBreaks );

    *pdwBreaks = 0;

    if (!ptpg->IsValid())
        goto Cleanup;

    ptp = ptpg->AdjacentTreePos( TPG_RIGHT );

    Assert( ptp );

    while ( ptp->IsPointer() )
        ptp = ptp->NextTreePos();

    //
    // Can only have breaks to the left of node pos's
    //
    
    if (!ptp->IsNode())
        goto Cleanup;

    //
    // Restart the breaker as neccesary.
    //

    if (!_pMarkup || _lMarkupContentsVersion != _pMarkup->GetMarkupContentsVersion() ||
        !_ptpPrevBreak || _ptpPrevBreak->InternalCompare( ptp ) >= 0)
    {
        hr = THR( Init( ptp ) );

        if (hr)
            goto Cleanup;
    }

    //
    // Now, while ptp is greater than the end of the computed range,
    // compute the next range.  
    //
    // If we can't get in range after 5 times, then reset the
    // state machine to the ptp, and go on from there.
    //

    nAttempts = 5;
    fReset = FALSE;
    
    while ( _ptpNextBreak->InternalCompare( ptp ) < 0 )
    {
        if (!fReset && !nAttempts--)
        {
            //
            // This should get us into range
            //
            
            hr = THR( Init( ptp ) );

            if (hr)
                goto Cleanup;

            //
            // Never reset more than once.
            //
            
            fReset = TRUE;

            continue;
        }
        
        hr = THR( ComputeNextBreaks() );

        if (hr)
            goto Cleanup;
    }
    
    Assert( _ptpPrevBreak->InternalCompare( ptp ) < 0 );
    Assert( _ptpNextBreak->InternalCompare( ptp ) >= 0 );

    for ( i = _aryBreaks.Size() - 1 ; i >= 0 ; i-- )
    {
        BreakEntry * pbe = & _aryBreaks [ i ];

        if (pbe->ptp == ptp)
        {
            Assert(
                pbe->bt == BREAK_BLOCK_BREAK || 
                pbe->bt == BREAK_SITE_BREAK || 
                pbe->bt == BREAK_SITE_END );
            
            (*pdwBreaks) |= pbe->bt;
        }
    }

Cleanup:

    RRETURN( hr );
}

HRESULT
CLineBreakCompat::ComputeNextBreaks ( )
{
    HRESULT    hr = S_OK;

    Assert( _lMarkupContentsVersion == _pMarkup->GetMarkupContentsVersion() );

    Assert( _ptpNextBreak );
    Assert( _ptpPrevBreak );

    //
    // Clear out the existing breaks in the current ran1ge
    //

    _aryBreaks.SetSize( 0 );
    
    //
    // Fill _aryRunEvents with events until substantive text is found
    //

    _aryRunEvents.SetSize( 0 );
    
    while ( _ptpWalk )
    {
        long cch = -1;
        
        Assert( _lMarkupContentsVersion == _pMarkup->GetMarkupContentsVersion() );
        
        if (_ptpWalk->IsNode())
        {
            if (!_ptpWalk->IsEdgeScope() || _ptpWalk->IsEndNode())
            {
                if (_ptpWalk->Branch()->Tag() == ETAG_ROOT)
                {
                    cch = 0;            // Force HandleText
                    _ptpWalk = NULL;    // Force exit of loop
                }
                else
                {
                    CRunEvent * preNew = _aryRunEvents.Append();

                    if (!preNew)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Cleanup;
                    }

                    preNew->ptp = _ptpWalk;
                    preNew->fEnd = TRUE;

                    int cIncl;
                    for ( cIncl = 0 ; ! _ptpWalk->IsEdgeScope() ; cIncl++ )
                        _ptpWalk = _ptpWalk->NextTreePos();

                    preNew->pNode = _ptpWalk->Branch();

                    if (hr)
                        goto Cleanup;

                    while ( cIncl-- )
                        _ptpWalk = _ptpWalk->NextTreePos();
                    
                    _ptpWalk = _ptpWalk->NextTreePos();
                }
            }
            else
            {
                Assert( _ptpWalk->IsBeginNode() );
                
                CRunEvent * preNew = _aryRunEvents.Append();
                
                if (!preNew)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                preNew->ptp = _ptpWalk;
                preNew->fEnd = FALSE;
                preNew->pNode = _ptpWalk->Branch();
                
                _ptpWalk = _ptpWalk->NextTreePos();
            }
        }
        else if (_ptpWalk->IsText())
        {
            long cch2 = 0;

            while ( ! _ptpWalk->IsNode() )
            {
                if (_ptpWalk->IsText())
                    cch2 += _ptpWalk->Cch();
                
                _ptpWalk = _ptpWalk->NextTreePos();
            }

            if (cch2 > 0)
                cch = cch2;
        }
        else
        {
            _ptpWalk = _ptpWalk->NextTreePos();
        }

        if (cch >= 0)
        {
            hr = THR( HandleText( _ptpWalk, cch ) );

            if (hr)
                goto Cleanup;

            _aryRunEvents.SetSize( 0 );

            //
            // If we generated any breaks, then we are done with this chunk!
            //

            if (_aryBreaks.Size())
                break;
        }
    }

    //
    // Establish the new range
    //

    _ptpPrevBreak = _ptpNextBreak;
    
    _ptpNextBreak =
        _aryBreaks.Size()
            ? _aryBreaks [ _aryBreaks.Size() - 1 ].ptp
            : _pMarkup->LastTreePos();

    Assert( _ptpPrevBreak && _ptpNextBreak );

Cleanup:

    RRETURN( hr );
}

HRESULT
CLineBreakCompat::SetPendingBreak ( DWORD btBreakNew, CTreePos * ptpBreakNew )
{
    HRESULT hr = S_OK;
    DWORD btBreak = BREAK_NONE;
    CTreePos * ptpBreak = NULL;

    //
    // We must put the new pending break into _BreakPending so that SetBreak
    // can fixup the iRun in _BreakPending if the tree if modified.
    //

    if (_BreakPending.IsSet())
    {
        btBreak = _BreakPending.btBreak;
        ptpBreak = _BreakPending.ptpBreak;
    }

    _BreakPending.btBreak = btBreakNew;
    _BreakPending.ptpBreak = ptpBreakNew;
    _BreakPending.nBreakId = _nNextTableBreakId++;

    if (ptpBreak)
    {
        hr = THR( SetBreak( btBreak, ptpBreak ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

HRESULT
CLineBreakCompat::SetBreak ( DWORD btBreak, CTreePos * ptpBreak )
{
    BreakEntry * pbe = _aryBreaks.Append();

    if (!pbe)
        return E_OUTOFMEMORY;

    pbe->ptp = ptpBreak;
    pbe->bt = btBreak;

    return S_OK;
}

void
CLineBreakCompat::ClearPendingBlockBreak ( )
{
    if (_BreakPending.IsSet() && _BreakPending.btBreak == BREAK_BLOCK_BREAK)
        _BreakPending.Clear();
}

HRESULT
CLineBreakCompat::FlushPendingBreak ( )
{
    DWORD btBreak;
    CTreePos * ptpBreak;

    if (!_BreakPending.IsSet())
        return S_OK;

    btBreak = _BreakPending.btBreak;
    ptpBreak = _BreakPending.ptpBreak;

    _BreakPending.Clear();

    RRETURN( SetBreak( btBreak, ptpBreak ) );
}

void
CLineBreakCompat::RemoveScope ( CElement * pElement, CBlockScope & bsRemoved )
{
    int cbs = _aryStackBS.Size();

    Assert( cbs > 0 );

    //
    // Block tags CAN overlap, but that is rather rare.  Test for the most
    // common case where the block scope is the top one.
    //

    if (_aryStackBS [ cbs - 1 ].pNodeBlock->Element() == pElement)
    {
        bsRemoved = _aryStackBS [ cbs - 1 ];
        _aryStackBS.Delete( cbs - 1 );
        
        return;
    }

    int i;
    for ( i = _aryStackBS.Size() - 1 ; i >= 0 ; i-- )
    {
        if (_aryStackBS[ i ].pNodeBlock->Element() == pElement)
            break;
    }

    Assert( i >= 0 );

    bsRemoved = _aryStackBS[ i ];

    _aryStackBS.Delete( i );
}

static inline BOOL
BreaksLineInEmptyLi ( CElement * pElement )
{
    return pElement->HasFlag( TAGDESC_LIST );
}

static BOOL
RequiresTextSiteEndChar ( CTreeNode * pNode )
{
    return pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT) && ! pNode->IsContainer();
}

static BOOL
InducesTextSiteBreakChar ( CTreeNode * pNode )
{
    BOOL fBreak;
    
    if (pNode->Tag() == ETAG_TABLE)
        return TRUE;

    if (!pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT))
        return FALSE;

    if (pNode->IsContainer())
        return FALSE;

    //
    // If the first site above this one is not a text site, then no break.
    // This makes sure, for example, that table cells do not get a site break
    // char before them.
    //

    fBreak = FALSE;
    
    for ( pNode = pNode->Parent() ; pNode ; pNode = pNode->Parent() )
    {
        if (pNode->ShouldHaveLayout())
        {
            fBreak = pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT) != NULL;
            break;
        }
    }

    return fBreak;
}

HRESULT
CLineBreakCompat::HandleText ( CTreePos * ptpRunNow, long cchInRun )
{
    HRESULT hr = S_OK;

    //
    // Process all the element events.
    //

    for ( int i = 0 ; i < _aryRunEvents.Size() ; i++ )
    {
        CTreePos * ptp = _aryRunEvents[ i ].ptp;
        CTreeNode * pNode = _aryRunEvents[ i ].pNode;
        CElement * pElement = pNode->Element();
        CFlowLayout * pFlowLayout = pElement->HasFlowLayout(GUL_USEFIRSTLAYOUT);
        CFlowLayout * pFlowLayoutAbove = pElement->GetFlowLayout(GUL_USEFIRSTLAYOUT);   // FIRSTLAYOUT okay so long as MULTI_FORMAT is disabled
        ELEMENT_TAG etag = pElement->Tag();
        BOOL fEnd = _aryRunEvents[ i ].fEnd;
        BOOL fIsBlock = pFlowLayoutAbove ? pFlowLayoutAbove->IsElementBlockInContext( pElement ) : FALSE;
        BOOL fAlwaysBreak = etag == ETAG_LI;
        BOOL fBreakOnEmpty = !fAlwaysBreak && pElement->_fBreakOnEmpty;
        BOOL fBreaksLine = pElement->BreaksLine();
        BOOL fIs1DDiv = (etag == ETAG_DIV || etag == ETAG_FIELDSET) && pElement->ShouldHaveLayout();

        //
        // The following controls the insertion of text site break characters
        // into the correct places.
        //
        // When certain sites come into scope, this causes site break characters
        // to be inserted into the parent text site.
        //
        // When certain text sites go out of scope, they get text site break
        // characters inserted at their end.
        //
        // If we are linebreaking for a text site which is not the ped, make
        // sure that we don't attempt to place a site break char before the
        // text site we are breaking (doing so would mean that we modified
        // stuff outside of the text site we are supposed to break).
        //
        
        if (!fEnd && InducesTextSiteBreakChar( pNode ))
        {
            CTreeNode * pNodeParent;
            CElement * pFlowLayoutParent;

            hr = THR( FlushPendingBreak() );

            if (hr)
                goto Cleanup;

            //
            // Associate the break with the element directly above
            // the table/marquee
            //

            pNodeParent = pNode->Parent();

            pFlowLayoutParent = pNodeParent->GetFlowLayoutElement(GUL_USEFIRSTLAYOUT);

            if (pFlowLayoutParent)
            {
                hr = THR( SetPendingBreak( BREAK_SITE_BREAK, ptp ) );

                if (hr)
                    goto Cleanup;
            }

            //
            // If the element inducing the site break is a table, we may
            // need to clear this site break char if there are no cells in
            // the table.  Here we record the id of the break char to be used
            // when the table goes out of scope.
            //

            if (etag == ETAG_TABLE)
            {
                hr = THR( _aryTableBreakCharIds.Append( _BreakPending.nBreakId ) );

                if (hr)
                    goto Cleanup;
            }
        }
        
        if (fEnd && RequiresTextSiteEndChar( pNode ))
        {
            Assert( pFlowLayout );

            //
            // Only clear a pending block break if we have not been
            // requested to save them.  If we are asked to save them,
            // then we will, for example, produce block breaks for blocks
            // at the end of text sites.
            //

            if (!_fWantEndingBreak)
                ClearPendingBlockBreak();

            hr = THR( SetPendingBreak( BREAK_SITE_END, ptp ) );

            if (hr)
                goto Cleanup;

            //
            // Text site end chars always go in.  If we do not flush here,
            // we might not get another break to push it in.
            //

            hr = THR( FlushPendingBreak() );

            if (hr)
                goto Cleanup;
            
            //
            // No text in scope just after a text site char.  However, a table
            // going out of scope, for example, will, later, cause fake text to
            // come into scope.
            //

            _textInScope = TIS_NONE;
        }

        //
        // When a table goes out of scope, we need to check to see if we should
        // clear the pending site break for the table.
        //

        if (fEnd && etag == ETAG_TABLE)
        {
            long nIds, nIdLast;
            
            nIds = _aryTableBreakCharIds.Size();
            
            if (nIds > 0)
            {
                nIdLast = (LONG)_aryTableBreakCharIds[ nIds - 1 ];
                          
                _aryTableBreakCharIds.Delete( nIds - 1 );

                if (_BreakPending.IsSet() && nIdLast == _BreakPending.nBreakId)
                    _BreakPending.Clear();
            }
        }
        
        //
        // Keep the _fInTable state up to date
        //

        if (fEnd)
        {
            if (etag == ETAG_TABLE)
            {
                _fInTable = FALSE;
            }
            else if (pFlowLayout)
            {
                CTreeNode * pNodeTemp = pNode->Parent();

                _fInTable = FALSE;
                
                for ( ; pNodeTemp ; pNodeTemp = pNodeTemp->Parent() )
                {
                    if (pNodeTemp->Tag() == ETAG_TABLE)
                    {
                        _fInTable = TRUE;
                        break;
                    }
                    else if (pNodeTemp->HasFlowLayout(GUL_USEFIRSTLAYOUT))
                    {
                        break;
                    }
                }
            }
        }
        else
        {
            if (etag == ETAG_TABLE)
            {
                _fInTable = TRUE;
            }
            else if (pFlowLayout)
            {
                _fInTable = FALSE;
            }
        }

        //
        // Because of flat run, some tags should not break a line.
        //

        if (pNode->ShouldHaveLayout() || _fInTable)
            fBreaksLine = FALSE;

        ///////////////////////////////////////////////////////////////////////
        //
        // !!HACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKAHCK!!
        //
        // When elements are created during editing, the break on empty bit
        // is always set on them (I'm not thrilled about this).  For some
        // elements, we must always ignore the break on empty.
        //

        if (pElement->HasFlag( TAGDESC_LIST ) || pFlowLayout)
        {
            fBreakOnEmpty = FALSE;
        }

        //
        // !!HACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKAHCK!!
        //
        ///////////////////////////////////////////////////////////////////////

        if (fIsBlock && !fEnd)
        {
            CBlockScope * pbsNew;

            //
            // Before we push the new block element onto the stack, if there is
            // a parent block element which is currently non-empty and not
            // already broken, and the new element is capable of breaking a
            // line, break it.
            //
            // This takes care of HTML like <h1>A<h2>, where the nested <h2>
            // immediately breaks the current contents of the <h1>.
            //
            // Also, for HTML like <li><h1>A, the <li> will not be broken
            // immedaitely because it will be currently empty (there is no
            // text between <li> and <h1>.
            //

            if (_aryStackBS.Size() > 0)
            {
                CBlockScope & bsTop = TopScope();
                enum BREAK { NO_BREAK, PENDING_BREAK, MANDATORY_BREAK };
                BREAK fBreak = NO_BREAK;

                //
                // If we have just seen text and this element comming into
                // scope is the kind of element which breaks lines, then break
                // a line because of it.
                //

                if (fBreaksLine && _textInScope)
                {
                    fBreak = PENDING_BREAK;

                    ///////////////////////////////////////////////////////////
                    //
                    // !!HACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACK
                    //
                    // Again, because of the nasty break on empty bits in
                    // ui-generated elements, we must ignore simulated text
                    // when certain elements are nested. For example,
                    // <blockquote> and <div>.
                    //

                    if (_textInScope == TIS_FAKE &&
                        (bsTop.pNodeBlock->Tag() == ETAG_BLOCKQUOTE ||
                         bsTop.pNodeBlock->Tag() == ETAG_DIV))
                    {
                        fBreak = NO_BREAK;
                    }

                    //
                    // !!HACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACK
                    //
                    ///////////////////////////////////////////////////////////
                }

                ///////////////////////////////////////////////////////////////
                //
                // !!HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK!!
                //
                // Hack to break certain element in the context of <LI>
                //

                if (bsTop.pNodeBlock->Tag() == ETAG_LI && bsTop.fVirgin &&
                    BreaksLineInEmptyLi( pElement ))
                {
                    fBreak = MANDATORY_BREAK;
                }

                //
                // !!HACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACK
                //
                ///////////////////////////////////////////////////////////////

                if (fBreak != NO_BREAK)
                {
                    hr = THR( SetPendingBreak( BREAK_BLOCK_BREAK, ptp ) );
                    
                    if (hr)
                        goto Cleanup;

                    if (fBreak == MANDATORY_BREAK)
                    {
                        hr = THR( FlushPendingBreak() );

                        if (hr)
                            goto Cleanup;
                    }

                    //
                    // Note that we do not set _pElementLastBreak to
                    // bsTop.pElementBlockhere because pElementScope is comming
                    // intpo scope, and would simply NULL it out anyway.
                    //
                }

                //
                // The parent block element is going out of scope, if it is
                // entered again we have to know if it not the first time.
                //

                bsTop.fVirgin = FALSE;
            }

            //
            // Push the new block element onto the stack.
            //

            hr = THR( _aryStackBS.AppendIndirect( NULL, & pbsNew ) );
            
            if (hr)
                goto Cleanup;

            pbsNew->pNodeBlock = pNode;
            pbsNew->fVirgin = TRUE;

            //
            // On the opening of a new block element, we must forget the last
            // element which received a block break.
            //

            _pElementLastBlockBreak = NULL;

            //
            // If the current block is marked as break on empty, then simulate
            // the presense of text, other wise we have not yet seen text after
            // this element.
            //

            _textInScope = fBreakOnEmpty ? TIS_FAKE : TIS_NONE;
        }
        else if (fIsBlock && fEnd)
        {
            //
            // Remove the scope corresponding to the element, copying the scope
            // state into bs.
            //

            CBlockScope bsEnd;

            RemoveScope( pElement, bsEnd );

            //
            // If the element going out of scope was not already broken and is
            // either non-empty or always breaks a line, the let it break a
            // line. (remember that end-tags are received in the first run they
            // don't influence after the last run they do).
            //
            // This takes care of HTML like <p>A<p> where the first <p> goes
            // out of scope, and should break.
            //
            // This also deals with empty <li>'s (the fAlwaysBreak check).
            //
            // Note that here we make sure that we break a line only the first
            // time this block is entered.
            //
            // Note here that we are associating the break char with the
            // element most recent in scope.  We have to do this because the
            // element going out of scope might not be on the top of the stack,
            // and we might split a run, and must point to the nearest element.
            //

            if (fBreaksLine && (_textInScope || (fAlwaysBreak && bsEnd.fVirgin)))
            {
                //
                // Must flush here (potentially modify the tree) before
                // inspecting the tree.
                //

                hr = THR( FlushPendingBreak() );

                if (hr)
                    goto Cleanup;

                //
                // We must not insert two breaks in a row for the same element
                //

                if (pElement != _pElementLastBlockBreak)
                {
                    hr = THR( SetPendingBreak( BREAK_BLOCK_BREAK, ptp ) );

                    if (hr)
                        goto Cleanup;
                    
                    _pElementLastBlockBreak = pElement;

                    //
                    // An 5.0 change to the measurer/renderer causes the last
                    // empty LI in a UL to have a block break when the list is
                    // in a table cell.  This was not the case for 4.0.  Thus,
                    // when an LI sets a pending block break, we force it in, so
                    // the ClearPendingBlockBreak call made when the table cell
                    // goes out of scope does not nuke the block break created
                    // by the LI.
                    //

                    if (etag == ETAG_LI)
                    {
                        hr = THR( FlushPendingBreak() );

                        if (hr)
                            goto Cleanup;
                    }
                }
            }

            //
            // If wanted, don't loose a pending break when major containers
            // go out of scope.
            //

            if (_fWantEndingBreak && etag == ETAG_BODY)
            {
                hr = THR( FlushPendingBreak() );

                if (hr)
                    goto Cleanup;
            }
            
            //
            // If a line breaking element just went out of scope, no text is in
            // scope
            //

            if (fBreaksLine)
                _textInScope = TIS_NONE;
        }

        //
        // Before flat run, some elements used to be embedded in the runs and
        // had an embedding character in the text, and had their own runs.
        // Now, in the non-flat world, these elements no longer have embedding
        // characters, but they still need to behave as though they did.  So,
        // here we check for these elements, and synthesize the presence of
        // text.
        //

        if (fEnd &&
            (etag == ETAG_TABLE ||
             etag == ETAG_MARQUEE ||
             etag == ETAG_SELECT ||
             etag == ETAG_BR ||
             etag == ETAG_HR ||
             etag == ETAG_OBJECT ||
             etag == ETAG_IMG ||
             etag == ETAG_INPUT ||
             etag == ETAG_BUTTON ||
             etag == ETAG_TEXTAREA ||
             fIs1DDiv) &&
            pNode->IsInlinedElement())
        {
            _textInScope = TIS_SIMU;
        }
    }

    _aryRunEvents.SetSize( 0 );

    if (cchInRun > 0)
    {
        //
        // If we find characters in a run, then we can flush any pending
        // breaks set prior to finding this text
        //

        hr = THR( FlushPendingBreak() );

        if (hr)
            goto Cleanup;

        //
        // There are real chars here, mark the block element owning these
        // chars to indicate that chars have been found in it scope.
        //

        _textInScope = TIS_REAL;

        //
        // When se see text, we forget the last element which received a block
        // break;
        //

        _pElementLastBlockBreak = NULL;
    }

Cleanup:

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\acctable.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccTable.Cxx
//
//  Contents:   Accessible table and table cell object implementations
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCTABLE_HXX_
#define X_ACCTABLE_HXX_
#include "acctable.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_TABLE_HXX_
#define X_TABLE__HXX_
#include "table.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE__HXX_
#include "ltable.hxx"
#endif

#ifndef X_TCELL_HXX_
#define X_TCELL_HXX_
#include "tcell.hxx"
#endif


//----------------------------------------------------------------------------
//  CAccTable
//  
//  DESCRIPTION:    
//      The table accessible object constructor
//
//  PARAMETERS:
//      Pointer to the element 
//----------------------------------------------------------------------------
CAccTable::CAccTable( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );
    
    //initialize the instance variables
    SetRole( ROLE_SYSTEM_TABLE );
}



//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      If the title is not empty, returns the title
//      else, returns the innertext of the first caption tag that is contained
//      in this object. If there is no title and not caption, the method is
//      not implemented.
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccTable::GetAccName( BSTR* pbstrName )
{
    HRESULT           hr= S_OK;
    TCHAR           * pchString = NULL;
    CTableCaption   * pCaption = NULL;
    CTableLayout    * pTableLayout = NULL;

    // validate out parameter
     if ( !pbstrName )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrName = NULL;

    //get the title 
    pchString = (LPTSTR) _pElement->GetAAtitle();
    if ( pchString )
    {
        *pbstrName = SysAllocString( pchString );
        if ( !(*pbstrName) )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        // check if the table has a caption. If it does, return 
        // inner text from the caption
        pTableLayout = (DYNCAST( CTable, _pElement))->TableLayoutCache();
        
        hr = pTableLayout->EnsureTableLayoutCache();
        if (hr)
            goto Cleanup;

        pCaption = pTableLayout->GetFirstCaption();

        if (pCaption)
        {
            hr = THR( pCaption->get_innerText( pbstrName ) );
        }
        else
            hr = E_NOTIMPL;
    }

Cleanup:
    RRETURN( hr );
}


//----------------------------------------------------------------------------
//  GetAccDescription
//  
//  DESCRIPTION:
//      Same as the GetAccName
//  
//  PARAMETERS:
//      pbstrDescription    :   BSTR pointer to receive the description
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccTable::GetAccDescription( BSTR* pbstrDescription )
{
    HRESULT           hr;
    CTableCaption   * pCaption = NULL;
    CTableLayout    * pTableLayout = NULL;
    BSTR              bstrTemp = NULL;

    // validate out parameter
     if ( !pbstrDescription )
     {
        hr = E_POINTER;
        goto Cleanup;
     }

    *pbstrDescription = NULL;

    // check if the table has a caption. If it does, return 
    // inner text from the caption
    pTableLayout = (DYNCAST( CTable, _pElement))->TableLayoutCache();
    
    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    // if there is a title then it went into name and the caption 
    // should be the description.  otherwise there is no description.
    //--------------------------------------------------------------
    hr = GetTitle(&bstrTemp);
    if (hr)
        goto Cleanup;
    else
    {
        SysFreeString(bstrTemp);
        hr = S_OK;
        pCaption = pTableLayout->GetFirstCaption();

        if (pCaption)
        {
            hr = THR( pCaption->get_innerText( pbstrDescription ) );
        }
        // else just return a blank string
    }

Cleanup:
    RRETURN1( hr, S_FALSE );
}


//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      always STATE_SYSTEM_NORMAL
//      if not visible, then STATE_SYSTEM_INVISIBLE
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccTable::GetAccState( VARIANT *pvarState)
{
    // validate out parameter
    if ( !pvarState )
        return ( E_POINTER );       
    
    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;

    //check visibility
    if ( !_pElement->IsVisible(FALSE) )
        V_I4( pvarState ) = STATE_SYSTEM_INVISIBLE;
        
    return S_OK;
}

//----------------------------------------------------------------------------
//  CAccTableCell
//  
//  DESCRIPTION:    
//      The table cell accessible object constructor
//
//  PARAMETERS:
//      Pointer to the element 
//----------------------------------------------------------------------------
CAccTableCell::CAccTableCell( CElement* pElementParent )
:CAccElement(pElementParent)
{
    Assert( pElementParent );
    
    //initialize the instance variables
    SetRole( ROLE_SYSTEM_CELL );
}


//----------------------------------------------------------------------------
//  GetAccName
//  
//  DESCRIPTION:
//      If the title is not empty, returns the title. Otherwise method not 
//      implemented
//  
//  PARAMETERS:
//      pbstrName   :   BSTR pointer to receive the name
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------
STDMETHODIMP
CAccTableCell::GetAccName( BSTR* pbstrName )
{
    HRESULT           hr = S_OK;

    // validate out parameter
    if ( !pbstrName )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrName = NULL;

    //get the title or label
    hr = GetTitleorLabel(pbstrName);

    if (!*pbstrName)
    {
        hr = E_NOTIMPL;
    }

Cleanup:
    RRETURN1( hr, E_NOTIMPL );
}



//----------------------------------------------------------------------------
//  GetAccState
//  
//  DESCRIPTION:
//      always STATE_SYSTEM_NORMAL
//      if not visible, then STATE_SYSTEM_INVISIBLE
//  
//  PARAMETERS:
//      pvarState   :   address of VARIANT to receive state information.
//  
//  RETURNS
//      S_OK | E_INVALIDARG
//----------------------------------------------------------------------------    
STDMETHODIMP
CAccTableCell::GetAccState( VARIANT *pvarState)
{
    // validate out parameter
    if ( !pvarState )
        return E_POINTER;
    
    V_VT( pvarState ) = VT_I4;
    V_I4( pvarState ) = 0;

    //check visibility
    if ( !_pElement->IsVisible(FALSE) )
        V_I4( pvarState ) = STATE_SYSTEM_INVISIBLE;
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\acc\accutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       AccUtil.Cxx
//
//  Contents:   Accessibility util functions
//
//----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ACCBASE_HXX_
#define X_ACCBASE_HXX_
#include "accbase.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"    
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_ACCELEM_HXX_
#define X_ACCELEM_HXX_
#include "accelem.hxx"
#endif

#ifndef X_ACCWIND_HXX_
#define X_ACCWIND_HXX_
#include "accwind.hxx"
#endif

#ifndef X_ACCFRAME_HXX_
#define X_ACCFRAME_HXX_
#include "accframe.hxx"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

//-----------------------------------------------------------------------
//  IsSupportedElement()
//
//  DESCRIPTION:
//
//          Tells if the element is a valid accessibility element or not.
//
//  PARAMETERS:
//
//      pElem            pointer to the CElement
//
//  RETURNS:
//
//      TRUE | FALSE
//-----------------------------------------------------------------------
BOOL 
IsSupportedElement(CElement *pElem )
{
    BOOL fRet = FALSE;

    if (!pElem)
        goto Cleanup;

    // An element that has an attached behavior that implements IAccessible 
    // takes precedence over a supported tag.  However, given that this function
    // does not return why a tag is supported, it is more efficient to check if the
    // TAG is in the supported list, and only do the QI if we are still unsure if
    // the tag is supported.
      
    switch ( pElem->Tag() ) 
    {
    case ETAG_INPUT:        //both input and input text are used for input elements
        if (DYNCAST(CInput, pElem)->GetAAtype() == htmlInputHidden)
        {
            fRet = FALSE;
            break;
        }
    case ETAG_BODY:
    case ETAG_FRAME:
    case ETAG_IFRAME:
    case ETAG_A:
    case ETAG_BUTTON:
    case ETAG_IMG:
    case ETAG_TEXTAREA:
    case ETAG_MARQUEE:
    case ETAG_SELECT:
    case ETAG_OBJECT:
    case ETAG_APPLET:
    case ETAG_EMBED:
    case ETAG_TABLE:
    case ETAG_TD:
    case ETAG_TH:
    case ETAG_LABEL:
        fRet = TRUE;
        break;

    default:
        //
        // if we are not in the "official list" above, we still may be supported:
        //
        // if there is a tabstop defined on this element see CDoc::OnElementEnter for comments about Tabstops
        // if we have a behavior that implements IAccessible or a viewlink 
        //

        if (pElem->HasPeerHolder())
        {
            if (pElem->HasSlavePtr())
            {
                fRet = TRUE;
            }
            else
            {
                fRet = IsIAccessiblePeer(pElem);
            }
        }

        fRet  = fRet | (pElem->GetAAtabIndex() != htmlTabIndexNotSet);
        break;
    }

Cleanup:
    return fRet;
}

//-----------------------------------------------------------------------
//
//  IsIAccessiblePeer()
//
//  DESCRIPTION:
//
//          Tells if the peer implements IAccessible
//
//          In order to conclude that we have an accessible peer,
//          We need to find an attached behavior that implements IAccessible OR 
//          Element behavior that implements IAccessible.
//
//  PARAMETERS:
//
//      pElem            pointer to the CElement
//
//  RETURNS:
//
//      TRUE | FALSE
//-----------------------------------------------------------------------

BOOL 
IsIAccessiblePeer(CElement *pElem)
{
    HRESULT hr;
    BOOL fRet  = FALSE;

    CPeerHolder * pPH;
    IAccessible * pAcc = NULL;

    Assert (pElem->HasPeerHolder());

    pPH = pElem->GetPeerHolder();

    // Element behaviors are always first in the peer chain.

    hr = THR(pPH->QueryPeerInterfaceMulti(IID_IAccessible, (void **)&pAcc, FALSE));

    if (!hr)
    {
        fRet = TRUE;
        Assert(pAcc);                 // Catch bad behavior
    }

    ReleaseInterface(pAcc);
    return fRet;
}

//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

HRESULT 
ScrollIn_Focus( CElement* pElem )
{
    HRESULT hr;
    
    if ( !pElem )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    //scrollintoview.
    hr = THR( pElem->ScrollIntoView());
    if ( hr )
    {
        goto Cleanup;
    }

    //focus
    hr = THR( pElem->focus() );
        
Cleanup:
    RRETURN( hr );
}

//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
HRESULT 
ScrollIn_Focus_Click( CElement* pElem )
{
    HRESULT hr;

    if ( !pElem )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR( ScrollIn_Focus(pElem) );
    if ( hr )
    {
        goto Cleanup;
    }

    hr = THR( pElem->DoClick( NULL, NULL, FALSE, NULL, TRUE) );
    
Cleanup:
    RRETURN( hr );
}

//-----------------------------------------------------------------------
//  IsFocusable
//  
//  DESCRIPTION:
//      If the document that contains the elenent has focus, the function
//      returns TRUE, since the element has the ability to receive focus.
//
//  PARAMETERS:
//      pElem   :   Pointer to the CElement 
//  
//  RETURNS :
//      TRUE if the element is focusable, FALSE otherwise
//-----------------------------------------------------------------------
BOOL
IsFocusable( CElement* pElem )
{
    CDoc* pDoc= pElem->Doc();

    // does this element have a document at all?
    if ( pDoc )
    {
        return (pDoc->HasFocus());
    }
    else
        return FALSE;
}

//-----------------------------------------------------------------------
//  GetMarkupLimits
//  
//  DESCRIPTION:
//      Receives a CElement pointer, and returns two markup pointer that
//      are places after the beginning and end tags of this element.
//      This method is counted on to be called elements with scope only. 
//      
//  PARAMETERS:
//      pElem   :   CElement * to the element 
//      ppBegin :   Address of the variable that receives the begin tag markup
//      ppEnd   :   Address of the variable that receives the end tag markup
//-----------------------------------------------------------------------
HRESULT
GetMarkupLimits( CElement* pElem, CMarkupPointer* pBegin, CMarkupPointer* pEnd )
{
    HRESULT hr = S_OK;

    if ( !pElem || !pBegin || !pEnd )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    hr = THR( pBegin->MoveAdjacentToElement( pElem, ELEM_ADJ_AfterBegin));
    if ( hr )
        goto Cleanup;

    hr = THR( pEnd->MoveAdjacentToElement( pElem, ELEM_ADJ_AfterEnd));
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}

//-----------------------------------------------------------------------
//  GetSubMarkupLimits
//
//  DESCRIPTION:
//      Very similar to the GetMarkupLimits. However, this one is used for
//      viewlinked markups, so if the markup is created through DOM, it 
//      is not possible to place a markup pointer after the ROOT closes.
//      The end pointer is placed before the root tag in this case.
//-----------------------------------------------------------------------
HRESULT
GetSubMarkupLimits(CElement* pElem, CMarkupPointer* pBegin, CMarkupPointer* pEnd )
{
    HRESULT hr = S_OK;

    if ( !pElem || !pBegin || !pEnd )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    hr = THR( pBegin->MoveAdjacentToElement( pElem, ELEM_ADJ_AfterBegin));
    if ( hr )
        goto Cleanup;

    hr = THR( pEnd->MoveAdjacentToElement( pElem, ELEM_ADJ_BeforeEnd));
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}

//-----------------------------------------------------------------------
//  AccStepRight
//  
//  DESCRIPTION:
//      Moves the markup pointer to the right one step. A step is considered
//      moving from one before/end tag position to the other. If the tag
//      to the right of the markup pointer belongs to a supported element
//      the function steps over the complete supported element tag. NOscope
//      elements are considered single steps
//      The method increments the counter if it steps over something that
//      would cause the child count to increase.
//  
//  PARAMETERS:
//      pMarkup :   Markup pointer to be moved
//      pCounter:   Pointer to the child counter on the caller side
//-----------------------------------------------------------------------
HRESULT
AccStepRight( CMarkupPointer* pMarkup, long * pCounter )
{
    HRESULT             hr = S_OK;
    MARKUP_CONTEXT_TYPE context;
    CTreeNode *         pElemNode = NULL;

    //get what is to our right
    hr = THR( pMarkup->Right( TRUE, &context, &pElemNode, NULL, NULL, NULL));

    switch ( context )
    {

#if DBG==1            
        case CONTEXT_TYPE_None:     
            //if there was nothing on this side at all,
            AssertSz(FALSE, "We have hit the root..");
            break;

        case CONTEXT_TYPE_ExitScope://don't care ...
            break;
#endif

        case CONTEXT_TYPE_EnterScope:
            //check the element to see if it is a supported element
            if ( IsSupportedElement( pElemNode->Element() ) )
            {
                //go to the end of this element, since we will handle it as a container
                hr = THR( pMarkup->MoveAdjacentToElement( pElemNode->Element(), ELEM_ADJ_AfterEnd));
                if ( hr )
                    goto Cleanup;

                (*pCounter)++;      
            }
            //don't do anything if it is not a supported element.
            break;  
            
        //we jumped over text or noscope
        case CONTEXT_TYPE_NoScope:
            if ( !IsSupportedElement( pElemNode->Element() ))
                break;
            
        case CONTEXT_TYPE_Text:
            (*pCounter)++;      
            break;
    }

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//  DESCRIPTION:
//      Returns the total number of acc. children between the two markup 
//      locations
//----------------------------------------------------------------------------
HRESULT 
GetChildCount( CMarkupPointer* pStart, CMarkupPointer* pEnd, long* pChildCnt)
{
    HRESULT             hr = S_OK;
    long                lChildCnt = 0;
    MARKUP_CONTEXT_TYPE context;
    CTreeNode *         pElemNode = NULL;

    Assert( pStart );
    Assert( pEnd );
    Assert( pChildCnt );
        
    *pChildCnt = 0;
//
//TODO:   FerhanE :   We can change this for perf, to compare the left elements and
//                    contexts of two pointers.
///                   1- Get left context and element of end ptr,
//                    2- Move startptr to right and keep track of the element
//                          and context. 
//                    3- Compare the context and element of the two pointers. 
//                       if they are the same, we have the child count.
//.                     

    //we walk the pStart through the HTML using this loop
    for (; ; )
    {
        // if the two pointers are pointing to the same location, or if
        // we passed the pEnd location. If the pEnd location is inside
        // a supported element tag, then we will not have a chance to 
        // stop there, we will jump over it. 
        if ( !pStart->IsLeftOf( pEnd ) )
            break;

        //get what is to our right
        hr = THR( pStart->Right( TRUE, &context, &pElemNode, NULL, NULL, NULL));

        switch ( context )
        {
#if DBG==1            
            case CONTEXT_TYPE_None:     
                //if there was nothing on this side at all,
                AssertSz(FALSE, "We have hit the root..");
                break;

            case CONTEXT_TYPE_ExitScope://don't care ...
                break;
#endif

            case CONTEXT_TYPE_EnterScope:
                //check the element to see if it is a supported element
                if ( IsSupportedElement( pElemNode->Element() ) )
                {
                    //go to the end of this element, since we will handle it as a container
                    hr = THR( pStart->MoveAdjacentToElement( pElemNode->Element(), ELEM_ADJ_AfterEnd));
                    if ( hr )
                        goto Cleanup;

                    lChildCnt++;      
                }
                //don't do anything if it is not a supported element.
                break;  
            
            //we jumped over text or noscope
            case CONTEXT_TYPE_NoScope:
                if ( !IsSupportedElement( pElemNode->Element() ))
                    break;
            
            case CONTEXT_TYPE_Text:
                lChildCnt++;      
                break;
        }
    }

Cleanup:
    if ( hr == S_OK )
        *pChildCnt = lChildCnt;

    RRETURN( hr );
}

//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
HRESULT 
GetHitChildID( CElement* pElem, CMessage * pMsg, VARIANT * pvarChild )
{
    HRESULT             hr = S_OK;
    CMarkupPointer      walkerMarkup( pElem->Doc() );
    CMarkupPointer      HitMarkup(pElem->Doc());
    BOOL                bNotAtBOL;
    BOOL                bAtLogicalBOL;
    BOOL                bRightOfCp;
    MARKUP_CONTEXT_TYPE contextleft, 
                        contextright;
    CTreeNode *         pElemNodeLeft = 0;
    CTreeNode *         pElemNodeRight = 0;
    POINT               ptContent;
    CLayoutContext *    pLayoutContext;

    Assert( pvarChild );

    CDispNode* pDispNode;
    // position the markup pointer at the point that we are given
    // $$ktam: does pMsg have correct layout context already?  what about correct tree node?
    CTreeNode * pTreeNode = pElem->Doc()->GetNodeFromPoint( pMsg->pt, &pLayoutContext, FALSE, &ptContent,
                                                            NULL, NULL, NULL, &pDispNode );
    if( pTreeNode == NULL )
        goto Cleanup;

    // $$ktam: passing pTreeNode->GetFlowLayout() as the containing layout seems fishy to me..?
    hr = THR( pElem->Doc()->MovePointerToPointInternal( ptContent, 
                                                        pTreeNode,
                                                        pLayoutContext,
                                                        &HitMarkup, 
                                                        &bNotAtBOL,
                                                        &bAtLogicalBOL,
                                                        &bRightOfCp, 
                                                        FALSE,
                                                        pTreeNode->GetFlowLayout( pLayoutContext ),
                                                        NULL,
                                                        TRUE,
                                                        NULL,
                                                        pDispNode ));
    if (hr)
        goto Cleanup;
    
    // Set the HitMarkup to the current context.
    //-------------------------------------------------------------------------------
    hr = THR( HitMarkup.Left( FALSE, &contextleft, &pElemNodeLeft, NULL, NULL, NULL));
    if ( hr )
        goto Cleanup;

    hr = THR( HitMarkup.Right( FALSE, &contextright, &pElemNodeRight, NULL, NULL, NULL));
    if ( hr )
        goto Cleanup;

    //if there is text to the hit markups left, move to the closest tag on its left.
    //otherwise we are ready to count children.
    if ( contextleft == CONTEXT_TYPE_Text )
    {
        hr = THR( HitMarkup.Left( TRUE, &contextleft, NULL, NULL, NULL, NULL));
        if ( hr )
            goto Cleanup;
    }
    else
    {
        // after placing the Markup pointers, if we are not over text then we are in one
        // of the "gutters" on our parent and possibly sitting next to a noscope supported
        // thing.  In this case we don't need to continue with context correctness of text
        // children, and can instead, just return.
        //--------------------------------------------------------------------------------
        if ((contextright != CONTEXT_TYPE_Text ) && 
                pElemNodeRight && 
                (pElem == pElemNodeRight->Element() || !IsSupportedElement(pElemNodeRight->Element()) ))
        {
            V_VT( pvarChild ) = VT_I4;
            V_I4(pvarChild) = CHILDID_SELF;
            goto Cleanup;
        }
    }
      
    //place the markup pointer to the beginning of the element's scope.
    hr = THR( walkerMarkup.MoveAdjacentToElement( pElem, ELEM_ADJ_AfterBegin));
    if ( hr )
        goto Cleanup;

    // Count the number of children from the point we start to the point we hit
    // that number is the child id for the spot we hit.
    hr = THR( GetChildCount( &walkerMarkup, &HitMarkup, &(V_I4(pvarChild)) ) );
    if ( hr )
        goto Cleanup;

    // the contents of this variable is a 0 based index, but we want
    // the child id to be 1 based.
    V_VT(pvarChild) = VT_I4;
    V_I4(pvarChild)++;
   
  
Cleanup:

    //
    // MovePointerToPointInternal now returns CTL_E_INVALIDLINE when you attempt to
    // position a markup pointer in a table or TR.  Previously, this was returning
    // E_FAIL.  We want to prop the E_FAIL return code for compat.
    //
    if( hr == CTL_E_INVALIDLINE )
    {
        hr = E_FAIL;
    }
    
    RRETURN( hr );
}

//----------------------------------------------------------------------------
//  GetTextFromMarkup
//  
//  DESCRIPTION:
//      Given a markup pointer that has text to its right, retrieves the text
//      and fills a BSTR with the text read.
//      This function assumes that the markup pointer passed was placed properly
//      before text.
//      
//  PARAMETERS:
//      pMarkup     :   Markup pointer to start reading from
//      pbstrText   :   Address of the bstr to receive the text.
//----------------------------------------------------------------------------
HRESULT
GetTextFromMarkup( CMarkupPointer *pMarkup, BSTR * pbstrText )
{
    HRESULT                 hr = E_INVALIDARG;
    MARKUP_CONTEXT_TYPE     context;
    long                    lchCnt =-1;
    
    if ( !pMarkup || !pbstrText)
        goto Cleanup;

    // get the number of characters available for reading.
    hr = THR( pMarkup->Right( FALSE, &context, NULL, &lchCnt, NULL, NULL));
    if ( hr )
        goto Cleanup;

    Assert( context == CONTEXT_TYPE_Text );   //just checking.. !

    //allocate buffer
    hr = FormsAllocStringLen ( NULL, lchCnt, pbstrText );
    if ( hr )
        goto Cleanup;

    //read text
    hr = THR( pMarkup->Right( TRUE, &context, NULL, &lchCnt, *pbstrText, NULL));
    if ( hr )
    {
        // release the BSTR and reset the pointer if we have failed to get
        // the text from tree services.
        FormsFreeString( *pbstrText );
        *pbstrText = NULL;
    }    
    
Cleanup:
    RRETURN( hr );
}


//-----------------------------------------------------------------------
//  GetAccObjOfElement
//
//  DESCRIPTION:
//
//      Returns the element's associated Lookaside acc. object. 
//      if the acc object is not created it creates it and adds it to the
//      lookaside list.
//
//  PARAMETERS:
//
//      pElem   :   pointer to the element
//
//  RETURNS:
//
//      Pointer to the CAccBase that is created/looked up.
//
//  NOTES:
//
//
//----------------------------------------------------------------------------
CAccBase * GetAccObjOfElement( CElement* pElem )
{
    CAccBase *  pAccObj = NULL;

    //we require a valid pointer.
    if ( !pElem )
        return NULL;

    //if the element has a lookaside ptr, return that.
    //otherwise, create one, add to the list and return.
    if (pElem->HasAccObjPtr())
    {
        // get the acc. lookaside ptr for this element.
        pAccObj = pElem->GetAccObjPtr();

        goto Cleanup;
    }

    //
    // If the element is not a FRAME or IFRAME tag, then create the element
    // using the lookaside pointer functions in the CElement.
    // Otherwise, create a CAccWindow that represents the frame or iframe 
    //
    if (( pElem->Tag() != ETAG_FRAME ) && 
        (pElem->Tag()!=ETAG_IFRAME))
    {
        //create the accessible object
        //the CAccBase constructor also adds the object to the lookaside list,
        pAccObj = pElem->CreateAccObj();
        if ( !pAccObj )
        {
            goto Cleanup;
        }
    }
    else
    {
        // If there is a behavior attached to this frame, then create a CAccBehavior
        // instead of a CAccFrame.
        if (pElem->HasPeerHolder())
        {
            pAccObj = pElem->AccObjForBehavior();
        }

        // if there is not a behavior, or if we could not create an accessible
        // object for that behavior, then do what we would do if we did not have
        // a behavior attached.
        // In the weird case of HTML code with more FRAME tags than the ones defined, 
        // there won't be a window, so we check here if we have a valid proxy 
        // before continuing. see bug #8673 in IEv60 database
        COmWindowProxy * pWindowProxy = (DYNCAST( CFrameSite, pElem))->_pWindow;

        if (!pAccObj && pWindowProxy)
        {   
            // get the inner window for a frame tag.
            CWindow * pInnerWnd = pWindowProxy->Window();

            Assert(pInnerWnd);

            if (!(pInnerWnd->_pAccWindow))
            {
                pInnerWnd->_pAccWindow = (CAccWindow *) new CAccFrame( pInnerWnd, pElem);
                if (!pInnerWnd->_pAccWindow)
                    goto Cleanup;
            }

            pAccObj = pInnerWnd->_pAccWindow;
        }
    }

//[FerhanE]    
//we could AddRef the element here, but we don't, since most of the
//users of this function are internal, and they don't need reference
//counts on the element or they may chose not to increment (WM_GETOBJECT case)
    
Cleanup:
    return pAccObj;
}

//+---------------------------------------------------------------------------
//  SelectText
//  
//  DESCRIPTION:
//      Selects the text starting from the markup pointer that is passed, 
//      until the next tag in the markup stream.
//      
//  PARAMETERS:
//      pElem   :   The element that parents the text. 
//      pBegin  :   Pointer to the beginning markup position
//      
//----------------------------------------------------------------------------
HRESULT
SelectText( CElement* pElem, IMarkupPointer * pMarkupBegin )
{
    HRESULT             hr;
    IMarkupPointer *    pMarkupEnd = NULL;
    MARKUP_CONTEXT_TYPE context;

    if ( !pElem || !pMarkupBegin )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Since the selection manager is in another module, we have to use 
    // (IMarkupPointer *) values instead of (CMarkupPointer) values.(ferhane)

    // Create another markup pointer and place to the same spot the
    // first one is placed.
    hr = THR( pElem->Doc()->CreateMarkupPointer( &pMarkupEnd ) );
    if ( hr )
        goto Cleanup;
    
    hr = THR( pMarkupEnd->MoveToPointer( pMarkupBegin ) );
    if ( hr ) 
        goto Cleanup;

    // move the end pointer next to the first tag in the HTML stream.
    hr = THR( pMarkupEnd->Right( TRUE, &context, NULL, NULL, NULL ) );
    if ( hr )
        goto Cleanup;

    // select the range marked by the two markup pointers we have.
    hr = THR( pElem->Doc()->Select( pMarkupBegin, pMarkupEnd, SELECTION_TYPE_Text) );

Cleanup:
    ReleaseInterface( pMarkupEnd );
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\bindhost.cxx ===
//+------------------------------------------------------------------------
//
//  File:       docurl.cxx
//
//  Contents:   url helpers, etc.
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include <shell.h>
#endif

#ifdef WIN16

#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include "shlguid.h"
#endif

#ifndef X_URLMKI_H_
#define X_URLMKI_H_
#include "urlmki.h"
#endif

#endif

BOOL IsUrlOnNet(const TCHAR *pchUrl);
BOOL IsSpecialUrl(LPCTSTR pszURL);

MtDefine(GetBaseTarget, Utilities, "CMarkup::GetBaseTarget")
MtDefine(GetFriendlyUrl, Utilities, "CMarkup::GetFriendlyUrl")
MtDefine(Url, CMarkup, "Urls");
MtDefine(SetUrl, Url, "CMarkup::SetUrl")
MtDefine(SetUrlOriginal, Url, "CMarkup::SetUrlOriginal")
MtDefine(ExpandUrlWithBaseUrl, Utilities, "ExpandUrlWithBaseUrl")

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetBaseTarget
//
//              Get the base URL for the document.
//
//              If supplied with an element, gets the base TARGET in effect
//              at that element, based on the position of <BASE> tags.
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::GetBaseTarget(
    TCHAR **    ppchTarget, 
    CElement *  pElementContext)
{
    TCHAR       *pchTarget = NULL;
    TCHAR       *pchTargetTemp;
    HRESULT      hr = S_OK;
    CTreeNode   *pNode;

    if (pElementContext && pElementContext->GetFirstBranch())
    {
        //  Search the body upwards for first Base tag with target attribute
        for (pNode = pElementContext->GetFirstBranch()->Parent(); 
             pNode; 
             pNode=pNode->Parent())
        {
            if (pNode->Tag() == ETAG_BASE)
            {
                pchTargetTemp = (LPTSTR) DYNCAST(CBaseElement, pNode->Element())->GetAAtarget();
                if (pchTargetTemp && *pchTargetTemp)
                {
                    pchTarget = pchTargetTemp;
                    break;
                }
            }
        }
    }

    if (pchTarget == NULL && pElementContext && pElementContext->IsInMarkup())
    {
        CElement * pElementHead = pElementContext->GetMarkup()->GetHeadElement();
        if (pElementHead)
        {
            CChildIterator ci (pElementHead);
            CTreeNode * pNode;

            ci.SetAfterEnd();

            while ((pNode = ci.PreviousChild()) != NULL)
            {
                if (pNode->Tag() == ETAG_BASE)
                {
                    pchTargetTemp = LPTSTR(DYNCAST(CBaseElement, pNode->Element())->GetAAtarget());
                    
                                    
                    if (pchTargetTemp && *pchTargetTemp)
                    {
                        pchTarget = pchTargetTemp;
                        break;
                    }
                }
            }
        }
    }

    *ppchTarget = NULL;
    if (pchTarget)
    {
        hr = THR(MemAllocString(Mt(GetBaseTarget), pchTarget, ppchTarget));
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member  : CMarkup::GetUrl
//
//  Synopsis: Retrieve the default url for this markup.
//
//----------------------------------------------------------------------------

LPCTSTR
CMarkup::GetUrl(CMarkup * pMarkupThis)
{
    if (pMarkupThis && pMarkupThis->HasLocationContext())
    {
        CMarkupLocationContext * pmlc = pMarkupThis->GetLocationContext();

        if (pmlc->_pchUrl)
            return pmlc->_pchUrl;
    }

    return _T("about:blank");
}

//+---------------------------------------------------------------------------
//
//  Member  : CMarkup::SetUrl
//
//  Synopsis: Sets the default url for this markup.
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::SetUrl(CMarkup * pMarkupThis, LPCTSTR pchUrl)
{
    HRESULT hr = E_FAIL;
    TCHAR * pchAlloc = NULL;
    CStr    cstrUrl;

    // check for %01 attacks
    cstrUrl.Set(pchUrl);
    hr = THR(UnescapeAndTruncateUrl(cstrUrl));
    if(hr)
        goto Cleanup;
    
    if (pMarkupThis)
    {
        if (pMarkupThis->Url() == pchUrl)
        {
            hr = S_OK;
            goto Cleanup;
        }

        if (pchUrl)
        {
            hr = THR(MemAllocString(Mt(SetUrl), pchUrl, &pchAlloc));
            if (hr)
                goto Cleanup;
        }

        MemFreeString(pMarkupThis->DelUrl());

        // Clear the URL location
        MemFreeString(pMarkupThis->DelUrlLocationPtr());

        if (pchAlloc)
        {
            hr = pMarkupThis->SetUrl(pchAlloc);
            if (hr)
                goto Cleanup;

            pchAlloc = NULL;
        }
    }

Cleanup:
    MemFreeString(pchAlloc);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetUrlOriginal
//
//  Synopsis:   Retrieves the default original url for this markup.
//
//----------------------------------------------------------------------------

LPCTSTR
CMarkup::GetUrlOriginal(CMarkup * const pMarkupThis)
{
    if (pMarkupThis && pMarkupThis->HasLocationContext())
    {
        CMarkupLocationContext * pmlc = pMarkupThis->GetLocationContext();

        if (pmlc->_pchUrlOriginal)
            return pmlc->_pchUrlOriginal;
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetUrlOriginal
//
//  Synopsis:   Retrieves the default original url for this markup.
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::SetUrlOriginal(CMarkup * pMarkupThis, const TCHAR * const pszUrlOriginal)
{
    HRESULT hr = E_FAIL;
    TCHAR * pchAlloc = NULL;

    Assert(pMarkupThis);

    if (pMarkupThis->UrlOriginal() == pszUrlOriginal)
    {
        hr = S_OK;
        goto Cleanup;
    }
    
    if (pszUrlOriginal)
    {
        hr = THR(MemAllocString(Mt(SetUrlOriginal), pszUrlOriginal, &pchAlloc));
        if (hr)
            goto Cleanup;
    }

    hr = pMarkupThis->SetUrlOriginal(pchAlloc);  // Passing NULL frees the string.
    if (hr)
        goto Cleanup;

    pchAlloc = NULL;

Cleanup:
    MemFreeString(pchAlloc);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetUrlLocation
//
//  Synopsis:   Retrieve the default url location for this markup.
//
//----------------------------------------------------------------------------

LPCTSTR
CMarkup::GetUrlLocation(CMarkup * pMarkupThis)
{
    TCHAR * pchLocation=NULL;
    if (pMarkupThis)
    {
        pchLocation = pMarkupThis->UrlLocationPtr();
    }

    if (pchLocation)
        return pchLocation;

    return _T("");
}

HRESULT
CMarkup::SetUrlLocation(CMarkup * pMarkupThis, LPCTSTR pchUrlLocation)
{
    HRESULT hr       = E_FAIL;
    TCHAR * pchAlloc = NULL;
    
    if (pMarkupThis)
    {
        if (pMarkupThis->UrlLocationPtr() == pchUrlLocation)
        {
            hr = S_OK;
            goto Cleanup;
        }

        if (pchUrlLocation)
        {
            hr = THR(MemAllocString(Mt(SetUrl), pchUrlLocation, &pchAlloc));
            if (hr)
                goto Cleanup;
        }

        MemFreeString(pMarkupThis->DelUrlLocationPtr());

        if (pchAlloc)
        {
            hr = pMarkupThis->SetUrlLocationPtr(pchAlloc);
            if (hr)
                goto Cleanup;

            pchAlloc = NULL;
        }
    }

Cleanup:
    MemFreeString(pchAlloc);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetUrlSearch
//
//  Synopsis:   Retrieve the default url search component for this markup.
//
//----------------------------------------------------------------------------

LPCTSTR
CMarkup::GetUrlSearch(CMarkup * pMarkupThis)
{
    TCHAR * pchSearch=NULL;
    if (pMarkupThis)
    {
        pchSearch = pMarkupThis->UrlSearchPtr();
    }

    if (pchSearch)
        return pchSearch;

    return _T("");
}


HRESULT
CMarkup::SetUrlSearch(CMarkup * pMarkupThis, LPCTSTR pchUrlSearch)
{
    HRESULT hr       = E_FAIL;
    TCHAR * pchAlloc = NULL;
    
    if (pMarkupThis)
    {
        if (pMarkupThis->UrlSearchPtr() == pchUrlSearch)
        {
            hr = S_OK;
            goto Cleanup;
        }

        if (pchUrlSearch)
        {
            hr = THR(MemAllocString(Mt(SetUrl), pchUrlSearch, &pchAlloc));
            if (hr)
                goto Cleanup;
        }

        MemFreeString(pMarkupThis->DelUrlSearchPtr());

        if (pchAlloc)
        {
            hr = pMarkupThis->SetUrlSearchPtr(pchAlloc);
            if (hr)
                goto Cleanup;

            pchAlloc = NULL;
        }
    }

Cleanup:
    MemFreeString(pchAlloc);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetBaseUrl
//
//              Get the base URL for the document.
//
//              If supplied with an element, gets the base URL in effect
//              at that element, based on the position of <BASE> tags.
//              Note that this is a pointer to an internal string, it can't
//              be modified. If you need to modify it, make a copy first.
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::GetBaseUrl(
    CMarkup *  pMarkupThis,
    TCHAR * *  ppchHref,
    CElement * pElementContext,
    BOOL *     pfDefault,
    TCHAR *    pszAlternateDocUrl )
{
    Assert(pMarkupThis || pElementContext);
    
    TCHAR *     pchHref = NULL;
    TCHAR    *  pchHrefTemp;
    BOOL        fDefault;
    HRESULT     hr=S_OK;
    CTreeNode * pNode;
    CDoc *      pDoc;

    if (    !pMarkupThis
        &&  pElementContext
        &&  pElementContext != EXPANDIGNOREBASETAGS)
    {
        pMarkupThis = pElementContext->GetMarkup();

        if (!pMarkupThis)
        {
            pMarkupThis = pElementContext->Doc()->PrimaryMarkup();
        }
    }

    pDoc = (pElementContext && pElementContext != EXPANDIGNOREBASETAGS) ? 
                pElementContext->Doc() : 
                pMarkupThis ? pMarkupThis->Doc() : NULL;

    Assert(!!GetUrl(pMarkupThis));
    Assert(pDoc);

    if (pElementContext != EXPANDIGNOREBASETAGS && pDoc->_fHasBaseTag)
    {
        if (pElementContext)
        {
            CTreeNode * pNodeContext = pElementContext->GetFirstBranch();

            if (pNodeContext)
            {
                //  Search the body upwards for first Base tag with href attribute
                for ( pNode = pNodeContext->Parent() ; 
                      pNode ; 
                      pNode = pNode->Parent() )
                {
                    if (pNode->Tag() == ETAG_BASE)
                    {
                        pchHrefTemp = (LPTSTR) DYNCAST(CBaseElement, pNode->Element())->GetHref();

                        if (pchHrefTemp && *pchHrefTemp)
                        {
                            pchHref = pchHrefTemp;
                            break;
                        }
                    }
                }
            }
        }

        if (pchHref == NULL && pMarkupThis)
        {
            CHeadElement * pHead = pMarkupThis->GetHeadElement();
            if (pHead)
            {
                CChildIterator ci ( pHead, NULL, CHILDITERATOR_DEEP );
                CTreeNode * pNode;

                ci.SetAfterEnd();

                while ( (pNode = ci.PreviousChild()) != NULL )
                {
                    if (pNode->Tag() == ETAG_BASE)
                    {
                        pchHrefTemp = LPTSTR (DYNCAST( CBaseElement, pNode->Element() )->GetHref() );
                    
                        if (pchHrefTemp && *pchHrefTemp)
                        {
                            pchHref = pchHrefTemp;
                            break;
                        }
                    }
                }
            }
        }
    }

    if (pchHref == NULL)
    {
        if (pszAlternateDocUrl)
        {
            *ppchHref = pszAlternateDocUrl; 
        }
        else if (IsSpecialUrl((TCHAR *)GetUrl(pMarkupThis)) && 
                    pMarkupThis->GetAAcreatorUrl())
        {
            *ppchHref = (TCHAR *)pMarkupThis->GetAAcreatorUrl();
        }
        else
        {
            *ppchHref = (TCHAR *)GetUrl(pMarkupThis);
        }

        fDefault = TRUE;
    }
    else
    {
        *ppchHref = pchHref;
        fDefault = FALSE;
    }

    if (pfDefault)
        *pfDefault = fDefault;

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::ExpandUrl
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::ExpandUrl(CMarkup *  pMarkupThis,
                   LPCTSTR    pchRel, 
                   LONG       dwUrlSize,
                   TCHAR *    pchUrlOut,
                   CElement * pElementContext,
                   DWORD      dwFlags,           /* = 0xFFFFFFFF */
                   TCHAR *    pszAlternateDocUrl /* = NULL */
                  )
{
    HRESULT hr=S_OK;
    DWORD cchBuf;
    BOOL fDefault;
    BOOL fCombine;
    DWORD dwSize;
    TCHAR *pchBaseUrl = NULL;

    AssertSz(dwUrlSize == pdlUrlLen, "Wrong size URL buffer!!");

    if (dwFlags == 0xFFFFFFFF)
        dwFlags = URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE;

    if (pchRel == NULL) // note: NULL is different from "", which is more similar to "."
    {
        *pchUrlOut = _T('\0');
        goto Cleanup;
    }

    hr = GetBaseUrl(pMarkupThis, &pchBaseUrl, pElementContext,
                    &fDefault, pszAlternateDocUrl);
    if (hr)
        goto Cleanup;

    //
    // Expanding an outbind url in printing causes dll deadlock
    // when the outlib pluggable protocal is handling the CombineUrl call.
    //
    // since the only case this can happen is printing a mail message,
    // and there is no relative link into the mail message, we can
    // just return the url passed in.
    //
    // Lets try to make this test fast.
    //
    extern BOOL bCallCoInternetCombineUrl;
    
    if (!bCallCoInternetCombineUrl
        && !fDefault
        && !pszAlternateDocUrl
        && pchBaseUrl )
    {
        CDoc * pDoc = (pElementContext) ? pElementContext->Doc() 
             : ( pMarkupThis) ? pMarkupThis->Doc()
             : NULL;

        if (    pDoc
            &&  pDoc->IsPrintDialog()
            &&  _tcslen(pchBaseUrl) > 8
            && (   _tcsnicmp(_T("outbind:"), 8, pchBaseUrl, 8) == 0  //outlook2k
                || _tcsnicmp(_T("outday:"), 7, pchBaseUrl, 7) == 0) // outlook98
           )
        {
            // the base is an "outbind:" scheme
            // so all URLs are not relative
            _tcsncpy (pchUrlOut, pchRel, dwUrlSize);
            pchUrlOut[dwUrlSize-1] = _T('\0');    //If there wasn't room for the URL.
            goto Cleanup;
        }
    }

    hr = THR(CoInternetCombineUrl(pchBaseUrl, pchRel, dwFlags,
                                  pchUrlOut, pdlUrlLen, &cchBuf, 0));
    if (hr)
        goto Cleanup;

    if (!fDefault && (pMarkupThis || pszAlternateDocUrl))
    {
        LPCTSTR pchUrl;

        pchUrl = pszAlternateDocUrl ? pszAlternateDocUrl : GetUrl(pMarkupThis);

        if (S_OK == THR(CoInternetQueryInfo(
                        pchUrl,
                        QUERY_RECOMBINE, 0, &fCombine,
                        sizeof(BOOL), &dwSize, 0))
            &&  fCombine)
        {
            TCHAR achBuf2[pdlUrlLen];
            DWORD cchBuf2;

            hr = THR(CoInternetCombineUrl(
                pchUrl,
                pchUrlOut, dwFlags, achBuf2, pdlUrlLen, &cchBuf2, 0));
            
            if (hr)
                goto Cleanup;

            _tcsncpy (pchUrlOut, achBuf2, dwUrlSize);
            pchUrlOut[dwUrlSize-1] = _T('\0');    //If there wasn't room for the URL.
        }
    }
    
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetRootSslState
//
//----------------------------------------------------------------------------
extern void PostManLock();
extern void PostManUnlock();


void
CDoc::EnterRootSslPrompt()
{
    _cInSslPrompt += 1;
    PostManLock();
}

BOOL
CDoc::InRootSslPrompt()
{
    return (!!_cInSslPrompt);
}

void
CDoc::LeaveRootSslPrompt()
{
    _cInSslPrompt -= 1;

    PostManUnlock();

    // Anything deferred because of InRootSslPrompt should be reexecuted now:
    if (_fNeedUrlImgCtxDeferredDownload)
    {
        _fNeedUrlImgCtxDeferredDownload = FALSE;
        OnUrlImgCtxDeferredDownload(NULL);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::ValidateSecureUrl
//
//  Synopsis:   Given an absolute URL, returns TRUE if it is okay (in terms
//              of SSL security) to begin download of the URL.
//
//              May prompt the user (once per top-level frame).
//
//              If fReprompt is TRUE (default FALSE), the user is reprompted
//              even if s/he previously answered NO. The user is never
//              reprompted if s/he previously answered YES. (Once unsecure,
//              always unsecure.)
//
//----------------------------------------------------------------------------
BOOL
CMarkup::ValidateSecureUrl(BOOL fPendingRoot, LPCTSTR pchUrl, BOOL fReprompt, BOOL fSilent, BOOL fUnsecureSource)
{
    BOOL                bResult = TRUE;
    DWORD               error;
    SSL_SECURITY_STATE  sslSecurity;
    SSL_PROMPT_STATE    sslPrompt;
    CDoc              * pDoc = Doc();

    // grab the current security state
    pDoc->GetRootSslState(fPendingRoot, &sslSecurity, &sslPrompt);

    // if everything is allowed, don't even look at URL (perf win)
    if (sslPrompt == SSL_PROMPT_ALLOW)
        return TRUE;

    // If the URL is https then it needs no validation
    if (!fUnsecureSource && IsUrlSecure(pchUrl))
        return TRUE;

    // Otherwise, we may need to prompt
    if (sslPrompt == SSL_PROMPT_QUERY ||
        (sslPrompt == SSL_PROMPT_DENY && fReprompt))
    {
        if (fSilent || (pDoc->_dwLoadf & DLCTL_SILENT))
        {
            // in silent mode, act as if the user ignores the warnings
            pDoc->SetRootSslState(fPendingRoot, SSL_SECURITY_UNSECURE, SSL_PROMPT_ALLOW);
            sslPrompt = SSL_PROMPT_ALLOW;
        }
        else
        {
            BOOL    fAllow = FALSE;
            DWORD   dwPolicy = URLPOLICY_QUERY;

            // Grab the primary markup so we can recognize if a switch happened
            CMarkup * pMarkupPrimary = pDoc->PrimaryMarkup();

            // Check if the security manager ( URLMON or Host ) needs to have the zone crossing
            // confirmed for mixed content. 

            IGNORE_HR(ProcessURLAction(URLACTION_HTML_MIXED_CONTENT, 
                                            &fAllow,
                                            PUAF_NOUI,
                                            &dwPolicy,
                                            pchUrl));

            //
            // If mixed content is not allowed or the policy is query, 
            // then ask user for permission.
            //
            if (fAllow)
            {
                error = ERROR_SUCCESS;
            }
            else if (GetUrlPolicyPermissions(dwPolicy) == URLPOLICY_QUERY)
            {
                // TODO: (jbeda) Work out reentrancy issues here
                // TODO: (jbeda) carry window context down here to CDoEnableModeless
                CDoEnableModeless   dem(pDoc, NULL);
                HWND                hwnd = dem._hwnd;

                pDoc->EnterRootSslPrompt();
                
                error = InternetErrorDlg(hwnd, 
                                         NULL,      // no request
                                         ERROR_INTERNET_MIXED_SECURITY,
                                         0,         // no flags
                                         NULL       // no extra data
                                         );

                pDoc->LeaveRootSslPrompt();
            }
            else 
            {
                // security settings disallow outright...
                Assert(GetUrlPolicyPermissions(dwPolicy) == URLPOLICY_DISALLOW);

                error = ERROR_CANCELLED;
            }

            // in case state has changed during message box,
            // grab the current security state again

            if (pMarkupPrimary != pDoc->PrimaryMarkup())
            {
                if (fPendingRoot)
                {
                    fPendingRoot = FALSE;
                }
                else
                {
                    // the regular root was navigated away while
                    // we were in the dialog.  Nothing really
                    // matters at this point since the markup
                    // is probably going to be torn down.
                    bResult = FALSE;
                    goto Cleanup;
                }
            }
            
            pDoc->GetRootSslState(fPendingRoot, &sslSecurity, &sslPrompt);

            if (error == ERROR_SUCCESS)
            {
                // User says "okay" to mixed content: downgrade security
                if (sslSecurity >= SSL_SECURITY_SECURE)
                    sslSecurity = SSL_SECURITY_MIXED;

                sslPrompt = SSL_PROMPT_ALLOW;
            }
            else
            {
                sslPrompt = SSL_PROMPT_DENY;
            }
            
            pDoc->SetRootSslState(fPendingRoot, sslSecurity, sslPrompt);
        }
    }
    
    bResult = (sslPrompt == SSL_PROMPT_ALLOW);
    
Cleanup:
    return bResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetRootSslState
//
//----------------------------------------------------------------------------

void
CDoc::GetRootSslState(BOOL fPendingRoot, SSL_SECURITY_STATE *psss, SSL_PROMPT_STATE *psps)
{
    if (!fPendingRoot)
    {
        *psss = _sslSecurity;
        *psps = _sslPrompt;
    }
    else
    {
        *psss = _sslSecurityPending;
        *psps = _sslPromptPending;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetRootSslState
//
//----------------------------------------------------------------------------

void
CDoc::SetRootSslState(BOOL fPendingRoot, SSL_SECURITY_STATE sss, SSL_PROMPT_STATE sps, BOOL fInit)
{
    SSL_SECURITY_STATE * psss;
    SSL_PROMPT_STATE * psps;

    if (!fPendingRoot)
    {
        psss = &_sslSecurity;
        psps = &_sslPrompt;
    }
    else
    {
        psss = &_sslSecurityPending;
        psps = &_sslPromptPending;
    }

    Assert(!(sss == SSL_SECURITY_UNSECURE && sps != SSL_PROMPT_ALLOW));
    Assert(!(sss >= SSL_SECURITY_SECURE && sps == SSL_PROMPT_ALLOW));

    *psps = sps;
    
    if (*psss != sss || fInit)
    {
        *psss = sss;
        if (!fPendingRoot && _pClientSite)
        {
            VARIANT varIn;
        
            Assert(SECURELOCK_SET_UNSECURE          == SSL_SECURITY_UNSECURE);
            Assert(SECURELOCK_SET_MIXED             == SSL_SECURITY_MIXED);
            Assert(SECURELOCK_SET_SECUREUNKNOWNBIT  == SSL_SECURITY_SECURE);
            Assert(SECURELOCK_SET_SECURE40BIT       == SSL_SECURITY_SECURE_40);
            Assert(SECURELOCK_SET_SECURE56BIT       == SSL_SECURITY_SECURE_56);
            Assert(SECURELOCK_SET_FORTEZZA          == SSL_SECURITY_FORTEZZA);
            Assert(SECURELOCK_SET_SECURE128BIT      == SSL_SECURITY_SECURE_128);

            V_VT(&varIn) = VT_I4;
            V_I4(&varIn) = sss;

            CTExec(
                _pClientSite,
                &CGID_ShellDocView,
                SHDVID_SETSECURELOCK,
                0,
                &varIn,   
                0);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::AllowFrameUnsecureRedirect
//
//----------------------------------------------------------------------------
BOOL
CDoc::AllowFrameUnsecureRedirect(BOOL fPendingRoot)
{
    SSL_SECURITY_STATE sslSecurity;
    SSL_PROMPT_STATE   sslPrompt;

    GetRootSslState(fPendingRoot, &sslSecurity, &sslPrompt);

    if (sslSecurity >= SSL_SECURITY_SECURE)
        return FALSE;

    if (sslPrompt != SSL_PROMPT_ALLOW)
        return FALSE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:  SecStateFromSecFlags
//
//----------------------------------------------------------------------------
SSL_SECURITY_STATE
SecStateFromSecFlags(DWORD dwFlags)
{
    if (!(dwFlags & SECURITY_FLAG_SECURE))
        return SSL_SECURITY_MIXED;

    if (dwFlags & SECURITY_FLAG_128BIT)
        return SSL_SECURITY_SECURE_128;

    if (dwFlags & SECURITY_FLAG_FORTEZZA)
        return SSL_SECURITY_FORTEZZA;

    if (dwFlags & SECURITY_FLAG_56BIT)
        return SSL_SECURITY_SECURE_56;
        
    if (dwFlags & SECURITY_FLAG_40BIT)
        return SSL_SECURITY_SECURE_40;

    return SSL_SECURITY_SECURE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnHtmDownloadSecFlags(dwFlags)
//
//----------------------------------------------------------------------------
void
CDoc::OnHtmDownloadSecFlags(BOOL fPendingRoot, DWORD dwFlags, CMarkup * pMarkup)
{
    if (pMarkup->IsPrimaryMarkup() || pMarkup->IsPendingPrimaryMarkup())
    {
        SSL_SECURITY_STATE sslSecurity;
        SSL_PROMPT_STATE   sslPrompt;

        GetRootSslState(fPendingRoot, &sslSecurity, &sslPrompt);

        sslSecurity = SecStateFromSecFlags(dwFlags);
                
        // we're a nonsecure top frame load...
        
        if (sslSecurity >= SSL_SECURITY_SECURE)
        {
            // We were potentially redirected to a secure URL
            
            if (sslPrompt == SSL_PROMPT_ALLOW)
                sslPrompt = SSL_PROMPT_QUERY;
                
            SetRootSslState(fPendingRoot, sslSecurity, sslPrompt);
        }
        else
        {
            // We were potentially redirected to an unsecure URL or to the cache

            SetRootSslState(fPendingRoot, SSL_SECURITY_UNSECURE, SSL_PROMPT_ALLOW);
        }
    }
    else
    {
        // Otherwise, we're a subframe load; behave like an image (except about:)
        
        if (!pMarkup->_fSslSuppressedLoad)
            OnSubDownloadSecFlags(fPendingRoot, CMarkup::GetUrl(pMarkup), dwFlags);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnSubDownloadSecFlags(dwFlags)
//
//----------------------------------------------------------------------------
void
CDoc::OnSubDownloadSecFlags(BOOL fPendingRoot, const TCHAR *pchUrl, DWORD dwFlags)
{
    SSL_SECURITY_STATE sslSecurity;
    SSL_SECURITY_STATE sslSecIn;
    SSL_SECURITY_STATE sslSecNew;
    SSL_PROMPT_STATE   sslPrompt;

    GetRootSslState(fPendingRoot, &sslSecurity, &sslPrompt);

    sslSecIn = SecStateFromSecFlags(dwFlags);

    sslSecNew = min(sslSecIn, sslSecurity);

    // note: SSL_SECURITY_SECURE (unknown bitness) should have been the
    // largest enum; but we can't change it because it is exported -
    // so fixup "min" by detecting the case where the smaller one was
    // SSL_SECURITY_SECURE and taking the other one
    
    if (sslSecNew == SSL_SECURITY_SECURE)
        sslSecNew = max(sslSecIn, sslSecurity);
        
    if (sslSecurity != sslSecNew && IsUrlOnNet(pchUrl))
        SetRootSslState(fPendingRoot, sslSecNew, sslPrompt);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnIgnoreFrameSslSecurity()
//
//  Synopsis:   when a non-SSL frame load has been suppressed by
//              the user, we need to touch subframe's host with a CTExec
//              SDHVID_SETSECURELOCK in LoadFromInfo so that the shell
//              doesn't ask urlmon/wininet for its idea of the frame's
//              security.
//
//----------------------------------------------------------------------------
void
CDoc::OnIgnoreFrameSslSecurity()
{
    SSL_SECURITY_STATE sslSecurity;
    SSL_PROMPT_STATE   sslPrompt;

    GetRootSslState(FALSE, &sslSecurity, &sslPrompt);
    
    if (_pClientSite)
    {

        VARIANT varIn;
    
        V_VT(&varIn) = VT_I4;
        V_I4(&varIn) = sslSecurity;

        CTExec(
            _pClientSite,
            &CGID_ShellDocView,
            SHDVID_SETSECURELOCK,
            0,
            &varIn,   
            0);
    }
}



// Implementation of the global GetFriendlyUrl

#define MAX_SUFFIX_LEN 256

#define PROTOCOL_FILE       _T("file")
#define PROTOCOL_MAILTO     _T("mailto")
#define PROTOCOL_GOPHER     _T("gopher")
#define PROTOCOL_FTP        _T("ftp")
#define PROTOCOL_HTTP       _T("http")
#define PROTOCOL_HTTPS      _T("https")
#define PROTOCOL_NEWS       _T("news")

static void Concat(TCHAR *pchDst, int sizeDst, const TCHAR *pchSrc, LONG x, LONG y)
{
    if (x >= 0)
    {
        TCHAR achTemp[pdlUrlLen + 1 + MAX_SUFFIX_LEN + 20];

        _tcscpy(achTemp, pchDst);
        Format(0, pchDst, sizeDst, _T("<0s><1s>?<2d>,<3d>"), achTemp, pchSrc, x, y);
    }
    else
        _tcscat(pchDst, pchSrc);
}

// GetFriendlyUrl
//      fShowFriendlyUrl = FALSE    
//          returns full url
//
//      fShowFriendlyUrl = TRUE     
//          replaces protocol with friendly description (like Shortcut to or Mail to),
//          strips path details: "http://sitename/path/filename.gif" -> "filename.gif at sitename"
//
//      x,y are only meaningful for server-side maps <a href="..."><img ismap=true>. With any setting, 
//      appends x,y coordinates to the end of URL: "http://sitename/path/filename.gif?123,152"
//          
TCHAR *
GetFriendlyUrl(const TCHAR *pchUrl, const TCHAR *pchBaseUrl, BOOL fShowFriendlyUrl,
               BOOL fPreface, LONG x, LONG y)
{
    TCHAR achFriendlyUrl[INTERNET_MAX_URL_LENGTH + 1 + MAX_SUFFIX_LEN + 20] = L""; // 20 is ample extra space
    TCHAR *pchFriendlyUrl = NULL;
    TCHAR achUrl[INTERNET_MAX_URL_LENGTH];
    DWORD cchUrl;

    // Call CoInternetParseUrl from URLMON
    if (S_OK != CoInternetParseUrl(pchUrl, PARSE_ENCODE, 0, achUrl, ARRAY_SIZE(achUrl), &cchUrl, 0))
    {
        long    cch = min(INTERNET_MAX_URL_LENGTH - 1, _tcslen(pchUrl));
        
        _tcsncpy(achUrl, pchUrl, cch);
        achUrl[cch] = 0;
    }

    // Now, only call InternetCrackUrl from WININET only if we truly need to
    // (not the case for local files - fShowFriendlyUrl is not always set)
    if (fShowFriendlyUrl)
    {
        // params for InternetCrackUrl
        URL_COMPONENTS uc;
        TCHAR achScheme[INTERNET_MAX_SCHEME_LENGTH];
        TCHAR achHostName[INTERNET_MAX_HOST_NAME_LENGTH];
        TCHAR achPath[INTERNET_MAX_URL_LENGTH];
        
        memset(&uc, 0, sizeof(uc));
        uc.dwStructSize = sizeof(uc);
        uc.lpszScheme = achScheme;
        uc.dwSchemeLength = ARRAY_SIZE(achScheme);
        uc.lpszHostName = achHostName;
        uc.dwHostNameLength = ARRAY_SIZE(achHostName);
        uc.lpszUrlPath = achPath;
        uc.dwUrlPathLength = ARRAY_SIZE(achPath);

        // CAUTION: this may be the first guy to load WININET. Think twice if you want to use it for a local file.
        if (InternetCrackUrl(achUrl, _tcslen(achUrl), 0, &uc))
        {
            if (!StrCmpIC(achScheme, PROTOCOL_MAILTO))
            {
                // mailto
                Format(FMT_OUT_ALLOC, &pchFriendlyUrl, 0, MAKEINTRESOURCE(IDS_FRIENDLYURL_SENDSMAILTO),
                       &achUrl[1 + _tcslen(PROTOCOL_MAILTO)]);
            }
            else
            {
                // all other protocols
                TCHAR achSuffix[MAX_SUFFIX_LEN];
                BOOL fFriendlyString = TRUE;

                achSuffix[0] = _T('\0');

                if (!StrCmpIC(achScheme, PROTOCOL_FILE))
                {
                    Format(0, achSuffix, ARRAY_SIZE(achSuffix), MAKEINTRESOURCE(IDS_FRIENDLYURL_LOCAL));
                    fFriendlyString = FALSE;
                }
                else if (!StrCmpIC(achScheme, PROTOCOL_GOPHER))
                    Format(0, achSuffix, ARRAY_SIZE(achSuffix), MAKEINTRESOURCE(IDS_FRIENDLYURL_GOPHER));
                else if (!StrCmpIC(achScheme, PROTOCOL_FTP))
                    Format(0, achSuffix, ARRAY_SIZE(achSuffix), MAKEINTRESOURCE(IDS_FRIENDLYURL_FTP));
                else if (!StrCmpIC(achScheme, PROTOCOL_HTTPS))
                    Format(0, achSuffix, ARRAY_SIZE(achSuffix), MAKEINTRESOURCE(IDS_FRIENDLYURL_SECUREWEBSITE));
                else if (StrCmpIC(achScheme, PROTOCOL_HTTP) && StrCmpIC(achScheme, PROTOCOL_NEWS))
                    fFriendlyString = FALSE;
                        
                if (fFriendlyString)
                {
                    // "http://sitename/path/filename.gif" -> "filename.gif at sitename"
                    int length = _tcslen(achPath);
                    TCHAR *pchShortName;
                    BOOL fShowHostName = FALSE;

                    if (length && (achPath[length - 1] == _T('/')))
                        achPath[length - 1] = _T('\0');

                    if (*achHostName)
                    {
                        URL_COMPONENTS ucBase;
                        TCHAR achHostNameBase[INTERNET_MAX_HOST_NAME_LENGTH];

                        memset(&ucBase, 0, sizeof(ucBase));

                        ucBase.dwStructSize = sizeof(ucBase);
                        ucBase.lpszHostName = achHostNameBase;
                        ucBase.dwHostNameLength = ARRAY_SIZE(achHostNameBase);

                        if (    !pchBaseUrl
                            ||  !InternetCrackUrl(pchBaseUrl, _tcslen(pchBaseUrl), 0, &ucBase)
                            ||  _tcsicmp(achHostName, achHostNameBase))
                            fShowHostName = TRUE;
                    }

                    pchShortName = _tcsrchr(achPath, _T('/'));
                    if (fShowHostName && pchShortName && *(pchShortName + 1))
                    {
                        TCHAR achShortName[INTERNET_MAX_URL_LENGTH];

                        achShortName[0] = _T('\0');
                        Concat(achShortName, ARRAY_SIZE(achShortName), pchShortName + 1, x, y);
                        Format(0, achFriendlyUrl, ARRAY_SIZE(achFriendlyUrl),
                               MAKEINTRESOURCE(IDS_FRIENDLYURL_AT), achShortName, achHostName);
                    }
                    else if (pchShortName && *(pchShortName + 1))
                        Concat(achFriendlyUrl, ARRAY_SIZE(achFriendlyUrl), pchShortName + 1, x, y);
                    else if (*achHostName)
                        _tcscat(achFriendlyUrl, achHostName);
                }
                else
                    Concat(achFriendlyUrl, ARRAY_SIZE(achFriendlyUrl), achUrl, x, y);

                if (fPreface)
                    Format(FMT_OUT_ALLOC, &pchFriendlyUrl, 0, MAKEINTRESOURCE(IDS_FRIENDLYURL_SHORTCUTTO),
                           achFriendlyUrl, achSuffix);
                else
                    Format(FMT_OUT_ALLOC, &pchFriendlyUrl, 0, _T("<0s> <1s>"),
                           achFriendlyUrl, achSuffix);
            }

            // NOTE: Format has allocated the memory
            return pchFriendlyUrl;
        }
    }

    // Not need to strip protocols, or InternetCrackUrl failed. Return full URL.
    Concat(achFriendlyUrl, ARRAY_SIZE(achFriendlyUrl), achUrl, x, y);

    // Allocate the return string
    MemAllocString(Mt(GetFriendlyUrl), achFriendlyUrl, &pchFriendlyUrl);

    return pchFriendlyUrl;
}


HRESULT
ExpandUrlWithBaseUrl(LPCTSTR pchBaseUrl, LPCTSTR pchRel, TCHAR ** ppchUrl)
{
    HRESULT hr;
    TCHAR achBuf[pdlUrlLen];
    DWORD cchBuf;
    BOOL fCombine;
    DWORD dwSize;

    *ppchUrl = NULL;

    if (pchRel == NULL) // note: NULL is different from "", which is more similar to "."
    {
        hr = MemAllocString(Mt(ExpandUrlWithBaseUrl), _T(""), ppchUrl);
        goto Cleanup;
    }

    if (!pchRel)
    {
        hr = MemAllocString(Mt(ExpandUrlWithBaseUrl), pchBaseUrl, ppchUrl);
    }
    else
    {
        hr = CoInternetCombineUrl(pchBaseUrl, pchRel, URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE, achBuf, ARRAY_SIZE(achBuf), &cchBuf, 0);
        if (hr)
            goto Cleanup;

        if (S_OK == CoInternetQueryInfo(pchBaseUrl, QUERY_RECOMBINE, 0, &fCombine, sizeof(BOOL), &dwSize, 0)  &&
            fCombine)
        {
            TCHAR achBuf2[pdlUrlLen];
            DWORD cchBuf2;

            hr = CoInternetCombineUrl(pchBaseUrl, achBuf, URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE, achBuf2, ARRAY_SIZE(achBuf2), &cchBuf2, 0);
            if (hr)
                goto Cleanup;

            hr = THR(MemAllocString(Mt(ExpandUrlWithBaseUrl), achBuf2, ppchUrl));
        }
        else
        {
            hr = THR(MemAllocString(Mt(ExpandUrlWithBaseUrl), achBuf, ppchUrl));
        }
    }

Cleanup:
    RRETURN(hr);
}

BOOL
IsUrlOnNet(const TCHAR *pchUrl)
{
    DWORD fOnNet;
    ULONG cb;
    
    switch (GetUrlScheme(pchUrl))
    {
    case URL_SCHEME_FILE:
    case URL_SCHEME_RES:
    case URL_SCHEME_JAVASCRIPT:
    case URL_SCHEME_VBSCRIPT:
        return FALSE;
        break;

    case URL_SCHEME_HTTP:
    case URL_SCHEME_HTTPS:
    case URL_SCHEME_FTP:
        return TRUE;
        break;

    default:
        if (!(CoInternetQueryInfo(pchUrl, QUERY_USES_NETWORK, 0, &fOnNet, sizeof(fOnNet), &cb, 0)) && cb == sizeof(fOnNet))
            return fOnNet;
        return FALSE;
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\chnglog.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CHNGLOG_HXX_
#define X_CHNGLOG_HXX_
#include "chnglog.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_LOGMGR_HXX_
#define X_LOGMGR_HXX_
#include "logmgr.hxx"
#endif


MtDefine(CChangeLog, Tree, "CChangeLog");


CChangeLog::CChangeLog( CLogManager     *   pLogMgr,
                        IHTMLChangeSink *   pChangeSink,
                        CChangeRecord_Placeholder * pPlaceholder)
{
    _pLogMgr        = pLogMgr;
    _pPlaceholder   = pPlaceholder;
    _pChangeSink    = pChangeSink;
    _pChangeSink->AddRef();
}

CChangeLog::~CChangeLog()
{
}

//+----------------------------------------------------------------+
//
//  Method: GetNextChange
//
//  Synopsis: Gets the next Change Record for the client, if the
//      buffer provided was adequate.  Returns the required buffer
//      size, if a pointer is given.
//
//+----------------------------------------------------------------+

STDMETHODIMP
CChangeLog::GetNextChange(
    BYTE * pbBuffer,
    long   nBufferSize,
    long * pnRecordLength )
{
    HRESULT             hr      = S_OK;
    CChangeRecordBase * pchrec;
    long                nLen;
    DWORD               dwFlags = 0;

    // If they say they gave us a buffer, we need a pointer
    if( ( nBufferSize > 0 && !pbBuffer ) || !pnRecordLength )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pchrec = _pPlaceholder->GetNextRecord();

    // No further records
    if( !pchrec )
    {
        *pnRecordLength = 0;

        goto Cleanup;
    }

    nLen = pchrec->RecordLength( _pPlaceholder->_opcode );

    *pnRecordLength = nLen;

    // I think I need a bigger buffer
    if( nBufferSize < nLen )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // Copy the buffer
    memcpy( pbBuffer, &(pchrec->_opcode), nLen );

    // Set the flags appropriately - turn on the bit
    // for what they're not interested in, then AND
    // the inverse of that with the opcode.
    Assert( ( _pPlaceholder->_opcode & CHANGE_RECORD_FORWARD ) || 
            ( _pPlaceholder->_opcode & CHANGE_RECORD_BACKWARD ) );

    if( !( _pPlaceholder->_opcode & CHANGE_RECORD_FORWARD ) )
    {
        dwFlags |= CHANGE_RECORD_FORWARD;
    }
    else if( !( _pPlaceholder->_opcode & CHANGE_RECORD_BACKWARD ) )
    {
        dwFlags |= CHANGE_RECORD_BACKWARD;
    }
    *(DWORD *)pbBuffer &= ~dwFlags;

    // Reposition our placeholder
    _pLogMgr->RemovePlaceholder( _pPlaceholder );
    _pLogMgr->InsertPlaceholderAfterRecord( _pPlaceholder, pchrec );

Cleanup:
    RRETURN1( hr, S_FALSE );
}


//+----------------------------------------------------------------+
//
//  Method: SetDirection
//
//  Synopsis: Allows the client to request which direction of
//      information they're interested in.
//
//+----------------------------------------------------------------+

STDMETHODIMP
CChangeLog::SetDirection( BOOL fForward, BOOL fBackward )
{
    HRESULT hr      = S_OK;

    Assert( _pLogMgr );
    Assert( fForward || fBackward );

    if( !fForward && !fBackward )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    _pPlaceholder->_opcode = CHANGE_RECORD_OPCODE( (DWORD)_pPlaceholder->_opcode & ~CHANGE_RECORD_BOTH );
    if( fForward )
    {
        _pPlaceholder->_opcode = CHANGE_RECORD_OPCODE( (DWORD)_pPlaceholder->_opcode | CHANGE_RECORD_FORWARD );
    }
    if( fBackward )
    {
        _pPlaceholder->_opcode = CHANGE_RECORD_OPCODE( (DWORD)_pPlaceholder->_opcode | CHANGE_RECORD_BACKWARD );
    }

    // Tell the log manager what we're now interested in.
    hr = THR( _pLogMgr->SetDirection( fForward, fBackward ) );

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------+
//
//  Method: NotifySink
//
//  Synopsis: Helper function to notify the sink of available
//      changes
//+----------------------------------------------------------------+

HRESULT
CChangeLog::NotifySink()
{
    HRESULT hr;

    Assert( _pChangeSink );

    hr = THR( _pChangeSink->Notify() );

    RRETURN( hr );
}

//+----------------------------------------------------------------+
//
//  Method: Passivate
//
//  Synopsis: Releases our sink and unregisters us from the log
//      manager
//
//+----------------------------------------------------------------+

void
CChangeLog::Passivate()
{
    _pChangeSink->Release();
    _pLogMgr->Unregister( this );

    super::Passivate();
}

///////////////////////////////////////////
//  CBase methods

const CChangeLog::CLASSDESC CChangeLog::s_classdesc =
{
    NULL,                               // _pclsid
    0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
    0,                                  // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                               // _pcpi
};

const CBase::CLASSDESC *
CChangeLog::GetClassDesc () const
{
    return &s_classdesc;
}

HRESULT
CChangeLog::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS(this, IUnknown)
        QI_INHERITS(this, IHTMLChangeLog)
    }

    if (!*ppv)
        RRETURN( E_NOINTERFACE );

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}




#if DBG==1
//
// Debug ChangeSink for use in testing TreeSync
//

MtDefine(CChangeSink, Tree, "CChangeSink");

CChangeSink::CChangeSink( CLogManager * pLogMgr )
{
    _pLog    = NULL;
    _pLogMgr = pLogMgr;
    _pMarkupSync = NULL;
}

CChangeSink::~CChangeSink()
{
}

void
CChangeSink::Passivate()
{
    if( _pMarkupSync )
    {
        _pMarkupSync->Release();
    }

    super::Passivate();
}


///////////////////////////////////////////
//  CBase methods

const CChangeSink::CLASSDESC CChangeSink::s_classdesc =
{
    NULL,                               // _pclsid
    0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
    0,                                  // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                               // _pcpi
};

const CBase::CLASSDESC *
CChangeSink::GetClassDesc () const
{
    return &s_classdesc;
}

HRESULT
CChangeSink::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS(this, IUnknown)
        QI_INHERITS(this, IHTMLChangeSink)
    }

    if (!*ppv)
        RRETURN( E_NOINTERFACE );

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}


#define DBG_RECORD_ARRAY_SIZE 20
#define DBG_STATIC_RECORD_SIZE 1024
HRESULT
CChangeSink::Notify()
{
    HRESULT hr = S_OK;
    long    nLen;
    long    nIndex = 0, nCurr;
    BYTE    abRecord[DBG_RECORD_ARRAY_SIZE][DBG_STATIC_RECORD_SIZE];
    IHTMLChangePlayback * pHCP = NULL;

    AssertSz( _pLog, "Not set up to be an IHTMLChangeSink" );

    hr = THR( _pLog->GetNextChange( NULL, 0, &nLen ) );
    if( FAILED(hr) || !nLen )
    {
        AssertSz( FALSE, "Notify called with no changes available!" );
        goto Cleanup;
    }


    InitDumpFile();
    WriteString( g_f, _T("\r\n--------------- IHTMLChangeSink Records -------------------\r\n") );

    do
    {
        hr = THR( _pLog->GetNextChange( abRecord[nIndex], DBG_STATIC_RECORD_SIZE, &nLen ) );
        if( FAILED( hr ) )
            goto Cleanup;

        if( nLen > 0 )
            nIndex++;
    }
    while( nLen > 0 && nIndex < DBG_RECORD_ARRAY_SIZE );

    if( _pMarkupSync )
    {
        // Unregister while we do our changes
        AddRef();
        _pLog->Release();
        _pMarkupSync->QueryInterface( IID_IHTMLChangePlayback, (void **)&pHCP );
    }

    for( nCurr = 0; nCurr < nIndex; nCurr++ )
    {
        _pLogMgr->DumpRecord( abRecord[nCurr] );

        if( _pMarkupSync )
        {
            // Replay this stuff forward
            hr = THR( pHCP->ExecChange( abRecord[nCurr], TRUE ) );
            // Replay this stuff backwards
            //hr = THR( _pMarkupSync->ExecChange( abRecord[nIndex - nCurr - 1], FALSE ) );
            if( hr )
                goto Cleanup;
        }
    }

    if( _pMarkupSync )
    {
        hr = THR( _pLogMgr->_pMarkup->CreateChangeLog( this, &_pLog, TRUE, TRUE ) );
        if( hr )
            goto Cleanup;

        Release();
    }

Cleanup:
    ReleaseInterface( pHCP );
    CloseDumpFile();
    RRETURN( hr );
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\ctxmenu.cxx ===
//+---------------------------------------------------------------------
//
//   File:      ctxmenu.cxx
//
//  Contents:   forms kernel command handlers
//
//  Notes:      These commands are exposed at design time only, and then
//              only through context menus. The form kernel has no menu bars
//              of it's own.
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef WIN16
#ifndef X_OLEDLG_H_
#define X_OLEDLG_H_
#include <oledlg.h>
#endif
#endif

#ifndef X_PROPUTIL_HXX_
#define X_PROPUTIL_HXX_
#include "proputil.hxx"      // For font dialog
#endif

//+---------------------------------------------------------------
//
//  Member:     CDoc::EditUndo
//
//  Synopsis:   Manage Undo command
//
//---------------------------------------------------------------

ExternTag(tagUndo);
PerfDbgExtern(tagMarkupUndo);

HRESULT
CDoc::EditUndo()
{
    TraceTag((tagUndo, "CDoc::EditUndo"));

    HRESULT hr = THR(_pUndoMgr->UndoTo(NULL));

    RRETURN(SetErrorInfo(hr)); // TODO more context needed
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::EditRedo
//
//  Synopsis:   Performs a Redo
//
//---------------------------------------------------------------

HRESULT
CDoc::EditRedo()
{
    TraceTag((tagUndo, "CDoc::EditRedo"));

    HRESULT hr = THR(_pUndoMgr->RedoTo(NULL));

    RRETURN(SetErrorInfo(hr)); // TODO more context needed
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\debugwindowguids.c ===
//
// Debug-only guids for interfaces in DebugWindow.idl
//

#if DBG==1 
#include "DebugWindow_i.c"
#endif

;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\csite.cxx ===
//+---------------------------------------------------------------------
//
//   File:      csite.cxx
//
//  Contents:   client-site object for forms kernel
//
//  Classes:    CSite (partial)
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_SELECOBJ_HXX_
#define X_SELECOBJ_HXX_
#include "selecobj.hxx"
#endif

#ifndef X_XBAG_HXX_
#define X_XBAG_HXX_
#include "xbag.hxx"
#endif

#ifndef X_RTFTOHTM_HXX_
#define X_RTFTOHTM_HXX_
#include "rtftohtm.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_FILTCOL_HXX_
#define X_FILTCOL_HXX_
#include "filtcol.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"       // table layout
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_OLEDLG_H_
#define X_OLEDLG_H_
#include <oledlg.h>
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_OCMM_H_
#define X_OCMM_H_
#include "ocmm.h"
#endif

#ifndef X_OLEDBERR_H_
#define X_OLEDBERR_H_
#include <oledberr.h>                   // for DB_E_DELETEDROW
#endif

#ifndef X_DISPDEFS_HXX_
#define X_DISPDEFS_HXX_
#include "dispdefs.hxx"
#endif

#ifndef X_DISPGDI16BIT_HXX_
#define X_DISPGDI16BIT_HXX_
#include "dispgdi16bit.hxx"
#endif

#ifndef X_FLOAT2INT_HXX_
#define X_FLOAT2INT_HXX_
#include "float2int.hxx"
#endif

#define _cxx_
#include "csite.hdl"

ExternTag(tagFormP);
ExternTag(tagMsoCommandTarget);
PerfDbgExtern(tagDocPaint)
DeclareTag(tagLayout, "Layout", "Trace SetPosition/RequestLayout");
DeclareTag(tagLayoutNoShort, "LayoutNoShort", "Prevent RequestLayout short-circuit");
DeclareTag(tagDrawBorder, "DrawBorder", "Trace DrawBorder information");

extern "C" const IID IID_IControl;

#define DRAWBORDER_OUTER    0
#define DRAWBORDER_SPACE    1
#define DRAWBORDER_INNER    2
#define DRAWBORDER_TOTAL    3
#define DRAWBORDER_INCRE    4
#define DRAWBORDER_LAST     5

CBorderInfo g_biDefault(0, 0);

void
CBorderInfo::InitFull()
{
    memset( this, 0, sizeof(CBorderInfo) );
    
    // Have to set up some default widths.
    CUnitValue cuv;
    cuv.SetValue( 4 /*MEDIUM*/, CUnitValue::UNIT_PIXELS );
    aiWidths[SIDE_TOP] = aiWidths[SIDE_BOTTOM] = cuv.GetPixelValue ( NULL, CUnitValue::DIRECTION_CY, 0, 0 );
    aiWidths[SIDE_RIGHT] = aiWidths[SIDE_LEFT] = cuv.GetPixelValue ( NULL, CUnitValue::DIRECTION_CX, 0, 0 );
}

//+---------------------------------------------------------------------------
//
//  Function:   CompareElementsByZIndex
//
//  Synopsis:   Comparison function used by qsort to compare the zIndex of
//              two elements.
//
//----------------------------------------------------------------------------

#define ELEMENT1_ONTOP 1
#define ELEMENT2_ONTOP -1
#define ELEMENTS_EQUAL 0

int RTCCONV
CompareElementsByZIndex ( const void * pv1, const void * pv2 )
{
    int        i, z1, z2;
    HWND       hwnd1, hwnd2;

    CElement * pElement1 = * (CElement **) pv1;
    CElement * pElement2 = * (CElement **) pv2;

    //
    // Only compare elements which have the same ZParent
    // TODO:   For now, since table elements (e.g., TDs, TRs, CAPTIONs) cannot be
    //         positioned, it is Ok if they all end up in the same list - even if
    //         their ZParent-age is different.
    //         THIS MUST BE RE-VISITED ONCE WE SUPPORT POSITIONING ON TABLE ELEMENTS.
    //         (brendand)
    //
    Assert(     pElement1->GetFirstBranch()->ZParent() == pElement2->GetFirstBranch()->ZParent()
           ||   (   pElement1->GetFirstBranch()->ZParent()->Tag() == ETAG_TR
                &&  pElement2->GetFirstBranch()->ZParent()->Tag() == ETAG_TR)
           ||   (   pElement1->GetFirstBranch()->ZParent()->Tag() == ETAG_TABLE
                &&  pElement2->GetFirstBranch()->ZParent()->Tag() == ETAG_TR)
           ||   (   pElement2->GetFirstBranch()->ZParent()->Tag() == ETAG_TABLE
                &&  pElement1->GetFirstBranch()->ZParent()->Tag() == ETAG_TR));

    // Sites with windows are _always_ above sites without windows.

    hwnd1 = pElement1->GetHwnd();
    hwnd2 = pElement2->GetHwnd();

    if ((hwnd1 == NULL) != (hwnd2 == NULL))
    {
        return (hwnd1 != NULL) ? ELEMENT1_ONTOP : ELEMENT2_ONTOP;
    }

    //
    // If one element contains the other, then the containee is on top.
    //
    // Since table cells cannot be positioned, we ignore any case where
    // something is contained inside a table cell. That way they essentially
    // become 'peers' of the cells and can be positioned above or below them.
    //
    if (pElement1->Tag() != ETAG_TD && pElement2->Tag() != ETAG_TD &&   // Cell
        pElement1->Tag() != ETAG_TH && pElement2->Tag() != ETAG_TH &&   // Header
        pElement1->Tag() != ETAG_TC && pElement2->Tag() != ETAG_TC)     // Caption
    {
        if (pElement1->GetFirstBranch()->SearchBranchToRootForScope(pElement2))
        {
            return ELEMENT1_ONTOP;
        }

        if (pElement2->GetFirstBranch()->SearchBranchToRootForScope(pElement1))
        {
            return ELEMENT2_ONTOP;
        }
    }

    //
    // Only pay attention to the z-index attribute if the element is positioned
    //
    // The higher z-index is on top, which means the higher z-index value
    // is "greater".
    //

    z1 = !pElement1->IsPositionStatic()
              ? pElement1->GetFirstBranch()->GetCascadedzIndex()
              : 0;

    z2 = !pElement2->IsPositionStatic()
              ? pElement2->GetFirstBranch()->GetCascadedzIndex()
              : 0;

    i = z1 - z2;

    if (i == ELEMENTS_EQUAL &&
        pElement1->IsPositionStatic() != pElement2->IsPositionStatic())
    {
        //
        // The non-static element has a z-index of 0, so we must make
        // sure it stays above anything in the flow (static).
        //
        i = (!pElement1->IsPositionStatic()) ? ELEMENT1_ONTOP : ELEMENT2_ONTOP;
    }

    //
    // Make sure that the source indices are up to date before accessing them
    //

    Assert( pElement1->Doc() == pElement2->Doc() );

    //
    // If the zindex is the same, then sort by source order.
    //
    // Later in the source is on top, which means the higher source-index
    // value is "greater".
    //

    if (i == ELEMENTS_EQUAL)
    {
        i = pElement1->GetSourceIndex() - pElement2->GetSourceIndex();
    }

    // Different elements should never be exactly equal.
    //
    // If this assert fires it's likely due to the element collection not
    // having been built yet.
    //

    Assert( i != ELEMENTS_EQUAL || pElement1 == pElement2 );

    return i;
}

//+---------------------------------------------------------------
//
//  Member:     CSite::CSite
//
//  Synopsis:   Normal constructor.
//
//  Arguments:  pParent  Site that's our parent
//
//---------------------------------------------------------------

CSite::CSite(ELEMENT_TAG etag, CDoc *pDoc)
    : CElement(etag, pDoc)
{
    TraceTag((tagCDoc, "constructing CSite"));

#ifdef WIN16
    m_baseOffset = ((BYTE *) (void *) (CBase *)this) - ((BYTE *) this);
    m_ElementOffset = ((BYTE *) (void *) (CElement *)this) - ((BYTE *) this);
#endif

    // We only need to initialize non-zero state because of our redefinition
    // of operator new.
}

    
//+---------------------------------------------------------------
//
//  Member:     CSite::Init
//
//  Synopsis:   Do any element initialization here, called after the element is
//              created from CreateElement()
//
//---------------------------------------------------------------

HRESULT
CSite::Init()
{
    HRESULT hr;

    hr = THR( super::Init() );

    if (hr)
        goto Cleanup;

    //  Explicitly set this here *after* the superclass' constructor, which would set it to false.
    _fLayoutAlwaysValid = TRUE;

Cleanup:

    RRETURN( hr );
}


//+------------------------------------------------------------------------
//
//  Member:     CSite::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CSite::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    // IE4 shipped the interface IHTMLControlElement with the same GUID as
    // IControl.  Unfortunately, IControl is a forms^3 interface, which is bad.
    // To resolve this problem Trident's GUID for IHTMLControlElement has
    // changed however, the old GUID remembered in the QI for CSite to return
    // IHTMLControlElement.  The only side affect is that using the old GUID
    // will not marshall the interface correctly only the new GUID has the
    // correct marshalling code.  So, the solution is that QI'ing for
    // IID_IControl or IID_IHTMLControlElement will return IHTMLControlElement.

    // For VB page designer we need to emulate IE4 behavior (fail the QI if not a site)
    if(iid == IID_IControl && Doc()->_fVB && !ShouldHaveLayout())
        RRETURN(E_NOINTERFACE);

    if (iid == IID_IHTMLControlElement || iid == IID_IControl)
    {
        hr = CreateTearOffThunk(this,
                                s_apfnpdIHTMLControlElement,
                                NULL,
                                ppv,
                                (void *)s_ppropdescsInVtblOrderIHTMLControlElement);
        if (hr)
            RRETURN(hr);
    }
    else
    {
        RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}

void
GetBorderColorInfoHelper(
    const CCharFormat *      pCF,
    const CFancyFormat *     pFF,
    const CBorderDefinition *pbd,
    CDocInfo *      pdci,
    CBorderInfo *   pborderinfo,
    BOOL fAllPhysical)
{
    BYTE i;
    COLORREF clr, clrHilight, clrLight, clrDark, clrShadow;

    for ( i=0; i<SIDE_MAX ; i++ )
    {
        BOOL  fNeedSysColor = FALSE;
        // Get the base color
        const CColorValue & ccv = pbd->GetLogicalBorderColor(i, !fAllPhysical && pCF->HasVerticalLayoutFlow(), 
                                                             fAllPhysical || pCF->_fWritingModeUsed, pFF);
        if ( !ccv.IsDefined() )
        {
            clr = pCF->_ccvTextColor.GetColorRef();
            fNeedSysColor = TRUE;
        }
        else
            clr = ccv.GetColorRef();

        clrLight = clr;

        // Set up the inner and outer colors
        switch ( pborderinfo->abStyles[i] )
        {
        case fmBorderStyleNone:
        case fmBorderStyleDouble:
        case fmBorderStyleSingle:
        case fmBorderStyleDotted:
        case fmBorderStyleDashed:
            pborderinfo->acrColors[i][0] =
            pborderinfo->acrColors[i][2] = clr;
            // Don't need inner/outer colors
            break;

        default:
            {
                // Set up the color variations
                if ( pbd->_ccvBorderColorHilight.IsDefined() && !ISBORDERSIDECLRSETUNIQUE( pbd, i ) )
                    clrHilight = pbd->_ccvBorderColorHilight.GetColorRef();
                else
                {
                    if (fNeedSysColor)
                    {
                        clrHilight = GetSysColorQuick(COLOR_BTNHIGHLIGHT);
                    }
                    else
                        clrHilight = clr;
                }
                if ( pbd->_ccvBorderColorDark.IsDefined() && !ISBORDERSIDECLRSETUNIQUE( pbd, i ) )
                    clrDark = pbd->_ccvBorderColorDark.GetColorRef();
                else
                {
                    if (fNeedSysColor)
                    {
                        clrDark = GetSysColorQuick(COLOR_3DDKSHADOW);
                    }
                    else
                        clrDark = ( clr & 0xff000000 ) |
                                  ( ( (clr & 0xff0000)>>1 ) & 0xff0000 ) |
                                  ( ( (clr & 0x00ff00)>>1 ) & 0x00ff00 ) |
                                  ( ( (clr & 0x0000ff)>>1 ) & 0x0000ff );
                }
                if ( pbd->_ccvBorderColorShadow.IsDefined() && !ISBORDERSIDECLRSETUNIQUE( pbd, i ) )
                    clrShadow = pbd->_ccvBorderColorShadow.GetColorRef();
                else
                {
                    if (fNeedSysColor)
                    {
                        clrShadow = GetSysColorQuick(COLOR_BTNSHADOW);
                    }
                    else
                        clrShadow = ( clr & 0xff000000 ) |
                                    ( ( (clr & 0xff0000)>>2 ) & 0xff0000 ) |
                                    ( ( (clr & 0x00ff00)>>2 ) & 0x00ff00 ) |
                                    ( ( (clr & 0x0000ff)>>2 ) & 0x0000ff );
                }

                // If the Light color isn't set synthesise a light color 3/4 of clr
                if ( pbd->_ccvBorderColorLight.IsDefined() && !ISBORDERSIDECLRSETUNIQUE( pbd, i ) )
                    clrLight = pbd->_ccvBorderColorLight.GetColorRef();
                else
                {
                    if (fNeedSysColor)
                    {
                        clrLight = GetSysColorQuick(COLOR_BTNFACE);
                    }
                    else
                        clrLight = clrShadow + clrDark;
                }

                if (i==SIDE_TOP || i==SIDE_LEFT)
                {   // Top/left edges
                    if ( pbd->_bBorderSoftEdges || (pborderinfo->wEdges & BF_SOFT))
                    {
                        switch ( pborderinfo->abStyles[i] )
                        {
                        case fmBorderStyleRaisedMono:
                            pborderinfo->acrColors[i][0] =
                            pborderinfo->acrColors[i][2] = clrHilight;
                            break;
                        case fmBorderStyleSunkenMono:
                            pborderinfo->acrColors[i][0] =
                            pborderinfo->acrColors[i][2] = clrDark;
                            break;
                        case fmBorderStyleRaised:
                            pborderinfo->acrColors[i][0] = clrHilight;
                            pborderinfo->acrColors[i][2] = clrLight;
                            break;
                        case fmBorderStyleSunken:
                        case fmBorderStyleWindowInset:
                            pborderinfo->acrColors[i][0] = clrDark;
                            pborderinfo->acrColors[i][2] = clrShadow;
                            break;
                        case fmBorderStyleEtched:
                            pborderinfo->acrColors[i][0] = clrDark;
                            pborderinfo->acrColors[i][2] = clrLight;
                            break;
                        case fmBorderStyleBump:
                            pborderinfo->acrColors[i][0] = clrHilight;
                            pborderinfo->acrColors[i][2] = clrShadow;
                            break;
                        }
                    }
                    else
                    {
                        switch ( pborderinfo->abStyles[i] )
                        {
                        case fmBorderStyleRaisedMono:
                            pborderinfo->acrColors[i][0] =
                            pborderinfo->acrColors[i][2] = clrLight;
                            break;
                        case fmBorderStyleSunkenMono:
                            pborderinfo->acrColors[i][0] =
                            pborderinfo->acrColors[i][2] = clrShadow;
                            break;
                        case fmBorderStyleRaised:
                            pborderinfo->acrColors[i][0] = clrLight;
                            pborderinfo->acrColors[i][2] = clrHilight;
                            break;
                        case fmBorderStyleSunken:
                        case fmBorderStyleWindowInset:
                            pborderinfo->acrColors[i][0] = clrShadow;
                            pborderinfo->acrColors[i][2] = clrDark;
                            break;
                        case fmBorderStyleEtched:
                            pborderinfo->acrColors[i][0] = clrShadow;
                            pborderinfo->acrColors[i][2] = clrHilight;
                            break;
                        case fmBorderStyleBump:
                            pborderinfo->acrColors[i][0] = clrLight;
                            pborderinfo->acrColors[i][2] = clrDark;
                            break;
                        }
                    }
                }
                else
                {   // Bottom/right edges
                    switch ( pborderinfo->abStyles[i] )
                    {
                    case fmBorderStyleRaisedMono:
                        pborderinfo->acrColors[i][0] =
                        pborderinfo->acrColors[i][2] = clrDark;
                        break;
                    case fmBorderStyleSunkenMono:
                        pborderinfo->acrColors[i][0] =
                        pborderinfo->acrColors[i][2] = clrHilight;
                        break;
                    case fmBorderStyleRaised:
                        pborderinfo->acrColors[i][0] = clrDark;
                        pborderinfo->acrColors[i][2] = clrShadow;
                        break;
                    case fmBorderStyleSunken:
                    case fmBorderStyleWindowInset:
                        pborderinfo->acrColors[i][0] = clrHilight;
                        pborderinfo->acrColors[i][2] = clrLight;
                        break;
                    case fmBorderStyleEtched:
                        pborderinfo->acrColors[i][0] = clrHilight;
                        pborderinfo->acrColors[i][2] = clrShadow;
                        break;
                    case fmBorderStyleBump:
                        pborderinfo->acrColors[i][0] = clrDark;
                        pborderinfo->acrColors[i][2] = clrLight;
                        break;
                    }
                }
            }
        }

        // Set up the flat color
        if (pborderinfo->abStyles[i] == fmBorderStyleWindowInset)
        {
            pborderinfo->acrColors[i][1] = clrLight;
        }
        else
        {
            pborderinfo->acrColors[i][1] = clr;
        }
    }

    if ( pbd->_bBorderSoftEdges )
        pborderinfo->wEdges |= BF_SOFT;
}

//+------------------------------------------------------------------------
//
//  GetBorderInfoHelper
//
//  Returns border info for a node.
//  DocInfo can be NULL.  If it is not, the returned values will be transformed
//  into document sizes.  
//  The CBorderInfo can be seeded with default values.  If the format caches
//  have nothing set to override them, they will be maintained.  Default values
//  will be scaled if a CDocInfo is passed.
//
//-------------------------------------------------------------------------

DWORD
GetBorderInfoHelper(
    CTreeNode *     pNodeContext,
    CDocInfo *      pdci,
    CBorderInfo *   pborderinfo,
    DWORD           dwFlags /* = GBIH_NONE */
    FCCOMMA FORMAT_CONTEXT FCPARAM )
{
    Assert( pNodeContext);
    const CFancyFormat *pFF = pNodeContext->GetFancyFormat(FCPARAM);
    const CCharFormat  *pCF = pNodeContext->GetCharFormat(FCPARAM);
    Assert( pFF && pCF );

    return GetBorderInfoHelperEx(pFF, pCF, pdci, pborderinfo, dwFlags);
}

DWORD
GetBorderInfoHelperEx(
    const CFancyFormat *  pFF, 
    const CCharFormat *   pCF, 
    CDocInfo *      pdci,
    CBorderInfo *   pborderinfo,
    DWORD           dwFlags /* = GBIH_NONE */)
{
    Assert(pborderinfo);
    Assert( pFF && pCF );

    BYTE  i;
    int   iBorderWidth = 0;

    BOOL  fAll    = (dwFlags & GBIH_ALL) ? TRUE : FALSE;
    BOOL  fPseudo = (dwFlags & GBIH_PSEUDO) ? TRUE : FALSE;
    BOOL  fAllPhysical = (dwFlags & GBIH_ALLPHY) ? TRUE : FALSE;
    BOOL  fWindowInset = FALSE;
    BOOL  fVertical = !fAllPhysical && pCF->HasVerticalLayoutFlow();
    BOOL  fWritingModeUsed = fAllPhysical || pCF->_fWritingModeUsed;
    const CBorderDefinition *pbd;
    int   iMaxBorder = pdci ? 10 * pdci->GetResolution().cx : MAX_BORDER_SPACE;
    
    if (fPseudo)
    {
        const CPseudoElementInfo *pPEI;
        Assert(pFF->_iPEI >= 0);
        pPEI = GetPseudoElementInfoEx(pFF->_iPEI);
        Assert(pPEI);
        pbd = &pPEI->_bd;
    }
    else
        pbd = &pFF->_bd;
    
    Assert( pCF );

    for (i = 0; i < SIDE_MAX; i++)
    {
        BYTE bBorderStyle = pbd->GetLogicalBorderStyle(i, fVertical, fWritingModeUsed, pFF);
        if (bBorderStyle != (BYTE)-1)
            pborderinfo->abStyles[i] = bBorderStyle;

        if (pborderinfo->abStyles[i] == fmBorderStyleWindowInset)
        {
            fWindowInset = TRUE;
        }

        if ( !pborderinfo->abStyles[i] )
        {
            pborderinfo->aiWidths[i] = 0;
            continue;
        }

        const CUnitValue & cuvBorderWidth = pbd->GetLogicalBorderWidth(i, fVertical, fWritingModeUsed, pFF);
        switch (cuvBorderWidth.GetUnitType())
        {
        case CUnitValue::UNIT_NULLVALUE:
            //  Scale any default value we were passed.
            if (pdci)
            {
                if ((i == SIDE_TOP) || (i == SIDE_BOTTOM))
                {
                    pborderinfo->aiWidths[i] = pdci->DeviceFromDocPixelsY(pborderinfo->aiWidths[i]);
                }
                else    // SIDE_RIGHT or SIDE_LEFT
                {
                    pborderinfo->aiWidths[i] = pdci->DeviceFromDocPixelsX(pborderinfo->aiWidths[i]);
                }
            }
            continue;
        case CUnitValue::UNIT_ENUM:
            {   // Pick up the default border width here.
                CUnitValue cuv;
                cuv.SetValue((cuvBorderWidth.GetUnitValue() + 1) * 2, CUnitValue::UNIT_PIXELS);
                iBorderWidth = cuv.GetPixelValue(pdci,
                                                ((i==SIDE_TOP)||(i==SIDE_BOTTOM))
                                                        ? CUnitValue::DIRECTION_CY
                                                        : CUnitValue::DIRECTION_CX,
                                                0, pCF->_yHeight);
            }
            break;
        default:
            iBorderWidth = cuvBorderWidth.GetPixelValue(pdci,
                                                        ((i==SIDE_TOP)||(i==SIDE_BOTTOM))
                                                            ? CUnitValue::DIRECTION_CY
                                                            : CUnitValue::DIRECTION_CX,
                                                        0, pCF->_yHeight);

            // If user sets tiny borderwidth, set smallest width possible (1px) instead of zero (IE5,5865).
            if (!iBorderWidth && cuvBorderWidth.GetUnitValue() > 0)
                iBorderWidth = 1;
        }
        if (iBorderWidth >= 0)
        {
            pborderinfo->aiWidths[i] = iBorderWidth < iMaxBorder ? iBorderWidth : iMaxBorder;
        }
    }

    if (fWindowInset)
    {
        pborderinfo->xyFlat = -1;
    }

    // Now pick up the edges if we set the border-style for that edge to "none"
    pborderinfo->wEdges &= ~BF_RECT;

    if ( pborderinfo->aiWidths[SIDE_TOP] )
        pborderinfo->wEdges |= BF_TOP;
    if ( pborderinfo->aiWidths[SIDE_RIGHT] )
        pborderinfo->wEdges |= BF_RIGHT;
    if ( pborderinfo->aiWidths[SIDE_BOTTOM] )
        pborderinfo->wEdges |= BF_BOTTOM;
    if ( pborderinfo->aiWidths[SIDE_LEFT] )
        pborderinfo->wEdges |= BF_LEFT;

    if ( fAll )
    {
        GetBorderColorInfoHelper(pCF, pFF, pbd, pdci, pborderinfo, fAllPhysical);

    }

    if ( pborderinfo->wEdges )
    {
        return (    pborderinfo->wEdges & BF_RECT
                &&  pborderinfo->aiWidths[SIDE_TOP]  == pborderinfo->aiWidths[SIDE_BOTTOM]
                &&  pborderinfo->aiWidths[SIDE_LEFT] == pborderinfo->aiWidths[SIDE_RIGHT]
                &&  pborderinfo->aiWidths[SIDE_TOP]  == pborderinfo->aiWidths[SIDE_LEFT]
                        ? DISPNODEBORDER_SIMPLE
                        : DISPNODEBORDER_COMPLEX);
    }
    return DISPNODEBORDER_NONE;
}

//+-------------------------------------------------------------------------
//
//  Function:   IsSimpleBorder
//
//  Synopsis:   This routine makes necessary check to determine if we can
//              use a pen and LineTo() calls to draw the border, instead
//              of calling the generic DrawBorder code. This is done for
//              performance considerations only.
//              Return value is FALSE if the border cannot be handled by the
//              simplified drawing function.
//--------------------------------------------------------------------------
#if DBG != 1
inline
#endif
BOOL
IsSimpleBorder(const CBorderInfo *pborderinfo)
{
    //  Check to see if we are a "simple" border.
    if ( 
        //  All borders must be one pixel wide.
       ((   pborderinfo->aiWidths[SIDE_TOP]
         |  pborderinfo->aiWidths[SIDE_LEFT]
         |  pborderinfo->aiWidths[SIDE_BOTTOM]
         | pborderinfo->aiWidths[SIDE_RIGHT])
         &  ~1)
        //  Can't be drawing a caption.
         ||  (pborderinfo->sizeCaption.cx || pborderinfo->sizeCaption.cy)
        //  xyFlat should be 0    
         ||  (pborderinfo->xyFlat) )
    {
        return FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   DrawSimpleBorder
//
//  Synopsis:   This routine draws the border in the case when conditions
//              in IsSimpleBorder are TRUE
//
//--------------------------------------------------------------------------

// BF_DRAW being one enables one less addition in the code below.
#define BF_DRAW         1
#define BF_NEEDTODRAW   2

#if DBG != 1
inline
#endif
void
DrawSimpleBorder(const XHDC hdc, const CBorderInfo *pborderinfo, RECT rc, const RECT &rcClip)
{
    //  This circumstance can currently cause a bug in the clipping algorithm below.
    //  I want to be aware of issues that may cause this circumstance to see whether
    //  this needs to handle a nonintersecting clip and draw rect. (greglett)
    if (!((CRect)rc).FastIntersects(rcClip))
        return;

    int         i;
    HPEN        hPen = 0;
    HPEN        hPenOriginal = 0;
    COLORREF    colorCurrent = 0;
    BOOL        fOldMarkerEdge = FALSE;
    int         fEdges[SIDE_MAX];
    // With fEdges, we need to be able to track whether an edge:
    // 1.  Shouldn't be drawn (0)
    // 2.  Should be drawn, and hasn't been yet (NEEDTODRAW)
    // 3.  Was or will be drawn                 (DRAW)
    // NEEDTODRAW is potentially important for the LEFT & BOTTOM borders, as
    // they can be drawn by their paired borders.
    // DRAW allows borders to determine whether or not they should be responsible for corners.    
    memset(fEdges, 0, sizeof(fEdges));

    AssertSz(IsSimpleBorder(pborderinfo), "DrawSimpleBoorder is called for a border type that cannot handled");

    // Do the manual clipping (this is needed for Win9x to work) 
    if (rc.top < rcClip.top)
        rc.top = rcClip.top;
    else if (pborderinfo->wEdges & BF_TOP)
        fEdges[SIDE_TOP] = BF_NEEDTODRAW | BF_DRAW;

    if (rc.left < rcClip.left)
        rc.left = rcClip.left;
    else if (pborderinfo->wEdges & BF_LEFT)
        fEdges[SIDE_LEFT] = BF_NEEDTODRAW | BF_DRAW;

    if (rc.bottom > rcClip.bottom)
        rc.bottom = rcClip.bottom;
    else if (pborderinfo->wEdges & BF_BOTTOM)
        fEdges[SIDE_BOTTOM] = BF_NEEDTODRAW | BF_DRAW;

    if (rc.right > rcClip.right)
        rc.right = rcClip.right;
    else if (pborderinfo->wEdges & BF_RIGHT)
        fEdges[SIDE_RIGHT] = BF_NEEDTODRAW | BF_DRAW;

    // We have to do -1 because RC is for Rectangle call that does not
    // paint the bottom and the right
    rc.bottom--;
    rc.right--;

    for (i = 0; i < SIDE_MAX; i++)
    {   
        if (!(fEdges[i] & BF_NEEDTODRAW))
            continue;

        if (!hPen)
        {
            colorCurrent = pborderinfo->acrColors[i][DRAWBORDER_OUTER];
            fOldMarkerEdge = pborderinfo->IsMarkerEdge(i);
            hPen = pborderinfo->IsMarkerEdge(i)
                ?   (HPEN)CreatePen(PS_DOT, 0, colorCurrent)
                :   (HPEN)CreatePen(PS_SOLID, 0, colorCurrent);
            hPenOriginal = (HPEN)SelectObject(hdc, hPen);
        }
        else if (    colorCurrent != pborderinfo->acrColors[i][DRAWBORDER_OUTER]
                ||  fOldMarkerEdge != pborderinfo->IsMarkerEdge(i))
        {
            HPEN hPenOld = hPen;
            colorCurrent = pborderinfo->acrColors[i][DRAWBORDER_OUTER];
            fOldMarkerEdge = pborderinfo->IsMarkerEdge(i);
            hPen = pborderinfo->IsMarkerEdge(i)
                ?   (HPEN)CreatePen(PS_DOT, 0, colorCurrent)
                :   (HPEN)CreatePen(PS_SOLID, 0, colorCurrent);
            SelectObject(hdc, hPen);
            DeleteObject(hPenOld);
        }
        switch (i)
        {
        case SIDE_TOP:
            //  The TR pixel will be overwritten by a right border, if one exists.
            MoveToEx(hdc, rc.right, rc.top, NULL);
            // A small optimization that allows us to skip a new pen and MoveTo 
            //  (and also saves us  about 2% in perf for a typical table)
            if (    !fEdges[SIDE_LEFT]
                ||  colorCurrent != pborderinfo->acrColors[SIDE_LEFT][DRAWBORDER_OUTER]
                ||  fOldMarkerEdge != pborderinfo->IsMarkerEdge(SIDE_LEFT) )
            {
                LineTo(hdc, rc.left - 1, rc.top);
                break;
            }
            LineTo(hdc, rc.left, rc.top);
            //  The BL pixel will be overwritten by a bottom border, if one exists.
            LineTo(hdc, rc.left, rc.bottom + 1);
            // We already painted the left border, so reset the flag
            fEdges[SIDE_LEFT] &= ~BF_NEEDTODRAW;
            break;
        case SIDE_LEFT:
            //  Should the left border take responsibility for the first pixel?
            //  Only if no top border has been drawn
            MoveToEx(hdc, rc.left, rc.top + (fEdges[SIDE_TOP] & BF_DRAW), NULL);
            //  Should the left border take responsibility for the last pixel?
            //  Only if no bottom border has been drawn
            //  NB: BF_DRAW needs to be defined as 1 for this to work.
            LineTo(hdc, rc.left, rc.bottom + (~fEdges[SIDE_BOTTOM] & BF_DRAW));
            break;
        case SIDE_RIGHT:
            MoveToEx(hdc, rc.right, rc.top, NULL);
            // A small optimization that allows us to skip a new pen and MoveTo 
            //  (and also saves us  about 2% in perf for a typical table)
            if (    !fEdges[SIDE_BOTTOM] 
                ||  colorCurrent != pborderinfo->acrColors[SIDE_BOTTOM][DRAWBORDER_OUTER]
                ||  fOldMarkerEdge != pborderinfo->IsMarkerEdge(SIDE_BOTTOM))
            {
                LineTo(hdc, rc.right, rc.bottom + 1);
                break;
            }
            LineTo(hdc, rc.right, rc.bottom);
            LineTo(hdc, rc.left - 1, rc.bottom);
            fEdges[SIDE_BOTTOM] &= ~BF_NEEDTODRAW;
            break;
        case SIDE_BOTTOM:
            //  Should the bottom border take responsibility for the first pixel?
            //  Only if no right border has been drawn
            MoveToEx(hdc, rc.right - (fEdges[SIDE_RIGHT] & BF_DRAW), rc.bottom, NULL);
            LineTo(hdc, rc.left - 1, rc.bottom);
            break;
        }            
    }
    if (hPen)
    {
        SelectObject(hdc, hPenOriginal);
        DeleteObject(hPen);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   DrawBorder
//
//  Synopsis:   This routine is functionally equivalent to the Win95
//              DrawEdge API
//  xyFlat:     positive means, we draw flat inside, outside if negative
//
//--------------------------------------------------------------------------

void DrawBorder(CFormDrawInfo *pDI,
        LPRECT lprc,
        CBorderInfo *pborderinfo)
{   
    Assert(pborderinfo);
    Assert(lprc->left <= lprc->right);
    Assert(lprc->top <= lprc->bottom);    
    
    TraceTagEx((tagDrawBorder, TAG_NONAME,
           "DrawBorder : DrawRect[(%d, %d),(%d, %d)]",
           lprc->left, lprc->top, lprc->right, lprc->bottom));

    TraceTagEx((tagDrawBorder, TAG_NONAME,
           "DrawBorder : wEdges[(L%d, T%d, R%d, B%d)]",
           pborderinfo->wEdges & BF_LEFT,
           pborderinfo->wEdges & BF_TOP,
           pborderinfo->wEdges & BF_RIGHT,
           pborderinfo->wEdges & BF_BOTTOM));

    XHDC        hdc(pDI->GetDC(*lprc));

    // 
    BOOL    fNoZoomOrComplexRotation = hdc.IsOffsetOnly() 
                                    || hdc.HasTrivialRotation() && hdc.HasNoScale();
    
    // This simplified case handles the most comonly used border types
    // Note that for 90 degree rotation we don't want to use the simplified border code
    // (not because the border is not simple enough, just because the simple border 
    // code doesn't work right with rotation).
    if (IsSimpleBorder(pborderinfo) && hdc.IsOffsetOnly())
    {
        DrawSimpleBorder(hdc, pborderinfo, *lprc, pDI->_rcClip);
        return;
    }
    
    RECT        rc;
    RECT        rcSave; // Original rectangle, maybe adjusted for flat border.
    RECT        rcOrig; // Original rectangle of the element container.
    HBRUSH      hbrOld = NULL;
    COLORREF    crNow = COLORREF_NONE;
    COLORREF    crNew;
    HPEN        hPen;
    HPEN        hPenDotDash = NULL;
    // Ordering of the next 2 arrays are top,right,bottom,left.
    BYTE        abCanUseJoin[SIDE_MAX];
    int         aiNumBorderLines[SIDE_MAX];
    int         aiLineWidths[SIDE_MAX][DRAWBORDER_LAST];     // outer, spacer, inner
    UINT        wEdges = 0;
    int         i,j;
    POINT       polygon[8];
    BOOL        fdrawCaption = pborderinfo->sizeCaption.cx || pborderinfo->sizeCaption.cy;
    BOOL        fContinuingPoly;
    SIZE        sizeLegend;
    SIZE        sizeRect;
    POINT       ptBrushOrg;
    BOOL        afMarkerBorder[SIDE_MAX];

    memset(afMarkerBorder, 0, sizeof(BOOL) * SIDE_MAX);
    memset(aiLineWidths, 0, sizeof(int) * SIDE_MAX * DRAWBORDER_LAST);

    rc = *lprc;
    rc.top += pborderinfo->offsetCaption;

    rcOrig = rc;

    if (pborderinfo->xyFlat < 0)
    {
        InflateRect(&rc, pborderinfo->xyFlat, pborderinfo->xyFlat);
    }

    rcSave = rc;

    // save legend size
    sizeLegend = pborderinfo->sizeCaption;

    hPen = (HPEN)GetStockObject(NULL_PEN);
    int xyFlat = abs(pborderinfo->xyFlat);

    SelectObject(hdc, hPen);

    // If we are to draw the edge, initialize its net border width into the DRAWBORDER_OUTER.
    // If not, leave the width zero so that adjacent borders don't make bevelling mistakes.
    // Because the BF_X and SIDE_X are not aligned, and neither can be realigned due to other places
    // using them, we have to do these checks spread out instead of in a loop.
    if (pborderinfo->wEdges & BF_LEFT)
        aiLineWidths[SIDE_LEFT][DRAWBORDER_OUTER] = pborderinfo->aiWidths[SIDE_LEFT] - xyFlat;
    if (pborderinfo->wEdges & BF_RIGHT)
        aiLineWidths[SIDE_RIGHT][DRAWBORDER_OUTER] = pborderinfo->aiWidths[SIDE_RIGHT] - xyFlat;
    if (pborderinfo->wEdges & BF_TOP)
        aiLineWidths[SIDE_TOP][DRAWBORDER_OUTER] = pborderinfo->aiWidths[SIDE_TOP] - xyFlat;
    if (pborderinfo->wEdges & BF_BOTTOM)
        aiLineWidths[SIDE_BOTTOM][DRAWBORDER_OUTER] = pborderinfo->aiWidths[SIDE_BOTTOM] - xyFlat;

    sizeRect.cx = rc.right - rc.left;
    sizeRect.cy = rc.bottom - rc.top;

    // set brush origin so that dither patterns are anchored correctly
    ::GetViewportOrgEx(hdc, &ptBrushOrg);
    ptBrushOrg.x += rc.left;
    ptBrushOrg.y += rc.top;

    // validate border size
    // if the broders are too big, truncate the bottom and right parts
    if (aiLineWidths[SIDE_TOP][DRAWBORDER_OUTER] +
        aiLineWidths[SIDE_BOTTOM][DRAWBORDER_OUTER] > sizeRect.cy)
    {
        aiLineWidths[SIDE_TOP][DRAWBORDER_OUTER] =
                        (aiLineWidths[SIDE_TOP][DRAWBORDER_OUTER] > sizeRect.cy) ?
                        sizeRect.cy :
                        aiLineWidths[SIDE_TOP][DRAWBORDER_OUTER];
        aiLineWidths[SIDE_BOTTOM][DRAWBORDER_OUTER] =
                                                sizeRect.cy -
                                                aiLineWidths[SIDE_TOP][DRAWBORDER_OUTER];
    }

    if (aiLineWidths[SIDE_RIGHT][DRAWBORDER_OUTER] +
        aiLineWidths[SIDE_LEFT][DRAWBORDER_OUTER] > sizeRect.cx)
    {
        aiLineWidths[SIDE_LEFT][DRAWBORDER_OUTER] =
                        (aiLineWidths[SIDE_LEFT][DRAWBORDER_OUTER] > sizeRect.cx) ?
                        sizeRect.cx :
                        aiLineWidths[SIDE_LEFT][DRAWBORDER_OUTER];
        aiLineWidths[SIDE_RIGHT][DRAWBORDER_OUTER] =
                                                sizeRect.cx -
                                                aiLineWidths[SIDE_LEFT][DRAWBORDER_OUTER];
    }

    for ( i = 0; i < 4; i++ )
    {
        aiLineWidths[i][DRAWBORDER_TOTAL] = max(aiLineWidths[i][DRAWBORDER_OUTER], 0);
    }

    for ( i = 0; i < 4; i++ )
    {
        switch ( pborderinfo->abStyles[i] )
        {
        case fmBorderStyleNone:
            aiNumBorderLines[i] = 0;    // *Don't* draw a line on this side.
            aiLineWidths[i][DRAWBORDER_TOTAL] = 
            aiLineWidths[i][DRAWBORDER_OUTER] = 0;
            break;

        case fmBorderStyleDashed:
        case fmBorderStyleDotted:            
            afMarkerBorder[i] = (aiLineWidths[i][DRAWBORDER_OUTER] > 0);
            // Can use for 1 pixel style, color & style matched dotted/dashed borders.
            // It would be more efficient given the marker border algorithm to redefine
            //  abCanUseJoin to go: UL, UR, LR, LL rather than UR, LR...
            abCanUseJoin[i] =   (aiLineWidths[i][DRAWBORDER_TOTAL] == 1)
                            &&  (aiLineWidths[i][DRAWBORDER_TOTAL]
                                == aiLineWidths[(i==0)?3:i-1][DRAWBORDER_TOTAL])
                            &&  (pborderinfo->acrColors[i][DRAWBORDER_OUTER]
                                == pborderinfo->acrColors[(i==0)?3:1-1][DRAWBORDER_OUTER]);
            aiNumBorderLines[i] = 0;    // *Don't* draw a line on this side.
            break;

        case fmBorderStyleSingle:
        case fmBorderStyleRaisedMono:
        case fmBorderStyleSunkenMono:
            aiNumBorderLines[i] = 1;
            abCanUseJoin[i] = !!(aiLineWidths[i][DRAWBORDER_OUTER] > 0);
            break;

        case fmBorderStyleRaised:
        case fmBorderStyleSunken:
        case fmBorderStyleEtched:
        case fmBorderStyleBump:
        case fmBorderStyleWindowInset:
            aiNumBorderLines[i] = 3;
            aiLineWidths[i][DRAWBORDER_INNER] = aiLineWidths[i][DRAWBORDER_OUTER] >> 1;
            aiLineWidths[i][DRAWBORDER_OUTER] -= aiLineWidths[i][DRAWBORDER_INNER];
            abCanUseJoin[i] = (aiLineWidths[i][DRAWBORDER_TOTAL] > 1
                                && (aiLineWidths[(i==0?3:(i-1))][DRAWBORDER_TOTAL]
                                    == aiLineWidths[i][DRAWBORDER_TOTAL]));
            break;

        case fmBorderStyleDouble:
            aiNumBorderLines[i] = 3;
            aiLineWidths[i][DRAWBORDER_SPACE] = aiLineWidths[i][DRAWBORDER_OUTER] / 3; // Spacer
            // If this were equal to the line above,
            aiLineWidths[i][DRAWBORDER_INNER] = (aiLineWidths[i][DRAWBORDER_OUTER]
                                                - aiLineWidths[i][DRAWBORDER_SPACE]) / 2;
            // we'd get widths of 3,1,1 instead of 2,1,2
            aiLineWidths[i][DRAWBORDER_OUTER] -= aiLineWidths[i][DRAWBORDER_SPACE]
                                                + aiLineWidths[i][DRAWBORDER_INNER];
            // evaluate border join between adjacent borders
            // we don't want to have a joint polygon borders if
            // the distribution does not match
            abCanUseJoin[i] = pborderinfo->acrColors[(i==0)?3:(i-1)][0]
                                    == pborderinfo->acrColors[i][0]
                                && (aiLineWidths[i][DRAWBORDER_TOTAL] > 2)
                                && (aiLineWidths[(i==0)?3:(i-1)][DRAWBORDER_TOTAL]
                                    == aiLineWidths[i][DRAWBORDER_TOTAL]);
            break;
        }
        abCanUseJoin[i] = abCanUseJoin[i]
                            && pborderinfo->abStyles[(4 + i - 1) % 4]
                                == pborderinfo->abStyles[i];
        aiLineWidths[i][DRAWBORDER_INCRE] = 0;
    }

    // Dotted/Dashed (Marker) border code --- 
    // If we have repeating marker borders (dotted/dashed), draw them first.  That way, we don't
    // have to calculate & draw bevels for each marker - the other border code will overdraw them.
    // Top & Bottom marker borders are responsible for the corners, unless there is no top/bottom marker
    // border in which case the side marker borders take responsibility.  (greglett)
    for (i = 0; i < 4; i++)
    {        
        int iMarkerWidth;

        if (!afMarkerBorder[i])
            continue;

        iMarkerWidth = aiLineWidths[i][DRAWBORDER_OUTER];
        //  Special case for 1px markers: use the system pen instead of drawing multiple markers.
        if (iMarkerWidth == 1)
        {         
            // Set the pen to the right color & style.
            // Since we bundle lines & don't cache pens, this *is* a different pen.                
            hPenDotDash = CreatePen(PS_DOT, iMarkerWidth, pborderinfo->acrColors[i][DRAWBORDER_OUTER]);
            SelectObject(hdc, hPenDotDash);

            //  Set up the (up to 5) line verticies in the polyline.
            //  Loop through remaining edges in clockwise order.
            for (j = 0; (i + j < 5) && ((j <= 1) || abCanUseJoin[(i+j-1)%4]); j++)
            {
                //  Set vertex to the initial point on border i + j.
                //  NOTE: deliberately set up so the default is the UL corner so that i + j = 4 works w/o a modulus.
                polygon[j].x = (i+j == SIDE_RIGHT || i+j == SIDE_BOTTOM)                 
                    ? rcSave.right - 1
                    : rcSave.left;
                polygon[j].y = (i+j == SIDE_LEFT || i+j == SIDE_BOTTOM)                        
                    ? rcSave.bottom - 1                                
                    : rcSave.top;
            }

            Polyline(hdc, polygon, j);
            SelectObject(hdc, hPen);        //  Restore NULL pen.
            DeleteObject(hPenDotDash);
            
            // If we've joined with j-2 other borders, we can skip their processing in the outer loop.
            i += j - 2;
        }
        else
        {
            int cMarkers, cSpaces;
            double dLeft, dTop;
            double dPerSpaceSize;
            double dX, dY;
            BOOL fDashed = (pborderinfo->abStyles[i] == fmBorderStyleDashed);
            BOOL fTopOrBottom = (i == SIDE_TOP || i == SIDE_BOTTOM);
            BOOL fLeadingSpace = false;
            BOOL fTrailingMarker = true;
            double dMarkerLength = fDashed ? 2 * iMarkerWidth : iMarkerWidth;
            double dBorderLength;

            if (fTopOrBottom)
            {
                dBorderLength = sizeRect.cx;
            }
            else
            {
                dBorderLength = sizeRect.cy;
                // If there are top/bottom marker borders, they are responsible for the corners.
                // So... subtract out such corners for side borders.
                if (afMarkerBorder[SIDE_TOP])
                {
                    fLeadingSpace = !fDashed;
                    dBorderLength -= aiLineWidths[SIDE_TOP][DRAWBORDER_OUTER];
                }
                if (afMarkerBorder[SIDE_BOTTOM])
                {
                    dBorderLength -= aiLineWidths[SIDE_BOTTOM][DRAWBORDER_OUTER];
                    fTrailingMarker = fDashed;
                }
            }
                              
            //  Sub out a marker iff we will have an extra one (trailing & leading marker)
            if (fTopOrBottom || !(afMarkerBorder[SIDE_TOP] || afMarkerBorder[SIDE_BOTTOM]))
                dBorderLength -= dMarkerLength;           

            //  Sub out a half marker if we will have an extra one (trailing xor leading half-dash)
            else if (fDashed && !(afMarkerBorder[SIDE_TOP] && afMarkerBorder[SIDE_BOTTOM]))
                dBorderLength -= dMarkerLength *.5;

            //  Sub out a space iff we will have an extra one (both trailing & leading space)
            else if (!fDashed && afMarkerBorder[SIDE_TOP] && afMarkerBorder[SIDE_BOTTOM])
                dBorderLength -= iMarkerWidth;           

            if (dBorderLength < 0)
                dBorderLength = 0;

            cSpaces = cMarkers = IntFloor(dBorderLength / (dMarkerLength + iMarkerWidth));

            // Add back in a space if we previously subtracted one.
            if (!fTopOrBottom && !fDashed && afMarkerBorder[SIDE_TOP] && afMarkerBorder[SIDE_BOTTOM])
            {
                cSpaces++;
                dBorderLength += iMarkerWidth;
            }

            if (cSpaces == 0)
            {
                // An absurdly short length or fat width border.  How do we handle this?
                // Right now, we don't.  Ignore it & move onto the next border.
                // NOTE: not bailing out here may currently cause a div by zero in the next line.
                continue;
            }

            // How many pixels per space?  Using: float point math.
            dPerSpaceSize = (dBorderLength - cMarkers * dMarkerLength) / cSpaces;

            // Add back in a marker if:
            //  1.  We've subtracted out a full marker.
            //  2.  We are a side, dashed border with any half dashes to add/split.
            if (fTopOrBottom || !(afMarkerBorder[SIDE_TOP] || afMarkerBorder[SIDE_BOTTOM])
                ||  (fDashed && (afMarkerBorder[SIDE_TOP] || afMarkerBorder[SIDE_BOTTOM])))
            {
                cMarkers++;
                dBorderLength += dMarkerLength;
            }
            if (fTrailingMarker) cMarkers--;

            crNew = pborderinfo->acrColors[i][DRAWBORDER_OUTER];
            if (crNew != crNow)
            {
                HBRUSH hbrNew;
                SelectCachedBrush(hdc, crNew, &hbrNew, &hbrOld, &crNow);
#ifndef WINCE
                if(hbrNew)
                {
                    // not supported on WINCE
                    ::UnrealizeObject(hbrNew);
                }
#endif
                ::SetBrushOrgEx(hdc, POSITIVE_MOD(ptBrushOrg.x,8), POSITIVE_MOD(ptBrushOrg.y,8), NULL);
            }

            // Set X and Y lengths for each marker.
            dX = fTopOrBottom ? dMarkerLength : iMarkerWidth;
            dY = fTopOrBottom
                ? iMarkerWidth
                : (fDashed && afMarkerBorder[SIDE_TOP])    // Leading halfdash code.
                    ? dMarkerLength * .5
                    : dMarkerLength;
            //  Rectangle & Ellipse draw *within* the pen, currently NULL_PEN (1px wide & invisible)
            //  In order to get a shape of the right size, we need to add one to our dimensions.
            dX += 1; dY += 1;

            // Compute the upper left corner
            dLeft = (i == SIDE_RIGHT)
                ?   rcSave.right - iMarkerWidth
                :   rcSave.left;
            dTop = (i == SIDE_BOTTOM)
              ?   rcSave.bottom - iMarkerWidth
              :   (i == SIDE_TOP || !afMarkerBorder[SIDE_TOP])
                  ?   rcSave.top
                  :   rcSave.top + aiLineWidths[SIDE_TOP][DRAWBORDER_OUTER];

            if (fLeadingSpace)
            {
                if (fTopOrBottom)
                    dLeft += dPerSpaceSize;
                else
                    dTop += dPerSpaceSize;
            }

            Assert(pborderinfo->abStyles[i] == fmBorderStyleDashed || pborderinfo->abStyles[i] == fmBorderStyleDotted);
            for (j = 0; j < cMarkers; j++)
            {                
                int iLeft   = IntNear(dLeft);
                int iTop    = IntNear(dTop );
                int iRight  = IntNear(dLeft + dX);
                int iBottom = IntNear(dTop + dY);
                switch (pborderinfo->abStyles[i])
                {
                case fmBorderStyleDotted:
                    if (iMarkerWidth == 2)                        
                        ::Rectangle(hdc, iLeft, iTop, iRight, iBottom);
                    else
                        ::Ellipse(hdc, iLeft, iTop, iRight, iBottom);
                    break;
                case fmBorderStyleDashed:                          
                    ::Rectangle(hdc, iLeft, iTop, iRight, iBottom);
                    //  Turn off that leading halfdash.
                    if (j==0 && !fTopOrBottom && afMarkerBorder[SIDE_TOP])
                    {
                        dY = dMarkerLength + 1;        // Reset to fulldash size.  (really, ((dY - 1) * 2) + 1)
                        dTop -= dMarkerLength * .5;    // Counter the fulldash subbed later.
                    }

                    break;
                }

                if (fTopOrBottom)
                {
                    dLeft += dMarkerLength + dPerSpaceSize;
                }
                else
                {
                    dTop += dMarkerLength + dPerSpaceSize;  
                }
            }

            if (fTrailingMarker)
            {             
                int iLeft   = IntNear(dLeft);
                int iTop    = IntNear(dTop );
                int iRight  = IntNear(dLeft + dX);
                int iBottom = IntNear(dTop + dY);
                switch (pborderinfo->abStyles[i])
                {
                case fmBorderStyleDotted:
                    if (iMarkerWidth == 2)
                        ::Rectangle(hdc, iLeft, iTop, iRight, iBottom);
                    else
                        ::Ellipse(hdc, iLeft, iTop, iRight, iBottom);
                    break;
                case fmBorderStyleDashed:            
                    if (!fTopOrBottom && afMarkerBorder[SIDE_BOTTOM])
                    {
                        dY = (dMarkerLength  * .5) + 1;     // Reset to fulldash size.  (really, ((dY - 1) * 2) + 1)
                        iBottom = IntNear(dTop + dY);
                    }
                    ::Rectangle(hdc, iLeft, iTop, iRight, iBottom);
                    break;
                }
            }
        }
    }           
  
    // Loop: draw outer lines (j=0), spacer (j=1), inner lines (j=2)
    for ( j=DRAWBORDER_OUTER; j<=DRAWBORDER_INNER; j++ )
    {
        fContinuingPoly = FALSE;
        wEdges = pborderinfo->wEdges;
        
        if ( j != DRAWBORDER_SPACE ) // if j==1, this line is a spacer only - don't draw lines, just deflate the rect.
        {
            i = 0;
            // We'll work around the border edges CW, starting with the right edge, in an attempt to reduce calls to polygon().
            // we must draw left first to follow Windows standard

            if ( wEdges & BF_LEFT && (j < aiNumBorderLines[SIDE_LEFT]) && aiLineWidths[SIDE_LEFT][j])
            {   // There's a left edge
                // get color brush for left side
                crNew = pborderinfo->acrColors[SIDE_LEFT][j];
                if (crNew != crNow)
                {
                    HBRUSH hbrNew;
                    SelectCachedBrush(hdc, crNew, &hbrNew, &hbrOld, &crNow);
#ifndef WINCE
                if(hbrNew)
                {
                    // not supported on WINCE
                    ::UnrealizeObject(hbrNew);
                }
#endif
                    ::SetBrushOrgEx(hdc, POSITIVE_MOD(ptBrushOrg.x,8), POSITIVE_MOD(ptBrushOrg.y,8), NULL);
                }
                
                // build left side polygon

                polygon[i].x = rc.left + aiLineWidths[SIDE_LEFT][j];    // lower right corner
                polygon[i++].y = rcSave.bottom - MulDivQuick(aiLineWidths[SIDE_BOTTOM][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_LEFT][DRAWBORDER_INCRE]
                                                        + aiLineWidths[SIDE_LEFT][j],
                                                    aiLineWidths[SIDE_LEFT][DRAWBORDER_TOTAL]);
                polygon[i].x = rc.left;                         // lower left corner
                polygon[i++].y = rcSave.bottom - MulDivQuick(aiLineWidths[SIDE_BOTTOM][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_LEFT][DRAWBORDER_INCRE],
                                                    aiLineWidths[SIDE_LEFT][DRAWBORDER_TOTAL]);

                if ( !(wEdges & BF_TOP) ||
                    ( pborderinfo->acrColors[SIDE_LEFT][j] != pborderinfo->acrColors[SIDE_TOP][j] )
                        || !abCanUseJoin[SIDE_TOP])
                {
                    polygon[i].x = rc.left;                         // upper left corner
                    polygon[i++].y = rcSave.top + MulDivQuick(aiLineWidths[SIDE_TOP][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_LEFT][DRAWBORDER_INCRE],
                                                    aiLineWidths[SIDE_LEFT][DRAWBORDER_TOTAL]);
                    polygon[i].x = rc.left + aiLineWidths[SIDE_LEFT][j];    // upper right corner
                    polygon[i++].y = rcSave.top + MulDivQuick(aiLineWidths[SIDE_TOP][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_LEFT][DRAWBORDER_INCRE]
                                                        + aiLineWidths[SIDE_LEFT][j],
                                                    aiLineWidths[SIDE_LEFT][DRAWBORDER_TOTAL]);
                    ::Polygon(hdc, polygon, i);
                    i = 0;
                }
                else
                    fContinuingPoly = TRUE;
            }
            if ( wEdges & BF_TOP && (j < aiNumBorderLines[SIDE_TOP]) && aiLineWidths[SIDE_TOP][j])
            {   // There's a top edge
                if ( !fContinuingPoly )
                {
                    // get color brush for top side
                    crNew = pborderinfo->acrColors[SIDE_TOP][j];
                    if (crNew != crNow)
                    {
                        HBRUSH hbrNew;
                        SelectCachedBrush(hdc, crNew, &hbrNew, &hbrOld, &crNow);
#ifndef WINCE
                        if(hbrNew)
                        {
                            // not supported on WINCE
                            ::UnrealizeObject(hbrNew);
                        }
#endif
                        ::SetBrushOrgEx(hdc, POSITIVE_MOD(ptBrushOrg.x,8), POSITIVE_MOD(ptBrushOrg.y,8), NULL);
                        i = 0;
                    }
                }
                // build top side polygon

                // up left
                polygon[i].x    = rcSave.left + ((wEdges & BF_LEFT) ? 
                                                    MulDivQuick(aiLineWidths[SIDE_LEFT][DRAWBORDER_TOTAL],
                                                        aiLineWidths[SIDE_TOP][DRAWBORDER_INCRE],
                                                        aiLineWidths[SIDE_TOP][DRAWBORDER_TOTAL])
                                                    : 0);
                polygon[i++].y  = rc.top;

                if (fdrawCaption)
                {
                    // shrink legend
                    sizeLegend.cx = sizeLegend.cx
                                        - aiLineWidths[SIDE_LEFT][DRAWBORDER_INCRE];
                    sizeLegend.cy = sizeLegend.cy
                                        - aiLineWidths[SIDE_LEFT][DRAWBORDER_INCRE];

                    polygon[i].x    = rc.left + sizeLegend.cx;
                    polygon[i++].y  = rc.top;
                    polygon[i].x    = rc.left + sizeLegend.cx;
                    polygon[i++].y  = rc.top + aiLineWidths[SIDE_TOP][j];

                    polygon[i].x    = rcSave.left + ((wEdges & BF_LEFT) ? 
                                                        MulDivQuick(aiLineWidths[SIDE_LEFT][DRAWBORDER_TOTAL],
                                                            aiLineWidths[SIDE_TOP][DRAWBORDER_INCRE]
                                                                + aiLineWidths[SIDE_TOP][j],
                                                            aiLineWidths[SIDE_TOP][DRAWBORDER_TOTAL])
                                                        : 0);

                    polygon[i++].y  = rc.top + aiLineWidths[SIDE_TOP][j];

                    ::Polygon(hdc, polygon, i);
                    i = 0;
                    polygon[i].x    = rc.left + sizeLegend.cy;
                    polygon[i++].y  = rc.top + aiLineWidths[SIDE_TOP][j];
                    polygon[i].x    = rc.left + sizeLegend.cy;
                    polygon[i++].y  = rc.top;
                }

                // upper right
                polygon[i].x    = rcSave.right - ((wEdges & BF_RIGHT) ?
                                                    MulDivQuick(aiLineWidths[SIDE_RIGHT][DRAWBORDER_TOTAL],
                                                        aiLineWidths[SIDE_TOP][DRAWBORDER_INCRE],
                                                        aiLineWidths[SIDE_TOP][DRAWBORDER_TOTAL])
                                                    : 0);
                polygon[i++].y  = rc.top;

                // lower right
                polygon[i].x    = rcSave.right - ((wEdges & BF_RIGHT) ?
                                                    MulDivQuick(aiLineWidths[SIDE_RIGHT][DRAWBORDER_TOTAL],
                                                        aiLineWidths[SIDE_TOP][DRAWBORDER_INCRE]
                                                            + aiLineWidths[SIDE_TOP][j],
                                                        aiLineWidths[SIDE_TOP][DRAWBORDER_TOTAL])
                                                    : 0 );
                polygon[i++].y  = rc.top + aiLineWidths[SIDE_TOP][j];

                if (!fdrawCaption)
                {
                    polygon[i].x    = rcSave.left + MulDivQuick(aiLineWidths[SIDE_LEFT][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_TOP][DRAWBORDER_INCRE]
                                                        + aiLineWidths[SIDE_TOP][j],
                                                    aiLineWidths[SIDE_TOP][DRAWBORDER_TOTAL]);
                    polygon[i++].y  = rc.top + aiLineWidths[SIDE_TOP][j];
                }

                ::Polygon(hdc, polygon, i);
                i = 0;
            }

            fContinuingPoly = FALSE;
            i = 0;

            if ( wEdges & BF_RIGHT && (j < aiNumBorderLines[SIDE_RIGHT]) && aiLineWidths[SIDE_RIGHT][j])
            {   // There's a right edge
                // get color brush for right side
                crNew = pborderinfo->acrColors[SIDE_RIGHT][j];
                if (crNew != crNow)
                {
                    HBRUSH hbrNew;
                    SelectCachedBrush(hdc, crNew, &hbrNew, &hbrOld, &crNow);
#ifndef WINCE
                    if(hbrNew)
                    {
                        // not supported on WINCE
                        ::UnrealizeObject(hbrNew);
                    }
#endif
                    ::SetBrushOrgEx(hdc, POSITIVE_MOD(ptBrushOrg.x,8), POSITIVE_MOD(ptBrushOrg.y,8), NULL);
                }

                // build right side polygon

                polygon[i].x    = rc.right - aiLineWidths[SIDE_RIGHT][j];     // upper left corner
                polygon[i++].y  =  rcSave.top + MulDivQuick(aiLineWidths[SIDE_TOP][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_RIGHT][DRAWBORDER_INCRE]
                                                        + aiLineWidths[SIDE_RIGHT][j],
                                                    aiLineWidths[SIDE_RIGHT][DRAWBORDER_TOTAL]);

                if (pborderinfo->abStyles[SIDE_RIGHT] == pborderinfo->abStyles[SIDE_TOP]
                        && aiLineWidths[SIDE_RIGHT][j] == 1 
                        && fNoZoomOrComplexRotation)      // with zoom, it may not be 1-pixel
                {
                    // upper right corner fix: we have to overlap one pixel to avoid holes
                    polygon[i].x    = rc.right - 1;
                    polygon[i].y    = rcSave.top + MulDivQuick(aiLineWidths[SIDE_TOP][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_RIGHT][DRAWBORDER_INCRE],
                                                    aiLineWidths[SIDE_RIGHT][DRAWBORDER_TOTAL]);

                    polygon[i+1].x    = rc.right;
                    polygon[i+1].y  = polygon[i].y;

                    i = i + 2;
                }
                else
                {
                    polygon[i].x    = rc.right;
                    polygon[i++].y    = rcSave.top + MulDivQuick(aiLineWidths[SIDE_TOP][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_RIGHT][DRAWBORDER_INCRE],
                                                    aiLineWidths[SIDE_RIGHT][DRAWBORDER_TOTAL]);
                }

                if ( !(wEdges & BF_BOTTOM) ||
                    ( pborderinfo->acrColors[SIDE_RIGHT][j] != pborderinfo->acrColors[SIDE_BOTTOM][j] )
                        || !abCanUseJoin[SIDE_BOTTOM])
                {
                    polygon[i].x    = rc.right;                                     // lower right corner
                    polygon[i++].y  = rcSave.bottom - MulDivQuick(aiLineWidths[SIDE_BOTTOM][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_RIGHT][DRAWBORDER_INCRE],
                                                    aiLineWidths[SIDE_RIGHT][DRAWBORDER_TOTAL]);

                    polygon[i].x    = rc.right - aiLineWidths[SIDE_RIGHT][j];     // lower left corner
                    polygon[i++].y  = rcSave.bottom - MulDivQuick(aiLineWidths[SIDE_BOTTOM][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_RIGHT][DRAWBORDER_INCRE]
                                                        + aiLineWidths[SIDE_RIGHT][j],
                                                    aiLineWidths[SIDE_RIGHT][DRAWBORDER_TOTAL]);
                    ::Polygon(hdc, polygon, i);
                    i = 0;
                }
                else
                    fContinuingPoly = TRUE;
            }
            if ( wEdges & BF_BOTTOM && (j < aiNumBorderLines[SIDE_BOTTOM]) && aiLineWidths[SIDE_BOTTOM][j])
            {   // There's a bottom edge
                if ( !fContinuingPoly )
                {
                    // get color brush for bottom side
                    crNew = pborderinfo->acrColors[SIDE_BOTTOM][j];
                    if (crNew != crNow)
                    {
                        HBRUSH hbrNew;
                        SelectCachedBrush(hdc, crNew, &hbrNew, &hbrOld, &crNow);
#ifndef WINCE
                        if(hbrNew)
                        {
                            // not supported on WINCE
                            ::UnrealizeObject(hbrNew);
                        }
#endif
                        ::SetBrushOrgEx(hdc, POSITIVE_MOD(ptBrushOrg.x,8), POSITIVE_MOD(ptBrushOrg.y,8), NULL);
                        i = 0;
                    }
                }

                // build bottom side polygon

                polygon[i].x    = rcSave.right - MulDivQuick(aiLineWidths[SIDE_RIGHT][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_BOTTOM][DRAWBORDER_INCRE],
                                                    aiLineWidths[SIDE_BOTTOM][DRAWBORDER_TOTAL]);
                polygon[i++].y  = rc.bottom;

                if (pborderinfo->abStyles[SIDE_BOTTOM] == pborderinfo->abStyles[SIDE_LEFT]
                        && aiLineWidths[SIDE_RIGHT][j] == 1
                        && fNoZoomOrComplexRotation)      // with zoom, it may not be 1-pixel
                {
                    // bottom left
                    polygon[i].x    = rcSave.left + MulDivQuick(aiLineWidths[SIDE_LEFT][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_BOTTOM][DRAWBORDER_INCRE],
                                                    aiLineWidths[SIDE_BOTTOM][DRAWBORDER_TOTAL]);
                    polygon[i].y    = rc.bottom;

                    // lower left fix, we have to overlap 1 pixel to avoid holes
                    polygon[i+1].x  = polygon[i].x;
                    polygon[i+1].y  = rc.bottom - 1;

                    i = i + 2;
                }
                else
                {
                    polygon[i].x    = rcSave.left + MulDivQuick(aiLineWidths[SIDE_LEFT][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_BOTTOM][DRAWBORDER_INCRE],
                                                    aiLineWidths[SIDE_BOTTOM][DRAWBORDER_TOTAL]);
                    polygon[i++].y    = rc.bottom;
                }

                // upper left, we have to overlap 1 pixel to avoid holes
                polygon[i].x    = rcSave.left + MulDivQuick(aiLineWidths[SIDE_LEFT][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_BOTTOM][DRAWBORDER_INCRE]
                                                        + aiLineWidths[SIDE_BOTTOM][j],
                                                    aiLineWidths[SIDE_BOTTOM][DRAWBORDER_TOTAL]);
                polygon[i++].y  = rc.bottom - aiLineWidths[SIDE_BOTTOM][j];
                polygon[i].x    = rcSave.right  - MulDivQuick(aiLineWidths[SIDE_RIGHT][DRAWBORDER_TOTAL],
                                                    aiLineWidths[SIDE_BOTTOM][DRAWBORDER_INCRE]
                                                        + aiLineWidths[SIDE_BOTTOM][j],
                                                    aiLineWidths[SIDE_BOTTOM][DRAWBORDER_TOTAL]);

                polygon[i++].y  = rc.bottom - aiLineWidths[SIDE_BOTTOM][j];

                ::Polygon(hdc, polygon, i);
                i = 0;
            }

        }


        // Shrink rect for this line or spacer
        rc.top    += aiLineWidths[SIDE_TOP][j];
        rc.right  -= aiLineWidths[SIDE_RIGHT][j];
        rc.bottom -= aiLineWidths[SIDE_BOTTOM][j];
        rc.left   += aiLineWidths[SIDE_LEFT][j];

        // increment border shifts
        aiLineWidths[SIDE_RIGHT][DRAWBORDER_INCRE] += aiLineWidths[SIDE_RIGHT][j];
        aiLineWidths[SIDE_TOP][DRAWBORDER_INCRE] += aiLineWidths[SIDE_TOP][j];
        aiLineWidths[SIDE_BOTTOM][DRAWBORDER_INCRE] += aiLineWidths[SIDE_BOTTOM][j];
        aiLineWidths[SIDE_LEFT][DRAWBORDER_INCRE] += aiLineWidths[SIDE_LEFT][j];
    }

    // Okay, now let's draw the flat border if necessary.
    if ( xyFlat != 0 )
    {
        if (pborderinfo->xyFlat < 0)
        {
            rc = rcOrig;
        }
        rc.right++;
        rc.bottom++;
        xyFlat++;

        if (wEdges & BF_RIGHT)
        {
            crNew = pborderinfo->acrColors[SIDE_RIGHT][1];
            if (crNew != crNow)
            {
                HBRUSH hbrNew;
                SelectCachedBrush(hdc, crNew, &hbrNew, &hbrOld, &crNow);
#ifndef WINCE
                if(hbrNew)
                {
                    // not supported on WINCE
                    ::UnrealizeObject(hbrNew);
                }
#endif
                ::SetBrushOrgEx(hdc, POSITIVE_MOD(ptBrushOrg.x,8), POSITIVE_MOD(ptBrushOrg.y,8), NULL);
            }
            ::Rectangle(hdc,
                        rc.right - xyFlat,
                        rc.top + ((wEdges & BF_TOP) ? 0 : xyFlat),
                        rc.right,
                        rc.bottom - ((wEdges & BF_BOTTOM) ? 0 : xyFlat)
                        );
        }
        if (wEdges & BF_BOTTOM)
        {
            crNew = pborderinfo->acrColors[SIDE_BOTTOM][1];
            if (crNew != crNow)
            {
                HBRUSH hbrNew;
                SelectCachedBrush(hdc, crNew, &hbrNew, &hbrOld, &crNow);
#ifndef WINCE
                if(hbrNew)
                {
                    // not supported on WINCE
                    ::UnrealizeObject(hbrNew);
                }
#endif
                ::SetBrushOrgEx(hdc, POSITIVE_MOD(ptBrushOrg.x,8), POSITIVE_MOD(ptBrushOrg.y,8), NULL);
            }
            ::Rectangle(hdc,
                        rc.left + ((wEdges & BF_LEFT) ? 0 : xyFlat),
                        rc.bottom - xyFlat,
                        rc.right - ((wEdges & BF_RIGHT) ? 0 : xyFlat),
                        rc.bottom
                        );
        }

        if (wEdges & BF_TOP)
        {
            crNew = pborderinfo->acrColors[SIDE_TOP][1];
            if (crNew != crNow)
            {
                HBRUSH hbrNew;
                SelectCachedBrush(hdc, crNew, &hbrNew, &hbrOld, &crNow);
#ifndef WINCE
                if(hbrNew)
                {
                    // not supported on WINCE
                    ::UnrealizeObject(hbrNew);
                }
#endif
                ::SetBrushOrgEx(hdc, POSITIVE_MOD(ptBrushOrg.x,8), POSITIVE_MOD(ptBrushOrg.y,8), NULL);
            }
            ::Rectangle(hdc,
                    rc.left + ((wEdges & BF_LEFT) ? 0 : xyFlat),
                    rc.top,
                    rc.right - ((wEdges & BF_RIGHT) ? 0 : xyFlat),
                    rc.top + xyFlat
                    );
        }
        if (wEdges & BF_LEFT)
        {
            crNew = pborderinfo->acrColors[SIDE_LEFT][1];
            if (crNew != crNow)
            {
                HBRUSH hbrNew;
                SelectCachedBrush(hdc, crNew, &hbrNew, &hbrOld, &crNow);
#ifndef WINCE
                if(hbrNew)
                {
                    // not supported on WINCE
                    ::UnrealizeObject(hbrNew);
                }
#endif
                ::SetBrushOrgEx(hdc, POSITIVE_MOD(ptBrushOrg.x,8), POSITIVE_MOD(ptBrushOrg.y,8), NULL);
            }
            ::Rectangle(hdc,
                        rc.left,
                        rc.top + ((wEdges & BF_TOP) ? 0 : xyFlat),
                        rc.left + xyFlat,
                        rc.bottom - ((wEdges & BF_BOTTOM) ? 0 : xyFlat)
                        );
        }
    }

    if (hbrOld)
        ReleaseCachedBrush((HBRUSH)SelectObject(hdc, hbrOld));
}

//+----------------------------------------------------------------------------
//
// Function:    CalcImgBgRect
//
// Synopsis:    Finds the rectangle to pass to Tile() to draw correct
//              background image with the attributes specified in the
//              fancy format (repeat-x, repeat-y, etc).
//
//-----------------------------------------------------------------------------
void
CalcBgImgRect(
    CTreeNode          * pNode,
    CFormDrawInfo      * pDI,
    const SIZE         * psizeObj,
    const SIZE         * psizeImg,
          CPoint       * pptBackOrig,
    CBackgroundInfo    * pbginfo )
{
    // pNode is used to a) extract formats to get the
    // background position values, and b) to get the font height so we
    // can handle em/en/ex units for position.
    const CFancyFormat * pFF = pNode->GetFancyFormat();
    const CCharFormat  * pCF = pNode->GetCharFormat();
    BOOL  fVerticalLayoutFlow = pCF->HasVerticalLayoutFlow();
    BOOL  fWritingModeUsed    = pCF->_fWritingModeUsed;
    const CUnitValue & cuvBgPosX = pbginfo->GetLogicalBgPosX(fVerticalLayoutFlow, fWritingModeUsed, pFF);
    const CUnitValue & cuvBgPosY = pbginfo->GetLogicalBgPosY(fVerticalLayoutFlow, fWritingModeUsed, pFF);
    RECT *prcBackClip = &pbginfo->rcImg;
    
    // N.B. Per CSS spec, percentages work as follows:
    // (x%, y%) means that the (x%, y%) point in the image is
    // positioned at the (x%, y%) point in the bounded rectangle.

    if (cuvBgPosX.GetUnitType() == CUnitValue::UNIT_PERCENT)
    {
        pptBackOrig->x =
                  MulDivQuick(cuvBgPosX.GetPercent(),
                              psizeObj->cx - psizeImg->cx,
                              100);
    }
    else
    {
        pptBackOrig->x =
         cuvBgPosX.GetPixelValue(pDI, CUnitValue::DIRECTION_CX, 0,
                                       pNode->GetFontHeightInTwips((CUnitValue*)&cuvBgPosX));
    }

    if (cuvBgPosY.GetUnitType() == CUnitValue::UNIT_PERCENT)
    {
        pptBackOrig->y =
                  MulDivQuick(cuvBgPosY.GetPercent(),
                              psizeObj->cy - psizeImg->cy,
                              100);
    }
    else
    {
        pptBackOrig->y =
          cuvBgPosY.GetPixelValue(pDI, CUnitValue::DIRECTION_CY, 0,
                                        pNode->GetFontHeightInTwips((CUnitValue*)&cuvBgPosY));
    }
    if (fVerticalLayoutFlow)
    {
        // Background position is a phisical property, so logical origin points 
        // to top-right corner.
        //   logical-x = phisical-y (already set)
        //   logical-y = is relative to the right edge of the object
        // NOTE: image size is in physical coordinate system
        pptBackOrig->y = psizeObj->cy - psizeImg->cx - pptBackOrig->y;
    }

    if (pbginfo->GetLogicalBgRepeatX(fVerticalLayoutFlow, fWritingModeUsed, pFF))
    {
        prcBackClip->left  = 0;
        prcBackClip->right = psizeObj->cx;
    }
    else
    {
        prcBackClip->left  = pptBackOrig->x;
        // NOTE: image size is in physical coordinate system
        if (fVerticalLayoutFlow)
            prcBackClip->right = pptBackOrig->x + psizeImg->cy;
        else
            prcBackClip->right = pptBackOrig->x + psizeImg->cx;
    }

    if (pbginfo->GetLogicalBgRepeatY(fVerticalLayoutFlow, fWritingModeUsed, pFF))
    {
        prcBackClip->top    = 0;
        prcBackClip->bottom = psizeObj->cy;
    }
    else
    {
        prcBackClip->top    = pptBackOrig->y;
        // NOTE: image size is in physical coordinate system
        if (fVerticalLayoutFlow)
            prcBackClip->bottom = pptBackOrig->y + psizeImg->cx;
        else
            prcBackClip->bottom = pptBackOrig->y + psizeImg->cy;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     get_form
//
//  Synopsis:   Exposes the form element of this site.
//
//  Note:
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CSite::get_form(IHTMLFormElement **ppDispForm)
{
    HRESULT        hr = S_OK;
    CFormElement * pForm;

    if (!ppDispForm)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDispForm = NULL;

    pForm = GetParentForm();
    if (pForm)
    {
        hr = THR_NOTRACE(pForm->QueryInterface(IID_IHTMLFormElement,
                                              (void**)ppDispForm));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN( SetErrorInfoPGet( hr, DISPID_CSite_form));
}

CSite::DRAGINFO::~DRAGINFO()
{
    if (_pBag)
        _pBag->Release();
}

void
CBorderInfo::FlipBorderInfo()
{
    CBorderInfo *pborderinfo = this;
    CBorderInfo biPhy;
    int side, sideL;
    
    memcpy(&biPhy, pborderinfo, sizeof(CBorderInfo));
    for (side = SIDE_TOP; side < SIDE_MAX; side++)
    {
        if (side == SIDE_TOP)
            sideL = SIDE_LEFT;
        else
            sideL = side - 1;
        pborderinfo->abStyles[sideL] = biPhy.abStyles[side];
        pborderinfo->aiWidths[sideL] = biPhy.aiWidths[side];
        pborderinfo->acrColors[sideL][0] = biPhy.acrColors[side][0];
        pborderinfo->acrColors[sideL][1] = biPhy.acrColors[side][1];
        pborderinfo->acrColors[sideL][2] = biPhy.acrColors[side][2];
    }

    pborderinfo->wEdges = 0;
    if ( pborderinfo->aiWidths[SIDE_TOP] )
        pborderinfo->wEdges |= BF_TOP;
    if ( pborderinfo->aiWidths[SIDE_RIGHT] )
        pborderinfo->wEdges |= BF_RIGHT;
    if ( pborderinfo->aiWidths[SIDE_BOTTOM] )
        pborderinfo->wEdges |= BF_BOTTOM;
    if ( pborderinfo->aiWidths[SIDE_LEFT] )
        pborderinfo->wEdges |= BF_LEFT;
}

//TODO (terrylu, alexz) pdl parser should be fixed so to avoid doing this
#if 1
HRESULT CSite::focus() { return super::focus(); };
HRESULT CSite::blur() { return super::blur(); };
HRESULT CSite::addFilter(IUnknown* pUnk) { return super::addFilter(pUnk); };
HRESULT CSite::removeFilter(IUnknown* pUnk) { return super::removeFilter(pUnk); };
HRESULT CSite::get_clientHeight(long*p) { return super::get_clientHeight(p); };
HRESULT CSite::get_clientWidth(long*p) { return super::get_clientWidth(p); };
HRESULT CSite::get_clientTop(long*p) { return super::get_clientTop(p); };
HRESULT CSite::get_clientLeft(long*p) { return super::get_clientLeft(p); };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\docdata.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1993 - 1995.
//
//  File:       docdata.cxx
//
//  Implement Data transfer support for Doc object
//
//------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_RTFTOHTM_HXX_
#define X_RTFTOHTM_HXX_
#include "rtftohtm.hxx"
#endif

//+---------------------------------------------------------------
//
//  Member:     CDoc::GetPlaintext
//
//  Synopsis:   Helper function to get plaintext in a specified codepage.
//
//---------------------------------------------------------------

HRESULT
CDoc::GetPlaintext(
        CServer * pServer,
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium,
        BOOL fHere,
        CODEPAGE codepage)
{
    HRESULT     hr;

    if (!fHere)
    {
        // fill in the pmedium structure
        pmedium->tymed = TYMED_ISTREAM;
        pmedium->pUnkForRelease = NULL;

        hr = THR(CreateStreamOnHGlobal(NULL, TRUE, &pmedium->pstm));
        if (hr)
            goto Cleanup;
    }

    //
    // Save to the stream in plaintext mode, but do not word wrap (since we do
    //  not word wrap on the clipboard either).
    //
    hr = THR(DYNCAST(CDoc, pServer)->SaveToStream(pmedium->pstm,
        WBF_SAVE_PLAINTEXT|WBF_FORMATTED_PLAINTEXT|WBF_NUMBER_LISTS|
        WBF_FORMATTED|WBF_NO_WRAP,
        codepage));

Cleanup:
    //  If we failed somehow and yet created a docfile, then we will
    //      release the docfile to delete it

    if (hr && !fHere)
        ClearInterface(&pmedium->pstm);

    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::GetTEXT
//
//  Synopsis:   Get CF_TEXT format for the CDoc object
//
//---------------------------------------------------------------

HRESULT
CDoc::GetTEXT(
        CServer * pServer,
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium,
        BOOL fHere)
{
    RRETURN(GetPlaintext(pServer, pformatetc, pmedium, fHere, g_cpDefault));
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::GetUNICODETEXT
//
//  Synopsis:   Get CF_UNICODETEXT format for the CDoc object
//
//---------------------------------------------------------------

HRESULT
CDoc::GetUNICODETEXT(
        CServer * pServer,
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium,
        BOOL fHere)
{
    RRETURN(GetPlaintext(pServer, pformatetc, pmedium, fHere, CP_UCS_2));
}

#ifndef NO_RTF
//+---------------------------------------------------------------
//
//  Member:     CDoc::GetRTF
//
//  Synopsis:   Get CF_RTF format for the CDoc object
//
//---------------------------------------------------------------

HRESULT
CDoc::GetRTF(
        CServer * pServer,
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium,
        BOOL fHere)
{
    HRESULT                 hr = S_OK;
#ifndef WINCE
    CDoc *                  pDoc = DYNCAST(CDoc, pServer);

    if (!pDoc->RtfConverterEnabled())
        return E_FAIL;

    if (!fHere)
    {
        // fill in the pmedium structure
        pmedium->tymed = TYMED_ISTREAM;
        pmedium->pUnkForRelease = NULL;

        hr = THR(CreateStreamOnHGlobal(NULL, TRUE, &pmedium->pstm));
        if (hr)
        {
            goto Cleanup;
        }
    }

    hr = CRtfToHtmlConverter::InternalHtmlToStreamRtf(pDoc, pmedium->pstm);

Cleanup:
    //  If we failed somehow and yet created a docfile, then we will
    //      release the docfile to delete it

    if (hr && !fHere)
        ClearInterface(&pmedium->pstm);

#endif // WINCE
    RRETURN1(hr, S_FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\dispserv.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       dispserv.cxx
//
//  Contents:   Display pointer implementation
//
//----------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_TPOINTER_H_
#define X_TPOINTER_H_
#include "tpointer.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_DISPSERV_HXX_
#define X_DISPSERV_HXX_
#include "dispserv.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

// TODO: move to global place in trident [ashrafm]
#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}
#define GetCharFmt(iCF)  (&(*_pts->_pCharFormatCache)[iCF])
#define GetParaFmt(iPF)  (&(*_pts->_pParaFormatCache)[iPF])
#define GetFancyFmt(iFF) (&(*_pts->_pFancyFormatCache)[iFF])

extern COORDINATE_SYSTEM MapToCoordinateEnum(COORD_SYSTEM eCoordSystem);

//
// DumpTree display pointer adorner
//
#if DBG == 1
static const LPCTSTR strDebugDispPointerPrefix = _T("DP");
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::CreateDisplayPointer, public
//
//  Synopsis:   IDisplayServices::CreateDisplayPointer
//
//----------------------------------------------------------------------------

HRESULT
CDoc::CreateDisplayPointer(IDisplayPointer **ppDispPointer)
{
    if (!ppDispPointer)
        return E_INVALIDARG;

    *ppDispPointer = new CDisplayPointer(this);
    if (!*ppDispPointer)
        return E_OUTOFMEMORY;

    return S_OK;
}

        
//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::CDisplayPointer, public
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CDisplayPointer::CDisplayPointer(CDoc *pDoc)
: _mpPosition(pDoc)
{
    // arbitrary defaults since pointer is not positioned
    _fNotAtBOL = FALSE;
    _cRefs = 1;
    
#if DBG==1    
    // Ensure tree dump contains display pointer prefix
    _mpPosition.SetDebugName(strDebugDispPointerPrefix);
#endif        
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::~CDisplayPointer, public
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CDisplayPointer::~CDisplayPointer()
{
    _mpPosition.Unposition();
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::AddRef, public
//
//  Synopsis:   IUnknown::AddRef
//
//----------------------------------------------------------------------------

ULONG
CDisplayPointer::AddRef()
{
    return ++_cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::Release, public
//
//  Synopsis:   IUnknown::Release
//
//----------------------------------------------------------------------------

ULONG
CDisplayPointer::Release()
{
    Assert(_cRefs > 0);
    
    --_cRefs;

    if( 0 == _cRefs )
    {
        delete this;
        return 0;
    }

    return _cRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::QueryInterface, public
//
//  Synopsis:   IUnknown::QueryInterface
//
//----------------------------------------------------------------------------

HRESULT 
CDisplayPointer::QueryInterface(
    REFIID  iid, 
    LPVOID  *ppvObj )
{
    if (!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if (iid == IID_IUnknown || iid == IID_IDisplayPointer)
    {
        *ppvObj = (IDisplayPointer *)this;
        AddRef();    
    }
    else if (iid == CLSID_CDisplayPointer)
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::PositionMarkupPointer, public
//
//  Synopsis:   Position a markup pointer at the current display pointer
//              position.
//
//----------------------------------------------------------------------------

HRESULT
CDisplayPointer::PositionMarkupPointer(IMarkupPointer *pPointer)
{
    HRESULT         hr;
    
    if (!pPointer)
        RRETURN(E_INVALIDARG);

    IFC( pPointer->MoveToPointer(&_mpPosition) );
    
Cleanup:        
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::PositionMarkupPointer, public
//
//  Synopsis:   Internal version of PositionMarkupPointer
//
//----------------------------------------------------------------------------

HRESULT
CDisplayPointer::PositionMarkupPointer(CMarkupPointer *pPointer)
{
    HRESULT         hr;
    
    if (!pPointer)
        RRETURN(E_INVALIDARG);

    IFC( pPointer->MoveToPointer(&_mpPosition) );
    
Cleanup:        
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::MoveToPointer, public
//
//  Synopsis:   Move current pointer to pDispPointer.
//
//----------------------------------------------------------------------------

HRESULT
CDisplayPointer::MoveToPointer(IDisplayPointer *pDispPointer)
{
    HRESULT         hr;
    CDisplayPointer *pDispPointerInternal;

    if (!pDispPointer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC( pDispPointer->QueryInterface(CLSID_CDisplayPointer, (LPVOID *)&pDispPointerInternal) );    

    if (!pDispPointerInternal->_mpPosition.IsPositioned())
    {
        IFC( _mpPosition.Unposition() );
    }
    else
    {
        IFC( _mpPosition.MoveToPointer(&pDispPointerInternal->_mpPosition) );
    }
    
    _fNotAtBOL = pDispPointerInternal->_fNotAtBOL;

Cleanup:    
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::MoveToPoint, public
//
//  Synopsis:   Display pointer hit testing method
//
//----------------------------------------------------------------------------

HRESULT
CDisplayPointer::MoveToPoint(
    POINT           pt, 
    COORD_SYSTEM    eCoordSystem, 
    IHTMLElement    *pElementContext,
    DWORD           dwHitTestOptions,
    DWORD           *pdwHitTestResults)
{
    HRESULT             hr = E_FAIL;
    POINT               ptContent = g_Zero.pt;      // keep compiler happy
    CTreeNode           *pTreeNode = NULL;
    CLayoutContext      *pLayoutContext = NULL;     // layout context corresponding to pTreeNode
    COORDINATE_SYSTEM   eInternalCoordSystem;
    BOOL                fNotAtBOL = FALSE;          // keep compiler happy
    BOOL                fAtLogicalBOL;
    CFlowLayout         *pContainingLayout = NULL;
    BOOL                fHitGlyph = FALSE;          // keep compiler happy
    CDispNode           *pDispNode = NULL;

    if (pdwHitTestResults)
        *pdwHitTestResults = NULL;

    g_uiDisplay.DeviceFromDocPixels(&pt);
 
    //
    // Convert external coordinate system to internal coordinate system
    //
    
    switch (eCoordSystem)
    {
        case COORD_SYSTEM_GLOBAL:   
        case COORD_SYSTEM_CONTENT:
            break;

        default:
            AssertSz(0, "Unsupported coordinate system");
            hr = E_INVALIDARG;
            goto Cleanup;
    }            

    IFC( MapToCoordinateEnum(eCoordSystem, &eInternalCoordSystem) );

    //
    // If we have a containing layout, transform to the layouts coordinate system
    //

    if (pElementContext)
    {
        CElement *pElementInternal;

        // $$ktam: TODO we're unable to get the context for pElementContext (it's passed in as
        // an IHTMLElement).  May be forced to pass GUL_USEFIRSTLAYOUT, even though that's clearly wrong.
        
        IFC( pElementContext->QueryInterface(CLSID_CElement, (void**)&pElementInternal) );
        pContainingLayout = pElementInternal->GetFlowLayout();
        if (!pContainingLayout)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        //
        // If passed global coordinates, transform to the layout's coordinate system
        //
        
        pTreeNode = pContainingLayout->GetFirstBranch();

        if (eCoordSystem == COORD_SYSTEM_GLOBAL)
        {
            if (!pTreeNode)
            {
                hr = E_UNEXPECTED;
                goto Cleanup;
            }
            
            pContainingLayout->TransformPoint((CPoint *)&pt, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT);
            eCoordSystem = COORD_SYSTEM_CONTENT;
        }        
        
        ptContent = pt;
    }
    else if (eCoordSystem == COORD_SYSTEM_CONTENT)
    {
        //
        // Can't hit test to COORD_SYSTEM_CONTENT without a layout element
        //

        AssertSz(0, "CDisplayPointer::MoveToPoint - missing pElementContext");
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Hit test to get the node
    //
        
    if (eCoordSystem == COORD_SYSTEM_GLOBAL)
    {
        pTreeNode = GetDoc()->GetNodeFromPoint(pt, &pLayoutContext, TRUE, &ptContent,
                                               NULL, NULL, NULL, &pDispNode);

        if( pTreeNode == NULL )
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        if (pTreeNode->Element()->Tag() == ETAG_HTML)
        {
            hr = CTL_E_INVALIDLINE;
            goto Cleanup;
        }
        
        if ((ptContent.x == 0) && (ptContent.y == 0))
        {
            //
            // Sometimes - HitTestPoint returns ptContent of 0 We take over ourselves.
            //
            CFlowLayout * pLayout = NULL;
            
            pLayout = pTreeNode->GetFlowLayout( pLayoutContext );
            if( pLayout == NULL )
            {
                hr = CTL_E_INVALIDLINE;
                goto Cleanup;
            }

            CPoint myPt( pt );
            pLayout->TransformPoint( &myPt, eInternalCoordSystem, COORDSYS_FLOWCONTENT, pDispNode );

            ptContent = myPt;

            pTreeNode = pLayout->ElementOwner()->GetFirstBranch();
            Assert( pTreeNode );
        }
    
    }

    //
    // Do the move pointer to point internal
    //
    
    hr = THR( GetDoc()->MovePointerToPointInternal(
        ptContent, 
        pTreeNode, 
        pLayoutContext,
        &_mpPosition, 
        &fNotAtBOL, 
        &fAtLogicalBOL, 
        NULL, 
        FALSE, 
        pContainingLayout, 
        NULL, 
        dwHitTestOptions & HT_OPT_AllowAfterEOL,
        &fHitGlyph,
        pDispNode) );

    if (pdwHitTestResults && fHitGlyph)
    {
        (*pdwHitTestResults) |= HT_RESULTS_Glyph;
    }
        
    _fNotAtBOL = fNotAtBOL;

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::SetPointerGravity, publiv
//
//  Synopsis:   Sets the cooresponding markup pointer gravity
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::SetPointerGravity(POINTER_GRAVITY eGravity)
{
    RRETURN( _mpPosition.SetGravity(eGravity) );
}
    
//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::IsPositioned, publiv
//
//  Synopsis:   Is the display pointer positioned?
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::IsPositioned(BOOL *pfPositioned)
{
    RRETURN( _mpPosition.IsPositioned(pfPositioned) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::Unposition, public
//
//  Synopsis:   Unposition the pointer
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::Unposition()
{
    RRETURN( _mpPosition.Unposition() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::SetDebugName, public
//
//  Synopsis:   Sets the cooresponding markup pointer debug name
//
//----------------------------------------------------------------------------
#if DBG==1
void 
CDisplayPointer::SetDebugName(LPCTSTR szDebugName)
{
    CStr strDebugName;

    strDebugName.Append(strDebugDispPointerPrefix);
    strDebugName.Append(L" - ");
    strDebugName.Append(szDebugName);
    _mpPosition.SetDebugName(strDebugName);
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::GetCp, publiv
//
//  Synopsis:   Gets the Cp for the current display pointer
//
//----------------------------------------------------------------------------
LONG 
CDisplayPointer::GetCp()
{
    return _mpPosition.GetCp();
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::MapToCoordinateEnum, private
//
//  Synopsis:   Maps external coord system to internal coord system
//
//----------------------------------------------------------------------------
HRESULT 
CDisplayPointer::MapToCoordinateEnum(COORD_SYSTEM eCoordSystem, COORDINATE_SYSTEM *peCoordSystemInternal)
{   
    HRESULT             hr = S_OK;

    Assert(peCoordSystemInternal);
    
    switch (eCoordSystem)
    {
    case COORD_SYSTEM_GLOBAL:   
        *peCoordSystemInternal = COORDSYS_GLOBAL;
        break;

    case COORD_SYSTEM_PARENT: 
        *peCoordSystemInternal = COORDSYS_PARENT;
        break;

    case COORD_SYSTEM_CONTAINER:
        *peCoordSystemInternal = COORDSYS_BOX;
        break;

    case COORD_SYSTEM_CONTENT:
        *peCoordSystemInternal  = COORDSYS_FLOWCONTENT;
        break;

    default:
        hr = E_INVALIDARG;       
    }

    RRETURN(hr);
}





//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::MoveUnit, public
//
//  Synopsis:   IDisplayServices::MoveUnit
//
//  Note:   MoveUnit takes paramter in content coordinate system!!!
// 
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::MoveUnit(DISPLAY_MOVEUNIT eMoveUnit, LONG lXCurReally)
{
    HRESULT hr = S_OK;
    CFlowLayout *pFlowLayout;
    CTreeNode   *pNode;
    CMarkup     *pMarkup = NULL;
    LONG        cp;
    BOOL        fNotAtBOL;
    BOOL        fAtLogicalBOL;
    CView       *pView = GetDoc()->GetView();

    CPoint      ptGlobalCurReally;
    ILineInfo   *pLineInfo = NULL;

    if (lXCurReally > 0)
    {
        lXCurReally = g_uiDisplay.DeviceFromDocPixelsX(lXCurReally);
    }

    switch (eMoveUnit)
    {
        case DISPLAY_MOVEUNIT_TopOfWindow:
        {
            //
            // TODO: We need to be a bit more precise about where the
            // top of the first line is
            //
            
            // Go to top of window, not container...
            CPoint pt;
            // TODO: why was this made 12?
            pt.x = 12;
            pt.y = 12;
                        
            fNotAtBOL = _fNotAtBOL;
            hr = THR( GetDoc()->MoveMarkupPointerToPointEx( pt, &_mpPosition, TRUE, &fNotAtBOL, &fAtLogicalBOL, NULL, FALSE ));
            _fNotAtBOL = fNotAtBOL;
            goto Cleanup;
        }
        
        case DISPLAY_MOVEUNIT_BottomOfWindow:
        {
            //
            // TODO: More precision about the actual end of line needed
            //
            
            // Little harder, first have to calc the window size

            CSize szScreen;
            CPoint pt;
            
            //
            // Get the rect of the document's window
            //

            if ( !pView->IsActive() )
            {
                hr = E_FAIL;
                goto Cleanup;
            }
            
            pView->GetViewSize( &szScreen );
            pt = szScreen.AsPoint();

            Assert( pt.x > 0 && pt.y > 0 );
            pt.x -= 12;
            pt.y -= 12;
            fNotAtBOL = _fNotAtBOL;
            hr = THR( GetDoc()->MoveMarkupPointerToPointEx(pt, &_mpPosition, TRUE, &fNotAtBOL, &fAtLogicalBOL, NULL, FALSE));
            _fNotAtBOL = fNotAtBOL;
            goto Cleanup;                
        }
    }
        
    // get element for current position so we can get its flow layout
    pNode = _mpPosition.CurrentScope(MPTR_SHOWSLAVE);
    if (!pNode)
    {
        pNode = _mpPosition.Markup()->Root()->GetFirstBranch();
        Assert( pNode );
    }

    // get cp for current position
    cp = _mpPosition.GetCp();

    // use layout to get new position
    // Get the line where we are positioned.
    pMarkup = pNode->GetMarkup();

    LAYOUT_MOVE_UNIT eUnit;
    
    switch (eMoveUnit)
    {
        case DISPLAY_MOVEUNIT_PreviousLine:
            eUnit = LAYOUT_MOVE_UNIT_PreviousLine;
            break;
            
        case DISPLAY_MOVEUNIT_NextLine:
            eUnit = LAYOUT_MOVE_UNIT_NextLine;
            break;
            
        case DISPLAY_MOVEUNIT_CurrentLineStart:
            eUnit = LAYOUT_MOVE_UNIT_CurrentLineStart;
            break;
            
        case DISPLAY_MOVEUNIT_CurrentLineEnd:
            eUnit = LAYOUT_MOVE_UNIT_CurrentLineEnd;
            break;
            
        default:
            hr = E_INVALIDARG;
            goto Cleanup;
    }

    //
    // Accessing line information, ensure a recalc has been done
    //
    hr = THR(pNode->Element()->EnsureRecalcNotify(FALSE));
    if (hr)
        goto Cleanup;
    
    fNotAtBOL = _fNotAtBOL;

    pFlowLayout = pNode->GetFlowLayout();
    if(!pFlowLayout)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }
    
    //  Bug 26586: Don't try to position the pointer inside of a hidden element.
    if ( !pNode->Element()->IsVisible(TRUE) )
    {
        TraceTag((tagWarning, "Trying to position a pointer inside of a hidden element."));
        goto Cleanup;
    }

    //
    // TODO:    MoveMarkupPointer uses global coordinate since it needs to move between different
    //          layouts. In the future we should not allow MoveUnit to move out of different 
    //          its current layout.  (zhenbinx)
    //
    //
    ptGlobalCurReally.x = lXCurReally;
    if (SUCCEEDED(GetLineInfo(&pLineInfo)))
    {
        LONG lYPos;
       
        pLineInfo->get_baseLine(&lYPos);

        ptGlobalCurReally.y = g_uiDisplay.DeviceFromDocPixelsY(lYPos);
    }
    else
    {
        ptGlobalCurReally.y = 0;
    }
    pFlowLayout->TransformPoint(&ptGlobalCurReally, COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL);
    hr = THR( pFlowLayout->MoveMarkupPointer(&_mpPosition, cp, eUnit, ptGlobalCurReally, &fNotAtBOL, &fAtLogicalBOL) );
    _fNotAtBOL = fNotAtBOL;

Cleanup:
    ReleaseInterface(pLineInfo);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::GetPointerGravity, public
//
//  Synopsis:   Get the markup pointer gravity
//
//----------------------------------------------------------------------------

HRESULT
CDisplayPointer::GetPointerGravity(POINTER_GRAVITY* peGravity)
{
    return _mpPosition.Gravity(peGravity);
}
    
//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::SetDisplayGravity, public
//
//  Synopsis:   Sets the display gravity, i.e., set _fNotAtBOL.
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::SetDisplayGravity(DISPLAY_GRAVITY eGravity)
{
    switch (eGravity)
    {
        case DISPLAY_GRAVITY_PreviousLine:
            _fNotAtBOL = TRUE;
            break;

        case DISPLAY_GRAVITY_NextLine:
            _fNotAtBOL = FALSE;
            break;

        default:
            return E_INVALIDARG;
          
    }

    return S_OK;
}
    
//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::GetDisplayGravity, public
//
//  Synopsis:   Gets the display gravity
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::GetDisplayGravity(DISPLAY_GRAVITY* peGravity)
{
    if (!peGravity)
        return E_INVALIDARG;

    *peGravity = _fNotAtBOL ? DISPLAY_GRAVITY_PreviousLine : DISPLAY_GRAVITY_NextLine;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::ScrollIntoView, public
//
//  Synopsis:   Scroll into view using POINTER_SCROLLPIN_Minimal
//
//----------------------------------------------------------------------------

HRESULT
CDisplayPointer::ScrollIntoView()
{
    RRETURN1(GetDoc()->ScrollPointerIntoView(&_mpPosition, _fNotAtBOL, POINTER_SCROLLPIN_Minimal), S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::GetLineInfo, public
//
//  Synopsis:   Create an ILineInfo object
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::GetLineInfo(ILineInfo **ppLineInfo)
{
    HRESULT     hr;
    CLineInfo   *pLineInfo = NULL;
    CTreeNode   *pNode = NULL;
    CFlowLayout *pFlowLayout;
    const CCharFormat *pCharFormat;

    //
    // Validate arguments    
    //
    
    if (!ppLineInfo)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    *ppLineInfo = NULL;

    if (!_mpPosition.IsPositioned())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pNode = _mpPosition.CurrentScope(MPTR_SHOWSLAVE);   
    if (!pNode && _mpPosition.Markup())
    {
        pNode = _mpPosition.Markup()->Root()->GetFirstBranch();
        Assert( pNode );
    }

    if(pNode == NULL)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    pFlowLayout = pNode->GetFlowLayout();
    pCharFormat = pNode->GetCharFormat();
    if(!pFlowLayout || !pCharFormat)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    // Create CLineInfo object
    //

    pLineInfo = new CLineInfo;
    if (!pLineInfo)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    IFC( pLineInfo->Init(&_mpPosition, pFlowLayout, pCharFormat, _fNotAtBOL) );

    *ppLineInfo = pLineInfo;
    pLineInfo->AddRef();
    
Cleanup:    
    ReleaseInterface(pLineInfo);
        
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::MoveToMarkupPointer, public
//
//  Synopsis:   Position the display pointer at the specific markup pointer
//              location using the specified display pointer as line context
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::MoveToMarkupPointer(IMarkupPointer* pPointer, IDisplayPointer* pDispLineContext)
{
    HRESULT             hr;
    CDisplayPointer     *pDispPointerInternal = NULL; // keep compiler happy
    CTreeNode           *pNode;
    LONG                cpStart;
    LONG                cpStartContext = 0;           // keep compiler happy
    CLayout             *pLayout;
    CMarkupPointer      *pPointerInternal;
    const CCharFormat   *pCF;

    //
    // Validate arguments
    //
    
    if (!pPointer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pDispLineContext)
    {
        IFC( pDispLineContext->QueryInterface(CLSID_CDisplayPointer, (LPVOID *)&pDispPointerInternal) );    

        if (!pDispPointerInternal->_mpPosition.IsPositioned())
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

    }

    //
    // Position the markup pointer
    //    
    IFC( _mpPosition.MoveToPointer(pPointer) );

    if( !_mpPosition.IsPositioned() )
        goto Cleanup;    


    //
    // Make sure that our nearest layout is a flow layout
    //

    IFC( pPointer->QueryInterface(CLSID_CMarkupPointer, (LPVOID *)&pPointerInternal) );

    pNode = pPointerInternal->CurrentScope();
    if( !pNode )
    {
        if( pPointerInternal->Markup()->GetElementClient() )
        {
            pNode = pPointerInternal->Markup()->GetElementClient()->GetFirstBranch();
        }
        else
        {
            pNode = pPointerInternal->Markup()->Root()->GetFirstBranch();
        }
        Assert( pNode );
    }

    pLayout = pNode->GetUpdatedNearestLayout( GUL_USEFIRSTLAYOUT );
    if (!pLayout || !pLayout->IsFlowLayout())
    {
        hr = CTL_E_INVALIDLINE;
        goto Cleanup;
    }

    //
    // Check for display none.  There are no valid lines here and we can't measure, so 
    // don't position a display pointer there.
    //

    pCF = pNode->GetCharFormat();
    Assert(pCF);

    if (pCF->_fDisplayNone)
    {
        hr = CTL_E_INVALIDLINE;
        goto Cleanup;
    }
    
    //
    // Get line context from display pointer
    //
    
    if (pDispLineContext)
    {
        IFC( pDispPointerInternal->GetLineStart(&cpStartContext) );
    }
    else
    {
        //
        // If no line context, we're done
        //
        goto Cleanup;
    }
    
    //
    // Position the markup pointer on the same line as pDispLineContext
    //

    IFC( GetLineStart(&cpStart) );

    if (cpStart != cpStartContext)
    {
        _fNotAtBOL = !_fNotAtBOL;
        IFC( GetLineStart(&cpStart) );

        if (cpStart != cpStartContext)
        {
            _fNotAtBOL = !_fNotAtBOL;
            hr = S_FALSE; // can't position on the same line, so return S_FALSE
        }
    }

Cleanup:    
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::IsEqualTo, public
//
//  Synopsis:   IDisplayServices::IsEqualTo
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::IsEqualTo(IDisplayPointer* pDispPointer, BOOL* pfIsEqual)
{
    HRESULT hr;
    CDisplayPointer *pDispPointerInternal;
    BOOL fBetweenLines;

    if (!pfIsEqual)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC( pDispPointer->QueryInterface(CLSID_CDisplayPointer, (LPVOID *)&pDispPointerInternal) );
    
    IFC( _mpPosition.IsEqualTo(&pDispPointerInternal->_mpPosition, pfIsEqual) );
    if (*pfIsEqual == FALSE)
        goto Cleanup;

    IFC( IsBetweenLines(&fBetweenLines) );
    if (!fBetweenLines)
        goto Cleanup;
    
    *pfIsEqual = (_fNotAtBOL == pDispPointerInternal->_fNotAtBOL);

Cleanup:
    RRETURN(hr);
}
    
//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::IsLeftOf, public
//
//  Synopsis:   IDisplayServices::IsLeftOf
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::IsLeftOf(IDisplayPointer* pDispPointer, BOOL* pfIsLeftOf)
{
    HRESULT hr;
    CDisplayPointer *pDispPointerInternal;
    BOOL fBetweenLines;

    if (!pfIsLeftOf)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC( pDispPointer->QueryInterface(CLSID_CDisplayPointer, (LPVOID *)&pDispPointerInternal) );
    
    IFC( _mpPosition.IsLeftOf(&pDispPointerInternal->_mpPosition, pfIsLeftOf) );
    if (*pfIsLeftOf == TRUE)
        goto Cleanup;

    IFC( _mpPosition.IsEqualTo(&pDispPointerInternal->_mpPosition, pfIsLeftOf) );
    if (*pfIsLeftOf == FALSE)
        goto Cleanup;

    IFC( IsBetweenLines(&fBetweenLines) );
    if (!fBetweenLines)
    {
        *pfIsLeftOf = FALSE;
        goto Cleanup;
    }
    
    // Equal and fBetweenLines so use gravity to determine CDisplayPointer::IsLeftOf
    *pfIsLeftOf = !_fNotAtBOL && pDispPointerInternal->_fNotAtBOL;

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::IsRightOf, public
//
//  Synopsis:   IDisplayServices::IsRightOf
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::IsRightOf(IDisplayPointer* pDispPointer, BOOL* pfIsRightOf)
{
    HRESULT hr;
    CDisplayPointer *pDispPointerInternal;
    BOOL fBetweenLines;

    if (!pfIsRightOf)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC( pDispPointer->QueryInterface(CLSID_CDisplayPointer, (LPVOID *)&pDispPointerInternal) );
    
    IFC( _mpPosition.IsRightOf(&pDispPointerInternal->_mpPosition, pfIsRightOf) );
    if (*pfIsRightOf == TRUE)
        goto Cleanup;

    IFC( _mpPosition.IsEqualTo(&pDispPointerInternal->_mpPosition, pfIsRightOf) );
    if (*pfIsRightOf == FALSE)
        goto Cleanup;

    IFC( IsBetweenLines(&fBetweenLines) );
    if (!fBetweenLines)
    {
        *pfIsRightOf = FALSE;
        goto Cleanup;
    }

    *pfIsRightOf = _fNotAtBOL && !pDispPointerInternal->_fNotAtBOL;

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::IsBetweenLines, public
//
//  Synopsis:   IDisplayServices::IsBetweenLines
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::IsBetweenLines(BOOL* pfBetweenLines)
{
    HRESULT             hr = S_OK;
    CFlowLayout *       pFlowLayout;
    CTreeNode *         pNode = NULL;
    LONG                cp;
    BOOL                fBetweenLines = TRUE;
    
    if(pfBetweenLines == NULL )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Assert( _mpPosition.IsPositioned() );
    
    cp = _mpPosition.GetCp();
    pNode = _mpPosition.CurrentScope(MPTR_SHOWSLAVE);
    if (!pNode && _mpPosition.Markup())
    {
        pNode = _mpPosition.Markup()->Root()->GetFirstBranch();
        Assert( pNode );
    }

    if (!pNode)
        goto Cleanup;
    
    pFlowLayout = pNode->GetFlowLayout();

    if( !pFlowLayout || pFlowLayout != pNode->GetUpdatedNearestLayout() )
        goto Cleanup;

    fBetweenLines = pFlowLayout->IsCpBetweenLines( cp );

Cleanup:
    if( pfBetweenLines )
        *pfBetweenLines = fBetweenLines;
        
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::IsAtBOL, public
//
//  Synopsis:   IDisplayServices::IsAtBOL
//
//----------------------------------------------------------------------------

HRESULT
CDisplayPointer::IsAtBOL(BOOL* pfIsAtBOL)
{
    HRESULT     hr = S_OK;
    LONG        cpCurrent, cpLineStart;
    
    if (!pfIsAtBOL && !_mpPosition.IsPositioned())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC(IsBetweenLines(pfIsAtBOL));
    if (*pfIsAtBOL)
    {
        *pfIsAtBOL = !_fNotAtBOL;
        goto Cleanup;
    }

    cpCurrent = GetCp();
    IFC( GetLineStart(&cpLineStart) );

    *pfIsAtBOL = (cpCurrent <= cpLineStart);
    
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::GetLineStart, private
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::GetLineStart(LONG *pcp)
{
    HRESULT     hr = S_OK;
    CFlowLayout *pFlowLayout;
    BOOL        fNotAtBOL, fAtLogicalBOL;

    Assert(pcp);

    *pcp = -1;
    
    // get element for current position so we can get its flow layout
    pFlowLayout = GetFlowLayout();
    if(!pFlowLayout)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    fNotAtBOL = _fNotAtBOL;
    *pcp = GetCp();    
    IFC( pFlowLayout->LineStart(pcp, &fNotAtBOL, &fAtLogicalBOL, TRUE) );

Cleanup:
    RRETURN(hr);
}    

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::GetLineEnd, private
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::GetLineEnd(LONG *pcp)
{
    HRESULT     hr = S_OK;
    CFlowLayout *pFlowLayout;
    BOOL        fNotAtBOL, fAtLogicalBOL;

    Assert(pcp);

    *pcp = -1;
    
    pFlowLayout = GetFlowLayout();
    if(!pFlowLayout)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    fNotAtBOL = _fNotAtBOL;
    *pcp = GetCp();    
    IFC( pFlowLayout->LineEnd(pcp, &fNotAtBOL, &fAtLogicalBOL, TRUE) );

Cleanup:
    RRETURN(hr);
}    

//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::GetFlowElement, public
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::GetFlowElement(IHTMLElement **ppLayoutElement)
{
    HRESULT hr;
    CFlowLayout *pFlowLayout;
    CTreeNode   *pNode;

    if (!_mpPosition.IsPositioned() || !ppLayoutElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    // get element for current position so we can get its flow layout
    pNode = _mpPosition.CurrentScope(MPTR_SHOWSLAVE);

    if( !pNode && _mpPosition.Markup())
    {
        if( _mpPosition.Markup()->GetElementClient() )
        {
            pNode = _mpPosition.Markup()->GetElementClient()->GetFirstBranch();
        }
        else
        {
            pNode = _mpPosition.Markup()->Root()->GetFirstBranch();
        }
        Assert( pNode );
    }
   
    pFlowLayout = pNode->GetFlowLayout();
    if(!pFlowLayout || !pFlowLayout->ElementOwner())
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (pFlowLayout->ElementOwner()->HasMasterPtr())
    {
        IFC( pFlowLayout->ElementOwner()->GetMasterPtr()->QueryInterface( IID_IHTMLElement, ( void**) ppLayoutElement ));
    }
    else
    {
        IFC( pFlowLayout->ElementOwner()->QueryInterface( IID_IHTMLElement, ( void**) ppLayoutElement ));
    }

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::GetFlowLayout, private
//
//----------------------------------------------------------------------------
CFlowLayout *
CDisplayPointer::GetFlowLayout()
{
    CFlowLayout *pFlowLayout = NULL;
    CTreeNode   *pNode;

    if (!_mpPosition.IsPositioned())
        goto Cleanup;
    
    // get element for current position so we can get its flow layout
    pNode = _mpPosition.CurrentScope(MPTR_SHOWSLAVE);
    if (!pNode && _mpPosition.Markup())
    {
        pNode = _mpPosition.Markup()->Root()->GetFirstBranch();
        Assert( pNode );
    }

    if (!pNode)
        goto Cleanup;

    pFlowLayout = pNode->GetFlowLayout();
    
Cleanup:
    return pFlowLayout;    
}
   
//+---------------------------------------------------------------------------
//
//  Member:     CDisplayPointer::QueryBreaks, public
//
//----------------------------------------------------------------------------
HRESULT
CDisplayPointer::QueryBreaks(DWORD *pfBreaks)
{
    HRESULT         hr;
    LONG            cpEnd;
    LONG            cp = GetCp();
    CFlowLayout     *pFlowLayout;

    //
    // Validate arguments
    //
    if (!pfBreaks)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    *pfBreaks = DISPLAY_BREAK_None;

    pFlowLayout = GetFlowLayout();
    if (!pFlowLayout)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // If not at EOL, use previous line as the reference point
    //

    {
        CDisplay *pdp = pFlowLayout->GetDisplay();
        CLinePtr  rp(pdp);

        //
        // Accessing line information, ensure a recalc has been done
        //
        hr = THR(pFlowLayout->ElementOwner()->EnsureRecalcNotify(FALSE));
        if (hr)
            goto Cleanup;
        
        //
        // Line end is only exposed at adjusted line end
        //

        IFC( GetLineEnd(&cpEnd) );
        if (cp != cpEnd)
            goto Cleanup; // Not at the end of the line

        rp.RpSetCp(cp, TRUE);

        //
        // Position CLinePtr
        //
        if (pdp)
        {
            CLineCore *pli;

            pli = rp.CurLine();
            if (pli)
            {
                if (pli->_fHasEOP || pli->_fForceNewLine)
                    *pfBreaks |= DISPLAY_BREAK_Block;

                if (pli->_fHasBreak)
                    *pfBreaks |= DISPLAY_BREAK_Break;
                
            }        
        }
    }
    
Cleanup:
    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Member:     CLineInfo::AddRef, public
//
//  Synopsis:   IUnknown::AddRef
//
//----------------------------------------------------------------------------

ULONG
CLineInfo::AddRef()
{
    return ++_cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLineInfo::Release, public
//
//  Synopsis:   IUnknown::Release
//
//----------------------------------------------------------------------------

ULONG
CLineInfo::Release()
{
    Assert(_cRefs > 0);
    
    --_cRefs;

    if( 0 == _cRefs )
    {
        delete this;
        return 0;
    }

    return _cRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLineInfo::QueryInterface, public
//
//  Synopsis:   IUnknown::QueryInterface
//
//----------------------------------------------------------------------------

HRESULT 
CLineInfo::QueryInterface(
    REFIID  iid, 
    LPVOID  *ppvObj )
{
    if (!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if (iid == IID_IUnknown || iid == IID_ILineInfo)
    {
        *ppvObj = (ILineInfo *)this;
        AddRef();    
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLineInfo::Init, public
//
//  Synopsis:   CLineInfo::Init
//
//----------------------------------------------------------------------------
HRESULT
CLineInfo::Init(CMarkupPointer *pPointerInternal, CFlowLayout *pFlowLayout, const CCharFormat *pCharFormat, BOOL fNotAtBOL)
{
    HRESULT             hr;
    HTMLPtrDispInfoRec  info;
    
    IFC( pFlowLayout->GetLineInfo(pPointerInternal, fNotAtBOL, &info, pCharFormat) );

    _lXPosition = g_uiDisplay.DocPixelsFromDeviceX(info.lXPosition);
    _yBaseLine = g_uiDisplay.DocPixelsFromDeviceY(info.lBaseline);
    _yTextDescent = g_uiDisplay.DocPixelsFromDeviceY(info.lTextDescent);
    _yTextHeight = g_uiDisplay.DocPixelsFromDeviceY(info.lTextHeight);
    
    _fRTLLine = info.fRTLLine;
    
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::CComputedStyle, public
//
//  Synopsis:   IDisplayServices::GetComputedStyle
//
//----------------------------------------------------------------------------

HRESULT
CDoc::HasFlowLayout(IHTMLElement *pIElement, BOOL *pfHasFlowLayout)
{
    HRESULT hr;
    CElement *pElement;
    CTreeNode *pNode;

    if (!pIElement || !pfHasFlowLayout)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(pIElement->QueryInterface(CLSID_CElement, (void**)&pElement));
    if (hr)
        goto Cleanup;

    if (pElement->HasMasterPtr())
    {
        pElement = pElement->GetMasterPtr();
        if (!pElement)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    pNode = pElement->GetFirstBranch();
    if(!pNode)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    *pfHasFlowLayout = !!pNode->HasFlowLayout();

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::CComputedStyle, public
//
//  Synopsis:   IDisplayServices::GetComputedStyle
//
//----------------------------------------------------------------------------

HRESULT
CDoc::GetComputedStyle(IMarkupPointer *pPointer, IHTMLComputedStyle **ppComputedStyle)
{
    HRESULT hr;
    CComputedStyle *pComputedStyle = NULL;
    CMarkupPointer *pPointerInternal;
    CTreeNode *pNode;
    long lcfIdx = -1, lpfIdx = -1, lffIdx = -1;
    THREADSTATE *pts;
    const CCharFormat *pCF;
    CColorValue ccvBackColor;
    BOOL fHasBgColor;
    
    if (!ppComputedStyle || !pPointer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppComputedStyle = NULL;

    hr = THR(pPointer->QueryInterface(CLSID_CMarkupPointer, (void **)&pPointerInternal));
    if (hr)
        goto Cleanup;

    pNode = pPointerInternal->CurrentScope(MPTR_SHOWSLAVE);
    if (!pNode && pPointerInternal->Markup())
    {
        pNode = pPointerInternal->Markup()->Root()->GetFirstBranch();
        Assert( pNode );
    }

    if (!pNode)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    lcfIdx = pNode->GetCharFormatIndex();
    lpfIdx = pNode->GetParaFormatIndex();
    lffIdx = pNode->GetFancyFormatIndex();

    Assert(lcfIdx >= 0);
    Assert(lpfIdx >= 0);
    Assert(lffIdx >= 0);

    pts = GetThreadState();

    //
    // Check for background color.  This value isn't inherited in the FancyFormat, so we need to 
    // compute its value here.
    //
    
    pCF = (&(*pts->_pCharFormatCache)[lcfIdx]);
    Assert(pCF);

    ccvBackColor.Undefine();        

    if (pNode->ShouldHaveLayout())
    {
        CBackgroundInfo bginfo;
        CLayout *pLayout = pNode->GetUpdatedLayout();
        pLayout->GetBackgroundInfo(NULL, &bginfo, FALSE);
        fHasBgColor = bginfo.crBack != COLORREF_NONE;
    }
    else
    {
        fHasBgColor = pCF->_fHasBgColor;
    }
    
    if (fHasBgColor)
    {
        CElement *pElementFL = pNode->GetFlowLayoutElement();
        const CFancyFormat * pFF;

        if (pElementFL)
        {
            while(pNode)
            {
                pFF = pNode->GetFancyFormat();

                if (pFF && pFF->_ccvBackColor.IsDefined())
                {
                    ccvBackColor = pFF->_ccvBackColor;
                    break;
                }
                else
                {
                    if (DifferentScope(pNode, pElementFL))
                        pNode = pNode->Parent();
                    else
                        pNode = NULL;
                }
            }
        }
        
    }

    //
    // Create the computed style object
    //
    
    pComputedStyle = new CComputedStyle(pts, lcfIdx, lpfIdx, lffIdx, ccvBackColor);
    if (!pComputedStyle)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    *ppComputedStyle = pComputedStyle;
    
Cleanup:    
    RRETURN(hr);
}

CComputedStyle::CComputedStyle(THREADSTATE *pts, long lcfIdx, long lpfIdx, long lffIdx, const CColorValue &ccvBgColor)
{
    _cRefs = 1;

    _lcfIdx = lcfIdx;
    _lpfIdx = lpfIdx;
    _lffIdx = lffIdx;
    
    Assert(pts);
    _pts = pts;
    pts->_pCharFormatCache->AddRefData(lcfIdx);
    pts->_pParaFormatCache->AddRefData(lpfIdx);
    pts->_pFancyFormatCache->AddRefData(lffIdx);        

    _ccvBgColor = ccvBgColor;
}

CComputedStyle::~CComputedStyle()
{
    Assert(_lcfIdx >= 0);
    Assert(_lpfIdx >= 0);
    Assert(_lffIdx >= 0);

    Assert(_pts);
    _pts->_pCharFormatCache->ReleaseData(_lcfIdx);
    _pts->_pParaFormatCache->ReleaseData(_lpfIdx);
    _pts->_pFancyFormatCache->ReleaseData(_lffIdx);        
}

ULONG
CComputedStyle::AddRef()
{
    return ++_cRefs;
}

ULONG
CComputedStyle::Release()
{
    Assert(_cRefs > 0);
    
    --_cRefs;

    if(0 == _cRefs)
    {
        delete this;
        return 0;
    }

    return _cRefs;
}

HRESULT 
CComputedStyle::QueryInterface(REFIID iid, LPVOID *ppvObj)
{
    if (!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if (iid == IID_IUnknown || iid == IID_IHTMLComputedStyle)
    {
        *ppvObj = (IHTMLComputedStyle *)this;
        AddRef();    
    }
    else if (iid == CLSID_CComputedStyle)
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    return S_OK;
}

HRESULT
CComputedStyle::get_bold(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *p = pcF->_fBold ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_italic(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *p = pcF->_fItalic ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_underline(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *p = pcF->_fUnderline ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_overline(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *p = pcF->_fOverline ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_strikeOut(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *p = pcF->_fStrikeOut ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_subScript(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *p = pcF->_fSubscript ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_superScript(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *p = pcF->_fSuperscript ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_explicitFace(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *p = pcF->_fExplicitFace ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_fontWeight(long *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *p = pcF->_wWeight;
    return S_OK;
}

HRESULT
CComputedStyle::get_fontSize(long *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *p = pcF->_yHeight;
    return S_OK;
}

HRESULT
CComputedStyle::get_fontName(LPTSTR pchName)
{
    HRESULT hr = S_OK;

    if (!pchName)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    
    // The destination buffer must be large enough in to include the NULL
    // terminator, so we assume it is LF_FACESIZE+1.  This fact needs to 
    // be documented in the sdk and I've verified that internal calls 
    // (as of 2/20/2002) do indeed allocate a large enough buffer.

    if (FAILED(StringCchCopy(pchName, LF_FACESIZE+1, pcF->GetFaceName())))
    {
        hr = E_FAIL;
    }

    RRETURN(hr);
}

HRESULT
CComputedStyle::get_hasBgColor(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);
    *p = _ccvBgColor.IsDefined() ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_textColor(DWORD *pdwColor)
{
    if (!pdwColor)
        RRETURN(E_INVALIDARG);

    Assert(_lcfIdx >= 0);
    const CCharFormat *pcF = GetCharFmt(_lcfIdx);
    Assert(pcF);
    *pdwColor = pcF->_ccvTextColor.GetIntoRGB();
    return S_OK;
}

HRESULT
CComputedStyle::get_backgroundColor(DWORD *pdwColor)
{
    if (!pdwColor)
        RRETURN(E_INVALIDARG);

    *pdwColor = _ccvBgColor.GetIntoRGB();
    return S_OK;
}

HRESULT
CComputedStyle::get_preFormatted(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lpfIdx >= 0);
    const CParaFormat *ppF = GetParaFmt(_lpfIdx);
    Assert(ppF);
    *p = ppF->_fPre ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_direction(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lpfIdx >= 0);
    const CParaFormat *ppF = GetParaFmt(_lpfIdx);
    Assert(ppF);
    *p = ppF->_fRTL ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_blockDirection(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lpfIdx >= 0);
    const CParaFormat *ppF = GetParaFmt(_lpfIdx);
    Assert(ppF);
    *p = ppF->_fRTLInner ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::get_OL(VARIANT_BOOL *p)
{
    if (!p)
        RRETURN(E_INVALIDARG);

    Assert(_lpfIdx >= 0);
    const CParaFormat *ppF = GetParaFmt(_lpfIdx);
    Assert(ppF);
    *p = (ppF->_cListing.GetType() == CListing::NUMBERING) ? VB_TRUE : VB_FALSE;
    return S_OK;
}

HRESULT
CComputedStyle::IsEqual(IHTMLComputedStyle *pComputedStyle, VARIANT_BOOL *pfEqual)
{
    HRESULT hr;
    CComputedStyle *pSrcStyle;

    if (!pComputedStyle || !pfEqual)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(pComputedStyle->QueryInterface(CLSID_CComputedStyle, (void **)&pSrcStyle));
    if (hr)
        goto Cleanup;

    *pfEqual = ((_lcfIdx == pSrcStyle->_lcfIdx) && 
                (_lpfIdx == pSrcStyle->_lpfIdx) &&
                (_lffIdx == pSrcStyle->_lffIdx));

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\doclyout.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       layout.cxx
//
//  Contents:   Layout management
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_ROOTELEMENT_HXX_
#define X_ROOTELEMENT_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

DeclareTag(tagDocSize, "DocSize tracing", "Trace changes to document size");

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetExtent, IOleObject
//
//  Synopsis:   Called when the container wants to tell us a new size.  We
//              override this method so we can maintain the logical size of
//              the form properly.
//
//  Arguments:  dwAspect    Aspect which is changing.
//              psizel      New size
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CDoc::SetExtent(DWORD dwAspect, SIZEL *psizel)
    {
    HRESULT hr;

    TraceTagEx((tagDocSize, TAG_NONAME,
           "Doc : SetExtent - sizel(%d, %d)",
           (psizel ? psizel->cx : 0),
           (psizel ? psizel->cy : 0)));

#ifdef WIN16
    // in case we were are on some other thread's stack (e.g. Java)...
    // impersonate our own
    CThreadImpersonate cimp(_dwThreadId);
#endif
    hr = THR(CServer::SetExtent(dwAspect, psizel));
    if (hr)
        goto Cleanup;

    //
    // Update the transform with the new extents
    //

    if (dwAspect == DVASPECT_CONTENT && psizel && (psizel->cx || psizel->cy))
    {
        // this ensures that psizel is at least one screen pixel in highmetric (about 26 for 96dpi)
        SIZE size1pixel;
        _dciRender.HimetricFromDevice(size1pixel, 1, 1);
        psizel->cx = max(psizel->cx, size1pixel.cx);
        psizel->cy = max(psizel->cy, size1pixel.cy);

        // FUTURE (alexmog, 9/6/99): I think we should review this, considering that we have WYSIWYG zoom.
        //                 Ole client calling this method, expects us to either zoom to the 
        //                 provided rectangle, or relayout to fit in it. The effect of SetViewSize
        //                 is probably relayout (but I need to see that in debugger). 
        //                 Is it what we want to do, or do we actually want to zoom?
        //
        //                 In any case, this is probably the only way to create a DocScaleInfo with
        //                 scaling ratio different from _sizeInch/2540. It probably means that if a 
        //                 different scaling is applied, we'll see a bunch of bugs. 

        SIZE size;
        _dciRender.CDocScaleInfo::DeviceFromHimetric(size, *psizel);

        //  Alter view/measuring device information
        _view.SetViewSize(size);

        TraceTagEx((tagDocSize, TAG_NONAME,
               "Doc : SetExtent - Rendering Device(%d, %d)",
               size.cx,
               size.cy));
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::SetObjectRects, IOleInplaceObject
//
//  Synopsis:   Set position and clip rectangles.
//
//-------------------------------------------------------------------------

HRESULT
CDoc::SetObjectRects(LPCOLERECT prcPos, LPCOLERECT prcClip)
{
    CRect rcPosPrev, rcClipPrev;
    CRect rcPos, rcClip;
    HRESULT hr;

    TraceTagEx((tagDocSize, TAG_NONAME,
           "Doc : SetObjectRects - rcPos(%d, %d, %d, %d) rcClip(%d, %d, %d, %d)",
           (!prcPos ? 0 : prcPos->left),
           (!prcPos ? 0 : prcPos->top),
           (!prcPos ? 0 : prcPos->right),
           (!prcPos ? 0 : prcPos->bottom),
           (!prcClip ? 0 : prcClip->left),
           (!prcClip ? 0 : prcClip->top),
           (!prcClip ? 0 : prcClip->right),
           (!prcClip ? 0 : prcClip->bottom)));

    Assert(State() >= OS_INPLACE);
    Assert(_pInPlace);

    rcPosPrev  = _pInPlace->_rcPos;
    rcClipPrev = _pInPlace->_rcClip;

#ifdef WIN16
    // in case we were are on some other thread's stack (e.g. Java)...
    // impersonate our own
    CThreadImpersonate cimp(_dwThreadId);
#endif
    {
        CLock   Lock(this, SERVERLOCK_IGNOREERASEBKGND);

        hr = THR(CServer::SetObjectRects(prcPos, prcClip));
        if (hr)
            goto Cleanup;
    }

    rcPos  = _pInPlace->_rcPos;
    rcClip = _pInPlace->_rcClip;

    {
        CSize sizePos;         rcPos.GetSize(&sizePos);
        CSize sizePosPrev; rcPosPrev.GetSize(&sizePosPrev);
    
        //
        // If necessary, initiate a re-layout
        //
        if (!sizePos.IsZero() && sizePos != sizePosPrev)
        {
            _view.SetViewSize(sizePos);
        }
        //
        //  Otherwise, just invalidate the view
        //
        else if (rcClip.right - rcClip.left != rcClipPrev.right - rcClipPrev.left ||
                 rcClip.bottom - rcClip.top != rcClipPrev.bottom - rcClipPrev.top  )
        {
            // TODO: We need an invalidation...will a partial work? (brendand)
            Invalidate();        
        }
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::EnsureFormatCacheChange
//
//  Synopsis:   Clears the format caches for the client site and then
//              invalidates it.
//
//----------------------------------------------------------------------------

void
CMarkup::EnsureFormatCacheChange(DWORD dwFlags)
{
    if ((Doc()->State() < OS_RUNNING) || !Root())
        return;

    Root()->EnsureFormatCacheChange(dwFlags);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ForceRelayout
//
//  Synopsis:   Whack the entire display
//
//----------------------------------------------------------------------------

HRESULT
CDoc::ForceRelayout ( )
{
    HRESULT hr = S_OK;
    CNotification   nf;

    if (PrimaryMarkup())
    {
        PrimaryRoot()->EnsureFormatCacheChange( ELEMCHNG_CLEARCACHES );
        nf.DisplayChange(PrimaryRoot());
        PrimaryRoot()->SendNotification(&nf);     
    }

    _view.ForceRelayout();

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\debugger.cxx ===
//+--------------------------------------------------------------------------
//
//  File:       stdform.cxx
//
//  Contents:   Script Debugger related code
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_ESCRIPT_HXX_
#define X_ESCRIPT_HXX_
#include "escript.hxx"
#endif

#ifndef X_DEBUGGER_HXX_
#define X_DEBUGGER_HXX_
#include "debugger.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

///////////////////////////////////////////////////////////////////////////
//
//  misc
//
///////////////////////////////////////////////////////////////////////////

// MtDefines

MtDefine(CScriptCookieTable,                   ObjectModel,         "CScriptCookieTable");
MtDefine(CScriptCookieTable_CItemsArray,       CScriptCookieTable,  "CScriptCookieTable::CItemsArray");

MtDefine(CScriptDebugDocument,                 ObjectModel,         "CScriptDebugDocument");

// trace tags

DeclareTag(tagDebuggerDocumentSize,            "Debugger",          "trace RequestDocumentSize and UpdateDocumentSize")

// CScriptDebugDocument related
#ifndef NO_SCRIPT_DEBUGGER
extern interface IProcessDebugManager * g_pPDM;
extern interface IDebugApplication *    g_pDebugApp;
#endif // NO_SCRIPT_DEBUGGER
//+------------------------------------------------------------------------
//
//  Function:     GetMarkupFromBase
//
//-------------------------------------------------------------------------

CMarkup *
GetMarkupFromBase (CBase * pBase)
{
    CMarkup *   pMarkup = NULL;

    THR_NOTRACE(pBase->PrivateQueryInterface(CLSID_CMarkup, (void**)&pMarkup));

    return pMarkup;
}

//+------------------------------------------------------------------------
//
//  Function:     GetScriptElementFromBase
//
//-------------------------------------------------------------------------

CScriptElement *
GetScriptElementFromBase (CBase * pBase)
{
    CScriptElement *   pScriptElement = NULL;

    THR_NOTRACE(pBase->PrivateQueryInterface(CLSID_HTMLScriptElement, (void**)&pScriptElement));

    return pScriptElement;
}

//+------------------------------------------------------------------------
//
//  Function:     CrackSourceObject
//
//-------------------------------------------------------------------------

void
CrackSourceObject(CBase * pSourceObject, CMarkup ** ppMarkup, CScriptElement ** ppScriptElement)
{
    Assert (ppMarkup && ppScriptElement);

    *ppScriptElement = NULL;

    *ppMarkup = GetMarkupFromBase(pSourceObject);
    if (*ppMarkup)
        goto Cleanup;   // done

    *ppScriptElement = GetScriptElementFromBase(pSourceObject);
    if ((*ppScriptElement) && (*ppScriptElement)->_fSrc)
        goto Cleanup;   // done

    *ppMarkup = (*ppScriptElement)->GetMarkup();
    *ppScriptElement = NULL;

Cleanup:
    Assert (( (*ppScriptElement) && !(*ppMarkup)) ||
            (!(*ppScriptElement) &&  (*ppMarkup)));
    return;
}

//+------------------------------------------------------------------------
//
//  Function:   GetNamesFromUrl
//
//-------------------------------------------------------------------------

HRESULT
GetNamesFromUrl(LPTSTR pchUrl, LPTSTR * ppchShortName, LPTSTR * ppchLongName)
{
    HRESULT         hr = S_OK;
    URL_COMPONENTS  uc;
    TCHAR           achPath[pdlUrlLen];
    TCHAR           achHost[pdlUrlLen];
    LPTSTR          pchFile;

    Assert (ppchShortName && ppchLongName);

    ZeroMemory(&uc, sizeof(uc));
    uc.dwStructSize = sizeof(uc);

    uc.lpszUrlPath      = achPath;
    uc.dwUrlPathLength  = ARRAY_SIZE(achPath);
    uc.lpszHostName     = achHost;
    uc.dwHostNameLength = ARRAY_SIZE(achHost);

    if (InternetCrackUrl(pchUrl, _tcslen(pchUrl), 0, &uc))
    {
        pchFile = _tcsrchr(achPath, _T('/'));
        if (!pchFile)
            pchFile = _tcsrchr (achPath, _T('\\'));

        *ppchShortName = pchFile ? (pchFile + 1) : achPath;

        // if we have no path use the host name
        if (!(*ppchShortName)[0])
            *ppchShortName = achHost;
    }
    else
    {
        *ppchShortName = _T("Unknown");
    }

    // long name is the full URL
    *ppchLongName = pchUrl;

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
//  Stateless helpers
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Helper:     GetScriptDebugDocument
//
//-------------------------------------------------------------------------

HRESULT
GetScriptDebugDocument(CBase * pSourceObject, CScriptDebugDocument ** ppScriptDebugDocument)
{
    HRESULT             hr = S_OK;
    CScriptElement *    pScriptElement;
    CMarkup *           pMarkup;

    Assert (ppScriptDebugDocument);

    *ppScriptDebugDocument = NULL;

    CrackSourceObject(pSourceObject, &pMarkup, &pScriptElement);

    if (pMarkup && pMarkup->HasScriptContext())
    {
        *ppScriptDebugDocument = pMarkup->ScriptContext()->_pScriptDebugDocument;
    }
    else if (pScriptElement)
    {
        *ppScriptDebugDocument = pScriptElement->_pScriptDebugDocument;
    }

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CScriptCookieTable
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CScriptCookieTable::CreateCookieForSourceObject
//
//-------------------------------------------------------------------------

HRESULT
CScriptCookieTable::CreateCookieForSourceObject (DWORD_PTR * pdwCookie, CBase * pSourceObject)
{
    HRESULT     hr;

    Assert (pdwCookie && pSourceObject);

    // we may generate 0 cookie so make sure it is not treated as NO_SOURCE_CONTEXT
    Assert (0 != NO_SOURCE_CONTEXT);

    *pdwCookie = (DWORD_PTR)_aryItems.Size();

    hr = THR(MapCookieToSourceObject(*pdwCookie, pSourceObject));

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptCookieTable::MapCookieToSourceObject
//
//-------------------------------------------------------------------------

HRESULT
CScriptCookieTable::MapCookieToSourceObject(DWORD_PTR dwCookie, CBase * pSourceObject)
{
    HRESULT                 hr = S_OK;
    CItem *                 pItem;
    CScriptElement *        pScriptElement;
    CMarkup *               pMarkup;
    CMarkupScriptContext *  pMarkupScriptContext;

    Assert (NO_SOURCE_CONTEXT != dwCookie && pSourceObject);

    // if the cookie is not unique bail out. Cookies will not be unique if:
    // 1) item is a script block w/o src with the same piece of code in the same markup
    //    (e.g). a script file containing doc.write of a script block w/o src, that is the
    //    src from two or more script block with src=.
    // 2) Item is an inline event handler script conating same code in same markup
    // 3) Item is a script block with src= that someone sets the text property on thru DOM

    pItem = FindItem(dwCookie);

    if (pItem)
    {
        if (pItem->_type == ITEMTYPE_MARKUP || pItem->_type == ITEMTYPE_SCRIPTELEMENT)
            //This cookie is not unique;
            goto Cleanup;

        if (pItem->_type == ITEMTYPE_REF)
        {
            CItem *pItemRef = FindItem(pItem->_dwCookieRef, pSourceObject);

            if( pItemRef && pItemRef->_type != ITEMTYPE_NULL )
                // Valid reference, cookie is not unique;
                goto Cleanup;
            //else: it is a null reference, we can reuse.
        }
        else
        {
            // pItem->_type is ITEMTYPE_NULL, reuse the cookie;
            Assert(pItem->_type == ITEMTYPE_NULL);
        }
    }
    else
        pItem = _aryItems.Append();

    if (!pItem)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pItem->_dwCookie = dwCookie;

    CrackSourceObject(pSourceObject, &pMarkup, &pScriptElement);

    if (pScriptElement)
    {
        pItem->_type = ITEMTYPE_SCRIPTELEMENT;
        pItem->_pScriptElement = (CScriptElement*)pSourceObject;
        pItem->_pScriptElement->_dwScriptCookie = pItem->_dwCookie;
    }
    else if (pMarkup)
    {
        hr = THR(pMarkup->EnsureScriptContext(&pMarkupScriptContext));
        if (hr)
            goto Cleanup;

        if (NO_SOURCE_CONTEXT == pMarkupScriptContext->_dwScriptCookie)
        {
            pItem->_type        = ITEMTYPE_MARKUP;
            pItem->_pMarkup     = pMarkup;

            pMarkupScriptContext->_dwScriptCookie = pItem->_dwCookie;
        }
        else
        {
            pItem->_type        = ITEMTYPE_REF;
            pItem->_dwCookieRef = pMarkupScriptContext->_dwScriptCookie;
        }
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptCookieTable::FindItem
//
//-------------------------------------------------------------------------

CScriptCookieTable::CItem *
CScriptCookieTable::FindItem(DWORD_PTR dwCookie, CBase * pSourceObject)
{
    CItem *     pItem;
    int         c;

    //
    // optimization: first, try at index specified by the cookie.
    // (when we get to generate cookies, we generate them so that they are indexes in the array)
    //
    if (dwCookie < (DWORD_PTR)_aryItems.Size())
    {
        pItem = &_aryItems[dwCookie];

        if (pItem->IsMatch(dwCookie, pSourceObject))
            return pItem;
    }

    //
    // if failed to find, make the normal search
    //

    for (pItem = _aryItems, c = _aryItems.Size(); c; c--, pItem++)
    {
        if (pItem->IsMatch(dwCookie, pSourceObject))
            return pItem;
    }

    return NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptCookieTable::FindItemDerefed
//
//-------------------------------------------------------------------------

CScriptCookieTable::CItem *
CScriptCookieTable::FindItemDerefed(DWORD_PTR dwCookie, CBase * pSourceObject)
{
    CItem * pItem = FindItem(dwCookie, pSourceObject);

    if (pItem && ITEMTYPE_REF == pItem->_type)
    {
        CItem *pItemRef = FindItem(pItem->_dwCookieRef, pSourceObject);

        // If we had a ref to a revoked item
        if( !pItemRef || pItemRef->_type == ITEMTYPE_NULL )
        {
            // revoke the ref and return NULL
            pItem->_type = ITEMTYPE_NULL;
            pItem = NULL;
        }
        else
        {
            Assert( pItemRef->_type == ITEMTYPE_MARKUP );
            pItem = pItemRef;
        }
    }

    return pItem;
}
//+------------------------------------------------------------------------
//
//  Member:     CScriptCookieTable::GetSourceObjects
//
//-------------------------------------------------------------------------

HRESULT
CScriptCookieTable::GetSourceObjects(
    DWORD_PTR               dwCookie,
    CMarkup **              ppMarkup,
    CScriptElement **       ppScriptElement,
    CScriptDebugDocument ** ppScriptDebugDocument)
{
    HRESULT             hr = S_OK;
    CScriptElement *    pScriptElement;
    CItem *             pItem= FindItemDerefed(dwCookie);

    Assert (ppMarkup);

    if (!ppScriptElement)
        ppScriptElement = &pScriptElement;

    (*ppMarkup)        = NULL;
    (*ppScriptElement) = NULL;

    if (!pItem)
        goto Cleanup;

    switch (pItem->_type)
    {
    case ITEMTYPE_NULL:
            break;

    case ITEMTYPE_SCRIPTELEMENT:
            (*ppScriptElement) = pItem->_pScriptElement;
            Assert (*ppScriptElement);
            break;

    case ITEMTYPE_MARKUP:
            (*ppMarkup) = pItem->_pMarkup;
            Assert (*ppMarkup);
            break;

    default:
            Assert (FALSE);
            break;
    }

    if ((*ppScriptElement) && (*ppScriptElement)->IsInMarkup())
    {
        *ppMarkup = (*ppScriptElement)->GetMarkup();
    }

    if (ppScriptDebugDocument)
    {
        hr = THR(GetScriptDebugDocument(pItem, ppScriptDebugDocument));
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptCookieTable::GetScriptDebugDocument
//
//-------------------------------------------------------------------------

HRESULT
CScriptCookieTable::GetScriptDebugDocument(
    CItem *                 pItem,
    CScriptDebugDocument ** ppScriptDebugDocument)
{
    HRESULT     hr = S_OK;

    Assert (pItem && ppScriptDebugDocument);

    *ppScriptDebugDocument = NULL;

    switch (pItem->_type)
    {
    case ITEMTYPE_SCRIPTELEMENT:
            *ppScriptDebugDocument = pItem->_pScriptElement->_pScriptDebugDocument;
            break;

    case ITEMTYPE_MARKUP:
            *ppScriptDebugDocument = pItem->_pMarkup->HasScriptContext() ?
                pItem->_pMarkup->ScriptContext()->_pScriptDebugDocument : NULL;
            break;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptCookieTable::GetScriptDebugDocument
//
//-------------------------------------------------------------------------

HRESULT
CScriptCookieTable::GetScriptDebugDocument (
    DWORD_PTR               dwCookie,
    CScriptDebugDocument ** ppScriptDebugDocument)
{
    HRESULT             hr = S_OK;
    CItem *             pItem = FindItemDerefed(dwCookie);

    if (!pItem)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(GetScriptDebugDocument(pItem, ppScriptDebugDocument));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptCookieTable::RevokeSourceObject
//
//-------------------------------------------------------------------------

HRESULT
CScriptCookieTable::RevokeSourceObject(DWORD_PTR dwCookie, CBase * pSourceObject)
{
    HRESULT     hr = S_OK;
    CItem *     pItem = FindItem(dwCookie, pSourceObject);

    if (pItem)
    {
        // assert that we do not revoke same thing twice
        Assert (ITEMTYPE_NULL != pItem->_type);

        pItem->_type = ITEMTYPE_NULL;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptCookieTable::GetScriptDebugDocumentContext
//
//-------------------------------------------------------------------------

HRESULT
CScriptCookieTable::GetScriptDebugDocumentContext(
    DWORD_PTR                   dwCookie,
    ULONG                       uCharacterOffset,
    ULONG                       uNumChars,
    IDebugDocumentContext **    ppDebugDocumentContext)
{
    HRESULT                 hr;
    CScriptDebugDocument *  pScriptDebugDocument;

    if (!ppDebugDocumentContext)
        RRETURN(E_POINTER);

    hr = THR(GetScriptDebugDocument(dwCookie, &pScriptDebugDocument));
    if (hr)
        goto Cleanup;

    Assert (pScriptDebugDocument);

    hr = THR(pScriptDebugDocument->GetDocumentContext(dwCookie, uCharacterOffset, uNumChars, ppDebugDocumentContext));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CScriptDebugDocument
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::CreateScriptDebugDocument, static helper
//
//-------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::Create(CCreateInfo * pInfo, CScriptDebugDocument ** ppScriptDebugDocument)
{
    HRESULT                 hr = S_OK;

    Assert (ppScriptDebugDocument);

    *ppScriptDebugDocument = NULL;

    if ( !pInfo->_pMarkup->GetScriptCollection()
#ifndef NO_SCRIPT_DEBUGGER
        || !g_pPDM || !g_pDebugApp
#endif
        )
            goto Cleanup;

    *ppScriptDebugDocument = new CScriptDebugDocument();
    if (!(*ppScriptDebugDocument))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR((*ppScriptDebugDocument)->Init(pInfo));

Cleanup:

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument constructor
//
//-------------------------------------------------------------------------

CScriptDebugDocument::CScriptDebugDocument()
{
#if DBG == 1
    _Host._pScriptDebugDocumentDbg = this;
#endif
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument destructor
//
//-------------------------------------------------------------------------

CScriptDebugDocument::~CScriptDebugDocument()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::Init
//
//-------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::Init(CCreateInfo * pInfo)
{
    HRESULT                 hr = S_OK;
    LPTSTR                  pchShortName;
    LPTSTR                  pchLongName;
    IDebugDocumentHelper *  pParentDebugHelper;

    //
    // setup data
    //

    hr = THR(_DebugHelperCriticalSection.Init());
    if (hr)
        goto Cleanup;

    _dwThreadId = pInfo->_pMarkup->Doc()->_dwTID;

    hr = THR(_cstrUrl.Set(pInfo->_pchUrl));
    if (hr)
        goto Cleanup;

    //
    // pInfo->_pMarkupHtmCtx or pInfo->_pchSource may be necessary in methods called from threads
    // other then main doc's thread. To avoid free-threading issues with access to the data,
    // we take it local (pInfo->_pchSource) or keep it SubAddRefed (pInfo->_pMarkupHtmCtx) for lifetime.
    // SubAddRef on HtmCtx is enough because it is already free-threaded.
    //

    if (pInfo->_pMarkupHtmCtx)
    {
        Assert (!pInfo->_pchScriptElementCode);

        _pMarkupHtmCtx = pInfo->_pMarkupHtmCtx;
        _pMarkupHtmCtx->SubAddRef();
    }
    else if (pInfo->_pchScriptElementCode)
    {
        hr = THR(_cstrScriptElementCode.Set(pInfo->_pchScriptElementCode));
        if (hr)
            goto Cleanup;
    }

    //
    // create and initialize
    //
#ifndef NO_SCRIPT_DEBUGGER
    hr = THR(g_pPDM->CreateDebugDocumentHelper (0, &_pDebugHelper));
    if (hr)
#endif
        goto Cleanup;

    GetDebugHelper(NULL);   // balanced by ReleaseDebugHelper in Passivate

    hr = THR(GetNamesFromUrl(_cstrUrl, &pchShortName, &pchLongName));
    if (hr)
        goto Cleanup;

#ifndef NO_SCRIPT_DEBUGGER
    hr = THR(_pDebugHelper->Init( g_pDebugApp, pchShortName, pchLongName, 0));
    if (hr)
#endif
        goto Cleanup;

    hr = THR(_pDebugHelper->SetDebugDocumentHost (&_Host));
    if (hr)
        goto Cleanup;

    //
    // set parent
    //

    pParentDebugHelper = NULL;

    if (!pInfo->_pMarkup->IsPrimaryMarkup())
    {
        CMarkup * pMarkup =  pInfo->_pMarkup->GetFrameOrPrimaryMarkup();
        CMarkup * pMarkupParent = NULL;

        // if the markup we received with the information is a frame or primary
        // markup, then we can assume that we are a frame because of the state
        // we are in.
        if ( pMarkup == pInfo->_pMarkup)
        {
            if (pMarkup->Root()->HasMasterPtr())
            {
                pMarkupParent = pMarkup->Root()->GetMasterPtr()->GetMarkup();
            }
        }
        else
        {
            // The markup that we received with the information is not a frame or primary
            // markup. It may be created in the ether or it may be an HTC. Set the parent
            // to the frame/primary markup of this markup.
            pMarkupParent = pMarkup;
        }

        // It is possible that the element that we are hanging off from is a frame/iframe
        // and in the ether.
        // In that case, we may have a NULL parent markup.
        if (pMarkupParent)
        {
            IGNORE_HR(pMarkupParent->EnsureScriptContext());

            CMarkupScriptContext * pScriptContext = pMarkupParent->ScriptContext();

            if (pScriptContext && pScriptContext->_pScriptDebugDocument)
            {
                pParentDebugHelper = pScriptContext->_pScriptDebugDocument->_pDebugHelper;
            }
        }
    }

    hr = THR(_pDebugHelper->Attach(pParentDebugHelper));
    if (hr)
        goto Cleanup;

Cleanup:

    if (hr && _pDebugHelper)
    {
        ReleaseDebugHelper(NULL);
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::Passivate
//
//-------------------------------------------------------------------------

void
CScriptDebugDocument::Passivate()
{
    ReleaseDebugHelper(NULL);   // to balance GetDebugHelper(NULL) in Init

    if (_pMarkupHtmCtx)
    {
        _pMarkupHtmCtx->SubRelease();
        _pMarkupHtmCtx = NULL;
    }

    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::GetDebugHelper
//
//-------------------------------------------------------------------------

void
CScriptDebugDocument::GetDebugHelper (IDebugDocumentHelper ** ppDebugHelper)
{
    _DebugHelperCriticalSection.Enter();

    if (_pDebugHelper)
    {
        _cDebugHelperAccesses++;

        if (ppDebugHelper)
        {
            *ppDebugHelper = _pDebugHelper;
            _pDebugHelper->AddRef();
        }
    }

    _DebugHelperCriticalSection.Leave();
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::ReleaseDebugHelper
//
//-------------------------------------------------------------------------

void
CScriptDebugDocument::ReleaseDebugHelper(IDebugDocumentHelper * pDebugHelper)
{
    IDebugDocumentHelper *  pDebugHelperToDetach = NULL;

    _DebugHelperCriticalSection.Enter();

    if (_pDebugHelper)
    {
        Assert(_cDebugHelperAccesses);

        _cDebugHelperAccesses--;

        if (0 == _cDebugHelperAccesses)
        {
            pDebugHelperToDetach = _pDebugHelper;
            if (pDebugHelperToDetach)
            {
                pDebugHelperToDetach->AddRef();
                ClearInterface(&_pDebugHelper);
            }
        }
    }

    _DebugHelperCriticalSection.Leave();

    if (pDebugHelperToDetach)
    {
        IGNORE_HR(pDebugHelperToDetach->Detach());
        pDebugHelperToDetach->Release();
    }

    ReleaseInterface (pDebugHelper);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::CreateDebugContext
//
//-------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::DefineScriptBlock(
    IActiveScript *     pActiveScript,
    ULONG               ulOffset,
    ULONG               ulCodeLen,
    BOOL                fScriptlet,
    DWORD_PTR *         pdwScriptCookie)
{
    HRESULT  hr = E_FAIL;

    Assert (pActiveScript && pdwScriptCookie);

    *pdwScriptCookie = NO_SOURCE_CONTEXT;

    if (_pDebugHelper)
        hr = THR(_pDebugHelper->DefineScriptBlock(ulOffset, ulCodeLen, pActiveScript, fScriptlet, pdwScriptCookie));

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::IllegalCall
//
//---------------------------------------------------------------------------

BOOL
CScriptDebugDocument::IllegalCall()
{
    if (_dwThreadId != GetCurrentThreadId())
    {
        AssertSz(FALSE, "Script debugger called across thread boundry (not an MSHTML bug)");
        return TRUE;
    }

    return FALSE;
}

//---------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::GetDocumentContext
//
//---------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::GetDocumentContext(
    DWORD_PTR                   dwCookie,
    ULONG                       uCharacterOffset,
    ULONG                       uNumChars,
    IDebugDocumentContext **    ppDebugDocumentContext)
{
    HRESULT                 hr;
    ULONG                   ulStartOffset;
    IDebugDocumentHelper *  pDebugHelper = NULL;

    GetDebugHelper(&pDebugHelper);
    if (!pDebugHelper)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    hr = THR(pDebugHelper->GetScriptBlockInfo(dwCookie, NULL, &ulStartOffset, NULL));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(pDebugHelper->CreateDebugDocumentContext(
        ulStartOffset + uCharacterOffset, uNumChars, ppDebugDocumentContext));

Cleanup:

    ReleaseDebugHelper(pDebugHelper);

    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::SetDocumentSize
//
//---------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::SetDocumentSize(ULONG ulSize)
{
    HRESULT     hr = S_OK;

    hr = THR(RequestDocumentSize(ulSize));
    if (hr)
        goto Cleanup;

    hr = THR(UpdateDocumentSize());

Cleanup:
    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::RequestDocumentSize
//
//---------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::RequestDocumentSize(ULONG ulSize)
{
    HRESULT     hr = S_OK;

    TraceTag((
        tagDebuggerDocumentSize,
        "CScriptDebugDocument::RequestDocumentSize: url: %ls, current size = %ld, requested size = %ld",
        (LPTSTR)_cstrUrl, _ulCurrentSize, ulSize));

    _ulNewSize = max (_ulCurrentSize, ulSize);

    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::UpdateDocumentSize
//
//---------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::UpdateDocumentSize()
{
    HRESULT     hr = S_OK;

    TraceTag((
        tagDebuggerDocumentSize,
        "CScriptDebugDocument::UpdateDocumentSize: url: %ls, current size = %ld, new size = %ld",
        (LPTSTR)_cstrUrl, _ulCurrentSize, _ulNewSize));

    if (_ulCurrentSize < _ulNewSize )
    {
#ifndef NO_SCRIPT_DEBUGGER
        if (_pDebugHelper)
            hr = THR(_pDebugHelper->AddDeferredText (_ulNewSize - _ulCurrentSize, _ulCurrentSize));
#endif

        _ulCurrentSize = _ulNewSize;
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::ViewSourceInDebugger
//
//----------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::ViewSourceInDebugger (ULONG ulLine, ULONG ulOffsetInLine)
{
    HRESULT                 hr = S_OK;
    ULONG                   ulLineOffset = 0;
    IDebugDocumentText *    pDebugDocumentText = NULL;
    IDebugDocumentContext * pDebugDocumentContext = NULL;

    hr = THR(UpdateDocumentSize());
    if (hr)
        goto Cleanup;

    if (ulLine || ulOffsetInLine)
    {
        hr = THR(_pDebugHelper->QueryInterface(IID_IDebugDocumentText, (void**)&pDebugDocumentText));
        if(hr)
            goto Cleanup;

        hr = THR(pDebugDocumentText->GetPositionOfLine(ulLine, &ulLineOffset));
        if(hr)
            goto Cleanup;
    }

    hr = THR(_pDebugHelper->CreateDebugDocumentContext(ulLineOffset + ulOffsetInLine, 0, &pDebugDocumentContext));
    if (hr)
        goto Cleanup;

    hr = THR(_pDebugHelper->BringDocumentContextToTop (pDebugDocumentContext));

Cleanup:

    ReleaseInterface(pDebugDocumentText);
    ReleaseInterface(pDebugDocumentContext);

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::CHost::QueryInterface, per IUnknown
//
//---------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::CHost::QueryInterface(REFIID iid, void **ppv)
{
    if (SDD()->IllegalCall())
        RRETURN(E_NOINTERFACE);

    if (!ppv)
        RRETURN(E_POINTER);

    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS(this, IUnknown)
    QI_INHERITS(this, IDebugDocumentHost)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::CHost::GetDeferredText, per IDebugDocumentHost
//
//----------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::CHost::GetDeferredText(
    DWORD               dwStart,
    WCHAR *             pchText,
    SOURCE_TEXT_ATTR *  ,
    ULONG *             pcTextLen,
    ULONG               cMaxTextLen)
{
    HRESULT     hr = S_OK;

    if (!pchText || !pcTextLen)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (SDD()->_pMarkupHtmCtx)
    {
        hr = THR(SDD()->_pMarkupHtmCtx->ReadUnicodeSource(pchText, dwStart, cMaxTextLen, pcTextLen));
    }
    else
    {
        Assert (!SDD()->_cstrScriptElementCode.IsNull());
        if (SDD()->_cstrScriptElementCode.Length() <= dwStart )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        *pcTextLen = min ((ULONG)(SDD()->_cstrScriptElementCode.Length() - dwStart), cMaxTextLen - 1);

        _tcsncpy(pchText, SDD()->_cstrScriptElementCode, *pcTextLen);

        pchText[*pcTextLen] = 0;
    }

Cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::CHost::GetPathName, per IDebugDocumentHost
//
//----------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::CHost::GetPathName(BSTR * pbstrLongName, BOOL * pfIsOriginalFile)
{
    HRESULT         hr = E_NOTIMPL;

    Assert (FALSE && "not implemeneted; not supposed to be called");

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CScriptDebugDocument::CHost::GetFileName, per IDebugDocumentHost
//
//----------------------------------------------------------------------------

HRESULT
CScriptDebugDocument::CHost::GetFileName(BSTR * pbstrShortName)
{
    HRESULT         hr = E_NOTIMPL;

    Assert (FALSE && "not implemeneted; not supposed to be called");

    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\cutil.cxx ===
//+---------------------------------------------------------------------
//
//   File:      cutil.cxx
//
//  Contents:   Utility functions for CSite, move out from csite.cxx
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_SELECOBJ_HXX_
#define X_SELECOBJ_HXX_
#include "selecobj.hxx"
#endif

#ifndef X_XBAG_HXX_
#define X_XBAG_HXX_
#include "xbag.hxx"
#endif

#ifndef X_RTFTOHTM_HXX_
#define X_RTFTOHTM_HXX_
#include "rtftohtm.hxx"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include "shell.h"
#endif

#ifndef X_OLEDLG_H_
#define X_OLEDLG_H_
#include <oledlg.h>
#endif

MtDefine(DoInsertObjectUI_plptszResult, Utilities, "DoInsertObjectUI *plptszResult")

extern "C" const CLSID CLSID_HTMLImg;
extern "C" const CLSID CLSID_HTMLButtonElement;
//extern "C" const CLSID CLSID_HTMLInputTextElement;
extern "C" const CLSID CLSID_HTMLTextAreaElement;
//extern "C" const CLSID CLSID_HTMLOptionButtonElement;
extern "C" const CLSID CLSID_HTMLListElement;
extern "C" const CLSID CLSID_HTMLMarqueeElement;
extern "C" const CLSID CLSID_HTMLDivPosition;
extern "C" const CLSID CLSID_HTMLHRElement;
extern "C" const CLSID CLSID_HTMLIFrame;
//extern "C" const CLSID CLSID_HTMLInputButtonElement;
//extern "C" const CLSID CLSID_HTMLInputFileElement;
extern "C" const CLSID CLSID_HTMLFieldSetElement;
extern "C" const CLSID CLSID_HTMLParaElement;
extern "C" const CLSID CLSID_HTMLInputElement;

static const struct HTMLSTRMAPPING
{
    UINT        cmd;
    const CLSID *     pClsid;
    LPCSTR      lpsz;
}
s_aHtmlMaps[] =
{   
    { 0,                    NULL,                           "<OBJECT %s></OBJECT>"},
    { IDM_IMAGE,            &CLSID_HTMLImg,                 "<IMG%s>"},
    { IDM_BUTTON,           &CLSID_HTMLButtonElement,       "<BUTTON%s></BUTTON>"},
    //{ IDM_RICHTEXT,         &CLSID_HTMLRichtextElement,     "<RICHTEXT%s></RICHTEXT"},
    { IDM_TEXTBOX,          &CLSID_HTMLInputElement,        "<INPUT TYPE = TEXT%s>"},
    { IDM_TEXTAREA,         &CLSID_HTMLTextAreaElement,     "<TEXTAREA%s></TEXTAREA>"},
    { IDM_CHECKBOX,         NULL,                           "<INPUT TYPE = CHECKBOX%s>"},   
    { IDM_RADIOBUTTON,      &CLSID_HTMLInputElement,        "<INPUT TYPE = RADIO%s>"},
    { IDM_DROPDOWNBOX,      &CLSID_HTMLListElement,         "<SELECT%s> </SELECT>"},
    { IDM_LISTBOX,          NULL,                           "<SELECT MULTIPLE%s> </SELECT>"},
    { IDM_MARQUEE,          &CLSID_HTMLMarqueeElement,      "<MARQUEE%s></MARQUEE>"},
    { IDM_1D,               &CLSID_HTMLDivPosition,         "<DIV STYLE=POSITION:RELATIVE%s></DIV>"},
    { IDM_HORIZONTALLINE,   &CLSID_HTMLHRElement,           "<HR%s>"},
    { IDM_IFRAME,           &CLSID_HTMLIFrame,              "<IFRAME%s></IFRAME>"},
    { IDM_INSINPUTBUTTON,   &CLSID_HTMLInputElement,        "<INPUT TYPE = BUTTON%s>"},
    { IDM_INSINPUTRESET,    NULL,                           "<INPUT TYPE = RESET%s>"},
    { IDM_INSINPUTSUBMIT,   NULL,                           "<INPUT TYPE = SUBMIT%s>"},
    { IDM_INSINPUTUPLOAD,   &CLSID_HTMLInputElement,        "<INPUT TYPE = FILEUPLOAD%s>"},
    { IDM_INSINPUTIMAGE,    &CLSID_HTMLInputElement,        "<INPUT TYPE = IMAGE%s>"},
    { IDM_INSINPUTHIDDEN,   NULL,                           "<INPUT TYPE = HIDDEN%s>"},
    { IDM_INSINPUTPASSWORD, NULL,                           "<INPUT TYPE = PASSWORD%s>"},
    { IDM_INSFIELDSET,      &CLSID_HTMLFieldSetElement,     "<FIELDSET%s></FIELDSET>"},
    { IDM_PARAGRAPH,        &CLSID_HTMLParaElement,         "<P%s>"},
    { IDM_NONBREAK,         NULL,                           "&nbsp;"}
};

typedef LPTSTR (*PFILEHELPER) (LPTSTR, LPTSTR, int, int *);


HRESULT
ClsidParamStrFromClsid (CLSID * pClsid, LPTSTR ptszParam, int cbParam)
{
    HRESULT     hr;

    hr = THR(Format (
        0, ptszParam, cbParam,
        _T("CLASSID = \"clsid<0g>"),
        pClsid
    ));
    if (!OK(hr))
        goto Cleanup;

    if ( (_T('{') != ptszParam[16+0]) || (_T('}') != ptszParam[16+37]) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    ptszParam[16+0 ] = _T(':');
    ptszParam[16+37] = _T('"');

Cleanup:
    RRETURN (hr);
}


HRESULT
ClsidParamStrFromClsidStr (LPTSTR ptszClsid, LPTSTR ptszParam, int cbParam)
{
    HRESULT     hr;

    hr = THR(Format (
        0, ptszParam, cbParam,
        _T("CLASSID = \"clsid<0s>"),
        ptszClsid
    ));
    if (!OK(hr))
        goto Cleanup;

    if ( (_T('{') != ptszParam[16+0]) || (_T('}') != ptszParam[16+37]) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    ptszParam[16+0 ] = _T(':');
    ptszParam[16+37] = _T('"');

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Function:   HtmlTagStrFromParam
//
//  Synopsis:   If it is intrinic control, create html tag and return S_OK
//
//-------------------------------------------------------------------------
HRESULT
HtmlTagStrFromParam (LPTSTR lptszInsertParam, int *pnFound)
{
    HRESULT             hr = E_FAIL;
    int                 i;
    TCHAR               aszClsid[CLSID_STRLEN + 1];
    CLSID               clsid;
    TCHAR  *            pch;

    Assert(pnFound);

    if (!lptszInsertParam)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Get clsid string from lptszInsertParam

    pch = _tcsstr(lptszInsertParam, _T(":"));
    if (!pch)
        goto Cleanup;

    _tcscpy(aszClsid, pch);

    aszClsid[0] = _T('{');
    aszClsid[CLSID_STRLEN - 1] = _T('}');
    aszClsid[CLSID_STRLEN] = 0;

    hr = CLSIDFromString(aszClsid, &clsid);
    if (hr)
        goto Cleanup;

    // find mapping
    for (i = 0; i < ARRAY_SIZE(s_aHtmlMaps); i++)
    {
        if (!s_aHtmlMaps[i].pClsid)
            continue;

        if (clsid.Data1 != s_aHtmlMaps[i].pClsid->Data1)
            continue;

        if(IsEqualCLSID(clsid, *s_aHtmlMaps[i].pClsid))
        {
            // match is found
            *pnFound = i;
            hr = S_OK;
            goto Cleanup;
        }
    }

    // No match is found
     *pnFound = -1;

Cleanup:
    RRETURN(hr);
}

#ifndef NO_OLEUI

//--------------------------------------------------------------------
// OleUIMetafilePictIconFree
//
// Purpose:
//  Deletes the metafile contained in a METAFILEPICT structure and
//  frees the memory for the structure itself.
//
// Parameters:
//  hMetaPict       HGLOBAL metafilepict structure created in
//                  OleUIMetafilePictFromIconAndLabel
//
// Return Value:
//  None
//-------------------------------------------------------------------

STDAPI_(void) OleUIMetafilePictIconFree(HGLOBAL hMetaPict)
{
    LPMETAFILEPICT      pMF;

    if (NULL==hMetaPict)
        return;

    pMF=(LPMETAFILEPICT)GlobalLock(hMetaPict);

    if (NULL!=pMF)
    {
        if (NULL!=pMF->hMF)
            DeleteMetaFile(pMF->hMF);
    }

    GlobalUnlock(hMetaPict);
    GlobalFree(hMetaPict);
}

//+----------------------------------------------------------------------------
//
//  Function:     DoInsertObjectUI
//
//  Synopsis:   executes UI for Insert / Object
//
//  Arguments   [out] dwResult      specifies what was specified in UI
//              [out] plptszResult  specifies classid, file name, etc., depending
//                                  on dwResult flags
//
//  Returns:    S_OK                OK hit in UI, plptszResult set
//              S_FALSE             CANCEL hit in UI, NULL == *plptszResult
//              other               failure
//
//-----------------------------------------------------------------------------

DYNLIB g_dynlibOLEDLG = { NULL, NULL, "OLEDLG.DLL" };

DYNPROC g_dynprocOleUIInsertObjectA =
         { NULL, &g_dynlibOLEDLG, "OleUIInsertObjectA" };

HRESULT
DoInsertObjectUI (CElement * pElement, DWORD * pdwResult, LPTSTR * plptszResult)
{
    HRESULT                 hr = S_OK;
    OLEUIINSERTOBJECTA      ouio;
    CHAR                    szFile[MAX_PATH] = "";
    TCHAR                   wszFile[MAX_PATH];
    UINT                    uRC;

    *pdwResult = 0;
    *plptszResult = NULL;

    // zero ouio
    memset(&ouio, 0, sizeof(ouio));

    // and fill it out
    ouio.cbStruct = sizeof(ouio);
    ouio.dwFlags =
            IOF_DISABLELINK |       // BUBUG Remove when form supports links.
            IOF_SELECTCREATENEW |
            IOF_DISABLEDISPLAYASICON |
            IOF_HIDECHANGEICON |
            IOF_VERIFYSERVERSEXIST |
            IOF_SHOWINSERTCONTROL;
    ouio.hWndOwner = pElement->Doc()->InPlace()->_hwnd;
    ouio.lpszFile = szFile;
    ouio.cchFile = ARRAY_SIZE(szFile);

    hr = THR(LoadProcedure(&g_dynprocOleUIInsertObjectA));
    if (!OK(hr))
        goto Cleanup;

    uRC = (*(UINT (STDAPICALLTYPE *)(LPOLEUIINSERTOBJECTA))
            g_dynprocOleUIInsertObjectA.pfn)(&ouio);

    hr = (OLEUI_OK     == uRC) ? S_OK :
         (OLEUI_CANCEL == uRC) ? S_FALSE :
                                 E_FAIL;
    if (S_OK != hr)
        goto Cleanup;

    Assert((ouio.dwFlags & IOF_SELECTCREATENEW) ||
           (ouio.dwFlags & IOF_SELECTCREATEFROMFILE) ||
           (ouio.dwFlags & IOF_SELECTCREATECONTROL));

    *pdwResult = ouio.dwFlags;

    if (*pdwResult & (IOF_SELECTCREATENEW|IOF_SELECTCREATECONTROL))
    {
        const int cbResult = 128;

        *plptszResult = new(Mt(DoInsertObjectUI_plptszResult)) TCHAR[cbResult];
        hr = (*plptszResult) ? S_OK : E_OUTOFMEMORY;
        if (!OK(hr))
            goto Cleanup;

        ClsidParamStrFromClsid (&ouio.clsid, *plptszResult, cbResult);
    }
    else // if (*pdwResult & IOF_SELECTCREATEFROMFILE)
    {
        int     nFile;

        nFile = MultiByteToWideChar(CP_ACP, 0,
            szFile, -1,
            wszFile, ARRAY_SIZE(wszFile));

        if (0 == nFile)
        {
            hr = HRESULT_FROM_WIN32(GetLastWin32Error());
            Assert (!OK(hr));
            goto Cleanup;
        }

        *plptszResult = new(Mt(DoInsertObjectUI_plptszResult)) TCHAR[nFile+1];
        hr = (*plptszResult) ? S_OK : E_OUTOFMEMORY;
        if (!OK(hr))
            goto Cleanup;

        _tcscpy ((LPTSTR)(*plptszResult), wszFile);
    }
Cleanup:
    if (ouio.hMetaPict)
        OleUIMetafilePictIconFree(ouio.hMetaPict);

    if (!OK(hr))
    {
        ClearErrorInfo();
        PutErrorInfoText(EPART_ACTION, IDS_EA_INSERT_CONTROL);
        pElement->CloseErrorInfo(hr);
    }

    RRETURN1 (hr, S_FALSE);
}
#endif  // NO_OLEUI

//+------------------------------------------------------------------------
//
//  Function:   ObjectParamStrFromDO
//
//  Synopsis:   creates object param string which will then be inserted
//              into html like this: <OBJECT %s> </OBJECT>
//
//  Arguments:  [in] pDO                data object to convert
//              [in] prc                rectangle which specifies size of the object
//                                      if NULL, no size specified
//                                      if not NULL and left <= right and top <= bottom,
//                                      (right-left, bottom-top) specify the size
//              [in-out] lptszParam     output string
//              [in] cbParam            max len of output string
//              [out] pfNeedToCreateFromDO
//                                      true if this object need to
//                                      be created from a data object
//
//-------------------------------------------------------------------------

HRESULT
ObjectParamStrFromDO (IDataObject * pDO, RECT * prc,
                      LPTSTR lptszParam, int cbParam)
{
    HRESULT         hr = S_OK;
    TCHAR           tszParam[pdlUrlLen + 10] = _T("");
    TCHAR           tszHW[64] = _T("");
    TCHAR           tszClsid[CLSID_STRLEN + 1] = _T("");

    // tszParam used for both file name and clsid param, so make sure it will
    // be able to contain CLSID param
    Assert (64 < MAX_PATH);
    TCHAR *pFormatStr = _T("style=\"WIDTH = <0d>px HEIGHT = <1d>px TOP = <2d>px LEFT = <3d>px\" ");

    // set HEIGHT & WIDTH attrs if any
    if (prc && (prc->left <= prc->right) && (prc->top <= prc->bottom) )
    {
        hr = THR(Format (
            0, tszHW, ARRAY_SIZE (tszHW),
            pFormatStr,
            prc->right - prc->left, prc->bottom - prc->top,
            prc->top, prc->left ) );
        if (!OK(hr))
            goto Cleanup;
    }

    //
    if (OK(GetcfCLSIDFmt(pDO, tszClsid)))
    {
        hr = THR(ClsidParamStrFromClsidStr(tszClsid, tszParam, ARRAY_SIZE(tszParam)));
        if (!OK(hr))
            goto Cleanup;
    }
    else
    {
        tszParam[0] = 0;
        
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR(Format (
        0, lptszParam, cbParam,
        _T("<0s><1s>"),
        tszHW, tszParam
    ));

Cleanup:

    RRETURN1 (hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetShortcutFileName
//
//  Synopsis:   Generate file name for URL shortcut
//
//  Arguments:  [pchUrl]    URL to be used for creating the shortcut (input)
//              [pchName]   Description of the URL (input)
//              [pchOut]    Buffer (must be of size MAX_PATH or more) to return
//                          file name (output)
//
//  Notes:      We should throw away this code and use the shell function
//              GetShortcutFileName() instead as and when that becomes
//              available as an exported function.
//
//----------------------------------------------------------------------------

BOOL
GetShortcutFileName(const TCHAR * pchUrl, const TCHAR * pchName, TCHAR * pchOut)
{
    TCHAR   achBuf[MAX_PATH-4];

    Assert(pchUrl && *pchUrl);
    Assert(pchOut);

    achBuf[0] = 0;

    // Use name/title if one is supplied
    if (pchName && *pchName)
    {
        _tcsncpy(achBuf, pchName, MAX_PATH - 5);

        // Force this to be null-terminated, since _tcsncpy does not always do so.
        achBuf[MAX_PATH - 5] = 0;
        
        // Remove leading space
        StrTrim(achBuf, _T(" \t\r\n"));
    }

    // Otherwise, use the URL
    if (!achBuf[0])
    {
        _tcsncpy(achBuf, PathFindFileName(pchUrl), MAX_PATH - 5);

        // Force this to be null-terminated, since _tcsncpy does not always do so.
        achBuf[MAX_PATH - 5] = 0;
        
        // Remove leading space
        StrTrim(achBuf, _T(" \t\r\n"));
    }

    // Validate the file name
    if (!PathCanonicalize(pchOut, achBuf))
    {
        return FALSE;
    }

    // Replace any remaining invalid characters with '-'
    while (*pchOut)
    {
        if (PathGetCharType(*pchOut) & (GCT_INVALID | GCT_WILD | GCT_SEPARATOR))
        {
            *pchOut = _T('-');
        }
        pchOut++;
    }


    _tcscat(pchOut, _T(".url"));
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateLinkDataObject
//
//  Synopsis:   Create a link data object as an Internet Shortcut
//
//  Arguments:  [pchUrl]    URL to be used for creating the shortcut (input)
//              [pchName]   Description of the URL (input)
//              [ppLink]    Pointer to the link data object created (output)
//
//  Notes:      Mostly copied from IE3.
//
//----------------------------------------------------------------------------
HRESULT
CreateLinkDataObject(const TCHAR *              pchUrl,
                     const TCHAR *              pchName,
                     IUniformResourceLocator ** ppLink)
{
#if defined(WIN16) || defined(WINCE)
    return E_FAIL;
#else
    HRESULT         hr = S_OK;
    IShellLink *    pisl = NULL;
    TCHAR           achFileName[MAX_PATH];

    if (!pchUrl || !*pchUrl || !ppLink)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppLink = NULL;
    hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
                           IID_IUniformResourceLocator, (void **)ppLink);
    if (hr)
        goto Cleanup;

    hr = (*ppLink)->SetURL(pchUrl, 0);
    if (hr)
    {
        // Translate URL-specific failure into generic failure.
        if (hr == URL_E_INVALID_SYNTAX)
            hr = E_FAIL;

        goto Cleanup;
    }

    hr = (*ppLink)->QueryInterface(IID_IShellLink, (void **)&pisl);
    if (hr != S_OK)
        goto Cleanup;

    if (!GetShortcutFileName(pchUrl, pchName, achFileName))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IGNORE_HR(pisl->SetDescription(achFileName));
    ReleaseInterface(pisl);

Cleanup:
    RRETURN(hr);
#endif
}


//+---------------------------------------------------------------------------
//
//  Function:   CopyFileToClipboard
//
//  Synopsis:   Supports CF_HDROP format
//
//  Arguments:  [pchPath]   Fully expanded file path (input)
//              [pDO]       Pointer to the data object (input)
//
//  Notes:      Mostly copied from IE3.
//
//----------------------------------------------------------------------------
HRESULT
CopyFileToClipboard(const TCHAR * pchPath, CGenDataObject * pDO)
{
    HRESULT             hr = S_OK;
#ifndef WIN16
    ULONG               cchPath, cchAnsi;
    HGLOBAL             hgDropFiles = NULL;
    DROPFILES *         pdf;
    char *              pchDropPath;

    if (!pchPath || !*pchPath || !pDO)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    cchPath = _tcslen(pchPath);

    // Convert file path to ANSI. While NT shell can handle both
    // UNICODE and ANSI, Win95 shell can handle only ANSI.
    cchAnsi = WideCharToMultiByte(CP_ACP, 0, pchPath, cchPath + 1,
                NULL, 0, NULL, NULL);
    if (cchAnsi <= 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // (+ 2) for double null terminator.
    // GPTR does zero-init for us
    hgDropFiles = GlobalAlloc(GPTR,
                    sizeof(DROPFILES) + cchAnsi + 1);
    if (!hgDropFiles)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pdf = (DROPFILES *)hgDropFiles;
    if (!pdf)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    pdf->pFiles = sizeof(DROPFILES);
    // pdf->fWide = FALSE; // ZeroInit takes care of this

    pchDropPath = (char *)(pdf + 1);
    WideCharToMultiByte(CP_ACP, 0, pchPath, cchPath + 1,
                pchDropPath, cchAnsi+1, NULL, NULL);

    hr = pDO->AppendFormatData(CF_HDROP, hgDropFiles);
    if (hr)
        goto Cleanup;

    // Don't free hgDropFiles on subsequent error now that
    // hgDropFiles has been added to the data object.
    // IDataObject::Release() will.
    hgDropFiles = NULL;

Cleanup:
    if (hgDropFiles)
        GlobalFree(hgDropFiles);
#endif // !WIN16
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// Function: IsTabKey
//
// Test if CMessage is a TAB KEYDOWN message.
//
//-----------------------------------------------------------------------------
BOOL
IsTabKey(CMessage * pMessage)
{
    BOOL fTabOrder = FALSE;

    if (pMessage->message == WM_KEYDOWN)
    {
        if (pMessage->wParam == VK_TAB)
        {
            fTabOrder = (pMessage->dwKeyState & FCONTROL) ? (FALSE) : (TRUE);
        }
    }

    return fTabOrder;
}

//+---------------------------------------------------------------------------
//
// Function: IsFrameTabKey
//
// Test if CMessage is a CTRL+TAB or F6 KEYDOWN message.
//
//-----------------------------------------------------------------------------
BOOL
IsFrameTabKey(CMessage * pMessage)
{
    BOOL fResult = FALSE;

    if (pMessage->message == WM_KEYDOWN)
    {
        if ((pMessage->wParam == VK_TAB && (pMessage->dwKeyState & FCONTROL))
                || (pMessage->wParam == VK_F6))
        {
            fResult = TRUE;
        }
    }
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\dom.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DOM_HXX_
#define X_DOM_HXX_
#include "dom.hxx"
#endif

#ifndef X_COLLBASE_HXX_
#define X_COLLBASE_HXX_
#include "collbase.hxx"
#endif

#ifndef X_DOMCOLL_HXX_
#define X_DOMCOLL_HXX_
#include "domcoll.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_COMMENT_HXX
#define X_COMMENT_HXX
#include "comment.hxx"
#endif

#ifndef X_EOBJECT_HXX
#define X_EOBJECT_HXX
#include "eobject.hxx"
#endif

#define _cxx_
#include "dom.hdl"

////////////////////////////////////////////////////////////////////////////////
//
// DOM Helper methods:
//
////////////////////////////////////////////////////////////////////////////////

static 
HRESULT 
CrackDOMNode ( IUnknown *pNode, CDOMTextNode**ppTextNode, CElement **ppElement, CMarkup * pWindowedMarkupContext )
{
    CMarkup *pMarkup; // Used to check if node is of type CDocument

    HRESULT hr = THR(pNode->QueryInterface(CLSID_CElement, (void **)ppElement));
    if (hr)
    {
        // If node supports Markup, it cant be CElement or CDOMTextNode & by elimination, it has to be CDocument
        hr = THR(pNode->QueryInterface(CLSID_CMarkup, (void **)&pMarkup));
        if (hr)
        {
            if (ppTextNode)
            {
                hr = THR(pNode->QueryInterface(CLSID_HTMLDOMTextNode, (void **)ppTextNode));
                if (!hr && (pWindowedMarkupContext != (*ppTextNode)->GetWindowedMarkupContext()))
                    hr = E_INVALIDARG;
            }
        }
        else 
        {
            *ppElement = pMarkup->Root();      // If CDocument, set element to root element
            if ( pWindowedMarkupContext != pMarkup->GetWindowedMarkupContext() )
                hr = E_INVALIDARG;
        }
    }
    else 
    {
        Assert( (*ppElement)->Tag() != ETAG_ROOT );
        if ( pWindowedMarkupContext != (*ppElement)->GetWindowedMarkupContext())
            hr = E_INVALIDARG;
    }

    RRETURN ( hr );
}

static 
HRESULT 
CrackDOMNodeVARIANT ( VARIANT *pVarNode, CDOMTextNode**ppTextNode, CElement **ppElement, CMarkup * pWindowedMarkupContext )
{
    HRESULT hr = S_OK;

    switch (V_VT(pVarNode))
    {
    case VT_DISPATCH:
    case VT_UNKNOWN:
        if (V_UNKNOWN(pVarNode))
        {
            // Element OR Text Node ??
            hr = THR(CrackDOMNode(V_UNKNOWN(pVarNode), ppTextNode, ppElement, pWindowedMarkupContext));
        }
        break;
    case VT_NULL:
    case VT_ERROR:
        hr = S_OK;
        break;

    default:
        hr = E_INVALIDARG;
        break;
    }   
    RRETURN ( hr );
}

static
HRESULT
GetDOMInsertHelper ( CElement *pRefElement, CDOMTextNode *pRefTextNode, CMarkupPointer *pmkptrPos )
{
    HRESULT hr = E_UNEXPECTED;

    Assert ( pRefElement || pRefTextNode );
    Assert ( !(pRefElement && pRefTextNode ) );
    
    if ( pRefElement )
    {
        // Element Insert
        if (!pRefElement->IsInMarkup())
            goto Cleanup;

        hr = THR(pmkptrPos->MoveAdjacentToElement ( pRefElement, pRefElement->Tag() == ETAG_ROOT? ELEM_ADJ_AfterBegin : ELEM_ADJ_BeforeBegin ));
        if ( hr )
           goto Cleanup;
    }
    else 
    {
        // Text Node Insert
        // Reposition the text node, then confirm we are it's parent
        CMarkupPointer *pmkpTextPtr = NULL;

        hr = THR(pRefTextNode->GetMarkupPointer ( &pmkpTextPtr ));
        if ( hr )
            goto Cleanup;
        hr = THR(pmkptrPos->MoveToPointer ( pmkpTextPtr ));
        if ( hr )
           goto Cleanup;
    }

Cleanup:
    RRETURN ( hr );
}


static 
HRESULT 
InsertDOMNodeHelper ( CElement *pNewElement, CDOMTextNode *pNewTextNode, CMarkupPointer *pmkptrTarget )
{
    HRESULT hr = S_OK;

    Assert ( pNewTextNode || pNewElement );

    if ( pNewElement )
    {

        CDoc *pDoc = pNewElement->Doc();

        // Insert/Move element with content
        if (pNewElement->IsInMarkup() && !pNewElement->IsNoScope()) 
        {
            CMarkupPointer mkptrStart(pDoc);
            CMarkupPointer mkptrEnd(pDoc);

            Assert(pNewElement->Tag() != ETAG_PARAM);
            hr = THR(pNewElement->GetMarkupPtrRange (&mkptrStart, &mkptrEnd) );
            if ( hr )
                goto Cleanup;

            hr = THR(pDoc->Move(&mkptrStart, &mkptrEnd, pmkptrTarget, MUS_DOMOPERATION));
        }
        else
        {
            if (pNewElement->IsInMarkup())
            {
                Assert(pNewElement->Tag() != ETAG_PARAM || !DYNCAST(CParamElement, pNewElement)->_pelObjParent);
                hr = THR(pDoc->RemoveElement(pNewElement, MUS_DOMOPERATION));
                if ( hr )
                    goto Cleanup;
            }
            else if (pNewElement->Tag() == ETAG_PARAM)
            {
                // remove <PARAM> from exisiting <OBJECT> if present, first
                CParamElement *pelParam = DYNCAST(CParamElement, pNewElement);
                if (pelParam->_pelObjParent)
                {
                    Assert(pelParam->_idxParam != -1);
                    pelParam->_pelObjParent->RemoveParam(pelParam);
                    Assert(pelParam->_idxParam == -1);
                    Assert(!pelParam->_pelObjParent);
                }
            }


            hr = THR(pDoc->InsertElement(pNewElement, pmkptrTarget, NULL, MUS_DOMOPERATION));
        }

        if (hr)
            goto Cleanup;
    }
    else
    {
        // Insert Text content
        hr = THR(pNewTextNode->MoveTo ( pmkptrTarget ));
        if (hr)
            goto Cleanup;       
    }

Cleanup:
    RRETURN(hr);
}

static 
HRESULT 
RemoveDOMNodeHelper ( CDoc *pDoc, CElement *pChildElement, CDOMTextNode *pChildTextNode )
{ 
    HRESULT hr = S_OK;
    CMarkup *pMarkupTarget = NULL;

    Assert ( pChildTextNode || pChildElement );

    if ( pChildTextNode )
    {
        // Removing a TextNode
        hr = THR(pChildTextNode->Remove());
    }
    else if (pChildElement->IsInMarkup())
    {
        // Removing an element
        if (!pChildElement->IsNoScope())
        {
            CMarkupPointer mkptrStart ( pDoc );
            CMarkupPointer mkptrEnd ( pDoc );
            CMarkupPointer mkptrTarget ( pDoc );

            hr = THR(pDoc->CreateMarkup(&pMarkupTarget, pChildElement->GetWindowedMarkupContext()));
            if ( hr )
                goto Cleanup;

            hr = THR( pMarkupTarget->SetOrphanedMarkup( TRUE ) );
            if( hr )
                goto Cleanup;

            hr = THR(mkptrTarget.MoveToContainer(pMarkupTarget,TRUE));
            if (hr)
                goto Cleanup;

            hr = THR(pChildElement->GetMarkupPtrRange (&mkptrStart, &mkptrEnd) );
            if ( hr )
                goto Cleanup;

            hr = THR(pDoc->Move(&mkptrStart, &mkptrEnd, &mkptrTarget, MUS_DOMOPERATION));
        }
        else
            hr = THR(pDoc->RemoveElement(pChildElement, MUS_DOMOPERATION));
    }

Cleanup:
    ReleaseInterface ( (IUnknown*)pMarkupTarget ); // Creating it addref'd it once
    RRETURN(hr);
}


static
HRESULT 
ReplaceDOMNodeHelper ( CDoc *pDoc, CElement *pTargetElement, CDOMTextNode *pTargetNode,
    CElement *pSourceElement, CDOMTextNode *pSourceTextNode )
{
    CMarkupPointer mkptrInsert ( pDoc );
    HRESULT hr;

    // Position ourselves in the right spot
    hr = THR(GetDOMInsertHelper ( pTargetElement, pTargetNode, &mkptrInsert ));
    if ( hr )
        goto Cleanup;

    mkptrInsert.SetGravity ( POINTER_GRAVITY_Left );

    {
        // Lock the markup, to prevent it from going away in case the entire contents are being removed.
        CMarkup::CLock MarkupLock(mkptrInsert.Markup());

        // Remove myself
        hr = THR(RemoveDOMNodeHelper ( pDoc, pTargetElement, pTargetNode ));
        if ( hr )
            goto Cleanup;

        // Insert the new element & all its content
        hr = THR(InsertDOMNodeHelper( pSourceElement, pSourceTextNode, &mkptrInsert ));
        if ( hr )
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

static
HRESULT
SwapDOMNodeHelper ( CDoc *pDoc, CElement *pElem, CDOMTextNode *pTextNode,
                   CElement *pElemSwap, CDOMTextNode *pTextNodeSwap )
{
    CMarkupPointer  mkptrThisInsert ( pDoc );
    CMarkupPointer  mkptrSwapInsert ( pDoc );
    HRESULT hr;

    // Position ourselves in the right spot
    if (!pElem || pElem->IsInMarkup())
    {
        hr = THR(GetDOMInsertHelper ( pElem, pTextNode, &mkptrThisInsert ));
        if (hr)
            goto Cleanup;
    }

    if (!pElemSwap || pElemSwap->IsInMarkup())
    {
        hr = THR(GetDOMInsertHelper ( pElemSwap, pTextNodeSwap, &mkptrSwapInsert ));
        if (hr)
            goto Cleanup;
    }

    // Lock the markup, to prevent it from going away in case the entire contents are being removed.
    if (mkptrSwapInsert.Markup())
        mkptrSwapInsert.Markup()->AddRef();

    // Insert the new element & all its content
    if (mkptrThisInsert.IsPositioned())
        hr = THR(InsertDOMNodeHelper( pElemSwap, pTextNodeSwap, &mkptrThisInsert ));
    else
        hr = THR(RemoveDOMNodeHelper(pDoc, pElemSwap, pTextNodeSwap));

    if ( hr )
        goto Cleanup;

    // Insert the new element & all its content
    if (mkptrSwapInsert.IsPositioned())
    {
        hr = THR(InsertDOMNodeHelper( pElem, pTextNode, &mkptrSwapInsert ));
        mkptrSwapInsert.Markup()->Release();
    }
    else
        hr = THR(RemoveDOMNodeHelper(pDoc, pElem, pTextNode));

Cleanup:
    RRETURN(hr);
}

static
HRESULT
CreateTextNode ( CDoc *pDoc, CMarkupPointer *pmkpTextEnd, long lTextID, CDOMTextNode **ppTextNode ) 
{                        
    CMarkupPointer *pmarkupWalkBegin = NULL;
    HRESULT hr = S_OK;

    Assert ( ppTextNode );
    Assert ( !(*ppTextNode) );

    if ( lTextID != 0 )
    {
        *ppTextNode = (CDOMTextNode *)pDoc->
            _HtPvPvDOMTextNodes.Lookup ( (void *)(DWORD_PTR)(lTextID<<4) );
    }

    if ( !(*ppTextNode) )
    {
        // Need to create a Text Node
        pmarkupWalkBegin =  new CMarkupPointer (pDoc); 
        if ( !pmarkupWalkBegin )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pmarkupWalkBegin->MoveToPointer ( pmkpTextEnd ));
        if ( hr )
            goto Cleanup;

        hr = THR(pmarkupWalkBegin->Left( TRUE, NULL, NULL, NULL, NULL, &lTextID));
        if ( hr )
            goto Cleanup;

        if ( lTextID == 0 )
        {
            hr = THR(pmarkupWalkBegin->SetTextIdentity(pmkpTextEnd, &lTextID));
            if ( hr )
                goto Cleanup;
        }

        // Stick to the text
        hr = THR(pmarkupWalkBegin->SetGravity (POINTER_GRAVITY_Right));
        if ( hr )
            goto Cleanup;   
        // Need to set Glue Also!
        
        Assert( lTextID != 0 );

        *ppTextNode = new CDOMTextNode ( lTextID, pDoc, pmarkupWalkBegin );
        if ( !*ppTextNode )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        // Now give ownership of this markup pointer to the text Node
        pmarkupWalkBegin = NULL;
        
        hr = THR(pDoc->_HtPvPvDOMTextNodes.Insert ( (void*)(DWORD_PTR)(lTextID<<4), (void*)*ppTextNode ) );
        if ( hr )
            goto Cleanup;
    }
    else
    {
        (*ppTextNode)->AddRef();
    }


Cleanup:
    delete pmarkupWalkBegin; 
    RRETURN(hr);
}


static
HRESULT
GetPreviousHelper ( CDoc *pDoc, CMarkupPointer *pmarkupWalk, IHTMLDOMNode **ppNode )
{
    HRESULT hr = S_OK;
    CTreeNode *pNodeLeft;
    MARKUP_CONTEXT_TYPE context;
    long lTextID;

    if (!ppNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppNode = NULL;
    
    hr = THR(pmarkupWalk->Left( FALSE, &context, &pNodeLeft, NULL, NULL, &lTextID));
    if ( hr )
        goto Cleanup;

    switch ( context )
    {
    case CONTEXT_TYPE_Text:
        {
            // Text Node
            CDOMTextNode *pTextNode = NULL;

            // If we find text we ccannot have left the scope of our parent
            hr = THR(CreateTextNode (pDoc, pmarkupWalk, lTextID, 
                &pTextNode ));
            if ( hr )
                goto Cleanup;

            hr = THR ( pTextNode->QueryInterface ( IID_IHTMLDOMNode, (void **)ppNode ) );
            if ( hr )
                goto Cleanup;
            pTextNode->Release();
        }
        break;

    case CONTEXT_TYPE_EnterScope:
    case CONTEXT_TYPE_NoScope:
        // Return Disp to Element
        hr = THR(pNodeLeft->GetElementInterface ( IID_IHTMLDOMNode, (void **) ppNode  ));
        if ( hr )
            goto Cleanup;
        break;

    case CONTEXT_TYPE_ExitScope:
    case CONTEXT_TYPE_None:
        break;

    default:
        Assert(FALSE); // Should never happen
        break;
    }
Cleanup:
    RRETURN(hr);
}


static
HRESULT
GetNextHelper ( CDoc *pDoc, CMarkupPointer *pmarkupWalk, IHTMLDOMNode **ppNode )
{
    HRESULT hr = S_OK;
    CTreeNode           *pnodeRight;
    MARKUP_CONTEXT_TYPE context;
    long lTextID;

    if (!ppNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppNode = NULL;
   
    hr = THR( pmarkupWalk->Right( TRUE, &context, &pnodeRight, NULL, NULL, &lTextID));
    if ( hr )
        goto Cleanup;

    switch ( context )
    {
    case CONTEXT_TYPE_Text:
        {
            // Text Node
            CDOMTextNode *pTextNode = NULL;

            // If we find text we ccannot have left the scope of our parent
            hr = THR(CreateTextNode (pDoc, pmarkupWalk, lTextID, 
                &pTextNode ));
            if ( hr )
                goto Cleanup;

            hr = THR ( pTextNode->QueryInterface ( IID_IHTMLDOMNode, (void **)ppNode ) );
            if ( hr )
                goto Cleanup;
            pTextNode->Release();
        }
        break;

    case CONTEXT_TYPE_EnterScope:
    case CONTEXT_TYPE_NoScope:
        // Return Disp to Element
        hr = THR(pnodeRight->GetElementInterface ( IID_IHTMLDOMNode, (void **) ppNode  ));
        if ( hr )
            goto Cleanup;
        break;

    case CONTEXT_TYPE_ExitScope:
    case CONTEXT_TYPE_None:
        break;

    default:
        Assert(FALSE); // Should never happen
        break;
    }
Cleanup:
    RRETURN(hr);
}

#if DBG == 1
static 
BOOL 
IsRootOnlyIfDocument(IHTMLDOMNode *pNode, CElement *pElement)
{
    HRESULT     hr;
    CMarkup *   pMarkup;

    if( pElement && pElement->Tag() == ETAG_ROOT )
    {
        hr = THR(pNode->QueryInterface(CLSID_CMarkup, (void **)&pMarkup));

        if( hr )  
        {
            return FALSE;
        }
    }

    return TRUE;
}
#endif

static
HRESULT
CurrentScope ( CMarkupPointer *pMkpPtr, IHTMLElement ** ppElemCurrent, CTreeNode ** ppNode )
{
    HRESULT     hr = S_OK;
    CTreeNode * pTreeNode = NULL;

    Assert( (!ppElemCurrent && ppNode) || (ppElemCurrent && !ppNode) );

    pMkpPtr->Validate();
    
    if (pMkpPtr->IsPositioned())
    {
        pTreeNode = pMkpPtr->Branch();
        if (pTreeNode->Tag() == ETAG_ROOT && !pTreeNode->Element()->GetMarkup()->HasDocument())
            pTreeNode = NULL;

    }

    if (ppNode)
    {
        *ppNode = pTreeNode;
        goto Cleanup;
    }
    else
    {
        Assert(ppElemCurrent);

        *ppElemCurrent = NULL;

        if (pTreeNode)
        {
            hr = THR(
                pTreeNode->GetElementInterface( IID_IHTMLElement, (void **) ppElemCurrent ) );

            if (hr)
                goto Cleanup;
        }
    }

Cleanup:

    RRETURN( hr );
}

static
HRESULT
ParentNodeHelper( CTreeNode *pNode, IHTMLDOMNode **pparentNode )
{
    HRESULT     hr = S_OK;
    CElement *  pElement;
    CMarkup *   pMarkup;
    CDocument * pDocument;
    BOOL        fDocumentPresent;

    *pparentNode = NULL;

    if (pNode->Tag() == ETAG_ROOT)
    {
        pElement = pNode->Element();
        pMarkup = pElement->GetMarkup();
        Assert(pMarkup);
        fDocumentPresent = pMarkup->HasDocument();

        hr = THR(pMarkup->EnsureDocument(&pDocument));
        if ( hr )
            goto Cleanup;

        Assert(pDocument);
        if (!fDocumentPresent)
            pDocument->_lnodeType = 11;

        hr = THR(pDocument->QueryInterface( IID_IHTMLDOMNode, (void**) pparentNode ));
        if ( hr )
            goto Cleanup;
    }
    else
    {
        hr = THR(pNode->GetElementInterface ( IID_IHTMLDOMNode, (void**) pparentNode ));
        if ( hr )
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

static
HRESULT
ScanText(CDoc *pDoc, CMarkupPointer *pMkpStart, CMarkupPointer *pMkpTxtEnd, CMarkupPointer *pMkpEnd)
{
    HRESULT hr = S_OK;
    MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;
    long lTextID;
    BOOL fEnterText = FALSE;
    CDOMTextNode *pTextNode;

    do
    {
        hr = THR(pMkpTxtEnd->Right(TRUE, &context, NULL, NULL, NULL, &lTextID));
        if (hr)
            goto Cleanup;

        if (lTextID)
        {
            Assert(context == CONTEXT_TYPE_Text);
            if (!fEnterText)
            {
                hr = THR(pMkpTxtEnd->Right(FALSE, &context, NULL, NULL, NULL, NULL));
                if (hr)
                    goto Cleanup;
                
                if (context == CONTEXT_TYPE_Text)
                    fEnterText = TRUE;
            }

            if (fEnterText)
            {
                pTextNode = (CDOMTextNode *)pDoc->_HtPvPvDOMTextNodes.Lookup((void *)(DWORD_PTR)(lTextID<<4));
                pTextNode->TearoffTextNode(pMkpStart, pMkpTxtEnd);
            }
        }
        else if (fEnterText && (context != CONTEXT_TYPE_Text))
            fEnterText = FALSE;

        hr = THR(pMkpStart->MoveToPointer(pMkpTxtEnd));
        if (hr)
            goto Cleanup;

    }
    while(pMkpTxtEnd->IsLeftOf(pMkpEnd));

Cleanup:
    RRETURN(hr);
}

static
HRESULT
OwnerDocHelper(IDispatch **ppretdoc, CDOMTextNode *pDOMTextNode, CElement *pElement)
{
    HRESULT hr = S_OK;
    CMarkup *pMarkup;
    CDocument *pDocument = NULL;

    Assert(!!pDOMTextNode ^ !!pElement);

    if( !ppretdoc )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppretdoc = NULL;

    pMarkup = pDOMTextNode? pDOMTextNode->GetWindowedMarkupContext() : pElement->GetWindowedMarkupContext();

    Assert( pMarkup );
    if ( ! pMarkup )
    {    
        hr = E_FAIL;
        goto Cleanup;
    }
    
    if( pMarkup->HasDocument() )
    {
        pDocument = pMarkup->Document();
        Assert(pDocument);
        Assert(pDocument->_lnodeType == 9);
        hr = THR(pDocument->QueryInterface(IID_IDispatch, (void **)ppretdoc));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

////////////////////////////////////////////////////////////////////////////////
//
// IHTMLDOMTextNode methods:
//
////////////////////////////////////////////////////////////////////////////////

MtDefine(CDOMTextNode, ObjectModel, "CDOMTextNode")

//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CDOMTextNode::s_classdesc =
{
    &CLSID_HTMLDOMTextNode,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLDOMTextNode,         // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

HRESULT
CDOMTextNode::PrivateQueryInterface(REFIID iid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;

    if ( !ppv )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IHTMLDOMTextNode2, NULL)
        QI_TEAROFF(this, IHTMLDOMTextNode, NULL)
        QI_TEAROFF(this, IHTMLDOMNode, NULL)
        QI_TEAROFF(this, IHTMLDOMNode2, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    }

    if ( iid == CLSID_HTMLDOMTextNode )
    {
        *ppv = (void*)this;
        return S_OK;
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }
Cleanup:
    return hr;
}

HRESULT
CDOMTextNode::UpdateTextID( CMarkupPointer *pMkpPtr )
{
    HRESULT hr = S_OK;
    long lNewTextID;

    hr = THR(_pMkpPtr->SetTextIdentity(pMkpPtr, &lNewTextID));
    if ( hr )
        goto Cleanup;

    // Update the Doc Text Node Ptr Lookup
    _pDoc->_HtPvPvDOMTextNodes.Remove ( (void *)(DWORD_PTR)(_lTextID<<4) );
    _lTextID = lNewTextID;
    hr = THR(_pDoc->_HtPvPvDOMTextNodes.Insert ( (void*)(DWORD_PTR)(_lTextID<<4), (void*)this ) );
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN( hr );

}

HRESULT
CDOMTextNode::MoveToOffset( long loffset, CMarkupPointer *pMkpPtr, CMarkupPointer *pMkpEnd )
{
    HRESULT hr = S_OK;
    MARKUP_CONTEXT_TYPE context;
    long lTextID;
    long lMove = loffset;

    // Move the markup pointer adjacent to the Text
    hr = THR( _pMkpPtr->FindTextIdentity ( _lTextID, pMkpEnd ) );
    if ( hr )
        goto Cleanup;

    pMkpEnd->SetGravity(POINTER_GRAVITY_Right);

    hr = THR(pMkpPtr->MoveToPointer(_pMkpPtr));
    if( hr )
        goto Cleanup;

    if( loffset )
    {
        hr = THR( pMkpPtr->Right( TRUE, &context, NULL, &lMove, NULL, &lTextID));
        if( hr )
            goto Cleanup;

        Assert( lTextID == _lTextID );
        Assert( context == CONTEXT_TYPE_Text );

        if ( loffset != lMove )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CDOMTextNode::InsertTextHelper( CMarkupPointer *pMkpPtr, BSTR bstrstring, long loffset)
{
    HRESULT hr = S_OK;
    
    // If loffset=0, _pMkpPtr is affected by remove / insert, & should not become unpositioned
    if(!loffset)
        _pMkpPtr->SetGravity( POINTER_GRAVITY_Left );

    pMkpPtr->SetGravity ( POINTER_GRAVITY_Right );

    hr = THR( _pDoc->InsertText( pMkpPtr, bstrstring, -1, MUS_DOMOPERATION ) );
    if ( hr )
        goto Cleanup;

    // Restore the proper gravity, so that new TextID can be set later.
    _pMkpPtr->SetGravity( POINTER_GRAVITY_Right );

Cleanup:
    RRETURN( hr );
}

HRESULT
CDOMTextNode::RemoveTextHelper(CMarkupPointer *pMkpStart, long lCount, long loffset)
{
    HRESULT hr = S_OK;
    CMarkupPointer MkpRight(_pDoc);

    if( lCount )
    {
        hr = THR(MkpRight.MoveToPointer(pMkpStart));
        if( hr )
            goto Cleanup;

        hr = THR( MkpRight.Right( TRUE, NULL, NULL, &lCount, NULL, NULL) );
        if( hr )
            goto Cleanup;
    
        // If loffset=0, _pMkpPtr is affected by remove / insert, & should not become unpositioned
        if(!loffset)
            _pMkpPtr->SetGravity ( POINTER_GRAVITY_Left );

        // Remove the Text
        hr = THR(_pDoc->Remove ( pMkpStart,  &MkpRight, MUS_DOMOPERATION ));
        if ( hr )
            goto Cleanup;

    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CDOMTextNode::get_data(BSTR *pbstrData)
{
    HRESULT hr = S_OK;
    MARKUP_CONTEXT_TYPE context;
    long lCharCount = -1;
    long lTextID;

    if ( !pbstrData )
        goto Cleanup;

    *pbstrData = NULL;

    // Move the markup pointer adjacent to the Text
    hr = THR( _pMkpPtr->FindTextIdentity ( _lTextID, (CMarkupPointer * )NULL ) );
    if ( hr )
        goto Cleanup;

    // Walk right (hopefully) over text, inital pass, don't move just get count of chars
    hr = THR( _pMkpPtr->Right( FALSE, &context, NULL, &lCharCount, NULL, &lTextID));
    if ( hr )
        goto Cleanup;

    Assert ( lTextID == _lTextID );

    if ( context == CONTEXT_TYPE_Text )
    {
        // Alloc memory
        hr = FormsAllocStringLen ( NULL, lCharCount, pbstrData );
        if ( hr )
            goto Cleanup;
        hr = THR( _pMkpPtr->Right( FALSE, &context, NULL, &lCharCount, *pbstrData, &lTextID));
        if ( hr )
            goto Cleanup;
    }  

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

CDOMTextNode::CDOMTextNode ( long lTextID, CDoc *pDoc, CMarkupPointer *pmkptr )
{ 
    Assert(pDoc);
    Assert(pmkptr);
    _pDoc = pDoc ; 
    _lTextID = lTextID ;
    _pDoc->AddRef();                // Due to lookaside table
    _pMkpPtr = pmkptr;
    // markup ptr will manage Markup in which text node is in.
    _pMkpPtr->SetKeepMarkupAlive(TRUE);
    // Add glue so that tree services can manage ptr movement
    // between markups automatically during splice operations
    _pMkpPtr->SetCling(TRUE);
}


CDOMTextNode::~CDOMTextNode()
{

    // tidy up lookaside
    _pDoc->_HtPvPvDOMTextNodes.Remove ( (void *)(DWORD_PTR)(_lTextID<<4) );

    // Tidy up markup ptr/markup
    _pMkpPtr->SetKeepMarkupAlive(FALSE);
    _pMkpPtr->SetCling(FALSE);

    _pDoc->Release();
    delete _pMkpPtr;
}


HRESULT STDMETHODCALLTYPE
CDOMTextNode::IsEqualObject(IUnknown * pUnk)
{
    HRESULT         hr;
    IUnknown   *    pUnkThis = NULL;
    CDOMTextNode *  pTargetTextNode;

    if (!pUnk)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // Test standard COM identity first
    hr = THR_NOTRACE(QueryInterface(IID_IUnknown, (void **)&pUnkThis));
    if (hr)
        goto Cleanup;

    if (pUnk == pUnkThis)
    {
        hr = S_OK;
        goto Cleanup;
    }

    // Do the dodgy CLSID QI
    hr = THR(pUnk->QueryInterface(CLSID_HTMLDOMTextNode, (void**)&pTargetTextNode));
    if ( hr )
        goto Cleanup;

    hr = (_lTextID == pTargetTextNode->_lTextID) ? S_OK : S_FALSE;

Cleanup:
    ReleaseInterface(pUnkThis);
    RRETURN1(hr, S_FALSE);
}

HRESULT
CDOMTextNode::cloneNode(VARIANT_BOOL fDeep, IHTMLDOMNode **ppNodeCloned)
{
    HRESULT hr;
    CMarkupPointer mkpRight (_pDoc );
    CMarkupPointer mkpTarget (_pDoc );
    CMarkup *pMarkup = NULL;
    CMarkupPointer *pmkpStart = NULL;

    if ( !ppNodeCloned )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(_pDoc->CreateMarkup ( &pMarkup, GetWindowedMarkupContext() ));
    if ( hr )
        goto Cleanup;

    hr = THR( pMarkup->SetOrphanedMarkup( TRUE ) );
    if( hr )
        goto Cleanup;

    // Move the markup pointer adjacent to the Text
    hr = THR( _pMkpPtr->FindTextIdentity ( _lTextID, &mkpRight ) );
    if ( hr )
        goto Cleanup;

    hr = THR(mkpTarget.MoveToContainer( pMarkup, TRUE ) );
    if ( hr )
        goto Cleanup;

    mkpTarget.SetGravity ( POINTER_GRAVITY_Right );
    
    // Copy the markup across to the new markup container
    // (mkpTarget gets moved to the right of the text as a result)
    hr = THR( _pDoc->Copy ( _pMkpPtr, &mkpRight, &mkpTarget, MUS_DOMOPERATION ) );  
    if ( hr )
        goto Cleanup;

    // Create the new text node markup pointer - will be handed off to text node
    pmkpStart = new CMarkupPointer ( _pDoc );
    if ( !pmkpStart )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pmkpStart->MoveToContainer( pMarkup, TRUE ) );
    if ( hr )
        goto Cleanup;

    // Create the new text node
    hr = THR(_pDoc->CreateDOMTextNodeHelper(pmkpStart, &mkpTarget, ppNodeCloned));
    if ( hr )
        goto Cleanup;

    pmkpStart = NULL; // Text Node owns the pointer

Cleanup:
    ReleaseInterface ( (IUnknown*)pMarkup ); // Text node addref'ed it
    delete pmkpStart;
    RRETURN( hr );
}

HRESULT
CDOMTextNode::splitText(long lOffset, IHTMLDOMNode**ppRetNode )
{
    HRESULT hr = S_OK;
    CMarkupPointer mkpRight (_pDoc);
    CMarkupPointer mkpEnd (_pDoc);
    CMarkupPointer *pmkpStart = NULL;
    long lMove = lOffset;
    long lTextID;
    
    if ( lOffset < 0 || !ppRetNode)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    // Split the text at the given offset to make a new text node, return the new text node

    pmkpStart = new CMarkupPointer ( _pDoc );
    if ( !pmkpStart )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Move the markup pointer adjacent to the Text
    hr = THR( _pMkpPtr->FindTextIdentity ( _lTextID, &mkpRight ) );
    if ( hr )
        goto Cleanup;

    hr = THR(pmkpStart->MoveToPointer ( _pMkpPtr ));
    if ( hr )
        goto Cleanup;

    lMove = lOffset;

    hr = THR(pmkpStart->Right ( TRUE, NULL, NULL, &lOffset, NULL, &lTextID ));
    if ( hr )
        goto Cleanup;

    // Position at point of split 
    hr = THR(mkpEnd.MoveToPointer (pmkpStart));
    if ( hr )
        goto Cleanup;

    // If my TextID changed, I moved outside my text node
    if ( lOffset != lMove )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Create the new text node
    hr = THR(_pDoc->CreateDOMTextNodeHelper(pmkpStart, &mkpRight, ppRetNode));
    if ( hr )
        goto Cleanup;

    pmkpStart = NULL; // New Text Node owns pointer

    // Re-Id the split text for original text node
    hr = THR(_pMkpPtr->SetTextIdentity(&mkpEnd, &lTextID));
    if ( hr )
        goto Cleanup;

    // Update the Doc Text Node Ptr Lookup
    _pDoc->_HtPvPvDOMTextNodes.Remove ( (void *)(DWORD_PTR)(_lTextID<<4) );
    _lTextID = lTextID;
    hr = THR(_pDoc->_HtPvPvDOMTextNodes.Insert ( (void*)(DWORD_PTR)(_lTextID<<4), (void*)this ) );
    if ( hr )
        goto Cleanup;

Cleanup:
    delete pmkpStart;

    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::put_data(BSTR bstrData)
{
    HRESULT hr = S_OK;
    CMarkupPointer mkpRight (_pDoc);
    CMarkupPointer mkpStart (_pDoc);

    // Move the markup pointer adjacent to the Text
    hr = THR( _pMkpPtr->FindTextIdentity ( _lTextID, &mkpRight ) );
    if ( hr )
        goto Cleanup;

    Assert(_pMkpPtr->Cling());

    // Set left gravity so that _pMkpPtr is not unpositioned, due to remove.
    _pMkpPtr->SetGravity ( POINTER_GRAVITY_Left );

    // Remove the old Text
    hr = THR(_pDoc->Remove ( _pMkpPtr,  &mkpRight, MUS_DOMOPERATION ));
    if ( hr )
        goto Cleanup;

    // OK, old text is out, put the new stuff in
    hr = THR(mkpStart.MoveToPointer ( _pMkpPtr ));
    if ( hr )
        goto Cleanup;
    
    // Set gravity of mkpStart to right, so that it moves to the end when text is inserted
    // at _pMkpPtr, which remains at the beginning due to left gravity.
    mkpStart.SetGravity(POINTER_GRAVITY_Right);

    hr = THR( _pDoc->InsertText( _pMkpPtr, bstrData, -1, MUS_DOMOPERATION ) );
    if ( hr )
        goto Cleanup;

    // restore gravity of _pMkpPtr to right
    _pMkpPtr->SetGravity(POINTER_GRAVITY_Right);

    hr = THR(UpdateTextID(&mkpStart));
    if( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::toString(BSTR *pbstrData)
{
    RRETURN(SetErrorInfo(get_data(pbstrData)));
}

HRESULT
CDOMTextNode::get_length(long *pLength)
{
    HRESULT hr = S_OK;
    long lCharCount = -1;
    long lTextID;
    MARKUP_CONTEXT_TYPE context;

    if ( !pLength )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = 0;

    // Move the markup pointer adjacent to the Text
    hr = THR( _pMkpPtr->FindTextIdentity ( _lTextID, (CMarkupPointer *)NULL ) );
    if ( hr )
        goto Cleanup;

    // Walk right (hopefully) over text, inital pass, don't move just get count of chars
    hr = THR( _pMkpPtr->Right( FALSE, &context, NULL, &lCharCount, NULL, &lTextID));
    if ( hr )
        goto Cleanup;

    Assert ( lTextID == _lTextID );

    if ( context == CONTEXT_TYPE_Text )
    {
        *pLength = lCharCount;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CDOMTextNode::get_nodeType(long *pnodeType)
{
    HRESULT hr = S_OK;

    if (!pnodeType)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pnodeType = 3; // DOM_TEXTNODE
Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CDOMTextNode::get_nodeName(BSTR *pbstrNodeName)
{
    HRESULT hr = S_OK;
    if (!pbstrNodeName)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrNodeName = NULL;
    
    hr = THR(FormsAllocString ( _T("#text"), pbstrNodeName ));
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::get_nodeValue(VARIANT *pvarValue)
{
    HRESULT hr = S_OK;
    if (!pvarValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    pvarValue->vt = VT_BSTR;

    hr = THR(get_data(&V_BSTR(pvarValue)));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::put_nodeValue(VARIANT varValue)
{
    HRESULT hr = S_OK;
    CVariant varBSTRValue;

    hr = THR(varBSTRValue.CoerceVariantArg ( &varValue, VT_BSTR ));
    if ( hr )
        goto Cleanup;

    hr = THR( put_data ( V_BSTR((VARIANT *)&varBSTRValue)));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::get_firstChild ( IHTMLDOMNode **ppNode )
{
    if (ppNode)
        *ppNode = NULL;

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CDOMTextNode::get_lastChild ( IHTMLDOMNode **ppNode )
{
    if (ppNode)
        *ppNode = NULL;

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CDOMTextNode::get_previousSibling ( IHTMLDOMNode **ppNode )
{
    HRESULT hr = S_OK;
    CMarkupPointer markupWalk ( _pDoc );

    // Move the markup pointer adjacent to the Text
    hr = THR(_pMkpPtr->FindTextIdentity ( _lTextID, (CMarkupPointer *)NULL ));
    if ( hr )
        goto Cleanup;

    hr = THR(markupWalk.MoveToPointer(_pMkpPtr));
    if ( hr )
        goto Cleanup;

    hr = THR(GetPreviousHelper ( _pDoc, &markupWalk, ppNode ));
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::get_nextSibling ( IHTMLDOMNode **ppNode )
{
    HRESULT hr = S_OK;
    CMarkupPointer markupWalk ( _pDoc );

    // Move the markup pointer adjacent to the Text
    hr = THR(_pMkpPtr->FindTextIdentity ( _lTextID, &markupWalk ));
    if ( hr )
        goto Cleanup;

    hr = THR(GetNextHelper ( _pDoc, &markupWalk, ppNode ));
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CDOMTextNode::get_parentNode(IHTMLDOMNode **pparentNode)
{
    HRESULT             hr = S_OK;
    CTreeNode *         pNode;

    if (!pparentNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pparentNode = NULL;

    // Move the markup pointer adjacent to the Text
    hr = THR( _pMkpPtr->FindTextIdentity ( _lTextID, (CMarkupPointer *)NULL ) );
    if ( hr )
        goto Cleanup;

    hr = CurrentScope(_pMkpPtr, NULL, &pNode);

    if ( hr )
        goto Cleanup;

    if (!pNode) 
    {
        goto Cleanup;
    }

    hr = THR(ParentNodeHelper(pNode, pparentNode));
    if ( hr )
        goto Cleanup;


Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::hasChildNodes(VARIANT_BOOL *p)
{
    HRESULT hr = S_OK;
    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *p = VARIANT_FALSE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

CDOMChildrenCollection *
CDOMTextNode::EnsureDOMChildrenCollectionPtr ( )
{
    CDOMChildrenCollection *pDOMPtr = NULL;
    GetPointerAt ( FindAAIndex ( DISPID_INTERNAL_CDOMCHILDRENPTRCACHE,CAttrValue::AA_Internal ),
        (void **)&pDOMPtr );
    if ( !pDOMPtr )
    {
        pDOMPtr = new CDOMChildrenCollection ( this, FALSE /* fIsElement */ );
        if ( pDOMPtr )
        {
            AddPointer ( DISPID_INTERNAL_CDOMCHILDRENPTRCACHE,
                (void *)pDOMPtr,
                CAttrValue::AA_Internal );
        }
    }
    else
    {
        pDOMPtr->AddRef();
    }
    return pDOMPtr;
}


HRESULT
CDOMTextNode::get_childNodes(IDispatch **ppChildCollection)
{
    HRESULT hr = S_OK;
    CDOMChildrenCollection *pChildren;

    if ( !ppChildCollection )
        goto Cleanup;

    *ppChildCollection = NULL;

    pChildren = EnsureDOMChildrenCollectionPtr();
    if ( !pChildren )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    hr = THR(pChildren->QueryInterface (IID_IDispatch,(void **)ppChildCollection));
    if ( hr )
        goto Cleanup;

    pChildren->Release(); // Lifetime is controlled by extrenal ref.

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::get_attributes(IDispatch **ppAttrCollection)
{
    HRESULT hr = S_OK;
    if (!ppAttrCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppAttrCollection = NULL;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::removeNode(VARIANT_BOOL fDeep,IHTMLDOMNode** ppnewNode)
{
    HRESULT hr = THR ( Remove () );
    if ( hr )
        goto Cleanup;

    if ( ppnewNode )
    {
        hr = THR(QueryInterface (IID_IHTMLDOMNode, (void**)ppnewNode ));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT 
CDOMTextNode::replaceNode(IHTMLDOMNode *pNodeReplace, IHTMLDOMNode **ppNodeReplaced)
{
    HRESULT hr;
    CDOMTextNode *pNewTextNode = NULL;
    CElement *pNewElement = NULL;

    if ( ppNodeReplaced )
        *ppNodeReplaced = NULL;

    if ( !pNodeReplace )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(CrackDOMNode((IUnknown*)pNodeReplace, &pNewTextNode, &pNewElement, GetWindowedMarkupContext()));
    if ( hr )
        goto Cleanup;

    Assert(IsRootOnlyIfDocument(pNodeReplace, pNewElement));

    hr = THR(ReplaceDOMNodeHelper ( _pDoc, NULL, this, pNewElement, pNewTextNode ));
    if ( hr )
        goto Cleanup;

    if ( ppNodeReplaced )
    {
        hr = THR(QueryInterface(IID_IHTMLDOMNode, (void**)ppNodeReplaced));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CDOMTextNode::swapNode(IHTMLDOMNode *pNodeSwap, IHTMLDOMNode **ppNodeSwapped)
{
    CElement *      pSwapElement = NULL;
    CDOMTextNode *  pSwapText = NULL;
    HRESULT         hr;

    if ( ppNodeSwapped )
        *ppNodeSwapped = NULL;

    if ( !pNodeSwap )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(CrackDOMNode((IUnknown*)pNodeSwap, &pSwapText, &pSwapElement, GetWindowedMarkupContext() ));
    if ( hr )
        goto Cleanup;

    Assert(IsRootOnlyIfDocument(pNodeSwap, pSwapElement));

    hr = THR (SwapDOMNodeHelper ( _pDoc, NULL, this, pSwapElement, pSwapText ));
    if ( hr )
        goto Cleanup;

    if ( ppNodeSwapped )
    {
        hr = THR(QueryInterface(IID_IHTMLDOMNode, (void**)ppNodeSwapped));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::insertBefore(IHTMLDOMNode *pNewChild, VARIANT refChild, IHTMLDOMNode **ppRetNode)
{
    if (ppRetNode)
        *ppRetNode = NULL;
    // Don't expect this method to be called on a text node
    RRETURN(SetErrorInfo(E_UNEXPECTED));
}

HRESULT
CDOMTextNode::appendChild(IHTMLDOMNode *pNewChild, IHTMLDOMNode **ppRetNode)
{
    if (ppRetNode)
        *ppRetNode = NULL;
    // Don't expect this method to be called on a text node
    RRETURN(SetErrorInfo(E_UNEXPECTED));
}

HRESULT
CDOMTextNode::replaceChild(IHTMLDOMNode *pNewChild, IHTMLDOMNode *pOldChild, 
                           IHTMLDOMNode **ppRetNode)
{
    if (ppRetNode)
        *ppRetNode = NULL;
    // Don't expect this method to be called on a text node
    RRETURN(SetErrorInfo(E_UNEXPECTED));
}

HRESULT
CDOMTextNode::removeChild(IHTMLDOMNode *pOldChild, IHTMLDOMNode **ppRetNode)
{
    if (ppRetNode)
        *ppRetNode = NULL;
    // Don't expect this method to be called on a text node
    RRETURN(SetErrorInfo(E_UNEXPECTED));
}


HRESULT 
CDOMTextNode::GetMarkupPointer( CMarkupPointer **ppMkp )
{
    HRESULT hr;

    // Move the markup pointer adjacent to the Text
    hr = THR( _pMkpPtr->FindTextIdentity ( _lTextID, (CMarkupPointer *)NULL ) );
    if ( hr )
        goto Cleanup;

    *ppMkp = _pMkpPtr;

Cleanup:
    RRETURN(hr);
}

HRESULT
CDOMTextNode::Remove ( void )
{
    // Move it into it's own Markup container
    HRESULT hr;
    CMarkup *pMarkup = NULL;
    CMarkupPointer mkpPtr (_pDoc);

    hr = THR( _pDoc->CreateMarkup( &pMarkup, GetWindowedMarkupContext() ) );
    if (hr)
        goto Cleanup;

    hr = THR( pMarkup->SetOrphanedMarkup( TRUE ) );
    if( hr )
        goto Cleanup;

    hr = THR(mkpPtr.MoveToContainer( pMarkup, TRUE ) );
    if ( hr )
        goto Cleanup;

    hr = THR(MoveTo ( &mkpPtr ));
    if ( hr )
        goto Cleanup;


Cleanup:
    // Leave markup refcount at 1, text node is keeping it alive
    ReleaseInterface ( (IUnknown*)pMarkup );
    RRETURN(hr);
}

HRESULT 
CDOMTextNode::MoveTo ( CMarkupPointer *pmkptrTarget )
{
    HRESULT         hr;
    CMarkupPointer  mkpEnd(_pDoc);
    long            lCount;

    hr = THR(get_length(&lCount));
    if ( hr )
        goto Cleanup;

    // Move the markup pointer adjacent to the Text
    hr = THR( _pMkpPtr->FindTextIdentity ( _lTextID, &mkpEnd ) );
    if ( hr )
        goto Cleanup;

    pmkptrTarget->SetGravity ( POINTER_GRAVITY_Left );

    // should have right gravity, which with cling will move it also along with text
    Assert(_pMkpPtr->Gravity());    
    Assert(_pMkpPtr->Cling());    
    hr = THR(_pDoc->Move ( _pMkpPtr, &mkpEnd, pmkptrTarget, MUS_DOMOPERATION )); 

Cleanup:
    RRETURN(hr);
}

inline CMarkup *
CDOMTextNode::GetWindowedMarkupContext()
{ 
    return _pMkpPtr->Markup()->GetWindowedMarkupContext();
}

// IHTMLDOMTextNode2 methods

HRESULT
CDOMTextNode::substringData (long loffset, long lCount, BSTR* pbstrsubString)
{
    HRESULT hr = E_POINTER;
    long lMove = lCount;
    CMarkupPointer mkpptr(_pDoc);
    CMarkupPointer mkpend(_pDoc);
    BSTR bstrTemp;

    if ( !pbstrsubString )
        goto Cleanup;

    if ( lCount < 0 || loffset < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pbstrsubString = NULL;

    hr = THR(MoveToOffset(loffset, &mkpptr, &mkpend));
    if ( hr )
        goto Cleanup;

    hr = FormsAllocStringLen( NULL, lCount, pbstrsubString );
    if ( hr )
        goto Cleanup;

    hr = THR( mkpptr.Right( FALSE, NULL, NULL, &lMove, *pbstrsubString, NULL) );
    if ( hr )
        goto Cleanup;

    if(lMove != lCount)
    {
        Assert(lMove < lCount);
        hr = FormsAllocStringLen(*pbstrsubString, lMove, &bstrTemp );
        SysFreeString(*pbstrsubString);
        *pbstrsubString = bstrTemp;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CDOMTextNode::appendData (BSTR bstrstring)
{
    HRESULT hr = S_OK;
    CMarkupPointer mkpptr(_pDoc);

    hr = THR( _pMkpPtr->FindTextIdentity ( _lTextID, &mkpptr ) );
    if ( hr )
        goto Cleanup;

    hr = THR(InsertTextHelper(&mkpptr, bstrstring, -1));
    if( hr )
        goto Cleanup;

    hr = THR(UpdateTextID(&mkpptr));
    if( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::insertData (long loffset, BSTR bstrstring)
{
    HRESULT hr = S_OK;
    CMarkupPointer mkpptr(_pDoc);
    CMarkupPointer mkpend(_pDoc);

    if ( loffset < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(MoveToOffset(loffset, &mkpptr, &mkpend));
    if ( hr )
        goto Cleanup;

    hr = THR(InsertTextHelper(&mkpptr, bstrstring, loffset));
    if( hr )
        goto Cleanup;

    hr = THR(UpdateTextID(&mkpend));
    if( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::deleteData (long loffset, long lCount)
{
    HRESULT hr = S_OK;
    CMarkupPointer mkpStart (_pDoc);
    CMarkupPointer mkpend (_pDoc);

    if( !lCount )
        goto Cleanup;

    if( loffset < 0 || lCount < 0 )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(MoveToOffset(loffset, &mkpStart, &mkpend));
    if ( hr )
        goto Cleanup;

    hr = THR(RemoveTextHelper(&mkpStart, lCount, loffset));
    if ( hr )
        goto Cleanup;
    
    _pMkpPtr->SetGravity(POINTER_GRAVITY_Right);

    hr = THR(UpdateTextID(&mkpend));
    if( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::replaceData (long loffset, long lCount, BSTR bstrstring)
{
    HRESULT hr = S_OK;
    CMarkupPointer mkpStart (_pDoc);
    CMarkupPointer mkpend (_pDoc);

    if( loffset < 0 || lCount < 0 )
        goto Cleanup;

    hr = THR(MoveToOffset(loffset, &mkpStart, &mkpend));
    if ( hr )
        goto Cleanup;

    hr = THR(RemoveTextHelper(&mkpStart, lCount, loffset));
    if ( hr )
        goto Cleanup;

    hr = THR(InsertTextHelper(&mkpStart, bstrstring, loffset));
    if( hr )
        goto Cleanup;

    hr = THR(UpdateTextID(&mkpend));
    if( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDOMTextNode::get_ownerDocument(IDispatch **ppretdoc)
{
    return OwnerDocHelper(ppretdoc, this, NULL);
}

HRESULT
CDOMTextNode::TearoffTextNode(CMarkupPointer *pMkpStart, CMarkupPointer *pMkpEnd)
{
    HRESULT hr = S_OK;
    CMarkup *pMarkup = NULL;
    CMarkupPointer mkpEndPtr(_pDoc);

    hr = THR(_pDoc->CreateMarkup(&pMarkup, GetWindowedMarkupContext()));
    if (hr)
        goto Cleanup;

    hr = THR(pMarkup->SetOrphanedMarkup(TRUE));
    if (hr)
        goto Cleanup;

    hr = THR(mkpEndPtr.MoveToContainer(pMarkup, TRUE));
    if (hr)
        goto Cleanup;

    mkpEndPtr.SetGravity(POINTER_GRAVITY_Right);

    // should have right gravity, which with cling will move it also along with text
    Assert(_pMkpPtr->Gravity());    
    Assert(_pMkpPtr->Cling());    
    Assert(!pMkpEnd->Cling());    
    hr = THR(_pDoc->Move(_pMkpPtr, pMkpEnd, &mkpEndPtr, MUS_DOMOPERATION)); 
    if (hr)
        goto Cleanup;
    
    Assert(!pMkpStart->Gravity());    
    Assert(pMkpStart->IsEqualTo(pMkpEnd));
    Assert(_pMkpPtr->IsLeftOf(&mkpEndPtr));
    
    pMkpEnd->SetGravity(POINTER_GRAVITY_Right);

    Assert(_pMkpPtr->Gravity());    
    Assert(_pMkpPtr->Cling());    
    hr = THR(_pDoc->Copy(_pMkpPtr, &mkpEndPtr, pMkpEnd, MUS_DOMOPERATION));  
    if (hr)
        goto Cleanup;

    Assert(pMkpStart->IsLeftOf(pMkpEnd));

Cleanup:
    ReleaseInterface((IUnknown*)pMarkup); // Text node addref'ed it
    RRETURN(hr);

}

////////////////////////////////////////////////////////////////////////////////
//
// IHTMLDOMAttribute methods:
//
////////////////////////////////////////////////////////////////////////////////

MtDefine(CAttribute, ObjectModel, "CAttribute")

//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CAttribute::s_classdesc =
{
    &CLSID_HTMLDOMAttribute,        // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLDOMAttribute,         // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

CAttribute::CAttribute(const PROPERTYDESC *pPropDesc, DISPID dispid, CElement *pElem, CDocument *pDocument)
{
    _pPropDesc = pPropDesc;
    _dispid = dispid;
    _pElem = pElem;
    if (pElem)
        pElem->SubAddRef();
    _pDocument = pDocument;    
    if (_pDocument)
    {
        _pDocument->SubAddRef();    
        _pMarkup = pDocument->Markup();
    }
    if (_pMarkup)
        _pMarkup->SubAddRef();
}

CAttribute::~CAttribute()
{
    if(_pElem)
        _pElem->SubRelease();
    if(_pMarkup)
        _pMarkup->SubRelease();
    if(_pDocument)
        _pDocument->SubRelease();
}

HRESULT
CAttribute::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IHTMLDOMAttribute, NULL)
        QI_TEAROFF(this, IHTMLDOMAttribute2, NULL)
    default:
        if (iid == CLSID_CAttribute)
        {
            *ppv = this;    // Weak ref
            return S_OK;
        }
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//
// Attribute helpers
//

static
HRESULT
GetIndexHelper(LPTSTR pchName, AAINDEX *paaIdx, AAINDEX *pvaaIdx, DISPID *pdispid, PROPERTYDESC **ppPropDesc, CElement *pElement, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    Assert(pchName && paaIdx && pdispid && ppPropDesc && pElement);

    *ppPropDesc = (PROPERTYDESC *)pElement->FindPropDescForName(pchName);
    
    if(!*ppPropDesc)
    {
        hr = THR(pElement->GetExpandoDISPID(pchName, pdispid, dwFlags));
        if (hr)
            goto Cleanup;
    }
    else
    {
        *pdispid = (*ppPropDesc)->GetDispid();
    }

    Assert(*pdispid);

    *paaIdx = pElement->FindAAIndex(*pdispid, CAttrValue::AA_DOMAttribute);

    if (pvaaIdx)
        *pvaaIdx = pElement->FindAAIndex(*pdispid, *ppPropDesc ? CAttrValue::AA_Attribute : CAttrValue::AA_Expando);

Cleanup:
    RRETURN(hr);
}

static
HRESULT
PutNodeValueHelper(CAttribute *pAttribute, AAINDEX aaIdx, VARIANT varValue)
{
    HRESULT hr;

    Assert(pAttribute);
    Assert(pAttribute->_pElem);

    if (pAttribute->_pPropDesc)
    {
        DISPPARAMS dp;

        dp.rgvarg = &varValue;
        dp.rgdispidNamedArgs = NULL;
        dp.cArgs = 1;
        dp.cNamedArgs = 0;

        hr = THR(pAttribute->_pElem->Invoke(pAttribute->_dispid,
                                       IID_NULL,
                                       g_lcidUserDefault,
                                       DISPATCH_PROPERTYPUT,
                                       &dp,
                                       NULL,
                                       NULL,
                                       NULL));
        if (hr)
            goto Cleanup;
    }
    else
    {
        Assert(pAttribute->_dispid != DISPID_UNKNOWN);
        Assert(pAttribute->_pElem->IsExpandoDISPID(pAttribute->_dispid));

        if (aaIdx == AA_IDX_UNKNOWN)
        {
            hr = THR(CAttrArray::Set(pAttribute->_pElem->GetAttrArray(), pAttribute->_dispid, &varValue, NULL, CAttrValue::AA_Expando));
        }
        else
        {
            CAttrArray *pAA = *pAttribute->_pElem->GetAttrArray();
            Assert(pAA && aaIdx == pAttribute->_pElem->FindAAIndex(pAttribute->_dispid, CAttrValue::AA_Expando));
            hr = THR(pAA->SetAt(aaIdx, &varValue));
        }

        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

static
HRESULT
GetNodeValueHelper(CAttribute *pAttribute, AAINDEX aaIdx, VARIANT *pvarValue)
{
    HRESULT hr = E_FAIL;

    Assert(pAttribute);
    Assert(pAttribute->_pElem);

    if (pAttribute->_pPropDesc)
    {
        if (!(pAttribute->_pPropDesc->GetPPFlags() & PROPPARAM_SCRIPTLET))
        {
            DISPPARAMS dp = { NULL, NULL, 0, 0 };

            hr = THR (pAttribute->_pElem->Invoke(pAttribute->_dispid,
                               IID_NULL,
                               g_lcidUserDefault,
                               DISPATCH_PROPERTYGET,
                               &dp,
                               pvarValue,
                               NULL,
                               NULL));
        }

        if (hr)
        {
            if (aaIdx == AA_IDX_UNKNOWN)
                aaIdx = pAttribute->_pElem->FindAAIndex(pAttribute->_dispid, CAttrValue::AA_Attribute);
            else
                Assert(aaIdx == pAttribute->_pElem->FindAAIndex(pAttribute->_dispid, CAttrValue::AA_Attribute));

            hr = THR(pAttribute->_pElem->GetVariantAt(aaIdx, pvarValue));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        Assert(pAttribute->_dispid != DISPID_UNKNOWN);
        Assert(pAttribute->_pElem->IsExpandoDISPID(pAttribute->_dispid));

        if (aaIdx == AA_IDX_UNKNOWN)
            aaIdx = pAttribute->_pElem->FindAAIndex(pAttribute->_dispid, CAttrValue::AA_Expando);
        else
            Assert(aaIdx == pAttribute->_pElem->FindAAIndex(pAttribute->_dispid, CAttrValue::AA_Expando));

        Assert(aaIdx != AA_IDX_UNKNOWN);
        hr = THR(pAttribute->_pElem->GetVariantAt(aaIdx, pvarValue));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);    
}

static
HRESULT
RemoveAttrHelper(LPTSTR pchAttrName, PROPERTYDESC **ppPropDesc, DISPID *pdispid, AAINDEX *paaIdx, AAINDEX *pvaaIdx, CElement *pElement, IHTMLDOMAttribute **ppAttribute, DWORD dwFlags)
{
    HRESULT hr;
    CAttribute *pretAttr = NULL;

    Assert(pchAttrName && paaIdx && pvaaIdx && pdispid && ppPropDesc && pElement && ppAttribute);

    hr = THR(GetIndexHelper(pchAttrName, paaIdx, pvaaIdx, pdispid, ppPropDesc, pElement, dwFlags));
    if (hr)
        goto Cleanup;

    if (*paaIdx == AA_IDX_UNKNOWN)
    {
        if (*pvaaIdx != AA_IDX_UNKNOWN)
        {
            // No Attr Node of same name as pAttr exists, but there exists an attr value,
            // create new node for returning to caller
            pretAttr = new CAttribute(NULL, DISPID_UNKNOWN, NULL);
            if (!pretAttr)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            pretAttr->_cstrName.Set(pchAttrName);
            Assert(pretAttr->_varValue.IsEmpty());

            //NOTE: may need to get invoked value here for defaults etc.
            hr = THR(pElement->GetVariantAt(*pvaaIdx, &pretAttr->_varValue));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        // Attr Node of same name as pAttr already exists, just return it.
        IUnknown *pUnk;
        hr = THR(pElement->GetUnknownObjectAt(*paaIdx, &pUnk));
        if (hr)
            goto Cleanup;

        pretAttr = (CAttribute *)pUnk;
        Assert(pretAttr);
        Assert(pretAttr->_varValue.IsEmpty());
        hr = THR(GetNodeValueHelper(pretAttr, *pvaaIdx, &pretAttr->_varValue));
        if (hr)
            goto Cleanup;
    }

    if (pretAttr)
    {
        if (pretAttr->_pElem)
        {
            pretAttr->_pElem->SubRelease();
            pretAttr->_pElem = NULL;
            pretAttr->_pPropDesc = NULL;
            pretAttr->_dispid = DISPID_UNKNOWN;
        }

        Assert(!pretAttr->_pPropDesc);
        Assert(pretAttr->_dispid == DISPID_UNKNOWN);

        hr = THR(pretAttr->PrivateQueryInterface(IID_IHTMLDOMAttribute, (void **)ppAttribute));
        pretAttr->Release();
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

void
CBase::RemoveDOMAttrNode(DISPID dispid)
{
    Assert(IsExpandoDISPID(dispid));
    AAINDEX aaIdx = FindAAIndex(dispid, CAttrValue::AA_DOMAttribute);
    if (aaIdx != AA_IDX_UNKNOWN)
    {
        IUnknown *pUnk;
        CAttribute *pAttr;

        IGNORE_HR(GetUnknownObjectAt(aaIdx, &pUnk));
        pAttr = (CAttribute *)pUnk;
        if (pAttr)
        {
            Assert(pAttr->_varValue.IsEmpty());
            Assert(pAttr->_pElem);
            IGNORE_HR(GetNodeValueHelper(pAttr, AA_IDX_UNKNOWN, &pAttr->_varValue));
            pAttr->_pElem->SubRelease();
            pAttr->_pElem = NULL;
            pAttr->_pPropDesc = NULL;
            pAttr->_dispid = DISPID_UNKNOWN;
            pAttr->Release();
        }
 
        DeleteAt(aaIdx);
    }
}

HRESULT
CBase::UpdateDomAttrCollection(BOOL fDelete, DISPID dispid)
{
    HRESULT hr = S_OK;
    AAINDEX collIdx;
    CAttrCollectionator *pAttrCollator = NULL;

    Assert(IsExpandoDISPID(dispid));
    
    collIdx = _pAA->FindAAIndex(DISPID_INTERNAL_CATTRIBUTECOLLPTRCACHE, CAttrValue::AA_Internal);
    if (collIdx != AA_IDX_UNKNOWN)
    {
        hr = THR(GetPointerAt(collIdx, (void **)&pAttrCollator));
        if (hr)
            goto Cleanup;

        if (!fDelete)
        {
            CAttrCollectionator::AttrDesc ad;
            ad._pPropdesc = NULL;
            ad._dispid = dispid;
            hr = THR(pAttrCollator->_aryAttrDescs.AppendIndirect(&ad));
            if (hr)
                goto Cleanup;
        }
        else 
        {
            long i;
            for (i = pAttrCollator->_lexpandoStartIndex; i < pAttrCollator->_aryAttrDescs.Size(); i++)
            {
                if (dispid == pAttrCollator->_aryAttrDescs[i]._dispid)
                {
                    pAttrCollator->_aryAttrDescs.Delete(i);
                    break;
                }
            }
        }
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CAttribute::get_nodeName(BSTR *pbstrName)
{
    HRESULT hr = E_POINTER;

    if (!pbstrName)
        goto Cleanup;

    *pbstrName = NULL;
    Assert((LPTSTR)_cstrName);

    hr = THR(_cstrName.AllocBSTR(pbstrName));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CAttribute::get_nodeValue(VARIANT *pvarValue)
{
    HRESULT hr = E_POINTER;

    if (!pvarValue)
        goto Cleanup;

    Assert((LPTSTR)_cstrName);
    if (!_pElem)
    {
        // Ether Attribuite Node
        Assert(_dispid == DISPID_UNKNOWN);
        Assert(!_pPropDesc);
        hr = THR(VariantCopy(pvarValue, &_varValue));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(GetNodeValueHelper(this, AA_IDX_UNKNOWN, pvarValue));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CAttribute::put_nodeValue(VARIANT varValue)
{
    HRESULT hr;

    Assert((LPTSTR)_cstrName);
    if (!_pElem)
    {
        // Ether Attribuite Node
        Assert(_dispid == DISPID_UNKNOWN);
        Assert(!_pPropDesc);
        hr = THR(_varValue.Copy(&varValue));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(PutNodeValueHelper(this, AA_IDX_UNKNOWN, varValue));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CAttribute::get_specified(VARIANT_BOOL *pbSpecified)
{
    HRESULT hr = S_OK;
    CAttrValue::AATYPE aaType;
    AAINDEX aaIdx;

    Assert((LPTSTR)_cstrName);
    if (!pbSpecified)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!_pElem)
    {
        // Ether Attribuite Node
        Assert(_dispid == DISPID_UNKNOWN);
        Assert(!_pPropDesc);
        *pbSpecified = VB_FALSE;
        goto Cleanup;
    }

    aaType = _pPropDesc ? CAttrValue::AA_Attribute : CAttrValue::AA_Expando;

    // not there in AA
    aaIdx = _pElem->FindAAIndex((_dispid == DISPID_CElement_style_Str) ? DISPID_INTERNAL_INLINESTYLEAA : _dispid,
                                (_dispid == DISPID_CElement_style_Str) ? CAttrValue::AA_AttrArray : aaType);

    if (_dispid == DISPID_CElement_style_Str && aaIdx != AA_IDX_UNKNOWN)
    {
        if (!_pElem->GetAttrValueAt(aaIdx)->GetAA()->HasAnyAttribute(TRUE))
            aaIdx = AA_IDX_UNKNOWN;
    }

    *pbSpecified = (aaIdx == AA_IDX_UNKNOWN) ? VARIANT_FALSE : VARIANT_TRUE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CAttribute::get_name(BSTR *pbstrName)
{
    return get_nodeName(pbstrName);
}

HRESULT
CAttribute::get_value(BSTR *pbstrvalue)
{
    HRESULT hr;
    CVariant varValue;
    VARIANT varRet;

    if (!pbstrvalue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(get_nodeValue(&varValue));
    if (hr)
        goto Cleanup;

    VariantInit(&varRet);

    // TODO: Need to handle style properly
    hr = THR(VariantChangeTypeSpecial(&varRet, &varValue, VT_BSTR));
    if (hr)
        goto Cleanup;

    *pbstrvalue = V_BSTR(&varRet);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CAttribute::put_value(BSTR bstrvalue)
{
    VARIANT varValue;

    V_VT(&varValue) = VT_BSTR;
    V_BSTR(&varValue) = bstrvalue;
    return put_nodeValue(varValue);
}

HRESULT
CAttribute::get_expando(VARIANT_BOOL *pfIsExpando)
{
    HRESULT hr = S_OK;

    if (!pfIsExpando)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    Assert((LPTSTR)_cstrName);
    Assert(!_pElem || _pPropDesc || _pElem->IsExpandoDISPID(_dispid));
    *pfIsExpando = (!_pElem || _pPropDesc) ? VB_FALSE : VB_TRUE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CAttribute::get_nodeType(long *pnodeType)
{
    HRESULT hr = S_OK;

    if (!pnodeType)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pnodeType = 2; // DOM_ATTRIBUTE
Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CAttribute::get_parentNode(IHTMLDOMNode **pparentNode)
{
    if(pparentNode)
        *pparentNode = NULL;

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::get_childNodes(IDispatch **ppChildCollection)
{
    if(ppChildCollection)
        *ppChildCollection = NULL;

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::get_firstChild ( IHTMLDOMNode **ppNode )
{
    if (ppNode)
        *ppNode = NULL;

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::get_lastChild ( IHTMLDOMNode **ppNode )
{
    if (ppNode)
        *ppNode = NULL;

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::get_previousSibling ( IHTMLDOMNode **ppNode )
{
    if (ppNode)
        *ppNode = NULL;

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::get_nextSibling ( IHTMLDOMNode **ppNode )
{
    if (ppNode)
        *ppNode = NULL;

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::get_attributes(IDispatch **ppAttrCollection)
{
    if (ppAttrCollection)
        *ppAttrCollection = NULL;

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::get_ownerDocument(IDispatch **ppretdoc)
{
    HRESULT     hr = S_OK;

    if(!ppretdoc)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if(_pDocument)
    {
        hr = E_ACCESSDENIED;
        if (   _pMarkup 
            && _pDocument->Markup() 
            && _pMarkup->AccessAllowed(_pDocument->Markup()))
        {
            hr = THR(_pDocument->QueryInterface(IID_IDispatch, (void **)ppretdoc));
        }
        goto Cleanup;
    }

    *ppretdoc = NULL;

    if(!_pElem)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(_pElem->get_ownerDocument(ppretdoc));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CAttribute::insertBefore(IHTMLDOMNode *pNewChild, VARIANT refChild, IHTMLDOMNode **ppRetNode)
{
    if (ppRetNode)
        *ppRetNode = NULL;
    // Don't expect this method to be called on a attribute node
    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::replaceChild(IHTMLDOMNode *pNewChild, IHTMLDOMNode *pOldChild, 
                           IHTMLDOMNode **ppRetNode)
{
    if (ppRetNode)
        *ppRetNode = NULL;
    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::removeChild(IHTMLDOMNode *pOldChild, IHTMLDOMNode **ppRetNode)
{
    if (ppRetNode)
        *ppRetNode = NULL;
    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::appendChild(IHTMLDOMNode *pNewChild, IHTMLDOMNode **ppRetNode)
{
    if (ppRetNode)
        *ppRetNode = NULL;
    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CAttribute::hasChildNodes(VARIANT_BOOL *p)
{
    HRESULT hr = S_OK;
    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *p = VARIANT_FALSE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CAttribute::cloneNode(VARIANT_BOOL fDeep, IHTMLDOMAttribute **ppNodeCloned)
{
    HRESULT               hr = S_OK;
    CDocument          *  pDocument;

    Assert((LPTSTR)_cstrName);

    if(!ppNodeCloned)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppNodeCloned = NULL;

    if(_pElem)
    {
        IDispatch * pIDispDocument;
        hr = THR(_pElem->get_document(&pIDispDocument));
        if(hr)
            goto Cleanup;
        hr = THR(pIDispDocument->QueryInterface(CLSID_CDocument, (void **) &pDocument));
        pIDispDocument->Release();
        if(hr)
            goto Cleanup;
    }
    else
    {
        Assert(_pDocument);
        pDocument = _pDocument;
    }

    hr = THR(pDocument->createAttribute(_cstrName, ppNodeCloned));

Cleanup:

    RRETURN(SetErrorInfo(hr));
}




////////////////////////////////////////////////////////////////////////////////
//
// IHTMLDOMNode methods:
//
////////////////////////////////////////////////////////////////////////////////

HRESULT
CElement::get_nodeType(long *pnodeType)
{
    HRESULT hr = S_OK;

    if (!pnodeType)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    if(Tag() != ETAG_RAW_COMMENT)
        *pnodeType = 1; // ELEMENT_NODE
    else
        *pnodeType = 8;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_nodeName(BSTR *pbstrNodeName)
{
    HRESULT hr = S_OK;

    if(Tag() != ETAG_RAW_COMMENT)
        hr = THR(get_tagName ( pbstrNodeName ));
    else
    {
        if (!pbstrNodeName)
        {
            hr = E_POINTER;
            goto Cleanup;
        }

        *pbstrNodeName = NULL;
    
        hr = THR(FormsAllocString ( _T("#comment"), pbstrNodeName ));
        if ( hr )
            goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_nodeValue(VARIANT *pvarValue)
{
    HRESULT hr = S_OK;

    if (!pvarValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    if (Tag() != ETAG_RAW_COMMENT)
        pvarValue->vt = VT_NULL;
    else
    {
        VariantInit(pvarValue);
        pvarValue->vt = VT_BSTR;
        return DYNCAST(CCommentElement, this)->get_data(&V_BSTR(pvarValue));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::put_nodeValue(VARIANT varValue)
{
    HRESULT hr = S_OK;

    if (Tag() == ETAG_RAW_COMMENT) 
    {

        if (V_VT(&varValue) == VT_BSTR)
        {
            return DYNCAST(CCommentElement, this)->put_data(V_BSTR(&varValue));
        }
        else
            hr = E_INVALIDARG;
    }

    RRETURN(SetErrorInfo(hr));
}


HRESULT
CElement::get_lastChild ( IHTMLDOMNode **ppNode )
{
    HRESULT hr = S_OK;
    CMarkupPointer markupWalk ( Doc() );

    if (!ppNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppNode = NULL;

    if (ETAG_OBJECT == Tag() || ETAG_APPLET == Tag())
    {
        CObjectElement *pelObj = DYNCAST(CObjectElement, this);
        int c = pelObj->_aryParams.Size();
        if (c)
            hr = THR(pelObj->_aryParams[c-1]->QueryInterface(IID_IHTMLDOMNode, (void **)ppNode));

        goto Cleanup; // done
    }

    if ( IsNoScope() )
        goto Cleanup;

    if ( !IsInMarkup() ) // Can just return NULL
        goto Cleanup;

    hr = THR(markupWalk.MoveAdjacentToElement( this, ELEM_ADJ_BeforeEnd));
    if ( hr )
        goto Cleanup;

    hr = THR(GetPreviousHelper ( Doc(), &markupWalk, ppNode ));
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CElement::get_previousSibling ( IHTMLDOMNode **ppNode )
{
    HRESULT hr = S_OK;
    CMarkupPointer markupWalk ( Doc() );

    if (!ppNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppNode = NULL;

    if (ETAG_PARAM == Tag())
    {
        CParamElement *pelParam = DYNCAST(CParamElement, this);
        CObjectElement *pelObj = pelParam->_pelObjParent;
        if (pelObj)
        {
            Assert(pelObj->_aryParams.Size() &&
                   pelParam->_idxParam != -1 &&
                   pelParam->_idxParam < pelObj->_aryParams.Size());
            if (pelParam->_idxParam > 0)
                hr = THR(pelObj->_aryParams[pelParam->_idxParam-1]->QueryInterface(IID_IHTMLDOMNode, (void **)ppNode));

            goto Cleanup; // done
        }
    }

    if ( !IsInMarkup() ) // Can just return NULL
        goto Cleanup;

    hr = THR( markupWalk.MoveAdjacentToElement( this, ELEM_ADJ_BeforeBegin));
    if ( hr )
        goto Cleanup;

    hr = THR(GetPreviousHelper ( Doc(), &markupWalk, ppNode ));
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CElement::get_nextSibling ( IHTMLDOMNode **ppNode )
{
    HRESULT hr = S_OK;
    CMarkupPointer markupWalk ( Doc() );

    if (!ppNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppNode = NULL;

    if (ETAG_PARAM == Tag())
    {
        CParamElement *pelParam = DYNCAST(CParamElement, this);
        CObjectElement *pelObj = pelParam->_pelObjParent;
        if (pelObj)
        {
            Assert(pelObj->_aryParams.Size() &&
                   pelParam->_idxParam != -1 &&
                   pelParam->_idxParam < pelObj->_aryParams.Size());
            if (pelParam->_idxParam+1 < pelObj->_aryParams.Size())
                hr = THR(pelObj->_aryParams[pelParam->_idxParam+1]->QueryInterface(IID_IHTMLDOMNode, (void **)ppNode));

            goto Cleanup; // done
        }
    }

    if ( !IsInMarkup() ) // Can just return NULL
        goto Cleanup;
    
    hr = THR( markupWalk.MoveAdjacentToElement( this, ELEM_ADJ_AfterEnd));
    if ( hr )
        goto Cleanup;

    hr = THR(GetNextHelper ( Doc(), &markupWalk, ppNode ));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_firstChild ( IHTMLDOMNode **ppNode )
{
    HRESULT hr = S_OK;
    CMarkupPointer markupWalk ( Doc() );

    if (!ppNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppNode = NULL;

    if (ETAG_OBJECT == Tag() || ETAG_APPLET == Tag())
    {
        CObjectElement *pelObj = DYNCAST(CObjectElement, this);
        if (pelObj->_aryParams.Size())
            hr = THR(pelObj->_aryParams[0]->QueryInterface(IID_IHTMLDOMNode, (void **)ppNode));

        goto Cleanup; // done
    }

    if ( !IsInMarkup() ) // Can just return NULL
        goto Cleanup;

    if ( IsNoScope() )
        goto Cleanup;

    hr = THR( markupWalk.MoveAdjacentToElement( this, ELEM_ADJ_AfterBegin));
    if ( hr )
        goto Cleanup;

    hr = THR(GetNextHelper ( Doc(), &markupWalk, ppNode ));


Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_parentNode(IHTMLDOMNode **pparentNode)
{
    HRESULT             hr = S_OK;
    CTreeNode           *pNode;

    if (!pparentNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pparentNode = NULL;

    pNode = GetFirstBranch();
    if ( !pNode )
    {
        if (ETAG_PARAM == Tag())
        {
            CObjectElement *pelObj = DYNCAST(CParamElement, this)->_pelObjParent;
            if (pelObj)
                hr = THR(pelObj->QueryInterface(IID_IHTMLDOMNode, (void **)pparentNode));
        }
     
        goto Cleanup;
    }

    pNode = pNode->Parent();

    hr = THR(ParentNodeHelper(pNode, pparentNode));
    if( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT 
CElement::DOMWalkChildren ( long lWantItem, long *plCount, IDispatch **ppDispItem )
{
    HRESULT             hr = S_OK;
    CMarkupPointer      markupWalk (Doc());
    CMarkupPointer      markupWalkEnd (Doc());
    CTreeNode           *pnodeRight;
    MARKUP_CONTEXT_TYPE context;
    long                lCount = 0;
    BOOL                fWantItem = (lWantItem == -1 ) ? FALSE : TRUE;
    long                lTextID;
    BOOL                fDone = FALSE;

    if (ppDispItem)
        *ppDispItem = NULL;

    if (!IsInMarkup())
        goto Cleanup;

    hr = THR( markupWalk.MoveAdjacentToElement( this, Tag() == ETAG_ROOT ? ELEM_ADJ_AfterBegin : ELEM_ADJ_BeforeBegin));
    if ( hr )
        goto Cleanup;

    hr = THR( markupWalkEnd.MoveAdjacentToElement( this, Tag() == ETAG_ROOT ? ELEM_ADJ_BeforeEnd : ELEM_ADJ_AfterEnd));
    if ( hr )
        goto Cleanup;

    do
    {
        hr = THR( markupWalk.Right( TRUE, &context, &pnodeRight, NULL, NULL, &lTextID));
        if ( hr )
            goto Cleanup;

        switch ( context )
        {
            case CONTEXT_TYPE_None:
                fDone = TRUE;
                break;
                
            case CONTEXT_TYPE_ExitScope://don't care ...
                if ( pnodeRight->Element() == this )
                    goto NotFound;
                break;

            case CONTEXT_TYPE_EnterScope:
                if ( pnodeRight->Element() != this )
                {
                    // Add to our child list
                    lCount++;
                    // Go to the end of this element, since we will handle it as a container
                    hr = THR( markupWalk.MoveAdjacentToElement( pnodeRight->Element(), ELEM_ADJ_AfterEnd));
                    if ( hr )
                        goto Cleanup;

                    // Need to test we haven't left the scope of my parent.
                    // Overlapping could cause us to move outside
                    if ( markupWalkEnd.IsLeftOf( & markupWalk ) )
                    {
                        fDone = TRUE;
                    }
                }
                break;

            case CONTEXT_TYPE_Text:
                lCount++;
                break;

            case CONTEXT_TYPE_NoScope:
                if ( pnodeRight->Element() == this )
                {
                    // Left scope of current noscope element
                    goto NotFound;
                }
                else
                {
                    // Add to our child list
                    lCount++;
                }
                break;
        }
        if (fWantItem && (lCount-1 == lWantItem ))
        {
            // Found the item we're looking for
            if ( !ppDispItem )
                goto Cleanup; // Didn't want an item, just validating index

            if ( context == CONTEXT_TYPE_Text )
            {
                // Text Node
                CDOMTextNode *pTextNode = NULL;

                hr = THR(CreateTextNode (Doc(), &markupWalk, lTextID, &pTextNode ));
                if ( hr )
                    goto Cleanup;

                hr = THR ( pTextNode->QueryInterface ( IID_IDispatch, (void **)ppDispItem ) );
                if ( hr )
                    goto Cleanup;
                pTextNode->Release();
            }
            else
            {
                // Return Disp to Element
                hr = THR(pnodeRight->GetElementInterface ( IID_IDispatch, (void **) ppDispItem  ));
                if ( hr )
                    goto Cleanup;
            }
            goto Cleanup;
        }
        // else just looking for count
    } while( !fDone );

NotFound:
    if ( fWantItem )
    {
        // Didn't find it - index must be beyond range
        hr = E_INVALIDARG;
    }

Cleanup:
    if ( plCount )
        *plCount = lCount;
    return hr;
}


HRESULT
CElement::hasChildNodes(VARIANT_BOOL *p)
{
    HRESULT hr = S_OK;

    if (!p)
        goto Cleanup;

    if (Tag() == ETAG_OBJECT || Tag() == ETAG_APPLET)
    {
        *p = DYNCAST(CObjectElement, this)->_aryParams.Size() ? VARIANT_TRUE : VARIANT_FALSE;
        goto Cleanup;
    }

    *p = VARIANT_FALSE;

    if ( !IsInMarkup() ) // Can just return FALSE
        goto Cleanup;

    // See if we have a child at Index == 0

    hr = THR( DOMWalkChildren ( 0, NULL, NULL ));
    if ( hr == E_INVALIDARG )
    {
        // Invalid Index
        hr = S_OK;
        goto Cleanup;
    }
    else if ( hr )
        goto Cleanup;

    *p = VARIANT_TRUE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_childNodes(IDispatch **ppChildCollection)
{
    HRESULT hr = S_OK;
    CDOMChildrenCollection *pChildren;

    if ( !ppChildCollection )
        goto Cleanup;

    *ppChildCollection = NULL;

    pChildren = EnsureDOMChildrenCollectionPtr();
    if ( !pChildren )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    hr = THR(pChildren->QueryInterface (IID_IDispatch,(void **)ppChildCollection));
    if ( hr )
        goto Cleanup;

    pChildren->Release(); // Lifetime is controlled by extrenal ref.

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


CAttrCollectionator *
CElement::EnsureAttributeCollectionPtr ( )
{
    HRESULT hr = S_OK;
    CAttrCollectionator *pAttrCollator = NULL;
    IGNORE_HR(GetPointerAt(FindAAIndex(DISPID_INTERNAL_CATTRIBUTECOLLPTRCACHE, CAttrValue::AA_Internal), (void **)&pAttrCollator));
    if (!pAttrCollator)
    {
        pAttrCollator = new CAttrCollectionator(this);
        
        if (pAttrCollator)
        {
            pAttrCollator->EnsureCollection();

            hr = THR(AddPointer(DISPID_INTERNAL_CATTRIBUTECOLLPTRCACHE, (void *)pAttrCollator, CAttrValue::AA_Internal ));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        pAttrCollator->AddRef();
    }

Cleanup:
    return pAttrCollator;
}

HRESULT
CElement::get_attributes(IDispatch **ppAttrCollection)
{

    HRESULT hr = S_OK;
    CAttrCollectionator *pAttrCollator = NULL;

    if (!ppAttrCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *ppAttrCollection = NULL;

    if(Tag() == ETAG_RAW_COMMENT)
        // Comment tags should return NULL according to spec
        goto Cleanup;

    pAttrCollator = EnsureAttributeCollectionPtr();
    if ( !pAttrCollator )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pAttrCollator->QueryInterface(IID_IDispatch, (void **)ppAttrCollection));
    if ( hr )
        goto Cleanup;

Cleanup:    
    if (pAttrCollator)
       pAttrCollator->Release();

    RRETURN(SetErrorInfo(hr));
}


HRESULT 
CElement::GetDOMInsertPosition ( CElement *pRefElement, CDOMTextNode *pRefTextNode, CMarkupPointer *pmkptrPos )
{
    HRESULT hr = S_OK;

    if ( !pRefElement && !pRefTextNode )
    {
        // As per DOM spec, if refChild is NULL Insert at end of child list
        // but only if the elem into which it is to be inserted can have children!
        if (IsNoScope())
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }

        hr = THR(EnsureInMarkup());
        if ( hr )
            goto Cleanup;
        hr = THR(pmkptrPos->MoveAdjacentToElement ( this, ELEM_ADJ_BeforeEnd ));
    }
    else
    {
        hr = GetDOMInsertHelper (pRefElement, pRefTextNode, pmkptrPos ); 
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CElement::appendChild(IHTMLDOMNode *pNewChild, IHTMLDOMNode **ppRetNode)
{
    CVariant varEmpty(VT_NULL);

    return insertBefore ( pNewChild, *(VARIANT *)&varEmpty, ppRetNode );
}

static BOOL IsChild(CElement *pelParent, CElement *pelChild, CDOMTextNode *pTextNode)
{
    Assert(pelParent);
    Assert(!pelChild || !pTextNode);

    if (pelChild)
    {
        if ((pelParent->Tag() == ETAG_OBJECT || pelParent->Tag() == ETAG_APPLET) &&
            pelChild->Tag() == ETAG_PARAM)
        {
            CParamElement *pelParam = DYNCAST(CParamElement, pelChild);
            Assert((pelParam->_pelObjParent != pelParent) ||
                   (pelParent->Tag() == ETAG_OBJECT) ||
                   (pelParent->Tag() == ETAG_APPLET));
            return (pelParam->_pelObjParent == pelParent);

        }

        CTreeNode *pNode = pelChild->GetFirstBranch();
        if (!pNode || !pNode->Parent() || (pNode->Parent()->Element() != pelParent))
            return FALSE;
    }
    else if (pTextNode)
    {
        CElement *pelTxtNodeParent = NULL;
        IHTMLElement *pITxtNodeParent = NULL;
        Assert(pTextNode->MarkupPtr());
        Assert(pTextNode->MarkupPtr()->Cling()); // Must have Glue!
        Assert(pTextNode->MarkupPtr()->Gravity()); // Must have right gravity.

        CurrentScope(pTextNode->MarkupPtr(), &pITxtNodeParent, NULL);
        if (pITxtNodeParent)
            pITxtNodeParent->QueryInterface(CLSID_CElement, (void **)&pelTxtNodeParent);
        ReleaseInterface(pITxtNodeParent);
        if (pelTxtNodeParent != pelParent)
            return FALSE;
    }

    return TRUE;
}

HRESULT
CElement::insertBefore(IHTMLDOMNode *pNewChild, VARIANT refChild, IHTMLDOMNode **ppRetNode)
{
    HRESULT                 hr;
    CElement *              pRefElement = NULL;
    CDOMTextNode *          pRefTextNode = NULL;
    CElement *              pNewElement = NULL;
    CDOMTextNode *          pNewTextNode = NULL;
    CDoc *                  pDoc = Doc();
    CMarkupPointer          mkpPtr (pDoc);

    if (!pNewChild)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(CrackDOMNodeVARIANT(&refChild, &pRefTextNode, &pRefElement, GetWindowedMarkupContext()));
    if (hr)
        goto Cleanup;

    hr = THR(CrackDOMNode((IUnknown*)pNewChild, &pNewTextNode, &pNewElement, GetWindowedMarkupContext()));
    if (hr)
        goto Cleanup;

    Assert(IsRootOnlyIfDocument(pNewChild, pNewElement));

    if (!IsChild(this, pRefElement, pRefTextNode))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
                
    if (pNewElement && (Tag() == ETAG_OBJECT || Tag() == ETAG_APPLET))
    {
        Assert(!pRefElement || pRefElement->Tag() == ETAG_PARAM);
        CObjectElement *pelObj = DYNCAST(CObjectElement, this);

        hr = THR(pelObj->AddParam(pNewElement, pRefElement));
    }
    else
    {
        // Position ourselves in the right spot
        hr = THR(GetDOMInsertPosition(pRefElement, pRefTextNode, &mkpPtr));
        if (hr)
            goto Cleanup;

        // Now mkpPtr is Positioned at the insertion point, insert the new content
        hr = THR(InsertDOMNodeHelper(pNewElement, pNewTextNode, &mkpPtr));
    }

    if (hr)
        goto Cleanup;

    if (ppRetNode)
        hr = THR(pNewChild->QueryInterface(IID_IHTMLDOMNode, (void**)ppRetNode));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::replaceChild(IHTMLDOMNode *pNewChild, IHTMLDOMNode *pOldChild, IHTMLDOMNode **pRetNode)
{
    HRESULT                 hr;
    CElement *              pOldElement = NULL;
    CDOMTextNode *          pOldTextNode = NULL;
    CElement *              pNewElement = NULL;
    CDOMTextNode *          pNewTextNode = NULL;
    CDoc *                  pDoc = Doc();
    CMarkupPointer          mkpPtr(pDoc);

    // Pull pOldChild, and all its contents, out of the tree, into its own tree
    // replace it with pNewChild, and all its contents

    if (!pNewChild || !pOldChild)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(CrackDOMNode((IUnknown*)pOldChild, &pOldTextNode, &pOldElement, GetWindowedMarkupContext() ));
    if ( hr )
        goto Cleanup;

    hr = THR(CrackDOMNode((IUnknown*)pNewChild, &pNewTextNode, &pNewElement, GetWindowedMarkupContext() ));
    if ( hr )
        goto Cleanup;

    Assert(IsRootOnlyIfDocument(pNewChild, pNewElement));

    if (!IsChild(this, pOldElement, pOldTextNode))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (Tag() == ETAG_OBJECT || Tag() == ETAG_APPLET)
    {
        CObjectElement *pelObj = DYNCAST(CObjectElement, this);
        
        if (pNewElement && pOldElement)
        {
            Assert(pOldElement->Tag() == ETAG_PARAM);
            hr = THR(pelObj->ReplaceParam(pNewElement, pOldElement));
            if (hr)
                goto Cleanup;

            // Return the node being replaced
            if (pRetNode)
                hr = THR(pOldChild->QueryInterface(IID_IHTMLDOMNode, (void**)pRetNode));

            goto Cleanup; // done
        }
    }

    // Position ourselves in the right spot
    hr = THR(GetDOMInsertPosition ( pOldElement, pOldTextNode, &mkpPtr ));
    if ( hr )
        goto Cleanup;

    mkpPtr.SetGravity ( POINTER_GRAVITY_Left );

    {
        // Lock the markup, to prevent it from going away in case the entire contents are being removed.
        CMarkup::CLock MarkupLock(mkpPtr.Markup());

        hr = THR(RemoveDOMNodeHelper ( pDoc, pOldElement, pOldTextNode ));
        if ( hr )
            goto Cleanup;

        // Now mkpPtr is Positioned at the insertion point, insert the new content
        hr = THR(InsertDOMNodeHelper( pNewElement, pNewTextNode, &mkpPtr ));
        if ( hr )
            goto Cleanup;

        // Return the node being replaced
        if ( pRetNode )
            hr = THR(pOldChild->QueryInterface ( IID_IHTMLDOMNode, (void**)pRetNode));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}



HRESULT
CElement::removeChild(IHTMLDOMNode *pOldChild, IHTMLDOMNode **pRetNode)
{
    HRESULT hr;
    CDOMTextNode *pChildTextNode = NULL;
    CElement *pChildElement = NULL;
    CDoc *pDoc = Doc();

    // Remove the child from the tree, putting it in its own tree

    if ( !pOldChild )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(CrackDOMNode((IUnknown*)pOldChild, &pChildTextNode, &pChildElement, GetWindowedMarkupContext() ));
    if ( hr )
        goto Cleanup;

    if (!IsChild(this, pChildElement, pChildTextNode))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pChildElement && (Tag() == ETAG_OBJECT || Tag() == ETAG_APPLET))
    {
        Assert(pChildElement->Tag() == ETAG_PARAM);
        CObjectElement *pelObj = DYNCAST(CObjectElement, this);

        hr = THR(pelObj->RemoveParam(pChildElement));
    }
    else
        hr = THR(RemoveDOMNodeHelper(pDoc, pChildElement, pChildTextNode));

    if ( hr )
        goto Cleanup;

    // Return the node being removed
    if ( pRetNode )
        hr = THR(pOldChild->QueryInterface ( IID_IHTMLDOMNode, (void**)pRetNode));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//
// IHTMLDocument3 DOM methods
//
HRESULT CDoc::CreateDOMTextNodeHelper ( CMarkupPointer *pmkpStart, CMarkupPointer *pmkpEnd,
                                       IHTMLDOMNode **ppTextNode)
{
    HRESULT hr;
    long lTextID;
    CDOMTextNode *pTextNode;

    // ID it
    hr = THR(pmkpStart->SetTextIdentity( pmkpEnd, &lTextID ));
    if ( hr )
        goto Cleanup;

    // set right gravity so that an adjacent text node's markup ptr can never
    // move accidentally.
    hr = THR(pmkpStart->SetGravity ( POINTER_GRAVITY_Right ));
    if (hr)
        goto Cleanup;

    // Text Node takes ownership of pmkpStart
    pTextNode = new CDOMTextNode ( lTextID, this, pmkpStart ); // AddRef's the Markup
    if ( !pTextNode )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if ( ppTextNode )
    {
        hr = THR(pTextNode->QueryInterface ( IID_IHTMLDOMNode, (void**)ppTextNode ));
        if ( hr )
            goto Cleanup;
    }

    pTextNode->Release(); // Creating AddREf'd it once - refcount owned by external AddRef

    hr = THR(_HtPvPvDOMTextNodes.Insert ( (void*)(DWORD_PTR)(lTextID<<4), (void*)pTextNode ) );
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//
//  IE5 XOM. Extensions for document construction
//

HRESULT 
CElement::GetMarkupPtrRange(CMarkupPointer *pmkptrStart, CMarkupPointer *pmkptrEnd, BOOL fEnsureMarkup)
{
    HRESULT hr;
    
    Assert(pmkptrStart);
    Assert(pmkptrEnd);
    
    if (fEnsureMarkup)
    {
        hr = THR(EnsureInMarkup());
        if (hr)
            goto Cleanup;
    }

    hr = THR(pmkptrStart->MoveAdjacentToElement(this, Tag() == ETAG_ROOT? ELEM_ADJ_AfterBegin : ELEM_ADJ_BeforeBegin));
    if (hr)
        goto Cleanup;

    hr = THR(pmkptrEnd->MoveAdjacentToElement(this, Tag() == ETAG_ROOT? ELEM_ADJ_BeforeEnd : ELEM_ADJ_AfterEnd));

Cleanup:
    return hr;
}


HRESULT
CElement::cloneNode(VARIANT_BOOL fDeep, IHTMLDOMNode **ppNodeCloned)
{
    HRESULT                 hr = E_OUTOFMEMORY;
    CDoc *                  pDoc = Doc();
    CMarkup *               pMarkupTarget = NULL;
    CElement *              pElement = NULL;
    CTreeNode   *           pNode;

    if ( !ppNodeCloned || Tag() == ETAG_ROOT )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppNodeCloned = NULL;

    if (!fDeep || !IsInMarkup() || IsNoScope())
    {
        hr = THR(Clone(&pElement, pDoc));
        if (hr)
            goto Cleanup;

        hr = THR(pElement->PrivateQueryInterface(IID_IHTMLDOMNode, (void **)ppNodeCloned));
        if (hr)
            goto Cleanup;

        pElement->Release();

        Assert(Tag() != ETAG_PARAM ||
               (!(DYNCAST(CParamElement, pElement)->_pelObjParent) &&
                DYNCAST(CParamElement, this)->_pelObjParent));

        if (fDeep && (Tag() == ETAG_OBJECT || Tag() == ETAG_APPLET))
        {
            CParamElement *pelParamClone;
            CObjectElement *pelObj = DYNCAST(CObjectElement, this);
            CObjectElement *pelObjClone = DYNCAST(CObjectElement, pElement);
            
            Assert(pelObjClone->_aryParams.Size() == 0);

            for (int i = 0; i < pelObj->_aryParams.Size(); i++)
            {
                Assert(pelObj->_aryParams[i] && pelObj->_aryParams[i]->Tag() == ETAG_PARAM);
                hr = THR(pelObj->_aryParams[i]->Clone((CElement **)&pelParamClone, pDoc));
                if (hr)
                    goto Cleanup;

                Assert(pelParamClone->_idxParam == -1);
                Assert(!pelParamClone->_pelObjParent);

                hr = THR(pelObjClone->AddParam(pelParamClone, NULL));
                if (hr)
                    goto Cleanup;

                Assert(pelParamClone->_idxParam == i);
                Assert(pelParamClone->_pelObjParent == pelObjClone);

                pelParamClone->Release();
                Assert(pelParamClone->GetObjectRefs());;
            }

            Assert(pelObj->_aryParams.Size() == pelObjClone->_aryParams.Size());
        }
    }
    else
    {
        CMarkupPointer mkptrStart ( pDoc );
        CMarkupPointer mkptrEnd ( pDoc );
        CMarkupPointer mkptrTarget ( pDoc );

        // Get src ptrs
        hr = THR(GetMarkupPtrRange(&mkptrStart, &mkptrEnd));
        if (hr)
            goto Cleanup;

        // create new markup
        hr = THR(pDoc->CreateMarkup(&pMarkupTarget, GetWindowedMarkupContext()));
        if (hr)
            goto Cleanup;

        hr = THR( pMarkupTarget->SetOrphanedMarkup( TRUE ) );
        if( hr )
            goto Cleanup;

        // Get target ptr

        hr = THR(mkptrTarget.MoveToContainer(pMarkupTarget,TRUE));
        if (hr)
            goto Cleanup;

        // Copy src -> target
        hr = THR(pDoc->Copy(&mkptrStart, &mkptrEnd, &mkptrTarget, MUS_DOMOPERATION));
        if (hr)
            goto Cleanup;

        // This addrefs the markup too!

        // Go Right to pick up the new node ptr
        hr = THR(mkptrTarget.Right(FALSE, NULL, &pNode, 0, NULL,NULL));
        if (hr)
            goto Cleanup;

        hr = THR(pNode->Element()->PrivateQueryInterface(IID_IHTMLDOMNode, (void **)ppNodeCloned));
        if (hr)
            goto Cleanup;
    }

Cleanup:

    // release extra markup lock
    if (pMarkupTarget)
        pMarkupTarget->Release();

    RRETURN(SetErrorInfo(hr));

}

// Surgicaly remove pElemApply out of its current context,
// Apply it over this element

HRESULT
CElement::applyElement(IHTMLElement *pElemApply, BSTR bstrWhere, IHTMLElement **ppElementApplied)
{
    HRESULT hr;
    CDoc *pDoc = Doc();
    CMarkupPointer mkptrStart(pDoc);
    CMarkupPointer mkptrEnd (pDoc);
    CElement *pElement;
    htmlApplyLocation where = htmlApplyLocationOutside;

    if ( ppElementApplied )
        *ppElementApplied = NULL;

    if ( !pElemApply )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!pDoc->IsOwnerOf(pElemApply))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(pElemApply->QueryInterface ( CLSID_CElement, (void**) &pElement ));
    if (hr)
        goto Cleanup;

    ENUMFROMSTRING(htmlApplyLocation, bstrWhere, (long *)&where);

    // No scoped elements cannot be applied as they cannot have children!
    // Nor can the root element, nor can you apply something outside a root
    if ( pElement->IsNoScope() || 
         pElement->Tag() == ETAG_ROOT || 
         ( Tag() == ETAG_ROOT && where == htmlApplyLocationOutside ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Get src ptrs
    hr = THR(EnsureInMarkup());
    if (hr)
        goto Cleanup;

    hr = THR(mkptrStart.MoveAdjacentToElement(this, where ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterBegin));
    if (hr)
        goto Cleanup;

    hr = THR(mkptrEnd.MoveAdjacentToElement(this, where ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeEnd));
    if (hr)
        goto Cleanup;

    // Surgically remove the elem to be applied if in a markup.
    if (pElement->IsInMarkup())
    {
        hr = THR(pDoc->RemoveElement(pElement, MUS_DOMOPERATION));
        if ( hr )
            goto Cleanup;
    }

    hr = THR(pDoc->InsertElement ( pElement, &mkptrStart, &mkptrEnd, MUS_DOMOPERATION ));
    if (hr)
        goto Cleanup;

    if ( ppElementApplied )
        hr = THR(pElemApply->QueryInterface ( IID_IHTMLElement, (void**) ppElementApplied ));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CElement::removeNode (VARIANT_BOOL fDeep, IHTMLDOMNode **ppNodeRemoved)
{
    HRESULT hr = S_OK;

    // Pull element out of the tree
    if ( ppNodeRemoved )
        *ppNodeRemoved = NULL;

    Assert( Tag() != ETAG_ROOT );

    if ( fDeep )
    {
        hr = THR(RemoveDOMNodeHelper ( Doc(), this, NULL ));
        if ( hr )
            goto Cleanup;
    }
    else if (IsInMarkup())
    {
        // Surgical removal
        hr = THR(Doc()->RemoveElement ( this, MUS_DOMOPERATION ) );
        if ( hr )
            goto Cleanup;
    }

    if ( ppNodeRemoved )
    {
        hr = THR(QueryInterface(IID_IHTMLDOMNode, (void**)ppNodeRemoved));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CElement::replaceNode(IHTMLDOMNode *pNodeReplace, IHTMLDOMNode **ppNodeReplaced)
{
    HRESULT hr;
    CDOMTextNode *pNewTextNode = NULL;
    CElement *pNewElement = NULL;
    CDoc *pDoc = Doc();
        
    if ( ppNodeReplaced )
        *ppNodeReplaced = NULL;

    Assert( Tag() != ETAG_ROOT );

    if ( !pNodeReplace )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(CrackDOMNode((IUnknown*)pNodeReplace, &pNewTextNode, &pNewElement, GetWindowedMarkupContext() ));
    if ( hr )
        goto Cleanup;

    Assert(IsRootOnlyIfDocument(pNodeReplace, pNewElement));

    hr = THR(ReplaceDOMNodeHelper ( pDoc, this, NULL, pNewElement, pNewTextNode ));
    if ( hr )
        goto Cleanup;

    if ( ppNodeReplaced )
    {
        hr = THR(QueryInterface(IID_IHTMLDOMNode, (void**)ppNodeReplaced));
    }

Cleanup:

    RRETURN(SetErrorInfo(hr));
}    

HRESULT
CElement::swapNode(IHTMLDOMNode *pNodeSwap, IHTMLDOMNode **ppNodeSwapped)
{
    CElement *      pSwapElement = NULL;
    CDOMTextNode *  pSwapText = NULL;
    CDoc *          pDoc = Doc();
    HRESULT         hr;
        
    if ( ppNodeSwapped )
        *ppNodeSwapped = NULL;

    Assert( Tag() != ETAG_ROOT );

    if ( !pNodeSwap )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(CrackDOMNode((IUnknown*)pNodeSwap, &pSwapText, &pSwapElement, GetWindowedMarkupContext() ));
    if ( hr )
        goto Cleanup;

    Assert(IsRootOnlyIfDocument(pNodeSwap, pSwapElement));

    hr = THR (SwapDOMNodeHelper ( pDoc, this, NULL, pSwapElement, pSwapText ));
    if ( hr )
        goto Cleanup;

    if ( ppNodeSwapped )
    {
        hr = THR(QueryInterface(IID_IHTMLDOMNode, (void**)ppNodeSwapped));
    }

Cleanup:

    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::insertAdjacentElement(BSTR bstrWhere, IHTMLElement *pElemInsert, IHTMLElement **ppElementInserted)
{
    HRESULT                     hr;
    htmlAdjacency               where;
    ELEMENT_ADJACENCY           adj;
    CDoc *pDoc =                Doc();
    CMarkupPointer mkptrTarget(pDoc);
    CElement *pElement = NULL;

    if (ppElementInserted)
        *ppElementInserted = NULL;

    if (!pElemInsert)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!pDoc->IsOwnerOf( pElemInsert ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(ENUMFROMSTRING(htmlAdjacency, bstrWhere, (long *)&where));
    if (hr)
        goto Cleanup;

    hr = THR(pElemInsert->QueryInterface(CLSID_CElement, (void **)&pElement));
    if (hr)
        goto Cleanup;

    // Can't insert a root, can't insert outside of root
    if( pElement->Tag() == ETAG_ROOT || 
        ( Tag() == ETAG_ROOT && 
          ( where == htmlAdjacencyBeforeBegin || 
            where == htmlAdjacencyAfterEnd ) ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    switch (where)
    {
    case htmlAdjacencyBeforeBegin:
    default:
        adj = ELEM_ADJ_BeforeBegin;
        break;
    case htmlAdjacencyAfterBegin:
        adj = ELEM_ADJ_AfterBegin;
        break;
    case htmlAdjacencyBeforeEnd:
        adj = ELEM_ADJ_BeforeEnd;
        break;
    case htmlAdjacencyAfterEnd:
        adj = ELEM_ADJ_AfterEnd;
        break;
    }

    // Get target ptr
    hr = THR(EnsureInMarkup());
    if (hr)
        goto Cleanup;

    hr = THR(mkptrTarget.MoveAdjacentToElement(this, adj));
    if (hr)
        goto Cleanup;

    // Move src -> target
    hr = THR(InsertDOMNodeHelper(pElement, NULL, &mkptrTarget));
    if (hr)
        goto Cleanup;

    if ( ppElementInserted )
    {
        *ppElementInserted = pElemInsert;
        (*ppElementInserted)->AddRef();
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

static
HRESULT
SetAdjacentTextPointer ( CElement *pElem, htmlAdjacency where, 
    MARKUP_CONTEXT_TYPE *pContext, CMarkupPointer *pmkptrStart, long *plCharCount)
{
    ELEMENT_ADJACENCY           adj;
    BOOL fLeft;
    HRESULT hr;

    switch (where)
    {
    case htmlAdjacencyBeforeBegin:
    default:
        adj = ELEM_ADJ_BeforeBegin;
        fLeft = TRUE;
        break;
    case htmlAdjacencyAfterBegin:
        adj = ELEM_ADJ_AfterBegin;
        fLeft = FALSE;
        break;
    case htmlAdjacencyBeforeEnd:
        adj = ELEM_ADJ_BeforeEnd;
        fLeft = TRUE;
        break;
    case htmlAdjacencyAfterEnd:
        adj = ELEM_ADJ_AfterEnd;
        fLeft = FALSE;
        break;
    }

    hr = THR(pmkptrStart->MoveAdjacentToElement(pElem, adj));
    if (hr)
        goto Cleanup;

    if ( fLeft )
    {
        // Need to move the pointer to the start of the text
        hr = THR(pmkptrStart->Left ( TRUE, pContext, NULL, plCharCount, NULL, NULL ));
        if ( hr )
            goto Cleanup;
    }
    else if ( plCharCount )
    {
        // Need to do a non-moving Right to get the text length
        hr = THR(pmkptrStart->Right ( FALSE, pContext, NULL, plCharCount, NULL, NULL ));
        if ( hr )
            goto Cleanup;
    }
Cleanup:
    RRETURN(hr);
}


HRESULT
CElement::getAdjacentText( BSTR bstrWhere, BSTR *pbstrText )
{
    HRESULT                     hr = S_OK;
    CMarkupPointer              mkptrStart ( Doc() );
    htmlAdjacency               where;
    long                        lCharCount = -1;
    MARKUP_CONTEXT_TYPE         context;

    hr = THR(ENUMFROMSTRING(htmlAdjacency, bstrWhere, (long *)&where));
    if (hr)
        goto Cleanup;

    if ( !pbstrText )
        goto Cleanup;

    *pbstrText = NULL;

    hr = THR(SetAdjacentTextPointer ( this, where, &context, &mkptrStart, &lCharCount ));
    if ( hr )
        goto Cleanup;

    // Is there any text to return
    if ( context != CONTEXT_TYPE_Text || lCharCount == 0 )
        goto Cleanup;

    // Alloc memory
    hr = FormsAllocStringLen ( NULL, lCharCount, pbstrText );
    if ( hr )
        goto Cleanup;

    // Read it into the buffer
    hr = THR(mkptrStart.Right( FALSE, &context, NULL, &lCharCount, *pbstrText, NULL));
    if ( hr )
        goto Cleanup;
    
Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::replaceAdjacentText( BSTR bstrWhere, BSTR bstrText, BSTR *pbstrText )
{
    HRESULT                     hr = S_OK;
    CMarkupPointer              mkptrStart ( Doc() );
    CMarkupPointer              mkptrEnd ( Doc() );
    htmlAdjacency               where;
    long                        lCharCount = -1;
    MARKUP_CONTEXT_TYPE         context;

    hr = THR(ENUMFROMSTRING(htmlAdjacency, bstrWhere, (long *)&where));
    if (hr)
        goto Cleanup;

    if ( pbstrText )
    {
        hr = THR (getAdjacentText(bstrWhere, pbstrText ));
        if ( hr )
            goto Cleanup;
    }

    hr = THR(SetAdjacentTextPointer ( this, where, &context, &mkptrStart, &lCharCount ));
    if ( hr )
        goto Cleanup;

    hr = THR(mkptrEnd.MoveToPointer ( &mkptrStart ) );
    if ( hr )
        goto Cleanup;

    if ( context == CONTEXT_TYPE_Text && lCharCount > 0 )
    {
        hr = THR( mkptrEnd.Right ( TRUE, &context, NULL, &lCharCount, NULL, NULL ));
        if ( hr )
            goto Cleanup;        
    }

    hr = THR(Doc()->Remove ( &mkptrStart, &mkptrEnd, MUS_DOMOPERATION ));
    if ( hr )
        goto Cleanup;

    hr = THR(mkptrStart.Doc()->InsertText( & mkptrStart, bstrText, -1, MUS_DOMOPERATION ));
    if ( hr )
        goto Cleanup;
    
Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_canHaveChildren(VARIANT_BOOL *pvb)
{
    *pvb = IsNoScope() ? VARIANT_FALSE : VARIANT_TRUE;
    return S_OK;
}

HRESULT
CElement::get_ownerDocument(IDispatch **ppretdoc)
{
    return OwnerDocHelper(ppretdoc, NULL, this);
}


HRESULT
CElement::normalize()
{
    HRESULT hr = S_OK;
    CDoc *pDoc = GetDocPtr();
    CMarkupPointer mkpStart(pDoc);
    CMarkupPointer mkpEnd(pDoc);        // Always positioned at just before the end of the element to normalize
    CMarkupPointer mkptxtend(pDoc);

    if(IsNoScope())
    {
        goto Cleanup;
    }

    hr = THR(mkpStart.MoveAdjacentToElement(this, ELEM_ADJ_AfterBegin));
    if (hr)
        goto Cleanup;
    
    hr = THR(mkpEnd.MoveAdjacentToElement(this, ELEM_ADJ_BeforeEnd));
    if (hr)
        goto Cleanup;

    hr = THR(mkptxtend.MoveToPointer(&mkpStart));
    if (hr)
        goto Cleanup;

    hr = THR(ScanText(pDoc, &mkpStart, &mkptxtend, &mkpEnd));
    if( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));

}

// Code for implementing IHTMLDOMNode for Document

HRESULT
CDocument::get_nodeType(long *pnodeType)
{
    
    HRESULT hr = S_OK;

    if (!pnodeType)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pnodeType = _lnodeType;        // Get the actual node type

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::get_parentNode(IHTMLDOMNode **pparentNode)
{
    HRESULT hr = S_OK;

    if (!pparentNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pparentNode = NULL;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::hasChildNodes(VARIANT_BOOL *p)
{
    return Markup()->Root()->hasChildNodes(p);
}

HRESULT
CDocument::get_childNodes(IDispatch **ppChildCollection)
{
    return Markup()->Root()->get_childNodes(ppChildCollection);
}

HRESULT
CDocument::get_attributes(IDispatch **ppAttrCollection)
{
    HRESULT hr = S_OK;

    if (!ppAttrCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppAttrCollection = NULL;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::insertBefore(IHTMLDOMNode *pNewChild, VARIANT refChild, IHTMLDOMNode **ppRetNode)
{
    return Markup()->Root()->insertBefore(pNewChild, refChild, ppRetNode);
}

HRESULT
CDocument::replaceChild(IHTMLDOMNode *pNewChild, IHTMLDOMNode *pOldChild, IHTMLDOMNode **ppRetNode)
{
    return Markup()->Root()->replaceChild(pNewChild, pOldChild, ppRetNode);
}

HRESULT
CDocument::removeChild(IHTMLDOMNode *pOldChild, IHTMLDOMNode **pRetNode)
{
    return Markup()->Root()->removeChild(pOldChild, pRetNode);
}

HRESULT
CDocument::cloneNode(VARIANT_BOOL fDeep, IHTMLDOMNode **ppNodeCloned)
{
    HRESULT         hr;
    CDoc *          pDoc = Doc();
    CMarkup *       pMarkupTarget = NULL;
    CDocument *     pDocument = NULL;

    *ppNodeCloned = NULL;
    hr = THR(pDoc->CreateMarkup(&pMarkupTarget, GetWindowedMarkupContext()));
    if (hr)
        goto Cleanup;
    
    hr = THR(pMarkupTarget->SetOrphanedMarkup(TRUE));
    if( hr )
        goto Cleanup;

    Assert(!pMarkupTarget->HasDocument());
    hr = THR(pMarkupTarget->EnsureDocument(&pDocument));
    if (hr)
        goto Cleanup;

    Assert(pDocument->_lnodeType == 9);
    pDocument->_lnodeType = 11; // document fragment

    if (fDeep)
    {
        CMarkupPointer mkptrStart ( pDoc );
        CMarkupPointer mkptrEnd ( pDoc );
        CMarkupPointer mkptrTarget ( pDoc );

        // Get src ptrs
        hr = THR(Markup()->Root()->GetMarkupPtrRange(&mkptrStart, &mkptrEnd));
        if (hr)
            goto Cleanup;

        // Get target ptr

        hr = THR(mkptrTarget.MoveToContainer(pMarkupTarget,TRUE));
        if (hr)
            goto Cleanup;

        // Copy src -> target
        hr = THR(pDocument->Doc()->Copy(&mkptrStart, &mkptrEnd, &mkptrTarget, MUS_DOMOPERATION));
        if (hr)
            goto Cleanup;
    }

    hr = THR(pDocument->QueryInterface(IID_IHTMLDOMNode, (void **)ppNodeCloned));
    if (hr)
        goto Cleanup;

Cleanup:

    // release extra markup lock
    if (pMarkupTarget)
        pMarkupTarget->Release();

    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::removeNode (VARIANT_BOOL fDeep, IHTMLDOMNode **ppNodeRemoved)
{
    HRESULT hr = E_NOTIMPL;
    if (ppNodeRemoved)
        *ppNodeRemoved = NULL;
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::replaceNode(IHTMLDOMNode *pNodeReplace, IHTMLDOMNode **ppNodeReplaced)
{
    HRESULT hr = E_NOTIMPL;
    if (ppNodeReplaced)
        *ppNodeReplaced = NULL;
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::swapNode(IHTMLDOMNode *pNodeSwap, IHTMLDOMNode **ppNodeSwapped)
{
    HRESULT hr = E_NOTIMPL;
    if (ppNodeSwapped)
        *ppNodeSwapped = NULL;
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::appendChild(IHTMLDOMNode *pNewChild, IHTMLDOMNode **ppRetNode)
{
    return Markup()->Root()->appendChild(pNewChild, ppRetNode);
}

HRESULT
CDocument::get_nodeName(BSTR *pbstrNodeName)
{
    HRESULT hr = S_OK;

    if (!pbstrNodeName)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrNodeName = NULL;
    
    if(_lnodeType == 9)
        hr = THR(FormsAllocString ( _T("#document"), pbstrNodeName ));
    else
    {
        Assert(_lnodeType == 11);
        hr = THR(FormsAllocString ( _T("#document-fragment"), pbstrNodeName ));
    }
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::get_nodeValue(VARIANT *pvarValue)
{
    HRESULT hr = S_OK;

    if (!pvarValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    pvarValue->vt = VT_NULL;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::put_nodeValue(VARIANT varValue)
{
    HRESULT hr = S_OK;

    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::get_firstChild ( IHTMLDOMNode **ppNode )
{
    return Markup()->Root()->get_firstChild(ppNode);
}

HRESULT
CDocument::get_lastChild ( IHTMLDOMNode **ppNode )
{
    return Markup()->Root()->get_lastChild(ppNode);
}

HRESULT
CDocument::get_previousSibling ( IHTMLDOMNode **ppNode )
{
    HRESULT hr = S_OK;

    if (!ppNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppNode = NULL;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::get_nextSibling ( IHTMLDOMNode **ppNode )
{
    HRESULT hr = S_OK;
    
    if (!ppNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppNode = NULL;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::get_ownerDocument(IDispatch **ppretdoc)
{
    HRESULT hr = S_OK;
    CMarkup *pMarkup;
    CDocument *pDocument;

    if( !ppretdoc )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppretdoc = NULL;

    if(_lnodeType == 11)
    {
        pMarkup = GetWindowedMarkupContext();
        Assert( pMarkup );        
        if(pMarkup->HasDocument())
        {
            Assert( pMarkup );
            pDocument = pMarkup->Document();
            Assert(pDocument);
            Assert(pDocument->_lnodeType == 9);
            hr = THR(pDocument->QueryInterface(IID_IDispatch, (void **)ppretdoc));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

// Methods for implemention IHTMLDocument5

HRESULT
CDocument::createAttribute(BSTR bstrAttrName, IHTMLDOMAttribute **ppAttribute)
{
    HRESULT hr = S_OK;
    CAttribute *pAttribute = NULL;

    if(!ppAttribute)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppAttribute = NULL;
    pAttribute = new CAttribute(NULL, DISPID_UNKNOWN, NULL, this);
    if (!pAttribute)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pAttribute->_cstrName.SetBSTR(bstrAttrName));
    if (hr)
        goto Cleanup;

    hr = THR(pAttribute->PrivateQueryInterface(IID_IHTMLDOMAttribute, (void **)ppAttribute));
    if (hr)
        goto Cleanup;

Cleanup:
    if (pAttribute)
        pAttribute->Release();

    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::getAttributeNode(BSTR bstrName, IHTMLDOMAttribute **ppAttribute)
{
    HRESULT hr;
    AAINDEX aaIdx = AA_IDX_UNKNOWN;
    CAttribute *pAttribute = NULL;
    DISPID dispid;
    PROPERTYDESC *pPropDesc;

    if (!ppAttribute)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!bstrName || !*bstrName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppAttribute = NULL;

    hr = THR(GetIndexHelper(bstrName, &aaIdx, NULL, &dispid, &pPropDesc, this, 0));
    if (DISP_E_UNKNOWNNAME == hr)
    {
        hr = S_OK;
        goto Cleanup;
    }

    if (aaIdx == AA_IDX_UNKNOWN)
    {
        // No Attr Node, create new
        pAttribute = new CAttribute(pPropDesc, dispid, this);
        if (!pAttribute)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pAttribute->_cstrName.SetBSTR(bstrName));
        if (hr)
            goto Cleanup;

        hr = THR(AddUnknownObject(dispid, (IUnknown *)(IPrivateUnknown *)pAttribute, CAttrValue::AA_DOMAttribute));
        if (hr)
            goto Cleanup;
    }
    else
    {
        IUnknown *pUnk;
        hr = THR(GetUnknownObjectAt(aaIdx, &pUnk));
        if (hr)
            goto Cleanup;

        pAttribute = (CAttribute *)pUnk;
    }

    Assert(pAttribute);
    hr = THR(pAttribute->QueryInterface(IID_IHTMLDOMAttribute, (void **)ppAttribute));
    if (hr)
        goto Cleanup;

Cleanup:
    if (pAttribute)
        pAttribute->Release();

    RRETURN(SetErrorInfo(hr));
}


HRESULT
CElement::setAttributeNode(IHTMLDOMAttribute *pAttrIn, IHTMLDOMAttribute **ppAttribute)
{
    HRESULT hr = S_OK;
    CAttribute *pAttribute;
    AAINDEX aaIdx;
    AAINDEX vaaIdx;
    DISPID dispid;
    PROPERTYDESC *pPropDesc = NULL;
    
    if (!ppAttribute)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!pAttrIn)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppAttribute = NULL;

    hr = THR(pAttrIn->QueryInterface(CLSID_CAttribute, (void **)&pAttribute));
    if (hr)
        goto Cleanup;

    if (pAttribute->_pElem)
    {
        // In use error.
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Assert((LPTSTR)(pAttribute->_cstrName));
    Assert(!pAttribute->_pElem);
    Assert(!pAttribute->_pPropDesc);
    Assert(pAttribute->_dispid == DISPID_UNKNOWN);

    hr = THR(RemoveAttrHelper(pAttribute->_cstrName, &pPropDesc, &dispid, &aaIdx, &vaaIdx, this, ppAttribute, fdexNameEnsure));
    if (hr)
        goto Cleanup;

    pAttribute->_pPropDesc = pPropDesc;
    pAttribute->_pElem = this;
    pAttribute->_dispid = dispid;
    SubAddRef();

    // Attr Node already exists?
    if (aaIdx == AA_IDX_UNKNOWN)
    {
        // No, set new one passed in
        hr = THR(AddUnknownObject(dispid, (IUnknown *)(IPrivateUnknown *)pAttribute, CAttrValue::AA_DOMAttribute));
        if (hr)
            goto Cleanup;

        if (!pPropDesc)
        {
            hr = THR(UpdateDomAttrCollection(FALSE, dispid));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        // Yes, replace it with passed in attr node
        CAttrArray *pAA = *GetAttrArray();
        VARIANT var;
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = (IUnknown *)(IPrivateUnknown *)pAttribute;
        Assert(pAA);
        hr = THR(pAA->SetAt(aaIdx, &var));
        if (hr)
            goto Cleanup;
    }
    
    // Need to set the new value now..

    if (!pAttribute->_varValue.IsEmpty())
    {
        hr = THR(PutNodeValueHelper(pAttribute, vaaIdx, pAttribute->_varValue));
        if (hr)
            goto Cleanup;

        hr = THR(pAttribute->_varValue.Clear());
        if (hr)
            goto Cleanup;
    }
    else
    {
        // Passed in Attr node doesn't have a value set yet
        if (vaaIdx != AA_IDX_UNKNOWN)
        {
            // But there is an existing value for this attr name, remove it.
            DeleteAt(vaaIdx);
        }

        // set default value of expando node to "undefined"
        if (!pPropDesc)
        {
            CVariant var; // initialized to VT_EMPTY to return undefined

            hr = THR(AddVariant(dispid, &var, CAttrValue::AA_Expando));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::removeAttributeNode(IHTMLDOMAttribute *pAttrRemove, IHTMLDOMAttribute **ppAttribute)
{
    HRESULT hr = S_OK;
    CAttribute *pAttribute;
    
    if (!ppAttribute)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppAttribute = NULL;

    if(!pAttrRemove)
        goto Cleanup;

    hr = THR(pAttrRemove->QueryInterface(CLSID_CAttribute, (void **)&pAttribute));
    if (hr)
        goto Cleanup;

    hr = THR(RemoveAttributeNode(pAttribute->_cstrName, ppAttribute));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::RemoveAttributeNode(LPTSTR pchAttrName, IHTMLDOMAttribute **ppAttribute)
{
    HRESULT hr = S_OK;
    BOOL fUpdateDOMAttrColl = FALSE;
    CAttribute *pAttrNew = NULL;
    AAINDEX aaIdx;
    AAINDEX vaaIdx;
    DISPID dispid;
    PROPERTYDESC *pPropDesc;

    hr = THR(RemoveAttrHelper(pchAttrName, &pPropDesc, &dispid, &aaIdx, &vaaIdx, this, ppAttribute, 0));
    if (hr)
        goto Cleanup;

    // remove attrNode from this element's AA if it exists
    if (aaIdx != AA_IDX_UNKNOWN)
    {
        DeleteAt(aaIdx);
        fUpdateDOMAttrColl = TRUE;
    }

    if (vaaIdx != AA_IDX_UNKNOWN)
    {
        // There is an existing value for this attr name, remove it.
        DeleteAt(vaaIdx);
        fUpdateDOMAttrColl = TRUE;
    }

    if (pPropDesc)
    {
        // All non-expando attrs have a default value so replace removed node with new one.
        Assert(!IsExpandoDISPID(dispid));

        pAttrNew = new CAttribute(pPropDesc, dispid, this);
        if (!pAttrNew)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pAttrNew->_cstrName.Set(pchAttrName));
        if (hr)
            goto Cleanup;

        hr = THR(AddUnknownObject(dispid, (IUnknown *)(IPrivateUnknown *)pAttrNew, CAttrValue::AA_DOMAttribute));
        if (hr)
            goto Cleanup;
    }
    else if (fUpdateDOMAttrColl)
    {
        Assert(!pPropDesc);
        hr = THR(UpdateDomAttrCollection(TRUE, dispid));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    if (pAttrNew)
        pAttrNew->Release();

    RRETURN(hr);
}

HRESULT
CDocument::createComment(BSTR data, IHTMLDOMNode **ppRetNode)
{
    HRESULT hr = S_OK;
    CCommentElement *pelComment = NULL;

    if(!ppRetNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pelComment = new CCommentElement(ETAG_RAW_COMMENT, Doc());
    if(!pelComment)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pelComment->_fAtomic = TRUE;

    hr = THR(pelComment->_cstrText.Set(_T("<!--"), 4));
    if( hr )
        goto Cleanup;

    hr = THR(pelComment->_cstrText.Append(data));
    if( hr )
        goto Cleanup;
    
    hr = THR(pelComment->_cstrText.Append(_T("-->"), 3));
    if( hr )
        goto Cleanup;

    hr = THR(pelComment->SetWindowedMarkupContextPtr(GetWindowedMarkupContext()));
    if( hr )
        goto Cleanup;

    pelComment->GetWindowedMarkupContextPtr()->SubAddRef();

    hr = THR(pelComment->PrivateQueryInterface(IID_IHTMLDOMNode, (void **)ppRetNode));
    if( hr )
        goto Cleanup;

Cleanup:
    if(pelComment)
        pelComment->Release();

    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::get_doctype(IHTMLDOMNode **ppnode)
{
    HRESULT hr = S_OK;

    if(!ppnode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppnode = NULL;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::get_implementation(IHTMLDOMImplementation **ppimplementation)
{
    HRESULT hr = S_OK;
    CDoc *pDoc = Doc();
    CDOMImplementation **pdomimpl = &pDoc->_pdomImplementation;

    if(!ppimplementation)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if(!*pdomimpl)
    {
        *pdomimpl = new CDOMImplementation(pDoc);
        if(!*pdomimpl)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = THR((*pdomimpl)->QueryInterface(IID_IHTMLDOMImplementation, (void **)ppimplementation));
    if(hr)
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));

}


// DOMImplementation


const CBase::CLASSDESC CDOMImplementation::s_classdesc =
{
    &CLSID_HTMLDOMImplementation,   // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif                              // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLDOMImplementation,    // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

MtDefine(CDOMImplementation, Mem, "CDOMImplementation")

CDOMImplementation::CDOMImplementation(CDoc *pDoc)
{
    _pDoc = pDoc;
    _pDoc->SubAddRef();
}

void CDOMImplementation::Passivate()
{
    _pDoc->SubRelease();
    CBase::Passivate();
}

HRESULT
CDOMImplementation::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IHTMLDOMImplementation)
        QI_TEAROFF_DISPEX(this, NULL)
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *) *ppv)->AddRef();

    return S_OK;
}

HRESULT
CDOMImplementation::hasFeature(BSTR bstrFeature, VARIANT version, VARIANT_BOOL* pfHasFeature)
{
    HRESULT hr = S_OK;
    BSTR bstrVersion = NULL;

    if(!pfHasFeature)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *pfHasFeature = VB_FALSE;

    switch (V_VT(&version))
    {
    case VT_BSTR:
        bstrVersion = V_BSTR(&version);
        break;

    case VT_NULL:
    case VT_ERROR:
    case VT_EMPTY:
        break;

    default:
        hr = E_INVALIDARG;
        goto Cleanup;
    }   

    if(!_tcsicmp(bstrFeature, _T("HTML")))
    {
        if(bstrVersion && *bstrVersion)
        {
            if(!_tcsicmp(bstrVersion, _T("1.0")))
                *pfHasFeature = VB_TRUE;
        }
        else
            *pfHasFeature = VB_TRUE;

    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\elemdb.cxx ===
//+---------------------------------------------------------------------
//
//   File:      elemdb.cxx
//
//  Contents:   Element's databinding methods
//
//  Classes:    CElement
//
//------------------------------------------------------------------------


#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include <binder.hxx>
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include <olesite.hxx>
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_DMEMBMGR_HXX_
#define X_DMEMBMGR_HXX_
#include <dmembmgr.hxx>
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include <dbtask.hxx>
#endif

MtDefine(DBMEMBERS, DataBind, "DBMEMBERS")
MtDefine(DBMEMBERS_arydsb_pv, DBMEMBERS, "DBMEMBERS::_arydsb::_pv")
MtDefine(CDataBindingEvents, DataBind, "CDataBindingEvents")
MtDefine(CDataBindingEvents_aryXfer_pv, CDataBindingEvents, "CDataBindingEvents::_aryXfer::_pv")

#ifndef NO_DATABINDING
// binding method tables shared by multiple element types
const CDBindMethodsText DBindMethodsTextRichRO(DBIND_ONEWAY|DBIND_HTMLOK);
#endif

static inline LONG
StringLen(LPCTSTR str)
{
    return str ? _tcslen(str) : 0;
}


//+----------------------------------------------------------------------------
//
//  Function: (static helper)
//
//  Synopsis:   str1 and str2 are both strings of field names separated by dots.
//              Find the longest prefix of str2 that's also a suffix of str1.
//              Return a pointer to the "tail" - the part of str2 that sticks
//              out past the end of str1;  this must be non-trivial (at least
//              one field name).

static LPCTSTR
FindOverlapAndTail(LPCTSTR str1, LPCTSTR str2, TCHAR tchDelim=_T('.'))
{
    LONG lLength1 = StringLen(str1);
    LPCTSTR strTail = str2 + StringLen(str2);
    LONG lPrefixLength;

    if (strTail == NULL)
        return NULL;
    
    for (;;)
    {
        // find the next delimiter in str2 (right-to-left)
        while (--strTail >= str2)
        {
            if (*strTail == tchDelim)
                break;
        }

        if (strTail < str2)
            break;

        // compare suffix of str1 with prefix of str2
        lPrefixLength = (strTail - str2);
        if (lLength1 >= lPrefixLength &&
            0 == FormsStringNCmp(str1 + lLength1 - lPrefixLength, lPrefixLength,
                                 str2, lPrefixLength))
        {
            break;
        }
    }

    return strTail + 1;
}


//+----------------------------------------------------------------------------
//
//  Function: get_datafld
//
//  Synopsis: Object model entry point to fetch the datafld property.
//
//  Arguments:
//            [p]  - where to return BSTR containing the string
//
//  Returns:  S_OK                  - this element support such a property
//            DISP_E_MEMBERNOTFOUND - this element doesn't support this
//                                    property
//            E_OUTOFMEMORY         - memory allocation failure
//            E_POINTER             - NULL pointer to receive BSTR
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CElement::get_dataFld(BSTR * p)
{
#ifndef NO_DATABINDING
    HRESULT hr;

    if ( p )
        *p = NULL;

    // note that set-consumers don't support datafld or dataformatas
    if (CDBindMethods::FDataFldValid(this))
    {
        hr = s_propdescCElementdataFld.b.GetStringProperty(
                p,
                this,
                (CVoid *)(void *)(GetAttrArray()) );
    }
    else
    {
        // To allow for..in to work we need to return S_OK, but an empty BSTR
        hr = SetErrorInfoPGet(S_OK, DISPID_CElement_dataFld);
    }

        RRETURN(hr);
#else
        return DISP_E_MEMBERNOTFOUND;
#endif // ndef NO_DATABINDING
}

//+----------------------------------------------------------------------------
//
//  Function: put_datafld
//
//  Synopsis: Object model entry point to put the datafld property.
//
//  Arguments:
//            [v]  - BSTR containing the new property value
//
//  Returns:  S_OK                  - successful
//            DISP_E_MEMBERNOTFOUND - this element doesn't support this
//                                    property
//            E_OUTOFMEMORY         - memory allocation failure
//
//  Notes:    TODO: to support dynamic changes to binding properties,
//            additional code should be place here or in OnPropertyChange()
//            to rebind.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CElement::put_dataFld(BSTR v)
{
#ifndef NO_DATABINDING
    HRESULT hr;

    // note that set-consumers don't support datafld or dataformatas
    if (CDBindMethods::FDataFldValid(this))
    {
        DetachDataBinding(ID_DBIND_DEFAULT);

        hr = s_propdescCElementdataFld.b.SetStringProperty(
                v,
                this,
                (CVoid *)(void *)(GetAttrArray()) );

        AttachDataBindings();   // TODO: better to specify ID_DBIND_DEFAULT
        if (IsInMarkup())
        {
            GetMarkup()->TickleDataBinding();
        }
    }
    else
    {
        hr = SetErrorInfoPSet(DISP_E_MEMBERNOTFOUND, DISPID_CElement_dataFld);
    }
    RRETURN(hr);
#else
        return DISP_E_MEMBERNOTFOUND;
#endif // ndef NO_DATABINDING
}

//+----------------------------------------------------------------------------
//
//  Function: get_dataformatas
//
//  Synopsis: Object model entry point to fetch the dataformatas property.
//
//  Arguments:
//            [p]  - where to return BSTR containing the string
//
//  Returns:  S_OK                  - this element support such a property
//            DISP_E_MEMBERNOTFOUND - this element doesn't support this
//                                    property
//            E_OUTOFMEMORY         - memory allocation failure
//            E_POINTER             - NULL pointer to receive BSTR
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CElement::get_dataFormatAs(BSTR * p)
{
#ifndef NO_DATABINDING
    HRESULT hr;

    if ( p )
        *p = NULL;

    // note that set-consumers don't support datafld or dataformatas
    if (CDBindMethods::FDataFormatAsValid(this))
    {
        hr = s_propdescCElementdataFormatAs.b.GetStringProperty(
                p,
                this,
                (CVoid *)(void *)(GetAttrArray()) );
    }
    else
    {
        // To allow for..in to work we need to return S_OK, but an empty BSTR
        hr = SetErrorInfoPGet(S_OK, DISPID_CElement_dataFormatAs);
    }

    RRETURN(hr);
#else
        return DISP_E_MEMBERNOTFOUND;
#endif // ndef NO_DATABINDING
}

//+----------------------------------------------------------------------------
//
//  Function: put_dataformatas
//
//  Synopsis: Object model entry point to put the dataformatas property.
//
//  Arguments:
//            [v]  - BSTR containing the new property value
//
//  Returns:  S_OK                  - successful
//            DISP_E_MEMBERNOTFOUND - this element doesn't support this
//                                    property
//            E_OUTOFMEMORY         - memory allocation failure
//
//  Notes:    TODO: to support dynamic changes to binding properties,
//            additional code should be place here or in OnPropertyChange()
//            to rebind.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CElement::put_dataFormatAs(BSTR v)
{
#ifndef NO_DATABINDING
    HRESULT hr;

    // note that set-consumers don't support datafld or dataformatas
    if (CDBindMethods::FDataFormatAsValid(this))
    {
        DetachDataBinding(ID_DBIND_DEFAULT);

        hr = s_propdescCElementdataFormatAs.b.SetStringProperty(
                v,
                this,
                (CVoid *)(void *)(GetAttrArray()) );

        AttachDataBindings();   // TODO: better to specify ID_DBIND_DEFAULT
        if (IsInMarkup())
        {
            GetMarkup()->TickleDataBinding();
        }
    }
    else
    {
        hr = SetErrorInfoPSet(DISP_E_MEMBERNOTFOUND, DISPID_CElement_dataFormatAs);
    }

    RRETURN(hr);
#else
        return DISP_E_MEMBERNOTFOUND;
#endif // ndef NO_DATABINDING
}

//+----------------------------------------------------------------------------
//
//  Function: get_datasrc
//
//  Synopsis: Object model entry point to fetch the datasrc property.
//
//  Arguments:
//            [p]  - where to return BSTR containing the string
//
//  Returns:  S_OK                  - this element support such a property
//            DISP_E_MEMBERNOTFOUND - this element doesn't support this
//                                    property
//            E_OUTOFMEMORY         - memory allocation failure
//            E_POINTER             - NULL pointer to receive BSTR
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CElement::get_dataSrc(BSTR * p)
{
#ifndef NO_DATABINDING
    HRESULT hr;

    if ( p )
        *p = NULL;

    // note that set-consumers and single-value consumers both support datasrc
    if (CDBindMethods::FDataSrcValid(this))
    {
        hr = s_propdescCElementdataSrc.b.GetStringProperty(
                p,
                this,
                (CVoid *)(void *)(GetAttrArray()) );
    }
    else
    {
        // To allow for..in to work we need to return S_OK, but an empty BSTR
        hr = SetErrorInfoPGet(S_OK, DISPID_CElement_dataSrc);
    }

    RRETURN(hr);
#else
        return DISP_E_MEMBERNOTFOUND;
#endif // ndef NO_DATABINDING
}

//+----------------------------------------------------------------------------
//
//  Function: put_datasrc
//
//  Synopsis: Object model entry point to put the datasrc property.
//
//  Arguments:
//            [v]  - BSTR containing the new property value
//
//  Returns:  S_OK                  - successful
//            DISP_E_MEMBERNOTFOUND - this element doesn't support this
//                                    property
//            E_OUTOFMEMORY         - memory allocation failure
//
//  Notes:    TODO: to support dynamic changes to binding properties,
//            additional code should be place here or in OnPropertyChange()
//            to rebind.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CElement::put_dataSrc(BSTR v)
{
#ifndef NO_DATABINDING
    HRESULT hr;

    // note that set-consumers and single-value consumers both support datasrc
    if (CDBindMethods::FDataSrcValid(this))
    {
        DetachDataBinding(ID_DBIND_DEFAULT);

        hr = s_propdescCElementdataSrc.b.SetStringProperty(
                v,
                this,
                (CVoid *)(void *)(GetAttrArray()) );

        AttachDataBindings();   // TODO: better to specify ID_DBIND_DEFAULT
        if (IsInMarkup())
        {
            GetMarkup()->TickleDataBinding();
        }
    }
    else
    {
        hr = SetErrorInfoPSet(DISP_E_MEMBERNOTFOUND, DISPID_CElement_dataSrc);
    }

    RRETURN(hr);
#else
        return DISP_E_MEMBERNOTFOUND;
#endif // ndef NO_DATABINDING
}

//+----------------------------------------------------------------------------
//
//  Function: FFilter
//
//  Synopsis: Determine if a given DBSPEC binding specification is consistent
//            with the rules for describing given type or types of bindings.
//
//  Arguments:
//            [dwFilter] - Some combination of at least one of
//                          DBIND_SETFILTER
//                          DBIND_CURRENTFILTER
//                          DBIND_TABLEFILTER
//            fHackyHierarchicalTableFlag - set to TRUE in calls on behalf of
//                          a TABLE.  To support hierarchy, TABLEs match
//                          dataSrc + dataFld to SETFILTER, not to CURRENTFILTER.
//
//  Returns:  TRUE - DBSPEC matches desired pattern
//            FALSE - DBSPEC doesn't match pattern
//
//-----------------------------------------------------------------------------
BOOL
DBSPEC::FFilter(DWORD dwFilter, BOOL fHackyHierarchicalTableFlag)
{
    BOOL fRet = FALSE;

    Assert(dwFilter & DBIND_ALLFILTER); // should specify at least one bit

    if (FormsIsEmptyString(_pStrDataFld))
    {
        if (!FormsIsEmptyString(_pStrDataSrc) && (dwFilter & DBIND_SETFILTER))
        {
            fRet = TRUE;
        }
    }
    else if (!FormsIsEmptyString(_pStrDataSrc))
    {
        if ((fHackyHierarchicalTableFlag && dwFilter & DBIND_SETFILTER) ||
            (!fHackyHierarchicalTableFlag && dwFilter & DBIND_CURRENTFILTER))
        {
            fRet = TRUE;
        }
    }
    else if (dwFilter & DBIND_TABLEFILTER)
    {
        fRet = TRUE;
    }

    return fRet;
}

//+----------------------------------------------------------------------------
//
//  Function: FHTML
//
//  Synopsis: Determine if a given DBSPEC binding specifies HTML-based
//            Transfer.  Note that this method does NOT consider whether
//            or the bound element actually supports such transfer..
//
//  Returns:  TRUE - HTML binding specified
//            FALSE - HTML binding not specified
//
//-----------------------------------------------------------------------------
BOOL
DBSPEC::FHTML()
{
    return (!FormsIsEmptyString(_pStrDataFormatAs) && StrCmpIC(_pStrDataFormatAs, _T("html")) == 0);
}

//+----------------------------------------------------------------------------
//
//  Function: FLocalized
//
//  Synopsis: Determine if a given DBSPEC binding specifies localized-text
//            transfer.  Note that this method does NOT consider whether
//            or the bound element actually supports such transfer..
//
//  Returns:  TRUE - localized binding specified
//            FALSE - localized binding not specified
//
//-----------------------------------------------------------------------------
BOOL
DBSPEC::FLocalized()
{
    return (!FormsIsEmptyString(_pStrDataFormatAs) && StrCmpIC(_pStrDataFormatAs, _T("localized-text")) == 0);
}


//+----------------------------------------------------------------------------
//
//  Function: GetNextDBSpec, static
//
//  Synopsis: Enumerate next specified binding on a given element, whether or
//            not it is sensible.
//
//  Arguments:
//            [pElement] - element which is subject of this inquiry
//            [pid]      - in/out parameter; on input, contains last enumerated
//                         id, or id after which to start earch
//            [pdbs]     - output: where to put the specification
//            [dwFilter] - restrictions on search.  Some combination of at
//                         least one of
//                             DBIND_SETFILTER
//                             DBIND_CURRENTFILTER
//                             DBIND_TABLEFILTER
//                         optionally plus
//                             DBIND_ONEIDFILTER.
//                         This last flag indicates where only interested in
//                         id which is the input *pid+1.  This flag is a hack
//                         to allow trivial implementation of GetDBSpec.
//
//  Returns:  S_OK    - binding spec found matching input restrictions; *pid
//                      filled in with binding id, *pdbs filled in with binding
//                      spec.
//            S_FALSE - no matching binding spec found.  *pid undisturbed.
//                      *pdbs may have been trashed.
//
//-----------------------------------------------------------------------------
HRESULT
CDBindMethods::GetNextDBSpec(CElement *pElem,
                            LONG *pid,
                            DBSPEC *pdbs,
                            DWORD dwFilter)
{
    HRESULT hr = S_FALSE;
#ifndef NO_DATABINDING
    LONG id = *pid;
    const CDBindMethods *pDBindMethods;

    Assert(dwFilter & DBIND_ALLFILTER); // at least one bit set?

    if (id == ID_DBIND_STARTLOOP)
    {
        id = ID_DBIND_DEFAULT;

        pdbs->_pStrDataFld = pElem->GetAAdataFld();
        pdbs->_pStrDataSrc = pElem->GetAAdataSrc();
        pdbs->_pStrDataFormatAs = pElem->GetAAdataFormatAs();

        if (pdbs->FFilter(dwFilter, pElem->Tag()==ETAG_TABLE))
        {
            hr = S_OK;
            goto Cleanup;
        }

        if (dwFilter & DBIND_ONEIDFILTER)
            goto Cleanup;
    }

    pDBindMethods = pElem->GetDBindMethods();

    if (pDBindMethods)
    {
        for (;;)
        {
            BOOL fFilter;

            if (pDBindMethods->GetNextDBSpecCustom(pElem, &id, pdbs))
                goto Cleanup;

            fFilter = pdbs->FFilter(dwFilter, pElem->Tag()==ETAG_TABLE);

            if (dwFilter & DBIND_ONEIDFILTER)   // only one value acceptable
            {
                if (fFilter && id == *pid + 1)
                {
                    hr = S_OK;
                }

                goto Cleanup;
            }

            if (fFilter)
            {
                hr = S_OK;
                goto Cleanup;
            }
        }
    }

Cleanup:
    if (!hr)
    {
        *pid = id;
    }
#endif // ndef NO_DATABINDING

    RRETURN1(hr, S_FALSE);
}



#ifndef NO_DATABINDING
//+-------------------------------------------------------------------------
// Member:      Get Binder (public)
//
// Returns:     my DataSourceBinder (or NULL, if none)

CDataSourceBinder *
DBMEMBERS::GetBinder(LONG id)
{
    CDataSourceBinder * pdsb = NULL;
    CDataSourceBinder ** ppdsb;
    int    i;

    Assert(id != ID_DBIND_ALL);

    for (i = _arydsb.Size(), ppdsb = _arydsb;
         i > 0;
         i--, ppdsb++)
    {
        if ((*ppdsb)->IdConsumer() == id)
        {
            pdsb = *ppdsb;
            break;
        }
    }

    return pdsb;
}


//+-------------------------------------------------------------------------
// Member:      MarkReadyToBind (public)
//
// Synopsis:    Mark all my binders "ready to bind"

void
DBMEMBERS::MarkReadyToBind()
{
    CDataSourceBinder **ppdsb;
    int i;

    for (i = _arydsb.Size(), ppdsb = _arydsb;
         i > 0;
         --i, ++ppdsb)
    {
        (*ppdsb)->SetReady(TRUE);
    }
}


//+-------------------------------------------------------------------------
// Member:      Ensure DataMemberManager (public)
//
// Synopsis:    Allocate a CDataMemberMgr, if not done already
//
// Arguments:   none
//
// Returns:     HRESULT

HRESULT
DBMEMBERS::EnsureDataMemberManager(CElement *pElement)
{
    HRESULT hr = S_OK;

    if (!_pDMembMgr)
    {
        hr = CDataMemberMgr::Create(pElement, &_pDMembMgr);

        pElement->Doc()->_fBroadcastStop = TRUE;
    }

    return(hr);
}


//+-------------------------------------------------------------------------
// Member:      Release DataMemberManager (public)
//
// Synopsis:    Deallocate the CDataMemberMgr, if not done already

void
DBMEMBERS::ReleaseDataMemberManager(CElement *pElement)
{
    if (_pDMembMgr)
    {
        // remove any pending requests attached to a data source object.
        // Note - don't call CDoc::GetDataBindTask(), because that creates
        // the dbtask if it doesn't exist.
        CDataBindTask *pDBTask = _pDMembMgr->GetOwner()->IsInMarkup()
                                    ? _pDMembMgr->GetOwner()->GetMarkup()->GetDBTask()
                                    : NULL;
        if (pDBTask)
        {
            pDBTask->RemoveDataEventRequestsFor(pElement);
        }

        _pDMembMgr->Detach();
        _pDMembMgr->Release();
        _pDMembMgr = NULL;
    }
}


//+-------------------------------------------------------------------------
// Member:      Ensure DBMembers (private)
//
// Synopsis:    Allocate a DBMEMBERS struct, if not done already
//
// Arguments:   none
//
// Returns:     HRESULT

HRESULT
CElement::EnsureDBMembers()
{
    if (HasDataBindPtr())
    {
        return(S_OK);
    }

    DBMEMBERS * pdbm = new DBMEMBERS;

    if (!pdbm)
    {
        return(E_OUTOFMEMORY);
    }

    HRESULT hr = SetDataBindPtr(pdbm);

    if (hr)
    {
        delete pdbm;
    }

    return(hr);
}


//+-------------------------------------------------------------------------
// Member:      Ensure DataMemberManager (public)
//
// Synopsis:    Allocate a CDataMemberMgr, if not done already
//
// Arguments:   none
//
// Returns:     HRESULT

HRESULT
CElement::EnsureDataMemberManager()
{
    HRESULT hr = EnsureDBMembers();

    if (!hr)
    {
        hr = GetDBMembers()->EnsureDataMemberManager(this);
    }

    return(hr);
}


//+-------------------------------------------------------------------------
// Member:      Get DataMemberManager (public)
//
// Synopsis:    Return my datamember manager
//
// Arguments:   none
//
// Returns:     HRESULT

CDataMemberMgr *
CElement::GetDataMemberManager()
{
    CDataMemberMgr *pdmm;

    if (HasDataBindPtr())
    {
        pdmm = GetDBMembers()->GetDataMemberManager();
    }
    else
    {
        pdmm = NULL;
    }
    
    return pdmm;
}


//+-------------------------------------------------------------------------
// Member:      IsDataProvider (public)
//
// Synopsis:    Decide whether I'm a data provider

BOOL
CElement::IsDataProvider()
{
    CDataMemberMgr *pdmm;
    
    EnsureDataMemberManager();
    pdmm = GetDataMemberManager();

    return pdmm && pdmm->IsDataProvider();
}


//+-------------------------------------------------------------------------
// Member:      CreateDatabindRequest (public)
//
// Synopsis:    Create a request to hookup my databinding, and register it
//              with the databinding task
//
// Arguments:   id      id of the binding
//              pdbs    DBSPEC for the binding
//
// Returns:     HRESULT

HRESULT
CElement::CreateDatabindRequest(LONG id, DBSPEC *pdbs /* NULL */)
{
    HRESULT hr = S_OK;
    DBMEMBERS *pdbm;
    DBSPEC dbs;

    // get the DBSPEC, if not already provided
    if (pdbs == NULL)
    {
        pdbs = &dbs;
        hr = CDBindMethods::GetDBSpec(this, id, pdbs);
        if (hr)
            goto Cleanup;
    }
    
    // we need DBMEMBERS allocated, so that we can hook things up.
    hr = EnsureDBMembers();
    if (hr)
        goto Cleanup;

    pdbm = GetDBMembers();

    if (!pdbm->GetBinder(id))
    {
        CDataSourceBinder *pdsbBinder;

        // get a binder object
        pdsbBinder = new CDataSourceBinder(this, id);
        if (!pdsbBinder)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // save it in my DBMEMBERS
        hr = pdbm->SetBinder(pdsbBinder);
        if (hr)
        {
            pdsbBinder->Passivate();
            goto Cleanup;
        }

        // tell binder to register itself with the databinding task
        pdsbBinder->SetReady(CDBindMethods::IsReadyToBind(this));
        hr = pdsbBinder->Register(pdbs);
        if (hr)
        {
            DetachDataBinding(id);
            goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     AttachDataBindings, public
//
//  Synopsis:   Make sure that all binders needed are present for the given
//              element.  (Note this doesn't actually handle state of
//              the CDataBindingEvents; other calls must be made to get
//              this set up.)
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CElement::AttachDataBindings()
{
    HRESULT hrRet = S_OK;
    HRESULT hr = S_OK;
    LONG id;
    DBSPEC dbs;
    CElement *pElementOuter, *pElementRepeat;
    LPCTSTR strTail;   

    // don't databind in design mode or outside the main tree
    if (    Tag() == ETAG_ROOT // Input optimization
        ||  IsDesignMode()
        || !IsConnectedToPrimaryWindow() 
        || !CDBindMethods::IsReadyToBind(this))
        goto Cleanup;

    // note post-operation of for-loop; hrRet is set to first error
    for (id = ID_DBIND_STARTLOOP;
         !CDBindMethods::GetNextDBSpec(this, &id, &dbs, DBIND_ALLFILTER);
         !hrRet && (hrRet = hr) != 0)
    {
        // see if I'm current-record or table-bound
        hr = FindDatabindContext(dbs._pStrDataSrc, dbs._pStrDataFld,
                                &pElementOuter, &pElementRepeat, &strTail);

        // I'm table-bound, but table isn't expanding yet (I'm in a template).
        // Ignore for now.  Wait until table expands
        if (hr == S_FALSE)
        {
            hr = S_OK;
            continue;
        }

        // something bad happened.  Punt.
        if (hr)
            continue;
        
        // table-bound - ask the table to hook me up
        if (pElementOuter)
        {
            CTable *pTable = DYNCAST(CTable, pElementOuter);
            CTableRow *pRow = DYNCAST(CTableRow, pElementRepeat);

            hr = pTable->AddDataboundElement(this, id, pRow, strTail);
        }

        // current-record-bound - ask the databind task to hook me up
        else
        {
            hr = CreateDatabindRequest(id, &dbs);
        }
    }

Cleanup:
    RRETURN(hrRet);
}

//+---------------------------------------------------------------------------
//
//  Member:     DetachDataBindings, public
//
//  Synopsis:   Let go of all of my databinding data, if any
//
//  Returns:    nothing
//
//----------------------------------------------------------------------------

void
CElement::DetachDataBindings()
{
    DBMEMBERS *pdbm = GetDataBindPtr();

    if (pdbm != NULL)
    {
        int i;

        pdbm->DetachBinding(this, ID_DBIND_ALL);

        // this loop is a little different from the standard FormsAry loop.
        //  It keeps i and ppsdb consistent in the body of the loop.
        //  It also keeps deletions at the end of the array, minimizing
        //  useless copying, and keeping the deletions from interfering with
        //  the loop.
        for (i = pdbm->_arydsb.Size(); i-- > 0; )
        {
            if (pdbm->_arydsb[i])
            {
                (pdbm->_arydsb[i])->Passivate();
            }
            pdbm->_arydsb.Delete(i);
        }

        pdbm->ReleaseDataMemberManager(this);

        delete pdbm;

        // Can't use this call above because the detach code expects to
        // be able to call GetDataBindPtr() and find it.

        DelDataBindPtr();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     DetachDataBinding, public
//
//  Synopsis:   Let go of all databinding state, if any, for one binding id
//
//  Returns:    nothing
//
//----------------------------------------------------------------------------

void
CElement::DetachDataBinding(LONG id)
{
    DBMEMBERS *pdbm = GetDBMembers();

    Assert(id != ID_DBIND_ALL);

    if (pdbm != NULL)
    {
        CDataSourceBinder *pdsb = pdbm->GetBinder(id);

        // Call DetachBinding before pdsb->Passivate, so that the
        // element's bound value is replaced with a null-equivalent
        pdbm->DetachBinding(this, id);

        if (pdsb)
        {
            pdsb->Passivate();
            pdbm->_arydsb.DeleteByValue(pdsb);
        }
    }
}


//+------------------------------------------------------------------------
//
//  Member:     FindDatabindContext, public
//
//  Synopsis:   find the enclosing repeated element with matching dataSrc
//              and dataFld attributes
//
//  Arguments:  strDataSrc  look for an element with this dataSrc attribute
//              strDataFld     ... and this dataFld attribute
//              ppElementOuter   container element (NULL, if I'm current-row bound)
//              ppElementRepeat  instance of repeating that contains me
//              pstrTail    tail of strDataFld, after stripping away prefix
//                          that matches the container [return]
//
//  Returns:    S_OK        found it, or I'm bound to current record
//              S_FALSE     found a syntactically enclosing element, but it's not
//                          repeating, *ppInstance will be NULL

HRESULT
CElement::FindDatabindContext(LPCTSTR strDataSrc, LPCTSTR strDataFld,
                            CElement **ppElementOuter, CElement **ppElementRepeat,
                            LPCTSTR *pstrTail)
{
    HRESULT hr = S_OK;
    CTreeNode *pNodeRow;
    CTreeNode *pNodeOuter = NULL;
    CTable *pTableOuter = NULL;
    DBSPEC dbsOuter;
    LPCTSTR strTail = NULL;

    *ppElementOuter = NULL;
    *ppElementRepeat = NULL;
    
    // search up the tree for a row in a table with the right spec
    for (   pNodeRow = GetFirstBranch()->Ancestor(ETAG_TR);
            pNodeRow;
            pNodeRow = pNodeOuter->Ancestor(ETAG_TR) )
    {
        pNodeOuter = pNodeRow->Ancestor(ETAG_TABLE);
        Assert(pNodeOuter && "TableRow not enclosed in Table");

        pTableOuter = DYNCAST(CTable, pNodeOuter->Element());

        // if outer table isn't bound, keep looking
        if (S_OK != CDBindMethods::GetDBSpec(pTableOuter, ID_DBIND_DEFAULT, &dbsOuter))
            continue;

        // if datasource attributes don't match, keep looking
        if (!FormsIsEmptyString(strDataSrc) &&
            FormsStringCmp(strDataSrc, pTableOuter->GetDataSrc()) != 0)
            continue;

        // if I'm not in the repeating part of the table, keep looking
        if (pNodeRow->Parent()->Tag() != ETAG_TBODY)
            continue;

        // if it's not repeating yet, I'm in a template - there's no instance
        if (!pTableOuter->IsRepeating())
        {
            *ppElementOuter = pTableOuter;
            hr = S_FALSE;
            goto Cleanup;
        }

        // if datafield attributes don't match, keep looking
        strTail = FindOverlapAndTail(pTableOuter->GetDataFld(), strDataFld);
        if (!pTableOuter->IsFieldKnown(strTail))
            continue;

        // I'm a table-bound element
        *ppElementOuter = pTableOuter;
        *ppElementRepeat = DYNCAST(CTableRow, pNodeRow->Element());
        goto Cleanup;
    }

    // if we fall out of the loop, I must be a current-row bound element
    strTail = strDataFld;
    
Cleanup:
    if (pstrTail)
        *pstrTail = strTail;
    RRETURN1(hr, S_FALSE);
}
#endif // ndef NO_DATABINDING


//+---------------------------------------------------------------------------
//
//  Member:     CElement::getRecordNumber
//
//  Synopsis:   returns the record number of this element if it's in a
//              databound table; otherwise returns -1
//
//----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CElement::get_recordNumber(VARIANT *retval)
{
    V_VT(retval) = VT_NULL;

    CTreeNode * pNode = GetFirstBranch();
    while (pNode)
    {
        CTreeNode * pNodeRow = NULL;

        while (!pNodeRow && pNode)
        {
            if (pNode->Tag() == ETAG_TR)
                pNodeRow = pNode;
            else
                pNode = pNode->Parent();
        }

        if (pNodeRow)
        {
            CTableLayout *pTableLayout = NULL;

            do
            {
                pNode = pNode->Parent();
                if (pNode && (pNode->Tag() == ETAG_TABLE))
                    pTableLayout = DYNCAST(CTable, pNode->Element())->TableLayoutCache();
            }
            while (!pTableLayout && pNode);

            if (!pTableLayout)
                goto Cleanup;       // TODO: Handle this better.  This case is valid through the DOM

            Assert(pTableLayout);

#ifndef NO_DATABINDING
            if (pTableLayout->IsRepeating())
            {
                int iRow = DYNCAST(CTableRowLayout, pNodeRow->GetUpdatedLayout())->RowPosition();
                if (pTableLayout->IsGenerated(iRow))
                {
                    V_VT(retval) = VT_I4;
                    V_I4(retval) = pTableLayout->RowIndex2RecordNumber(iRow);
                    break;
                }
            }
#endif
        }
    }
Cleanup:
    RRETURN(SetErrorInfo(S_OK));
}

#ifndef NO_DATABINDING
//+----------------------------------------------------------------------------
//
//  Class CDBindMethods
//
//-----------------------------------------------------------------------------


//+----------------------------------------------------------------------------
//
//  Function: FDataSrcValid, static
//
//  Synopsis: Indicates whether or not the object model for the given element
//            should datasrc as a valid property.
//
//-----------------------------------------------------------------------------
BOOL
CDBindMethods::FDataSrcValid(CElement *pElem)
{
    const CDBindMethods *pDBindMethods = pElem->GetDBindMethods();

    return (pDBindMethods && pDBindMethods->FDataSrcValidImpl(pElem));
}

//+----------------------------------------------------------------------------
//
//  Function: FDataSrcValidImpl, virtual (default implementation)
//
//  Synopsis: Indicates whether or not the object model for the given element
//            should datasrc as a valid property.
//
//-----------------------------------------------------------------------------
BOOL
CDBindMethods::FDataSrcValidImpl(CElement *pElem) const
{
    return (DBindKind(pElem, ID_DBIND_DEFAULT) != DBIND_NONE);
}

//+----------------------------------------------------------------------------
//
//  Function: FDataFldValid, static
//
//  Synopsis: Indicates whether or not the object model for the given element
//            should datafld as a valid property.
//
//-----------------------------------------------------------------------------
BOOL
CDBindMethods::FDataFldValid(CElement *pElem)
{
    const CDBindMethods *pDBindMethods = pElem->GetDBindMethods();

    return (pDBindMethods && pDBindMethods->FDataFldValidImpl(pElem));
}

//+----------------------------------------------------------------------------
//
//  Function: FDataFldValidImpl, virtual (default implementation)
//
//  Synopsis: Indicates whether or not the object model for the given element
//            should datasrc as a valid property.
//
//-----------------------------------------------------------------------------
BOOL
CDBindMethods::FDataFldValidImpl(CElement *pElem) const
{
    DBIND_KIND dbk = DBindKind(pElem, ID_DBIND_DEFAULT);
    return (dbk == DBIND_SINGLEVALUE) || (dbk == DBIND_TABLE);
}

//+----------------------------------------------------------------------------
//
//  Function: FDataFormatAsValid, static
//
//  Synopsis: Indicates whether or not the object model for the given element
//            should dataformatas as a valid property.
//
//-----------------------------------------------------------------------------
BOOL
CDBindMethods::FDataFormatAsValid(CElement *pElem)
{
    const CDBindMethods *pDBindMethods = pElem->GetDBindMethods();

    return (pDBindMethods && pDBindMethods->FDataFormatAsImpl());
}

//+----------------------------------------------------------------------------
//
//  Function: DBindKind, static
//
//  Synopsis: Indicate whether or not <element, id> can be databound, and
//            optionally return additional info about binding.
//
//            Wraps calls to CDBindMethods::DBindKindImpl, and handles
//            initialization of any non-NULL pdbi passed in.
//
//  Arguments:
//            [pElem] - element whose binding status/ability is being queried
//            [id]    - id of binding specification for which info is desired
//            [pdbi]  - pointer to struct to get data type and ID;
//                      may be NULL
//
//  Returns:  Binding status: one of
//              DBIND_NONE
//              DBIND_SINGLEVALUE
//              DBIND_ICURSOR
//              DBIND_IROWSET
//              DBIND_TABLE
//              DBIND_IDATASOURCE
//            For base CElement, always returns DBIND_NONE
//
//-----------------------------------------------------------------------------
DBIND_KIND
CDBindMethods::DBindKind(CElement *pElem, LONG id, DBINFO *pdbi)
{
    DBIND_KIND dbk = DBIND_NONE;
    const CDBindMethods *pDBindMethods;

    if (pdbi)
    {
        pdbi->_vt = VT_EMPTY;
        pdbi->_dwTransfer = DBIND_ONEWAY; // one-way, no HTML
    }

    pDBindMethods = pElem->GetDBindMethods();

    if (pDBindMethods)
    {
        dbk = pDBindMethods->DBindKindImpl(pElem, id, pdbi);
    }

    return dbk;
}

//+----------------------------------------------------------------------------
//
//  Function: IsReadyToBind, static
//
//  Synopsis: Indicate whether the element is ready to be bound.  Most elements
//              are, except for OBJECT/APPLET (depends on readystate) and TABLE
//              (have to see the </TABLE>, so we have all the template rows).
//
//            Wraps calls to CDBindMethods::IsReadyImpl.
//
//  Arguments:
//            [pElem] - element whose binding readiness is being queried
//-----------------------------------------------------------------------------
BOOL
CDBindMethods::IsReadyToBind(CElement *pElem)
{
    BOOL fIsReady = FALSE;
    const CDBindMethods *pDBindMethods;

    pDBindMethods = pElem->GetDBindMethods();

    if (pDBindMethods)
    {
        fIsReady = pDBindMethods->IsReadyImpl(pElem);
    }

    return fIsReady;
}

//+----------------------------------------------------------------------------
//
//  Class CDBindMethodsSimple:  support for simple controls with single binding
//
//-----------------------------------------------------------------------------


//+----------------------------------------------------------------------------
//
//  Function: DBindKindImpl, CDBindMethodsSimple
//
//  Synopsis: Simple elements with only a single binding respond to DBindKind in
//              more or less the same way.  Handled here.
//  Arguments:
//            [pdbi]  - pointer to struct to get data type and ID;
//                      may be NULL.  If not NULL, has already been pre-
//                      initialized to state appropriate for DBIND_NONE.
//
//
//  Returns:  as in DBindKind
//
//-----------------------------------------------------------------------------
DBIND_KIND
CDBindMethodsSimple::DBindKindImpl(CElement *pElem,
                                   LONG id,
                                   DBINFO *pdbi) const
{
    DBIND_KIND dbk = DBIND_NONE;

    if (id == ID_DBIND_DEFAULT)
    {
        dbk = DBIND_SINGLEVALUE;

        if (pdbi)
        {
            pdbi->_vt = _vt;
            pdbi->_dwTransfer = _dwTransfer;
        }
    }

    return dbk;
}


//+----------------------------------------------------------------------------
//
//  Function: BoundValueFromElement, CDBindMethods
//
//  Synopsis: For the convenience of classes which support only 1-way bindings,
//            we provide a base implementation of BoundValueFromElement, which
//            satisfies compiler but should never be called.
//
//-----------------------------------------------------------------------------
HRESULT
CDBindMethodsSimple::BoundValueFromElement(CElement *,
                                         LONG,
                                         BOOL,
                                         LPVOID) const
{
    Assert(FALSE);
    return E_UNEXPECTED;
}

//+----------------------------------------------------------------------------
//
//  Class CDBindMethodsText: for elements which use the text code to get and
//  set strings.
//
//-----------------------------------------------------------------------------


//+----------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: Default implemenation for transferring bound data to element.
//            Note that this won't be called unless some implementation of
//            BindStatus indicated a binding was present.  Assumes that we
//            are working with a textual element.
//
//  Arguments:
//            [pElem]   - destination element of transfer
//            [id]      - ID of binding point.  For the text-based
//                        must be ID_DBIND_DEFAULT.
//            [fHTML]   - whether text should be interpret as HTML
//            [pvData]  - pointer to data to transfer, in the expected data
//                        type.  For text-based transfers, must be BSTR.
//
//-----------------------------------------------------------------------------

HRESULT
CDBindMethodsText::BoundValueToElement ( CElement *pElem,
                                         LONG id,
                                         BOOL fHTML,
                                         LPVOID pvData ) const
{
    BSTR *  pBstr = (BSTR *) pvData;

    Assert( pBstr );

#if DBG==1
    {
        DBINFO dbi;

        Assert( id == ID_DBIND_DEFAULT );
        Assert( DBindKind( pElem, id, & dbi ) > DBIND_NONE );
        Assert( dbi._vt == VT_BSTR );
    }
#endif // DBG == 1

    RRETURN(
        THR(
            pElem->Inject(
                CElement::Inside, fHTML,
                *pBstr, FormsStringLen( * pBstr ) ) ) );
}



HRESULT
CDBindMethodsText::BoundValueFromElement(CElement *pElem,
                                         LONG id,
                                         BOOL fHTML,
                                         LPVOID pvData) const
{
    BSTR       *pBstr = (BSTR *) pvData;

    Assert(pBstr);
    // shouldn't be called for one-way bindings
    Assert((_dwTransfer & DBIND_ONEWAY) == 0);

#if DBG==1
    {
        DBINFO dbi;

        Assert(id == ID_DBIND_DEFAULT);
        Assert(DBindKind(pElem, id, &dbi) > DBIND_NONE);
        Assert(dbi._vt == VT_BSTR);
    }
#endif // DBG == 1

    RRETURN(pElem->GetBstrFromElement(fHTML, pBstr));
}

#endif // ndef NO_DATABINDING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\element3.cxx ===
//+---------------------------------------------------------------------
//
//   File:      element3.cxx
//
//  Contents:   Element class related member functions
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif


#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_FILTCOL_HXX_
#define X_FILTCOL_HXX_
#include "filtcol.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_OBJSAFE_H_
#define X_OBJSAFE_H_
#include "objsafe.h"
#endif

#ifndef X_IEXTAG_HXX_
#define X_IEXTAG_HXX_
#include "iextag.h"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X__IME_H_
#define X__IME_H_
#include "_ime.h"
#endif

#ifndef X_CTLRANGE_HXX_
#define X_CTLRANGE_HXX_
#include "ctlrange.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_SCROLLBARCONTROLLER_HXX_
#define X_SCROLLBARCONTROLLER_HXX_
#include "scrollbarcontroller.hxx"
#endif

#ifndef X_DISPSCROLLER_HXX_
#define X_DISPSCROLLER_HXX_
#include "dispscroller.hxx"
#endif

#ifndef X_AVUNDO_HXX_
#define X_AVUNDO_HXX_
#include "avundo.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

MtDefine(CElement_pAccels, PerProcess, "CElement::_pAccels")
MtDefine(CElementGetNextSubDivision_pTabs, Locals, "CElement::GetNextSubdivision pTabs")
MtDefine(CLayoutAry, CLayout, "CLayoutAry::_pv")

ExternTag(tagMsoCommandTarget);
ExternTag(tagNotifyPath);
ExternTag(tagLayoutTrackMulti);

DeclareTag(tagEdImm, "Edit", "IMM association and IME controls");

extern DWORD GetBorderInfoHelper(CTreeNode * pNode,
                                CDocInfo * pdci,
                                CBorderInfo * pbi,
                                DWORD dwFlags
                                FCCOMMA FORMAT_CONTEXT FCPARAM);
extern HRESULT CreateImgDataObject(
                 CDoc            * pDoc,
                 CImgCtx         * pImgCtx,
                 CBitsCtx        * pBitsCtx,
                 CElement        * pElement,
                 CGenDataObject ** ppImgDO);

extern IActiveIMMApp * GetActiveIMM();
extern HIMC ImmGetContextDIMM(HWND hWnd);


//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetBorderInfo
//
//  Synopsis:   get the elements border information.
//
//  Arguments:  pdci        - Current CDocInfo
//              pborderinfo - pointer to return the border information
//              fAll        - (FALSE by default) return all border related
//                            related information (border style's etc.),
//                            if TRUE
//
//  Returns:    0 - if no borders
//              1 - if simple border (all sides present, all the same size)
//              2 - if complex border (present, but not simple)
//
//----------------------------------------------------------------------------
DWORD
CElement::GetBorderInfo(
    CDocInfo *      pdci,
    CBorderInfo *   pborderinfo,
    BOOL            fAll,
    BOOL            fAllPhysical
    FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    DWORD dwFlags = GBIH_NONE;
    DWORD retVal;
    BOOL  fObjectHasBorderAttribute = FALSE;
    
    if(fAll)
        dwFlags |= GBIH_ALL;

    dwFlags |= GBIH_ALLPHY;
    
    // We need to emulate the CSS border info fo OBJECT tags that have the border Attribute set
    // If both border attribute is set and the tag has border set usign CSS we ignore the border
    //    attribute
    if(Tag() == ETAG_OBJECT)
    {
        CUnitValue   uvBorder  = (DYNCAST(CObjectElement, this))->GetAAborder();

        if(!uvBorder.IsNull())
        {
            long lWidth = uvBorder.GetPixelValue();
            pborderinfo->aiWidths[0] = lWidth;
            pborderinfo->aiWidths[1] = lWidth;
            pborderinfo->aiWidths[2] = lWidth;
            pborderinfo->aiWidths[3] = lWidth;
            pborderinfo->abStyles[0] = fmBorderStyleSingle;
            pborderinfo->abStyles[1] = fmBorderStyleSingle;
            pborderinfo->abStyles[2] = fmBorderStyleSingle;
            pborderinfo->abStyles[3] = fmBorderStyleSingle;
            pborderinfo->wEdges = BF_RECT;

            fObjectHasBorderAttribute = TRUE;
        }
    }

    retVal = GetBorderInfoHelper(GetFirstBranch(), pdci, pborderinfo, dwFlags FCCOMMA FCPARAM);

    if(fObjectHasBorderAttribute &&  retVal == DISPNODEBORDER_NONE)
        retVal = DISPNODEBORDER_SIMPLE;

    if (!fAllPhysical && HasVerticalLayoutFlow())
    {
        pborderinfo->FlipBorderInfo();
    }
    return retVal;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetFirstCp
//
//  Synopsis:   Get the first character position of this element in the text
//              flow. (relative to the Markup)
//
//  Returns:    LONG        - start character position in the flow. -1 if the
//                            element is not found in the tree
//
//----------------------------------------------------------------------------
long
CElement::GetFirstCp()
{
    CTreePos *  ptpStart;

    GetTreeExtent( &ptpStart, NULL );

    return ptpStart ? ptpStart->GetCp() + 1 : -1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetLastCp
//
//  Synopsis:   Get the last character position of this element in the text
//              flow. (relative to the Markup)
//
//  Returns:    LONG        - end character position in the flow. -1 if the
//                            element is not found in the tree
//
//----------------------------------------------------------------------------
long
CElement::GetLastCp()
{
    CTreePos *  ptpEnd;

    GetTreeExtent( NULL, &ptpEnd );

    return ptpEnd ? ptpEnd->GetCp() : -1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetFirstAndLastCp
//
//  Synopsis:   Get the first and last character position of this element in
//              the text flow. (relative to the Markup)
//
//  Returns:    no of characters influenced by the element, 0 if the element
//              is not found in the tree.
//
//----------------------------------------------------------------------------
LONG
CElement::GetFirstAndLastCp(long * pcpFirst, long * pcpLast)
{
    CTreePos *  ptpStart, *ptpLast;
    long        cpFirst, cpLast;

    Assert (pcpFirst || pcpLast);

    if (!pcpFirst)
        pcpFirst = &cpFirst;

    if (!pcpLast)
        pcpLast = &cpLast;

    GetTreeExtent( &ptpStart, &ptpLast );

    Assert( (ptpStart && ptpLast) || (!ptpStart && !ptpLast) );

    if( ptpStart )
    {
        *pcpFirst = ptpStart->GetCp() + 1;
        *pcpLast = ptpLast->GetCp();
    }
    else
    {
        *pcpFirst = *pcpLast = 0;
    }

    Assert( *pcpLast - *pcpFirst >= 0 );

    return *pcpLast - *pcpFirst;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::TakeCapture
//
//  Synopsis:   Set the element with the mouse capture.
//
//----------------------------------------------------------------------------

void
CElement::TakeCapture(BOOL fTake)
{
    CDoc * pDoc = Doc();

    if (fTake)
    {
        pDoc->SetMouseCapture(
                MOUSECAPTURE_METHOD(CElement, HandleCaptureMessage,
                                           handlecapturemessage),
                this);
    }
    else
    {
        pDoc->ClearMouseCapture(this);
    }
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// The following seciton has the persistence support routines.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+------------------------------------------------------------------------
//
//  Member:     GetPersistID
//
//  Synopsis:   Helper function to return the ID that is used for matching up
//          persistence data to this element.  By default this is the nested ID of the
//          frame, but if no ID is specified, then we construct one using the
//          nested position of the frame in the name space of its parent.
//
// TODO (jbeda) get rid of the bstr crap
//-------------------------------------------------------------------------

BSTR
CElement::GetPersistID (BSTR bstrParentName)
{
    // TODO: (jbeda) this routine is really screwy.  KTam says we
    // should be able to get rid of the GetUpdatedParentLayout call here.
    // Here is my conclusion for what this actually is.  All normal elements
    // have an ID of <DOC/MARKUPID>#SourceIndex.  However, if your parent layout
    // is a frameset (where did this come from?) you have an id of 
    // <DOC/MARKUPID>#SourceIndexOfFrameSet#SouceIndex.  The <DOC/MARKUPID> is the
    // PersistID of your master element.  
    
    TCHAR       ach[MAX_PERSIST_ID_LENGTH];
    LPCTSTR     pstrID;
    BOOL        fNeedToFree = FALSE;
    CLayout   * pParentLayout = GetUpdatedParentLayout();   // NOTE: (jbeda) this will climb out of slave

    // TODO: (jbeda) If we want to extend this model to view-links
    // we now need to make sure that every markup transition takes 2 #? because
    // otherwise we can run into conflicts.

    CMarkup *   pMarkup = GetMarkup();
    if (pMarkup == NULL)
        return SysAllocString(_T(""));

    // Special case for parent layout of FRAMESET
    if (pParentLayout && pParentLayout->Tag() == ETAG_FRAMESET)
    {
        fNeedToFree = TRUE;
        bstrParentName = pParentLayout->ElementOwner()->GetPersistID(bstrParentName);
    }
    else
    {
        if (!bstrParentName)
        {
            fNeedToFree = TRUE;
            if (pMarkup->Root()->HasMasterPtr())
                bstrParentName = pMarkup->Root()->GetMasterPtr()->GetPersistID();
            else
                bstrParentName = SysAllocString(_T("DOC"));
        }
    }

    // Now get this ID and with the name base, concatenate and leave.
    if ((pstrID = GetAAid()) == NULL)
        IGNORE_HR(Format(0, ach, ARRAY_SIZE(ach), _T("<0s>#<1d>"),
                                                  bstrParentName,
                                                  GetSourceIndex()));
    else
        IGNORE_HR(Format(0, ach, ARRAY_SIZE(ach), _T("<0s>_<1s>"),
                                                  bstrParentName,
                                                  pstrID));

    if (fNeedToFree)
        SysFreeString(bstrParentName);

    return SysAllocString(ach);
}
//+-----------------------------------------------------------------------------
//
//  Member : GetPeerPersist
//
//  Synopsis : this hepler function consolidates the test code that gets the
//      IHTmlPersistData interface from a peer, if there is one.
//      this is used in numerous ::Notify routines.
//+-----------------------------------------------------------------------------
IHTMLPersistData *
CElement::GetPeerPersist()
{
    IHTMLPersistData * pIPersist = NULL;

    if( HasPeerHolder() )
    {
        IGNORE_HR( GetPeerHolder()->QueryPeerInterfaceMulti( IID_IHTMLPersistData, (void **)&pIPersist, FALSE ) );
    }

    return pIPersist;
}
//+-----------------------------------------------------------------------------
//
//  Member : GetPersistenceCache
//
//  Synopsis : Creates and returns the XML DOC.
//      TODO (carled) this needs to check the registry for a pluggable XML store
//
//------------------------------------------------------------------------------
HRESULT
CElement::GetPersistenceCache( IXMLDOMDocument **ppXMLDoc )
{
    HRESULT         hr = S_OK;
    IObjectSafety * pObjSafe = NULL;

    Assert(ppXMLDoc);
    *ppXMLDoc = NULL;

    // 3efaa428-272f-11d2-836f-0000f87a7782
    hr = THR(CoCreateInstance(CLSID_DOMDocument,
                              0,
                              CLSCTX_INPROC_SERVER,
                              IID_IXMLDOMDocument,
                              (void **)ppXMLDoc));
    if (hr)
        goto ErrorCase;

    hr = (*ppXMLDoc)->QueryInterface(IID_IObjectSafety,
                                     (void **)&pObjSafe);
    if (hr)
        goto ErrorCase;

    hr = pObjSafe->SetInterfaceSafetyOptions( IID_NULL,
                                              INTERFACE_USES_SECURITY_MANAGER,
                                              INTERFACE_USES_SECURITY_MANAGER);
    if (hr)
        goto ErrorCase;

Cleanup:
    ReleaseInterface(pObjSafe);
    RRETURN( hr );

ErrorCase:
    delete *ppXMLDoc;
    *ppXMLDoc = NULL;
    goto Cleanup;
}

//+-----------------------------------------------------------------------------
//
//  Member : TryPeerSnapshotSave
//
//  synopsis : notification helper
//
//+-----------------------------------------------------------------------------
HRESULT
CElement::TryPeerSnapshotSave (IUnknown * pDesignDoc)
{
    // check to see if we are a persistence XTag
    HRESULT hr = S_OK;
    IHTMLPersistData * pIPersist = GetPeerPersist();

    // Better be true
    Assert(!IsInMarkup() ||
        GetMarkup()->MetaPersistEnabled((long)htmlPersistStateSnapshot));

    if (pIPersist)
    {
        VARIANT_BOOL       fContinue;

        hr = THR(pIPersist->save(pDesignDoc,
                                 htmlPersistStateSnapshot,
                                 &fContinue));
    }

    ReleaseInterface(pIPersist);
    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  Member : TryPeerPersist
//
//  synopsis : notification helper
//
//+-----------------------------------------------------------------------------

HRESULT
CElement::TryPeerPersist(PERSIST_TYPE sn, void * pvNotify)
{
    // check to see if we are a persistence XTag
    HRESULT hr = S_OK;
    IHTMLPersistData * pIPersist = GetPeerPersist();

    if (pIPersist)
    {
        VARIANT_BOOL       fSupported = VB_FALSE;
        htmlPersistState   hps = (sn==XTAG_HISTORY_SAVE ||
                                  sn==XTAG_HISTORY_LOAD) ? htmlPersistStateHistory:
                                                          htmlPersistStateFavorite;

        // Better be true
        Assert(!IsInMarkup() ||
            GetMarkup()->MetaPersistEnabled((long)hps));

        // one last check, before going through the effort of calling:
        //  Is this particular persist Tag, appropriate for this event
        hr = THR(pIPersist->queryType((long)hps, &fSupported));
        if (!hr && fSupported == VB_TRUE)
        {
            // this can return S_FALSE to stop the propogation of
            // Notify.
            switch (sn)
            {
            case XTAG_HISTORY_SAVE:
                hr = THR(DoPersistHistorySave(pIPersist, pvNotify));
                break;

            case XTAG_HISTORY_LOAD:
                hr = THR(DoPersistHistoryLoad(pIPersist, pvNotify));
                break;

            case FAVORITES_LOAD:
            case FAVORITES_SAVE:
                hr = THR(DoPersistFavorite(pIPersist, pvNotify, sn));
                break;
            }
        }

        ReleaseInterface(pIPersist);
    }

    RRETURN1( hr, S_FALSE );
}

//+-----------------------------------------------------------------------------
//
// Member : DoPersistHistorySave
//
//  Synopsis: helper function for saving this element's/XTags's data into the
//      history stream.  Save is an odd case, since EACH element can have the
//      authordata from the Peer, as well as its own state info (e.g. checkboxs)
//      Most of our work is related to managing the two forms of information, and
//      getting it back to the correct place.
//
//------------------------------------------------------------------------------

HRESULT
CElement::DoPersistHistorySave(IHTMLPersistData *pIPersist,
                               void *            pvNotify)
{
    HRESULT              hr = S_OK;
    IXMLDOMDocument    * pXMLDoc = NULL;
    IUnknown           * pUnk       = NULL;
    VARIANT_BOOL         fContinue  = VB_TRUE;
    VARIANT_BOOL         vtbCleanThisUp;
    CMarkup            * pMarkup = GetMarkup();
    CMarkupBehaviorContext * pContext = NULL;

    if (!pIPersist || !pMarkup)
        return E_INVALIDARG;

    hr = THR(pMarkup->EnsureBehaviorContext(&pContext));
    if (hr)
        goto Cleanup;

    // get the XML cache for the history's userdata block
    if (!pContext->_pXMLHistoryUserData)
    {
        BSTR bstrXML;

        // we haven't needed one yet so create one...
        bstrXML = SysAllocString(_T("<ROOTSTUB />"));
        if (!bstrXML)
            return  E_OUTOFMEMORY;

        // get the xml chache and initialize it.
        hr = GetPersistenceCache(&pXMLDoc);
        if (!hr)
        {
            hr = THR(pXMLDoc->loadXML(bstrXML, &vtbCleanThisUp));
        }
        SysFreeString(bstrXML);
        if (hr)
            goto Cleanup;

        pContext->_pXMLHistoryUserData = pXMLDoc;
    }
    else
    {
        pXMLDoc = pContext->_pXMLHistoryUserData;
    }

    Assert(pXMLDoc);

    hr = pXMLDoc->QueryInterface(IID_IUnknown, (void**)&pUnk);
    if (hr)
        goto Cleanup;

     // call the XTAG and let it save  any userdata
     hr = pIPersist->save(pUnk, htmlPersistStateHistory, &fContinue);
     if (hr)
        goto Cleanup;

    // now in the std History stream give the element a chance
    // to do all its normal saveing. Do this by turning around
    // and giving the element the SN_SAVEHISTORY, this will catch
    // all scope elemnts too. cool.
    // although history does an outerHTML this is really necesary
    //  for object tags to get caught properly.
    if (SUCCEEDED(hr) &&
        fContinue==VB_TRUE &&
        ShouldHaveLayout())
    {
        CNotification   nf;
        nf.SaveHistory1(this, pvNotify);

        // fire against ourself.
        Notify(&nf);

        if (nf.IsSecondChanceRequested())
        {
            nf.SaveHistory2(this, pvNotify);
            Notify(&nf);
        }
    }

    hr = (fContinue==VB_TRUE) ? hr : S_FALSE;

Cleanup:
    ReleaseInterface(pUnk);
    RRETURN1( hr, S_FALSE );
}

//+-------------------------------------------------------------
//
// Member : DoPesistHistoryLoad
//
//  synposis: notification helper function, undoes what DoPersistHistory Save
//      started
//+-------------------------------------------------------------

HRESULT
CElement::DoPersistHistoryLoad(IHTMLPersistData *pIPersist,
                               void *            pvNotify)
{
    HRESULT             hr = E_INVALIDARG;
    IUnknown          * pUnk     = NULL;
    VARIANT_BOOL        fContinue = VB_TRUE;
    VARIANT_BOOL        vtbCleanThisUp;
    IXMLDOMDocument   * pXMLDoc  = NULL;
    CMarkup           * pMarkup = GetMarkup();
    CLock               lock(this);
    CMarkupBehaviorContext * pContext = NULL;

    if (!pIPersist || !pMarkup)
        goto Cleanup;

    hr = THR(pMarkup->EnsureBehaviorContext(&pContext));
    if (hr)
        goto Cleanup;

    // if we are loading the the doc's XML History is NULL,
    //  then this is the first call. so create it and
    //  intialize it from the string.
    if (!pContext->_pXMLHistoryUserData &&
         pContext->_cstrHistoryUserData &&
         pContext->_cstrHistoryUserData.Length())
    {
        BSTR bstrXML;

        if (FAILED(THR(GetPersistenceCache(&pXMLDoc))))
            goto Cleanup;

        hr = pContext->_cstrHistoryUserData.AllocBSTR( &bstrXML );
        if (SUCCEEDED( hr) )
        {   
            hr = THR(pXMLDoc->loadXML(bstrXML, &vtbCleanThisUp));
            if (SUCCEEDED(hr))
            {
                pContext->_pXMLHistoryUserData = pXMLDoc;
                pXMLDoc->AddRef();
                hr = S_OK;
            }
            SysFreeString(bstrXML);
        }
    }
    else if (pContext->_pXMLHistoryUserData)
    {
        pXMLDoc = pContext->_pXMLHistoryUserData;
        pXMLDoc->AddRef();
        hr = S_OK;
    }

    if (!pXMLDoc)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // if for some reason the cache is not yet init'd. do the default
    //---------------------------------------------------------------
    if (hr)
    {
        BSTR bstrXML;

        bstrXML = SysAllocString(_T("<ROOTSTUB />"));
        if (!bstrXML)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pXMLDoc->loadXML(bstrXML, &vtbCleanThisUp));
        SysFreeString(bstrXML);
        if (hr)
            goto Cleanup;
    }

    hr = pXMLDoc->QueryInterface(IID_IUnknown, (void**)&pUnk);
    if (hr)
        goto Cleanup;

    // now that the xml object is initialized properly... call the XTag
    //  give the persist data xtag the chance to load its own information
    hr = pIPersist->load(pUnk, (long)htmlPersistStateHistory, &fContinue);

    hr = (fContinue==VB_TRUE) ? hr : S_FALSE;

Cleanup:
    ReleaseInterface(pUnk);
    ReleaseInterface(pXMLDoc);
    RRETURN1( hr, S_FALSE );
}


//+--------------------------------------------------------------------------
//
//  Member : PersistUserData
//
//  Synopsis : Handles most of the cases where persistence XTags are responsible
//      for handling favorites firing events and gathering user data associated with
//      this element.  in a nutshell :-
//          1> load/create and initialize and XML store
//          2> call the appropriate save/load method on the Peer's IHTMLPersistData
//          3> do any final processing (e.g. for shortcuts, put the xml store into
//                  the shortcut object via INamedPropertyBag)
//
//+--------------------------------------------------------------------------

HRESULT
CElement::DoPersistFavorite(IHTMLPersistData *pIPersist,
                            void *            pvNotify,
                            PERSIST_TYPE      sn)
{
    // This is called when we actually have a persistence cache and the meta tag is
    // enabling it's use
    HRESULT             hr = S_OK;
    BSTR                bstrStub  = NULL;
    VARIANT_BOOL        fContinue = VB_TRUE;
    VARIANT_BOOL        vtbCleanThisUp;
    CVariant            varValue;
    BSTR                bstrXMLText=NULL;
    IUnknown          * pUnk     = NULL;
    IXMLDOMDocument   * pXMLDoc  = NULL;
    INamedPropertyBag * pINPB    = NULL;
    IPersistStreamInit * pIPSI   = NULL;

    if (!pIPersist)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // first initialize the cache
    pINPB = ((FAVORITES_NOTIFY_INFO*)pvNotify)->pINPB;
    hr = GetPersistenceCache(&pXMLDoc);
    if (hr)
        goto Cleanup;

    // don't even initialize with this, if the permissions are wrong
    if (PersistAccessAllowed(pINPB))
    {
        PROPVARIANT  varValue;

        // shortcuts get the xml data into the INPB as the value of the property
        // "XMLUSERDATA"
        bstrStub = GetPersistID();
        if (!bstrStub)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // ask for a value of this type, if this type can't be served, then VT_ERROR
        //  comes back
        V_VT(&varValue) = VT_BLOB;
        hr = THR(pINPB->ReadPropertyNPB(bstrStub, _T("XMLUSERDATA"), &varValue));

        if (hr==S_OK && V_VT(&varValue) == VT_BLOB)
        {
            BSTR bstrXML;

            // turn the blob into a bstr
            bstrXML = SysAllocStringLen((LPOLESTR)varValue.blob.pBlobData,
                                              (varValue.blob.cbSize/sizeof(OLECHAR)));

            // now that we have the string for the xml object.
            if (bstrXML)
            {
                hr = THR(pXMLDoc->loadXML(bstrXML, &vtbCleanThisUp));
                SysFreeString(bstrXML);
            }
            CoTaskMemFree(varValue.blob.pBlobData);
            hr = S_OK;
        }
    }
    else hr = S_FALSE;

    // if for some reason the cache is not yet init'd. do the default
    if (hr)
    {
        BSTR bstrXML;

        bstrXML = SysAllocString(_T("<ROOTSTUB />"));
        if (!bstrXML)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pXMLDoc->loadXML(bstrXML, &vtbCleanThisUp));
        SysFreeString(bstrXML);
    }

    hr = pXMLDoc->QueryInterface(IID_IUnknown, (void**)&pUnk);
    if (hr)
        goto Cleanup;

    // now that the xml object is initialized properly... call the XTag
    switch (sn)
    {
    case FAVORITES_LOAD:
        //  give the persist data xtag the chance to load its own information
        hr = pIPersist->load(pUnk, htmlPersistStateFavorite, &fContinue);
        break;

    case FAVORITES_SAVE:
        {
            PROPVARIANT varXML;

            hr = pIPersist->save(pUnk, htmlPersistStateFavorite, &fContinue);

            // now that we have fired the event and given the persist object the oppurtunity to
            // save its information, we need to actually save it.
            // First, load the variant with the XML Data

            // get the text of the XML document
            hr = THR(pXMLDoc->get_xml( &bstrXMLText));
            if (hr)
                goto Cleanup;

            // now save this in the ini file
            SysFreeString(bstrStub);
            bstrStub = GetPersistID();
            if (!bstrStub)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            // set up the BLOB, don't free this
            V_VT(&varXML) = VT_BLOB;
            varXML.blob.cbSize = (1+SysStringLen(bstrXMLText))*sizeof(OLECHAR);
            varXML.blob.pBlobData = (BYTE*)bstrXMLText;

            // NOTE: security, don't allow more than 32K per object
            // otherwise, just fail silently and free thing up on the way out
            if (varXML.blob.cbSize < PERSIST_XML_DATA_SIZE_LIMIT)
            {
                // write the XML user data
                hr = THR(pINPB->WritePropertyNPB(bstrStub, _T("XMLUSERDATA"), &varXML));
                if (hr)
                    goto Cleanup;

                // now use the propvariant for the other value to write
                V_VT(&varXML) = VT_BSTR;
                if (S_OK != FormsAllocString(Doc()->GetPrimaryUrl(), &V_BSTR(&varXML)))
                    goto Cleanup;

                // and write the user data security url
                hr = THR(pINPB->WritePropertyNPB(bstrStub, _T("USERDATAURL"), &varXML));
                SysFreeString(V_BSTR(&varXML));
                if (hr)
                    goto Cleanup;
            }
        };
        break;
    }

    hr = (fContinue==VB_TRUE) ? hr : S_FALSE;


Cleanup:
    SysFreeString(bstrXMLText);
    SysFreeString(bstrStub);
    ReleaseInterface(pIPSI);
    ReleaseInterface(pUnk);
    ReleaseInterface(pXMLDoc);
    RRETURN1( hr, S_FALSE );
}


//+------------------------------------------------------------------------------
//
//  Member : AccessAllowed()
//
//  Synopsis : checks the security ID of hte document against he stored security
//      id of the XML user data section
//
//-------------------------------------------------------------------------------
BOOL
CElement::PersistAccessAllowed(INamedPropertyBag * pINPB)
{
    BOOL     fRes = FALSE;
    BSTR     bstrDomain;
    HRESULT  hr;
    PROPVARIANT varValue;
    CMarkup * pMarkup = GetMarkup();

    V_VT(&varValue) = VT_BSTR;
    V_BSTR(&varValue) = NULL;

    bstrDomain = GetPersistID();
    if (!bstrDomain)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pINPB->ReadPropertyNPB(bstrDomain,
                                     _T("USERDATAURL"),
                                     &varValue));
    SysFreeString(bstrDomain);
    if (hr)
        goto Cleanup;

    if (V_VT(&varValue) != VT_BSTR)
        goto Cleanup;

    fRes = pMarkup->AccessAllowed(V_BSTR(&varValue));

Cleanup:
    if (V_BSTR(&varValue))
        SysFreeString(V_BSTR(&varValue));
    return fRes;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//          END PERSISTENCE ROUTINES
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+---------------------------------------------------------------------------
//
// Member:      HandleMnemonic
//
//  Synopsis:   This function is called because the user tried to navigate to
//              this element. There at least four ways the user can do this:
//                  1) by pressing Tab or Shift+Tab
//                  2) by pressing the access key for this element
//                  3) by clicking on a label associated with this element
//                  4) by pressing the access key for a label associated with
//                     this element
//
//              Typically, this function sets focus/currency to this element.
//              Click-able elements usually override this function to call
//              DoClick() on themselves if fTab is FALSE (i.e. navigation
//              happened due to reasons other than tabbing).
//
//----------------------------------------------------------------------------
HRESULT
CElement::HandleMnemonic(CMessage * pmsg, BOOL fDoClick, BOOL * pfYieldFailed)
{
    HRESULT     hr      = S_FALSE;
    CDoc *      pDoc    = Doc();

    Assert( IsInMarkup() );
    Assert(pmsg);

    if (IsFrameTabKey(pmsg))
    {
        // Allow this only for the main element inside a FRAME
        CMarkup *   pMarkup     = GetMarkup();
        CElement *  pElemMaster = pMarkup->Root()->GetMasterPtr();

        if (pElemMaster && pElemMaster->Tag() != ETAG_FRAME)
            goto Cleanup;
        
        if (this != pMarkup->GetElementClient())
            goto Cleanup;
    }

    if (IsEditable(TRUE))
    {
        if (Tag() == ETAG_ROOT || Tag() == ETAG_BODY)
        {
            Assert( Tag() != ETAG_ROOT || this == pDoc->PrimaryRoot() );
            hr = THR(BecomeCurrentAndActive(pmsg->lSubDivision, pfYieldFailed, NULL, TRUE, 0, TRUE));
        }
        else
        {
            // BugFix 14600 / 14496 (JohnBed) 03/26/98
            // If the current element does not have layout, just fall
            // out of this so the parent element can handle the mnemonic

            CLayout * pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

            if (!pLayout)
                goto Cleanup;

            // Site-select the element
            {
                CMarkupPointer      ptrStart(pDoc);
                CMarkupPointer      ptrEnd(pDoc);
                IMarkupPointer *    pIStart;
                IMarkupPointer *    pIEnd;

                hr = ptrStart.MoveAdjacentToElement(this, ELEM_ADJ_BeforeBegin);
                if (hr)
                    goto Cleanup;
                hr = ptrEnd.MoveAdjacentToElement(this, ELEM_ADJ_AfterEnd);
                if (hr)
                    goto Cleanup;

                Verify(S_OK == ptrStart.QueryInterface(IID_IMarkupPointer, (void**)&pIStart));
                Verify(S_OK == ptrEnd.QueryInterface(IID_IMarkupPointer, (void**)&pIEnd));
                hr = pDoc->Select(pIStart, pIEnd, SELECTION_TYPE_Control);
                if (hr)
                {
                    if (hr == E_INVALIDARG)
                    {
                        // This element was not site-selectable. Return S_FALSE, so
                        // that we can try the next element
                        hr = S_FALSE;
                    }
                }
                pIStart->Release();
                pIEnd->Release();
                if (hr)
                    goto Cleanup;
            }

            hr = THR(ScrollIntoView());
        }
    }
    else
    {
        Assert(IsFocussable(pmsg->lSubDivision));

        CLock lock(this);
        hr = THR(BecomeCurrentAndActive(pmsg->lSubDivision, pfYieldFailed, pmsg, TRUE, 0, TRUE));
        if (hr)
            goto Cleanup;

        //
        // we may have changed currency during the focus change ( events may have fired)
        // IE6 Bug# 16476
        // so we only do the below if we are indeed the current element
        // 

        if ( pDoc->_pElemCurrent == this )
        {
            hr = THR(ScrollIntoView());
            if (FAILED(hr))
                goto Cleanup;

            if (fDoClick 
                && (    _fActsLikeButton
                    ||  Tag() == ETAG_INPUT && DYNCAST(CInput, this)->IsOptionButton()))
            {
                IGNORE_HR(DoClick(pmsg));
            }

            hr = GotMnemonic(pmsg);
        }
    }

Cleanup:

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::QueryStatus
//
//  Synopsis:   Called to discover if a given command is supported
//              and if it is, what's its state.  (disabled, up or down)
//
//--------------------------------------------------------------------------

HRESULT
CElement::QueryStatus(
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    TraceTag((tagMsoCommandTarget, "CSite::QueryStatus"));

    Assert(IsCmdGroupSupported(pguidCmdGroup));
    Assert(cCmds == 1);

    MSOCMD *    pCmd = &rgCmds[0];
    HRESULT     hr = S_OK;
    CScrollbarController* pSBC;

    Assert(!pCmd->cmdf);

    switch (IDMFromCmdID(pguidCmdGroup, pCmd->cmdID))
    {
    case IDM_DYNSRCPLAY:
    case IDM_DYNSRCSTOP:
        // The selected site wes not an image site, return disabled
       pCmd->cmdf = MSOCMDSTATE_DISABLED;
       break;

    case  IDM_SIZETOCONTROL:
    case  IDM_SIZETOCONTROLHEIGHT:
    case  IDM_SIZETOCONTROLWIDTH:
        // will be executed only if the selection is not a control range
       pCmd->cmdf = MSOCMDSTATE_DISABLED;
       break;

    case IDM_SETWALLPAPER:
        if (Doc()->_pOptionSettings->dwNoChangingWallpaper)
        {
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
            break;
        }
        // fall through
    case IDM_SAVEBACKGROUND:
    case IDM_COPYBACKGROUND:
    case IDM_SETDESKTOPITEM:
        pCmd->cmdf = GetNearestBgImgCtx() ? MSOCMDSTATE_UP
                                          : MSOCMDSTATE_DISABLED;
        break;

    case IDM_SELECTALL:
        if (HasFlag(TAGDESC_CONTAINER))
        {
            // Do not bubble to parent if this is a container.
            pCmd->cmdf =  DisallowSelection()
                            ? MSOCMDSTATE_DISABLED
                            : MSOCMDSTATE_UP;
        }
        break;

    case IDM_SCROLL_HERE:
    case IDM_SCROLL_TOP:
    case IDM_SCROLL_BOTTOM:
    case IDM_SCROLL_PAGEUP:
    case IDM_SCROLL_PAGEDOWN:
    case IDM_SCROLL_UP:
    case IDM_SCROLL_DOWN:
    case IDM_SCROLL_LEFTEDGE:
    case IDM_SCROLL_RIGHTEDGE:
    case IDM_SCROLL_PAGELEFT:
    case IDM_SCROLL_PAGERIGHT:
    case IDM_SCROLL_LEFT:
    case IDM_SCROLL_RIGHT:
        pSBC = TLS(pSBC);
        if (ShouldHaveLayout() && pSBC->GetLayout() == GetUpdatedLayout(GUL_USEFIRSTLAYOUT))
        {
            pCmd->cmdf = MSOCMDSTATE_UP;
        }
        break;
    }

//    if (!pCmd->cmdf )
//        hr = THR_NOTRACE(super::QueryStatus(pguidCmdGroup, 1, pCmd, pcmdtext));


    RRETURN_NOTRACE(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSite::Exec
//
//  Synopsis:   Called to execute a given command.  If the command is not
//              consumed, it may be routed to other objects on the routing
//              chain.
//
//--------------------------------------------------------------------------

HRESULT
CElement::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    TraceTag((tagMsoCommandTarget, "CSite::Exec"));

    Assert(IsCmdGroupSupported(pguidCmdGroup));

    UINT    idm;
    HRESULT hr = OLECMDERR_E_NOTSUPPORTED;

    //
    // default processing
    //

    switch (idm = IDMFromCmdID(pguidCmdGroup, nCmdID))
    {
        case IDM_SAVEBACKGROUND:
        case IDM_SETWALLPAPER:
        case IDM_SETDESKTOPITEM:
        {
            CImgCtx *pImgCtx = GetNearestBgImgCtx();

            if (pImgCtx)
                Doc()->SaveImgCtxAs(pImgCtx, NULL, idm);

            hr = S_OK;
            break;
        }
        case IDM_COPYBACKGROUND:
        {
            CImgCtx *pImgCtx = GetNearestBgImgCtx();

            if (pImgCtx)
                CreateImgDataObject(Doc(), pImgCtx, NULL, NULL, NULL);

            hr = S_OK;
            break;
        }

        case IDM_SCROLL_HERE:
        case IDM_SCROLL_TOP:
        case IDM_SCROLL_BOTTOM:
        case IDM_SCROLL_PAGEUP:
        case IDM_SCROLL_PAGEDOWN:
        case IDM_SCROLL_UP:
        case IDM_SCROLL_DOWN:
        case IDM_SCROLL_LEFTEDGE:
        case IDM_SCROLL_RIGHTEDGE:
        case IDM_SCROLL_PAGELEFT:
        case IDM_SCROLL_PAGERIGHT:
        case IDM_SCROLL_LEFT:
        case IDM_SCROLL_RIGHT:
        {
            CScrollbarController* pSBC = TLS(pSBC);
            if (ShouldHaveLayout() && pSBC->GetLayout() == GetUpdatedLayout(GUL_USEFIRSTLAYOUT))
            {
                pSBC->DoContextMenuScroll(idm);
            }
            hr = S_OK;
            break;
        }
    }
    if (hr != OLECMDERR_E_NOTSUPPORTED)
        goto Cleanup;

    //
    // behaviors
    //

    if (HasPeerHolder())
    {
        hr = THR_NOTRACE(GetPeerHolder()->ExecMulti(
                        pguidCmdGroup,
                        nCmdID,
                        nCmdexecopt,
                        pvarargIn,
                        pvarargOut));
        if (hr != OLECMDERR_E_NOTSUPPORTED)
            goto Cleanup;
    }

Cleanup:

    RRETURN_NOTRACE(hr);
}

//+---------------------------------------------------------------------------
//
//  Member: CElement::IsParent
//
//  Params: pElement: Check if pElement is the parent of this site
//
//  Descr:  Returns TRUE is pSite is a parent of this site, FALSE otherwise
//
//----------------------------------------------------------------------------
BOOL
CElement::IsParent(CElement *pElement)
{
    CTreeNode *pNodeSiteTest = GetFirstBranch();

    while (pNodeSiteTest)
    {
        if (SameScope(pNodeSiteTest, pElement))
        {
            return TRUE;
        }
        pNodeSiteTest = pNodeSiteTest->GetUpdatedParentLayoutNode();
    }
    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::GetNearestBgImgCtx
//
//--------------------------------------------------------------------------
CImgCtx *
CElement::GetNearestBgImgCtx()
{
    CTreeNode * pNodeSite;
    CImgCtx * pImgCtx;

    for (pNodeSite = GetFirstBranch();
         pNodeSite;
         pNodeSite = pNodeSite->GetUpdatedParentLayoutNode())
    {
        pImgCtx = pNodeSite->Element()->GetBgImgCtx();
        if (pImgCtx && (pImgCtx->GetState() & IMGLOAD_COMPLETE))
            return pImgCtx;
    }

    return NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     Celement::GetParentForm()
//
//  Synopsis:   Returns the site's containing form if any.
//
//-------------------------------------------------------------------------
CFormElement *
CElement::GetParentForm()
{
    CElement * pElement = GetFirstBranch() ?
        GetFirstBranch()->SearchBranchToRootForTag(ETAG_FORM)->SafeElement() :
        NULL;

    if (pElement)
        return DYNCAST(CFormElement, pElement);
    else
        return NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     get_form
//
//  Synopsis:   Exposes the form element, NULL otherwise.
//
//  Note:
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CElement::get_form(IHTMLFormElement **ppDispForm)
{
    HRESULT        hr = S_OK;
    CFormElement * pForm;

    if (!ppDispForm)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDispForm = NULL;

    pForm = GetParentForm();
    if (pForm)
    {
        hr = THR_NOTRACE(pForm->QueryInterface(IID_IHTMLFormElement,
                                              (void**)ppDispForm));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN( SetErrorInfo(hr) );
}

//+-------------------------------------------------------------------------
//
//  Method:   CDoc::TakeFocus
//
//  Synopsis: To have trident window take focus if it does not already have it.
//
//--------------------------------------------------------------------------
BOOL
CDoc::TakeFocus()
{
    BOOL fRet = FALSE;

    if (_pInPlace && !_pInPlace->_fDeactivating)
    {
        if (::GetFocus() != _pInPlace->_hwnd)
        {
            SetFocusWithoutFiringOnfocus();
            fRet = TRUE;
        }
    }

    return fRet;
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::YieldCurrency
//
//  Synopsis:   Relinquish currency
//
//  Arguments:  pElementNew    New Element that wants currency
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------

HRESULT
CElement::YieldCurrency(CElement *pElemNew)
{
    HRESULT hr = S_OK;
    CLayout * pLayout = GetUpdatedLayout( GUL_USEFIRSTLAYOUT );
    CDoc* pDoc = Doc();
    if (pLayout)
    {
        CFlowLayout * pFlowLayout = pLayout->IsFlowLayout();
        if (pFlowLayout)
        {
            hr = THR(pFlowLayout->YieldCurrencyHelper(pElemNew));
            if (hr)
                goto Cleanup;
        }
    }

#ifndef NO_IME

    // Restore the IMC if we've temporarily disabled it.  See BecomeCurrent().
    if (pDoc && pDoc->_pInPlace && !pDoc->_pInPlace->_fDeactivating
        && pDoc->_pInPlace->_hwnd && pElemNew)
    {
        // Terminate any IME compositions which are currently in progress
        IUnknown    *pUnknown = NULL;
        IHTMLEditor *pIEditor = NULL;

        IGNORE_HR( this->QueryInterface(IID_IUnknown, (void**) & pUnknown) );
        pIEditor = pDoc->GetHTMLEditor(FALSE);
        
        if( pIEditor )
        {
            IGNORE_HR( pIEditor->TerminateIMEComposition() );
        }

        ReleaseInterface(pUnknown);
    }
#endif

    // 
    // Hide caret (but don't clear selection!) when focus changes
    // in the same frame
    //
    if (IsInMarkup() && pElemNew->GetMarkup() )
    {
        CMarkup* pMarkup = GetMarkup();
        CMarkup* pNewMarkup = pElemNew->GetMarkup();
        
        // 
        // make sure we're done parsing, make sure we are switching
        // to another element in the same frame
        //
        if ( ( ( pMarkup->LoadStatus() == LOADSTATUS_DONE ) ||
               ( pMarkup->LoadStatus() == LOADSTATUS_PARSE_DONE ) ||
               ( pMarkup->LoadStatus() == LOADSTATUS_UNINITIALIZED ) )
                && ( _etag != ETAG_ROOT && pElemNew->_etag != ETAG_DEFAULT) 
                && ( pMarkup->GetFrameOrPrimaryMarkup() == pNewMarkup->GetFrameOrPrimaryMarkup()) )
        {
            IUnknown* pUnknown = NULL;
            IGNORE_HR( pElemNew->QueryInterface( IID_IUnknown, ( void**) & pUnknown ));
            hr = THR( pDoc->NotifySelection( EDITOR_NOTIFY_YIELD_FOCUS , pUnknown ));
            ReleaseInterface( pUnknown );
        }
    }

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CElement::YieldUI
//
//  Synopsis:   Relinquish UI, opposite of BecomeUIActive
//
//  Arguments:  pElementNew    New site that wants UI
//
//--------------------------------------------------------------------------

void
CElement::YieldUI(CElement *pElemNew)
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::BecomeUIActive
//
//  Synopsis:   Force ui activity on the site.
//
//  Notes:      This is the method that external objects should call
//              to force sites to become ui active.
//
//--------------------------------------------------------------------------

HRESULT
CElement::BecomeUIActive()
{
    HRESULT hr = S_FALSE;
    CLayout *pLayout = NULL;

    // NOTE: (krisma) We somethimes can set focus to 
    // an element that's no longer in the tree. (See bug
    // 81787.) In this case, we should return S_FALSE.
    CMarkup *pMarkup = GetMarkup();
    if (!pMarkup)
        goto Cleanup;

    pLayout = GetUpdatedParentLayout();

    // This site does not care about grabbing the UI.
    // Give the parent a chance.
    if (pLayout)
    {
        hr = THR(pLayout->ElementOwner()->BecomeUIActive());
    }
    else
    {
        hr = pMarkup->Root()->BecomeUIActive();
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CElement::BecomeCurrent
//
//  Synopsis:   Force currency on the site.
//
//  Notes:      This is the method that external objects should call
//              to force sites to become current.
//
//--------------------------------------------------------------------------

HRESULT
CElement::BecomeCurrent(
    long        lSubDivision,
    BOOL *      pfYieldFailed,
    CMessage *  pmsg,
    BOOL        fTakeFocus /*=FALSE*/,
    LONG        lButton /*=0*/,
    BOOL *      pfDisallowedByEd /*=NULL*/, 
    BOOL        fFireFocusBlurEvents /*=TRUE*/,
    BOOL        fMnemonic /*=FALSE*/)
{
    HRESULT     hr              = S_FALSE;
    CDoc *      pDoc            = Doc();
    CElement *  pElemOld        = pDoc->_pElemCurrent;
    long        lSubOld         = pDoc->_lSubCurrent;
    CLock       lock(this);

#ifdef MOHANB_WINDOW_FOCUS // need to turn this on sometime soon
    HWND        hwndFocus;
    HWND        hwndCurrent;
    BOOL        fPrevHasFocus   = FALSE;
#endif // MOHANB_WINDOW_FOCUS // need to turn this on sometime soon

    Assert(IsInMarkup());


    // Hack for slave. The editing code calls BecomeCurrent() on slave.
    // For now, make the master current, Need to think about the nested slave tree case
    if (HasMasterPtr())
    {
        return GetMasterPtr()->BecomeCurrent(lSubDivision, pfYieldFailed, pmsg, fTakeFocus, lButton );
    }

#ifdef MOHANB_WINDOW_FOCUS // need to turn this on sometime soon
    // We may need to force fTakeFocus to TRUE. Check if a child window of
    // Trident window has focus. If yes, that child window must be the window
    // associated with the current element. Note that this window is not
    // necessarily _pElemCurrent->GetHwnd(). For example, there are OLE
    // controls that claim to be windowless but internally have a window which
    // is given focus when the control is current (e.g. Active Movie control).
    // Also, the current element could be the child of a windowed element, in
    // case, the parent element's window has focus. In all these cases, Trident
    // needs to makes sure that remove focus from this window. 
    hwndFocus = ::GetFocus();
    fPrevHasFocus = (       hwndFocus
                        &&  pDoc->_pInPlace
                        &&  hwndFocus != pDoc->_pInPlace->_hwnd
                        &&  ::IsChild(pDoc->_pInPlace->_hwnd, hwndFocus)
                    );

#if DBG==1
    if (fPrevHasFocus)
    {
        Assert(pDoc->_pElemCurrent);
        hwndCurrent = pDoc->_pElemCurrent->GetHwnd();
        if (hwndCurrent)
        {
            Assert(hwndFocus == hwndCurrent || ::IsChild(hwndCurrent, hwndFocus));
        }
    }
#endif
#endif // MOHANB_WINDOW_FOCUS // need to turn this on sometime soon

    Assert(pDoc->_fForceCurrentElem || pDoc->_pInPlace);
    if (!pDoc->_fForceCurrentElem && pDoc->_pInPlace->_fDeactivating)
        goto Cleanup;

    if (!IsFocussable(lSubDivision))
        goto Cleanup;

    hr = THR(PreBecomeCurrent(lSubDivision, pmsg));
    if (hr)
        goto Cleanup;

    hr = THR(pDoc->SetCurrentElem(this,
                                  lSubDivision,
                                  pfYieldFailed,
                                  lButton,
                                  pfDisallowedByEd,
                                  fFireFocusBlurEvents,
                                  fMnemonic));
    if (hr)
    {
        IGNORE_HR(THR(BecomeCurrentFailed(lSubDivision, pmsg)));

        // Take focus if necessary, whether or not current element has changed #99296
        if (fTakeFocus && !pDoc->HasFocus())
        {
            pDoc->TakeFocus();
        }

        goto Cleanup;
    }

    //  The event might have killed the element

    if (! IsInMarkup() )
        goto Cleanup;

    // Do not inhibit if Currency did not change. Onfocus needs to be fired from
    // WM_SETFOCUS handler if clicking in the address bar and back to the same element
    // that previously had the focus.

    pDoc->_fInhibitFocusFiring = (this != pElemOld);

    if ( IsEditable( FALSE ) && !pDoc->_fPopupDoc)
    {
        //
        // An editable element has just become current.
        // We create the editor if one doesn't already exist.
        //
        
        if (  _etag != ETAG_ROOT ) // make sure we're done parsing
        {
            //
            // marka - we need to put in whether to select the text or not.
            //

            Verify( pDoc->GetHTMLEditor( TRUE ));


        }

    }

#ifdef MOHANB_WINDOW_FOCUS // need to turn this on sometime soon

    if (fPrevHasFocus)
    {
        hwndFocus = ::GetFocus();
        hwndCurrent = GetHwnd();

        if (    hwndFocus
            &&  hwndCurrent
            &&  (hwndFocus == hwndCurrent || ::IsChild(hwndCurrent, hwndFocus))
           ) 
        {
            // Leave focus alone, it's already with the new current element
        }
        else
        {
            // TODO (MohanB) I am ignoring the case where the focus is with
            // the window of a parent element of the current element. We currently
            // don't have windowed elements whose children could become current.
            fTakeFocus = TRUE;
        }
    }
#endif // MOHANB_WINDOW_FOCUS // need to turn this on sometime soon

    //
    // Take focus only if told to do so, and the element becoming current is not 
    // the root and not an olesite.  Olesite's will do it themselves.  
    //
    
    if (fTakeFocus && !TestClassFlag(ELEMENTDESC_OLESITE))
    {
        pDoc->TakeFocus();
    }

#ifndef NO_IME
    if (pDoc->_pInPlace && !pDoc->_pInPlace->_fDeactivating && pDoc->_pInPlace->_hwnd)
    {
        // If ElementOwner is not editable, disable current imm and cache the HIMC.  The 
        // HIMC is restored in YieldCurrency.
        //
        BOOL fIsPassword = ( Tag() == ETAG_INPUT 
                             && (DYNCAST(CInput, this))->GetType() == htmlInputPassword );

        // If the current object is a non-password edit field or object, we must
        // disable the IME and cache the IMM input context so we can re-enable it
        // in the future
        if ((!IsEditable(/*fCheckContainerOnly*/FALSE) && Tag() != ETAG_OBJECT) || fIsPassword)
        {
            //
            // If this has been disabled. We won't disable it again
            //
            if (NULL == Doc()->_himcCache)
            {
                HIMC himc = ImmGetContext(Doc()->_pInPlace->_hwnd);

                if (himc)
                {
                    // Disable the IME
                    himc = ImmAssociateContext(Doc()->_pInPlace->_hwnd, NULL);
                    Doc()->_himcCache = himc;
                    TraceTag((tagEdImm, "Element %d Disable IME 0x%x for window 0x%x _pDocDbg %x", 
                                        _etagDbg, himc, Doc()->_pInPlace->_hwnd, _pDocDbg)
                                        );
                }            
             }
        }
        else
        {
            // If we previously disabled the IME, we need to re-enable it for this 
            // editable object. 
            if (Doc()->_himcCache)
            {
                TraceTag((tagEdImm, "Element %d Enable IME 0x%x for window 0x%x _pDocDbg %x", 
                                    _etagDbg, _pDocDbg->_himcCache, Doc()->_pInPlace->_hwnd, _pDocDbg)
                                    );
                ImmAssociateContext(Doc()->_pInPlace->_hwnd, Doc()->_himcCache);
                Doc()->_himcCache = NULL;
            }

            //
            // Set the IME state for inputs and textareas.  
            //
            // Note:  We have to do this even when it has been called since the 
            //        above code might have enabled IME again even though it is 
            //        supposed to be disabled! #94387  [zhenbinx]
            //
            //
            if( Tag() == ETAG_INPUT || Tag() == ETAG_TEXTAREA )
            {
                IGNORE_HR(SetImeState());
            }
        }
    }
#endif // NO_IME

    pDoc->_fInhibitFocusFiring = FALSE;
    hr = S_OK;

    if (HasPeerHolder() && GetPeerHolder()->_pPeerUI)
    {
        GetPeerHolder()->_pPeerUI->OnReceiveFocus(TRUE, pDoc->_lSubCurrent);
    }

    if (pElemOld->HasPeerHolder() &&
        pElemOld->GetPeerHolder()->_pPeerUI)
    {
        pElemOld->GetPeerHolder()->_pPeerUI->OnReceiveFocus(
            FALSE,
            lSubOld);
    }

    if (Tag() != ETAG_ROOT && pDoc->_pInPlace)
    {
        CLayout * pLayout = GetUpdatedLayout( pmsg ? pmsg->pLayoutContext : GUL_USEFIRSTLAYOUT );

        if (pLayout && pLayout->IsFlowLayout())
        {
            hr = THR(pLayout->IsFlowLayout()->BecomeCurrentHelper(lSubDivision, pfYieldFailed, pmsg));
            if (hr)
                goto Cleanup;
        }
    }


    hr = THR(PostBecomeCurrent(pmsg, fTakeFocus));

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CElement::BecomeCurrentAndActive
//
//  Synopsis:   Force currency and uiactivity on the site.
//
//--------------------------------------------------------------------------

HRESULT
CElement::BecomeCurrentAndActive(long           lSubDivision    /*=0*/,
                                 BOOL *         pfYieldFailed   /*=NULL*/,
                                 CMessage *     pmsg            /*=NULL*/,
                                 BOOL           fTakeFocus      /*=FALSE*/,
                                 LONG           lButton         /*=0*/,
                                 BOOL           fMnemonic       /*=FALSE*/)
{
    HRESULT     hr          = S_FALSE;
    CDoc *      pDoc        = Doc();
    CElement *  pElemOld    = pDoc->_pElemCurrent;
    long        lSubOld     = pDoc->_lSubCurrent;
    CLock       lock(this);

    // Store the old current site in case the new current site cannot
    // become ui-active.  If the becomeuiactive call fails, then we
    // must reset currency to the old guy.
    //

    if (pDoc->IsPrintDialogNoUI())
        goto Cleanup;

    hr = THR(BecomeCurrent(lSubDivision, pfYieldFailed, pmsg, fTakeFocus, lButton, NULL, TRUE, fMnemonic));
    if (hr)
        goto Cleanup;

    hr = THR(BecomeUIActive());
    if (OK(hr))
    {
        hr = S_OK;
    }
    else
    {
        if (pElemOld)
        {
            // Don't take focus in this case
            Verify(!pElemOld->BecomeCurrent(lSubOld));
        }
    }
Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Method:     CElement::BubbleBecomeCurrent
//
//  Synopsis:   Bubble up BecomeCurrent requests through parent chain.
//
//----------------------------------------------------------------------------
HRESULT
CElement::BubbleBecomeCurrent(long       lSubDivision,
                              BOOL     * pfYieldFailed,
                              CMessage * pMessage,
                              BOOL       fTakeFocus, 
                              LONG       lButton /* = 0*/ )
    {
    CTreeNode * pNode           = NULL;
    HRESULT     hr              = S_OK;
    BOOL        fDisallowedByEd = FALSE;
    BOOL        fYieldFailed    = FALSE;
    CDoc *      pDoc            = Doc();
    unsigned    cCurrentElemChangesOld;
    
    if (HasMasterPtr())
    {
        return GetMasterPtr()->BubbleBecomeCurrent(lSubDivision, pfYieldFailed, pMessage, fTakeFocus, lButton );
    }

    pNode = GetFirstBranch();
    if (!pNode)
        goto Cleanup;


    hr = S_FALSE;
    cCurrentElemChangesOld = pDoc->_cCurrentElemChanges;

    while (hr == S_FALSE && pNode && !fDisallowedByEd && !fYieldFailed)
    {
        hr = THR(pNode->Element()->BecomeCurrent(
                                    lSubDivision, & fYieldFailed, pMessage, fTakeFocus, lButton, & fDisallowedByEd  ));

        if (hr == S_FALSE)
        {
            // We do not want to retry if currency was changed
            if (cCurrentElemChangesOld != pDoc->_cCurrentElemChanges)
            {
                hr = S_OK;
            }
            else
            {
                pNode = pNode->Parent();
                lSubDivision = 0; // Don't need to set this except in the first iteration, but..
            }
        }
    }

Cleanup:
    if (pfYieldFailed)
    {
        *pfYieldFailed = fYieldFailed;
    }
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CElement::RequestYieldCurrency
//
//  Synopsis:   Check if OK to Relinquish currency
//
//  Arguments:  BOOl fForce -- if TRUE, force change and don't ask user about
//                             usaveable data.
//
//  Returns:    S_OK        ok to yield currency
//              S_FALSE     ok to yield currency, but user explicitly reverted
//                          the value to what the database has
//              E_*         not ok to yield currency
//
//--------------------------------------------------------------------------

HRESULT
CElement::RequestYieldCurrency(BOOL fForce)
{
    HRESULT hr = S_OK;
#ifndef NO_DATABINDING
    CElement * pElemBound;
    DBMEMBERS *pdbm;
    DBINFO dbi;
    CDoc* pDoc = Doc();

    if (!IsValid())
    {
        // TODO     Need to display error message here.
        //          May not be able to handle synchronous
        //          display, so consider deferred display.
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!ShouldHaveLayout())
        goto Cleanup;

    pElemBound = GetElementDataBound();
    pdbm = pElemBound->GetDBMembers();

    if (pdbm == NULL)
    {
        goto Cleanup;
    }

#ifndef NO_IME
    // IEV6-26259
    // if we have a databinding session, need to terminate IME before 
    // data is saved. 
    if (pDoc && pDoc->_pInPlace && !pDoc->_pInPlace->_fDeactivating
        && pDoc->_pInPlace->_hwnd)
    {
        // Terminate any IME compositions which are currently in progress
        IUnknown    *pUnknown = NULL;
        IHTMLEditor *pIEditor = NULL;

        IGNORE_HR( this->QueryInterface(IID_IUnknown, (void**) & pUnknown) );
        pIEditor = pDoc->GetHTMLEditor(FALSE);
        
        if( pIEditor )
        {
            IGNORE_HR( pIEditor->TerminateIMEComposition() );
        }

        ReleaseInterface(pUnknown);
    }    
#endif

    // Save, with accompanying cancellable notifications
    hr = THR(pElemBound->SaveDataIfChanged(ID_DBIND_ALL, /* fLoud */ !fForce));
    if (fForce)
    {
        hr = S_OK;
    }

Cleanup:
#endif // ndef NO_DATABINDING
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member: CElement::GetInfo
//
//  Params: [gi]: The GETINFO enumeration.
//
//  Descr:  Returns the information requested in the enum
//
//----------------------------------------------------------------------------
DWORD
CElement::GetInfo(GETINFO gi)
{
    switch (gi)
    {
    case GETINFO_ISCOMPLETED:
        return TRUE;

    case GETINFO_HISTORYCODE:
        return Tag();
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
// Method:      CElement::HaPercentBgImg
//
// Synopsis:    Does this element have a background image whose width or
//              height is percent based.
//
//----------------------------------------------------------------------------

BOOL
CElement::HasPercentBgImg()
{
    CImgCtx * pImgCtx = GetBgImgCtx();
    const CFancyFormat * pFF = GetFirstBranch()->GetFancyFormat();

    // Logical/Physical does not matter here since we look at both.
    return pImgCtx &&
           (pFF->GetBgPosX().GetUnitType() == CUnitValue::UNIT_PERCENT ||
            pFF->GetBgPosY().GetUnitType() == CUnitValue::UNIT_PERCENT);
}


//+---------------------------------------------------------------------------
//
//  Member:     CElement::IsVisible
//
//  Synopsis:   Is this layout element visible?
//
//  Parameters: fCheckParent - check the parent first
//
//----------------------------------------------------------------------------

BOOL
CElement::IsVisible (BOOL fCheckParent FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    CTreeNode *pNode         = GetUpdatedNearestLayoutNode();
    BOOL       fVisible      = !!pNode;

    // If we don't have an ancestor w/ layout, check if
    // we have a master.  If so, we're in a inner-slave relationship,
    // and we have the visibility of our master.  Else we're not
    // visible (probably not in tree).
    if (!pNode)
    {
        if (HasMasterPtr())
        {
            return GetMasterPtr()->IsVisible(fCheckParent);
        }
        return FALSE;
    }

    // Certain controls are marked as invisible.
    if (TestClassFlag(ELEMENTDESC_OLESITE))
    {
        if (DYNCAST(COleSite, this)->_fInvisibleAtRuntime)
            fVisible = FALSE;
    }

    while (fVisible)
    {
        const CCharFormat * pCF;
        
        if (!pNode)
            break;

        if (!pNode->Element()->IsInMarkup())
        {
            fVisible = FALSE;
            break;
        }

        // Visibility is inherited per CSS2, thus it suffices to check
        // ourself (instead of every element in the parent element chain).
        pCF = GetFirstBranch()->GetCharFormat( FCPARAM );

        if ( pCF->IsDisplayNone() || pCF->IsVisibilityHidden())
        {
            fVisible = FALSE;
            break;
        }
        
        if (!fCheckParent)
        {
            fVisible = TRUE;
            break;
        }
#ifdef MULTI_FORMAT
        if (FCPARAM)
        {
            CTreeNode * pTempNode = pNode;
            pNode = pNode->Element()->GetParentFormatNode(pTempNode, FCPARAM);
            FCPARAM = pNode->Element()->GetParentFormatContext(pTempNode, FCPARAM);
        }
        else
#endif         
        {
            pNode = pNode->GetUpdatedParentLayoutNode();
        }
    }
    return fVisible;
}

BOOL 
CElement::IsParentEditable()
{
    CTreeNode* pNode = GetFirstBranch();
    CTreeNode* pParent = pNode ? pNode->Parent() : NULL ;

    if ( pParent && 
         pParent->Element() )
    {
        return pParent->Element()->IsEditable(/*fCheckContainerOnly*/FALSE);
    }
    else
        return FALSE;
}

BOOL
CElement::IsMasterParentEditable()
{
    CMarkup * pMarkup  = GetMarkup();
    CElement* pMaster = pMarkup->Root()->HasMasterPtr() ? 
                            pMarkup->Root()->GetMasterPtr() :
                            NULL ;

    return ( pMaster && ( pMaster->IsParentEditable() || pMaster->IsMasterParentEditable() ) );
}


BOOL CElement::IsEditable(BOOL fCheckContainerOnly 
                          FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    if (IsRoot() || (fCheckContainerOnly && Tag() == ETAG_BODY))
    {
        return IsDesignMode();
    }
    else
    {
        CTreeNode *pNode = GetFirstBranch();

        return (pNode && pNode->IsEditable(fCheckContainerOnly FCCOMMA FCPARAM));
    }
}

BOOL CElement::IsFrozen()
{  
    CDefaults * pDefaults = GetDefaults();
    if (pDefaults)
    {
        return pDefaults->GetAAfrozen();
    }

    return FALSE;    
}

BOOL CElement::IsParentFrozen()
{
    if (IsInMarkup())        
    {
        return GetFirstBranch()->GetCharFormat()->_fParentFrozen;
    }

    return FALSE;
}

BOOL CElement::IsUnselectable()
{
    HRESULT hr = S_OK;
    VARIANT var;
    BOOL    fUnselectable = FALSE;

    VariantInit(&var);
    V_VT(&var)   = VT_BSTR ;
    V_BSTR(&var) =  NULL ;

    hr = THR( getAttribute(_T("unselectable"), 0, &var) );
    if (hr != S_OK)
        goto Cleanup;

    if (V_VT(&var) == VT_BSTR)
    {
        fUnselectable = !!(_tcsicmp(var.bstrVal, _T("on")) == 0);
    }
    else if (V_VT(&var) == VT_BOOL)
    {
        fUnselectable = !!(V_BOOL(&var));
    }
Cleanup:
    return fUnselectable;
}



//+---------------------------------------------------------------------------
//
//  Member:     CElement::IsEnabled
//
//  Synopsis:   Is this element enabled? Try to get the cascaded info cached
//              in the char format. If the element is not in any markup,
//              use the 'disabled attribute directly.
//
//  Returns:    BOOL
//
//----------------------------------------------------------------------------

BOOL
CElement::IsEnabled(FORMAT_CONTEXT FCPARAM)
{
    CTreeNode * pNode = GetFirstBranch();

    return !(pNode
            ? pNode->GetCharFormat(FCPARAM)->_fDisabled
            : GetAAdisabled());
}


BOOL
CElement::IsLocked(FORMAT_CONTEXT FCPARAM)
{
    // only absolute sites can be locked.
    if(IsAbsolute(FCPARAM))
    {
        CVariant var;
        CStyle *pStyle;

        pStyle = GetInLineStylePtr();

        if (!pStyle || pStyle->getAttribute(L"Design_Time_Lock", 0, &var))
            return FALSE;

        return var.boolVal;
    }
    return FALSE;
}

// Accelerator Table handling
//
CElement::ACCELS::ACCELS(ACCELS * pSuper, WORD wAccels)
{
    _pSuper = pSuper;
    _wAccels = wAccels;
    _fResourcesLoaded = FALSE;
    _pAccels = NULL;
}

CElement::ACCELS::~ACCELS()
{
    delete _pAccels;
}

HRESULT
CElement::ACCELS::LoadAccelTable()
{
    HRESULT hr = S_OK;
    HACCEL  hAccel;
    int     cLoaded;

    if (!_wAccels)
        goto Cleanup;

    hAccel = LoadAccelerators(GetResourceHInst(), MAKEINTRESOURCE(_wAccels));
    if (!hAccel)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    _cAccels = CopyAcceleratorTable(hAccel, NULL, 0);
    Assert (_cAccels);

    _pAccels = new(Mt(CElement_pAccels)) ACCEL[_cAccels];
    if (!_pAccels)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    cLoaded = CopyAcceleratorTable(hAccel, _pAccels, _cAccels);
    if (cLoaded != _cAccels)
    {
        hr = E_OUTOFMEMORY;
    }

Cleanup:
    if (hr)
    {
        _cAccels = 0;
        _pAccels = NULL;
    }
    RRETURN (hr);
}


HRESULT
CElement::ACCELS::EnsureResources()
{
    if (!_fResourcesLoaded)
    {
        CGlobalLock     glock;

        if (!_fResourcesLoaded)
        {
            HRESULT hr;

            hr = THR(LoadAccelTable ());

            _fResourcesLoaded = TRUE;

            RRETURN (hr);
        }
    }

    return S_OK;
}


DWORD
CElement::ACCELS::GetCommandID(LPMSG pmsg)
{
    HRESULT     hr;
    DWORD       nCmdID = IDM_UNKNOWN;
    WORD        wVKey;
    ACCEL *     pAccel;
    int         i;
    DWORD       dwKeyState = FormsGetKeyState();

    if (WM_KEYDOWN != pmsg->message && WM_SYSKEYDOWN != pmsg->message)
        goto Cleanup;

    if (_pSuper)
    {
        nCmdID = _pSuper->GetCommandID(pmsg);
        if (IDM_UNKNOWN != nCmdID) // found id, nothing more to do
            goto Cleanup;
    }

    hr = THR(EnsureResources());
    if (hr)
        goto Cleanup;

    // loop through the table
    for (i = 0, pAccel = _pAccels; i < _cAccels; i++, pAccel++)
    {
// WINCEREVIEW - don't have VkKeyScan
#ifndef WINCE
        if (!(pAccel->fVirt & FVIRTKEY))
        {
            wVKey = LOBYTE(VkKeyScan(pAccel->key));
        }
        else
#endif // WINCE
        {
            wVKey = pAccel->key;
        }

        if (wVKey == pmsg->wParam &&
            EQUAL_BOOL(pAccel->fVirt & FCONTROL, dwKeyState & MK_CONTROL) &&
            EQUAL_BOOL(pAccel->fVirt & FSHIFT,   dwKeyState & MK_SHIFT) &&
            EQUAL_BOOL(pAccel->fVirt & FALT,     dwKeyState & MK_ALT))
        {
            nCmdID = pAccel->cmd;
            break;
        }
    }

Cleanup:
    return nCmdID;
}

CElement::ACCELS CElement::s_AccelsElementDesign =
                 CElement::ACCELS(NULL, IDR_ACCELS_SITE_DESIGN);
CElement::ACCELS CElement::s_AccelsElementDesignNoHTML =
                 CElement::ACCELS(NULL, IDR_ACCELS_INPUTTXT_DESIGN);
CElement::ACCELS CElement::s_AccelsElementRun    =
                 CElement::ACCELS(NULL, IDR_ACCELS_SITE_RUN);


//+---------------------------------------------------------------
//
//  Member:     CElement::PerformTA
//
//  Synopsis:   Forms implementation of TranslateAccelerator
//              Check against a list of accelerators for the incoming
//              message and if a match is found, fire the appropriate
//              command.  Return true if match found, false otherwise.
//
//  Input:      pMessage    Ptr to incoming message
//
//---------------------------------------------------------------
HRESULT
CElement::PerformTA(CMessage *pMessage)
{
    HRESULT     hr = S_FALSE;
    DWORD       cmdID;
    MSOCMD      msocmd;
    CDoc *      pDoc = Doc();

    cmdID = GetCommandID(pMessage);

    if (cmdID == IDM_UNKNOWN)
        goto Cleanup;

    // CONSIDER: (anandra) Think about using an Exec
    // call directly here, instead of sendmessage.
    //
    msocmd.cmdID = cmdID;
    msocmd.cmdf  = 0;

    // So QueryStatus() should be called, instead of QueryStatusHelper() with
    // Document() as the context.  The reason for this is because the SendMessage
    // which actually executes the command below is routed to CDoc::Exec.  This
    // means that the Exec() call has no context of which CDocument originated
    // the call.  Therefore, we should QueryStatus the same way we exec, with 
    // CDoc having no knowledge of its originating document.

    hr = THR(pDoc->QueryStatus(
            (GUID *)&CGID_MSHTML,
            1,
            &msocmd,
            NULL));
    if (hr)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    if (msocmd.cmdf == 0)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    if (msocmd.cmdf == MSOCMDSTATE_DISABLED)
        goto Cleanup; // hr == S_OK;

    SendMessage(
            pDoc->_pInPlace->_hwnd,
            WM_COMMAND,
            GET_WM_COMMAND_MPS(cmdID, NULL, 1));
    hr = S_OK; 

Cleanup:

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------
//
//  Member:     CElement::GetCommandID
//
//---------------------------------------------------------------
DWORD
CElement::GetCommandID(LPMSG lpmsg)
{
    DWORD   nCmdID;
    ACCELS  *pAccels = NULL;
    HRESULT hr = S_OK;
    
    //
    // Only one set of design time accelerators is now available.  This is
    // because any element can have contentEditable set, so accels have
    // to work for potentially any element.  Removed the design time
    // accels from the classdesc for each element - johnthim
    //
    if( !IsEditable(/*fCheckContainerOnly*/FALSE) )
    {
        pAccels = ElementDesc()->_pAccelsRun;
    }
    else
    {
        VARIANT_BOOL fSupportsHTML;
    
        hr = get_canHaveHTML(&fSupportsHTML);
        if( !FAILED(hr) )
        {
            pAccels = (fSupportsHTML == VB_TRUE) ? &CElement::s_AccelsElementDesign : &CElement::s_AccelsElementDesignNoHTML;
        }
    }

    nCmdID = pAccels ? pAccels->GetCommandID(lpmsg) : IDM_UNKNOWN;

    // IE5 73627 -- If the SelectAll accelerator is received by an element
    // that does not allow selection (possibly because it is in a dialog),
    // treat the accelerator as unknown instead of disabled. This allows the
    // accelerator to bubble up.
    if (nCmdID == IDM_SELECTALL && DisallowSelection())
    {
        nCmdID = IDM_UNKNOWN;
    }

    return nCmdID;
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::OnContextMenu
//
//  Synopsis:   Handles WM_CONTEXTMENU message.
//
//--------------------------------------------------------------------------
HRESULT
CElement::OnContextMenu(int x, int y, int id)
{
    int cx = x;
    int cy = y;
    CDoc *  pDoc = Doc();


    if (cx == -1 && cy == -1)
    {
        RECT rcWin;

        GetWindowRect(pDoc->InPlace()->_hwnd, &rcWin);
        cx = rcWin.left;
        cy = rcWin.top;
    }

    {
        EVENTPARAM  param(pDoc, this, NULL, TRUE);
        CTreeNode  *pNode;

        pNode = (pDoc->HasCapture() && pDoc->_pNodeLastMouseOver) ?
                    pDoc->_pNodeLastMouseOver : GetFirstBranch();

        param.SetNodeAndCalcCoordinates(pNode);
        param.SetType(_T("MenuExtUnknown"));

        //
        // we should release out capture
        //

        pDoc->SetMouseCapture(NULL, NULL);
        RRETURN1(THR(pDoc->ShowContextMenu(cx, cy, id, this)), S_FALSE);
    }
}

#ifndef NO_MENU
//+---------------------------------------------------------------
//
//  Member:     CElement::OnMenuSelect
//
//  Synopsis:   Handle WM_MENUSELECT by updating status line text.
//
//----------------------------------------------------------------
HRESULT
CElement::OnMenuSelect(UINT uItem, UINT fuFlags, HMENU hmenu)
{

    CDoc * pDoc = Doc();
    TCHAR  achMessage[FORMS_BUFLEN + 1];

    if (hmenu == NULL && fuFlags == 0xFFFF) // menu closed
    {
        pDoc->SetStatusText(NULL, STL_ROLLSTATUS, GetMarkup());
        return S_OK;
    }
    else if ((fuFlags & (MF_POPUP|MF_SYSMENU)) == 0 && uItem != 0)
    {
        LoadString(
                GetResourceHInst(),
                IDS_MENUHELP(uItem),
                achMessage,
                ARRAY_SIZE(achMessage));
    }

#if 0
    // what's this supposed to do????????????

    else if ((fuFlags & MF_POPUP) && (pDoc->InPlace()->_hmenuShared == hmenu))
    {
        // For top level popup menu
        //
        LoadString(
                GetResourceHInst(),
                IDS_MENUHELP(uItem),
                achMessage,
                ARRAY_SIZE(achMessage));
    }
#endif

    else
    {
        achMessage[0] = TEXT('\0');
    }

    pDoc->SetStatusText(achMessage, STL_ROLLSTATUS, GetMarkup());

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     CElement::OnInitMenuPopup
//
//  Synopsis:   Handles WM_CONTEXTMENU message.
//
//---------------------------------------------------------------
inline BOOL IsMenuItemFontOrEncoding(ULONG idm)
{
    return  ( idm >= IDM_MIMECSET__FIRST__ && idm <= IDM_MIMECSET__LAST__)
    ||  ( (idm >= IDM_BASELINEFONT1 && idm <= IDM_BASELINEFONT5)
                       || (idm == IDM_DIRLTR || idm == IDM_DIRRTL) );
}
HRESULT
CElement::OnInitMenuPopup(HMENU hmenu, int item, BOOL fSystemMenu)
{
    int             i;
    MSOCMD          msocmd;
    UINT            mf;

    for(i = 0; i < GetMenuItemCount(hmenu); i++)
    {
        msocmd.cmdID = GetMenuItemID(hmenu, i);
        if (msocmd.cmdID > 0 && !IsMenuItemFontOrEncoding(msocmd.cmdID))
        {
            Doc()->QueryStatusHelper(
                    Document(),
                    (GUID *) &CGID_MSHTML,
                    1,
                    &msocmd,
                    NULL);
            switch (msocmd.cmdf)
            {
            case MSOCMDSTATE_UP:
            case MSOCMDSTATE_NINCHED:
                mf = MF_BYCOMMAND | MF_ENABLED | MF_UNCHECKED;
                break;

            case MSOCMDSTATE_DOWN:
                mf = MF_BYCOMMAND | MF_ENABLED | MF_CHECKED;
                break;

            case MSOCMDSTATE_DISABLED:
            default:
                mf = MF_BYCOMMAND | MF_DISABLED | MF_GRAYED;
                break;
            }
            CheckMenuItem(hmenu,  msocmd.cmdID, mf & ~(MF_ENABLED | MF_DISABLED | MF_GRAYED));
            EnableMenuItem(hmenu, msocmd.cmdID, mf & ~(MF_CHECKED | MF_UNCHECKED));
        }
    }
    return S_OK;
}
#endif // NO_MENU

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetColors
//
//  Synopsis:   Gets the color set for the Element.
//
//  Returns:    The return code is as per GetColorSet.
//              If any child site fails, that is our return code.  If any
//              child site returns S_OK, that is our return code, otherwise
//              we return S_FALSE.
//
//----------------------------------------------------------------------------
HRESULT
CElement::GetColors(CColorInfo *pCI)
{
    DWORD_PTR dw = 0;
    HRESULT   hr = S_FALSE;

    CLayout * pLayoutThis = GetUpdatedLayout();
    CLayout * pLayout;

    Assert(pLayoutThis && "CElement::GetColors() should not be called here !!!");
    if (!pLayoutThis)
        goto Error;

    for (pLayout = pLayoutThis->GetFirstLayout(&dw);
         pLayout && !pCI->IsFull() ;
         pLayout = pLayoutThis->GetNextLayout(&dw))
    {
        HRESULT hrTemp = pLayout->ElementOwner()->GetColors(pCI);
        if (FAILED(hrTemp) && hrTemp != E_NOTIMPL)
        {
            hr = hrTemp;
            goto Error;
        }
        else if (hrTemp == S_OK)
            hr = S_OK;
    }

Error:
    if (pLayoutThis)
        pLayoutThis->ClearLayoutIterator(dw, FALSE);
    RRETURN1(hr, S_FALSE);
}

#ifndef NO_DATABINDING

CElement *
CElement::GetElementDataBound()
{
    CElement * pElement = this;
    Assert(ShouldHaveLayout() && "CElement::GetElementDataBound() should not be called !!!");
    return pElement;
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::SaveDataIfChanged
//
//  Synopsis:   Determine whether or not is appropate to save the value
//              in  a control to a datasource, and do so.  Fire any appropriate
//              events.
//
//  Arguments:  id     - identifies which binding is being saved
//              fLoud  - should we put an alert in user's face on failure?
//              fForceIsCurrent - treat the element as if it were the current
//                          focus element, even if it's not
//
//  Returns:    S_OK        no work to do, or transfer successful
//              S_FALSE     user reverted value to database version
//
//--------------------------------------------------------------------------
HRESULT
CElement::SaveDataIfChanged(LONG id, BOOL fLoud, BOOL fForceIsCurrent)
{
    HRESULT     hr = S_OK;
    DBMEMBERS * pdbm;

    pdbm = GetDBMembers();
    if (!pdbm)
        goto Cleanup;

    hr = pdbm->SaveIfChanged(this, id, fLoud, fForceIsCurrent);

Cleanup:
    RRETURN1(hr, S_FALSE);
}
#endif // NO_DATABINDING


HRESULT
CElement::ScrollIntoView(SCROLLPIN spVert, SCROLLPIN spHorz, BOOL /*fScrollBits*/)
{
    HRESULT hr = S_OK;
    
    if(GetFirstBranch())
    {
        // If <OPTION> scroll the <SELECT> instead
        if (Tag() == ETAG_OPTION)
        {
            CElement * pElementParent = GetFirstBranch()->Parent()->SafeElement();

            if(pElementParent && pElementParent->Tag() == ETAG_SELECT)
            {
                hr = pElementParent->ScrollIntoView(spVert, spHorz);
            }
        }
        else
        { 
            CLayout *   pLayout;

            hr = THR(EnsureRecalcNotify());
            if (!hr)
            {           
                pLayout = GetUpdatedParentLayout();

                if (pLayout)
                {
                    hr = pLayout->ScrollElementIntoView(this, spVert, spHorz);
                }
            }
        }
    }

    return hr;
}

HRESULT DetectSiteState(CElement * pElement)
{
    CDoc *     pDoc = pElement->Doc();

    if (!pElement->IsInMarkup())
        return E_UNEXPECTED;

    if (pDoc->State() < OS_INPLACE ||
        pDoc->_fHidden == TRUE ||
        !pElement->IsVisible(TRUE) ||
        !pElement->IsEnabled())
        return CTL_E_CANTMOVEFOCUSTOCTRL;

    return S_OK;
}

STDMETHODIMP
CElement::setActive()
{
    CDoc *      pDoc = Doc();
    FOCUS_ITEM  fi;
    HRESULT hr = S_OK ;
    
    if ( ! pDoc->_pInPlace )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    if (ETAG_AREA == Tag())
    {
        fi = DYNCAST(CAreaElement, this)->GetFocusItem();
        if (!fi.pElement)
            goto Cleanup;
    }
    else
    {
        fi.pElement = this;
        fi.lSubDivision = 0;
    }

    if (    !(pDoc->_pElemCurrent == fi.pElement && pDoc->_lSubCurrent == fi.lSubDivision)
        &&  fi.pElement->IsFocussable(fi.lSubDivision))
    {
        hr = fi.pElement->BecomeCurrent(fi.lSubDivision,
                                        /* pfYieldFailed        */  NULL,
                                        /* pMessage             */  NULL,
                                        /* fTakeFocus           */  FALSE,
                                        /* lButton              */  0,
                                        /* pfDisallowedByEd     */  NULL,
                                        /* fFireFocusBlurEvents */  FALSE);
    }
    
Cleanup:
    if (S_OK == hr && this != pDoc->_pElemCurrent)
    {
        hr = S_FALSE;
    }
    RRETURN1(SetErrorInfo(hr), S_FALSE);
}

STDMETHODIMP
CElement::focus()
{
    RRETURN(THR(
        (ETAG_AREA == Tag())?
                DYNCAST(CAreaElement, this)->focus()
            :   focusHelper(0)
    ));
}


HRESULT
CElement::focusHelper(long lSubDivision)
{
    HRESULT     hr              = S_OK;
    CDoc *      pDoc        = Doc();
    BOOL        fTakeFocus;

    // TODO(sramani): Hack for IE5 bug# 56032. Don't allow focus() calls on
    // hidden elements in outlook98 organize pane to return an error.

    if (!_tcsicmp(pDoc->GetPrimaryUrl(), _T("outday://")) && !IsVisible(TRUE))
        goto Cleanup;

    // bail out if the site has been detached, or the doc is not yet inplace, etc.
    hr = THR(DetectSiteState(this));
    if (hr)
        goto Cleanup;

    // if called on body, delegate to the window
    if (Tag() == ETAG_BODY)
    {
        if (IsInMarkup())
        {
            CMarkup *   pMarkup = GetMarkup();
            if (pMarkup->HasWindow())
            {
                hr = THR(pMarkup->Window()->focus());
                if (hr)
                    goto Cleanup;
            }
        }
        goto Cleanup;
    }

    if (!IsFocussable(lSubDivision))
        goto Cleanup;

    // if our thread does not have any active windows, make ourselves the foreground window
    // (above all other top-level windows) only if the current foreground is a browser window
    // else make ourselves come above the topmost browser window if any, else do nothing.
    fTakeFocus = pDoc->_pInPlace && !MakeThisTopBrowserInProcess(pDoc->_pInPlace->_hwnd);

    pDoc->_fFirstTimeTab = FALSE;

    hr = BecomeCurrent(lSubDivision, NULL, NULL, fTakeFocus);
    if (hr)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR(EnsureRecalcNotify());
    if (hr)
        goto Cleanup;

    IGNORE_HR(ScrollIntoView(SP_MINIMAL, SP_MINIMAL));

    hr = THR(BecomeUIActive());

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


STDMETHODIMP
CElement::blur()
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = Doc();

    if (ETAG_AREA == Tag())
    {
        hr = THR(DYNCAST(CAreaElement, this)->blur());
        goto Cleanup;
    }

    if (!IsInMarkup())
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // if called on body, delegate to the window
    if (Tag() == ETAG_BODY)
    {
        if (IsInMarkup())
        {
            CMarkup *   pMarkup = GetMarkup();
            if (pMarkup->HasWindow())
            {
                hr = THR(pMarkup->Window()->blur());
                if (hr)
                    goto Cleanup;
            }
        }
        goto Cleanup;
    }

    // Don't blur current object in focus if called on
    // another object that does not have the focus or if the
    // frame in which this object is does not currently have the focus
    if (    this != pDoc->_pElemCurrent 
        ||  (       (::GetFocus() != pDoc->_pInPlace->_hwnd)
                &&  Tag() != ETAG_SELECT))
        goto Cleanup;

    hr = THR(GetMarkup()->GetElementTop()->BecomeCurrent(0));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::addFilter(IUnknown *pUnk)
{
    HRESULT hr = E_NOTIMPL;
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::removeFilter(IUnknown *pUnk)
{
    HRESULT hr = E_NOTIMPL;
    RRETURN(SetErrorInfo(hr));
}

BOOL
CElement::HasVerticalLayoutFlow()
{
    BOOL fVert = FALSE;

    if (   GetMarkup()
        && GetMarkup()->_fHaveDifferingLayoutFlows)
    {
        CTreeNode * pNode = GetFirstBranch();

        if (pNode)
        {
            const CCharFormat  * pCF = pNode->GetCharFormat();
            if (pCF)
                fVert = pCF->HasVerticalLayoutFlow();
        }
    }
    return fVert;
}

//+----------------------------------------------------------
//
//  member  :   get_clientWidth, IHTMLControlElement
//
//  synopsis    :   returns a long value of the client window
//      width (not counting scrollbar, borders..)
//
//-----------------------------------------------------------

HRESULT
CElement::get_clientWidth( long * pl)
{
    if (!HasVerticalLayoutFlow())
    {
        return get_clientWidth_Logical(pl);
    }
    else 
    {
        return get_clientHeight_Logical(pl);
    }
}

HRESULT CElement::get_clientWidth_Logical( long * pl)
{
    HRESULT hr = S_OK;

    if (!pl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pl = 0;

    if (IsInMarkup() && Doc()->GetView()->IsActive())
    {
        hr = THR(EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        CLayout * pLayout;
        pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

        if(pLayout)
        {
            RECT    rect;
            const CUnitInfo *pUnitInfo = &g_uiDisplay;

            // TR's are strange beasts since they have layout but
            // no display (unless they are positioned....
            if (Tag() == ETAG_TR)
            {
                CDispNode * pDispNode = pLayout->GetElementDispNode();
                if (!pDispNode)
                {
                    // we don't have a display so GetClientRect will return 0
                    // so rather than this, default to the offsetWidth.  This
                    // is the same behavior as scrollWidth
                    hr = get_offsetWidth(pl);
                    goto Cleanup;
                }
            }

            pLayout->GetClientRect(&rect, CLIENTRECT_CONTENT);

            *pl = rect.right - rect.left;

            //
            // but wait, if we are in a media resolution measurement, the value returned is in 
            // a different metric, so we need to untransform it before returning this to the OM call.
            //
            CLayoutContext *pContext  = (pLayout) 
                            ? (pLayout->LayoutContext()) 
                                    ? pLayout->LayoutContext() 
                                    : pLayout->DefinedLayoutContext() 
                            : NULL;

            if (   pContext 
                && pContext->GetMedia() != mediaTypeNotSet)
            {
               const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                        pContext->GetMedia());

               pUnitInfo = pdiTemp->GetUnitInfo();
            }

            *pl = pUnitInfo->DocPixelsFromDeviceX(*pl);
        }
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------
//
//  member  :   get_clientHeight, IHTMLControlElement
//
//  synopsis    :   returns a long value of the client window
//      Height of the body
//
//-----------------------------------------------------------

HRESULT
CElement::get_clientHeight( long * pl)
{
    if (!HasVerticalLayoutFlow())
    {
        return get_clientHeight_Logical(pl);
    }
    else 
    {
        return get_clientWidth_Logical(pl);
    }
}

HRESULT
CElement::get_clientHeight_Logical( long * pl)
{
    HRESULT hr = S_OK;

    if (!pl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pl = 0;

    if (IsInMarkup() && Doc()->GetView()->IsActive())
    {
        hr = THR(EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        CLayout * pLayout;
        pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

        if(pLayout)
        {
            RECT    rect;
            const   CUnitInfo *pUnitInfo = &g_uiDisplay;

            // TR's are strange beasts since they have layout but
            // no display (unless they are positioned....
            if (Tag() == ETAG_TR)
            {
                CDispNode * pDispNode = pLayout->GetElementDispNode();
                if (!pDispNode)
                {
                    // we don't have a display so GetClientRect will return 0
                    // so rather than this, default to the offsetHeight. This
                    // is the same behavior as scrollHeight
                    hr = get_offsetHeight(pl);
                    goto Cleanup;
                }
            }

            pLayout->GetClientRect(&rect, CLIENTRECT_CONTENT);

            *pl = rect.bottom - rect.top;
            //
            // but wait, if we are in a media resolution measurement, the value returned is in 
            // a different metric, so we need to untransform it before returning this to the OM call.
            //
            CLayoutContext *pContext  = (pLayout) 
                            ? (pLayout->LayoutContext()) 
                                    ? pLayout->LayoutContext() 
                                    : pLayout->DefinedLayoutContext() 
                            : NULL;

            if (   pContext 
                && pContext->GetMedia() != mediaTypeNotSet)
            {
               const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                        pContext->GetMedia());
               pUnitInfo = pdiTemp->GetUnitInfo();
            }

            *pl = pUnitInfo->DocPixelsFromDeviceY(*pl);
        }
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------
//
//  member  :   get_clientTop, IHTMLControlElement
//
//  synopsis    :   returns a long value of the client window
//      Top (inside borders)
//
//-----------------------------------------------------------
HRESULT
CElement::get_clientTop( long * pl)
{
    if (!HasVerticalLayoutFlow())
    {
        return get_clientTop_Logical(pl);
    }
    else 
    {
        return get_clientLeft_Logical(pl);
    }
}


//+----------------------------------------------------------
//
//  member  :   get_clientTop_Logical
//
//  synopsis    :   returns a long value of the client window
//      Top (inside borders)
//
//-----------------------------------------------------------

HRESULT
CElement::get_clientTop_Logical( long * pl)
{
    HRESULT     hr = S_OK;

    if (!pl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pl = 0;

    if (IsInMarkup() && Doc()->GetView()->IsActive())
    {
        CLayout *   pLayout;

        hr = THR(EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);
        if (pLayout)
        {
            CDispNode * pDispNode= pLayout->GetElementDispNode();

            if (pDispNode)
            {
                CRect rcBorders;
                const CUnitInfo *pUnitInfo = &g_uiDisplay;

                pDispNode->GetBorderWidths(&rcBorders);

                *pl = rcBorders.top;

                //
                // but wait, if we are in a media resolution measurement, the value returned is in 
                // a different metric, so we need to untransform it before returning this to the OM call.
                //
                CLayoutContext *pContext  = (pLayout) 
                                ? (pLayout->LayoutContext()) 
                                        ? pLayout->LayoutContext() 
                                        : pLayout->DefinedLayoutContext() 
                                : NULL;

                if (   pContext 
                    && pContext->GetMedia() != mediaTypeNotSet)
                {
                   const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                            pContext->GetMedia());

                   pUnitInfo = pdiTemp->GetUnitInfo();
                }

                *pl = pUnitInfo->DocPixelsFromDeviceY(*pl);
            }
        }
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------
//
//  member  :   get_clientLeft, IHTMLControlElement
//
//  synopsis    :   returns a long value of the client window
//      Left (inside borders)
//
//-----------------------------------------------------------

HRESULT
CElement::get_clientLeft( long * pl)
{
    if (!HasVerticalLayoutFlow())
    {
        return get_clientLeft_Logical(pl);
    }
    else 
    {
        return get_clientBottom_Logical(pl);
    }
}

//+----------------------------------------------------------
//
//  member  :   get_clientLeft_Logical
//
//  synopsis    :   returns a long value of the client window
//      Left (inside borders)
//
//-----------------------------------------------------------

HRESULT
CElement::get_clientLeft_Logical( long * pl)
{
    HRESULT     hr = S_OK;

    if (!pl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pl = 0;

    if (IsInMarkup() && Doc()->GetView()->IsActive())
    {
        CLayout *   pLayout;

        hr = THR(EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        pLayout   = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

        if (pLayout)
        {
            CDispNode * pDispNode= pLayout->GetElementDispNode();

            if (pDispNode)
            {
                // border and scroll widths are dynamic. This method
                // provides a good way to get the client left amount
                // without having to have special knowledge of the
                // display tree workings. We are getting the distance
                // between the top left of the client rect and the
                // top left of the container rect.
                CRect rcClient;
                pLayout->GetClientRect(&rcClient);
                CPoint pt;
                const CUnitInfo *pUnitInfo = &g_uiDisplay;

                pDispNode->TransformPoint(rcClient.TopLeft(), COORDSYS_FLOWCONTENT, &pt, COORDSYS_BOX);

                *pl = pt.x;

                //
                // but wait, if we are in a media resolution measurement, the value returned is in 
                // a different metric, so we need to untransform it before returning this to the OM call.
                //
                CLayoutContext *pContext  = (pLayout) 
                                ? (pLayout->LayoutContext()) 
                                        ? pLayout->LayoutContext() 
                                        : pLayout->DefinedLayoutContext() 
                                : NULL;

                if (   pContext 
                    && pContext->GetMedia() != mediaTypeNotSet)
                {
                   const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                            pContext->GetMedia());

                   pUnitInfo = pdiTemp->GetUnitInfo();
                }

                *pl = pUnitInfo->DocPixelsFromDeviceX(*pl);
            }
        }
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------
//
//  member  :   get_clientBottom_Logical
//
//  synopsis    :   returns a long value of the client window
//      Bottom (inside borders)
//
//-----------------------------------------------------------

HRESULT
CElement::get_clientBottom_Logical( long * pl)
{
    HRESULT     hr = S_OK;

    if (!pl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pl = 0;

    if (IsInMarkup() && Doc()->GetView()->IsActive())
    {
        CLayout *   pLayout;

        hr = THR(EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        pLayout   = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

        if (pLayout)
        {
            CDispNode * pDispNode= pLayout->GetElementDispNode();

            if (pDispNode)
            {
                // border and scroll widths are dynamic. This method
                // provides a good way to get the client left amount
                // without having to have special knowledge of the
                // display tree workings. We are getting the distance
                // between the top left of the client rect and the
                // top left of the container rect.
                CRect rcClient;
                pLayout->GetClientRect(&rcClient);
                CPoint pt;
                CSize sz;
                
                pDispNode->TransformPoint(rcClient.BottomRight(), COORDSYS_FLOWCONTENT, &pt, COORDSYS_BOX);
                sz = pDispNode->GetSize();
                *pl = sz.cy - pt.y;

                //
                // but wait, if we are in a media resolution measurement, the value returned is in 
                // a different metric, so we need to untransform it before returning this to the OM call.
                //
                CLayoutContext *pContext  = (pLayout) 
                                ? (pLayout->LayoutContext()) 
                                        ? pLayout->LayoutContext() 
                                        : pLayout->DefinedLayoutContext() 
                                : NULL;

                if (   pContext 
                    && pContext->GetMedia() != mediaTypeNotSet)
                {
                   const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                            pContext->GetMedia());

                    *pl = pdiTemp->DocPixelsFromDeviceY(*pl);
                }
            }
        }
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::SetDefaultElem
//
//  Synopsis:   Set the default element
//  Parameters:
//              fFindNew = TRUE: we need to find a new one
//                       = FALSE: set itself to be the default if appropriate
//
//-------------------------------------------------------------------------
void
CElement::SetDefaultElem(BOOL fFindNew /* FALSE */)
{
    CFormElement    * pForm = GetParentForm();
    CElement        **ppElem;
    CDoc            * pDoc  = Doc();

    ppElem = pForm ? &pForm->_pElemDefault : &pDoc->_pElemDefault;

    Assert(TestClassFlag(ELEMENTDESC_DEFAULT));
    if (fFindNew)
    {
        // Only find the new when the current is the default and
        // the document is not deactivating
        *ppElem = (*ppElem == this
                    && pDoc->_pInPlace
                    && !pDoc->_pInPlace->_fDeactivating) ?
                                    FindDefaultElem(TRUE, TRUE) : 0;
        Assert(*ppElem != this);
    }
    else if (!*ppElem || (*ppElem)->GetSourceIndex() > GetSourceIndex())
    {
                if (IsEnabled() && IsVisible(TRUE))
        {
            *ppElem = this;
        }
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::FindDefaultElem
//
//  Synopsis:   Find the default element
//
//-------------------------------------------------------------------------

CElement *
CElement::FindDefaultElem(BOOL fDefault,
                          BOOL fFull    /* = FALSE */)
{
    CElement        * pElem = NULL;
    CFormElement    * pForm = NULL;
    CDoc *            pDoc = Doc();

    if (!pDoc || !pDoc->_pInPlace || pDoc->_pInPlace->_fDeactivating)
        return NULL;

    if (!fFull && (fDefault ? _fDefault : FALSE))
        return this;

    pForm = GetParentForm();

    if (pForm)
    {
        if (fFull)
        {
            pElem = pForm->FindDefaultElem(fDefault, FALSE);
            if (fDefault)
            {
                pForm->_pElemDefault = pElem;
            }
        }
        else
        {
            Assert(fDefault);
            pElem = pForm->_pElemDefault;
        }
    }
    else
    {
        if (fFull)
        {
            pElem = GetMarkup()->FindDefaultElem(fDefault, FALSE);
            if (fDefault)
            {
                pDoc->_pElemDefault = pElem;
            }
        }
        else
        {
            Assert(fDefault);
            pElem = pDoc->_pElemDefault;
        }
    }

    return pElem;
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::get_uniqueNumber
//
//  Synopsis:   Compute a unique ID of the element regardless of the id
//              or name property (these could be non-unique on our page).
//              This function guarantees a unique name which will not change
//              for the life of this document.
//
//-------------------------------------------------------------------------

HRESULT
CElement::get_uniqueNumber(long *plUniqueNumber)
{
    HRESULT     hr = S_OK;
    CStr        cstrUniqueName;
    TCHAR      *pFoundStr;

    hr = THR(GetUniqueIdentifier(&cstrUniqueName, TRUE));
    if (hr)
        goto Cleanup;

    pFoundStr = StrStr(cstrUniqueName, UNIQUE_NAME_PREFIX);
    if (pFoundStr)
    {
        pFoundStr += lstrlenW(UNIQUE_NAME_PREFIX);

        if (ttol_with_error(pFoundStr, plUniqueNumber))
        {
            *plUniqueNumber = 0;            // Unknown number.
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::get_uniqueID
//
//  Synopsis:   Compute a unique ID of the element regardless of the id
//              or name property (these could be non-unique on our page).
//              This function guarantees a unique name which will not change
//              for the life of this document.
//
//-------------------------------------------------------------------------

HRESULT
CElement::get_uniqueID(BSTR * pUniqueStr)
{
    HRESULT     hr = S_OK;
    CStr        cstrUniqueName;

    hr = THR(GetUniqueIdentifier(&cstrUniqueName, TRUE));
    if (hr)
        goto Cleanup;

    hr = cstrUniqueName.AllocBSTR(pUniqueStr);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+-------------------------------------------------------------------------
//
//  Method:     CElement::NoUIActivate
//
//  Synopsis:   Determines if this site does not allow UIActivation
//
//  Arguments:  none
//
//--------------------------------------------------------------------------
BOOL
CElement::NoUIActivate()
{
    return (    _fNoUIActivate
            || (    IsEditable(/*fCheckContainerOnly*/TRUE)
                &&  _fNoUIActivateInDesign));
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::GetSubDivisionCount
//
//  Synopsis:   Get the count of subdivisions for this element
//
//-------------------------------------------------------------------------

HRESULT
CElement::GetSubDivisionCount(long *pc)
{
    HRESULT                 hr = S_OK;
    HRESULT                 hr2;
    ISubDivisionProvider *  pProvider = NULL;

    *pc = 0;
    if (HasPeerHolder())
    {
        CPeerHolder *pHolder = GetPeerHolder();

        if (pHolder->_pPeerUI)
        {
            hr2 = THR(pHolder->_pPeerUI->GetSubDivisionProvider(&pProvider));
            if (hr2)
            {
                // if this failed - e.g. peer does not implement subdivision provider, -
                // we still want to keep looking for next tab stop, so we supress the error here
                Assert (S_OK == hr);
                goto Cleanup;
            }

            hr = THR(pProvider->GetSubDivisionCount(pc));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::GetSubDivisionTabs
//
//  Synopsis:   Get the tabindices of subdivisions for this element
//
//-------------------------------------------------------------------------

HRESULT
CElement::GetSubDivisionTabs(long *pTabs, long c)
{
    HRESULT                 hr = S_OK;
    ISubDivisionProvider *  pProvider = NULL;

    if (HasPeerHolder())
    {
        CPeerHolder *pHolder = GetPeerHolder();

        if (pHolder->_pPeerUI)
        {
            hr = THR(pHolder->_pPeerUI->GetSubDivisionProvider(&pProvider));
            if (hr)
                goto Cleanup;

            hr = THR(pProvider->GetSubDivisionTabs(c, pTabs));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        Assert(c == 0);
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::SubDivisionFromPt
//
//  Synopsis:   Perform a hittest of subdivisions for this element
//
//-------------------------------------------------------------------------

HRESULT
CElement::SubDivisionFromPt(POINT pt, long *plSub)
{
    HRESULT                 hr = S_OK;
    ISubDivisionProvider *  pProvider = NULL;

    *plSub = 0;
    if (HasPeerHolder())
    {
        CPeerHolder *pHolder = GetPeerHolder();

        if (pHolder->_pPeerUI)
        {
            hr = THR_NOTRACE(pHolder->_pPeerUI->GetSubDivisionProvider(&pProvider));
            if (hr)
                goto Cleanup;

            hr = THR(pProvider->SubDivisionFromPt(pt, plSub));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetNextSubdivision
//
//  Synopsis:   Finds the next tabbable subdivision which has tabindex
//              == 0.  This is a helper meant to be used by SearchFocusTree.
//
//  Returns:    The next subdivision in plSubNext.  Set to -1, if there is no
//              such subdivision.
//
//  Notes:      lSubDivision coming in can be set to -1 to search for the
//              first possible subdivision.
//
//----------------------------------------------------------------------------

HRESULT
CElement::GetNextSubdivision(
    FOCUS_DIRECTION dir,
    long lSubDivision,
    long *plSubNext)
{
    HRESULT hr = S_OK;
    long    c;
    long *  pTabs = NULL;
    long    i;

    hr = THR(GetSubDivisionCount(&c));
    if (hr)
        goto Cleanup;

    if (!c)
    {
        *plSubNext = (lSubDivision == -1) ? 0 : -1;
        goto Cleanup;
    }

    pTabs = new (Mt(CElementGetNextSubDivision_pTabs)) long[c];
    if (!pTabs)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(GetSubDivisionTabs(pTabs, c));
    if (hr)
        goto Cleanup;

    if (lSubDivision < 0 && dir == DIRECTION_BACKWARD)
    {
        lSubDivision = c;
    }

    //
    // Search for the next subdivision if possible to tab to it.
    //

    for (i = (DIRECTION_FORWARD == dir) ? lSubDivision + 1 :  lSubDivision - 1;
         (DIRECTION_FORWARD == dir) ? i < c : i >= 0;
         (DIRECTION_FORWARD == dir) ? i++ : i--)
    {
        if (pTabs[i] == 0 || pTabs[i] == htmlTabIndexNotSet)
        {
            //
            // Found something to tab to! Return it.  We're
            // only checking for zero here because negative
            // tab indices means cannot tab to them.  Positive
            // ones would already have been put in the focus array
            //

            *plSubNext = i;
            goto Cleanup;
        }
    }

    //
    // To reach here means that there are no further tabbable
    // subdivisions in this element.
    //

    *plSubNext = -1;

Cleanup:
    delete [] pTabs;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::HasTabIndex
//
//  Synopsis:   Checks if this element already has a tabIndex
//
//----------------------------------------------------------------------------

BOOL
CElement::HasTabIndex()
{
    long    lCount;

    return (OK(GetSubDivisionCount(&lCount)) && 
            lCount == 0                      && 
            GetAAtabIndex() > 0               );
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::HasCurrency
//
//  Synopsis:   Checks if this element has currency. If this element is a slave,
//              check if its master has currency.
//
//  Notes:      Can't inline, because that would need including the defn of
//              CDoc in element.hxx.
//
//----------------------------------------------------------------------------

BOOL
CElement::HasCurrency()
{
    CElement * pElemCurrent = Doc()->_pElemCurrent;

    return (    this
            &&  pElemCurrent
            &&  (pElemCurrent == this || (HasMasterPtr() && pElemCurrent == GetMasterPtr())));
}

BOOL
CElement::IsInPrimaryMarkup() const
{
    CMarkup * pMarkup = GetMarkup();

    return pMarkup ? pMarkup->IsPrimaryMarkup() : FALSE;
}

BOOL
CElement::IsInThisMarkup ( CMarkup* pMarkupIn ) const
{
    CMarkup * pMarkup = GetMarkup();

    return pMarkup == pMarkupIn;
}

CRootElement *
CElement::MarkupRoot()
{
    CMarkup * pMarkup = GetMarkup();

    return (pMarkup ? pMarkup->Root() : NULL);
}


//+---------------------------------------------------------------------------
//
//  Member:     CElement::Init
//
//  Synopsis:   Do any element initialization here, called after the element is
//              created from CreateElement()
//
//----------------------------------------------------------------------------

HRESULT
CElement::Init()
{
    HRESULT hr;

    hr = THR( super::Init() );

    if (hr)
        goto Cleanup;

    //  CSite derived classes will overwrite this in their constructor.
    _fLayoutAlwaysValid = !!TestClassFlag(ELEMENTDESC_NOLAYOUT);

Cleanup:

    RRETURN( hr );
}

#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

// Assert and fix up layout context so that it doesn't mess up this element's layouts
void CElement::ValidateLayoutContextCore(CLayoutContext **ppLayoutContext) const
{
    CLayout *pLayoutOwner;
    CElement *pElementOwner;

    // We expect a valid pointer and a valid layout
    Assert(ppLayoutContext);
    if (IsFirstLayoutContext(*ppLayoutContext))
        return;

    Assert(!IsBadWritePtr(*ppLayoutContext, sizeof(CLayoutContext)));
    Assert((*ppLayoutContext)->IsValid());

    pLayoutOwner = (*ppLayoutContext)->GetLayoutOwner();   

    Assert(pLayoutOwner);
    Assert(!IsBadWritePtr(pLayoutOwner, sizeof(CLayout)));
    pElementOwner = pLayoutOwner->ElementOwner();
    
    Assert(pElementOwner);
    Assert(!IsBadWritePtr(pElementOwner, sizeof(CElement)));
    
    // VALID CASE: A child is trying to get parent layout with context passed by parent.
    //             If this is the context we define, change it to our containing context.
    if ((*ppLayoutContext)->GetLayoutOwner()->ElementOwner() == this)
    {
        // return containing context
        // TODO LRECT 112511: The intention of this method is to catch places where layout context is
        //                         incorrect. As a validator, it should be debug-only. If there is work it 
        //                         needs to do in retail, it should be split into retail and debug parts
        
        *ppLayoutContext = (*ppLayoutContext)->GetLayoutOwner()->LayoutContext();
        return;
    }
    
    // Check that this context is not from one of our children 
    {
        for (CElement *pElement = pElementOwner; pElement;)
        {
            // Do we see ourselves?
            if (pElement == this)
            {
                AssertSz(0, "Child layout context used on parent");
                goto Bad;
            }

            // get parent. go to master markup if necessary
            if (pElement->HasMasterPtr())
            {
                Assert(pElement != GetMasterPtr());
                pElement = GetMasterPtr();
            }
            else
            {
                CTreeNode *pNode = pElement->GetFirstBranch();
                if (pNode)
                    pNode = pNode->Parent();

                if (pNode)
                    pElement = pNode->Element();
                else
                    pElement = NULL;
            }

            // Do we see the context owner again?
            if (pElement == pElementOwner)
            {
                AssertSz(0, "Loop in layout contexts detected");
                goto Bad;
            }
        }
    }

    // More stuff can be verified here...
    return;
    
Bad:
    *ppLayoutContext = NULL;
}

#if DBG == 1
void CElement::AssertAppropriateLayoutContextInGetUpdatedLayout(CLayoutContext *pLayoutContext)
{
    if (IsFirstLayoutContext(pLayoutContext) 
        && !IsExplicitFirstLayoutContext(pLayoutContext)
        && HasLayoutAry()
        && GetLayoutAry()->Size() > 1)
    {
        // If we get here, we are a context-free call and we know we
        // are supposed to have at least 1 layout with context.  
        // This _may_ be a bug;
        // all such calls should be examined. There are cases where
        // the caller doesn't care about context; once it's been
        // determined that a particular caller legitimately isn't
        // passing context, that caller should be modified to pass
        // GUL_USEFIRSTLAYOUT, which is an explicit statement that
        // getting the first layout associated with the element is
        // good enough.

        // In retail we always just allow it silently.
        // In debug, we only allow it if GUL_USEFIRSTLAYOUT was
        // explicitly passed -- otherwise we assert, unless the
        // AllowGULBugs trace tag is on, in which case we log it.
        // Returning the first layout in our collection.
        if ( IsTagEnabled(tagLayoutAllowGULBugs) )
        {
            // In debug, log the fact that we allowed a buggy call
            TraceTag((tagLayoutAllowGULBugs, "GULBUG: Call to GetUpdatedLayout w/o context when required!"));
        }
        else
        {
            // We can only be here if in debug and the tag is off.
            Assert( FALSE && "GULBUG: Call to GetUpdatedLayout w/o context when required!" );
        }
    }
}
#endif

//
//  In the single layout case (null context):
//  If we already have a layout, this will return it whether we really need it or not.
//  This harmless cheat significantly speeds up calls to this function (though it may
//  result in a little extra work being done by people diddling with transient layouts).
//  Right now, this is a small perf win, esp. with tables.
//  If we really need to know if we need a layout, call ShouldHaveLayout .
//  In the multiple layout case (non-null context):
//  If we should have layout, we get it (creating it if necessary).
//  Otherwise we return NULL.
//
CLayout *
CElement::GetUpdatedLayoutWithContext( CLayoutContext *pLayoutContext )
{
    ValidateLayoutContext(&pLayoutContext);
    
    // Asking for the first available?
    if (IsFirstLayoutContext(pLayoutContext))
    {
        if ( HasLayoutPtr() )
        {
            // NOTE: GetUpdatedLayout handles this, but the context may be changed by ValidateLayoutContext
            return GetLayoutPtr();
        }

        if ( HasLayoutAry() )
        {
            AssertAppropriateLayoutContextInGetUpdatedLayout(pLayoutContext);
            return EnsureLayoutAry()->GetLayoutWithContext(NULL);
        }

        // Create a layout if we need one.
        // NOTE: we don't check this up-front, because it is an expensive check, involving format calculation
        if ( ShouldHaveLayout())
        {
            // No layouts exist so far. Search for default layout context.
            // CAUTION: this call forces layout creation for all layout parents
            CLayout *pLayout = EnsureLayoutInDefaultContext();

            // note: this assert goes after EnsureLayout, so that we know what kind of layout is there.
            AssertAppropriateLayoutContextInGetUpdatedLayout(pLayoutContext);
            return pLayout;
        }
        
        return NULL;
    }
    
    // Explicit multiple layout case (non-NULL layout context)
    
    // PERF: MAJOR potential perf problem here.  Really need to think about how to
    // make this efficient in face of lots of callers.  One problem is that it's unclear whether
    // checking for existing layout w/ context (which requires walking the collection) is cheaper
    // than asking whether the element needs layout (which may require format computation).

    if ( ShouldHaveLayout()) // TODO (t-michda) ShouldHaveLayout should be passed
                             // context, but I can't pass it a format context since
                             // CLayoutContext::GetFormatContext won't compile here...
    {
        CLayout *pLayout = EnsureLayoutAry()->GetLayoutWithContext( pLayoutContext );
        return ( pLayout ? pLayout : CreateLayout( pLayoutContext ) );
    }
    return NULL;
}


//
// Create layout in default context. 
// Ensures that all layout parents have layouts.
//
CLayout * 
CElement::EnsureLayoutInDefaultContext()
{
    Assert(ShouldHaveLayout()); // This really shouldn't be caled if element doesn't need a layout

    // first, see if we have a valid layout
    if (CurrentlyHasAnyLayout())
    {
        Assert(GetUpdatedLayout(GUL_USEFIRSTLAYOUT));        
        return GetUpdatedLayout(GUL_USEFIRSTLAYOUT);
    }
    
    // OK, we don't have any layout yet. Find layout parent to get context from them.
    // This should go up the master chain if needed (see assert below).
    CElement * pParent = GetUpdatedParentLayoutElement();   // if there is a parent layout element, go there
    Assert(!HasMasterPtr() || pParent == GetMasterPtr());

    CLayoutContext *pLayoutContext = NULL;

    // If we have a parent, recursively ensure its default layout and get context from it.
    // Otherwise we are the root, and we'll create a layout with NULL context
    if (pParent)
    {
        // Recursively call the parent.
        // NOTE: we'll be in trouble here if we fail to detect cycles
        CLayout *pParentDefaultLayout = pParent->EnsureLayoutInDefaultContext();
        
        Assert(pParentDefaultLayout);
        if (pParentDefaultLayout->HasDefinedLayoutContext())
            pLayoutContext = pParentDefaultLayout->DefinedLayoutContext();
        else
            pLayoutContext = pParentDefaultLayout->LayoutContext();
    }
    AssertValidLayoutContext(pLayoutContext);

    // Now create a layout with this context
    return CreateLayout( pLayoutContext );
}

CLayoutAry *
CElement::EnsureLayoutAry()
{
    CLayoutAry *pLA;
    
    if ( HasLayoutAry() )
    {
        pLA = (CLayoutAry*)_pLayoutInfo;
        Assert( _pLayoutAryDbg == pLA );
    }
    else
    {
        // Need to instantiate a layout array and hook it up to the __pvChain. 

        // If we already have a layout, we need to get rid of it.  We can't make use
        // of it anymore because it was created w/o context (for speed/space reasons in the old world).
        if ( HasLayoutPtr() )
        {
            // TODO LRECT 112511: Change this assert to only fire for actual bugs.
            //                 We should be able to figure out when a layout should not be
            //                 removed, or when the old layout should not be there withoug a context.
            AssertSz( !IsTagEnabled(tagLayoutTrackMulti), "removing a layout in EnsureLayoutAry");

            // If we are deleting a layout which defines a context, we'll probably crash soon.
            // TODO LRECT 112511: we need to be more robust in regards to layout/layoutcontext lifetime
            AssertSz( !GetLayoutPtr()->HasDefinedLayoutContext(), "removing a layout with defined context in EnsureLayoutAry");
        
            CLayout * pLayout = DelLayoutPtr();

            if (Tag() == ETAG_TABLE)
            {
                WHEN_DBG(pLayout->_fSizeThis    = FALSE);
                WHEN_DBG(pLayout->_fForceLayout = FALSE);

                // In a case of table element we shouldn't delete layout but instead of this 
                // just save it into element as a table layout cache
                DYNCAST(CTable, this)->SetTableLayoutCache(DYNCAST(CTableLayout, pLayout));

                // (bug # 90460) restore markup pointer on layout cache
#if DBG ==1
                if ( _fHasMarkupPtr )
                {
                    pLayout->_pMarkupDbg = _pMarkupDbg;
                }
#endif
                pLayout->__pvChain = __pvChain;
                pLayout->_fHasMarkupPtr = _fHasMarkupPtr;
            }
            else if (Tag() == ETAG_TR)
            {
                // In a case of table row element we shouldn't delete layout but instead of this 
                // just save it into element as a table layout cache
                DYNCAST(CTableRow, this)->SetRowLayoutCache(DYNCAST(CTableRowLayout, pLayout));

                // (bug # 90460) restore markup pointer on layout cache
#if DBG ==1
                if ( _fHasMarkupPtr )
                {
                    pLayout->_pMarkupDbg = _pMarkupDbg;
                }
#endif
                pLayout->__pvChain = __pvChain;
                pLayout->_fHasMarkupPtr = _fHasMarkupPtr;
            }
            else
            {
                pLayout->Detach();
                pLayout->Release();
            }
        }

        Assert( !HasLayoutPtr() );

        pLA = new CLayoutAry( this );
        if ( !pLA )
        {
            goto Cleanup;
        }

        // Layout array's __pvChain behaves like a layout's; could point at
        // a markup or doc.
        pLA->__pvChain = __pvChain;
        _pLayoutInfo = pLA;

#if DBG ==1
        if ( _fHasMarkupPtr )
        {
            pLA->_pMarkupDbg = _pMarkupDbg;
        }
#endif
        pLA->_fHasMarkupPtr = _fHasMarkupPtr;
        
        WHEN_DBG(_pLayoutAryDbg = pLA);
        _fHasLayoutAry = TRUE;

    }

    
Cleanup:
    Assert( pLA && "Must have an array" );
    return pLA;
}

//+----------------------------------------------------------------
//
//  Memeber : DelLayoutAry
//
//  Synopsis : responsible for cleaning up the layout arrays and 
//      cached layouts under a number of situations.
//
//  Argument : fComplete - TRUE if alls layouts should be detached
//                       - FALSE if the ary should be detached, and the cache restored.
//
//-----------------------------------------------------------------
void
CElement::DelLayoutAry( BOOL fComplete /* == TRUE */)
{
    Assert( HasLayoutAry() );
    Assert( (CLayoutAry *)_pLayoutInfo == _pLayoutAryDbg );
    
    if (fComplete)
    {
        // If we are a table detach table cache first.
        // Note : order is important (CTable::TableLayoutCache() will be confused after 
        // layout array is destroyed!)
        if (Tag() == ETAG_TABLE)
        {
            CLayout *pLayout = DYNCAST(CTable, this)->TableLayoutCache();
            pLayout->Detach();
            pLayout->Release();
            DYNCAST(CTable, this)->SetTableLayoutCache(NULL);
        }
        // If we are a table row detach row cache first.
        // Note : order is important (CTableRow::RowLayoutCache() will be confused after 
        // layout array is destroyed!)
        else if (Tag() == ETAG_TR)
        {
            CLayout *pLayout = DYNCAST(CTableRow, this)->RowLayoutCache();
            pLayout->Detach();
            pLayout->Release();
            DYNCAST(CTableRow, this)->SetRowLayoutCache(NULL);
        }
    }

    // Detach layouts in the array.
    CLayoutAry * pLA = (CLayoutAry*)_pLayoutInfo;

    __pvChain = pLA->__pvChain;

    WHEN_DBG( _pLayoutAryDbg = NULL);
    _fHasLayoutAry = FALSE;

    if (HasMarkupPtr())
        pLA->DelMarkupPtr();
    delete pLA;

    if (!fComplete)
    {
        // at this point the layout Array is gone, but the cache remains.
        // we need to move the cache into the layoutPtr position
        if (Tag() == ETAG_TABLE)
        {
            CLayout *pLayout = DYNCAST(CTable, this)->TableLayoutCache();

            //  Before call to SetLayoutPtr delete markup ptr on cached layout if any
            //  (consistency with CElement::EnsureLayoutAry)
            if (pLayout->_fHasMarkupPtr)
                pLayout->DelMarkupPtr();

            SetLayoutPtr(pLayout);

            DYNCAST(CTable, this)->SetTableLayoutCache(NULL);
        }
        else if (Tag() == ETAG_TR)
        {
            CLayout *pLayout = DYNCAST(CTableRow, this)->RowLayoutCache();

            //  Before call to SetLayoutPtr delete markup ptr on cached layout if any
            //  (consistency with CElement::EnsureLayoutAry)
            if (pLayout->_fHasMarkupPtr)
                pLayout->DelMarkupPtr();

            SetLayoutPtr(pLayout);

            DYNCAST(CTableRow, this)->SetRowLayoutCache(NULL);
        }
    }
}

// TODO (KTam): Why aren't these implemented as virtuals on CLayoutInfo?
// (possible excuse: we may have done this before introducing CLayoutInfo)

BOOL
CElement::LayoutContainsRelative()
{
    if ( HasLayoutPtr() )
    {
        return GetLayoutPtr()->_fContainsRelative;
    }
    else if ( HasLayoutAry() )
    {
        return GetLayoutAry()->ContainsRelative();
    }
    return FALSE;
}

BOOL
CElement::LayoutGetEditableDirty()
{
    if ( HasLayoutPtr() )
    {
        return GetLayoutPtr()->_fEditableDirty;
    }
    else if ( HasLayoutAry() )
    {
        return GetLayoutAry()->GetEditableDirty();
    }
    return FALSE;
}

void
CElement::LayoutSetEditableDirty( BOOL fEditableDirty )
{
    if ( HasLayoutPtr() )
    {
        GetLayoutPtr()->_fEditableDirty = fEditableDirty;
    }
    else if ( HasLayoutAry() )
    {
        GetLayoutAry()->SetEditableDirty( fEditableDirty );
    }
}

void            
CElement::SetLayoutPtr( CLayout * pLayout )
{ 
    Assert( ! HasLayoutPtr() );
    Assert( ! pLayout->_fHasMarkupPtr );

    pLayout->__pvChain = __pvChain; 
    _pLayoutInfo = pLayout;

#if DBG ==1
    if ( _fHasMarkupPtr )
    {
        pLayout->_pMarkupDbg = _pMarkupDbg;
    }
#endif
    pLayout->_fHasMarkupPtr = _fHasMarkupPtr;

    WHEN_DBG(_pLayoutDbg = pLayout);
    _fHasLayoutPtr = TRUE;
}

CLayout *       
CElement::DelLayoutPtr()
{ 
    Assert( HasLayoutPtr() );

    Assert( (CLayout *) _pLayoutInfo == _pLayoutDbg );
    CLayout * pLayoutRet = (CLayout*)_pLayoutInfo;

    __pvChain = pLayoutRet->__pvChain;

    WHEN_DBG( _pLayoutDbg = NULL);
    _fHasLayoutPtr = FALSE;

    if (HasMarkupPtr())
        pLayoutRet->DelMarkupPtr();

    return pLayoutRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetMarkupPtr
//
//  Synopsis:   Get the markup pointer if any
//
//----------------------------------------------------------------------------
CMarkup *
CElement::GetMarkupPtr() const
{
    if (HasMarkupPtr())
    {
        void * pv = __pvChain;

        if (CurrentlyHasAnyLayout())
            pv = _pLayoutInfo->__pvChain;

        Assert( pv == _pMarkupDbg );
        return (CMarkup *)pv;
    }

    Assert( NULL == _pMarkupDbg );

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::SetMarkupPtr
//
//  Synopsis:   Set the markup pointer
//
//----------------------------------------------------------------------------
void
CElement::SetMarkupPtr( CMarkup * pMarkup )
{
    Assert( ! HasMarkupPtr() );
    Assert( pMarkup );

    if (CurrentlyHasAnyLayout())
    {
        Assert(     (HasLayoutPtr() &&  (CLayout *)_pLayoutInfo == _pLayoutDbg )
               ||   (HasLayoutAry() &&  (CLayoutAry *)_pLayoutInfo == _pLayoutAryDbg ));
        _pLayoutInfo->SetMarkupPtr(pMarkup);
    }
    else
    {
        Assert( pMarkup->Doc() == _pDocDbg );
        _pMarkup = pMarkup;
    }

    WHEN_DBG( _pMarkupDbg = pMarkup );
    _fHasMarkupPtr = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::DelMarkupPtr
//
//  Synopsis:   Remove the markup pointer
//
//----------------------------------------------------------------------------
void
CElement::DelMarkupPtr( )
{
    Assert( HasMarkupPtr() );

    if (CurrentlyHasAnyLayout())
    {
        Assert(     (HasLayoutPtr() &&  (CLayout *)_pLayoutInfo == _pLayoutDbg )
               ||   (HasLayoutAry() &&  (CLayoutAry *)_pLayoutInfo == _pLayoutAryDbg ));
        Assert(_pLayoutInfo->_pMarkup == _pMarkupDbg );
        _pLayoutInfo->DelMarkupPtr();
    }
    else
    {
        Assert( _pMarkup == _pMarkupDbg);
        _pDoc = _pMarkup->Doc();
    }

    WHEN_DBG( _pMarkupDbg = NULL );
    _fHasMarkupPtr = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetDocPtr
//
//  Synopsis:   Get the CDoc pointer
//
//----------------------------------------------------------------------------
CDoc *
CElement::GetDocPtr() const
{
    void *  pv = __pvChain;

    if (CurrentlyHasAnyLayout())
        pv = _pLayoutInfo->__pvChain;

    if (HasMarkupPtr())
        pv = ((CMarkup *)pv)->Doc();

    Assert( pv == _pDocDbg );

    return (CDoc*)pv;
}

#pragma optimize("", on)


//+------------------------------------------------------------------
//
//  Members: [get/put]_scroll[top/left] and get_scroll[height/width]
//
//  Synopsis : CElement members. _dp is in pixels.
//
//------------------------------------------------------------------

HRESULT
CElement::get_scrollHeight(long *plValue)
{
    HRESULT     hr = S_OK;

    if (!plValue)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plValue = 0;

    if (IsInMarkup())
    {
        CLayout *   pLayout;

        // make sure that current is calced
        hr = THR(EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

        if (pLayout)
        {
            const CUnitInfo *pUnitInfo = &g_uiDisplay;

            // If we are a scrolling parent then we do not want to get the actual size, rather
            // we want to get the size of scroll value -- that is to include any outlying
            // abspos'd elements.
            BOOL fActualSize = !IsScrollingParent() || pLayout->LayoutContext();
            *plValue = HasVerticalLayoutFlow() ? pLayout->GetContentWidth(fActualSize) : pLayout->GetContentHeight(fActualSize);

            //
            // but wait, if we are in a media resolution measurement, the value returned is in 
            // a different metric, so we need to untransform it before returning this to the OM call.
            //
            CLayoutContext *pContext  = (pLayout->LayoutContext()) 
                                            ? pLayout->LayoutContext() 
                                            : pLayout->DefinedLayoutContext();

            if (   pContext 
                && pContext->GetMedia() != mediaTypeNotSet)
            {
               const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                        pContext->GetMedia());

               pUnitInfo = pdiTemp->GetUnitInfo();
            }


            *plValue = HasVerticalLayoutFlow() 
                            ? pUnitInfo->DocPixelsFromDeviceX(*plValue)
                            : pUnitInfo->DocPixelsFromDeviceY(*plValue);
        }

        // we don't want to return a zero for the Height (only happens
        // when there is no content). so default to the offsetHeight
        if (!pLayout || *plValue==0)
        {
            // NOTE(SujalP): get_offsetHeight is already in physical coordinates, so no need to flip.
            // return the offsetWidth instead
            hr = THR(get_offsetHeight(plValue));
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_scrollWidth(long *plValue)
{
    HRESULT     hr = S_OK;

    if (!plValue)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plValue = 0;

    if (IsInMarkup())
    {
        CLayout *   pLayout;

        // make sure that current is calced
        hr = THR(EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

        if (pLayout)
        {
            const CUnitInfo *pUnitInfo = &g_uiDisplay;

            // If we are a scrolling parent then we do not want to get the actual size, rather
            // we want to get the size of scroll value -- that is to include any outlying
            // abspos'd elements.
            BOOL fActualSize = !IsScrollingParent() || pLayout->LayoutContext();
            *plValue = HasVerticalLayoutFlow() ? pLayout->GetContentHeight(fActualSize) : pLayout->GetContentWidth(fActualSize);

            //
            // but wait, if we are in a media resolution measurement, the value returned is in 
            // a different metric, so we need to untransform it before returning this to the OM call.
            //
            CLayoutContext *pContext  = (pLayout->LayoutContext()) 
                                            ? pLayout->LayoutContext() 
                                            : pLayout->DefinedLayoutContext();

            if (   pContext 
                && pContext->GetMedia() != mediaTypeNotSet)
            {
               const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                        pContext->GetMedia());

               pUnitInfo = pdiTemp->GetUnitInfo();
            }

            *plValue = HasVerticalLayoutFlow() 
                            ? pUnitInfo->DocPixelsFromDeviceY(*plValue)
                            : pUnitInfo->DocPixelsFromDeviceX(*plValue);
        }

        // we don't want to return a zero for teh width (only haoppens
        // when there is no content). so default to the offsetWidth
        if (!pLayout || *plValue==0)
        {
            // NOTE(SujalP): get_offsetWidth is already in physical coordinates, so no need to flip.
            // return the offsetWidth instead
            hr = THR(get_offsetWidth(plValue));
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_scrollTop(long *plValue)
{
    HRESULT     hr = S_OK;

     if (!plValue)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plValue = 0;

    if (IsInMarkup())
    {
        CLayout *   pLayout;
        CDispNode * pDispNode;

        hr = THR(EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

        if ( pLayout &&
            (pDispNode = pLayout->GetElementDispNode()) != NULL)
        {
            if (pDispNode->IsScroller())
            {
                CSize   sizeOffset;
                const   CUnitInfo *pUnitInfo = &g_uiDisplay;

                DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffset);

                //
                // but wait, if we are in a media resolution measurement, the value returned is in 
                // a different metric, so we need to untransform it before returning this to the OM call.
                //
                CLayoutContext *pContext  = (pLayout) 
                                ? (pLayout->LayoutContext()) 
                                        ? pLayout->LayoutContext() 
                                        : pLayout->DefinedLayoutContext() 
                                : NULL;

                *plValue = HasVerticalLayoutFlow() ? sizeOffset.cx : sizeOffset.cy;

                if (   pContext 
                    && pContext->GetMedia() != mediaTypeNotSet)
                {
                   const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                            pContext->GetMedia());

                   pUnitInfo = pdiTemp->GetUnitInfo();
                }
                *plValue = HasVerticalLayoutFlow() 
                            ? pUnitInfo->DocPixelsFromDeviceX(*plValue)
                            : pUnitInfo->DocPixelsFromDeviceY(*plValue);
            }
            else
            {
                // if this isn't a scrolling element, then the scrollTop must be 0
                // for IE4 compatability
                *plValue = 0;
            }
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_scrollLeft(long *plValue)
{
    HRESULT     hr = S_OK;

    if (!plValue)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plValue = 0;

    if (IsInMarkup())
    {
        CLayout    *pLayout;
        CDispNode  *pDispNode;

        hr = THR(EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

        if ( pLayout &&
            (pDispNode = pLayout->GetElementDispNode()) != NULL)
        {
            if (pDispNode->IsScroller())
            {
                CSize   sizeOffset;
                const   CUnitInfo *pUnitInfo = &g_uiDisplay;

                DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffset);

                if (!HasVerticalLayoutFlow())
                {
                    *plValue = sizeOffset.cx;
                }
                else
                {
                    CRect rcClient;
                    CSize size;
                            
                    pDispNode->GetClientRect(&rcClient, CLIENTRECT_CONTENT);
                    pLayout->GetContentSize(&size, FALSE);
                    *plValue = size.cy - rcClient.Height() - sizeOffset.cy;
                    Assert(*plValue >= 0);
                }

                CLayoutContext *pContext  = (pLayout->LayoutContext()) 
                                            ? pLayout->LayoutContext() 
                                            : pLayout->DefinedLayoutContext();

                if (   pContext 
                    && pContext->GetMedia() != mediaTypeNotSet)
                {
                   const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                            pContext->GetMedia());

                   pUnitInfo = pdiTemp->GetUnitInfo();
                }

                // NOTE: keep this insync wrt x,y with the test above
                *plValue = HasVerticalLayoutFlow() 
                            ? pUnitInfo->DocPixelsFromDeviceY(*plValue)
                            : pUnitInfo->DocPixelsFromDeviceX(*plValue);

            }
            else
            {
                // if this isn't a scrolling element, then the scrollTop must be 0
                // for IE4 compatability
                *plValue = 0;
            }
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CElement::put_scrollTop(long lPixels)
{
    if(!GetFirstBranch())
    {
        RRETURN(E_FAIL);
    }
    else
    {
        CLayout *   pLayout;
        CDispNode * pDispNode;

        // make sure that the element is calc'd
        if (S_OK != EnsureRecalcNotify())
            RRETURN(E_FAIL);

        pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

        pDispNode = pLayout
                        ? pLayout->GetElementDispNode()
                        : NULL;

        if (    pDispNode
            &&  pDispNode->IsScroller())
        {

            // the display tree uses negative numbers to indicate nochange,
            // but the OM uses negative nubers to mean scrollto the top.
            if (!HasVerticalLayoutFlow())
            {
                lPixels = g_uiDisplay.DeviceFromDocPixelsY(lPixels);
                pLayout->ScrollToY((lPixels <0) ? 0 : lPixels);
            }
            else
            {
                lPixels = g_uiDisplay.DeviceFromDocPixelsX(lPixels);
                pLayout->ScrollToX((lPixels <0) ? 0 : lPixels);
            }
        }
    }

    return S_OK;
}


HRESULT
CElement::put_scrollLeft(long lPixels)
{
    if(!GetFirstBranch())
    {
        RRETURN(E_FAIL);
    }
    else
    {
        CLayout *   pLayout;
        CDispNode * pDispNode;

        // make sure that the element is calc'd
        if (S_OK != EnsureRecalcNotify())
            RRETURN(E_FAIL);

        pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

        pDispNode = pLayout
                        ? pLayout->GetElementDispNode()
                        : NULL;

        if (    pDispNode
            &&  pDispNode->IsScroller())
        {
            if (!HasVerticalLayoutFlow())
            {
                lPixels = g_uiDisplay.DeviceFromDocPixelsX(lPixels);
                pLayout->ScrollToX((lPixels<0) ? 0 : lPixels );
            }
            else
            {
                CRect rcClient;
                CSize size;

                lPixels = g_uiDisplay.DeviceFromDocPixelsY(lPixels);

                pDispNode->GetClientRect(&rcClient, CLIENTRECT_CONTENT);
                pLayout->GetContentSize(&size, FALSE);
                lPixels = max(0l, lPixels);
                lPixels = min(lPixels, size.cy - rcClient.Height());
                lPixels = size.cy - rcClient.Height() - lPixels;
                Assert(lPixels >= 0);
                pLayout->ScrollToY(lPixels);
            }
        }
    }

    return S_OK;
}


//+-------------------------------------------------------------------------------
//
//  Member:     createControlRange
//
//  Synopsis:   Implementation of the automation interface method.
//              This creates a default structure range (CAutoTxtSiteRange) and
//              passes it back.
//
//+-------------------------------------------------------------------------------

HRESULT
CElement::createControlRange(IDispatch ** ppDisp)
{
    HRESULT             hr = E_INVALIDARG;
    CAutoTxtSiteRange * pControlRange = NULL;

    if (! ppDisp)
        goto Cleanup;

    if (! HasFlowLayout() )
    {
        hr = S_OK;
        goto Cleanup;
    }

    pControlRange = new CAutoTxtSiteRange(this);
    if (! pControlRange)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR( pControlRange->QueryInterface(IID_IDispatch, (void **) ppDisp) );
    pControlRange->Release();
    if (hr)
    {
        *ppDisp = NULL;
        goto Cleanup;
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}


//+-------------------------------------------------------------------------------
//
//  Member:     clearAttributes
//
//+-------------------------------------------------------------------------------

HRESULT
CElement::clearAttributes()
{
    HRESULT hr = S_OK;
    CAttrArray *pAA = *(GetAttrArray());
    CMergeAttributesUndo Undo( this );

    Undo.SetClearAttr( TRUE );
    Undo.SetWasNamed( _fIsNamed );

    if (pAA)
    {
        CAttrArray * pAttrUndo = NULL;
        BOOL fTreeSync;
        BOOL fCreateUndo = QueryCreateUndo( TRUE, FALSE, &fTreeSync );

        if( fTreeSync || fCreateUndo )
        {
            pAttrUndo = new CAttrArray();
            if( !pAttrUndo )
            {
                fTreeSync = fCreateUndo = FALSE;
            }
        }

        pAA->Clear(pAttrUndo);
        // TODO (sramani) for now call onpropchange here, even though it will be duplicated
        // again if someone calls clear immediately followed by mergeAttributes (effectively
        // to do a copy). Will revisit in RTM

/*
        // TODO(sramani) since ID is preserved by default, we will re-enable this in IE6
        // if\when optional param to nuke id is implemented.

        // If the element was named it's not anymore.
        if (_fIsNamed)
        {
            _fIsNamed = FALSE;
            // Inval all collections affected by a name change
                    DoElementNameChangeCollections();
        }
*/

        hr = THR(OnPropertyChange(DISPID_UNKNOWN, ELEMCHNG_REMEASUREINPARENT|ELEMCHNG_CLEARCACHES|ELEMCHNG_REMEASUREALLCONTENTS));
        if (hr)
            goto Cleanup;

        if( fTreeSync )
        {
            IGNORE_HR( LogAttrArray( NULL, pAttrUndo, NULL ) );
        }

        if( fCreateUndo )
        {
            Undo.SetAA( pAttrUndo );
        }
        else
        {
            delete pAttrUndo;
        }
    }

    IGNORE_HR(Undo.CreateAndSubmit());

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+--------------------------------------------------------------------------
//
//  member : ComputeExtraFormat
//
//  Synopsis : Uses a modified ComputeFomrats call to return requested
//              property. Only some of the properties can be returned this way.
//              if eCmpType is ComputeFormatsType_GetValue  only this element is searched
//              if eCmpType is ComputeFormatsType_GetInheritedValue this element
//                         and its ancestors are searched, till we meet a table cell
//              if eCmpType is ComputeFormatsType_GetInheritedIntoTableValue this element
//                         and its all ancestors are searched
//+---------------------------------------------------------------------------

HRESULT
CElement::ComputeExtraFormat(DISPID dispID,
                             COMPUTEFORMATSTYPE eCmpType,
                             CTreeNode * pTreeNode,
                             VARIANT *pVarReturn)
{
    BYTE            ab[sizeof(CFormatInfo)];
    CFormatInfo   * pInfo = (CFormatInfo *)ab;
    HRESULT         hr;

    Assert(pVarReturn);
    Assert(pTreeNode);
    Assert(eCmpType == ComputeFormatsType_GetValue || 
            eCmpType == ComputeFormatsType_GetInheritedValue || 
            eCmpType == ComputeFormatsType_GetInheritedIntoTableValue); 

    // Make sure that the formats are calculated
    pTreeNode->GetCharFormatIndex();
    pTreeNode->GetFancyFormatIndex();

    VariantInit(pVarReturn);

    // Set the special mode flag so that ComputeFormats does not use
    // cached info,
    pInfo->_eExtraValues = eCmpType;

    // Save the requested property dispID
    pInfo->_dispIDExtra = dispID;
    pInfo->_pvarExtraValue = pVarReturn;
    pInfo->_lRecursionDepth = 0;
    hr = THR(ComputeFormats(pInfo, pTreeNode));
    if (hr)
        goto Cleanup;

Cleanup:
    pInfo->Cleanup();

    RRETURN(hr);
}


//+-------------------------------------------------------------------------------
//
//  Memeber:    SetImeState
//
//  Synopsis:   Check imeMode to set state of IME.
//
//+-------------------------------------------------------------------------------
HRESULT
CElement::SetImeState()
{
    HRESULT hr = S_OK;

#ifndef NO_IME
    CDoc *          pDoc = Doc();
    Assert( pDoc->_pInPlace->_hwnd );
    HIMC            himc = ImmGetContext(pDoc->_pInPlace->_hwnd);
    styleImeMode    sty;
    BOOL            fSuccess;
    VARIANT         varValue;
    DWORD           dwConversion, dwSentence;
    UINT            nCodePage;
    
    if (!himc)
        goto Cleanup;

    hr = THR(ComputeExtraFormat(
        DISPID_A_IMEMODE,
        ComputeFormatsType_GetValue,
        GetUpdatedNearestLayoutNode(),
        &varValue));
    if(hr)
        goto Cleanup;
   
    sty = (((CVariant *)&varValue)->IsEmpty())
                            ? styleImeModeNotSet
                            : (styleImeMode) V_I4(&varValue);

    if( sty != styleImeModeNotSet )
    {

        nCodePage = GetKeyboardCodePage();
        
        fSuccess = ImmGetConversionStatus( himc, &dwConversion, &dwSentence );
        if( !fSuccess )
            goto Cleanup;

        switch (sty)
        {
            case styleImeModeActive:

                TraceTag((tagEdImm, "styleImeModeActive conv 0x%x, sent 0x%x", dwConversion, dwSentence));
                if (_JAPAN_CP == nCodePage)
                {
                    //
                    // We have to set open status to open and close japanese IMEs
                    // There are simply too many JPN IME conversion modes that 
                    // are very confusing and buggy. So we set open status instead. 
                    // Also, this seems to be the only way to switch on/off 
                    // direct input mode
                    //
                    fSuccess = ImmSetOpenStatus( himc, TRUE );           
                    if (!fSuccess)
                    {
                        AssertSz(FALSE, "IME Mode Active - Failed to open JPN IME");
                        goto Cleanup;
                    }
                }
                else
                {
                    dwConversion = IME_CMODE_NATIVE;  // Turn on IME
                    TraceTag((tagEdImm, "styleImeModeActive conv 0x%x, sent 0x%x", dwConversion, dwSentence));
                    
                    fSuccess = ImmSetConversionStatus(himc, dwConversion, dwSentence);
                    if( !fSuccess )
                    {
                        AssertSz(FALSE, "IME Mode Active -- Failed at set conversion status");
                        goto Cleanup;
                    }
                }
                break;

            case styleImeModeInactive:

                TraceTag((tagEdImm, "styleImeModeInactive conv 0x%x, sent 0x%x", dwConversion, dwSentence));
                //
                // TODO:
                //
                // GIME JPN cannot be set to IME_CMODE_ALPHANUMERIC
                // before it is closed. Otherwise it will have problem
                // activating. So we handle JPN specially.
                //
                // [zhenbinx]
                //
                // Japanese IME has a special mode for alphanumeric 
                // (half/full width ascii) We don't want to stay in 
                // half width ascii mode so we need to we need to set 
                // open status to off for direct input.
                //
                if (_JAPAN_CP == nCodePage)
                {
                    fSuccess = ImmSetOpenStatus( himc, FALSE );
                    
                    if (!fSuccess)
                        goto Cleanup;
                }
                else
                {
                    dwConversion = IME_CMODE_ALPHANUMERIC;   // Turn off IME 
                    
                    fSuccess = ImmSetConversionStatus(himc, dwConversion, dwSentence);
                    if (!fSuccess)
                    {
                        AssertSz(FALSE, "IME Mode InActive -- Failed at set conversion status");
                        goto Cleanup;
                    }
                
                }
                
                break;

            case styleImeModeDisabled:
                pDoc->_himcCache = ImmAssociateContext(pDoc->_pInPlace->_hwnd, NULL);

                break;

            default:
                break;
        }
    }

Cleanup:
#endif //ndef NO_IME
    RRETURN(hr);
}

//+-------------------------------------------------------------------------------
//
//  Member:     mergeAttributes
//
//+-------------------------------------------------------------------------------

HRESULT
CElement::mergeAttributes(IHTMLElement *pIHTMLElementMergeThis, VARIANT *pvarFlags)
{
    BOOL fPreserveID = (V_VT(pvarFlags) == VT_BOOL) ? V_BOOL(pvarFlags) : TRUE;
    RRETURN(SetErrorInfo(MergeAttributesInternal(pIHTMLElementMergeThis, !fPreserveID)));
}

HRESULT
CElement::mergeAttributes(IHTMLElement *pIHTMLElementMergeThis)
{
    RRETURN(SetErrorInfo(MergeAttributesInternal(pIHTMLElementMergeThis)));
}

HRESULT
CElement::MergeAttributesInternal(IHTMLElement *pIHTMLElementMergeThis, BOOL fCopyID)
{
    HRESULT hr = E_INVALIDARG;
    CElement *pSrcElement;

    if (!pIHTMLElementMergeThis)
        goto Cleanup;

    hr = THR(pIHTMLElementMergeThis->QueryInterface(CLSID_CElement, (void **)&pSrcElement));
    if (hr)
        goto Cleanup;

    hr = THR(MergeAttributes(pSrcElement, fCopyID));
    if (hr)
        goto Cleanup;

    hr = THR(OnPropertyChange(DISPID_UNKNOWN, ELEMCHNG_REMEASUREINPARENT|ELEMCHNG_CLEARCACHES|ELEMCHNG_REMEASUREALLCONTENTS));

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   GetBstrFromElement
//
//  Synopsis:   A helper for data binding, fetches the text of some Element.
//
//  Arguments:  [fHTML]     - does caller want HTML or plain text?
//              [pbstr]     - where to return the BSTR holding the contents
//
//  Returns:    S_OK if successful
//
//-----------------------------------------------------------------------------

HRESULT
CElement::GetBstrFromElement ( BOOL fHTML, BSTR * pbstr )
{
    HRESULT hr;

    *pbstr = NULL;

    if (fHTML)
    {
        //
        //  Go through the HTML saver
        //
        hr = GetText(pbstr, 0);
        if (hr)
            goto Cleanup;
    }
    else
    {
        //
        //  Grab the plaintext directly from the runs
        //
        CStr cstr;

        hr = GetPlainTextInScope(&cstr);
        if (hr)
            goto Cleanup;

        hr = cstr.AllocBSTR(pbstr);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Function:   EnsureInMarkup()
//
//  Synopsis:   Creates a private markup for the element, if it is
//                  outside any markup.
//
//
//  Returns:    S_OK if successful
//
//-----------------------------------------------------------------------------

HRESULT
CElement::EnsureInMarkup()
{
    HRESULT   hr = S_OK;

    if (!IsInMarkup())
    {
        Assert( !IsPassivated() );
        if( IsPassivating() )
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }

        hr = THR(Doc()->CreateMarkupWithElement(NULL, this));
        if (hr)
            goto Cleanup;

        WHEN_DBG( GetMarkupPtr()->_fEnsuredMarkupDbg = TRUE );
    }

    Assert(GetMarkup());

Cleanup:
    RRETURN(hr);
}

CElement *CElement::GetFocusBlurFireTarget(long lSubDiv)
{
    HRESULT hr;
    CElement *pElemFireTarget = this;

    if (Tag() == ETAG_IMG)
    {
        CAreaElement *pArea = NULL;
        CImgElement *pImg = DYNCAST(CImgElement, this);

        pImg->EnsureMap();
        if (!pImg->GetMap())
            goto Cleanup;

        Assert(lSubDiv >= 0);
        hr = THR(pImg->GetMap()->GetAreaContaining(lSubDiv, &pArea));
        if (hr)
            goto Cleanup;

        Assert(pArea);
        pElemFireTarget = pArea;
    }

Cleanup:
    return pElemFireTarget;
}


//+----------------------------------------------------------------------------
//  Member:     GetDefaultFocussability
//
//  Synopsis:   Returns the default focussability of this element.
//
//-----------------------------------------------------------------------------
FOCUSSABILITY
CElement::GetDefaultFocussability()
{
    switch (Tag())
    {
    // FOCUSSABILITY_TABBABLE
    // These need to be in the tab order by default

    case ETAG_A:
    case ETAG_BODY:
    case ETAG_BUTTON:
    case ETAG_EMBED:
    case ETAG_FRAME:
    case ETAG_IFRAME:
    case ETAG_IMG:
    case ETAG_INPUT:
    case ETAG_ISINDEX:
    case ETAG_OBJECT:
    case ETAG_SELECT:
    case ETAG_TEXTAREA:

        return FOCUSSABILITY_TABBABLE;


    // FOCUSSABILITY_FOCUSSABLE
    // Not recommended. Better have a good reason for each tag why
    // it it is focussable but not tabbable

    //  Don't tab to applet.  This is to fix ie4 bug 41206 where the
    //  VM cannot call using IOleControlSite correctly.  If we allow
    //  tabbing into the VM, we can never ever tab out due to this.
    //  (AnandRa 8/21/97)
    case ETAG_APPLET:

    // Should be MAYBE, but for IE4 compat (IE5 #63134)
    case ETAG_CAPTION:

    // special element
    case ETAG_DEFAULT:

    // Should be MAYBE, but for IE4 compat
    case ETAG_DIV:

    // Should be MAYBE, but for IE4 compat (IE5 63626)
    case ETAG_FIELDSET:

    // special element
    case ETAG_FRAMESET:

    // Should be MAYBE, but for IE4 compat (IE5 #62701)
    case ETAG_MARQUEE:

    // special element
    case ETAG_ROOT:

    // Should be MAYBE, but for IE4 compat
    case ETAG_SPAN:

    // Should be MAYBE, but for IE4 compat
    case ETAG_TABLE:    
    case ETAG_TD:

        return FOCUSSABILITY_FOCUSSABLE;


    // Any tag that can render/have renderable content (and does not appear in the above lists)

    case ETAG_ACRONYM:
    case ETAG_ADDRESS:
    case ETAG_B:
    case ETAG_BDO:
    case ETAG_BIG:
    case ETAG_BLINK:
    case ETAG_BLOCKQUOTE:
    case ETAG_CENTER:
    case ETAG_CITE:
    case ETAG_DD:
    case ETAG_DEL:
    case ETAG_DFN:
    case ETAG_DIR:
    case ETAG_DL:
    case ETAG_DT:
    case ETAG_EM:
    case ETAG_FONT:
    case ETAG_FORM:
    case ETAG_GENERIC:
    case ETAG_GENERIC_BUILTIN:
    case ETAG_GENERIC_LITERAL:
    case ETAG_H1:
    case ETAG_H2:
    case ETAG_H3:
    case ETAG_H4:
    case ETAG_H5:
    case ETAG_H6:
    case ETAG_HR:
    case ETAG_I:
    case ETAG_INS:
    case ETAG_KBD:

    // target is always focussable, label itself is not (unless forced by tabIndex) 
    case ETAG_LABEL:
    case ETAG_LEGEND:

    case ETAG_LI:
    case ETAG_LISTING:
    case ETAG_MENU:
    case ETAG_OL:
    case ETAG_P:
    case ETAG_PLAINTEXT:
    case ETAG_PRE:
    case ETAG_Q:
    //case ETAG_RB:
    case ETAG_RT:
    case ETAG_RUBY:
    case ETAG_S:
    case ETAG_SAMP:
    case ETAG_SMALL:
    case ETAG_STRIKE:
    case ETAG_STRONG:
    case ETAG_SUB:
    case ETAG_SUP:
    case ETAG_TBODY:
    case ETAG_TC:
    case ETAG_TFOOT:
    case ETAG_TH:
    case ETAG_THEAD:
    case ETAG_TR:
    case ETAG_TT:
    case ETAG_U:
    case ETAG_UL:
    case ETAG_VAR:
    case ETAG_XMP:

        return FOCUSSABILITY_MAYBE;

    // All the others - tags that do not ever render

    // this is a subdivision, never takes focus direcxtly
    case ETAG_AREA:
    
    case ETAG_BASE:
    case ETAG_BASEFONT:
    case ETAG_BGSOUND:
    case ETAG_BR:
    case ETAG_CODE:
    case ETAG_COL:
    case ETAG_COLGROUP:
    case ETAG_COMMENT:
    case ETAG_HEAD:
    case ETAG_LINK:
    case ETAG_MAP:
    case ETAG_META:
    case ETAG_NEXTID:
    case ETAG_NOBR:
    case ETAG_NOEMBED:
    case ETAG_NOFRAMES:
    case ETAG_NOSCRIPT:

    // May change in future when we re-implement SELECT
    case ETAG_OPTION:
    case ETAG_OPTGROUP:

    case ETAG_PARAM:
    case ETAG_RAW_BEGINFRAG:
    case ETAG_RAW_BEGINSEL:
    case ETAG_RAW_CODEPAGE:
    case ETAG_RAW_COMMENT:
    case ETAG_RAW_DOCSIZE:
    case ETAG_RAW_ENDFRAG:
    case ETAG_RAW_ENDSEL:
    case ETAG_RAW_EOF:
    case ETAG_RAW_SOURCE:
    case ETAG_RAW_TEXT:
    case ETAG_RAW_TEXTFRAG:
    case ETAG_SCRIPT:
    case ETAG_STYLE:
    case ETAG_TITLE_ELEMENT:
    case ETAG_TITLE_TAG:
    case ETAG_WBR:
    case ETAG_UNKNOWN:

        return FOCUSSABILITY_NEVER;

    // Special case: If CSS1+ doctype, the HTML needs to be focusable
    //               If backcompat mode, HTML is not focusable
    case ETAG_HTML:
        return (IsInMarkup() &&  GetMarkup()->IsHtmlLayout())
                ? FOCUSSABILITY_FOCUSSABLE
                : FOCUSSABILITY_NEVER;

    default:
        AssertSz(FALSE, "Focussability undefined for this tag");
        return FOCUSSABILITY_NEVER;
    }
}


BOOL
CElement::IsFocussable(long lSubDivision)
{
    // avoid visibilty and other checks for special elements
    if (Tag() == ETAG_ROOT || Tag() == ETAG_DEFAULT)
        return TRUE;

    CDoc      *pDoc      = Doc();
    CDefaults *pDefaults = GetDefaults();
    FOCUSSABILITY       fcDefault       = GetDefaultFocussability();

    if (pDefaults && pDefaults->GetAAtabStop())
    {
        fcDefault = FOCUSSABILITY_TABBABLE;
    }
    
    if (    fcDefault <= FOCUSSABILITY_NEVER
        ||  !IsInMarkup()
        ||  !IsEnabled()
        ||  !IsVisible(TRUE)
        ||  NoUIActivate()
        ||  !(this == GetMarkup()->GetCanvasElement() || GetUpdatedParentLayoutNode())
        ||  GetFirstBranch()->SearchBranchToRootForTag(ETAG_HEAD)
        ||  IsParentFrozen()
        ||  IsFrozen()
        ||  !IsInViewTree()
       )
    {
        return FALSE;
    }

    if ( fcDefault <= FOCUSSABILITY_MAYBE && IsParentEditable() )
    {
        if ( pDoc->IsElementUIActivatable( this ) )
            return TRUE;
    }


    //
    // If the element has contentEditable set to true, we can
    // set the focus
    //
    if( fcDefault == FOCUSSABILITY_MAYBE )
    {
        htmlEditable enumEditable;

        enumEditable = GetAAcontentEditable();

        if( (enumEditable == htmlEditableInherit) && pDefaults )
            enumEditable = pDefaults->GetAAcontentEditable();
     
        if( enumEditable == htmlEditableTrue )
            return TRUE;
    }

    if (!IsVisible(FALSE))
        return FALSE ;
           
    // do not  query for focussability if tabIndex is set.
    if (GetAAtabIndex() != htmlTabIndexNotSet)
        return TRUE;

    if (fcDefault < FOCUSSABILITY_FOCUSSABLE)
        return FALSE;

    // Hack for DIV and SPAN which want focus only they have a layout
    // I don't want to send them a queryfocussable because the hack is
    // more obvious here and we will try to get rid of it in IE6
    if ((Tag() == ETAG_DIV || Tag() == ETAG_SPAN) && !GetUpdatedLayout(GUL_USEFIRSTLAYOUT))
        return FALSE;

    BOOL fNotify = FALSE;

    // Send only to the listeners
    if (TestClassFlag(ELEMENTDESC_OLESITE))
    {
        fNotify = TRUE;
    }
    else
    {
        switch (Tag())
        {
        case ETAG_A:
        case ETAG_IMG:
        case ETAG_SELECT:
            fNotify = TRUE;
            break;
        }
    }
    if (fNotify)
    {
        CQueryFocus qf;

        qf._lSubDivision    = lSubDivision;
        qf._fRetVal         = TRUE;

        SendNotification(NTYPE_ELEMENT_QUERYFOCUSSABLE, &qf);
        return qf._fRetVal;
    }
    else
    {
        return TRUE;
    }
}


BOOL
CElement::IsTabbable(long lSubDivision)
{
    FOCUSSABILITY       fcDefault       = GetDefaultFocussability();
    BOOL                fDesignMode     = IsEditable(/*fCheckContainerOnly*/TRUE);
    CDefaults *         pDefaults       = GetDefaults();
    htmlEditable        enumEditable    = GetAAcontentEditable();
    
    if (pDefaults && pDefaults->GetAAtabStop())
    {
        fcDefault = FOCUSSABILITY_TABBABLE;
    }


    if (IsParentFrozen())
    {
        return FALSE;
    }

    if (fDesignMode)
    {
        // design-time tabbing checks for site-selectability

        // avoid visibilty and other checks for special elements
        if (Tag() == ETAG_ROOT || Tag() == ETAG_DEFAULT)
            return FALSE;

        if (!IsInMarkup() || !IsVisible(TRUE))
            return FALSE;
    }
    else
    {
        // browse-time tabbing checks for focussability
        if (!IsFocussable(lSubDivision))
            return FALSE;
    }

    long lTabIndex = GetAAtabIndex();

    // Specifying an explicit tabIndex overrides the rest of the checks
    if (!(Tag() == ETAG_INPUT
            && DYNCAST(CInput, this)->GetType() == htmlInputRadio)
        && lTabIndex != htmlTabIndexNotSet)
    {
        return (lTabIndex >= 0);
    }

    //
    // If the element has contentEditable set to true, we can
    // tab to this element.
    //
    if( (enumEditable == htmlEditableInherit) && pDefaults )
        enumEditable = pDefaults->GetAAcontentEditable();
 
    if( enumEditable == htmlEditableTrue )
        return TRUE;

    if (    fcDefault < FOCUSSABILITY_TABBABLE
         && !(fDesignMode && GetUpdatedLayout(GUL_USEFIRSTLAYOUT) && Doc()->IsElementSiteSelectable(this))
       )
    {      
        return FALSE;
    }

    BOOL fNotify = FALSE;

    // Send only to the listeners
    if (TestClassFlag(ELEMENTDESC_OLESITE))
    {
        fNotify = TRUE;
    }
    else
    {
        switch (Tag())
        {
        case ETAG_BODY:
        case ETAG_IMG:
        case ETAG_INPUT:
            fNotify = TRUE;
            break;
        }
    }
    if (fNotify)
    {
        CQueryFocus qf;

        qf._lSubDivision    = lSubDivision;
        qf._fRetVal         = TRUE;
        SendNotification(NTYPE_ELEMENT_QUERYTABBABLE, &qf);
        return qf._fRetVal;
    }
    else
    {
        return TRUE;
    }
}

BOOL
CElement::IsMasterTabStop()
{
    Assert(HasSlavePtr() && Tag() != ETAG_INPUT);

    switch (Tag())
    {
    case ETAG_FRAME:
        return FALSE;
        
    case ETAG_IFRAME:
        return IsParentEditable() ; // we want Iframes that are in editable regions to be "tab stops"

    default:
        {
            Assert(TagType() == ETAG_GENERIC);
            CDefaults * pDefaults = GetDefaults();
            return (!pDefaults || pDefaults->GetAAviewMasterTab());
        }
    }
}

HRESULT
CElement::PreBecomeCurrent(long lSubDivision, CMessage * pMessage)
{
    // Send only to the listeners
    if (TestClassFlag(ELEMENTDESC_OLESITE))
    {
        CSetFocus   sf;

        sf._pMessage        = pMessage;
        sf._lSubDivision    = lSubDivision;
        sf._hr              = S_OK;
        SendNotification(NTYPE_ELEMENT_SETTINGFOCUS, &sf);
        return sf._hr;
    }
    else
    {
        return S_OK;
    }
}


HRESULT
CElement::BecomeCurrentFailed(long lSubDivision, CMessage * pMessage)
{
    // Send only to the listeners
    if (TestClassFlag(ELEMENTDESC_OLESITE))
    {
        CSetFocus   sf;

        sf._pMessage        = pMessage;
        sf._lSubDivision    = lSubDivision;
        sf._hr              = S_OK;
        SendNotification(NTYPE_ELEMENT_SETFOCUSFAILED, &sf);
        return sf._hr;
    }
    else
    {
        return S_OK;
    }
}

HRESULT
CElement::PostBecomeCurrent(CMessage * pMessage, BOOL fTakeFocus)
{
    BOOL fNotify = FALSE;

    // Send only to the listeners
    if (TestClassFlag(ELEMENTDESC_OLESITE))
    {
        fNotify = TRUE;
    }
    else
    {
        switch (Tag())
        {
        case ETAG_A:
        case ETAG_BODY:
        case ETAG_BUTTON:
        case ETAG_IMG:
        case ETAG_INPUT:
        case ETAG_SELECT:
            fNotify = TRUE;
            break;
        }
    }
    if (fNotify)
    {
        CSetFocus   sf;

        sf._pMessage        = pMessage;
        sf._hr              = S_OK;
        sf._fTakeFocus      = fTakeFocus;
        SendNotification(NTYPE_ELEMENT_SETFOCUS, &sf);
        return sf._hr;
    }
    else
    {
        return S_OK;
    }
}

HRESULT
CElement::GotMnemonic(CMessage * pMessage)
{
    // Send only to the listeners
    switch (Tag())
    {
    case ETAG_FRAME:
    case ETAG_IFRAME:
    case ETAG_INPUT:
    case ETAG_TEXTAREA:
        {
            CSetFocus   sf;

            sf._pMessage    = pMessage;
            sf._hr          = S_OK;
            SendNotification(NTYPE_ELEMENT_GOTMNEMONIC, &sf);
            return sf._hr;
        }
    }
    return S_OK;
}


HRESULT
CElement::LostMnemonic()
{
    // Send only to the listeners
    switch (Tag())
    {
    case ETAG_INPUT:
    case ETAG_TEXTAREA:
        {
            CSetFocus   sf;

            sf._pMessage    = NULL;
            sf._hr          = S_OK;
            SendNotification(NTYPE_ELEMENT_LOSTMNEMONIC, &sf);
            return sf._hr;
        }
    }
    return S_OK;
}

FOCUS_ITEM
CElement::GetMnemonicTarget(long lSubDivision)
{
    BOOL        fNotify = FALSE;
    FOCUS_ITEM  fi;

    fi.pElement = this;
    fi.lSubDivision = lSubDivision;
    // fi.lTabIndex is unused

    // Send only to the listeners
    if (TestClassFlag(ELEMENTDESC_OLESITE))
    {
        fNotify = TRUE;
    }
    else
    {
        switch (Tag())
        {
        case ETAG_AREA:
        case ETAG_LABEL:
        case ETAG_LEGEND:
            fNotify = TRUE;
            break;
        }
    }
    if (fNotify)
    {
        SendNotification(NTYPE_ELEMENT_QUERYMNEMONICTARGET, &fi);
    }
    return fi;
}

HRESULT
CElement::get_tabIndex(short * puTabIndex)
{
    short tabIndex = GetAAtabIndex();

    *puTabIndex = (tabIndex == htmlTabIndexNotSet) ? 0 : tabIndex;
    return S_OK;
}

//+----------------------------------------------------------------------------
//  Member:     DestroyLayout
//
//  Synopsis:   Destroy the current layout attached to the element. This is
//              called from CFlowLayout::DoLayout to destroy the layout lazily
//              when an element loses layoutness.
//
//-----------------------------------------------------------------------------

void
CElement::DestroyLayout( CLayoutContext * pLayoutContext )
{
    AssertSz(CurrentlyHasAnyLayout() && !ShouldHaveLayout()
             // media change causes layout destruction on elements that still need them
             // TODO LRECT 112511: does it delete child layouts?
             || Tag() == ETAG_GENERIC && !FormsStringICmp(TagName(), _T("DEVICERECT")),
             "hold on! we still ned a layout here!");
    Assert(!_fLayoutAlwaysValid);

    CLayout  *  pLayout = GetLayoutPtr();
    if ( pLayout )
    {
        pLayout->ElementContent()->_fOwnsRuns = FALSE;

        Verify(Doc()->OpenView());
        Verify(pLayout == DelLayoutPtr());
    
        pLayout->Detach();
        pLayout->Release();
    }
    else
    {
        CLayoutAry *pLA = GetLayoutAry();
        if ( pLA )
        {
            delete pLA;
        }
    }
}

BOOL
CElement::IsOverlapped()
{
    CTreeNode *pNode = GetFirstBranch();

    return pNode && !pNode->IsLastBranch();
}

//+---------------------------------------------------------------------------
//
//  Method:     SetSurfaceFlags
//
//  Synopsis:   Set/clear the surface flags
//
//----------------------------------------------------------------------------
void
CElement::SetSurfaceFlags(BOOL fSurface, BOOL f3DSurface, BOOL fDontFilter )// = FALSE 
{
    //
    // f3DSurface is illegal without fSurface
    //
    Assert(!f3DSurface || fSurface);
    fSurface |= f3DSurface;

    // Normalize the BOOLs
    fSurface = !!fSurface;
    f3DSurface = !!f3DSurface;

    if (IsConnectedToPrimaryWindow())
    {
        if ((unsigned)fSurface != _fSurface)
        {
            if (fSurface)
                Doc()->_cSurface++;
            else
                Doc()->_cSurface--;
        }
        if ((unsigned)f3DSurface != _f3DSurface)
        {
            if (f3DSurface)
                Doc()->_c3DSurface++;
            else
                Doc()->_c3DSurface--;
        }
    }

    _fSurface = (unsigned)fSurface;
    _f3DSurface = (unsigned)f3DSurface;
}

//+---------------------------------------------------------------------------
//
//  Method:   HasInlineMBP
//
//  Synopsis: The function determines whether a an inline node contributes
//            any margins/borders/padding.
//
//  Return: BOOL
//
//----------------------------------------------------------------------------
BOOL
CTreeNode::HasInlineMBP(FORMAT_CONTEXT FCPARAM)
{
    if (   GetCharFormat(FCPARAM)->MayHaveInlineMBP()
        && !_fBlockNess // We have done a getcharformat which will refresh this bit if needed
        && !ShouldHaveLayout()
        && !Element()->HasFlag(TAGDESC_TEXTLESS)
       )
    {
        const CFancyFormat *pFF = GetFancyFormat(FCPARAM);
        BOOL fHasMBP;

        // We are checking all sides (top/bottom/left/right), so it doesn't matter if we get
        // logical or physical values. For performance we get physical.
        fHasMBP =    pFF->_bd.GetBorderStyle(SIDE_TOP) != fmBorderStyleNone
                  || pFF->_bd.GetBorderStyle(SIDE_RIGHT) != fmBorderStyleNone
                  || pFF->_bd.GetBorderStyle(SIDE_BOTTOM) != fmBorderStyleNone
                  || pFF->_bd.GetBorderStyle(SIDE_LEFT) != fmBorderStyleNone
                  || !pFF->GetMargin(SIDE_TOP).IsNull()
                  || !pFF->GetMargin(SIDE_BOTTOM).IsNull()
                  || !pFF->GetMargin(SIDE_LEFT).IsNull()
                  || !pFF->GetMargin(SIDE_RIGHT).IsNull()
                  || !pFF->GetPadding(SIDE_TOP).IsNull()
                  || !pFF->GetPadding(SIDE_BOTTOM).IsNull()
                  || !pFF->GetPadding(SIDE_LEFT).IsNull()
                  || !pFF->GetPadding(SIDE_RIGHT).IsNull();
                
        return fHasMBP;
    }
    else
        return FALSE;
}

BOOL
IsInlineBPNode(CCalcInfo *pci, CTreeNode *pNode, BOOL fTop)
{
    BOOL fHasBPParent;
    if (pNode->HasInlineMBP())
    {
        BOOL fJunk;
        CRect rc;
        pNode->GetInlineMBPContributions(pci, GIMBPC_BORDERONLY | GIMBPC_PADDINGONLY, &rc, &fJunk, &fJunk);
        fHasBPParent = fTop ? (rc.top != 0) : (rc.bottom != 0);
    }
    else
    {
        fHasBPParent = FALSE;
    }
    return fHasBPParent;
}

BOOL IsInlineTopBPNode   (CTreeNode * pNode, void *pvData) { return IsInlineBPNode((CCalcInfo *)pvData, pNode, TRUE);  }
BOOL IsInlineBottomBPNode(CTreeNode * pNode, void *pvData) { return IsInlineBPNode((CCalcInfo *)pvData, pNode, FALSE); }

BOOL
IsTableCellNode(CTreeNode * pNode)
{
    return !!pNode->Element()->TestClassFlag(CElement::ELEMENTDESC_TABLECELL);
}

BOOL
IsWidthNode(CTreeNode * pNode)
{
    const CFancyFormat * pFF     = pNode->GetFancyFormat();
    const CCharFormat  * pCF     = pNode->GetCharFormat();
    BOOL fVerticalLayoutFlow     = pCF->HasVerticalLayoutFlow();
    BOOL fWritingModeUsed        = pCF->_fWritingModeUsed;
    const CUnitValue & cuvWidth  = pFF->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);
    
    // If width specified, then we can stop
    return !cuvWidth.IsNullOrEnum();
}

BOOL IsDoublyNestedCell(CTreeNode *pCell)
{
    BOOL fDoublyNested = FALSE;
    Assert(pCell);
    Assert(pCell->Element()->TestClassFlag(CElement::ELEMENTDESC_TABLECELL));
    CTreeNode *pTable = pCell->GetMarkup()->SearchBranchForTagInStory(pCell, ETAG_TABLE);
    if (pTable)
    {
        fDoublyNested = !!pTable->GetMarkup()->SearchBranchForCriteriaInStory(pTable->Parent(), IsTableCellNode);
    }
    return fDoublyNested;
}

//+---------------------------------------------------------------------------
//
//  Method:     GetParentWidth
//
//  Synopsis:   This function computes the width of a parent when we have
//              % margins or % padding.
//
//  Return:     LONG: The width to be used to %age computations. Note its
//              NOT correct to use the return value for anything other than
//              %age computations.
//
//----------------------------------------------------------------------------
LONG
CTreeNode::GetParentWidth(CCalcInfo *pci, LONG xOriginalWidth)
{
    LONG xParentWidth = xOriginalWidth;
    
    // If we have any horz percent attr, then we need to find out if this node is parented by a
    // TD. The reason is that inside TD's, its impossible to compute widths of the % padding/margins
    // since those are a percent of the size of the TD, and in min-max mode we are computing
    // the size of the TD itself. Also, since we did not do it in min-max mode, we cannot suddenly come
    // up with a size in natural pass either.
    CTreeNode *pCell = GetMarkup()->SearchBranchForCriteriaInStory(this, IsTableCellNode);
    if (pCell)
    {
        // If it is, then find out if its parent by a node which has width specified on it
        // (that node could be the table itself). If so then it benefits us to use that
        // width in the %age computations.
        CTreeNode *pWidthNode = GetMarkup()->SearchBranchForCriteriaInStory(this, IsWidthNode);

        if (pWidthNode)
        {
            const CCharFormat *pCF = pWidthNode->GetCharFormat();
            const CFancyFormat *pFF = pWidthNode->GetFancyFormat();
            BOOL fVertical = pCF->HasVerticalLayoutFlow();
            BOOL fWritingModeUsed = pCF->_fWritingModeUsed;

            const CUnitValue & cuvWidth  = pFF->GetLogicalWidth(fVertical, fWritingModeUsed);

            // If the element with width itself has %age width, then there is nothing we can do
            if (   cuvWidth.IsNullOrEnum()
                || cuvWidth.IsPercent()
               )
            {
                xParentWidth = IsDoublyNestedCell(pCell) ? 0 : pci->_sizeParent.cx;
            }
            else
            {
                LONG lFontHeight = pCF->GetHeightInTwips(Doc());
                xParentWidth = max(0l, cuvWidth.XGetPixelValue(pci, 0, lFontHeight));
            }
        }
        else
        {
            xParentWidth = IsDoublyNestedCell(pCell) ? 0 : pci->_sizeParent.cx;
        }
    }

    // WARNING: Return value should be used only when computing %age values!!
    return xParentWidth;
}

//+---------------------------------------------------------------------------
//
//  Method:     GetInlineMBPContributions
//
//  Synopsis:   This function computes the actual M/B/P values for a given
//              inline node. Note, that HasInlineMBP has to be called before
//              calling this one to ensure that the node does indeed contribute
//              M/B/P
//
//  Return:     BOOL: False if all of left/top/bottom/right are 0. This could
//              happen even if HasInlineMBP is true because of negative margins.
//
//----------------------------------------------------------------------------
BOOL
CTreeNode::GetInlineMBPContributions(CCalcInfo *pci,
                                     DWORD dwFlags,
                                     CRect *pResults,
                                     BOOL *pfHorzPercentAttr,
                                     BOOL *pfVertPercentAttr)
{
    CBorderInfo borderinfo;
    const CCharFormat  *pCF = GetCharFormat();
    const CFancyFormat *pFF = GetFancyFormat();
    LONG lFontHeight = pCF->GetHeightInTwips(Doc());
    CElement *pElement = Element();
    CRect rcEmpty(CRect::CRECT_EMPTY);
    BOOL fThisVertical = pCF->HasVerticalLayoutFlow();
    Assert(fThisVertical == IsParentVertical());
    BOOL fWritingModeUsed = pCF->_fWritingModeUsed;
    Assert(HasInlineMBP());
    LONG xParentWidth;

    BOOL fMargin  = (dwFlags & GIMBPC_MARGINONLY ) ? TRUE : FALSE;
    BOOL fBorder  = (dwFlags & GIMBPC_BORDERONLY ) ? TRUE : FALSE;
    BOOL fPadding = (dwFlags & GIMBPC_PADDINGONLY) ? TRUE : FALSE;

    Assert(fMargin || fBorder || fPadding);

    pResults->SetRectEmpty();

    //
    // Handle the borders first
    //
    if (fBorder)
    {
        pElement->_fDefinitelyNoBorders = !GetBorderInfoHelper(this, pci, &borderinfo, GBIH_NONE FCCOMMA LC_TO_FC(pci->GetLayoutContext()));
        if (!pElement->_fDefinitelyNoBorders)
        {
            pResults->left = borderinfo.aiWidths[SIDE_LEFT];
            pResults->right = borderinfo.aiWidths[SIDE_RIGHT];
            pResults->top = borderinfo.aiWidths[SIDE_TOP];
            pResults->bottom = borderinfo.aiWidths[SIDE_BOTTOM];
        }
    }

    if (fPadding || fMargin)
    {
        const CUnitValue & cuvPaddingTop    = pFF->GetLogicalPadding(SIDE_TOP, fThisVertical, fWritingModeUsed);
        const CUnitValue & cuvPaddingRight  = pFF->GetLogicalPadding(SIDE_RIGHT, fThisVertical, fWritingModeUsed);
        const CUnitValue & cuvPaddingBottom = pFF->GetLogicalPadding(SIDE_BOTTOM, fThisVertical, fWritingModeUsed);
        const CUnitValue & cuvPaddingLeft   = pFF->GetLogicalPadding(SIDE_LEFT, fThisVertical, fWritingModeUsed);

        const CUnitValue & cuvMarginLeft   = pFF->GetLogicalMargin(SIDE_LEFT, fThisVertical, fWritingModeUsed);
        const CUnitValue & cuvMarginRight  = pFF->GetLogicalMargin(SIDE_RIGHT, fThisVertical, fWritingModeUsed);
        const CUnitValue & cuvMarginTop    = pFF->GetLogicalMargin(SIDE_TOP, fThisVertical, fWritingModeUsed);
        const CUnitValue & cuvMarginBottom = pFF->GetLogicalMargin(SIDE_BOTTOM, fThisVertical, fWritingModeUsed);

        // If we have horizontal padding in percentages, flag the display
        // so it can do a full recalc pass when necessary (e.g. parent width changes)
        *pfHorzPercentAttr = (   cuvPaddingLeft.IsPercent()
                              || cuvPaddingRight.IsPercent()
                              || cuvMarginLeft.IsPercent()
                              || cuvMarginRight.IsPercent()
                             );
        *pfVertPercentAttr = (   cuvPaddingTop.IsPercent()
                              || cuvPaddingBottom.IsPercent()
                              || cuvMarginTop.IsPercent()
                              || cuvMarginBottom.IsPercent()
                             );

        xParentWidth = (*pfHorzPercentAttr) ? GetParentWidth(pci, pci->_sizeParent.cx) : pci->_sizeParent.cx;

        //
        // Handle the padding next (only positive padding allowed)
        //
        if (fPadding)
        {
            pResults->left   += max(0l, cuvPaddingLeft.XGetPixelValue(pci, cuvPaddingLeft.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight));
            pResults->right  += max(0l, cuvPaddingRight.XGetPixelValue(pci, cuvPaddingRight.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight));
            pResults->top    += max(0l, cuvPaddingTop.YGetPixelValue(pci, pci->_sizeParent.cx, lFontHeight));
            pResults->bottom += max(0l, cuvPaddingBottom.YGetPixelValue(pci, pci->_sizeParent.cx, lFontHeight));
        }

        //
        // Finally, handle the margin information
        //
        if (fMargin)
        {
            LONG topMargin, bottomMargin;
            pResults->left   += cuvMarginLeft.XGetPixelValue(pci, cuvMarginLeft.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight);
            pResults->right  += cuvMarginRight.XGetPixelValue(pci, cuvMarginRight.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight);
            
            topMargin = cuvMarginTop.YGetPixelValue(pci, pci->_sizeParent.cx, lFontHeight);
            if (   topMargin
                && GetMarkup()->SearchBranchForCriteria(Parent(), IsInlineTopBPNode, (void*)pci)
               )
            {
                pResults->top  += topMargin;
            }
            bottomMargin = cuvMarginBottom.YGetPixelValue(pci, pci->_sizeParent.cx, lFontHeight);
            if (   bottomMargin
                && GetMarkup()->SearchBranchForCriteria(Parent(), IsInlineBottomBPNode, (void*)pci)
               )
            {
                pResults->bottom += bottomMargin;
            }
        }
    }
    
    return *pResults != rcEmpty;
}

//+---------------------------------------------------------------------------
//
//  Method:     GetInlineMBPForPseudo
//
//  Synopsis:   Similar to above, except that this function is to MBP contributed
//              by the pseudo element.
//
//  Return:     BOOL
//
//----------------------------------------------------------------------------
BOOL
CTreeNode::GetInlineMBPForPseudo(CCalcInfo *pci,
                                 DWORD dwFlags,
                                 CRect *pResults,
                                 BOOL *pfHorzPercentAttr,
                                 BOOL *pfVertPercentAttr)
{
    CRect rcEmpty(CRect::CRECT_EMPTY);
    const CCharFormat  *pCF = GetCharFormat(LC_TO_FC(pci->GetLayoutContext()));
    const CFancyFormat *pFF = GetFancyFormat(LC_TO_FC(pci->GetLayoutContext()));
    BOOL  fInlineBackground = FALSE;

    if (pFF->_iPEI >= 0)
    {
        CBorderInfo borderinfo;
        const CPseudoElementInfo *pPEI = GetPseudoElementInfoEx(pFF->_iPEI);
        LONG lFontHeight = pCF->GetHeightInTwips(Doc());
        BOOL fVertical = pCF->HasVerticalLayoutFlow();
        BOOL fWM = pCF->_fWritingModeUsed;
        Assert(fVertical == IsParentVertical());
        LONG xParentWidth;

        BOOL fMargin  = (dwFlags & GIMBPC_MARGINONLY ) ? TRUE : FALSE;
        BOOL fBorder  = (dwFlags & GIMBPC_BORDERONLY ) ? TRUE : FALSE;
        BOOL fPadding = (dwFlags & GIMBPC_PADDINGONLY) ? TRUE : FALSE;

        Assert(fMargin || fBorder || fPadding);

        //
        // Handle the borders first
        //
        if (fBorder && GetBorderInfoHelper(this, pci, &borderinfo, GBIH_PSEUDO FCCOMMA LC_TO_FC(pci->GetLayoutContext())))
        {
            pResults->left = borderinfo.aiWidths[SIDE_LEFT];
            pResults->right = borderinfo.aiWidths[SIDE_RIGHT];
            pResults->top = borderinfo.aiWidths[SIDE_TOP];
            pResults->bottom = borderinfo.aiWidths[SIDE_BOTTOM];
        }
        else
        {
            pResults->SetRectEmpty();
        }

        //
        // Handle the padding next (only positive padding allowed)
        //
        if (fPadding || fMargin)
        {
            const CUnitValue & cuvPaddingTop    = pPEI->GetLogicalPadding(SIDE_TOP,    fVertical, fWM, pFF);
            const CUnitValue & cuvPaddingRight  = pPEI->GetLogicalPadding(SIDE_RIGHT,  fVertical, fWM, pFF);
            const CUnitValue & cuvPaddingBottom = pPEI->GetLogicalPadding(SIDE_BOTTOM, fVertical, fWM, pFF);
            const CUnitValue & cuvPaddingLeft   = pPEI->GetLogicalPadding(SIDE_LEFT,   fVertical, fWM, pFF);

            const CUnitValue & cuvMarginLeft   = pPEI->GetLogicalMargin(SIDE_LEFT,   fVertical, fWM, pFF);
            const CUnitValue & cuvMarginRight  = pPEI->GetLogicalMargin(SIDE_RIGHT,  fVertical, fWM, pFF);
            const CUnitValue & cuvMarginTop    = pPEI->GetLogicalMargin(SIDE_TOP,    fVertical, fWM, pFF);
            const CUnitValue & cuvMarginBottom = pPEI->GetLogicalMargin(SIDE_BOTTOM, fVertical, fWM, pFF);

            // If we have horizontal padding in percentages, flag the display
            // so it can do a full recalc pass when necessary (e.g. parent width changes)
            // Also see ApplyLineIndents() where we do this for horizontal indents.
            *pfHorzPercentAttr = (   cuvPaddingLeft.IsPercent()
                                  || cuvPaddingRight.IsPercent()
                                  || cuvMarginLeft.IsPercent()
                                  || cuvMarginRight.IsPercent()
                                 );
            *pfVertPercentAttr = (   cuvPaddingTop.IsPercent()
                                  || cuvPaddingBottom.IsPercent()
                                  || cuvMarginTop.IsPercent()
                                  || cuvMarginBottom.IsPercent()
                                 );

            xParentWidth = (*pfHorzPercentAttr) ? GetParentWidth(pci, pci->_sizeParent.cx) : pci->_sizeParent.cx;

            //
            // Handle the padding next (only positive padding allowed)
            //
            if (fPadding)
            {
                pResults->left   += max(0l, cuvPaddingLeft.XGetPixelValue(pci, cuvPaddingLeft.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight));
                pResults->right  += max(0l, cuvPaddingRight.XGetPixelValue(pci, cuvPaddingRight.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight));
                pResults->top    += max(0l, cuvPaddingTop.YGetPixelValue(pci, pci->_sizeParent.cy, lFontHeight));
                pResults->bottom += max(0l, cuvPaddingBottom.YGetPixelValue(pci, pci->_sizeParent.cy, lFontHeight));
            }

            //
            // Finally, handle the margin information
            //
            if (fMargin)
            {
                pResults->left   += cuvMarginLeft.XGetPixelValue(pci, cuvMarginLeft.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight);
                pResults->right  += cuvMarginRight.XGetPixelValue(pci, cuvMarginRight.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight);
                pResults->top    += cuvMarginTop.YGetPixelValue(pci, pci->_sizeParent.cx, lFontHeight);
                pResults->bottom += cuvMarginBottom.YGetPixelValue(pci, pci->_sizeParent.cx, lFontHeight);
            }
        }

        fInlineBackground = pFF->HasBackgrounds(TRUE);
    }
    else
    {
        *pResults = rcEmpty;
    }
    
    return (   *pResults != rcEmpty
            || fInlineBackground);
}

LONG
CTreeNode::GetRotationAngleForVertical(const CFancyFormat *pFF FCCOMMA  FORMAT_CONTEXT FCPARAM)
{
    CTreeNode *pZParent = ZParentBranch();
    LONG lAngle;
    
    if (   SameScope(Parent(), pZParent)
        || !pZParent
       )
    {
        lAngle = pFF->_fLayoutFlowChanged
                 ? (GetCharFormat(FCPARAM)->HasVerticalLayoutFlow() ? 270 : 90)
                 : 0;
    }
    else
    {
        Assert(pZParent);
        const CCharFormat *pCF = GetCharFormat(FCPARAM);
        const CCharFormat *pCFZParent = pZParent->GetCharFormat(FCPARAM);
        if (!!pCF->HasVerticalLayoutFlow() == !!pCFZParent->HasVerticalLayoutFlow())
        {
            // My Z-Parent and I have the same layout flow. Do nothing.
            lAngle = 0;
        }
        else
        {
            // It is different from my parent.
            lAngle = pCF->HasVerticalLayoutFlow() ? 270 : 90;
        }
    }
    return lAngle;
}

LONG
CTreeNode::GetLogicalUserWidth(CDocScaleInfo const * pdsi, BOOL fVerticalLayoutFlow)
{
    LONG lWidth;
    const CCharFormat  * pCF = GetCharFormat();
    const CFancyFormat * pFF = GetFancyFormat();

    const CUnitValue & cuvWidth = pFF->GetLogicalWidth(fVerticalLayoutFlow, pCF->_fWritingModeUsed);
    if (cuvWidth.IsNullOrEnum() || cuvWidth.IsPercent())
    {
        lWidth = Parent() ? Parent()->GetLogicalUserWidth(pdsi, fVerticalLayoutFlow) : 0;

        if (cuvWidth.IsPercent())
        {
            lWidth = cuvWidth.XGetPixelValue(pdsi, lWidth, GetFontHeightInTwips(&cuvWidth));
        }
    }
    else
    {
        lWidth = cuvWidth.XGetPixelValue(pdsi, 0, GetFontHeightInTwips(&cuvWidth));
    }

    return lWidth;
}

BOOL
CTreeNode::HasEllipsis()
{
    const CFancyFormat * pFF = GetFancyFormat();
    BOOL fHasEllipsis = (pFF->GetTextOverflow() == styleTextOverflowEllipsis);
    if (fHasEllipsis)
    {
        const CCharFormat * pCF = GetCharFormat();
        styleOverflow overflow = pFF->GetLogicalOverflowX(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
        fHasEllipsis =    !pFF->_fContentEditable
                       && !Element()->_fEditable
                       && (overflow == styleOverflowHidden || overflow == styleOverflowScroll || overflow == styleOverflowAuto);
    }
    return fHasEllipsis;
}


//+-----------------------------------------------------------------------------
//
//  Method: CElement::DrawToDC, IHTMLElementRender
//
//------------------------------------------------------------------------------
HRESULT 
CElement::DrawToDC(HDC hDC)
{
    HRESULT hr = E_UNEXPECTED;

    if (IsInMarkup() && Doc()->GetView()->IsActive())
    {
        hr = Doc()->GetView()->RenderElement(this, hDC);
    }

    RRETURN(hr);
}
//  Method: CElement::DrawToDC, IHTMLElementRender

CMarkup *
CElement::GetMarkupForBaseUrl()
{
    return GetWindowedMarkupContext();
}

CElementFactory::~CElementFactory()
{
    if (_pMarkup)
        _pMarkup->SubRelease();
}

CDocument *
CElement::Document()
{
    CMarkup * pMarkup = GetMarkup();
    if (pMarkup) {
        COmWindowProxy * pOmWindow = pMarkup->Window();
        if (pOmWindow)      
        {
            return pOmWindow->Document();
        }
    }
    return NULL;
}

CDocument *
CElement::DocumentOrPendingDocument()
{
    CDocument * pDocument = Document();
    if(!pDocument)
    {
        // No document yet, try the pendind window
        COmWindowProxy * pWin;
        pWin = IsInMarkup() ? GetMarkup()->GetWindowPending() : NULL;
        if(pWin)
            pDocument = pWin->Document();
        AssertSz(!pDocument || pDocument->GetPageTransitionInfo()->GetTransitionFromMarkup(),
                    "Page Transitions - We should need to get the Document from pending window only when called from ApplyPage Transitions");
    }

    return pDocument;
}


//+---------------------------------------------------------------------------
//
//  Member:     CElement::glyphMode, public
//
//  Synopsis:   return the glyph mode:
//
//              0 - no glyphs
//              1 - glyph on start
//              2 - glyph on end
//              3 - glyph on both start and end
//
//----------------------------------------------------------------------------

HRESULT
CElement::get_glyphMode(LONG *plGlyphMode)
{
    HRESULT     hr = S_OK;
    CTreePos    *ptpBegin = NULL;
    CTreePos    *ptpEnd = NULL;
    
    //
    // Validate args
    //
    
    if (!plGlyphMode )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plGlyphMode = 0;

    if( !GetMarkup()->HasGlyphTable())
        goto Cleanup; // no glyph

    //
    // Find the TreePos where we're supposed to start looking
    //

    GetTreeExtent(&ptpBegin, &ptpEnd);

    Assert(ptpBegin && (ptpEnd || IsNoScope()));

    if (ptpBegin->ShowTreePos())
        *plGlyphMode |= htmlGlyphModeBegin;

    if (!IsNoScope() && ptpEnd->ShowTreePos())
        *plGlyphMode |= htmlGlyphModeEnd;
        
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::DeferredFireEvent
//
//----------------------------------------------------------------------------

void 
CElement::DeferredFireEvent (DWORD_PTR pDesc)
{
    FireEvent ((const PROPERTYDESC_BASIC *) pDesc);
}

BOOL 
CElement::IsTablePart( )
{
    switch( _etag )
    {
        case ETAG_TD:
        case ETAG_TR:
        case ETAG_TBODY:
        case ETAG_TFOOT:
        case ETAG_TH:
        case ETAG_THEAD:
        case ETAG_CAPTION:
        case ETAG_TC:
        case ETAG_COL:
        case ETAG_COLGROUP:
        
            return TRUE;

        default:
            return FALSE;
    }
}

CMarkup *
CElement::GetWindowedMarkupContext()
{
    if (Tag() == ETAG_DEFAULT)
        return Doc()->PrimaryMarkup();

#if DBG==1
    // Compiler was puking if this assert was merged together.
    if( IsInMarkup() )
    {
        Assert( GetMarkupPtr()->GetWindowedMarkupContext() );
    }
    else
    {
        Assert( HasWindowedMarkupContextPtr() );
    }
#endif // DBG

    return IsInMarkup() ? GetMarkupPtr()->GetWindowedMarkupContext() : GetWindowedMarkupContextPtr();
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::GetCWindowPtr()
//
//--------------------------------------------------------------------------
CWindow * CElement::GetCWindowPtr()
{
    CMarkup * pMarkup = GetWindowedMarkupContext();

    Assert(pMarkup);
    
    COmWindowProxy * pWindowProxy = pMarkup->Window();

    if (pWindowProxy)
    {
        return pWindowProxy->Window();
    }
    
    return NULL;
}

BOOL
CElement::IsBodySizingForStrictCSS1NeededCore()
{
    Assert(Tag() == ETAG_BODY);
    return    GetMarkup()->IsStrictCSS1Document()
           && !GetFirstBranch()->IsScrollingParent();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\elementp.cxx ===
//+---------------------------------------------------------------------
//
//  File:       elementp.cxx
//
//  Classes:    CDefaults, etc.
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_GENERIC_HXX_
#define X_GENERIC_HXX_
#include "generic.hxx"
#endif

#ifndef X_PEERMGR_HXX_
#define X_PEERMGR_HXX_
#include "peermgr.hxx"
#endif

#define _cxx_
#include "elementp.hdl"


///////////////////////////////////////////////////////////////////////////
//
//  misc
//
///////////////////////////////////////////////////////////////////////////

MtDefine(CDefaults,     ObjectModel,        "CDefaults");

BEGIN_TEAROFF_TABLE(CDefaults, IOleCommandTarget)
    TEAROFF_METHOD(CDefaults, QueryStatus, querystatus, (GUID * pguidCmdGroup, ULONG cCmds, MSOCMD rgCmds[], MSOCMDTEXT * pcmdtext))
    TEAROFF_METHOD(CDefault, Exec, exec, (GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG * pvarargIn, VARIANTARG * pvarargOut))
END_TEAROFF_TABLE()

const CBase::CLASSDESC CDefaults::s_classdesc =
{
    &CLSID_HTMLDefaults,            // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLElementDefaults,      // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

#define DISPID_INTERNAL_VIEWLINK (DISPID_DEFAULTS+50)

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CDefaults
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CDefaults::CDefaults
//
//-------------------------------------------------------------------------

CDefaults::CDefaults(CElement * pElement)
{
    _pElement = pElement;
    _pElement->SubAddRef(); // balanced in Passivate
}

//+------------------------------------------------------------------------
//
//  Member:     CDefaults::Passivate
//
//-------------------------------------------------------------------------

void
CDefaults::Passivate()
{
    Assert (_pElement);

    CPeerMgr::OnDefaultsPassivate(_pElement);

    _pElement->SubRelease();
    _pElement = NULL;

    if (_pStyle)
    {
        delete _pStyle;
        _pStyle = NULL;
    }

    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CDefaults::PrivateQueryInterface, per IPrivateUnknown
//
//-------------------------------------------------------------------------

HRESULT
CDefaults::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS((IPrivateUnknown *)this, IUnknown)
    QI_TEAROFF_DISPEX(this, NULL)
    QI_TEAROFF (this, IOleCommandTarget, NULL)
    QI_HTML_TEAROFF(this, IHTMLElementDefaults, NULL)

    default:

        if (IsEqualGUID(CLSID_HTMLDefaults, iid))
        {
            *ppv = this;
            return S_OK;
        }

        break;
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (super::PrivateQueryInterface(iid, ppv));
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CDefaults::OnPropertyChange
//
//-------------------------------------------------------------------------

HRESULT
CDefaults::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr;

    dwFlags |= ELEMCHNG_DONTFIREEVENTS;
    hr = _pElement->OnPropertyChange(dispid, dwFlags);
    if ( FAILED(hr) )
        goto Cleanup;

    hr = super::OnPropertyChange(dispid, dwFlags);

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDefaults::EnsureStyle
//
//-------------------------------------------------------------------------

HRESULT
CDefaults::EnsureStyle(CStyle ** ppStyle)
{
    HRESULT     hr = S_OK;

    Assert (ppStyle);

    *ppStyle = NULL;

    if (!_pStyle)
    {
        _pStyle = new CStyle(_pElement, DISPID_UNKNOWN, CStyle::STYLE_SEPARATEFROMELEM | CStyle::STYLE_DEFSTYLE);
        if (!_pStyle)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    *ppStyle = _pStyle;

Cleanup:

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDefaults::GetStyleAttrArray
//
//-------------------------------------------------------------------------

CAttrArray *
CDefaults::GetStyleAttrArray()
{
    if (_pStyle)
    {
        CAttrArray **ppAA = _pStyle->GetAttrArray();
        return ppAA ? *ppAA : NULL;
    }

    return NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CDefaults::get_style
//
//-------------------------------------------------------------------------

HRESULT
CDefaults::get_style(IHTMLStyle ** ppStyle)
{
    HRESULT     hr = S_OK;
    CStyle *    pStyle = NULL;

    *ppStyle = NULL;

    hr = THR(EnsureStyle(&pStyle));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pStyle->QueryInterface(IID_IHTMLStyle, (void**)ppStyle));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CDefaults::GetAAcanHaveHTML
//
//-------------------------------------------------------------------------

BOOL
CDefaults::GetAAcanHaveHTML(VARIANT_BOOL *pfValue) const 
{
    DWORD v;
    BOOL retVal = CAttrArray::FindSimple(*GetAttrArray(), &s_propdescCDefaultscanHaveHTML.a, &v);
    if (pfValue)
        *pfValue = *(VARIANT_BOOL*)&v;
    return retVal;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDefaults::Exec
//
//--------------------------------------------------------------------------

HRESULT
CDefaults::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    HRESULT hr = OLECMDERR_E_NOTSUPPORTED;

    if (*pguidCmdGroup == CGID_ProtectedElementPrivate)
    {
        // Reference Media for layout
        if (nCmdID == IDM_ELEMENTP_SETREFERENCEMEDIA)
        {
            hr = SetReferenceMediaForLayout((mediaType) nCmdexecopt);
        }
    }
    
    RRETURN_NOTRACE(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDefaults::put_viewLink
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CDefaults::put_viewLink(IHTMLDocument * pISlave)
{
    HRESULT             hr = 0;
    AAINDEX             aaIdx           = FindAAIndex(DISPID_INTERNAL_VIEWLINK, CAttrValue::AA_Internal);
    IMarkupContainer *  pIMarkupSlave   = NULL;
    CMarkup *           pMarkupSlave    = NULL;
    CElement *          pElemSlave      = NULL;

    // Validation

    // 1. For now, allow viewLinking only for generic tags
    Assert(_pElement->TagType() == ETAG_GENERIC);

    if (pISlave)
    {
        hr = THR(pISlave->QueryInterface(IID_IMarkupContainer, (void**) &pIMarkupSlave));
        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        hr = THR(pIMarkupSlave->QueryInterface(CLSID_CMarkup, (void**) &pMarkupSlave));
        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        Assert(pMarkupSlave);

        // Make sure that the slave and the master are in the same CDoc
        if (_pElement->Doc() != pMarkupSlave->Doc())
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        pElemSlave = pMarkupSlave->Root();

        
        // 2. Make sure that pMarkupSlave does not already have a master
        if ( pElemSlave )
        {
            if (pElemSlave->HasMasterPtr())
            {
                hr = (pElemSlave->GetMasterPtr() == _pElement) ? S_OK : E_INVALIDARG;
                goto Cleanup;
            }
        }

        // 3. Make sure that a cylce is not being created
        if (_pElement->IsCircularViewLink(pMarkupSlave))
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

    }

    if (aaIdx == AA_IDX_UNKNOWN)
    {
        if (pISlave)
        {
            hr = AddUnknownObject(DISPID_INTERNAL_VIEWLINK, pISlave, CAttrValue::AA_Internal);
        }
    }
    else
    {
        if ( pISlave )
        {
            hr = ChangeUnknownObjectAt(aaIdx, pISlave);
        }
        else
        {
            DeleteAt(aaIdx);
        }
    }
    if (hr)
        goto Cleanup;

    hr = THR(_pElement->SetViewSlave(pElemSlave));

Cleanup:
    ReleaseInterface(pIMarkupSlave);
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------------------
//
//  Member:     CDefaults::get_viewLink
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CDefaults::get_viewLink(IHTMLDocument ** ppISlave)
{
    HRESULT     hr;
    CDefaults * pHead = this;
    IUnknown  * pIUnk = NULL;
    
    if (!ppISlave)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppISlave = NULL;

    if (   _pElement->ShouldHaveLayout()
        && _pElement->GetUpdatedLayout()->ViewChain()
        && _pElement->GetUpdatedLayout()->ViewChain()->GetLayoutOwner()) 
    {
        pHead = _pElement->GetUpdatedLayout()->ViewChain()->GetLayoutOwner()->ElementOwner()->GetDefaults();
    }

    hr = THR(pHead->GetUnknownObjectAt(
            pHead->FindAAIndex(DISPID_INTERNAL_VIEWLINK, CAttrValue::AA_Internal),
            &pIUnk));
    if (FAILED(hr))
        goto Cleanup;

    hr = pIUnk->QueryInterface(IID_IHTMLDocument, (void **)ppISlave);        

Cleanup:
    ReleaseInterface(pIUnk);
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     CDefaults::SetReferenceMediaForMeasurement
//
//  Synopsis:   Enables layout for a reference media
//
//-----------------------------------------------------------------------------

HRESULT
CDefaults::SetReferenceMediaForLayout(mediaType media)
{
    Assert(_pElement);
    
    HRESULT hr = S_OK;

    // Store the media in ELEMENT's attr array. 
    // It will be set in CFancyFormat by ApplyFormatInfoProperty.
    {
        AAINDEX aaIdx = _pElement->FindAAIndex(DISPID_INTERNAL_MEDIA_REFERENCE, CAttrValue::AA_StyleAttribute);
        if (aaIdx == AA_IDX_UNKNOWN)
        {
            // media is not set yet. Only set if this is a non-default value
            if (mediaTypeNotSet == media)
                goto Cleanup;
                
            hr = _pElement->AddSimple(DISPID_INTERNAL_MEDIA_REFERENCE, media, CAttrValue::AA_StyleAttribute);
        }
        else
        {
            // this attribute has been set. do nothing if it is not changing
            DWORD dwOldValue = 0; // keep compiler happy
            if (S_OK != (hr = _pElement->GetSimpleAt(aaIdx, &dwOldValue)) || dwOldValue == (DWORD) media)
                goto Cleanup;

            hr = _pElement->ChangeSimpleAt(aaIdx, media);
        }
    }
    if (hr)
        goto Cleanup;

    // This is positively a different media. Destroy all layouts if any exist
    // NOTE: this is because we can't dynamically change context on a layout tree.
    //       If we could, it would work much faster.
    if (_pElement->CurrentlyHasAnyLayout())
    {
        _pElement->DestroyLayout();
        _pElement->GetFirstBranch()->VoidFancyFormat();    // must recalc fancy format before we re-create layout
  
        // this will invalidate the layout.
        // we don't need to call this if the layout doesn't exist yet (it will force layout creation).
        hr = _pElement->OnPropertyChange(DISPID_INTERNAL_MEDIA_REFERENCE, ELEMCHNG_REMEASUREINPARENT|ELEMCHNG_CLEARCACHES|ELEMCHNG_REMEASUREALLCONTENTS);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\dump.cxx ===
//+---------------------------------------------------------------------
//
//  File:       dump.cxx
//
//  Contents:   Diagnostic output routines
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_BREAKER_HXX_
#define X_BREAKER_HXX_
#include "breaker.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#if DBG == 1 || defined(DUMPTREE)

#ifndef X_LOGMGR_HXX_
#define X_LOGMGR_HXX_
#include "logmgr.hxx"
#endif

DeclareTagOther(tagSaveDocOnDump, "TreeDump", "Save Doc in Tree Dump");
DeclareTagOther(tagSaveLBOnDump, "TreeDump", "Save LineBreaks in Tree Dump");
DeclareTagOther(tagDumpAlwaysOverwrite, "TreeDump", "Always create new file");
DeclareTagOther(tagDumpXML, "TreeDump", "Dump XML");

#define NODE_TYPE_BEGIN  -1
#define NODE_TYPE_NEUTRAL 0
#define NODE_TYPE_END     1

void
CMarkup::PrintNodeTag ( CTreeNode * pNode, int type )
{
    CElement * pElement = pNode->Element();
    
    if (type != NODE_TYPE_NEUTRAL)
    {
        if (type == NODE_TYPE_BEGIN)
            WriteHelp( g_f, _T("<<") );
        else
            WriteHelp( g_f, _T("<</") );
    }

    if (pElement->Namespace())
        WriteHelp( g_f, _T("<0s>:"), pElement->Namespace() );

    if (pNode->Tag() == ETAG_UNKNOWN)
        WriteHelp( g_f, _T("\"<0s>\""), pElement->TagName() );
    else
        WriteHelp( g_f, _T("<0s>"), pElement->TagName() );

    if (type != NODE_TYPE_NEUTRAL)
        WriteHelp( g_f, _T(">") );

    WriteHelp( g_f, _T(" [E<0d> N<1d>"), long( pElement->SN() ), pNode->SN() );

    if (pElement->_fBreakOnEmpty)
        WriteString( g_f, _T(",BreakOnEmpty"));

    WriteString( g_f, _T("]"));
}

void
CMarkup::PrintNode ( CTreeNode * pNode, BOOL fSimple, int type )
{
    PrintNodeTag( pNode, type );

    if (!fSimple)
    {
        WriteHelp( g_f, _T(" (") );

        WriteHelp(
            g_f, _T("ERefs=<0d>, EAllRefs=<1d>, <2d> <3d> <4d>"),
            (long)pNode->Element()->GetObjectRefs(), (long)pNode->Element()->GetRefs(),
            (long)pNode->_iCF, (long)pNode->_iPF, (long)pNode->_iFF);

        if (pNode->Parent())
        {
            WriteString( g_f, _T(", Parent = ") );

            PrintNodeTag( pNode->Parent() );
        }

        WriteString( g_f, _T(")") );
    }
}

void
CMarkup::DumpTree ( )
{
    if (IsTagEnabled(tagDumpXML))
    {
        DumpTreeInXML();
    }
    else
    {
        if (!InitDumpFile(IsTagEnabled(tagDumpAlwaysOverwrite)))
            return;

        DumpTreeWithMessage();

        CloseDumpFile();

        if( HasLogManager() )
        {
            GetLogManager()->DumpQueue();
        }
    }
}

void
CMarkup::DumpTreeOverwrite ( )
{
    if (!InitDumpFile(TRUE))
        return;

    DumpTreeWithMessage();

    CloseDumpFile();
}

void
DumpTreeOverwrite()
{
    if (g_pDebugMarkup)
        g_pDebugMarkup->DumpTreeOverwrite();
}

void 
CMarkup::SetDebugMarkup ( )
{ 
    g_pDebugMarkup = this; 
}


static void 
DumpFormat( FORMATETC * pfetc, TCHAR * szFormat, BOOL fUnicode )
{
#ifndef WIN16
    char          abBuf[256];
    ULONG         cbRead;
    HRESULT       hr;
    STGMEDIUM     medium = {TYMED_NULL, NULL, NULL};
    HGLOBAL       hglobal = NULL;
    LPSTREAM      pIStream = NULL;   // IStream pointer
    IDataObject*  pdo;               // Pointer to the data object on the clipboard

    WriteHelp(g_f, _T("----- FORMAT: <0s> -----\r\n"), szFormat);

    hr = OleGetClipboard(&pdo);
    if ( hr )
        goto Cleanup;

    hr = pdo->GetData(pfetc, &medium);
    if( hr )
        goto Cleanup;

    // STGFIX: t-gpease 8-13-97
    Assert(medium.tymed == TYMED_HGLOBAL);

    hglobal = medium.hGlobal;
    if( !GlobalLock(hglobal) )
    {
        hglobal = NULL;
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr  = THR(CreateStreamOnHGlobal(hglobal, FALSE, &pIStream));
    if (hr)
        goto Cleanup;

    while (S_OK == pIStream->Read(abBuf, ARRAY_SIZE(abBuf), &cbRead))
    {
        if (fUnicode)
        {
            TCHAR *     pchBuf;
            ULONG       cchLength;
            ULONG       cchRead = cbRead/2;

            for( pchBuf = (TCHAR*) abBuf, cchLength = 0;
                 cchLength < cchRead && *pchBuf;
                 pchBuf++, cchLength++ )
                ;

            if (!cchLength)
                break;

            WriteFileAnsi( g_f, abBuf, cchLength );

            if (cchLength < cchRead)
                break;
        }
        else
        {
            char *        pbBuf;
            ULONG         cchLength;
            TCHAR         achBuffer[256];
            long          cchWideChar;

            for (pbBuf = abBuf, cchLength = 0;
                 cchLength < cbRead && *pbBuf;
                 pbBuf++, cchLength++);

            if (!cchLength)
                break;

            cchWideChar = MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    abBuf,
                    cchLength,
                    achBuffer,
                    ARRAY_SIZE(achBuffer));

            Assert(cchWideChar > 0);

            WriteFileAnsi( g_f, achBuffer, cchWideChar );

            if (cchLength < cbRead)
                break;
        }
    }

    WriteString( g_f, _T("\r\n") );

Cleanup:

    ReleaseInterface(pIStream);

    if(hglobal)
    {
        GlobalUnlock(hglobal);
    }

    ReleaseStgMedium(&medium);

    pdo->Release();
#endif //!WIN16
}

void
CMarkup::DumpClipboardText( )
{
#ifndef WIN16
    if( !InitDumpFile())
        goto Cleanup;

    WriteString(g_f, _T("----- DUMP OF CLIPBOARD CONTENTS -----\r\n"));

    DumpFormat( &g_rgFETC[iHTML], _T("CF_HTML"), FALSE );
//    DumpFormat( &g_rgFETC[iRtfFETC], _T("RTF") );
    DumpFormat( &g_rgFETC[iUnicodeFETC], _T("Unicode plain text"), TRUE );
    DumpFormat( &g_rgFETC[iAnsiFETC], _T("ANSI plain text"), FALSE );

    WriteString(g_f, _T("----- END DUMP OF CLIPBOARD CONTENTS -----\r\n\r\n"));

Cleanup:
    CloseDumpFile( );
#endif //!WIN16
}

static void DumpNumber ( int n )
{
    if (n < 10)
        WriteHelp( g_f, _T("   ") );
    else if (n < 100)
        WriteHelp( g_f, _T("  ") );
    else if (n < 1000)
        WriteHelp( g_f, _T(" ") );
        
    WriteHelp( g_f, _T("<0d>"), long( n ) );
}

static void DumpSerialNumber ( TCHAR * pchType, int n )
{
    WriteHelp( g_f, _T("[<0s>"), pchType );
    DumpNumber( n );
    WriteHelp( g_f, _T("]") );
}

void
CMarkup::DumpTextTreePos ( CTreePos * ptpCurr )
{
    long cch;

    cch = ptpCurr->Cch();

    WriteString( g_f, _T("  ") );
    
    WriteString( g_f, _T("'") );
    
    if (cch)
    {
        CTxtPtr rpTX(this);
        TCHAR chBuff [ 30 ];
        long cpCurr = ptpCurr->GetCp();
        BOOL fNotEnoughCharacters = FALSE;

        if( cpCurr + cch > rpTX.GetTextLength() )
        {
            cch = rpTX.GetTextLength() - cpCurr;
            fNotEnoughCharacters = TRUE;
        }

        
        if(cch > 0)
        {
            rpTX.BindToCp(cpCurr);

            if (cch <= ARRAY_SIZE( chBuff ))
            {
                rpTX.GetRawText( cch, chBuff );

                WriteFormattedString( g_f, chBuff, cch );
            }
            else
            {
                long cchDiv2 = ARRAY_SIZE( chBuff ) / 2;

                rpTX.GetRawText( cchDiv2, chBuff );

                WriteFormattedString( g_f, chBuff, cchDiv2 );

                WriteString( g_f, _T( "..." ) );

                rpTX.AdvanceCp( cch - cchDiv2 );

                rpTX.GetRawText( cchDiv2, chBuff );

                WriteFormattedString( g_f, chBuff, cchDiv2 );

                rpTX.AdvanceCp( - (cch - cchDiv2) );
            }
        }


        if (fNotEnoughCharacters)
        {
            WriteString( g_f, _T(", Not enough text in the story") );
        }
    }
    
    WriteString( g_f, _T("'"));
    
    WriteHelp( g_f, _T(", _sid(<0s>)"), SidName( ptpCurr->Sid() ) );

    if( ptpCurr->TextID() )
    {
        WriteHelp( g_f, _T(", _lTextID(<0d>)"), long( ptpCurr->TextID() ) );
    }
}

void
CMarkup::DumpTreeWithMessage ( TCHAR * szMessage )
{
    if (szMessage && szMessage[0])
        WriteHelp( g_f, _T("<0s>\r\n\r\n"), szMessage );

    if (IsTagEnabled(tagSaveDocOnDump))
    {
        //
        // Print out the saved version of the tree
        //

        HGLOBAL     hg;
        IStream *   pStm;

        THR(CreateStreamOnHGlobal(NULL, TRUE, &pStm));
        {
            SaveToStream( pStm, 0, CP_1252 );
        }

        THR(GetHGlobalFromStream(pStm, &hg));

        if (hg)
        {
            long nChars = GlobalSize( hg );

            char * pChar = (char *) GlobalLock( hg );

            for ( ; nChars > 0 ; nChars--, pChar++ )
            {
                WriteChar(g_f, *pChar);
            }

            GlobalUnlock( hg );
            GlobalFree( hg );
        }

        WriteString( g_f, _T("\r\n\r\n"));
    }

    CTreePos * ptpCurr = FirstTreePos();
    CLineBreakCompat * pLineBreaks = NULL;
    CTreePosGap tpg;
    MarkupTextFrag *ptf = NULL;
    long            ctf = 0;

    if (IsTagEnabled(tagSaveLBOnDump))
    {
        pLineBreaks = new CLineBreakCompat;
    }

    if (HasTextFragContext())
    {
        CMarkupTextFragContext * ptfc = GetTextFragContext();

        Assert( ptfc );

        ctf = ptfc->_aryMarkupTextFrag.Size();
        ptf = ptfc->_aryMarkupTextFrag;
    }
        
    WriteHelp(
        g_f, _T("Tree Dump For Markup: M<0d>, TreeVer=<1d>, ContentsVer=<2d>"),
        SN(), GetMarkupTreeVersion(), GetMarkupContentsVersion() );

    WriteHelp( g_f, _T(" Cch = <0d>" ), long( GetTextLength() ) );
    

    WriteString( g_f, _T("\r\n\r\n") );
    if (pLineBreaks)
        WriteString( g_f, _T("Type   Pos   Cp  Cch Brk\r\n") );
    else
        WriteString( g_f, _T("Type   Pos   Cp  Cch\r\n") );


    while (ptpCurr)
    {
        long cch = 999;
        long depth = 0;
        
        switch( ptpCurr->Type() )
        {
        case CTreePos::NodeBeg :
            WriteHelp( g_f, _T("Begin ") );
            cch = ptpCurr->GetCch();
            depth = ptpCurr->Branch()->Depth();
            break;
            
        case CTreePos::NodeEnd :
            WriteHelp( g_f, _T("End   ") );
            cch = ptpCurr->GetCch();
            depth = ptpCurr->Branch()->Depth();
            break;
            
        case CTreePos::Text    :
            WriteHelp( g_f, _T("Text  ") );
            cch = ptpCurr->Cch();
            depth = ptpCurr->GetInterNode()->Depth();
            break;
            
        case CTreePos::Pointer :
            cch = 0;
            depth = ptpCurr->GetInterNode()->Depth();
            WriteString( g_f, _T("Ptr ") );
            WriteString( g_f, ptpCurr->Gravity() == POINTER_GRAVITY_Left ? _T("<") : _T(">") );
            WriteString( g_f, ptpCurr->Cling() ? _T("*") : _T(" ") );
            break;
            
        default:
            AssertSz( 0, "Yikes!" );
        }

        DumpNumber( ptpCurr->_nSerialNumber );
        
        WriteHelp( g_f, _T(" ") );

        if (cch > 0)
            DumpNumber( ptpCurr->GetCp() );
        else
            WriteHelp( g_f, _T("   -") );
        
        WriteHelp( g_f, _T(" ") );
        
        if (ptpCurr->Type() == CTreePos::NodeBeg || ptpCurr->Type() == CTreePos::NodeEnd)
        {
            if( ptpCurr->IsEdgeScope() )
                WriteHelp( g_f, _T("   *") );
            else
                WriteHelp( g_f, _T("   -") );
        }
        else if (cch > 0 || ptpCurr->Type() == CTreePos::Text)
            DumpNumber( cch );
        else
            WriteHelp( g_f, _T("   -") );

        if (pLineBreaks)
        {
            WriteHelp( g_f, _T(" ") );
            
            if (ptpCurr->Type() == CTreePos::NodeBeg || ptpCurr->Type() == CTreePos::NodeEnd)
            {
                DWORD dwBreaks = BREAK_NONE;

                if (pLineBreaks && ptpCurr->Branch()->Tag() != ETAG_ROOT)
                {
                    tpg.MoveTo( ptpCurr, TPG_LEFT );
            
                    IGNORE_HR( pLineBreaks->QueryBreaks( & tpg, & dwBreaks ) );
                }


                WriteHelp( g_f, (dwBreaks & BREAK_BLOCK_BREAK) ? _T("B") : _T(" ") );
                WriteHelp( g_f, (dwBreaks & BREAK_SITE_BREAK)  ? _T("S") : _T(" ") );
                WriteHelp( g_f, (dwBreaks & BREAK_SITE_END)    ? _T("E") : _T(" ") );
            }
            else
            {
                WriteHelp( g_f, _T("   ") );
            }
        }
        
        WriteHelp( g_f, _T(" | ") );

        for ( int i = depth - 1 ; i > 0 ;i-- )
            WriteString( g_f, _T("  "));
        
        switch( ptpCurr->Type() )
        {
        case CTreePos::NodeBeg :
        case CTreePos::NodeEnd :
            PrintNode(
                ptpCurr->Branch(), 
                ! ptpCurr->IsBeginNode(),
                ptpCurr->IsEdgeScope()
                    ? (ptpCurr->IsBeginNode() 
                        ? NODE_TYPE_BEGIN 
                        : NODE_TYPE_END) 
                    : NODE_TYPE_NEUTRAL );

            if (CTxtPtr( this, ptpCurr->GetCp() ).GetChar() != WCH_NODE)
            {
                TCHAR ch = CTxtPtr( this, ptpCurr->GetCp() ).GetChar();
                WriteString( g_f, _T(" '") );
                WriteFormattedString( g_f, & ch, 1 );
                WriteString( g_f, _T("'") );
            }

            break;
            
        case CTreePos::Text    :
            DumpTextTreePos(ptpCurr);
            break;
            
        case CTreePos::Pointer :
                
            WriteHelp( g_f, _T("  <<=== "));

            if (ctf > 0 && ptf->_ptpTextFrag == ptpCurr)
            {
                TCHAR chBuff [ 30 ];
                long  cchTextFrag = _tcslen(ptf->_pchTextFrag);

                Assert( !ptpCurr->MarkupPointer() );

                WriteHelp( g_f, _T("TextFrag: '") );

                if (cchTextFrag <= ARRAY_SIZE( chBuff ))
                {
                    WriteFormattedString( g_f, ptf->_pchTextFrag, cchTextFrag );
                }
                else
                {
                    long cchDiv2 = ARRAY_SIZE( chBuff ) / 2;

                    _tcsncpy(chBuff, ptf->_pchTextFrag, cchDiv2);

                    WriteFormattedString( g_f, chBuff, cchDiv2 );

                    WriteString( g_f, _T( "..." ) );

                    _tcsncpy( chBuff, ptf->_pchTextFrag + cchTextFrag - cchDiv2, cchDiv2 );

                    WriteFormattedString( g_f, chBuff, cchDiv2 );
                }

                WriteHelp( g_f, _T("'") );

                ctf--;
                ptf++;
            }
            else
            {
                CMarkupPointer * pmp = ptpCurr->MarkupPointer();
                TCHAR *pchCollapsedWhitespace = ptpCurr->GetCollapsedWhitespace();
            
                if (pmp)
                {
                    WriteHelp( g_f, _T(" P<0d>"), pmp->SN() );

                    if (pmp->CpIsCached())
                        WriteHelp( g_f, _T(" cp=<0d>, ver=<1d>"), pmp->_cpCache, pmp->_verCp );

                    if (LPTSTR( pmp->_cstrDbgName ))
                        WriteHelp( g_f, _T(" <0s>"), LPTSTR( pmp->_cstrDbgName ) );
                }

                if (pchCollapsedWhitespace)
                {                    
                    WriteString( g_f, _T( "[" ) );
                    WriteFormattedString( g_f, pchCollapsedWhitespace, _tcslen(pchCollapsedWhitespace) );
                    WriteString( g_f, _T( "]" ) );
                }
            break;
        }
        }
        
        WriteString( g_f, _T("\r\n"));

        CMarkupPointer * pmp;

        for ( pmp = _pmpFirst ; pmp ; pmp = pmp = pmp->_pmpNext )
        {
            Assert( ! pmp->_fEmbedded );
            
            if (pmp->_ptpRef != ptpCurr)
                continue;

            WriteString( g_f, _T("ptr ") );
            WriteString( g_f, pmp->Gravity() == POINTER_GRAVITY_Left ? _T("<") : _T(">") );
            WriteString( g_f, pmp->Cling() ? _T("*") : _T(" ") );
            
            if (IsTagEnabled(tagSaveLBOnDump))
                WriteString( g_f, _T("   -    -    -     | "));
            else
                WriteString( g_f, _T("   -    -    - | "));

            for ( i = depth - 1 ; i > 0 ;i-- )
                WriteString( g_f, _T("  "));

            if (ptpCurr->IsText())
            {
                for ( i = 0 ; i < pmp->_ichRef ; i++ )
                    WriteHelp( g_f, _T(" ") );
            
                WriteHelp( g_f, _T("   ^===") );
            }
            else
            {
                WriteHelp( g_f, _T("^===") );
            }

            WriteHelp( g_f, _T(" ") );
            
            WriteHelp( g_f, _T("  P<0d>"), pmp->SN() );

            if (pmp->CpIsCached())
                WriteHelp( g_f, _T("  cp=<0d>, ver=<1d>"), pmp->_cpCache, pmp->_verCp );
            
            WriteHelp( g_f, _T(" ich=<0d>"), pmp->_ichRef );

            if (LPTSTR( pmp->_cstrDbgName ))
                WriteHelp( g_f, _T(" <0s>"), LPTSTR( pmp->_cstrDbgName ) );
            
            WriteString( g_f, _T("\r\n"));
        }

        ptpCurr = ptpCurr->NextTreePos();
    }
    
    WriteString( g_f, _T("\r\n"));

    if (pLineBreaks)
        delete pLineBreaks;
}

void __cdecl WriteXMLTagBegin( HANDLE hFile, int &nIndent, TCHAR *pchTagName, BOOL fCR, TCHAR *pchFormat, ...);
void WriteXMLTagEnd( HANDLE hFile, int &nIndent, TCHAR *pchTagName, BOOL fDoIndent = FALSE, BOOL fCR = TRUE );
void __cdecl WriteXMLNoScope( HANDLE hFile, int &nIndex, TCHAR *pchTagName, TCHAR *pchFormat, ... );
void __cdecl WriteXMLElement( HANDLE hFile, int &nIndent, TCHAR *pchTagName, TCHAR *pchFormat, ... );
void WriteXMLFormattedString( HANDLE hFile, TCHAR * pch, long cch );

void 
__cdecl
WriteXMLTagBegin( HANDLE hFile, int &nIndent, TCHAR *pchTagName, BOOL fCR, TCHAR *pchFormat, ...)
{
    va_list arg;

    va_start( arg, pchFormat );

    WriteChar( hFile, _T(' '), nIndent );
    WriteHelp( hFile, _T("<<<0s>"), pchTagName );

    if (pchFormat)
    {
        WriteChar( hFile, _T(' ') );
        WriteHelpV( hFile, pchFormat, &arg );
    }

    WriteChar( hFile, _T('>') );
    
    if (fCR)
        WriteString( hFile, _T("\r\n") );

    nIndent++;
}

void 
WriteXMLTagEnd( HANDLE hFile, int &nIndent, TCHAR *pchTagName, BOOL fDoIndent, BOOL fCR)
{
    nIndent--;

    if (fDoIndent)
        WriteChar( hFile, _T(' '), nIndent );

    WriteHelp( hFile, _T("<</<0s>>"), pchTagName );
    
    if (fCR)
        WriteString( hFile, _T("\r\n") );
}

void 
__cdecl
WriteXMLNoScope( HANDLE hFile, int &nIndent, TCHAR *pchTagName, TCHAR *pchFormat, ... )
{
    va_list arg;

    va_start( arg, pchFormat );

    WriteChar( hFile, _T(' '), nIndent );
    WriteHelp( hFile, _T("<<<0s>"), pchTagName );

    if (pchFormat)
    {
        WriteChar( hFile, _T(' ') );
        WriteHelpV( hFile, pchFormat, &arg );
    }
    
    WriteString( hFile, _T("/>\r\n") );
}


void 
__cdecl
WriteXMLElement( HANDLE hFile, int &nIndent, TCHAR *pchTagName, TCHAR *pchFormat, ... )
{
    va_list arg;

    va_start( arg, pchFormat );

    WriteXMLTagBegin( hFile, nIndent, pchTagName, FALSE, NULL );

    if (pchFormat)
        WriteHelpV( hFile, pchFormat, &arg );

    WriteXMLTagEnd( hFile, nIndent, pchTagName );
}

void 
WriteXMLFormattedString( HANDLE hFile, TCHAR * pch, long cch )
{
    if (!pch)
        return;

    for ( int i = 0 ; i < cch ; i++ )
    {
        TCHAR ch = pch[i];

        if (ch >= 1 && ch <= 26)
        {
            if (ch == _T('\r'))
                WriteString( hFile,  _T("\\r"));
            else if (ch == _T('\n'))
                WriteString( hFile, _T("\\n"));
            else
            {
                WriteHelp( hFile, _T("[<0d>]"), (long)int(ch) );
            }
        }
        else
        {
            switch ( ch )
            {
            case 0 :
                WriteString( hFile, _T("[NULL]"));
                break;

            case _T('<'):
                WriteString( hFile, _T("&lt;"));
                break;

            case _T('>'):
                WriteString( hFile, _T("&gt;"));
                break;

            case _T('&'):
                WriteString( hFile, _T("&amp;"));
                break;

            case WCH_NODE:
                WriteString( hFile, _T("[Node]"));
                break;

            case WCH_NBSP :
                WriteString( hFile, _T("[NBSP]"));
                break;

            default :
                if (ch < 256 && _istprint(ch))
                {
                    WriteChar(hFile, ch);
                }
                else
                {
                    TCHAR achHex[9];

                    Format( 0, achHex, ARRAY_SIZE(achHex), _T("<0x>"), ch);

                    StrCpy( achHex, TEXT("[U+") );
                    StrCpy( achHex + 3, achHex + 4 );
                    StrCpy( achHex + 7, TEXT("]") );

                    WriteString( hFile, achHex );
                }

                break;
            }
        }
    }
}

void
CMarkup::DumpTreeInXML ( )
{
    HANDLE  hFile = 0;
    int     nIndent = 0;

    // TODO: I don't handle unembeded pointers yet.
    Verify( ! EmbedPointers() );

    hFile = CreateFile(
            _T("c:\\tridump.xml"),
            GENERIC_WRITE | GENERIC_READ,
            FILE_SHARE_WRITE | FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        AssertSz(0, "CreateFile failed for DumpTreeInXML");
        return;
    }

    // Write out the root XML element
    WriteXMLTagBegin( hFile, nIndent, _T("Markup"), TRUE, NULL );

    WriteXMLElement( hFile, nIndent, _T("SN"), _T("<0d>"), SN() );
    WriteXMLElement( hFile, nIndent, _T("Length"), _T("<0d>"), long( GetTextLength() ) );

    // Walk the tree, dumping info for each tree pos
    WriteXMLTagBegin( hFile, nIndent, _T("TreePoses"), TRUE, NULL );

    {
        CTreePos * ptp;

        ptp = FirstTreePos();

        while(ptp)
        {
            switch (ptp->Type())
            {
            case CTreePos::NodeBeg:
            case CTreePos::NodeEnd:
                {
                    TCHAR * pchType;

                    if (ptp->IsBeginNode())
                        pchType = _T("NodeBeg");
                    else
                        pchType = _T("NodeEnd");

                    WriteXMLTagBegin( hFile, nIndent, pchType, TRUE, NULL );

                    WriteXMLElement( hFile, nIndent, _T("SN"), _T("<0d>"), ptp->SN() );
                    if (ptp->IsEdgeScope())
                        WriteXMLNoScope( hFile, nIndent, _T("Edge"), NULL );
                    WriteXMLElement( hFile, nIndent, _T("NodeSN"), _T("<0d>"), ptp->Branch()->SN() );

                    WriteXMLTagEnd( hFile, nIndent, pchType, TRUE );
                }

                break;
            case CTreePos::Text:
                WriteXMLTagBegin( hFile, nIndent, _T("Text"), TRUE, NULL );

                WriteXMLElement( hFile, nIndent, _T("SN"), _T("<0d>"), ptp->SN() );
                WriteXMLElement( hFile, nIndent, _T("Length"), _T("<0d>"), ptp->Cch() );
                WriteXMLElement( hFile, nIndent, _T("ScriptID"), _T("<0s>"), SidName( ptp->Sid() ) );
                if (ptp->TextID())
                    WriteXMLElement( hFile, nIndent, _T("TextID"), _T("<0d>"), ptp->TextID() );

                WriteXMLTagBegin( hFile, nIndent, _T("Content"), FALSE, NULL );
                {
                    TCHAR * pch;
                    long    cch = ptp->Cch();
                    long    cp = ptp->GetCp();
                    CTxtPtr tp(this, cp);

                    pch = (TCHAR*)MemAlloc(Mt(Mem), sizeof(TCHAR)*cch);
                    Assert(pch);

                    Assert( cch == tp.GetRawText( cch, pch ) );

                    WriteXMLFormattedString( hFile, pch, cch );

                    MemFree( pch );
                }

                WriteXMLTagEnd( hFile, nIndent, _T("Content"), FALSE );

                WriteXMLTagEnd( hFile, nIndent, _T("Text"), TRUE );

                break;
            case CTreePos::Pointer:
                {
                    CMarkupPointer * pmp = ptp->MarkupPointer();
                    LPTSTR pchDbgName = pmp ? LPTSTR( pmp->_cstrDbgName ) : NULL;

                    WriteXMLTagBegin( hFile, nIndent, _T("Pointer"), TRUE, NULL );

                    WriteXMLElement( hFile, nIndent, _T("SN"), _T("<0d>"), ptp->SN() );
                    WriteXMLElement( hFile, nIndent, _T("Gravity"), _T("<0s>"), ptp->Gravity() ? _T("Right") : _T("Left") );
                    if (ptp->Cling())
                        WriteXMLNoScope( hFile, nIndent, _T("Cling"), NULL );
                    if (pchDbgName)
                        WriteXMLElement( hFile, nIndent, _T("DebugName"), _T("<0s>"), pchDbgName );

                    WriteXMLTagEnd( hFile, nIndent, _T("Pointer"), TRUE );
                }
                break;
            }

            ptp = ptp->NextTreePos();
        }
    }
    WriteXMLTagEnd( hFile, nIndent, _T("TreePoses"), TRUE );

    // Walk the tree, dumping info for each tree node
    WriteXMLTagBegin( hFile, nIndent, _T("TreeNodes"), TRUE, NULL );
    {
        CTreePos * ptp;

        ptp = FirstTreePos();

        while(ptp)
        {
            if (ptp->IsBeginNode())
            {
                CTreeNode * pNode = ptp->Branch();
                CElement * pElement = pNode->Element();

                WriteXMLTagBegin( hFile, nIndent, _T("Node"), TRUE, NULL );

                WriteXMLElement( hFile, nIndent, _T("SN"), _T("<0d>"), pNode->SN() );
                if (!pNode->IsLastBranch())
                    WriteXMLElement( hFile, nIndent, _T("NextBranchSN"), _T("<0d>"), pNode->NextBranch()->SN() );
                if (!pNode->IsFirstBranch())
                    WriteXMLElement( hFile, nIndent, _T("PreviousBranchSN"), _T("<0d>"), pNode->PreviousBranch()->SN() );
                if (pNode->Parent())
                    WriteXMLElement( hFile, nIndent, _T("ParentSN"), _T("<0d>"), pNode->Parent()->SN() );
                if (pNode->_iCF != -1)
                    WriteXMLElement( hFile, nIndent, _T("CharFormat"), _T("<0d>"), pNode->_iCF );
                if (pNode->_iPF != -1)
                    WriteXMLElement( hFile, nIndent, _T("ParaFormat"), _T("<0d>"), pNode->_iPF );
                if (pNode->_iFF != -1)
                    WriteXMLElement( hFile, nIndent, _T("FancyFormat"), _T("<0d>"), pNode->_iFF );
                WriteXMLElement( hFile, nIndent, _T("ElementSN"), _T("<0d>"), pElement->SN() );
                WriteXMLElement( hFile, nIndent, _T("BeginPosSN"), _T("<0d>"), pNode->GetBeginPos()->SN() );
                WriteXMLElement( hFile, nIndent, _T("EndPosSN"), _T("<0d>"), pNode->GetEndPos()->SN() );

                WriteXMLTagEnd( hFile, nIndent, _T("Node"), TRUE );
            }

            ptp = ptp->NextTreePos();
        }
    }
    WriteXMLTagEnd( hFile, nIndent, _T("TreeNodes"), TRUE );

    // Walk the tree, dumping info for each element
    WriteXMLTagBegin( hFile, nIndent, _T("Elements"), TRUE, NULL );
    {
        CTreePos * ptp;

        ptp = FirstTreePos();

        while(ptp)
        {
            if (ptp->IsBeginElementScope())
            {
                CTreeNode * pNode = ptp->Branch();
                CElement * pElement = pNode->Element();

                WriteXMLTagBegin( hFile, nIndent, _T("Element"), TRUE, NULL );

                WriteXMLElement( hFile, nIndent, _T("SN"), _T("<0d>"), pElement->SN() );
                WriteXMLElement( hFile, nIndent, _T("TagName"), _T("<0s>"), pElement->TagName() );
                if (pElement->Namespace())
                    WriteXMLElement( hFile, nIndent, _T("Namespace"), _T("<0s>"), pElement->Namespace() );
                if (pElement->Tag() == ETAG_UNKNOWN)
                    WriteXMLNoScope( hFile, nIndent, _T("Unknown"), NULL );
                if (pElement->_fBreakOnEmpty)
                    WriteXMLNoScope( hFile, nIndent, _T("BreakOnEmpty"), NULL );

                WriteXMLTagBegin( hFile, nIndent, _T("ElementNodes"), TRUE, NULL );
                {
                    CTreeNode * pNode = pElement->GetFirstBranch();
                    while( pNode )
                    {
                        WriteXMLElement( hFile, nIndent, _T("NodeSN"), _T("<0d>"), pNode->SN() );
                        pNode = pNode->NextBranch();
                    }
                }
                WriteXMLTagEnd( hFile, nIndent, _T("ElementNodes"), TRUE );
                

                WriteXMLTagEnd( hFile, nIndent, _T("Element"), TRUE );
            }

            ptp = ptp->NextTreePos();
        }
    }
    WriteXMLTagEnd( hFile, nIndent, _T("Elements"), TRUE );

    // Write out the end of the root XML element
    WriteXMLTagEnd( hFile, nIndent, _T("Markup"), TRUE );

    CloseHandle( hFile );    
}

void
CMarkup::DumpTextChanges ( )
{
    if (!InitDumpFile())
        return;

    WriteString( g_f, _T("Text Change Dump For ped: " ) );

    WriteHelp( g_f, _T("Tree Dump For Markup: M<0d>"), SN() );

    //
    //  TODO: Do this through a DEBUG only notification sent through the tree
    //  TODO: Make this routine into "dump dirty ranges" and have all things
    //        that track ranges respond (e.g., collections, CFlowLayout).
    //

    WriteString( g_f, _T("Unimplemented"));

    WriteString( g_f, _T("\r\n\r\n") );

    CloseDumpFile();
}

void
CMarkup::DumpSplayTree(CTreePos *ptpStart, CTreePos *ptpFinish)
{
    if (!InitDumpFile())
        return;

    if (ptpStart == NULL)
        ptpStart = FirstTreePos();
    if (ptpFinish == NULL)
        ptpFinish = LastTreePos();

    CTreePos *ptpCurr = ptpStart;
    long cDepth = ptpCurr->Depth();

    // for each TreePos in the desired range...
    for (;;)
    {
        // print structure
        for (long i=0; i<cDepth-1; ++i)
            WriteString(g_f, _T("  "));

        if (cDepth > 0)
            WriteString(g_f, ptpCurr->IsLeftChild() ? _T("v ") : _T("^ "));

        // print content
        switch (ptpCurr->Type())
        {
        case CTreePos::NodeBeg:
        case CTreePos::NodeEnd:
            WriteChar(g_f, _T('N'));
            WriteChar(g_f, ptpCurr->IsBeginNode() ? _T('+') : _T('-'));
            if (ptpCurr->IsEdgeScope())
                WriteChar(g_f, _T('*'));
            WriteHelp(g_f, _T(" <0s> <1x>"), ptpCurr->Branch()->Element()->TagName(), ptpCurr->Branch());
            break;
        case CTreePos::Text:
            WriteChar(g_f, _T('T'));
            WriteHelp(g_f, _T("<0d> "), ptpCurr->Cch());
            break;
        case CTreePos::Pointer:
            WriteChar(g_f, _T('P'));
            break;
        }

        // finish printing
        WriteHelp(g_f, _T("  <0x>\r\n"), ptpCurr);

        // terminate loop
        if (ptpCurr == ptpFinish)
            break;

        // advance to next TreePos
        CTreePos *ptpChild = ptpCurr->RightChild();
        if (ptpChild)
        {
            while (ptpChild)
            {
                ++ cDepth;
                ptpCurr = ptpChild;
                ptpChild = ptpCurr->LeftChild();
            }
        }
        else
        {
            while (!ptpCurr->IsLeftChild())
            {
                -- cDepth;
                ptpCurr = ptpCurr->Parent();
            }
            -- cDepth;
            ptpCurr = ptpCurr->Parent();
        }
    }

    CloseDumpFile();
}
#endif


#if DBG==1
void
CMarkup::DumpDisplayTree()
{
    Doc()->GetView()->DumpDisplayTree();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\edrouter.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       EDROUTER.CXX
//
//  Contents:   Infrastructure for appropriate routing of edit commands
//
//  Classes:    CEditRouter
//
//  History:    19-Feb-98   raminh  Created
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include "mshtmhst.h"
#endif

#ifndef X_EDROUTER_HXX_
#define X_EDROUTER_HXX_
#include "edrouter.hxx"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

extern "C" const CLSID  CLSID_Mshtmled;
extern "C" const GUID   SID_SEditCommandTarget;
extern "C" const GUID   CGID_EditStateCommands;

DeclareTag( tagEditRouter, "EditRouter", "EditRouter traces" );

//+-------------------------------------------------------------------------
//
//  CEditRouter constructor and destructors
//
//--------------------------------------------------------------------------
CEditRouter::CEditRouter()
{
    _pInternalCmdTarget = NULL;
    _pHostCmdTarget = NULL;
    _fHostChecked = FALSE;
}

void
CEditRouter::Passivate()
{
    TraceTag( (tagEditRouter, "CEditRouter::Passivate: this [%x]", this ) );
    
    ReleaseInterface( _pInternalCmdTarget );
    _pInternalCmdTarget = NULL;
    ReleaseInterface( _pHostCmdTarget );
    _pHostCmdTarget = NULL;
    _fHostChecked = FALSE;
}

CEditRouter::~CEditRouter()
{
    Passivate();    // Dup call just in case it wasn't already done.
}

//+-------------------------------------------------------------------------
//
//  Method:     CEditRouter::ExecEditCommand
//
//  Synopsis:   Routes and editing command to the appropriate edit handler(s);
//              last parameter provides the context in which the edit operation
//              will be carried on by the edit handler.
//
// Notes: If the host provides an edit handler, then commands are routed there 
//        and creation of the default edit handler (Mshtmled) is deferred to later. 
//        In fact, the default handler may never be created, for instance, when
//        all commands are supported by the host handler.
//
//--------------------------------------------------------------------------
HRESULT
CEditRouter::ExecEditCommand(GUID *          pguidCmdGroup,
                             DWORD           nCmdID,
                             DWORD           nCmdexecopt,
                             VARIANTARG *    pvarargIn,
                             VARIANTARG *    pvarargOut,
                             IUnknown   *    punkContext,
                             CDoc *          pDoc )
{
    int                 idm;
    HRESULT             hr = OLECMDERR_E_NOTSUPPORTED;

    if ( punkContext == NULL || ! pDoc )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    punkContext->AddRef();
    
    // If there is no host to route to yet...
    if( _pHostCmdTarget == NULL && ! _fHostChecked )
    {
        hr = THR( SetHostEditHandler( punkContext, pDoc ));
        _fHostChecked = TRUE;
    }

    //
    //  Commands are described using a pair of CmdGroup and CmdID. IDMFromCmdID an IDM, which is
    //  the canonical form of the CmdGroup + CmdID pair. 
    //  If IDM is unknown it can only be sent to the host, since it may be a new command that the
    //  host can handle. In this case the original CmdGroup + CmdID is sent to the host. Otherwise
    //  the canonical form (IDM + CGID_MSHTML) is sent to the host.
    //  MshtmlEd is only sent the canonical form, since it will not be able to handle unknown commands.
    //
    idm = CBase::IDMFromCmdID(pguidCmdGroup, nCmdID);

    if (_pHostCmdTarget)
    {   //
        // Route command to the host edit handler first
        //
        
        if (idm == IDM_UNKNOWN)
            hr = THR_NOTRACE( _pHostCmdTarget->Exec(
                    pguidCmdGroup, 
                    nCmdID, 
                    nCmdexecopt, 
                    pvarargIn, pvarargOut));
        else
            hr = THR_NOTRACE( _pHostCmdTarget->Exec(
                    &CGID_MSHTML, 
                    idm, 
                    nCmdexecopt, 
                    pvarargIn, pvarargOut));
        
        if( !FAILED( hr ))
            goto Cleanup; // The host handled the command so we're done.
    }

    // Okay, the host didn't like that one. Lets send it to our internal editor
    // If we don't know what it is, bail...
    if (idm == IDM_UNKNOWN)
    {
        hr = OLECMDERR_E_NOTSUPPORTED;
        goto Cleanup;
    }

    // Dispatch to our internal handler based on the passed in punk
    if( _pInternalCmdTarget == NULL )
    {
        hr = SetInternalEditHandler( punkContext, pDoc, TRUE );  // If we get here, our only hope is the editor
        if( hr )
            goto Cleanup;       // outta here
    }

    if( pDoc->GetHTMLEditor(FALSE) )
    {   
        hr = THR_NOTRACE( _pInternalCmdTarget->Exec(
                &CGID_MSHTML, 
                idm, 
                nCmdexecopt, 
                pvarargIn, pvarargOut));
    }

Cleanup:

    // Temporary workaround for cycle problem with addref'd
    // IOleCommandTarget's in the editor
    Passivate();
    ReleaseInterface( punkContext );
    
    SRETURN(hr);
}

//+-------------------------------------------------------------------------
//
// Method:      CEditRouter::QueryStatusEditCommand
//
// Description: This method takes QueryStatus calls from ranges and from the
//              CDoc::PrivateQueryStatus() and determines if the editor can
//              handle the command or not.
//
//              The punkContext passed in is an IUnknown pointer to a range or
//              to a CMarkup.  We use this pointer to retrieve the correct
//              IOleCommandTarget from the editor.
//
// Arguments:   pguidCmdGroup = GUID of command group
//              cCmds = Number of commands
//              rgCmds = Array of commands
//              pcmdtext =
//
//              punkContext = Context of caller.  For a range, this will be
//               a pointer to a range.  If the call is coming from 
//               CDoc::QueryStatus, this will be a markup
//
//              pMarkup = If the caller is from CDoc::QueryStatus, this 
//               will contain the CMarkup pointer.
//
//              pDoc = Pointer to main CDoc
//+-------------------------------------------------------------------------
HRESULT
CEditRouter::QueryStatusEditCommand(GUID * pguidCmdGroup,
                                    ULONG cCmds,
                                    MSOCMD rgCmds[],
                                    MSOCMDTEXT * pcmdtext,
                                    IUnknown * punkContext,
                                    CMarkup *pMarkup,
                                    CDoc * pDoc )
{ 
    ULONG               idm;
    HRESULT             hr = S_OK;

    // TODO: raminh removed the assert below.  
    //
    // Which is curious, because we certainly are NOT handling the query status
    // of multiple commands in this code.  Think about re-enabling - johnthim
    //
    // Assert( cCmds == 1 );
    MSOCMD * pCmd = & rgCmds[ 0 ];
    MSOCMD newCommand;
    
    // If there is no host to route to yet...
    if( _pHostCmdTarget == NULL && ! _fHostChecked )
    {
        hr = THR_NOTRACE(SetHostEditHandler( punkContext, pDoc ));
        _fHostChecked = TRUE;
    }

    //
    //  Commands are described using a pair of CmdGroup and CmdID. IDMFromCmdID an IDM, which is
    //  the canonical form of the CmdGroup + CmdID pair. 
    //  If IDM is unknown it can only be sent to the host, since it may be a new command that the
    //  host can handle. In this case the original CmdGroup + CmdID is sent to the host. Otherwise
    //  the canonical form (IDM + CGID_MSHTML) is sent to the host.
    //  MshtmlEd is only sent the canonical form, since it will not be able to handle unknown commands.
    //
    idm = CBase::IDMFromCmdID(pguidCmdGroup,pCmd->cmdID);
    
    newCommand.cmdf = 0;    // just initialize (alexa)
    newCommand.cmdID = idm; // store the new Command Id.
    
    if (_pHostCmdTarget)
    {   //
        // Route command to the host edit handler first
        //
        
        if (idm == IDM_UNKNOWN)
            hr = _pHostCmdTarget->QueryStatus(
                    pguidCmdGroup, 
                    cCmds,
                    &newCommand ,
                    pcmdtext );
        else
            hr = _pHostCmdTarget->QueryStatus(
                    &CGID_MSHTML, 
                    cCmds, & newCommand, 
                    pcmdtext );
        
        if( ! FAILED( hr ))
            goto Cleanup; // The host handled the command so we're done.
    }

    // If we don't know what it is, bail...
    if (idm == IDM_UNKNOWN)
    {
        hr = OLECMDERR_E_NOTSUPPORTED;
        goto Cleanup;
    }

    // Dispatch to our internal handler
    if( _pInternalCmdTarget == NULL )
    {
        hr = SetInternalEditHandler( punkContext, pDoc, FALSE ); // Do NOT force creation of the editor
        if( hr )
            goto Cleanup;       // outta here
    }

    if( _pInternalCmdTarget == NULL ) // We are STILL null after last check...
    {
        switch( idm )
        {
            // PUT ALL THE COMMANDS THAT SHOULD BE ENABLED EVEN IF THERE ISN'T AN EDITOR TO CHECK WITH HERE
            case IDM_SELECTALL:
                if( !pMarkup || !pMarkup->_fFrameSet )
                    newCommand.cmdf = MSOCMDSTATE_UP;
                else
                    newCommand.cmdf = MSOCMDSTATE_DISABLED;
                break;
            
            default:
                newCommand.cmdf = MSOCMDSTATE_DISABLED;
        }
        goto Cleanup;
    }
    
    // _pInternalCmdTarget  can be null if an event fired that 
    // changed the document. sadness
    if( _pInternalCmdTarget && pDoc->GetHTMLEditor(FALSE) )
    {
        //
        // HACKHACK: Outlook98 assumes that we always have either justify left, center, or right.
        // With the addition of the justify none command, this assumption is no longer valid.  
        // So, we check justify none so that Outlook's assumption holds.
        //
        // TODO: expose fOutlook98 for the editor.  Check with johnbed. [ashrafm]
        //
        
        if (pDoc->_fOutlook98 
            && newCommand.cmdID == IDM_JUSTIFYLEFT)
        {
            newCommand.cmdID = IDM_JUSTIFYNONE; // try the common case first
            
            hr = THR_NOTRACE( _pInternalCmdTarget->QueryStatus(
                            &CGID_MSHTML, 
                            cCmds, & newCommand, 
                            pcmdtext ));
    
            if (hr || newCommand.cmdf == MSOCMDSTATE_DOWN)
                goto Cleanup; // done
    
            newCommand.cmdID = IDM_JUSTIFYLEFT; // now try left
        }
    
        hr = THR_NOTRACE( _pInternalCmdTarget->QueryStatus(
                    &CGID_MSHTML, 
                    cCmds, & newCommand, 
                    pcmdtext ));
    }

Cleanup:

    Passivate();
    
    if (hr == S_OK)
        pCmd->cmdf = newCommand.cmdf;

    SRETURN( hr );
}


//+-------------------------------------------------------------------------
//
//  Method:     CEditRouter::SetHostEditHandler
//
//  Synopsis:   Helper routine to get an IOleCommandTarget from the host 
//              (if any), where editing commands will be routed.
//--------------------------------------------------------------------------
HRESULT
CEditRouter::SetHostEditHandler(IUnknown * punkContext, CDoc * pDoc )
{
    IServiceProvider      * pServiceProvider = 0;
    VARIANTARG              varParamIn;
    HRESULT                 hr = S_FALSE;
    
    hr = pDoc->QueryInterface(  IID_IServiceProvider, 
                                (void**)&pServiceProvider);
    if (hr)
        goto Cleanup;

    hr = pServiceProvider->QueryService(SID_SEditCommandTarget, 
                                        IID_IOleCommandTarget,
                                        (void **) &_pHostCmdTarget);
    if (hr)
        goto Cleanup;

    V_VT(&varParamIn)      = VT_UNKNOWN;
    V_UNKNOWN(&varParamIn) = punkContext;
    hr = _pHostCmdTarget->Exec(&CGID_EditStateCommands, 
                                   IDM_CONTEXT, 0,
                                   &varParamIn, NULL);
    if (hr)
    {   //
        // Host will not be able to process edit commands properly, 
        // since it failed to handle EditStateCommand. Nullify HostEditHandler.
        //
        ClearInterface(&_pHostCmdTarget);
        goto Cleanup;
    }

Cleanup:
    ReleaseInterface( pServiceProvider );

    RRETURN( hr );
}


HRESULT
CEditRouter::SetInternalEditHandler( 
    IUnknown *      punkContext , 
    CDoc *          pDoc,
    BOOL            fForceCreate )
{
    HRESULT         hr = S_OK;
    IHTMLEditor     *ped = NULL;
    IUnknown        *punk = NULL;
    IHTMLDocument   *pTest = NULL;
    BOOL            fRange;
    
    AssertSz( _pInternalCmdTarget == NULL , "CEditRouter::SetInternalEditHandler called when it already has one." );
    
    if( _pInternalCmdTarget != NULL )
        goto Cleanup;
        
    // See if we are being passed in a range as our context
    hr = punkContext->QueryInterface( IID_IHTMLDocument , (void **) &pTest );
    ReleaseInterface( pTest );
    fRange = (hr != S_OK);

    ped = pDoc->GetHTMLEditor( fRange ? TRUE : fForceCreate );
    if( ped == NULL )
    {
        hr = S_OK;
        _pInternalCmdTarget = NULL;
        goto Cleanup;
    }


#if DBG == 1
    if( fRange )   
    {
        ISegmentList * pSLTest = NULL;
        hr = THR( punkContext->QueryInterface( IID_ISegmentList, 
                                        (void **) &pSLTest ));
        AssertSz( !FAILED( hr ) , "CEditRouter punkContext is not castable to an ISegmentList" );
        ReleaseInterface( pSLTest );
    }
#endif // DBG == 1

    hr = THR( ped->GetCommandTarget( punkContext, &punk ));
    if( hr )
        goto Cleanup;

        
    hr = THR( punk->QueryInterface( IID_IOleCommandTarget, 
                                    (void **) &_pInternalCmdTarget ));
    if( hr )
        goto Cleanup;
   
Cleanup:
    ReleaseInterface( punk );
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\elemlyt.cxx ===
//==================================================================
//
//  File : ElemLyt.cxx
//
//  Contents : The CElement functions related to handling their layouts
//
//==================================================================
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_INPUTLYT_HXX_
#define X_INPUTLYT_HXX_
#include "inputlyt.hxx"
#endif

#ifndef X_CKBOXLYT_HXX_
#define X_CKBOXLYT_HXX_
#include "ckboxlyt.hxx"
#endif

#ifndef X_FSLYT_HXX_
#define X_FSLYT_HXX_
#include "fslyt.hxx"
#endif

#ifndef X_FRAMELYT_HXX_
#define X_FRAMELYT_HXX_
#include "framelyt.hxx"
#endif

#ifndef X_SELLYT_HXX_
#define X_SELLYT_HXX_
#include "sellyt.hxx"
#endif

#ifndef X_OLELYT_HXX_
#define X_OLELYT_HXX_
#include "olelyt.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_BODYLYT_HXX_
#define X_BODYLYT_HXX_
#include "bodylyt.hxx"
#endif

#ifndef X_BTNLYT_HXX_
#define X_BTNLYT_HXX_
#include "btnlyt.hxx"
#endif

#ifndef X_TAREALYT_HXX_
#define X_TAREALYT_HXX_
#include "tarealyt.hxx"
#endif

#ifndef X_IMGLYT_HXX_
#define X_IMGLYT_HXX_
#include "imglyt.hxx"
#endif

#ifndef X_HRLYT_HXX_
#define X_HRLYT_HXX_
#include "hrlyt.hxx"
#endif

#ifndef X_HTMLLYT_HXX_
#define X_HTMLLYT_HXX_
#include "htmllyt.hxx"
#endif

#ifndef X_MARQLYT_HXX_
#define X_MARQLYT_HXX_
#includ