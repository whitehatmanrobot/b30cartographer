                      &Length,
                                  Source,
                                  SourceLength * sizeof(WCHAR)
                                 );
        if (NT_SUCCESS(Status)) {
            return Length;
        } else {
            return 0;
        }
    } else {
        ASSERT (Source != (LPWSTR)Target);
#ifdef SOURCE_EQ_TARGET
        LPSTR pszDestTmp;
        CHAR StackBuffer[STACK_BUFFER_SIZE];

        DBGCHARS(("ConvertOutputToOem U->%d %.*ls\n", Codepage,
                SourceLength > 10 ? 10 : SourceLength, Source));

        if (TargetLength > STACK_BUFFER_SIZE) {
            pszDestTmp = ConsoleHeapAlloc(TMP_TAG, TargetLength);
            if (pszDestTmp == NULL) {
                return 0;
            }
        } else {
            pszDestTmp = StackBuffer;
        }
        TargetLength = WideCharToMultiByte(Codepage, 0,
                Source, SourceLength,
                pszDestTmp, TargetLength, NULL, NULL);

        RtlCopyMemory(Target, pszDestTmp, TargetLength);
        if (pszDestTmp != StackBuffer) {
            ConsoleHeapFree(pszDestTmp);
        }
        return TargetLength;
#else
        DBGCHARS(("ConvertOutputToOem U->%d %.*ls\n", Codepage,
                SourceLength > 10 ? 10 : SourceLength, Source));
        return WideCharToMultiByte(Codepage, 0,
                Source, SourceLength, Target, TargetLength, NULL, NULL);
#endif
    }
}

NTSTATUS
RealUnicodeToFalseUnicode(
    IN OUT LPWSTR Source,
    IN int SourceLength,     // in chars
    IN UINT Codepage
    )

/*

    this routine converts a unicode string into the correct characters
    for an OEM (cp 437) font.  this code is needed because the gdi glyph
    mapper converts unicode to ansi using codepage 1252 to index
    font.  this is how the data is stored internally.

*/

{
    NTSTATUS Status;
    LPSTR Temp;
    ULONG TempLength;
    ULONG Length;
    CHAR StackBuffer[STACK_BUFFER_SIZE];
    BOOL NormalChars;
    int i;

    DBGCHARS(("RealUnicodeToFalseUnicode U->%d:ACP->U %.*ls\n", Codepage,
            SourceLength > 10 ? 10 : SourceLength, Source));
#if defined(FE_SB)
    if (OEMCP == WINDOWSCP && Codepage == WINDOWSCP)
        return STATUS_SUCCESS;
    if (SourceLength == 0 )
        return STATUS_SUCCESS;
#endif
    NormalChars = TRUE;
    for (i=0;i<SourceLength;i++) {
        if (Source[i] > 0x7f) {
            NormalChars = FALSE;
            break;
        }
    }
    if (NormalChars) {
        return STATUS_SUCCESS;
    }
    TempLength = SourceLength;
    if (TempLength > STACK_BUFFER_SIZE) {
        Temp = ConsoleHeapAlloc(TMP_TAG, TempLength);
        if (Temp == NULL) {
            return STATUS_NO_MEMORY;
        }
    } else {
        Temp = StackBuffer;
    }
    if (Codepage == OEMCP) {
        Status = RtlUnicodeToOemN(Temp,
                                  TempLength,
                                  &Length,
                                  Source,
                                  SourceLength * sizeof(WCHAR)
                                 );
    } else {
        Status = WideCharToMultiByte(Codepage,
                                   0,
                                   Source,
                                   SourceLength,
                                   Temp,
                                   TempLength,
                                   NULL,
                                   NULL);
    }
    if (!NT_SUCCESS(Status)) {
        if (TempLength > STACK_BUFFER_SIZE) {
            ConsoleHeapFree(Temp);
        }
        return Status;
    }

    if (CONSOLE_IS_DBCS_ENABLED()) {
        MultiByteToWideChar(USACP,
                        0,
                        Temp,
                        TempLength,
                        Source,
                        SourceLength
                       );
    } else {
        Status = RtlMultiByteToUnicodeN(Source,
                           SourceLength * sizeof(WCHAR),
                           &Length,
                           Temp,
                           TempLength
                          );
    }

    if (TempLength > STACK_BUFFER_SIZE) {
        ConsoleHeapFree(Temp);
    }
    if (!NT_SUCCESS(Status)) {
        return Status;
    } else {
        return STATUS_SUCCESS;
    }
}

NTSTATUS
FalseUnicodeToRealUnicode(
    IN OUT LPWSTR Source,
    IN int SourceLength,     // in chars
    IN UINT Codepage
    )

/*

    this routine converts a unicode string from the internally stored
    unicode characters into the real unicode characters.

*/

{
    NTSTATUS Status;
    LPSTR Temp;
    ULONG TempLength;
    ULONG Length;
    CHAR StackBuffer[STACK_BUFFER_SIZE];
    BOOL NormalChars;
    int i;

    DBGCHARS(("UnicodeAnsiToUnicodeAnsi U->ACP:%d->U %.*ls\n", Codepage,
            SourceLength > 10 ? 10 : SourceLength, Source));
#if defined(FE_SB)
    if (OEMCP == WINDOWSCP && Codepage == WINDOWSCP)
        return STATUS_SUCCESS;
    if (SourceLength == 0 )
        return STATUS_SUCCESS;
#endif
    NormalChars = TRUE;
    /*
     * Test for characters < 0x20 or >= 0x7F.  If none are found, we don't have
     * any conversion to do!
     */
    for (i=0;i<SourceLength;i++) {
        if ((USHORT)(Source[i] - 0x20) > 0x5e) {
            NormalChars = FALSE;
            break;
        }
    }
    if (NormalChars) {
        return STATUS_SUCCESS;
    }

    TempLength = SourceLength;
    if (TempLength > STACK_BUFFER_SIZE) {
        Temp = ConsoleHeapAlloc(TMP_TAG, TempLength);
        if (Temp == NULL) {
            return STATUS_NO_MEMORY;
        }
    } else {
        Temp = StackBuffer;
    }
    if (CONSOLE_IS_DBCS_ENABLED()) {
        Status = WideCharToMultiByte(USACP,
                                 0,
                                 Source,
                                 SourceLength,
                                 Temp,
                                 TempLength,
                                 NULL,
                                 NULL);
    } else {
        Status = RtlUnicodeToMultiByteN(Temp,
                                    TempLength,
                                    &Length,
                                    Source,
                                    SourceLength * sizeof(WCHAR)
                                   );
    }

    if (!NT_SUCCESS(Status)) {
        if (TempLength > STACK_BUFFER_SIZE) {
            ConsoleHeapFree(Temp);
        }
        return Status;
    }
    if (Codepage == OEMCP) {
        Status = RtlCustomCPToUnicodeN(&GlyphCP,
                                  Source,
                                  SourceLength * sizeof(WCHAR),
                                  &Length,
                                  Temp,
                                  TempLength
                                 );
    } else {
        Status = MultiByteToWideChar(Codepage,
                                   MB_USEGLYPHCHARS,
                                   Temp,
                                   TempLength*sizeof(WCHAR),
                                   Source,
                                   SourceLength);
    }
#if defined(FE_SB)
    if (SourceLength > STACK_BUFFER_SIZE) {
        ConsoleHeapFree(Temp);
    }
#else
    if (TempLength > STACK_BUFFER_SIZE) {
        ConsoleHeapFree(Temp);
    }
#endif
    if (!NT_SUCCESS(Status)) {
        return Status;
    } else {
        return STATUS_SUCCESS;
    }
}


BOOL InitializeCustomCP() {
    PPEB pPeb;

    pPeb = NtCurrentPeb();
    if ((pPeb == NULL) || (pPeb->OemCodePageData == NULL)) {
        return FALSE;
    }

    /*
     * Fill in the CPTABLEINFO struct
     */
    RtlInitCodePageTable(pPeb->OemCodePageData, &GlyphCP);

    /*
     * Make a copy of the MultiByteToWideChar table
     */
    RtlCopyMemory(GlyphTable, GlyphCP.MultiByteTable, 256 * sizeof(USHORT));

    /*
     * Modify the first 0x20 bytes so that they are glyphs.
     */
    MultiByteToWideChar(CP_OEMCP, MB_USEGLYPHCHARS,
            "\x20\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F"
            "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F",
            0x20, GlyphTable, 0x20);
    MultiByteToWideChar(CP_OEMCP, MB_USEGLYPHCHARS,
            "\x7f", 1, &GlyphTable[0x7f], 1);


    /*
     * Point the Custom CP at the glyph table
     */
    GlyphCP.MultiByteTable = GlyphTable;

#if defined(FE_SB) && defined(i386)
    if (ISNECPC98(gdwMachineId)) {
        InitializeNEC_OS2_CP();
    }
#endif
    return TRUE;
}

#if defined(FE_SB)
VOID
SetConsoleCPInfo(
    IN PCONSOLE_INFORMATION Console,
    IN BOOL Output
    )
{
    if (Output) {
        if (! GetCPInfo(Console->OutputCP,
                        &Console->OutputCPInfo)) {
            Console->OutputCPInfo.LeadByte[0] = 0;
        }
    }
    else {
        if (! GetCPInfo(Console->CP,
                        &Console->CPInfo)) {
            Console->CPInfo.LeadByte[0] = 0;
        }
    }
}

BOOL
CheckBisectStringW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN DWORD CodePage,
    IN PWCHAR Buffer,
    IN DWORD NumWords,
    IN DWORD NumBytes
    )

/*++

Routine Description:

    This routine check bisected on Unicode string end.

Arguments:

    ScreenInfo - Pointer to screen information structure.

    CodePage - Value of code page.

    Buffer - Pointer to Unicode string buffer.

    NumWords - Number of Unicode string.

    NumBytes - Number of bisect position by byte counts.

Return Value:

    TRUE - Bisected character.

    FALSE - Correctly.

--*/

{
    while(NumWords && NumBytes) {
        if (IsConsoleFullWidth(ScreenInfo->Console->hDC,CodePage,*Buffer)) {
            if (NumBytes < 2)
                return TRUE;
            else {
                NumWords--;
                NumBytes -= 2;
                Buffer++;
            }
        }
        else {
            NumWords--;
            NumBytes--;
            Buffer++;
        }
    }
    return FALSE;
}

BOOL
CheckBisectProcessW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN DWORD CodePage,
    IN PWCHAR Buffer,
    IN DWORD NumWords,
    IN DWORD NumBytes,
    IN SHORT OriginalXPosition,
    IN BOOL Echo
    )

/*++

Routine Description:

    This routine check bisected on Unicode string end.

Arguments:

    ScreenInfo - Pointer to screen information structure.

    CodePage - Value of code page.

    Buffer - Pointer to Unicode string buffer.

    NumWords - Number of Unicode string.

    NumBytes - Number of bisect position by byte counts.

    Echo - TRUE if called by Read (echoing characters)

Return Value:

    TRUE - Bisected character.

    FALSE - Correctly.

--*/

{
    WCHAR Char;
    ULONG TabSize;

    if (ScreenInfo->OutputMode & ENABLE_PROCESSED_OUTPUT) {
        while(NumWords && NumBytes) {
            Char = *Buffer;
            if (Char >= (WCHAR)' ') {
                if (IsConsoleFullWidth(ScreenInfo->Console->hDC,CodePage,Char)) {
                    if (NumBytes < 2)
                        return TRUE;
                    else {
                        NumWords--;
                        NumBytes -= 2;
                        Buffer++;
                        OriginalXPosition += 2;
                    }
                }
                else {
                    NumWords--;
                    NumBytes--;
                    Buffer++;
                    OriginalXPosition++;
                }
            }
            else {
                NumWords--;
                Buffer++;
                switch (Char) {
                    case UNICODE_BELL:
                        if (Echo)
                            goto CtrlChar;
                        break;
                    case UNICODE_BACKSPACE:
                    case UNICODE_LINEFEED:
                    case UNICODE_CARRIAGERETURN:
                        break;
                    case UNICODE_TAB:
                        TabSize = NUMBER_OF_SPACES_IN_TAB(OriginalXPosition);
                        OriginalXPosition = (SHORT)(OriginalXPosition + TabSize);
                        if (NumBytes < TabSize)
                            return TRUE;
                        NumBytes -= TabSize;
                        break;
                    default:
                        if (Echo) {
                    CtrlChar:
                            if (NumBytes < 2)
                                return TRUE;
                            NumBytes -= 2;
                            OriginalXPosition += 2;
                        } else {
                            NumBytes--;
                            OriginalXPosition++;
                        }
                }
            }
        }
        return FALSE;
    }
    else {
        return CheckBisectStringW(ScreenInfo,
                                  CodePage,
                                  Buffer,
                                  NumWords,
                                  NumBytes);
    }
}
#endif // FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\input.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    input.c

Abstract:

        This file implements the circular buffer management for
        input events.

        The circular buffer is described by a header,
        which resides in the beginning of the memory allocated when the
        buffer is created.  The header contains all of the
        per-buffer information, such as reader, writer, and
        reference counts, and also holds the pointers into
        the circular buffer proper.

        When the in and out pointers are equal, the circular buffer
        is empty.  When the in pointer trails the out pointer
        by 1, the buffer is full.  Thus, a 512 byte buffer can hold
        only 511 bytes; one byte is lost so that full and empty
        conditions can be distinguished. So that the user can
        put 512 bytes in a buffer that they created with a size
        of 512, we allow for this byte lost when allocating
        the memory.

Author:

    Therese Stowell (thereses) 6-Nov-1990
    Adapted from OS/2 subsystem server\srvpipe.c

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define CTRL_BUT_NOT_ALT(n) \
        (((n) & (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED)) && \
        !((n) & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED)))

UINT ProgmanHandleMessage;

int DialogBoxCount;

LPTHREAD_START_ROUTINE CtrlRoutine;  // address of client side ctrl-thread routine

DWORD InputThreadTlsIndex;

#define MAX_CHARS_FROM_1_KEYSTROKE 6


//
// the following data structures are a hack to work around the fact that
// MapVirtualKey does not return the correct virtual key code in many cases.
// we store the correct info (from the keydown message) in the CONSOLE_KEY_INFO
// structure when a keydown message is translated.  then when we receive a
// wm_[sys][dead]char message, we retrieve it and clear out the record.
//

#define CONSOLE_FREE_KEY_INFO 0
#define CONSOLE_MAX_KEY_INFO 32

typedef struct _CONSOLE_KEY_INFO {
    HWND hWnd;
    WORD wVirtualKeyCode;
    WORD wVirtualScanCode;
} CONSOLE_KEY_INFO, *PCONSOLE_KEY_INFO;

CONSOLE_KEY_INFO ConsoleKeyInfo[CONSOLE_MAX_KEY_INFO];

VOID
UserExitWorkerThread(NTSTATUS Status);

BOOL
InitWindowClass( VOID );

#if !defined(FE_SB)
NTSTATUS
ReadBuffer(
    IN PINPUT_INFORMATION InputInformation,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG EventsRead,
    IN BOOL Peek,
    IN BOOL StreamRead,
    OUT PBOOL ResetWaitEvent
    );
#endif

NTSTATUS
CreateInputBuffer(
    IN ULONG NumberOfEvents OPTIONAL,
    IN PINPUT_INFORMATION InputBufferInformation
#if defined(FE_SB)
    ,
    IN PCONSOLE_INFORMATION Console
#endif
    )

/*++

Routine Description:

    This routine creates an input buffer.  It allocates the circular
    buffer and initializes the information fields.

Arguments:

    NumberOfEvents - Size of input buffer in events.

    InputBufferInformation - Pointer to input buffer information structure.

Return Value:


--*/

{
    ULONG BufferSize;
    NTSTATUS Status;

    if (NumberOfEvents == 0) {
        NumberOfEvents = DEFAULT_NUMBER_OF_EVENTS;
    }

    // allocate memory for circular buffer

    BufferSize =  sizeof(INPUT_RECORD) * (NumberOfEvents+1);
    InputBufferInformation->InputBuffer = ConsoleHeapAlloc(BUFFER_TAG, BufferSize);
    if (InputBufferInformation->InputBuffer == NULL) {
        return STATUS_NO_MEMORY;
    }
    Status = NtCreateEvent(&InputBufferInformation->InputWaitEvent,
                           EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE);
    if (!NT_SUCCESS(Status)) {
        ConsoleHeapFree(InputBufferInformation->InputBuffer);
        return STATUS_NO_MEMORY;
    }
    InitializeListHead(&InputBufferInformation->ReadWaitQueue);

    // initialize buffer header

    InputBufferInformation->InputBufferSize = NumberOfEvents;
    InputBufferInformation->ShareAccess.OpenCount = 0;
    InputBufferInformation->ShareAccess.Readers = 0;
    InputBufferInformation->ShareAccess.Writers = 0;
    InputBufferInformation->ShareAccess.SharedRead = 0;
    InputBufferInformation->ShareAccess.SharedWrite = 0;
    InputBufferInformation->InputMode = ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT | ENABLE_ECHO_INPUT | ENABLE_MOUSE_INPUT;
    InputBufferInformation->RefCount = 0;
    InputBufferInformation->First = (ULONG_PTR) InputBufferInformation->InputBuffer;
    InputBufferInformation->In = (ULONG_PTR) InputBufferInformation->InputBuffer;
    InputBufferInformation->Out = (ULONG_PTR) InputBufferInformation->InputBuffer;
    InputBufferInformation->Last = (ULONG_PTR) InputBufferInformation->InputBuffer + BufferSize;
#if defined(FE_SB)
#if defined(FE_IME)
    InputBufferInformation->ImeMode.Disable     = FALSE;
    InputBufferInformation->ImeMode.Unavailable = FALSE;
    InputBufferInformation->ImeMode.Open        = FALSE;
    InputBufferInformation->ImeMode.ReadyConversion = FALSE;
#endif // FE_IME
    InputBufferInformation->Console = Console;
    RtlZeroMemory(&InputBufferInformation->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));
    RtlZeroMemory(&InputBufferInformation->WriteConInpDbcsLeadByte,sizeof(INPUT_RECORD));
#endif

    return STATUS_SUCCESS;
}

NTSTATUS
ReinitializeInputBuffer(
    OUT PINPUT_INFORMATION InputBufferInformation
    )

/*++

Routine Description:

    This routine resets the input buffer information fields to their
    initial values.

Arguments:

    InputBufferInformation - Pointer to input buffer information structure.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    NtClearEvent(InputBufferInformation->InputWaitEvent);
    InputBufferInformation->ShareAccess.OpenCount = 0;
    InputBufferInformation->ShareAccess.Readers = 0;
    InputBufferInformation->ShareAccess.Writers = 0;
    InputBufferInformation->ShareAccess.SharedRead = 0;
    InputBufferInformation->ShareAccess.SharedWrite = 0;
    InputBufferInformation->InputMode = ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT  | ENABLE_ECHO_INPUT | ENABLE_MOUSE_INPUT;
    InputBufferInformation->In = (ULONG_PTR) InputBufferInformation->InputBuffer;
    InputBufferInformation->Out = (ULONG_PTR) InputBufferInformation->InputBuffer;
    return STATUS_SUCCESS;
}

VOID
FreeInputBuffer(
    IN PINPUT_INFORMATION InputBufferInformation
    )

/*++

Routine Description:

    This routine frees the resources associated with an input buffer.

Arguments:

    InputBufferInformation - Pointer to input buffer information structure.

Return Value:


--*/

{
    UserAssert(InputBufferInformation->RefCount == 0);
    CloseHandle(InputBufferInformation->InputWaitEvent);
    ConsoleHeapFree(InputBufferInformation->InputBuffer);
}

NTSTATUS
WaitForMoreToRead(
    IN PINPUT_INFORMATION InputInformation,
    IN PCSR_API_MSG Message OPTIONAL,
    IN CSR_WAIT_ROUTINE WaitRoutine OPTIONAL,
    IN PVOID WaitParameter OPTIONAL,
    IN ULONG WaitParameterLength  OPTIONAL,
    IN BOOLEAN WaitBlockExists OPTIONAL
    )

/*++

Routine Description:

    This routine waits for a writer to add data to the buffer.

Arguments:

    InputInformation - buffer to wait for

    Console - Pointer to console buffer information.

    Message - if called from dll (not InputThread), points to api
    message.  this parameter is used for wait block processing.

    WaitRoutine - Routine to call when wait is woken up.

    WaitParameter - Parameter to pass to wait routine.

    WaitParameterLength - Length of wait parameter.

    WaitBlockExists - TRUE if wait block has already been created.

Return Value:

    STATUS_WAIT - call was from client and wait block has been created.

    STATUS_SUCCESS - call was from server and wait has been satisfied.

--*/

{
    PVOID WaitParameterBuffer;

    if (!WaitBlockExists) {
        WaitParameterBuffer = ConsoleHeapAlloc(WAIT_TAG, WaitParameterLength);
        if (WaitParameterBuffer == NULL) {
            return STATUS_NO_MEMORY;
        }
        RtlCopyMemory(WaitParameterBuffer,WaitParameter,WaitParameterLength);
#if defined(FE_SB)
        if (WaitParameterLength == sizeof(COOKED_READ_DATA) &&
            InputInformation->Console->lpCookedReadData == WaitParameter) {
            InputInformation->Console->lpCookedReadData = WaitParameterBuffer;
        }
#endif
        if (!CsrCreateWait(&InputInformation->ReadWaitQueue,
                          WaitRoutine,
                          CSR_SERVER_QUERYCLIENTTHREAD(),
                          Message,
                          WaitParameterBuffer)) {
            ConsoleHeapFree(WaitParameterBuffer);
#if defined(FE_SB)
            InputInformation->Console->lpCookedReadData = NULL;
#endif
            return STATUS_NO_MEMORY;
        }
    }
    return CONSOLE_STATUS_WAIT;
}

VOID
WakeUpReadersWaitingForData(
    IN PCONSOLE_INFORMATION Console,
    PINPUT_INFORMATION InputInformation
    )

/*++

Routine Description:

    This routine wakes up readers waiting for data to read.

Arguments:

    InputInformation - buffer to alert readers for

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed.

--*/

{
    BOOLEAN WaitSatisfied;
    WaitSatisfied = CsrNotifyWait(&InputInformation->ReadWaitQueue,
                  FALSE,
                  NULL,
                  NULL
                 );
    if (WaitSatisfied) {
        // #334370 under stress, WaitQueue may already hold the satisfied waits
        UserAssert((Console->WaitQueue == NULL) ||
                (Console->WaitQueue == &InputInformation->ReadWaitQueue));
        Console->WaitQueue = &InputInformation->ReadWaitQueue;
    }
}

NTSTATUS
GetNumberOfReadyEvents(
    IN PINPUT_INFORMATION InputInformation,
    OUT PULONG NumberOfEvents
    )

/*++

Routine Description:

    This routine returns the number of events in the input buffer.

Arguments:

    InputInformation - Pointer to input buffer information structure.

    NumberOfEvents - On output contains the number of events.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    if (InputInformation->In < InputInformation->Out) {
        *NumberOfEvents = (ULONG)(InputInformation->Last - InputInformation->Out);
        *NumberOfEvents += (ULONG)(InputInformation->In - InputInformation->First);
    }
    else {
        *NumberOfEvents = (ULONG)(InputInformation->In - InputInformation->Out);
    }
    *NumberOfEvents /= sizeof(INPUT_RECORD);

    return STATUS_SUCCESS;
}

NTSTATUS
FlushAllButKeys(
    PINPUT_INFORMATION InputInformation
    )

/*++

Routine Description:

    This routine removes all but the key events from the buffer.

Arguments:

    InputInformation - Pointer to input buffer information structure.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    ULONG NumberOfEventsRead,i;
    NTSTATUS Status;
    PINPUT_RECORD TmpInputBuffer,InPtr,TmpInputBufferPtr;
    ULONG BufferSize;
    BOOL Dummy;

    if (InputInformation->In != InputInformation->Out)  {

        //
        // allocate memory for temp buffer
        //

        BufferSize =  sizeof(INPUT_RECORD) * (InputInformation->InputBufferSize+1);
        TmpInputBuffer = ConsoleHeapAlloc(TMP_TAG, BufferSize);
        if (TmpInputBuffer == NULL) {
            return STATUS_NO_MEMORY;
        }
        TmpInputBufferPtr = TmpInputBuffer;

        //
        // copy input buffer.
        // let ReadBuffer do any compaction work.
        //

        Status = ReadBuffer(InputInformation,
                            TmpInputBuffer,
                            InputInformation->InputBufferSize,
                            &NumberOfEventsRead,
                            TRUE,
                            FALSE,
                            &Dummy
#if defined(FE_SB)
                            ,
                            TRUE
#endif
                           );

        if (!NT_SUCCESS(Status)) {
            ConsoleHeapFree(TmpInputBuffer);
            return Status;
        }

        InputInformation->Out = (ULONG_PTR) InputInformation->InputBuffer;
        InPtr = InputInformation->InputBuffer;
        for (i=0;i<NumberOfEventsRead;i++) {
            if (TmpInputBuffer->EventType == KEY_EVENT) {
                *InPtr = *TmpInputBuffer;
                InPtr++;
            }
            TmpInputBuffer++;
        }
        InputInformation->In = (ULONG_PTR) InPtr;
        if (InputInformation->In == InputInformation->Out) {
            NtClearEvent(InputInformation->InputWaitEvent);
        }
        ConsoleHeapFree(TmpInputBufferPtr);
    }
    return STATUS_SUCCESS;
}

NTSTATUS
FlushInputBuffer(
    PINPUT_INFORMATION InputInformation
    )

/*++

Routine Description:

    This routine empties the input buffer

Arguments:

    InputInformation - Pointer to input buffer information structure.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    InputInformation->In = (ULONG_PTR) InputInformation->InputBuffer;
    InputInformation->Out = (ULONG_PTR) InputInformation->InputBuffer;
    NtClearEvent(InputInformation->InputWaitEvent);
    return STATUS_SUCCESS;
}


NTSTATUS
SetInputBufferSize(
    IN PINPUT_INFORMATION InputInformation,
    IN ULONG Size
    )

/*++

Routine Description:

    This routine resizes the input buffer.

Arguments:

    InputInformation - Pointer to input buffer information structure.

    Size - New size in number of events.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    ULONG NumberOfEventsRead;
    NTSTATUS Status;
    PINPUT_RECORD InputBuffer;
    ULONG BufferSize;
    BOOL Dummy;

#if DBG
    ULONG_PTR NumberOfEvents;
    if (InputInformation->In < InputInformation->Out) {
        NumberOfEvents = InputInformation->Last - InputInformation->Out;
        NumberOfEvents += InputInformation->In - InputInformation->First;
    } else {
        NumberOfEvents = InputInformation->In - InputInformation->Out;
    }
    NumberOfEvents /= sizeof(INPUT_RECORD);
#endif
    UserAssert(Size > InputInformation->InputBufferSize);

    //
    // Allocate memory for new input buffer.
    //

    BufferSize =  sizeof(INPUT_RECORD) * (Size+1);
    InputBuffer = ConsoleHeapAlloc(BUFFER_TAG, BufferSize);
    if (InputBuffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // Copy old input buffer. Let the ReadBuffer do any compaction work.
    //

    Status = ReadBuffer(InputInformation,
                        InputBuffer,
                        Size,
                        &NumberOfEventsRead,
                        TRUE,
                        FALSE,
                        &Dummy
#if defined(FE_SB)
                        ,
                        TRUE
#endif
                       );

    if (!NT_SUCCESS(Status)) {
        ConsoleHeapFree(InputBuffer);
        return Status;
    }
    InputInformation->Out = (ULONG_PTR)InputBuffer;
    InputInformation->In = (ULONG_PTR)InputBuffer + sizeof(INPUT_RECORD) * NumberOfEventsRead;

    //
    // adjust pointers
    //

    InputInformation->First = (ULONG_PTR) InputBuffer;
    InputInformation->Last = (ULONG_PTR) InputBuffer + BufferSize;

    //
    // free old input buffer
    //

    ConsoleHeapFree(InputInformation->InputBuffer);
    InputInformation->InputBufferSize = Size;
    InputInformation->InputBuffer = InputBuffer;

    return Status;
}


NTSTATUS
ReadBuffer(
    IN PINPUT_INFORMATION InputInformation,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG EventsRead,
    IN BOOL Peek,
    IN BOOL StreamRead,
    OUT PBOOL ResetWaitEvent
#ifdef FE_SB
    , IN BOOLEAN Unicode
#endif
    )
/*++

Routine Description:

    This routine reads from a buffer.  It does the actual circular buffer
    manipulation.

Arguments:

    InputInformation - buffer to read from

    Buffer - buffer to read into

    Length - length of buffer in events

    EventsRead - where to store number of events read

    Peek - if TRUE, don't remove data from buffer, just copy it.

    StreamRead - if TRUE, events with repeat counts > 1 are returned
    as multiple events.  also, EventsRead == 1.

    ResetWaitEvent - on exit, TRUE if buffer became empty.

Return Value:

    ??

Note:

    The console lock must be held when calling this routine.

--*/

{
    ULONG TransferLength,OldTransferLength;
    ULONG BufferLengthInBytes;
#ifdef FE_SB
    PCONSOLE_INFORMATION Console;
    ULONG Length2;
    PINPUT_RECORD BufferRecords;
    PINPUT_RECORD QueueRecords;
    WCHAR UniChar;
    WORD EventType;
#endif

#ifdef FE_SB
    Console = InputInformation->Console;
#endif
    *ResetWaitEvent = FALSE;

    //
    // if StreamRead, just return one record.  if repeat count is greater
    // than one, just decrement it.  the repeat count is > 1 if more than
    // one event of the same type was merged.  we need to expand them back
    // to individual events here.
    //

    if (StreamRead &&
        ((PINPUT_RECORD)(InputInformation->Out))->EventType == KEY_EVENT) {

        UserAssert(Length == 1);
        UserAssert(InputInformation->In != InputInformation->Out);
        RtlMoveMemory((PBYTE)Buffer,
                      (PBYTE)InputInformation->Out,
                      sizeof(INPUT_RECORD)
                     );
        InputInformation->Out += sizeof(INPUT_RECORD);
        if (InputInformation->Last == InputInformation->Out) {
            InputInformation->Out = InputInformation->First;
        }
        if (InputInformation->Out == InputInformation->In) {
            *ResetWaitEvent = TRUE;
        }
        *EventsRead = 1;
        return STATUS_SUCCESS;
    }

    BufferLengthInBytes = Length * sizeof(INPUT_RECORD);

    //
    // if in > out, buffer looks like this:
    //
    //         out     in
    //    ______ _____________
    //   |      |      |      |
    //   | free | data | free |
    //   |______|______|______|
    //
    // we transfer the requested number of events or the amount in the buffer
    //

    if (InputInformation->In > InputInformation->Out) {
        if  ((InputInformation->In - InputInformation->Out) > BufferLengthInBytes) {
            TransferLength = BufferLengthInBytes;
        }
        else {
            TransferLength = (ULONG)(InputInformation->In - InputInformation->Out);
        }
#ifdef FE_SB
        if (!Unicode) {
            BufferLengthInBytes = 0;
            OldTransferLength = TransferLength / sizeof(INPUT_RECORD);
            BufferRecords = (PINPUT_RECORD)Buffer;
            QueueRecords = (PINPUT_RECORD)InputInformation->Out;

            while (BufferLengthInBytes < Length &&
                   OldTransferLength) {
                UniChar = QueueRecords->Event.KeyEvent.uChar.UnicodeChar;
                EventType = QueueRecords->EventType;
                *BufferRecords++ = *QueueRecords++;
                if (EventType == KEY_EVENT) {
                    if (IsConsoleFullWidth(Console->hDC,
                                           Console->CP,
                                           UniChar)) {
                        BufferLengthInBytes += 2;
                    }
                    else {
                        BufferLengthInBytes++;
                    }
                }
                else {
                    BufferLengthInBytes++;
                }
                OldTransferLength--;
            }
            UserAssert(TransferLength >= OldTransferLength * sizeof(INPUT_RECORD));
            TransferLength -= OldTransferLength * sizeof(INPUT_RECORD);
        }
        else
#endif
        {
            RtlMoveMemory((PBYTE)Buffer,
                          (PBYTE)InputInformation->Out,
                          TransferLength
                         );
        }
        *EventsRead = TransferLength / sizeof(INPUT_RECORD);
#ifdef FE_SB
        UserAssert(*EventsRead <= Length);
#endif
        if (!Peek) {
            InputInformation->Out += TransferLength;
#ifdef FE_SB
            UserAssert(InputInformation->Out <= InputInformation->Last);
#endif
        }
        if (InputInformation->Out == InputInformation->In) {
            *ResetWaitEvent = TRUE;
        }
        return STATUS_SUCCESS;
    }

    //
    // if out > in, buffer looks like this:
    //
    //         in     out
    //    ______ _____________
    //   |      |      |      |
    //   | data | free | data |
    //   |______|______|______|
    //
    // we read from the out pointer to the end of the buffer then from the
    // beginning of the buffer, until we hit the in pointer or enough bytes
    // are read.
    //

    else {

        if  ((InputInformation->Last - InputInformation->Out) > BufferLengthInBytes) {
            TransferLength = BufferLengthInBytes;
        }
        else {
            TransferLength = (ULONG)(InputInformation->Last - InputInformation->Out);
        }
#ifdef FE_SB
        if (!Unicode) {
            BufferLengthInBytes = 0;
            OldTransferLength = TransferLength / sizeof(INPUT_RECORD);
            BufferRecords = (PINPUT_RECORD)Buffer;
            QueueRecords = (PINPUT_RECORD)InputInformation->Out;

            while (BufferLengthInBytes < Length &&
                   OldTransferLength) {
                UniChar = QueueRecords->Event.KeyEvent.uChar.UnicodeChar;
                EventType = QueueRecords->EventType;
                *BufferRecords++ = *QueueRecords++;
                if (EventType == KEY_EVENT) {
                    if (IsConsoleFullWidth(Console->hDC,
                                           Console->CP,
                                    UniChar)) {
                        BufferLengthInBytes += 2;
                    }
                    else {
                        BufferLengthInBytes++;
                    }
                }
                else {
                    BufferLengthInBytes++;
                }
                OldTransferLength--;
            }
            UserAssert(TransferLength >= OldTransferLength * sizeof(INPUT_RECORD));
            TransferLength -= OldTransferLength * sizeof(INPUT_RECORD);
        }
        else
#endif
        {
            RtlMoveMemory((PBYTE)Buffer,
                          (PBYTE)InputInformation->Out,
                          TransferLength
                         );
        }
        *EventsRead = TransferLength / sizeof(INPUT_RECORD);
#ifdef FE_SB
        UserAssert(*EventsRead <= Length);
#endif

        if (!Peek) {
            InputInformation->Out += TransferLength;
#ifdef FE_SB
            UserAssert(InputInformation->Out <= InputInformation->Last);
#endif
            if (InputInformation->Out == InputInformation->Last) {
                InputInformation->Out = InputInformation->First;
            }
        }
#ifdef FE_SB
        if (!Unicode) {
            if (BufferLengthInBytes >= Length) {
                if (InputInformation->Out == InputInformation->In) {
                    *ResetWaitEvent = TRUE;
                }
                return STATUS_SUCCESS;
            }
        }
        else
#endif
        if (*EventsRead == Length) {
            if (InputInformation->Out == InputInformation->In) {
                *ResetWaitEvent = TRUE;
            }
            return STATUS_SUCCESS;
        }

        //
        // hit end of buffer, read from beginning
        //

        OldTransferLength = TransferLength;
#ifdef FE_SB
        Length2 = Length;
        if (!Unicode) {
            UserAssert(Length > BufferLengthInBytes);
            Length -= BufferLengthInBytes;
            if (Length == 0) {
                if (InputInformation->Out == InputInformation->In) {
                    *ResetWaitEvent = TRUE;
                }
            return STATUS_SUCCESS;
            }
            BufferLengthInBytes = Length * sizeof(INPUT_RECORD);

            if ((InputInformation->In - InputInformation->First) > BufferLengthInBytes) {
                TransferLength = BufferLengthInBytes;
            }
            else {
                TransferLength = (ULONG)(InputInformation->In - InputInformation->First);
            }
        }
        else
#endif
        if  ((InputInformation->In - InputInformation->First) > (BufferLengthInBytes - OldTransferLength)) {
            TransferLength = BufferLengthInBytes - OldTransferLength;
        }
        else {
            TransferLength = (ULONG)(InputInformation->In - InputInformation->First);
        }
#ifdef FE_SB
        if (!Unicode) {
            BufferLengthInBytes = 0;
            OldTransferLength = TransferLength / sizeof(INPUT_RECORD);
            QueueRecords = (PINPUT_RECORD)InputInformation->First;

            while (BufferLengthInBytes < Length &&
                   OldTransferLength) {
                UniChar = QueueRecords->Event.KeyEvent.uChar.UnicodeChar;
                EventType = QueueRecords->EventType;
                *BufferRecords++ = *QueueRecords++;
                if (EventType == KEY_EVENT) {
                    if (IsConsoleFullWidth(Console->hDC,
                                           Console->CP,
                                    UniChar)) {
                        BufferLengthInBytes += 2;
                    }
                    else {
                        BufferLengthInBytes++;
                    }
                }
                else {
                    BufferLengthInBytes++;
                }
                OldTransferLength--;
            }
            UserAssert(TransferLength >= OldTransferLength * sizeof(INPUT_RECORD));
            TransferLength -= OldTransferLength * sizeof(INPUT_RECORD);
        }
        else
#endif
        {
            RtlMoveMemory((PBYTE)Buffer+OldTransferLength,
                          (PBYTE)InputInformation->First,
                          TransferLength
                         );
        }
        *EventsRead += TransferLength / sizeof(INPUT_RECORD);
#ifdef FE_SB
        UserAssert(*EventsRead <= Length2);
#endif
        if (!Peek) {
            InputInformation->Out = InputInformation->First + TransferLength;
        }
        if (InputInformation->Out == InputInformation->In) {
            *ResetWaitEvent = TRUE;
        }
        return STATUS_SUCCESS;
    }
}


NTSTATUS
ReadInputBuffer(
    IN PINPUT_INFORMATION InputInformation,
    OUT PINPUT_RECORD lpBuffer,
    IN OUT PDWORD nLength,
    IN BOOL Peek,
    IN BOOL WaitForData,
    IN BOOL StreamRead,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData OPTIONAL,
    IN PCSR_API_MSG Message OPTIONAL,
    IN CSR_WAIT_ROUTINE WaitRoutine OPTIONAL,
    IN PVOID WaitParameter OPTIONAL,
    IN ULONG WaitParameterLength  OPTIONAL,
    IN BOOLEAN WaitBlockExists OPTIONAL
#if defined(FE_SB)
    ,
    IN BOOLEAN Unicode
#endif
    )

/*++

Routine Description:

    This routine reads from the input buffer.

Arguments:

    InputInformation - Pointer to input buffer information structure.

    lpBuffer - Buffer to read into.

    nLength - On input, number of events to read.  On output, number of
    events read.

    Peek - If TRUE, copy events to lpBuffer but don't remove them from
    the input buffer.

    WaitForData - if TRUE, wait until an event is input.  if FALSE, return
        immediately

    StreamRead - if TRUE, events with repeat counts > 1 are returned
    as multiple events.  also, EventsRead == 1.

    Console - Pointer to console buffer information.

    HandleData - Pointer to handle data structure.  This parameter is
    optional if WaitForData is false.

    Message - if called from dll (not InputThread), points to api
    message.  this parameter is used for wait block processing.

    WaitRoutine - Routine to call when wait is woken up.

    WaitParameter - Parameter to pass to wait routine.

    WaitParameterLength - Length of wait parameter.

    WaitBlockExists - TRUE if wait block has already been created.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    ULONG EventsRead;
    NTSTATUS Status;
    BOOL ResetWaitEvent;

    if (InputInformation->In == InputInformation->Out)  {
        if (!WaitForData) {
            *nLength = 0;
            return STATUS_SUCCESS;
        }
        LockReadCount(HandleData);
        HandleData->InputReadData->ReadCount += 1;
        UnlockReadCount(HandleData);
        Status = WaitForMoreToRead(InputInformation,
                                   Message,
                                   WaitRoutine,
                                   WaitParameter,
                                   WaitParameterLength,
                                   WaitBlockExists
                                  );

        if (!NT_SUCCESS(Status)) {
            if (Status != CONSOLE_STATUS_WAIT) {
                /*
                 * WaitForMoreToRead failed, restore ReadCount and bale out
                 */
                LockReadCount(HandleData);
                HandleData->InputReadData->ReadCount -= 1;
                UnlockReadCount(HandleData);
            }
            *nLength = 0;
            return Status;
        }

        //
        // we will only get to this point if we were called by GetInput.
        //
        UserAssert(FALSE); // I say we never get here !  IANJA

        LockConsole(Console);
    }

    //
    // read from buffer
    //

    Status = ReadBuffer(InputInformation,
                        lpBuffer,
                        *nLength,
                        &EventsRead,
                        Peek,
                        StreamRead,
                        &ResetWaitEvent
#if defined(FE_SB)
                        ,
                        Unicode
#endif
                       );
    if (ResetWaitEvent) {
        NtClearEvent(InputInformation->InputWaitEvent);
    }

    *nLength = EventsRead;
    return Status;
}

NTSTATUS
WriteBuffer(
    OUT PINPUT_INFORMATION InputInformation,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG EventsWritten,
    OUT PBOOL SetWaitEvent
    )

/*++

Routine Description:

    This routine writes to a buffer.  It does the actual circular buffer
    manipulation.

Arguments:

    InputInformation - buffer to write to

    Buffer - buffer to write from

    Length - length of buffer in events

    BytesRead - where to store number of bytes written.

    SetWaitEvent - on exit, TRUE if buffer became non-empty.

Return Value:

    ERROR_BROKEN_PIPE - no more readers.

Note:

    The console lock must be held when calling this routine.

--*/

{
    NTSTATUS Status;
    ULONG TransferLength;
    ULONG BufferLengthInBytes;
#if defined(FE_SB)
    PCONSOLE_INFORMATION Console = InputInformation->Console;
#endif

    *SetWaitEvent = FALSE;

    //
    // windows sends a mouse_move message each time a window is updated.
    // coalesce these.
    //

    if (Length == 1 && InputInformation->Out != InputInformation->In) {
        PINPUT_RECORD InputEvent=Buffer;

        if (InputEvent->EventType == MOUSE_EVENT &&
            InputEvent->Event.MouseEvent.dwEventFlags == MOUSE_MOVED) {
            PINPUT_RECORD LastInputEvent;

            if (InputInformation->In == InputInformation->First) {
                LastInputEvent = (PINPUT_RECORD) (InputInformation->Last - sizeof(INPUT_RECORD));
            }
            else {
                LastInputEvent = (PINPUT_RECORD) (InputInformation->In - sizeof(INPUT_RECORD));
            }
            if (LastInputEvent->EventType == MOUSE_EVENT &&
                LastInputEvent->Event.MouseEvent.dwEventFlags == MOUSE_MOVED) {
                LastInputEvent->Event.MouseEvent.dwMousePosition.X =
                    InputEvent->Event.MouseEvent.dwMousePosition.X;
                LastInputEvent->Event.MouseEvent.dwMousePosition.Y =
                    InputEvent->Event.MouseEvent.dwMousePosition.Y;
                *EventsWritten = 1;
                return STATUS_SUCCESS;
            }
        }
        else if (InputEvent->EventType == KEY_EVENT &&
                 InputEvent->Event.KeyEvent.bKeyDown) {
            PINPUT_RECORD LastInputEvent;
            if (InputInformation->In == InputInformation->First) {
                LastInputEvent = (PINPUT_RECORD) (InputInformation->Last - sizeof(INPUT_RECORD));
            }
            else {
                LastInputEvent = (PINPUT_RECORD) (InputInformation->In - sizeof(INPUT_RECORD));
            }
#if defined(FE_SB)
            if (IsConsoleFullWidth(Console->hDC,
                                   Console->CP,InputEvent->Event.KeyEvent.uChar.UnicodeChar)) {
                ;
            }
            else
            if (InputEvent->Event.KeyEvent.dwControlKeyState & NLS_IME_CONVERSION) {
                if (LastInputEvent->EventType == KEY_EVENT &&
                    LastInputEvent->Event.KeyEvent.bKeyDown &&
                    (LastInputEvent->Event.KeyEvent.uChar.UnicodeChar ==
                        InputEvent->Event.KeyEvent.uChar.UnicodeChar) &&
                    (LastInputEvent->Event.KeyEvent.dwControlKeyState ==
                        InputEvent->Event.KeyEvent.dwControlKeyState) ) {
                    LastInputEvent->Event.KeyEvent.wRepeatCount +=
                        InputEvent->Event.KeyEvent.wRepeatCount;
                    *EventsWritten = 1;
                    return STATUS_SUCCESS;
                }
            }
            else
#endif
            if (LastInputEvent->EventType == KEY_EVENT &&
                LastInputEvent->Event.KeyEvent.bKeyDown &&
                (LastInputEvent->Event.KeyEvent.wVirtualScanCode == // scancode same
                    InputEvent->Event.KeyEvent.wVirtualScanCode) &&
                (LastInputEvent->Event.KeyEvent.uChar.UnicodeChar == // character same
                    InputEvent->Event.KeyEvent.uChar.UnicodeChar) &&
                (LastInputEvent->Event.KeyEvent.dwControlKeyState == // ctrl/alt/shift state same
                    InputEvent->Event.KeyEvent.dwControlKeyState) ) {
                LastInputEvent->Event.KeyEvent.wRepeatCount +=
                    InputEvent->Event.KeyEvent.wRepeatCount;
                *EventsWritten = 1;
                return STATUS_SUCCESS;
            }
        }
    }

    BufferLengthInBytes = Length*sizeof(INPUT_RECORD);
    *EventsWritten = 0;
    while (*EventsWritten < Length) {

        //
        //
        // if out > in, buffer looks like this:
        //
        //             in     out
        //        ______ _____________
        //       |      |      |      |
        //       | data | free | data |
        //       |______|______|______|
        //
        // we can write from in to out-1
        //

        if (InputInformation->Out > InputInformation->In)       {
            TransferLength = BufferLengthInBytes;
            if  ((InputInformation->Out - InputInformation->In - sizeof(INPUT_RECORD))
                   < BufferLengthInBytes) {
                Status = SetInputBufferSize(InputInformation,
                                            InputInformation->InputBufferSize+Length+INPUT_BUFFER_SIZE_INCREMENT);
                if (!NT_SUCCESS(Status)) {
                    RIPMSG1(RIP_WARNING,
                            "Couldn't grow input buffer, Status == 0x%x",
                            Status);
                    TransferLength = (ULONG)(InputInformation->Out - InputInformation->In - sizeof(INPUT_RECORD));
                    if (TransferLength == 0) {
                        return Status;
                    }
                } else {
                    goto OutPath;   // after resizing, in > out
                }
            }
            RtlMoveMemory((PBYTE)InputInformation->In,
                          (PBYTE)Buffer,
                          TransferLength
                         );
            Buffer = (PVOID) (((PBYTE) Buffer)+TransferLength);
            *EventsWritten += TransferLength/sizeof(INPUT_RECORD);
            BufferLengthInBytes -= TransferLength;
            InputInformation->In += TransferLength;
        }

        //
        // if in >= out, buffer looks like this:
        //
        //             out     in
        //        ______ _____________
        //       |      |      |      |
        //       | free | data | free |
        //       |______|______|______|
        //
        // we write from the in pointer to the end of the buffer then from the
        // beginning of the buffer, until we hit the out pointer or enough bytes
        // are written.
        //

        else {
            if (InputInformation->Out == InputInformation->In) {
                *SetWaitEvent = TRUE;
            }
OutPath:
            if  ((InputInformation->Last - InputInformation->In) > BufferLengthInBytes) {
                TransferLength = BufferLengthInBytes;
            }
            else {
                if (InputInformation->First == InputInformation->Out &&
                    InputInformation->In == (InputInformation->Last-sizeof(INPUT_RECORD))) {
                    TransferLength = BufferLengthInBytes;
                    Status = SetInputBufferSize(InputInformation,
                                                InputInformation->InputBufferSize+Length+INPUT_BUFFER_SIZE_INCREMENT);
                    if (!NT_SUCCESS(Status)) {
                        RIPMSG1(RIP_WARNING,
                                "Couldn't grow input buffer, Status == 0x%x",
                                Status);
                        return Status;
                    }
                }
                else {
                    TransferLength = (ULONG)(InputInformation->Last - InputInformation->In);
                    if (InputInformation->First == InputInformation->Out) {
                        TransferLength -= sizeof(INPUT_RECORD);
                    }
                }
            }
            RtlMoveMemory((PBYTE)InputInformation->In,
                          (PBYTE)Buffer,
                          TransferLength
                         );
            Buffer = (PVOID) (((PBYTE) Buffer)+TransferLength);
            *EventsWritten += TransferLength/sizeof(INPUT_RECORD);
            BufferLengthInBytes -= TransferLength;
            InputInformation->In += TransferLength;
            if (InputInformation->In == InputInformation->Last) {
                InputInformation->In = InputInformation->First;
            }
        }
        if (TransferLength == 0) {
            UserAssert(FALSE);
        }
    }
    return STATUS_SUCCESS;
}


__inline BOOL
IsSystemKey(
    WORD wVirtualKeyCode
    )
{
    switch (wVirtualKeyCode) {
    case VK_SHIFT:
    case VK_CONTROL:
    case VK_MENU:
    case VK_PAUSE:
    case VK_CAPITAL:
    case VK_LWIN:
    case VK_RWIN:
    case VK_NUMLOCK:
    case VK_SCROLL:
        return TRUE;
    }
    return FALSE;
}

DWORD
PreprocessInput(
    IN PCONSOLE_INFORMATION Console,
    IN PINPUT_RECORD InputEvent,
    IN DWORD nLength
    )

/*++

Routine Description:

    This routine processes special characters in the input stream.

Arguments:

    Console - Pointer to console structure.

    InputEvent - Buffer to write from.

    nLength - Number of events to write.

Return Value:

    Number of events to write after special characters have been stripped.

Note:

    The console lock must be held when calling this routine.

--*/

{
    ULONG NumEvents;


    for (NumEvents = nLength; NumEvents != 0; NumEvents--) {
        if (InputEvent->EventType == KEY_EVENT && InputEvent->Event.KeyEvent.bKeyDown) {
            //
            // if output is suspended, any keyboard input releases it.
            //

            if ((Console->Flags & CONSOLE_SUSPENDED) &&
                !IsSystemKey(InputEvent->Event.KeyEvent.wVirtualKeyCode)) {

                UnblockWriteConsole(Console, CONSOLE_OUTPUT_SUSPENDED);
                RtlMoveMemory(InputEvent, InputEvent + 1, (NumEvents - 1) * sizeof(INPUT_RECORD));
                nLength--;
                continue;
            }

            //
            // intercept control-s
            //

            if ((Console->InputBuffer.InputMode & ENABLE_LINE_INPUT) &&
                    (InputEvent->Event.KeyEvent.wVirtualKeyCode == VK_PAUSE ||
                     IsPauseKey(&InputEvent->Event.KeyEvent))) {

                Console->Flags |= CONSOLE_OUTPUT_SUSPENDED;
                RtlMoveMemory(InputEvent, InputEvent + 1, (NumEvents - 1) * sizeof(INPUT_RECORD));
                nLength--;
                continue;
            }
        }
        InputEvent++;
    }
    return nLength;
}


DWORD
PrependInputBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN PINPUT_INFORMATION InputInformation,
    IN PINPUT_RECORD lpBuffer,
    IN DWORD nLength
    )

/*++

Routine Description:

    This routine writes to the beginning of the input buffer.

Arguments:

    InputInformation - Pointer to input buffer information structure.

    lpBuffer - Buffer to write from.

    nLength - On input, number of events to write.  On output, number of
    events written.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    NTSTATUS Status;
    ULONG EventsWritten,EventsRead;
    BOOL SetWaitEvent;
    ULONG NumExistingEvents;
    PINPUT_RECORD pExistingEvents;
    BOOL Dummy;

    nLength = PreprocessInput(Console, lpBuffer, nLength);
    if (nLength == 0) {
        return 0;
    }

    Status = GetNumberOfReadyEvents(InputInformation,
                                    &NumExistingEvents
                                   );

    if (NumExistingEvents) {

        pExistingEvents = ConsoleHeapAlloc(BUFFER_TAG, NumExistingEvents * sizeof(INPUT_RECORD));
        if (pExistingEvents == NULL)
            return (DWORD)STATUS_NO_MEMORY;
        Status = ReadBuffer(InputInformation,
                            pExistingEvents,
                            NumExistingEvents,
                            &EventsRead,
                            FALSE,
                            FALSE,
                            &Dummy
#if defined(FE_SB)
                            ,
                            TRUE
#endif
                           );

        if (!NT_SUCCESS(Status)) {
            ConsoleHeapFree(pExistingEvents);
            return Status;
        }
    } else {
        pExistingEvents = NULL;
    }

    //
    // write new info to buffer
    //

    Status = WriteBuffer(InputInformation,
                         lpBuffer,
                         nLength,
                         &EventsWritten,
                         &SetWaitEvent
                        );

    //
    // write existing info to buffer
    //

    if (pExistingEvents) {
        Status = WriteBuffer(InputInformation,
                             pExistingEvents,
                             EventsRead,
                             &EventsWritten,
                             &Dummy
                            );
        ConsoleHeapFree(pExistingEvents);
    }

    if (SetWaitEvent) {
        NtSetEvent(InputInformation->InputWaitEvent,NULL);
    }

    //
    // alert any writers waiting for space
    //

    WakeUpReadersWaitingForData(Console,InputInformation);

    return nLength;
}

DWORD
WriteInputBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN PINPUT_INFORMATION InputInformation,
    IN PINPUT_RECORD lpBuffer,
    IN DWORD nLength
    )

/*++

Routine Description:

    This routine writes to the input buffer.

Arguments:

    InputInformation - Pointer to input buffer information structure.

    lpBuffer - Buffer to write from.

    nLength - On input, number of events to write.  On output, number of
    events written.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    ULONG EventsWritten;
    BOOL SetWaitEvent;

    nLength = PreprocessInput(Console, lpBuffer, nLength);
    if (nLength == 0) {
        return 0;
    }

    //
    // write to buffer
    //

    WriteBuffer(InputInformation,
                lpBuffer,
                nLength,
                &EventsWritten,
                &SetWaitEvent
                );

    if (SetWaitEvent) {
        NtSetEvent(InputInformation->InputWaitEvent,NULL);
    }

    //
    // alert any writers waiting for space
    //

    WakeUpReadersWaitingForData(Console,InputInformation);


    return EventsWritten;
}

VOID
StoreKeyInfo(
    IN PMSG msg)
{
    int i;

    for (i=0;i<CONSOLE_MAX_KEY_INFO;i++) {
        if (ConsoleKeyInfo[i].hWnd == CONSOLE_FREE_KEY_INFO ||
            ConsoleKeyInfo[i].hWnd == msg->hwnd) {
            break;
        }
    }
    if (i!=CONSOLE_MAX_KEY_INFO) {
        ConsoleKeyInfo[i].hWnd = msg->hwnd;
        ConsoleKeyInfo[i].wVirtualKeyCode = LOWORD(msg->wParam);
        ConsoleKeyInfo[i].wVirtualScanCode = (BYTE)(HIWORD(msg->lParam));
    } else {
        RIPMSG0(RIP_WARNING, "ConsoleKeyInfo buffer is full");
    }
}

VOID
RetrieveKeyInfo(
    IN HWND hWnd,
    OUT PWORD pwVirtualKeyCode,
    OUT PWORD pwVirtualScanCode,
    IN BOOL FreeKeyInfo)
{
    int i;

    for (i = 0; i < CONSOLE_MAX_KEY_INFO; i++) {
        if (ConsoleKeyInfo[i].hWnd == hWnd) {
            break;
        }
    }
    if (i != CONSOLE_MAX_KEY_INFO) {
        *pwVirtualKeyCode = ConsoleKeyInfo[i].wVirtualKeyCode;
        *pwVirtualScanCode = ConsoleKeyInfo[i].wVirtualScanCode;
        if (FreeKeyInfo) {
            ConsoleKeyInfo[i].hWnd = CONSOLE_FREE_KEY_INFO;
        }
    } else {
        *pwVirtualKeyCode = (WORD)MapVirtualKey(*pwVirtualScanCode, 3);
    }
}

VOID
ClearKeyInfo(
    IN HWND hWnd
    )
{
    int i;

    for (i=0;i<CONSOLE_MAX_KEY_INFO;i++) {
        if (ConsoleKeyInfo[i].hWnd == hWnd) {
            ConsoleKeyInfo[i].hWnd = CONSOLE_FREE_KEY_INFO;
        }
    }
}


/***************************************************************************\
* ProcessCreateConsoleWindow
*
* This routine processes a CM_CREATE_CONSOLE_WINDOW message. It is called
* from the InputThread message loop under normal circumstances and from
* the DialogHookProc if we have a dialog box up. The USER critical section
* should not be held when calling this routine.
\***************************************************************************/
VOID
ProcessCreateConsoleWindow(
    IN LPMSG lpMsg)
{
    NTSTATUS Status;
    PCONSOLE_INFORMATION pConsole;

    if (NT_SUCCESS(RevalidateConsole((HANDLE)lpMsg->wParam, &pConsole))) {

        //
        // Make sure the console doesn't already have a window.
        //

        if (pConsole->hWnd) {
            RIPMSG1(RIP_WARNING, "Console %#p already has a window", pConsole);
            UnlockConsole(pConsole);
            return;
        }

        pConsole->InputThreadInfo = TlsGetValue(InputThreadTlsIndex);

        Status = CreateWindowsWindow(pConsole);
        switch (Status) {
        case STATUS_SUCCESS:
        case STATUS_NO_MEMORY:
            UnlockConsole(pConsole);
            break;
        case STATUS_INVALID_HANDLE:
            // Console is gone, don't do anything.
            break;
        default:
            RIPMSG1(RIP_ERROR, "CreateWindowsWindow returned %x", Status);
            break;
        }
    }
}


LRESULT
DialogHookProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam
    )

// this routine gets called to filter input to console dialogs so
// that we can do the special processing that StoreKeyInfo does.

{
    MSG *pmsg = (PMSG)lParam;

    UNREFERENCED_PARAMETER(wParam);

    if (pmsg->message == CM_CREATE_CONSOLE_WINDOW) {
        ProcessCreateConsoleWindow(pmsg);
        return TRUE;
    }

    if (CONSOLE_IS_IME_ENABLED()) {
        if (pmsg->message == CM_CONSOLE_INPUT_THREAD_MSG) {
            PINPUT_THREAD_INFO pThreadInfo = TlsGetValue(InputThreadTlsIndex);
            MSG msg;

            UserAssert(pThreadInfo);

            if (UnqueueThreadMessage(pThreadInfo->ThreadId, &msg.message, &msg.wParam, &msg.lParam)) {
                RIPMSG3(RIP_WARNING, "DialogHookProc: %04x (%08x, %08x)", msg.message, msg.wParam, msg.lParam);
                switch (msg.message) {
                case CM_CONIME_CREATE:
                    ProcessCreateConsoleIME(&msg, pThreadInfo->ThreadId);
                    return TRUE;
                case CM_WAIT_CONIME_PROCESS:
                    WaitConsoleIMEStuff((HDESK)msg.wParam, (HANDLE)msg.lParam);
                    return TRUE;
                case CM_SET_CONSOLEIME_WINDOW:
                    pThreadInfo->hWndConsoleIME = (HWND)msg.wParam;
                    return TRUE;
                default:
                    RIPMSG1(RIP_WARNING, "DialogHookProc: invalid thread message(%04x) !!", msg.message);
                    break;
                }
            }
            else {
                RIPMSG0(RIP_WARNING, "DialogHookProc: bogus thread message is posted. ignored");
            }
        }
    }

    if (nCode == MSGF_DIALOGBOX) {
        if (pmsg->message >= WM_KEYFIRST &&
            pmsg->message <= WM_KEYLAST) {
            if (pmsg->message != WM_CHAR &&
                pmsg->message != WM_DEADCHAR &&
                pmsg->message != WM_SYSCHAR &&
                pmsg->message != WM_SYSDEADCHAR) {

                // don't store key info if dialog box input
                if (GetWindowLongPtr(pmsg->hwnd, GWLP_HWNDPARENT) == 0) {
                    StoreKeyInfo(pmsg);
                }
            }
        }
    }
    return 0;
}

#undef DbgPrint  // Need this to build on free systems

ULONG InputExceptionFilter(
    PEXCEPTION_POINTERS pexi)
{
    NTSTATUS Status;
    SYSTEM_KERNEL_DEBUGGER_INFORMATION KernelDebuggerInfo;

    if (pexi->ExceptionRecord->ExceptionCode != STATUS_PORT_DISCONNECTED) {
        Status = NtQuerySystemInformation( SystemKernelDebuggerInformation,
                                           &KernelDebuggerInfo,
                                           sizeof(KernelDebuggerInfo),
                                           NULL
                                         );

        if (NT_SUCCESS(Status) && KernelDebuggerInfo.KernelDebuggerEnabled) {
            DbgPrint("Unhandled Exception hit in csrss.exe InputExceptionFilter\n");
            DbgPrint("first, enter .exr %p for the exception record\n", pexi->ExceptionRecord);
            DbgPrint("next, enter .cxr %p for the context\n", pexi->ContextRecord);
            DbgPrint("then kb to get the faulting stack\n");
            DbgBreakPoint();
        }
    }

    return EXCEPTION_EXECUTE_HANDLER;
}

/////////////////////////////////////////
// Input Thread internal Message Queue:
// Mainly used for Console IME stuff
/////////////////////////////////////////

LIST_ENTRY gInputThreadMsg;
CRITICAL_SECTION gInputThreadMsgLock;

VOID
InitializeThreadMessages()
{
    RtlEnterCriticalSection(&gInputThreadMsgLock);
    InitializeListHead(&gInputThreadMsg);
    RtlLeaveCriticalSection(&gInputThreadMsgLock);
}

VOID
CleanupInputThreadMessages(
    DWORD dwThreadId)
{
    UINT message;
    WPARAM wParam;
    LPARAM lParam;

    UserAssert(dwThreadId);

    while (UnqueueThreadMessage(dwThreadId, &message, &wParam, &lParam)) {
        RIPMSG3(RIP_WARNING, "CleanupInputThreadMessages: %04x (%08x, %08x)", message, wParam, lParam);
    }
}

//
// QueueThreadMessage
//
// Posts a message to Input Thread, specified by dwThreadId.
// CM_CONSOLE_INPUT_THEAD_MSG is used as a stub message. Actual parameters are
// stored in gInputThreadMsg. Input thread should call UnqueueThreadMessage
// when it gets CM_CONSOLE_INPUT_THREAD_MSG.
//
NTSTATUS
QueueThreadMessage(
    DWORD dwThreadId,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PCONSOLE_THREAD_MSG pConMsg;

    RIPMSG4(RIP_VERBOSE, "QueueThreadMessage: TID=%08x msg:%04x (%08x, %08x)",
            dwThreadId, message, wParam, lParam);

    pConMsg = ConsoleHeapAlloc(TMP_TAG, sizeof *pConMsg);
    if (pConMsg == NULL) {
        RIPMSG0(RIP_WARNING, "QueueThreadMessage: failed to allocate pConMsg");
        return STATUS_NO_MEMORY;
    }

    pConMsg->dwThreadId = dwThreadId;
    pConMsg->Message = message;
    pConMsg->wParam = wParam;
    pConMsg->lParam = lParam;

    RtlEnterCriticalSection(&gInputThreadMsgLock);
    InsertHeadList(&gInputThreadMsg, &pConMsg->ListLink);
    RtlLeaveCriticalSection(&gInputThreadMsgLock);

    if (!PostThreadMessage(dwThreadId, CM_CONSOLE_INPUT_THREAD_MSG, 0, 0)) {
        RIPMSG1(RIP_WARNING, "QueueThreadMessage: failed to post thread msg(%04x)", message);
        RtlEnterCriticalSection(&gInputThreadMsgLock);
        RemoveEntryList(&pConMsg->ListLink);
        RtlLeaveCriticalSection(&gInputThreadMsgLock);
        ConsoleHeapFree(pConMsg);
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

//
// UnqueueThreadMessage
//
// return value:
//  TRUE  -- a message found.
//  FALSE -- no message for dwThreadId found.
//
BOOL UnqueueThreadMessage(
    DWORD dwThreadId,
    UINT* pMessage,
    WPARAM* pwParam,
    LPARAM* plParam)
{
    BOOL fResult = FALSE;       // if message is found, set this to TRUE
    PLIST_ENTRY pEntry;

    UserAssert(dwThreadId);

    RtlEnterCriticalSection(&gInputThreadMsgLock);

    //
    // Search for dwThreadId message from the tail of the queue.
    //
    pEntry = gInputThreadMsg.Blink;

    while (pEntry != &gInputThreadMsg) {
        PCONSOLE_THREAD_MSG pConMsg = CONTAINING_RECORD(pEntry, CONSOLE_THREAD_MSG, ListLink);

        if (pConMsg->dwThreadId == dwThreadId) {
            *pMessage = pConMsg->Message;
            *pwParam = pConMsg->wParam;
            *plParam = pConMsg->lParam;

            RemoveEntryList(pEntry);
            ConsoleHeapFree(pConMsg);
            fResult = TRUE;
            break;
        }
        pEntry = pEntry->Blink;
    }

    RtlLeaveCriticalSection(&gInputThreadMsgLock);

    return fResult;
}

NTSTATUS
ConsoleInputThread(
    PINPUT_THREAD_INIT_INFO pInputThreadInitInfo)
{
    MSG msg;
    PTEB Teb = NtCurrentTeb();
    PCSR_THREAD pcsrt = NULL;
    INPUT_THREAD_INFO ThreadInfo;
    int i;
    HANDLE hThread = NULL;
    HHOOK hhook = NULL;
    BOOL fQuit = FALSE;
    CONSOLEDESKTOPCONSOLETHREAD ConsoleDesktopInfo;
    NTSTATUS Status;

    /*
     * Set this thread's desktop to the one we just created/opened.
     * When the very first app is loaded, the desktop hasn't been
     * created yet so the above call might fail.  Make sure we don't
     * accidentally call SetThreadDesktop with a NULL pdesk.  The
     * first app will create the desktop and open it for itself.
     */
    ThreadInfo.Desktop = pInputThreadInitInfo->DesktopHandle;
    ThreadInfo.WindowCount = 0;
    ThreadInfo.ThreadHandle = pInputThreadInitInfo->ThreadHandle;
    ThreadInfo.ThreadId = HandleToUlong(Teb->ClientId.UniqueThread);
#if defined(FE_IME)
    ThreadInfo.hWndConsoleIME = NULL;
#endif
    TlsSetValue(InputThreadTlsIndex, &ThreadInfo);
    ConsoleDesktopInfo.hdesk = pInputThreadInitInfo->DesktopHandle;
    ConsoleDesktopInfo.dwThreadId = HandleToUlong(Teb->ClientId.UniqueThread);
    Status = NtUserConsoleControl(ConsoleDesktopConsoleThread, &ConsoleDesktopInfo, sizeof(ConsoleDesktopInfo));
    if (NT_SUCCESS(Status)) {

        //
        // This call forces the client-side desktop information
        // to be updated.
        //

        pcsrt = CsrConnectToUser();
        if (pcsrt == NULL ||
                !SetThreadDesktop(pInputThreadInitInfo->DesktopHandle)) {
            Status = STATUS_UNSUCCESSFUL;
        } else {

            //
            // Save our thread handle for cleanup purposes
            //

            hThread = pcsrt->ThreadHandle;

            if (!fOneTimeInitialized) {

                InitializeCustomCP();

                //
                // Initialize default screen dimensions.  we have to initialize
                // the font info here (in the input thread) so that GDI doesn't
                // get completely confused on process termination (since a
                // process that looks like it's terminating created all the
                // server HFONTS).
                //

                EnumerateFonts(EF_DEFFACE);

                InitializeScreenInfo();

                if (!InitWindowClass()) {
                    /*
                     * If the class already exists, this means that some other console attempted
                     * to initialize and registered the class but failed right after.
                     */
                    if (GetLastError() == ERROR_CLASS_ALREADY_EXISTS) {
                        RIPMSG0(RIP_WARNING, "ConsoleInputThread: Class already exists.");
                    } else {
                        RIPMSG0(RIP_WARNING, "ConsoleInputThread: InitWindowClass failed.");
                        Status = STATUS_UNSUCCESSFUL;
                    }
                }

                for (i = 0; i < CONSOLE_MAX_KEY_INFO; i++) {
                    ConsoleKeyInfo[i].hWnd = CONSOLE_FREE_KEY_INFO;
                }

                ProgmanHandleMessage = RegisterWindowMessage(TEXT(CONSOLE_PROGMAN_HANDLE_MESSAGE));
            }
        }

        hhook = SetWindowsHookEx(WH_MSGFILTER,
                                 DialogHookProc,
                                 NULL,
                                 HandleToUlong(Teb->ClientId.UniqueThread));
        if (hhook == NULL) {
            DWORD dwError = GetLastError();

            /*
            * Unfortunately, there's no way to map a Win32 error code to an
            * NTSTATUS, so let's try to be smart about the most likely reasons
            * this API would fail.
            */
            RIPMSGF1(RIP_WARNING,
                    "SetWindowsHookEx failed, GLE: 0x%x.",
                    dwError);
            if (dwError == ERROR_NOT_ENOUGH_MEMORY || dwError == ERROR_OUTOFMEMORY) {
                Status = STATUS_NO_MEMORY;
            } else if (dwError == ERROR_ACCESS_DENIED) {
                Status = STATUS_ACCESS_DENIED;
            } else {
                Status = STATUS_UNSUCCESSFUL;
            }
        }
    }

    //
    // If we successfully initialized, the input thread is ready to run.
    // Otherwise, kill the thread.
    //
    pInputThreadInitInfo->InitStatus = Status;
    NtSetEvent(pInputThreadInitInfo->InitCompleteEventHandle, NULL);

    if (!NT_SUCCESS(Status)) {
        RIPMSGF1(RIP_WARNING,
                 "Failed to initialize, status 0x%x. Bailing out.",
                 Status);
        goto Cleanup;
    }

    while (TRUE) {

        //
        // If a WM_QUIT has been received and all windows
        // are gone, get out.
        //

        if (fQuit && ThreadInfo.WindowCount == 0) {
            break;
        }

        //
        // Make sure we don't hold any locks while we're idle.
        //
        UserAssert(NtCurrentTeb()->CountOfOwnedCriticalSections == 0);

        GetMessage(&msg, NULL, 0, 0);

        //
        // Trap messages posted to the thread.
        //

        if (msg.message == CM_CREATE_CONSOLE_WINDOW) {
            ProcessCreateConsoleWindow(&msg);
            continue;
        } else if (msg.message == WM_QUIT) {

            //
            // The message was posted from ExitWindows.  This
            // means that it's OK to terminate the thread.
            //

            fQuit = TRUE;

            //
            // Only exit the loop if there are no windows,
            //

            if (ThreadInfo.WindowCount == 0) {
                break;
            }
            RIPMSG0(RIP_WARNING, "WM_QUIT received by console with windows");
            continue;
        } else if (CONSOLE_IS_IME_ENABLED()) {
            if (msg.message == CM_CONSOLE_INPUT_THREAD_MSG) {
                if (UnqueueThreadMessage(ThreadInfo.ThreadId, &msg.message, &msg.wParam, &msg.lParam)) {
                    RIPMSG3(RIP_VERBOSE, "InputThread: Unqueue: msg=%04x (%08x, %08x)", msg.message, msg.wParam, msg.lParam);
                    switch (msg.message) {
                    case CM_CONIME_CREATE:
                        ProcessCreateConsoleIME(&msg, ThreadInfo.ThreadId);
                        continue;
                    case CM_WAIT_CONIME_PROCESS:
                        WaitConsoleIMEStuff((HDESK)msg.wParam, (HANDLE)msg.lParam);
                        continue;
                    case CM_SET_CONSOLEIME_WINDOW:
                        ThreadInfo.hWndConsoleIME = (HWND)msg.wParam;
                        continue;
                    default:
                        RIPMSG1(RIP_WARNING, "ConsoleInputThread: invalid thread message(%04x) !!", msg.message);
                        break;
                    }
                } else {
                    RIPMSGF1(RIP_WARNING,
                             "Bogus thread message posted (msg = 0x%x).",
                             msg.message);
                    continue;
                }
            }
        }

        if (!TranslateMessageEx(&msg, TM_POSTCHARBREAKS)) {
            DispatchMessage(&msg);
        } else {
            // do this so that alt-tab works while journalling
            if (msg.message == WM_SYSKEYDOWN && msg.wParam == VK_TAB &&
                (msg.lParam & 0x20000000) ) {   // alt is really down
                DispatchMessage(&msg);
            } else {
                StoreKeyInfo(&msg);
            }
        }
    }

    //
    // Cleanup the input thread messages.
    //
    CleanupInputThreadMessages(ThreadInfo.ThreadId);

    UserAssert(Status == STATUS_SUCCESS);

Cleanup:

    //
    // Free all resources used by this thread
    //

    if (hhook != NULL) {
        UnhookWindowsHookEx(hhook);
    }
    ConsoleDesktopInfo.dwThreadId = 0;
    NtUserConsoleControl(ConsoleDesktopConsoleThread,
                         &ConsoleDesktopInfo,
                         sizeof(ConsoleDesktopInfo));

    //
    // Close the desktop handle. CSR is special cased to close
    // the handle even if the thread has windows.  The desktop
    // remains assigned to the thread.
    //

    UserVerify(CloseDesktop(ThreadInfo.Desktop));

    //
    // Restore thread handle so that CSR won't get confused.
    //

    if (hThread != NULL) {
        pcsrt->ThreadHandle = hThread;
    }

    if (pcsrt != NULL) {
        CsrDereferenceThread(pcsrt);
    }

    UserExitWorkerThread(Status);

    return Status;
}

ULONG
GetControlKeyState(
    LPARAM lParam
    )
{
    ULONG ControlKeyState = 0;

    if (GetKeyState(VK_LMENU) & KEY_PRESSED) {
        ControlKeyState |= LEFT_ALT_PRESSED;
    }
    if (GetKeyState(VK_RMENU) & KEY_PRESSED) {
        ControlKeyState |= RIGHT_ALT_PRESSED;
    }
    if (GetKeyState(VK_LCONTROL) & KEY_PRESSED) {
        ControlKeyState |= LEFT_CTRL_PRESSED;
    }
    if (GetKeyState(VK_RCONTROL) & KEY_PRESSED) {
        ControlKeyState |= RIGHT_CTRL_PRESSED;
    }
    if (GetKeyState(VK_SHIFT) & KEY_PRESSED) {
        ControlKeyState |= SHIFT_PRESSED;
    }
    if (GetKeyState(VK_NUMLOCK) & KEY_TOGGLED) {
        ControlKeyState |= NUMLOCK_ON;
    }
    if (GetKeyState(VK_OEM_SCROLL) & KEY_TOGGLED) {
        ControlKeyState |= SCROLLLOCK_ON;
    }
    if (GetKeyState(VK_CAPITAL) & KEY_TOGGLED) {
        ControlKeyState |= CAPSLOCK_ON;
    }
    if (lParam & KEY_ENHANCED) {
        ControlKeyState |= ENHANCED_KEY;
    }
    ControlKeyState |= (lParam & ALTNUMPAD_BIT);
    return ControlKeyState;
}

ULONG
ConvertMouseButtonState(
    IN ULONG Flag,
    IN ULONG State
    )
{
    if (State & MK_LBUTTON) {
        Flag |= FROM_LEFT_1ST_BUTTON_PRESSED;
    }
    if (State & MK_MBUTTON) {
        Flag |= FROM_LEFT_2ND_BUTTON_PRESSED;
    }
    if (State & MK_RBUTTON) {
        Flag |= RIGHTMOST_BUTTON_PRESSED;
    }
    return Flag;
}

VOID
TerminateRead(
    IN PCONSOLE_INFORMATION Console,
    IN PINPUT_INFORMATION InputInfo,
    IN DWORD Flag
    )

/*++

Routine Description:

    This routine wakes up any readers waiting for data when a ctrl-c
    or ctrl-break is input.

Arguments:

    InputInfo - pointer to input buffer

    Flag - flag indicating whether ctrl-break or ctrl-c was input

--*/

{
    BOOLEAN WaitSatisfied;
    WaitSatisfied = CsrNotifyWait(&InputInfo->ReadWaitQueue,
                  TRUE,
                  NULL,
                  IntToPtr(Flag)
                 );
    if (WaitSatisfied) {
        // #334370 under stress, WaitQueue may already hold the satisfied waits
        UserAssert((Console->WaitQueue == NULL) ||
                (Console->WaitQueue == &InputInfo->ReadWaitQueue));
        Console->WaitQueue = &InputInfo->ReadWaitQueue;
    }
}

BOOL
HandleSysKeyEvent(
    IN PCONSOLE_INFORMATION Console,
    IN HWND hWnd,
    IN UINT Message,
    IN WPARAM wParam,
    IN LPARAM lParam,
    IN PBOOL pbUnlockConsole
    )

/*

    returns TRUE if DefWindowProc should be called.

*/

{
    WORD VirtualKeyCode;
    BOOL bCtrlDown;

#ifndef i386
    UNREFERENCED_PARAMETER(pbUnlockConsole);
#endif

#if defined (FE_IME)
// Sep.16.1995 Support Console IME by v-HirShi(Hirotoshi Shimizu)
    if (Message == WM_SYSCHAR || Message == WM_SYSDEADCHAR ||
        Message == WM_SYSCHAR+CONIME_KEYDATA || Message == WM_SYSDEADCHAR+CONIME_KEYDATA)
#else
    if (Message == WM_SYSCHAR || Message == WM_SYSDEADCHAR)
#endif
    {
        VirtualKeyCode = (WORD)MapVirtualKey(LOBYTE(HIWORD(lParam)), 1);
    } else {
        VirtualKeyCode = LOWORD(wParam);
    }

    //
    // check for ctrl-esc
    //
    bCtrlDown = GetKeyState(VK_CONTROL) & KEY_PRESSED;

    if (VirtualKeyCode == VK_ESCAPE &&
        bCtrlDown &&
        !(GetKeyState(VK_MENU) & KEY_PRESSED) &&
        !(GetKeyState(VK_SHIFT) & KEY_PRESSED) &&
        !(Console->ReserveKeys & CONSOLE_CTRLESC) ) {
        return TRUE;    // call DefWindowProc
    }

    if ((lParam & 0x20000000) == 0) {   // we're iconic
        //
        // Check for ENTER while iconic (restore accelerator).
        //

        if (VirtualKeyCode == VK_RETURN && !(Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE)) {

            return TRUE;    // call DefWindowProc
        } else {
            HandleKeyEvent(Console,
                           hWnd,
                           Message,
                           wParam,
                           lParam
                          );
            return FALSE;
        }
    }

    if (VirtualKeyCode == VK_RETURN && !bCtrlDown &&
            !(Console->ReserveKeys & CONSOLE_ALTENTER)) {
#ifdef i386
        if (!(Message & KEY_UP_TRANSITION)) {
            if (FullScreenInitialized && !GetSystemMetrics(SM_REMOTESESSION)) {
                if (Console->FullScreenFlags == 0) {
                    ConvertToFullScreen(Console);
                    Console->FullScreenFlags = CONSOLE_FULLSCREEN;

                    ChangeDispSettings(Console, Console->hWnd, CDS_FULLSCREEN);
                } else {
                    ConvertToWindowed(Console);
                    Console->FullScreenFlags &= ~CONSOLE_FULLSCREEN;

                    ChangeDispSettings(Console, Console->hWnd,0);

                    ShowWindow(Console->hWnd, SW_RESTORE);
                }
            } else {
                WCHAR ItemString[70];
                HWND hwnd = Console->hWnd;
                LPWSTR lpTitle;

                /*
                 * We must unlock the console around the MessageBox call,
                 * since this can block indefinitely long (otherwise, any
                 * thread that tries to access this console will get hung
                 * trying to acquire its lock).
                 */
                lpTitle = ConsoleHeapAlloc(TMP_TAG,
                                           Console->TitleLength + sizeof(WCHAR));
                if (lpTitle) {
                    RtlCopyMemory(lpTitle, Console->Title, Console->TitleLength);
                    lpTitle[Console->TitleLength / sizeof(WCHAR)] = 0;

                    UnlockConsole(Console);
                    *pbUnlockConsole = FALSE;

                    LoadString(ghInstance,
                               msgNoFullScreen,
                               ItemString,
                               ARRAY_SIZE(ItemString));
                    ++DialogBoxCount;
                    MessageBox(hWnd,
                               ItemString,
                               lpTitle,
                               MB_SYSTEMMODAL | MB_OK);
                    --DialogBoxCount;
                    ConsoleHeapFree(lpTitle);
                }
            }
        }
#endif
        return FALSE;
    }

    //
    // make sure alt-space gets translated so that the system
    // menu is displayed.
    //

    if (!(GetKeyState(VK_CONTROL) & KEY_PRESSED)) {
        if (VirtualKeyCode == VK_SPACE && !(Console->ReserveKeys & CONSOLE_ALTSPACE)) {
            return TRUE; // call DefWindowProc
        }

        if (VirtualKeyCode == VK_ESCAPE && !(Console->ReserveKeys & CONSOLE_ALTESC)) {
            return TRUE;  // call DefWindowProc
        }
        if (VirtualKeyCode == VK_TAB && !(Console->ReserveKeys & CONSOLE_ALTTAB)) {
            return TRUE;  // call DefWindowProc
        }
    }

    HandleKeyEvent(Console,
                   hWnd,
                   Message,
                   wParam,
                   lParam);

    return FALSE;
}

VOID
HandleKeyEvent(
    IN PCONSOLE_INFORMATION Console,
    IN HWND hWnd,
    IN UINT Message,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    INPUT_RECORD InputEvent;
    BOOLEAN ContinueProcessing;
    ULONG EventsWritten;
    WORD VirtualKeyCode;
    ULONG ControlKeyState;
    BOOL bKeyDown;
    BOOL bGenerateBreak = FALSE;
#ifdef FE_SB
    BOOL KeyMessageFromConsoleIME;
#endif

#ifdef FE_SB
    // v-HirShi Sep.21.1995 For Console IME
    if ((WM_KEYFIRST+CONIME_KEYDATA) <= Message && Message <= (WM_KEYLAST+CONIME_KEYDATA)) {
        Message -= CONIME_KEYDATA ;
        KeyMessageFromConsoleIME = TRUE;
    } else {
        KeyMessageFromConsoleIME = FALSE;
    }
#endif
    /*
     * BOGUS for WM_CHAR/WM_DEADCHAR, in which LOWORD(lParam) is a character
     */
    VirtualKeyCode = LOWORD(wParam);
    ControlKeyState = GetControlKeyState(lParam);
    bKeyDown = !(lParam & KEY_TRANSITION_UP);

    //
    // Make sure we retrieve the key info first, or we could chew up
    // unneeded space in the key info table if we bail out early.
    //

    InputEvent.Event.KeyEvent.wVirtualKeyCode = VirtualKeyCode;
    InputEvent.Event.KeyEvent.wVirtualScanCode = (BYTE)(HIWORD(lParam));
    if (Message == WM_CHAR || Message == WM_SYSCHAR ||
        Message == WM_DEADCHAR || Message == WM_SYSDEADCHAR) {
        RetrieveKeyInfo(hWnd,
                        &InputEvent.Event.KeyEvent.wVirtualKeyCode,
                        &InputEvent.Event.KeyEvent.wVirtualScanCode,
                        !(Console->InputBuffer.ImeMode.Open ^ KeyMessageFromConsoleIME));
        VirtualKeyCode = InputEvent.Event.KeyEvent.wVirtualKeyCode;
    }

    //
    // If this is a key up message, should we ignore it? We do this
    // so that if a process reads a line from the input buffer, the
    // key up event won't get put in the buffer after the read
    // completes.
    //

    if (Console->Flags & CONSOLE_IGNORE_NEXT_KEYUP) {
        Console->Flags &= ~CONSOLE_IGNORE_NEXT_KEYUP;
        if (!bKeyDown) {
            return;
        }
    }

#ifdef FE_SB
    // v-HirShi Sep.21.1995 For Console IME
    if (KeyMessageFromConsoleIME) {
        goto FromConsoleIME ;
    }
#endif

    if (Console->Flags & CONSOLE_SELECTING) {

        if (!bKeyDown) {
            return;
        }

        //
        // if escape or ctrl-c, cancel selection
        //

        if (!(Console->SelectionFlags & CONSOLE_MOUSE_DOWN) ) {
            if (VirtualKeyCode == VK_ESCAPE ||
                (VirtualKeyCode == 'C' &&
                 (GetKeyState(VK_CONTROL) & KEY_PRESSED) )) {
                ClearSelection(Console);
                return;
            } else if (VirtualKeyCode == VK_RETURN) {

                // if return, copy selection

                DoCopy(Console);
                return;
            } else if (gfEnableColorSelection &&
                      ('0' <= VirtualKeyCode) && ('9' >= VirtualKeyCode) &&
                      (Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER))  {

                BOOLEAN AltPressed, ShiftPressed, CtrlPressed = FALSE;
                PSMALL_RECT Selection = &Console->SelectionRect;

                //
                //  It's a numeric key,  a text mode buffer and the color selection regkey is set,
                //  then check to see if the user want's to color the selection or search and
                //  highlight the selection.
                //

                AltPressed = (ControlKeyState & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED)) != 0;
                ShiftPressed = (ControlKeyState & SHIFT_PRESSED) != 0;

                //
                //  Shift implies a find-and-color operation.  We only support finding a string,  not
                //  a block.  So if the selected area is > 1 line in height,  just ignore the shift
                //  and color the selection.  Also ignore if there is no current selection.
                //

                if ((ShiftPressed) &&
                    ( !(Console->SelectionFlags & CONSOLE_SELECTION_NOT_EMPTY) ||
                      (Selection->Top != Selection->Bottom)))  {

                    ShiftPressed = FALSE;
                }

                //
                //  If CTRL + ALT together,  then we interpret as ALT (eg on French
                //  keyboards AltGr == RALT+LCTRL,  but we want it to behave as ALT).
                //

                if (!AltPressed)  {

                    CtrlPressed = (ControlKeyState & (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)) != 0;
                }

                //
                //  Clip the selection to within the console buffer
                //

                if (Selection->Left < 0) {
                    Selection->Left = 0;
                }
                if (Selection->Top < 0) {
                    Selection->Top = 0;
                }
                if (Selection->Right >= Console->CurrentScreenBuffer->ScreenBufferSize.X) {
                    Selection->Right = (SHORT)(Console->CurrentScreenBuffer->ScreenBufferSize.X-1);
                }
                if (Selection->Bottom >= Console->CurrentScreenBuffer->ScreenBufferSize.Y) {
                    Selection->Bottom = (SHORT)(Console->CurrentScreenBuffer->ScreenBufferSize.Y-1);
                }

                //
                //  If ALT or CTRL are pressed,  then color the selected area.
                //  ALT+n => fg,  CTRL+n => bg
                //

                if (AltPressed || CtrlPressed) {

                    ULONG Attr = VirtualKeyCode - '0' + 6;

                    if (CtrlPressed)  {

                        //
                        //  Setting background color.  Set fg color to black.
                        //

                        Attr <<= 4;

                    } else {

                        //
                        //  Set foreground color.  Maintain the current console bg color
                        //

                        Attr |= Console->CurrentScreenBuffer->Attributes & 0xf0;
                    }

                    //
                    //  If shift was pressed as well,  then this is actually a find-and-color
                    //  request.  Otherwise just color the selection.
                    //

                    if (ShiftPressed)  {

                        WCHAR SearchString[SEARCH_STRING_LENGTH + 1];
                        ULONG Length, RowIndex;
                        PROW Row;
                        PSCREEN_INFORMATION ScreenInfo = Console->CurrentScreenBuffer;

                        Length = Selection->Right - Selection->Left + 1;

                        if (Length > SEARCH_STRING_LENGTH)  {

                            Length = SEARCH_STRING_LENGTH;
                        }

                        //
                        //  Pull the selection out of the buffer to pass to the search function.
                        //  Clamp to max search string length.  We just copy the bytes out of
                        //  the row buffer.
                        //

                        RowIndex = (Selection->Top + ScreenInfo->BufferInfo.TextInfo.FirstRow)
                                   % ScreenInfo->ScreenBufferSize.Y;

                        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[ RowIndex];

                        RtlCopyMemory( SearchString,
                                       &Row->CharRow.Chars[ Selection->Left],
                                       Length * sizeof( WCHAR));

                        SearchString[ Length] = L'\0';

                        //
                        //  Clear the selection,  and call the search / mark function.
                        //

                        ClearSelection(Console);

                        SearchForString( ScreenInfo,
                                         SearchString,
                                         (USHORT)Length,
                                         TRUE,
                                         FALSE,
                                         TRUE,
                                         Attr,
                                         NULL);

                    } else {
                        ColorSelection( Console, Selection, Attr);
                        ClearSelection(Console);
                    }

                    return;
                }
            }
        }

        if (!(Console->SelectionFlags & CONSOLE_MOUSE_SELECTION)) {
            if ((Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) &&
                (VirtualKeyCode == VK_RIGHT ||
                 VirtualKeyCode == VK_LEFT ||
                 VirtualKeyCode == VK_UP ||
                 VirtualKeyCode == VK_DOWN ||
                 VirtualKeyCode == VK_NEXT ||
                 VirtualKeyCode == VK_PRIOR ||
                 VirtualKeyCode == VK_END ||
                 VirtualKeyCode == VK_HOME
                ) ) {
                PSCREEN_INFORMATION ScreenInfo;
#ifdef FE_SB
                SHORT RowIndex;
                PROW Row;
                BYTE KAttrs;
                SHORT NextRightX;
                SHORT NextLeftX;
#endif

                ScreenInfo = Console->CurrentScreenBuffer;

                //
                // see if shift is down.  if so, we're extending
                // the selection.  otherwise, we're resetting the
                // anchor
                //

                ConsoleHideCursor(ScreenInfo);
#ifdef FE_SB
                RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y) % ScreenInfo->ScreenBufferSize.Y;
                Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];

               if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
               {
                    KAttrs = Row->CharRow.KAttrs[ScreenInfo->BufferInfo.TextInfo.CursorPosition.X];
                    if (KAttrs & ATTR_LEADING_BYTE)
                        NextRightX = 2;
                    else
                        NextRightX = 1;
                }
                else
                {
                    NextRightX = 1;
                }
                if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.X > 0) {
                    if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
                        KAttrs = Row->CharRow.KAttrs[ScreenInfo->BufferInfo.TextInfo.CursorPosition.X-1];
                        if (KAttrs & ATTR_TRAILING_BYTE)
                            NextLeftX = 2;
                        else if (KAttrs & ATTR_LEADING_BYTE) {
                            if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.X-1 > 0) {
                                KAttrs = Row->CharRow.KAttrs[ScreenInfo->BufferInfo.TextInfo.CursorPosition.X-2];
                                if (KAttrs & ATTR_TRAILING_BYTE)
                                    NextLeftX = 3;
                                else
                                    NextLeftX = 2;
                            }
                            else
                                NextLeftX = 1;
                        }
                        else
                            NextLeftX = 1;
                    }
                    else
                        NextLeftX = 1;
                }

                switch (VirtualKeyCode) {
                    case VK_RIGHT:
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.X+NextRightX < ScreenInfo->ScreenBufferSize.X) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.X+=NextRightX;
                        }
                        break;
                    case VK_LEFT:
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.X > 0) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.X-=NextLeftX;
                        }
                        break;
                    case VK_UP:
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y > 0) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y-=1;
                        }
                        break;
                    case VK_DOWN:
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y+1 < ScreenInfo->ScreenBufferSize.Y) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y+=1;
                        }
                        break;
                    case VK_NEXT:
                        ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y += CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-1;
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y >= ScreenInfo->ScreenBufferSize.Y) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y = ScreenInfo->ScreenBufferSize.Y-1;
                        }
                        break;
                    case VK_PRIOR:
                        ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y -= CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-1;
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y < 0) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y = 0;
                        }
                        break;
                    case VK_END:
                        ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y = ScreenInfo->ScreenBufferSize.Y-CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
                        break;
                    case VK_HOME:
                        ScreenInfo->BufferInfo.TextInfo.CursorPosition.X = 0;
                        ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y = 0;
                        break;
                    default:
                        UserAssert(FALSE);
                }
#else   // FE_SB
                switch (VirtualKeyCode) {
                    case VK_RIGHT:
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.X+1 < ScreenInfo->ScreenBufferSize.X) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.X+=1;
                        }
                        break;
                    case VK_LEFT:
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.X > 0) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.X-=1;
                        }
                        break;
                    case VK_UP:
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y > 0) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y-=1;
                        }
                        break;
                    case VK_DOWN:
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y+1 < ScreenInfo->ScreenBufferSize.Y) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y+=1;
                        }
                        break;
                    case VK_NEXT:
                        ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y += CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-1;
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y >= ScreenInfo->ScreenBufferSize.Y) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y = ScreenInfo->ScreenBufferSize.Y-1;
                        }
                        break;
                    case VK_PRIOR:
                        ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y -= CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-1;
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y < 0) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y = 0;
                        }
                        break;
                    case VK_END:
                        ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y = ScreenInfo->ScreenBufferSize.Y-CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
                        break;
                    case VK_HOME:
                        ScreenInfo->BufferInfo.TextInfo.CursorPosition.X = 0;
                        ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y = 0;
                        break;
                    default:
                        UserAssert(FALSE);
                }
#endif  // FE_SB
                ConsoleShowCursor(ScreenInfo);
                if (GetKeyState(VK_SHIFT) & KEY_PRESSED) {
                    {
                        ExtendSelection(Console,ScreenInfo->BufferInfo.TextInfo.CursorPosition);
                    }
                } else {
                    if (Console->SelectionFlags & CONSOLE_SELECTION_NOT_EMPTY) {
                        MyInvert(Console,&Console->SelectionRect);
                        Console->SelectionFlags &= ~CONSOLE_SELECTION_NOT_EMPTY;
                        ConsoleShowCursor(ScreenInfo);
                    }
                    ScreenInfo->BufferInfo.TextInfo.CursorMoved = TRUE;
                    Console->SelectionAnchor = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
                    MakeCursorVisible(ScreenInfo,Console->SelectionAnchor);
                    Console->SelectionRect.Left = Console->SelectionRect.Right = Console->SelectionAnchor.X;
                    Console->SelectionRect.Top = Console->SelectionRect.Bottom = Console->SelectionAnchor.Y;
                }
                return;
            }
        } else if (!(Console->SelectionFlags & CONSOLE_MOUSE_DOWN)) {

            //
            // if in mouse selection mode and user hits a key, cancel selection
            //

            if (!IsSystemKey(VirtualKeyCode)) {
                ClearSelection(Console);
            }
        }
    } else if (Console->Flags & CONSOLE_SCROLLING) {

        if (!bKeyDown) {
            return;
        }

        //
        // if escape, enter or ctrl-c, cancel scroll
        //

        if (VirtualKeyCode == VK_ESCAPE ||
            VirtualKeyCode == VK_RETURN ||
            (VirtualKeyCode == 'C' &&
             (GetKeyState(VK_CONTROL) & KEY_PRESSED) )) {
            ClearScroll(Console);
        } else {
            WORD ScrollCommand;
            BOOL Horizontal=FALSE;
            switch (VirtualKeyCode) {
                case VK_UP:
                    ScrollCommand = SB_LINEUP;
                    break;
                case VK_DOWN:
                    ScrollCommand = SB_LINEDOWN;
                    break;
                case VK_LEFT:
                    ScrollCommand = SB_LINEUP;
                    Horizontal=TRUE;
                    break;
                case VK_RIGHT:
                    ScrollCommand = SB_LINEDOWN;
                    Horizontal=TRUE;
                    break;
                case VK_NEXT:
                    ScrollCommand = SB_PAGEDOWN;
                    break;
                case VK_PRIOR:
                    ScrollCommand = SB_PAGEUP;
                    break;
                case VK_END:
                    ScrollCommand = SB_PAGEDOWN;
                    Horizontal=TRUE;
                    break;
                case VK_HOME:
                    ScrollCommand = SB_PAGEUP;
                    Horizontal=TRUE;
                    break;
                case VK_SHIFT:
                case VK_CONTROL:
                case VK_MENU:
                    return;
                default:
                    Beep(800, 200);
                    return;
            }
            if (Horizontal) {
                HorizontalScroll(Console->CurrentScreenBuffer, ScrollCommand, 0);
            } else {
                VerticalScroll(Console, Console->CurrentScreenBuffer,ScrollCommand,0);
            }
        }

        return;
    }

    //
    // if the user is inputting chars at an inappropriate time, beep.
    //

    if ((Console->Flags & (CONSOLE_SELECTING | CONSOLE_SCROLLING | CONSOLE_SCROLLBAR_TRACKING)) &&
        bKeyDown &&
        !IsSystemKey(VirtualKeyCode)) {
        Beep(800, 200);
        return;
    }

    //
    // if in fullscreen mode, process PrintScreen
    //

#ifdef LATER
//
// Changed this code to get commas to work (build 485).
//
// Therese, the problem is that WM_CHAR/WM_SYSCHAR messages come through
// here - in this case, LOWORD(wParam) is a character value and not a virtual
// key. It happens that VK_SNAPSHOT == 0x2c, and the character value for a
// comma is also == 0x2c, so execution enters this conditional when a comma
// is hit. Commas aren't coming out because of the newly entered return
// statement.
//
// HandleKeyEvent() is making many virtual key comparisons - need to make
// sure that for each one, there is either no corresponding character value,
// or that you check before you compare so that you are comparing two values
// that have the same data type.
//
// I added the message comparison so that we know we're checking virtual
// keys against virtual keys and not characters.
//
// - scottlu
//

#endif

    if (Message != WM_CHAR && Message != WM_SYSCHAR &&
        VirtualKeyCode == VK_SNAPSHOT &&
        !(Console->ReserveKeys & (CONSOLE_ALTPRTSC | CONSOLE_PRTSC )) ) {
        if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
            Console->SelectionFlags |= CONSOLE_SELECTION_NOT_EMPTY;
            Console->SelectionRect = Console->CurrentScreenBuffer->Window;
            StoreSelection(Console);
            Console->SelectionFlags &= ~CONSOLE_SELECTION_NOT_EMPTY;
        }
        return;
    }

    //
    // IME stuff
    //
    if (!(Console->Flags & CONSOLE_VDM_REGISTERED)) {
        LPARAM lParamForHotKey ;
        DWORD HotkeyID ;
        lParamForHotKey = lParam ;

        HotkeyID = NtUserCheckImeHotKey( (VirtualKeyCode & 0x00ff),lParamForHotKey) ;
        //
        // If it's direct KL switching hokey, handle it here
        // regardless the system is IME enabled or not.
        //
        if (HotkeyID >= IME_HOTKEY_DSWITCH_FIRST && HotkeyID <= IME_HOTKEY_DSWITCH_LAST) {
            UINT uModifier, uVkey;
            HKL hkl;

            RIPMSG1(RIP_VERBOSE, "HandleKeyEvent: handling IME HOTKEY id=%x", HotkeyID);
            if (NtUserGetImeHotKey(HotkeyID, &uModifier, &uVkey, &hkl) && hkl != NULL) {
                BYTE bCharSetSys = CodePageToCharSet(GetACP());
                WPARAM wpSysChar = 0;
                CHARSETINFO cs;

                if (TranslateCharsetInfo((LPDWORD)LOWORD(hkl), &cs, TCI_SRCLOCALE)) {
                    if (bCharSetSys == cs.ciCharset) {
                        wpSysChar = INPUTLANGCHANGE_SYSCHARSET;
                    }
                }
                PostMessage(hWnd, WM_INPUTLANGCHANGEREQUEST, wpSysChar, (LPARAM)hkl);
            }
            return;
        }

        if (!(Console->InputBuffer.ImeMode.Disable) && CONSOLE_IS_IME_ENABLED()) {

            if (HotkeyID != IME_INVALID_HOTKEY) {
                switch(HotkeyID) {
                case IME_JHOTKEY_CLOSE_OPEN:
                    {
                        BOOL fOpen = Console->InputBuffer.ImeMode.Open;
                        if (!bKeyDown)
                            break ;

                        Console->InputBuffer.ImeMode.Open = !fOpen ;
                        if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                                              CONIME_HOTKEY,
                                              (WPARAM)Console->ConsoleHandle,
                                              HotkeyID))) {
                            break;
                        }

                        // Update in the system conversion mode buffer.
                        GetImeKeyState(Console, NULL);

                        break ;
                    }
                case IME_CHOTKEY_IME_NONIME_TOGGLE:
                case IME_THOTKEY_IME_NONIME_TOGGLE:
                case IME_CHOTKEY_SHAPE_TOGGLE:
                case IME_THOTKEY_SHAPE_TOGGLE:
                case IME_CHOTKEY_SYMBOL_TOGGLE:
                case IME_THOTKEY_SYMBOL_TOGGLE:
                case IME_KHOTKEY_SHAPE_TOGGLE:
                case IME_KHOTKEY_HANJACONVERT:
                case IME_KHOTKEY_ENGLISH:
                case IME_ITHOTKEY_RESEND_RESULTSTR:
                case IME_ITHOTKEY_PREVIOUS_COMPOSITION:
                case IME_ITHOTKEY_UISTYLE_TOGGLE:
                default:
                    {
                        if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                                              CONIME_HOTKEY,
                                              (WPARAM)Console->ConsoleHandle,
                                              HotkeyID))) {
                            break;
                        }

                        // Update in the system conversion mode buffer.
                        GetImeKeyState(Console, NULL);

                        break ;
                    }
                }
                return ;
            }

            if ( CTRL_BUT_NOT_ALT(ControlKeyState) &&
                    (bKeyDown) ) {
                if (VirtualKeyCode == 'C' &&
                        Console->InputBuffer.InputMode & ENABLE_PROCESSED_INPUT) {
                    goto FromConsoleIME ;
                }
                else if (VirtualKeyCode == VK_CANCEL) {
                    goto FromConsoleIME ;
                }
                else if (VirtualKeyCode == 'S'){
                    goto FromConsoleIME ;
                }
            }
            else if (VirtualKeyCode == VK_PAUSE ){
                goto FromConsoleIME ;
            }
            else if ( ((VirtualKeyCode == VK_SHIFT)   ||
                       (VirtualKeyCode == VK_CONTROL) ||
                       (VirtualKeyCode == VK_CAPITAL) ||
                       (VirtualKeyCode == VK_KANA)    ||    // VK_KANA == VK_HANGUL
                       (VirtualKeyCode == VK_JUNJA)   ||
                       (VirtualKeyCode == VK_HANJA)   ||
                       (VirtualKeyCode == VK_NUMLOCK) ||
                       (VirtualKeyCode == VK_SCROLL)     )
                      &&
                      !(Console->InputBuffer.ImeMode.Unavailable) &&
                      !(Console->InputBuffer.ImeMode.Open)
                    )
            {
                if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                                      Message+CONIME_KEYDATA,
                                      (WPARAM)LOWORD(wParam)<<16|LOWORD(VirtualKeyCode),
                                      lParam
                                     ))) {
                    return;
                }
                goto FromConsoleIME ;
            }

            if (!Console->InputBuffer.ImeMode.Unavailable && Console->InputBuffer.ImeMode.Open) {
                if (! (HIWORD(lParam) & KF_REPEAT))
                {
                    if (PRIMARYLANGID(LOWORD(Console->hklActive)) == LANG_JAPANESE &&
                            (BYTE)wParam == VK_KANA) {
                        if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                                              CONIME_NOTIFY_VK_KANA,
                                              0,
                                              0
                                             ))) {
                            return;
                        }
                    }
                }

                ConsoleImeMessagePump(Console,
                                      Message+CONIME_KEYDATA,
                                      LOWORD(wParam)<<16|LOWORD(VirtualKeyCode),
                                      lParam
                                     );
                return ;
            }
        }
    }
FromConsoleIME:

    //
    // ignore key strokes that will generate CHAR messages.  this is only
    // necessary while a dialog box is up.
    //

    if (DialogBoxCount > 0) {
        if (Message != WM_CHAR && Message != WM_SYSCHAR && Message != WM_DEADCHAR && Message != WM_SYSDEADCHAR) {
            WCHAR awch[MAX_CHARS_FROM_1_KEYSTROKE];
            int cwch;
            BYTE KeyState[256];

            GetKeyboardState(KeyState);
            cwch = ToUnicodeEx((UINT)wParam,
                               HIWORD(lParam),
                               KeyState,
                               awch,
                               ARRAY_SIZE(awch),
                               TM_POSTCHARBREAKS,
                               NULL);
            if (cwch != 0) {
                return;
            }
        } else {
            // remember to generate break
            if (Message == WM_CHAR) {
                bGenerateBreak = TRUE;
            }
        }
    }

#ifdef FE_IME
    // ignore key stroke while IME property is up.
    if (Console->InputBuffer.hWndConsoleIME)
        return;
#endif

    InputEvent.EventType = KEY_EVENT;
    InputEvent.Event.KeyEvent.bKeyDown = bKeyDown;
    InputEvent.Event.KeyEvent.wRepeatCount = LOWORD(lParam);

    if (Message == WM_CHAR || Message == WM_SYSCHAR || Message == WM_DEADCHAR || Message == WM_SYSDEADCHAR) {
        // If this is a fake character, zero the scancode.
        if (lParam & 0x02000000) {
            InputEvent.Event.KeyEvent.wVirtualScanCode = 0;
        }
        InputEvent.Event.KeyEvent.dwControlKeyState = GetControlKeyState(lParam);
        if (Message == WM_CHAR || Message == WM_SYSCHAR) {
            InputEvent.Event.KeyEvent.uChar.UnicodeChar = (WCHAR)wParam;
        } else {
            InputEvent.Event.KeyEvent.uChar.UnicodeChar = (WCHAR)0;
        }
    } else {
        // if alt-gr, ignore
        if (lParam & 0x02000000) {
            return;
        }
        InputEvent.Event.KeyEvent.dwControlKeyState = ControlKeyState;
        InputEvent.Event.KeyEvent.uChar.UnicodeChar = 0;
    }

#ifdef FE_IME
    if (CONSOLE_IS_IME_ENABLED()) {
        // MSKK August.22.1993 KazuM
        DWORD dwConversion;

        if (!NT_SUCCESS(GetImeKeyState(Console, &dwConversion))) {
            return;
        }

        InputEvent.Event.KeyEvent.dwControlKeyState |= ImmConversionToConsole(dwConversion);
    }
#endif

    ContinueProcessing=TRUE;

    if (CTRL_BUT_NOT_ALT(InputEvent.Event.KeyEvent.dwControlKeyState) &&
        InputEvent.Event.KeyEvent.bKeyDown) {

        //
        // check for ctrl-c, if in line input mode.
        //

        if (InputEvent.Event.KeyEvent.wVirtualKeyCode == 'C' &&
            Console->InputBuffer.InputMode & ENABLE_PROCESSED_INPUT) {
            HandleCtrlEvent(Console,CTRL_C_EVENT);
            if (!Console->PopupCount)
                TerminateRead(Console,&Console->InputBuffer,CONSOLE_CTRL_C_SEEN);
            if (!(Console->Flags & CONSOLE_SUSPENDED)) {
                ContinueProcessing=FALSE;
            }
        }

        //
        // check for ctrl-break.
        //

        else if (InputEvent.Event.KeyEvent.wVirtualKeyCode == VK_CANCEL) {
            FlushInputBuffer(&Console->InputBuffer);
            HandleCtrlEvent(Console,CTRL_BREAK_EVENT);
            if (!Console->PopupCount)
                TerminateRead(Console,&Console->InputBuffer,CONSOLE_CTRL_BREAK_SEEN);
            if (!(Console->Flags & CONSOLE_SUSPENDED)) {
                ContinueProcessing=FALSE;
            }
        }

        //
        // don't write ctrl-esc to the input buffer
        //

        else if (InputEvent.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE &&
                 !(Console->ReserveKeys & CONSOLE_CTRLESC)) {
            ContinueProcessing=FALSE;
        }
    } else if (InputEvent.Event.KeyEvent.dwControlKeyState & (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED) &&
               InputEvent.Event.KeyEvent.bKeyDown &&
               InputEvent.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE &&
               !(Console->ReserveKeys & CONSOLE_ALTESC)) {
        ContinueProcessing=FALSE;
    }

    if (ContinueProcessing) {
        EventsWritten = WriteInputBuffer( Console,
                                          &Console->InputBuffer,
                                          &InputEvent,
                                          1
                                         );
        if (EventsWritten && bGenerateBreak) {
            InputEvent.Event.KeyEvent.bKeyDown = FALSE;
            WriteInputBuffer( Console,
                              &Console->InputBuffer,
                              &InputEvent,
                              1
                             );
        }
    }
}

/*
 * Returns TRUE if DefWindowProc should be called.
 */
BOOL
HandleMouseEvent(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN UINT Message,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
    ULONG ButtonFlags,EventFlags;
    INPUT_RECORD InputEvent;
    ULONG EventsWritten;
    COORD MousePosition;
    SHORT RowIndex;
    PROW Row;

    if (!(Console->Flags & CONSOLE_HAS_FOCUS) &&
        !(Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) &&
        !(Console->SelectionFlags & CONSOLE_MOUSE_DOWN)) {
        return TRUE;
    }

    if (Console->Flags & CONSOLE_IGNORE_NEXT_MOUSE_INPUT) {
        // only reset on up transition
        if (Message != WM_LBUTTONDOWN &&
            Message != WM_MBUTTONDOWN &&
            Message != WM_RBUTTONDOWN) {
            Console->Flags &= ~CONSOLE_IGNORE_NEXT_MOUSE_INPUT;
            return FALSE;
        }
        return TRUE;
    }

    //
    // translate mouse position into characters, if necessary.
    //

    MousePosition.X = LOWORD(lParam);
    MousePosition.Y = HIWORD(lParam);
    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        MousePosition.X /= SCR_FONTSIZE(ScreenInfo).X;
        MousePosition.Y /= SCR_FONTSIZE(ScreenInfo).Y;
    }
    MousePosition.X += ScreenInfo->Window.Left;
    MousePosition.Y += ScreenInfo->Window.Top;

    //
    // make sure mouse position is clipped to screen buffer
    //

    if (MousePosition.X < 0) {
        MousePosition.X = 0;
    } else if (MousePosition.X >= ScreenInfo->ScreenBufferSize.X) {
        MousePosition.X = ScreenInfo->ScreenBufferSize.X - 1;
    }
    if (MousePosition.Y < 0) {
        MousePosition.Y = 0;
    } else if (MousePosition.Y >= ScreenInfo->ScreenBufferSize.Y) {
        MousePosition.Y = ScreenInfo->ScreenBufferSize.Y - 1;
    }

    if (Console->Flags & CONSOLE_SELECTING ||
        ((Console->Flags & CONSOLE_QUICK_EDIT_MODE) &&
         (Console->FullScreenFlags == 0))) {
        if (Message == WM_LBUTTONDOWN) {

            //
            // make sure message matches button state
            //

            if (!(GetKeyState(VK_LBUTTON) & KEY_PRESSED)) {
                return FALSE;
            }

            if (Console->Flags & CONSOLE_QUICK_EDIT_MODE &&
                !(Console->Flags & CONSOLE_SELECTING)) {
                Console->Flags |= CONSOLE_SELECTING;
                Console->SelectionFlags = CONSOLE_MOUSE_SELECTION | CONSOLE_MOUSE_DOWN | CONSOLE_SELECTION_NOT_EMPTY;

                //
                // invert selection
                //

                InitializeMouseSelection(Console, MousePosition);
                MyInvert(Console,&Console->SelectionRect);
                SetWinText(Console,msgSelectMode,TRUE);
                SetCapture(Console->hWnd);
            } else {
                //
                // We now capture the mouse to our Window. We do this so that the
                // user can "scroll" the selection endpoint to an off screen
                // position by moving the mouse off the client area.
                //

                if (Console->SelectionFlags & CONSOLE_MOUSE_SELECTION) {
                    //
                    // Check for SHIFT-Mouse Down "continue previous selection"
                    // command.
                    //
                    if (GetKeyState(VK_SHIFT) & KEY_PRESSED) {
                        Console->SelectionFlags |= CONSOLE_MOUSE_DOWN;
                        SetCapture(Console->hWnd);
                        ExtendSelection(Console, MousePosition);
                    } else {
                        //
                        // Invert old selection, reset anchor, and invert
                        // new selection.
                        //

                        MyInvert(Console,&Console->SelectionRect);
                        Console->SelectionFlags |= CONSOLE_MOUSE_DOWN;
                        SetCapture(Console->hWnd);
                        InitializeMouseSelection(Console, MousePosition);
                        MyInvert(Console,&Console->SelectionRect);
                    }
                } else {
                    ConvertToMouseSelect(Console, MousePosition);
                }
            }
        } else if (Message == WM_LBUTTONUP) {
            if (Console->SelectionFlags & CONSOLE_MOUSE_SELECTION) {
                Console->SelectionFlags &= ~CONSOLE_MOUSE_DOWN;
                ReleaseCapture();
            }
        } else if (Message == WM_LBUTTONDBLCLK) {
            if ((MousePosition.X == Console->SelectionAnchor.X) &&
                (MousePosition.Y == Console->SelectionAnchor.Y)) {
                RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+MousePosition.Y) % ScreenInfo->ScreenBufferSize.Y;
                Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
                while (Console->SelectionAnchor.X > 0) {
                    if (IS_WORD_DELIM(Row->CharRow.Chars[Console->SelectionAnchor.X - 1])) {
                        break;
                    }
                    Console->SelectionAnchor.X--;
                }
                while (MousePosition.X < ScreenInfo->ScreenBufferSize.X) {
                    if (IS_WORD_DELIM(Row->CharRow.Chars[MousePosition.X])) {
                        break;
                    }
                    MousePosition.X++;
                }
                if (gfTrimLeadingZeros) {
                    //
                    // Trim the leading zeros: 000fe12 -> fe12, except 0x and 0n.
                    // Useful for debugging
                    //
                    if (MousePosition.X > Console->SelectionAnchor.X + 2 &&
                            Row->CharRow.Chars[Console->SelectionAnchor.X + 1] != L'x' &&
                            Row->CharRow.Chars[Console->SelectionAnchor.X + 1] != L'X' &&
                            Row->CharRow.Chars[Console->SelectionAnchor.X + 1] != L'n') {
                        // Don't touch the selection begins with 0x
                        while (Row->CharRow.Chars[Console->SelectionAnchor.X] == L'0' && Console->SelectionAnchor.X < MousePosition.X - 1) {
                            Console->SelectionAnchor.X++;
                        }
                    }
                }
                ExtendSelection(Console, MousePosition);
            }
        } else if ((Message == WM_RBUTTONDOWN) || (Message == WM_RBUTTONDBLCLK)) {
            if (!(Console->SelectionFlags & CONSOLE_MOUSE_DOWN)) {
                if (Console->Flags & CONSOLE_SELECTING) {
                    DoCopy(Console);
                } else if (Console->Flags & CONSOLE_QUICK_EDIT_MODE) {
                    DoPaste(Console);
                }
                Console->Flags |= CONSOLE_IGNORE_NEXT_MOUSE_INPUT;
            }
        } else if (Message == WM_MOUSEMOVE) {
            if (Console->SelectionFlags & CONSOLE_MOUSE_DOWN) {
                ExtendSelection(Console, MousePosition);
            }
        } else if (Message == WM_MOUSEWHEEL) {
            return TRUE;
        }
        return FALSE;
    }

    if (!(Console->InputBuffer.InputMode & ENABLE_MOUSE_INPUT)) {
        ReleaseCapture();
        if (Console->FullScreenFlags == 0) {
            return TRUE;
        }
        return FALSE;
    }

    InputEvent.Event.MouseEvent.dwControlKeyState = GetControlKeyState(0);

    if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
        if (MousePosition.X > ScreenInfo->Window.Right) {
            MousePosition.X = ScreenInfo->Window.Right;
        }
        if (MousePosition.Y > ScreenInfo->Window.Bottom) {
            MousePosition.Y = ScreenInfo->Window.Bottom;
        }
    }

    switch (Message) {
        case WM_LBUTTONDOWN:
            SetCapture(Console->hWnd);
            ButtonFlags = FROM_LEFT_1ST_BUTTON_PRESSED;
            EventFlags = 0;
            break;
        case WM_LBUTTONUP:
        case WM_MBUTTONUP:
        case WM_RBUTTONUP:
            ReleaseCapture();
            ButtonFlags = EventFlags = 0;
            break;
        case WM_RBUTTONDOWN:
            SetCapture(Console->hWnd);
            ButtonFlags = RIGHTMOST_BUTTON_PRESSED;
            EventFlags = 0;
            break;
        case WM_MBUTTONDOWN:
            SetCapture(Console->hWnd);
            ButtonFlags = FROM_LEFT_2ND_BUTTON_PRESSED;
            EventFlags = 0;
            break;
        case WM_MOUSEMOVE:
            ButtonFlags = 0;
            EventFlags = MOUSE_MOVED;
            break;
        case WM_LBUTTONDBLCLK:
            ButtonFlags = FROM_LEFT_1ST_BUTTON_PRESSED;
            EventFlags = DOUBLE_CLICK;
            break;
        case WM_RBUTTONDBLCLK:
            ButtonFlags = RIGHTMOST_BUTTON_PRESSED;
            EventFlags = DOUBLE_CLICK;
            break;
        case WM_MBUTTONDBLCLK:
            ButtonFlags = FROM_LEFT_2ND_BUTTON_PRESSED;
            EventFlags = DOUBLE_CLICK;
            break;
        case WM_MOUSEWHEEL:
            ButtonFlags = ((UINT)wParam & 0xFFFF0000);
            EventFlags = MOUSE_WHEELED;
            break;
        default:
            RIPMSG1(RIP_ERROR, "Invalid message 0x%x", Message);
    }
    InputEvent.EventType = MOUSE_EVENT;
    InputEvent.Event.MouseEvent.dwMousePosition = MousePosition;
    InputEvent.Event.MouseEvent.dwEventFlags = EventFlags;
    InputEvent.Event.MouseEvent.dwButtonState =
    ConvertMouseButtonState(ButtonFlags, (UINT)wParam);
    EventsWritten = WriteInputBuffer(Console,
                                     &Console->InputBuffer,
                                     &InputEvent,
                                     1
                                     );
    if (EventsWritten != 1) {
        RIPMSG1(RIP_WARNING,
                "PutInputInBuffer: EventsWritten != 1 (0x%x), 1 expected",
                EventsWritten);
    }

#ifdef i386
    if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
        UpdateMousePosition(ScreenInfo, InputEvent.Event.MouseEvent.dwMousePosition);
    }
#endif
    return FALSE;
}

VOID
HandleFocusEvent(
    IN PCONSOLE_INFORMATION Console,
    IN BOOL bSetFocus
    )
{
    INPUT_RECORD InputEvent;
    ULONG EventsWritten;
    USERTHREAD_FLAGS Flags;

    InputEvent.EventType = FOCUS_EVENT;
    InputEvent.Event.FocusEvent.bSetFocus = bSetFocus;

    Flags.dwFlags = 0;
    if (bSetFocus) {
        if (Console->Flags & CONSOLE_VDM_REGISTERED) {
            Flags.dwFlags |= TIF_VDMAPP;
        }
        if (Console->Flags & CONSOLE_CONNECTED_TO_EMULATOR) {
            Flags.dwFlags |= TIF_DOSEMULATOR;
        }
    }

    Flags.dwMask = (TIF_VDMAPP | TIF_DOSEMULATOR);
    NtUserSetInformationThread(Console->InputThreadInfo->ThreadHandle,
            UserThreadFlags, &Flags, sizeof(Flags));
    EventsWritten = WriteInputBuffer( Console,
                                      &Console->InputBuffer,
                                      &InputEvent,
                                      1
                                     );
#if DBG
    if (EventsWritten != 1) {
        DbgPrint("PutInputInBuffer: EventsWritten != 1, 1 expected\n");
    }
#endif
}

VOID
HandleMenuEvent(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD wParam
    )
{
    INPUT_RECORD InputEvent;
    ULONG EventsWritten;

    InputEvent.EventType = MENU_EVENT;
    InputEvent.Event.MenuEvent.dwCommandId = wParam;
    EventsWritten = WriteInputBuffer( Console,
                                      &Console->InputBuffer,
                                      &InputEvent,
                                      1
                                     );
#if DBG
    if (EventsWritten != 1) {
        DbgPrint("PutInputInBuffer: EventsWritten != 1, 1 expected\n");
    }
#endif
}

VOID
HandleCtrlEvent(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD EventType
    )
{
    switch (EventType) {
        case CTRL_C_EVENT:
            Console->CtrlFlags |= CONSOLE_CTRL_C_FLAG;
            break;
        case CTRL_BREAK_EVENT:
            Console->CtrlFlags |= CONSOLE_CTRL_BREAK_FLAG;
            break;
        case CTRL_CLOSE_EVENT:
            Console->CtrlFlags |= CONSOLE_CTRL_CLOSE_FLAG;
            break;
        default:
            RIPMSG1(RIP_ERROR, "Invalid EventType: 0x%x", EventType);
    }
}

VOID
KillProcess(
    PCONSOLE_PROCESS_TERMINATION_RECORD ProcessHandleRecord,
    ULONG_PTR ProcessId
    )
{
    NTSTATUS status;

    //
    // Just terminate the process outright.
    //

    status = NtTerminateProcess(ProcessHandleRecord->ProcessHandle,
                ProcessHandleRecord->bDebugee ? DBG_TERMINATE_PROCESS : CONTROL_C_EXIT);

#if DBG
    if (status != STATUS_SUCCESS &&
            status != STATUS_PROCESS_IS_TERMINATING &&
            status != STATUS_THREAD_WAS_SUSPENDED &&
            !(status == STATUS_ACCESS_DENIED && ProcessHandleRecord->bDebugee)) {
        DbgPrint("NtTerminateProcess failed - status = %x\n", status);
        DbgBreakPoint();
    }
#endif

    //
    // Clear any remaining hard errors for the process.
    //

    if (ProcessId)
        BoostHardError(ProcessId, BHE_FORCE);

    //
    // Give the process 5 seconds to exit.
    //

    if (NT_SUCCESS(status)) {
        LARGE_INTEGER li;

        li.QuadPart = (LONGLONG)-10000 * CMSHUNGAPPTIMEOUT;
        status = NtWaitForSingleObject(ProcessHandleRecord->ProcessHandle,
                                       FALSE,
                                       &li);
        if (status != STATUS_WAIT_0) {
            RIPMSG2(RIP_WARNING,
                    "KillProcess: wait for process %x failed with status %x",
                    ProcessId, status);
        }
    }
}

int CreateCtrlThread(
    IN PCONSOLE_PROCESS_TERMINATION_RECORD ProcessHandleList,
    IN ULONG ProcessHandleListLength,
    IN PWCHAR Title,
    IN DWORD EventType,
    IN BOOL fForce)
{
    HANDLE Thread;
    DWORD Status;
    NTSTATUS status;
    DWORD ShutdownFlags;
    int Success=CONSOLE_SHUTDOWN_SUCCEEDED;
    ULONG i;
    DWORD EventFlags;
    PROCESS_BASIC_INFORMATION BasicInfo;
    PCSR_PROCESS Process;
    BOOL fForceProcess;
    BOOL fExitProcess;
    BOOL fFirstPass=TRUE;
    BOOL fSecondPassNeeded=FALSE;
    BOOL fHasError;
    BOOL fFirstWait;
    BOOL fEventProcessed;
    BOOL fBreakEvent;

BigLoop:
    for (i = 0; i < ProcessHandleListLength; i++) {

        //
        // If the user has already cancelled shutdown, don't try to kill
        // any more processes.
        //

        if (Success == CONSOLE_SHUTDOWN_FAILED) {
            break;
        }

        //
        // Get the process shutdown parameters here. First get the process
        // id so we can get the csr process structure pointer.
        //

        status = NtQueryInformationProcess(ProcessHandleList[i].ProcessHandle,
                                           ProcessBasicInformation,
                                           &BasicInfo,
                                           sizeof(BasicInfo),
                                           NULL);

        //
        // Grab the shutdown flags from the csr process structure.  If
        // the structure cannot be found, terminate the process.
        //

        ProcessHandleList[i].bDebugee = FALSE;
        ShutdownFlags = 0;
        if (NT_SUCCESS(status)) {
            CsrLockProcessByClientId((HANDLE)BasicInfo.UniqueProcessId, &Process);
            if (Process == NULL) {
                KillProcess(&ProcessHandleList[i], BasicInfo.UniqueProcessId);
                continue;
            }
        } else {
            KillProcess(&ProcessHandleList[i], 0);
            continue;
        }
        ShutdownFlags = Process->ShutdownFlags;
        ProcessHandleList[i].bDebugee = Process->DebugUserInterface.UniqueProcess!=NULL;
        CsrUnlockProcess(Process);

        if (!ProcessHandleList[i].bDebugee) {
            HANDLE DebugPort = NULL;

            //
            // See if we're a console app that's being debugged.
            //
            status = NtQueryInformationProcess(
                        ProcessHandleList[i].ProcessHandle,
                        ProcessDebugPort,
                        (PVOID)&DebugPort,
                        sizeof(DebugPort),
                        NULL
                        );
            if (NT_SUCCESS(status) && DebugPort) {
                ProcessHandleList[i].bDebugee = TRUE;
            }
        }
        if (EventType != CTRL_C_EVENT && EventType != CTRL_BREAK_EVENT) {
            fBreakEvent = FALSE;
            if (fFirstPass) {
                if (ProcessHandleList[i].bDebugee) {
                    fSecondPassNeeded = TRUE;
                    continue;
                }
            } else {
                if (!ProcessHandleList[i].bDebugee) {
                    continue;
                }
            }
        } else {
            fBreakEvent = TRUE;
            fFirstPass=FALSE;
        }

        //
        // fForce is whether ExitWindowsEx was called with EWX_FORCE.
        // ShutdownFlags are the shutdown flags for this process. If
        // either are force (noretry is the same as force), then force:
        // which means if the app doesn't exit, don't bring up the retry
        // dialog - just force it to exit right away.
        //

        fForceProcess = fForce || (ShutdownFlags & SHUTDOWN_NORETRY);

        //
        // Only notify system security and service context processes.
        // Don't bring up retry dialogs for them.
        //

        fExitProcess = TRUE;
        EventFlags = 0;
        if (ShutdownFlags & (SHUTDOWN_SYSTEMCONTEXT | SHUTDOWN_OTHERCONTEXT)) {

            //
            // System context - make sure we don't cause it to exit, make
            // sure we don't bring up retry dialogs.
            //

            fExitProcess = FALSE;
            fForceProcess = TRUE;

            //
            // This EventFlag will be passed on down to the CtrlRoutine()
            // on the client side. That way that side knows not to exit
            // this process.
            //

            EventFlags = 0x80000000;
        }

        //
        // Is this the first time we're waiting for this process to die?
        //

        fFirstWait = TRUE;
        fEventProcessed = FALSE;

        while (!fEventProcessed) {
            DWORD ThreadExitCode;
            DWORD ProcessExitCode;
            DWORD cMsTimeout;

            Thread = InternalCreateCallbackThread(ProcessHandleList[i].ProcessHandle,
                                                  (ULONG_PTR)ProcessHandleList[i].CtrlRoutine,
                                                  EventType | EventFlags);

            //
            // If the thread cannot be created, terminate the process.
            //
            if (Thread == NULL) {
                RIPMSG1(RIP_WARNING,
                        "CreateRemoteThread failed 0x%x",
                        GetLastError());
                break;
            }

            //
            // Mark the event as processed.
            //

            fEventProcessed = TRUE;

            /*
             * if it's a ctrl-c or ctrl-break event, just close our
             * handle to the thread.  otherwise it's a close.  wait
             * for client-side thread to terminate.
             */

            if (EventType == CTRL_CLOSE_EVENT) {
                cMsTimeout = gCmsHungAppTimeout;
            } else if (EventType == CTRL_LOGOFF_EVENT) {
                cMsTimeout = gCmsWaitToKillTimeout;
            } else if (EventType == CTRL_SHUTDOWN_EVENT) {

                //
                // If we are shutting down services.exe, we need to look in the
                // registry to see how long to wait.
                //

                if (fFirstWait && BasicInfo.UniqueProcessId == gdwServicesProcessId) {
                    cMsTimeout = gdwServicesWaitToKillTimeout;
                } else {
                    cMsTimeout = gCmsWaitToKillTimeout;
                }
            } else {
                CloseHandle(Thread);
                fExitProcess = FALSE;
                break;
            }

            while (TRUE) {
                fHasError = BoostHardError(BasicInfo.UniqueProcessId,
                        (fForceProcess ? BHE_FORCE : BHE_ACTIVATE));

                //
                // Use a 1 second wait if there was a hard error, otherwise
                // wait cMsTimeout ms.
                //

                Status = InternalWaitCancel(Thread,
                        (fHasError && fForceProcess) ? 1000 : cMsTimeout);
                if (Status == WAIT_TIMEOUT) {
                    int Action;

                    //
                    // If there was a hard error, see if there is another one.
                    //

                    if (fHasError && fForceProcess) {
                        continue;
                    }

                    if (!fForceProcess) {

                        //
                        // we timed out in the handler.  ask the user what
                        // to do.
                        //

                        DialogBoxCount++;
                        Action = ThreadShutdownNotify(WMCS_CONSOLE, (ULONG_PTR)Thread, (LPARAM)Title);
                        DialogBoxCount--;

                        //
                        // If the response is Cancel or EndTask, exit the loop.
                        // Otherwise retry the wait.
                        //

                        if (Action == TSN_USERSAYSCANCEL) {
                            Success = CONSOLE_SHUTDOWN_FAILED;
                        }
                    }
                } else if (Status == 0) {
                    ThreadExitCode = 0;
                    GetExitCodeThread(Thread,&ThreadExitCode);
                    GetExitCodeProcess(ProcessHandleList[i].ProcessHandle,
                            &ProcessExitCode);

                    //
                    // if the app returned TRUE (event handled)
                    // notify the user and see if the app should
                    // be terminated anyway.
                    //

                    if (fHasError || (ThreadExitCode == EventType &&
                            ProcessExitCode == STILL_ACTIVE)) {
                        int Action;

                        if (!fForceProcess) {

                            //
                            // Wait for the process to exit.  If it does exit,
                            // don't bring up the end task dialog.
                            //

                            Status = InternalWaitCancel(ProcessHandleList[i].ProcessHandle,
                                    (fHasError || fFirstWait) ? 1000 : cMsTimeout);
                            if (Status == 0) {

                                //
                                // The process exited.
                                //

                                fExitProcess = FALSE;
                            } else if (Status == WAIT_TIMEOUT) {
                                DialogBoxCount++;
                                Action = ThreadShutdownNotify(WMCS_CONSOLE,
                                                              (ULONG_PTR)ProcessHandleList[i].ProcessHandle,
                                                               (LPARAM)Title);
                                DialogBoxCount--;

                                if (Action == TSN_USERSAYSCANCEL) {
                                    Success = CONSOLE_SHUTDOWN_FAILED;
                                }
                            }
                        }
                    } else {

                        //
                        // The process exited.
                        //

                        fExitProcess = FALSE;
                    }
                }

                //
                // If we get here, we know that all wait conditions have
                // been satisfied.  Time to finish with the process.
                //

                break;
            }

            CloseHandle(Thread);
        }

        //
        // If the process is shutting down, mark it as terminated.
        // This prevents the process from raising any hard error popups
        // after we're done shutting it down.
        //

        if (!fBreakEvent &&
                !(ShutdownFlags & (SHUTDOWN_SYSTEMCONTEXT | SHUTDOWN_OTHERCONTEXT)) &&
                Success == CONSOLE_SHUTDOWN_SUCCEEDED) {
            CsrLockProcessByClientId(
                    (HANDLE)BasicInfo.UniqueProcessId, &Process);
            if (Process) {
                Process->Flags |= CSR_PROCESS_TERMINATED;
                CsrUnlockProcess(Process);
            }

            //
            // Force the termination of the process if needed.  Otherwise,
            // acknowledge any remaining hard errors.
            //
            if (fExitProcess) {
                KillProcess(&ProcessHandleList[i],
                        BasicInfo.UniqueProcessId);
            } else {
                BoostHardError(BasicInfo.UniqueProcessId, BHE_FORCE);
            }
        }
    }

    //
    // If this was our first time through and we skipped one of the
    // processes because it was being debugged, we'll go back for a
    // second pass.
    //

    if (fFirstPass && fSecondPassNeeded) {
        fFirstPass = FALSE;
        goto BigLoop;
    }

    // if we're shutting down a system or service security context
    // thread, don't wait for the process to terminate

    if (ShutdownFlags & (SHUTDOWN_SYSTEMCONTEXT | SHUTDOWN_OTHERCONTEXT)) {
        return CONSOLE_SHUTDOWN_SYSTEM;
    }
    return Success;
}

int
ProcessCtrlEvents(
    IN PCONSOLE_INFORMATION Console
    )
/* returns TRUE if a ctrl thread was created */
{
    PWCHAR Title;
    CONSOLE_PROCESS_TERMINATION_RECORD ProcessHandles[2];
    PCONSOLE_PROCESS_TERMINATION_RECORD ProcessHandleList;
    ULONG ProcessHandleListLength,i;
    ULONG CtrlFlags;
    PLIST_ENTRY ListHead, ListNext;
    BOOL FreeTitle;
    int Success;
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    DWORD EventType;
    DWORD LimitingProcessId;
    NTSTATUS Status;

    //
    // If the console was marked for destruction, do it now.
    //

    if (Console->Flags & CONSOLE_IN_DESTRUCTION) {
        DestroyConsole(Console);
        return CONSOLE_SHUTDOWN_FAILED;
    }

    //
    // make sure we don't try to process control events if this
    // console is already going away
    //

    if (Console->Flags & CONSOLE_TERMINATING) {
        Console->CtrlFlags = 0;
    }

    if (Console->CtrlFlags == 0) {
        RtlLeaveCriticalSection(&Console->ConsoleLock);
        return CONSOLE_SHUTDOWN_FAILED;
    }

    //
    // make our own copy of the console process handle list
    //

    LimitingProcessId = Console->LimitingProcessId;
    Console->LimitingProcessId = 0;

    ListHead = &Console->ProcessHandleList;
    ListNext = ListHead->Flink;
    ProcessHandleListLength = 0;
    while (ListNext != ListHead) {
        ProcessHandleRecord = CONTAINING_RECORD( ListNext, CONSOLE_PROCESS_HANDLE, ListLink );
        ListNext = ListNext->Flink;
        if ( LimitingProcessId ) {
            if ( ProcessHandleRecord->Process->ProcessGroupId == LimitingProcessId ) {
                ProcessHandleListLength += 1;
            }
        } else {
            ProcessHandleListLength += 1;
        }
    }

    //
    // Use the stack buffer to hold the process handles if there are only a
    // few, otherwise allocate a buffer from the heap.
    //

    if (ProcessHandleListLength <= ARRAY_SIZE(ProcessHandles)) {
        ProcessHandleList = ProcessHandles;
    } else {
        ProcessHandleList = ConsoleHeapAlloc(TMP_TAG, ProcessHandleListLength * sizeof(CONSOLE_PROCESS_TERMINATION_RECORD));
        if (ProcessHandleList == NULL) {
            RtlLeaveCriticalSection(&Console->ConsoleLock);
            return CONSOLE_SHUTDOWN_FAILED;
        }
    }

    ListNext = ListHead->Flink;
    i = 0;
    while (ListNext != ListHead) {
        BOOLEAN ProcessIsIn;

        UserAssert(i <= ProcessHandleListLength);
        ProcessHandleRecord = CONTAINING_RECORD(ListNext, CONSOLE_PROCESS_HANDLE, ListLink);
        ListNext = ListNext->Flink;

        if (LimitingProcessId) {
            if (ProcessHandleRecord->Process->ProcessGroupId == LimitingProcessId) {
                ProcessIsIn = TRUE;
            } else {
                ProcessIsIn = FALSE;
            }
        } else {
            ProcessIsIn = TRUE;
        }

        if (ProcessIsIn) {
            Success = (int)DuplicateHandle(NtCurrentProcess(),
                           ProcessHandleRecord->ProcessHandle,
                           NtCurrentProcess(),
                           &ProcessHandleList[i].ProcessHandle,
                           0,
                           FALSE,
                           DUPLICATE_SAME_ACCESS);

            //
            // If the duplicate failed, the best we can do is to skip
            // including the process in the list and hope it goes
            // away.
            //
            if (!Success) {
                RIPMSG3(RIP_WARNING,
                        "Dup handle failed for %d of %d in 0x%p",
                        i,
                        ProcessHandleListLength,
                        Console);
                continue;
            }

            if (Console->CtrlFlags & CONSOLE_CTRL_CLOSE_FLAG) {
                ProcessHandleRecord->TerminateCount++;
            } else {
                ProcessHandleRecord->TerminateCount = 0;
            }
            ProcessHandleList[i].TerminateCount = ProcessHandleRecord->TerminateCount;

            if (ProcessHandleRecord->CtrlRoutine) {
                ProcessHandleList[i].CtrlRoutine = ProcessHandleRecord->CtrlRoutine;
            } else {
                ProcessHandleList[i].CtrlRoutine = CtrlRoutine;
            }

            //
            // If this is the VDM process and we're closing the
            // console window, move it to the front of the list
            //

            if (i > 0 && Console->VDMProcessId && Console->VDMProcessId ==
                    ProcessHandleRecord->Process->ClientId.UniqueProcess &&
                    ProcessHandleRecord->TerminateCount > 0) {
                CONSOLE_PROCESS_TERMINATION_RECORD ProcessHandle;
                ProcessHandle = ProcessHandleList[0];
                ProcessHandleList[0] = ProcessHandleList[i];
                ProcessHandleList[i] = ProcessHandle;
            }

            i++;
        }
    }
    ProcessHandleListLength = i;
    UserAssert(ProcessHandleListLength > 0);

    //
    // Copy title. titlelength does not include terminating null.
    //
    Title = ConsoleHeapAlloc(TITLE_TAG, Console->TitleLength + sizeof(WCHAR));
    if (Title) {
        FreeTitle = TRUE;
        RtlCopyMemory(Title,Console->Title,Console->TitleLength+sizeof(WCHAR));
    } else {
        FreeTitle = FALSE;
        Title = L"Command Window";
    }

    //
    // Copy ctrl flags.
    //

    CtrlFlags = Console->CtrlFlags;
    UserAssert( !((CtrlFlags & (CONSOLE_CTRL_CLOSE_FLAG | CONSOLE_CTRL_BREAK_FLAG | CONSOLE_CTRL_C_FLAG)) &&
              (CtrlFlags & (CONSOLE_CTRL_LOGOFF_FLAG | CONSOLE_CTRL_SHUTDOWN_FLAG)) ));

    Console->CtrlFlags = 0;

    RtlLeaveCriticalSection(&Console->ConsoleLock);

    //
    // the ctrl flags could be a combination of the following
    // values:
    //
    //        CONSOLE_CTRL_C_FLAG
    //        CONSOLE_CTRL_BREAK_FLAG
    //        CONSOLE_CTRL_CLOSE_FLAG
    //        CONSOLE_CTRL_LOGOFF_FLAG
    //        CONSOLE_CTRL_SHUTDOWN_FLAG
    //

    Success = CONSOLE_SHUTDOWN_FAILED;

    EventType = (DWORD)-1;
    switch (CtrlFlags & (CONSOLE_CTRL_CLOSE_FLAG | CONSOLE_CTRL_BREAK_FLAG |
            CONSOLE_CTRL_C_FLAG | CONSOLE_CTRL_LOGOFF_FLAG |
            CONSOLE_CTRL_SHUTDOWN_FLAG)) {

    case CONSOLE_CTRL_CLOSE_FLAG:
        EventType = CTRL_CLOSE_EVENT;
        break;

    case CONSOLE_CTRL_BREAK_FLAG:
        EventType = CTRL_BREAK_EVENT;
        break;

    case CONSOLE_CTRL_C_FLAG:
        EventType = CTRL_C_EVENT;
        break;

    case CONSOLE_CTRL_LOGOFF_FLAG:
        EventType = CTRL_LOGOFF_EVENT;
        break;

    case CONSOLE_CTRL_SHUTDOWN_FLAG:
        EventType = CTRL_SHUTDOWN_EVENT;
        break;
    }

    if (EventType != (DWORD)-1) {

        Success = CreateCtrlThread(ProcessHandleList,
                ProcessHandleListLength,
                Title,
                EventType,
                (CtrlFlags & CONSOLE_FORCE_SHUTDOWN_FLAG) != 0
                );
    }

    if (FreeTitle) {
        ConsoleHeapFree(Title);
    }

    for (i=0;i<ProcessHandleListLength;i++) {
        Status = NtClose(ProcessHandleList[i].ProcessHandle);
        UserAssert(NT_SUCCESS(Status));
    }

    if (ProcessHandleList != ProcessHandles) {
        ConsoleHeapFree(ProcessHandleList);
    }

    return Success;
}

VOID
UnlockConsole(
    IN PCONSOLE_INFORMATION Console
    )
{
    LIST_ENTRY WaitQueue;

    //
    // Make sure the console pointer is still valid.
    //
    UserAssert(NT_SUCCESS(ValidateConsole(Console)));

#ifdef i386
    //
    // ALL the console locks locked by the UnlockConsoleOwningThread were
    // released while it processing VDM screen switch.  If it failed to get
    // the locks back, the UnlockConsole has nothing to do.
    //

    if (Console->UnlockConsoleSkipCount != 0) {
        if (Console->UnlockConsoleOwningThread == NtCurrentTeb()->ClientId.UniqueThread) {
            Console->UnlockConsoleSkipCount--;
            return;
        }
    }

    //
    // do nothing if we are in screen switching(handshaking with ntvdm)
    // we don't check anything else because we are in a safe state here.
    //
    if (ConsoleVDMOnSwitching == Console &&
        ConsoleVDMOnSwitching->VDMProcessId == CONSOLE_CLIENTPROCESSID()) {
        RIPMSG1(RIP_WARNING,
                "    UnlockConsole - Thread %lx is leaving VDM CritSec",
                GetCurrentThreadId());
        RtlLeaveCriticalSection(&ConsoleVDMCriticalSection);
        return;
    }
#endif

    //
    // if we're about to release the console lock, see if there
    // are any satisfied wait blocks that need to be dereferenced.
    // this code avoids a deadlock between grabbing the console
    // lock and then grabbing the process structure lock.
    //
#if defined(_X86_) || defined(_AMD64_)
    if (Console->ConsoleLock.RecursionCount == 1) {
#endif
#if defined(_IA64_)
    if (Console->ConsoleLock.RecursionCount == 0) {
#endif
        InitializeListHead(&WaitQueue);
        if (Console->WaitQueue) {
            CsrMoveSatisfiedWait(&WaitQueue, Console->WaitQueue);
            Console->WaitQueue = NULL;
        }
        ProcessCtrlEvents(Console);

        /*
         * Can't call CsrDereferenceWait with the console locked or we could deadlock.
         */
        if (!IsListEmpty(&WaitQueue)) {
            CsrDereferenceWait(&WaitQueue);
        }
    } else {
        RtlLeaveCriticalSection(&Console->ConsoleLock);
    }
}

ULONG
ShutdownConsole(
    IN HANDLE ConsoleHandle,
    IN DWORD dwFlags
    )
/*
    returns TRUE if console shutdown.  we recurse here so we don't
    return from the WM_QUERYENDSESSION until the console is gone.

*/

{
    DWORD EventFlag;
    int WaitForShutdown;
    PCONSOLE_INFORMATION Console;

    EventFlag = 0;

    //
    // Transmit the force bit (meaning don't bring up the retry dialog
    // if the app times out.
    //

    if (dwFlags & EWX_FORCE)
        EventFlag |= CONSOLE_FORCE_SHUTDOWN_FLAG;

    //
    // Remember if this is shutdown or logoff - inquiring apps want to know.
    //

    if (dwFlags & EWX_SHUTDOWN) {
        EventFlag |= CONSOLE_CTRL_SHUTDOWN_FLAG;
    } else {
        EventFlag |= CONSOLE_CTRL_LOGOFF_FLAG;
    }

    //
    // see if console already going away
    //

    if (!NT_SUCCESS(RevalidateConsole(ConsoleHandle, &Console))) {
        RIPMSG0(RIP_WARNING, "Shutting down terminating console");
        return SHUTDOWN_KNOWN_PROCESS;
    }

    Console->Flags |= CONSOLE_SHUTTING_DOWN;
    Console->CtrlFlags = EventFlag;
    Console->LimitingProcessId = 0;

    WaitForShutdown = ProcessCtrlEvents(Console);
    if (WaitForShutdown == CONSOLE_SHUTDOWN_SUCCEEDED) {
        return (ULONG)STATUS_PROCESS_IS_TERMINATING;
    } else {
        if (!NT_SUCCESS(RevalidateConsole(ConsoleHandle, &Console))) {
            return SHUTDOWN_KNOWN_PROCESS;
        }
        Console->Flags &= ~CONSOLE_SHUTTING_DOWN;
        UnlockConsole(Console);
        if (WaitForShutdown == CONSOLE_SHUTDOWN_SYSTEM) {
            return SHUTDOWN_KNOWN_PROCESS;
        } else {
            return SHUTDOWN_CANCEL;
        }
    }
}

/*
 * Exit routine for threads created with RtlCreateUserThread. These threads
 * cannot call ExitThread(). So don't do that.
 *
 */
VOID UserExitWorkerThread(
    NTSTATUS Status)
{
    NtCurrentTeb()->FreeStackOnTermination = TRUE;
    NtTerminateThread(NtCurrentThread(), Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\share.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    share.c

Abstract:

    Implements sharing for input and output handles

Author:

    Therese Stowell (thereses) 11-Nov-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

NTSTATUS
ConsoleAddShare(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PCONSOLE_SHARE_ACCESS ShareAccess,
    IN OUT PHANDLE_DATA HandleData
    )

{
    ULONG Ocount;
    ULONG ReadAccess;
    ULONG WriteAccess;
    ULONG SharedRead;
    ULONG SharedWrite;

    //
    // Set the access type in the file object for the current accessor.
    //

    ReadAccess = (DesiredAccess & GENERIC_READ) != 0;
    WriteAccess = (DesiredAccess & GENERIC_WRITE) != 0;

    SharedRead = (DesiredShareAccess & FILE_SHARE_READ) != 0;
    SharedWrite = (DesiredShareAccess & FILE_SHARE_WRITE) != 0;

    //
    // Now check to see whether or not the desired accesses are compatible
    // with the way that the file is currently open.
    //

    Ocount = ShareAccess->OpenCount;

    if ( (ReadAccess && (ShareAccess->SharedRead < Ocount))
         ||
         (WriteAccess && (ShareAccess->SharedWrite < Ocount))
         ||
         ((ShareAccess->Readers != 0) && !SharedRead)
         ||
         ((ShareAccess->Writers != 0) && !SharedWrite)
       ) {

        //
        // The check failed.  Simply return to the caller indicating that the
        // current open cannot access the file.
        //

        return STATUS_SHARING_VIOLATION;

    } else {

        //
        // The check was successful.  Update the counter information in the
        // shared access structure for this open request if the caller
        // specified that it should be updated.
        //

        ShareAccess->OpenCount++;

        ShareAccess->Readers += ReadAccess;
        ShareAccess->Writers += WriteAccess;

        ShareAccess->SharedRead += SharedRead;
        ShareAccess->SharedWrite += SharedWrite;
        HandleData->Access = DesiredAccess;
        HandleData->ShareAccess = DesiredShareAccess;

        return STATUS_SUCCESS;
    }
}

NTSTATUS
ConsoleDupShare(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PCONSOLE_SHARE_ACCESS ShareAccess,
    IN OUT PHANDLE_DATA TargetHandleData
    )

{
    ULONG ReadAccess;
    ULONG WriteAccess;
    ULONG SharedRead;
    ULONG SharedWrite;

    //
    // Set the access type in the file object for the current accessor.
    //

    ReadAccess = (DesiredAccess & GENERIC_READ) != 0;
    WriteAccess = (DesiredAccess & GENERIC_WRITE) != 0;

    SharedRead = (DesiredShareAccess & FILE_SHARE_READ) != 0;
    SharedWrite = (DesiredShareAccess & FILE_SHARE_WRITE) != 0;

    if (ShareAccess->OpenCount == 0) {
        ASSERT (FALSE);
        return STATUS_SHARING_VIOLATION;
    }

    ShareAccess->OpenCount++;

    ShareAccess->Readers += ReadAccess;
    ShareAccess->Writers += WriteAccess;

    ShareAccess->SharedRead += SharedRead;
    ShareAccess->SharedWrite += SharedWrite;

    TargetHandleData->Access = DesiredAccess;
    TargetHandleData->ShareAccess = DesiredShareAccess;

    return STATUS_SUCCESS;
}

NTSTATUS
ConsoleRemoveShare(
    IN ULONG DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PCONSOLE_SHARE_ACCESS ShareAccess
    )

{
    ULONG ReadAccess;
    ULONG WriteAccess;
    ULONG SharedRead;
    ULONG SharedWrite;

    //
    // Set the access type in the file object for the current accessor.
    //

    ReadAccess = (DesiredAccess & GENERIC_READ) != 0;
    WriteAccess = (DesiredAccess & GENERIC_WRITE) != 0;

    SharedRead = (DesiredShareAccess & FILE_SHARE_READ) != 0;
    SharedWrite = (DesiredShareAccess & FILE_SHARE_WRITE) != 0;

    if (ShareAccess->OpenCount == 0) {
        ASSERT (FALSE);
        return STATUS_UNSUCCESSFUL;
    }

    ShareAccess->OpenCount--;

    ShareAccess->Readers -= ReadAccess;
    ShareAccess->Writers -= WriteAccess;

    ShareAccess->SharedRead -= SharedRead;
    ShareAccess->SharedWrite -= SharedWrite;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\sources.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Therese Stowell (thereses) 11-Nov-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=windows
MINORCOMP=consrvl

TARGETNAME=consrvl
TARGETTYPE=LIBRARY

TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)

C_DEFINES=$(C_DEFINES) -DUNICODE

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=                                        \
        ..\;                                     \
        ..\..\inc;                               \
        $(WINCORE_PATH)\w32inc;                  \
        $(WINCORE_PATH)\w32inc\$(O);             \
        $(NTGDI_PATH)\inc;                       \
        $(NTUSER_PATH)\inc;                      \
        $(NTUSER_PATH)\inc\$(ALT_PROJECT)\$(O);  \
        $(NTUSER_PATH)\server;                   \
        $(NTUSER_PATH)\server\daytona\$(O);      \
        $(SHELL_INC_PATH);                       \
        $(BASE_INC_PATH)

SOURCES=..\bitmap.c    \
        ..\clipbrd.c   \
        ..\cmdline.c   \
        ..\constubs.c  \
        ..\cursor.c    \
        ..\directio.c  \
        ..\find.c      \
        ..\getset.c    \
        ..\handle.c    \
        ..\input.c     \
        ..\link.c      \
        ..\menu.c      \
        ..\misc.c      \
        ..\output.c    \
        ..\private.c   \
        ..\resize.c    \
        ..\share.c     \
        ..\srvinit.c   \
        ..\srvvdm.c    \
        ..\stream.c    \
        ..\dispatch.c  \
        ..\dbcs.c      \
        ..\convarea.c  \
        ..\eudc.c      \
        ..\foncache.c  \
        ..\hard.c

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\resize.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    resize.c

Abstract:

        This file implements window resizing.

Author:

    Therese Stowell (thereses) 6-Oct-1991

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop


VOID
CalculateNewSize(
    IN PBOOLEAN MaximizedX,
    IN PBOOLEAN MaximizedY,
    IN OUT PSHORT DeltaX,
    IN OUT PSHORT DeltaY,
    IN SHORT WindowSizeX,
    IN SHORT WindowSizeY,
    IN COORD ScreenBufferSize,
    IN COORD FontSize
    );

VOID
ProcessResizeWindow(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCONSOLE_INFORMATION Console,
    IN LPWINDOWPOS WindowPos
    )
{
    SHORT DeltaX,DeltaY;
    SHORT PixelDeltaX,PixelDeltaY;
    DWORD Flags=0;
    COORD FontSize;

#ifdef THERESES_DEBUG
DbgPrint("WM_WINDOWPOSCHANGING message ");
DbgPrint("  WindowSize is %d %d\n",CONSOLE_WINDOW_SIZE_X(ScreenInfo),CONSOLE_WINDOW_SIZE_Y(ScreenInfo));
DbgPrint("  WindowRect is %d %d %d %d\n",Console->WindowRect.left,
                                         Console->WindowRect.top,
                                         Console->WindowRect.right,
                                         Console->WindowRect.bottom);
DbgPrint("  window pos is %d %d %d %d\n",WindowPos->x,
                                         WindowPos->y,
                                         WindowPos->cx,
                                         WindowPos->cy);
#endif

    //
    // If the window is not being resized, don't do anything
    //

    if (WindowPos->flags & SWP_NOSIZE) {
        return;
    }

    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        FontSize = SCR_FONTSIZE(ScreenInfo);
    } else {
        FontSize.X = 1;
        FontSize.Y = 1;
    }

    //
    // If the frame changed, update the system metrics
    //

    if (WindowPos->flags & SWP_FRAMECHANGED) {

        InitializeSystemMetrics();
        if (Console->VerticalClientToWindow != VerticalClientToWindow ||
            Console->HorizontalClientToWindow != HorizontalClientToWindow) {

            Console->VerticalClientToWindow = VerticalClientToWindow;
            Console->HorizontalClientToWindow = HorizontalClientToWindow;
            Console->WindowRect.left = WindowPos->x;
            Console->WindowRect.top = WindowPos->y;
            Console->WindowRect.right = WindowPos->x + WindowPos->cx;
            Console->WindowRect.bottom = WindowPos->y + WindowPos->cy;
            return;
        }
    }

    PixelDeltaX = (SHORT)(WindowPos->cx - (Console->WindowRect.right - Console->WindowRect.left));
    PixelDeltaY = (SHORT)(WindowPos->cy - (Console->WindowRect.bottom - Console->WindowRect.top));

    if (WindowPos->cx >= (ScreenInfo->ScreenBufferSize.X * FontSize.X + VerticalClientToWindow) &&
        WindowPos->cy >= (ScreenInfo->ScreenBufferSize.Y * FontSize.Y + HorizontalClientToWindow)) {

        //
        // handle maximized case
        //

        ScreenInfo->WindowMaximizedX = TRUE;
        ScreenInfo->WindowMaximizedY = TRUE;
        DeltaX = (SHORT)(ScreenInfo->ScreenBufferSize.X - CONSOLE_WINDOW_SIZE_X(ScreenInfo));
        DeltaY = (SHORT)(ScreenInfo->ScreenBufferSize.Y - CONSOLE_WINDOW_SIZE_Y(ScreenInfo));
    } else {

        DeltaX = PixelDeltaX / FontSize.X;
        DeltaY = PixelDeltaY / FontSize.Y;

        //
        // the only time we will get a WM_WINDOWPOSCHANGING message to grow the
        // window larger than the maximum window size is when another app calls
        // SetWindowPos for our window.  the program manager does that when
        // the user requests Tiling.
        //

        CalculateNewSize(&ScreenInfo->WindowMaximizedX,
                         &ScreenInfo->WindowMaximizedY,
                         &DeltaX,
                         &DeltaY,
                         (SHORT)(CONSOLE_WINDOW_SIZE_X(ScreenInfo)),
                         (SHORT)(CONSOLE_WINDOW_SIZE_Y(ScreenInfo)),
                         ScreenInfo->ScreenBufferSize,
                         FontSize
                        );
#ifdef THERESES_DEBUG
DbgPrint("Delta X Y is now %d %d\n",DeltaX,DeltaY);
DbgPrint("Maximized X Y is now %d %d\n",ScreenInfo->WindowMaximizedX,ScreenInfo->WindowMaximizedY);
#endif
    }

    //
    // don't move window when resizing less than a column or row.
    //

    if (!DeltaX && !DeltaY && (PixelDeltaX || PixelDeltaY)) {
        COORD OriginDifference;

        //
        // handle tiling case.  tiling can move the window without resizing, but using
        // a size message. we detect this by checking for the window origin changed by
        // more than one character.
        //

        OriginDifference.X = (SHORT)(WindowPos->x - Console->WindowRect.left);
        OriginDifference.Y = (SHORT)(WindowPos->y - Console->WindowRect.top);
        if (OriginDifference.X < FontSize.X && OriginDifference.X > -FontSize.X &&
            OriginDifference.Y < FontSize.Y && OriginDifference.Y > -FontSize.Y) {
            WindowPos->x = Console->WindowRect.left;
            WindowPos->y = Console->WindowRect.top;
            WindowPos->cx = Console->WindowRect.right - Console->WindowRect.left;
            WindowPos->cy = Console->WindowRect.bottom - Console->WindowRect.top;
            return;
        }
    }

    Flags |= RESIZE_SCROLL_BARS;
    WindowPos->cx = (DeltaX + CONSOLE_WINDOW_SIZE_X(ScreenInfo)) * FontSize.X + (!ScreenInfo->WindowMaximizedY * VerticalScrollSize) + VerticalClientToWindow;
    WindowPos->cy = (DeltaY + CONSOLE_WINDOW_SIZE_Y(ScreenInfo)) * FontSize.Y + (!ScreenInfo->WindowMaximizedX * HorizontalScrollSize) + HorizontalClientToWindow;

    //
    // reflect the new window size in the
    // console window structure
    //

    {
    SHORT ScrollRange,ScrollPos;

    //
    // PercentFromTop = ScrollPos / ScrollRange;
    // PercentFromBottom = (ScrollRange - ScrollPos) / ScrollRange;
    //
    // if drag top border up
    //     Window.Top -= NumLines * PercentFromBottom;
    //     Window.Bottom +=  NumLines - (NumLines * PercentFromBottom);
    //
    // if drag top border down
    //     Window.Top += NumLines * PercentFromBottom;
    //     Window.Bottom -=  NumLines - (NumLines * PercentFromBottom);
    //
    // if drag bottom border up
    //     Window.Top -= NumLines * PercentFromTop;
    //     Window.Bottom +=  NumLines - (NumLines * PercentFromTop);
    //
    // if drag bottom border down
    //     Window.Top += NumLines * PercentFromTop;
    //     Window.Bottom -=  NumLines - (NumLines * PercentFromTop);
    //

    ScrollRange = (SHORT)(ScreenInfo->ScreenBufferSize.X - CONSOLE_WINDOW_SIZE_X(ScreenInfo));
    ScrollPos = ScreenInfo->Window.Left;

    if (WindowPos->x != Console->WindowRect.left) {
        SHORT NumLinesFromRight;
        if (ScrollRange) {
            NumLinesFromRight = DeltaX * (ScrollRange - ScrollPos) / ScrollRange;
        } else {
            NumLinesFromRight = DeltaX; // have scroll pos at left edge
        }
        ScreenInfo->Window.Left -= DeltaX - NumLinesFromRight;
        ScreenInfo->Window.Right += NumLinesFromRight;
    } else {
        SHORT NumLinesFromLeft;
        if (ScrollRange) {
            NumLinesFromLeft = DeltaX * ScrollPos / ScrollRange;
        } else {
            NumLinesFromLeft = 0;   // have scroll pos at left edge
        }
        ScreenInfo->Window.Left -= NumLinesFromLeft;
        ScreenInfo->Window.Right += DeltaX - NumLinesFromLeft;
    }

    ScrollRange = (SHORT)(ScreenInfo->ScreenBufferSize.Y - CONSOLE_WINDOW_SIZE_Y(ScreenInfo));
    ScrollPos = ScreenInfo->Window.Top;
    if (WindowPos->y != Console->WindowRect.top) {
        SHORT NumLinesFromBottom;
        if (ScrollRange) {
            NumLinesFromBottom = DeltaY * (ScrollRange - ScrollPos) / ScrollRange;
        } else {
            NumLinesFromBottom = DeltaY; // have scroll pos at top edge
        }
        ScreenInfo->Window.Top -= DeltaY - NumLinesFromBottom;
        ScreenInfo->Window.Bottom += NumLinesFromBottom;
    } else {
        SHORT NumLinesFromTop;
        if (ScrollRange) {
            NumLinesFromTop = DeltaY * ScrollPos / ScrollRange;
        } else {
            NumLinesFromTop = 0;   // have scroll pos at top edge
        }
        ScreenInfo->Window.Top -= NumLinesFromTop;
        ScreenInfo->Window.Bottom += DeltaY - NumLinesFromTop;
    }
    }

    if (ScreenInfo->WindowMaximizedX)
        ASSERT (CONSOLE_WINDOW_SIZE_X(ScreenInfo) == ScreenInfo->ScreenBufferSize.X);
    if (ScreenInfo->WindowMaximizedY)
        ASSERT (CONSOLE_WINDOW_SIZE_Y(ScreenInfo) == ScreenInfo->ScreenBufferSize.Y);
#ifdef THERESES_DEBUG
DbgPrint("  WindowSize is now %d %d\n",CONSOLE_WINDOW_SIZE_X(ScreenInfo),CONSOLE_WINDOW_SIZE_Y(ScreenInfo));
DbgPrint("  window pos is now %d %d %d %d\n",WindowPos->x,
                                         WindowPos->y,
                                         WindowPos->cx,
                                         WindowPos->cy);
#endif
    Console->ResizeFlags = Flags | (Console->ResizeFlags & SCREEN_BUFFER_CHANGE);
}



VOID
CalculateNewSize(
    IN PBOOLEAN MaximizedX,
    IN PBOOLEAN MaximizedY,
    IN OUT PSHORT DeltaX,
    IN OUT PSHORT DeltaY,
    IN SHORT WindowSizeX,
    IN SHORT WindowSizeY,
    IN COORD ScreenBufferSize,
    IN COORD FontSize
    )
{
    SHORT MaxDeltaX = ScreenBufferSize.X - WindowSizeX;
    SHORT MaxDeltaY = ScreenBufferSize.Y - WindowSizeY;
    SHORT MinDeltaX = 1 - WindowSizeX;
    SHORT MinDeltaY = 1 - WindowSizeY;

    while (TRUE) {

        /*
         * Do we need to remove a horizontal scroll bar?
         */
        if (!*MaximizedX && *DeltaX >= MaxDeltaX) {
            *MaximizedX = TRUE;
            *DeltaY += (VerticalScrollSize+FontSize.Y-1) / FontSize.Y;
        }

        /*
         * Do we need to remove a vertical scroll bar?
         */
        else if (!*MaximizedY && *DeltaY >= MaxDeltaY) {
            *MaximizedY = TRUE;
            *DeltaX += (HorizontalScrollSize+FontSize.X-1) / FontSize.X;
        }

        /*
         * Do we need to add a horizontal scroll bar?
         */
        else if (*MaximizedX && *DeltaX < MaxDeltaX) {
            *MaximizedX = FALSE;
            *DeltaY -= (VerticalScrollSize+FontSize.Y-1) / FontSize.Y;
        }

        /*
         * Do we need to add a vertical scroll bar?
         */
        else if (*MaximizedY && *DeltaY < MaxDeltaY) {
            *MaximizedY = FALSE;
            *DeltaX -= (HorizontalScrollSize+FontSize.X-1) / FontSize.X;
        }

        /*
         * Everything is done, so get out.
         */
        else {
            if (*DeltaX > MaxDeltaX)
                *DeltaX = MaxDeltaX;
            else if (*DeltaX < MinDeltaX)
                *DeltaX = MinDeltaX;
            if (*DeltaY > MaxDeltaY)
                *DeltaY = MaxDeltaY;
            else if (*DeltaY < MinDeltaY)
                *DeltaY = MinDeltaY;
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\srvinit.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    srvinit.c

Abstract:

    This is the main initialization file for the console
    Server.

Author:

    Therese Stowell (thereses) 11-Nov-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


CONST PCSR_API_ROUTINE ConsoleServerApiDispatchTable[ConsolepMaxApiNumber - ConsolepOpenConsole] = {
    SrvOpenConsole,
    SrvGetConsoleInput,
    SrvWriteConsoleInput,
    SrvReadConsoleOutput,
    SrvWriteConsoleOutput,
    SrvReadConsoleOutputString,
    SrvWriteConsoleOutputString,
    SrvFillConsoleOutput,
    SrvGetConsoleMode,
    SrvGetConsoleNumberOfFonts,
    SrvGetConsoleNumberOfInputEvents,
    SrvGetConsoleScreenBufferInfo,
    SrvGetConsoleCursorInfo,
    SrvGetConsoleMouseInfo,
    SrvGetConsoleFontInfo,
    SrvGetConsoleFontSize,
    SrvGetConsoleCurrentFont,
    SrvSetConsoleMode,
    SrvSetConsoleActiveScreenBuffer,
    SrvFlushConsoleInputBuffer,
    SrvGetLargestConsoleWindowSize,
    SrvSetConsoleScreenBufferSize,
    SrvSetConsoleCursorPosition,
    SrvSetConsoleCursorInfo,
    SrvSetConsoleWindowInfo,
    SrvScrollConsoleScreenBuffer,
    SrvSetConsoleTextAttribute,
    SrvSetConsoleFont,
    SrvSetConsoleIcon,
    SrvReadConsole,
    SrvWriteConsole,
    SrvDuplicateHandle,
    SrvGetHandleInformation,
    SrvSetHandleInformation,
    SrvCloseHandle,
    SrvVerifyConsoleIoHandle,
    SrvAllocConsole,
    SrvFreeConsole,
    SrvGetConsoleTitle,
    SrvSetConsoleTitle,
    SrvCreateConsoleScreenBuffer,
    SrvInvalidateBitMapRect,
    SrvVDMConsoleOperation,
    SrvSetConsoleCursor,
    SrvShowConsoleCursor,
    SrvConsoleMenuControl,
    SrvSetConsolePalette,
    SrvSetConsoleDisplayMode,
    SrvRegisterConsoleVDM,
    SrvGetConsoleHardwareState,
    SrvSetConsoleHardwareState,
    SrvGetConsoleDisplayMode,
    SrvAddConsoleAlias,
    SrvGetConsoleAlias,
    SrvGetConsoleAliasesLength,
    SrvGetConsoleAliasExesLength,
    SrvGetConsoleAliases,
    SrvGetConsoleAliasExes,
    SrvExpungeConsoleCommandHistory,
    SrvSetConsoleNumberOfCommands,
    SrvGetConsoleCommandHistoryLength,
    SrvGetConsoleCommandHistory,
    SrvSetConsoleCommandHistoryMode,
    SrvGetConsoleCP,
    SrvSetConsoleCP,
    SrvSetConsoleKeyShortcuts,
    SrvSetConsoleMenuClose,
    SrvConsoleNotifyLastClose,
    SrvGenerateConsoleCtrlEvent,
    SrvGetConsoleKeyboardLayoutName,
    SrvGetConsoleWindow,
#if defined(FE_SB)
    SrvGetConsoleCharType,
    SrvSetConsoleLocalEUDC,
    SrvSetConsoleCursorMode,
    SrvGetConsoleCursorMode,
    SrvRegisterConsoleOS2,
    SrvSetConsoleOS2OemFormat,
#if defined(FE_IME)
    SrvGetConsoleNlsMode,
    SrvSetConsoleNlsMode,
    SrvRegisterConsoleIME,
    SrvUnregisterConsoleIME,
#endif // FE_IME
#endif // FE_SB
    SrvGetConsoleLangId,
    SrvAttachConsole,
    SrvGetConsoleSelectionInfo,
    SrvGetConsoleProcessList,
};

CONST BOOLEAN ConsoleServerApiServerValidTable[ConsolepMaxApiNumber - ConsolepOpenConsole] = {
    FALSE,     // OpenConsole
    FALSE,     // GetConsoleInput,
    FALSE,     // WriteConsoleInput,
    FALSE,     // ReadConsoleOutput,
    FALSE,     // WriteConsoleOutput,
    FALSE,     // ReadConsoleOutputString,
    FALSE,     // WriteConsoleOutputString,
    FALSE,     // FillConsoleOutput,
    FALSE,     // GetConsoleMode,
    FALSE,     // GetNumberOfConsoleFonts,
    FALSE,     // GetNumberOfConsoleInputEvents,
    FALSE,     // GetConsoleScreenBufferInfo,
    FALSE,     // GetConsoleCursorInfo,
    FALSE,     // GetConsoleMouseInfo,
    FALSE,     // GetConsoleFontInfo,
    FALSE,     // GetConsoleFontSize,
    FALSE,     // GetCurrentConsoleFont,
    FALSE,     // SetConsoleMode,
    FALSE,     // SetConsoleActiveScreenBuffer,
    FALSE,     // FlushConsoleInputBuffer,
    FALSE,     // GetLargestConsoleWindowSize,
    FALSE,     // SetConsoleScreenBufferSize,
    FALSE,     // SetConsoleCursorPosition,
    FALSE,     // SetConsoleCursorInfo,
    FALSE,     // SetConsoleWindowInfo,
    FALSE,     // ScrollConsoleScreenBuffer,
    FALSE,     // SetConsoleTextAttribute,
    FALSE,     // SetConsoleFont,
    FALSE,     // SetConsoleIcon
    FALSE,     // ReadConsole,
    FALSE,     // WriteConsole,
    FALSE,     // DuplicateHandle,
    FALSE,     // GetHandleInformation,
    FALSE,     // SetHandleInformation,
    FALSE,     // CloseHandle
    FALSE,     // VerifyConsoleIoHandle
    FALSE,     // AllocConsole,
    FALSE,     // FreeConsole
    FALSE,     // GetConsoleTitle,
    FALSE,     // SetConsoleTitle,
    FALSE,     // CreateConsoleScreenBuffer
    FALSE,     // InvalidateConsoleBitmapRect
    FALSE,     // VDMConsoleOperation
    FALSE,     // SetConsoleCursor,
    FALSE,     // ShowConsoleCursor
    FALSE,     // ConsoleMenuControl
    FALSE,     // SetConsolePalette
    FALSE,     // SetConsoleDisplayMode
    FALSE,     // RegisterConsoleVDM,
    FALSE,     // GetConsoleHardwareState
    FALSE,     // SetConsoleHardwareState
    TRUE,      // GetConsoleDisplayMode
    FALSE,     // AddConsoleAlias,
    FALSE,     // GetConsoleAlias,
    FALSE,     // GetConsoleAliasesLength,
    FALSE,     // GetConsoleAliasExesLength,
    FALSE,     // GetConsoleAliases,
    FALSE,     // GetConsoleAliasExes
    FALSE,     // ExpungeConsoleCommandHistory,
    FALSE,     // SetConsoleNumberOfCommands,
    FALSE,     // GetConsoleCommandHistoryLength,
    FALSE,     // GetConsoleCommandHistory,
    FALSE,     // SetConsoleCommandHistoryMode
    FALSE,     // SrvGetConsoleCP,
    FALSE,     // SrvSetConsoleCP,
    FALSE,     // SrvSetConsoleKeyShortcuts,
    FALSE,     // SrvSetConsoleMenuClose
    FALSE,     // SrvConsoleNotifyLastClose
    FALSE,     // SrvGenerateConsoleCtrlEvent
    FALSE,     // SrvGetConsoleKeyboardLayoutName
    FALSE,     // SrvGetConsoleWindow,
#if defined(FE_SB)
    FALSE,     // GetConsoleCharType
    FALSE,     // SrvSetConsoleLocalEUDC,
    FALSE,     // SrvSetConsoleCursorMode,
    FALSE,     // SrvGetConsoleCursorMode
    FALSE,     // SrvRegisterConsoleOS2,
    FALSE,     // SrvSetConsoleOS2OemFormat,
#if defined(FE_IME)
    FALSE,     // GetConsoleNlsMode
    FALSE,     // SetConsoleNlsMode
    FALSE,     // RegisterConsoleIME
    FALSE,     // UnregisterConsoleIME
#endif // FE_IME
#endif // FE_SB
    FALSE,     // GetConsoleLangId
    FALSE,     // AttachConsole
    FALSE,     // GetConsoleSelectionInfo,
    FALSE,     // GetConsoleProcessList
};

#if DBG
CONST PSZ ConsoleServerApiNameTable[ConsolepMaxApiNumber - ConsolepOpenConsole] = {
    "SrvOpenConsole",
    "SrvGetConsoleInput",
    "SrvWriteConsoleInput",
    "SrvReadConsoleOutput",
    "SrvWriteConsoleOutput",
    "SrvReadConsoleOutputString",
    "SrvWriteConsoleOutputString",
    "SrvFillConsoleOutput",
    "SrvGetConsoleMode",
    "SrvGetConsoleNumberOfFonts",
    "SrvGetConsoleNumberOfInputEvents",
    "SrvGetConsoleScreenBufferInfo",
    "SrvGetConsoleCursorInfo",
    "SrvGetConsoleMouseInfo",
    "SrvGetConsoleFontInfo",
    "SrvGetConsoleFontSize",
    "SrvGetConsoleCurrentFont",
    "SrvSetConsoleMode",
    "SrvSetConsoleActiveScreenBuffer",
    "SrvFlushConsoleInputBuffer",
    "SrvGetLargestConsoleWindowSize",
    "SrvSetConsoleScreenBufferSize",
    "SrvSetConsoleCursorPosition",
    "SrvSetConsoleCursorInfo",
    "SrvSetConsoleWindowInfo",
    "SrvScrollConsoleScreenBuffer",
    "SrvSetConsoleTextAttribute",
    "SrvSetConsoleFont",
    "SrvSetConsoleIcon",
    "SrvReadConsole",
    "SrvWriteConsole",
    "SrvDuplicateHandle",
    "SrvGetHandleInformation",
    "SrvSetHandleInformation",
    "SrvCloseHandle",
    "SrvVerifyConsoleIoHandle",
    "SrvAllocConsole",
    "SrvFreeConsole",
    "SrvGetConsoleTitle",
    "SrvSetConsoleTitle",
    "SrvCreateConsoleScreenBuffer",
    "SrvInvalidateBitMapRect",
    "SrvVDMConsoleOperation",
    "SrvSetConsoleCursor",
    "SrvShowConsoleCursor",
    "SrvConsoleMenuControl",
    "SrvSetConsolePalette",
    "SrvSetConsoleDisplayMode",
    "SrvRegisterConsoleVDM",
    "SrvGetConsoleHardwareState",
    "SrvSetConsoleHardwareState",
    "SrvGetConsoleDisplayMode",
    "SrvAddConsoleAlias",
    "SrvGetConsoleAlias",
    "SrvGetConsoleAliasesLength",
    "SrvGetConsoleAliasExesLength",
    "SrvGetConsoleAliases",
    "SrvGetConsoleAliasExes",
    "SrvExpungeConsoleCommandHistory",
    "SrvSetConsoleNumberOfCommands",
    "SrvGetConsoleCommandHistoryLength",
    "SrvGetConsoleCommandHistory",
    "SrvSetConsoleCommandHistoryMode",
    "SrvGetConsoleCP",
    "SrvSetConsoleCP",
    "SrvSetConsoleKeyShortcuts",
    "SrvSetConsoleMenuClose",
    "SrvConsoleNotifyLastClose",
    "SrvGenerateConsoleCtrlEvent",
    "SrvGetConsoleKeyboardLayoutName",
    "SrvGetConsoleWindow",
#if defined(FE_SB)
    "SrvGetConsoleCharType",
    "SrvSetConsoleLocalEUDC",
    "SrvSetConsoleCursorMode",
    "SrvGetConsoleCursorMode",
    "SrvRegisterConsoleOS2",
    "SrvSetConsoleOS2OemFormat",
#if defined(FE_IME)
    "SrvGetConsoleNlsMode",
    "SrvSetConsoleNlsMode",
    "SrvRegisterConsoleIME",
    "SrvUnregisterConsoleIME",
#endif // FE_IME
#endif // FE_SB
    "SrvGetConsoleLangId",
    "SrvAttachConsole",
    "SrvGetConsoleSelectionInfo",
    "SrvGetConsoleProcessList",
};
#endif // DBG

BOOL FullScreenInitialized;
CRITICAL_SECTION    ConsoleVDMCriticalSection;
PCONSOLE_INFORMATION    ConsoleVDMOnSwitching;


CRITICAL_SECTION ConsoleInitWindowsLock;
BOOL fOneTimeInitialized;

UINT OEMCP;
UINT WINDOWSCP;
UINT ConsoleOutputCP;
CONSOLE_REGISTRY_INFO DefaultRegInfo;
#if defined(FE_SB)
BOOLEAN gfIsDBCSACP;
#endif

VOID
UnregisterVDM(
    IN PCONSOLE_INFORMATION Console
    );

ULONG
NonConsoleProcessShutdown(
    PCSR_PROCESS Process,
    DWORD dwFlags
    );

ULONG
ConsoleClientShutdown(
    PCSR_PROCESS Process,
    ULONG Flags,
    BOOLEAN fFirstPass
    );

NTSTATUS
ConsoleClientConnectRoutine(
    IN PCSR_PROCESS Process,
    IN OUT PVOID ConnectionInfo,
    IN OUT PULONG ConnectionInfoLength
    );

VOID
ConsoleClientDisconnectRoutine(
    IN PCSR_PROCESS Process
    );

VOID ConsolePlaySound(
    VOID
    );



HANDLE ghInstance;
HICON ghDefaultIcon;
HICON ghDefaultSmIcon;
HCURSOR ghNormalCursor;

PWIN32HEAP pConHeap;
DWORD  dwConBaseTag;

DWORD gExtendedEditKey;
BOOL  gfTrimLeadingZeros;
BOOL  gfEnableColorSelection;

BOOL gfLoadConIme;

VOID LoadLinkInfo(
    PCONSOLE_INFO ConsoleInfo,
    LPWSTR Title,
    LPDWORD TitleLength,
    LPWSTR CurDir,
    LPWSTR AppName
    )
{
    DWORD dwLinkLen;
    WCHAR LinkName[MAX_PATH + 1];
    LNKPROPNTCONSOLE linkprops;
    LPWSTR pszIconLocation;
    int nIconIndex;

    ConsoleInfo->uCodePage = OEMCP;

    // Do some initialization
    ConsoleInfo->hIcon = ghDefaultIcon;
    ConsoleInfo->hSmIcon = ghDefaultSmIcon;
    pszIconLocation = NULL;
    nIconIndex = 0;

    // Try to impersonate the client-side thread
    if (!CsrImpersonateClient(NULL)) {
        ConsoleInfo->dwStartupFlags &= ~STARTF_TITLEISLINKNAME;
        goto DefaultInit;
    }

    // Did we get started from a link?
    if (ConsoleInfo->dwStartupFlags & STARTF_TITLEISLINKNAME) {
        DWORD Success;
        DWORD oldLen;

        // Get the filename of the link (TitleLength is BYTES, not CHARS)
        dwLinkLen = (DWORD)(min(*TitleLength,(MAX_PATH+1)*sizeof(WCHAR)));
        RtlCopyMemory(LinkName, Title, dwLinkLen);
        LinkName[ MAX_PATH ] = (WCHAR)0;


        // Get the title for the window, which is effectively the link file name
        oldLen = *TitleLength;
        *TitleLength = GetTitleFromLinkName( LinkName, Title );
        if (*TitleLength < oldLen)
            Title[ *TitleLength / sizeof(WCHAR) ] = L'\0';

        // try to get console properties from the link
        Success = GetLinkProperties( LinkName,
                                      &linkprops,
                                      sizeof(linkprops)
                                     );

        if (Success == LINK_NOINFO) {
            ConsoleInfo->dwStartupFlags &= (~STARTF_TITLEISLINKNAME);
            goto NormalInit;
        }

        if (linkprops.pszIconLocation && *linkprops.pszIconLocation) {
            pszIconLocation = linkprops.pszIconLocation;
            nIconIndex = linkprops.uIcon;
            ConsoleInfo->iIconId = 0;
        }

        // Transfer link settings
        ConsoleInfo->dwHotKey = linkprops.uHotKey;
        ConsoleInfo->wShowWindow = (WORD)linkprops.uShowCmd;

        if (Success == LINK_SIMPLEINFO) {
            ConsoleInfo->dwStartupFlags &= (~STARTF_TITLEISLINKNAME);
            goto NormalInit;
        }

        // Transfer console link settings
        ConsoleInfo->wFillAttribute = linkprops.console_props.wFillAttribute;
        ConsoleInfo->wPopupFillAttribute = linkprops.console_props.wPopupFillAttribute;

        RtlCopyMemory( &ConsoleInfo->dwScreenBufferSize,
                       &linkprops.console_props.dwScreenBufferSize,
                       sizeof(NT_CONSOLE_PROPS) - FIELD_OFFSET(NT_CONSOLE_PROPS, dwScreenBufferSize)
                      );

        ConsoleInfo->uCodePage = linkprops.fe_console_props.uCodePage;
        ConsoleInfo->dwStartupFlags &= ~(STARTF_USESIZE | STARTF_USECOUNTCHARS);
    }

NormalInit:

    //
    // Go get the icon
    //

    if (pszIconLocation == NULL) {
        dwLinkLen = RtlDosSearchPath_U(CurDir,
                                       AppName,
                                       NULL,
                                       sizeof(LinkName),
                                       LinkName,
                                       NULL);
        if (dwLinkLen > 0 && dwLinkLen < sizeof(LinkName)) {
            pszIconLocation = LinkName;
        } else {
            pszIconLocation = AppName;
        }
    }

    if (pszIconLocation != NULL) {
        HICON hIcon, hSmIcon;
        hIcon = hSmIcon = NULL;
        PrivateExtractIconExW(pszIconLocation,
                              nIconIndex,
                              &hIcon,
                              &hSmIcon,
                              1);
        /*
         * If there is no large icon, use the default ones.
         * If there is only a large icon in the resource, do not use
         * the default small one but let it be NULL so we'll stretch
         * the large one.
         */
        if (hIcon != NULL) {
            ConsoleInfo->hIcon = hIcon;
            ConsoleInfo->hSmIcon = hSmIcon;
        }
    }

    CsrRevertToSelf();

    if (!IsValidCodePage(ConsoleInfo->uCodePage)) {    // fail safe
        ConsoleInfo->uCodePage = OEMCP;
    }

    if (!(ConsoleInfo->dwStartupFlags & STARTF_TITLEISLINKNAME)) {
        CONSOLE_REGISTRY_INFO RegInfo;

DefaultInit:
        //
        // read values from the registry
        //

        RegInfo = DefaultRegInfo;
        GetRegistryValues(Title, &RegInfo);

        //
        // If a value isn't specified in STARTUPINFO, then use the one
        // from the registry.
        //

        if (!(ConsoleInfo->dwStartupFlags & STARTF_USEFILLATTRIBUTE)) {
            ConsoleInfo->wFillAttribute = RegInfo.ScreenFill.Attributes;
        }
        ConsoleInfo->wPopupFillAttribute = RegInfo.PopupFill.Attributes;

        if (!(ConsoleInfo->dwStartupFlags & STARTF_USECOUNTCHARS)) {
            ConsoleInfo->dwScreenBufferSize = RegInfo.ScreenBufferSize;
        }
        if (!(ConsoleInfo->dwStartupFlags & STARTF_USESIZE)) {
            ConsoleInfo->dwWindowSize = RegInfo.WindowSize;
        }
        if (!(ConsoleInfo->dwStartupFlags & STARTF_USEPOSITION)) {
            ConsoleInfo->dwWindowOrigin = RegInfo.WindowOrigin;
            ConsoleInfo->bAutoPosition = RegInfo.AutoPosition;
        } else {
            ConsoleInfo->bAutoPosition = FALSE;
        }
        if (!(ConsoleInfo->dwStartupFlags & STARTF_RUNFULLSCREEN)) {
            ConsoleInfo->bFullScreen = RegInfo.FullScreen;
        } else {
            ConsoleInfo->bFullScreen = TRUE;
        }

        ConsoleInfo->uFontFamily = RegInfo.FontFamily;
        ConsoleInfo->uFontWeight = RegInfo.FontWeight;
        ConsoleInfo->dwFontSize = RegInfo.FontSize;
        RtlCopyMemory(ConsoleInfo->FaceName, RegInfo.FaceName, sizeof(RegInfo.FaceName));

        ConsoleInfo->bQuickEdit = RegInfo.QuickEdit;
        ConsoleInfo->bInsertMode = RegInfo.InsertMode;

        ConsoleInfo->uCursorSize = RegInfo.CursorSize;
        ConsoleInfo->uHistoryBufferSize = RegInfo.HistoryBufferSize;
        ConsoleInfo->uNumberOfHistoryBuffers = RegInfo.NumberOfHistoryBuffers;
        ConsoleInfo->bHistoryNoDup = RegInfo.HistoryNoDup;
        RtlCopyMemory(ConsoleInfo->ColorTable, RegInfo.ColorTable, sizeof(RegInfo.ColorTable));
#ifdef FE_SB
        ConsoleInfo->uCodePage = RegInfo.CodePage;
#endif
    }
}


BOOL
InitWindowClass( VOID )
{
    WNDCLASSEX wc;
    BOOL retval;
    ATOM atomConsoleClass;

    ghNormalCursor = LoadCursor(NULL, IDC_ARROW);
    ASSERT(ghModuleWin != NULL);
    ghDefaultIcon       = LoadIcon(ghModuleWin, MAKEINTRESOURCE(IDI_CONSOLE));
    ghDefaultSmIcon     = LoadImage(ghModuleWin, MAKEINTRESOURCE(IDI_CONSOLE), IMAGE_ICON,
                                    GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
                                    LR_SHARED);
    wc.hIcon            = ghDefaultIcon;
    wc.cbSize           = sizeof(WNDCLASSEX);
    wc.style            = CS_HREDRAW | CS_VREDRAW | CS_OWNDC | CS_DBLCLKS;
    wc.lpfnWndProc      = ConsoleWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = GWL_CONSOLE_WNDALLOC;
    wc.hInstance        = ghInstance;
    wc.hCursor          = ghNormalCursor;
    wc.hbrBackground    = CreateSolidBrush(DefaultRegInfo.ColorTable[LOBYTE(DefaultRegInfo.ScreenFill.Attributes >> 4) & 0xF]);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = CONSOLE_WINDOW_CLASS;
    wc.hIconSm          = ghDefaultSmIcon;

    atomConsoleClass = RegisterClassEx(&wc);
    retval = (atomConsoleClass != 0);

    if (retval) {
        NtUserConsoleControl(ConsoleClassAtom, &atomConsoleClass, sizeof(ATOM));
    }

    return retval;
}


NTSTATUS
InitWindowsStuff(
    HDESK hdesk,
    LPDWORD lpdwThreadId)
{
    NTSTATUS Status = STATUS_SUCCESS;
    CLIENT_ID ClientId;
    CONSOLEDESKTOPCONSOLETHREAD ConsoleDesktopInfo;
    INPUT_THREAD_INIT_INFO InputThreadInitInfo;

    //
    // This routine must be done within a critical section to ensure that
    // only one thread can initialize at a time. We need a special critical
    // section here because Csr calls into ConsoleAddProcessRoutine with
    // it's own critical section locked and then tries to grab the
    // ConsoleHandleTableLock. If we call CsrAddStaticServerThread here
    // with the ConsoleHandleTableLock locked we could get into a deadlock
    // situation. This critical section should not be used anywhere else.
    //

    RtlEnterCriticalSection(&ConsoleInitWindowsLock);

    ConsoleDesktopInfo.hdesk = hdesk;
    ConsoleDesktopInfo.dwThreadId = (DWORD)-1;
    NtUserConsoleControl(ConsoleDesktopConsoleThread, &ConsoleDesktopInfo,
            sizeof(ConsoleDesktopInfo));
    if (ConsoleDesktopInfo.dwThreadId == 0) {

        if (!fOneTimeInitialized) {

#ifdef FE_SB
            InitializeDbcsMisc();
#endif // FE_SB

            FullScreenInitialized = InitializeFullScreen();

            //
            // read the registry values
            //

            GetRegistryValues(L"", &DefaultRegInfo);

            //
            // allocate buffer for scrolling
            //

            Status = InitializeScrollBuffer();
            if (!NT_SUCCESS(Status)) {
                RIPMSG1(RIP_WARNING, "InitWindowsStuff: InitScrollBuffer failed %x", Status);
                goto ErrorExit;
            }
        }

        //
        // create GetMessage thread
        //

        Status = NtCreateEvent(&InputThreadInitInfo.InitCompleteEventHandle,
                               EVENT_ALL_ACCESS,
                               NULL,
                               NotificationEvent,
                               FALSE);
        if (!NT_SUCCESS(Status)) {
            goto ErrorExit;
        }

        Status = NtDuplicateObject(NtCurrentProcess(), hdesk,
                NtCurrentProcess(), &InputThreadInitInfo.DesktopHandle, 0,
                0, DUPLICATE_SAME_ACCESS);
        if (!NT_SUCCESS(Status)) {
            NtClose(InputThreadInitInfo.InitCompleteEventHandle);
            goto ErrorExit;
        }

        //
        // Create GetMessage thread.
        //
        Status = RtlCreateUserThread(NtCurrentProcess(),
                                     (PSECURITY_DESCRIPTOR) NULL,
                                     TRUE,
                                     0,
                                     0,
                                     0x5000,
                                     ConsoleInputThread,
                                     &InputThreadInitInfo,
                                     &InputThreadInitInfo.ThreadHandle,
                                     &ClientId);
        if (!NT_SUCCESS(Status)) {
            NtClose(InputThreadInitInfo.InitCompleteEventHandle);
            CloseDesktop(InputThreadInitInfo.DesktopHandle);
            goto ErrorExit;
        }

        CsrAddStaticServerThread(InputThreadInitInfo.ThreadHandle, &ClientId, 0);
        NtResumeThread(InputThreadInitInfo.ThreadHandle, NULL);
        NtWaitForSingleObject(InputThreadInitInfo.InitCompleteEventHandle, FALSE, NULL);
        NtClose(InputThreadInitInfo.InitCompleteEventHandle);

        if (!NT_SUCCESS(InputThreadInitInfo.InitStatus)) {
            Status = InputThreadInitInfo.InitStatus;
            goto ErrorExit;
        }

        *lpdwThreadId = HandleToUlong(ClientId.UniqueThread);

        fOneTimeInitialized=TRUE;
    } else {
        *lpdwThreadId = ConsoleDesktopInfo.dwThreadId;
    }

ErrorExit:
    RtlLeaveCriticalSection(&ConsoleInitWindowsLock);

    return Status;
}


NTSTATUS
ConServerDllInitialization(
    PCSR_SERVER_DLL LoadedServerDll)

/*++

Routine Description:

    This routine is called to initialize the server dll.  It initializes
    the console handle table.

Arguments:

    LoadedServerDll - Pointer to console server dll data

Return Value:

--*/

{
    NTSTATUS Status;

    LoadedServerDll->ApiNumberBase = CONSRV_FIRST_API_NUMBER;
    LoadedServerDll->MaxApiNumber = ConsolepMaxApiNumber;
    LoadedServerDll->ApiDispatchTable = (PCSR_API_ROUTINE *)ConsoleServerApiDispatchTable;
    LoadedServerDll->ApiServerValidTable = (PBOOLEAN)ConsoleServerApiServerValidTable;
#if DBG
    LoadedServerDll->ApiNameTable = ConsoleServerApiNameTable;
#endif
    LoadedServerDll->PerProcessDataLength = sizeof(CONSOLE_PER_PROCESS_DATA);
    LoadedServerDll->ConnectRoutine = ConsoleClientConnectRoutine;
    LoadedServerDll->DisconnectRoutine = ConsoleClientDisconnectRoutine;
    LoadedServerDll->AddProcessRoutine = ConsoleAddProcessRoutine;
    LoadedServerDll->ShutdownProcessRoutine = ConsoleClientShutdown;

    ghInstance = LoadedServerDll->ModuleHandle;

    // initialize data structures

    InitWin32HeapStubs();

    pConHeap = Win32HeapCreate(
                              "CH_Head",
                              "CH_Tail",
                              HEAP_GROWABLE | HEAP_CLASS_5 |
#ifdef PRERELEASE
                              HEAP_TAIL_CHECKING_ENABLED,
#else
                              0,
#endif // PRERELEASE
                              NULL,             // HeapBase
                              64 * 1024,        // ReserveSize
                              4096,             // CommitSize
                              NULL,             // Lock to use for serialization
                              NULL);            // GrowthThreshold

    if (pConHeap == NULL) {
        return STATUS_NO_MEMORY;
    }

    dwConBaseTag = Win32HeapCreateTag( pConHeap,
                                     0,
                                     L"CON!",
                                     L"TMP\0"
                                     L"BMP\0"
                                     L"ALIAS\0"
                                     L"HISTORY\0"
                                     L"TITLE\0"
                                     L"HANDLE\0"
                                     L"CONSOLE\0"
                                     L"ICON\0"
                                     L"BUFFER\0"
                                     L"WAIT\0"
                                     L"FONT\0"
                                     L"SCREEN\0"
#if defined(FE_SB)
                                     L"TMP DBCS\0"
                                     L"SCREEN DBCS\0"
                                     L"EUDC\0"
                                     L"CONVAREA\0"
                                     L"IME\0"
#endif
                                   );
    Status = InitializeConsoleHandleTable();
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = RtlInitializeCriticalSectionAndSpinCount(&ConsoleInitWindowsLock,
                                                      0x80000000);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Initialize Input thread local message queue
    //
    Status = RtlInitializeCriticalSectionAndSpinCount(&gInputThreadMsgLock,
                                                      0x80000000);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    InitializeThreadMessages();

#ifdef i386
    Status = RtlInitializeCriticalSectionAndSpinCount(&ConsoleVDMCriticalSection,
                                                      0x80000000);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    ConsoleVDMOnSwitching = NULL;
#endif

    OEMCP = GetOEMCP();
    WINDOWSCP = GetACP();
#if !defined(FE_SB)
    ConsoleOutputCP = OEMCP;
#endif

    InitializeFonts();

    InputThreadTlsIndex = TlsAlloc();
    if (InputThreadTlsIndex == 0xFFFFFFFF) {
        return STATUS_UNSUCCESSFUL;
    }

#if defined(FE_SB)
    gfIsDBCSACP = !!IsAvailableFarEastCodePage(WINDOWSCP);
#endif

    return STATUS_SUCCESS;
}

BOOL
MapHandle(
    IN HANDLE ClientProcessHandle,
    IN HANDLE ServerHandle,
    OUT PHANDLE ClientHandle
    )
{
    //
    // map event handle into dll's handle space.
    //

    return DuplicateHandle(NtCurrentProcess(),
                           ServerHandle,
                           ClientProcessHandle,
                           ClientHandle,
                           0,
                           FALSE,
                           DUPLICATE_SAME_ACCESS
                          );
}

VOID
AddProcessToList(
    IN OUT PCONSOLE_INFORMATION Console,
    IN OUT PCONSOLE_PROCESS_HANDLE ProcessHandleRecord,
    IN HANDLE ProcessHandle
    )
{
    ASSERT(!(Console->Flags & (CONSOLE_TERMINATING | CONSOLE_SHUTTING_DOWN)));

    ProcessHandleRecord->ProcessHandle = ProcessHandle;
    ProcessHandleRecord->TerminateCount = 0;
    InsertHeadList(&Console->ProcessHandleList, &ProcessHandleRecord->ListLink);

    SetProcessFocus(ProcessHandleRecord->Process, Console->Flags & CONSOLE_HAS_FOCUS);
}

PCONSOLE_PROCESS_HANDLE
FindProcessInList(
    IN PCONSOLE_INFORMATION Console,
    IN HANDLE ProcessHandle
    )
{
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    PLIST_ENTRY ListHead, ListNext;

    ListHead = &Console->ProcessHandleList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        ProcessHandleRecord = CONTAINING_RECORD( ListNext, CONSOLE_PROCESS_HANDLE, ListLink );
        if (ProcessHandleRecord->ProcessHandle == ProcessHandle) {
            return ProcessHandleRecord;
        }
        ListNext = ListNext->Flink;
    }
    return NULL;
}

VOID
RemoveProcessFromList(
    IN OUT PCONSOLE_INFORMATION Console,
    IN HANDLE ProcessHandle
    )
{
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    PLIST_ENTRY ListHead, ListNext;

    ListHead = &Console->ProcessHandleList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        ProcessHandleRecord = CONTAINING_RECORD( ListNext, CONSOLE_PROCESS_HANDLE, ListLink );
        ListNext = ListNext->Flink;
        if (ProcessHandleRecord->ProcessHandle == ProcessHandle) {
            RemoveEntryList(&ProcessHandleRecord->ListLink);
            ConsoleHeapFree(ProcessHandleRecord);
            return;
        }
    }

    RIPMSG1(RIP_ERROR, "RemoveProcessFromList: Process %#p not found", ProcessHandle);
}

NTSTATUS
SetUpConsole(
    IN OUT PCONSOLE_INFO ConsoleInfo,
    IN DWORD TitleLength,
    IN LPWSTR Title,
    IN LPWSTR CurDir,
    IN LPWSTR AppName,
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN BOOLEAN WindowVisible,
    IN PUNICODE_STRING pstrDesktopName)
{
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    DWORD ConsoleThreadId;
    HWINSTA hwinsta;
    HDESK hdesk;
    USEROBJECTFLAGS UserObjectFlags;
    DWORD Length;

    //
    // Connect to the windowstation and desktop.
    //

    if (!CsrImpersonateClient(NULL)) {
        return STATUS_BAD_IMPERSONATION_LEVEL;
    }

    hdesk = NtUserResolveDesktop(CONSOLE_CLIENTPROCESSHANDLE(),
                                 pstrDesktopName,
                                 FALSE,
                                 &hwinsta);

    CsrRevertToSelf();

    if (hdesk == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Need to initialize windows stuff once real console app starts.
    // This is because for the time being windows expects the first
    // app to be a windows app.
    //

    Status = InitWindowsStuff(hdesk, &ConsoleThreadId);
    if (!NT_SUCCESS(Status)) {
        CloseDesktop(hdesk);
        CloseWindowStation(hwinsta);
        return Status;
    }

    //
    // If the windowstation isn't visible, then neither is the window.
    //

    if (WindowVisible) {
        if (GetUserObjectInformation(hwinsta,
                                     UOI_FLAGS,
                                     &UserObjectFlags,
                                     sizeof(UserObjectFlags),
                                     &Length)) {
            if (!(UserObjectFlags.dwFlags & WSF_VISIBLE)) {
                WindowVisible = FALSE;
            }
        }
    }

    //
    // We need to see if we were spawned from a link.  If we were, we
    // need to call back into the shell to try to get all the console
    // information from the link.
    //

    LoadLinkInfo( ConsoleInfo, Title, &TitleLength, CurDir, AppName );

    LockConsoleHandleTable();

    Status = AllocateConsoleHandle(&ConsoleInfo->ConsoleHandle);
    if (!NT_SUCCESS(Status)) {
        UnlockConsoleHandleTable();
        CloseDesktop(hdesk);
        CloseWindowStation(hwinsta);
        return Status;
    }

    Status = AllocateConsole(ConsoleInfo->ConsoleHandle,
                             Title,
                             (USHORT)TitleLength,
                             CONSOLE_CLIENTPROCESSHANDLE(),
                             &ConsoleInfo->StdIn,
                             &ConsoleInfo->StdOut,
                             &ConsoleInfo->StdErr,
                             ProcessData,
                             ConsoleInfo,
                             WindowVisible,
                             ConsoleThreadId
                             );
    if (!NT_SUCCESS(Status)) {
        FreeConsoleHandle(ConsoleInfo->ConsoleHandle);
        UnlockConsoleHandleTable();
        CloseDesktop(hdesk);
        CloseWindowStation(hwinsta);
        return Status;
    }
    CONSOLE_SETCONSOLEHANDLE(ConsoleInfo->ConsoleHandle);
    Status = DereferenceConsoleHandle(ConsoleInfo->ConsoleHandle,&Console);
    ASSERT (NT_SUCCESS(Status));

    //
    // increment console reference count
    //

    RefConsole(Console);

    //
    // Save the windowstation and desktop handles so they
    // can be used later
    //

    Console->hWinSta = hwinsta;
    Console->hDesk = hdesk;

    UnlockConsoleHandleTable();

#if defined(FE_IME)
    if (CONSOLE_IS_IME_ENABLED())
    {
        if (WindowVisible)
        {
            InitConsoleIMEStuff(Console->hDesk, ConsoleThreadId, Console);
        }
    }
#endif

    return Status;
}

NTSTATUS
ConsoleClientConnectRoutine(
    IN PCSR_PROCESS Process,
    IN OUT PVOID ConnectionInfo,
    IN OUT PULONG ConnectionInfoLength)

/*++

Routine Description:

    This routine is called when a new process is created.  For processes
    without parents, it creates the console.  For processes with
    parents, it duplicates the handle table.

Arguments:

    Process - Pointer to process structure.

    ConnectionInfo - Pointer to connection info.

    ConnectionInfoLength - Connection info length.

Return Value:

--*/

{
    NTSTATUS Status;
    PCONSOLE_API_CONNECTINFO p = (PCONSOLE_API_CONNECTINFO)ConnectionInfo;
    PCONSOLE_INFORMATION Console;
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    CONSOLEWINDOWSTATIONPROCESS ConsoleWindowStationInfo;
    UNICODE_STRING strDesktopName;
    CONSOLE_PROCESS_INFO cpi;

    if (p == NULL ||
        *ConnectionInfoLength != sizeof( *p ) ||
        p->AppNameLength > sizeof(p->AppName) ||
        p->CurDirLength > sizeof(p->CurDir) ||
        p->TitleLength > sizeof(p->Title)) {

        RIPMSG0(RIP_ERROR, "CONSRV: bad connection info");
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Make sure the strings are NULL terminated.
    //

    p->AppName[NELEM(p->AppName) - 1] = 0;
    p->CurDir[NELEM(p->CurDir) - 1] = 0;
    p->Title[NELEM(p->Title) - 1] = 0;

    if (CtrlRoutine == NULL) {
        CtrlRoutine = p->CtrlRoutine;
    }
#if defined(FE_IME)
    if (ConsoleIMERoutine == NULL) {
        ConsoleIMERoutine = p->ConsoleIMERoutine;
    }
#endif
    ProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(Process);
    Console = NULL;

    //
    // If this process is not a console app, stop right here - no
    // initialization is needed. Just need to remember that this
    // is not a console app so that we do no work during
    // ConsoleClientDisconnectRoutine().
    //

    Status = STATUS_SUCCESS;
    if ((CONSOLE_GETCONSOLEAPPFROMPROCESSDATA(ProcessData) = p->ConsoleApp)) {

        //
        // First call off to USER so it unblocks any app waiting on a call
        // to WaitForInputIdle. This way apps calling WinExec() to exec console
        // apps will return right away.
        //


        cpi.dwProcessID = HandleToUlong(CONSOLE_CLIENTPROCESSID());
        cpi.dwFlags = (p->ConsoleInfo.ConsoleHandle != NULL) ? 0 : CPI_NEWPROCESSWINDOW;
        NtUserConsoleControl(ConsoleNotifyConsoleApplication,
                             &cpi,
                             sizeof(CONSOLE_PROCESS_INFO));

        //
        // create console
        //

        if (p->ConsoleInfo.ConsoleHandle == NULL) {
            ProcessHandleRecord = ConsoleHeapAlloc(HANDLE_TAG, sizeof(CONSOLE_PROCESS_HANDLE));
            if (ProcessHandleRecord == NULL) {
                Status = STATUS_NO_MEMORY;
                goto ErrorExit;
            }

            //
            // We are creating a new console, so derereference
            // the parent's console, if any.
            //

            if (ProcessData->ConsoleHandle != NULL) {
                RemoveConsole(ProcessData, Process->ProcessHandle, 0);
            }

            //
            // Get the desktop name.
            //

            if (p->DesktopLength) {
                strDesktopName.Buffer = ConsoleHeapAlloc(TMP_TAG,
                                                         p->DesktopLength);
                if (strDesktopName.Buffer == NULL) {
                    Status = STATUS_NO_MEMORY;
                    goto ErrorExit;
                }
                Status = NtReadVirtualMemory(Process->ProcessHandle,
                                    (PVOID)p->Desktop,
                                    strDesktopName.Buffer,
                                    p->DesktopLength,
                                    NULL
                                   );
                if (!NT_SUCCESS(Status)) {
                    ConsoleHeapFree(strDesktopName.Buffer);
                    goto ErrorExit;
                }
                strDesktopName.MaximumLength = (USHORT)p->DesktopLength;
                strDesktopName.Length = (USHORT)(p->DesktopLength - sizeof(WCHAR));
            } else {
                RtlInitUnicodeString(&strDesktopName, L"Default");
            }

            ProcessData->RootProcess = TRUE;
            Status = SetUpConsole(&p->ConsoleInfo,
                                  p->TitleLength,
                                  p->Title,
                                  p->CurDir,
                                  p->AppName,
                                  ProcessData,
                                  p->WindowVisible,
                                  &strDesktopName);
            if (p->DesktopLength) {
                ConsoleHeapFree(strDesktopName.Buffer);
            }

            if (!NT_SUCCESS(Status)) {
                goto ErrorExit;
            }

            // Play the Open sound for console apps

            ConsolePlaySound();

            Status = RevalidateConsole(p->ConsoleInfo.ConsoleHandle, &Console);
            ASSERT (NT_SUCCESS(Status));
        } else {
            ProcessHandleRecord = NULL;
            ProcessData->RootProcess = FALSE;

            Status = STATUS_SUCCESS;
            if (!(NT_SUCCESS(RevalidateConsole(p->ConsoleInfo.ConsoleHandle, &Console))) ) {
                Status = STATUS_PROCESS_IS_TERMINATING;
                goto ErrorExit;
            }

            if (Console->Flags & CONSOLE_SHUTTING_DOWN) {
                Status = STATUS_PROCESS_IS_TERMINATING;
                goto ErrorExit;
            }

            Status = MapEventHandles(CONSOLE_CLIENTPROCESSHANDLE(),
                                     Console,
                                     &p->ConsoleInfo
                                    );
            if (!NT_SUCCESS(Status)) {
                goto ErrorExit;
            }

            ProcessHandleRecord = FindProcessInList(Console, CONSOLE_CLIENTPROCESSHANDLE());
            if (ProcessHandleRecord) {
                ProcessHandleRecord->CtrlRoutine = p->CtrlRoutine;
                ProcessHandleRecord->PropRoutine = p->PropRoutine;
                ProcessHandleRecord = NULL;
            }
        }

        if (NT_SUCCESS(Status)) {

            //
            // Associate the correct window station with client process
            // so they can do Global atom calls.
            //
            if (DuplicateHandle( NtCurrentProcess(),
                                 Console->hWinSta,
                                 Process->ProcessHandle,
                                 &ConsoleWindowStationInfo.hwinsta,
                                 0,
                                 FALSE,
                                 DUPLICATE_SAME_ACCESS
                               )
               ) {
                ConsoleWindowStationInfo.dwProcessId = HandleToUlong(CONSOLE_CLIENTPROCESSID());
                NtUserConsoleControl(ConsoleWindowStationProcess,
                                     &ConsoleWindowStationInfo,
                                     sizeof(ConsoleWindowStationInfo));

                }

            if (ProcessHandleRecord) {
                ProcessHandleRecord->Process = Process;
                ProcessHandleRecord->CtrlRoutine = p->CtrlRoutine;
                ProcessHandleRecord->PropRoutine = p->PropRoutine;
                AddProcessToList(Console, ProcessHandleRecord, CONSOLE_CLIENTPROCESSHANDLE());
            }
            SetProcessForegroundRights(Process,
                                       Console->Flags & CONSOLE_HAS_FOCUS);
            AllocateCommandHistory(Console,
                                   p->AppNameLength,
                                   p->AppName,
                                   CONSOLE_CLIENTPROCESSHANDLE());
        } else {
ErrorExit:
            CONSOLE_SETCONSOLEAPPFROMPROCESSDATA(ProcessData, FALSE);
            if (ProcessHandleRecord)
                ConsoleHeapFree(ProcessHandleRecord);
            if (ProcessData->ConsoleHandle != NULL) {
                RemoveConsole(ProcessData, Process->ProcessHandle, 0);
            }
        }

        if (Console) {
            ConsoleNotifyWinEvent(Console,
                                  EVENT_CONSOLE_START_APPLICATION,
                                  HandleToULong(Process->ClientId.UniqueProcess),
                                  0);
            UnlockConsole(Console);
        }
    } else if (ProcessData->ConsoleHandle != NULL) {

        //
        // This is a non-console app with a reference to a
        // reference to a parent console.  Dereference the
        // console.
        //

        RemoveConsole(ProcessData, Process->ProcessHandle, 0);
    }

    return Status;
}


#if defined(FE_IME)
VOID FreeConsoleIMEStuff(
    PCONSOLE_INFORMATION Console)
{
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;
    PCONVERSIONAREA_INFORMATION ConvAreaInfoNext;

    ConvAreaInfo = Console->ConsoleIme.ConvAreaRoot;
    while(ConvAreaInfo) {
        ConvAreaInfoNext = ConvAreaInfo->ConvAreaNext;
        FreeConvAreaScreenBuffer(ConvAreaInfo->ScreenBuffer);
        ConsoleHeapFree(ConvAreaInfo);
        ConvAreaInfo = ConvAreaInfoNext;
    }

    if (Console->ConsoleIme.NumberOfConvAreaCompStr) {
        ConsoleHeapFree(Console->ConsoleIme.ConvAreaCompStr);
    }
    if (Console->ConsoleIme.CompStrData) {
        ConsoleHeapFree(Console->ConsoleIme.CompStrData);
    }
}
#else
#define FreeConsoleIMEStuff(Console)
#endif

NTSTATUS
RemoveConsole(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN HANDLE ProcessHandle,
    IN HANDLE ProcessId)
{
    ULONG i;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = RevalidateConsole(ProcessData->ConsoleHandle, &Console);

    //
    // If this process isn't using the console, error.
    //

    if (!NT_SUCCESS(Status)) {
        ASSERT(FALSE);
        return Status;
    }

    if (Console->Flags & CONSOLE_NOTIFY_LAST_CLOSE) {
        if (Console->ProcessIdLastNotifyClose == ProcessId) {
            //
            // If this process is the one who wants last close notification,
            // remove it.
            //
            Console->Flags &= ~CONSOLE_NOTIFY_LAST_CLOSE;
            NtClose(Console->hProcessLastNotifyClose);
        } else if (ProcessData->RootProcess) {
            //
            // Notify the ntvdm process to terminate if the console root
            // process is going away.
            //
            HANDLE ConsoleHandle;
            CONSOLE_PROCESS_TERMINATION_RECORD ProcessHandleList;

            Console->Flags &= ~CONSOLE_NOTIFY_LAST_CLOSE;
            ConsoleHandle = Console->ConsoleHandle;
            ProcessHandleList.ProcessHandle = Console->hProcessLastNotifyClose;
            ProcessHandleList.TerminateCount = 0;
            ProcessHandleList.CtrlRoutine = CtrlRoutine;
            UnlockConsole(Console);
            CreateCtrlThread(&ProcessHandleList,
                             1,
                             NULL,
                             SYSTEM_ROOT_CONSOLE_EVENT,
                             TRUE);
            NtClose(ProcessHandleList.ProcessHandle);
            Status = RevalidateConsole(ConsoleHandle, &Console);
            UserAssert(NT_SUCCESS(Status));
            if (!NT_SUCCESS(Status)) {
                return STATUS_SUCCESS;
            }
        }
    }

    if (Console->VDMProcessId == ProcessId &&
        (Console->Flags & CONSOLE_VDM_REGISTERED)) {
        Console->Flags &= ~CONSOLE_FULLSCREEN_NOPAINT;
        UnregisterVDM(Console);
    }

    if (ProcessHandle != NULL) {
        RemoveProcessFromList(Console, ProcessHandle);
        FreeCommandHistory(Console, ProcessHandle);
    }

    UserAssert(Console->RefCount);

    //
    // close the process's handles.
    //

    for (i = 0; i < ProcessData->HandleTableSize; i++) {
        if (ProcessData->HandleTablePtr[i].HandleType != CONSOLE_FREE_HANDLE) {
            Status = DereferenceIoHandleNoCheck(ProcessData,
                                                LongToHandle(i),
                                                &HandleData);
            UserAssert(NT_SUCCESS(Status));
            if (HandleData->HandleType & CONSOLE_INPUT_HANDLE) {
                Status = CloseInputHandle(ProcessData, Console, HandleData, LongToHandle(i));
            } else {
                Status = CloseOutputHandle(ProcessData, Console, HandleData, LongToHandle(i), FALSE);
            }
        }
    }
    FreeProcessData(ProcessData);
    ProcessData->ConsoleHandle = NULL;

    //
    // Decrement the console reference count. Free the console if it goes to
    // zero.
    //

    DerefConsole(Console);
    if (Console->RefCount == 0) {
        FreeConsoleIMEStuff(Console);
        FreeCon(Console);
    } else {
        //
        // The root process is going away, so we need to reparent it.
        //
        if (ProcessData->RootProcess) {
            PLIST_ENTRY ListHead = Console->ProcessHandleList.Flink;
            PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
            PCSR_THREAD Thread;
            HANDLE hThread;

            RIPMSG1(RIP_WARNING, "Reparenting console 0x%p", ProcessData);

            ProcessHandleRecord = CONTAINING_RECORD(ListHead,
                                                    CONSOLE_PROCESS_HANDLE,
                                                    ListLink);

            ListHead = ProcessHandleRecord->Process->ThreadList.Flink;
            Thread = CONTAINING_RECORD(ListHead, CSR_THREAD, Link);
            ProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(ProcessHandleRecord->Process);
            UserAssert(ProcessData->RootProcess == FALSE);
            ProcessData->RootProcess = TRUE;

            Status = NtDuplicateObject(NtCurrentProcess(),
                                       Thread->ThreadHandle,
                                       NtCurrentProcess(),
                                       &hThread,
                                       0,
                                       FALSE,
                                       DUPLICATE_SAME_ACCESS);
            if (NT_SUCCESS(Status)) {
                /*
                 * We can only close this handle if the dup call above
                 * succeeded. If it didn't, then we're going to zombie this
                 * process, but at least we can keep going.
                 */
                NtClose(Console->ClientThreadHandle);
                Console->ClientThreadHandle = hThread;
            } else {
                RIPMSGF1(RIP_WARNING,
                         "Failed to dup thread handle: Status = 0x%x",
                         Status);
            }
        }

        UnlockConsole(Console);
    }

    return STATUS_SUCCESS;
}


VOID
ConsoleClientDisconnectRoutine(
    IN PCSR_PROCESS Process)

/*++

Routine Description:

    This routine is called when a process is destroyed.  It closes the
    process's handles and frees the console if it's the last reference.

Arguments:

    Process - Pointer to process structure.

Return Value:

--*/

{
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    PCONSOLE_INFORMATION Console;
    NTSTATUS Status;

    ProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(Process);

    //
    // If this process is not a console app, stop right here - no
    // disconnect processing is needed, because this app didn't create
    // or connect to an existing console.
    //

    if (ProcessData->ConsoleHandle == NULL) {
#if defined(FE_IME)
        if (ProcessData->hDesk) {
            //
            // If this process is a Console IME,
            // should unregister console IME on this desktop.
            //
            RemoveConsoleIME(Process, HandleToUlong(Process->ClientId.UniqueThread));
        }
#endif
        return;
    }

    Status = RevalidateConsole(ProcessData->ConsoleHandle, &Console);
    if (NT_SUCCESS(Status)) {
        ConsoleNotifyWinEvent(Console,
                              EVENT_CONSOLE_END_APPLICATION,
                              HandleToULong(Process->ClientId.UniqueProcess),
                              0);
        UnlockConsole(Console);
    } else {
        RIPMSG2(RIP_WARNING, "RevalidateConsole returned status 0x%x on console 0x%x", Status, ProcessData->ConsoleHandle);
    }

    RemoveConsole(ProcessData,
                  CONSOLE_FROMPROCESSPROCESSHANDLE(Process),
                  Process->ClientId.UniqueProcess);
    CONSOLE_SETCONSOLEAPPFROMPROCESSDATA(ProcessData, FALSE);
}

ULONG
SrvAllocConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_ALLOC_MSG a = (PCONSOLE_ALLOC_MSG)&m->u.ApiMessageData;
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    PCSR_PROCESS Process;
    UNICODE_STRING strDesktopName;

    ProcessData = CONSOLE_PERPROCESSDATA();
    ASSERT(!CONSOLE_GETCONSOLEAPPFROMPROCESSDATA(ProcessData));

    if (!CsrValidateMessageBuffer(m, &a->Title, a->TitleLength, sizeof(BYTE)) ||
        !CsrValidateMessageBuffer(m, &a->Desktop, a->DesktopLength, sizeof(BYTE)) ||
        !CsrValidateMessageBuffer(m, &a->CurDir, a->CurDirLength, sizeof(BYTE)) ||
        !CsrValidateMessageBuffer(m, &a->AppName, a->AppNameLength, sizeof(BYTE)) ||
        !CsrValidateMessageBuffer(m, &a->ConsoleInfo, sizeof(*a->ConsoleInfo), sizeof(BYTE))) {

        return STATUS_INVALID_PARAMETER;
    }

    Process = (PCSR_PROCESS)(CSR_SERVER_QUERYCLIENTTHREAD()->Process);
    if (a->DesktopLength) {
        RtlInitUnicodeString(&strDesktopName, a->Desktop);
    } else {
        RtlInitUnicodeString(&strDesktopName, L"Default");
    }

    ProcessHandleRecord = ConsoleHeapAlloc(HANDLE_TAG, sizeof(CONSOLE_PROCESS_HANDLE));
    if (ProcessHandleRecord == NULL) {
        return (ULONG)STATUS_NO_MEMORY;
    }

    Status = SetUpConsole(a->ConsoleInfo,
                          a->TitleLength,
                          a->Title,
                          a->CurDir,
                          a->AppName,
                          ProcessData,
                          TRUE,
                          &strDesktopName);
    if (!NT_SUCCESS(Status)) {
        ConsoleHeapFree(ProcessHandleRecord);
        return Status;
    }
    CONSOLE_SETCONSOLEAPP(TRUE);
    Process->Flags |= CSR_PROCESS_CONSOLEAPP;
    Status = RevalidateConsole(a->ConsoleInfo->ConsoleHandle,&Console);
    ASSERT (NT_SUCCESS(Status));
    ProcessHandleRecord->Process = CSR_SERVER_QUERYCLIENTTHREAD()->Process;
    ProcessHandleRecord->CtrlRoutine = a->CtrlRoutine;
    ProcessHandleRecord->PropRoutine = a->PropRoutine;
    ASSERT (!(Console->Flags & CONSOLE_SHUTTING_DOWN));
    AddProcessToList(Console, ProcessHandleRecord, CONSOLE_CLIENTPROCESSHANDLE());
    SetProcessForegroundRights(Process, Console->Flags & CONSOLE_HAS_FOCUS);
    AllocateCommandHistory(Console,
                           a->AppNameLength,
                           a->AppName,
                           CONSOLE_CLIENTPROCESSHANDLE());

    UnlockConsole(Console);

    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvFreeConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_FREE_MSG a = (PCONSOLE_FREE_MSG)&m->u.ApiMessageData;
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    NTSTATUS Status;

    ProcessData = CONSOLE_PERPROCESSDATA();
    ASSERT (CONSOLE_GETCONSOLEAPPFROMPROCESSDATA(ProcessData));

    if (CONSOLE_GETCONSOLEHANDLEFROMPROCESSDATA(ProcessData) != a->ConsoleHandle) {
        RIPMSG1(RIP_WARNING, "SrvFreeConsole: invalid console handle %x", a->ConsoleHandle);
        return STATUS_INVALID_HANDLE;
    }

    Status = RemoveConsole(ProcessData,
            CONSOLE_CLIENTPROCESSHANDLE(),
            CONSOLE_CLIENTPROCESSID());

    if (NT_SUCCESS(Status)) {
        CONSOLE_SETCONSOLEAPP(FALSE);
    }

    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvAttachConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_ATTACH_MSG a = (PCONSOLE_ATTACH_MSG)&m->u.ApiMessageData;
    DWORD ProcessId;
    NTSTATUS Status;
    PCSR_PROCESS ParentProcess;
    PCSR_PROCESS Process;
    CLIENT_ID ClientId;
    OBJECT_ATTRIBUTES Obja;
    HANDLE ProcessHandle;
    PCONSOLE_INFORMATION Console;
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    PCONSOLE_PER_PROCESS_DATA ParentProcessData;
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;

    Process = (PCSR_PROCESS)(CSR_SERVER_QUERYCLIENTTHREAD()->Process);

    //
    // Make sure we have a valid buffer
    //

    if (!CsrValidateMessageBuffer(m, &a->ConsoleInfo, sizeof(*a->ConsoleInfo), sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make sure we're not already attached to a console
    //

    ProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(Process);
    if (CONSOLE_GETCONSOLEAPPFROMPROCESSDATA(ProcessData)) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // Figure out what process we're attaching to.
    //

    if (a->ProcessId == (DWORD)-1) {
        ProcessId = ProcessData->ParentProcessId;
    } else {
        ProcessId = a->ProcessId;
    }

    //
    // Lock the process we're attaching to so it can't go away.
    //

    Status = CsrLockProcessByClientId(LongToHandle(ProcessId), &ParentProcess);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Make sure we have access to the process.
    //

    if (!CsrImpersonateClient(NULL)) {
        CsrUnlockProcess(ParentProcess);
        return STATUS_BAD_IMPERSONATION_LEVEL;
    }

    ClientId.UniqueThread = NULL;
    ClientId.UniqueProcess = UlongToHandle(ProcessId);

    InitializeObjectAttributes(
        &Obja,
        NULL,
        0,
        NULL,
        NULL
        );

    Status = NtOpenProcess(
                &ProcessHandle,
                PROCESS_ALL_ACCESS,
                &Obja,
                &ClientId
                );

    CsrRevertToSelf();

    if (!NT_SUCCESS(Status)) {
        CsrUnlockProcess(ParentProcess);
        return Status;
    }
    NtClose(ProcessHandle);

    //
    // Add current process to parent process's console.
    //

    Process->Flags |= CSR_PROCESS_CONSOLEAPP;
    ParentProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(ParentProcess);
    *ProcessData = *ParentProcessData;
    Status = ConsoleAddProcessRoutine(ParentProcess, Process);
    if (NT_SUCCESS(Status)) {
        CONSOLE_SETCONSOLEAPP(TRUE);
        Status = RevalidateConsole(ProcessData->ConsoleHandle, &Console);
    }

    CsrUnlockProcess(ParentProcess);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Initialize per process console settings.
    //


    Status = MapEventHandles(CONSOLE_CLIENTPROCESSHANDLE(),
                             Console,
                             a->ConsoleInfo
                            );
    if (!NT_SUCCESS(Status)) {
        CONSOLE_SETCONSOLEAPPFROMPROCESSDATA(ProcessData, FALSE);
        UnlockConsole(Console);
        RemoveConsole(ProcessData, Process->ProcessHandle, 0);
        return Status;
    }

    NtCurrentPeb()->ProcessParameters->ConsoleHandle =
        a->ConsoleInfo->ConsoleHandle = ProcessData->ConsoleHandle;
    a->ConsoleInfo->StdIn  = INDEX_TO_HANDLE(0);
    a->ConsoleInfo->StdOut = INDEX_TO_HANDLE(1);
    a->ConsoleInfo->StdErr = INDEX_TO_HANDLE(2);

    ProcessHandleRecord = FindProcessInList(Console, CONSOLE_CLIENTPROCESSHANDLE());
    if (ProcessHandleRecord) {
        ProcessHandleRecord->CtrlRoutine = a->CtrlRoutine;
        ProcessHandleRecord->PropRoutine = a->PropRoutine;
    }
    SetProcessForegroundRights(Process,
                               Console->Flags & CONSOLE_HAS_FOCUS);

    UnlockConsole(Console);

    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

NTSTATUS
MyRegOpenKey(
    IN HANDLE hKey,
    IN LPWSTR lpSubKey,
    OUT PHANDLE phResult
    )
{
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      SubKey;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &SubKey, lpSubKey );

    //
    // Initialize the OBJECT_ATTRIBUTES structure and open the key.
    //

    InitializeObjectAttributes(
        &Obja,
        &SubKey,
        OBJ_CASE_INSENSITIVE,
        hKey,
        NULL
        );

    return NtOpenKey(
              phResult,
              KEY_READ,
              &Obja
              );
}

NTSTATUS
MyRegQueryValue(
    IN HANDLE hKey,
    IN LPWSTR lpValueName,
    IN DWORD dwValueLength,
    OUT LPBYTE lpData
    )
{
    UNICODE_STRING ValueName;
    ULONG BufferLength;
    ULONG ResultLength;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    NTSTATUS Status;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &ValueName, lpValueName );

    BufferLength = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + dwValueLength;
    KeyValueInformation = ConsoleHeapAlloc(TMP_TAG, BufferLength);
    if (KeyValueInformation == NULL)
        return STATUS_NO_MEMORY;

    Status = NtQueryValueKey(
                hKey,
                &ValueName,
                KeyValuePartialInformation,
                KeyValueInformation,
                BufferLength,
                &ResultLength
                );
    if (NT_SUCCESS(Status)) {
        ASSERT(KeyValueInformation->DataLength <= dwValueLength);
        RtlCopyMemory(lpData,
            KeyValueInformation->Data,
            KeyValueInformation->DataLength);
        if (KeyValueInformation->Type == REG_SZ ||
            KeyValueInformation->Type == REG_MULTI_SZ
           ) {
            if (KeyValueInformation->DataLength + sizeof(WCHAR) > dwValueLength) {
                KeyValueInformation->DataLength -= sizeof(WCHAR);
            }
            lpData[KeyValueInformation->DataLength++] = 0;
            lpData[KeyValueInformation->DataLength] = 0;
        }
    }
    ConsoleHeapFree(KeyValueInformation);
    return Status;
}

#if defined(FE_SB)
NTSTATUS
MyRegQueryValueEx(
    IN HANDLE hKey,
    IN LPWSTR lpValueName,
    IN DWORD dwValueLength,
    OUT LPBYTE lpData,
    OUT LPDWORD lpDataLength
    )
{
    UNICODE_STRING ValueName;
    ULONG BufferLength;
    ULONG ResultLength;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    NTSTATUS Status;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &ValueName, lpValueName );

    BufferLength = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + dwValueLength;
    KeyValueInformation = ConsoleHeapAlloc(TMP_TAG, BufferLength);
    if (KeyValueInformation == NULL)
        return STATUS_NO_MEMORY;

    Status = NtQueryValueKey(
                hKey,
                &ValueName,
                KeyValuePartialInformation,
                KeyValueInformation,
                BufferLength,
                &ResultLength
                );
    if (NT_SUCCESS(Status)) {
        ASSERT(KeyValueInformation->DataLength <= dwValueLength);
        RtlCopyMemory(lpData,
            KeyValueInformation->Data,
            KeyValueInformation->DataLength);
        if (lpDataLength)
        {
            *lpDataLength = KeyValueInformation->DataLength;
        }
    }
    ConsoleHeapFree(KeyValueInformation);
    return Status;
}

NTSTATUS
MyRegEnumValue(
    IN HANDLE hKey,
    IN DWORD dwIndex,
    OUT DWORD dwValueLength,
    OUT LPWSTR lpValueName,
    OUT DWORD dwDataLength,
    OUT LPBYTE lpData
    )
{
    ULONG BufferLength;
    ULONG ResultLength;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    NTSTATUS Status;

    //
    // Convert the subkey to a counted Unicode string.
    //

    BufferLength = sizeof(KEY_VALUE_FULL_INFORMATION) + dwValueLength + dwDataLength;
    KeyValueInformation = ConsoleHeapAlloc(TMP_TAG, BufferLength);
    if (KeyValueInformation == NULL)
        return STATUS_NO_MEMORY;

    Status = NtEnumerateValueKey(
                hKey,
                dwIndex,
                KeyValueFullInformation,
                KeyValueInformation,
                BufferLength,
                &ResultLength
                );
    if (NT_SUCCESS(Status)) {
        ASSERT(KeyValueInformation->NameLength <= dwValueLength);
        RtlMoveMemory(lpValueName,
                      KeyValueInformation->Name,
                      KeyValueInformation->NameLength);
        lpValueName[ KeyValueInformation->NameLength >> 1 ] = UNICODE_NULL;


        ASSERT(KeyValueInformation->DataLength <= dwDataLength);
        RtlMoveMemory(lpData,
            (PBYTE)KeyValueInformation + KeyValueInformation->DataOffset,
            KeyValueInformation->DataLength);
        if (KeyValueInformation->Type == REG_SZ) {
            if (KeyValueInformation->DataLength + sizeof(WCHAR) > dwDataLength) {
                KeyValueInformation->DataLength -= sizeof(WCHAR);
            }
            lpData[KeyValueInformation->DataLength++] = 0;
            lpData[KeyValueInformation->DataLength] = 0;
        }
    }
    ConsoleHeapFree(KeyValueInformation);
    return Status;
}
#endif

#define SYSTEM_ROOT         (L"%SystemRoot%")
#define SYSTEM_ROOT_LENGTH  (sizeof(SYSTEM_ROOT) - sizeof(WCHAR))

LPWSTR
TranslateConsoleTitle(
    LPWSTR ConsoleTitle,
    PUSHORT pcbTranslatedTitle,
    BOOL Unexpand,
    BOOL Substitute
    )
/*++

Routine Description:

    This routine translates path characters into '_' characters because
    the NT registry apis do not allow the creation of keys with
    names that contain path characters. It also converts absolute paths
    into %SystemRoot% relative ones. As an example, if both behaviors were
    specified it would convert a title like C:\WINNT\System32\cmd.exe to
    %SystemRoot%_System32_cmd.exe.

Arguments:

    ConsoleTitle - Pointer to string to translate.

    pcbTranslatedTitle - On return, contains size of translated title.

    Unexpand - Convert absolute path to %SystemRoot% relative one.

    Substitute - Replace '\' with '_' in path.

Return Value:

    Pointer to translated title or NULL.

Note:

    This routine allocates a buffer that must be freed.

--*/
{
    USHORT cbConsoleTitle, i;
    USHORT cbSystemRoot;
    LPWSTR TranslatedConsoleTitle, Tmp;

    cbConsoleTitle = (USHORT)((lstrlenW(ConsoleTitle) + 1) * sizeof(WCHAR));
    cbSystemRoot = (USHORT)(lstrlenW(USER_SHARED_DATA->NtSystemRoot) * sizeof(WCHAR));

    if (Unexpand && !MyStringCompareW(ConsoleTitle,
                                      USER_SHARED_DATA->NtSystemRoot,
                                      cbSystemRoot,
                                      TRUE)) {
        cbConsoleTitle -= cbSystemRoot;
        (PBYTE)ConsoleTitle += cbSystemRoot;
        cbSystemRoot = SYSTEM_ROOT_LENGTH;
    } else {
        cbSystemRoot = 0;
    }

    Tmp = TranslatedConsoleTitle = ConsoleHeapAlloc(TITLE_TAG, cbSystemRoot + cbConsoleTitle);
    if (TranslatedConsoleTitle == NULL) {
        return NULL;
    }

    RtlCopyMemory(TranslatedConsoleTitle, SYSTEM_ROOT, cbSystemRoot);
    (PBYTE)TranslatedConsoleTitle += cbSystemRoot;

    for (i=0;i<cbConsoleTitle;i+=sizeof(WCHAR)) {
        if (Substitute && *ConsoleTitle == '\\') {
            *TranslatedConsoleTitle++ = (WCHAR)'_';
        } else {
            *TranslatedConsoleTitle++ = *ConsoleTitle;
        }
        ConsoleTitle++;
    }

    if (pcbTranslatedTitle) {
        *pcbTranslatedTitle = cbSystemRoot + cbConsoleTitle;
    }

    return Tmp;
}


ULONG
ConsoleClientShutdown(
    PCSR_PROCESS Process,
    ULONG Flags,
    BOOLEAN fFirstPass
    )
{
    PCONSOLE_INFORMATION Console;
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    NTSTATUS Status;
    HWND hWnd;
    HANDLE TerminationEvent;
    HANDLE ConsoleHandle;
    NTSTATUS WaitStatus;
    USERTHREAD_USEDESKTOPINFO utudi;

    //
    // Find the console associated with this process
    //

    ProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(Process);

    //
    // If this process is not a console app, stop right here unless
    // this is the second pass of shutdown, in which case we'll take
    // it.
    //

    if (!ProcessData || !CONSOLE_GETCONSOLEAPPFROMPROCESSDATA(ProcessData)) {
#if defined(FE_IME)
        if (fFirstPass &&
            (ProcessData->ConsoleHandle == NULL) &&
            (ProcessData->hDesk != NULL))
        {
            //
            // If this process is a Console IME,
            // should unregister console IME on this desktop.
            //
            RemoveConsoleIME(Process, HandleToUlong(Process->ClientId.UniqueThread));
        }
#endif
        if (fFirstPass) {
            return SHUTDOWN_UNKNOWN_PROCESS;
        }
        return NonConsoleProcessShutdown(Process, Flags);
    }

    //
    // Find the console structure pointer.
    //

    ConsoleHandle = CONSOLE_GETCONSOLEHANDLEFROMPROCESSDATA(ProcessData);
    Status = RevalidateConsole(
            ConsoleHandle,
            &Console);

    if (!NT_SUCCESS(Status)) {
        return SHUTDOWN_UNKNOWN_PROCESS;
        }

    //
    // If this is the invisible WOW console, return UNKNOWN so USER
    // enumerates 16-bit gui apps.
    //

    if ((Console->Flags & CONSOLE_NO_WINDOW) &&
        (Console->Flags & CONSOLE_WOW_REGISTERED)) {
        UnlockConsole(Console);
        return SHUTDOWN_UNKNOWN_PROCESS;
        }

    //
    // Sometimes the console structure is around even though the
    // hWnd has been NULLed out. In this case, go to non-console
    // process shutdown.
    //

    hWnd = Console->hWnd;
    if (hWnd == NULL || !IsWindow(hWnd)) {
        UnlockConsole(Console);
        return NonConsoleProcessShutdown(Process, Flags);
        }

    //
    // Make a copy of the console termination event
    //

    Status = NtDuplicateObject(NtCurrentProcess(),
                               Console->TerminationEvent,
                               NtCurrentProcess(),
                               &TerminationEvent,
                               0,
                               FALSE,
                               DUPLICATE_SAME_ACCESS
                               );
    if (!NT_SUCCESS(Status)) {
        UnlockConsole(Console);
        return NonConsoleProcessShutdown(Process, Flags);
    }

    //
    // Attach to the desktop.
    //

    utudi.hThread = Console->InputThreadInfo->ThreadHandle;
    utudi.drdRestore.pdeskRestore = NULL;
    Status = NtUserSetInformationThread(NtCurrentThread(),
                                        UserThreadUseDesktop,
                                        &utudi,
                                        sizeof(utudi));

    UnlockConsole(Console);
    if (!NT_SUCCESS(Status)) {
        NtClose(TerminationEvent);
        return NonConsoleProcessShutdown(Process, Flags);
    }

    //
    // We're done looking at this process structure, so dereference it.
    //
    CsrDereferenceProcess(Process);

    //
    // Synchronously talk to this console.
    //

    Status = ShutdownConsole(ConsoleHandle, Flags);

    //
    // Detach from the desktop.
    //

    utudi.hThread = NULL;
    NtUserSetInformationThread(NtCurrentThread(),
                               UserThreadUseDesktop,
                               &utudi,
                               sizeof(utudi));

    //
    // If Status == STATUS_PROCESS_IS_TERMINATING, then we should wait
    // for the console to exit.
    //

    if (Status == STATUS_PROCESS_IS_TERMINATING) {
        WaitStatus = InternalWaitCancel(TerminationEvent, 500000);
        if (WaitStatus == STATUS_WAIT_1) {
            Status = SHUTDOWN_CANCEL;
        } else if (WaitStatus != STATUS_TIMEOUT) {
            Status = SHUTDOWN_KNOWN_PROCESS;
        } else {
#if DBG
            PLIST_ENTRY ListHead, ListNext;
            PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
            PCSR_PROCESS Process;

            RIPMSG0(RIP_ERROR | RIP_THERESMORE, "********************************************");
            RIPMSG1(RIP_ERROR | RIP_THERESMORE, "Shutdown wait timed out on console %p", Console);
            RIPMSG1(RIP_ERROR | RIP_THERESMORE, "Reference count is %d", Console->RefCount);
            RIPMSG0(RIP_ERROR | RIP_THERESMORE, "Dump these processes and see if they're hung");
            ListHead = &Console->ProcessHandleList;
            ListNext = ListHead->Flink;
            while (ListNext != ListHead) {
                ProcessHandleRecord = CONTAINING_RECORD(ListNext, CONSOLE_PROCESS_HANDLE, ListLink);
                Process = ProcessHandleRecord->Process;
                RIPMSG2(RIP_ERROR | RIP_THERESMORE, "CsrProcess = %p ProcessId = %x", Process, Process->ClientId.UniqueProcess);
                ListNext = ListNext->Flink;
            }
            RIPMSG0(RIP_ERROR, "********************************************");
#endif
            Status = SHUTDOWN_CANCEL;
        }
    }
    NtClose(TerminationEvent);

    return Status;
}

ULONG
NonConsoleProcessShutdown(
    PCSR_PROCESS Process,
    DWORD dwFlags
    )
{
    CONSOLE_PROCESS_TERMINATION_RECORD TerminateRecord;
    DWORD EventType;
    BOOL Success;
    HANDLE ProcessHandle;

    Success = DuplicateHandle(NtCurrentProcess(),
            Process->ProcessHandle,
            NtCurrentProcess(),
            &ProcessHandle,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);

    if (!Success)
        ProcessHandle = Process->ProcessHandle;

    TerminateRecord.ProcessHandle = ProcessHandle;
    TerminateRecord.TerminateCount = 0;
    TerminateRecord.CtrlRoutine = CtrlRoutine;

    CsrDereferenceProcess(Process);

    EventType = CTRL_LOGOFF_EVENT;
    if (dwFlags & EWX_SHUTDOWN)
        EventType = CTRL_SHUTDOWN_EVENT;

    CreateCtrlThread(&TerminateRecord,
            1,
            NULL,
            EventType,
            TRUE);

    if (Success)
        CloseHandle(ProcessHandle);

    return SHUTDOWN_KNOWN_PROCESS;
}

VOID
InitializeConsoleAttributes( VOID )

/*++

Routine Description:

    This routine initializes default attributes from the current
    user's registry values. It gets called during logon/logoff.

Arguments:

    none

Return Value:

    none

--*/

{
    //
    // Store default values in structure and mark it
    // as invalid (by resetting LastWriteTime).
    //

    DefaultRegInfo.ScreenFill.Attributes = 0x07;            // white on black
    DefaultRegInfo.ScreenFill.Char.UnicodeChar = (WCHAR)' ';
    DefaultRegInfo.PopupFill.Attributes = 0xf5;             // purple on white
    DefaultRegInfo.PopupFill.Char.UnicodeChar = (WCHAR)' ';
    DefaultRegInfo.InsertMode = FALSE;
    DefaultRegInfo.QuickEdit = FALSE;
    DefaultRegInfo.AutoPosition = TRUE;
    DefaultRegInfo.FullScreen = FALSE;
    DefaultRegInfo.ScreenBufferSize.X = 80;
    DefaultRegInfo.ScreenBufferSize.Y = 25;
    DefaultRegInfo.WindowSize.X = 80;
    DefaultRegInfo.WindowSize.Y = 25;
    DefaultRegInfo.WindowOrigin.X = 0;
    DefaultRegInfo.WindowOrigin.Y = 0;
    DefaultRegInfo.FontSize.X = 0;
    DefaultRegInfo.FontSize.Y = 0;
    DefaultRegInfo.FontFamily = 0;
    DefaultRegInfo.FontWeight = 0;
    DefaultRegInfo.FaceName[0] = L'\0';
    DefaultRegInfo.CursorSize = CURSOR_SMALL_SIZE;
    DefaultRegInfo.HistoryBufferSize = DEFAULT_NUMBER_OF_COMMANDS;
    DefaultRegInfo.NumberOfHistoryBuffers = DEFAULT_NUMBER_OF_BUFFERS;
    DefaultRegInfo.HistoryNoDup = FALSE;
    DefaultRegInfo.ColorTable[ 0] = RGB(0,   0,   0   );
    DefaultRegInfo.ColorTable[ 1] = RGB(0,   0,   0x80);
    DefaultRegInfo.ColorTable[ 2] = RGB(0,   0x80,0   );
    DefaultRegInfo.ColorTable[ 3] = RGB(0,   0x80,0x80);
    DefaultRegInfo.ColorTable[ 4] = RGB(0x80,0,   0   );
    DefaultRegInfo.ColorTable[ 5] = RGB(0x80,0,   0x80);
    DefaultRegInfo.ColorTable[ 6] = RGB(0x80,0x80,0   );
    DefaultRegInfo.ColorTable[ 7] = RGB(0xC0,0xC0,0xC0);
    DefaultRegInfo.ColorTable[ 8] = RGB(0x80,0x80,0x80);
    DefaultRegInfo.ColorTable[ 9] = RGB(0,   0,   0xFF);
    DefaultRegInfo.ColorTable[10] = RGB(0,   0xFF,0   );
    DefaultRegInfo.ColorTable[11] = RGB(0,   0xFF,0xFF);
    DefaultRegInfo.ColorTable[12] = RGB(0xFF,0,   0   );
    DefaultRegInfo.ColorTable[13] = RGB(0xFF,0,   0xFF);
    DefaultRegInfo.ColorTable[14] = RGB(0xFF,0xFF,0   );
    DefaultRegInfo.ColorTable[15] = RGB(0xFF,0xFF,0xFF);
#if defined(FE_SB) // scotthsu
    DefaultRegInfo.CodePage = OEMCP;
#endif
    DefaultRegInfo.LastWriteTime = 0;

    //
    // Get system metrics for this user
    //

    InitializeSystemMetrics();
}


VOID
GetRegistryValues(
    IN LPWSTR ConsoleTitle,
    OUT PCONSOLE_REGISTRY_INFO RegInfo
    )

/*++

Routine Description:

    This routine reads in values from the registry and places them
    in the supplied structure.

Arguments:

    ConsoleTitle - name of subkey to open

    RegInfo - pointer to structure to receive information

Return Value:

    none

--*/

{
    HANDLE hCurrentUserKey;
    HANDLE hConsoleKey;
    HANDLE hTitleKey;
    NTSTATUS Status;
    LPWSTR TranslatedConsoleTitle;
    DWORD dwValue;
    DWORD i;
    WCHAR awchFaceName[LF_FACESIZE];
    WCHAR awchBuffer[64];
    KEY_BASIC_INFORMATION KeyInfo;
    ULONG ResultLength;

    //
    // Impersonate the client process
    //

    if (!CsrImpersonateClient(NULL)) {
        RIPMSG0(RIP_WARNING, "GetRegistryValues Impersonate failed");
        return;
    }

    //
    // Open the current user registry key
    //

    Status = RtlOpenCurrentUser(MAXIMUM_ALLOWED, &hCurrentUserKey);
    if (!NT_SUCCESS(Status)) {
        CsrRevertToSelf();
        return;
    }

    //
    // Open the console registry key
    //

    Status = MyRegOpenKey(hCurrentUserKey,
                          CONSOLE_REGISTRY_STRING,
                          &hConsoleKey);
    if (!NT_SUCCESS(Status)) {
        NtClose(hCurrentUserKey);
        CsrRevertToSelf();
        return;
    }

    //
    // If we're not reading the default key, check if the default values
    // need to be updated
    //

    Status = NtQueryKey(hConsoleKey,
                        KeyBasicInformation,
                        &KeyInfo,
                        sizeof(KeyInfo),
                        &ResultLength);
    if (!NT_ERROR(Status)) {
        if (DefaultRegInfo.LastWriteTime != KeyInfo.LastWriteTime.QuadPart) {
            DefaultRegInfo.LastWriteTime = KeyInfo.LastWriteTime.QuadPart;
            if (RegInfo != &DefaultRegInfo) {
                GetRegistryValues(L"", &DefaultRegInfo);
                *RegInfo = DefaultRegInfo;
            }
        }
    }

    //
    // Open the console title subkey
    //

    TranslatedConsoleTitle = TranslateConsoleTitle(ConsoleTitle, NULL, TRUE, TRUE);
    if (TranslatedConsoleTitle == NULL) {
        NtClose(hConsoleKey);
        NtClose(hCurrentUserKey);
        CsrRevertToSelf();
        return;
    }
    Status = MyRegOpenKey(hConsoleKey,
                         TranslatedConsoleTitle,
                         &hTitleKey);
    ConsoleHeapFree(TranslatedConsoleTitle);
    if (!NT_SUCCESS(Status)) {
        TranslatedConsoleTitle = TranslateConsoleTitle(ConsoleTitle, NULL, FALSE, TRUE);
        if (TranslatedConsoleTitle) {
            Status = MyRegOpenKey(hConsoleKey,
                                 TranslatedConsoleTitle,
                                 &hTitleKey);
            ConsoleHeapFree(TranslatedConsoleTitle);
        }
    }
    if (!NT_SUCCESS(Status)) {
        NtClose(hConsoleKey);
        NtClose(hCurrentUserKey);
        CsrRevertToSelf();
        return;
    }

    //
    // Initial screen fill
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FILLATTR,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->ScreenFill.Attributes = (WORD)dwValue;
    }

    //
    // Initial popup fill
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_POPUPATTR,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->PopupFill.Attributes = (WORD)dwValue;
    }

    //
    // Initial insert mode
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_INSERTMODE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->InsertMode = !!dwValue;
    }

    //
    // Initial quick edit mode
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_QUICKEDIT,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->QuickEdit = !!dwValue;
    }

#ifdef i386
    //
    // Initial full screen mode
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FULLSCR,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->FullScreen = !!dwValue;
    }
#endif

#if defined(FE_SB) // scotthsu
    //
    // Code Page
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_CODEPAGE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->CodePage = (UINT)dwValue;

        // If this routine specified default settings for console property,
        // then make sure code page value when Fae East environment.
        // If code page value does not the same to OEMCP and any FE's code page then
        // we are override code page value to OEMCP on default console property.
        // Because, Far East environment has limitation that doesn not switch to
        // another FE's code page by the SetConsoleCP/SetConsoleOutputCP.
        //
        // Compare of ConsoleTitle and L"" has limit to default property of console.
        // It means, this code doesn't care user defined property.
        // Content of user defined property has responsibility to themselves.

        if (wcscmp(ConsoleTitle, L"") == 0 &&
             IsAvailableFarEastCodePage(RegInfo->CodePage) &&
             OEMCP != RegInfo->CodePage) {
            RegInfo->CodePage = OEMCP;
        }
    }
#endif // FE_SB

    //
    // Initial screen buffer size
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_BUFFERSIZE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->ScreenBufferSize.X = LOWORD(dwValue);
        RegInfo->ScreenBufferSize.Y = HIWORD(dwValue);
        if (RegInfo->ScreenBufferSize.X <= 0)
            RegInfo->ScreenBufferSize.X = 1;
        if (RegInfo->ScreenBufferSize.Y <= 0)
            RegInfo->ScreenBufferSize.Y = 1;
    }

    //
    // Initial window size
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_WINDOWSIZE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->WindowSize.X = LOWORD(dwValue);
        RegInfo->WindowSize.Y = HIWORD(dwValue);
        if (RegInfo->WindowSize.X <= 0)
            RegInfo->WindowSize.X = 1;
        else if (RegInfo->WindowSize.X > RegInfo->ScreenBufferSize.X)
            RegInfo->WindowSize.X = RegInfo->ScreenBufferSize.X;
        if (RegInfo->WindowSize.Y <= 0)
            RegInfo->WindowSize.Y = 1;
        else if (RegInfo->WindowSize.Y > RegInfo->ScreenBufferSize.Y)
            RegInfo->WindowSize.Y = RegInfo->ScreenBufferSize.Y;
    }

    //
    // Initial window position
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_WINDOWPOS,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->WindowOrigin.X = LOWORD(dwValue);
        RegInfo->WindowOrigin.Y = HIWORD(dwValue);
        RegInfo->AutoPosition = FALSE;
    }

    //
    // Initial font size
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FONTSIZE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->FontSize.X = LOWORD(dwValue);
        RegInfo->FontSize.Y = HIWORD(dwValue);
    }

    //
    // Initial font family
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FONTFAMILY,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->FontFamily = dwValue;
    }

    //
    // Initial font weight
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FONTWEIGHT,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->FontWeight = dwValue;
    }

    //
    // Initial font face name
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FACENAME,
                       sizeof(awchFaceName), (PBYTE)awchFaceName))) {
        RtlCopyMemory(RegInfo->FaceName, awchFaceName, sizeof(awchFaceName));
        RegInfo->FaceName[NELEM(RegInfo->FaceName) - 1] = 0;
    }

    //
    // Initial cursor size
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_CURSORSIZE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->CursorSize = dwValue;
    }

    //
    // Initial history buffer size
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_HISTORYSIZE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->HistoryBufferSize = dwValue;
    }

    //
    // Initial number of history buffers
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_HISTORYBUFS,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->NumberOfHistoryBuffers = dwValue;
    }

    //
    // Initial history duplication mode
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_HISTORYNODUP,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->HistoryNoDup = dwValue;
    }

    for (i=0; i<16; i++) {
        wsprintf(awchBuffer, CONSOLE_REGISTRY_COLORTABLE, i);
        if (NT_SUCCESS(MyRegQueryValue(hTitleKey, awchBuffer,
                           sizeof(dwValue), (PBYTE)&dwValue))) {
            RegInfo->ColorTable[ i ] = dwValue;
        }
    }

    if (RegInfo == &DefaultRegInfo) {
        //
        // If the common (default) setting has been changed,
        //

        //
        // Get registry for conime flag
        //
        if (NT_SUCCESS(MyRegQueryValue(hConsoleKey, CONSOLE_REGISTRY_LOAD_CONIME, sizeof dwValue, (PBYTE)&dwValue))) {
            gfLoadConIme = (dwValue != 0);
        } else {
            gfLoadConIme = TRUE;
        }

        //
        // get extended edit mode and keys from registry.
        //
        if (NT_SUCCESS(MyRegQueryValue(hConsoleKey,
                CONSOLE_REGISTRY_EXTENDEDEDITKEY,
                sizeof dwValue,
                (PBYTE)&dwValue)) &&
                dwValue <= 1) {

            ExtKeyDefBuf buf;

            gExtendedEditKey = dwValue;

            //
            // Initialize Extended Edit keys
            //
            InitExtendedEditKeys(NULL);

            if (NT_SUCCESS(MyRegQueryValue(hConsoleKey,
                           CONSOLE_REGISTRY_EXTENDEDEDITKEY_CUSTOM,
                           sizeof(buf),
                           (PBYTE)&buf))) {
                InitExtendedEditKeys(&buf);
            } else {
                RIPMSG0(RIP_VERBOSE, "Error reading ExtendedEditkeyCustom.");
            }
        } else {
            gExtendedEditKey = 0;
            RIPMSG0(RIP_VERBOSE, "Error reading ExtendedEditkey.");
        }

        //
        // Word delimiters
        //
        if (gExtendedEditKey) {
            // If extended edit key is given, provide extended word delimiters
            // by default.
            memcpy((LPBYTE)gaWordDelimChars, (LPBYTE)gaWordDelimCharsDefault,
                    sizeof gaWordDelimChars[0] * WORD_DELIM_MAX);
        } else {
            // Otherwise, stick to the original word delimiter.
            gaWordDelimChars[0] = L'\0';
        }

        // Read word delimiters from registry
        if (NT_SUCCESS(MyRegQueryValue(hConsoleKey,
                    CONSOLE_REGISTRY_WORD_DELIM,
                    sizeof awchBuffer,
                    (PBYTE)awchBuffer))) {
            // OK, copy it to the word delimiter array.
            wcsncpy(gaWordDelimChars, awchBuffer, WORD_DELIM_MAX);
            gaWordDelimChars[WORD_DELIM_MAX - 1] = 0;
        }

        //
        // Read Trim Zero Heading flag
        //
        if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                           CONSOLE_REGISTRY_TRIMZEROHEADINGS,
                           sizeof(dwValue), (PBYTE)&dwValue))) {
            gfTrimLeadingZeros = dwValue;
        } else {
            gfTrimLeadingZeros = FALSE;
        }

        //
        // Color selected area function enable flag
        //

        if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                           CONSOLE_REGISTRY_ENABLE_COLOR_SELECTION,
                           sizeof(dwValue), (PBYTE)&dwValue))) {

            gfEnableColorSelection = !!dwValue;
        }
        else {
            gfEnableColorSelection = FALSE;
        }
    }

    //
    // Close the registry keys
    //

    NtClose(hTitleKey);
    NtClose(hConsoleKey);
    NtClose(hCurrentUserKey);
    CsrRevertToSelf();
}

NTSTATUS
GetConsoleLangId(
    IN UINT OutputCP,
    OUT LANGID* pLangId
    )
{
    NTSTATUS Status;

    if (CONSOLE_IS_DBCS_ENABLED()){
        if (pLangId != NULL) {
            switch (OutputCP) {
                case 932:
                    *pLangId = MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT);
                    break;
                case 949:
                    *pLangId = MAKELANGID(LANG_KOREAN, SUBLANG_KOREAN);
                    break;
                case 936:
                    *pLangId = MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED);
                    break;
                case 950:
                    *pLangId = MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL);
                    break;
                default:
                    *pLangId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
                    break;
            }
        }
        Status = STATUS_SUCCESS;
    }
    else {
        Status = STATUS_NOT_SUPPORTED;
    }

    return Status;
}

ULONG
SrvGetConsoleLangId(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_LANGID_MSG a = (PCONSOLE_LANGID_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = GetConsoleLangId(Console->OutputCP, &a->LangId);

    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\precomp.h ===
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrsrv.h>
#include <windows.h>
#include <conroute.h>
#include <ntddvdeo.h>
#include "shellapi.h"
#include "shlobj.h"
#include "shlwapi.h"
#define NO_SHLWAPI_STRFCNS
#define NO_SHLWAPI_PATH
#define NO_SHLWAPI_REG
#define NO_SHLWAPI_UALSTR
#define NO_SHLWAPI_HTTP
#define NO_SHLWAPI_INTERNAL
#include "shlwapip.h"
#include "shlobjp.h"
#undef _DROPFILES
#undef DROPFILES
#undef LPDROPFILES
#include "conapi.h"
#include "conmsg.h"
#include "usersrv.h"
#include "server.h"
#include "cmdline.h"
#include "font.h"
#include "heap.h"
#include "consrv.h"
#include "directio.h"
#include "globals.h"
#include "menu.h"
#include "stream.h"
#include "winuserp.h"
#include "winconp.h"
#include "winbasep.h"
#ifndef WIN32
#define WIN32
#endif
#if defined(FE_SB)
#include "dbcs.h"
#include "dispatch.h"
#include "eudc.h"
#include "foncache.h"
#include "machine.h"
#if defined(FE_IME)
#include "conv.h"
#include <immp.h>
#endif
#endif
#include <ntosp.h>
#include <w32p.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\private.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    private.c

Abstract:

        This file implements private APIs for Hardware Desktop Support.

Author:

    Therese Stowell (thereses) 12-13-1991

Revision History:

Notes:

--*/

#include "precomp.h"
#include "vdm.h"
#pragma hdrstop

#if defined(FE_SB)
BOOL fFullScreenGraphics ; // Do not trun graphics mode.
#if defined(i386)
extern ULONG  gdwMachineId;
#endif // i386
#endif

//
// initial palette registers
//

#define PAL_BLACK       0
#define PAL_BLUE        1
#define PAL_GREEN       2
#define PAL_RED         4
#define PAL_YELLOW      (PAL_RED | PAL_GREEN)
#define PAL_CYAN        (PAL_GREEN | PAL_BLUE)
#define PAL_MAGENTA     (PAL_BLUE | PAL_RED)
#define PAL_WHITE       (PAL_RED | PAL_GREEN | PAL_BLUE)

#define PAL_I_BLACK     (PAL_BLACK      + (PAL_WHITE    << 3))
#define PAL_I_RED       (PAL_RED        + (PAL_RED      << 3))
#define PAL_I_GREEN     (PAL_GREEN      + (PAL_GREEN    << 3))
#define PAL_I_YELLOW    (PAL_YELLOW     + (PAL_YELLOW   << 3))
#define PAL_I_BLUE      (PAL_BLUE       + (PAL_BLUE     << 3))
#define PAL_I_CYAN      (PAL_CYAN       + (PAL_CYAN     << 3))
#define PAL_I_MAGENTA   (PAL_MAGENTA    + (PAL_MAGENTA  << 3))
#define PAL_I_WHITE     (PAL_WHITE      + (PAL_WHITE    << 3))

#define INITIAL_PALETTE_SIZE 18

USHORT InitialPalette[INITIAL_PALETTE_SIZE] = {

        16, // 16 entries
        0,  // start with first palette register
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
};

#if defined(FE_SB)
PUSHORT RegInitialPalette = InitialPalette;
#endif

UCHAR ColorBuffer[] = {

        16, // 16 entries
        0,
        0,
        0,  // start with first palette register
        0x00, 0x00, 0x00, 0x00, // black
        0x00, 0x00, 0x2A, 0x00, // blue
        0x00, 0x2A, 0x00, 0x00, // green
        0x00, 0x2A, 0x2A, 0x00, // cyan
        0x2A, 0x00, 0x00, 0x00, // red
        0x2A, 0x00, 0x2A, 0x00, // magenta
        0x2A, 0x2A, 0x00, 0x00, // mustard/brown
        0x36, 0x36, 0x36, 0x00, // light gray  39
        0x28, 0x28, 0x28, 0x00, // dark gray   2A
        0x00, 0x00, 0x3F, 0x00, // bright blue
        0x00, 0x3F, 0x00, 0x00, // bright green
        0x00, 0x3F, 0x3F, 0x00, // bright cyan
        0x3F, 0x00, 0x00, 0x00, // bright red
        0x3F, 0x00, 0x3F, 0x00, // bright magenta
        0x3F, 0x3F, 0x00, 0x00, // bright yellow
        0x3F, 0x3F, 0x3F, 0x00  // bright white
};

#if defined(FE_SB)
PUCHAR RegColorBuffer = ColorBuffer;
PUCHAR RegColorBufferNoTranslate = NULL;
#endif

#if defined(FE_SB)
MODE_FONT_PAIR ModeFontPairs[] = {
    {FS_MODE_TEXT, 80, 21, 640, 350, 8, 16},
    {FS_MODE_TEXT, 80, 25, 720, 400, 8, 16},
    {FS_MODE_TEXT, 80, 28, 720, 400, 8, 14},
    {FS_MODE_TEXT, 80, 43, 640, 350, 8, 8 },
    {FS_MODE_TEXT, 80, 50, 720, 400, 8, 8 }
};

DWORD NUMBER_OF_MODE_FONT_PAIRS = sizeof(ModeFontPairs)/sizeof(MODE_FONT_PAIR);
PMODE_FONT_PAIR RegModeFontPairs = ModeFontPairs;

SINGLE_LIST_ENTRY gRegFullScreenCodePage;    // This list contain FS_CODEPAGE data.

#else
typedef struct _MODE_FONT_PAIR {
    ULONG Height;
    COORD Resolution;
    COORD FontSize;
} MODE_FONT_PAIR, PMODE_FONT_PAIR;

#define NUMBER_OF_MODE_FONT_PAIRS 5

MODE_FONT_PAIR ModeFontPairs[NUMBER_OF_MODE_FONT_PAIRS] = {
    {21, 640, 350, 8, 16},
    {25, 720, 400, 8, 16},
    {28, 720, 400, 8, 14},
    {43, 640, 350, 8, 8 },
    {50, 720, 400, 8, 8 }
};
#endif


HANDLE hCPIFile;    // handle to font file

typedef struct _FONTFILEHEADER {
    BYTE  ffhFileTag[8]; // SHOULD BE 0FFH,"FONT___"
    BYTE  ffhReserved[8];
    WORD  ffhPointers;
    BYTE  ffhPointerType;
    BYTE  ffhOffset1;
    WORD  ffhOffset2;
    BYTE  ffhOffset3;
} FONTFILEHEADER, *LPFONTFILEHEADER;

typedef struct _FONTINFOHEADER {
    WORD  fihCodePages;
} FONTINFOHEADER, *LPFONTINFOHEADER;

typedef struct _CPENTRYHEADER {
    WORD  cpeLength;
    WORD  cpeNext1;
    WORD  cpeNext2;
    WORD  cpeDevType;
    BYTE  cpeDevSubtype[8];
    WORD  cpeCodepageID;
    BYTE  cpeReserved[6];
    DWORD cpeOffset;
} CPENTRYHEADER, *LPCPENTRYHEADER;

typedef struct _FONTDATAHEADER {
    WORD  fdhReserved;
    WORD  fdhFonts;
    WORD  fdhLength;
} FONTDATAHEADER, *LPFONTDATAHEADER;

typedef struct _SCREENFONTHEADER {
    BYTE  sfhHeight;
    BYTE  sfhWidth;
    WORD  sfhAspect;
    WORD  sfhCharacters;
} SCREENFONTHEADER, *LPSCREENFONTHEADER;

#define CONSOLE_WINDOWS_DIR_LENGTH 256
#define CONSOLE_EGACPI_LENGTH 9 // includes NULL
#define CONSOLE_EGACPI "\\ega.cpi"
#define CONSOLE_FONT_BUFFER_LENGTH 50
#define CONSOLE_DEFAULT_ROM_FONT 437


#ifdef i386
VOID
ReverseMousePointer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    );

VOID
ReadRectFromScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD SourcePoint,
    IN PCHAR_INFO Target,
    IN COORD TargetSize,
    IN PSMALL_RECT TargetRect
    );

#endif

NTSTATUS
MapViewOfSection(
    PHANDLE SectionHandle,
    ULONG CommitSize,
    PVOID *BaseAddress,
    PSIZE_T ViewSize,
    HANDLE ClientHandle,
    PVOID *BaseClientAddress
    );

NTSTATUS
ConnectToEmulator(
    IN BOOL Connect,
    IN PCONSOLE_INFORMATION Console
    );


ULONG
SrvSetConsoleCursor(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Description:

    Sets the mouse pointer for the specified screen buffer.

Parameters:

    hConsoleOutput - Supplies a console output handle.

    hCursor - win32 cursor handle, should be NULL to set the default
        cursor.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PCONSOLE_SETCURSOR_MSG a = (PCONSOLE_SETCURSOR_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_GRAPHICS_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        if (a->CursorHandle == NULL) {
            HandleData->Buffer.ScreenBuffer->CursorHandle = ghNormalCursor;
        } else {
            HandleData->Buffer.ScreenBuffer->CursorHandle = a->CursorHandle;
        }
        PostMessage(HandleData->Buffer.ScreenBuffer->Console->hWnd,
                     WM_SETCURSOR,
                     0,
                     -1
                    );
    }
    UnlockConsole(Console);
    return Status;
}

#ifdef i386
VOID
FullScreenCursor(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN BOOL On
    )
{
    if (On) {
        if (ScreenInfo->CursorDisplayCount < 0) {
            ScreenInfo->CursorDisplayCount = 0;
            ReverseMousePointer(ScreenInfo, &ScreenInfo->Window);
        }
    } else {
        if (ScreenInfo->CursorDisplayCount >= 0) {
            ReverseMousePointer(ScreenInfo, &ScreenInfo->Window);
            ScreenInfo->CursorDisplayCount = -1;
        }
    }

}
#endif

ULONG
SrvShowConsoleCursor(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Description:

    Sets the mouse pointer visibility counter.  If the counter is less than
    zero, the mouse pointer is not shown.

Parameters:

    hOutput - Supplies a console output handle.

    bShow - if TRUE, the display count is to be increased. if FALSE,
        decreased.

Return value:

    The return value specifies the new display count.

--*/

{
    PCONSOLE_SHOWCURSOR_MSG a = (PCONSOLE_SHOWCURSOR_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE | CONSOLE_GRAPHICS_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        if (!(Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE)) {
            if (a->bShow) {
                HandleData->Buffer.ScreenBuffer->CursorDisplayCount += 1;
            } else {
                HandleData->Buffer.ScreenBuffer->CursorDisplayCount -= 1;
            }
            if (HandleData->Buffer.ScreenBuffer == Console->CurrentScreenBuffer) {
                PostMessage(HandleData->Buffer.ScreenBuffer->Console->hWnd,
                             WM_SETCURSOR,
                             0,
                             -1
                            );
            }
        } else {
#ifdef i386
            if (HandleData->HandleType != CONSOLE_GRAPHICS_OUTPUT_HANDLE &&
                Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE &&
                HandleData->Buffer.ScreenBuffer == Console->CurrentScreenBuffer) {
                FullScreenCursor(HandleData->Buffer.ScreenBuffer, a->bShow);
            }
#endif
        }
        a->DisplayCount = HandleData->Buffer.ScreenBuffer->CursorDisplayCount;
    }
    UnlockConsole(Console);
    return Status;
}


ULONG
SrvConsoleMenuControl(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Description:

    Sets the command id range for the current screen buffer and returns the
    menu handle.

Parameters:

    hConsoleOutput - Supplies a console output handle.

    dwCommandIdLow - Specifies the lowest command id to store in the input buffer.

    dwCommandIdHigh - Specifies the highest command id to store in the input
        buffer.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PCONSOLE_MENUCONTROL_MSG a = (PCONSOLE_MENUCONTROL_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE | CONSOLE_GRAPHICS_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        a->hMenu = HandleData->Buffer.ScreenBuffer->Console->hMenu;
        HandleData->Buffer.ScreenBuffer->CommandIdLow = a->CommandIdLow;
        HandleData->Buffer.ScreenBuffer->CommandIdHigh = a->CommandIdHigh;
    }

    UnlockConsole(Console);
    return Status;
}

ULONG
SrvSetConsolePalette(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Description:

    Sets the palette for the console screen buffer.

Parameters:

    hOutput - Supplies a console output handle.

    hPalette - Supplies a handle to the palette to set.

    dwUsage - Specifies use of the system palette.

        SYSPAL_NOSTATIC - System palette contains no static colors
                          except black and white.

        SYSPAL_STATIC -   System palette contains static colors
                          which will not change when an application
                          realizes its logical palette.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PCONSOLE_SETPALETTE_MSG a = (PCONSOLE_SETPALETTE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    HPALETTE hOldPalette;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_GRAPHICS_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        USERTHREAD_USEDESKTOPINFO utudi;
        BOOL bReset = FALSE;

        /*
         * Palette handle was converted in the client.
         */
        if (GetCurrentThreadId() != HandleData->Buffer.ScreenBuffer->
                Console->InputThreadInfo->ThreadId) {
            bReset = TRUE;
            utudi.hThread = HandleData->Buffer.ScreenBuffer->Console->InputThreadInfo->ThreadHandle;
            utudi.drdRestore.pdeskRestore = NULL;
            NtUserSetInformationThread(NtCurrentThread(),
                    UserThreadUseDesktop,
                    &utudi, sizeof(utudi));
        }

        NtUserConsoleControl(ConsolePublicPalette, &(a->hPalette), sizeof(HPALETTE));

        hOldPalette = SelectPalette(
                HandleData->Buffer.ScreenBuffer->Console->hDC,
                a->hPalette,
                FALSE);

        if (hOldPalette == NULL) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            if ((HandleData->Buffer.ScreenBuffer->hPalette != NULL) &&
                    (a->hPalette != HandleData->Buffer.ScreenBuffer->hPalette)) {
                DeleteObject(HandleData->Buffer.ScreenBuffer->hPalette);
            }
            HandleData->Buffer.ScreenBuffer->hPalette = a->hPalette;
            HandleData->Buffer.ScreenBuffer->dwUsage = a->dwUsage;
            if (!(HandleData->Buffer.ScreenBuffer->Console->Flags & CONSOLE_IS_ICONIC) &&
                    HandleData->Buffer.ScreenBuffer->Console->FullScreenFlags == 0) {

                SetSystemPaletteUse(HandleData->Buffer.ScreenBuffer->Console->hDC,
                        HandleData->Buffer.ScreenBuffer->dwUsage);
                RealizePalette(HandleData->Buffer.ScreenBuffer->Console->hDC);
            }
            if (HandleData->Buffer.ScreenBuffer->Console->hSysPalette == NULL) {
                    HandleData->Buffer.ScreenBuffer->Console->hSysPalette = hOldPalette;
            }
        }

        if (bReset) {
            utudi.hThread = NULL;
            NtUserSetInformationThread(NtCurrentThread(),
                    UserThreadUseDesktop, &utudi, sizeof(utudi));
        }
    }
    UnlockConsole(Console);
    return Status;
}


VOID
SetActivePalette(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    USERTHREAD_USEDESKTOPINFO utudi;
    BOOL bReset = FALSE;

    if (GetCurrentThreadId() != ScreenInfo->Console->InputThreadInfo->ThreadId) {
        bReset = TRUE;
        utudi.hThread = ScreenInfo->Console->InputThreadInfo->ThreadHandle;
        utudi.drdRestore.pdeskRestore = NULL;
        NtUserSetInformationThread(NtCurrentThread(),
                UserThreadUseDesktop,
                &utudi, sizeof(utudi));
    }

    SetSystemPaletteUse(ScreenInfo->Console->hDC,
                        ScreenInfo->dwUsage
                       );
    RealizePalette(ScreenInfo->Console->hDC);

    if (bReset == TRUE) {
        utudi.hThread = NULL;
        NtUserSetInformationThread(NtCurrentThread(),
                UserThreadUseDesktop, &utudi, sizeof(utudi));
    }
}

VOID
UnsetActivePalette(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    USERTHREAD_USEDESKTOPINFO utudi;
    BOOL bReset = FALSE;

    if (GetCurrentThreadId() != ScreenInfo->Console->InputThreadInfo->ThreadId) {
        bReset = TRUE;
        utudi.hThread = ScreenInfo->Console->InputThreadInfo->ThreadHandle;
        utudi.drdRestore.pdeskRestore = NULL;
        NtUserSetInformationThread(NtCurrentThread(),
                UserThreadUseDesktop,
                &utudi, sizeof(utudi));
    }

    SetSystemPaletteUse(ScreenInfo->Console->hDC,
                        SYSPAL_STATIC
                       );
    RealizePalette(ScreenInfo->Console->hDC);


    if (bReset == TRUE) {
        utudi.hThread = NULL;
        NtUserSetInformationThread(NtCurrentThread(),
                UserThreadUseDesktop, &utudi, sizeof(utudi));
    }
}

NTSTATUS
ConvertToFullScreen(
    IN PCONSOLE_INFORMATION Console
    )
{
#ifdef i386
    PSCREEN_INFORMATION Cur;
    COORD WindowedWindowSize, WindowSize;

    // for each charmode screenbuffer
    //     match window size to a mode/font
    //     grow screen buffer if necessary
    //     save old window dimensions
    //     set new window dimensions

    for (Cur=Console->ScreenBuffers;Cur!=NULL;Cur=Cur->Next) {

        if (Cur->Flags & CONSOLE_GRAPHICS_BUFFER) {
            continue;
        }

        // save old window dimensions

        WindowedWindowSize.X = CONSOLE_WINDOW_SIZE_X(Cur);
        WindowedWindowSize.Y = CONSOLE_WINDOW_SIZE_Y(Cur);

        Cur->BufferInfo.TextInfo.WindowedWindowSize = WindowedWindowSize;
        Cur->BufferInfo.TextInfo.WindowedScreenSize = Cur->ScreenBufferSize;

        // match window size to a mode/font

        Cur->BufferInfo.TextInfo.ModeIndex = MatchWindowSize(
                Console->OutputCP,
                Cur->ScreenBufferSize, &WindowSize);

        // grow screen buffer if necessary

        if (WindowSize.X > Cur->ScreenBufferSize.X ||
            WindowSize.Y > Cur->ScreenBufferSize.Y) {
            COORD NewScreenSize;

            NewScreenSize.X = max(WindowSize.X, Cur->ScreenBufferSize.X);
            NewScreenSize.Y = max(WindowSize.Y, Cur->ScreenBufferSize.Y);

            if (ResizeScreenBuffer(Cur, NewScreenSize, FALSE) == STATUS_INVALID_HANDLE) {
                return STATUS_INVALID_HANDLE;
            }
        }

        //
        // Set new window dimensions.
        // We always resize horizontally from the right (change the
        // right edge).
        // We resize vertically from the bottom, keeping the cursor visible.
        //

        if (WindowedWindowSize.X != WindowSize.X) {
            Cur->Window.Right -= WindowedWindowSize.X - WindowSize.X;
            if (Cur->Window.Right >= Cur->ScreenBufferSize.X) {
                Cur->Window.Left -= Cur->Window.Right - Cur->ScreenBufferSize.X + 1;
                Cur->Window.Right -= Cur->Window.Right - Cur->ScreenBufferSize.X + 1;
            }
        }
        if (WindowedWindowSize.Y > WindowSize.Y) {
            Cur->Window.Bottom -= WindowedWindowSize.Y - WindowSize.Y;
            if (Cur->Window.Bottom >= Cur->ScreenBufferSize.Y) {
                Cur->Window.Top -= Cur->Window.Bottom - Cur->ScreenBufferSize.Y + 1;
                Cur->Window.Bottom = Cur->ScreenBufferSize.Y - 1;
            }
        } else if (WindowedWindowSize.Y < WindowSize.Y) {
            Cur->Window.Top -= WindowSize.Y - WindowedWindowSize.Y;
            if (Cur->Window.Top < 0) {
                Cur->Window.Bottom -= Cur->Window.Top;
                Cur->Window.Top = 0;
            }
        }
        if (Cur->BufferInfo.TextInfo.CursorPosition.Y > Cur->Window.Bottom) {
            Cur->Window.Top += Cur->BufferInfo.TextInfo.CursorPosition.Y - Cur->Window.Bottom;
            Cur->Window.Bottom = Cur->BufferInfo.TextInfo.CursorPosition.Y;
        }

        UserAssert(WindowSize.X == CONSOLE_WINDOW_SIZE_X(Cur));
        UserAssert(WindowSize.Y == CONSOLE_WINDOW_SIZE_Y(Cur));
        Cur->BufferInfo.TextInfo.MousePosition.X = Cur->Window.Left;
        Cur->BufferInfo.TextInfo.MousePosition.Y = Cur->Window.Top;

        if (Cur->Flags & CONSOLE_OEMFONT_DISPLAY) {
            DBGCHARS(("ConvertToFullScreen converts UnicodeOem -> Unicode\n"));
            FalseUnicodeToRealUnicode(
                    Cur->BufferInfo.TextInfo.TextRows,
                    Cur->ScreenBufferSize.X * Cur->ScreenBufferSize.Y,
                    Console->OutputCP);
        } else {
            DBGCHARS(("ConvertToFullScreen needs no conversion\n"));
        }
        DBGCHARS(("Cur->BufferInfo.TextInfo.Rows = %lx\n",
                Cur->BufferInfo.TextInfo.Rows));
        DBGCHARS(("Cur->BufferInfo.TextInfo.TextRows = %lx\n",
                Cur->BufferInfo.TextInfo.TextRows));
    }

    Cur = Console->CurrentScreenBuffer;

    if (Cur->Flags & CONSOLE_TEXTMODE_BUFFER) {
        if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
            PCONVERSIONAREA_INFORMATION ConvAreaInfo;
            ConvAreaInfo = Console->ConsoleIme.ConvAreaRoot;
            while (ConvAreaInfo) {
                NTSTATUS Status;

                Status = StoreTextBufferFontInfo(ConvAreaInfo->ScreenBuffer,
                                                 SCR_FONTNUMBER(Cur),
                                                 SCR_FONTSIZE(Cur),
                                                 SCR_FAMILY(Cur),
                                                 SCR_FONTWEIGHT(Cur),
                                                 SCR_FACENAME(Cur),
                                                 SCR_FONTCODEPAGE(Cur));
                if (!NT_SUCCESS(Status)) {
                    return((ULONG) Status);
                }

                ConvAreaInfo->ScreenBuffer->BufferInfo.TextInfo.ModeIndex = Cur->BufferInfo.TextInfo.ModeIndex;
                ConvAreaInfo = ConvAreaInfo->ConvAreaNext;
            }
        }
        Cur->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
    }

    SetWindowSize(Cur);
    WriteToScreen(Cur, &Console->CurrentScreenBuffer->Window);

#else
    UNREFERENCED_PARAMETER(Console);
#endif
    return STATUS_SUCCESS;
}

NTSTATUS
ConvertToWindowed(
    IN PCONSOLE_INFORMATION Console
    )
{
#ifdef i386
    PSCREEN_INFORMATION Cur;
    SMALL_RECT WindowedWindow;

    // for each charmode screenbuffer
    //     restore window dimensions

    for (Cur=Console->ScreenBuffers;Cur!=NULL;Cur=Cur->Next) {
        if ((Cur->Flags & CONSOLE_TEXTMODE_BUFFER) == 0) {
            continue;
        }

        if (ResizeScreenBuffer(Cur,
                           Cur->BufferInfo.TextInfo.WindowedScreenSize,
                           FALSE) == STATUS_INVALID_HANDLE) {
            /*
             * Something really went wrong. All we can do is just to
             * bail out.
             */
            return STATUS_INVALID_HANDLE;
        }

        WindowedWindow.Right  = Cur->Window.Right;
        WindowedWindow.Bottom = Cur->Window.Bottom;
        WindowedWindow.Left   = Cur->Window.Right + 1 -
                                Cur->BufferInfo.TextInfo.WindowedWindowSize.X;
        WindowedWindow.Top    = Cur->Window.Bottom + 1 -
                                Cur->BufferInfo.TextInfo.WindowedWindowSize.Y;
        if (WindowedWindow.Left > Cur->Window.Left) {
            WindowedWindow.Right -= WindowedWindow.Left - Cur->Window.Left;
            WindowedWindow.Left = Cur->Window.Left;
        }
        if (WindowedWindow.Right < Cur->BufferInfo.TextInfo.CursorPosition.X) {
            WindowedWindow.Left += Cur->BufferInfo.TextInfo.CursorPosition.X - WindowedWindow.Right;
            WindowedWindow.Right = Cur->BufferInfo.TextInfo.CursorPosition.X;
        }
        if (WindowedWindow.Top > Cur->Window.Top) {
            WindowedWindow.Bottom -= WindowedWindow.Top - Cur->Window.Top;
            WindowedWindow.Top = Cur->Window.Top;
        }
        if (WindowedWindow.Bottom < Cur->BufferInfo.TextInfo.CursorPosition.Y) {
            WindowedWindow.Top += Cur->BufferInfo.TextInfo.CursorPosition.Y - WindowedWindow.Bottom;
            WindowedWindow.Bottom = Cur->BufferInfo.TextInfo.CursorPosition.Y;
        }
        ResizeWindow(Cur, &WindowedWindow, FALSE);

        if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
            SetFont(Cur);
        }

        if (Cur->Flags & CONSOLE_OEMFONT_DISPLAY) {
            DBGCHARS(("ConvertToWindowed converts Unicode -> UnicodeOem\n"));
            RealUnicodeToFalseUnicode(
                    Cur->BufferInfo.TextInfo.TextRows,
                    Cur->ScreenBufferSize.X * Cur->ScreenBufferSize.Y,
                    Console->OutputCP);
        } else {
            DBGCHARS(("ConvertToWindowed needs no conversion\n"));
        }
        DBGCHARS(("Cur->BufferInfo.TextInfo.Rows = %lx\n",
                Cur->BufferInfo.TextInfo.Rows));
        DBGCHARS(("Cur->BufferInfo.TextInfo.TextRows = %lx\n",
                Cur->BufferInfo.TextInfo.TextRows));
    }

    Cur = Console->CurrentScreenBuffer;

    if (Cur->Flags & CONSOLE_TEXTMODE_BUFFER) {
        if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
            PCONVERSIONAREA_INFORMATION ConvAreaInfo;
            ConvAreaInfo = Console->ConsoleIme.ConvAreaRoot;
            while (ConvAreaInfo) {
                NTSTATUS Status;

                Status = StoreTextBufferFontInfo(ConvAreaInfo->ScreenBuffer,
                                                 SCR_FONTNUMBER(Cur),
                                                 SCR_FONTSIZE(Cur),
                                                 SCR_FAMILY(Cur),
                                                 SCR_FONTWEIGHT(Cur),
                                                 SCR_FACENAME(Cur),
                                                 SCR_FONTCODEPAGE(Cur));
                if (!NT_SUCCESS(Status)) {
                    return((ULONG) Status);
                }

                ConvAreaInfo->ScreenBuffer->BufferInfo.TextInfo.ModeIndex = Cur->BufferInfo.TextInfo.ModeIndex;
                ConvAreaInfo = ConvAreaInfo->ConvAreaNext;
            }
        }
        Cur->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
    }

    SetWindowSize(Cur);
    WriteToScreen(Cur, &Console->CurrentScreenBuffer->Window);

#else
    UNREFERENCED_PARAMETER(Console);
#endif
    return STATUS_SUCCESS;
}

ULONG
SrvSetConsoleDisplayMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Description:

    This routine sets the console display mode for an output buffer.
    This API is only supported on x86 machines.

Parameters:

    hConsoleOutput - Supplies a console output handle.

    dwFlags - Specifies the display mode. Options are:

        CONSOLE_FULLSCREEN_MODE - data is displayed fullscreen

        CONSOLE_WINDOWED_MODE - data is displayed in a window

    lpNewScreenBufferDimensions - On output, contains the new dimensions of
        the screen buffer.  The dimensions are in rows and columns for
        textmode screen buffers.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PCONSOLE_SETDISPLAYMODE_MSG a = (PCONSOLE_SETDISPLAYMODE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    PSCREEN_INFORMATION ScreenInfo;
    UINT State;
    HANDLE  hEvent = NULL;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = NtDuplicateObject(CONSOLE_CLIENTPROCESSHANDLE(),
                               a->hEvent,
                               NtCurrentProcess(),
                               &hEvent,
                               0,
                               FALSE,
                               DUPLICATE_SAME_ACCESS
                               );
    if (!NT_SUCCESS(Status)) {
        goto SrvSetConsoleDisplayModeFailure;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE | CONSOLE_GRAPHICS_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        ScreenInfo = HandleData->Buffer.ScreenBuffer;
        if (!ACTIVE_SCREEN_BUFFER(ScreenInfo))  {
            Status = STATUS_INVALID_PARAMETER;
            goto SrvSetConsoleDisplayModeFailure;
        }
        if (a->dwFlags == CONSOLE_FULLSCREEN_MODE) {
#if !defined(_X86_)
            if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
                Status = STATUS_INVALID_PARAMETER;
                goto SrvSetConsoleDisplayModeFailure;
            }
#else
            if (!FullScreenInitialized || GetSystemMetrics(SM_REMOTESESSION)) {
                Status = STATUS_INVALID_PARAMETER;
                goto SrvSetConsoleDisplayModeFailure;
            }
#endif
            if (Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
                KdPrint(("CONSRV: VDM converting to fullscreen twice\n"));
                Status = STATUS_SUCCESS;
                goto SrvSetConsoleDisplayModeFailure;
            }
            State = FULLSCREEN;
        } else {
            if (Console->FullScreenFlags == 0) {
                KdPrint(("CONSRV: VDM converting to windowed twice\n"));
                Status = STATUS_SUCCESS;
                goto SrvSetConsoleDisplayModeFailure;
            }
            State = WINDOWED;
        }
        Status = QueueConsoleMessage(Console,
                    CM_MODE_TRANSITION,
                    State,
                    (LPARAM)hEvent
                    );
        if (!NT_SUCCESS(Status)) {
            goto SrvSetConsoleDisplayModeFailure;
        }
    }
    UnlockConsole(Console);
    return Status;

SrvSetConsoleDisplayModeFailure:
    if (hEvent) {
        NtSetEvent(hEvent, NULL);
        NtClose(hEvent);
    }

    UnlockConsole(Console);
    return Status;
}

VOID
UnregisterVDM(
    IN PCONSOLE_INFORMATION Console
    )
{
// williamh, Feb 2 1994.
// catch multiple calls to unregister vdm. Believe it or not, this could
// happen
    //UserAssert(Console->Flags & CONSOLE_VDM_REGISTERED);
    if (!(Console->Flags & CONSOLE_VDM_REGISTERED))
        return;

#if defined(FE_SB) && defined(i386)
// When HDOS apps exit, console screen resolution is changed to 640*400. Because HBIOS set
// Screen resolution to 640*400. So, we should replace current screen resoultion(640*480).
// 09/11/96 bklee
    {

    if ((Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE)  &&
        ( Console->OutputCP == KOREAN_CP ||
         (Console->OutputCP == JAPAN_CP && ISNECPC98(gdwMachineId) ) )) {

         ULONG Index;
         DEVMODEW Devmode;
         BOOL fGraphics = fFullScreenGraphics ? IsAvailableFsCodePage(Console->OutputCP) : FALSE;

         Index = Console->CurrentScreenBuffer->BufferInfo.TextInfo.ModeIndex;

         ZeroMemory(&Devmode, sizeof(Devmode));

         Devmode.dmSize = sizeof(Devmode);
         Devmode.dmDriverExtra = 0;
         Devmode.dmFields = DM_BITSPERPEL   |
                            DM_PELSWIDTH    |
                            DM_PELSHEIGHT   |
                            DM_DISPLAYFLAGS;

         Devmode.dmBitsPerPel   = 4;

         Devmode.dmPelsWidth  = RegModeFontPairs[Index].Resolution.X;
         Devmode.dmPelsHeight = RegModeFontPairs[Index].Resolution.Y;
         Devmode.dmDisplayFlags = (fGraphics && (RegModeFontPairs[Index].Mode & FS_MODE_GRAPHICS)) ? 0 : DMDISPLAYFLAGS_TEXTMODE;

         GdiFullscreenControl(FullscreenControlSetMode,
                              &Devmode,
                              sizeof(Devmode),
                              NULL,
                              NULL);
    }
    }
#endif
#ifdef i386
    if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE &&
        Console->Flags & CONSOLE_CONNECTED_TO_EMULATOR) {
        NtUserConsoleControl(ConsoleSetVDMCursorBounds, NULL, 0);
        // connect emulator
        ConnectToEmulator(FALSE, Console);
    }

    if (FullScreenInitialized) {
        CloseHandle(Console->VDMStartHardwareEvent);
        CloseHandle(Console->VDMEndHardwareEvent);
        if (Console->VDMErrorHardwareEvent) {
            CloseHandle(Console->VDMErrorHardwareEvent);
            Console->VDMErrorHardwareEvent = NULL;
        }
        NtUnmapViewOfSection(NtCurrentProcess(), Console->StateBuffer);
        NtUnmapViewOfSection(Console->VDMProcessHandle, Console->StateBufferClient);
        NtClose(Console->StateSectionHandle);
        Console->StateLength = 0;
    }

#endif

    Console->Flags &= ~CONSOLE_VDM_REGISTERED;

    if (Console->Flags & CONSOLE_HAS_FOCUS) {
        USERTHREAD_FLAGS Flags;

        Flags.dwFlags = 0;
        Flags.dwMask = (TIF_VDMAPP | TIF_DOSEMULATOR);
        NtUserSetInformationThread(Console->InputThreadInfo->ThreadHandle,
                UserThreadFlags, &Flags, sizeof(Flags));
    }
    Console->Flags &= ~CONSOLE_WOW_REGISTERED;
    UserAssert(Console->VDMBuffer != NULL);
    if (Console->VDMBuffer != NULL) {
        NtUnmapViewOfSection(Console->VDMProcessHandle, Console->VDMBufferClient);
        NtUnmapViewOfSection(NtCurrentProcess(), Console->VDMBuffer);
        NtClose(Console->VDMBufferSectionHandle);
        Console->VDMBuffer = NULL;
    }
#ifdef i386
    if (Console->CurrentScreenBuffer &&
        Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) {
        Console->CurrentScreenBuffer->BufferInfo.TextInfo.MousePosition.X = 0;
        Console->CurrentScreenBuffer->BufferInfo.TextInfo.MousePosition.Y = 0;
    }
#endif
    UserAssert(Console->VDMProcessHandle);
    CloseHandle(Console->VDMProcessHandle);
    Console->VDMProcessHandle = NULL;

#if defined(FE_SB) && defined(FE_IME) && defined(i386)
    {
        if (Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
            Console->Flags |= CONSOLE_JUST_VDM_UNREGISTERED ;
        }
        else if (Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) {
            AdjustCursorPosition(Console->CurrentScreenBuffer,
                                 Console->CurrentScreenBuffer->BufferInfo.TextInfo.CursorPosition,
                                 TRUE,
                                 NULL);
        }
    }
#endif
}

ULONG
SrvRegisterConsoleVDM(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_REGISTERVDM_MSG a = (PCONSOLE_REGISTERVDM_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    SIZE_T ViewSize;
    VDM_QUERY_VDM_PROCESS_DATA QueryVdmProcessData;
#ifdef i386
    VIDEO_REGISTER_VDM RegisterVdm;
    ULONG RegisterVdmSize = sizeof(RegisterVdm);
    VIDEO_VDM Vdm;
#endif  //i386

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // First make sure the caller is a VDM process
    //

    QueryVdmProcessData.ProcessHandle = CONSOLE_CLIENTPROCESSHANDLE();
    Status = NtVdmControl(VdmQueryVdmProcess, &QueryVdmProcessData);
    if (!NT_SUCCESS(Status) || QueryVdmProcessData.IsVdmProcess == FALSE) {
        UnlockConsole(Console);
        return STATUS_ACCESS_DENIED;
    }

    if (a->RegisterFlags & CONSOLE_REGISTER_VDM) {
        ConsoleNotifyWinEvent(Console,
                              EVENT_CONSOLE_START_APPLICATION,
                              HandleToUlong(CONSOLE_CLIENTPROCESSID()),
                              CONSOLE_APPLICATION_16BIT);
    } else if (a->RegisterFlags == 0) {
        ConsoleNotifyWinEvent(Console,
                              EVENT_CONSOLE_END_APPLICATION,
                              HandleToUlong(CONSOLE_CLIENTPROCESSID()),
                              CONSOLE_APPLICATION_16BIT);
    }


    if (!a->RegisterFlags) {
//      williamh, Jan 28 1994
//      do not do an assert here because we may have unregistered the ntvdm
//      and the ntvdm doesn't necessarily know this(and it could post another
//      unregistervdm). Return error here so NTVDM knows what to do
//      UserAssert(Console->Flags & CONSOLE_VDM_REGISTERED);

        if (Console->Flags & CONSOLE_VDM_REGISTERED) {
            UserAssert(!(Console->Flags & CONSOLE_FULLSCREEN_NOPAINT));
            UnregisterVDM(Console);
#ifdef i386
            if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE &&
                Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) {
                // SetVideoMode(Console->CurrentScreenBuffer);
                // Set up cursor
                SetCursorInformationHW(Console->CurrentScreenBuffer,
                                       Console->CurrentScreenBuffer->BufferInfo.TextInfo.CursorSize,
                                       Console->CurrentScreenBuffer->BufferInfo.TextInfo.CursorVisible);
                SetCursorPositionHW(Console->CurrentScreenBuffer,
                                    Console->CurrentScreenBuffer->BufferInfo.TextInfo.CursorPosition);
            }
#endif // i386
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_ACCESS_DENIED;
        }
        UnlockConsole(Console);
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->VDMBufferSectionName, a->VDMBufferSectionNameLength, sizeof(BYTE))) {

        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    // check it out. A console should have only one VDM registered.
    UserAssert(!(Console->Flags & CONSOLE_VDM_REGISTERED));

    if (Console->Flags & CONSOLE_VDM_REGISTERED) {
        UnlockConsole(Console);
        return (ULONG) STATUS_ACCESS_DENIED;
    }

    UserAssert(!Console->VDMProcessHandle);

    Status = NtDuplicateObject(NtCurrentProcess(), CONSOLE_CLIENTPROCESSHANDLE(),
                               NtCurrentProcess(), &Console->VDMProcessHandle,
                               0, FALSE, DUPLICATE_SAME_ACCESS);
    if (!NT_SUCCESS(Status)) {
        UnlockConsole(Console);
        return Status;
    }
    Console->VDMProcessId = CONSOLE_CLIENTPROCESSID();

#ifdef i386

    Vdm.ProcessHandle = Console->VDMProcessHandle;

    //
    // Assume fullscreen initialization will fail.
    // have state length set to zero so that NTVDM will know
    // full screen is disabled.
    //

    a->StateLength = 0;
    Console->StateLength = 0;
    Console->StateBufferClient = NULL;
    Console->VDMErrorHardwareEvent = NULL;

    if (FullScreenInitialized) {

        Status = NtDuplicateObject(CONSOLE_CLIENTPROCESSHANDLE(),
                                   a->StartEvent,
                                   NtCurrentProcess(),
                                   &Console->VDMStartHardwareEvent,
                                   0,
                                   FALSE,
                                   DUPLICATE_SAME_ACCESS
                                  );
        if (NT_SUCCESS(Status)) {
            Status = NtDuplicateObject(CONSOLE_CLIENTPROCESSHANDLE(),
                                       a->EndEvent,
                                       NtCurrentProcess(),
                                       &Console->VDMEndHardwareEvent,
                                       0,
                                       FALSE,
                                       DUPLICATE_SAME_ACCESS
                                      );
            if (NT_SUCCESS(Status)) {
                if (a->ErrorEvent) {
                    Status = NtDuplicateObject(CONSOLE_CLIENTPROCESSHANDLE(),
                                               a->ErrorEvent,
                                               NtCurrentProcess(),
                                               &Console->VDMErrorHardwareEvent,
                                               0,
                                               FALSE,
                                               DUPLICATE_SAME_ACCESS
                                              );
                }
                if (NT_SUCCESS(Status)) {
                    Status = GdiFullscreenControl(FullscreenControlRegisterVdm,
                                                  &Vdm,
                                                  sizeof(Vdm),
                                                  &RegisterVdm,
                                                  &RegisterVdmSize
                                                 );

                    if (NT_SUCCESS(Status)) {

                        //
                        // create state section and map a view of it into server and vdm.
                        // this section is used to get/set video hardware state during
                        // the fullscreen<->windowed transition.  we create the section
                        // instead of the vdm for security purposes.
                        //

                        Status = MapViewOfSection(&Console->StateSectionHandle,
                                                  RegisterVdm.MinimumStateSize,
                                                  &Console->StateBuffer,
                                                  &ViewSize,
                                                  Console->VDMProcessHandle,
                                                  &a->StateBuffer
                                                 );

                        if (NT_SUCCESS(Status)) {
                            a->StateLength = RegisterVdm.MinimumStateSize;
                            Console->StateLength = RegisterVdm.MinimumStateSize;
                            Console->StateBufferClient = a->StateBuffer;
                        } else {
                            CloseHandle(Console->VDMStartHardwareEvent);
                            CloseHandle(Console->VDMEndHardwareEvent);
                            if (Console->VDMErrorHardwareEvent) {
                                CloseHandle(Console->VDMErrorHardwareEvent);
                            }
                        }

                    } else {

                        CloseHandle(Console->VDMStartHardwareEvent);
                        CloseHandle(Console->VDMEndHardwareEvent);
                        if (Console->VDMErrorHardwareEvent) {
                            CloseHandle(Console->VDMErrorHardwareEvent);
                        }
                    }
                } else {
                    CloseHandle(Console->VDMStartHardwareEvent);
                    CloseHandle(Console->VDMEndHardwareEvent);
                }

            } else {

                CloseHandle(Console->VDMStartHardwareEvent);
            }

        }

        //
        // If we failed to duplicate screen switch events or map
        // view to video state shared buffer, fail this API.
        //
        if (!NT_SUCCESS(Status)) {
            UnlockConsole(Console);
            return Status;
        }
    }

#endif // i386

    //
    // Create vdm char section and map a view of it into server and vdm.
    // This section is used by the vdm to update the screen when in a
    // charmode window. This is a performance optimization. We create
    // the section instead of the vdm for security purposes.
    //

    Status = MapViewOfSection(&Console->VDMBufferSectionHandle,
#ifdef i386
                              a->VDMBufferSize.X * a->VDMBufferSize.Y * 2,
#else
                              a->VDMBufferSize.X * a->VDMBufferSize.Y * 4,
#endif // i386
                              &Console->VDMBuffer,
                              &ViewSize,
                              Console->VDMProcessHandle,
                              &a->VDMBuffer
                             );
    if (!NT_SUCCESS(Status)) {

        Console->VDMBuffer = NULL;

#ifdef i386

        if (FullScreenInitialized) {

            NtUnmapViewOfSection(NtCurrentProcess(), Console->StateBuffer);
            NtUnmapViewOfSection(Console->VDMProcessHandle, Console->StateBufferClient);
            NtClose(Console->StateSectionHandle);
            CloseHandle(Console->VDMStartHardwareEvent);
            CloseHandle(Console->VDMEndHardwareEvent);
            if (Console->VDMErrorHardwareEvent) {
                CloseHandle(Console->VDMErrorHardwareEvent);
            }
        }

#endif // i386
        CloseHandle(Console->VDMProcessHandle);
        Console->VDMProcessHandle = NULL;
        UnlockConsole(Console);
        return Status;
    }
    Console->VDMBufferClient = a->VDMBuffer;

    Console->Flags |= CONSOLE_VDM_REGISTERED;

    if (Console->Flags & CONSOLE_HAS_FOCUS) {
        USERTHREAD_FLAGS Flags;

        Flags.dwFlags = TIF_VDMAPP;
        Flags.dwMask = TIF_VDMAPP;
        NtUserSetInformationThread(Console->InputThreadInfo->ThreadHandle,
                                   UserThreadFlags,
                                   &Flags,
                                   sizeof(Flags));
    }
    Console->VDMBufferSize = a->VDMBufferSize;

    if (a->RegisterFlags & CONSOLE_REGISTER_WOW) {
        Console->Flags |= CONSOLE_WOW_REGISTERED;
    } else {
        Console->Flags &= ~CONSOLE_WOW_REGISTERED;
    }

    //
    // If we're already in fullscreen and we run a DOS app for
    // the first time, connect the emulator.
    //

#ifdef i386
    if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
        RECT CursorRect = {-32767, -32767, 32767, 32767};
        NtUserConsoleControl(ConsoleSetVDMCursorBounds, &CursorRect, sizeof(RECT));

        UserAssert(!(Console->Flags & CONSOLE_CONNECTED_TO_EMULATOR));
        ConnectToEmulator(TRUE, Console);
    }
#endif

    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

NTSTATUS
SrvConsoleNotifyLastClose(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_NOTIFYLASTCLOSE_MSG a = (PCONSOLE_NOTIFYLASTCLOSE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Don't allow two or more processes to have last-close notify on
    // the same console.
    //
    if (Console->Flags & CONSOLE_NOTIFY_LAST_CLOSE) {
        UnlockConsole(Console);
        return STATUS_ACCESS_DENIED;
    }

    Status = NtDuplicateObject(NtCurrentProcess(), CONSOLE_CLIENTPROCESSHANDLE(),
                               NtCurrentProcess(),
                               &Console->hProcessLastNotifyClose,
                               0, FALSE, DUPLICATE_SAME_ACCESS
                               );
    if (!NT_SUCCESS(Status)) {
        UnlockConsole(Console);
        return Status;
    }

    Console->Flags |= CONSOLE_NOTIFY_LAST_CLOSE;
    Console->ProcessIdLastNotifyClose = CONSOLE_CLIENTPROCESSID();
    UnlockConsole(Console);
    return Status;
}

NTSTATUS
MapViewOfSection(
    PHANDLE SectionHandle,
    ULONG CommitSize,
    PVOID *BaseAddress,
    PSIZE_T ViewSize,
    HANDLE ClientHandle,
    PVOID *BaseClientAddress
    )
{

    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    LARGE_INTEGER secSize;

    //
    // open section and map a view of it.
    //
    InitializeObjectAttributes(
        &Obja,
        NULL,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    secSize.QuadPart = CommitSize;
    Status = NtCreateSection (SectionHandle,
                              SECTION_ALL_ACCESS,
                              &Obja,
                              &secSize,
                              PAGE_READWRITE,
                              SEC_RESERVE,
                              NULL
                             );
    if (!NT_SUCCESS(Status)) {
        return((ULONG) Status);
    }

    *BaseAddress = 0;
    *ViewSize = 0;

    Status = NtMapViewOfSection(*SectionHandle,
                                NtCurrentProcess(),
                                BaseAddress,        // Receives the base
                                                    // address of the section.

                                0,                  // No specific type of
                                                    // address required.

                                CommitSize,         // Commit size. It was
                                                    // passed by the caller.
                                                    // NULL for a save, and
                                                    // size of the section
                                                    // for a set.

                                NULL,               // Section offset it NULL;
                                                    // Map from the start.

                                ViewSize,           // View Size is NULL since
                                                    // we want to map the
                                                    // entire section.

                                ViewUnmap,
                                0L,
                                PAGE_READWRITE
                               );
    if (!NT_SUCCESS(Status)) {
        NtClose(*SectionHandle);
        return Status;
    }

    *BaseClientAddress = 0;
    *ViewSize = 0;
    Status = NtMapViewOfSection(*SectionHandle,
                                ClientHandle,
                                BaseClientAddress,  // Receives the base
                                                    // address of the section.

                                0,                  // No specific type of
                                                    // address required.

                                CommitSize,         // Commit size. It was
                                                    // passed by the caller.
                                                    // NULL for a save, and
                                                    // size of the section
                                                    // for a set.

                                NULL,               // Section offset it NULL;
                                                    // Map from the start.

                                ViewSize,           // View Size is NULL since
                                                    // we want to map the
                                                    // entire section.

                                ViewUnmap,
// williamh, Jan 28 1994
// This MEM_TOP_DOWN is necessary.
// if the console has VDM registered, ntvdm would have released its video memory
// address space(0xA0000 ~ 0xBFFFF). Without the MEM_TOP_DOWN, the
// NtMapViewOfSection can grab the address space and we will have trouble of
// mapping the address space to the physical video ram. We don't do a test
// for VDM because there is no harm of doing this for non-vdm application.
                                MEM_TOP_DOWN,
                                PAGE_READWRITE
                               );
    if (!NT_SUCCESS(Status)) {
        NtUnmapViewOfSection(NtCurrentProcess(), *BaseAddress);
        NtClose(*SectionHandle);
    }
    return((ULONG) Status);
}

NTSTATUS
ConnectToEmulator(
    IN BOOL Connect,
    IN PCONSOLE_INFORMATION Console
    )
{
    NTSTATUS Status;
    FULLSCREENCONTROL fsctl;
    VIDEO_VDM ConnectInfo;
    HANDLE ProcessHandle = Console->VDMProcessHandle;
    USERTHREAD_FLAGS Flags;

    DBGFULLSCR(("ConnectToEmulator :  %s - entering\n", Connect ? "CONNECT" : "DISCONNECT"));

    Flags.dwMask = TIF_DOSEMULATOR;
    if (Connect) {
        fsctl = FullscreenControlEnable;
        UserAssert((Console->Flags & CONSOLE_CONNECTED_TO_EMULATOR) == 0);
        Console->Flags |= CONSOLE_CONNECTED_TO_EMULATOR;
        Flags.dwFlags = TIF_DOSEMULATOR;
#if DBG
        RtlWalkFrameChain(Console->ConnectStack,
                          ARRAY_SIZE(Console->ConnectStack),
                          0);
#endif
    } else {
        fsctl = FullscreenControlDisable;
        UserAssert((Console->Flags & CONSOLE_CONNECTED_TO_EMULATOR) != 0);
        Console->Flags &= ~CONSOLE_CONNECTED_TO_EMULATOR;
        Flags.dwFlags = 0;
#if DBG
        RtlWalkFrameChain(Console->DisconnectStack,
                          ARRAY_SIZE(Console->DisconnectStack),
                          0);
#endif
    }

    if (Console->Flags & CONSOLE_HAS_FOCUS) {
        NtUserSetInformationThread(Console->InputThreadInfo->ThreadHandle,
                UserThreadFlags, &Flags, sizeof(Flags));
    }

    ConnectInfo.ProcessHandle = ProcessHandle;


    Status = GdiFullscreenControl(fsctl,
                                  &ConnectInfo,
                                  sizeof(ConnectInfo),
                                  NULL,
                                  NULL);

    UserAssert(Status == STATUS_SUCCESS ||
               Status == STATUS_CONFLICTING_ADDRESSES ||
               Status == STATUS_PROCESS_IS_TERMINATING);

    DBGFULLSCR(("ConnectToEmulator : leaving, staus = %08lx\n", Status));

    return Status;
}

#define CONSOLE_VDM_TIMEOUT 20000
#ifdef i386
VOID
LockConsoleForCurrentThread(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD Count)
{
    while (Console->ConsoleLock.RecursionCount != Count) {
        LockConsole(Console);
    }
}
DWORD
UnlockConsoleForCurrentThread(
    IN PCONSOLE_INFORMATION Console)
{
    DWORD Count, i;

    Count = Console->ConsoleLock.RecursionCount;
    ASSERT(Count > 0);
    for (i = 0; i < Count; i++) {
        UnlockConsole(Console);
    }
    return Count;
}
#endif

NTSTATUS
DisplayModeTransition(
    IN BOOL bForeground,
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
#ifdef i386
    NTSTATUS Status;
    LARGE_INTEGER li;
    DWORD WaitCount;
    HANDLE WaitHandles[2];

    if (!FullScreenInitialized || GetSystemMetrics(SM_REMOTESESSION)) {
        return STATUS_SUCCESS;
    }

    WaitCount = 1;
    WaitHandles[0] = Console->VDMEndHardwareEvent;
    if (Console->VDMErrorHardwareEvent) {
        WaitHandles[1] = Console->VDMErrorHardwareEvent;
        WaitCount++;
    }


    if (bForeground) {
        if (!(Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
            KdPrint(("CONSRV: received fullscreen message too early\n"));
            return STATUS_UNSUCCESSFUL;
        }

    } else {

        //
        // Check first to see if we're not already fullscreen. If we aren't,
        // don't allow this. Temporary BETA fix till USER gets fixed.
        //
        if (!(Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE)) {
            KdPrint(("CONSRV: received multiple windowed messages\n"));
            return STATUS_SUCCESS;
        }
    }

    //
    // Before actually doing any mode switching work, notify ntvdm to give it
    // a chance to bring all threads to a stoppable state.
    //

    if (Console->Flags & CONSOLE_VDM_REGISTERED) {

        //
        // make a special case for ntvdm during switching because
        // ntvdm has to suspend its main thread which may be making
        // console api calls before it can be suspended.
        //
        HANDLE ConsoleHandle = Console->ConsoleHandle;
        NTSTATUS Statusx;

        //
        // Make timeout longer than usual.  It will take long to
        // stop ntvdm threads under stress.
        //
        li.QuadPart = (LONGLONG)-10000 * CONSOLE_VDM_TIMEOUT * 3;
        Status = NtSetEvent(Console->VDMStartHardwareEvent, NULL);
        if (NT_SUCCESS(Status)) {
            HANDLE OwningThread;
            DWORD  RecursionCount;

            //
            // After notifying ntvdm to do screen switch, we must release
            // console locks to avoid deadlock.  Before doing so, we need to
            // remember how many locks are released and who releases them, in
            // case that we fail to get the locks back.
            //
            OwningThread = Console->ConsoleLock.OwningThread;
            Console->UnlockConsoleOwningThread = OwningThread;
            RecursionCount = UnlockConsoleForCurrentThread(Console);
            Status = NtWaitForMultipleObjects(WaitCount, WaitHandles, WaitAny, FALSE, &li);
            Statusx = RevalidateConsole(ConsoleHandle, &Console);
            if (!NT_SUCCESS(Statusx)) {
                Console->UnlockConsoleSkipCount = RecursionCount;
                NtSetEvent(Console->VDMErrorHardwareEvent, NULL);
                return Statusx;
            }

            //
            // Get back the original number of locks.  Since the lock is owned
            // by us already (by calling RevalidateConsole), the following call
            // simply increases the recursion count of the lock.
            //
            LockConsoleForCurrentThread(Console, RecursionCount);
            Console->UnlockConsoleOwningThread = NULL;
        }

        if (Status != 0) {
           Console->Flags &= ~CONSOLE_FULLSCREEN_NOPAINT;
           NtSetEvent(Console->VDMErrorHardwareEvent, NULL);
           UnregisterVDM(Console);
           KdPrint(("CONSRV: VDM not responding to initial request.\n"));
        }
    }

    if (bForeground) {
        PSCREEN_INFORMATION ScreenInfo = Console->CurrentScreenBuffer;
        NTSTATUS Status;

        KdPrint(("    CONSRV - Display Mode transition to fullscreen \n"));

        Console->FullScreenFlags |= CONSOLE_FULLSCREEN_HARDWARE;

        //
        // Fire off an event to let accessibility apps know the layout has
        // changed. We only want to do this while going *to* full-screen;
        // on the way back we'll send this event from InternalUpdateScrollBars.
        //
        ConsoleNotifyWinEvent(ScreenInfo->Console,
                              EVENT_CONSOLE_LAYOUT,
                              0,
                              0);
        if (!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER)) {
#if defined(FE_SB)
            BOOL fGraphics = fFullScreenGraphics ? IsAvailableFsCodePage(Console->OutputCP) : FALSE;
#endif
#if 1
            DEVMODEW Devmode;
            ULONG Index;

            Index = Console->CurrentScreenBuffer->BufferInfo.TextInfo.ModeIndex;

            //
            // set mode to go to full screen
            //

            ZeroMemory(&Devmode, sizeof(Devmode));

            Devmode.dmSize = sizeof(Devmode);
            Devmode.dmDriverExtra = 0;
            Devmode.dmFields = DM_BITSPERPEL   |
                               DM_PELSWIDTH    |
                               DM_PELSHEIGHT   |
                               DM_DISPLAYFLAGS;

            Devmode.dmBitsPerPel   = 4;
#if defined(FE_SB)
            Devmode.dmPelsWidth    = RegModeFontPairs[Index].Resolution.X;
            Devmode.dmPelsHeight   = RegModeFontPairs[Index].Resolution.Y;
            Devmode.dmDisplayFlags = (fGraphics && (RegModeFontPairs[Index].Mode & FS_MODE_GRAPHICS)) ? 0 : DMDISPLAYFLAGS_TEXTMODE;
#else
            Devmode.dmPelsWidth    = ModeFontPairs[Index].Resolution.X;
            Devmode.dmPelsHeight   = ModeFontPairs[Index].Resolution.Y;
            Devmode.dmDisplayFlags = DMDISPLAYFLAGS_TEXTMODE;
#endif

            if (NT_SUCCESS(GdiFullscreenControl(FullscreenControlSetMode,
                                                   &Devmode,
                                                   sizeof(Devmode),
                                                   NULL,
                                                   NULL)))
            {
#endif
                // set video mode and font
                if (SetVideoMode(ScreenInfo)) {

#if defined(FE_SB)
                    if (!(Console->Flags & CONSOLE_VDM_REGISTERED)) {
                        int     i ;
                        for (i = 0 ; i < ScreenInfo->ScreenBufferSize.Y; i++) {
                            ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.OldLeft = INVALID_OLD_LENGTH ;
                            ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.OldRight = INVALID_OLD_LENGTH ;
                        }
                    }
#endif
                    //set up cursor

                    SetCursorInformationHW(ScreenInfo,
                                    ScreenInfo->BufferInfo.TextInfo.CursorSize,
                                    ScreenInfo->BufferInfo.TextInfo.CursorVisible);
                    SetCursorPositionHW(ScreenInfo,
                                    ScreenInfo->BufferInfo.TextInfo.CursorPosition);
                }
            }
        }

        // tell VDM to unmap memory

        if (Console->Flags & CONSOLE_VDM_REGISTERED) {

            //
            // Increase the regular timeout value, since ntvdm needs to
            // do A LOT of transitions between kernel mode and user mode
            // to collect the video state information. (During stress, it may
            // take a long time.)
            //

            li.QuadPart = (LONGLONG)-10000 * CONSOLE_VDM_TIMEOUT * 3;
            Status = NtSetEvent(Console->VDMStartHardwareEvent, NULL);
            if (NT_SUCCESS(Status)) {
                Status = NtWaitForMultipleObjects(WaitCount, WaitHandles, WaitAny, FALSE, &li);
            }
            if (Status != 0) {
               Console->Flags &= ~CONSOLE_FULLSCREEN_NOPAINT;
               NtSetEvent(Console->VDMErrorHardwareEvent, NULL);
               UnregisterVDM(Console);
               KdPrint(("CONSRV: VDM not responding or in error state.\n"));
            }
        }

        if (!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER)) {

            WriteRegionToScreen(ScreenInfo, &ScreenInfo->Window);
        }

        if (Console->Flags & CONSOLE_VDM_REGISTERED) {

            // connect emulator and map memory into the VDMs address space.
            UserAssert(!(Console->Flags & CONSOLE_CONNECTED_TO_EMULATOR));

            Status = ConnectToEmulator(TRUE, Console);

            if (NT_SUCCESS(Status)) {

                VIDEO_HARDWARE_STATE State;
                ULONG StateSize = sizeof(State);

                State.StateHeader = Console->StateBuffer;
                State.StateLength = Console->StateLength;


                Status = GdiFullscreenControl(FullscreenControlRestoreHardwareState,
                                                 &State,
                                                 StateSize,
                                                 &State,
                                                 &StateSize);
            }

            if (Status != STATUS_SUCCESS) {
                Console->Flags &= ~CONSOLE_FULLSCREEN_NOPAINT;
                NtSetEvent(Console->VDMErrorHardwareEvent, NULL);
                UnregisterVDM(Console);
                KdPrint(("CONSRV: set hardware state failed.\n"));
            } else {

                //
                // tell VDM that it's getting the hardware.
                //

                RECT CursorRect;
                CursorRect.left = -32767;
                CursorRect.top = -32767;
                CursorRect.right = 32767;
                CursorRect.bottom = 32767;
                NtUserConsoleControl(ConsoleSetVDMCursorBounds,
                        &CursorRect, sizeof(RECT));

                //
                // wait for vdm to say ok. We could initiate another switch
                // (set hStartHardwareEvent which vdm is now waiting for to
                // complete the handshaking) when we return (WM_FULLSCREEN
                // could be in the message queue already). If we don't wait
                // for vdm to get signaled here, the hStartHardwareEvent
                // can get set twice and signaled once so the vdm will never
                // gets the newly switch request we may post after return.
                //
                // Also, we can not simply continue if timeout or error occurs.
                // We could set hStartHardwareEvent twice if a new mode switch
                // request is in our queue.  This will cause us and ntvdm
                // out of sync.
                //

                li.QuadPart = (LONGLONG)-10000 * CONSOLE_VDM_TIMEOUT;
                NtSetEvent(Console->VDMStartHardwareEvent, NULL);
                Status = NtWaitForMultipleObjects(WaitCount, WaitHandles, WaitAny, FALSE, &li);
                if (Status != 0) {
                   Console->Flags &= ~CONSOLE_FULLSCREEN_NOPAINT;
                   NtSetEvent(Console->VDMErrorHardwareEvent, NULL);
                   UnregisterVDM(Console);
                   KdPrint(("CONSRV: VDM not responding or in error state.\n"));
                }
            }
        }

        //
        // let the app know that it has the focus.
        //

        HandleFocusEvent(Console, TRUE);

        // unset palette

        if (ScreenInfo->hPalette != NULL) {
            SelectPalette(ScreenInfo->Console->hDC,
                             ScreenInfo->Console->hSysPalette,
                             FALSE);
            UnsetActivePalette(ScreenInfo);
        }
        SetConsoleReserveKeys(Console->hWnd, Console->ReserveKeys);
        HandleFocusEvent(Console, TRUE);

    } else {

        KdPrint(("    CONSRV - Display Mode transition to windowed \n"));

        // turn off mouse pointer so VDM doesn't see it when saving
        // hardware
        if (!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER)) {
            ReverseMousePointer(ScreenInfo, &ScreenInfo->Window);
        }


        Console->FullScreenFlags &= ~CONSOLE_FULLSCREEN_HARDWARE;
        if (Console->Flags & CONSOLE_VDM_REGISTERED) {

            //
            // tell vdm that it's losing the hardware
            //

            li.QuadPart = (LONGLONG)-10000 * CONSOLE_VDM_TIMEOUT;
            Status = NtSetEvent(Console->VDMStartHardwareEvent, NULL);
            if (NT_SUCCESS(Status)) {
                Status = NtWaitForMultipleObjects(WaitCount, WaitHandles, WaitAny, FALSE, &li);
                if (Status == STATUS_TIMEOUT || Status == 1) {
                    Status = STATUS_UNSUCCESSFUL;
                }
            }

            // if ntvdm didn't respond or we failed to save the video hardware
            // states, kick ntvdm out of our world. The ntvdm process eventually
            // would die but what choice do have here?

            if (NT_SUCCESS(Status)) {
                VIDEO_HARDWARE_STATE State;
                ULONG StateSize = sizeof(State);

                State.StateHeader = Console->StateBuffer;
                State.StateLength = Console->StateLength;


                Status = GdiFullscreenControl(FullscreenControlSaveHardwareState,
                                              &State,
                                              StateSize,
                                              &State,
                                              &StateSize);
            }

            if (NT_SUCCESS(Status)) {
                NtUserConsoleControl(ConsoleSetVDMCursorBounds, NULL, 0);

                // disconnect emulator and unmap video memory

                UserAssert(Console->Flags & CONSOLE_CONNECTED_TO_EMULATOR);
                ConnectToEmulator(FALSE, Console);

            } else {

                Console->Flags &= ~CONSOLE_FULLSCREEN_NOPAINT;
                NtSetEvent(Console->VDMErrorHardwareEvent, NULL);
                UnregisterVDM(Console);
                if (Status != 0) {
                    KdPrint(("CONSRV: VDM not responding.\n"));
                } else {
                    KdPrint(("CONSRV: Save Video States Failed\n"));
                }
            }
        }

        // tell VDM to map memory

        if (Console->Flags & CONSOLE_VDM_REGISTERED) {

            // make a special case for ntvdm during switching because
            // ntvdm has to make console api calls. We don't want to
            // unlock the console at this moment because as soon as
            // we release the lock, other theads which are waiting
            // for the lock will claim the lock and the ntvdm thread doing
            // the screen switch will have to wait for the lock. In an
            // extreme case, the following NtWaitForSingleObject will time
            // out because the ntvdm may be still waiting for the lock.
            // We keep this thing in a single global variable because
            // there is only one process who can own the screen at any moment.

            RtlEnterCriticalSection(&ConsoleVDMCriticalSection);
            ConsoleVDMOnSwitching = Console;
            RtlLeaveCriticalSection(&ConsoleVDMCriticalSection);

            //
            // Increase the regular timeout value, since ntvdm needs to
            // do A LOT of transitions between kernel mode and user mode
            // before it can signal console back. (During stress, it may
            // take a long time.)
            //

            li.QuadPart = (LONGLONG)-10000 * CONSOLE_VDM_TIMEOUT * 3;
            Status = NtSetEvent(Console->VDMStartHardwareEvent, NULL);
            if (NT_SUCCESS(Status)) {
                Status = NtWaitForMultipleObjects(WaitCount, WaitHandles, WaitAny, FALSE, &li);
            }

            // time to go back to normal
            RtlEnterCriticalSection(&ConsoleVDMCriticalSection);
            ConsoleVDMOnSwitching = NULL;
            RtlLeaveCriticalSection(&ConsoleVDMCriticalSection);

            if (Status != 0) {
                Console->Flags &= ~CONSOLE_FULLSCREEN_NOPAINT;
                NtSetEvent(Console->VDMErrorHardwareEvent, NULL);
                UnregisterVDM(Console);
                KdPrint(("CONSRV: VDM not responding. - second wait\n"));
                return Status;
            }
            ScreenInfo = Console->CurrentScreenBuffer;
        }

        // set palette

        if (ScreenInfo->hPalette != NULL) {
            SelectPalette(ScreenInfo->Console->hDC,
                             ScreenInfo->hPalette,
                             FALSE);
            SetActivePalette(ScreenInfo);
        }
        SetConsoleReserveKeys(Console->hWnd, CONSOLE_NOSHORTCUTKEY);
        HandleFocusEvent(Console, FALSE);

    }

    /*
     * Boost or lower the priority if we are going fullscreen or away.
     *
     * Note that console usually boosts and lowers its priority based on
     * WM_FOCUS and WM_KILLFOCUS but when you switch to full screen the
     * implementation actually sends a WM_KILLFOCUS so we reboost the
     * correct console here.
     */
    ModifyConsoleProcessFocus(Console, bForeground);
#else
    UNREFERENCED_PARAMETER(bForeground);
    UNREFERENCED_PARAMETER(Console);
    UNREFERENCED_PARAMETER(ScreenInfo);
#endif

    return STATUS_SUCCESS;
}
#if defined(_X86_)

BOOL
SetVideoMode(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    NTSTATUS Status;
    UINT i, j;

#if defined(FE_SB)
    //
    // load RAM font
    //

    Status = SetRAMFontCodePage(ScreenInfo);
#endif

    //
    // load ROM font
    //

    Status = SetROMFontCodePage(ScreenInfo->Console->OutputCP,
                                ScreenInfo->BufferInfo.TextInfo.ModeIndex);

    if (Status == STATUS_INVALID_PARAMETER) {
        Status = SetROMFontCodePage(GetOEMCP(),
                                    ScreenInfo->BufferInfo.TextInfo.ModeIndex);

        if (Status == STATUS_INVALID_PARAMETER) {
            Status = SetROMFontCodePage(CONSOLE_DEFAULT_ROM_FONT,
                                        ScreenInfo->BufferInfo.TextInfo.ModeIndex);
        }
    }

    //
    // initialize palette
    //

#if defined(FE_SB)
    Status = GdiFullscreenControl(FullscreenControlSetPalette,
                                  (PVOID) RegInitialPalette,
                                  RegInitialPalette[0] * sizeof(USHORT) + sizeof(DWORD),
                                  NULL,
                                  NULL);
#else
    Status = GdiFullscreenControl(FullscreenControlSetPalette,
                                  (PVOID) &InitialPalette,
                                  sizeof (InitialPalette),
                                  NULL,
                                  NULL);
#endif

    if (Status != STATUS_SUCCESS) {
        RIPMSG1(RIP_WARNING, "FullscreenControlSetPalette failed - Status = 0x%x",
                Status);
        return FALSE;
    }

    //
    // initialize color table
    //

#if defined(FE_SB)
    if (RegColorBufferNoTranslate)
    {
        Status = GdiFullscreenControl(FullscreenControlSetColors,
                                      (PVOID) RegColorBufferNoTranslate,
                                      RegColorBufferNoTranslate[0] * sizeof(DWORD) + sizeof(DWORD),
                                      NULL,
                                      NULL);
    }
    else
    {
        for (i = 0, j = 4; i < 16; i++) {
            RegColorBuffer[j++] = ((((GetRValue(ScreenInfo->Console->ColorTable[i]) +
                                      0x2A) * 0x02) / 0x55) * 0x15) / 0x02;
            RegColorBuffer[j++] = ((((GetGValue(ScreenInfo->Console->ColorTable[i]) +
                                      0x2A) * 0x02) / 0x55) * 0x15) / 0x02;
            RegColorBuffer[j++] = ((((GetBValue(ScreenInfo->Console->ColorTable[i]) +
                                      0x2A) * 0x02) / 0x55) * 0x15) / 0x02;
            RegColorBuffer[j++] = 0;
        }

        Status = GdiFullscreenControl(FullscreenControlSetColors,
                                      (PVOID) RegColorBuffer,
                                      RegColorBuffer[0] * sizeof(DWORD) + sizeof(DWORD),
                                      NULL,
                                      NULL);
    }
#else
    for (i = 0, j = 4; i < 16; i++) {
        ColorBuffer[j++] = ((((GetRValue(ScreenInfo->Console->ColorTable[i]) +
                               0x2A) * 0x02) / 0x55) * 0x15) / 0x02;
        ColorBuffer[j++] = ((((GetGValue(ScreenInfo->Console->ColorTable[i]) +
                               0x2A) * 0x02) / 0x55) * 0x15) / 0x02;
        ColorBuffer[j++] = ((((GetBValue(ScreenInfo->Console->ColorTable[i]) +
                               0x2A) * 0x02) / 0x55) * 0x15) / 0x02;
        ColorBuffer[j++] = 0;
    }

    Status = GdiFullscreenControl(FullscreenControlSetColors,
                                     (PVOID) &ColorBuffer,
                                     sizeof (ColorBuffer),
                                     NULL,
                                     NULL);
#endif

    if (Status != STATUS_SUCCESS) {
        RIPMSG1(RIP_WARNING, "FullscreenControlSetColors failed - Status = 0x%x",
                Status);
        return FALSE;
    }

    return TRUE;
}
#endif


#if defined(_X86_)

NTSTATUS
ChangeDispSettings(
    PCONSOLE_INFORMATION Console,
    HWND hwnd,
    DWORD dwFlags)
{
    DEVMODEW Devmode;
    ULONG Index;
    CONSOLE_FULLSCREEN_SWITCH switchBlock;

    if (dwFlags == CDS_FULLSCREEN) {
#if defined(FE_SB)
        BOOL fGraphics = fFullScreenGraphics ? IsAvailableFsCodePage(Console->OutputCP) : FALSE;
#endif

        Index = Console->CurrentScreenBuffer->BufferInfo.TextInfo.ModeIndex;

        //
        // set mode to go to full screen
        //

        ZeroMemory(&Devmode, sizeof(Devmode));

        Devmode.dmSize = sizeof(Devmode);
        Devmode.dmDriverExtra = 0;
        Devmode.dmFields = DM_BITSPERPEL   |
                           DM_PELSWIDTH    |
                           DM_PELSHEIGHT   |
                           DM_DISPLAYFLAGS;

        Devmode.dmBitsPerPel   = 4;
#if defined(FE_SB)
        Devmode.dmPelsWidth    = RegModeFontPairs[Index].Resolution.X;
        Devmode.dmPelsHeight   = RegModeFontPairs[Index].Resolution.Y;
        Devmode.dmDisplayFlags = (fGraphics && (RegModeFontPairs[Index].Mode & FS_MODE_GRAPHICS)) ? 0 : DMDISPLAYFLAGS_TEXTMODE;
#else
        Devmode.dmPelsWidth    = ModeFontPairs[Index].Resolution.X;
        Devmode.dmPelsHeight   = ModeFontPairs[Index].Resolution.Y;
        Devmode.dmDisplayFlags = DMDISPLAYFLAGS_TEXTMODE;
#endif

        switchBlock.bFullscreenSwitch = TRUE;
        switchBlock.hwnd              = hwnd;
        switchBlock.pNewMode          = &Devmode;

    } else {
        switchBlock.bFullscreenSwitch = FALSE;
        switchBlock.hwnd              = hwnd;
        switchBlock.pNewMode          = NULL;
    }

    return NtUserConsoleControl(ConsoleFullscreenSwitch,
                                &switchBlock,
                                sizeof(CONSOLE_FULLSCREEN_SWITCH));
}

#endif

BOOL
InitializeFullScreen( VOID )
{
    UNICODE_STRING vgaString;
    DEVMODEW devmode;
    ULONG   i;
#ifdef FE_SB
    DWORD mode1 = 0;
    DWORD mode2 = 0;
#else
    BOOLEAN mode1 = FALSE;
    BOOLEAN mode2 = FALSE;
#endif

    CHAR WindowsDir[CONSOLE_WINDOWS_DIR_LENGTH + CONSOLE_EGACPI_LENGTH];
    UINT WindowsDirLength;

    //
    // query number of available modes
    //

    ZeroMemory(&devmode, sizeof(DEVMODEW));
    devmode.dmSize = sizeof(DEVMODEW);

    RtlInitUnicodeString(&vgaString, L"VGACOMPATIBLE");

    DBGCHARS(("Number of modes = %d\n", NUMBER_OF_MODE_FONT_PAIRS));

    for (i=0; ; i++)
    {
        DBGCHARS(("EnumDisplaySettings %d\n", i));

        if (!(NT_SUCCESS(NtUserEnumDisplaySettings(&vgaString,
                                                   i,
                                                   &devmode,
                                                   0))))
        {
            break;
        }

#if defined(FE_SB)
        {
            ULONG Index;

            DBGCHARS(("Mode X = %d, Y = %d\n",
                     devmode.dmPelsWidth, devmode.dmPelsHeight));

            for (Index=0;Index<NUMBER_OF_MODE_FONT_PAIRS;Index++)
            {
                if ((SHORT)devmode.dmPelsWidth == RegModeFontPairs[Index].Resolution.X &&
                    (SHORT)devmode.dmPelsHeight == RegModeFontPairs[Index].Resolution.Y  )
                {
                    if (devmode.dmDisplayFlags & DMDISPLAYFLAGS_TEXTMODE)
                    {
                        if (RegModeFontPairs[Index].Mode & FS_MODE_TEXT)
                        {
                            RegModeFontPairs[Index].Mode |= FS_MODE_FIND;
                            mode1++;
                        }
                    }
                    else
                    {
                        if (RegModeFontPairs[Index].Mode & FS_MODE_GRAPHICS)
                        {
                            RegModeFontPairs[Index].Mode |= FS_MODE_FIND;
                            mode2++;
                        }
                    }
                }
            }

            DBGCHARS(("mode1 = %d, mode2 = %d\n", mode1, mode2));
        }
#else

        if (devmode.dmPelsWidth == 720 &&
            devmode.dmPelsHeight == 400)
        {
            mode1 = TRUE;
        }
        if (devmode.dmPelsWidth == 640 &&
            devmode.dmPelsHeight == 350)
        {
            mode2 = TRUE;
        }
#endif
    }

#if !defined(FE_SB)
    if (!(mode1 && mode2))
#else
    if (mode1 < 2)
#endif
    {
        //
        // One of the modes we expected to get was not returned.
        // lets just fail fullscreen initialization.
        //

        KdPrint(("CONSRV: InitializeFullScreen Missing text mode\n"));
        return FALSE;
    }

#if defined(FE_SB)
    if (mode2 > 0)
    {
        // Can do trun graphics mode.
        fFullScreenGraphics = TRUE;
    }
#endif

    //
    // open ega.cpi
    //

    WindowsDirLength = GetSystemDirectoryA(WindowsDir,
                                           CONSOLE_WINDOWS_DIR_LENGTH);
    if (WindowsDirLength == 0)
    {
        KdPrint(("CONSRV: InitializeFullScreen Finding Font file failed\n"));
        return FALSE;
    }

    RtlCopyMemory(&WindowsDir[WindowsDirLength],
                  CONSOLE_EGACPI,
                  CONSOLE_EGACPI_LENGTH);

    if ((hCPIFile = CreateFileA(WindowsDir,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL)) == INVALID_HANDLE_VALUE)
    {
        KdPrint(("CONSRV: InitializeFullScreen Opening Font file failed\n"));
        return FALSE;
    }

    return TRUE;
}


ULONG
SrvGetConsoleHardwareState(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
#ifdef i386
    PCONSOLE_GETHARDWARESTATE_MSG a = (PCONSOLE_GETHARDWARESTATE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    PSCREEN_INFORMATION ScreenInfo;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        ScreenInfo = HandleData->Buffer.ScreenBuffer;
        if (ScreenInfo->BufferInfo.TextInfo.ModeIndex == -1) {
            UnlockConsole(Console);
            return STATUS_UNSUCCESSFUL;
        }
#if defined(FE_SB)
        a->Resolution = RegModeFontPairs[ScreenInfo->BufferInfo.TextInfo.ModeIndex].Resolution;
        a->FontSize = RegModeFontPairs[ScreenInfo->BufferInfo.TextInfo.ModeIndex].FontSize;
#else
        a->Resolution = ModeFontPairs[ScreenInfo->BufferInfo.TextInfo.ModeIndex].Resolution;
        a->FontSize = ModeFontPairs[ScreenInfo->BufferInfo.TextInfo.ModeIndex].FontSize;
#endif
    }
    UnlockConsole(Console);
    return Status;
#else
    return STATUS_UNSUCCESSFUL;
    UNREFERENCED_PARAMETER(m);
#endif
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvSetConsoleHardwareState(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
#ifdef i386
    PCONSOLE_SETHARDWARESTATE_MSG a = (PCONSOLE_SETHARDWARESTATE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    PSCREEN_INFORMATION ScreenInfo;
    ULONG Index;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (!(Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE)) {
        UnlockConsole(Console);
        return STATUS_UNSUCCESSFUL;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
#if defined(FE_SB)
        BOOL fGraphics = fFullScreenGraphics ? IsAvailableFsCodePage(Console->OutputCP) : FALSE;
#endif
        ScreenInfo = HandleData->Buffer.ScreenBuffer;

        // match requested mode

        for (Index=0;Index<NUMBER_OF_MODE_FONT_PAIRS;Index++) {
#if defined(FE_SB)
            if (a->Resolution.X == RegModeFontPairs[Index].Resolution.X &&
                a->Resolution.Y == RegModeFontPairs[Index].Resolution.Y &&
                a->FontSize.Y == RegModeFontPairs[Index].FontSize.Y &&
                a->FontSize.X == RegModeFontPairs[Index].FontSize.X &&
                ( ( fGraphics && (RegModeFontPairs[Index].Mode & FS_GRAPHICS)==FS_GRAPHICS) ||
                  (!fGraphics && (RegModeFontPairs[Index].Mode & FS_TEXT)==FS_TEXT)           )
               ) {
                break;
            }
#else
            if (a->Resolution.X == ModeFontPairs[Index].Resolution.X &&
                a->Resolution.Y == ModeFontPairs[Index].Resolution.Y &&
                a->FontSize.Y == ModeFontPairs[Index].FontSize.Y &&
                a->FontSize.X == ModeFontPairs[Index].FontSize.X) {
                break;
            }
#endif
        }
        if (Index == NUMBER_OF_MODE_FONT_PAIRS) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            // set requested mode
            ScreenInfo->BufferInfo.TextInfo.ModeIndex = Index;
            SetVideoMode(ScreenInfo);
        }
    }
    UnlockConsole(Console);
    return Status;
#else
    return STATUS_UNSUCCESSFUL;
    UNREFERENCED_PARAMETER(m);
#endif
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleDisplayMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETDISPLAYMODE_MSG a = (PCONSOLE_GETDISPLAYMODE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (NT_SUCCESS(Status)) {
        a->ModeFlags = Console->FullScreenFlags;
        UnlockConsole(Console);
    }
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvSetConsoleMenuClose(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETMENUCLOSE_MSG a = (PCONSOLE_SETMENUCLOSE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (a->Enable) {
        Console->Flags &= ~CONSOLE_DISABLE_CLOSE;
    } else {
        Console->Flags |= CONSOLE_DISABLE_CLOSE;
    }

    UnlockConsole(Console);
    return Status;
}


DWORD
ConvertHotKey(
    IN LPAPPKEY UserAppKey
    )
{
    DWORD wParam;

    wParam = MapVirtualKey(UserAppKey->ScanCode,1);
    if (UserAppKey->Modifier & CONSOLE_MODIFIER_SHIFT) {
        wParam |= 0x0100;
    }
    if (UserAppKey->Modifier & CONSOLE_MODIFIER_CONTROL) {
        wParam |= 0x0200;
    }
    if (UserAppKey->Modifier & CONSOLE_MODIFIER_ALT) {
        wParam |= 0x0400;
    }
    return wParam;
}

ULONG
SrvSetConsoleKeyShortcuts(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETKEYSHORTCUTS_MSG a = (PCONSOLE_SETKEYSHORTCUTS_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    /*
     * We only call CsrCaptureMessageBuffer() in SetConsoleKeyShortcuts if
     * a->NumAppKeys != 0, so we only want to call CsrValidateMessageBuffer when
     * that condition's true.
     */
    if (a->NumAppKeys != 0 && !CsrValidateMessageBuffer(m, &a->AppKeys, a->NumAppKeys, sizeof(*a->AppKeys))) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    if (a->NumAppKeys <= CONSOLE_MAX_APP_SHORTCUTS) {
        Console->ReserveKeys = a->ReserveKeys;
        if (Console->Flags & CONSOLE_HAS_FOCUS) {
            if (!(SetConsoleReserveKeys(Console->hWnd, a->ReserveKeys))) {
                Status = STATUS_INVALID_PARAMETER;
            }
        }
        if (a->NumAppKeys) {
            PostMessage(Console->hWnd,
                         WM_SETHOTKEY,
                         ConvertHotKey(a->AppKeys),
                         0
                        );
        }
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    UnlockConsole(Console);
    return Status;
}

#ifdef i386
ULONG
MatchWindowSize(
#if defined(FE_SB)
    IN UINT CodePage,
#endif
    IN COORD WindowSize,
    OUT PCOORD pWindowSize
    )

/*++

    find the best match font.  it's the one that's the same size
    or slightly larger than the window size.

--*/
{
    ULONG i;
#if defined(FE_SB)
    BOOL fGraphics = fFullScreenGraphics ? IsAvailableFsCodePage(CodePage) : FALSE;
#endif

    for (i=0;i<NUMBER_OF_MODE_FONT_PAIRS;i++) {
#if defined(FE_SB)
        if (WindowSize.Y <= RegModeFontPairs[i].ScreenSize.Y &&
            ( ( fGraphics && (RegModeFontPairs[i].Mode & FS_GRAPHICS)==FS_GRAPHICS) ||
              (!fGraphics && (RegModeFontPairs[i].Mode & FS_TEXT)==FS_TEXT)           )
           )
#else
        if (WindowSize.Y <= (SHORT)ModeFontPairs[i].Height)
#endif
        {
            break;
        }
    }
    if (i == NUMBER_OF_MODE_FONT_PAIRS)
#if defined(FE_SB)
    {
        DWORD Find;
        ULONG FindIndex;
        COORD WindowSizeDelta;

        FindIndex = 0;
        Find = (DWORD)-1;
        for (i=0; i<NUMBER_OF_MODE_FONT_PAIRS;i++) {
            if ( ( fGraphics && (RegModeFontPairs[i].Mode & FS_GRAPHICS)==FS_GRAPHICS) ||
                 (!fGraphics && (RegModeFontPairs[i].Mode & FS_TEXT)==FS_TEXT)           )
            {
                WindowSizeDelta.Y = (SHORT) abs(WindowSize.Y - RegModeFontPairs[i].ScreenSize.Y);
                if (Find > (DWORD)(WindowSizeDelta.Y))
                {
                    Find = (DWORD)(WindowSizeDelta.Y);
                    FindIndex = i;
                }
            }
        }

        i = FindIndex;
    }
#else
        i-=1;
#endif
#if defined(FE_SB)
    *pWindowSize = RegModeFontPairs[i].ScreenSize;
#else
    pWindowSize->X = 80;
    pWindowSize->Y = (SHORT)ModeFontPairs[i].Height;
#endif
    return i;
}

VOID
ReadRegionFromScreenHW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region,
    IN PCHAR_INFO ReadBufPtr
    )
{
    ULONG CurFrameBufPtr;   // offset in frame buffer
    SHORT FrameY;
    SHORT WindowY, WindowX, WindowSizeX;

    //
    // get pointer to start of region in frame buffer
    //

    WindowY = Region->Top - ScreenInfo->Window.Top;
    WindowX = Region->Left - ScreenInfo->Window.Left;
    WindowSizeX = CONSOLE_WINDOW_SIZE_X(ScreenInfo);

    //
    // copy the chars and attrs from the frame buffer
    //

    for (FrameY = Region->Top;
         FrameY <= Region->Bottom;
         FrameY++, WindowY++) {

        CurFrameBufPtr = SCREEN_BUFFER_POINTER(WindowX,
                                               WindowY,
                                               WindowSizeX,
                                               sizeof(VGA_CHAR));

        GdiFullscreenControl(FullscreenControlReadFromFrameBuffer,
                                (PULONG) CurFrameBufPtr,
                                (Region->Right - Region->Left + 1) *
                                    sizeof(VGA_CHAR),
                                ReadBufPtr, NULL);
        ReadBufPtr += (Region->Right - Region->Left + 1);
    }
}

VOID
ReverseMousePointer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    )
{
    ULONG CurFrameBufPtr;   // offset in frame buffer
    SHORT WindowSizeX;

#ifdef FE_SB
    // fail safe
    UserAssert(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
    if (!(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)) {
        return;
    }
#endif

    WindowSizeX = CONSOLE_WINDOW_SIZE_X(ScreenInfo);

    if (ScreenInfo->BufferInfo.TextInfo.MousePosition.X < Region->Left ||
        ScreenInfo->BufferInfo.TextInfo.MousePosition.X > Region->Right ||
        ScreenInfo->BufferInfo.TextInfo.MousePosition.Y < Region->Top ||
        ScreenInfo->BufferInfo.TextInfo.MousePosition.Y > Region->Bottom ||
        ScreenInfo->CursorDisplayCount < 0 ||
        !(ScreenInfo->Console->InputBuffer.InputMode & ENABLE_MOUSE_INPUT) ||
        ScreenInfo->Console->Flags & CONSOLE_VDM_REGISTERED) {
        return;
    }

#if defined(FE_SB)
    {
        FSVIDEO_REVERSE_MOUSE_POINTER MousePointer;
        SHORT RowIndex;
        PROW Row;
        COORD TargetPoint;

        TargetPoint.X = ScreenInfo->BufferInfo.TextInfo.MousePosition.X;
        TargetPoint.Y = ScreenInfo->BufferInfo.TextInfo.MousePosition.Y;

        RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetPoint.Y) % ScreenInfo->ScreenBufferSize.Y;
        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
        if (!CONSOLE_IS_DBCS_CP(ScreenInfo->Console))
            MousePointer.dwType = CHAR_TYPE_SBCS;
        else if (Row->CharRow.KAttrs[TargetPoint.X] & ATTR_TRAILING_BYTE)
            MousePointer.dwType = CHAR_TYPE_TRAILING;
        else if (Row->CharRow.KAttrs[TargetPoint.X] & ATTR_LEADING_BYTE)
            MousePointer.dwType = CHAR_TYPE_LEADING;
        else
            MousePointer.dwType = CHAR_TYPE_SBCS;

        MousePointer.Screen.Position.X = TargetPoint.X - ScreenInfo->Window.Left;
        MousePointer.Screen.Position.Y = TargetPoint.Y - ScreenInfo->Window.Top;
        MousePointer.Screen.ScreenSize.X = WindowSizeX;
        MousePointer.Screen.ScreenSize.Y = CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
        MousePointer.Screen.nNumberOfChars = 0;

        GdiFullscreenControl(FullscreenControlReverseMousePointerDB,
                             &MousePointer,
                             sizeof(MousePointer),
                             NULL,
                             NULL);

        UNREFERENCED_PARAMETER(CurFrameBufPtr);
    }
#else
    CurFrameBufPtr = SCREEN_BUFFER_POINTER(ScreenInfo->BufferInfo.TextInfo.MousePosition.X - ScreenInfo->Window.Left,
                                           ScreenInfo->BufferInfo.TextInfo.MousePosition.Y - ScreenInfo->Window.Top,
                                           WindowSizeX,
                                           sizeof(VGA_CHAR));

    GdiFullscreenControl(FullscreenControlReverseMousePointer,
                            (PULONG)CurFrameBufPtr,
                            0,
                            NULL,
                            NULL);
#endif
}

VOID
CopyVideoMemory(
    SHORT SourceY,
    SHORT TargetY,
    SHORT Length,
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine copies rows of characters in video memory.  It only copies
    complete rows.

Arguments:

    SourceY - Row to copy from.

    TargetY - Row to copy to.

    Length - Number of rows to copy.

Return Value:

--*/

{
    ULONG SourcePtr, TargetPtr;
    SHORT WindowSizeX, WindowSizeY;

    WindowSizeX = CONSOLE_WINDOW_SIZE_X(ScreenInfo);
    WindowSizeY = CONSOLE_WINDOW_SIZE_Y(ScreenInfo);

    if (max(SourceY, TargetY) + Length > WindowSizeY) {
        Length = WindowSizeY - max(SourceY, TargetY);
        if (Length <= 0 ) {
            return;
        }
    }

#if defined(FE_SB)
    {
        FSCNTL_SCREEN_INFO FsCntlSrc;
        FSCNTL_SCREEN_INFO FsCntlDest;

        FsCntlSrc.Position.X = 0;
        FsCntlSrc.Position.Y = SourceY;
        FsCntlSrc.ScreenSize.X = WindowSizeX;
        FsCntlSrc.ScreenSize.Y = CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
        FsCntlSrc.nNumberOfChars = Length * WindowSizeX;

        FsCntlDest.Position.X = 0;
        FsCntlDest.Position.Y = TargetY;
        FsCntlDest.ScreenSize.X = WindowSizeX;
        FsCntlDest.ScreenSize.Y = CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
        FsCntlDest.nNumberOfChars = Length * WindowSizeX;

        GdiFullscreenControl(FullscreenControlCopyFrameBufferDB,
                             &FsCntlSrc,
                             sizeof(FsCntlSrc),
                             &FsCntlDest,
                             (PULONG)sizeof(FsCntlDest));

        UNREFERENCED_PARAMETER(SourcePtr);
        UNREFERENCED_PARAMETER(TargetPtr);
    }
#else
    SourcePtr = SCREEN_BUFFER_POINTER(0,
                                      SourceY,
                                      WindowSizeX,
                                      sizeof(VGA_CHAR));

    TargetPtr = SCREEN_BUFFER_POINTER(0,
                                      TargetY,
                                      WindowSizeX,
                                      sizeof(VGA_CHAR));

    GdiFullscreenControl(FullscreenControlCopyFrameBuffer,
                            (PULONG) SourcePtr,
                            Length * WindowSizeX * sizeof(VGA_CHAR),
                            (PULONG) TargetPtr,
                            (PULONG) (Length * WindowSizeX * sizeof(VGA_CHAR)));
#endif
}

VOID
ScrollHW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT ScrollRect,
    IN PSMALL_RECT MergeRect,
    IN COORD TargetPoint
    )
{
    SMALL_RECT TargetRectangle;
    if (ScreenInfo->Console->Flags & CONSOLE_VDM_REGISTERED)
        return;

    TargetRectangle.Left = TargetPoint.X;
    TargetRectangle.Top = TargetPoint.Y;
    TargetRectangle.Right = TargetPoint.X + ScrollRect->Right - ScrollRect->Left;
    TargetRectangle.Bottom = TargetPoint.Y + ScrollRect->Bottom - ScrollRect->Top;

    //
    // if the scroll region is as wide as the screen, we can update
    // the screen by copying the video memory.  if we scroll this
    // way, we then must clip and update the fill region.
    //

    if (ScrollRect->Left == ScreenInfo->Window.Left &&
        TargetRectangle.Left == ScreenInfo->Window.Left &&
        ScrollRect->Right == ScreenInfo->Window.Right &&
        TargetRectangle.Right == ScreenInfo->Window.Right &&
        ScrollRect->Top >= ScreenInfo->Window.Top &&
        TargetRectangle.Top >= ScreenInfo->Window.Top &&
        ScrollRect->Bottom <= ScreenInfo->Window.Bottom &&
        TargetRectangle.Bottom <= ScreenInfo->Window.Bottom) {

        //
        // we must first make the mouse pointer invisible because
        // otherwise it would get copied to another place on the
        // screen if it were part of the scroll region.
        //

        ReverseMousePointer(ScreenInfo, &ScreenInfo->Window);

        CopyVideoMemory((SHORT) (ScrollRect->Top - ScreenInfo->Window.Top),
                        (SHORT) (TargetRectangle.Top - ScreenInfo->Window.Top),
                        (SHORT) (TargetRectangle.Bottom - TargetRectangle.Top + 1),
                        ScreenInfo);

        //
        // update the fill region.  first we ensure that the scroll and
        // target regions aren't the same.  if they are, we don't fill.
        //

        if (TargetRectangle.Top != ScrollRect->Top) {

            //
            // if scroll and target regions overlap, with scroll
            // region above target region, clip scroll region.
            //

            if (TargetRectangle.Top <= ScrollRect->Bottom &&
                TargetRectangle.Bottom >= ScrollRect->Bottom) {
                ScrollRect->Bottom = (SHORT)(TargetRectangle.Top-1);
            }
            else if (TargetRectangle.Top <= ScrollRect->Top &&
                TargetRectangle.Bottom >= ScrollRect->Top) {
                ScrollRect->Top = (SHORT)(TargetRectangle.Bottom+1);
            }
            WriteToScreen(ScreenInfo, ScrollRect);

            //
            // WriteToScreen should take care of writing the mouse pointer.
            // however, the update region may be clipped so that the
            // mouse pointer is not written. in that case, we draw the
            // mouse pointer here.
            //

            if (ScreenInfo->BufferInfo.TextInfo.MousePosition.Y < ScrollRect->Top ||
                ScreenInfo->BufferInfo.TextInfo.MousePosition.Y > ScrollRect->Bottom) {
                ReverseMousePointer(ScreenInfo, &ScreenInfo->Window);
            }
        }
        if (MergeRect) {
            WriteToScreen(ScreenInfo, MergeRect);
        }
    }
    else {
        if (MergeRect) {
            WriteToScreen(ScreenInfo, MergeRect);
        }
        WriteToScreen(ScreenInfo, ScrollRect);
        WriteToScreen(ScreenInfo, &TargetRectangle);
    }
}

VOID
UpdateMousePosition(
    PSCREEN_INFORMATION ScreenInfo,
    COORD Position
    )

/*++

Routine Description:

    This routine moves the mouse pointer.

Arguments:

    ScreenInfo - Pointer to screen buffer information.

    Position - Contains the new position of the mouse in screen buffer
    coordinates.

Return Value:

    none.

--*/

// Note: CurrentConsole lock must be held in share mode when calling this routine
{
    SMALL_RECT CursorRegion;
#ifdef FE_SB
    SHORT RowIndex;
    PROW  Row;
    BOOL  fOneMore = FALSE;
#endif

    if ((ScreenInfo->Console->Flags & CONSOLE_VDM_REGISTERED) ||
            (ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER)) {
        return;
    }

    if (Position.X < ScreenInfo->Window.Left ||
        Position.X > ScreenInfo->Window.Right ||
        Position.Y < ScreenInfo->Window.Top ||
        Position.Y > ScreenInfo->Window.Bottom) {
        return;
    }

    if (Position.X == ScreenInfo->BufferInfo.TextInfo.MousePosition.X &&
        Position.Y == ScreenInfo->BufferInfo.TextInfo.MousePosition.Y) {
        return;
    }

#ifdef FE_SB
    if (CONSOLE_IS_DBCS_CP(ScreenInfo->Console)) {
        RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+Position.Y) % ScreenInfo->ScreenBufferSize.Y;
        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
        if (Row->CharRow.KAttrs[Position.X] & ATTR_LEADING_BYTE) {
            if (Position.X != ScreenInfo->ScreenBufferSize.X - 1) {
                fOneMore = TRUE;
            }
        } else if (Row->CharRow.KAttrs[Position.X] & ATTR_TRAILING_BYTE) {
            if (Position.X != 0) {
                fOneMore = TRUE;
                Position.X--;
            }
        }

    }
#endif

    if (ScreenInfo->CursorDisplayCount < 0 || !(ScreenInfo->Console->InputBuffer.InputMode & ENABLE_MOUSE_INPUT)) {
        ScreenInfo->BufferInfo.TextInfo.MousePosition = Position;
        return;
    }


    // turn off old mouse position.

    CursorRegion.Left = CursorRegion.Right = ScreenInfo->BufferInfo.TextInfo.MousePosition.X;
    CursorRegion.Top = CursorRegion.Bottom = ScreenInfo->BufferInfo.TextInfo.MousePosition.Y;

#ifdef FE_SB
    if (CONSOLE_IS_DBCS_CP(ScreenInfo->Console)) {
        RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+CursorRegion.Top) % ScreenInfo->ScreenBufferSize.Y;
        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
        if (Row->CharRow.KAttrs[CursorRegion.Left] & ATTR_LEADING_BYTE) {
            if (CursorRegion.Left != ScreenInfo->ScreenBufferSize.X - 1) {
                CursorRegion.Right++;
            }
        }
    }
#endif

    // store new mouse position

    ScreenInfo->BufferInfo.TextInfo.MousePosition.X = Position.X;
    ScreenInfo->BufferInfo.TextInfo.MousePosition.Y = Position.Y;
    WriteToScreen(ScreenInfo, &CursorRegion);

    // turn on new mouse position

    CursorRegion.Left = CursorRegion.Right = Position.X;
    CursorRegion.Top = CursorRegion.Bottom = Position.Y;
#ifdef FE_SB
    if (fOneMore)
        CursorRegion.Right++;
#endif
    WriteToScreen(ScreenInfo, &CursorRegion);
}

NTSTATUS
SetROMFontCodePage(
    IN UINT wCodePage,
    IN ULONG ModeIndex
    )

/*

    this function opens ega.cpi and looks for the desired font in the
    specified codepage.  if found, it loads it into the video ROM.

*/

{
    BYTE Buffer[CONSOLE_FONT_BUFFER_LENGTH];
    DWORD dwBytesRead;
    LPFONTFILEHEADER lpFontFileHeader=(LPFONTFILEHEADER)Buffer;
    LPFONTINFOHEADER lpFontInfoHeader=(LPFONTINFOHEADER)Buffer;
    LPFONTDATAHEADER lpFontDataHeader=(LPFONTDATAHEADER)Buffer;
    LPCPENTRYHEADER lpCPEntryHeader=(LPCPENTRYHEADER)Buffer;
    LPSCREENFONTHEADER lpScreenFontHeader=(LPSCREENFONTHEADER)Buffer;
    WORD NumEntries;
    COORD FontDimensions;
    NTSTATUS Status;
    BOOL Found;
    LONG FilePtr;
    BOOL bDOS = FALSE;

    FontDimensions = ModeFontPairs[ModeIndex].FontSize;

    //
    // read FONTINFOHEADER
    //
    // do {
    //     read CPENTRYHEADER
    //     if (correct codepage)
    //         break;
    // } while (codepages)
    // if (codepage found)
    //     read FONTDATAHEADER
    //

    // read FONTFILEHEADER

    FilePtr = 0;
    if (SetFilePointer(hCPIFile, FilePtr, NULL, FILE_BEGIN) == -1) {
        Status = STATUS_INVALID_PARAMETER;
        goto DoExit;
    }

    if (!ReadFile(hCPIFile, Buffer, sizeof(FONTFILEHEADER), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(FONTFILEHEADER)) {
        Status = STATUS_INVALID_PARAMETER;
        goto DoExit;
    }

    // verify signature

    if (memcmp(lpFontFileHeader->ffhFileTag, "\xFF""FONT.NT",8) ) {
        if (memcmp(lpFontFileHeader->ffhFileTag, "\xFF""FONT   ",8) ) {
            Status = STATUS_INVALID_PARAMETER;
            goto DoExit;
        } else {
            bDOS = TRUE;
        }
    }

    // seek to FONTINFOHEADER.  jump through hoops to get the offset value.

    FilePtr = lpFontFileHeader->ffhOffset1;
    FilePtr |= (lpFontFileHeader->ffhOffset2 << 8);
    FilePtr |= (lpFontFileHeader->ffhOffset3 << 24);

    if (SetFilePointer(hCPIFile, FilePtr, NULL, FILE_BEGIN) == -1) {
        Status = STATUS_INVALID_PARAMETER;
        goto DoExit;
    }

    // read FONTINFOHEADER

    if (!ReadFile(hCPIFile, Buffer, sizeof(FONTINFOHEADER), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(FONTINFOHEADER)) {
        Status = STATUS_INVALID_PARAMETER;
        goto DoExit;
    }
    FilePtr += dwBytesRead;
    NumEntries = lpFontInfoHeader->fihCodePages;

    Found = FALSE;
    while (NumEntries &&
           ReadFile(hCPIFile, Buffer, sizeof(CPENTRYHEADER), &dwBytesRead, NULL) &&
           dwBytesRead == sizeof(CPENTRYHEADER)) {
        if (lpCPEntryHeader->cpeCodepageID == wCodePage) {
            Found = TRUE;
            break;
        }
        // seek to next CPEENTRYHEADER

        if (bDOS) {
            FilePtr = MAKELONG(lpCPEntryHeader->cpeNext1, lpCPEntryHeader->cpeNext2);
        } else {
            FilePtr += MAKELONG(lpCPEntryHeader->cpeNext1, lpCPEntryHeader->cpeNext2);
        }
        if (SetFilePointer(hCPIFile, FilePtr, NULL, FILE_BEGIN) == -1) {
            Status = STATUS_INVALID_PARAMETER;
            goto DoExit;
        }
        NumEntries -= 1;
    }
    if (!Found) {
        Status = STATUS_INVALID_PARAMETER;
        goto DoExit;
    }

    // seek to FONTDATAHEADER

    if (bDOS) {
        FilePtr = lpCPEntryHeader->cpeOffset;
    } else {
        FilePtr += lpCPEntryHeader->cpeOffset;
    }
    if (SetFilePointer(hCPIFile, FilePtr, NULL, FILE_BEGIN) == -1) {
        Status = STATUS_INVALID_PARAMETER;
        goto DoExit;
    }

    // read FONTDATAHEADER

    if (!ReadFile(hCPIFile, Buffer, sizeof(FONTDATAHEADER), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(FONTDATAHEADER)) {
        Status = STATUS_INVALID_PARAMETER;
        goto DoExit;
    }
    FilePtr += dwBytesRead;

    NumEntries = lpFontDataHeader->fdhFonts;

    while (NumEntries) {
        if (!ReadFile(hCPIFile, Buffer, sizeof(SCREENFONTHEADER), &dwBytesRead, NULL) ||
            dwBytesRead != sizeof(SCREENFONTHEADER)) {
            Status = STATUS_INVALID_PARAMETER;
            goto DoExit;
        }

        if (lpScreenFontHeader->sfhHeight == (BYTE)FontDimensions.Y &&
            lpScreenFontHeader->sfhWidth == (BYTE)FontDimensions.X) {
            PVIDEO_LOAD_FONT_INFORMATION FontInformation;

            FontInformation = ConsoleHeapAlloc(TMP_TAG,
                                    lpScreenFontHeader->sfhCharacters *
                                    lpScreenFontHeader->sfhHeight +
                                    sizeof(VIDEO_LOAD_FONT_INFORMATION));
            if (FontInformation == NULL) {
                RIPMSG1(RIP_WARNING, "SetROMFontCodePage: failed to memory allocation %d bytes",
                    lpScreenFontHeader->sfhCharacters * lpScreenFontHeader->sfhHeight +
                    sizeof(VIDEO_LOAD_FONT_INFORMATION));
                return STATUS_NO_MEMORY;
            }
            if (!ReadFile(hCPIFile, FontInformation->Font,
                          lpScreenFontHeader->sfhCharacters*lpScreenFontHeader->sfhHeight,
                          &dwBytesRead, NULL) ||
                          dwBytesRead != (DWORD)(lpScreenFontHeader->sfhCharacters*lpScreenFontHeader->sfhHeight)) {
                ConsoleHeapFree(FontInformation);
                return STATUS_INVALID_PARAMETER;
            }
            FontInformation->WidthInPixels = FontDimensions.X;
            FontInformation->HeightInPixels = FontDimensions.Y;
            FontInformation->FontSize = lpScreenFontHeader->sfhCharacters*lpScreenFontHeader->sfhHeight;

            Status = GdiFullscreenControl(FullscreenControlLoadFont,
                                             FontInformation,
                                             lpScreenFontHeader->sfhCharacters*lpScreenFontHeader->sfhHeight + sizeof(VIDEO_LOAD_FONT_INFORMATION),
                                             NULL,
                                             NULL);

            ConsoleHeapFree(FontInformation);
            return Status;
        } else {
            FilePtr = lpScreenFontHeader->sfhCharacters*lpScreenFontHeader->sfhHeight;
            if (SetFilePointer(hCPIFile, FilePtr, NULL, FILE_CURRENT) == -1) {
                Status = STATUS_INVALID_PARAMETER;
                goto DoExit;
            }
        }
        NumEntries -= 1;
    }
DoExit:
    return Status;
}
#endif

NTSTATUS
GetThreadConsoleDesktop(
    DWORD dwThreadId,
    HDESK *phdeskConsole)
{
    PCSR_THREAD pcsrt;
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    PCONSOLE_INFORMATION Console;
    NTSTATUS Status;
    HANDLE ConsoleHandle = NULL;

    *phdeskConsole = NULL;
    Status = CsrLockThreadByClientId(LongToHandle(dwThreadId), &pcsrt);
    if (NT_SUCCESS(Status)) {
        ProcessData = CONSOLE_FROMTHREADPERPROCESSDATA(pcsrt);
        ConsoleHandle = ProcessData->ConsoleHandle;
        CsrUnlockThread(pcsrt);
    }

    //
    // If this process is a console app, return the
    // handle to its desktop.  Otherwise, return NULL.
    //

    if (ConsoleHandle != NULL) {
        Status = RevalidateConsole(ConsoleHandle, &Console);
        if (NT_SUCCESS(Status)) {
            *phdeskConsole = Console->hDesk;
        }
        UnlockConsole(Console);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
SetRAMFontCodePage(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    FSVIDEO_SCREEN_INFORMATION ScreenInformation;
    ULONG ModeIndex = ScreenInfo->BufferInfo.TextInfo.ModeIndex;
    COORD FontSize;
    WCHAR wChar;
    WCHAR wCharBuf[2];
    LPSTRINGBITMAP StringBitmap;
    DWORD BufferSize;
    PWORD FontImage;
    PFONT_CACHE_INFORMATION FontCache;
    WCHAR AltFaceName[LF_FACESIZE];
    COORD AltFontSize;
    BYTE  AltFontFamily;
    ULONG AltFontIndex = 0;
    HFONT hOldFont;
    NTSTATUS Status;

    ScreenInformation.ScreenSize = RegModeFontPairs[ModeIndex].ScreenSize;
    ScreenInformation.FontSize = RegModeFontPairs[ModeIndex].FontSize;
    if (ScreenInfo->Console->FontCacheInformation == NULL)
    {
        Status = CreateFontCache(&FontCache);
        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING, "SetRAMFontCodePage: failed in CreateFontCache. Status=%08x", Status);
            return STATUS_UNSUCCESSFUL;
        }
        (PFONT_CACHE_INFORMATION)ScreenInfo->Console->FontCacheInformation = FontCache;

        MakeAltRasterFont(SCR_FONTCODEPAGE(ScreenInfo),
                          RegModeFontPairs[ModeIndex].FontSize,
                          &AltFontSize, &AltFontFamily, &AltFontIndex, AltFaceName);
        FontCache->FullScreenFontIndex = AltFontIndex;
        FontCache->FullScreenFontSize  = AltFontSize;

        BufferSize = CalcBitmapBufferSize(FontCache->FullScreenFontSize, BYTE_ALIGN);
        StringBitmap = ConsoleHeapAlloc(TMP_DBCS_TAG,
                                 sizeof(STRINGBITMAP) + sizeof(StringBitmap->ajBits) * BufferSize);
        if (StringBitmap==NULL) {
            RIPMSG0(RIP_WARNING, "SetRAMFontCodePage: failed to allocate StringBitmap");
            return STATUS_UNSUCCESSFUL;
        }


        /*
         * Change GDI font to full screen font that best matched.
         */
        hOldFont = SelectObject(ScreenInfo->Console->hDC, FontInfo[FontCache->FullScreenFontIndex].hFont);


        for (wChar=0x00; wChar < 0x80; wChar++) {
            wCharBuf[0] = wChar;
            wCharBuf[1] = TEXT('\0');
            GetStringBitmapW(ScreenInfo->Console->hDC,
                             wCharBuf,
                             1,
                             (ULONG)ConsoleHeapSize(StringBitmap),
                             (BYTE*)StringBitmap
                            );

            FontSize.X = (SHORT)StringBitmap->uiWidth;
            FontSize.Y = (SHORT)StringBitmap->uiHeight;

#if defined(LATER_DBCS_FOR_GRID_CHAR)  // by kazum
            BufferSize = CalcBitmapBufferSize(FontSize, BYTE_ALIGN);
            *(StringBitmap->ajBits + BufferSize) = 0;
            *(StringBitmap->ajBits + BufferSize + 1) = 0;

            if (gpGridCharacter) {
                PGRID_CHARACTER_INFORMATION GridCharacter;
                PWCHAR CodePoint;

                GridCharacter = gpGridCharacter;
                do {
                    if (GridCharacter->CodePage == OEMCP) {
                        CodePoint = GridCharacter->CodePoint;
                        while (*CodePoint) {
                            if (*CodePoint == wChar) {
                                if (FontSize.X <= 8)
                                    *(StringBitmap->ajBits + BufferSize) = *(StringBitmap->ajBits + BufferSize - 1);
                                else {
                                    *(StringBitmap->ajBits + BufferSize) = *(StringBitmap->ajBits + BufferSize - 2);
                                    *(StringBitmap->ajBits + BufferSize + 1) = *(StringBitmap->ajBits + BufferSize - 1);
                                }
                                break;
                            }
                            else
                                CodePoint++;
                        }
                        break;
                    }
                } while (GridCharacter = GridCharacter->pNext);
            }
#endif // LATER_DBCS_FOR_GRID_CHAR  // by kazum

            Status = SetFontImage(ScreenInfo->Console->FontCacheInformation,
                                  wChar,
                                  FontSize,
                                  BYTE_ALIGN,
                                  StringBitmap->ajBits
                                 );
            if (!NT_SUCCESS(Status)) {
                RIPMSG3(RIP_WARNING, "SetRAMFontCodePage: failed to set font image. wc=%04x sz=(%x, %x).",
                        wChar, FontSize.X, FontSize.Y);
            }

            if (FontSize.X != ScreenInformation.FontSize.X ||
                FontSize.Y != ScreenInformation.FontSize.Y) {
                BufferSize = CalcBitmapBufferSize(ScreenInformation.FontSize, WORD_ALIGN);
                FontImage = ConsoleHeapAlloc(TMP_DBCS_TAG, BufferSize);
                if (FontImage!=NULL) {
                    GetExpandFontImage(ScreenInfo->Console->FontCacheInformation,
                                       wChar,
                                       FontSize,
                                       ScreenInformation.FontSize,
                                       FontImage);

                    Status = SetFontImage(ScreenInfo->Console->FontCacheInformation,
                                          wChar,
                                          ScreenInformation.FontSize,
                                          WORD_ALIGN,
                                          FontImage);
                    if (!NT_SUCCESS(Status)) {
                        RIPMSG3(RIP_WARNING, "SetRAMFontCodePage: failed to set font image. wc=%04x, sz=(%x,%x)",
                                wChar, ScreenInformation.FontSize.X, ScreenInformation.FontSize.Y);
                    }

                    ConsoleHeapFree(FontImage);
                } else {
                    RIPMSG0(RIP_WARNING, "SetRAMFontCodePage: failed to allocate FontImage.");
                }
            }
        }

        ConsoleHeapFree(StringBitmap);

        /*
         * Back to GDI font
         */
        SelectObject(ScreenInfo->Console->hDC, hOldFont);
    }

    Status = GdiFullscreenControl(FullscreenControlSetScreenInformation,
                                  &ScreenInformation,
                                  sizeof(ScreenInformation),
                                  NULL,
                                  NULL);

    return Status;
}

NTSTATUS
SetRAMFont(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCHAR_INFO ScreenBufPtr,
    IN DWORD Length
    )
{
    ULONG ModeIndex = ScreenInfo->BufferInfo.TextInfo.ModeIndex;
    COORD FsFontSize1 = RegModeFontPairs[ModeIndex].FontSize;
    COORD FsFontSize2 = FsFontSize1;
    COORD GdiFontSize1;
    COORD GdiFontSize2;
    COORD RetFontSize;
    WCHAR wCharBuf[2];
    LPSTRINGBITMAP StringBitmap;
    DWORD BufferSize;
    PWORD FontImage;
    PFONT_CACHE_INFORMATION FontCache;
    HFONT hOldFont;
    NTSTATUS Status;

    FontCache = (PFONT_CACHE_INFORMATION)ScreenInfo->Console->FontCacheInformation;
    if (FontCache==NULL)
    {
        RIPMSG0(RIP_ERROR, "SetRAMFont: ScreenInfo->Console->FontCacheInformation == NULL.");
        return STATUS_UNSUCCESSFUL;
    }

    GdiFontSize1 = FontCache->FullScreenFontSize;
    GdiFontSize2 = GdiFontSize1;
    GdiFontSize2.X *= 2;
    FsFontSize2.X *= 2;

    BufferSize = CalcBitmapBufferSize(GdiFontSize2, BYTE_ALIGN);
    StringBitmap = ConsoleHeapAlloc(TMP_DBCS_TAG,
                             sizeof(STRINGBITMAP) + sizeof(StringBitmap->ajBits) * BufferSize);
    if (StringBitmap == NULL) {
        RIPMSG0(RIP_WARNING, "SetRAMFont: failed to allocate StringBitmap");
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * Change GDI font to full screen font that best matched.
     */
    hOldFont = SelectObject(ScreenInfo->Console->hDC, FontInfo[FontCache->FullScreenFontIndex].hFont);

    while (Length--) {
        Status = GetFontImage(ScreenInfo->Console->FontCacheInformation,
                              ScreenBufPtr->Char.UnicodeChar,
                              (ScreenBufPtr->Attributes & COMMON_LVB_SBCSDBCS) ? FsFontSize2 : FsFontSize1,
                              0,
                              NULL);
        if (!NT_SUCCESS(Status)) {
            wCharBuf[0] = ScreenBufPtr->Char.UnicodeChar;
            wCharBuf[1] = TEXT('\0');
            GetStringBitmapW(ScreenInfo->Console->hDC,
                             wCharBuf,
                             1,
                             (ULONG)ConsoleHeapSize(StringBitmap),
                             (BYTE*)StringBitmap
                            );

            RetFontSize.X = (SHORT)StringBitmap->uiWidth;
            RetFontSize.Y = (SHORT)StringBitmap->uiHeight;

            Status = SetFontImage(ScreenInfo->Console->FontCacheInformation,
                                  ScreenBufPtr->Char.UnicodeChar,
                                  RetFontSize,
                                  BYTE_ALIGN,
                                  StringBitmap->ajBits
                                 );
            if (!NT_SUCCESS(Status)) {
                RIPMSG3(RIP_WARNING, "SetRAMFont: failed to set font image. wc=%04x sz=(%x,%x)",
                        ScreenBufPtr->Char.UnicodeChar, RetFontSize.X, RetFontSize.Y);
            }

            if (((ScreenBufPtr->Attributes & COMMON_LVB_SBCSDBCS) &&
                    (GdiFontSize2.X != FsFontSize2.X || GdiFontSize2.Y != FsFontSize2.Y)) ||
                 (!(ScreenBufPtr->Attributes & COMMON_LVB_SBCSDBCS) &&
                    (GdiFontSize1.X != FsFontSize1.X || GdiFontSize1.Y != FsFontSize1.Y))) {
                BufferSize = CalcBitmapBufferSize(FsFontSize2, WORD_ALIGN);
                FontImage = ConsoleHeapAlloc(TMP_DBCS_TAG, BufferSize);
                if (FontImage != NULL) {

                    GetExpandFontImage(ScreenInfo->Console->FontCacheInformation,
                                       ScreenBufPtr->Char.UnicodeChar,
                                       (ScreenBufPtr->Attributes & COMMON_LVB_SBCSDBCS) ? GdiFontSize2 : GdiFontSize1,
                                       (ScreenBufPtr->Attributes & COMMON_LVB_SBCSDBCS) ? FsFontSize2 : FsFontSize1,
                                       FontImage
                                      );

                    Status = SetFontImage(ScreenInfo->Console->FontCacheInformation,
                                          ScreenBufPtr->Char.UnicodeChar,
                                          (ScreenBufPtr->Attributes & COMMON_LVB_SBCSDBCS) ? FsFontSize2 : FsFontSize1,
                                          WORD_ALIGN,
                                          FontImage
                                         );
                    if (!NT_SUCCESS(Status)) {
                        RIPMSG3(RIP_WARNING, "SetRAMFont: failed to set font image. wc=%04x sz=(%x,%x)",
                                ScreenBufPtr->Char.UnicodeChar,
                                ((ScreenBufPtr->Attributes & COMMON_LVB_SBCSDBCS) ? FsFontSize2 : FsFontSize1).X,
                                ((ScreenBufPtr->Attributes & COMMON_LVB_SBCSDBCS) ? FsFontSize2 : FsFontSize1).Y);
                    }

                    ConsoleHeapFree(FontImage);
                } else {
                    RIPMSG0(RIP_WARNING, "SetRAMFont: failed to allocate FontImage.");
                }
            }
        }

        if (ScreenBufPtr->Attributes & COMMON_LVB_SBCSDBCS) {
            ScreenBufPtr += 2;
            if (Length >= 1) {
                Length -= 1;
            } else {
                break;
            }
        } else {
            ScreenBufPtr++;
        }
    }

    ConsoleHeapFree(StringBitmap);

    /*
     * Back to GDI font
     */
    SelectObject(ScreenInfo->Console->hDC, hOldFont);

    return Status;
}

#ifdef i386
#if defined(FE_SB)

#define WWSB_NOFE
#include "_priv.h"
#undef  WWSB_NOFE
#define WWSB_FE
#include "_priv.h"
#undef  WWSB_FE

#endif  // FE_SB
#endif  // i386
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\srvvdm.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    srvvdm.c

Abstract:

    This file contains all VDM functions

Author:

Revision History:

--*/

#include "precomp.h"
#include "vdm.h"
#pragma hdrstop


ULONG
SrvVDMConsoleOperation(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_VDM_MSG a = (PCONSOLE_VDM_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    VDM_QUERY_VDM_PROCESS_DATA QueryVdmProcessData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // First make sure the caller is a VDM process
    //

    QueryVdmProcessData.ProcessHandle = CONSOLE_CLIENTPROCESSHANDLE();
    Status = NtVdmControl(VdmQueryVdmProcess, &QueryVdmProcessData);
    if (!NT_SUCCESS(Status) || QueryVdmProcessData.IsVdmProcess == FALSE) {
        Status = STATUS_ACCESS_DENIED;
    } else if (!(Console->Flags & CONSOLE_VDM_REGISTERED) ||
        (Console->VDMProcessId != CONSOLE_CLIENTPROCESSID())) {
        Status = STATUS_INVALID_PARAMETER;
    } else {
        switch (a->iFunction) {
        case VDM_HIDE_WINDOW:
                Console->Flags |= CONSOLE_VDM_HIDDEN_WINDOW;
                PostMessage(Console->hWnd,
                             CM_HIDE_WINDOW,
                             0,
                             0
                           );
                break;
            case VDM_IS_ICONIC:
                a->Bool = IsIconic(Console->hWnd);
                break;
            case VDM_CLIENT_RECT:
                GetClientRect(Console->hWnd,&a->Rect);
                break;
            case VDM_CLIENT_TO_SCREEN:
                ClientToScreen(Console->hWnd,&a->Point);
                break;
            case VDM_SCREEN_TO_CLIENT:
                ScreenToClient(Console->hWnd,&a->Point);
                break;
            case VDM_IS_HIDDEN:
                a->Bool = ((Console->Flags & CONSOLE_NO_WINDOW) != 0);
                break;
            case VDM_FULLSCREEN_NOPAINT:
                if (a->Bool) {
                    Console->Flags |= CONSOLE_FULLSCREEN_NOPAINT;
                } else {
                    Console->Flags &= ~CONSOLE_FULLSCREEN_NOPAINT;
                }
                break;
#if defined(FE_SB)
            case VDM_SET_VIDEO_MODE:
                Console->fVDMVideoMode = (a->Bool != 0);
                break;
#endif
            default:
                ASSERT(FALSE);
                Status = STATUS_INVALID_PARAMETER;
        }
    }

    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\output.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    output.c

Abstract:

        This file implements the video buffer management.

Author:

    Therese Stowell (thereses) 6-Nov-1990

Revision History:

Notes:

 ScreenBuffer data structure overview:

 each screen buffer has an array of ROW structures.  each ROW structure
 contains the data for one row of text.  the data stored for one row of
 text is a character array and an attribute array.  the character array
 is allocated the full length of the row from the heap, regardless of the
 non-space length. we also maintain the non-space length.  the character
 array is initialized to spaces.  the attribute
 array is run length encoded (i.e 5 BLUE, 3 RED). if there is only one
 attribute for the whole row (the normal case), it is stored in the ATTR_ROW
 structure.  otherwise the attr string is allocated from the heap.

 ROW - CHAR_ROW - CHAR string
     \          \ length of char string
      \
       ATTR_ROW - ATTR_PAIR string
                \ length of attr pair string
 ROW
 ROW
 ROW

 ScreenInfo->Rows points to the ROW array. ScreenInfo->Rows[0] is not
 necessarily the top row. ScreenInfo->BufferInfo.TextInfo.FirstRow contains the index of
 the top row.  That means scrolling (if scrolling entire screen)
 merely involves changing the FirstRow index,
 filling in the last row, and updating the screen.

--*/

#include "precomp.h"
#pragma hdrstop


//#define PROFILE_GDI
#ifdef PROFILE_GDI
LONG ScrollDCCount;
LONG ExtTextOutCount;
LONG TextColor = 1;

#define SCROLLDC_CALL ScrollDCCount++
#define TEXTOUT_CALL ExtTextOutCount++
#define TEXTCOLOR_CALL TextColor++
#else
#define SCROLLDC_CALL
#define TEXTOUT_CALL
#define TEXTCOLOR_CALL
#endif // PROFILE_GDI

#define ITEM_MAX_SIZE 256

// NOTE: we use this to communicate with progman - see Q105446 for details.
typedef struct _PMIconData {
       DWORD dwResSize;
       DWORD dwVer;
       BYTE iResource;  // icon resource
} PMICONDATA, *LPPMICONDATA;

//
// Screen dimensions
//

int ConsoleFullScreenX;
int ConsoleFullScreenY;
int ConsoleCaptionY;
int MinimumWidthX;
SHORT VerticalScrollSize;
SHORT HorizontalScrollSize;

SHORT VerticalClientToWindow;
SHORT HorizontalClientToWindow;

PCHAR_INFO ScrollBuffer;
ULONG ScrollBufferSize;
CRITICAL_SECTION ScrollBufferLock;

// this value keeps track of the number of existing console windows.
// if a window is created when this value is zero, the Face Names
// must be reenumerated because no WM_FONTCHANGE message was processed
// if there's no window.
LONG gnConsoleWindows;

BOOL gfInitSystemMetrics;

BOOL UsePolyTextOut;

HRGN ghrgnScroll;
LPRGNDATA gprgnData;

ULONG gucWheelScrollLines;

UINT guCaretBlinkTime;

#define GRGNDATASIZE (sizeof(RGNDATAHEADER) + (6 * sizeof(RECTL)))


#define LockScrollBuffer() RtlEnterCriticalSection(&ScrollBufferLock)
#define UnlockScrollBuffer() RtlLeaveCriticalSection(&ScrollBufferLock)

#define SetWindowConsole(hWnd, Console) SetWindowLongPtr((hWnd), GWLP_USERDATA, (LONG_PTR)(Console))

#ifdef LATER
#ifndef IS_IME_KBDLAYOUT
#define IS_IME_KBDLAYOUT(hkl) ((((ULONG_PTR)(hkl)) & 0xf0000000) == 0xe0000000)
#endif
#endif


VOID GetNonBiDiKeyboardLayout(
    HKL *phklActive);

VOID FreeConsoleBitmap(
    IN PSCREEN_INFORMATION ScreenInfo);

VOID
ScrollIfNecessary(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo
    );

VOID
ProcessResizeWindow(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCONSOLE_INFORMATION Console,
    IN LPWINDOWPOS WindowPos
    );

NTSTATUS
AllocateScrollBuffer(
    DWORD Size
    );

VOID FreeScrollBuffer ( VOID );

VOID
InternalUpdateScrollBars(
    IN PSCREEN_INFORMATION ScreenInfo
    );

#if defined(FE_SB)
BOOL
SB_PolyTextOutCandidate(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    );

VOID
SB_ConsolePolyTextOut(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    );
#endif



VOID
InitializeSystemMetrics( VOID )
{
    RECT WindowSize;

    gfInitSystemMetrics = FALSE;
    SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &gucWheelScrollLines, FALSE);
    ConsoleFullScreenX = GetSystemMetrics(SM_CXFULLSCREEN);
    ConsoleFullScreenY = GetSystemMetrics(SM_CYFULLSCREEN);
    ConsoleCaptionY = GetSystemMetrics(SM_CYCAPTION);
    VerticalScrollSize = (SHORT)GetSystemMetrics(SM_CXVSCROLL);
    HorizontalScrollSize = (SHORT)GetSystemMetrics(SM_CYHSCROLL);
    WindowSize.left = WindowSize.top = 0;
    WindowSize.right = WindowSize.bottom = 50;
    AdjustWindowRectEx(&WindowSize,
                        CONSOLE_WINDOW_FLAGS,
                        FALSE,
                        CONSOLE_WINDOW_EX_FLAGS
                       );
    VerticalClientToWindow = (SHORT)(WindowSize.right-WindowSize.left-50);
    HorizontalClientToWindow = (SHORT)(WindowSize.bottom-WindowSize.top-50);

#ifdef LATER
    gfIsIMEEnabled = !!GetSystemMetrics(SM_IMMENABLED);
    RIPMSG1(RIP_VERBOSE, "InitializeSystemMetrics: gfIsIMEEnabled=%d", gfIsIMEEnabled);
#endif

    guCaretBlinkTime = GetCaretBlinkTime();
}

VOID
GetWindowLimits(
    IN PSCREEN_INFORMATION ScreenInfo,
    OUT PWINDOW_LIMITS WindowLimits
    )
{
    HMONITOR hMonitor;
    MONITORINFO MonitorInfo = {sizeof(MonitorInfo)};
    COORD FontSize;

    //
    // If the system metrics have changed or there aren't any console
    // windows around, reinitialize the global valeus.
    //

    if (gfInitSystemMetrics || gnConsoleWindows == 0) {
        InitializeSystemMetrics();
    }

    if (ScreenInfo->Console &&
            (ScreenInfo->Console->hWnd || !(ScreenInfo->Console->Flags & CONSOLE_AUTO_POSITION)) &&
            ((hMonitor = MonitorFromRect(&ScreenInfo->Console->WindowRect, MONITOR_DEFAULTTOPRIMARY)) != NULL) &&
            GetMonitorInfo(hMonitor, &MonitorInfo)) {
        WindowLimits->FullScreenSize.X = (SHORT)(MonitorInfo.rcWork.right - MonitorInfo.rcWork.left);
        WindowLimits->FullScreenSize.Y = (SHORT)(MonitorInfo.rcWork.bottom - MonitorInfo.rcWork.top - ConsoleCaptionY);
    } else {
        WindowLimits->FullScreenSize.X = (SHORT)ConsoleFullScreenX;
        WindowLimits->FullScreenSize.Y = (SHORT)ConsoleFullScreenY;
    }

    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        FontSize = SCR_FONTSIZE(ScreenInfo);
    } else {
        FontSize.X = 1;
        FontSize.Y = 1;
    }

    WindowLimits->MinimumWindowSize.X = ((MinimumWidthX - VerticalClientToWindow + FontSize.X - 1) / FontSize.X);
    WindowLimits->MinimumWindowSize.Y = 1;
    WindowLimits->MaximumWindowSize.X = min(WindowLimits->FullScreenSize.X/FontSize.X, ScreenInfo->ScreenBufferSize.X);
    WindowLimits->MaximumWindowSize.X = max(WindowLimits->MaximumWindowSize.X, WindowLimits->MinimumWindowSize.X);
    WindowLimits->MaximumWindowSize.Y = min(WindowLimits->FullScreenSize.Y/FontSize.Y, ScreenInfo->ScreenBufferSize.Y);
    WindowLimits->MaxWindow.X = WindowLimits->MaximumWindowSize.X*FontSize.X + VerticalClientToWindow;
    WindowLimits->MaxWindow.Y = WindowLimits->MaximumWindowSize.Y*FontSize.Y + HorizontalClientToWindow;
}

VOID
InitializeScreenInfo( VOID )
{
    HDC hDC;

    InitializeMouseButtons();
    MinimumWidthX = GetSystemMetrics(SM_CXMIN);

    InitializeSystemMetrics();

    hDC = CreateDCW(L"DISPLAY", NULL, NULL, NULL);
    if (hDC != NULL) {
        UsePolyTextOut = GetDeviceCaps(hDC, TEXTCAPS) & TC_SCROLLBLT;
        DeleteDC(hDC);
    }
}

NTSTATUS
DoCreateScreenBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN PCONSOLE_INFO ConsoleInfo
    )

/*++

    this routine figures out what parameters to pass to CreateScreenBuffer,
    based on the data from STARTUPINFO and the defaults in win.ini,
    then calls CreateScreenBuffer.

--*/

{
    CHAR_INFO Fill,PopupFill;
    COORD dwScreenBufferSize, dwWindowSize;
    NTSTATUS Status;
    int FontIndexWant;

    if (ConsoleInfo->dwStartupFlags & STARTF_USESHOWWINDOW) {
        Console->wShowWindow = ConsoleInfo->wShowWindow;
    } else {
        Console->wShowWindow = SW_SHOWNORMAL;
    }

    //
    // Get values from consoleinfo (which was initialized through link).
    //

    Fill.Attributes = ConsoleInfo->wFillAttribute;
    Fill.Char.UnicodeChar = (WCHAR)' ';
    PopupFill.Attributes = ConsoleInfo->wPopupFillAttribute;
    PopupFill.Char.UnicodeChar = (WCHAR)' ';

    dwScreenBufferSize = ConsoleInfo->dwScreenBufferSize;
    if (!(ConsoleInfo->dwStartupFlags & STARTF_USECOUNTCHARS)) {
        if (Console->Flags & CONSOLE_NO_WINDOW) {
            dwScreenBufferSize.X = min(dwScreenBufferSize.X, 80);
            dwScreenBufferSize.Y = min(dwScreenBufferSize.Y, 25);
        }
    }
    if (dwScreenBufferSize.X == 0) {
        dwScreenBufferSize.X = 1;
    }
    if (dwScreenBufferSize.Y == 0) {
        dwScreenBufferSize.Y = 1;
    }

    //
    // Grab font
    //
#if defined(FE_SB)
    FontIndexWant = FindCreateFont(ConsoleInfo->uFontFamily,
                                   ConsoleInfo->FaceName,
                                   ConsoleInfo->dwFontSize,
                                   ConsoleInfo->uFontWeight,
                                   ConsoleInfo->uCodePage
                                  );
#else
    FontIndexWant = FindCreateFont(ConsoleInfo->uFontFamily,
                                   ConsoleInfo->FaceName,
                                   ConsoleInfo->dwFontSize,
                                   ConsoleInfo->uFontWeight);
#endif

    //
    // grab window size information
    //

    dwWindowSize = ConsoleInfo->dwWindowSize;
    if (ConsoleInfo->dwStartupFlags & STARTF_USESIZE) {
        dwWindowSize.X /= FontInfo[FontIndexWant].Size.X;
        dwWindowSize.Y /= FontInfo[FontIndexWant].Size.Y;
    } else if (Console->Flags & CONSOLE_NO_WINDOW) {
        dwWindowSize.X = min(dwWindowSize.X, 80);
        dwWindowSize.Y = min(dwWindowSize.Y, 25);
    }
    if (dwWindowSize.X == 0)
        dwWindowSize.X = 1;
    if (dwWindowSize.Y == 0)
        dwWindowSize.Y = 1;

    if (dwScreenBufferSize.X < dwWindowSize.X)
        dwScreenBufferSize.X = dwWindowSize.X;
    if (dwScreenBufferSize.Y < dwWindowSize.Y)
        dwScreenBufferSize.Y = dwWindowSize.Y;

    Console->dwWindowOriginX = ConsoleInfo->dwWindowOrigin.X;
    Console->dwWindowOriginY = ConsoleInfo->dwWindowOrigin.Y;

    if (ConsoleInfo->bAutoPosition) {
        Console->Flags |= CONSOLE_AUTO_POSITION;
        Console->dwWindowOriginX = CW_USEDEFAULT;
    } else {
        Console->WindowRect.left = Console->dwWindowOriginX;
        Console->WindowRect.top = Console->dwWindowOriginY;
        Console->WindowRect.right = Console->dwWindowOriginX + dwWindowSize.X * FontInfo[FontIndexWant].Size.X;
        Console->WindowRect.bottom = Console->dwWindowOriginY + dwWindowSize.Y * FontInfo[FontIndexWant].Size.Y;
    }

#ifdef i386
    if (FullScreenInitialized && !GetSystemMetrics(SM_REMOTESESSION)) {
        if (ConsoleInfo->bFullScreen) {
            Console->FullScreenFlags = CONSOLE_FULLSCREEN;
        }
    }
#endif
    if (ConsoleInfo->bQuickEdit) {
        Console->Flags |= CONSOLE_QUICK_EDIT_MODE;
    }
    Console->Flags |= CONSOLE_USE_PRIVATE_FLAGS;

    Console->InsertMode = (ConsoleInfo->bInsertMode != FALSE);
    Console->CommandHistorySize = (SHORT)ConsoleInfo->uHistoryBufferSize;
    Console->MaxCommandHistories = (SHORT)ConsoleInfo->uNumberOfHistoryBuffers;
    if (ConsoleInfo->bHistoryNoDup) {
        Console->Flags |= CONSOLE_HISTORY_NODUP;
    } else {
        Console->Flags &= ~CONSOLE_HISTORY_NODUP;
    }
    RtlCopyMemory(Console->ColorTable, ConsoleInfo->ColorTable, sizeof( Console->ColorTable ));

#if defined(FE_SB)
    // for FarEast version, we want get the code page from registry or shell32,
    // so we can specify console codepage by console.cpl or shell32
    // default codepage is OEMCP. scotthsu
    Console->CP = ConsoleInfo->uCodePage;
    Console->OutputCP = ConsoleInfo->uCodePage;
    Console->fIsDBCSCP = CONSOLE_IS_DBCS_ENABLED() && IsAvailableFarEastCodePage(Console->CP);
    Console->fIsDBCSOutputCP = CONSOLE_IS_DBCS_ENABLED() && IsAvailableFarEastCodePage(Console->OutputCP);
#endif
#if defined(FE_IME)
    Console->ConsoleIme.ScrollWaitTimeout = guCaretBlinkTime * 2;
#endif
TryNewSize:
    Status = CreateScreenBuffer(&Console->ScreenBuffers,
                                dwWindowSize,
                                FontIndexWant,
                                dwScreenBufferSize,
                                Fill,
                                PopupFill,
                                Console,
                                CONSOLE_TEXTMODE_BUFFER,
                                NULL,
                                NULL,
                                NULL,
                                ConsoleInfo->uCursorSize,
                                ConsoleInfo->FaceName
                               );
    if (Status == STATUS_NO_MEMORY) {
        //
        // If we failed to create a large buffer, try again with a small one.
        //
        if (dwScreenBufferSize.X > 80 || dwScreenBufferSize.Y > 50) {
            dwScreenBufferSize.X = min(dwScreenBufferSize.X, 80);
            dwScreenBufferSize.Y = min(dwScreenBufferSize.Y, 50);
            dwWindowSize.X = min(dwWindowSize.X, dwScreenBufferSize.X);
            dwWindowSize.Y = min(dwWindowSize.Y, dwScreenBufferSize.Y);
            Console->Flags |= CONSOLE_DEFAULT_BUFFER_SIZE;
            goto TryNewSize;
        }
    }

    return Status;
}

NTSTATUS
CreateScreenBuffer(
    OUT PSCREEN_INFORMATION *ScreenInformation,
    IN COORD dwWindowSize,
    IN DWORD nFont,
    IN COORD dwScreenBufferSize,
    IN CHAR_INFO Fill,
    IN CHAR_INFO PopupFill,
    IN PCONSOLE_INFORMATION Console,
    IN DWORD Flags,
    IN PCONSOLE_GRAPHICS_BUFFER_INFO GraphicsBufferInfo OPTIONAL,
    OUT PVOID *lpBitmap OPTIONAL,
    OUT HANDLE *hMutex OPTIONAL,
    IN UINT CursorSize,
    IN LPWSTR FaceName
    )

/*++

Routine Description:

    This routine allocates and initializes the data associated with a screen
    buffer.  It also creates a window.

Arguments:

    ScreenInformation - the new screen buffer.

    dwWindowSize - the initial size of screen buffer's window (in rows/columns)

    nFont - the initial font to generate text with.

    dwScreenBufferSize - the initial size of the screen buffer (in rows/columns).

Return Value:


--*/

{
    LONG i,j;
    PSCREEN_INFORMATION ScreenInfo;
    NTSTATUS Status;
    PWCHAR TextRowPtr;
#if defined(FE_SB)
    PBYTE AttrRowPtr;
#endif
    WINDOW_LIMITS WindowLimits;

    /*
     * Make sure we have a valid font. Bail if no fonts are available.
     */
    ASSERT(nFont < NumberOfFonts);
    if (NumberOfFonts == 0) {
        return STATUS_UNSUCCESSFUL;
    }

    ScreenInfo = ConsoleHeapAlloc(SCREEN_TAG, sizeof(SCREEN_INFORMATION));
    if (ScreenInfo == NULL) {
        return STATUS_NO_MEMORY;
    }

    ScreenInfo->Console = Console;
    ScreenInfo->Flags = Flags;
    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {

        ASSERT(FontInfo[nFont].FaceName != NULL);

        ScreenInfo->BufferInfo.TextInfo.ListOfTextBufferFont = NULL;

        Status = StoreTextBufferFontInfo(ScreenInfo,
                                         nFont,
                                         FontInfo[nFont].Size,
                                         FontInfo[nFont].Family,
                                         FontInfo[nFont].Weight,
                                         FaceName ? FaceName : FontInfo[nFont].FaceName,
                                         Console->OutputCP);
        if (!NT_SUCCESS(Status)) {
            ConsoleHeapFree(ScreenInfo);
            return((ULONG) Status);
        }

        DBGFONTS(("DoCreateScreenBuffer sets FontSize(%d,%d), FontNumber=%x, Family=%x\n",
                SCR_FONTSIZE(ScreenInfo).X,
                SCR_FONTSIZE(ScreenInfo).Y,
                SCR_FONTNUMBER(ScreenInfo),
                SCR_FAMILY(ScreenInfo)));

        if (TM_IS_TT_FONT(FontInfo[nFont].Family)) {
            ScreenInfo->Flags &= ~CONSOLE_OEMFONT_DISPLAY;
        } else {
            ScreenInfo->Flags |= CONSOLE_OEMFONT_DISPLAY;
        }

        ScreenInfo->ScreenBufferSize = dwScreenBufferSize;
        GetWindowLimits(ScreenInfo, &WindowLimits);
        dwScreenBufferSize.X = max(dwScreenBufferSize.X, WindowLimits.MinimumWindowSize.X);
        dwWindowSize.X = max(dwWindowSize.X, WindowLimits.MinimumWindowSize.X);

        ScreenInfo->BufferInfo.TextInfo.ModeIndex = (ULONG)-1;
#ifdef i386
        if (Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
            COORD WindowSize;
            ScreenInfo->BufferInfo.TextInfo.WindowedWindowSize = dwWindowSize;
            ScreenInfo->BufferInfo.TextInfo.WindowedScreenSize = dwScreenBufferSize;
            ScreenInfo->BufferInfo.TextInfo.ModeIndex = MatchWindowSize(Console->OutputCP,dwWindowSize,&WindowSize);
        }
#endif
        ScreenInfo->BufferInfo.TextInfo.FirstRow = 0;
        ScreenInfo->BufferInfo.TextInfo.Rows = ConsoleHeapAlloc(SCREEN_TAG, dwScreenBufferSize.Y * sizeof(ROW));
        if (ScreenInfo->BufferInfo.TextInfo.Rows == NULL) {
            RemoveTextBufferFontInfo(ScreenInfo);
            ConsoleHeapFree(ScreenInfo);
            return STATUS_NO_MEMORY;
        }
        ScreenInfo->BufferInfo.TextInfo.TextRows = ConsoleHeapAlloc(SCREEN_TAG, dwScreenBufferSize.X * dwScreenBufferSize.Y * sizeof(WCHAR));
        if (ScreenInfo->BufferInfo.TextInfo.TextRows == NULL) {
            ConsoleHeapFree(ScreenInfo->BufferInfo.TextInfo.Rows);
            RemoveTextBufferFontInfo(ScreenInfo);
            ConsoleHeapFree(ScreenInfo);
            return STATUS_NO_MEMORY;
        }
#if defined(FE_SB)
        if (!CreateDbcsScreenBuffer(Console, dwScreenBufferSize, &ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer)) {
            ConsoleHeapFree(ScreenInfo->BufferInfo.TextInfo.TextRows);
            ConsoleHeapFree(ScreenInfo->BufferInfo.TextInfo.Rows);
            RemoveTextBufferFontInfo(ScreenInfo);
            ConsoleHeapFree(ScreenInfo);
            return STATUS_NO_MEMORY;
        }

        AttrRowPtr=ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.KAttrRows;
#endif
        for (i=0,TextRowPtr=ScreenInfo->BufferInfo.TextInfo.TextRows;
             i<dwScreenBufferSize.Y;
             i++,TextRowPtr+=dwScreenBufferSize.X)
        {
            ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.Left = dwScreenBufferSize.X;
            ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.OldLeft = INVALID_OLD_LENGTH;
            ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.Right = 0;
            ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.OldRight = INVALID_OLD_LENGTH;
            ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.Chars = TextRowPtr;
#if defined(FE_SB)
            ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.KAttrs = AttrRowPtr;
#endif
            for (j=0;j<dwScreenBufferSize.X;j++) {
                TextRowPtr[j] = (WCHAR)' ';
            }
#if defined(FE_SB)
            if (AttrRowPtr) {
                RtlZeroMemory(AttrRowPtr, dwScreenBufferSize.X);
                AttrRowPtr+=dwScreenBufferSize.X;
            }
#endif
            ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Length = 1;
            ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.AttrPair.Length = dwScreenBufferSize.X;
            ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.AttrPair.Attr = Fill.Attributes;
            ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs = &ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.AttrPair;

        }
        ScreenInfo->BufferInfo.TextInfo.CursorSize = CursorSize;
        ScreenInfo->BufferInfo.TextInfo.CursorPosition.X = 0;
        ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y = 0;
        ScreenInfo->BufferInfo.TextInfo.CursorMoved = FALSE;
        ScreenInfo->BufferInfo.TextInfo.CursorVisible = TRUE;
        ScreenInfo->BufferInfo.TextInfo.CursorOn = FALSE;
        ScreenInfo->BufferInfo.TextInfo.CursorYSize = (WORD)CURSOR_SIZE_IN_PIXELS(SCR_FONTSIZE(ScreenInfo).Y,ScreenInfo->BufferInfo.TextInfo.CursorSize);
        ScreenInfo->BufferInfo.TextInfo.UpdatingScreen = 0;
        ScreenInfo->BufferInfo.TextInfo.DoubleCursor = FALSE;
        ScreenInfo->BufferInfo.TextInfo.DelayCursor = FALSE;
        ScreenInfo->BufferInfo.TextInfo.Flags = SINGLE_ATTRIBUTES_PER_LINE;
        ScreenInfo->ScreenBufferSize = dwScreenBufferSize;
        ScreenInfo->Window.Left = 0;
        ScreenInfo->Window.Top = 0;
        ScreenInfo->Window.Right = dwWindowSize.X - 1;
        ScreenInfo->Window.Bottom = dwWindowSize.Y - 1;
        if (ScreenInfo->Window.Right >= WindowLimits.MaximumWindowSize.X) {
            ScreenInfo->Window.Right = WindowLimits.MaximumWindowSize.X-1;
            dwWindowSize.X = CONSOLE_WINDOW_SIZE_X(ScreenInfo);
        }
        if (ScreenInfo->Window.Bottom >= WindowLimits.MaximumWindowSize.Y) {
            ScreenInfo->Window.Bottom = WindowLimits.MaximumWindowSize.Y-1;
            dwWindowSize.Y = CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
        }
        ScreenInfo->WindowMaximizedX = (dwWindowSize.X == dwScreenBufferSize.X);
        ScreenInfo->WindowMaximizedY = (dwWindowSize.Y == dwScreenBufferSize.Y);
#if defined(FE_SB)
#if defined(_X86_)
        ScreenInfo->BufferInfo.TextInfo.MousePosition.X = 0;
        ScreenInfo->BufferInfo.TextInfo.MousePosition.Y = 0;
#endif // i386

        ScreenInfo->BufferInfo.TextInfo.CursorBlink = TRUE;
        ScreenInfo->BufferInfo.TextInfo.CursorDBEnable = TRUE;
#endif

    }
    else {
        Status = CreateConsoleBitmap(GraphicsBufferInfo,
                              ScreenInfo,
                              lpBitmap,
                              hMutex
                             );
        if (!NT_SUCCESS(Status)) {
            ConsoleHeapFree(ScreenInfo);
            return Status;
        }
        ScreenInfo->WindowMaximizedX = TRUE;
        ScreenInfo->WindowMaximizedY = TRUE;
    }

    ScreenInfo->WindowMaximized = FALSE;
    ScreenInfo->RefCount = 0;
    ScreenInfo->ShareAccess.OpenCount = 0;
    ScreenInfo->ShareAccess.Readers = 0;
    ScreenInfo->ShareAccess.Writers = 0;
    ScreenInfo->ShareAccess.SharedRead = 0;
    ScreenInfo->ShareAccess.SharedWrite = 0;
    ScreenInfo->CursorHandle = ghNormalCursor;
    ScreenInfo->CursorDisplayCount = 0;
    ScreenInfo->CommandIdLow = (UINT)-1;
    ScreenInfo->CommandIdHigh = (UINT)-1;
    ScreenInfo->dwUsage = SYSPAL_STATIC;
    ScreenInfo->hPalette = NULL;

    ScreenInfo->OutputMode = ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT;


    ScreenInfo->ResizingWindow = 0;
    ScreenInfo->Next = NULL;
    ScreenInfo->Attributes = Fill.Attributes;
    ScreenInfo->PopupAttributes = PopupFill.Attributes;

    ScreenInfo->WheelDelta = 0;

#if defined(FE_SB)
    ScreenInfo->WriteConsoleDbcsLeadByte[0] = 0;
    ScreenInfo->BisectFlag = 0;
    if (Flags & CONSOLE_TEXTMODE_BUFFER) {
        SetLineChar(ScreenInfo);
    }
    ScreenInfo->FillOutDbcsLeadChar = 0;
    ScreenInfo->ConvScreenInfo = NULL;
#endif

    *ScreenInformation = ScreenInfo;
    DBGOUTPUT(("SCREEN at %lx\n", ScreenInfo));
    return STATUS_SUCCESS;
}

VOID
PositionConsoleWindow(
    IN PCONSOLE_INFORMATION Console,
    IN BOOL Initialize
    )
{
    GetWindowRect(Console->hWnd, &Console->WindowRect);

    //
    // If this is an autoposition window being initialized, make sure it's
    // client area doesn't descend below the tray
    //

    if (Initialize && (Console->Flags & CONSOLE_AUTO_POSITION)) {
        RECT ClientRect;
        LONG dx = 0;
        LONG dy = 0;
        HMONITOR hMonitor;
        MONITORINFO MonitorInfo = {sizeof(MonitorInfo)};

        hMonitor = MonitorFromRect(&Console->WindowRect, MONITOR_DEFAULTTONULL);
        if (hMonitor && GetMonitorInfo(hMonitor, &MonitorInfo)) {
            GetClientRect(Console->hWnd, &ClientRect);
            ClientToScreen(Console->hWnd, (LPPOINT)&ClientRect.left);
            ClientToScreen(Console->hWnd, (LPPOINT)&ClientRect.right);
            if (Console->WindowRect.right > MonitorInfo.rcWork.right) {
                dx = max(min((Console->WindowRect.right - MonitorInfo.rcWork.right),
                             (Console->WindowRect.left - MonitorInfo.rcWork.left)),
                         min((ClientRect.right - MonitorInfo.rcWork.right),
                             (ClientRect.left - MonitorInfo.rcWork.left)));
            }
            if (Console->WindowRect.bottom > MonitorInfo.rcWork.bottom) {
                dy = max(min((Console->WindowRect.bottom - MonitorInfo.rcWork.bottom),
                             (Console->WindowRect.top - MonitorInfo.rcWork.top)),
                         min((ClientRect.bottom - MonitorInfo.rcWork.bottom),
                             (ClientRect.top - MonitorInfo.rcWork.top)));
            }
            if (dx || dy) {
                SetWindowPos(Console->hWnd,
                             NULL,
                             Console->WindowRect.left - dx,
                             Console->WindowRect.top - dy,
                             0,
                             0,
                             SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
            }
        }
    }
}

/*
 * Bug 273518 - joejo
 *
 * This will allow console windows to set foreground correctly on new
 * process' it launches, as opposed it just forcing foreground.
 */
NTSTATUS
ConsoleSetActiveWindow(
    IN PCONSOLE_INFORMATION Console
    )
{
    HWND hWnd = Console->hWnd;
    HANDLE ConsoleHandle = Console->ConsoleHandle;

    UnlockConsole(Console);
    SetActiveWindow(hWnd);
    return RevalidateConsole(ConsoleHandle, &Console);
}

NTSTATUS
CreateWindowsWindow(
    IN PCONSOLE_INFORMATION Console
    )
{
    PSCREEN_INFORMATION ScreenInfo;
    SIZE WindowSize;
    DWORD Style;
    THREAD_BASIC_INFORMATION ThreadInfo;
    HWND hWnd;

    ScreenInfo = Console->ScreenBuffers;

    //
    // figure out how big to make the window, given the desired client area
    // size.  window is always created in textmode.
    //

    ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
    WindowSize.cx = CONSOLE_WINDOW_SIZE_X(ScreenInfo)*SCR_FONTSIZE(ScreenInfo).X + VerticalClientToWindow;
    WindowSize.cy = CONSOLE_WINDOW_SIZE_Y(ScreenInfo)*SCR_FONTSIZE(ScreenInfo).Y + HorizontalClientToWindow;
    Style = CONSOLE_WINDOW_FLAGS & ~WS_VISIBLE;
    if (!ScreenInfo->WindowMaximizedX) {
        WindowSize.cy += HorizontalScrollSize;
    } else {
        Style &= ~WS_HSCROLL;
    }
    if (!ScreenInfo->WindowMaximizedY) {
        WindowSize.cx += VerticalScrollSize;
    } else {
        Style &= ~WS_VSCROLL;
    }

    //
    // create the window.
    //

    Console->WindowRect.left = Console->dwWindowOriginX;
    Console->WindowRect.top = Console->dwWindowOriginY;
    Console->WindowRect.right = WindowSize.cx + Console->dwWindowOriginX;
    Console->WindowRect.bottom = WindowSize.cy + Console->dwWindowOriginY;
    hWnd = CreateWindowEx(CONSOLE_WINDOW_EX_FLAGS,
                          CONSOLE_WINDOW_CLASS,
                          Console->Title,
                          Style,
                          Console->dwWindowOriginX,
                          Console->dwWindowOriginY,
                          WindowSize.cx,
                          WindowSize.cy,
                          (Console->Flags & CONSOLE_NO_WINDOW) ? HWND_MESSAGE : HWND_DESKTOP,
                          NULL,
                          ghInstance,
                          NULL);
    if (hWnd == NULL) {
        NtSetEvent(Console->InitEvents[INITIALIZATION_FAILED],NULL);
        return STATUS_NO_MEMORY;
    }

    Console->hWnd = hWnd;

    SetWindowConsole(hWnd, Console);

    //
    // Stuff the client id into the window so USER can find it.
    //

    if (NT_SUCCESS(NtQueryInformationThread(Console->ClientThreadHandle,
            ThreadBasicInformation, &ThreadInfo,
            sizeof(ThreadInfo), NULL))) {

        SetConsolePid(Console->hWnd, HandleToUlong(ThreadInfo.ClientId.UniqueProcess));
        SetConsoleTid(Console->hWnd, HandleToUlong(ThreadInfo.ClientId.UniqueThread));
    }

    //
    // Get the dc.
    //

    Console->hDC = GetDC(Console->hWnd);

    if (Console->hDC == NULL) {
        NtSetEvent(Console->InitEvents[INITIALIZATION_FAILED],NULL);
        DestroyWindow(Console->hWnd);
        Console->hWnd = NULL;
        return STATUS_NO_MEMORY;
    }
    Console->hMenu = GetSystemMenu(Console->hWnd,FALSE);

    //
    // modify system menu to our liking.
    //

    InitSystemMenu(Console);

    gnConsoleWindows++;
    Console->InputThreadInfo->WindowCount++;

#if defined(FE_IME)
    SetUndetermineAttribute(Console);
#endif
#if defined(FE_SB)
    RegisterKeisenOfTTFont(ScreenInfo);
#endif

    //
    // Set up the hot key for this window
    //
    if ((Console->dwHotKey != 0) && !(Console->Flags & CONSOLE_NO_WINDOW)) {
        SendMessage(Console->hWnd, WM_SETHOTKEY, Console->dwHotKey, 0L);
    }

    //
    // create icon
    //

    if (Console->iIconId) {

        // We have no icon, try and get one from progman.

        PostMessage(HWND_BROADCAST,
                    ProgmanHandleMessage,
                    (WPARAM)Console->hWnd,
                    1);
    }
    if (Console->hIcon == NULL) {
        Console->hIcon = ghDefaultIcon;
        Console->hSmIcon = ghDefaultSmIcon;
    } else if (Console->hIcon != ghDefaultIcon) {
        SendMessage(Console->hWnd, WM_SETICON, ICON_BIG, (LPARAM)Console->hIcon);
        SendMessage(Console->hWnd, WM_SETICON, ICON_SMALL, (LPARAM)Console->hSmIcon);
    }

    SetBkMode(Console->hDC,OPAQUE);
    SetFont(ScreenInfo);
    SelectObject(Console->hDC, GetStockObject(DC_BRUSH));
    SetScreenColors(ScreenInfo, ScreenInfo->Attributes,
                    ScreenInfo->PopupAttributes, FALSE);
    if (Console->Flags & CONSOLE_NO_WINDOW) {
        ShowWindowAsync(Console->hWnd, SW_HIDE);
#ifdef i386
    } else if (Console->FullScreenFlags != 0) {
        if (Console->wShowWindow == SW_SHOWMINNOACTIVE) {
            ShowWindowAsync(Console->hWnd, Console->wShowWindow);
            Console->FullScreenFlags = 0;
            Console->Flags |= CONSOLE_IS_ICONIC;
        } else {
            ConvertToFullScreen(Console);
            if (!NT_SUCCESS(ConsoleSetActiveWindow(Console))) {
                return STATUS_INVALID_HANDLE;
            }

            ChangeDispSettings(Console, Console->hWnd,CDS_FULLSCREEN);
        }
#endif
    } else {
        if (Console->wShowWindow != SW_SHOWNOACTIVATE &&
            Console->wShowWindow != SW_SHOWMINNOACTIVE &&
            Console->wShowWindow != SW_HIDE) {
            if (!NT_SUCCESS(ConsoleSetActiveWindow(Console))) {
                return STATUS_INVALID_HANDLE;
            }
        } else if (Console->wShowWindow == SW_SHOWMINNOACTIVE) {
            Console->Flags |= CONSOLE_IS_ICONIC;
        }
        ShowWindowAsync(Console->hWnd, Console->wShowWindow);
    }

    //UpdateWindow(Console->hWnd);
    InternalUpdateScrollBars(ScreenInfo);
    if (!(Console->Flags & CONSOLE_IS_ICONIC) &&
         (Console->FullScreenFlags == 0) ) {

        PositionConsoleWindow(Console, TRUE);
    }

#if defined(FE_IME)
    if (CONSOLE_IS_IME_ENABLED() && !(Console->Flags & CONSOLE_NO_WINDOW)) {
        SetTimer(Console->hWnd, SCROLL_WAIT_TIMER, guCaretBlinkTime, NULL);
    }
#endif
    NtSetEvent(Console->InitEvents[INITIALIZATION_SUCCEEDED],NULL);
    return STATUS_SUCCESS;
}

NTSTATUS
FreeScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine frees the memory associated with a screen buffer.

Arguments:

    ScreenInfo - screen buffer data to free.

Return Value:

Note: console handle table lock must be held when calling this routine

--*/

{
    SHORT i;
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    ASSERT(ScreenInfo->RefCount == 0);
    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        for (i=0;i<ScreenInfo->ScreenBufferSize.Y;i++) {
            if (ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Length > 1) {
                ConsoleHeapFree(ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs);
            }
        }
        ConsoleHeapFree(ScreenInfo->BufferInfo.TextInfo.TextRows);
        ConsoleHeapFree(ScreenInfo->BufferInfo.TextInfo.Rows);
#if defined(FE_SB)
        DeleteDbcsScreenBuffer(&ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer);
#endif
        RemoveTextBufferFontInfo(ScreenInfo);
    } else {
        if (ScreenInfo->hPalette != NULL) {
            if (GetCurrentObject(Console->hDC, OBJ_PAL) == ScreenInfo->hPalette) {
                SelectPalette(Console->hDC, Console->hSysPalette, FALSE);
            }
            DeleteObject(ScreenInfo->hPalette);
        }
        FreeConsoleBitmap(ScreenInfo);
    }
    ConsoleHeapFree(ScreenInfo);
    return STATUS_SUCCESS;
}

VOID
FindAttrIndex(
    IN PATTR_PAIR String,
    IN SHORT Index,
    OUT PATTR_PAIR *IndexedAttr,
    OUT PSHORT CountOfAttr
    )

/*++

Routine Description:

    This routine finds the nth attribute in a string.

Arguments:

    String - attribute string

    Index - which attribute to find

    IndexedAttr - pointer to attribute within string

    CountOfAttr - on output, contains corrected length of indexed attr.
    for example, if the attribute string was { 5, BLUE } and the requested
    index was 3, CountOfAttr would be 2.

Return Value:

    none.

--*/

{
    SHORT i;

    for (i=0;i<Index;) {
        i += String->Length;
        String++;
    }

    if (i>Index) {
        String--;
        *CountOfAttr = i-Index;
    }
    else {
        *CountOfAttr = String->Length;
    }
    *IndexedAttr = String;
}



NTSTATUS
MergeAttrStrings(
    IN PATTR_PAIR Source,
    IN WORD SourceLength,
    IN PATTR_PAIR Merge,
    IN WORD MergeLength,
    OUT PATTR_PAIR *Target,
    OUT LPWORD TargetLength,
    IN SHORT StartIndex,
    IN SHORT EndIndex,
    IN PROW Row,
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine merges two run-length encoded attribute strings into
    a third.

    for example, if the source string was { 4, BLUE }, the merge string
    was { 2, RED }, and the StartIndex and EndIndex were 1 and 2,
    respectively, the target string would be { 1, BLUE, 2, RED, 1, BLUE }
    and the target length would be 3.

Arguments:

    Source - pointer to source attribute string

    SourceLength - length of source.  for example, the length of
    { 4, BLUE } is 1.

    Merge - pointer to attribute string to insert into source

    MergeLength - length of merge

    Target - where to store pointer to resulting attribute string

    TargetLength - where to store length of resulting attribute string

    StartIndex - index into Source at which to insert Merge String.

    EndIndex - index into Source at which to stop insertion of Merge String

Return Value:

    none.

--*/
{
    PATTR_PAIR SrcAttr,TargetAttr,SrcEnd;
    PATTR_PAIR NewString;
    SHORT i;

    //
    // if just changing the attr for the whole row
    //

    if (MergeLength == 1 && Row->AttrRow.Length == 1) {
        if (Row->AttrRow.Attrs->Attr == Merge->Attr) {
            *TargetLength = 1;
            *Target = &Row->AttrRow.AttrPair;
            return STATUS_SUCCESS;
        }
        if (StartIndex == 0 && EndIndex == (SHORT)(ScreenInfo->ScreenBufferSize.X-1)) {
            NewString = &Row->AttrRow.AttrPair;
            NewString->Attr = Merge->Attr;
            *TargetLength = 1;
            *Target = NewString;
            return STATUS_SUCCESS;
        }
    }

    NewString = ConsoleHeapAlloc(SCREEN_TAG, (SourceLength + MergeLength + 1) * sizeof(ATTR_PAIR));
    if (NewString == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // copy the source string, up to the start index.
    //

    SrcAttr = Source;
    SrcEnd = Source + SourceLength;
    TargetAttr = NewString;
    i=0;
    if (StartIndex != 0) {
        while (i<StartIndex) {
            i += SrcAttr->Length;
            *TargetAttr++ = *SrcAttr++;
        }

        //
        // back up to the last pair copied, in case the attribute in the first
        // pair in the merge string matches.  also, adjust TargetAttr->Length
        // based on i, the attribute
        // counter, back to the StartIndex.  i will be larger than the
        // StartIndex in the case where the last attribute pair copied had
        // a length greater than the number needed to reach StartIndex.
        //

        TargetAttr--;
        if (i>StartIndex) {
            TargetAttr->Length -= i-StartIndex;
        }
        if (Merge->Attr == TargetAttr->Attr) {
            TargetAttr->Length += Merge->Length;
            MergeLength-=1;
            Merge++;
        }
        TargetAttr++;
    }

    //
    // copy the merge string.
    //

    RtlCopyMemory(TargetAttr,Merge,MergeLength*sizeof(ATTR_PAIR));
    TargetAttr += MergeLength;

    //
    // figure out where to resume copying the source string.
    //

    while (i<=EndIndex) {
        ASSERT(SrcAttr != SrcEnd);
        i += SrcAttr->Length;
        SrcAttr++;
    }

    //
    // if not done, copy the rest of the source
    //

    if (SrcAttr != SrcEnd || i!=(SHORT)(EndIndex+1)) {

        //
        // see if we've gone past the right attribute.  if so, back up and
        // copy the attribute and the correct length.
        //

        TargetAttr--;
        if (i>(SHORT)(EndIndex+1)) {
            SrcAttr--;
            if (TargetAttr->Attr == SrcAttr->Attr) {
                TargetAttr->Length += i-(EndIndex+1);
            } else {
                TargetAttr++;
                TargetAttr->Attr = SrcAttr->Attr;
                TargetAttr->Length = (SHORT)(i-(EndIndex+1));
            }
            SrcAttr++;
        }

        //
        // see if we can merge the source and target.
        //

        else if (TargetAttr->Attr == SrcAttr->Attr) {
            TargetAttr->Length += SrcAttr->Length;
            i += SrcAttr->Length;
            SrcAttr++;
        }
        TargetAttr++;

        //
        // copy the rest of the source
        //

        if (SrcAttr < SrcEnd) {
            RtlCopyMemory(TargetAttr,SrcAttr,(SrcEnd-SrcAttr)*sizeof(ATTR_PAIR));
            TargetAttr += SrcEnd - SrcAttr;
        }
    }

    *TargetLength = (WORD)(TargetAttr - NewString);
    *Target = NewString;
    if (*TargetLength == 1) {
        *Target = &Row->AttrRow.AttrPair;
        **Target = *NewString;
        ConsoleHeapFree(NewString);
    }
    return STATUS_SUCCESS;
}

VOID
ResetTextFlags(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN SHORT StartX,
    IN SHORT StartY,
    IN SHORT EndX,
    IN SHORT EndY
    )
{
    SHORT RowIndex;
    PROW Row;
    WCHAR Char;
    PATTR_PAIR Attr;
    SHORT CountOfAttr;
    SHORT i;

    //
    // Fire off a winevent to let accessibility apps know what changed.
    //

    if (ACTIVE_SCREEN_BUFFER(ScreenInfo)) {
        ASSERT(EndX < ScreenInfo->ScreenBufferSize.X);
        if (StartX == EndX && StartY == EndY) {
            RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+StartY) % ScreenInfo->ScreenBufferSize.Y;
            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
            Char = Row->CharRow.Chars[StartX];
            FindAttrIndex(Row->AttrRow.Attrs, StartX, &Attr, &CountOfAttr);
            ConsoleNotifyWinEvent(ScreenInfo->Console,
                                  EVENT_CONSOLE_UPDATE_SIMPLE,
                                  MAKELONG(StartX, StartY),
                                  MAKELONG(Char, Attr->Attr));
        } else {
            ConsoleNotifyWinEvent(ScreenInfo->Console,
                                  EVENT_CONSOLE_UPDATE_REGION,
                                  MAKELONG(StartX, StartY),
                                  MAKELONG(EndX, EndY));
        }
    }

    //
    // first see whether we wrote any lines with multiple attributes.  if
    // we did, set the flags and bail out.  also, remember if any of the
    // lines we wrote had attributes different from other lines.
    //

    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+StartY) % ScreenInfo->ScreenBufferSize.Y;
    for (i=StartY;i<=EndY;i++) {
        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
        if (Row->AttrRow.Length != 1) {
            ScreenInfo->BufferInfo.TextInfo.Flags &= ~SINGLE_ATTRIBUTES_PER_LINE;
            return;
        }
        if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
            RowIndex = 0;
        }
    }

    // all of the written lines have the same attribute.

    if (ScreenInfo->BufferInfo.TextInfo.Flags & SINGLE_ATTRIBUTES_PER_LINE) {
        return;
    }

    if (StartY == 0 && EndY == (ScreenInfo->ScreenBufferSize.Y-1)) {
        ScreenInfo->BufferInfo.TextInfo.Flags |= SINGLE_ATTRIBUTES_PER_LINE;
        return;
    }

    RowIndex = ScreenInfo->BufferInfo.TextInfo.FirstRow;
    for (i=0;i<StartY;i++) {
        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
        if (Row->AttrRow.Length != 1) {
            return;
        }
        if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
            RowIndex = 0;
        }
        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
    }
    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+EndY+1) % ScreenInfo->ScreenBufferSize.Y;
    for (i=EndY+1;i<ScreenInfo->ScreenBufferSize.Y;i++) {
        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
        if (Row->AttrRow.Length != 1) {
            return;
        }
        if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
            RowIndex = 0;
        }
    }
    ScreenInfo->BufferInfo.TextInfo.Flags |= SINGLE_ATTRIBUTES_PER_LINE;
}


VOID
ReadRectFromScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD SourcePoint,
    IN PCHAR_INFO Target,
    IN COORD TargetSize,
    IN PSMALL_RECT TargetRect
    )

/*++

Routine Description:

    This routine copies a rectangular region from the screen buffer.
    no clipping is done.

Arguments:

    ScreenInfo - pointer to screen info

    SourcePoint - upper left coordinates of source rectangle

    Target - pointer to target buffer

    TargetSize - dimensions of target buffer

    TargetRect - rectangle in source buffer to copy

Return Value:

    none.

--*/

{

    PCHAR_INFO TargetPtr;
    SHORT i,j,k;
    SHORT XSize,YSize;
    BOOLEAN WholeTarget;
    SHORT RowIndex;
    PROW Row;
    PWCHAR Char;
    PATTR_PAIR Attr;
    SHORT CountOfAttr;

    DBGOUTPUT(("ReadRectFromScreenBuffer\n"));

    XSize = (SHORT)(TargetRect->Right - TargetRect->Left + 1);
    YSize = (SHORT)(TargetRect->Bottom - TargetRect->Top + 1);

    TargetPtr = Target;
    WholeTarget = FALSE;
    if (XSize == TargetSize.X) {
        ASSERT (TargetRect->Left == 0);
        if (TargetRect->Top != 0) {
            TargetPtr = (PCHAR_INFO)
                ((PBYTE)Target + SCREEN_BUFFER_POINTER(TargetRect->Left,
                                                       TargetRect->Top,
                                                       TargetSize.X,
                                                       sizeof(CHAR_INFO)));
        }
        WholeTarget = TRUE;
    }
    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+SourcePoint.Y) % ScreenInfo->ScreenBufferSize.Y;
    for (i=0;i<YSize;i++) {
        if (!WholeTarget) {
            TargetPtr = (PCHAR_INFO)
                ((PBYTE)Target + SCREEN_BUFFER_POINTER(TargetRect->Left,
                                                       TargetRect->Top+i,
                                                       TargetSize.X,
                                                       sizeof(CHAR_INFO)));
        }

        //
        // copy the chars and attrs from their respective arrays
        //

        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
        Char = &Row->CharRow.Chars[SourcePoint.X];
        FindAttrIndex(Row->AttrRow.Attrs,
                      SourcePoint.X,
                      &Attr,
                      &CountOfAttr
                     );
        k=0;
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console)) {
            PBYTE AttrP = &Row->CharRow.KAttrs[SourcePoint.X];
            for (j=0;j<XSize;TargetPtr++) {
                BYTE AttrR;
                AttrR = *AttrP++;
                if (j==0 && AttrR & ATTR_TRAILING_BYTE)
                {
                    TargetPtr->Char.UnicodeChar = UNICODE_SPACE;
                    AttrR = 0;
                }
                else if (j+1 >= XSize && AttrR & ATTR_LEADING_BYTE)
                {
                    TargetPtr->Char.UnicodeChar = UNICODE_SPACE;
                    AttrR = 0;
                }
                else
                    TargetPtr->Char.UnicodeChar = *Char;
                Char++;
                TargetPtr->Attributes = Attr->Attr | (WCHAR)(AttrR & ATTR_DBCSSBCS_BYTE) << 8;
                j+=1;
                if (++k==CountOfAttr && j<XSize) {
                    Attr++;
                    k=0;
                    CountOfAttr = Attr->Length;
                }
            }
        }
        else{
#endif
        for (j=0;j<XSize;TargetPtr++) {
            TargetPtr->Char.UnicodeChar = *Char++;
            TargetPtr->Attributes = Attr->Attr;
            j+=1;
            if (++k==CountOfAttr && j<XSize) {
                Attr++;
                k=0;
                CountOfAttr = Attr->Length;
            }
        }
#if defined(FE_SB)
        }
#endif

        if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
            RowIndex = 0;
        }
    }
}

VOID
CopyRectangle(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT SourceRect,
    IN COORD TargetPoint
    )

/*++

Routine Description:

    This routine copies a rectangular region from the screen buffer to
    the screen buffer.  no clipping is done.

Arguments:

    ScreenInfo - pointer to screen info

    SourceRect - rectangle in source buffer to copy

    TargetPoint - upper left coordinates of new location rectangle

Return Value:

    none.

--*/

{
    SMALL_RECT Target;
    COORD SourcePoint;
    COORD Size;
    DBGOUTPUT(("CopyRectangle\n"));


    LockScrollBuffer();

    SourcePoint.X = SourceRect->Left;
    SourcePoint.Y = SourceRect->Top;
    Target.Left = 0;
    Target.Top = 0;
    Target.Right = Size.X = SourceRect->Right - SourceRect->Left;
    Target.Bottom = Size.Y = SourceRect->Bottom - SourceRect->Top;
    Size.X++;
    Size.Y++;

    if (ScrollBufferSize < (Size.X * Size.Y * sizeof(CHAR_INFO))) {
        FreeScrollBuffer();
        if (!NT_SUCCESS(AllocateScrollBuffer(Size.X * Size.Y * sizeof(CHAR_INFO)))) {
            UnlockScrollBuffer();
            return;
        }
    }

    ReadRectFromScreenBuffer(ScreenInfo,
                             SourcePoint,
                             ScrollBuffer,
                             Size,
                             &Target
                            );

    WriteRectToScreenBuffer((PBYTE)ScrollBuffer,
                            Size,
                            &Target,
                            ScreenInfo,
                            TargetPoint,
                            0xFFFFFFFF  // ScrollBuffer won't need conversion
                           );
    UnlockScrollBuffer();
}


NTSTATUS
ReadScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInformation,
    OUT PCHAR_INFO Buffer,
    IN OUT PSMALL_RECT ReadRegion
    )

/*++

Routine Description:

    This routine reads a rectangular region from the screen buffer.
    The region is first clipped.

Arguments:

    ScreenInformation - Screen buffer to read from.

    Buffer - Buffer to read into.

    ReadRegion - Region to read.

Return Value:


--*/

{
    COORD TargetSize;
    COORD TargetPoint,SourcePoint;
    SMALL_RECT Target;

    DBGOUTPUT(("ReadScreenBuffer\n"));
    //
    // calculate dimensions of caller's buffer.  have to do this calculation
    // before clipping.
    //

    TargetSize.X = (SHORT)(ReadRegion->Right - ReadRegion->Left + 1);
    TargetSize.Y = (SHORT)(ReadRegion->Bottom - ReadRegion->Top + 1);

    if (TargetSize.X <= 0 || TargetSize.Y <= 0) {
        return STATUS_SUCCESS;
    }

    // do clipping.

    if (ReadRegion->Right > (SHORT)(ScreenInformation->ScreenBufferSize.X-1)) {
        ReadRegion->Right = (SHORT)(ScreenInformation->ScreenBufferSize.X-1);
    }
    if (ReadRegion->Bottom > (SHORT)(ScreenInformation->ScreenBufferSize.Y-1)) {
        ReadRegion->Bottom = (SHORT)(ScreenInformation->ScreenBufferSize.Y-1);
    }
    if (ReadRegion->Left < 0) {
        TargetPoint.X = -ReadRegion->Left;
        ReadRegion->Left = 0;
    } else {
        TargetPoint.X = 0;
    }

    if (ReadRegion->Top < 0) {
        TargetPoint.Y = -ReadRegion->Top;
        ReadRegion->Top = 0;
    }
    else {
        TargetPoint.Y = 0;
    }

    SourcePoint.X = ReadRegion->Left;
    SourcePoint.Y = ReadRegion->Top;
    Target.Left = TargetPoint.X;
    Target.Top = TargetPoint.Y;
    Target.Right = TargetPoint.X + (ReadRegion->Right - ReadRegion->Left);
    Target.Bottom = TargetPoint.Y + (ReadRegion->Bottom - ReadRegion->Top);
    ReadRectFromScreenBuffer(ScreenInformation,
                             SourcePoint,
                             Buffer,
                             TargetSize,
                             &Target
                            );
    return STATUS_SUCCESS;
}

NTSTATUS
WriteScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInformation,
    IN PCHAR_INFO Buffer,
    IN OUT PSMALL_RECT WriteRegion
    )

/*++

Routine Description:

    This routine write a rectangular region to the screen buffer.
    The region is first clipped.

    The region should contain Unicode or UnicodeOem chars.

Arguments:

    ScreenInformation - Screen buffer to write to.

    Buffer - Buffer to write from.

    ReadRegion - Region to write.

Return Value:


--*/

{
    COORD SourceSize;
    COORD TargetPoint;
    SMALL_RECT SourceRect;

    DBGOUTPUT(("WriteScreenBuffer\n"));

    //
    // Calculate dimensions of caller's buffer; this calculation must be
    // done before clipping.
    //
    SourceSize.X = (SHORT)(WriteRegion->Right - WriteRegion->Left + 1);
    SourceSize.Y = (SHORT)(WriteRegion->Bottom - WriteRegion->Top + 1);
    if (SourceSize.X <= 0 || SourceSize.Y <= 0) {
        return STATUS_SUCCESS;
    }

    //
    // Ensure that the write region is within the constraints of the screen
    // buffer.
    //
    if (WriteRegion->Left >= ScreenInformation->ScreenBufferSize.X ||
        WriteRegion->Top  >= ScreenInformation->ScreenBufferSize.Y) {
        return STATUS_SUCCESS;
    }

    //
    // Do clipping.
    //
    if (WriteRegion->Right > (SHORT)(ScreenInformation->ScreenBufferSize.X-1)) {
        WriteRegion->Right = (SHORT)(ScreenInformation->ScreenBufferSize.X-1);
    }
    SourceRect.Right = WriteRegion->Right - WriteRegion->Left;

    if (WriteRegion->Bottom > (SHORT)(ScreenInformation->ScreenBufferSize.Y-1)) {
        WriteRegion->Bottom = (SHORT)(ScreenInformation->ScreenBufferSize.Y-1);
    }
    SourceRect.Bottom = WriteRegion->Bottom - WriteRegion->Top;

    if (WriteRegion->Left < 0) {
        SourceRect.Left = -WriteRegion->Left;
        WriteRegion->Left = 0;
    } else {
        SourceRect.Left = 0;
    }

    if (WriteRegion->Top < 0) {
        SourceRect.Top = -WriteRegion->Top;
        WriteRegion->Top = 0;
    } else {
        SourceRect.Top = 0;
    }

    if (SourceRect.Left > SourceRect.Right ||
        SourceRect.Top > SourceRect.Bottom) {
        return STATUS_INVALID_PARAMETER;
    }

    TargetPoint.X = WriteRegion->Left;
    TargetPoint.Y = WriteRegion->Top;
    WriteRectToScreenBuffer((PBYTE)Buffer,
                            SourceSize,
                            &SourceRect,
                            ScreenInformation,
                            TargetPoint,
                            0xFFFFFFFF
                           );
    return STATUS_SUCCESS;
}




NTSTATUS
ReadOutputString(
    IN PSCREEN_INFORMATION ScreenInfo,
    OUT PVOID Buffer,
    IN COORD ReadCoord,
    IN ULONG StringType,
    IN OUT PULONG NumRecords // this value is valid even for error cases
    )

/*++

Routine Description:

    This routine reads a string of characters or attributes from the
    screen buffer.

Arguments:

    ScreenInfo - Pointer to screen buffer information.

    Buffer - Buffer to read into.

    ReadCoord - Screen buffer coordinate to begin reading from.

    StringType

        CONSOLE_ASCII         - read a string of ASCII characters.
        CONSOLE_REAL_UNICODE  - read a string of Real Unicode characters.
        CONSOLE_FALSE_UNICODE - read a string of False Unicode characters.
        CONSOLE_ATTRIBUTE     - read a string of attributes.

    NumRecords - On input, the size of the buffer in elements.  On output,
    the number of elements read.

Return Value:


--*/

{
    ULONG NumRead;
    SHORT X,Y;
    SHORT RowIndex;
    SHORT CountOfAttr;
    PATTR_PAIR Attr;
    PROW Row;
    PWCHAR Char;
    SHORT j,k;
    PWCHAR TransBuffer = NULL;
    PWCHAR BufPtr;
#if defined(FE_SB)
    PBYTE AttrP;
    PBYTE TransBufferA,BufPtrA;
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;
#endif

    DBGOUTPUT(("ReadOutputString\n"));
    if (*NumRecords == 0)
        return STATUS_SUCCESS;
    NumRead = 0;
    X=ReadCoord.X;
    Y=ReadCoord.Y;
    if (X>=ScreenInfo->ScreenBufferSize.X ||
        X<0 ||
        Y>=ScreenInfo->ScreenBufferSize.Y ||
        Y<0) {
        *NumRecords = 0;
        return STATUS_SUCCESS;
    }

    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+ReadCoord.Y) % ScreenInfo->ScreenBufferSize.Y;

    if (StringType == CONSOLE_ASCII) {
        TransBuffer = ConsoleHeapAlloc(TMP_TAG, *NumRecords * sizeof(WCHAR));
        if (TransBuffer == NULL) {
            return STATUS_NO_MEMORY;
        }
        BufPtr = TransBuffer;
    } else {
        BufPtr = Buffer;
    }

#if defined(FE_SB)
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
    {
        TransBufferA = ConsoleHeapAlloc(TMP_DBCS_TAG, *NumRecords * sizeof(BYTE));
        if (TransBufferA == NULL) {
            if (TransBuffer != NULL)
                ConsoleHeapFree(TransBuffer);
            return STATUS_NO_MEMORY;
        }
        BufPtrA = TransBufferA;
    }
#endif
    if ((StringType == CONSOLE_ASCII) ||
            (StringType == CONSOLE_REAL_UNICODE) ||
            (StringType == CONSOLE_FALSE_UNICODE)) {
        while (NumRead < *NumRecords) {

            //
            // copy the chars from its array
            //

            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
            Char = &Row->CharRow.Chars[X];
#if defined(FE_SB)
            if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
                AttrP = &Row->CharRow.KAttrs[X];
#endif
            if ((ULONG)(ScreenInfo->ScreenBufferSize.X - X) > (*NumRecords - NumRead)) {
                RtlCopyMemory(BufPtr,Char,(*NumRecords - NumRead) * sizeof(WCHAR));
#if defined(FE_SB)
                if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
                    RtlCopyMemory(BufPtrA,AttrP,(*NumRecords - NumRead) * sizeof(CHAR));
#endif
                NumRead += *NumRecords - NumRead;
                break;
            }
            RtlCopyMemory(BufPtr,Char,(ScreenInfo->ScreenBufferSize.X - X) * sizeof(WCHAR));
            BufPtr = (PVOID)((PBYTE)BufPtr + ((ScreenInfo->ScreenBufferSize.X - X) * sizeof(WCHAR)));
#if defined(FE_SB)
            if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
                RtlCopyMemory(BufPtrA,AttrP,(ScreenInfo->ScreenBufferSize.X - X) * sizeof(CHAR));
                BufPtrA = (PVOID)((PBYTE)BufPtrA + ((ScreenInfo->ScreenBufferSize.X - X) * sizeof(CHAR)));
            }
#endif
            NumRead += ScreenInfo->ScreenBufferSize.X - X;
            if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
                RowIndex = 0;
            }
            X = 0;
            Y++;
            if (Y>=ScreenInfo->ScreenBufferSize.Y) {
                break;
            }
        }
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_OUTPUTCP(Console) && (NumRead)) {
            if (StringType == CONSOLE_ASCII) {
                Char = BufPtr = TransBuffer;
            } else {
                Char = BufPtr = Buffer;
            }
            AttrP = BufPtrA = TransBufferA;

            if (*BufPtrA & ATTR_TRAILING_BYTE)
            {
                j = k = (SHORT)(NumRead - 1);
                BufPtr++;
                *Char++ = UNICODE_SPACE;
                BufPtrA++;
                NumRead = 1;
            }
            else {
                j = k = (SHORT)NumRead;
                NumRead = 0;
            }
            while (j--) {
                if (!(*BufPtrA & ATTR_TRAILING_BYTE)) {
                    *Char++ = *BufPtr;
                    NumRead++;
                }
                BufPtr++;
                BufPtrA++;
            }
            if (k && *(BufPtrA-1) & ATTR_LEADING_BYTE)
            {
                *(Char-1) = UNICODE_SPACE;
            }
        }
#endif
    } else if (StringType == CONSOLE_ATTRIBUTE) {
        PWORD TargetPtr=BufPtr;
        while (NumRead < *NumRecords) {

            //
            // copy the attrs from its array
            //

            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
#if defined(FE_SB)
            if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
                AttrP = &Row->CharRow.KAttrs[X];
#endif
            FindAttrIndex(Row->AttrRow.Attrs,
                          X,
                          &Attr,
                          &CountOfAttr
                         );
            k=0;
            for (j=X;j<ScreenInfo->ScreenBufferSize.X;TargetPtr++) {
#if defined(FE_SB)
                if (!CONSOLE_IS_DBCS_OUTPUTCP(Console) )
                    *TargetPtr = Attr->Attr;
                else if ((j == X) && (*AttrP & ATTR_TRAILING_BYTE))
                    *TargetPtr = Attr->Attr;
                else if (*AttrP & ATTR_LEADING_BYTE){
                    if ((NumRead == *NumRecords-1)||(j == ScreenInfo->ScreenBufferSize.X-1))
                        *TargetPtr = Attr->Attr;
                    else
                        *TargetPtr = Attr->Attr | (WCHAR)(*AttrP & ATTR_DBCSSBCS_BYTE) << 8;
                }
                else
                    *TargetPtr = Attr->Attr | (WCHAR)(*AttrP & ATTR_DBCSSBCS_BYTE) << 8;
#else
                *TargetPtr = Attr->Attr;
#endif
                NumRead++;
                j+=1;
                if (++k==CountOfAttr && j<ScreenInfo->ScreenBufferSize.X) {
                    Attr++;
                    k=0;
                    CountOfAttr = Attr->Length;
                }
                if (NumRead == *NumRecords) {
#if defined(FE_SB)
                    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
                        ConsoleHeapFree(TransBufferA);
#endif
                    return STATUS_SUCCESS;
                }
#if defined(FE_SB)
                if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
                    AttrP++;
#endif
            }
            if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
                RowIndex = 0;
            }
            X = 0;
            Y++;
            if (Y>=ScreenInfo->ScreenBufferSize.Y) {
                break;
            }
        }
    } else {
        *NumRecords = 0;
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
            ConsoleHeapFree(TransBufferA);
#endif
        return STATUS_INVALID_PARAMETER;
    }

    if (StringType == CONSOLE_ASCII) {
        UINT Codepage;
#if defined(FE_SB)
        if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
            if (ScreenInfo->Console->OutputCP != WINDOWSCP)
                Codepage = USACP;
            else
                Codepage = WINDOWSCP;
        } else {
            Codepage = ScreenInfo->Console->OutputCP;
        }
#else
        if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
            Codepage = WINDOWSCP;
        } else {
            Codepage = ScreenInfo->Console->OutputCP;
        }
#endif
#if defined(FE_SB)
        if ((NumRead == 1) && !CONSOLE_IS_DBCS_OUTPUTCP(Console))
#else
        if (NumRead == 1)
#endif
        {
            *((PBYTE)Buffer) = WcharToChar(Codepage, *TransBuffer);
        } else {
            NumRead = ConvertOutputToOem(Codepage, TransBuffer, NumRead, Buffer, *NumRecords);
        }
        ConsoleHeapFree(TransBuffer);
    } else if (StringType == CONSOLE_REAL_UNICODE &&
            (ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
            !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
        /*
         * Buffer contains false Unicode (UnicodeOem) only in Windowed
         * RasterFont mode, so in this case, convert it to real Unicode.
         */
        FalseUnicodeToRealUnicode(Buffer,
                                NumRead,
                                ScreenInfo->Console->OutputCP
                                );
    }

#if defined(FE_SB)
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        ConsoleHeapFree(TransBufferA);
#endif
    *NumRecords = NumRead;
    return STATUS_SUCCESS;
}



NTSTATUS
GetScreenBufferInformation(
    IN PSCREEN_INFORMATION ScreenInfo,
    OUT PCOORD Size,
    OUT PCOORD CursorPosition,
    OUT PCOORD ScrollPosition,
    OUT PWORD  Attributes,
    OUT PCOORD CurrentWindowSize,
    OUT PCOORD MaximumWindowSize
    )

/*++

Routine Description:

    This routine returns data about the screen buffer.

Arguments:

    ScreenInfo - Pointer to screen buffer information.

    Size - Pointer to location in which to store screen buffer size.

    CursorPosition - Pointer to location in which to store the cursor position.

    ScrollPosition - Pointer to location in which to store the scroll position.

    Attributes - Pointer to location in which to store the default attributes.

    CurrentWindowSize - Pointer to location in which to store current window size.

    MaximumWindowSize - Pointer to location in which to store maximum window size.

Return Value:

--*/

{
    WINDOW_LIMITS WindowLimits;

    *Size = ScreenInfo->ScreenBufferSize;
    *CursorPosition = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
    ScrollPosition->X = ScreenInfo->Window.Left;
    ScrollPosition->Y = ScreenInfo->Window.Top;
    *Attributes = ScreenInfo->Attributes;
    CurrentWindowSize->X = (SHORT)CONSOLE_WINDOW_SIZE_X(ScreenInfo);
    CurrentWindowSize->Y = (SHORT)CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
    if (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
        MaximumWindowSize->X = min(80,ScreenInfo->ScreenBufferSize.X);
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console)) {
            MaximumWindowSize->Y = min(25,ScreenInfo->ScreenBufferSize.Y);
        } else {
            MaximumWindowSize->Y = min(50,ScreenInfo->ScreenBufferSize.Y);
        }
#else
        MaximumWindowSize->Y = min(50,ScreenInfo->ScreenBufferSize.Y);
#endif
    } else {
        GetWindowLimits(ScreenInfo, &WindowLimits);
        *MaximumWindowSize = WindowLimits.MaximumWindowSize;
    }
    return STATUS_SUCCESS;
}


VOID
UpdateScrollBars(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    if (!ACTIVE_SCREEN_BUFFER(ScreenInfo)) {
        return;
    }

    if (ScreenInfo->Console->Flags & CONSOLE_UPDATING_SCROLL_BARS)
        return;
    ScreenInfo->Console->Flags |= CONSOLE_UPDATING_SCROLL_BARS;
    PostMessage(ScreenInfo->Console->hWnd,
                 CM_UPDATE_SCROLL_BARS,
                 (WPARAM)ScreenInfo,
                 0
                );
}

VOID
InternalUpdateScrollBars(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    SCROLLINFO si;

    ScreenInfo->Console->Flags &= ~CONSOLE_UPDATING_SCROLL_BARS;
    if (!ACTIVE_SCREEN_BUFFER(ScreenInfo)) {
        return;
    }

    ScreenInfo->ResizingWindow++;

    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;
    si.nPage = CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
    si.nMin = 0;
    si.nMax = ScreenInfo->ScreenBufferSize.Y - 1;
    si.nPos = ScreenInfo->Window.Top;
    SetScrollInfo(ScreenInfo->Console->hWnd, SB_VERT, &si, TRUE);

    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;
    si.nPage = CONSOLE_WINDOW_SIZE_X(ScreenInfo);
    si.nMin = 0;
    si.nMax = ScreenInfo->ScreenBufferSize.X - 1;
    si.nPos = ScreenInfo->Window.Left;
    SetScrollInfo(ScreenInfo->Console->hWnd, SB_HORZ, &si, TRUE);

    //
    // Fire off an event to let accessibility apps know the layout has changed.
    //

    ConsoleNotifyWinEvent(ScreenInfo->Console,
                          EVENT_CONSOLE_LAYOUT,
                          0,
                          0);

    ScreenInfo->ResizingWindow--;
}

VOID
ScreenBufferSizeChange(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD NewSize
    )
{
    INPUT_RECORD InputEvent;

    InputEvent.EventType = WINDOW_BUFFER_SIZE_EVENT;
    InputEvent.Event.WindowBufferSizeEvent.dwSize = NewSize;
    WriteInputBuffer(ScreenInfo->Console,
                     &ScreenInfo->Console->InputBuffer,
                     &InputEvent,
                     1
                     );
}

NTSTATUS
ResizeScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD NewScreenSize,
    IN BOOL DoScrollBarUpdate
    )

/*++

Routine Description:

    This routine resizes the screen buffer.

Arguments:

    ScreenInfo - pointer to screen buffer info.

    NewScreenSize - new size of screen.

Return Value:

--*/

{
    SHORT i,j;
    BOOLEAN WindowMaximizedX,WindowMaximizedY;
    SHORT LimitX,LimitY;
    PWCHAR TextRows,TextRowPtr;
    BOOL UpdateWindow;
    SHORT TopRow,TopRowIndex; // new top row of screen buffer
    COORD CursorPosition;
#if defined(FE_SB)
    DBCS_SCREEN_BUFFER NewDbcsScreenBuffer;
    PBYTE TextRowPtrA;
#endif

    //
    // Don't allow resize of graphics apps
    //

    if (!(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)) {
        return STATUS_UNSUCCESSFUL;
    }

    TextRows = ConsoleHeapAlloc(SCREEN_TAG,
                                NewScreenSize.X * NewScreenSize.Y * sizeof(WCHAR));
    if (TextRows == NULL) {
        return STATUS_NO_MEMORY;
    }
#if defined(FE_SB)
    if (! CreateDbcsScreenBuffer(ScreenInfo->Console,NewScreenSize,&NewDbcsScreenBuffer))
    {
        ConsoleHeapFree(TextRows);
        return STATUS_NO_MEMORY;
    }
#endif
    LimitX = (NewScreenSize.X < ScreenInfo->ScreenBufferSize.X) ?
              NewScreenSize.X : ScreenInfo->ScreenBufferSize.X;
    LimitY = (NewScreenSize.Y < ScreenInfo->ScreenBufferSize.Y) ?
              NewScreenSize.Y : ScreenInfo->ScreenBufferSize.Y;
    TopRow = 0;
    if (NewScreenSize.Y <= ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y) {
        TopRow += ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y - NewScreenSize.Y + 1;
    }
    TopRowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TopRow) % ScreenInfo->ScreenBufferSize.Y;
    if (NewScreenSize.Y != ScreenInfo->ScreenBufferSize.Y) {
        PROW Temp;
        SHORT NumToCopy,NumToCopy2;

        //
        // resize ROWs array.  first alloc a new ROWs array. then copy the old
        // one over, resetting the FirstRow.
        //
        //

        Temp = ConsoleHeapAlloc(SCREEN_TAG, NewScreenSize.Y * sizeof(ROW));
        if (Temp == NULL) {
            ConsoleHeapFree(TextRows);
#if defined(FE_SB)
            DeleteDbcsScreenBuffer(&NewDbcsScreenBuffer);
#endif
            return STATUS_NO_MEMORY;
        }
        NumToCopy = ScreenInfo->ScreenBufferSize.Y-TopRowIndex;
        if (NumToCopy > NewScreenSize.Y)
            NumToCopy = NewScreenSize.Y;
        RtlCopyMemory(Temp,&ScreenInfo->BufferInfo.TextInfo.Rows[TopRowIndex],NumToCopy*sizeof(ROW));
        if (TopRowIndex!=0 && NumToCopy != NewScreenSize.Y) {
            NumToCopy2 = TopRowIndex;
            if (NumToCopy2 > (NewScreenSize.Y-NumToCopy))
                NumToCopy2 = NewScreenSize.Y-NumToCopy;
            RtlCopyMemory(&Temp[NumToCopy],
                   ScreenInfo->BufferInfo.TextInfo.Rows,
                   NumToCopy2*sizeof(ROW)
                  );
        }
        for (i=0;i<LimitY;i++) {
            if (Temp[i].AttrRow.Length == 1) {
                Temp[i].AttrRow.Attrs = &Temp[i].AttrRow.AttrPair;
            }
        }

        //
        // if the new screen buffer has fewer rows than the existing one,
        // free the extra rows.  if the new screen buffer has more rows
        // than the existing one, allocate new rows.
        //

        if (NewScreenSize.Y < ScreenInfo->ScreenBufferSize.Y) {
            i = (TopRowIndex+NewScreenSize.Y) % ScreenInfo->ScreenBufferSize.Y;
            for (j=NewScreenSize.Y;j<ScreenInfo->ScreenBufferSize.Y;j++) {
                if (ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Length > 1) {
                    ConsoleHeapFree(ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs);
                }
                if (++i == ScreenInfo->ScreenBufferSize.Y) {
                    i = 0;
                }
            }
        } else if (NewScreenSize.Y > ScreenInfo->ScreenBufferSize.Y) {
            for (i=ScreenInfo->ScreenBufferSize.Y;i<NewScreenSize.Y;i++) {
                Temp[i].AttrRow.Length = 1;
                Temp[i].AttrRow.AttrPair.Length = NewScreenSize.X;
                Temp[i].AttrRow.AttrPair.Attr = ScreenInfo->Attributes;
                Temp[i].AttrRow.Attrs = &Temp[i].AttrRow.AttrPair;
            }
        }
        ScreenInfo->BufferInfo.TextInfo.FirstRow = 0;
        ConsoleHeapFree(ScreenInfo->BufferInfo.TextInfo.Rows);
        ScreenInfo->BufferInfo.TextInfo.Rows = Temp;
    }

    //
    // Realloc each row.  any horizontal growth results in the last
    // attribute in a row getting extended.
    //
#if defined(FE_SB)
    TextRowPtrA=NewDbcsScreenBuffer.KAttrRows;
#endif
    for (i=0,TextRowPtr=TextRows;i<LimitY;i++,TextRowPtr+=NewScreenSize.X)
    {
        RtlCopyMemory(TextRowPtr,
               ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.Chars,
               LimitX*sizeof(WCHAR));
#if defined(FE_SB)
        if (TextRowPtrA) {
            RtlCopyMemory(TextRowPtrA,
                          ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.KAttrs,
                          LimitX*sizeof(CHAR));
        }
#endif
        for (j=ScreenInfo->ScreenBufferSize.X;j<NewScreenSize.X;j++) {
            TextRowPtr[j] = (WCHAR)' ';
        }

        if (ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.Right > NewScreenSize.X) {
            ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.OldRight = INVALID_OLD_LENGTH;
            ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.Right = NewScreenSize.X;
        }
        ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.Chars = TextRowPtr;
#if defined(FE_SB)
        ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.KAttrs = TextRowPtrA;
        if (TextRowPtrA) {
            if (NewScreenSize.X > ScreenInfo->ScreenBufferSize.X)
                RtlZeroMemory(TextRowPtrA+ScreenInfo->ScreenBufferSize.X,
                              NewScreenSize.X-ScreenInfo->ScreenBufferSize.X);
            TextRowPtrA+=NewScreenSize.X;
        }
#endif
    }
    for (;i<NewScreenSize.Y;i++,TextRowPtr+=NewScreenSize.X)
    {
        for (j=0;j<NewScreenSize.X;j++) {
            TextRowPtr[j] = (WCHAR)' ';
        }
#if defined(FE_SB)
        if (TextRowPtrA) {
           RtlZeroMemory(TextRowPtrA, NewScreenSize.X);
        }
#endif
        ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.Chars = TextRowPtr;
        ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.OldLeft = INVALID_OLD_LENGTH;
        ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.OldRight = INVALID_OLD_LENGTH;
        ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.Left = NewScreenSize.X;
        ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.Right = 0;
#if defined(FE_SB)
        ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.KAttrs = TextRowPtrA;
        if (TextRowPtrA) {
            TextRowPtrA+=NewScreenSize.X;
        }
#endif
    }
    ConsoleHeapFree(ScreenInfo->BufferInfo.TextInfo.TextRows);
    ScreenInfo->BufferInfo.TextInfo.TextRows = TextRows;
#if defined(FE_SB)
    DeleteDbcsScreenBuffer(&ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer);
    ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer = NewDbcsScreenBuffer;
#endif

    if (NewScreenSize.X != ScreenInfo->ScreenBufferSize.X) {
        for (i=0;i<LimitY;i++) {
            PATTR_PAIR IndexedAttr;
            SHORT CountOfAttr;

            if (NewScreenSize.X > ScreenInfo->ScreenBufferSize.X) {
                FindAttrIndex(ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs,
                              (SHORT)(ScreenInfo->ScreenBufferSize.X-1),
                              &IndexedAttr,
                              &CountOfAttr
                             );
  ASSERT (IndexedAttr <=
    &ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs[ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Length-1]);
                IndexedAttr->Length += NewScreenSize.X - ScreenInfo->ScreenBufferSize.X;
            }
            else {

                FindAttrIndex(ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs,
                              (SHORT)(NewScreenSize.X-1),
                              &IndexedAttr,
                              &CountOfAttr
                             );
                IndexedAttr->Length -= CountOfAttr-1;
                if (ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Length != 1)  {
                    ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Length = (SHORT)(IndexedAttr - ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs + 1);
                    if (ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Length != 1) {
                        ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs = ConsoleHeapReAlloc(SCREEN_TAG, ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs,
                                                                         ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Length * sizeof(ATTR_PAIR));
                    }
                    else {
                        ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.AttrPair = *IndexedAttr;
                        ConsoleHeapFree(ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs);
                        ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs = &ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.AttrPair;
                    }
                }
            }
        }
    }

    //
    // if the screen buffer is resized smaller than the saved
    // window size, shrink the saved window size.
    //
#ifdef i386
    if (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
        if (NewScreenSize.X < ScreenInfo->BufferInfo.TextInfo.WindowedWindowSize.X) {
            ScreenInfo->BufferInfo.TextInfo.WindowedWindowSize.X = NewScreenSize.X;
        }
        if (NewScreenSize.Y < ScreenInfo->BufferInfo.TextInfo.WindowedWindowSize.Y) {
            ScreenInfo->BufferInfo.TextInfo.WindowedWindowSize.Y = NewScreenSize.Y;
        }
        ScreenInfo->BufferInfo.TextInfo.WindowedScreenSize = NewScreenSize;
    }
#endif

    UpdateWindow = FALSE;

    //
    // if the screen buffer shrunk beyond the boundaries of the window,
    // adjust the window origin.
    //

    if (NewScreenSize.X > CONSOLE_WINDOW_SIZE_X(ScreenInfo)) {
        if (ScreenInfo->Window.Right >= NewScreenSize.X) {
            ScreenInfo->Window.Left -= ScreenInfo->Window.Right - NewScreenSize.X + 1;
            ScreenInfo->Window.Right -= ScreenInfo->Window.Right - NewScreenSize.X + 1;
            UpdateWindow = TRUE;
        }
    } else {
        ScreenInfo->Window.Left = 0;
        ScreenInfo->Window.Right = NewScreenSize.X - 1;
        UpdateWindow = TRUE;
    }
    if (NewScreenSize.Y > CONSOLE_WINDOW_SIZE_Y(ScreenInfo)) {
        if (ScreenInfo->Window.Bottom >= NewScreenSize.Y) {
            ScreenInfo->Window.Top -= ScreenInfo->Window.Bottom - NewScreenSize.Y + 1;
            ScreenInfo->Window.Bottom -= ScreenInfo->Window.Bottom - NewScreenSize.Y + 1;
            UpdateWindow = TRUE;
        }
    } else {
        ScreenInfo->Window.Top = 0;
        ScreenInfo->Window.Bottom = NewScreenSize.Y - 1;
        UpdateWindow = TRUE;
    }

#if defined(FE_SB)
    // Should be sets ScreenBufferSize before calls SetCursorPosition
    // because SetCursorPosition refer ScreenBufferSize.
    // Also, FE version refer in InvertPixels.
    //
    // kkntbug:11311
    ScreenInfo->ScreenBufferSize = NewScreenSize;
#endif

    //
    // adjust cursor position if it's no longer with screen buffer
    //

    CursorPosition=ScreenInfo->BufferInfo.TextInfo.CursorPosition;
    if (CursorPosition.X >= NewScreenSize.X) {
        if (ScreenInfo->OutputMode & ENABLE_WRAP_AT_EOL_OUTPUT) {
            CursorPosition.X = 0;
            CursorPosition.Y += 1;
        } else {
            CursorPosition.X = NewScreenSize.X-1;
        }
    }
    if (CursorPosition.Y >= NewScreenSize.Y) {
        CursorPosition.Y = NewScreenSize.Y-1;
    }
#if defined(FE_SB)
    // set cursor position Y is ZERO when expand screen buffer with IME open mode
    // from screen buffer is one line mode.
    // Because, One line screen buffer mode and IME open mode is set -1 as cursor position Y.
    if (ScreenInfo->Console->InputBuffer.ImeMode.Open && CursorPosition.Y < 0) {
        CursorPosition.Y = 0;
    }
#endif
    if (CursorPosition.X != ScreenInfo->BufferInfo.TextInfo.CursorPosition.X ||
        CursorPosition.Y != ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y) {
        SetCursorPosition(ScreenInfo,
                          CursorPosition,
                          FALSE
                          );
    }

    ASSERT (ScreenInfo->Window.Left >= 0);
    ASSERT (ScreenInfo->Window.Right < NewScreenSize.X);
    ASSERT (ScreenInfo->Window.Top >= 0);
    ASSERT (ScreenInfo->Window.Bottom < NewScreenSize.Y);

    ScreenInfo->ScreenBufferSize = NewScreenSize;
    ResetTextFlags(ScreenInfo,
                   0,
                   0,
                   (SHORT)(ScreenInfo->ScreenBufferSize.X - 1),
                   (SHORT)(ScreenInfo->ScreenBufferSize.Y - 1));
    WindowMaximizedX = (CONSOLE_WINDOW_SIZE_X(ScreenInfo) ==
                          ScreenInfo->ScreenBufferSize.X);
    WindowMaximizedY = (CONSOLE_WINDOW_SIZE_Y(ScreenInfo) ==
                          ScreenInfo->ScreenBufferSize.Y);

#if defined(FE_IME)
    if (CONSOLE_IS_IME_ENABLED()) {
        if (!NT_SUCCESS(ConsoleImeMessagePump(ScreenInfo->Console,
                              CONIME_NOTIFY_SCREENBUFFERSIZE,
                              (WPARAM)ScreenInfo->Console->ConsoleHandle,
                              (LPARAM)MAKELPARAM(NewScreenSize.X, NewScreenSize.Y)
                             ))) {
            return STATUS_INVALID_HANDLE;
        }
    }

    if ( (! ScreenInfo->ConvScreenInfo) &&
         (CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console)))
    {
        if (!NT_SUCCESS(ConsoleImeResizeModeSystemScreenBuffer(ScreenInfo->Console,NewScreenSize)) ||
                !NT_SUCCESS(ConsoleImeResizeCompStrScreenBuffer(ScreenInfo->Console,NewScreenSize))) {
            /*
             * If something went wrong, just bail out.
             */
            return STATUS_INVALID_HANDLE;
        }
    }
#endif // FE_IME
    if (ScreenInfo->WindowMaximizedX != WindowMaximizedX ||
        ScreenInfo->WindowMaximizedY != WindowMaximizedY) {
        ScreenInfo->WindowMaximizedX = WindowMaximizedX;
        ScreenInfo->WindowMaximizedY = WindowMaximizedY;
        UpdateWindow = TRUE;
    }
    if (UpdateWindow) {
        SetWindowSize(ScreenInfo);
    }

    //
    // Fire off an event to let accessibility apps know the layout has changed.
    //

    if (ACTIVE_SCREEN_BUFFER(ScreenInfo)) {
        ConsoleNotifyWinEvent(ScreenInfo->Console,
                              EVENT_CONSOLE_LAYOUT,
                              0,
                              0);
    }

    if (DoScrollBarUpdate) {
         UpdateScrollBars(ScreenInfo);
    }
    if (ScreenInfo->Console->InputBuffer.InputMode & ENABLE_WINDOW_INPUT) {
        ScreenBufferSizeChange(ScreenInfo,ScreenInfo->ScreenBufferSize);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
AllocateScrollBuffer(
    DWORD Size
    )
{
    ScrollBuffer = ConsoleHeapAlloc(SCREEN_TAG, Size);
    if (ScrollBuffer == NULL) {
        ScrollBufferSize = 0;
        return STATUS_NO_MEMORY;
    }
    ScrollBufferSize = Size;
    return STATUS_SUCCESS;
}

VOID
FreeScrollBuffer( VOID )
{
    ConsoleHeapFree(ScrollBuffer);
    ScrollBuffer = NULL;
    ScrollBufferSize = 0;
}

NTSTATUS
InitializeScrollBuffer(
    VOID)
{
    NTSTATUS Status;

    /*
     * It's possible for this function to be called multiple times, if, e.g.,
     * console initialization fails the first time *after* this function is
     * called.
     */
    if (ghrgnScroll) {
        return STATUS_SUCCESS;
    }

    ghrgnScroll = CreateRectRgn(0,0,1,1);
    if (ghrgnScroll == NULL) {
        RIPMSGF0(RIP_WARNING, "Cannot allocate ghrgnScroll.");
        return STATUS_UNSUCCESSFUL;
    }
    gprgnData = ConsoleHeapAlloc(SCREEN_TAG, GRGNDATASIZE);
    if (gprgnData == NULL) {
        RIPMSGF0(RIP_WARNING, "Cannot allocate gprgnData.");
        Status = STATUS_NO_MEMORY;
        goto error;
    }

    Status = AllocateScrollBuffer(DefaultRegInfo.ScreenBufferSize.X *
                                  DefaultRegInfo.ScreenBufferSize.Y *
                                  sizeof(CHAR_INFO));
    if (!NT_SUCCESS(Status)) {
        goto error;
    }

    Status = RtlInitializeCriticalSectionAndSpinCount(&ScrollBufferLock,
                                                      0x80000000);

error:
    if (!NT_SUCCESS(Status)) {
        RIPMSG0(RIP_WARNING, "InitializeScrollBuffer failed, cleaning up");
        if (ghrgnScroll) {
            DeleteObject(ghrgnScroll);
            ghrgnScroll = NULL;
        }

        if (gprgnData) {
            ConsoleHeapFree(gprgnData);
            gprgnData = NULL;
        }
    }

    UserAssert(!NT_SUCCESS(Status) || ghrgnScroll);

    return Status;
}

VOID
UpdateComplexRegion(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD FontSize
    )
{
    int iSize,i;
    LPRECT pRect;
    SMALL_RECT UpdateRegion;
    LPRGNDATA pRgnData;

    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
    }
    pRgnData = gprgnData;

    /*
     * the dreaded complex region.
     */
    iSize = GetRegionData(ghrgnScroll, 0, NULL);
    if (iSize > GRGNDATASIZE) {
        pRgnData = ConsoleHeapAlloc(TMP_TAG, iSize);
        if (pRgnData == NULL)
            return;
    }

    if (!GetRegionData(ghrgnScroll, iSize, pRgnData)) {
        ASSERT(FALSE);
        if (pRgnData != gprgnData) {
            ConsoleHeapFree(pRgnData);
        }
        return;
    }

    pRect = (PRECT)&pRgnData->Buffer;

    /*
     * Redraw each rectangle
     */
    for(i=0;i<(int)pRgnData->rdh.nCount;i++,pRect++) {
        /*
         * Convert to chars. We know
         * this is only get to get converted back during
         * the textout call.
         */
        UpdateRegion.Left = (SHORT)((pRect->left/FontSize.X)+ \
                            ScreenInfo->Window.Left);
        UpdateRegion.Right = (SHORT)(((pRect->right-1)/FontSize.X)+ \
                            ScreenInfo->Window.Left);
        UpdateRegion.Top = (SHORT)((pRect->top/FontSize.Y)+ \
                            ScreenInfo->Window.Top);
        UpdateRegion.Bottom = (SHORT)(((pRect->bottom-1)/FontSize.Y)+ \
                            ScreenInfo->Window.Top);
        /*
         * Fill the rectangle with goodies.
         */
        WriteToScreen(ScreenInfo, &UpdateRegion);
    }
    if (pRgnData != gprgnData) {
        ConsoleHeapFree(pRgnData);
    }
}

VOID
ScrollScreen(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT ScrollRect,
    IN PSMALL_RECT MergeRect,
    IN COORD TargetPoint
    )
{
    RECT ScrollRectGdi;
    SMALL_RECT UpdateRegion;
    COORD FontSize;
    BOOL Success;
    RECT BoundingBox;
#if defined(FE_SB)
    BYTE fBisect = 0;
    SMALL_RECT UpdateRect;
    SMALL_RECT TmpBisect;
#endif

    DBGOUTPUT(("ScrollScreen\n"));
    if (!ACTIVE_SCREEN_BUFFER(ScreenInfo)) {
        return;
    }
    if (ScreenInfo->Console->FullScreenFlags == 0 &&
        !(ScreenInfo->Console->Flags & (CONSOLE_IS_ICONIC | CONSOLE_NO_WINDOW))) {
#if defined(FE_SB)
        if (ScreenInfo->BisectFlag){
            SMALL_RECT RedrawRect;
            if (ScrollRect->Top < TargetPoint.Y){
                RedrawRect.Top = ScrollRect->Top;
                RedrawRect.Bottom = TargetPoint.Y+(ScrollRect->Bottom-ScrollRect->Top);
            }
            else{
                RedrawRect.Top = TargetPoint.Y;
                RedrawRect.Bottom = ScrollRect->Bottom;
            }
            if (ScrollRect->Left < TargetPoint.X){
                RedrawRect.Left = ScrollRect->Left;
                RedrawRect.Right = TargetPoint.X+(ScrollRect->Right-ScrollRect->Left);
            }
            else{
                RedrawRect.Left = TargetPoint.X;
                RedrawRect.Right = ScrollRect->Right;
            }
            WriteToScreen(ScreenInfo,&RedrawRect);
        }
        else{
#endif
        ScrollRectGdi.left = ScrollRect->Left-ScreenInfo->Window.Left;
        ScrollRectGdi.right = (ScrollRect->Right-ScreenInfo->Window.Left+1);
        ScrollRectGdi.top = ScrollRect->Top-ScreenInfo->Window.Top;
        ScrollRectGdi.bottom = (ScrollRect->Bottom-ScreenInfo->Window.Top+1);
        if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
            FontSize = SCR_FONTSIZE(ScreenInfo);
            ScrollRectGdi.left *= FontSize.X;
            ScrollRectGdi.right *= FontSize.X;
            ScrollRectGdi.top *= FontSize.Y;
            ScrollRectGdi.bottom *= FontSize.Y;
            ASSERT (ScreenInfo->BufferInfo.TextInfo.UpdatingScreen>0);
        } else {
            FontSize.X = 1;
            FontSize.Y = 1;
        }
        SCROLLDC_CALL;
        LockScrollBuffer();
        Success = (int)ScrollDC(ScreenInfo->Console->hDC,
                             (TargetPoint.X-ScrollRect->Left)*FontSize.X,
                             (TargetPoint.Y-ScrollRect->Top)*FontSize.Y,
                             &ScrollRectGdi,
                             NULL,
                             ghrgnScroll,
                             NULL);

        //
        // Fire off an event to let accessibility apps know we've scrolled.
        //

        ConsoleNotifyWinEvent(ScreenInfo->Console,
                              EVENT_CONSOLE_UPDATE_SCROLL,
                              TargetPoint.X - ScrollRect->Left,
                              TargetPoint.Y - ScrollRect->Top);

        if (Success) {
            /*
             * Fetch our rectangles. If this is a simple rect then
             * we have already retrieved the rectangle. Otherwise
             * we need to call gdi to get the rectangles. We are
             * optimized for speed rather than size.
             */
            switch (GetRgnBox(ghrgnScroll, &BoundingBox)) {
            case SIMPLEREGION:
                UpdateRegion.Left = (SHORT)((BoundingBox.left / FontSize.X) + \
                                    ScreenInfo->Window.Left);
                UpdateRegion.Right = (SHORT)(((BoundingBox.right-1) / FontSize.X) + \
                                    ScreenInfo->Window.Left);
                UpdateRegion.Top = (SHORT)((BoundingBox.top / FontSize.Y) + \
                                    ScreenInfo->Window.Top);
                UpdateRegion.Bottom = (SHORT)(((BoundingBox.bottom-1) / FontSize.Y) + \
                                    ScreenInfo->Window.Top);
#if defined(FE_SB)
                fBisect = ScreenInfo->BisectFlag;
#endif
                WriteToScreen(ScreenInfo, &UpdateRegion);
                break;
            case COMPLEXREGION:
                UpdateComplexRegion(ScreenInfo, FontSize);
                break;
            }

            if (MergeRect) {
#if defined(FE_SB)
                if (fBisect)
                    ScreenInfo->BisectFlag = fBisect;
                else
                    fBisect = ScreenInfo->BisectFlag;
#endif
                WriteToScreen(ScreenInfo, MergeRect);
            }
#if defined(FE_SB)
            if (CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console)) {
                UpdateRect.Left = TargetPoint.X;
                UpdateRect.Right = ScrollRect->Right + (TargetPoint.X-ScrollRect->Left);
                UpdateRect.Top = TargetPoint.Y;
                UpdateRect.Bottom = ScrollRect->Bottom + (TargetPoint.Y-ScrollRect->Top);
                if (UpdateRect.Left &&
                    UpdateRect.Right+1 < ScreenInfo->ScreenBufferSize.X &&
                    UpdateRect.Right-UpdateRect.Left <= 2) {
                    TmpBisect.Left = UpdateRect.Left-1;
                    TmpBisect.Right = UpdateRect.Right+1;
                    TmpBisect.Top = UpdateRect.Top;
                    TmpBisect.Bottom = UpdateRect.Bottom;
                    WriteToScreen(ScreenInfo, &TmpBisect);
                }
                else {
                    if (UpdateRect.Left) {
                        TmpBisect.Left = UpdateRect.Left-1;
                        TmpBisect.Right = UpdateRect.Left;
                        TmpBisect.Top = UpdateRect.Top;
                        TmpBisect.Bottom = UpdateRect.Bottom;
                        WriteToScreen(ScreenInfo, &TmpBisect);
                    }
                    if (UpdateRect.Right+1 < ScreenInfo->ScreenBufferSize.X) {
                        TmpBisect.Left = UpdateRect.Right;
                        TmpBisect.Right = UpdateRect.Right+1;
                        TmpBisect.Top = UpdateRect.Top;
                        TmpBisect.Bottom = UpdateRect.Bottom;
                        WriteToScreen(ScreenInfo, &TmpBisect);
                    }
                }
            }
#endif
        } else {
#if defined(FE_SB)
            if (fBisect)
                ScreenInfo->BisectFlag = fBisect;
            else
                fBisect = ScreenInfo->BisectFlag;
#endif
            WriteToScreen(ScreenInfo, &ScreenInfo->Window);
        }
        UnlockScrollBuffer();
#if defined(FE_SB)
        }
#endif
    }
#ifdef i386
    else if (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console)) {
            if (! ScreenInfo->ConvScreenInfo) {
                if (ScreenInfo->Console->CurrentScreenBuffer == ScreenInfo) {
                    ScrollHW(ScreenInfo,
                             ScrollRect,
                             MergeRect,
                             TargetPoint
                            );
                }
            }
            else if (ScreenInfo->Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) {
                ScrollHW(ScreenInfo,
                         ScrollRect,
                         MergeRect,
                         TargetPoint
                        );
            }
        }
        else
#endif
        ScrollHW(ScreenInfo,
                 ScrollRect,
                 MergeRect,
                 TargetPoint
                );
    }
#endif
}


void CopyRow(
    PROW Row,
    PROW PrevRow)
{
    if (PrevRow->AttrRow.Length != 1 ||
        Row->AttrRow.Length != 1 ||
        PrevRow->AttrRow.Attrs->Attr != Row->AttrRow.Attrs->Attr) {
        Row->CharRow.OldRight = INVALID_OLD_LENGTH;
        Row->CharRow.OldLeft = INVALID_OLD_LENGTH;
    } else {
        Row->CharRow.OldRight = PrevRow->CharRow.Right;
        Row->CharRow.OldLeft = PrevRow->CharRow.Left;
    }
}

SHORT
ScrollEntireScreen(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN SHORT ScrollValue,
    IN BOOL UpdateRowIndex
    )

/**++

    this routine updates FirstRow and all the OldLeft and OldRight
    values when the screen is scrolled up by ScrollValue.

--*/

{
    SHORT RowIndex;
    int i;
    int new;
    int old;

    ScreenInfo->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;

    //
    // store index of first row
    //

    RowIndex = ScreenInfo->BufferInfo.TextInfo.FirstRow;

    //
    // update the oldright and oldleft values
    //

    new = (RowIndex + ScreenInfo->Window.Bottom + ScrollValue) %
               ScreenInfo->ScreenBufferSize.Y;
    old = (RowIndex + ScreenInfo->Window.Bottom) %
               ScreenInfo->ScreenBufferSize.Y;
    for (i = WINDOW_SIZE_Y(&ScreenInfo->Window) - 1; i >= 0; i--) {
        CopyRow(
            &ScreenInfo->BufferInfo.TextInfo.Rows[new],
            &ScreenInfo->BufferInfo.TextInfo.Rows[old]);
        if (--new < 0)
            new = ScreenInfo->ScreenBufferSize.Y - 1;
        if (--old < 0)
            old = ScreenInfo->ScreenBufferSize.Y - 1;
    }

    //
    // update screen buffer
    //

    if (UpdateRowIndex) {
        ScreenInfo->BufferInfo.TextInfo.FirstRow =
            (SHORT)((RowIndex + ScrollValue) % ScreenInfo->ScreenBufferSize.Y);
    }

    return RowIndex;
}

VOID
StreamScrollRegion(
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine is a special-purpose scroll for use by
    AdjustCursorPosition.

Arguments:

    ScreenInfo - pointer to screen buffer info.

Return Value:

--*/

{
    SHORT RowIndex;
    PROW Row;
    PWCHAR Char;
    RECT Rect;
    RECT BoundingBox;
    int ScreenWidth,ScrollHeight,ScreenHeight;
    COORD FontSize;
    SMALL_RECT UpdateRegion;
    BOOL Success;
    int i;
#if defined(FE_SB)
    PBYTE AttrP;
#endif
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    RowIndex = ScrollEntireScreen(ScreenInfo,1,TRUE);

    Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];

    //
    // fill line with blanks
    //

    Char = &Row->CharRow.Chars[Row->CharRow.Left];
    for (i=Row->CharRow.Left;i<Row->CharRow.Right;i++) {
        *Char = (WCHAR)' ';
        Char++;
    }
#if defined(FE_SB)
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console)){
        int LineWidth = Row->CharRow.Right - Row->CharRow.Left;
        AttrP = &Row->CharRow.KAttrs[Row->CharRow.Left];
        if ( LineWidth > 0 )
            RtlZeroMemory(AttrP, LineWidth);
        AttrP += LineWidth;
        Row->CharRow.OldRight = INVALID_OLD_LENGTH;
        Row->CharRow.OldLeft = INVALID_OLD_LENGTH;
        Console->ConsoleIme.ScrollWaitCountDown = Console->ConsoleIme.ScrollWaitTimeout;
    }
#endif
    Row->CharRow.Right = 0;
    Row->CharRow.Left = ScreenInfo->ScreenBufferSize.X;

    //
    // set up attributes
    //

    if (Row->AttrRow.Length != 1) {
        ConsoleHeapFree(Row->AttrRow.Attrs);
        Row->AttrRow.Attrs = &Row->AttrRow.AttrPair;
        Row->AttrRow.AttrPair.Length = ScreenInfo->ScreenBufferSize.X;
        Row->AttrRow.Length = 1;
    }
    Row->AttrRow.AttrPair.Attr = ScreenInfo->Attributes;

    //
    // update screen
    //

    if (ACTIVE_SCREEN_BUFFER(ScreenInfo) &&
        Console->FullScreenFlags == 0 &&
        !(Console->Flags & (CONSOLE_IS_ICONIC | CONSOLE_NO_WINDOW))) {

        ConsoleHideCursor(ScreenInfo);
        if (UsePolyTextOut) {
            WriteRegionToScreen(ScreenInfo, &ScreenInfo->Window);
        } else {
            FontSize = SCR_FONTSIZE(ScreenInfo);
            ScreenWidth = WINDOW_SIZE_X(&ScreenInfo->Window) * FontSize.X;
            ScreenHeight = WINDOW_SIZE_Y(&ScreenInfo->Window) * FontSize.Y;
            ScrollHeight = ScreenHeight - FontSize.Y;

            Rect.left = 0;
            Rect.right = ScreenWidth;
            Rect.top = FontSize.Y;
            Rect.bottom = ScreenHeight;

            //
            // find smallest bounding rectangle
            //

            if (ScreenInfo->BufferInfo.TextInfo.Flags & TEXT_VALID_HINT) {
                SHORT MinLeft,MaxRight;
                MinLeft = ScreenInfo->ScreenBufferSize.X;
                MaxRight = 0;
                RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+ScreenInfo->Window.Top) % ScreenInfo->ScreenBufferSize.Y;
                for (i=ScreenInfo->Window.Top+1;i<=ScreenInfo->Window.Bottom;i++) {
                    Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
                    if (Row->CharRow.OldLeft == INVALID_OLD_LENGTH) {
                        MinLeft = 0;
                    } else {
                        if (MinLeft > min(Row->CharRow.Left,Row->CharRow.OldLeft)) {
                            MinLeft = min(Row->CharRow.Left,Row->CharRow.OldLeft);
                        }
                    }
                    if (Row->CharRow.OldRight == INVALID_OLD_LENGTH) {
                        MaxRight = ScreenInfo->ScreenBufferSize.X-1;
                    } else {
                        if (MaxRight < max(Row->CharRow.Right,Row->CharRow.OldRight)) {
                            MaxRight = max(Row->CharRow.Right,Row->CharRow.OldRight);
                        }
                    }
                    if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
                        RowIndex = 0;
                    }
                }
                Rect.left = MinLeft*FontSize.X;
                Rect.right = (MaxRight+1)*FontSize.X;
            }

            LockScrollBuffer();
            ASSERT (ScreenInfo->BufferInfo.TextInfo.UpdatingScreen>0);
            Success = (int)ScrollDC(Console->hDC,
                                0,
                                -FontSize.Y,
                                &Rect,
                                NULL,
                                ghrgnScroll,
                                NULL
                               );

            //
            // Fire off an event to let accessibility apps know we've scrolled.
            //

            ConsoleNotifyWinEvent(Console,
                                  EVENT_CONSOLE_UPDATE_SCROLL,
                                  0,
                                  -1);

            if (Success && ScreenInfo->Window.Top!=ScreenInfo->Window.Bottom) {
#if defined(FE_SB)
                if (CONSOLE_IS_DBCS_OUTPUTCP(Console) &&
                    ScreenInfo->Attributes & (COMMON_LVB_GRID_HORIZONTAL +
                                               COMMON_LVB_GRID_LVERTICAL +
                                               COMMON_LVB_GRID_RVERTICAL +
                                               COMMON_LVB_REVERSE_VIDEO  +
                                               COMMON_LVB_UNDERSCORE     )){
                    UpdateRegion = ScreenInfo->Window;
                    UpdateRegion.Top = UpdateRegion.Bottom;
                    ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
                    WriteToScreen(ScreenInfo,&UpdateRegion);
                }
                else{
#endif
                switch (GetRgnBox(ghrgnScroll, &BoundingBox)) {
                case SIMPLEREGION:
                    if (BoundingBox.left == 0 &&
                        BoundingBox.right == ScreenWidth &&
                        BoundingBox.top == ScrollHeight &&
                        BoundingBox.bottom == ScreenHeight) {

                        PatBlt(Console->hDC,0,ScrollHeight,ScreenWidth,FontSize.Y,PATCOPY);
                        GdiFlush();
                    } else {
                        UpdateRegion.Left = (SHORT)((BoundingBox.left/FontSize.X)+ScreenInfo->Window.Left);
                        UpdateRegion.Right = (SHORT)(((BoundingBox.right-1)/FontSize.X)+ScreenInfo->Window.Left);
                        UpdateRegion.Top = (SHORT)((BoundingBox.top/FontSize.Y)+ScreenInfo->Window.Top);
                        UpdateRegion.Bottom = (SHORT)(((BoundingBox.bottom-1)/FontSize.Y)+ScreenInfo->Window.Top);
                        WriteToScreen(ScreenInfo,&UpdateRegion);
                    }
                    break;
                case COMPLEXREGION:
                    UpdateComplexRegion(ScreenInfo,FontSize);
                    break;
                }
#if defined(FE_SB)
                }
#endif
            } else  {
                WriteToScreen(ScreenInfo,&ScreenInfo->Window);
            }
            UnlockScrollBuffer();
        }
        ConsoleShowCursor(ScreenInfo);
    }
#ifdef i386
    else if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
        SMALL_RECT ScrollRect;
        COORD TargetPoint;

        ScrollRect = ScreenInfo->Window;
        TargetPoint.Y = ScrollRect.Top;
        ScrollRect.Top += 1;
        TargetPoint.X = 0;
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_OUTPUTCP(Console) ) {
            if (! ScreenInfo->ConvScreenInfo)  {
                if (ScreenInfo->Console->CurrentScreenBuffer == ScreenInfo) {
                    ScrollHW(ScreenInfo,
                             &ScrollRect,
                             NULL,
                             TargetPoint
                            );
                }
            }
            else if (ScreenInfo->Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) {
                ScrollHW(ScreenInfo,
                         &ScrollRect,
                         NULL,
                         TargetPoint
                        );
            }
        }
        else
#endif
        ScrollHW(ScreenInfo,
                 &ScrollRect,
                 NULL,
                 TargetPoint
                );
        ScrollRect.Top = ScrollRect.Bottom - 1;
        WriteRegionToScreenHW(ScreenInfo,&ScrollRect);
    }
#endif
}

NTSTATUS
ScrollRegion(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN OUT PSMALL_RECT ScrollRectangle,
    IN PSMALL_RECT ClipRectangle OPTIONAL,
    IN COORD  DestinationOrigin,
    IN CHAR_INFO Fill
    )

/*++

Routine Description:

    This routine copies ScrollRectangle to DestinationOrigin then
    fills in ScrollRectangle with Fill.  The scroll region is
    copied to a third buffer, the scroll region is filled, then the
    original contents of the scroll region are copied to the destination.

Arguments:

    ScreenInfo - pointer to screen buffer info.

    ScrollRectangle - Region to copy

    ClipRectangle - Optional pointer to clip region.

    DestinationOrigin - Upper left corner of target region.

    Fill - Character and attribute to fill source region with.

Return Value:

--*/

{
    SMALL_RECT TargetRectangle, SourceRectangle;
    COORD TargetPoint;
    COORD Size;
    SMALL_RECT OurClipRectangle;
    SMALL_RECT ScrollRectangle2,ScrollRectangle3;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    // here's how we clip:
    //
    // Clip source rectangle to screen buffer => S
    // Create target rectangle based on S => T
    // Clip T to ClipRegion => T
    // Create S2 based on clipped T => S2
    // Clip S to ClipRegion => S3
    //
    // S2 is the region we copy to T
    // S3 is the region to fill

    if (Fill.Char.UnicodeChar == '\0' && Fill.Attributes == 0) {
        Fill.Char.UnicodeChar = (WCHAR)' ';
        Fill.Attributes = ScreenInfo->Attributes;
    }

    //
    // clip the source rectangle to the screen buffer
    //

    if (ScrollRectangle->Left < 0) {
        DestinationOrigin.X += -ScrollRectangle->Left;
        ScrollRectangle->Left = 0;
    }
    if (ScrollRectangle->Top < 0) {
        DestinationOrigin.Y += -ScrollRectangle->Top;
        ScrollRectangle->Top = 0;
    }
    if (ScrollRectangle->Right >= ScreenInfo->ScreenBufferSize.X) {
        ScrollRectangle->Right = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
    }
    if (ScrollRectangle->Bottom >= ScreenInfo->ScreenBufferSize.Y) {
        ScrollRectangle->Bottom = (SHORT)(ScreenInfo->ScreenBufferSize.Y-1);
    }

    //
    // if source rectangle doesn't intersect screen buffer, return.
    //

    if (ScrollRectangle->Bottom < ScrollRectangle->Top ||
        ScrollRectangle->Right < ScrollRectangle->Left) {
        return STATUS_SUCCESS;
    }

    //
    // clip the target rectangle
    // if a cliprectangle was provided, clip it to the screen buffer.
    // if not, set the cliprectangle to the screen buffer region.
    //

    if (ClipRectangle) {

        //
        // clip the cliprectangle.
        //

        if (ClipRectangle->Left < 0) {
            ClipRectangle->Left = 0;
        }
        if (ClipRectangle->Top < 0) {
            ClipRectangle->Top = 0;
        }
        if (ClipRectangle->Right >= ScreenInfo->ScreenBufferSize.X) {
            ClipRectangle->Right = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
        }
        if (ClipRectangle->Bottom >= ScreenInfo->ScreenBufferSize.Y) {
            ClipRectangle->Bottom = (SHORT)(ScreenInfo->ScreenBufferSize.Y-1);
        }
    }
    else {
        OurClipRectangle.Left = 0;
        OurClipRectangle.Top = 0;
        OurClipRectangle.Right = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
        OurClipRectangle.Bottom = (SHORT)(ScreenInfo->ScreenBufferSize.Y-1);
        ClipRectangle = &OurClipRectangle;
    }

    //
    // Create target rectangle based on S => T
    // Clip T to ClipRegion => T
    // Create S2 based on clipped T => S2
    //

    ScrollRectangle2 = *ScrollRectangle;
    TargetRectangle.Left = DestinationOrigin.X;
    TargetRectangle.Top = DestinationOrigin.Y;
    TargetRectangle.Right = (SHORT)(DestinationOrigin.X + (ScrollRectangle2.Right -  ScrollRectangle2.Left + 1) - 1);
    TargetRectangle.Bottom = (SHORT)(DestinationOrigin.Y + (ScrollRectangle2.Bottom - ScrollRectangle2.Top + 1) - 1);

    if (TargetRectangle.Left < ClipRectangle->Left) {
        ScrollRectangle2.Left += ClipRectangle->Left - TargetRectangle.Left;
        TargetRectangle.Left = ClipRectangle->Left;
    }
    if (TargetRectangle.Top < ClipRectangle->Top) {
        ScrollRectangle2.Top += ClipRectangle->Top - TargetRectangle.Top;
        TargetRectangle.Top = ClipRectangle->Top;
    }
    if (TargetRectangle.Right > ClipRectangle->Right) {
        ScrollRectangle2.Right -= TargetRectangle.Right - ClipRectangle->Right;
        TargetRectangle.Right = ClipRectangle->Right;
    }
    if (TargetRectangle.Bottom > ClipRectangle->Bottom) {
        ScrollRectangle2.Bottom -= TargetRectangle.Bottom - ClipRectangle->Bottom;
        TargetRectangle.Bottom = ClipRectangle->Bottom;
    }

    //
    // clip scroll rect to clipregion => S3
    //

    ScrollRectangle3 = *ScrollRectangle;
    if (ScrollRectangle3.Left < ClipRectangle->Left) {
        ScrollRectangle3.Left = ClipRectangle->Left;
    }
    if (ScrollRectangle3.Top < ClipRectangle->Top) {
        ScrollRectangle3.Top = ClipRectangle->Top;
    }
    if (ScrollRectangle3.Right > ClipRectangle->Right) {
        ScrollRectangle3.Right = ClipRectangle->Right;
    }
    if (ScrollRectangle3.Bottom > ClipRectangle->Bottom) {
        ScrollRectangle3.Bottom = ClipRectangle->Bottom;
    }

    //
    // if scroll rect doesn't intersect clip region, return.
    //

    if (ScrollRectangle3.Bottom < ScrollRectangle3.Top ||
        ScrollRectangle3.Right < ScrollRectangle3.Left) {
        return STATUS_SUCCESS;
    }

    ConsoleHideCursor(ScreenInfo);

#if defined(FE_IME)
    Console->ConsoleIme.ScrollWaitCountDown = Console->ConsoleIme.ScrollWaitTimeout;
#endif // FE_IME
    //
    // if target rectangle doesn't intersect screen buffer, skip scrolling
    // part.
    //

    if (!(TargetRectangle.Bottom < TargetRectangle.Top ||
          TargetRectangle.Right < TargetRectangle.Left)) {

        //
        // if we can, don't use intermediate scroll region buffer.  do this
        // by figuring out fill rectangle.  NOTE: this code will only work
        // if CopyRectangle copies from low memory to high memory (otherwise
        // we would overwrite the scroll region before reading it).
        //

        if (ScrollRectangle2.Right == TargetRectangle.Right &&
            ScrollRectangle2.Left == TargetRectangle.Left &&
            ScrollRectangle2.Top > TargetRectangle.Top &&
            ScrollRectangle2.Top < TargetRectangle.Bottom) {

            SMALL_RECT FillRect;
            SHORT LastRowIndex,OldRight,OldLeft;
            PROW Row;

            TargetPoint.X = TargetRectangle.Left;
            TargetPoint.Y = TargetRectangle.Top;
            if (ScrollRectangle2.Right == (SHORT)(ScreenInfo->ScreenBufferSize.X-1) &&
                ScrollRectangle2.Left == 0 &&
                ScrollRectangle2.Bottom == (SHORT)(ScreenInfo->ScreenBufferSize.Y-1) &&
                ScrollRectangle2.Top == 1 ) {
                LastRowIndex = ScrollEntireScreen(ScreenInfo,(SHORT)(ScrollRectangle2.Top-TargetRectangle.Top),TRUE);
                Row = &ScreenInfo->BufferInfo.TextInfo.Rows[LastRowIndex];
                OldRight = Row->CharRow.OldRight;
                OldLeft = Row->CharRow.OldLeft;
            } else {
                LastRowIndex = -1;
                CopyRectangle(ScreenInfo,
                              &ScrollRectangle2,
                              TargetPoint
                             );
            }
            FillRect.Left = TargetRectangle.Left;
            FillRect.Right = TargetRectangle.Right;
            FillRect.Top = (SHORT)(TargetRectangle.Bottom+1);
            FillRect.Bottom = ScrollRectangle->Bottom;
            if (FillRect.Top < ClipRectangle->Top) {
                FillRect.Top = ClipRectangle->Top;
            }
            if (FillRect.Bottom > ClipRectangle->Bottom) {
                FillRect.Bottom = ClipRectangle->Bottom;
            }
            FillRectangle(Fill,
                          ScreenInfo,
                          &FillRect
                         );

            //
            // After ScrollEntireScreen, the OldRight and OldLeft values
            // for the last row are set correctly.  however, FillRectangle
            // resets them with the previous first row of the screen.
            // reset them here.
            //

            if (LastRowIndex != -1) {
                Row->CharRow.OldRight = OldRight;
                Row->CharRow.OldLeft = OldLeft;
            }

            //
            // update to screen, if we're not iconic.  we're marked as
            // iconic if we're fullscreen, so check for fullscreen.
            //

            if (!(Console->Flags & CONSOLE_IS_ICONIC) ||
                 Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
                ScrollScreen(ScreenInfo,
                       &ScrollRectangle2,
                       &FillRect,
                       TargetPoint
                      );
            }
        }

        //
        // if no overlap, don't need intermediate copy
        //

        else if (ScrollRectangle3.Right < TargetRectangle.Left ||
                 ScrollRectangle3.Left > TargetRectangle.Right ||
                 ScrollRectangle3.Top > TargetRectangle.Bottom ||
                 ScrollRectangle3.Bottom < TargetRectangle.Top) {
            TargetPoint.X = TargetRectangle.Left;
            TargetPoint.Y = TargetRectangle.Top;
            CopyRectangle(ScreenInfo,
                          &ScrollRectangle2,
                          TargetPoint
                         );
            FillRectangle(Fill,
                          ScreenInfo,
                          &ScrollRectangle3
                         );

            //
            // update to screen, if we're not iconic.  we're marked as
            // iconic if we're fullscreen, so check for fullscreen.
            //

            if (!(Console->Flags & CONSOLE_IS_ICONIC) ||
                Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
                ScrollScreen(ScreenInfo,
                       &ScrollRectangle2,
                       &ScrollRectangle3,
                       TargetPoint
                      );
            }
        }

        //
        // for the case where the source and target rectangles overlap, we
        // copy the source rectangle, fill it, then copy it to the target.
        //

        else {
            SMALL_RECT TargetRect;
            COORD SourcePoint;

            LockScrollBuffer();
            Size.X = (SHORT)(ScrollRectangle2.Right - ScrollRectangle2.Left + 1);
            Size.Y = (SHORT)(ScrollRectangle2.Bottom - ScrollRectangle2.Top + 1);
            if (ScrollBufferSize < (Size.X * Size.Y * sizeof(CHAR_INFO))) {
                FreeScrollBuffer();
                Status = AllocateScrollBuffer(Size.X * Size.Y * sizeof(CHAR_INFO));
                if (!NT_SUCCESS(Status)) {
                    UnlockScrollBuffer();
                    ConsoleShowCursor(ScreenInfo);
                    return Status;
                }
            }

            TargetRect.Left = 0;
            TargetRect.Top = 0;
            TargetRect.Right = ScrollRectangle2.Right - ScrollRectangle2.Left;
            TargetRect.Bottom = ScrollRectangle2.Bottom - ScrollRectangle2.Top;
            SourcePoint.X = ScrollRectangle2.Left;
            SourcePoint.Y = ScrollRectangle2.Top;
            ReadRectFromScreenBuffer(ScreenInfo,
                                     SourcePoint,
                                     ScrollBuffer,
                                     Size,
                                     &TargetRect
                                    );

            FillRectangle(Fill,
                          ScreenInfo,
                          &ScrollRectangle3
                         );

            SourceRectangle.Top = 0;
            SourceRectangle.Left = 0;
            SourceRectangle.Right = (SHORT)(Size.X-1);
            SourceRectangle.Bottom = (SHORT)(Size.Y-1);
            TargetPoint.X = TargetRectangle.Left;
            TargetPoint.Y = TargetRectangle.Top;
            WriteRectToScreenBuffer((PBYTE)ScrollBuffer,
                                    Size,
                                    &SourceRectangle,
                                    ScreenInfo,
                                    TargetPoint,
                                    0xFFFFFFFF
                                   );
            UnlockScrollBuffer();

            //
            // update to screen, if we're not iconic.  we're marked as
            // iconic if we're fullscreen, so check for fullscreen.
            //

            if (!(Console->Flags & CONSOLE_IS_ICONIC) ||
                Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {

                //
                // update regions on screen.
                //

                ScrollScreen(ScreenInfo,
                       &ScrollRectangle2,
                       &ScrollRectangle3,
                       TargetPoint
                      );
            }
        }
    }
    else {

        //
        // do fill
        //

        FillRectangle(Fill,
                      ScreenInfo,
                      &ScrollRectangle3
                     );

        //
        // update to screen, if we're not iconic.  we're marked as
        // iconic if we're fullscreen, so check for fullscreen.
        //

        if (ACTIVE_SCREEN_BUFFER(ScreenInfo) &&
            !(Console->Flags & CONSOLE_IS_ICONIC) ||
            Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
            WriteToScreen(ScreenInfo,&ScrollRectangle3);
        }
    }
    ConsoleShowCursor(ScreenInfo);
    return STATUS_SUCCESS;
}


NTSTATUS
SetWindowOrigin(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN BOOLEAN Absolute,
    IN COORD WindowOrigin
    )

/*++

Routine Description:

    This routine sets the window origin.

Arguments:

    ScreenInfo - pointer to screen buffer info.

    Absolute - if TRUE, WindowOrigin is specified in absolute screen
    buffer coordinates.  if FALSE, WindowOrigin is specified in coordinates
    relative to the current window origin.

    WindowOrigin - New window origin.

Return Value:

--*/

{
    SMALL_RECT NewWindow;
    COORD WindowSize;
    RECT BoundingBox;
    BOOL Success;
    RECT ScrollRect;
    SMALL_RECT UpdateRegion;
    COORD FontSize;
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    //
    // calculate window size
    //

    WindowSize.X = (SHORT)CONSOLE_WINDOW_SIZE_X(ScreenInfo);
    WindowSize.Y = (SHORT)CONSOLE_WINDOW_SIZE_Y(ScreenInfo);

    //
    // if relative coordinates, figure out absolute coords.
    //

    if (!Absolute) {
        if (WindowOrigin.X == 0 && WindowOrigin.Y == 0) {
            return STATUS_SUCCESS;
        }
        NewWindow.Left = ScreenInfo->Window.Left + WindowOrigin.X;
        NewWindow.Top = ScreenInfo->Window.Top + WindowOrigin.Y;
    }
    else {
        if (WindowOrigin.X == ScreenInfo->Window.Left &&
            WindowOrigin.Y == ScreenInfo->Window.Top) {
            return STATUS_SUCCESS;
        }
        NewWindow.Left = WindowOrigin.X;
        NewWindow.Top = WindowOrigin.Y;
    }
    NewWindow.Right = (SHORT)(NewWindow.Left + WindowSize.X - 1);
    NewWindow.Bottom = (SHORT)(NewWindow.Top + WindowSize.Y - 1);

    //
    // see if new window origin would extend window beyond extent of screen
    // buffer
    //

    if (NewWindow.Left < 0 || NewWindow.Top < 0 ||
        NewWindow.Right < 0 || NewWindow.Bottom < 0 ||
        NewWindow.Right >= ScreenInfo->ScreenBufferSize.X ||
        NewWindow.Bottom >= ScreenInfo->ScreenBufferSize.Y) {
        return STATUS_INVALID_PARAMETER;
    }

    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        FontSize = SCR_FONTSIZE(ScreenInfo);
        ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
    } else {
        FontSize.X = 1;
        FontSize.Y = 1;
    }
    ConsoleHideCursor(ScreenInfo);
    if (ACTIVE_SCREEN_BUFFER(ScreenInfo) &&
        Console->FullScreenFlags == 0 &&
        !(Console->Flags & (CONSOLE_IS_ICONIC | CONSOLE_NO_WINDOW))) {

        InvertSelection(Console, TRUE);
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_OUTPUTCP(Console) &&
            !(Console->ConsoleIme.ScrollFlag & HIDE_FOR_SCROLL)) {
            ConsoleImeBottomLineUse(ScreenInfo,0);
        }
#endif
        if (   ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER
            && UsePolyTextOut
            && NewWindow.Left == ScreenInfo->Window.Left
           ) {
            ScrollEntireScreen(ScreenInfo,
                (SHORT)(NewWindow.Top - ScreenInfo->Window.Top),
                FALSE);
            ScreenInfo->Window = NewWindow;
            WriteRegionToScreen(ScreenInfo, &NewWindow);
        } else {
#if defined(FE_SB)
            RECT ClipRect;
#endif
            ScrollRect.left = 0;
            ScrollRect.right = CONSOLE_WINDOW_SIZE_X(ScreenInfo)*FontSize.X;
            ScrollRect.top = 0;
#if defined(FE_SB)
            if (CONSOLE_IS_DBCS_OUTPUTCP(Console) &&
                Console->InputBuffer.ImeMode.Open )
            {
                if (ScreenInfo->Window.Top <= NewWindow.Top)
                    ScrollRect.bottom = (CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-1)*FontSize.Y;
                else
                    ScrollRect.bottom = (CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-2)*FontSize.Y;
                ClipRect = ScrollRect;
                ClipRect.bottom = (CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-1)*FontSize.Y;
            }
            else
#endif
            ScrollRect.bottom = CONSOLE_WINDOW_SIZE_Y(ScreenInfo)*FontSize.Y;

#if defined(FE_SB)
            if (CONSOLE_IS_DBCS_OUTPUTCP(Console) &&
                ScrollRect.bottom == 0) {
                UpdateRegion.Left   = 0;
                UpdateRegion.Top    = 0;
                UpdateRegion.Right  = CONSOLE_WINDOW_SIZE_X(ScreenInfo);
                UpdateRegion.Bottom = 0;
                WriteToScreen(ScreenInfo,&UpdateRegion);
            }
            else {
#endif
            SCROLLDC_CALL;
#if defined(FE_SB)
                if (CONSOLE_IS_DBCS_OUTPUTCP(Console) &&
                     Console->InputBuffer.ImeMode.Open )
                {
                    Success = ScrollDC(Console->hDC,
                                         (ScreenInfo->Window.Left-NewWindow.Left)*FontSize.X,
                                         (ScreenInfo->Window.Top-NewWindow.Top)*FontSize.Y,
                                         &ScrollRect,
                                         &ClipRect,
                                         NULL,
                                         &BoundingBox
                                         );
                }
                else
#endif
            Success = ScrollDC(Console->hDC,
                                 (ScreenInfo->Window.Left-NewWindow.Left)*FontSize.X,
                                 (ScreenInfo->Window.Top-NewWindow.Top)*FontSize.Y,
                                 &ScrollRect,
                                 NULL,
                                 NULL,
                                 &BoundingBox
                               );

            //
            // Fire off an event to let accessibility apps know we've scrolled.
            //

            ConsoleNotifyWinEvent(Console,
                                  EVENT_CONSOLE_UPDATE_SCROLL,
                                  ScreenInfo->Window.Left - NewWindow.Left,
                                  ScreenInfo->Window.Top - NewWindow.Top);

            if (Success) {
                UpdateRegion.Left = (SHORT)((BoundingBox.left/FontSize.X)+NewWindow.Left);
                UpdateRegion.Right = (SHORT)(((BoundingBox.right-1)/FontSize.X)+NewWindow.Left);
                UpdateRegion.Top = (SHORT)((BoundingBox.top/FontSize.Y)+NewWindow.Top);
                UpdateRegion.Bottom = (SHORT)(((BoundingBox.bottom-1)/FontSize.Y)+NewWindow.Top);
            }
            else  {
                UpdateRegion = NewWindow;
            }

            //
            // new window is ok.  store it in screeninfo and refresh screen.
            //

            ScreenInfo->Window = NewWindow;

            WriteToScreen(ScreenInfo,&UpdateRegion);
#if defined(FE_SB)
            }
#endif
        }
        InvertSelection(Console, FALSE);
    }
#ifdef i386
    else if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE &&
             ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {


        //
        // keep mouse pointer on screen
        //

        if (ScreenInfo->BufferInfo.TextInfo.MousePosition.X < NewWindow.Left) {
            ScreenInfo->BufferInfo.TextInfo.MousePosition.X = NewWindow.Left;
        } else if (ScreenInfo->BufferInfo.TextInfo.MousePosition.X > NewWindow.Right) {
            ScreenInfo->BufferInfo.TextInfo.MousePosition.X = NewWindow.Right;
        }

        if (ScreenInfo->BufferInfo.TextInfo.MousePosition.Y < NewWindow.Top) {
            ScreenInfo->BufferInfo.TextInfo.MousePosition.Y = NewWindow.Top;
        } else if (ScreenInfo->BufferInfo.TextInfo.MousePosition.Y > NewWindow.Bottom) {
            ScreenInfo->BufferInfo.TextInfo.MousePosition.Y = NewWindow.Bottom;
        }
        ScreenInfo->Window = NewWindow;
        WriteToScreen(ScreenInfo,&ScreenInfo->Window);
    }
#endif
    else {
        // we're iconic
        ScreenInfo->Window = NewWindow;
    }

#if defined(FE_SB)
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console) ) {
        ConsoleImeResizeModeSystemView(Console,ScreenInfo->Window);
        ConsoleImeResizeCompStrView(Console,ScreenInfo->Window);
    }
#endif
    ConsoleShowCursor(ScreenInfo);

    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
         ScreenInfo->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;
    }

    UpdateScrollBars(ScreenInfo);
    return STATUS_SUCCESS;
}

NTSTATUS
ResizeWindow(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT WindowDimensions,
    IN BOOL DoScrollBarUpdate
    )

/*++

Routine Description:

    This routine changes the console data structures to reflect the specified
    window size change.  it does not call the user component to update
    the screen.

Arguments:

    ScreenInformation - the new screen buffer.

    dwWindowSize - the initial size of screen buffer's window.

    nFont - the initial font to generate text with.

    dwScreenBufferSize - the initial size of the screen buffer.

Return Value:


--*/

{
    //
    // make sure there's something to do
    //

    if (RtlEqualMemory(&ScreenInfo->Window, WindowDimensions, sizeof(SMALL_RECT))) {
        return STATUS_SUCCESS;
    }

    if (WindowDimensions->Left < 0) {
        WindowDimensions->Right -= WindowDimensions->Left;
        WindowDimensions->Left = 0;
    }
    if (WindowDimensions->Top < 0) {
        WindowDimensions->Bottom -= WindowDimensions->Top;
        WindowDimensions->Top = 0;
    }

    if (WindowDimensions->Right >= ScreenInfo->ScreenBufferSize.X) {
        WindowDimensions->Right = ScreenInfo->ScreenBufferSize.X;
    }
    if (WindowDimensions->Bottom >= ScreenInfo->ScreenBufferSize.Y) {
        WindowDimensions->Bottom = ScreenInfo->ScreenBufferSize.Y;
    }

    ScreenInfo->Window = *WindowDimensions;
    ScreenInfo->WindowMaximizedX = (CONSOLE_WINDOW_SIZE_X(ScreenInfo) == ScreenInfo->ScreenBufferSize.X);
    ScreenInfo->WindowMaximizedY = (CONSOLE_WINDOW_SIZE_Y(ScreenInfo) == ScreenInfo->ScreenBufferSize.Y);

    if (DoScrollBarUpdate) {
        UpdateScrollBars(ScreenInfo);
    }

    if (!(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)) {
        return STATUS_SUCCESS;
    }

    if (ACTIVE_SCREEN_BUFFER(ScreenInfo)) {
        ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
    }

#ifdef i386
    if (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {

        //
        // keep mouse pointer on screen
        //

        if (ScreenInfo->BufferInfo.TextInfo.MousePosition.X < WindowDimensions->Left) {
            ScreenInfo->BufferInfo.TextInfo.MousePosition.X = WindowDimensions->Left;
        } else if (ScreenInfo->BufferInfo.TextInfo.MousePosition.X > WindowDimensions->Right) {
            ScreenInfo->BufferInfo.TextInfo.MousePosition.X = WindowDimensions->Right;
        }

        if (ScreenInfo->BufferInfo.TextInfo.MousePosition.Y < WindowDimensions->Top) {
            ScreenInfo->BufferInfo.TextInfo.MousePosition.Y = WindowDimensions->Top;
        } else if (ScreenInfo->BufferInfo.TextInfo.MousePosition.Y > WindowDimensions->Bottom) {
            ScreenInfo->BufferInfo.TextInfo.MousePosition.Y = WindowDimensions->Bottom;
        }
    }
#endif

    return(STATUS_SUCCESS);
}

VOID
SetWindowSize(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
#if defined(FE_IME)
    if (ScreenInfo->ConvScreenInfo != NULL)
        return;
#endif
    if (ScreenInfo->Console->Flags & CONSOLE_SETTING_WINDOW_SIZE)
        return;
    ScreenInfo->Console->Flags |= CONSOLE_SETTING_WINDOW_SIZE;
    PostMessage(ScreenInfo->Console->hWnd,
                 CM_SET_WINDOW_SIZE,
                 (WPARAM)ScreenInfo,
                 0x47474747
                );
}

VOID
UpdateWindowSize(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    LONG WindowStyle;

    if (!(Console->Flags & CONSOLE_IS_ICONIC)) {
        InternalUpdateScrollBars(ScreenInfo);

        WindowStyle = GetWindowLong(Console->hWnd, GWL_STYLE);
        if (ScreenInfo->WindowMaximized) {
            WindowStyle |= WS_MAXIMIZE;
        } else {
            WindowStyle &= ~WS_MAXIMIZE;
        }
        SetWindowLong(Console->hWnd, GWL_STYLE, WindowStyle);

        SetWindowPos(Console->hWnd, NULL,
                     0,
                     0,
                     Console->WindowRect.right-Console->WindowRect.left,
                     Console->WindowRect.bottom-Console->WindowRect.top,
                     SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_DRAWFRAME
                    );
        Console->ResizeFlags &= ~SCREEN_BUFFER_CHANGE;
    } else {
        Console->ResizeFlags |= SCREEN_BUFFER_CHANGE;
    }
}

NTSTATUS
InternalSetWindowSize(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Window
    )
{
    SIZE WindowSize;
    WORD WindowSizeX, WindowSizeY;

    Console->Flags &= ~CONSOLE_SETTING_WINDOW_SIZE;
    if (Console->CurrentScreenBuffer == ScreenInfo) {
        if (Console->FullScreenFlags == 0) {
            //
            // Make sure our max screen sizes reflect reality
            //

            if (gfInitSystemMetrics) {
                InitializeSystemMetrics();
            }

            //
            // figure out how big to make the window, given the desired client area
            // size.
            //

            ScreenInfo->ResizingWindow++;
            WindowSizeX = WINDOW_SIZE_X(Window);
            WindowSizeY = WINDOW_SIZE_Y(Window);
            if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
                WindowSize.cx = WindowSizeX*SCR_FONTSIZE(ScreenInfo).X;
                WindowSize.cy = WindowSizeY*SCR_FONTSIZE(ScreenInfo).Y;
            } else {
                WindowSize.cx = WindowSizeX;
                WindowSize.cy = WindowSizeY;
            }
            WindowSize.cx += VerticalClientToWindow;
            WindowSize.cy += HorizontalClientToWindow;

            if (WindowSizeY != 0) {
                if (!ScreenInfo->WindowMaximizedX) {
                    WindowSize.cy += HorizontalScrollSize;
                }
                if (!ScreenInfo->WindowMaximizedY) {
                    WindowSize.cx += VerticalScrollSize;
                }
            }

            Console->WindowRect.right = Console->WindowRect.left + WindowSize.cx;
            Console->WindowRect.bottom = Console->WindowRect.top + WindowSize.cy;

            UpdateWindowSize(Console,ScreenInfo);
            ScreenInfo->ResizingWindow--;
        } else if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
            WriteToScreen(ScreenInfo,&ScreenInfo->Window);
        }
#if defined(FE_IME)
        if ( (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) &&
             (CONSOLE_IS_DBCS_OUTPUTCP(Console)))
        {
            ConsoleImeResizeModeSystemView(Console,Console->CurrentScreenBuffer->Window);
            ConsoleImeResizeCompStrView(Console,Console->CurrentScreenBuffer->Window);
        }
#endif // FE_IME
    }
    return STATUS_SUCCESS;
}

NTSTATUS
SetActiveScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    PSCREEN_INFORMATION OldScreenInfo;
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    OldScreenInfo = Console->CurrentScreenBuffer;
    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {

#if !defined(_X86_)
        if (Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
            return STATUS_INVALID_PARAMETER;
        }
#endif
        Console->CurrentScreenBuffer = ScreenInfo;

        if (Console->FullScreenFlags == 0) {

            //
            // initialize cursor
            //

            ScreenInfo->BufferInfo.TextInfo.CursorOn = FALSE;

            //
            // set font
            //

            SetFont(ScreenInfo);
        }
#if defined(_X86_)
        else if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {

            if (!(Console->Flags & CONSOLE_VDM_REGISTERED)) {

                if ( (!(OldScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)) ||
                     (OldScreenInfo->BufferInfo.TextInfo.ModeIndex!=ScreenInfo->BufferInfo.TextInfo.ModeIndex)) {

                    // set video mode and font
                    SetVideoMode(ScreenInfo);
                }

                //set up cursor

                SetCursorInformationHW(ScreenInfo,
                                       ScreenInfo->BufferInfo.TextInfo.CursorSize,
                                       ScreenInfo->BufferInfo.TextInfo.CursorVisible);
                SetCursorPositionHW(ScreenInfo,
                                    ScreenInfo->BufferInfo.TextInfo.CursorPosition);
            }

        }
#endif
    }
    else {
        Console->CurrentScreenBuffer = ScreenInfo;
    }

    //
    // empty input buffer
    //

    FlushAllButKeys(&Console->InputBuffer);

    if (Console->FullScreenFlags == 0) {

        SetScreenColors(ScreenInfo, ScreenInfo->Attributes,
                        ScreenInfo->PopupAttributes, FALSE);

        //
        // set window size
        //

        SetWindowSize(ScreenInfo);

        //
        // initialize the palette, if we have the focus and we're not fullscreen
        //

        if (!(Console->Flags & CONSOLE_IS_ICONIC) &&
            Console->FullScreenFlags == 0) {
            if (ScreenInfo->hPalette != NULL || OldScreenInfo->hPalette != NULL) {
                HPALETTE hPalette;
                BOOL bReset = FALSE;
                USERTHREAD_USEDESKTOPINFO utudi;

                if (GetCurrentThreadId() != Console->InputThreadInfo->ThreadId) {
                    bReset = TRUE;
                    utudi.hThread = Console->InputThreadInfo->ThreadHandle;
                    utudi.drdRestore.pdeskRestore = NULL;
                    NtUserSetInformationThread(NtCurrentThread(),
                            UserThreadUseDesktop,
                            &utudi, sizeof(utudi));
                }

                if (ScreenInfo->hPalette == NULL) {
                    hPalette = Console->hSysPalette;
                } else {
                    hPalette = ScreenInfo->hPalette;
                }
                SelectPalette(Console->hDC,
                                 hPalette,
                                 FALSE);
                SetActivePalette(ScreenInfo);

                if (bReset == TRUE) {
                    utudi.hThread = NULL;
                    NtUserSetInformationThread(NtCurrentThread(),
                            UserThreadUseDesktop, &utudi, sizeof(utudi));
                }
            }
        }
    }

#if defined(FE_IME)
    SetUndetermineAttribute(Console);
#endif
    //
    // write data to screen
    //

    ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
    WriteToScreen(ScreenInfo,&ScreenInfo->Window);
    return STATUS_SUCCESS;
}

VOID
SetProcessFocus(
    IN PCSR_PROCESS Process,
    IN BOOL Foreground
    )
{
    if (Foreground) {
        CsrSetForegroundPriority(Process);
    } else {
        CsrSetBackgroundPriority(Process);
    }
}

VOID
SetProcessForegroundRights(
    IN PCSR_PROCESS Process,
    IN BOOL Foreground
    )
{
    USERTHREAD_FLAGS Flags;

    Flags.dwMask  = (W32PF_ALLOWSETFOREGROUND | W32PF_CONSOLEHASFOCUS);
    Flags.dwFlags = (Foreground ? (W32PF_ALLOWSETFOREGROUND | W32PF_CONSOLEHASFOCUS) : 0);

    NtUserSetInformationProcess(Process->ProcessHandle, UserProcessFlags, &Flags, sizeof(Flags));
}

VOID
ModifyConsoleProcessFocus(
    IN PCONSOLE_INFORMATION Console,
    IN BOOL Foreground
    )
{
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    PLIST_ENTRY ListHead, ListNext;

    ListHead = &Console->ProcessHandleList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        ProcessHandleRecord = CONTAINING_RECORD( ListNext, CONSOLE_PROCESS_HANDLE, ListLink );
        ListNext = ListNext->Flink;
        SetProcessFocus(ProcessHandleRecord->Process, Foreground);
        SetProcessForegroundRights(ProcessHandleRecord->Process, Foreground);
    }
}

VOID
TrimConsoleWorkingSet(
    IN PCONSOLE_INFORMATION Console
    )
{
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    PLIST_ENTRY ListHead, ListNext;

    ListHead = &Console->ProcessHandleList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        ProcessHandleRecord = CONTAINING_RECORD( ListNext, CONSOLE_PROCESS_HANDLE, ListLink );
        ListNext = ListNext->Flink;
        SetProcessWorkingSetSize(ProcessHandleRecord->Process->ProcessHandle, (SIZE_T)-1, (SIZE_T)-1);
    }
}

NTSTATUS
QueueConsoleMessage(
    PCONSOLE_INFORMATION Console,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    This inserts a message into the console's message queue and wakes up
    the console input thread to process it.

Arguments:

    Console - Pointer to console information structure.

    Message - Message to store in queue.

    wParam - wParam to store in queue.

    lParam - lParam to store in queue.

Return Value:

    NTSTATUS - STATUS_SUCCESS if everything is OK.

--*/

{
    PCONSOLE_MSG pConMsg;

    ASSERT(ConsoleLocked(Console));

    pConMsg = ConsoleHeapAlloc(TMP_TAG, sizeof(CONSOLE_MSG));
    if (pConMsg == NULL) {
        return STATUS_NO_MEMORY;
    }

    pConMsg->Message = Message;
    pConMsg->wParam = wParam;
    pConMsg->lParam = lParam;

    InsertHeadList(&Console->MessageQueue, &pConMsg->ListLink);

    if (!PostMessage(Console->hWnd, CM_CONSOLE_MSG, 0, 0)) {
        RemoveEntryList(&pConMsg->ListLink);
        ConsoleHeapFree(pConMsg);
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

BOOL
UnqueueConsoleMessage(
    PCONSOLE_INFORMATION Console,
    UINT *pMessage,
    WPARAM *pwParam,
    LPARAM *plParam
    )

/*++

Routine Description:

    This routine removes a message from the console's message queue.

Arguments:

    Console - Pointer to console information structure.

    pMessage - Pointer in which to return Message.

    pwParam - Pointer in which to return wParam.

    plParam - Pointer in which to return lParam.

Return Value:

    BOOL - TRUE if message was found and FALSE otherwise.

--*/

{
    PLIST_ENTRY pEntry;
    PCONSOLE_MSG pConMsg = NULL;

    ASSERT(ConsoleLocked(Console));

    if (IsListEmpty(&Console->MessageQueue)) {
        return FALSE;
    }

    pEntry = RemoveTailList(&Console->MessageQueue);
    pConMsg = CONTAINING_RECORD(pEntry, CONSOLE_MSG, ListLink);

    *pMessage = pConMsg->Message;
    *pwParam = pConMsg->wParam;
    *plParam = pConMsg->lParam;

    ConsoleHeapFree(pConMsg);

    return TRUE;
}

VOID
CleanupConsoleMessages(
    PCONSOLE_INFORMATION Console
    )

/*++

Routine Description:

    This routine cleans up any console messages still in the queue.

Arguments:

    Console - Pointer to console information structure.

Return Value:

    none.

--*/

{
    UINT Message;
    WPARAM wParam;
    LPARAM lParam;

    while (UnqueueConsoleMessage(Console, &Message, &wParam, &lParam)) {
        switch (Message) {
        case CM_MODE_TRANSITION:
            NtSetEvent((HANDLE)lParam, NULL);
            NtClose((HANDLE)lParam);
            break;
        case CM_SET_IME_CODEPAGE:
        case CM_SET_NLSMODE:
        case CM_GET_NLSMODE:
            if (wParam) {
                NtSetEvent((HANDLE)wParam, NULL);
                NtClose((HANDLE)wParam);
            }
            break;
        case EVENT_CONSOLE_CARET:
        case EVENT_CONSOLE_UPDATE_REGION:
        case EVENT_CONSOLE_UPDATE_SIMPLE:
        case EVENT_CONSOLE_UPDATE_SCROLL:
        case EVENT_CONSOLE_LAYOUT:
        case EVENT_CONSOLE_START_APPLICATION:
        case EVENT_CONSOLE_END_APPLICATION:
            break;
        default:
            RIPMSG1(RIP_ERROR,
                    "CleanupConsoleMessages - unknown message 0x%x",
                    Message);
            break;
        }
    }
}

VOID
ConsoleNotifyWinEvent(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD Event,
    IN LONG idObjectType,
    IN LONG idObject
    )

/*++

Routine Description:

    If this routine is called by the console input thread, it can notify the
    system about the event by calling NotifyWinEvent directly. Otherwise, it
    queues the event up for the input thread to deal with.

Arguments:

    Console - Pointer to console information structure.

    Event - Event that occurred.

    idObjectType - Additional data about the event.

    idObject - Additional data about the event.

Return Value:

    none.

--*/

{
    //
    // If no one's listening then there's no reason to send the winevent.
    //
    if (!IsWinEventHookInstalled(Event)) {
        return;
    }

    //
    // Due to the asynchronous nature of console creation, it's possible we'll get
    // here but the InputThreadInfo pointer hasn't been set yet. If that's the case,
    // we're certainly not the ConsoleInputThread, so conceptually we'd want to queue
    // up the winevent anyway.
    //
    if (Console->InputThreadInfo != NULL &&
        HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) == Console->InputThreadInfo->ThreadId) {
        NotifyWinEvent(Event, Console->hWnd, idObjectType, idObject);
    } else {
        QueueConsoleMessage(Console, Event, idObjectType, idObject);
    }
}

VOID
AbortCreateConsole(
    IN PCONSOLE_INFORMATION Console
    )
{
    //
    // Signal any process waiting for us that initialization failed
    //

    NtSetEvent(Console->InitEvents[INITIALIZATION_FAILED], NULL);

    //
    // Now clean up the console structure
    //

    CloseHandle(Console->ClientThreadHandle);
    FreeInputBuffer(&Console->InputBuffer);
    ConsoleHeapFree(Console->Title);
    ConsoleHeapFree(Console->OriginalTitle);
    NtClose(Console->InitEvents[INITIALIZATION_SUCCEEDED]);
    NtClose(Console->InitEvents[INITIALIZATION_FAILED]);
    NtClose(Console->TerminationEvent);
    FreeAliasBuffers(Console);
    FreeCommandHistoryBuffers(Console);
#if defined(FE_SB)
    FreeLocalEUDC(Console);
    DestroyFontCache(Console->FontCacheInformation);
#endif
    DestroyConsole(Console);
}

VOID
DestroyWindowsWindow(
    IN PCONSOLE_INFORMATION Console
    )
{
    PSCREEN_INFORMATION Cur,Next;
    HWND hWnd = Console->hWnd;

    gnConsoleWindows--;
    Console->InputThreadInfo->WindowCount--;

    SetWindowConsole(hWnd, NULL);

    KillTimer(Console->hWnd, CURSOR_TIMER);

    if (Console->hWndProperties) {
        SendMessage(Console->hWndProperties, WM_CLOSE, 0, 0);
    }

    // FE_SB
    if (Console->FonthDC) {
        ReleaseDC(NULL, Console->FonthDC);
        DeleteObject(Console->hBitmap);
    }
    DeleteEUDC(Console);

    // FE_IME
    if (CONSOLE_IS_IME_ENABLED()) {
        if (!(Console->Flags & CONSOLE_NO_WINDOW)) {
            KillTimer(Console->hWnd, SCROLL_WAIT_TIMER);
        }
        ConsoleImeMessagePump(Console,
                              CONIME_DESTROY,
                              (WPARAM)Console->ConsoleHandle,
                              (LPARAM)NULL
                             );
    }

    CleanupConsoleMessages(Console);

    ReleaseDC(NULL, Console->hDC);
    Console->hDC = NULL;

    DestroyWindow(Console->hWnd);
    Console->hWnd = NULL;

    //
    // Tell the worker thread that the window is destroyed.
    //

    ReplyMessage(0);

    //
    // Clear out any keyboard messages we have stored away.
    //

    ClearKeyInfo(hWnd);

    if (Console->hIcon != NULL && Console->hIcon != ghDefaultIcon) {
        DestroyIcon(Console->hIcon);
    }
    if (Console->hSmIcon != NULL && Console->hSmIcon != ghDefaultSmIcon) {
        DestroyIcon(Console->hSmIcon);
    }

    //
    // must keep this thread handle around until after the destroywindow
    // call so that impersonation will work.
    //

    CloseHandle(Console->ClientThreadHandle);

    //
    // once the sendmessage returns, there will be no more input to
    // the console so we don't need to lock it.
    // also, we've freed the console handle, so no apis may access the console.
    //

    //
    // free screen buffers
    //

    for (Cur=Console->ScreenBuffers;Cur!=NULL;Cur=Next) {
        Next = Cur->Next;
        FreeScreenBuffer(Cur);
    }

    FreeAliasBuffers(Console);
    FreeCommandHistoryBuffers(Console);

    //
    // free input buffer
    //

    FreeInputBuffer(&Console->InputBuffer);
    ConsoleHeapFree(Console->Title);
    ConsoleHeapFree(Console->OriginalTitle);
    NtClose(Console->InitEvents[INITIALIZATION_SUCCEEDED]);
    NtClose(Console->InitEvents[INITIALIZATION_FAILED]);
    NtClose(Console->TerminationEvent);
    if (Console->hWinSta != NULL) {
        CloseDesktop(Console->hDesk);
        CloseWindowStation(Console->hWinSta);
    }
    if (Console->VDMProcessHandle) {
        CloseHandle(Console->VDMProcessHandle);
    }
    ASSERT(!(Console->Flags & CONSOLE_VDM_REGISTERED));

#if defined(FE_SB)
    FreeLocalEUDC(Console);
    DestroyFontCache(Console->FontCacheInformation);
#endif

    DestroyConsole(Console);
}

VOID
VerticalScroll(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN WORD ScrollCommand,
    IN WORD AbsoluteChange
    )
{
    COORD NewOrigin;

    NewOrigin.X = ScreenInfo->Window.Left;
    NewOrigin.Y = ScreenInfo->Window.Top;
    switch (ScrollCommand) {
        case SB_LINEUP:
            NewOrigin.Y--;
            break;
        case SB_LINEDOWN:
            NewOrigin.Y++;
            break;
        case SB_PAGEUP:
#if defined(FE_IME)
// MSKK July.22.1993 KazuM
// Plan of bottom line reservation for console IME.
            if (ScreenInfo->Console->InputBuffer.ImeMode.Open) {
                ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
                if (!(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)) {
                    return;
                }
                NewOrigin.Y-=CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-2;
                ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
                ScreenInfo->BufferInfo.TextInfo.Flags |= CONSOLE_CONVERSION_AREA_REDRAW;
            }
            else
#endif // FE_IME
            NewOrigin.Y-=CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-1;
            break;
        case SB_PAGEDOWN:
#if defined(FE_IME)
// MSKK July.22.1993 KazuM
// Plan of bottom line reservation for console IME.
            if ( ScreenInfo->Console->InputBuffer.ImeMode.Open )
            {
                NewOrigin.Y+=CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-2;
                ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
                ScreenInfo->BufferInfo.TextInfo.Flags |= CONSOLE_CONVERSION_AREA_REDRAW;
            }
            else
#endif // FE_IME
            NewOrigin.Y+=CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-1;
            break;
        case SB_THUMBTRACK:
            Console->Flags |= CONSOLE_SCROLLBAR_TRACKING;
            NewOrigin.Y= AbsoluteChange;
            break;
        case SB_THUMBPOSITION:
            UnblockWriteConsole(Console, CONSOLE_SCROLLBAR_TRACKING);
            NewOrigin.Y= AbsoluteChange;
            break;
        case SB_TOP:
            NewOrigin.Y=0;
            break;
        case SB_BOTTOM:
            NewOrigin.Y=(WORD)(ScreenInfo->ScreenBufferSize.Y-CONSOLE_WINDOW_SIZE_Y(ScreenInfo));
            break;

        default:
            return;
    }

    NewOrigin.Y = (WORD)(max(0,min((SHORT)NewOrigin.Y,
                            (SHORT)ScreenInfo->ScreenBufferSize.Y-(SHORT)CONSOLE_WINDOW_SIZE_Y(ScreenInfo))));
    SetWindowOrigin(ScreenInfo,
                    (BOOLEAN)TRUE,
                    NewOrigin
                   );
}

VOID
HorizontalScroll(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN WORD ScrollCommand,
    IN WORD AbsoluteChange
    )
{
    COORD NewOrigin;

    NewOrigin.X = ScreenInfo->Window.Left;
    NewOrigin.Y = ScreenInfo->Window.Top;
    switch (ScrollCommand) {
        case SB_LINEUP:
            NewOrigin.X--;
            break;
        case SB_LINEDOWN:
            NewOrigin.X++;
            break;
        case SB_PAGEUP:
            NewOrigin.X-=CONSOLE_WINDOW_SIZE_X(ScreenInfo)-1;
            break;
        case SB_PAGEDOWN:
            NewOrigin.X+=CONSOLE_WINDOW_SIZE_X(ScreenInfo)-1;
            break;
        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:
            NewOrigin.X= AbsoluteChange;
            break;
        case SB_TOP:
            NewOrigin.X=0;
            break;
        case SB_BOTTOM:
            NewOrigin.X=(WORD)(ScreenInfo->ScreenBufferSize.X-CONSOLE_WINDOW_SIZE_X(ScreenInfo));
            break;

        default:
            return;
    }

    NewOrigin.X = (WORD)(max(0,min((SHORT)NewOrigin.X,
                            (SHORT)ScreenInfo->ScreenBufferSize.X-(SHORT)CONSOLE_WINDOW_SIZE_X(ScreenInfo))));
    SetWindowOrigin(ScreenInfo,
                    (BOOLEAN)TRUE,
                    NewOrigin
                   );
}

/*
 * If guCaretBlinkTime is -1, we don't want to blink the caret. However, we
 * need to make sure it gets drawn, so we'll set a short timer. When that
 * goes off, we'll hit CursorTimerRoutine, and it'll do the right thing if
 * guCaretBlinkTime is -1.
 */
VOID SetCaretTimer(
    HWND hWnd)
{
    static CONST DWORD dwDefTimeout = 0x212;

    SetTimer(hWnd,
             CURSOR_TIMER,
             guCaretBlinkTime == -1 ? dwDefTimeout : guCaretBlinkTime,
             NULL);
}

LRESULT APIENTRY
ConsoleWindowProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam)
{
    HDC hDC;
    PAINTSTRUCT ps;
    PCONSOLE_INFORMATION Console;
    PSCREEN_INFORMATION ScreenInfo;
    SMALL_RECT PaintRect;
    LRESULT Status = 0;
    BOOL Unlock = TRUE;

    Console = GetWindowConsole(hWnd);
    if (Console != NULL) {
        //
        // Set up our thread so we can impersonate the client
        // while processing the message.
        //

        CSR_SERVER_QUERYCLIENTTHREAD()->ThreadHandle =
                Console->ClientThreadHandle;

        //
        // If the console is terminating, don't bother processing messages
        // other than CM_DESTROY_WINDOW.
        //
        if (Console->Flags & CONSOLE_TERMINATING) {
            LockConsole(Console);
            DestroyWindowsWindow(Console);
            return 0;
        }

        //
        // Make sure the console pointer is still valid
        //
        ASSERT(NT_SUCCESS(ValidateConsole(Console)));

        LockConsole(Console);

        ScreenInfo = Console->CurrentScreenBuffer;
    }
    try {
        if (Console == NULL || ScreenInfo == NULL) {
            switch (Message) {
            case WM_GETMINMAXINFO:
                {
                //
                // createwindow issues a WM_GETMINMAXINFO
                // message before we have the windowlong set up
                // with the console pointer.  we need to allow
                // the created window to be bigger than the
                // default size by the scroll size.
                //

                LPMINMAXINFO lpmmi = (LPMINMAXINFO)lParam;
                lpmmi->ptMaxTrackSize.y += HorizontalScrollSize;
                lpmmi->ptMaxTrackSize.x += VerticalScrollSize;
                }
                break;

            default:
                goto CallDefWin;
            }
        } else if (Message == ProgmanHandleMessage && lParam == 0) {
            //
            // NOTE: lParam will be 0 if progman is sending it and
            // 1 if console is sending it. This is a workaround for
            // a progman bug. progman sends a progmanhandlemessage
            // twice for each window in the system each time one is
            // requested (for one window).
            //
            if ((HWND)wParam != hWnd && Console->bIconInit) {
                ATOM App,Topic;
                CHAR szItem[ITEM_MAX_SIZE+1];
                PCHAR lpItem;
                ATOM aItem;
                HANDLE ConsoleHandle;

                if (!(Console->Flags & CONSOLE_TERMINATING)) {
                    ConsoleHandle = Console->ConsoleHandle;
                    Console->hWndProgMan = (HWND)wParam;
                    UnlockConsole(Console);
                    App = GlobalAddAtomA("Shell");
                    Topic = GlobalAddAtomA("AppIcon");
                    SendMessage(Console->hWndProgMan,
                                WM_DDE_INITIATE,
                                (WPARAM)hWnd,
                                MAKELONG(App, Topic)
                               );

                    // If the console is still valid, continue getting icon.
                    Status = RevalidateConsole(ConsoleHandle, &Console);
                    if (NT_SUCCESS(Status)) {
                        Console->bIconInit = FALSE;
                        lpItem = _itoa((int)Console->iIconId, szItem, 10);
                        aItem = GlobalAddAtomA(lpItem);
                        PostMessage(Console->hWndProgMan,
                                    WM_DDE_REQUEST,
                                    (WPARAM)hWnd,
                                    MAKELONG(CF_TEXT, aItem));
                    }
                }
            }
        } else {
            switch (Message) {
            case WM_DROPFILES:
                DoDrop (wParam,Console);
                break;
            case WM_MOVE:
                if (!IsIconic(hWnd)) {
                    PositionConsoleWindow(Console, (Console->WindowRect.left == CW_USEDEFAULT));
#if defined(FE_IME)
                    if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
                        ConsoleImeResizeModeSystemView(Console,ScreenInfo->Window);
                        ConsoleImeResizeCompStrView(Console,ScreenInfo->Window);
                    }
#endif // FE_IME
                }
                break;
            case WM_SIZE:

                if (wParam != SIZE_MINIMIZED) {

                    //
                    // both SetWindowPos and SetScrollRange cause WM_SIZE
                    // messages to be issued.  ignore them if we have already
                    // figured out what size the window should be.
                    //

                    if (!ScreenInfo->ResizingWindow) {
                        ScreenInfo->WindowMaximized = (wParam == SIZE_MAXIMIZED);

                        if (Console->ResizeFlags & SCREEN_BUFFER_CHANGE) {
                            UpdateWindowSize(Console,ScreenInfo);
                        }
                        PositionConsoleWindow(Console, (Console->WindowRect.left == CW_USEDEFAULT));
#if defined(FE_IME)
                        if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
                            ConsoleImeResizeModeSystemView(Console,ScreenInfo->Window);
                            ConsoleImeResizeCompStrView(Console,ScreenInfo->Window);
                        }
#endif // FE_IME
                        if (Console->ResizeFlags & SCROLL_BAR_CHANGE) {
                            InternalUpdateScrollBars(ScreenInfo);
                            Console->ResizeFlags &= ~SCROLL_BAR_CHANGE;
                        }
                    }
                } else {

                    //
                    // Console is going iconic. Trim working set of all
                    // processes in the console
                    //

                    TrimConsoleWorkingSet(Console);

                }

                break;
            case WM_DDE_ACK:
                if (Console->bIconInit) {
                    Console->hWndProgMan = (HWND)wParam;
                }
                break;
            case WM_DDE_DATA:
                {
                DDEDATA *lpDDEData;
                LPPMICONDATA lpIconData;
                HICON hIcon;
                HANDLE hDdeData;
                BOOL bRelease;
                WPARAM atomTemp;

                UnpackDDElParam(WM_DDE_DATA, lParam, (WPARAM *)&hDdeData, &atomTemp);

                if (hDdeData == NULL) {
                    break;
                }
                lpDDEData = (DDEDATA *)GlobalLock(hDdeData);
                ASSERT(lpDDEData->cfFormat == CF_TEXT);
                lpIconData = (LPPMICONDATA)lpDDEData->Value;
                hIcon = CreateIconFromResourceEx(&lpIconData->iResource,
                        0, TRUE, 0x30000, 0, 0, LR_DEFAULTSIZE);
                if (hIcon) {
                    if (Console->hIcon != NULL && Console->hIcon != ghDefaultIcon) {
                        DestroyIcon(Console->hIcon);
                    }
                    Console->hIcon = hIcon;
                    SendMessage(hWnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon);

                    if (Console->hSmIcon != NULL) {
                        if (Console->hSmIcon != ghDefaultSmIcon) {
                            DestroyIcon(Console->hSmIcon);
                        }
                        Console->hSmIcon = NULL;
                        SendMessage(hWnd, WM_SETICON, ICON_SMALL, (LPARAM)NULL);
                    }
                }

                if (lpDDEData->fAckReq) {

                    PostMessage(Console->hWndProgMan,
                                WM_DDE_ACK,
                                (WPARAM)hWnd,
                                ReuseDDElParam(lParam, WM_DDE_DATA, WM_DDE_ACK, 0x8000, atomTemp));
                }

                bRelease = lpDDEData->fRelease;
                GlobalUnlock(hDdeData);
                if (bRelease){
                    GlobalFree(hDdeData);
                }
                PostMessage(Console->hWndProgMan,
                            WM_DDE_TERMINATE,
                            (WPARAM)hWnd,
                            0
                           );
                if (Console->Flags & CONSOLE_IS_ICONIC) {
                    // force repaint of icon
                    InvalidateRect(hWnd, NULL, TRUE);
                }
                }
                break;
            case WM_ACTIVATE:

                //
                // if we're activated by a mouse click, remember it so
                // we don't pass the click on to the app.
                //

                if (LOWORD(wParam) == WA_CLICKACTIVE) {
                    Console->Flags |= CONSOLE_IGNORE_NEXT_MOUSE_INPUT;
                }
                goto CallDefWin;
                break;
            case WM_DDE_TERMINATE:
                break;
                // FE_IME
            case CM_CONIME_KL_ACTIVATE:
                ActivateKeyboardLayout((HKL)wParam, KLF_SETFORPROCESS);
                break;
            case WM_INPUTLANGCHANGEREQUEST:
                if (CONSOLE_IS_IME_ENABLED()) {
                    ULONG ConimeMessage;
                    LRESULT lResult;

                    if (wParam & INPUTLANGCHANGE_BACKWARD) {
                        ConimeMessage = CONIME_INPUTLANGCHANGEREQUESTBACKWARD;
                    } else if (wParam & INPUTLANGCHANGE_FORWARD) {
                        ConimeMessage = CONIME_INPUTLANGCHANGEREQUESTFORWARD;
                    } else {
                        ConimeMessage = CONIME_INPUTLANGCHANGEREQUEST;
                    }

                    if (!NT_SUCCESS(ConsoleImeMessagePumpWorker(Console,
                                              ConimeMessage,
                                              (WPARAM)Console->ConsoleHandle,
                                              (LPARAM)lParam,
                                              &lResult)) ||
                            !lResult) {

                        break;
                    }
                }
#ifdef LATER
                else if (IS_IME_KBDLAYOUT(lParam)) {
                    // IME keyboard layout should be avoided
                    // if the console is not IME enabled.
                    break;
                }
                // Call the default window proc and let it handle
                // the keyboard layout activation.
#endif
                goto CallDefWin;

                break;
                // end FE_IME

            case WM_INPUTLANGCHANGE:
                Console->hklActive = (HKL)lParam;
                // FE_IME
                if (CONSOLE_IS_IME_ENABLED()) {
                    if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                                          CONIME_INPUTLANGCHANGE,
                                          (WPARAM)Console->ConsoleHandle,
                                          (LPARAM)Console->hklActive
                                         ))) {
                        break;
                    } else{
                        GetImeKeyState(Console, NULL) ;
                    }
                }
                // end FE_IME
                goto CallDefWin;

                break;

            case WM_SETFOCUS:
                ModifyConsoleProcessFocus(Console, TRUE);
                SetConsoleReserveKeys(hWnd, Console->ReserveKeys);
                Console->Flags |= CONSOLE_HAS_FOCUS;

                SetCaretTimer(hWnd);

                HandleFocusEvent(Console, TRUE);
                if (!Console->hklActive) {
                    SystemParametersInfo(SPI_GETDEFAULTINPUTLANG, 0, &Console->hklActive, FALSE);
                    GetNonBiDiKeyboardLayout(&Console->hklActive);
                }
                ActivateKeyboardLayout(Console->hklActive, 0);
                // FE_IME
                if (CONSOLE_IS_IME_ENABLED()) {
                    // v-HirShi Sep.15.1995 Support Console IME
                    if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                                          CONIME_SETFOCUS,
                                          (WPARAM)Console->ConsoleHandle,
                                          (LPARAM)Console->hklActive
                                         ))) {
                        break;
                    }

                    if (Console->InputBuffer.hWndConsoleIME) {
                        /*
                         * Open property window by ImmConfigureIME.
                         * Never set focus on console window
                         * so, set focus to property window.
                         */
                        HWND hwnd = GetLastActivePopup(Console->InputBuffer.hWndConsoleIME);
                        if (hwnd != NULL)
                            SetForegroundWindow(hwnd);
                    }
                }
                // FE_IME
                break;
            case WM_KILLFOCUS:
                ModifyConsoleProcessFocus(Console, FALSE);
                SetConsoleReserveKeys(hWnd, CONSOLE_NOSHORTCUTKEY);
                Console->Flags &= ~CONSOLE_HAS_FOCUS;

                if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
                    ConsoleHideCursor(ScreenInfo);
                    ScreenInfo->BufferInfo.TextInfo.UpdatingScreen -= 1; // counteract HideCursor
                }
                KillTimer(hWnd, CURSOR_TIMER);
                HandleFocusEvent(Console,FALSE);

                // FE_IME
                if (CONSOLE_IS_IME_ENABLED()) {
                    // v-HirShi Sep.16.1995 Support Console IME
                    if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                                          CONIME_KILLFOCUS,
                                          (WPARAM)Console->ConsoleHandle,
                                          (LPARAM)NULL
                                         ))) {
                        break;
                    }
                }
                // end FE_IME
                break;
            case WM_PAINT:

                // ICONIC bit is not set if we're fullscreen and don't
                // have the hardware

                ConsoleHideCursor(ScreenInfo);
                hDC = BeginPaint(hWnd, &ps);
                if (Console->Flags & CONSOLE_IS_ICONIC ||
                    Console->FullScreenFlags == CONSOLE_FULLSCREEN) {
                    RECT rc;
                    UINT cxIcon, cyIcon;
                    GetClientRect(hWnd, &rc);
                    cxIcon = GetSystemMetrics(SM_CXICON);
                    cyIcon = GetSystemMetrics(SM_CYICON);

                    rc.left = (rc.right - cxIcon) >> 1;
                    rc.top = (rc.bottom - cyIcon) >> 1;

                    DrawIcon(hDC, rc.left, rc.top, Console->hIcon);
                } else {
                    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
                        PaintRect.Left = (SHORT)((ps.rcPaint.left/SCR_FONTSIZE(ScreenInfo).X)+ScreenInfo->Window.Left);
                        PaintRect.Right = (SHORT)((ps.rcPaint.right/SCR_FONTSIZE(ScreenInfo).X)+ScreenInfo->Window.Left);
                        PaintRect.Top = (SHORT)((ps.rcPaint.top/SCR_FONTSIZE(ScreenInfo).Y)+ScreenInfo->Window.Top);
                        PaintRect.Bottom = (SHORT)((ps.rcPaint.bottom/SCR_FONTSIZE(ScreenInfo).Y)+ScreenInfo->Window.Top);
                    } else {
                        PaintRect.Left = (SHORT)(ps.rcPaint.left+ScreenInfo->Window.Left);
                        PaintRect.Right = (SHORT)(ps.rcPaint.right+ScreenInfo->Window.Left);
                        PaintRect.Top = (SHORT)(ps.rcPaint.top+ScreenInfo->Window.Top);
                        PaintRect.Bottom = (SHORT)(ps.rcPaint.bottom+ScreenInfo->Window.Top);
                    }
                    ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
                    WriteToScreen(ScreenInfo,&PaintRect);
                }
                EndPaint(hWnd,&ps);
                ConsoleShowCursor(ScreenInfo);
                break;
            case WM_CLOSE:
                if (!(Console->Flags & CONSOLE_NO_WINDOW) ||
                    !(Console->Flags & CONSOLE_WOW_REGISTERED)) {
                    HandleCtrlEvent(Console,CTRL_CLOSE_EVENT);
                }
                break;
            case WM_ERASEBKGND:

                // ICONIC bit is not set if we're fullscreen and don't
                // have the hardware

                if (Console->Flags & CONSOLE_IS_ICONIC ||
                    Console->FullScreenFlags == CONSOLE_FULLSCREEN) {
                    Message = WM_ICONERASEBKGND;
                    goto CallDefWin;
                }
                break;

            case WM_SETTINGCHANGE:
                {
                    DWORD dwCaretBlinkTime = GetCaretBlinkTime();

                    if (dwCaretBlinkTime != guCaretBlinkTime) {
                        KillTimer(hWnd, CURSOR_TIMER);
                        guCaretBlinkTime = dwCaretBlinkTime;
                        SetCaretTimer(hWnd);
                    }
                }
                /* Fall through */

            case WM_DISPLAYCHANGE:
                gfInitSystemMetrics = TRUE;

                break;

            case WM_SETCURSOR:
                if (lParam == -1) {

                    //
                    // the app changed the cursor visibility or shape.
                    // see if the cursor is in the client area.
                    //

                    POINT Point;
                    HWND hWndTmp;
                    GetCursorPos(&Point);
                    hWndTmp = WindowFromPoint(Point);
                    if (hWndTmp == hWnd) {
                        lParam = DefWindowProc(hWnd,WM_NCHITTEST,0,MAKELONG((WORD)Point.x, (WORD)Point.y));
                    }
                }
                if ((WORD)lParam == HTCLIENT) {
                    if (ScreenInfo->CursorDisplayCount < 0) {
                        SetCursor(NULL);
                    } else {
                        SetCursor(ScreenInfo->CursorHandle);
                    }
                } else {
                    goto CallDefWin;
                }
                break;
            case WM_GETMINMAXINFO:
                {
                LPMINMAXINFO lpmmi = (LPMINMAXINFO)lParam;
                COORD FontSize;
                WINDOW_LIMITS WindowLimits;

                GetWindowLimits(ScreenInfo, &WindowLimits);
                if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
                    FontSize = SCR_FONTSIZE(ScreenInfo);
                } else {
                    FontSize.X = 1;
                    FontSize.Y = 1;
                }
                lpmmi->ptMaxSize.x = lpmmi->ptMaxTrackSize.x = WindowLimits.MaxWindow.X;
                if (!ScreenInfo->WindowMaximizedY) {
                    lpmmi->ptMaxTrackSize.x += VerticalScrollSize;
                    lpmmi->ptMaxSize.x += VerticalScrollSize;
                }
                while (lpmmi->ptMaxSize.x > WindowLimits.FullScreenSize.X + VerticalClientToWindow) {
                    lpmmi->ptMaxSize.x -= FontSize.X;
                }
                lpmmi->ptMaxSize.y = lpmmi->ptMaxTrackSize.y = WindowLimits.MaxWindow.Y;
                if (!ScreenInfo->WindowMaximizedX) {
                    lpmmi->ptMaxTrackSize.y += HorizontalScrollSize;
                    lpmmi->ptMaxSize.y += HorizontalScrollSize;
                }
                while (lpmmi->ptMaxSize.y > WindowLimits.FullScreenSize.Y + HorizontalClientToWindow) {
                    lpmmi->ptMaxSize.y -= FontSize.Y;
                }
                lpmmi->ptMinTrackSize.x = WindowLimits.MinimumWindowSize.X * FontSize.X + VerticalClientToWindow;
                lpmmi->ptMinTrackSize.y = HorizontalClientToWindow;
                }
                break;
            case WM_QUERYDRAGICON:
                Status = (LRESULT)Console->hIcon;
                break;
            case WM_WINDOWPOSCHANGING:
                {
                    LPWINDOWPOS WindowPos = (LPWINDOWPOS)lParam;
                    DWORD fMinimized;

                    /*
                     * This message is sent before a SetWindowPos() operation
                     * occurs. We use it here to set/clear the CONSOLE_IS_ICONIC
                     * bit appropriately... doing so in the WM_SIZE handler
                     * is incorrect because the WM_SIZE comes after the
                     * WM_ERASEBKGND during SetWindowPos() processing, and the
                     * WM_ERASEBKGND needs to know if the console window is
                     * iconic or not.
                     */
                    fMinimized = IsIconic(hWnd);
                    if (fMinimized) {
                        if (!(Console->Flags & CONSOLE_IS_ICONIC)) {
                            Console->Flags |= CONSOLE_IS_ICONIC;

                            //
                            // If the palette is something other than default,
                            // select the default palette in. Otherwise, the
                            // screen will repaint twice each time the icon
                            // is painted.
                            //

                            if (ScreenInfo->hPalette != NULL &&
                                Console->FullScreenFlags == 0) {
                                SelectPalette(Console->hDC,
                                              Console->hSysPalette,
                                              FALSE);
                                UnsetActivePalette(ScreenInfo);
                            }
                        }
                    } else {
                        if (Console->Flags & CONSOLE_IS_ICONIC) {
                            Console->Flags &= ~CONSOLE_IS_ICONIC;

                            //
                            // If the palette is something other than default,
                            // select the default palette in. Otherwise, the
                            // screen will repaint twice each time the icon
                            // is painted.
                            //

                            if (ScreenInfo->hPalette != NULL &&
                                Console->FullScreenFlags == 0) {
                                SelectPalette(Console->hDC,
                                              ScreenInfo->hPalette,
                                              FALSE);
                                SetActivePalette(ScreenInfo);
                            }
                        }
                    }
                    if (!ScreenInfo->ResizingWindow &&
                        (WindowPos->cx || WindowPos->cy) &&
                        !fMinimized) {
                        ProcessResizeWindow(ScreenInfo,Console,WindowPos);
                    }
                }
                break;
            case WM_CONTEXTMENU:
                if (DefWindowProc(hWnd, WM_NCHITTEST, 0, lParam) == HTCLIENT) {
                    TrackPopupMenuEx(Console->hHeirMenu,
                                     TPM_RIGHTBUTTON,
                                     GET_X_LPARAM(lParam),
                                     GET_Y_LPARAM(lParam),
                                     hWnd,
                                     NULL);
                } else {
                    goto CallDefWin;
                }
                break;
            case WM_NCLBUTTONDOWN:
                // allow user to move window even when bigger than the screen
                switch (wParam & 0x00FF) {
                    case HTCAPTION:
                        UnlockConsole(Console);
                        Unlock = FALSE;
                        SetActiveWindow(hWnd);
                        SendMessage(hWnd, WM_SYSCOMMAND,
                                       SC_MOVE | wParam, lParam);
                        break;
                    default:
                        goto CallDefWin;
                }
                break;
#if defined (FE_IME)
// Sep.16.1995 Support Console IME
            case WM_KEYDOWN    +CONIME_KEYDATA:
            case WM_KEYUP      +CONIME_KEYDATA:
            case WM_CHAR       +CONIME_KEYDATA:
            case WM_DEADCHAR   +CONIME_KEYDATA:

            case WM_SYSKEYDOWN +CONIME_KEYDATA:
            case WM_SYSKEYUP   +CONIME_KEYDATA:
            case WM_SYSCHAR    +CONIME_KEYDATA:
            case WM_SYSDEADCHAR+CONIME_KEYDATA:
#endif
            case WM_KEYDOWN:
            case WM_KEYUP:
            case WM_CHAR:
            case WM_DEADCHAR:
                HandleKeyEvent(Console,hWnd,Message,wParam,lParam);
                break;
            case WM_SYSKEYDOWN:
            case WM_SYSKEYUP:
            case WM_SYSCHAR:
            case WM_SYSDEADCHAR:
                if (HandleSysKeyEvent(Console, hWnd, Message, wParam, lParam, &Unlock)) {
                    goto CallDefWin;
                }
                break;
            case WM_COMMAND:
                //
                // If this is an edit command from the context menu, treat
                // it like a sys command.
                //
                if ((wParam < cmCopy) || (wParam > cmSelectAll)) {
                    break;
                }
                // FALL THRU
            case WM_SYSCOMMAND:
                if (wParam >= ScreenInfo->CommandIdLow &&
                    wParam <= ScreenInfo->CommandIdHigh) {
                    HandleMenuEvent(Console, (DWORD)wParam);
                } else if (wParam == cmMark) {
                    DoMark(Console);
                } else if (wParam == cmCopy) {
                    DoCopy(Console);
                } else if (wParam == cmPaste) {
                    DoPaste(Console);
                } else if (wParam == cmScroll) {
                    DoScroll(Console);
                } else if (wParam == cmFind) {
                    DoFind(Console);
                } else if (wParam == cmSelectAll) {
                    DoSelectAll(Console);
                } else if (wParam == cmControl) {
                    PropertiesDlgShow(Console, TRUE);
                } else if (wParam == cmDefaults) {
                    PropertiesDlgShow(Console, FALSE);
                } else if ((wParam == SC_RESTORE || wParam == SC_MAXIMIZE) &&
                           Console->Flags & CONSOLE_VDM_HIDDEN_WINDOW) {
                    Console->Flags &= ~CONSOLE_VDM_HIDDEN_WINDOW;
                    SendMessage(Console->hWnd, CM_MODE_TRANSITION, FULLSCREEN, 0L);
                } else {
                    goto CallDefWin;
                }
                break;
            case WM_TIMER:
#if defined(FE_IME)
                if (wParam == SCROLL_WAIT_TIMER) {
                    ASSERT(CONSOLE_IS_IME_ENABLED());
                    if ((ScreenInfo->Console->ConsoleIme.ScrollFlag & (HIDE_FOR_SCROLL)) &&
                        (ScreenInfo->Console->ConsoleIme.ScrollWaitCountDown > 0)
                       ) {
                        if ((ScreenInfo->Console->ConsoleIme.ScrollWaitCountDown -= guCaretBlinkTime) <= 0) {
                            ConsoleImeBottomLineInUse(ScreenInfo);
                        }
                    }
                    break;
                }
#endif
                CursorTimerRoutine(ScreenInfo);
                ScrollIfNecessary(Console, ScreenInfo);
                break;
            case WM_HSCROLL:
                HorizontalScroll(ScreenInfo, LOWORD(wParam), HIWORD(wParam));
                break;
            case WM_VSCROLL:
                VerticalScroll(Console, ScreenInfo, LOWORD(wParam), HIWORD(wParam));
                break;
            case WM_INITMENU:
                HandleMenuEvent(Console, WM_INITMENU);
                InitializeMenu(Console);
                break;
            case WM_MENUSELECT:
                if (HIWORD(wParam) == 0xffff) {
                    HandleMenuEvent(Console, WM_MENUSELECT);
                }
                break;
            case WM_MOUSEMOVE:
            case WM_LBUTTONDOWN:
            case WM_LBUTTONUP:
            case WM_LBUTTONDBLCLK:
            case WM_RBUTTONDOWN:
            case WM_RBUTTONUP:
            case WM_RBUTTONDBLCLK:
            case WM_MBUTTONDOWN:
            case WM_MBUTTONUP:
            case WM_MBUTTONDBLCLK:
            case WM_MOUSEWHEEL:
                if (HandleMouseEvent(Console, ScreenInfo, Message, wParam, lParam)) {
                    if (Message != WM_MOUSEWHEEL) {
                        goto CallDefWin;
                    }
                } else {
                    break;
                }

                /*
                 * Don't handle zoom.
                 */
                if (wParam & MK_CONTROL) {
                    goto CallDefWin;
                }

                Status = 1;
                if (gfInitSystemMetrics) {
                    InitializeSystemMetrics();
                }

                ScreenInfo->WheelDelta -= (short)HIWORD(wParam);
                if (abs(ScreenInfo->WheelDelta) >= WHEEL_DELTA &&
                        gucWheelScrollLines > 0) {

                    COORD   NewOrigin;
                    SHORT   dy;

                    NewOrigin.X = ScreenInfo->Window.Left;
                    NewOrigin.Y = ScreenInfo->Window.Top;

                    /*
                     * Limit a roll of one (1) WHEEL_DELTA to scroll one (1)
                     * page. If in shift scroll mode then scroll one page at
                     * a time regardless.
                     */

                    if (!(wParam & MK_SHIFT)) {
                        dy = (int) min(
                                (UINT) CONSOLE_WINDOW_SIZE_Y(ScreenInfo) - 1,
                                gucWheelScrollLines);
                    } else {
                        dy = CONSOLE_WINDOW_SIZE_Y(ScreenInfo) - 1;
                    }

                    if (dy == 0) {
                        dy++;
                    }

                    dy *= (ScreenInfo->WheelDelta / WHEEL_DELTA);
                    ScreenInfo->WheelDelta %= WHEEL_DELTA;

                    NewOrigin.Y += dy;
                    if (NewOrigin.Y < 0) {
                        NewOrigin.Y = 0;
                    } else if (NewOrigin.Y + CONSOLE_WINDOW_SIZE_Y(ScreenInfo) >
                            ScreenInfo->ScreenBufferSize.Y) {
                        NewOrigin.Y = ScreenInfo->ScreenBufferSize.Y -
                                CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
                    }

                    SetWindowOrigin(ScreenInfo, TRUE, NewOrigin);
                }
                break;

            case WM_PALETTECHANGED:
                if (Console->FullScreenFlags == 0) {
                    if (ScreenInfo->hPalette != NULL) {
                        SetActivePalette(ScreenInfo);
                        if (ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER) {
                            WriteRegionToScreenBitMap(ScreenInfo,
                                                      &ScreenInfo->Window);
                        }
                    } else {
                        SetScreenColors(ScreenInfo, ScreenInfo->Attributes,
                                        ScreenInfo->PopupAttributes, TRUE);
                    }
                }
                break;
#if defined(_X86_)
            case WM_FULLSCREEN:

                //
                // This message is sent by the system to tell console that
                // the fullscreen state of a window has changed.
                // In some cases, this message will be sent in response to
                // a call from console to change to fullscreen (Atl-Enter)
                // or may also come directly from the system (switch of
                // focus from a windowed app to a fullscreen app).
                //

                RIPMSG0(RIP_WARNING, "WindowProc - WM_FULLSCREEN");

                Status = DisplayModeTransition(wParam,Console,ScreenInfo);
#if defined(FE_IME)
                if (NT_SUCCESS(Status)) {
                    Status = ImeWmFullScreen(wParam,Console,ScreenInfo);
                }
#endif // FE_IME
                break;
#endif
            case CM_SET_WINDOW_SIZE:
                if (lParam == 0x47474747) {
                    Status = InternalSetWindowSize(Console,
                                                   (PSCREEN_INFORMATION)wParam,
                                                   &ScreenInfo->Window
                                                   );
                }
                break;
            case CM_BEEP:
                if (lParam == 0x47474747) {
                    Beep(800, 200);
                }
                break;
            case CM_UPDATE_SCROLL_BARS:
                InternalUpdateScrollBars(ScreenInfo);
                break;
            case CM_UPDATE_TITLE:
                SetWindowText(hWnd, Console->Title);
                break;
            case CM_CONSOLE_MSG:
                if (!UnqueueConsoleMessage(Console, &Message, &wParam, &lParam)) {
                    break;
                }
                switch (Message) {

#if defined(_X86_)
                case CM_MODE_TRANSITION:

                    RIPMSG0(RIP_WARNING, "WindowProc - CM_MODE_TRANSITION");

                    if (wParam == FULLSCREEN) {
                        if (Console->FullScreenFlags == 0) {
                            ConvertToFullScreen(Console);
                            Console->FullScreenFlags |= CONSOLE_FULLSCREEN;
                            ChangeDispSettings(Console, hWnd, CDS_FULLSCREEN);
                        }
                    } else {
                        if (Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
                            ConvertToWindowed(Console);
                            Console->FullScreenFlags &= ~CONSOLE_FULLSCREEN;
                            ChangeDispSettings(Console, hWnd, 0);

                            ShowWindow(hWnd, SW_RESTORE);
                        }
                    }

                    UnlockConsole(Console);
                    Unlock = FALSE;

                    NtSetEvent((HANDLE)lParam, NULL);
                    NtClose((HANDLE)lParam);
                    break;
#endif
#if defined (FE_IME)
                case CM_SET_IME_CODEPAGE: {
                    if (!LOWORD(lParam)) {
                        // Input code page
                        Status = SetImeCodePage(Console);
                    } else {
                        // Output code page
                        Status = SetImeOutputCodePage(Console, ScreenInfo, HIWORD(lParam));
                    }

                    if (wParam) {
                        NtSetEvent((HANDLE)wParam, NULL);
                        NtClose((HANDLE)wParam);
                    }
                    break;
                }
                case CM_SET_NLSMODE:
                    Status = SetImeKeyState(Console, ImmConversionFromConsole((DWORD)lParam));
                    if (wParam) {
                        NtSetEvent((HANDLE)wParam, NULL);
                        NtClose((HANDLE)wParam);
                    }
                    break;
                case CM_GET_NLSMODE:
                    if (Console->InputThreadInfo->hWndConsoleIME) {
                        ASSERT(CONSOLE_IS_IME_ENABLED());

                        if (!NT_SUCCESS(GetImeKeyState(Console, NULL))) {
                            if (wParam) {
                                NtSetEvent((HANDLE)wParam, NULL);
                                NtClose((HANDLE)wParam);
                            }
                            break;
                        }
                        if (wParam) {
                            NtSetEvent((HANDLE)wParam, NULL);
                            NtClose((HANDLE)wParam);
                        }
                    } else if (lParam < 10) {
                        /*
                         * try get conversion mode until ready ConIME.
                         */
                        Status = QueueConsoleMessage(Console,
                                    CM_GET_NLSMODE,
                                    wParam,
                                    lParam+1
                                   );
                        if (!NT_SUCCESS(Status)) {
                            if (wParam) {
                                NtSetEvent((HANDLE)wParam, NULL);
                                NtClose((HANDLE)wParam);
                            }
                        }
                    } else {
                        if (wParam) {
                            NtSetEvent((HANDLE)wParam, NULL);
                            NtClose((HANDLE)wParam);
                        }
                    }
                    break;
#endif // FE_IME
                case EVENT_CONSOLE_CARET:
                case EVENT_CONSOLE_UPDATE_REGION:
                case EVENT_CONSOLE_UPDATE_SIMPLE:
                case EVENT_CONSOLE_UPDATE_SCROLL:
                case EVENT_CONSOLE_LAYOUT:
                case EVENT_CONSOLE_START_APPLICATION:
                case EVENT_CONSOLE_END_APPLICATION:
                    NotifyWinEvent(Message, hWnd, (LONG)wParam, (LONG)lParam);
                    break;
                default:
                    RIPMSG1(RIP_WARNING, "Unknown console message 0x%x", Message);
                    break;
                }
                break;

#if defined(_X86_)
            case CM_MODE_TRANSITION:
                /*
                 * This is called by win32k.sys to request a display mode
                 * transition.
                 */


                RIPMSG0(RIP_WARNING, "WindowProc - CM_MODE_TRANSITION");
                if (wParam == FULLSCREEN) {
                    if (Console->FullScreenFlags == 0) {
                        ConvertToFullScreen(Console);
                        Console->FullScreenFlags |= CONSOLE_FULLSCREEN;
                        ChangeDispSettings(Console, hWnd, CDS_FULLSCREEN);
                    }
                } else {
                    if (Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
                        ConvertToWindowed(Console);
                        Console->FullScreenFlags &= ~CONSOLE_FULLSCREEN;
                        ChangeDispSettings(Console, hWnd, 0);

                        ShowWindow(hWnd, SW_RESTORE);
                    }
                }

                UnlockConsole(Console);
                Unlock = FALSE;

                break;
#endif // _X86_

            case CM_HIDE_WINDOW:
                ShowWindowAsync(hWnd, SW_MINIMIZE);
                break;
            case CM_PROPERTIES_START:
                Console->hWndProperties = (HWND)wParam;
                break;
            case CM_PROPERTIES_UPDATE:
                PropertiesUpdate(Console, (HANDLE)wParam);
                break;
            case CM_PROPERTIES_END:
                Console->hWndProperties = NULL;
                break;
#if defined(FE_IME)
            case WM_COPYDATA:
                if (CONSOLE_IS_IME_ENABLED() && CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
                    Status = ImeControl(Console,(HWND)wParam,(PCOPYDATASTRUCT)lParam);
                }
                break;
// v-HirShi Sep.18.1995 Support Console IME
            case WM_ENTERMENULOOP:
                if (Console->Flags & CONSOLE_HAS_FOCUS) {
                    Console->InputBuffer.ImeMode.Unavailable = TRUE;
                    if (CONSOLE_IS_IME_ENABLED()) {
                        if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                                              CONIME_KILLFOCUS,
                                              (WPARAM)Console->ConsoleHandle,
                                              (LPARAM)NULL
                                             ))) {
                            break;
                        }
                    }
                }
                break;

            case WM_EXITMENULOOP:
                if (Console->Flags & CONSOLE_HAS_FOCUS) {
                    if (CONSOLE_IS_IME_ENABLED()) {
                        if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                                              CONIME_SETFOCUS,
                                              (WPARAM)Console->ConsoleHandle,
                                              (LPARAM)Console->hklActive
                                             ))) {
                            break;
                        }
                    }
                    Console->InputBuffer.ImeMode.Unavailable = FALSE;
                }
                break;

            case WM_ENTERSIZEMOVE:
                if (Console->Flags & CONSOLE_HAS_FOCUS) {
                    Console->InputBuffer.ImeMode.Unavailable = TRUE;
                }
                break;

            case WM_EXITSIZEMOVE:
                if (Console->Flags & CONSOLE_HAS_FOCUS) {
                    Console->InputBuffer.ImeMode.Unavailable = FALSE;
                }
                break;
#endif // FE_IME

CallDefWin:
            default:
                if (Unlock && Console != NULL) {
                    UnlockConsole(Console);
                    Unlock = FALSE;
                }
                Status = DefWindowProc(hWnd,Message,wParam,lParam);
                break;
            }
        }
    } finally {
        if (Unlock && Console != NULL) {
            UnlockConsole(Console);
        }
    }

    return Status;
}


/*
* Drag and Drop support functions for console window
*/

/*++

Routine Description:

    This routine retrieves the filenames of dropped files. It was copied from
    shelldll API DragQueryFile. We didn't use DragQueryFile () because we don't
    want to load Shell32.dll in CSR

Arguments:
    Same as DragQueryFile

Return Value:


--*/
UINT ConsoleDragQueryFile(
    IN HANDLE hDrop,
    IN PVOID lpFile,
    IN UINT cb)
{
    UINT i = 0;
    LPDROPFILESTRUCT lpdfs;
    BOOL fWide;

    lpdfs = (LPDROPFILESTRUCT)GlobalLock(hDrop);

    if (lpdfs && lpdfs != hDrop) {
        try {
            fWide = (LOWORD(lpdfs->pFiles) == sizeof(DROPFILES));
            if (fWide) {
                //
                // This is a new (NT-compatible) HDROP
                //
                fWide = lpdfs->fWide;       // Redetermine fWide from struct
                                            // since it is present.
            }

            if (fWide) {
                LPWSTR lpList;

                //
                // UNICODE HDROP
                //

                lpList = (LPWSTR)((LPBYTE)lpdfs + lpdfs->pFiles);

                i = lstrlenW(lpList);

                if (!i)
                    goto Exit;

                cb--;
                if (cb < i)
                    i = cb;

                lstrcpynW((LPWSTR)lpFile, lpList, i + 1);
            } else {
                LPSTR lpList;

                //
                // This is Win31-style HDROP or an ANSI NT Style HDROP
                //
                lpList = (LPSTR)((LPBYTE)lpdfs + lpdfs->pFiles);

                i = lstrlenA(lpList);

                if (!i) {
                    goto Exit;
                }

                cb--;
                if (cb < i) {
                    i = cb;
                }

                MultiByteToWideChar(CP_ACP, 0, lpList, -1, (LPWSTR)lpFile, cb);

            }
        } except( EXCEPTION_EXECUTE_HANDLER ) {
           RIPMSG1(RIP_WARNING, "CONSRV: WM_DROPFILES raised exception 0x%x", GetExceptionCode());
           i = 0;
        }
Exit:
        GlobalUnlock(hDrop);
        GlobalFree(hDrop);
    }

    return i;
}


/*++

Routine Description:

    This routine is called when ConsoleWindowProc receives a WM_DROPFILES
    message. It initially calls ConsoleDragQueryFile() to calculate the number
    of files dropped and then ConsoleDragQueryFile() is called
    to retrieve the filename. DoStringPaste() pastes the filename to the console
    window

Arguments:
    wParam  -   Identifies the structure containing the filenames of the
                dropped files.
    Console -   Pointer to CONSOLE_INFORMATION structure


Return Value:
    None


--*/
VOID
DoDrop(
    WPARAM wParam,
    PCONSOLE_INFORMATION Console)
{
    WCHAR szPath[MAX_PATH];
    BOOL fAddQuotes;

    if (ConsoleDragQueryFile((HANDLE)wParam, szPath, ARRAY_SIZE(szPath))) {
        fAddQuotes = (wcschr(szPath, L' ') != NULL);
        if (fAddQuotes) {
            DoStringPaste(Console, L"\"", 1);
        }
        DoStringPaste(Console, szPath, wcslen(szPath));
        if (fAddQuotes) {
            DoStringPaste(Console, L"\"", 1);
        }
    }
}

BOOL
CreateDbcsScreenBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN COORD dwScreenBufferSize,
    OUT PDBCS_SCREEN_BUFFER DbcsScreenBuffer)
{
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
        DbcsScreenBuffer->TransBufferCharacter =
            ConsoleHeapAlloc(SCREEN_DBCS_TAG,
                             (dwScreenBufferSize.X * dwScreenBufferSize.Y * sizeof(WCHAR)) + sizeof(WCHAR));
        if (DbcsScreenBuffer->TransBufferCharacter == NULL) {
            return FALSE;
        }

        DbcsScreenBuffer->TransBufferAttribute =
            ConsoleHeapAlloc(SCREEN_DBCS_TAG,
                             (dwScreenBufferSize.X * dwScreenBufferSize.Y * sizeof(BYTE)) + sizeof(BYTE));
        if (DbcsScreenBuffer->TransBufferAttribute == NULL) {
            ConsoleHeapFree(DbcsScreenBuffer->TransBufferCharacter);
            return FALSE;
        }

        DbcsScreenBuffer->TransWriteConsole =
            ConsoleHeapAlloc(SCREEN_DBCS_TAG,
                             (dwScreenBufferSize.X * dwScreenBufferSize.Y * sizeof(WCHAR)) + sizeof(WCHAR));
        if (DbcsScreenBuffer->TransWriteConsole == NULL) {
            ConsoleHeapFree(DbcsScreenBuffer->TransBufferAttribute);
            ConsoleHeapFree(DbcsScreenBuffer->TransBufferCharacter);
            return FALSE;
        }

        DbcsScreenBuffer->KAttrRows =
            ConsoleHeapAlloc(SCREEN_DBCS_TAG,
                             dwScreenBufferSize.X * dwScreenBufferSize.Y * sizeof(BYTE));
        if (DbcsScreenBuffer->KAttrRows == NULL) {
            ConsoleHeapFree(DbcsScreenBuffer->TransWriteConsole);
            ConsoleHeapFree(DbcsScreenBuffer->TransBufferAttribute);
            ConsoleHeapFree(DbcsScreenBuffer->TransBufferCharacter);
            return FALSE;
        }
    } else {
        DbcsScreenBuffer->TransBufferCharacter = NULL;
        DbcsScreenBuffer->TransBufferAttribute = NULL;
        DbcsScreenBuffer->TransWriteConsole = NULL;
        DbcsScreenBuffer->KAttrRows = NULL;
    }

    return TRUE;
}

BOOL
DeleteDbcsScreenBuffer(
    IN PDBCS_SCREEN_BUFFER DbcsScreenBuffer
    )
{
    if (DbcsScreenBuffer->KAttrRows) {
        ConsoleHeapFree(DbcsScreenBuffer->TransBufferCharacter);
        ConsoleHeapFree(DbcsScreenBuffer->TransBufferAttribute);
        ConsoleHeapFree(DbcsScreenBuffer->TransWriteConsole);
        ConsoleHeapFree(DbcsScreenBuffer->KAttrRows);
    }

    return TRUE;
}

BOOL
ReCreateDbcsScreenBufferWorker(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    SHORT i;
    PBYTE KAttrRowPtr;
    COORD dwScreenBufferSize;
    DBCS_SCREEN_BUFFER NewDbcsScreenBuffer;

    ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
    if (!(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)) {
        return FALSE;
    }

    dwScreenBufferSize = ScreenInfo->ScreenBufferSize;

    if (!CreateDbcsScreenBuffer(Console,
            dwScreenBufferSize,
            &NewDbcsScreenBuffer)) {
        return FALSE;
    }

    KAttrRowPtr = NewDbcsScreenBuffer.KAttrRows;
    for (i = 0; i < dwScreenBufferSize.Y; i++) {
        ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.KAttrs = KAttrRowPtr;
        if (KAttrRowPtr) {
            RtlZeroMemory(KAttrRowPtr, dwScreenBufferSize.X);
            KAttrRowPtr += dwScreenBufferSize.X;
        }
    }
    ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer = NewDbcsScreenBuffer;

    return TRUE;
}


typedef struct _DBCS_SCREEN_BUFFER_TRACKER {
    DBCS_SCREEN_BUFFER data;
#if DBG
    PSCREEN_INFORMATION pScreenInfo;
#endif
} DBCS_SCREEN_BUFFER_TRACKER, *PDBCS_SCREEN_BUFFER_TRACKER;

BOOL
ReCreateDbcsScreenBuffer(
    IN PCONSOLE_INFORMATION pConsole,
    IN UINT OldCodePage)
{
    BOOL fResult = FALSE;
    PDBCS_SCREEN_BUFFER_TRACKER pDbcsScreenBuffer;
    PSCREEN_INFORMATION pScreenInfo;
    UINT nScreen;
    UINT i;
#if DBG
    UINT nScreenSave;
#endif

    //
    // If DbcsBuffers don't need to be modified, just bail out.
    //
    if (!IsAvailableFarEastCodePage(OldCodePage) == !CONSOLE_IS_DBCS_OUTPUTCP(pConsole) )
        return TRUE;

    //
    // Count the number of screens allocated.
    //
    for (nScreen = 0, pScreenInfo = pConsole->ScreenBuffers; pScreenInfo; pScreenInfo = pScreenInfo->Next) {
        //
        // Ignore graphic mode buffer.
        //
        if (pScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
            ++nScreen;
        }
    }
#if DBG
    nScreenSave = nScreen;
#endif

    //
    // Allocate the temporary buffer to store the old values
    //
    pDbcsScreenBuffer = ConsoleHeapAlloc(TMP_DBCS_TAG, sizeof(*pDbcsScreenBuffer) * nScreen);
    if (pDbcsScreenBuffer == NULL) {
        RIPMSG0(RIP_WARNING, "ReCreateDbcsScreenBuffer: not enough memory.");
        return FALSE;
    }

    //
    // Try to allocate or de-allocate the necessary DBCS buffers
    //
    for (nScreen = 0, pScreenInfo = pConsole->ScreenBuffers; pScreenInfo; pScreenInfo = pScreenInfo->Next) {
        ASSERT(nScreen < nScreenSave);  // make sure ScreenBuffers are not changed

        //
        // We only handle the text mode screen buffer.
        //
        if (pScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
            //
            // Save the previous value just in case something goes bad.
            //
#if DBG
            pDbcsScreenBuffer[nScreen].pScreenInfo = pScreenInfo;
#endif
            pDbcsScreenBuffer[nScreen++].data = pScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer;

            if (!ReCreateDbcsScreenBufferWorker(pConsole, pScreenInfo)) {
                //
                // If we fail to ReCreate the DbcsScreenBuffer,
                // free all allocation to this point, and restore the orginal.
                //
                RIPMSG0(RIP_WARNING, "ReCreateDbcsScreenBuffer: failed to recreate dbcs screen buffer.");

                for (i = 0, pScreenInfo = pConsole->ScreenBuffers; i < nScreen;  pScreenInfo = pScreenInfo->Next) {
                    ASSERT(pScreenInfo);

                    if (pScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
                        ASSERT(pDbcsScreenBuffer[i].pScreenInfo == pScreenInfo);
                        if (i < nScreen - 1) {
                            ASSERT(pScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.KAttrRows != pDbcsScreenBuffer[i].data.KAttrRows);
                            DeleteDbcsScreenBuffer(&pScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer);
                        }

                        pScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer = pDbcsScreenBuffer[i++].data;
                    }
                }
                goto exit;
            }
        }
    }

    //
    // All allocation succeeded. Now we can delete the old allocation.
    //
    for (i = 0; i < nScreen; ++i) {
        DeleteDbcsScreenBuffer(&pDbcsScreenBuffer[i].data);
    }

    fResult = TRUE;

exit:
    ConsoleHeapFree(pDbcsScreenBuffer);

    return fResult;
}

// Checks if the primary language of this keyborad layout is BiDi or not.
BOOL
IsNotBiDILayout(
    HKL hkl)
{
    BOOL bRet = TRUE;
    LANGID LangID = PRIMARYLANGID(HandleToUlong(hkl));

    if (LangID == LANG_ARABIC || LangID == LANG_HEBREW) {
        bRet = FALSE;
    }

    return bRet;
}

VOID
GetNonBiDiKeyboardLayout(
    HKL *phklActive)
{
    HKL hkl = *phklActive;
    HKL hklActive = *phklActive;

    if (IsNotBiDILayout(hkl)) {
        return;
    }

    // Start with the default one.
    ActivateKeyboardLayout(hkl, 0);
    // We know that the default is not good, activate the next.
    ActivateKeyboardLayout((HKL)HKL_NEXT, 0);

    // Loop until you find a none BiDi one or endof list.
    while (hkl = GetKeyboardLayout(0)) {
        if ((hkl == hklActive) || IsNotBiDILayout(hkl)) {
            *phklActive = hkl;
            break;
        }
        ActivateKeyboardLayout((HKL)HKL_NEXT, 0);
    }
}

#if defined(FE_SB)

#define WWSB_NOFE
#include "_output.h"
#undef  WWSB_NOFE
#define WWSB_FE
#include "_output.h"
#undef  WWSB_FE

#endif  // FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\stream.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    stream.h

Abstract:

        This file implements the NT console direct I/O API

Author:

    KazuM Apr.20.1996

Revision History:

--*/


typedef struct _RAW_READ_DATA {
    PINPUT_INFORMATION InputInfo;
    PCONSOLE_INFORMATION Console;
    ULONG BufferSize;
    PWCHAR BufPtr;
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    HANDLE HandleIndex;
} RAW_READ_DATA, *PRAW_READ_DATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\stream.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    stream.c

Abstract:

        This file implements the NT console server stream API

Author:

    Therese Stowell (thereses) 6-Nov-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define IS_CONTROL_CHAR(wch)  ((wch) < L' ')
#define IS_GLYPH_CHAR(wch)   (((wch) < L' ') || ((wch) == 0x007F))

#define LINE_INPUT_BUFFER_SIZE (256 * sizeof(WCHAR))

HANDLE
FindActiveScreenBufferHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN PCONSOLE_INFORMATION Console
    )
{
    ULONG i;
    HANDLE ActiveScreenHandle;
    PHANDLE_DATA ActiveScreenHandleData;
    NTSTATUS Status;

    ActiveScreenHandle = INVALID_HANDLE_VALUE;
    for (i=0;i<ProcessData->HandleTableSize;i++) {
        Status = DereferenceIoHandleNoCheck(ProcessData,
                                     LongToHandle(i),
                                     &ActiveScreenHandleData
                                    );
        if (NT_SUCCESS(Status) &&
            Console->CurrentScreenBuffer == ActiveScreenHandleData->Buffer.ScreenBuffer) {
            ASSERT (ActiveScreenHandleData->HandleType & (CONSOLE_OUTPUT_HANDLE | CONSOLE_GRAPHICS_OUTPUT_HANDLE));
            ActiveScreenHandle = LongToHandle(i);
            break;
        }
    }
    return ActiveScreenHandle;
}

ULONG
SrvOpenConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine returns a handle to the input buffer or active screen buffer.

Arguments:

    ApiMessageData - Points to parameter structure.

Return Value:

--*/

{
    PCONSOLE_OPENCONSOLE_MSG a = (PCONSOLE_OPENCONSOLE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    HANDLE Handle;
    PHANDLE_DATA HandleData;
    PCONSOLE_PER_PROCESS_DATA ProcessData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    try {
        Handle = INVALID_HANDLE_VALUE;
        ProcessData = CONSOLE_PERPROCESSDATA();
        if (a->HandleType == CONSOLE_INPUT_HANDLE) {

            Status = AllocateIoHandle(ProcessData,
                                      a->HandleType,
                                      &Handle
                                     );
            if (!NT_SUCCESS(Status)) {
                leave;
            }
            Status = DereferenceIoHandleNoCheck(ProcessData,
                                         Handle,
                                         &HandleData
                                        );
            ASSERT (NT_SUCCESS(Status));
            if (!NT_SUCCESS(Status)) {
                leave;
            }
            if (!InitializeInputHandle(HandleData, &Console->InputBuffer)) {
                Status = STATUS_NO_MEMORY;
                leave;
            }
            if (a->InheritHandle) {
                HandleData->HandleType |= CONSOLE_INHERITABLE;
            }
            Status = ConsoleAddShare(a->DesiredAccess,
                                     a->ShareMode,
                                     &HandleData->Buffer.InputBuffer->ShareAccess,
                                     HandleData
                                    );
            if (!NT_SUCCESS(Status)) {
                HandleData->Buffer.InputBuffer->RefCount--;
                leave;
            }
        } else if (a->HandleType == CONSOLE_OUTPUT_HANDLE){
            PSCREEN_INFORMATION ScreenInfo;

            //
            // open a handle to the active screen buffer.
            //

            ScreenInfo = Console->CurrentScreenBuffer;
            if (ScreenInfo == NULL) {
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
                leave;
            }
            Status = AllocateIoHandle(ProcessData,
                                      a->HandleType,
                                      &Handle
                                     );
            if (!NT_SUCCESS(Status)) {
                leave;
            }
            Status = DereferenceIoHandleNoCheck(ProcessData,
                                         Handle,
                                         &HandleData
                                        );
            ASSERT (NT_SUCCESS(Status));
            if (!NT_SUCCESS(Status)) {
                leave;
            }
            InitializeOutputHandle(HandleData, ScreenInfo);
            if (a->InheritHandle) {
                HandleData->HandleType |= CONSOLE_INHERITABLE;
            }
            Status = ConsoleAddShare(a->DesiredAccess,
                                     a->ShareMode,
                                     &HandleData->Buffer.ScreenBuffer->ShareAccess,
                                     HandleData
                                    );
            if (!NT_SUCCESS(Status)) {
                HandleData->Buffer.ScreenBuffer->RefCount--;
                leave;
            }
        }
        else {
            Status = STATUS_INVALID_PARAMETER;
            leave;
        }
        a->Handle = INDEX_TO_HANDLE(Handle);
        Status = STATUS_SUCCESS;
    } finally {
        if (!NT_SUCCESS(Status) && Handle != INVALID_HANDLE_VALUE) {
            FreeIoHandle(ProcessData,
                         Handle
                        );
        }
        UnlockConsole(Console);
    }
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

/*
 * Convert real Windows NT modifier bit into bizarre Console bits
 */
#define EITHER_CTRL_PRESSED (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED)
#define EITHER_ALT_PRESSED (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED)
#define MOD_PRESSED (SHIFT_PRESSED | EITHER_CTRL_PRESSED | EITHER_ALT_PRESSED)

DWORD ConsKbdState[] = {
    0,
    SHIFT_PRESSED,
                    EITHER_CTRL_PRESSED,
    SHIFT_PRESSED | EITHER_CTRL_PRESSED,
                                          EITHER_ALT_PRESSED,
    SHIFT_PRESSED |                       EITHER_ALT_PRESSED,
                    EITHER_CTRL_PRESSED | EITHER_ALT_PRESSED,
    SHIFT_PRESSED | EITHER_CTRL_PRESSED | EITHER_ALT_PRESSED
};

#define KEYEVENTSTATE_EQUAL_WINMODS(Event, WinMods)\
    ((Event.Event.KeyEvent.dwControlKeyState & ConsKbdState[WinMods]) && \
    !(Event.Event.KeyEvent.dwControlKeyState & MOD_PRESSED & ~ConsKbdState[WinMods]))

BOOL IsDbcsExemptionForHighAnsi(
    UINT wCodePage,
    WORD wNumpadChar)
{
    UserAssert(HIBYTE(wNumpadChar) == 0);

    if (wCodePage == CP_JAPANESE && IS_JPN_1BYTE_KATAKANA(wNumpadChar)) {
        /*
         * If hkl is JAPANESE and NumpadChar is in KANA range,
         * NumpadChar should be handled by the input locale.
         */
        return FALSE;
    }
    else if (wNumpadChar >= 0x80 && wNumpadChar <= 0xff) {
        /*
         * Otherwise if NumpadChar is in High ANSI range,
         * use 1252 for conversion.
         */
        return TRUE;
    }

    /*
     * None of the above.
     * This case includes the compound Leading Byte and Trailing Byte,
     * which is larger than 0xff.
     */
    return FALSE;
}

NTSTATUS
GetChar(
    IN PINPUT_INFORMATION InputInfo,
    OUT PWCHAR Char,
    IN BOOLEAN Wait,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData,
    IN PCSR_API_MSG Message OPTIONAL,
    IN CSR_WAIT_ROUTINE WaitRoutine OPTIONAL,
    IN PVOID WaitParameter OPTIONAL,
    IN ULONG WaitParameterLength  OPTIONAL,
    IN BOOLEAN WaitBlockExists OPTIONAL,
    OUT PBOOLEAN CommandLineEditingKeys OPTIONAL,
    OUT PBOOLEAN CommandLinePopupKeys OPTIONAL,
    OUT PBOOLEAN EnableScrollMode OPTIONAL,
    OUT PDWORD KeyState OPTIONAL
    )

/*++

Routine Description:

    This routine is used in stream input.  It gets input and filters it
    for unicode characters.

Arguments:

    InputInfo - Pointer to input buffer information.

    Char - Unicode char input.

    Wait - TRUE if the routine shouldn't wait for input.

    Console - Pointer to console buffer information.

    HandleData - Pointer to handle data structure.

    Message - csr api message.

    WaitRoutine - Routine to call when wait is woken up.

    WaitParameter - Parameter to pass to wait routine.

    WaitParameterLength - Length of wait parameter.

    WaitBlockExists - TRUE if wait block has already been created.

    CommandLineEditingKeys - if present, arrow keys will be returned. on
    output, if TRUE, Char contains virtual key code for arrow key.

    CommandLinePopupKeys - if present, arrow keys will be returned. on
    output, if TRUE, Char contains virtual key code for arrow key.

Return Value:

--*/

{
    ULONG NumRead;
    INPUT_RECORD Event;
    NTSTATUS Status;

    if (ARGUMENT_PRESENT(CommandLineEditingKeys)) {
        *CommandLineEditingKeys = FALSE;
    }
    if (ARGUMENT_PRESENT(CommandLinePopupKeys)) {
        *CommandLinePopupKeys = FALSE;
    }
    if (ARGUMENT_PRESENT(EnableScrollMode)) {
        *EnableScrollMode = FALSE;
    }
    if (ARGUMENT_PRESENT(KeyState)) {
        *KeyState = 0;
    }

    NumRead = 1;
    while (TRUE) {
        Status =ReadInputBuffer(InputInfo,
                                 &Event,
                                 &NumRead,
                                 FALSE,
                                 Wait,
                                 TRUE,
                                 Console,
                                 HandleData,
                                 Message,
                                 WaitRoutine,
                                 WaitParameter,
                                 WaitParameterLength,
                                 WaitBlockExists
#if defined(FE_SB)
                                 ,
                                 TRUE
#endif
                                );
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
        if (NumRead == 0) {
            if (Wait) {
                ASSERT (FALSE);
            }
            else {
                return STATUS_UNSUCCESSFUL;
            }
        }
        if (Event.EventType == KEY_EVENT) {
            BOOL fCommandLineEditKey;

            if (ARGUMENT_PRESENT(CommandLineEditingKeys)) {
                fCommandLineEditKey = IsCommandLineEditingKey(&Event.Event.KeyEvent);
            } else if (ARGUMENT_PRESENT(CommandLinePopupKeys)) {
                fCommandLineEditKey = IsCommandLinePopupKey(&Event.Event.KeyEvent);
            } else {
                fCommandLineEditKey = FALSE;
            }

            //
            // Always return keystate if caller asked for it.
            //
            if (ARGUMENT_PRESENT(KeyState)) {
                *KeyState = Event.Event.KeyEvent.dwControlKeyState;
            }

            if (Event.Event.KeyEvent.uChar.UnicodeChar != 0 &&
                    !fCommandLineEditKey) {

                //
                // chars that are generated using alt+numpad
                //
                if (!Event.Event.KeyEvent.bKeyDown &&
                        Event.Event.KeyEvent.wVirtualKeyCode == VK_MENU) {
                    if (Event.Event.KeyEvent.dwControlKeyState & ALTNUMPAD_BIT)
                    {
                        if (CONSOLE_IS_DBCS_CP(Console) && HIBYTE(Event.Event.KeyEvent.uChar.UnicodeChar)) {
                            char chT[2] = {
                                HIBYTE(Event.Event.KeyEvent.uChar.UnicodeChar),
                                LOBYTE(Event.Event.KeyEvent.uChar.UnicodeChar),
                            };
                            *Char = CharToWchar(Console, Console->CP, chT);
                        } else {
                            // Because USER doesn't know our codepage, it gives us the
                            // raw OEM char and we convert it to a Unicode character.
                            char chT = LOBYTE(Event.Event.KeyEvent.uChar.UnicodeChar);
                            UINT uCodePage = Console->CP;

                            //
                            // FarEast hack for High ANSI OEM characters.
                            //
                            if (CONSOLE_IS_DBCS_CP(Console)) {
                                if (IsDbcsExemptionForHighAnsi(uCodePage, chT)) {
                                    /*
                                     * FarEast hack:
                                     * treat characters in High ANSI area as if they are
                                     * the ones of Codepage 1252.
                                     */
                                    uCodePage = 1252;
                                }
                            }
                            *Char = CharToWchar(Console, uCodePage, &chT);
                        }
                    } else {
                        *Char = Event.Event.KeyEvent.uChar.UnicodeChar;
                    }
                    return STATUS_SUCCESS;
                }
                //
                // Ignore Escape and Newline chars
                //
                else if (Event.Event.KeyEvent.bKeyDown &&
                        Event.Event.KeyEvent.wVirtualKeyCode != VK_ESCAPE &&
                        Event.Event.KeyEvent.uChar.UnicodeChar != 0x0a) {

                    *Char = Event.Event.KeyEvent.uChar.UnicodeChar;
                    return STATUS_SUCCESS;
                }
            }

            if (Event.Event.KeyEvent.bKeyDown) {
                SHORT sTmp;
                if (ARGUMENT_PRESENT(CommandLineEditingKeys) &&
                        fCommandLineEditKey) {
                    *CommandLineEditingKeys = TRUE;
                    *Char = (WCHAR) Event.Event.KeyEvent.wVirtualKeyCode;
                    return STATUS_SUCCESS;
                }
                else if (ARGUMENT_PRESENT(CommandLinePopupKeys) &&
                        fCommandLineEditKey) {
                    *CommandLinePopupKeys = TRUE;
                    *Char = (CHAR) Event.Event.KeyEvent.wVirtualKeyCode;
                    return STATUS_SUCCESS;
                }

                sTmp = VkKeyScan(0);

                if ((LOBYTE(sTmp) == Event.Event.KeyEvent.wVirtualKeyCode) &&
                    KEYEVENTSTATE_EQUAL_WINMODS(Event, HIBYTE(sTmp))) {
                    /*
                     * This really is the character 0x0000
                     */
                    *Char = Event.Event.KeyEvent.uChar.UnicodeChar;
                    return STATUS_SUCCESS;
                }
            }
        }
    }
}

BOOLEAN
RawReadWaitRoutine(
    IN PLIST_ENTRY WaitQueue,
    IN PCSR_THREAD WaitingThread,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PVOID WaitParameter,
    IN PVOID SatisfyParameter1,
    IN PVOID SatisfyParameter2,
    IN ULONG WaitFlags
    )

/*++

Routine Description:

    This routine is called to complete a raw read that blocked in
    ReadInputBuffer.  The context of the read was saved in the RawReadData
    structure.  This routine is called when events have been written to
    the input buffer.  It is called in the context of the writing thread.
    ?It will be called at most once per read.?

Arguments:

    WaitQueue - pointer to queue containing wait block

    WaitingThread - pointer to waiting thread

    WaitReplyMessage - Pointer to reply message to return to dll when
        read is completed.

    RawReadData - pointer to data saved in ReadChars

    SatisfyParameter1 - not used

    SatisfyParameter2 - not used

    WaitFlags - Flags indicating status of wait.

Return Value:

--*/

{
    NTSTATUS Status;
    PWCHAR lpBuffer;
    PCONSOLE_READCONSOLE_MSG a;
    PCONSOLE_INFORMATION Console;
    PRAW_READ_DATA RawReadData;
    PHANDLE_DATA HandleData;
    BOOLEAN RetVal = TRUE;
#ifdef FE_SB
    DWORD NumBytes;
    BOOL fAddDbcsLead = FALSE;
#endif

    a = (PCONSOLE_READCONSOLE_MSG)&WaitReplyMessage->u.ApiMessageData;
    RawReadData = (PRAW_READ_DATA)WaitParameter;

    Status = DereferenceIoHandleNoCheck(RawReadData->ProcessData,
                                        RawReadData->HandleIndex,
                                        &HandleData
                                       );
    ASSERT (NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        return TRUE;
    }

    //
    // see if this routine was called by CloseInputHandle.  if it
    // was, see if this wait block corresponds to the dying handle.
    // if it doesn't, just return.
    //

    if (SatisfyParameter1 != NULL &&
        SatisfyParameter1 != HandleData) {
        return FALSE;
    }
    if ((ULONG_PTR)SatisfyParameter2 & CONSOLE_CTRL_C_SEEN) {
        return FALSE;
    }

    Console = RawReadData->Console;

    //
    // this routine should be called by a thread owning the same
    // lock on the same console as we're reading from.
    //

    a->NumBytes = 0;
#ifdef FE_SB
    NumBytes = 0 ;
#endif
    try {
        LockReadCount(HandleData);
        ASSERT(HandleData->InputReadData->ReadCount);
        HandleData->InputReadData->ReadCount -= 1;
        UnlockReadCount(HandleData);

        //
        // if a ctrl-c is seen, don't terminate read.  if ctrl-break is seen,
        // terminate read.
        //

        if ((ULONG_PTR)SatisfyParameter2 & CONSOLE_CTRL_BREAK_SEEN) {
            WaitReplyMessage->ReturnValue = STATUS_ALERTED;
            leave;
        }

        //
        // see if called by CsrDestroyProcess or CsrDestroyThread
        // via CsrNotifyWaitBlock.   if so, just decrement the ReadCount
        // and return.
        //

        if (WaitFlags & CSR_PROCESS_TERMINATING) {
            Status = STATUS_THREAD_IS_TERMINATING;
            leave;
        }

        //
        // We must see if we were woken up because the handle is being
        // closed.  if so, we decrement the read count.  if it goes to
        // zero, we wake up the close thread.  otherwise, we wake up any
        // other thread waiting for data.
        //

        if (HandleData->InputReadData->InputHandleFlags & HANDLE_CLOSING) {
            ASSERT (SatisfyParameter1 == HandleData);
            Status = STATUS_ALERTED;
            leave;
        }

        //
        // if we get to here, this routine was called either by the input
        // thread or a write routine.  both of these callers grab the
        // current console lock.
        //

        //
        // this routine should be called by a thread owning the same
        // lock on the same console as we're reading from.
        //

        ASSERT (ConsoleLocked(Console));

        if (a->CaptureBufferSize <= BUFFER_SIZE) {
            lpBuffer = a->Buffer;
        }
        else {
            lpBuffer = RawReadData->BufPtr;
        }

        //
        // this call to GetChar may block.
        //

#ifdef FE_SB
        if (!a->Unicode && CONSOLE_IS_DBCS_CP(Console)) {
            if (HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                fAddDbcsLead = TRUE;
                *lpBuffer = HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar;
                RawReadData->BufferSize-=sizeof(WCHAR);
                RtlZeroMemory(&HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));
                Status = STATUS_SUCCESS;
                if (RawReadData->BufferSize == 0) {
                    a->NumBytes = 1;
                    return FALSE;
                }
            }
            else{
                Status = GetChar(RawReadData->InputInfo,
                         lpBuffer,
                         TRUE,
                         Console,
                         HandleData,
                         WaitReplyMessage,
                         RawReadWaitRoutine,
                         RawReadData,
                         sizeof(*RawReadData),
                         TRUE,
                         NULL,
                         NULL,
                         NULL,
                         NULL
                        );
            }
        }
        else
#endif
        Status = GetChar(RawReadData->InputInfo,
                         lpBuffer,
                         TRUE,
                         Console,
                         HandleData,
                         WaitReplyMessage,
                         RawReadWaitRoutine,
                         RawReadData,
                         sizeof(*RawReadData),
                         TRUE,
                         NULL,
                         NULL,
                         NULL,
                         NULL
                        );

        if (!NT_SUCCESS(Status)) {
            if (Status == CONSOLE_STATUS_WAIT) {
                RetVal = FALSE;
            }
            leave;
        }
#ifdef FE_SB
        IsConsoleFullWidth(Console->hDC,
                           Console->CP,*lpBuffer) ? NumBytes+=2 : NumBytes++;
#endif
        lpBuffer++;
        a->NumBytes += sizeof(WCHAR);
        while (a->NumBytes < RawReadData->BufferSize) {

            //
            // this call to GetChar won't block.
            //

            Status = GetChar(RawReadData->InputInfo,lpBuffer,FALSE,NULL,NULL,NULL,NULL,NULL,0,TRUE,NULL,NULL,NULL,NULL);
            if (!NT_SUCCESS(Status)) {
                Status = STATUS_SUCCESS;
                break;
            }
#ifdef FE_SB
            IsConsoleFullWidth(Console->hDC,
                               Console->CP,*lpBuffer) ? NumBytes+=2 : NumBytes++;
#endif
            lpBuffer++;
            a->NumBytes += sizeof(WCHAR);
        }
    } finally {

        //
        // if the read was completed (status != wait), free the raw read
        // data.
        //

        if (Status != CONSOLE_STATUS_WAIT) {
            if (!a->Unicode) {

                //
                // if ansi, translate string.
                //

                PCHAR TransBuffer;

#ifdef FE_SB
                TransBuffer = ConsoleHeapAlloc(TMP_DBCS_TAG, NumBytes);
#else
                TransBuffer = ConsoleHeapAlloc(TMP_TAG, a->NumBytes / sizeof(WCHAR));
#endif
                if (TransBuffer == NULL) {
                    RetVal = TRUE;
                    goto EndFinally;
                }

                if (a->CaptureBufferSize <= BUFFER_SIZE) {
                    lpBuffer = a->Buffer;
                }
                else {
                    lpBuffer = RawReadData->BufPtr;
                }

#ifdef FE_SB
                if (CONSOLE_IS_DBCS_CP(Console))
                {
                    a->NumBytes = TranslateUnicodeToOem(Console,
                                                        lpBuffer,
                                                        a->NumBytes / sizeof (WCHAR),
                                                        TransBuffer,
                                                        NumBytes,
                                                        &HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte);
                }
                else
#endif
                a->NumBytes = ConvertToOem(RawReadData->Console->CP,
                                     lpBuffer,
                                     a->NumBytes / sizeof (WCHAR),
                                     TransBuffer,
                                     a->NumBytes / sizeof (WCHAR)
                                     );
                RtlCopyMemory(lpBuffer,TransBuffer,a->NumBytes);
#ifdef FE_SB
                if (fAddDbcsLead)
                    a->NumBytes++;
#endif
                ConsoleHeapFree(TransBuffer);
            }
            WaitReplyMessage->ReturnValue = Status;
            ConsoleHeapFree(RawReadData);
        }
EndFinally:;
    }
    return RetVal;

    //
    // satisfy the unreferenced parameter warnings.
    //

    UNREFERENCED_PARAMETER(WaitQueue);
    UNREFERENCED_PARAMETER(WaitingThread);
}

ULONG
RetrieveTotalNumberOfSpaces(
    IN SHORT OriginalCursorPositionX,
    IN PWCHAR Buffer,
    IN ULONG CurrentPosition
#if defined(FE_SB)
    ,
    IN PCONSOLE_INFORMATION Console
#endif
    )

/*++

    This routine returns the total number of screen spaces the characters
    up to the specified character take up.

--*/

{
    WCHAR Char;
    ULONG i,NumSpacesForChar,NumSpaces;
    SHORT XPosition;

    XPosition=OriginalCursorPositionX;
    NumSpaces=0;
    for (i=0;i<CurrentPosition;i++) {
        Char = Buffer[i];
        if (Char == UNICODE_TAB) {
            NumSpacesForChar = NUMBER_OF_SPACES_IN_TAB(XPosition);
        } else if (IS_CONTROL_CHAR(Char)) {
            NumSpacesForChar = 2;
#if defined(FE_SB)
        } else if (IsConsoleFullWidth(Console->hDC,Console->CP,Char)) {
            NumSpacesForChar = 2;
#endif
        } else {
            NumSpacesForChar = 1;
        }
        XPosition = (SHORT)(XPosition+NumSpacesForChar);
        NumSpaces += NumSpacesForChar;
    }
    return NumSpaces;
}

ULONG
RetrieveNumberOfSpaces(
    IN SHORT OriginalCursorPositionX,
    IN PWCHAR Buffer,
    IN ULONG CurrentPosition
#if defined(FE_SB)
    ,
    IN PCONSOLE_INFORMATION Console,
    IN DWORD CodePage
#endif
    )

/*++

    This routine returns the number of screen spaces the specified character
    takes up.

--*/

{
    WCHAR Char;
    ULONG i,NumSpaces;
    SHORT XPosition;

    Char = Buffer[CurrentPosition];
    if (Char == UNICODE_TAB) {
        NumSpaces=0;
        XPosition=OriginalCursorPositionX;
        for (i=0;i<=CurrentPosition;i++) {
            Char = Buffer[i];
            if (Char == UNICODE_TAB) {
                NumSpaces = NUMBER_OF_SPACES_IN_TAB(XPosition);
            } else if (IS_CONTROL_CHAR(Char)) {
                NumSpaces = 2;
#if defined(FE_SB)
            } else if (IsConsoleFullWidth(Console->hDC,CodePage,Char)) {
                NumSpaces = 2;
#endif
            } else {
                NumSpaces = 1;
            }
            XPosition = (SHORT)(XPosition+NumSpaces);
        }
        return NumSpaces;
    }
    else if (IS_CONTROL_CHAR(Char)) {
        return 2;
    }
#if defined(FE_SB)
    else if (IsConsoleFullWidth(Console->hDC,CodePage,Char)) {
        return 2;
    }
#endif
    else {
        return 1;
    }
}

BOOL
ProcessCookedReadInput(
    IN PCOOKED_READ_DATA CookedReadData,
    IN WCHAR Char,
    IN DWORD KeyState,
    OUT PNTSTATUS Status
    )

/*++

    Return Value:

        TRUE if read is completed
--*/

{
    DWORD NumSpaces;
    SHORT ScrollY=0;
    ULONG NumToWrite;
    WCHAR wchOrig = Char;
    BOOL fStartFromDelim;

    *Status = STATUS_SUCCESS;
    if (CookedReadData->BytesRead >= (CookedReadData->BufferSize-(2*sizeof(WCHAR))) &&
        Char != UNICODE_CARRIAGERETURN &&
        Char != UNICODE_BACKSPACE) {
        return FALSE;
    }

    if (CookedReadData->CtrlWakeupMask != 0 &&
        Char < L' ' && (CookedReadData->CtrlWakeupMask & (1 << Char))) {
        *CookedReadData->BufPtr = Char;
        CookedReadData->BytesRead += sizeof(WCHAR);
        CookedReadData->BufPtr+=1;
        CookedReadData->CurrentPosition+=1;
        CookedReadData->ControlKeyState = KeyState;
        return TRUE;
    }


    if (Char == EXTKEY_ERASE_PREV_WORD) {
        Char = UNICODE_BACKSPACE;

    }
    if (AT_EOL(CookedReadData)) {

        //
        // if at end of line, processing is relatively simple. just store the
        // character and write it to the screen.
        //


        if (Char == UNICODE_BACKSPACE2) {
            Char = UNICODE_BACKSPACE;
        }
        if (Char != UNICODE_BACKSPACE ||
            CookedReadData->BufPtr != CookedReadData->BackupLimit) {

            fStartFromDelim = gExtendedEditKey && IS_WORD_DELIM(CookedReadData->BufPtr[-1]);

eol_repeat:
            if (CookedReadData->Echo) {
                NumToWrite=sizeof(WCHAR);
                *Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                    CookedReadData->BackupLimit,
                                    CookedReadData->BufPtr,
                                    &Char,
                                    &NumToWrite,
                                    (PLONG)&NumSpaces,
                                    CookedReadData->OriginalCursorPosition.X,
                                    WC_DESTRUCTIVE_BACKSPACE |
                                            WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                    &ScrollY
                                    );
                if (NT_SUCCESS(*Status)) {
                    CookedReadData->OriginalCursorPosition.Y += ScrollY;
                } else {
                    RIPMSG1(RIP_WARNING, "WriteCharsFromInput failed %x", *Status);
                }
            }
            CookedReadData->NumberOfVisibleChars += NumSpaces;
            if (Char == UNICODE_BACKSPACE && CookedReadData->Processed) {
                CookedReadData->BytesRead -= sizeof(WCHAR);
                *CookedReadData->BufPtr=(WCHAR)' ';
                CookedReadData->BufPtr-=1;
                CookedReadData->CurrentPosition-=1;

                // Repeat until it hits the word boundary
                if (gExtendedEditKey &&
                        wchOrig == EXTKEY_ERASE_PREV_WORD &&
                        CookedReadData->BufPtr != CookedReadData->BackupLimit &&
                        fStartFromDelim ^ !IS_WORD_DELIM(CookedReadData->BufPtr[-1])) {
                    goto eol_repeat;
                }
            }
            else {
                *CookedReadData->BufPtr = Char;
                CookedReadData->BytesRead += sizeof(WCHAR);
                CookedReadData->BufPtr+=1;
                CookedReadData->CurrentPosition+=1;
            }
        }
    } else {
        BOOL CallWrite=TRUE;

        //
        // processing in the middle of the line is more complex:
        //
        //
        // calculate new cursor position
        // store new char
        // clear the current command line from the screen
        // write the new command line to the screen
        // update the cursor position
        //

        if (Char == UNICODE_BACKSPACE && CookedReadData->Processed) {

            //
            // for backspace, use writechars to calculate the new cursor position.
            // this call also sets the cursor to the right position for the
            // second call to writechars.
            //
            if (CookedReadData->BufPtr != CookedReadData->BackupLimit) {

                fStartFromDelim = gExtendedEditKey && IS_WORD_DELIM(CookedReadData->BufPtr[-1]);

bs_repeat:

                //
                // we call writechar here so that cursor position gets updated
                // correctly.  we also call it later if we're not at eol so
                // that the remainder of the string can be updated correctly.
                //

                if (CookedReadData->Echo) {
                    NumToWrite=sizeof(WCHAR);
                    *Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                             CookedReadData->BackupLimit,
                             CookedReadData->BufPtr,
                             &Char,
                             &NumToWrite,
                             NULL,
                             CookedReadData->OriginalCursorPosition.X,
                             WC_DESTRUCTIVE_BACKSPACE |
                                     WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                             NULL);

                    if (!NT_SUCCESS(*Status)) {
                        RIPMSG1(RIP_WARNING, "WriteCharsFromInput failed %x", *Status);
                    }
                }
                CookedReadData->BytesRead -= sizeof(WCHAR);
                CookedReadData->BufPtr-=1;
                CookedReadData->CurrentPosition-=1;
                RtlCopyMemory(CookedReadData->BufPtr,
                       CookedReadData->BufPtr+1,
                       CookedReadData->BytesRead - (CookedReadData->CurrentPosition * sizeof(WCHAR))
                      );
#if defined(FE_SB)
                {
                    PWCHAR buf = (PWCHAR)((PBYTE)CookedReadData->BackupLimit +
                                                 CookedReadData->BytesRead    );
                    *buf = (WCHAR)' ';
                }
#endif
                NumSpaces = 0;

                // Repeat until it hits the word boundary
                if (gExtendedEditKey &&
                        wchOrig == EXTKEY_ERASE_PREV_WORD &&
                        CookedReadData->BufPtr != CookedReadData->BackupLimit &&
                        fStartFromDelim ^ !IS_WORD_DELIM(CookedReadData->BufPtr[-1])) {
                    goto bs_repeat;
                }
            } else {
                 CallWrite = FALSE;
            }
        } else {

            //
            // store the char
            //

            if (Char == UNICODE_CARRIAGERETURN) {
                CookedReadData->BufPtr = (PWCHAR)((PBYTE)CookedReadData->BackupLimit + CookedReadData->BytesRead);
                *CookedReadData->BufPtr = Char;
                CookedReadData->BufPtr+=1;
                CookedReadData->BytesRead += sizeof(WCHAR);
                CookedReadData->CurrentPosition += 1;
            } else {
#if defined(FE_SB)
                BOOL fBisect = FALSE;
                if (CookedReadData->Echo) {
                    if (CheckBisectProcessW(CookedReadData->ScreenInfo,
                                            CookedReadData->ScreenInfo->Console->CP,
                                            CookedReadData->BackupLimit,
                                            CookedReadData->CurrentPosition+1,
                                            CookedReadData->ScreenInfo->ScreenBufferSize.X
                                             -CookedReadData->OriginalCursorPosition.X,
                                            CookedReadData->OriginalCursorPosition.X,
                                            TRUE)) {
                        fBisect = TRUE;
                    }
                }
#endif
                if (INSERT_MODE(CookedReadData)) {
                    memmove(CookedReadData->BufPtr+1,
                            CookedReadData->BufPtr,
                            CookedReadData->BytesRead - (CookedReadData->CurrentPosition * sizeof(WCHAR))
                           );
                    CookedReadData->BytesRead += sizeof(WCHAR);
                }
                *CookedReadData->BufPtr = Char;
                CookedReadData->BufPtr+=1;
                CookedReadData->CurrentPosition += 1;

                //
                // calculate new cursor position
                //

                if (CookedReadData->Echo) {
                    NumSpaces = RetrieveNumberOfSpaces(CookedReadData->OriginalCursorPosition.X,
                                                       CookedReadData->BackupLimit,
                                                       CookedReadData->CurrentPosition-1
#if defined(FE_SB)
                                                       ,
                                                       CookedReadData->ScreenInfo->Console,
                                                       CookedReadData->ScreenInfo->Console->CP
#endif
                                                      );
#if defined(FE_SB)
                    if (NumSpaces > 0 && fBisect)
                        NumSpaces--;
#endif
                }
            }
        }

        if (CookedReadData->Echo && CallWrite) {

            COORD CursorPosition;

            //
            // save cursor position
            //

            CursorPosition = CookedReadData->ScreenInfo->BufferInfo.TextInfo.CursorPosition;
            CursorPosition.X = (SHORT)(CursorPosition.X+NumSpaces);

            //
            // clear the current command line from the screen
            //

            DeleteCommandLine(CookedReadData,
                              FALSE);

            //
            // write the new command line to the screen
            //

            NumToWrite = CookedReadData->BytesRead;
            *Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                CookedReadData->BackupLimit,
                                CookedReadData->BackupLimit,
                                CookedReadData->BackupLimit,
                                &NumToWrite,
                                (PLONG)&CookedReadData->NumberOfVisibleChars,
                                CookedReadData->OriginalCursorPosition.X,
                                (Char != UNICODE_CARRIAGERETURN) ?
                                     WC_DESTRUCTIVE_BACKSPACE | WC_ECHO :
                                     WC_DESTRUCTIVE_BACKSPACE | WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                &ScrollY
                                );
            if (!NT_SUCCESS(*Status)) {
                RIPMSG1(RIP_WARNING, "WriteCharsFromInput failed %x", *Status);
                CookedReadData->BytesRead = 0;
                return TRUE;
            }

            //
            // update cursor position
            //

            if (Char != UNICODE_CARRIAGERETURN) {
#if defined(FE_SB)
                if (CheckBisectProcessW(CookedReadData->ScreenInfo,
                                        CookedReadData->ScreenInfo->Console->CP,
                                        CookedReadData->BackupLimit,
                                        CookedReadData->CurrentPosition+1,
                                        CookedReadData->ScreenInfo->ScreenBufferSize.X
                                         -CookedReadData->OriginalCursorPosition.X,
                                        CookedReadData->OriginalCursorPosition.X,
                                        TRUE)) {
                    if (CursorPosition.X == (CookedReadData->ScreenInfo->ScreenBufferSize.X-1))
                        CursorPosition.X++;
                }
#endif

                // adjust cursor position for WriteChars
                CookedReadData->OriginalCursorPosition.Y += ScrollY;
                CursorPosition.Y += ScrollY;
                *Status = AdjustCursorPosition(CookedReadData->ScreenInfo,
                                              CursorPosition,
                                              TRUE,
                                              NULL);
                ASSERT(NT_SUCCESS(*Status));
                if (!NT_SUCCESS(*Status)) {
                    CookedReadData->BytesRead = 0;
                    return TRUE;
                }
            }
        }
    }

    //
    // in cooked mode, enter (carriage return) is converted to
    // carriage return linefeed (0xda).  carriage return is always
    // stored at the end of the buffer.
    //

    if (Char == UNICODE_CARRIAGERETURN) {
        if (CookedReadData->Processed) {
            if (CookedReadData->BytesRead < CookedReadData->BufferSize) {
                *CookedReadData->BufPtr = UNICODE_LINEFEED;
                if (CookedReadData->Echo) {
                    NumToWrite=sizeof(WCHAR);
                    *Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                             CookedReadData->BackupLimit,
                             CookedReadData->BufPtr,
                             CookedReadData->BufPtr,
                             &NumToWrite,
                             NULL,
                             CookedReadData->OriginalCursorPosition.X,
                             WC_DESTRUCTIVE_BACKSPACE |
                                     WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                             NULL);

                    if (!NT_SUCCESS(*Status)) {
                        RIPMSG1(RIP_WARNING, "WriteCharsFromInput failed %x", *Status);
                    }
                }
                CookedReadData->BytesRead += sizeof(WCHAR);
                CookedReadData->BufPtr++;
                CookedReadData->CurrentPosition += 1;
            }
        }
        //
        // reset the cursor back to 25% if necessary
        //
        if (CookedReadData->Line) {
            if (CookedReadData->InsertMode != CookedReadData->Console->InsertMode) {
                ProcessCommandLine(CookedReadData,VK_INSERT,0,NULL,NULL,FALSE); // make cursor small
            }
            *Status = STATUS_SUCCESS;
            return TRUE;
        }
    }
    return FALSE;
}

NTSTATUS
CookedRead(
    IN PCOOKED_READ_DATA CookedReadData,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    )
{
    WCHAR Char;
    BOOLEAN CommandLineEditingKeys,EnableScrollMode;
    DWORD KeyState;
    NTSTATUS Status=STATUS_SUCCESS;
    PCONSOLE_READCONSOLE_MSG a;
    PHANDLE_DATA HandleData;
#ifdef FE_SB
    DWORD NumBytes;
    ULONG NumToWrite;
    BOOL fAddDbcsLead = FALSE;
#endif

    Status = DereferenceIoHandleNoCheck(CookedReadData->ProcessData,
                                        CookedReadData->HandleIndex,
                                        &HandleData
                                       );
    if (!NT_SUCCESS(Status)) {
        CookedReadData->BytesRead = 0;
        ConsoleHeapFree(CookedReadData->BackupLimit); 
        return Status;
    }

    a = (PCONSOLE_READCONSOLE_MSG)&WaitReplyMessage->u.ApiMessageData;
    while (CookedReadData->BytesRead < CookedReadData->BufferSize) {

        //
        // this call to GetChar may block.
        //

        Status = GetChar(CookedReadData->InputInfo,
                         &Char,
                         TRUE,
                         CookedReadData->Console,
                         HandleData,
                         WaitReplyMessage,
                         CookedReadWaitRoutine,
                         CookedReadData,
                         sizeof(*CookedReadData),
                         WaitRoutine,
                         &CommandLineEditingKeys,
                         NULL,
                         &EnableScrollMode,
                         &KeyState
                        );
        if (!NT_SUCCESS(Status)) {
            if (Status != CONSOLE_STATUS_WAIT) {
                CookedReadData->BytesRead = 0;
            }
            break;
        }

        //
        // we should probably set these up in GetChars, but we set them
        // up here because the debugger is multi-threaded and calls
        // read before outputting the prompt.
        //

        if (CookedReadData->OriginalCursorPosition.X == -1) {
            CookedReadData->OriginalCursorPosition = CookedReadData->ScreenInfo->BufferInfo.TextInfo.CursorPosition;
        }

        if (CommandLineEditingKeys) {
            Status = ProcessCommandLine(CookedReadData,Char,KeyState,WaitReplyMessage,WaitingThread,WaitRoutine);
            if (Status == CONSOLE_STATUS_READ_COMPLETE ||
                Status == CONSOLE_STATUS_WAIT) {
                break;
            }
            if (!NT_SUCCESS(Status)) {
                if (Status == CONSOLE_STATUS_WAIT_NO_BLOCK) {
                    Status = CONSOLE_STATUS_WAIT;
                    if (!WaitRoutine) {
                        //
                        // we have no wait block, so create one.
                        //
                        WaitForMoreToRead(CookedReadData->InputInfo,
                                          WaitReplyMessage,
                                          CookedReadWaitRoutine,
                                          CookedReadData,
                                          sizeof(*CookedReadData),
                                          FALSE
                                         );
                    }
                } else {
                    CookedReadData->BytesRead = 0;
                }
                break;
            }
        } else {
            if (ProcessCookedReadInput(CookedReadData,
                                       Char,
                                       KeyState,
                                       &Status
                                      )) {
                CookedReadData->Console->Flags |= CONSOLE_IGNORE_NEXT_KEYUP;
                break;
            }
        }
    }

    //
    // if the read was completed (status != wait), free the cooked read
    // data.  also, close the temporary output handle that was opened to
    // echo the characters read.
    //

    if (Status != CONSOLE_STATUS_WAIT) {

        DWORD LineCount=1;
        if (CookedReadData->Echo) {
            BOOLEAN FoundCR;
            ULONG i,StringLength;
            PWCHAR StringPtr;

            // figure out where real string ends (at carriage return
            // or end of buffer)

            StringPtr = CookedReadData->BackupLimit;
            StringLength = CookedReadData->BytesRead;
            FoundCR = FALSE;
            for (i=0;i<(CookedReadData->BytesRead/sizeof(WCHAR));i++) {
                if (*StringPtr++ == UNICODE_CARRIAGERETURN) {
                    StringLength = i*sizeof(WCHAR);
                    FoundCR = TRUE;
                    break;
                }
            }

            if (FoundCR) {
                //
                // add to command line recall list
                //

                AddCommand(CookedReadData->CommandHistory,CookedReadData->BackupLimit,(USHORT)StringLength,CookedReadData->Console->Flags & CONSOLE_HISTORY_NODUP);

                //
                // check for alias
                //

                i = CookedReadData->BufferSize;
                if (NT_SUCCESS(MatchandCopyAlias(CookedReadData->Console,
                                                 CookedReadData->BackupLimit,
                                                 (USHORT)StringLength,
                                                 CookedReadData->BackupLimit,
                                                 (PUSHORT)&i,
                                                 CookedReadData->ExeName,
                                                 CookedReadData->ExeNameLength,
                                                 &LineCount
                                                ))) {
                  CookedReadData->BytesRead = i;
                }
            }

            //
            // Close the handle - unless ProcessCommandListInput already did it.
            //

            if (Status != CONSOLE_STATUS_READ_COMPLETE) {
                CloseOutputHandle(CONSOLE_FROMTHREADPERPROCESSDATA(WaitingThread),
                                  CookedReadData->Console,
                                  &CookedReadData->TempHandle,
                                  NULL,
                                  FALSE
                                 );
            }
        }
        WaitReplyMessage->ReturnValue = Status;

        //
        // at this point, a->NumBytes contains the number of bytes in
        // the UNICODE string read.  UserBufferSize contains the converted
        // size of the app's buffer.
        //

        if (CookedReadData->BytesRead > CookedReadData->UserBufferSize || LineCount > 1) {
            if (LineCount > 1) {
                PWSTR Tmp;
                HandleData->InputReadData->InputHandleFlags |= HANDLE_MULTI_LINE_INPUT;
#ifdef FE_SB
                if (!a->Unicode && CONSOLE_IS_DBCS_CP(CookedReadData->Console)) {
                    if (HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                        fAddDbcsLead = TRUE;
                        *CookedReadData->UserBuffer++ = HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar;
                        CookedReadData->UserBufferSize-=sizeof(WCHAR);
                        RtlZeroMemory(&HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));
                    }
                    NumBytes = 0;
                    for (Tmp=CookedReadData->BackupLimit;
                         *Tmp!=UNICODE_LINEFEED && CookedReadData->UserBufferSize/sizeof(WCHAR) > NumBytes;
                         (IsConsoleFullWidth(CookedReadData->Console->hDC,
                                             CookedReadData->Console->CP,*Tmp) ? NumBytes+=2 : NumBytes++),Tmp++) ;
                }
#endif
                for (Tmp=CookedReadData->BackupLimit;*Tmp!=UNICODE_LINEFEED;Tmp++)
                    ASSERT(Tmp<(CookedReadData->BackupLimit+CookedReadData->BytesRead));
                a->NumBytes = (ULONG)(Tmp-CookedReadData->BackupLimit+1)*sizeof(*Tmp);
            } else {
#ifdef FE_SB
                if (!a->Unicode && CONSOLE_IS_DBCS_CP(CookedReadData->Console)) {
                    PWSTR Tmp;

                    if (HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                        fAddDbcsLead = TRUE;
                        *CookedReadData->UserBuffer++ = HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar;
                        CookedReadData->UserBufferSize-=sizeof(WCHAR);
                        RtlZeroMemory(&HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));
                    }
                    NumBytes = 0;
                    NumToWrite = CookedReadData->BytesRead;
                    for (Tmp=CookedReadData->BackupLimit;
                         NumToWrite && CookedReadData->UserBufferSize/sizeof(WCHAR) > NumBytes;
                         (IsConsoleFullWidth(CookedReadData->Console->hDC,
                                             CookedReadData->Console->CP,*Tmp) ? NumBytes+=2 : NumBytes++),Tmp++,NumToWrite-=sizeof(WCHAR)) ;
                }
#endif
                a->NumBytes = CookedReadData->UserBufferSize;
            }
            HandleData->InputReadData->InputHandleFlags |= HANDLE_INPUT_PENDING;
            HandleData->InputReadData->BufPtr = CookedReadData->BackupLimit;
            HandleData->InputReadData->BytesAvailable = CookedReadData->BytesRead - a->NumBytes;
            HandleData->InputReadData->CurrentBufPtr=(PWCHAR)((PBYTE)CookedReadData->BackupLimit+a->NumBytes);
            RtlCopyMemory(CookedReadData->UserBuffer,CookedReadData->BackupLimit,a->NumBytes);
        }
        else {
#ifdef FE_SB
            if (!a->Unicode && CONSOLE_IS_DBCS_CP(CookedReadData->Console)) {
                PWSTR Tmp;

                if (HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                    fAddDbcsLead = TRUE;
                    *CookedReadData->UserBuffer++ = HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar;
                    CookedReadData->UserBufferSize-=sizeof(WCHAR);
                    RtlZeroMemory(&HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));

                    if (CookedReadData->UserBufferSize == 0) {
                        a->NumBytes = 1;
                        ConsoleHeapFree(CookedReadData->BackupLimit);
                        return STATUS_SUCCESS;
                    }
                }
                NumBytes = 0;
                NumToWrite = CookedReadData->BytesRead;
                for (Tmp=CookedReadData->BackupLimit;
                     NumToWrite && CookedReadData->UserBufferSize/sizeof(WCHAR) > NumBytes;
                     (IsConsoleFullWidth(CookedReadData->Console->hDC,
                                         CookedReadData->Console->CP,*Tmp) ? NumBytes+=2 : NumBytes++),Tmp++,NumToWrite-=sizeof(WCHAR)) ;
            }
#endif
            a->NumBytes = CookedReadData->BytesRead;
            RtlCopyMemory(CookedReadData->UserBuffer,CookedReadData->BackupLimit,a->NumBytes);
            ConsoleHeapFree(CookedReadData->BackupLimit);
        }
        a->ControlKeyState = CookedReadData->ControlKeyState;

        if (!a->Unicode) {

            //
            // if ansi, translate string.
            //

            PCHAR TransBuffer;

#ifdef FE_SB
            if (CONSOLE_IS_DBCS_CP(CookedReadData->Console))
                TransBuffer = ConsoleHeapAlloc(TMP_DBCS_TAG, NumBytes);
            else
#endif
            TransBuffer = ConsoleHeapAlloc(TMP_TAG, a->NumBytes / sizeof(WCHAR));
            if (TransBuffer == NULL) {
                return STATUS_NO_MEMORY;
            }

#ifdef FE_SB
            if (CONSOLE_IS_DBCS_CP(CookedReadData->Console)) {
                a->NumBytes = TranslateUnicodeToOem(CookedReadData->Console,
                                                    CookedReadData->UserBuffer,
                                                    a->NumBytes / sizeof (WCHAR),
                                                    TransBuffer,
                                                    NumBytes,
                                                    &HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte);
            }
            else
#endif
            a->NumBytes = ConvertToOem(CookedReadData->Console->CP,
                                 CookedReadData->UserBuffer,
                                 a->NumBytes / sizeof (WCHAR),
                                 TransBuffer,
                                 a->NumBytes / sizeof (WCHAR)
                                 );
            RtlCopyMemory(CookedReadData->UserBuffer,TransBuffer,a->NumBytes);
#ifdef FE_SB
            if (fAddDbcsLead)
                a->NumBytes++;
#endif
            ConsoleHeapFree(TransBuffer);
        }
        ConsoleHeapFree(CookedReadData->ExeName);
        if (WaitRoutine) {
#ifdef FE_SB
            CookedReadData->Console->lpCookedReadData = NULL;
#endif
            ConsoleHeapFree(CookedReadData);
        }
    }
    return Status;
}

BOOLEAN
CookedReadWaitRoutine(
    IN PLIST_ENTRY WaitQueue,
    IN PCSR_THREAD WaitingThread,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PVOID WaitParameter,
    IN PVOID SatisfyParameter1,
    IN PVOID SatisfyParameter2,
    IN ULONG WaitFlags
    )

/*++

Routine Description:

    This routine is called to complete a cooked read that blocked in
    ReadInputBuffer.  The context of the read was saved in the CookedReadData
    structure.  This routine is called when events have been written to
    the input buffer.  It is called in the context of the writing thread.
    It may be called more than once.

Arguments:

    WaitQueue - pointer to queue containing wait block

    WaitingThread - pointer to waiting thread

    WaitReplyMessage - pointer to reply message

    CookedReadData - pointer to data saved in ReadChars

    SatisfyParameter1 - if this routine was called (indirectly) by
    CloseInputHandle, this argument contains a HandleData pointer of
    the dying handle.  otherwise, it contains NULL.

    SatisfyParameter2 - if this routine is called because a ctrl-c or
    ctrl-break was seen, this argument contains CONSOLE_CTRL_SEEN.
    otherwise it contains NULL.

    WaitFlags - Flags indicating status of wait.

Return Value:

--*/


{
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PCOOKED_READ_DATA CookedReadData;
    PCONSOLE_READCONSOLE_MSG a;
    PHANDLE_DATA HandleData;

    a = (PCONSOLE_READCONSOLE_MSG)&WaitReplyMessage->u.ApiMessageData;
    CookedReadData = (PCOOKED_READ_DATA)WaitParameter;

    Status = DereferenceIoHandleNoCheck(CookedReadData->ProcessData,
                                        CookedReadData->HandleIndex,
                                        &HandleData
                                       );
    ASSERT (NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        return TRUE;
    }
    ASSERT(!(HandleData->InputReadData->InputHandleFlags & HANDLE_INPUT_PENDING));

    //
    // see if this routine was called by CloseInputHandle.  if it
    // was, see if this wait block corresponds to the dying handle.
    // if it doesn't, just return.
    //

    if (SatisfyParameter1 != NULL &&
        SatisfyParameter1 != HandleData) {
        //DbgPrint("CookedReadWaitRoutine exit 1\n");
        return FALSE;
    }

    Console = CookedReadData->Console;

    //
    // this routine should be called by a thread owning the same
    // lock on the same console as we're reading from.
    //

    LockReadCount(HandleData);
    ASSERT(HandleData->InputReadData->ReadCount);
    HandleData->InputReadData->ReadCount -= 1;
    UnlockReadCount(HandleData);

    //
    // if ctrl-c or ctrl-break was seen, terminate read.
    //

    if ((ULONG_PTR)SatisfyParameter2 & (CONSOLE_CTRL_C_SEEN | CONSOLE_CTRL_BREAK_SEEN)) {
        if (CookedReadData->Echo) {
            CloseOutputHandle(CONSOLE_FROMTHREADPERPROCESSDATA(WaitingThread),
                              CookedReadData->Console,
                              &CookedReadData->TempHandle,
                              NULL,
                              FALSE
                             );
        }
        //DbgPrint("CookedReadWaitRoutine exit 2\n");
        WaitReplyMessage->ReturnValue = STATUS_ALERTED;
        ConsoleHeapFree(CookedReadData->BackupLimit);
        ConsoleHeapFree(CookedReadData->ExeName);
#if defined(FE_SB)
        CookedReadData->Console->lpCookedReadData = NULL;
#endif
        ConsoleHeapFree(CookedReadData);
        return TRUE;
    }

    //
    // see if called by CsrDestroyProcess or CsrDestroyThread
    // via CsrNotifyWaitBlock.   if so, just decrement the ReadCount
    // and return.
    //

    if (WaitFlags & CSR_PROCESS_TERMINATING) {
        if (CookedReadData->Echo) {
            CloseOutputHandle(CONSOLE_FROMTHREADPERPROCESSDATA(WaitingThread),
                              CookedReadData->Console,
                              &CookedReadData->TempHandle,
                              NULL,
                              FALSE
                             );
        }
        //DbgPrint("CookedReadWaitRoutine exit 3\n");
        WaitReplyMessage->ReturnValue = (ULONG)STATUS_THREAD_IS_TERMINATING;

        //
        // clean up popup data structures
        //

        CleanUpPopups(CookedReadData);
        ConsoleHeapFree(CookedReadData->BackupLimit);
        ConsoleHeapFree(CookedReadData->ExeName);
#if defined(FE_SB)
        CookedReadData->Console->lpCookedReadData = NULL;
#endif
        ConsoleHeapFree(CookedReadData);
        return TRUE;
    }

    //
    // We must see if we were woken up because the handle is being
    // closed.  if so, we decrement the read count.  if it goes to
    // zero, we wake up the close thread.  otherwise, we wake up any
    // other thread waiting for data.
    //

    if (HandleData->InputReadData->InputHandleFlags & HANDLE_CLOSING) {
        ASSERT (SatisfyParameter1 == HandleData);
        if (CookedReadData->Echo) {
            CloseOutputHandle(CONSOLE_FROMTHREADPERPROCESSDATA(WaitingThread),
                              CookedReadData->Console,
                              &CookedReadData->TempHandle,
                              NULL,
                              FALSE
                             );
        }
        //DbgPrint("CookedReadWaitRoutine exit 4\n");
        WaitReplyMessage->ReturnValue = STATUS_ALERTED;

        //
        // clean up popup data structures
        //

        CleanUpPopups(CookedReadData);
        ConsoleHeapFree(CookedReadData->BackupLimit);
        ConsoleHeapFree(CookedReadData->ExeName);
#if defined(FE_SB)
        CookedReadData->Console->lpCookedReadData = NULL;
#endif
        ConsoleHeapFree(CookedReadData);
        return TRUE;
    }

    //
    // if we get to here, this routine was called either by the input
    // thread or a write routine.  both of these callers grab the
    // current console lock.
    //

    //
    // this routine should be called by a thread owning the same
    // lock on the same console as we're reading from.
    //

    ASSERT (ConsoleLocked(Console));

    if (CookedReadData->CommandHistory) {
        PCLE_POPUP Popup;
        if (!CLE_NO_POPUPS(CookedReadData->CommandHistory)) {
            Popup = CONTAINING_RECORD( CookedReadData->CommandHistory->PopupList.Flink, CLE_POPUP, ListLink );
            Status = (Popup->PopupInputRoutine)(CookedReadData,
                                                WaitReplyMessage,
                                                WaitingThread,
                                                TRUE);
            if (Status == CONSOLE_STATUS_READ_COMPLETE ||
                (Status != CONSOLE_STATUS_WAIT &&
                 Status != CONSOLE_STATUS_WAIT_NO_BLOCK) ) {
                ConsoleHeapFree(CookedReadData->BackupLimit);
                ConsoleHeapFree(CookedReadData->ExeName);
#if defined(FE_SB)
                CookedReadData->Console->lpCookedReadData = NULL;
#endif
                ConsoleHeapFree(CookedReadData);
                return TRUE;
            }
            return FALSE;
        }
    }
    if (a->CaptureBufferSize <= BUFFER_SIZE &&
        CookedReadData->BytesRead == 0) {
        CookedReadData->UserBuffer = a->Buffer;
    }
    Status = CookedRead(CookedReadData,
                        WaitReplyMessage,
                        WaitingThread,
                        TRUE
                       );

    if (Status != CONSOLE_STATUS_WAIT) {
        return TRUE;
    } else {
        return FALSE;
    }

    //
    // satisfy the unreferenced parameter warnings.
    //

    UNREFERENCED_PARAMETER(WaitQueue);
    UNREFERENCED_PARAMETER(SatisfyParameter2);
}


NTSTATUS
ReadChars(
    IN PINPUT_INFORMATION InputInfo,
    IN PCONSOLE_INFORMATION Console,
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN OUT PWCHAR lpBuffer,
    IN OUT PDWORD NumBytes,
    IN DWORD InitialNumBytes,
    IN DWORD CtrlWakeupMask,
    IN PHANDLE_DATA HandleData,
    IN PCOMMAND_HISTORY CommandHistory,
    IN PCSR_API_MSG Message OPTIONAL,
    IN HANDLE HandleIndex,
    IN USHORT ExeNameLength,
    IN PWCHAR ExeName,
    IN BOOLEAN Unicode
    )

/*++

Routine Description:

    This routine reads in characters for stream input and does the
    required processing based on the input mode (line,char,echo).
    This routine returns UNICODE characters.

Arguments:

    InputInfo - Pointer to input buffer information.

    Console - Pointer to console buffer information.

    ScreenInfo - Pointer to screen buffer information.

    lpBuffer - Pointer to buffer to read into.

    NumBytes - On input, size of buffer.  On output, number of bytes
    read.

    HandleData - Pointer to handle data structure.

Return Value:

--*/

{
    DWORD BufferSize;
    NTSTATUS Status;
    HANDLE_DATA TempHandle;
    BOOLEAN Echo = FALSE;
    ULONG NumToWrite;
#ifdef FE_SB
    PCONSOLE_READCONSOLE_MSG a = (PCONSOLE_READCONSOLE_MSG)&Message->u.ApiMessageData;
    BOOL fAddDbcsLead = FALSE;
    ULONG NumToBytes;
#endif

    BufferSize = *NumBytes;
    *NumBytes = 0;

    if (HandleData->InputReadData->InputHandleFlags & HANDLE_INPUT_PENDING) {

        //
        // if we have leftover input, copy as much fits into the user's
        // buffer and return.  we may have multi line input, if a macro
        // has been defined that contains the $T character.
        //

        if (HandleData->InputReadData->InputHandleFlags & HANDLE_MULTI_LINE_INPUT) {
            PWSTR Tmp;
#ifdef FE_SB
            if (!Unicode && CONSOLE_IS_DBCS_CP(Console)) {

                if (HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                    fAddDbcsLead = TRUE;
                    *lpBuffer++ = HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar;
                    BufferSize--;
                    HandleData->InputReadData->BytesAvailable--;
                    RtlZeroMemory(&HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));
                }
                if (HandleData->InputReadData->BytesAvailable == 0 ||
                    BufferSize == 0) {
                    HandleData->InputReadData->InputHandleFlags &= ~(HANDLE_INPUT_PENDING | HANDLE_MULTI_LINE_INPUT);
                    ConsoleHeapFree(HandleData->InputReadData->BufPtr);
                    *NumBytes = 1;
                    return STATUS_SUCCESS;
                }
                else {
                    for (NumToWrite=0,Tmp=HandleData->InputReadData->CurrentBufPtr,NumToBytes=0;
                         NumToBytes < HandleData->InputReadData->BytesAvailable && NumToBytes < BufferSize/sizeof(WCHAR) && *Tmp!=UNICODE_LINEFEED;
                         (IsConsoleFullWidth(Console->hDC,
                                             Console->CP,*Tmp) ? NumToBytes+=2 : NumToBytes++),Tmp++,NumToWrite+=sizeof(WCHAR)) ;
                }
            }
#endif
            for (NumToWrite=0,Tmp=HandleData->InputReadData->CurrentBufPtr;
                 NumToWrite < HandleData->InputReadData->BytesAvailable && *Tmp!=UNICODE_LINEFEED;
                 Tmp++,NumToWrite+=sizeof(WCHAR)) ;
            NumToWrite += sizeof(WCHAR);
            if (NumToWrite > BufferSize) {
                NumToWrite = BufferSize;
            }
        } else {
#ifdef FE_SB
            if (!Unicode && CONSOLE_IS_DBCS_CP(Console)) {
                PWSTR Tmp;

                if (HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                    fAddDbcsLead = TRUE;
                    *lpBuffer++ = HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar;
                    BufferSize-=sizeof(WCHAR);
                    HandleData->InputReadData->BytesAvailable-=sizeof(WCHAR);
                    RtlZeroMemory(&HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));
                }
                if (HandleData->InputReadData->BytesAvailable == 0) {
                    HandleData->InputReadData->InputHandleFlags &= ~(HANDLE_INPUT_PENDING | HANDLE_MULTI_LINE_INPUT);
                    ConsoleHeapFree(HandleData->InputReadData->BufPtr);
                    *NumBytes = 1;
                    return STATUS_SUCCESS;
                }
                else {
                    for (NumToWrite=0,Tmp=HandleData->InputReadData->CurrentBufPtr,NumToBytes=0;
                         NumToBytes < HandleData->InputReadData->BytesAvailable && NumToBytes < BufferSize/sizeof(WCHAR);
                         (IsConsoleFullWidth(Console->hDC,
                                             Console->CP,*Tmp) ? NumToBytes+=2 : NumToBytes++),Tmp++,NumToWrite+=sizeof(WCHAR)) ;
                }
            }
#endif
            NumToWrite = (BufferSize < HandleData->InputReadData->BytesAvailable) ?
                          BufferSize : HandleData->InputReadData->BytesAvailable;
        }
        RtlCopyMemory(lpBuffer,HandleData->InputReadData->CurrentBufPtr,NumToWrite);
        HandleData->InputReadData->BytesAvailable-= NumToWrite;
        if (HandleData->InputReadData->BytesAvailable == 0) {
            HandleData->InputReadData->InputHandleFlags &= ~(HANDLE_INPUT_PENDING | HANDLE_MULTI_LINE_INPUT);
            ConsoleHeapFree(HandleData->InputReadData->BufPtr);
        }
        else {
            HandleData->InputReadData->CurrentBufPtr=(PWCHAR)((PBYTE)HandleData->InputReadData->CurrentBufPtr+NumToWrite);
        }
        if (!Unicode) {

            //
            // if ansi, translate string.  we allocated the capture buffer large
            // enough to handle the translated string.
            //

            PCHAR TransBuffer;

#ifdef FE_SB
            if (CONSOLE_IS_DBCS_CP(Console))
                TransBuffer = ConsoleHeapAlloc(TMP_DBCS_TAG, NumToBytes);
            else
#endif
            TransBuffer = ConsoleHeapAlloc(TMP_TAG, NumToWrite / sizeof(WCHAR));
            if (TransBuffer == NULL) {
                return STATUS_NO_MEMORY;
            }

#ifdef FE_SB
            if (CONSOLE_IS_DBCS_CP(Console))
            {
                NumToWrite = TranslateUnicodeToOem(Console,
                                                   lpBuffer,
                                                   NumToWrite / sizeof (WCHAR),
                                                   TransBuffer,
                                                   NumToBytes,
                                                   &HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte);
            }
            else
#endif
            NumToWrite = ConvertToOem(Console->CP,
                                lpBuffer,
                                NumToWrite / sizeof (WCHAR),
                                TransBuffer,
                                NumToWrite / sizeof (WCHAR)
                                );
            RtlCopyMemory(lpBuffer,TransBuffer,NumToWrite);
#ifdef FE_SB
            if (fAddDbcsLead)
                NumToWrite++;
#endif
            ConsoleHeapFree(TransBuffer);
        }
        *NumBytes = NumToWrite;
        return STATUS_SUCCESS;
    }

    //
    // we need to create a temporary handle to the current screen buffer
    // if echo is on.
    //

    if ((InputInfo->InputMode & (ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT)) ==
        (ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT)) {
        HANDLE ActiveScreenHandle;

        Echo = FALSE;
        ActiveScreenHandle = FindActiveScreenBufferHandle(ProcessData,Console);
        if (ActiveScreenHandle != INVALID_HANDLE_VALUE) {
            TempHandle.HandleType = CONSOLE_OUTPUT_HANDLE;
            TempHandle.Buffer.ScreenBuffer = Console->CurrentScreenBuffer;
            if (TempHandle.Buffer.ScreenBuffer != NULL) {
                Status = ConsoleAddShare(GENERIC_WRITE,
                                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                                         &TempHandle.Buffer.ScreenBuffer->ShareAccess,
                                         &TempHandle
                                        );
                if (NT_SUCCESS(Status)) {
                    Echo = TRUE;
                    TempHandle.Buffer.ScreenBuffer->RefCount++;
                }
            }
        }
    }

    if (InputInfo->InputMode & ENABLE_LINE_INPUT) {

        //
        // read in characters until the buffer is full or return is read.
        // since we may wait inside this loop, store all important variables
        // in the read data structure.  if we do wait, a read data structure
        // will be allocated from the heap and its pointer will be stored
        // in the wait block.  the CookedReadData will be copied into the
        // structure.  the data is freed when the read is completed.
        //

        COOKED_READ_DATA CookedReadData;
        ULONG i;
        PWCHAR TempBuffer;
        ULONG TempBufferSize;

        //
        // to emulate OS/2 KbdStringIn, we read into our own big buffer
        // (256 bytes) until the user types enter.  then return as many
        // chars as will fit in the user's buffer.
        //

        TempBufferSize = (BufferSize < LINE_INPUT_BUFFER_SIZE) ? LINE_INPUT_BUFFER_SIZE : BufferSize;
        TempBuffer = ConsoleHeapAlloc(TMP_TAG, TempBufferSize);
        if (TempBuffer==NULL) {
            if (Echo) {
                CloseOutputHandle(ProcessData,
                                  Console,
                                  &TempHandle,
                                  NULL,
                                  FALSE
                                 );
            }
            return STATUS_NO_MEMORY;
        }

        //
        // initialize the user's buffer to spaces.  this is done so that
        // moving in the buffer via cursor doesn't do strange things.
        //

        for (i=0;i<TempBufferSize/sizeof(WCHAR);i++) {
            TempBuffer[i] = (WCHAR)' ';
        }

        CookedReadData.InputInfo = InputInfo;
        CookedReadData.ScreenInfo = ScreenInfo;
        CookedReadData.Console = Console;
        CookedReadData.TempHandle.HandleType = TempHandle.HandleType;
        CookedReadData.TempHandle.Buffer.ScreenBuffer = TempHandle.Buffer.ScreenBuffer;
        CookedReadData.BufferSize = TempBufferSize;
        CookedReadData.BytesRead = 0;
        CookedReadData.CurrentPosition = 0;
        CookedReadData.BufPtr = TempBuffer;
        CookedReadData.BackupLimit = TempBuffer;
        CookedReadData.UserBufferSize = BufferSize;
        CookedReadData.UserBuffer = lpBuffer;
        CookedReadData.OriginalCursorPosition.X = -1;
        CookedReadData.OriginalCursorPosition.Y = -1;
        CookedReadData.NumberOfVisibleChars = 0;
        CookedReadData.CtrlWakeupMask = CtrlWakeupMask;
        CookedReadData.CommandHistory = CommandHistory;
        CookedReadData.Echo = Echo;
        CookedReadData.InsertMode = Console->InsertMode;
        CookedReadData.Processed = (InputInfo->InputMode & ENABLE_PROCESSED_INPUT) != 0;
        CookedReadData.Line = (InputInfo->InputMode & ENABLE_LINE_INPUT) != 0;
        CookedReadData.ProcessData = ProcessData;
        CookedReadData.HandleIndex = HandleIndex;
        CookedReadData.ExeName = ConsoleHeapAlloc(HISTORY_TAG, ExeNameLength);
        if (InitialNumBytes != 0) {
            RtlCopyMemory(CookedReadData.BufPtr, CookedReadData.UserBuffer, InitialNumBytes);
            CookedReadData.BytesRead += InitialNumBytes;
            CookedReadData.NumberOfVisibleChars = (InitialNumBytes / sizeof(WCHAR));
            CookedReadData.BufPtr += (InitialNumBytes / sizeof(WCHAR));
            CookedReadData.CurrentPosition = (InitialNumBytes / sizeof(WCHAR));
            CookedReadData.OriginalCursorPosition = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
            CookedReadData.OriginalCursorPosition.X -= (SHORT)CookedReadData.CurrentPosition;


            while (CookedReadData.OriginalCursorPosition.X < 0) {
                CookedReadData.OriginalCursorPosition.X += ScreenInfo->ScreenBufferSize.X;
                CookedReadData.OriginalCursorPosition.Y -= 1;
            }
        }
        if (CookedReadData.ExeName) {
            RtlCopyMemory(CookedReadData.ExeName,ExeName,ExeNameLength);
            CookedReadData.ExeNameLength = ExeNameLength;
        }
#ifdef FE_SB
        Console->lpCookedReadData = (PVOID)&CookedReadData;
#endif

        Status = CookedRead(&CookedReadData,
                            Message,
                            CSR_SERVER_QUERYCLIENTTHREAD(),
                            FALSE
                           );
#ifdef FE_SB
        if (Status != CONSOLE_STATUS_WAIT) {
            Console->lpCookedReadData = NULL;
        }
#endif
        return Status;
    }

    //
    // character (raw) mode
    //

    else {

        //
        // read at least one character in.  after one character has been
        // read, get any more available characters and return.  the first
        //  call to GetChar may wait.   if we do wait, a read data structure
        // will be allocated from the heap and its pointer will be stored
        // in the wait block.  the RawReadData will be copied into the
        // structure.  the data is freed when the read is completed.
        //

        RAW_READ_DATA RawReadData;

        RawReadData.InputInfo = InputInfo;
        RawReadData.Console = Console;
        RawReadData.BufferSize = BufferSize;
        RawReadData.BufPtr = lpBuffer;
        RawReadData.ProcessData = ProcessData;
        RawReadData.HandleIndex = HandleIndex;
        if (*NumBytes < BufferSize) {
            PWCHAR pwchT;

#ifdef FE_SB
            PWCHAR lpBufferTmp = lpBuffer;

            NumToWrite = 0;
            if (!Unicode && CONSOLE_IS_DBCS_CP(Console)) {
                if (HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                    fAddDbcsLead = TRUE;
                    *lpBuffer++ = HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar;
                    BufferSize-=sizeof(WCHAR);
                    RtlZeroMemory(&HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));
                    Status = STATUS_SUCCESS;
                    if (BufferSize == 0) {
                        *NumBytes = 1;
                        return STATUS_SUCCESS;
                    }
                }
                else{
                    Status = GetChar(InputInfo,
                             lpBuffer,
                             TRUE,
                             Console,
                             HandleData,
                             Message,
                             RawReadWaitRoutine,
                             &RawReadData,
                             sizeof(RawReadData),
                             FALSE,
                             NULL,
                             NULL,
                             NULL,
                             NULL
                            );
                }
            }
            else
#endif
            Status = GetChar(InputInfo,
                             lpBuffer,
                             TRUE,
                             Console,
                             HandleData,
                             Message,
                             RawReadWaitRoutine,
                             &RawReadData,
                             sizeof(RawReadData),
                             FALSE,
                             NULL,
                             NULL,
                             NULL,
                             NULL
                            );

            if (!NT_SUCCESS(Status)) {
                *NumBytes = 0;
                return Status;
            }
#ifdef FE_SB
            if (! fAddDbcsLead) {
                IsConsoleFullWidth(Console->hDC,
                                   Console->CP,*lpBuffer) ? *NumBytes+=2 : ++*NumBytes;
                NumToWrite+=sizeof(WCHAR);
                lpBuffer++;
            }
            if (CONSOLE_IS_DBCS_CP(Console)) {
                while (NumToWrite < BufferSize) {
                    Status = GetChar(InputInfo,lpBuffer,FALSE,NULL,NULL,NULL,NULL,NULL,0,FALSE,NULL,NULL,NULL,NULL);
                    if (!NT_SUCCESS(Status)) {
                        return STATUS_SUCCESS;
                    }
                    IsConsoleFullWidth(Console->hDC,
                                       Console->CP,*lpBuffer) ? *NumBytes+=2 : ++*NumBytes;
                    lpBuffer++;
                    NumToWrite+=sizeof(WCHAR);
                }
            }
            else{
#endif
            pwchT = lpBuffer + 1;
            *NumBytes += sizeof(WCHAR);
            while (*NumBytes < BufferSize) {
                Status = GetChar(InputInfo,pwchT,FALSE,NULL,NULL,NULL,NULL,NULL,0,FALSE,NULL,NULL,NULL,NULL);
                if (!NT_SUCCESS(Status)) {
                    break;
                }
                pwchT++;
                *NumBytes += sizeof(WCHAR);
            }
#ifdef FE_SB
            }
#endif

            //
            // if ansi, translate string.  we allocated the capture buffer large
            // enough to handle the translated string.
            //

            if (!Unicode) {

                PCHAR TransBuffer;

                TransBuffer = ConsoleHeapAlloc(TMP_TAG, *NumBytes / sizeof(WCHAR));
                if (TransBuffer == NULL) {
                    return STATUS_NO_MEMORY;
                }

#ifdef FE_SB
                lpBuffer = lpBufferTmp;
                if (CONSOLE_IS_DBCS_CP(Console))
                {
                    *NumBytes = TranslateUnicodeToOem(Console,
                                                      lpBuffer,
                                                      NumToWrite / sizeof (WCHAR),
                                                      TransBuffer,
                                                      *NumBytes,
                                                      &HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte);
                }
                else
#endif
                *NumBytes = ConvertToOem(Console->CP,
                                   lpBuffer,
                                   *NumBytes / sizeof (WCHAR),
                                   TransBuffer,
                                   *NumBytes / sizeof (WCHAR)
                                   );
                RtlCopyMemory(lpBuffer,TransBuffer,*NumBytes);
#ifdef FE_SB
                if (fAddDbcsLead)
                    ++*NumBytes;
#endif
                ConsoleHeapFree(TransBuffer);
            }
        }
    }
    return STATUS_SUCCESS;
}


ULONG
SrvReadConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine reads characters from the input stream.

Arguments:

    ApiMessageData - Points to parameter structure.

Return Value:

--*/

{
    PCONSOLE_READCONSOLE_MSG a = (PCONSOLE_READCONSOLE_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;
    PWCHAR Buffer;
    PCONSOLE_PER_PROCESS_DATA ProcessData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    ProcessData = CONSOLE_PERPROCESSDATA();
    Status = DereferenceIoHandle(ProcessData,
                                 a->InputHandle,
                                 CONSOLE_INPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        a->NumBytes = 0;
    } else {

        if (a->CaptureBufferSize <= BUFFER_SIZE) {
            Buffer = a->Buffer;
        }
        else {
            Buffer = a->BufPtr;
            if (!CsrValidateMessageBuffer(m, &a->BufPtr, a->CaptureBufferSize, sizeof(BYTE))) {
                UnlockConsole(Console);
                return STATUS_INVALID_PARAMETER;
            }
        }

#if defined(FE_SB)
        Console->ReadConInpNumBytesTemp = a->NumBytes / sizeof(WCHAR);
#endif
        Status = ReadChars(HandleData->Buffer.InputBuffer,
                           Console,
                           ProcessData,
                           Console->CurrentScreenBuffer,
                           Buffer,
                           &a->NumBytes,
                           a->InitialNumBytes,
                           a->CtrlWakeupMask,
                           HandleData,
                           FindCommandHistory(Console,CONSOLE_CLIENTPROCESSHANDLE()),
                           m,
                           HANDLE_TO_INDEX(a->InputHandle),
                           a->ExeNameLength,
                           a->Buffer,
                           a->Unicode
                          );
        if (Status == CONSOLE_STATUS_WAIT) {
            *ReplyStatus = CsrReplyPending;
        }
    }

    UnlockConsole(Console);
    return Status;
}


VOID
MakeCursorVisible(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD CursorPosition
    )
{
    COORD WindowOrigin;
    NTSTATUS Status;

    WindowOrigin.X = 0;
    WindowOrigin.Y = 0;
    if (CursorPosition.X > ScreenInfo->Window.Right) {
        WindowOrigin.X = CursorPosition.X - ScreenInfo->Window.Right;
    } else if (CursorPosition.X < ScreenInfo->Window.Left) {
        WindowOrigin.X = CursorPosition.X - ScreenInfo->Window.Left;
    }

    if (CursorPosition.Y > ScreenInfo->Window.Bottom) {
        WindowOrigin.Y = CursorPosition.Y - ScreenInfo->Window.Bottom;
    } else if (CursorPosition.Y < ScreenInfo->Window.Top) {
        WindowOrigin.Y = CursorPosition.Y - ScreenInfo->Window.Top;
    }

    if (WindowOrigin.X != 0 || WindowOrigin.Y != 0) {
        Status = SetWindowOrigin(ScreenInfo,
                               FALSE,
                               WindowOrigin
                              );
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }
}

#define WRITE_NO_CR_LF 0
#define WRITE_CR 1
#define WRITE_CR_LF 2
#define WRITE_SPECIAL_CHARS 4
#define WRITE_UNICODE_CRLF 0x000a000d

DWORD
FastStreamWrite(
    IN PWCHAR lpString,
    IN DWORD NumChars
    )

/*++

Routine Description:

    This routine determines whether the text string contains characters
    that require special processing.  If it doesn't,
    unicode characters.  The string is also copied to the input buffer, if
    the output mode is line mode.

Arguments:

    lpString - Pointer to string to write.

    NumChars - Number of chars in buffer.

Return Value:

    WRITE_SPECIAL_CHARS - string contains characters requiring special processing

    WRITE_NO_CR_LF - string contains no special chars and no CRLF

    WRITE_CR_LF - string contains no special chars and is terminated by CRLF

    WRITE_CR - string contains no special chars and is terminated by CR

--*/

{
    DWORD UNALIGNED *Tmp;
    register PWCHAR StrPtr=lpString;
    while (NumChars) {
        if (*StrPtr < UNICODE_SPACE) {
            Tmp = (PDWORD)StrPtr;
            if (NumChars == 2 &&
                *Tmp == WRITE_UNICODE_CRLF) {
                return WRITE_CR_LF;
            } else if (NumChars == 1 &&
                *StrPtr == (WCHAR)'\r') {
                return WRITE_CR;
            } else {
                return WRITE_SPECIAL_CHARS;
            }
        }
        StrPtr++;
        NumChars--;
    }
    return WRITE_NO_CR_LF;
}

VOID UnblockWriteConsole(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD Reason)
{
    Console->Flags &= ~Reason;

    if ((Console->Flags & (CONSOLE_SUSPENDED | CONSOLE_SELECTING | CONSOLE_SCROLLBAR_TRACKING)) == 0) {
        /*
         * no remain reason to suspend output, so unblock it.
         */
        if (CsrNotifyWait(&Console->OutputQueue, TRUE, NULL, NULL)) {
            // #334370 under stress, WaitQueue may already hold the satisfied waits
            ASSERT ((Console->WaitQueue == NULL) ||
                    (Console->WaitQueue == &Console->OutputQueue));
            Console->WaitQueue = &Console->OutputQueue;
        }
    }
}


ULONG
SrvWriteConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine writes characters to the output stream.

Arguments:

    ApiMessageData - Points to parameter structure.

Return Value:

--*/

{
    NTSTATUS Status;
    PCONSOLE_WRITECONSOLE_MSG a = (PCONSOLE_WRITECONSOLE_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!a->BufferInMessage) {
        if (!CsrValidateMessageBuffer(m, &a->BufPtr, a->NumBytes, sizeof(BYTE))) {
            UnlockConsole(Console);
            return STATUS_INVALID_PARAMETER;
        }
    }
    else if (a->NumBytes > sizeof(a->Buffer)) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }


    //
    // Make sure we have a valid screen buffer.
    //

    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        UnlockConsole(Console);
        return Status;
    }

    Status = DoSrvWriteConsole(m,ReplyStatus,Console,HandleData);

    UnlockConsole(Console);
    return Status;
}

BOOLEAN
WriteConsoleWaitRoutine(
    IN PLIST_ENTRY WaitQueue,
    IN PCSR_THREAD WaitingThread,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PVOID WaitParameter,
    IN PVOID SatisfyParameter1,
    IN PVOID SatisfyParameter2,
    IN ULONG WaitFlags
    )
{
    NTSTATUS Status;
    PCONSOLE_WRITECONSOLE_MSG a = (PCONSOLE_WRITECONSOLE_MSG)&WaitReplyMessage->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;

    if (WaitFlags & CSR_PROCESS_TERMINATING) {
        WaitReplyMessage->ReturnValue = (ULONG)STATUS_THREAD_IS_TERMINATING;
        return TRUE;
    }
    LockConsoleHandleTable();
    Status = DereferenceConsoleHandle(a->ConsoleHandle,
                                      &Console
                                     );
    UnlockConsoleHandleTable();
    ASSERT (NT_SUCCESS(Status));

    //
    // if we get to here, this routine was called by the input
    // thread, which grabs the current console lock.
    //

    //
    // this routine should be called by a thread owning the same
    // lock on the same console as we're reading from.
    //

    ASSERT (ConsoleLocked(Console));

    //
    // if we're unicode, the string may still be in the message buffer.
    // since the message was reallocated and copied when the wait was
    // created, we need to fix up a->TransBuffer here.
    //

    if (a->Unicode && a->BufferInMessage) {
        a->TransBuffer = a->Buffer;
    }

    Status = DoWriteConsole(WaitReplyMessage,Console,WaitingThread);
    if (Status == CONSOLE_STATUS_WAIT) {
        return FALSE;
    }
    if (!a->Unicode) {
#ifdef FE_SB
        if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        {
            if (a->NumBytes == Console->WriteConOutNumBytesUnicode)
                a->NumBytes = Console->WriteConOutNumBytesTemp;
            else
                a->NumBytes /= sizeof(WCHAR);
            }
        else
#endif
        a->NumBytes /= sizeof(WCHAR);
        ConsoleHeapFree(a->TransBuffer);
    }
    WaitReplyMessage->ReturnValue = Status;
    return TRUE;
    UNREFERENCED_PARAMETER(WaitQueue);
    UNREFERENCED_PARAMETER(WaitParameter);
    UNREFERENCED_PARAMETER(SatisfyParameter1);
    UNREFERENCED_PARAMETER(SatisfyParameter2);
}

ULONG
SrvDuplicateHandle(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine duplicates an input or output handle.

Arguments:

    ApiMessageData - Points to parameter structure.

Return Value:

--*/

{
    PCONSOLE_DUPHANDLE_MSG a = (PCONSOLE_DUPHANDLE_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA SourceHandleData,TargetHandleData;
    PCONSOLE_SHARE_ACCESS ShareAccess;
    NTSTATUS Status;
    PCONSOLE_PER_PROCESS_DATA ProcessData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    ProcessData = CONSOLE_PERPROCESSDATA();
    Status = DereferenceIoHandleNoCheck(ProcessData,
                                 HANDLE_TO_INDEX(a->SourceHandle),
                                 &SourceHandleData
                                );
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }
    if (a->Options & DUPLICATE_SAME_ACCESS) {
        a->DesiredAccess = SourceHandleData->Access;
    }

    //
    // make sure that requested access is a subset of source handle's access
    //

    else if ((a->DesiredAccess & SourceHandleData->Access) != a->DesiredAccess) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }
    Status = AllocateIoHandle(ProcessData,
                              SourceHandleData->HandleType,
                              &a->TargetHandle
                             );
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    //
    // it's possible that AllocateIoHandle realloced the handle table,
    // so deference SourceHandle again.
    //

    Status = DereferenceIoHandleNoCheck(ProcessData,
                                 HANDLE_TO_INDEX(a->SourceHandle),
                                 &SourceHandleData
                                );
    ASSERT (NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }
    Status = DereferenceIoHandleNoCheck(ProcessData,
                                 a->TargetHandle,
                                 &TargetHandleData
                                );
    ASSERT (NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        FreeIoHandle(ProcessData,
                     a->TargetHandle
                    );
        goto exit;
    }
    if (SourceHandleData->HandleType & CONSOLE_INPUT_HANDLE) {
        // grab input lock
        if (!InitializeInputHandle(TargetHandleData,
                                   SourceHandleData->Buffer.InputBuffer)) {
            FreeIoHandle(ProcessData,
                         a->TargetHandle
                        );
            Status = STATUS_NO_MEMORY;
            goto exit;
        }
        ShareAccess = &SourceHandleData->Buffer.InputBuffer->ShareAccess;
    }
    else {
        // grab output lock
        InitializeOutputHandle(TargetHandleData,SourceHandleData->Buffer.ScreenBuffer);
        ShareAccess = &SourceHandleData->Buffer.ScreenBuffer->ShareAccess;
    }
    TargetHandleData->HandleType = SourceHandleData->HandleType;
    if (a->InheritHandle) {
        TargetHandleData->HandleType |= CONSOLE_INHERITABLE;
    } else {
        TargetHandleData->HandleType &= ~CONSOLE_INHERITABLE;
    }

    Status = ConsoleDupShare(a->DesiredAccess,
                             SourceHandleData->ShareAccess,
                             ShareAccess,
                             TargetHandleData
                            );
    if (!NT_SUCCESS(Status)) {
        FreeIoHandle(ProcessData,
                     a->TargetHandle
                    );
        if (SourceHandleData->HandleType & CONSOLE_INPUT_HANDLE) {
            SourceHandleData->Buffer.InputBuffer->RefCount--;
        }
        else {
            SourceHandleData->Buffer.ScreenBuffer->RefCount--;
        }
    }
    else {
        a->TargetHandle = INDEX_TO_HANDLE(a->TargetHandle);
    }

    if (a->Options & DUPLICATE_CLOSE_SOURCE) {
        if (SourceHandleData->HandleType & CONSOLE_INPUT_HANDLE)
            CloseInputHandle(ProcessData,Console,SourceHandleData,HANDLE_TO_INDEX(a->SourceHandle));
        else {
            CloseOutputHandle(ProcessData,Console,SourceHandleData,HANDLE_TO_INDEX(a->SourceHandle),TRUE);
        }
    }

exit:
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

ULONG
SrvGetHandleInformation(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This gets information about an input or output handle.

Arguments:

    ApiMessageData - Points to parameter structure.

Return Value:

--*/

{
    PCONSOLE_GETHANDLEINFORMATION_MSG a = (PCONSOLE_GETHANDLEINFORMATION_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandleNoCheck(CONSOLE_PERPROCESSDATA(),
                                 HANDLE_TO_INDEX(a->Handle),
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        a->Flags = 0;
        if (HandleData->HandleType & CONSOLE_INHERITABLE) {
            a->Flags |= HANDLE_FLAG_INHERIT;
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

ULONG
SrvSetHandleInformation(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This sets information about an input or output handle.

Arguments:

    ApiMessageData - Points to parameter structure.

Return Value:

--*/

{
    PCONSOLE_SETHANDLEINFORMATION_MSG a = (PCONSOLE_SETHANDLEINFORMATION_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandleNoCheck(CONSOLE_PERPROCESSDATA(),
                                 HANDLE_TO_INDEX(a->Handle),
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        if (a->Mask & HANDLE_FLAG_INHERIT) {
            if (a->Flags & HANDLE_FLAG_INHERIT) {
                HandleData->HandleType |= CONSOLE_INHERITABLE;
            } else {
                HandleData->HandleType &= ~CONSOLE_INHERITABLE;
            }
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

NTSTATUS
CloseInputHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData,
    IN HANDLE Handle
    )

/*++

Routine Description:

    This routine closes an input handle.  It decrements the input buffer's
    reference count.  If it goes to zero, the buffer is reinitialized.
    Otherwise, the handle is removed from sharing.

Arguments:

    ProcessData - Pointer to per process data.

    HandleData - Pointer to handle data structure.

    Handle - Handle to close.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    BOOLEAN WaitSatisfied = FALSE;

    if (HandleData->InputReadData->InputHandleFlags & HANDLE_INPUT_PENDING) {
        HandleData->InputReadData->InputHandleFlags &= ~HANDLE_INPUT_PENDING;
        ConsoleHeapFree(HandleData->InputReadData->BufPtr);
    }

    //
    // see if there are any reads waiting for data via this handle.  if
    // there are, wake them up.  there aren't any other outstanding i/o
    // operations via this handle because the console lock is held.
    //

    LockReadCount(HandleData);
    if (HandleData->InputReadData->ReadCount != 0) {
        UnlockReadCount(HandleData);
        HandleData->InputReadData->InputHandleFlags |= HANDLE_CLOSING;

        WaitSatisfied |= CsrNotifyWait(&HandleData->Buffer.InputBuffer->ReadWaitQueue,
                      TRUE,
                      (PVOID) HandleData,
                      NULL
                     );
        LockReadCount(HandleData);
    }
    if (WaitSatisfied) {
        // #334370 under stress, WaitQueue may already hold the satisfied waits
        ASSERT ((Console->WaitQueue == NULL) ||
                (Console->WaitQueue == &HandleData->Buffer.InputBuffer->ReadWaitQueue));
        Console->WaitQueue = &HandleData->Buffer.InputBuffer->ReadWaitQueue;
    }
    if (HandleData->InputReadData->ReadCount != 0) {
        KdPrint(("ReadCount is %lX\n",HandleData->InputReadData->ReadCount));
    }
    ASSERT (HandleData->InputReadData->ReadCount == 0);
    UnlockReadCount(HandleData);

    ASSERT (HandleData->Buffer.InputBuffer->RefCount);
    HandleData->Buffer.InputBuffer->RefCount--;
    if (HandleData->Buffer.InputBuffer->RefCount == 0) {
        ReinitializeInputBuffer(HandleData->Buffer.InputBuffer);
    }
    else {
        ConsoleRemoveShare(HandleData->Access,
                           HandleData->ShareAccess,
                           &HandleData->Buffer.InputBuffer->ShareAccess
                          );
    }
    return FreeIoHandle(ProcessData,Handle);
}

NTSTATUS
CloseOutputHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData,
    IN HANDLE Handle,
    IN BOOLEAN FreeHandle
    )

/*++

Routine Description:

    This routine closes an output handle.  It decrements the screen buffer's
    reference count.  If it goes to zero, the buffer is freed.  Otherwise,
    the handle is removed from sharing.

Arguments:

    ProcessData - Pointer to per process data.

    Console - Pointer to console information structure.

    HandleData - Pointer to handle data structure.

    Handle - Handle to close.

    FreeHandle - if TRUE, free handle.  used by ReadChars in echo mode
    and by process cleanup.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    NTSTATUS Status;

    ASSERT (HandleData->Buffer.ScreenBuffer->RefCount);
    HandleData->Buffer.ScreenBuffer->RefCount--;
    if (HandleData->Buffer.ScreenBuffer->RefCount == 0) {
        RemoveScreenBuffer(Console,HandleData->Buffer.ScreenBuffer);
        if (HandleData->Buffer.ScreenBuffer == Console->CurrentScreenBuffer &&
            Console->ScreenBuffers != Console->CurrentScreenBuffer) {
            if (Console->ScreenBuffers != NULL) {
                SetActiveScreenBuffer(Console->ScreenBuffers);
            } else {
                Console->CurrentScreenBuffer = NULL;
            }
        }
        Status = FreeScreenBuffer(HandleData->Buffer.ScreenBuffer);
    }
    else {
        Status = ConsoleRemoveShare(HandleData->Access,
                                    HandleData->ShareAccess,
                                    &HandleData->Buffer.ScreenBuffer->ShareAccess
                                   );
    }
    if (FreeHandle)
        Status = FreeIoHandle(ProcessData,Handle);
    return Status;
}


ULONG
SrvCloseHandle(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine closes an input or output handle.

Arguments:

    ApiMessageData - Points to parameter structure.

Return Value:

--*/

{
    PCONSOLE_CLOSEHANDLE_MSG a = (PCONSOLE_CLOSEHANDLE_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;
    PCONSOLE_PER_PROCESS_DATA ProcessData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    ProcessData = CONSOLE_PERPROCESSDATA();
    Status = DereferenceIoHandleNoCheck(ProcessData,
                                 HANDLE_TO_INDEX(a->Handle),
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        if (HandleData->HandleType & CONSOLE_INPUT_HANDLE)
            Status = CloseInputHandle(ProcessData,Console,HandleData,HANDLE_TO_INDEX(a->Handle));
        else {
            Status = CloseOutputHandle(ProcessData,Console,HandleData,HANDLE_TO_INDEX(a->Handle),TRUE);
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

NTSTATUS
WriteCharsFromInput(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PWCHAR lpBufferBackupLimit,
    IN PWCHAR lpBuffer,
    IN PWCHAR lpString,
    IN OUT PDWORD NumBytes,
    OUT PLONG NumSpaces OPTIONAL,
    IN SHORT OriginalXPosition,
    IN DWORD dwFlags,
    OUT PSHORT ScrollY OPTIONAL
    )

/*++

Routine Description:

    This routine converts chars from their true unicode representation
    to the Unicode representation (UnicodeAnsi) that will generate
    the correct glyph given an OEM font and an ANSI translation by GDI.
    It then calls WriteChars.

Arguments:

    ScreenInfo - Pointer to screen buffer information structure.

    lpBufferBackupLimit - Pointer to beginning of buffer.

    lpBuffer - Pointer to buffer to copy string to.  assumed to be at least
    as long as lpString.  This pointer is updated to point to the next
    position in the buffer.

    lpString - Pointer to string to write.

    NumBytes - On input, number of bytes to write.  On output, number of
    bytes written.

    NumSpaces - On output, the number of spaces consumed by the written characters.

    dwFlags -
      WC_DESTRUCTIVE_BACKSPACE backspace overwrites characters.
      WC_KEEP_CURSOR_VISIBLE   change window origin desirable when hit rt. edge
      WC_ECHO                  if called by Read (echoing characters)
      WC_FALSIFY_UNICODE       if RealUnicodeToFalseUnicode need be called.

Return Value:

Note:

    This routine does not process tabs and backspace properly.  That code
    will be implemented as part of the line editing services.

--*/

{
    DWORD Length,i;

    if (ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER) {
        return STATUS_UNSUCCESSFUL;
    }

    if (!(ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) ||
            (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
        goto SimpleWrite;
    }

    Length = *NumBytes / sizeof(WCHAR);
    for (i=0;i<Length;i++) {
        if (lpString[i] > 0x7f) {
            dwFlags |= WC_FALSIFY_UNICODE;
            break;
        }
    }

SimpleWrite:
    return WriteChars(ScreenInfo,
                    lpBufferBackupLimit,
                    lpBuffer,
                    lpString,
                    NumBytes,
                    NumSpaces,
                    OriginalXPosition,
                    dwFlags,
                    ScrollY
                   );
}

#if defined(FE_SB)

#define WWSB_NOFE
#include "dispatch.h"
#include "_stream.h"
#undef  WWSB_NOFE
#define WWSB_FE
#include "dispatch.h"
#include "_stream.h"
#undef  WWSB_FE

#endif // FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\_output.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    _output.h

Abstract:

    Performance critical routine for Single Binary

    Each function will be created with two flavors FE and non FE

Author:

    KazuM Jun.11.1997

Revision History:

--*/

#define WWSB_NEUTRAL_FILE 1

#if !defined(FE_SB)
#error This header file should be included with FE_SB
#endif

#if !defined(WWSB_FE) && !defined(WWSB_NOFE)
#error Either WWSB_FE and WWSB_NOFE must be defined.
#endif

#if defined(WWSB_FE) && defined(WWSB_NOFE)
#error Both WWSB_FE and WWSB_NOFE defined.
#endif

#include "dispatch.h"

#if defined(WWSB_FE)
#pragma alloc_text(FE_TEXT, FE_StreamWriteToScreenBuffer)
#pragma alloc_text(FE_TEXT, FE_WriteRectToScreenBuffer)
#pragma alloc_text(FE_TEXT, FE_WriteRegionToScreen)
#pragma alloc_text(FE_TEXT, FE_WriteToScreen)
#pragma alloc_text(FE_TEXT, FE_WriteOutputString)
#pragma alloc_text(FE_TEXT, FE_FillOutput)
#pragma alloc_text(FE_TEXT, FE_FillRectangle)
#pragma alloc_text(FE_TEXT, FE_PolyTextOutCandidate)
#pragma alloc_text(FE_TEXT, FE_ConsolePolyTextOut)
#endif


#if defined(WWSB_NOFE)
VOID
SB_StreamWriteToScreenBuffer(
    IN PWCHAR String,
    IN SHORT StringLength,
    IN PSCREEN_INFORMATION ScreenInfo
    )
#else
VOID
FE_StreamWriteToScreenBuffer(
    IN PWCHAR String,
    IN SHORT StringLength,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCHAR StringA
    )
#endif
{
    SHORT RowIndex;
    PROW Row;
    PWCHAR Char;
    COORD TargetPoint;

    DBGOUTPUT(("StreamWriteToScreenBuffer\n"));
#ifdef WWSB_FE
    ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
#endif
    ScreenInfo->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;
    TargetPoint = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetPoint.Y) % ScreenInfo->ScreenBufferSize.Y;
    Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
    DBGOUTPUT(("RowIndex = %x, Row = %x, TargetPoint = (%x,%x)\n",
            RowIndex, Row, TargetPoint.X, TargetPoint.Y));

    //
    // copy chars
    //
#ifdef WWSB_FE
    BisectWrite(StringLength,TargetPoint,ScreenInfo);
    if (TargetPoint.Y == ScreenInfo->ScreenBufferSize.Y-1 &&
        TargetPoint.X+StringLength >= ScreenInfo->ScreenBufferSize.X &&
        *(StringA+ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) & ATTR_LEADING_BYTE
       ) {
        *(String+ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) = UNICODE_SPACE;
        *(StringA+ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) = 0;
        if (StringLength > ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) {
            *(String+ScreenInfo->ScreenBufferSize.X-TargetPoint.X) = UNICODE_SPACE;
            *(StringA+ScreenInfo->ScreenBufferSize.X-TargetPoint.X) = 0;
        }
    }

    RtlCopyMemory(&Row->CharRow.KAttrs[TargetPoint.X],StringA,StringLength*sizeof(CHAR));
#endif

    RtlCopyMemory(&Row->CharRow.Chars[TargetPoint.X],String,StringLength*sizeof(WCHAR));

    // recalculate first and last non-space char

    Row->CharRow.OldLeft = Row->CharRow.Left;
    if (TargetPoint.X < Row->CharRow.Left) {
        PWCHAR LastChar = &Row->CharRow.Chars[ScreenInfo->ScreenBufferSize.X];

        for (Char=&Row->CharRow.Chars[TargetPoint.X];Char < LastChar && *Char==(WCHAR)' ';Char++)
            ;
        Row->CharRow.Left = (SHORT)(Char-Row->CharRow.Chars);
    }

    Row->CharRow.OldRight = Row->CharRow.Right;
    if ((TargetPoint.X+StringLength) >= Row->CharRow.Right) {
        PWCHAR FirstChar = Row->CharRow.Chars;

        for (Char=&Row->CharRow.Chars[TargetPoint.X+StringLength-1];*Char==(WCHAR)' ' && Char >= FirstChar;Char--)
            ;
        Row->CharRow.Right = (SHORT)(Char+1-FirstChar);
    }

    //
    // see if attr string is different.  if so, allocate a new
    // attr buffer and merge the two strings.
    //

    if (Row->AttrRow.Length != 1 ||
        Row->AttrRow.Attrs->Attr != ScreenInfo->Attributes) {
        PATTR_PAIR NewAttrs;
        WORD NewAttrsLength;
        ATTR_PAIR Attrs;

        Attrs.Length = StringLength;
        Attrs.Attr = ScreenInfo->Attributes;
        if (!NT_SUCCESS(MergeAttrStrings(Row->AttrRow.Attrs,
                         Row->AttrRow.Length,
                         &Attrs,
                         1,
                         &NewAttrs,
                         &NewAttrsLength,
                         TargetPoint.X,
                         (SHORT)(TargetPoint.X+StringLength-1),
                         Row,
                         ScreenInfo
                        ))) {
            return;
        }
        if (Row->AttrRow.Length > 1) {
            ConsoleHeapFree(Row->AttrRow.Attrs);
        }
        else {
            ASSERT(Row->AttrRow.Attrs == &Row->AttrRow.AttrPair);
        }
        Row->AttrRow.Attrs = NewAttrs;
        Row->AttrRow.Length = NewAttrsLength;
        Row->CharRow.OldLeft = INVALID_OLD_LENGTH;
        Row->CharRow.OldRight = INVALID_OLD_LENGTH;
    }
    ResetTextFlags(ScreenInfo,
                   TargetPoint.X,
                   TargetPoint.Y,
                   TargetPoint.X + StringLength - 1,
                   TargetPoint.Y);
}


#define CHAR_OF_PCI(p)  (((PCHAR_INFO)(p))->Char.AsciiChar)
#define WCHAR_OF_PCI(p) (((PCHAR_INFO)(p))->Char.UnicodeChar)
#define ATTR_OF_PCI(p)  (((PCHAR_INFO)(p))->Attributes)
#define SIZEOF_CI_CELL  sizeof(CHAR_INFO)

#define CHAR_OF_VGA(p)  (p[0])
#define ATTR_OF_VGA(p)  (p[1])
#ifdef i386
#define SIZEOF_VGA_CELL 2
#else // risc
#define SIZEOF_VGA_CELL 4
#endif


#define COMMON_LVB_MASK        0x33
#define ATTR_OF_COMMON_LVB(p)  (ATTR_OF_VGA(p) + (((p[2] & ~COMMON_LVB_MASK)) << 8))
#define SIZEOF_COMMON_LVB_CELL 4

VOID
WWSB_WriteRectToScreenBuffer(
    PBYTE Source,
    COORD SourceSize,
    PSMALL_RECT SourceRect,
    PSCREEN_INFORMATION ScreenInfo,
    COORD TargetPoint,
    IN UINT Codepage
    )

/*++

Routine Description:

    This routine copies a rectangular region to the screen buffer.
    no clipping is done.

    The source should contain Unicode or UnicodeOem chars.

Arguments:

    Source - pointer to source buffer (a real VGA buffer or CHAR_INFO[])

    SourceSize - dimensions of source buffer

    SourceRect - rectangle in source buffer to copy

    ScreenInfo - pointer to screen info

    TargetPoint - upper left coordinates of target rectangle

    Codepage - codepage to translate real VGA buffer from,
               0xFFFFFFF if Source is CHAR_INFO[] (not requiring translation)
Return Value:

    none.

--*/

{

    PBYTE SourcePtr;
    SHORT i,j;
    SHORT XSize,YSize;
    BOOLEAN WholeSource;
    SHORT RowIndex;
    PROW Row;
    PWCHAR Char;
    ATTR_PAIR Attrs[80];
    PATTR_PAIR AttrBuf;
    PATTR_PAIR Attr;
    SHORT AttrLength;
    BOOL bVGABuffer;
    ULONG ulCellSize;
#ifdef WWSB_FE
    PCHAR AttrP;
#endif

    DBGOUTPUT(("WriteRectToScreenBuffer\n"));
#ifdef WWSB_FE
    ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
#endif

    ScreenInfo->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;
    XSize = (SHORT)(SourceRect->Right - SourceRect->Left + 1);
    YSize = (SHORT)(SourceRect->Bottom - SourceRect->Top + 1);


    AttrBuf = Attrs;
    if (XSize > 80) {
        AttrBuf = ConsoleHeapAlloc(TMP_TAG, XSize * sizeof(ATTR_PAIR));
        if (AttrBuf == NULL) {
            return;
        }
    }

    bVGABuffer = (Codepage != 0xFFFFFFFF);
    if (bVGABuffer) {
#ifdef WWSB_FE
        ulCellSize = (ScreenInfo->Console->fVDMVideoMode) ? SIZEOF_COMMON_LVB_CELL : SIZEOF_VGA_CELL;
#else
        ulCellSize = SIZEOF_VGA_CELL;
#endif
    } else {
        ulCellSize = SIZEOF_CI_CELL;
    }

    SourcePtr = Source;

    WholeSource = FALSE;
    if (XSize == SourceSize.X) {
        ASSERT (SourceRect->Left == 0);
        if (SourceRect->Top != 0) {
            SourcePtr += SCREEN_BUFFER_POINTER(SourceRect->Left,
                                               SourceRect->Top,
                                               SourceSize.X,
                                               ulCellSize);
        }
        WholeSource = TRUE;
    }
    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetPoint.Y) % ScreenInfo->ScreenBufferSize.Y;
    for (i=0;i<YSize;i++) {
        if (!WholeSource) {
            SourcePtr = Source + SCREEN_BUFFER_POINTER(SourceRect->Left,
                                                       SourceRect->Top+i,
                                                       SourceSize.X,
                                                       ulCellSize);
        }

        //
        // copy the chars and attrs into their respective arrays
        //

#ifdef WWSB_FE
        if (! bVGABuffer) {
            COORD TPoint;

            TPoint.X = TargetPoint.X;
            TPoint.Y = TargetPoint.Y + i;
            BisectWrite(XSize,TPoint,ScreenInfo);
            if (TPoint.Y == ScreenInfo->ScreenBufferSize.Y-1 &&
                TPoint.X+XSize-1 >= ScreenInfo->ScreenBufferSize.X &&
                ATTR_OF_PCI(SourcePtr+ScreenInfo->ScreenBufferSize.X-TPoint.X-1) & COMMON_LVB_LEADING_BYTE)
            {
                WCHAR_OF_PCI(SourcePtr+ScreenInfo->ScreenBufferSize.X-TPoint.X-1) = UNICODE_SPACE;
                ATTR_OF_PCI(SourcePtr+ScreenInfo->ScreenBufferSize.X-TPoint.X-1) &= ~COMMON_LVB_SBCSDBCS;
                if (XSize-1 > ScreenInfo->ScreenBufferSize.X-TPoint.X-1) {
                    WCHAR_OF_PCI(SourcePtr+ScreenInfo->ScreenBufferSize.X-TPoint.X) = UNICODE_SPACE;
                    ATTR_OF_PCI(SourcePtr+ScreenInfo->ScreenBufferSize.X-TPoint.X) &= ~COMMON_LVB_SBCSDBCS;
                }
            }
        }
#endif

        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
        Char = &Row->CharRow.Chars[TargetPoint.X];
#ifdef WWSB_FE
        AttrP = &Row->CharRow.KAttrs[TargetPoint.X];
#endif
        Attr = AttrBuf;
        Attr->Length = 0;
        AttrLength = 1;

        /*
         * Two version of the following loop to keep it fast:
         * one for VGA buffers, one for CHAR_INFO buffers.
         */
        if (bVGABuffer) {
#ifdef WWSB_FE
            Attr->Attr = (ScreenInfo->Console->fVDMVideoMode) ? ATTR_OF_COMMON_LVB(SourcePtr) : ATTR_OF_VGA(SourcePtr);
#else
            Attr->Attr = ATTR_OF_VGA(SourcePtr);
#endif
            for (j = SourceRect->Left;
                    j <= SourceRect->Right;
                    j++,
#ifdef WWSB_FE
                    SourcePtr += (ScreenInfo->Console->fVDMVideoMode) ? SIZEOF_COMMON_LVB_CELL : SIZEOF_VGA_CELL
#else
                    SourcePtr += SIZEOF_VGA_CELL
#endif
                ) {

#ifdef WWSB_FE
                UCHAR TmpBuff[2];

                if (IsDBCSLeadByteConsole(CHAR_OF_VGA(SourcePtr),&ScreenInfo->Console->OutputCPInfo)) {
                    if (j+1 > SourceRect->Right) {
                        *Char = UNICODE_SPACE;
                        *AttrP = 0;
                    }
                    else {
                        TmpBuff[0] = CHAR_OF_VGA(SourcePtr);
                        TmpBuff[1] = CHAR_OF_VGA((SourcePtr + ((ScreenInfo->Console->fVDMVideoMode) ? SIZEOF_COMMON_LVB_CELL : SIZEOF_VGA_CELL)));
                        ConvertOutputToUnicode(Codepage,
                                               TmpBuff,
                                               2,
                                               Char,
                                               2);
                        Char++;
                        j++;
                        *AttrP++ = ATTR_LEADING_BYTE;
                        *Char++ = *(Char-1);
                        *AttrP++ = ATTR_TRAILING_BYTE;

                        if (ScreenInfo->Console->fVDMVideoMode) {
                            if (Attr->Attr == ATTR_OF_COMMON_LVB(SourcePtr)) {
                                Attr->Length += 1;
                            }
                            else {
                                Attr++;
                                Attr->Length = 1;
                                Attr->Attr = ATTR_OF_COMMON_LVB(SourcePtr);
                                AttrLength += 1;
                            }
                        }
                        else
                        {
                            if (Attr->Attr == ATTR_OF_VGA(SourcePtr)) {
                                Attr->Length += 1;
                            }
                            else {
                                Attr++;
                                Attr->Length = 1;
                                Attr->Attr = ATTR_OF_VGA(SourcePtr);
                                AttrLength += 1;
                            }
                        }

                        SourcePtr += (ScreenInfo->Console->fVDMVideoMode) ? SIZEOF_COMMON_LVB_CELL : SIZEOF_VGA_CELL;
                    }
                }
                else {
                    ConvertOutputToUnicode(Codepage,
                                           &CHAR_OF_VGA(SourcePtr),
                                           1,
                                           Char,
                                           1);
                    Char++;
                    *AttrP++ = 0;
                }
#else
                *Char++ = SB_CharToWcharGlyph(Codepage, CHAR_OF_VGA(SourcePtr));
#endif

#ifdef WWSB_FE
                if (ScreenInfo->Console->fVDMVideoMode) {
                    if (Attr->Attr == ATTR_OF_COMMON_LVB(SourcePtr)) {
                        Attr->Length += 1;
                    }
                    else {
                        Attr++;
                        Attr->Length = 1;
                        Attr->Attr = ATTR_OF_COMMON_LVB(SourcePtr);
                        AttrLength += 1;
                    }
                }
                else
#endif
                if (Attr->Attr == ATTR_OF_VGA(SourcePtr)) {
                    Attr->Length += 1;
                }
                else {
                    Attr++;
                    Attr->Length = 1;
                    Attr->Attr = ATTR_OF_VGA(SourcePtr);
                    AttrLength += 1;
                }
            }
        } else {
#ifdef WWSB_FE
            Attr->Attr = ATTR_OF_PCI(SourcePtr) & ~COMMON_LVB_SBCSDBCS;
#else
            Attr->Attr = ATTR_OF_PCI(SourcePtr);
#endif
            for (j = SourceRect->Left;
                    j <= SourceRect->Right;
                    j++, SourcePtr += SIZEOF_CI_CELL) {

                *Char++ = WCHAR_OF_PCI(SourcePtr);
#ifdef WWSB_FE
                // MSKK Apr.02.1993 V-HirotS For KAttr
                *AttrP++ = (CHAR)((ATTR_OF_PCI(SourcePtr) & COMMON_LVB_SBCSDBCS) >>8);
#endif

#ifdef WWSB_FE
                if (Attr->Attr == (ATTR_OF_PCI(SourcePtr) & ~COMMON_LVB_SBCSDBCS))
#else
                if (Attr->Attr == ATTR_OF_PCI(SourcePtr))
#endif
                {
                    Attr->Length += 1;
                }
                else {
                    Attr++;
                    Attr->Length = 1;
#ifdef WWSB_FE
                    // MSKK Apr.02.1993 V-HirotS For KAttr
                    Attr->Attr = ATTR_OF_PCI(SourcePtr) & ~COMMON_LVB_SBCSDBCS;
#else
                    Attr->Attr = ATTR_OF_PCI(SourcePtr);
#endif
                    AttrLength += 1;
                }
            }
        }

        // recalculate first and last non-space char

        Row->CharRow.OldLeft = Row->CharRow.Left;
        if (TargetPoint.X < Row->CharRow.Left) {
            PWCHAR LastChar = &Row->CharRow.Chars[ScreenInfo->ScreenBufferSize.X];

            for (Char=&Row->CharRow.Chars[TargetPoint.X];Char < LastChar && *Char==(WCHAR)' ';Char++)
                ;
            Row->CharRow.Left = (SHORT)(Char-Row->CharRow.Chars);
        }

        Row->CharRow.OldRight = Row->CharRow.Right;
        if ((TargetPoint.X+XSize) >= Row->CharRow.Right) {
            SHORT LastNonSpace;
            PWCHAR FirstChar = Row->CharRow.Chars;

            LastNonSpace = (SHORT)(TargetPoint.X+XSize-1);
            for (Char=&Row->CharRow.Chars[(TargetPoint.X+XSize-1)];*Char==(WCHAR)' ' && Char >= FirstChar;Char--)
                LastNonSpace--;

            //
            // if the attributes change after the last non-space, make the
            // index of the last attribute change + 1 the length.  otherwise
            // make the length one more than the last non-space.
            //

            Row->CharRow.Right = (SHORT)(LastNonSpace+1);
        }

        //
        // see if attr string is different.  if so, allocate a new
        // attr buffer and merge the two strings.
        //


        if (AttrLength != Row->AttrRow.Length ||
            memcmp(Row->AttrRow.Attrs,AttrBuf,AttrLength*sizeof(*Attr))) {
            PATTR_PAIR NewAttrs;
            WORD NewAttrsLength;

            if (!NT_SUCCESS(MergeAttrStrings(Row->AttrRow.Attrs,
                             Row->AttrRow.Length,
                             AttrBuf,
                             AttrLength,
                             &NewAttrs,
                             &NewAttrsLength,
                             TargetPoint.X,
                             (SHORT)(TargetPoint.X+XSize-1),
                             Row,
                             ScreenInfo
                            ))) {
                if (XSize > 80) {
                    ConsoleHeapFree(AttrBuf);
                }
                ResetTextFlags(ScreenInfo,
                               TargetPoint.X,
                               TargetPoint.Y,
                               (SHORT)(TargetPoint.X + XSize - 1),
                               (SHORT)(TargetPoint.Y + YSize - 1));
                return;
            }
            if (Row->AttrRow.Length > 1) {
                ConsoleHeapFree(Row->AttrRow.Attrs);
            }
            else {
                ASSERT(Row->AttrRow.Attrs == &Row->AttrRow.AttrPair);
            }
            Row->AttrRow.Attrs = NewAttrs;
            Row->AttrRow.Length = NewAttrsLength;
            Row->CharRow.OldLeft = INVALID_OLD_LENGTH;
            Row->CharRow.OldRight = INVALID_OLD_LENGTH;
        }
        if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
            RowIndex = 0;
        }
    }
    ResetTextFlags(ScreenInfo,
                   TargetPoint.X,
                   TargetPoint.Y,
                   (SHORT)(TargetPoint.X + XSize - 1),
                   (SHORT)(TargetPoint.Y + YSize - 1));

    if (XSize > 80) {
        ConsoleHeapFree(AttrBuf);
    }
}

VOID
WWSB_WriteRegionToScreen(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    )
{
    COORD Window;
    int i,j;
    PATTR_PAIR Attr;
    RECT TextRect;
    SHORT RowIndex;
    SHORT CountOfAttr;
    PROW Row;
    BOOL OneLine, SimpleWrite;  // one line && one attribute per line
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;
    PWCHAR TransBufferCharacter = NULL ;
#ifdef WWSB_FE
    BOOL  DoubleColorDbcs;
    SHORT CountOfAttrOriginal;
    SHORT RegionRight;
    BOOL  LocalEUDCFlag;
    SMALL_RECT CaTextRect;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo = ScreenInfo->ConvScreenInfo;
#endif

    DBGOUTPUT(("WriteRegionToScreen\n"));

#ifdef WWSB_FE
    if (ConvAreaInfo) {
        CaTextRect.Left = Region->Left - ScreenInfo->Console->CurrentScreenBuffer->Window.Left - ConvAreaInfo->CaInfo.coordConView.X;
        CaTextRect.Right = CaTextRect.Left + (Region->Right - Region->Left);
        CaTextRect.Top   = Region->Top - ScreenInfo->Console->CurrentScreenBuffer->Window.Top - ConvAreaInfo->CaInfo.coordConView.Y;
        CaTextRect.Bottom = CaTextRect.Top + (Region->Bottom - Region->Top);
    }

    if (Region->Left && (ScreenInfo->BisectFlag & BISECT_LEFT)) {
        Region->Left--;
    }
    if (Region->Right+1 < ScreenInfo->ScreenBufferSize.X && (ScreenInfo->BisectFlag & BISECT_RIGHT)) {
        Region->Right++;
    }
    ScreenInfo->BisectFlag &= ~(BISECT_LEFT | BISECT_RIGHT);
    Console->ConsoleIme.ScrollWaitCountDown = Console->ConsoleIme.ScrollWaitTimeout;
#endif

    if (Console->FullScreenFlags == 0) {

        //
        // if we have a selection, turn it off.
        //

        InvertSelection(Console, TRUE);

        ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
        if (WWSB_PolyTextOutCandidate(ScreenInfo,Region)) {
            WWSB_ConsolePolyTextOut(ScreenInfo,Region);
        }
        else {

#ifdef WWSB_FE
            if (ConvAreaInfo) {
                Window.Y = Region->Top - Console->CurrentScreenBuffer->Window.Top;
                Window.X = Region->Left - Console->CurrentScreenBuffer->Window.Left;
            }
            else {
#endif
                Window.Y = Region->Top - ScreenInfo->Window.Top;
                Window.X = Region->Left - ScreenInfo->Window.Left;
#ifdef WWSB_FE
            }
#endif

#ifdef WWSB_FE
            RowIndex = (ConvAreaInfo ? CaTextRect.Top :
                                       (ScreenInfo->BufferInfo.TextInfo.FirstRow+Region->Top) % ScreenInfo->ScreenBufferSize.Y
                       );
            RegionRight = Region->Right;
#else
            RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+Region->Top) % ScreenInfo->ScreenBufferSize.Y;
#endif
            OneLine = (Region->Top==Region->Bottom);

            TransBufferCharacter = ConsoleHeapAlloc(TMP_DBCS_TAG,
                                                    (ScreenInfo->ScreenBufferSize.X * sizeof(WCHAR)) + sizeof(WCHAR));
            if (TransBufferCharacter == NULL) {
                RIPMSG0(RIP_WARNING, "WriteRegionToScreen cannot allocate memory");
                return;
            }

            for (i=Region->Top;i<=Region->Bottom;i++,Window.Y++) {
#ifdef WWSB_FE
                DoubleColorDbcs = FALSE;
                Region->Right = RegionRight;
#endif

                //
                // copy the chars and attrs from their respective arrays
                //

                Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];

                if (Row->AttrRow.Length == 1) {
                    Attr = Row->AttrRow.Attrs;
                    CountOfAttr = ScreenInfo->ScreenBufferSize.X;
                    SimpleWrite = TRUE;
                } else {
                    SimpleWrite = FALSE;
                    FindAttrIndex(Row->AttrRow.Attrs,
#ifdef WWSB_FE
                                  (SHORT)(ConvAreaInfo ? CaTextRect.Left : Region->Left),
#else
                                  Region->Left,
#endif
                                  &Attr,
                                  &CountOfAttr
                                 );
                }
                if (Console->LastAttributes != Attr->Attr) {
                    TEXTCOLOR_CALL;
#ifdef WWSB_FE
                    if (Attr->Attr & COMMON_LVB_REVERSE_VIDEO)
                    {
                        SetBkColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr->Attr)));
                        SetTextColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr->Attr >> 4)));
                    }
                    else{
#endif
                        SetTextColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr->Attr)));
                        SetBkColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr->Attr >> 4)));
#ifdef WWSB_FE
                    }
#endif
                    Console->LastAttributes = Attr->Attr;
                }
                TextRect.top = Window.Y*SCR_FONTSIZE(ScreenInfo).Y;
                TextRect.bottom = TextRect.top + SCR_FONTSIZE(ScreenInfo).Y;
                for (j=Region->Left;j<=Region->Right;) {
                    SHORT NumberOfChars;
                    int TextLeft;
                    SHORT LeftChar,RightChar;

                    if (CountOfAttr > (SHORT)(Region->Right - j + 1)) {
                        CountOfAttr = (SHORT)(Region->Right - j + 1);
                    }

#ifdef WWSB_FE
                    CountOfAttrOriginal = CountOfAttr;


                    LocalEUDCFlag = FALSE;
                    if((ScreenInfo->Console->Flags & CONSOLE_VDM_REGISTERED &&
                        ((PEUDC_INFORMATION)(ScreenInfo->Console->EudcInformation))->LocalVDMEudcMode)){
                        LocalEUDCFlag = CheckEudcRangeInString(
                                            Console,
                                            &Row->CharRow.Chars[ConvAreaInfo ?
                                                                CaTextRect.Left + (j-Region->Left) : j],
                                            CountOfAttr,
                                            &CountOfAttr);
                    }
                    if (!(ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                        !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN) &&
                        ((PEUDC_INFORMATION)(ScreenInfo->Console->EudcInformation))->LocalKeisenEudcMode
                       ) {
                        SHORT k;
                        PWCHAR Char2;
                        Char2 = &Row->CharRow.Chars[ConvAreaInfo ? CaTextRect.Left + (j-Region->Left) : j];
                        for ( k = 0 ; k < CountOfAttr ; k++,Char2++){
                            if (*Char2 < UNICODE_SPACE){
                                CountOfAttr = k ;
                                LocalEUDCFlag = TRUE;
                                break;
                            }
                        }
                    }
#endif

                    //
                    // make the bounding rect smaller, if we can.  the TEXT_VALID_HINT
                    // flag gets set each time we write to the screen buffer.  it gets
                    // turned off any time we get asked to redraw the screen
                    // and we don't know exactly what needs to be redrawn
                    // (i.e. paint messages).
                    //
                    // we have the left and right bounds of the text on the
                    // line.  the opaqueing rectangle and the number of
                    // chars get set according to those values.
                    //
                    // if there's more than one attr per line (!SimpleWrite)
                    // we bail on the opaqueing rect.
                    //

                    if (ScreenInfo->BufferInfo.TextInfo.Flags & TEXT_VALID_HINT && SimpleWrite) {
                        if (Row->CharRow.OldLeft != INVALID_OLD_LENGTH) {
                            TextRect.left = (max(min(Row->CharRow.Left,Row->CharRow.OldLeft),j)-ScreenInfo->Window.Left) *
                                            SCR_FONTSIZE(ScreenInfo).X;
                        } else {
                            TextRect.left = Window.X*SCR_FONTSIZE(ScreenInfo).X;
                        }

                        if (Row->CharRow.OldRight != INVALID_OLD_LENGTH) {
                            TextRect.right = (min(max(Row->CharRow.Right,Row->CharRow.OldRight),j+CountOfAttr)-ScreenInfo->Window.Left) *
                                             SCR_FONTSIZE(ScreenInfo).X;
                        } else {
                            TextRect.right = TextRect.left + CountOfAttr*SCR_FONTSIZE(ScreenInfo).X;
                        }
                        LeftChar = max(Row->CharRow.Left,j);
                        RightChar = min(Row->CharRow.Right,j+CountOfAttr);
                        NumberOfChars = RightChar - LeftChar;
                        TextLeft = (LeftChar-ScreenInfo->Window.Left)*SCR_FONTSIZE(ScreenInfo).X;
                    } else {
#ifdef WWSB_FE
                        LeftChar = ConvAreaInfo ? CaTextRect.Left + (j-Region->Left) : j;
#else
                        LeftChar = (SHORT)j;
#endif
                        TextRect.left = Window.X*SCR_FONTSIZE(ScreenInfo).X;
                        TextRect.right = TextRect.left + CountOfAttr*SCR_FONTSIZE(ScreenInfo).X;
#ifdef WWSB_FE
                        if (ConvAreaInfo)
                            NumberOfChars = (Row->CharRow.Right > (SHORT)((CaTextRect.Left+(j-Region->Left)) + CountOfAttr)) ?
                                (CountOfAttr) : (SHORT)(Row->CharRow.Right-(CaTextRect.Left+(j-Region->Left)));
                        else
#endif
                            NumberOfChars = (Row->CharRow.Right > (SHORT)(j + CountOfAttr)) ? (CountOfAttr) : (SHORT)(Row->CharRow.Right-j);
                        TextLeft = TextRect.left;
                    }

                    if (NumberOfChars < 0)
                    {
                        NumberOfChars = 0;
#ifdef WWSB_FE
                        TextRect.left = Window.X*SCR_FONTSIZE(ScreenInfo).X;
                        TextRect.right = TextRect.left + CountOfAttr*SCR_FONTSIZE(ScreenInfo).X;
#endif
                    }
                    TEXTOUT_CALL;
#ifdef WWSB_FE
                    /*
                     * Text out everything (i.e. SBCS/DBCS, Common LVB attribute, Local EUDC)
                     */
                    TextOutEverything(Console,
                                      ScreenInfo,
                                      (SHORT)j,
                                      &Region->Right,
                                      &CountOfAttr,
                                      CountOfAttrOriginal,
                                      &DoubleColorDbcs,
                                      LocalEUDCFlag,
                                      Row,
                                      Attr,
                                      LeftChar,
                                      RightChar,
                                      TextLeft,
                                      TextRect,
                                      NumberOfChars);
#else
                    NumberOfChars =
                        (SHORT)RemoveDbcsMarkAll(ScreenInfo,
                                                 Row,
                                                 &LeftChar,
                                                 &TextRect,
                                                 &TextLeft,
                                                 TransBufferCharacter,
                                                 NumberOfChars);
                    ExtTextOutW(Console->hDC,
                               TextLeft,
                               TextRect.top,
                               ETO_OPAQUE,
                               &TextRect,
                               TransBufferCharacter,
                               NumberOfChars,
                               NULL
                              );
#endif
                    if (OneLine && SimpleWrite) {
                        break;
                    }
                    j+=CountOfAttr;
                    if (j <= Region->Right) {
                        Window.X += CountOfAttr;
#ifdef WWSB_FE
                        if (CountOfAttr < CountOfAttrOriginal){
                            CountOfAttr = CountOfAttrOriginal - CountOfAttr;
                        }
                        else {
#endif
                            Attr++;
                            CountOfAttr = Attr->Length;
#ifdef WWSB_FE
                        }
#endif
#ifdef WWSB_FE
                        if (Attr->Attr & COMMON_LVB_REVERSE_VIDEO)
                        {
                            SetBkColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr->Attr)));
                            SetTextColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr->Attr >> 4)));
                        }
                        else{
#endif
                            SetTextColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr->Attr)));
                            SetBkColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr->Attr >> 4)));
#ifdef WWSB_FE
                        }
#endif
                        Console->LastAttributes = Attr->Attr;
                    }
                }
                Window.X = Region->Left - ScreenInfo->Window.Left;
                if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
                    RowIndex = 0;
                }
            }
            GdiFlush();
            ConsoleHeapFree(TransBufferCharacter);
        }

        //
        // if we have a selection, turn it on.
        //

        InvertSelection(Console, FALSE);
    }
#ifdef i386
    else if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
#ifdef WWSB_FE
        if (! ScreenInfo->ConvScreenInfo) {
            if (ScreenInfo->Console->CurrentScreenBuffer == ScreenInfo) {
                WWSB_WriteRegionToScreenHW(ScreenInfo,Region);
            }
        }
        else if (ScreenInfo->Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER)
#endif
            WWSB_WriteRegionToScreenHW(ScreenInfo,Region);
    }
#endif

#ifdef WWSB_FE
    {
        SMALL_RECT TmpRegion;

        if (ScreenInfo->BisectFlag & BISECT_TOP) {
            ScreenInfo->BisectFlag &= ~BISECT_TOP;
            if (Region->Top) {
                TmpRegion.Top = Region->Top-1;
                TmpRegion.Bottom = Region->Top-1;
                TmpRegion.Left = ScreenInfo->ScreenBufferSize.X-1;
                TmpRegion.Right = ScreenInfo->ScreenBufferSize.X-1;
                WWSB_WriteRegionToScreen(ScreenInfo,&TmpRegion);
            }
        }
        if (ScreenInfo->BisectFlag & BISECT_BOTTOM) {
            ScreenInfo->BisectFlag &= ~BISECT_BOTTOM;
            if (Region->Bottom+1 < ScreenInfo->ScreenBufferSize.Y) {
                TmpRegion.Top = Region->Bottom+1;
                TmpRegion.Bottom = Region->Bottom+1;
                TmpRegion.Left = 0;
                TmpRegion.Right = 0;
                WWSB_WriteRegionToScreen(ScreenInfo,&TmpRegion);
            }
        }
    }
#endif
}

VOID
WWSB_WriteToScreen(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    )
/*++

Routine Description:

    This routine writes a screen buffer region to the screen.

Arguments:

    ScreenInfo - Pointer to screen buffer information.

    Region - Region to write in screen buffer coordinates.  Region is
    inclusive

Return Value:

    none.

--*/

{
    SMALL_RECT ClippedRegion;

    DBGOUTPUT(("WriteToScreen\n"));
    //
    // update to screen, if we're not iconic.  we're marked as
    // iconic if we're fullscreen, so check for fullscreen.
    //

    if (!ACTIVE_SCREEN_BUFFER(ScreenInfo) ||
        (ScreenInfo->Console->Flags & (CONSOLE_IS_ICONIC | CONSOLE_NO_WINDOW) &&
         ScreenInfo->Console->FullScreenFlags == 0)) {
        return;
    }

    // clip region

    ClippedRegion.Left = max(Region->Left, ScreenInfo->Window.Left);
    ClippedRegion.Top = max(Region->Top, ScreenInfo->Window.Top);
    ClippedRegion.Right = min(Region->Right, ScreenInfo->Window.Right);
    ClippedRegion.Bottom = min(Region->Bottom, ScreenInfo->Window.Bottom);
    if (ClippedRegion.Right < ClippedRegion.Left ||
        ClippedRegion.Bottom < ClippedRegion.Top) {
        return;
    }

    if (ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER) {
        if (ScreenInfo->Console->FullScreenFlags == 0) {
            WriteRegionToScreenBitMap(ScreenInfo, &ClippedRegion);
        }
    } else {
        ConsoleHideCursor(ScreenInfo);
        WWSB_WriteRegionToScreen(ScreenInfo, &ClippedRegion);
#ifdef WWSB_FE
        if (!(ScreenInfo->Console->ConsoleIme.ScrollFlag & HIDE_FOR_SCROLL))
        {
            PCONVERSIONAREA_INFORMATION ConvAreaInfo;

            if (! ScreenInfo->Console->CurrentScreenBuffer->ConvScreenInfo) {
                WriteConvRegionToScreen(ScreenInfo,
                                        ScreenInfo->Console->ConsoleIme.ConvAreaRoot,
                                        Region);
            }
            else if (ConvAreaInfo = ScreenInfo->Console->ConsoleIme.ConvAreaRoot) {
                do {
                    if (ConvAreaInfo->ScreenBuffer == ScreenInfo)
                        break;
                } while (ConvAreaInfo = ConvAreaInfo->ConvAreaNext);
                if (ConvAreaInfo) {
                    WriteConvRegionToScreen(ScreenInfo,
                                            ConvAreaInfo->ConvAreaNext,
                                            Region);
                }
            }
        }
#endif
        ConsoleShowCursor(ScreenInfo);
    }
}

NTSTATUS
WWSB_WriteOutputString(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PVOID Buffer,
    IN COORD WriteCoord,
    IN ULONG StringType,
    IN OUT PULONG NumRecords, // this value is valid even for error cases
    OUT PULONG NumColumns OPTIONAL
    )

/*++

Routine Description:

    This routine writes a string of characters or attributes to the
    screen buffer.

Arguments:

    ScreenInfo - Pointer to screen buffer information.

    Buffer - Buffer to write from.

    WriteCoord - Screen buffer coordinate to begin writing to.

    StringType
      One of the following:
        CONSOLE_ASCII          - write a string of ascii characters.
        CONSOLE_REAL_UNICODE   - write a string of real unicode characters.
        CONSOLE_FALSE_UNICODE  - write a string of false unicode characters.
        CONSOLE_ATTRIBUTE      - write a string of attributes.

    NumRecords - On input, the number of elements to write.  On output,
    the number of elements written.

    NumColumns - receives the number of columns output, which could be more
                 than NumRecords (FE fullwidth chars)
Return Value:


--*/

{
    ULONG NumWritten;
    SHORT X,Y,LeftX;
    SMALL_RECT WriteRegion;
    PROW Row;
    PWCHAR Char;
    SHORT RowIndex;
    SHORT j;
    PWCHAR TransBuffer;
#ifdef WWSB_NOFE
    WCHAR SingleChar;
#endif
    UINT Codepage;
#ifdef WWSB_FE
    PBYTE AttrP;
    PBYTE TransBufferA;
    PBYTE BufferA;
    ULONG NumRecordsSavedForUnicode;
    BOOL  fLocalHeap = FALSE;
#endif

    DBGOUTPUT(("WriteOutputString\n"));
#ifdef WWSB_FE
    ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
#endif

    if (*NumRecords == 0)
        return STATUS_SUCCESS;

    NumWritten = 0;
    X=WriteCoord.X;
    Y=WriteCoord.Y;
    if (X>=ScreenInfo->ScreenBufferSize.X ||
        X<0 ||
        Y>=ScreenInfo->ScreenBufferSize.Y ||
        Y<0) {
        *NumRecords = 0;
        return STATUS_SUCCESS;
    }

    ScreenInfo->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;
    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+WriteCoord.Y) % ScreenInfo->ScreenBufferSize.Y;

    if (StringType == CONSOLE_ASCII) {
#ifdef WWSB_FE
        PCHAR TmpBuf;
        PWCHAR TmpTrans;
        ULONG i;
        PCHAR TmpTransA;
#endif

        if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
            !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
            if (ScreenInfo->Console->OutputCP != WINDOWSCP)
                Codepage = USACP;
            else
                Codepage = WINDOWSCP;
        } else {
            Codepage = ScreenInfo->Console->OutputCP;
        }

#ifdef WWSB_FE
        if (*NumRecords > (ULONG)(ScreenInfo->ScreenBufferSize.X * ScreenInfo->ScreenBufferSize.Y)) {

            TransBuffer = ConsoleHeapAlloc(TMP_DBCS_TAG, *NumRecords * 2 * sizeof(WCHAR));
            if (TransBuffer == NULL) {
                return STATUS_NO_MEMORY;
            }
            TransBufferA = ConsoleHeapAlloc(TMP_DBCS_TAG, *NumRecords * 2 * sizeof(CHAR));
            if (TransBufferA == NULL) {
                ConsoleHeapFree(TransBuffer);
                return STATUS_NO_MEMORY;
            }

            fLocalHeap = TRUE;
        }
        else {
            TransBuffer  = ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferCharacter;
            TransBufferA = ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferAttribute;
        }

        TmpBuf = Buffer;
        TmpTrans = TransBuffer;
        TmpTransA = TransBufferA;      // MSKK Apr.02.1993 V-HirotS For KAttr
        for (i=0; i < *NumRecords;) {
            if (IsDBCSLeadByteConsole(*TmpBuf,&ScreenInfo->Console->OutputCPInfo)) {
                if (i+1 >= *NumRecords) {
                    *TmpTrans = UNICODE_SPACE;
                    *TmpTransA = 0;
                    i++;
                }
                else {
                    ConvertOutputToUnicode(Codepage,
                                           TmpBuf,
                                           2,
                                           TmpTrans,
                                           2);
                    *(TmpTrans+1) = *TmpTrans;
                    TmpTrans += 2;
                    TmpBuf += 2;
                    *TmpTransA++ = ATTR_LEADING_BYTE;
                    *TmpTransA++ = ATTR_TRAILING_BYTE;
                    i += 2;
                }
            }
            else {
                ConvertOutputToUnicode(Codepage,
                                       TmpBuf,
                                       1,
                                       TmpTrans,
                                       1);
                TmpTrans++;
                TmpBuf++;
                *TmpTransA++ = 0;               // MSKK APr.02.1993 V-HirotS For KAttr
                i++;
            }
        }
        BufferA = TransBufferA;
        Buffer = TransBuffer;
#else
        if (*NumRecords == 1) {
            TransBuffer = NULL;
            SingleChar = SB_CharToWcharGlyph(Codepage, *((char *)Buffer));
            Buffer = &SingleChar;
        } else {
            TransBuffer = ConsoleHeapAlloc(TMP_TAG, *NumRecords * sizeof(WCHAR));
            if (TransBuffer == NULL) {
                return STATUS_NO_MEMORY;
            }
            ConvertOutputToUnicode(Codepage, Buffer, *NumRecords,
                    TransBuffer, *NumRecords);
            Buffer = TransBuffer;
        }
#endif
    } else if (StringType == CONSOLE_REAL_UNICODE &&
            (ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
            !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
        RealUnicodeToFalseUnicode(Buffer,
                                *NumRecords,
                                ScreenInfo->Console->OutputCP
                                );
    }

#ifdef WWSB_FE
    if ((StringType == CONSOLE_REAL_UNICODE) || (StringType == CONSOLE_FALSE_UNICODE)) {
        PWCHAR TmpBuf;
        PWCHAR TmpTrans;
        PCHAR TmpTransA;
        ULONG i,j;
        WCHAR c;

        /* Avoid overflow into TransBufferCharacter , TransBufferAttribute
         * because, if hit by IsConsoleFullWidth()
         * then one unicde character needs two spaces on TransBuffer.
         */
        if ((*NumRecords*2) > (ULONG)(ScreenInfo->ScreenBufferSize.X * ScreenInfo->ScreenBufferSize.Y)) {

            TransBuffer = ConsoleHeapAlloc(TMP_DBCS_TAG, *NumRecords * 2 * sizeof(WCHAR));
            if (TransBuffer == NULL) {
                return STATUS_NO_MEMORY;
            }
            TransBufferA = ConsoleHeapAlloc(TMP_DBCS_TAG, *NumRecords * 2 * sizeof(CHAR));
            if (TransBufferA == NULL) {
                ConsoleHeapFree(TransBuffer);
                return STATUS_NO_MEMORY;
            }

            fLocalHeap = TRUE;
        }
        else {
            TransBuffer  = ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferCharacter;
            TransBufferA = ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferAttribute;
        }

        TmpBuf = Buffer;
        TmpTrans = TransBuffer;
        TmpTransA = TransBufferA;
        for (i=0,j=0; i < *NumRecords; i++,j++) {
            *TmpTrans++ = c = *TmpBuf++;
            *TmpTransA = 0;
            if (IsConsoleFullWidth(ScreenInfo->Console->hDC,
                                   ScreenInfo->Console->OutputCP,c)) {
                *TmpTransA++ = ATTR_LEADING_BYTE;
                *TmpTrans++ = c;
                *TmpTransA = ATTR_TRAILING_BYTE;
                j++;
            }
            TmpTransA++;
        }
        NumRecordsSavedForUnicode = *NumRecords;
        *NumRecords = j;
        Buffer = TransBuffer;
        BufferA = TransBufferA;
    }
#endif

    if ((StringType == CONSOLE_REAL_UNICODE) ||
            (StringType == CONSOLE_FALSE_UNICODE) ||
            (StringType == CONSOLE_ASCII)) {
        while (TRUE) {

            LeftX = X;

            //
            // copy the chars into their arrays
            //

            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
            Char = &Row->CharRow.Chars[X];
#ifdef WWSB_FE
            AttrP = &Row->CharRow.KAttrs[X];
#endif
            if ((ULONG)(ScreenInfo->ScreenBufferSize.X - X) >= (*NumRecords - NumWritten)) {
                /*
                 * The text will not hit the right hand edge, copy it all
                 */
#ifdef WWSB_FE
                COORD TPoint;

                TPoint.X = X;
                TPoint.Y = Y;
                BisectWrite((SHORT)(*NumRecords-NumWritten),TPoint,ScreenInfo);
                if (TPoint.Y == ScreenInfo->ScreenBufferSize.Y-1 &&
                    (SHORT)(TPoint.X+*NumRecords-NumWritten) >= ScreenInfo->ScreenBufferSize.X &&
                    *((PCHAR)BufferA+ScreenInfo->ScreenBufferSize.X-TPoint.X-1) & ATTR_LEADING_BYTE
                   ) {
                    *((PWCHAR)Buffer+ScreenInfo->ScreenBufferSize.X-TPoint.X-1) = UNICODE_SPACE;
                    *((PCHAR)BufferA+ScreenInfo->ScreenBufferSize.X-TPoint.X-1) = 0;
                    if ((SHORT)(*NumRecords-NumWritten) > (SHORT)(ScreenInfo->ScreenBufferSize.X-TPoint.X-1)) {
                        *((PWCHAR)Buffer+ScreenInfo->ScreenBufferSize.X-TPoint.X) = UNICODE_SPACE;
                        *((PCHAR)BufferA+ScreenInfo->ScreenBufferSize.X-TPoint.X) = 0;
                    }
                }
                RtlCopyMemory(AttrP,BufferA,(*NumRecords - NumWritten) * sizeof(CHAR));
#endif
                RtlCopyMemory(Char,Buffer,(*NumRecords - NumWritten) * sizeof(WCHAR));
                X=(SHORT)(X+*NumRecords - NumWritten-1);
                NumWritten = *NumRecords;
            }
            else {
                /*
                 * The text will hit the right hand edge, copy only that much
                 */
#ifdef WWSB_FE
                COORD TPoint;

                TPoint.X = X;
                TPoint.Y = Y;
                BisectWrite((SHORT)(ScreenInfo->ScreenBufferSize.X-X),TPoint,ScreenInfo);
                if (TPoint.Y == ScreenInfo->ScreenBufferSize.Y-1 &&
                    TPoint.X+ScreenInfo->ScreenBufferSize.X-X >= ScreenInfo->ScreenBufferSize.X &&
                    *((PCHAR)BufferA+ScreenInfo->ScreenBufferSize.X-TPoint.X-1) & ATTR_LEADING_BYTE
                   ) {
                    *((PWCHAR)Buffer+ScreenInfo->ScreenBufferSize.X-TPoint.X-1) = UNICODE_SPACE;
                    *((PCHAR)BufferA+ScreenInfo->ScreenBufferSize.X-TPoint.X-1) = 0;
                    if (ScreenInfo->ScreenBufferSize.X-X > ScreenInfo->ScreenBufferSize.X-TPoint.X-1) {
                        *((PWCHAR)Buffer+ScreenInfo->ScreenBufferSize.X-TPoint.X) = UNICODE_SPACE;
                        *((PCHAR)BufferA+ScreenInfo->ScreenBufferSize.X-TPoint.X) = 0;
                    }
                }
                RtlCopyMemory(AttrP,BufferA,(ScreenInfo->ScreenBufferSize.X - X) * sizeof(CHAR));
                BufferA = (PVOID)((PBYTE)BufferA + ((ScreenInfo->ScreenBufferSize.X - X) * sizeof(CHAR)));
#endif
                RtlCopyMemory(Char,Buffer,(ScreenInfo->ScreenBufferSize.X - X) * sizeof(WCHAR));
                Buffer = (PVOID)((PBYTE)Buffer + ((ScreenInfo->ScreenBufferSize.X - X) * sizeof(WCHAR)));
                NumWritten += ScreenInfo->ScreenBufferSize.X - X;
                X = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
            }

            // recalculate first and last non-space char

            Row->CharRow.OldLeft = Row->CharRow.Left;
            if (LeftX < Row->CharRow.Left) {
                PWCHAR LastChar = &Row->CharRow.Chars[ScreenInfo->ScreenBufferSize.X];

                for (Char=&Row->CharRow.Chars[LeftX];Char < LastChar && *Char==(WCHAR)' ';Char++)
                    ;
                Row->CharRow.Left = (SHORT)(Char-Row->CharRow.Chars);
            }

            Row->CharRow.OldRight = Row->CharRow.Right;
            if ((X+1) >= Row->CharRow.Right) {
                WORD LastNonSpace;
                PWCHAR FirstChar = Row->CharRow.Chars;

                LastNonSpace = X;
                for (Char=&Row->CharRow.Chars[X];*Char==(WCHAR)' ' && Char >= FirstChar;Char--)
                    LastNonSpace--;
                Row->CharRow.Right = (SHORT)(LastNonSpace+1);
            }
            if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
                RowIndex = 0;
            }
            if (NumWritten < *NumRecords) {
                /*
                 * The string hit the right hand edge, so wrap around to the
                 * next line by going back round the while loop, unless we
                 * are at the end of the buffer - in which case we simply
                 * abandon the remainder of the output string!
                 */
                X = 0;
                Y++;
                if (Y >= ScreenInfo->ScreenBufferSize.Y) {
                    break; // abandon output, string is truncated
                }
            } else {
                break;
            }
        }
    } else if (StringType == CONSOLE_ATTRIBUTE) {
        PWORD SourcePtr=Buffer;
        PATTR_PAIR AttrBuf;
        ATTR_PAIR Attrs[80];
        PATTR_PAIR Attr;
        SHORT AttrLength;

        AttrBuf = Attrs;
        if (ScreenInfo->ScreenBufferSize.X > 80) {
            AttrBuf = ConsoleHeapAlloc(TMP_TAG, ScreenInfo->ScreenBufferSize.X * sizeof(ATTR_PAIR));
            if (AttrBuf == NULL)
                return STATUS_NO_MEMORY;
        }
#ifdef WWSB_FE
        {
            COORD TPoint;
            TPoint.X = X;
            TPoint.Y = Y;
            if ((ULONG)(ScreenInfo->ScreenBufferSize.X - X) >= (*NumRecords - NumWritten)) {
                BisectWriteAttr((SHORT)(*NumRecords-NumWritten),TPoint,ScreenInfo);
            }
            else{
                BisectWriteAttr((SHORT)(ScreenInfo->ScreenBufferSize.X-X),TPoint,ScreenInfo);
            }
        }
#endif
        while (TRUE) {

            //
            // copy the attrs into the screen buffer arrays
            //

            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
            Attr = AttrBuf;
            Attr->Length = 0;
#ifdef WWSB_FE
            Attr->Attr = *SourcePtr & ~COMMON_LVB_SBCSDBCS;
#else
            Attr->Attr = *SourcePtr;
#endif
            AttrLength = 1;
            for (j=X;j<ScreenInfo->ScreenBufferSize.X;j++,SourcePtr++) {
#ifdef WWSB_FE
                if (Attr->Attr == (*SourcePtr & ~COMMON_LVB_SBCSDBCS))
#else
                if (Attr->Attr == *SourcePtr)
#endif
                {
                    Attr->Length += 1;
                }
                else {
                    Attr++;
                    Attr->Length = 1;
#ifdef WWSB_FE
                    Attr->Attr = *SourcePtr & ~COMMON_LVB_SBCSDBCS;
#else
                    Attr->Attr = *SourcePtr;
#endif
                    AttrLength += 1;
                }
                NumWritten++;
                X++;
                if (NumWritten == *NumRecords) {
                    break;
                }
            }
            X--;

            // recalculate last non-space char

            //
            // see if attr string is different.  if so, allocate a new
            // attr buffer and merge the two strings.
            //

            if (AttrLength != Row->AttrRow.Length ||
                memcmp(Row->AttrRow.Attrs,AttrBuf,AttrLength*sizeof(*Attr))) {
                PATTR_PAIR NewAttrs;
                WORD NewAttrsLength;

                if (!NT_SUCCESS(MergeAttrStrings(Row->AttrRow.Attrs,
                                 Row->AttrRow.Length,
                                 AttrBuf,
                                 AttrLength,
                                 &NewAttrs,
                                 &NewAttrsLength,
                                 (SHORT)((Y == WriteCoord.Y) ? WriteCoord.X : 0),
                                 X,
                                 Row,
                                 ScreenInfo
                                ))) {
                    if (ScreenInfo->ScreenBufferSize.X > 80) {
                        ConsoleHeapFree(AttrBuf);
                    }
                    ResetTextFlags(ScreenInfo,
                                   WriteCoord.X,
                                   WriteCoord.Y,
                                   X,
                                   Y);
                    return STATUS_NO_MEMORY;
                }
                if (Row->AttrRow.Length > 1) {
                    ConsoleHeapFree(Row->AttrRow.Attrs);
                }
                else {
                    ASSERT(Row->AttrRow.Attrs == &Row->AttrRow.AttrPair);
                }
                Row->AttrRow.Attrs = NewAttrs;
                Row->AttrRow.Length = NewAttrsLength;
                Row->CharRow.OldLeft = INVALID_OLD_LENGTH;
                Row->CharRow.OldRight = INVALID_OLD_LENGTH;
            }

            if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
                RowIndex = 0;
            }
            if (NumWritten < *NumRecords) {
                X = 0;
                Y++;
                if (Y>=ScreenInfo->ScreenBufferSize.Y) {
                    break;
                }
            } else {
                break;
            }
        }
        ResetTextFlags(ScreenInfo,
                       WriteCoord.X,
                       WriteCoord.Y,
                       X,
                       Y);
        if (ScreenInfo->ScreenBufferSize.X > 80) {
            ConsoleHeapFree(AttrBuf);
        }
    } else {
        *NumRecords = 0;
        return STATUS_INVALID_PARAMETER;
    }
    if ((StringType == CONSOLE_ASCII) && (TransBuffer != NULL)) {
#ifdef WWSB_FE
        if (fLocalHeap) {
            ConsoleHeapFree(TransBuffer);
            ConsoleHeapFree(TransBufferA);
        }
#else
        ConsoleHeapFree(TransBuffer);
#endif
    }
#ifdef WWSB_FE
    else if ((StringType == CONSOLE_FALSE_UNICODE) || (StringType == CONSOLE_REAL_UNICODE)) {
        if (fLocalHeap) {
            ConsoleHeapFree(TransBuffer);
            ConsoleHeapFree(TransBufferA);
        }
        NumWritten = NumRecordsSavedForUnicode - (*NumRecords - NumWritten);
    }
#endif

    //
    // determine write region.  if we're still on the same line we started
    // on, left X is the X we started with and right X is the one we're on
    // now.  otherwise, left X is 0 and right X is the rightmost column of
    // the screen buffer.
    //
    // then update the screen.
    //

    WriteRegion.Top = WriteCoord.Y;
    WriteRegion.Bottom = Y;
    if (Y != WriteCoord.Y) {
        WriteRegion.Left = 0;
        WriteRegion.Right = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
    }
    else {
        WriteRegion.Left = WriteCoord.X;
        WriteRegion.Right = X;
    }
    WWSB_WriteToScreen(ScreenInfo,&WriteRegion);
    if (NumColumns) {
        *NumColumns = X + (WriteCoord.Y - Y) * ScreenInfo->ScreenBufferSize.X - WriteCoord.X + 1;
    }
    *NumRecords = NumWritten;
    return STATUS_SUCCESS;
}

NTSTATUS
WWSB_FillOutput(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN WORD Element,
    IN COORD WriteCoord,
    IN ULONG ElementType,
    IN OUT PULONG Length // this value is valid even for error cases
    )

/*++

Routine Description:

    This routine fills the screen buffer with the specified character or
    attribute.

Arguments:

    ScreenInfo - Pointer to screen buffer information.

    Element - Element to write.

    WriteCoord - Screen buffer coordinate to begin writing to.

    ElementType

        CONSOLE_ASCII         - element is an ascii character.
        CONSOLE_REAL_UNICODE  - element is a real unicode character. These will
                                get converted to False Unicode as required.
        CONSOLE_FALSE_UNICODE - element is a False Unicode character.
        CONSOLE_ATTRIBUTE     - element is an attribute.

    Length - On input, the number of elements to write.  On output,
    the number of elements written.

Return Value:


--*/

{
    ULONG NumWritten;
    SHORT X,Y,LeftX;
    SMALL_RECT WriteRegion;
    PROW Row;
    PWCHAR Char;
    SHORT RowIndex;
    SHORT j;
#ifdef WWSB_FE
    PCHAR AttrP;
#endif

    DBGOUTPUT(("FillOutput\n"));
    if (*Length == 0)
        return STATUS_SUCCESS;
    NumWritten = 0;
    X=WriteCoord.X;
    Y=WriteCoord.Y;
    if (X>=ScreenInfo->ScreenBufferSize.X ||
        X<0 ||
        Y>=ScreenInfo->ScreenBufferSize.Y ||
        Y<0) {
        *Length = 0;
        return STATUS_SUCCESS;
    }

#ifdef WWSB_FE
    ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
#endif

    ScreenInfo->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;
    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+WriteCoord.Y) % ScreenInfo->ScreenBufferSize.Y;

    if (ElementType == CONSOLE_ASCII) {
        UINT Codepage;
        if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                ((ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
            if (ScreenInfo->Console->OutputCP != WINDOWSCP)
                Codepage = USACP;
            else
                Codepage = WINDOWSCP;
        } else {
            Codepage = ScreenInfo->Console->OutputCP;
        }
#ifdef WWSB_FE
        if (ScreenInfo->FillOutDbcsLeadChar == 0){
            if (IsDBCSLeadByteConsole((CHAR)Element,&ScreenInfo->Console->OutputCPInfo)) {
                ScreenInfo->FillOutDbcsLeadChar = (CHAR)Element;
                *Length = 0;
                return STATUS_SUCCESS;
            }else{
                CHAR Char=(CHAR)Element;
                ConvertOutputToUnicode(Codepage,
                          &Char,
                          1,
                          &Element,
                          1);
            }
        }else{
            CHAR Char[2];
            Char[0]=ScreenInfo->FillOutDbcsLeadChar;
            Char[1]=(BYTE)Element;
            ScreenInfo->FillOutDbcsLeadChar = 0;
            ConvertOutputToUnicode(Codepage,
                      Char,
                      2,
                      &Element,
                      2);
        }
#else
        Element = SB_CharToWchar(Codepage, (CHAR)Element);
#endif
    } else if (ElementType == CONSOLE_REAL_UNICODE &&
            (ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
            !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
        RealUnicodeToFalseUnicode(&Element,
                                1,
                                ScreenInfo->Console->OutputCP
                                );
    }

    if ((ElementType == CONSOLE_ASCII) ||
            (ElementType == CONSOLE_REAL_UNICODE) ||
            (ElementType == CONSOLE_FALSE_UNICODE)) {
#ifdef WWSB_FE
        DWORD StartPosFlag ;
        StartPosFlag = 0;
#endif
        while (TRUE) {

            //
            // copy the chars into their arrays
            //

            LeftX = X;
            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
            Char = &Row->CharRow.Chars[X];
#ifdef WWSB_FE
            AttrP = &Row->CharRow.KAttrs[X];
#endif
            if ((ULONG)(ScreenInfo->ScreenBufferSize.X - X) >= (*Length - NumWritten)) {
#ifdef WWSB_FE
                {
                    COORD TPoint;

                    TPoint.X = X;
                    TPoint.Y = Y;
                    BisectWrite((SHORT)(*Length-NumWritten),TPoint,ScreenInfo);
                }
#endif
#ifdef WWSB_FE
                if (IsConsoleFullWidth(ScreenInfo->Console->hDC,
                                       ScreenInfo->Console->OutputCP,(WCHAR)Element)) {
                    for (j=0;j<(SHORT)(*Length - NumWritten);j++) {
                        *Char++ = (WCHAR)Element;
                        *AttrP &= ~ATTR_DBCSSBCS_BYTE;
                        if(StartPosFlag++ & 1)
                            *AttrP++ |= ATTR_TRAILING_BYTE;
                        else
                            *AttrP++ |= ATTR_LEADING_BYTE;
                    }
                    if(StartPosFlag & 1){
                        *(Char-1) = UNICODE_SPACE;
                        *(AttrP-1) &= ~ATTR_DBCSSBCS_BYTE;
                    }
                }
                else {
#endif
                    for (j=0;j<(SHORT)(*Length - NumWritten);j++) {
                        *Char++ = (WCHAR)Element;
#ifdef WWSB_FE
                        *AttrP++ &= ~ATTR_DBCSSBCS_BYTE;
#endif
                    }
#ifdef WWSB_FE
                }
#endif
                X=(SHORT)(X+*Length - NumWritten - 1);
                NumWritten = *Length;
            }
            else {
#ifdef WWSB_FE
                {
                    COORD TPoint;

                    TPoint.X = X;
                    TPoint.Y = Y;
                    BisectWrite((SHORT)(ScreenInfo->ScreenBufferSize.X-X),TPoint,ScreenInfo);
                }
#endif
#ifdef WWSB_FE
                if (IsConsoleFullWidth(ScreenInfo->Console->hDC,
                                       ScreenInfo->Console->OutputCP,(WCHAR)Element)) {
                    for (j=0;j<ScreenInfo->ScreenBufferSize.X - X;j++) {
                        *Char++ = (WCHAR)Element;
                        *AttrP &= ~ATTR_DBCSSBCS_BYTE;
                        if(StartPosFlag++ & 1)
                            *AttrP++ |= ATTR_TRAILING_BYTE;
                        else
                            *AttrP++ |= ATTR_LEADING_BYTE;
                    }
                }
                else {
#endif
                    for (j=0;j<ScreenInfo->ScreenBufferSize.X - X;j++) {
                        *Char++ = (WCHAR)Element;
#ifdef WWSB_FE
                        *AttrP++ &= ~ATTR_DBCSSBCS_BYTE;
#endif
                    }
#ifdef WWSB_FE
                }
#endif
                NumWritten += ScreenInfo->ScreenBufferSize.X - X;
                X = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
            }

            // recalculate first and last non-space char

            Row->CharRow.OldLeft = Row->CharRow.Left;
            if (LeftX < Row->CharRow.Left) {
                if (Element == UNICODE_SPACE) {
                    Row->CharRow.Left = X+1;
                } else {
                    Row->CharRow.Left = LeftX;
                }
            }
            Row->CharRow.OldRight = Row->CharRow.Right;
            if ((X+1) >= Row->CharRow.Right) {
                if (Element == UNICODE_SPACE) {
                    Row->CharRow.Right = LeftX;
                } else {
                    Row->CharRow.Right = X+1;
                }
            }
            if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
                RowIndex = 0;
            }
            if (NumWritten < *Length) {
                X = 0;
                Y++;
                if (Y>=ScreenInfo->ScreenBufferSize.Y) {
                    break;
                }
            } else {
                break;
            }
        }
    } else if (ElementType == CONSOLE_ATTRIBUTE) {
        ATTR_PAIR Attr;

#ifdef WWSB_FE
        COORD TPoint;
        TPoint.X = X;
        TPoint.Y = Y;

        if ((ULONG)(ScreenInfo->ScreenBufferSize.X - X) >= (*Length - NumWritten)) {
            BisectWriteAttr((SHORT)(*Length-NumWritten),TPoint,ScreenInfo);
        }
        else{
            BisectWriteAttr((SHORT)(ScreenInfo->ScreenBufferSize.X-X),TPoint,ScreenInfo);
        }
#endif

        while (TRUE) {

            //
            // copy the attrs into the screen buffer arrays
            //

            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
            if ((ULONG)(ScreenInfo->ScreenBufferSize.X - X) >= (*Length - NumWritten)) {
                X=(SHORT)(X+*Length - NumWritten - 1);
                NumWritten = *Length;
            }
            else {
                NumWritten += ScreenInfo->ScreenBufferSize.X - X;
                X = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
            }

            // recalculate last non-space char

            //
            //  merge the two attribute strings.
            //

            Attr.Length = (SHORT)((Y == WriteCoord.Y) ? (X-WriteCoord.X+1) : (X+1));
#ifdef WWSB_FE
            Attr.Attr = Element & ~COMMON_LVB_SBCSDBCS;
#else
            Attr.Attr = Element;
#endif
            if (1 != Row->AttrRow.Length ||
                memcmp(Row->AttrRow.Attrs,&Attr,sizeof(Attr))) {
                PATTR_PAIR NewAttrs;
                WORD NewAttrsLength;

                if (!NT_SUCCESS(MergeAttrStrings(Row->AttrRow.Attrs,
                                 Row->AttrRow.Length,
                                 &Attr,
                                 1,
                                 &NewAttrs,
                                 &NewAttrsLength,
                                 (SHORT)(X-Attr.Length+1),
                                 X,
                                 Row,
                                 ScreenInfo
                                ))) {
                    ResetTextFlags(ScreenInfo,
                                   WriteCoord.X,
                                   WriteCoord.Y,
                                   X,
                                   Y);
                    return STATUS_NO_MEMORY;
                }
                if (Row->AttrRow.Length > 1) {
                    ConsoleHeapFree(Row->AttrRow.Attrs);
                }
                else {
                    ASSERT(Row->AttrRow.Attrs == &Row->AttrRow.AttrPair);
                }
                Row->AttrRow.Attrs = NewAttrs;
                Row->AttrRow.Length = NewAttrsLength;
                Row->CharRow.OldLeft = INVALID_OLD_LENGTH;
                Row->CharRow.OldRight = INVALID_OLD_LENGTH;
            }

            if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
                RowIndex = 0;
            }
            if (NumWritten < *Length) {
                X = 0;
                Y++;
                if (Y>=ScreenInfo->ScreenBufferSize.Y) {
                    break;
                }
            } else {
                break;
            }
        }
        ResetTextFlags(ScreenInfo,
                       WriteCoord.X,
                       WriteCoord.Y,
                       X,
                       Y);
    } else {
        *Length = 0;
        return STATUS_INVALID_PARAMETER;
    }

    //
    // determine write region.  if we're still on the same line we started
    // on, left X is the X we started with and right X is the one we're on
    // now.  otherwise, left X is 0 and right X is the rightmost column of
    // the screen buffer.
    //
    // then update the screen.
    //

#ifdef WWSB_FE
    if (ScreenInfo->ConvScreenInfo) {
        WriteRegion.Top = WriteCoord.Y + ScreenInfo->Window.Left + ScreenInfo->ConvScreenInfo->CaInfo.coordConView.Y;
        WriteRegion.Bottom = Y + ScreenInfo->Window.Left + ScreenInfo->ConvScreenInfo->CaInfo.coordConView.Y;
        if (Y != WriteCoord.Y) {
            WriteRegion.Left = 0;
            WriteRegion.Right = (SHORT)(ScreenInfo->Console->CurrentScreenBuffer->ScreenBufferSize.X-1);
        }
        else {
            WriteRegion.Left = WriteCoord.X + ScreenInfo->Window.Top + ScreenInfo->ConvScreenInfo->CaInfo.coordConView.X;
            WriteRegion.Right = X + ScreenInfo->Window.Top + ScreenInfo->ConvScreenInfo->CaInfo.coordConView.X;
        }
        WriteConvRegionToScreen(ScreenInfo->Console->CurrentScreenBuffer,
                                ScreenInfo->ConvScreenInfo,
                                &WriteRegion
                               );
        ScreenInfo->BisectFlag &= ~(BISECT_LEFT | BISECT_RIGHT | BISECT_TOP | BISECT_BOTTOM);
        *Length = NumWritten;
        return STATUS_SUCCESS;
    }
#endif

    WriteRegion.Top = WriteCoord.Y;
    WriteRegion.Bottom = Y;
    if (Y != WriteCoord.Y) {
        WriteRegion.Left = 0;
        WriteRegion.Right = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
    }
    else {
        WriteRegion.Left = WriteCoord.X;
        WriteRegion.Right = X;
    }
    WWSB_WriteToScreen(ScreenInfo,&WriteRegion);
    *Length = NumWritten;
    return STATUS_SUCCESS;
}

VOID
WWSB_FillRectangle(
    IN CHAR_INFO Fill,
    IN OUT PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT TargetRect
    )

/*++

Routine Description:

    This routine fills a rectangular region in the screen
    buffer.  no clipping is done.

Arguments:

    Fill - element to copy to each element in target rect

    ScreenInfo - pointer to screen info

    TargetRect - rectangle in screen buffer to fill

Return Value:

--*/

{
    SHORT i,j;
    SHORT XSize;
    SHORT RowIndex;
    PROW Row;
    PWCHAR Char;
    ATTR_PAIR Attr;
#ifdef WWSB_FE
    PCHAR AttrP;
    BOOL Width;
#endif
    DBGOUTPUT(("FillRectangle\n"));
#ifdef WWFE_SB
    ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
#endif

    XSize = (SHORT)(TargetRect->Right - TargetRect->Left + 1);

    ScreenInfo->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;
    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetRect->Top) % ScreenInfo->ScreenBufferSize.Y;
    for (i=TargetRect->Top;i<=TargetRect->Bottom;i++) {

        //
        // copy the chars and attrs into their respective arrays
        //

#ifdef WWSB_FE
        {
            COORD TPoint;

            TPoint.X = TargetRect->Left;
            TPoint.Y = i;
            BisectWrite(XSize,TPoint,ScreenInfo);
            Width = IsConsoleFullWidth(ScreenInfo->Console->hDC,
                                       ScreenInfo->Console->OutputCP,Fill.Char.UnicodeChar);
        }
#endif

        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
        Char = &Row->CharRow.Chars[TargetRect->Left];
#ifdef WWSB_FE
        AttrP = &Row->CharRow.KAttrs[TargetRect->Left];
#endif
        for (j=0;j<XSize;j++) {
#ifdef WWSB_FE
            if (Width){
                if (j < XSize-1){
                    *Char++ = Fill.Char.UnicodeChar;
                    *Char++ = Fill.Char.UnicodeChar;
                    *AttrP++ = ATTR_LEADING_BYTE;
                    *AttrP++ = ATTR_TRAILING_BYTE;
                    j++;
                }
                else{
                    *Char++ = UNICODE_SPACE;
                    *AttrP++ = 0 ;
                }
            }
            else{
#endif
                *Char++ = Fill.Char.UnicodeChar;
#ifdef WWSB_FE
                *AttrP++ = 0 ;
            }
#endif
        }

        // recalculate first and last non-space char

        Row->CharRow.OldLeft = Row->CharRow.Left;
        if (TargetRect->Left < Row->CharRow.Left) {
            if (Fill.Char.UnicodeChar == UNICODE_SPACE) {
                Row->CharRow.Left = (SHORT)(TargetRect->Right+1);
            }
            else {
                Row->CharRow.Left = (SHORT)(TargetRect->Left);
            }
        }

        Row->CharRow.OldRight = Row->CharRow.Right;
        if (TargetRect->Right >= Row->CharRow.Right) {
            if (Fill.Char.UnicodeChar == UNICODE_SPACE) {
                Row->CharRow.Right = (SHORT)(TargetRect->Left);
            }
            else {
                Row->CharRow.Right = (SHORT)(TargetRect->Right+1);
            }
        }

        Attr.Length = XSize;
        Attr.Attr = Fill.Attributes;

        //
        //  merge the two attribute strings.
        //

        if (1 != Row->AttrRow.Length ||
            memcmp(Row->AttrRow.Attrs,&Attr,sizeof(Attr))) {
            PATTR_PAIR NewAttrs;
            WORD NewAttrsLength;

            if (!NT_SUCCESS(MergeAttrStrings(Row->AttrRow.Attrs,
                             Row->AttrRow.Length,
                             &Attr,
                             1,
                             &NewAttrs,
                             &NewAttrsLength,
                             TargetRect->Left,
                             TargetRect->Right,
                             Row,
                             ScreenInfo
                            ))) {
                ResetTextFlags(ScreenInfo,
                               TargetRect->Left,
                               TargetRect->Top,
                               TargetRect->Right,
                               TargetRect->Bottom);
                return;
            }
            if (Row->AttrRow.Length > 1) {
                ConsoleHeapFree(Row->AttrRow.Attrs);
            }
            else {
                ASSERT(Row->AttrRow.Attrs == &Row->AttrRow.AttrPair);
            }
            Row->AttrRow.Attrs = NewAttrs;
            Row->AttrRow.Length = NewAttrsLength;
            Row->CharRow.OldLeft = INVALID_OLD_LENGTH;
            Row->CharRow.OldRight = INVALID_OLD_LENGTH;
        }
        if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
            RowIndex = 0;
        }
    }
    ResetTextFlags(ScreenInfo,
                   TargetRect->Left,
                   TargetRect->Top,
                   TargetRect->Right,
                   TargetRect->Bottom);
}

BOOL
WWSB_PolyTextOutCandidate(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    )

/*

    This function returns TRUE if the input region is reasonable to
    pass to ConsolePolyTextOut.  The criteria are that there is only
    one attribute per line.

*/

{
    SHORT RowIndex;
    PROW Row;
    SHORT i;

#ifdef WWSB_FE
    if((ScreenInfo->Console->Flags & CONSOLE_VDM_REGISTERED &&
        ((PEUDC_INFORMATION)(ScreenInfo->Console->EudcInformation))->LocalVDMEudcMode)){
        return FALSE;
    }
    if (!(ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
        !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN) &&
        ((PEUDC_INFORMATION)(ScreenInfo->Console->EudcInformation))->LocalKeisenEudcMode
       ) {
        return FALSE;
    }
    ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
    if (ScreenInfo->BufferInfo.TextInfo.Flags & CONSOLE_CONVERSION_AREA_REDRAW) {
        return FALSE;
    }
#endif

    if (ScreenInfo->BufferInfo.TextInfo.Flags & SINGLE_ATTRIBUTES_PER_LINE) {
        return TRUE;
    }

    //
    // make sure there is only one attr per line.
    //

    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+Region->Top) % ScreenInfo->ScreenBufferSize.Y;
    for (i=Region->Top;i<=Region->Bottom;i++) {
        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
        if (Row->AttrRow.Length != 1) {
            return FALSE;
        }
        if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
            RowIndex = 0;
        }
    }
    return TRUE;
}


#define MAX_POLY_LINES 80
#define VERY_BIG_NUMBER 0x0FFFFFFF

#ifdef WWSB_FE
typedef struct _KEISEN_INFORMATION {
    COORD Coord;
    WORD n;
} KEISEN_INFORMATION, *PKEISEN_INFORMATION;
#endif

VOID
WWSB_ConsolePolyTextOut(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    )

/*

    This function calls PolyTextOut.  The only restriction is that
    there can't be more than one attribute per line in the region.

*/

{
    PROW  Row,LastRow;
    SHORT i,k;
    WORD Attr;
    POLYTEXTW TextInfo[MAX_POLY_LINES];
    RECT  TextRect;
    RECTL BoundingRect;
    int   xSize = SCR_FONTSIZE(ScreenInfo).X;
    int   ySize = SCR_FONTSIZE(ScreenInfo).Y;
    ULONG Flags = ScreenInfo->BufferInfo.TextInfo.Flags;
    int   WindowLeft = ScreenInfo->Window.Left;
    int   RegionLeft = Region->Left;
    int   RegionRight = Region->Right + 1;
    int   DefaultLeft  = (RegionLeft - WindowLeft) * xSize;
    int   DefaultRight = (RegionRight - WindowLeft) * xSize;
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;
    PWCHAR TransPolyTextOut = NULL ;
#ifdef WWSB_FE
    KEISEN_INFORMATION KeisenInfo[MAX_POLY_LINES];
    SHORT j;
    WORD OldAttr;
#endif

    //
    // initialize the text rect and window position.
    //

    TextRect.top = (Region->Top - ScreenInfo->Window.Top) * ySize;
    // TextRect.bottom is invalid.
    BoundingRect.top = TextRect.top;
    BoundingRect.left = VERY_BIG_NUMBER;
    BoundingRect.right = 0;

    //
    // copy the chars and attrs from their respective arrays
    //

    Row = &ScreenInfo->BufferInfo.TextInfo.Rows
           [ScreenInfo->BufferInfo.TextInfo.FirstRow+Region->Top];
    LastRow = &ScreenInfo->BufferInfo.TextInfo.Rows[ScreenInfo->ScreenBufferSize.Y];
    if (Row >= LastRow)
        Row -= ScreenInfo->ScreenBufferSize.Y;

    Attr = Row->AttrRow.AttrPair.Attr;
    if (Console->LastAttributes != Attr) {
#ifdef WWSB_FE
        if (Attr & COMMON_LVB_REVERSE_VIDEO)
        {
            SetBkColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr)));
            SetTextColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr >> 4)));
        }
        else{
#endif
            SetTextColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr)));
            SetBkColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr >> 4)));
#ifdef WWSB_FE
        }
#endif
        Console->LastAttributes = Attr;
    }

    TransPolyTextOut = ConsoleHeapAlloc(TMP_DBCS_TAG,
                                        ScreenInfo->ScreenBufferSize.X * MAX_POLY_LINES * sizeof(WCHAR));
    if (TransPolyTextOut == NULL) {
        RIPMSG0(RIP_WARNING, "ConsoleTextOut cannot allocate memory");
        return;
    }

    for (i=Region->Top;i<=Region->Bottom;) {
        PWCHAR TmpChar;
        TmpChar = TransPolyTextOut;
        for(k=0;i<=Region->Bottom&&k<MAX_POLY_LINES;i++) {
            SHORT NumberOfChars;
            SHORT LeftChar,RightChar;

            //
            // make the bounding rect smaller, if we can.  the TEXT_VALID_HINT
            // flag gets set each time we write to the screen buffer.  it gets
            // turned off any time we get asked to redraw the screen
            // and we don't know exactly what needs to be redrawn
            // (i.e. paint messages).
            //
            // we have the left and right bounds of the text on the
            // line.  the opaqueing rectangle and the number of
            // chars get set according to those values.
            //

            TextRect.left  = DefaultLeft;
            TextRect.right = DefaultRight;

            if (Flags & TEXT_VALID_HINT)
            {
            // We compute an opaquing interval.  If A is the old interval of text,
            // B is the new interval, and R is the Region, then the opaquing interval
            // must be R*(A+B), where * represents intersection and + represents union.

                if (Row->CharRow.OldLeft != INVALID_OLD_LENGTH)
                {
                // The min determines the left of (A+B).  The max intersects that with
                // the left of the region.

                    TextRect.left = (
                                      max
                                      (
                                        min
                                        (
                                          Row->CharRow.Left,
                                          Row->CharRow.OldLeft
                                        ),
                                        RegionLeft
                                      )
                                      -WindowLeft
                                    ) * xSize;
                }

                if (Row->CharRow.OldRight != INVALID_OLD_LENGTH)
                {
                // The max determines the right of (A+B).  The min intersects that with
                // the right of the region.

                    TextRect.right = (
                                       min
                                       (
                                         max
                                         (
                                           Row->CharRow.Right,
                                           Row->CharRow.OldRight
                                         ),
                                         RegionRight
                                       )
                                       -WindowLeft
                                     ) * xSize;
                }
            }

            //
            // We've got to draw any new text that appears in the region, so we just
            // intersect the new text interval with the region.
            //

            LeftChar = max(Row->CharRow.Left,RegionLeft);
            RightChar = min(Row->CharRow.Right,RegionRight);
            NumberOfChars = RightChar - LeftChar;
#ifdef WWSB_FE
            if (Row->CharRow.KAttrs[RightChar-1] & ATTR_LEADING_BYTE){
                if(TextRect.right <= ScreenInfo->Window.Right*xSize) {
                    TextRect.right += xSize;
                }
            }
#endif

            //
            // Empty rows are represented by CharRow.Right=0, CharRow.Left=MAX, so we
            // may have NumberOfChars<0 at this point if there is no text that needs
            // drawing.  (I.e. the intersection was empty.)
            //

            if (NumberOfChars < 0) {
                NumberOfChars = 0;
                LeftChar = 0;
                RightChar = 0;
            }

            //
            // We may also have TextRect.right<TextRect.left if the screen
            // is already cleared, and we really don't need to do anything at all.
            //

            if (TextRect.right > TextRect.left)
            {
                NumberOfChars = (SHORT)RemoveDbcsMarkAll(ScreenInfo,Row,&LeftChar,&TextRect,NULL,TmpChar,NumberOfChars);
                TextInfo[k].x = (LeftChar-WindowLeft) * xSize;
                TextInfo[k].y = TextRect.top;
                TextRect.bottom =  TextRect.top + ySize;
                TextInfo[k].n = NumberOfChars;
                TextInfo[k].lpstr = TmpChar;
#ifdef WWSB_FE
                if (CheckBisectStringW(ScreenInfo,
                                       Console->OutputCP,
                                       TmpChar,
                                       NumberOfChars,
                                       (TextRect.right-max(TextRect.left,TextInfo[k].x))/xSize
                                      )
                   ) {
                    TextRect.right += xSize;
                }
#endif
                TmpChar += NumberOfChars;
                TextInfo[k].rcl = TextRect;
                TextInfo[k].pdx = NULL;
                TextInfo[k].uiFlags = ETO_OPAQUE;
#ifdef WWSB_FE
                KeisenInfo[k].n = DefaultRight-DefaultLeft ;
                KeisenInfo[k].Coord.Y = (WORD)TextRect.top;
                KeisenInfo[k].Coord.X = (WORD)DefaultLeft;
#endif
                k++;

                if (BoundingRect.left > TextRect.left) {
                    BoundingRect.left = TextRect.left;
                }
                if (BoundingRect.right < TextRect.right) {
                    BoundingRect.right = TextRect.right;
                }
            }

            // Advance the high res bounds.

            TextRect.top += ySize;

            // Advance the row pointer.

            if (++Row >= LastRow)
                Row = ScreenInfo->BufferInfo.TextInfo.Rows;

            // Draw now if the attributes are about to change.

#ifdef WWSB_FE
            OldAttr = Attr ;
#endif
            if (Attr != Row->AttrRow.AttrPair.Attr) {
                Attr = Row->AttrRow.AttrPair.Attr;
                i++;
                break;
            }
        }

        if (k)
        {
            BoundingRect.bottom = TextRect.top;
            ASSERT(BoundingRect.left != VERY_BIG_NUMBER);
            ASSERT(BoundingRect.left <= BoundingRect.right);
            ASSERT(BoundingRect.top <= BoundingRect.bottom);
            GdiConsoleTextOut(Console->hDC,
                              TextInfo,
                              k,
                              &BoundingRect);
#ifdef WWSB_FE
            for ( j = 0 ; j < k ; j++){
                RECT TextRect;

                TextRect.left   = KeisenInfo[j].Coord.X;
                TextRect.top    = KeisenInfo[j].Coord.Y;
                TextRect.right  = KeisenInfo[j].n + TextRect.left;
                TextRect.bottom = KeisenInfo[j].Coord.Y + ySize;
                TextOutCommonLVB(ScreenInfo->Console, OldAttr, TextRect);
            }
#endif
        }
        if (Console->LastAttributes != Attr) {
#ifdef WWSB_FE
            if (Attr & COMMON_LVB_REVERSE_VIDEO)
            {
                SetBkColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr)));
                SetTextColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr >> 4)));
            }
            else{
#endif
                SetTextColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr)));
                SetBkColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr >> 4)));
#ifdef WWSB_FE
            }
#endif
            Console->LastAttributes = Attr;
            BoundingRect.top = TextRect.top;
            BoundingRect.left = VERY_BIG_NUMBER;
            BoundingRect.right = 0;
        }
    }
    GdiFlush();
    ConsoleHeapFree(TransPolyTextOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\_priv.h ===
/***************************** Module Header ******************************\
* Module Name: priv.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Performance critical routine for Single Binary
*
* Each function will be created with two flavors FE and non FE
*
* 30-May-1997 Hiroyama   Moved from private.c
\**************************************************************************/

#define WWSB_NEUTRAL_FILE 1

#if !defined(FE_SB)
#error This header file should be included with FE_SB
#endif

#if !defined(WWSB_FE) && !defined(WWSB_NOFE)
#error Either WWSB_FE and WWSB_NOFE must be defined.
#endif

#if defined(WWSB_FE) && defined(WWSB_NOFE)
#error Both WWSB_FE and WWSB_NOFE defined.
#endif

#include "dispatch.h" // get the FE_ prototypes for alloc_text()

#ifdef WWSB_FE
#pragma alloc_text(FE_TEXT, FE_WriteRegionToScreenHW)
#endif

#if defined(WWSB_NOFE)
VOID
SB_WriteRegionToScreenHW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    )
#else
VOID
FE_WriteRegionToScreenHW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    )
#endif
{
    SHORT ScreenY,ScreenX;
    SHORT WindowY,WindowX,WindowSizeX;
    PCHAR_INFO ScreenBufPtr,ScreenBufPtrTmp;    // points to place to read in screen buffer
    PCHAR_INFO ScreenBufSrc;
    COORD TargetSize,SourcePoint;
    SMALL_RECT Target;
    COORD WindowOrigin;
#ifdef WWSB_FE
    PCHAR_IMAGE_INFO CharImageBufPtr,CharImageBufPtrTmp;
    PCHAR_IMAGE_INFO CharImageBufSrc;
    PFONT_IMAGE FontImage;
#endif
    ULONG ModeIndex = ScreenInfo->BufferInfo.TextInfo.ModeIndex;
    COORD FsFontSize1 = RegModeFontPairs[ModeIndex].FontSize;
    COORD FsFontSize2 = FsFontSize1;
    NTSTATUS Status;

#ifdef WWSB_FE
    SMALL_RECT CaTextRect;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo = ScreenInfo->ConvScreenInfo;
    PSCREEN_INFORMATION CurrentScreenBuffer = ScreenInfo->Console->CurrentScreenBuffer;
#endif

    FsFontSize2.X *= 2;

#ifdef WWSB_NOFE
    if (ScreenInfo->Console->FontCacheInformation == NULL) {
        Status = SetRAMFontCodePage(ScreenInfo);
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }
#endif

    if (ScreenInfo->Console->Flags & CONSOLE_VDM_REGISTERED) {
        return;
    }

#ifdef WWSB_FE
    if (ConvAreaInfo) {
        CaTextRect.Left = Region->Left - CurrentScreenBuffer->Window.Left - ConvAreaInfo->CaInfo.coordConView.X;
        CaTextRect.Right = CaTextRect.Left + (Region->Right - Region->Left);
        CaTextRect.Top   = Region->Top - CurrentScreenBuffer->Window.Top - ConvAreaInfo->CaInfo.coordConView.Y;
        CaTextRect.Bottom = CaTextRect.Top + (Region->Bottom - Region->Top);
    }
#endif

    TargetSize.X = Region->Right - Region->Left + 1;
    TargetSize.Y = Region->Bottom - Region->Top + 1;
    ScreenBufPtrTmp = ScreenBufPtr = ConsoleHeapAlloc(TMP_TAG, sizeof(CHAR_INFO) * TargetSize.X * TargetSize.Y);
    if (ScreenBufPtr == NULL) {
        return;
    }
#ifdef WWSB_FE
    CharImageBufPtrTmp = CharImageBufPtr = ConsoleHeapAlloc(TMP_TAG, sizeof(CHAR_IMAGE_INFO) * TargetSize.X * TargetSize.Y);
    if (CharImageBufPtr == NULL) {
        ConsoleHeapFree(ScreenBufPtrTmp);
        return;
    }
    if (ConvAreaInfo) {
        SourcePoint.X = CaTextRect.Left;
        SourcePoint.Y = CaTextRect.Top;
    } else {
        SourcePoint.X = Region->Left;
        SourcePoint.Y = Region->Top;
    }
#else
    SourcePoint.X = Region->Left;
    SourcePoint.Y = Region->Top;
#endif
    Target.Left = 0;
    Target.Top = 0;
    Target.Right = TargetSize.X-1;
    Target.Bottom = TargetSize.Y-1;
    ReadRectFromScreenBuffer(ScreenInfo,
                             SourcePoint,
                             ScreenBufPtr,
                             TargetSize,
                             &Target
                            );

    //
    // make sure region lies within window
    //

    if (Region->Bottom > ScreenInfo->Window.Bottom) {
        WindowOrigin.X = 0;
        WindowOrigin.Y = Region->Bottom - ScreenInfo->Window.Bottom;
        SetWindowOrigin(ScreenInfo, FALSE, WindowOrigin);
    }

#ifdef WWSB_FE
    if (ConvAreaInfo) {
        WindowY = Region->Top - CurrentScreenBuffer->Window.Top;
        WindowX = Region->Left - CurrentScreenBuffer->Window.Left;
    }
    else {
        WindowY = Region->Top - ScreenInfo->Window.Top;
        WindowX = Region->Left - ScreenInfo->Window.Left;
    }
#else
    WindowY = Region->Top - ScreenInfo->Window.Top;
    WindowX = Region->Left - ScreenInfo->Window.Left;
#endif
    WindowSizeX = CONSOLE_WINDOW_SIZE_X(ScreenInfo);

    for (ScreenY = Region->Top;
         ScreenY <= Region->Bottom;
         ScreenY++, WindowY++) {

#ifdef WWSB_FE
        CharImageBufSrc = CharImageBufPtr;
        SetRAMFont(ScreenInfo, ScreenBufPtr, WINDOW_SIZE_X(Region));
#else
        ULONG CurFrameBufPtr;   // offset in frame buffer

        CurFrameBufPtr = SCREEN_BUFFER_POINTER(WindowX,
                                               WindowY,
                                               WindowSizeX,
                                               sizeof(VGA_CHAR));
#endif
        ScreenBufSrc = ScreenBufPtr;


        for (ScreenX = Region->Left;
             ScreenX <= Region->Right;
             ScreenX++, ScreenBufPtr++) {

#ifdef WWSB_FE
            CharImageBufPtr->CharInfo = *ScreenBufPtr;
            Status = GetFontImagePointer(ScreenInfo->Console->FontCacheInformation,
                                         ScreenBufPtr->Char.UnicodeChar,
                                         ScreenBufPtr->Attributes & COMMON_LVB_SBCSDBCS ?
                                             FsFontSize2 : FsFontSize1,
                                         &FontImage);
            if (! NT_SUCCESS(Status))
            {
                CharImageBufPtr->FontImageInfo.FontSize.X = 0;
                CharImageBufPtr->FontImageInfo.FontSize.Y = 0;
                CharImageBufPtr->FontImageInfo.ImageBits = NULL;
            }
            else
            {
                CharImageBufPtr->FontImageInfo.FontSize  = FontImage->FontSize;
                CharImageBufPtr->FontImageInfo.ImageBits = FontImage->ImageBits;
            }
            CharImageBufPtr++;
#else
            //
            // if the char is > 127, we have to convert it back to OEM.
            //
            if (ScreenBufPtr->Char.UnicodeChar > 127) {
                ScreenBufPtr->Char.AsciiChar = WcharToChar(
                        ScreenInfo->Console->OutputCP,
                        ScreenBufPtr->Char.UnicodeChar);
            }
#endif
        }

#ifdef WWSB_FE
        {
            FSCNTL_SCREEN_INFO FsCntl;

            FsCntl.Position.X = WindowX;
            FsCntl.Position.Y = WindowY;
            FsCntl.ScreenSize.X = WindowSizeX;
            FsCntl.ScreenSize.Y = CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
            FsCntl.nNumberOfChars = WINDOW_SIZE_X(Region);
            GdiFullscreenControl(FullscreenControlWriteToFrameBufferDB,
                                 CharImageBufSrc,
                                 (Region->Right - Region->Left + 1) *
                                     sizeof(CHAR_IMAGE_INFO),
                                 &FsCntl,
                                 (PULONG)sizeof(FsCntl));

        }
#else
        GdiFullscreenControl(FullscreenControlWriteToFrameBuffer,
                                ScreenBufSrc,
                                (Region->Right - Region->Left + 1) *
                                    sizeof(CHAR_INFO),
                                (PULONG) CurFrameBufPtr,
                                (PULONG) ((Region->Right - Region->Left + 1) *
                                    sizeof(VGA_CHAR)));
#endif

    }

    ConsoleHeapFree(ScreenBufPtrTmp);
#ifdef WWSB_FE
    ConsoleHeapFree(CharImageBufPtrTmp);
#endif

    ReverseMousePointer(ScreenInfo, Region);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntcon\server\_stream.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    _stream.h

Abstract:

    Performance critical routine for Single Binary

    Each function will be created with two flavors FE and non FE

Author:

    KazuM Jun.09.1997

Revision History:

--*/

#define WWSB_NEUTRAL_FILE 1

#if !defined(FE_SB)
#error This header file should be included with FE_SB
#endif

#if !defined(WWSB_FE) && !defined(WWSB_NOFE)
#error Either WWSB_FE and WWSB_NOFE must be defined.
#endif

#if defined(WWSB_FE) && defined(WWSB_NOFE)
#error Both WWSB_FE and WWSB_NOFE defined.
#endif

#ifdef WWSB_FE
#pragma alloc_text(FE_TEXT, FE_AdjustCursorPosition)
#pragma alloc_text(FE_TEXT, FE_WriteChars)
#pragma alloc_text(FE_TEXT, FE_DoWriteConsole)
#pragma alloc_text(FE_TEXT, FE_DoSrvWriteConsole)
#endif


NTSTATUS
WWSB_AdjustCursorPosition(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD CursorPosition,
    IN BOOL KeepCursorVisible,
    OUT PSHORT ScrollY OPTIONAL
    )

/*++

Routine Description:

    This routine updates the cursor position.  Its input is the non-special
    cased new location of the cursor.  For example, if the cursor were being
    moved one space backwards from the left edge of the screen, the X
    coordinate would be -1.  This routine would set the X coordinate to
    the right edge of the screen and decrement the Y coordinate by one.

Arguments:

    ScreenInfo - Pointer to screen buffer information structure.

    CursorPosition - New location of cursor.

    KeepCursorVisible - TRUE if changing window origin desirable when hit right edge

Return Value:

--*/

{
    COORD WindowOrigin;
    NTSTATUS Status;
#ifdef WWSB_FE
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    if (!(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER))
        return STATUS_SUCCESS;
#endif

    if (CursorPosition.X < 0) {
        if (CursorPosition.Y > 0) {
            CursorPosition.X = (SHORT)(ScreenInfo->ScreenBufferSize.X+CursorPosition.X);
            CursorPosition.Y = (SHORT)(CursorPosition.Y-1);
        }
        else {
            CursorPosition.X = 0;
        }
    }
    else if (CursorPosition.X >= ScreenInfo->ScreenBufferSize.X) {

        //
        // at end of line. if wrap mode, wrap cursor.  otherwise leave it
        // where it is.
        //

        if (ScreenInfo->OutputMode & ENABLE_WRAP_AT_EOL_OUTPUT) {
            CursorPosition.Y += CursorPosition.X / ScreenInfo->ScreenBufferSize.X;
            CursorPosition.X = CursorPosition.X % ScreenInfo->ScreenBufferSize.X;
        }
        else {
            CursorPosition.X = ScreenInfo->BufferInfo.TextInfo.CursorPosition.X;
        }
    }
#ifdef WWSB_FE
    if (CursorPosition.Y >= ScreenInfo->ScreenBufferSize.Y &&
        !(Console->InputBuffer.ImeMode.Open)
       )
#else
    if (CursorPosition.Y >= ScreenInfo->ScreenBufferSize.Y)
#endif
    {

        //
        // at end of buffer.  scroll contents of screen buffer so new
        // position is visible.
        //

        ASSERT (CursorPosition.Y == ScreenInfo->ScreenBufferSize.Y);
        StreamScrollRegion(ScreenInfo);

        if (ARGUMENT_PRESENT(ScrollY)) {
            *ScrollY += (SHORT)(ScreenInfo->ScreenBufferSize.Y - CursorPosition.Y - 1);
        }
        CursorPosition.Y += (SHORT)(ScreenInfo->ScreenBufferSize.Y - CursorPosition.Y - 1);
    }
#ifdef WWSB_FE
    else if (!(Console->InputBuffer.ImeMode.Disable) && Console->InputBuffer.ImeMode.Open)
    {
        if (CursorPosition.Y == (ScreenInfo->ScreenBufferSize.Y-1)) {
            ConsoleImeBottomLineUse(ScreenInfo,2);
            if (ARGUMENT_PRESENT(ScrollY)) {
                *ScrollY += (SHORT)(ScreenInfo->ScreenBufferSize.Y - CursorPosition.Y - 2);
            }
            CursorPosition.Y += (SHORT)(ScreenInfo->ScreenBufferSize.Y - CursorPosition.Y - 2);
            if (!ARGUMENT_PRESENT(ScrollY) && Console->lpCookedReadData) {
                ((PCOOKED_READ_DATA)(Console->lpCookedReadData))->OriginalCursorPosition.Y--;
            }
        }
        else if (CursorPosition.Y == ScreenInfo->Window.Bottom) {
            ;
        }
    }
#endif

    //
    // if at right or bottom edge of window, scroll right or down one char.
    //

#ifdef WWSB_FE
    if (CursorPosition.Y > ScreenInfo->Window.Bottom &&
        !(Console->InputBuffer.ImeMode.Open)
       )
#else
    if (CursorPosition.Y > ScreenInfo->Window.Bottom)
#endif
    {
        WindowOrigin.X = 0;
        WindowOrigin.Y = CursorPosition.Y - ScreenInfo->Window.Bottom;
        Status = SetWindowOrigin(ScreenInfo,
                               FALSE,
                               WindowOrigin
                              );
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }
#ifdef WWSB_FE
    else if (Console->InputBuffer.ImeMode.Open)
    {
        if (CursorPosition.Y >= ScreenInfo->Window.Bottom &&
            CONSOLE_WINDOW_SIZE_Y(ScreenInfo) > 1
           ) {
            WindowOrigin.X = 0;
            WindowOrigin.Y = CursorPosition.Y - ScreenInfo->Window.Bottom + 1;
            Status = SetWindowOrigin(ScreenInfo,
                                        FALSE,
                                        WindowOrigin
                                       );
            if (!NT_SUCCESS(Status)) {
                return Status;
            }
        }
    }
#endif
    if (KeepCursorVisible) {
        MakeCursorVisible(ScreenInfo,CursorPosition);
    }
    Status = SetCursorPosition(ScreenInfo,
                               CursorPosition,
                               KeepCursorVisible
                              );
    return Status;
}

#define LOCAL_BUFFER_SIZE 100

NTSTATUS
WWSB_WriteChars(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PWCHAR lpBufferBackupLimit,
    IN PWCHAR lpBuffer,
    IN PWCHAR lpRealUnicodeString,
    IN OUT PDWORD NumBytes,
    OUT PLONG NumSpaces OPTIONAL,
    IN SHORT OriginalXPosition,
    IN DWORD dwFlags,
    OUT PSHORT ScrollY OPTIONAL
    )

/*++

Routine Description:

    This routine writes a string to the screen, processing any embedded
    unicode characters.  The string is also copied to the input buffer, if
    the output mode is line mode.

Arguments:

    ScreenInfo - Pointer to screen buffer information structure.

    lpBufferBackupLimit - Pointer to beginning of buffer.

    lpBuffer - Pointer to buffer to copy string to.  assumed to be at least
    as long as lpRealUnicodeString.  This pointer is updated to point to the
    next position in the buffer.

    lpRealUnicodeString - Pointer to string to write.

    NumBytes - On input, number of bytes to write.  On output, number of
    bytes written.

    NumSpaces - On output, the number of spaces consumed by the written characters.

    dwFlags -
      WC_DESTRUCTIVE_BACKSPACE backspace overwrites characters.
      WC_KEEP_CURSOR_VISIBLE   change window origin desirable when hit rt. edge
      WC_ECHO                  if called by Read (echoing characters)
      WC_FALSIFY_UNICODE       if RealUnicodeToFalseUnicode need be called.

Return Value:

Note:

    This routine does not process tabs and backspace properly.  That code
    will be implemented as part of the line editing services.

--*/

{
    DWORD BufferSize;
    COORD CursorPosition;
    NTSTATUS Status;
    ULONG NumChars;
    static WCHAR Blanks[TAB_SIZE] = { UNICODE_SPACE,
                                      UNICODE_SPACE,
                                      UNICODE_SPACE,
                                      UNICODE_SPACE,
                                      UNICODE_SPACE,
                                      UNICODE_SPACE,
                                      UNICODE_SPACE,
                                      UNICODE_SPACE };
    SHORT XPosition;
    WCHAR LocalBuffer[LOCAL_BUFFER_SIZE];
    PWCHAR LocalBufPtr;
    ULONG i,j;
    SMALL_RECT Region;
    ULONG TabSize;
    DWORD TempNumSpaces;
    WCHAR Char;
    WCHAR RealUnicodeChar;
    WORD Attributes;
    PWCHAR lpString;
    PWCHAR lpAllocatedString;
    BOOL fUnprocessed = ((ScreenInfo->OutputMode & ENABLE_PROCESSED_OUTPUT) == 0);
#ifdef WWSB_FE
    CHAR LocalBufferA[LOCAL_BUFFER_SIZE];
    PCHAR LocalBufPtrA;
#endif

    ConsoleHideCursor(ScreenInfo);

    Attributes = ScreenInfo->Attributes;
    BufferSize = *NumBytes;
    *NumBytes = 0;
    TempNumSpaces = 0;

    lpAllocatedString = NULL;
    if (dwFlags & WC_FALSIFY_UNICODE) {
        // translation from OEM -> ANSI -> OEM doesn't
        // necessarily yield the same value, so do
        // translation in a separate buffer.

        lpString = ConsoleHeapAlloc(TMP_TAG, BufferSize);
        if (lpString == NULL) {
            Status = STATUS_NO_MEMORY;
            goto ExitWriteChars;
        }

        lpAllocatedString = lpString;
        RtlCopyMemory(lpString, lpRealUnicodeString, BufferSize);
        Status = RealUnicodeToFalseUnicode(lpString,
                                         BufferSize / sizeof(WCHAR),
                                         ScreenInfo->Console->OutputCP
                                        );
        if (!NT_SUCCESS(Status)) {
            goto ExitWriteChars;
        }
    } else {
       lpString = lpRealUnicodeString;
    }

    while (*NumBytes < BufferSize) {

        //
        // as an optimization, collect characters in buffer and
        // print out all at once.
        //

        XPosition = ScreenInfo->BufferInfo.TextInfo.CursorPosition.X;
        i=0;
        LocalBufPtr = LocalBuffer;
#ifdef WWSB_FE
        LocalBufPtrA = LocalBufferA;
#endif
        while (*NumBytes < BufferSize &&
               i < LOCAL_BUFFER_SIZE &&
               XPosition < ScreenInfo->ScreenBufferSize.X) {
            Char = *lpString;
            RealUnicodeChar = *lpRealUnicodeString;
            if (!IS_GLYPH_CHAR(RealUnicodeChar) || fUnprocessed) {
#ifdef WWSB_FE
                if (IsConsoleFullWidth(ScreenInfo->Console->hDC,
                                       ScreenInfo->Console->OutputCP,Char)) {
                    if (i < (LOCAL_BUFFER_SIZE-1) &&
                        XPosition < (ScreenInfo->ScreenBufferSize.X-1)) {
                        *LocalBufPtr++ = Char;
                        *LocalBufPtrA++ = ATTR_LEADING_BYTE;
                        *LocalBufPtr++ = Char;
                        *LocalBufPtrA++ = ATTR_TRAILING_BYTE;
                        XPosition+=2;
                        i+=2;
                        lpBuffer++;
                    }
                    else
                        goto EndWhile;
                }
                else {
#endif
                    *LocalBufPtr = Char;
                    LocalBufPtr++;
                    XPosition++;
                    i++;
                    lpBuffer++;
#ifdef WWSB_FE
                    *LocalBufPtrA++ = 0;
                }
#endif
            } else {
                ASSERT(ScreenInfo->OutputMode & ENABLE_PROCESSED_OUTPUT);
                switch (RealUnicodeChar) {
                    case UNICODE_BELL:
                        if (dwFlags & WC_ECHO) {
                            goto CtrlChar;
                        } else {
                            SendNotifyMessage(ScreenInfo->Console->hWnd,
                                              CM_BEEP,
                                              0,
                                              0x47474747);
                        }
                        break;
                    case UNICODE_BACKSPACE:

                        // automatically go to EndWhile.  this is because
                        // backspace is not destructive, so "aBkSp" prints
                        // a with the cursor on the "a". we could achieve
                        // this behavior staying in this loop and figuring out
                        // the string that needs to be printed, but it would
                        // be expensive and it's the exceptional case.

                        goto EndWhile;
                        break;
                    case UNICODE_TAB:
                        TabSize = NUMBER_OF_SPACES_IN_TAB(XPosition);
                        XPosition = (SHORT)(XPosition + TabSize);
                        if (XPosition >= ScreenInfo->ScreenBufferSize.X) {
                            goto EndWhile;
                        }
                        for (j=0;j<TabSize && i<LOCAL_BUFFER_SIZE;j++,i++) {
                            *LocalBufPtr = (WCHAR)' ';
                            LocalBufPtr++;
#ifdef WWSB_FE
                            *LocalBufPtrA++ = 0;
#endif
                        }
                        lpBuffer++;
                        break;
                    case UNICODE_LINEFEED:
                    case UNICODE_CARRIAGERETURN:
                        goto EndWhile;
                    default:

                        //
                        // if char is ctrl char, write ^char.
                        //

                        if ((dwFlags & WC_ECHO) && (IS_CONTROL_CHAR(RealUnicodeChar))) {

CtrlChar:                   if (i < (LOCAL_BUFFER_SIZE-1)) {
                                *LocalBufPtr = (WCHAR)'^';
                                LocalBufPtr++;
                                XPosition++;
                                i++;
                                *LocalBufPtr = (WCHAR)(RealUnicodeChar+(WCHAR)'@');
                                LocalBufPtr++;
                                XPosition++;
                                i++;
                                lpBuffer++;
#ifdef WWSB_FE
                                *LocalBufPtrA++ = 0;
                                *LocalBufPtrA++ = 0;
#endif
                            }
                            else {
                                goto EndWhile;
                            }
                        } else {
                            if (!(ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) ||
                                    (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
                                /*
                                 * As a special favor to incompetent apps
                                 * that attempt to display control chars,
                                 * convert to corresponding OEM Glyph Chars
                                 */
#ifdef WWSB_FE
                                WORD CharType;

                                GetStringTypeW(CT_CTYPE1,&RealUnicodeChar,1,&CharType);
                                if (CharType == C1_CNTRL)
                                    ConvertOutputToUnicode(ScreenInfo->Console->OutputCP,
                                                           &(char)RealUnicodeChar,
                                                           1,
                                                           LocalBufPtr,
                                                           1);
                                else
                                    *LocalBufPtr = Char;
#else
                                *LocalBufPtr = SB_CharToWcharGlyph(
                                        ScreenInfo->Console->OutputCP,
                                        (char)RealUnicodeChar);
#endif
                            } else {
                                *LocalBufPtr = Char;
                            }
                            LocalBufPtr++;
                            XPosition++;
                            i++;
                            lpBuffer++;
#ifdef WWSB_FE
                            *LocalBufPtrA++ = 0;
#endif
                        }
                }
            }
            lpString++;
            lpRealUnicodeString++;
            *NumBytes += sizeof(WCHAR);
        }
EndWhile:
        if (i != 0) {

            //
            // Make sure we don't write past the end of the buffer.
            //

            if (i > (ULONG)ScreenInfo->ScreenBufferSize.X - ScreenInfo->BufferInfo.TextInfo.CursorPosition.X) {
                i = (ULONG)ScreenInfo->ScreenBufferSize.X - ScreenInfo->BufferInfo.TextInfo.CursorPosition.X;
            }

#ifdef WWSB_FE
            FE_StreamWriteToScreenBuffer(LocalBuffer,
                                         (SHORT)i,
                                         ScreenInfo,
                                         LocalBufferA
                                        );
#else
            SB_StreamWriteToScreenBuffer(LocalBuffer,
                                         (SHORT)i,
                                         ScreenInfo
                                        );
#endif
            Region.Left = ScreenInfo->BufferInfo.TextInfo.CursorPosition.X;
            Region.Right = (SHORT)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.X + i - 1);
            Region.Top = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
            Region.Bottom = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
            WWSB_WriteToScreen(ScreenInfo,&Region);
            TempNumSpaces += i;
            CursorPosition.X = (SHORT)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.X + i);
            CursorPosition.Y = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
            Status = WWSB_AdjustCursorPosition(ScreenInfo,CursorPosition,
                    dwFlags & WC_KEEP_CURSOR_VISIBLE,ScrollY);
            if (*NumBytes == BufferSize) {
                ConsoleShowCursor(ScreenInfo);
                if (ARGUMENT_PRESENT(NumSpaces)) {
                    *NumSpaces = TempNumSpaces;
                }
                Status = STATUS_SUCCESS;
                goto ExitWriteChars;
            }
            continue;
        } else if (*NumBytes == BufferSize) {

            ASSERT(ScreenInfo->OutputMode & ENABLE_PROCESSED_OUTPUT);
            // this catches the case where the number of backspaces ==
            // the number of characters.
            if (ARGUMENT_PRESENT(NumSpaces)) {
                *NumSpaces = TempNumSpaces;
            }
            ConsoleShowCursor(ScreenInfo);
            Status = STATUS_SUCCESS;
            goto ExitWriteChars;
        }

        ASSERT(ScreenInfo->OutputMode & ENABLE_PROCESSED_OUTPUT);
        switch (*lpString) {
            case UNICODE_BACKSPACE:

                //
                // move cursor backwards one space. overwrite current char with blank.
                //
                // we get here because we have to backspace from the beginning of the line

                CursorPosition = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
                TempNumSpaces -= 1;
                if (lpBuffer == lpBufferBackupLimit) {
                    CursorPosition.X-=1;
                }
                else {
                    PWCHAR pBuffer;
                    WCHAR TmpBuffer[LOCAL_BUFFER_SIZE];
                    PWCHAR Tmp,Tmp2;
                    WCHAR LastChar;
                    ULONG i;

                    if (lpBuffer-lpBufferBackupLimit > LOCAL_BUFFER_SIZE) {
                        pBuffer = ConsoleHeapAlloc(TMP_TAG, (ULONG)(lpBuffer-lpBufferBackupLimit) * sizeof(WCHAR));
                        if (pBuffer == NULL) {
                            Status = STATUS_NO_MEMORY;
                            goto ExitWriteChars;
                        }
                    } else {
                        pBuffer = TmpBuffer;
                    }

                    for (i=0,Tmp2=pBuffer,Tmp=lpBufferBackupLimit;
                         i<(ULONG)(lpBuffer-lpBufferBackupLimit);
                         i++,Tmp++) {
                        if (*Tmp == UNICODE_BACKSPACE) {
                            if (Tmp2 > pBuffer) {
                                Tmp2--;
                            }
                        } else {
                            ASSERT(Tmp2 >= pBuffer);
                            *Tmp2++ = *Tmp;
                        }

                    }
                    if (Tmp2 == pBuffer) {
                        LastChar = (WCHAR)' ';
                    } else {
                        LastChar = *(Tmp2-1);
                    }
                    if (pBuffer != TmpBuffer) {
                        ConsoleHeapFree(pBuffer);
                    }

                    if (LastChar == UNICODE_TAB) {
                        CursorPosition.X -=
                            (SHORT)(RetrieveNumberOfSpaces(OriginalXPosition,
                                                           lpBufferBackupLimit,
                                                           (ULONG)(lpBuffer - lpBufferBackupLimit - 1),
                                                           ScreenInfo->Console,
                                                           ScreenInfo->Console->OutputCP
                                                          ));
                        if (CursorPosition.X < 0) {
                            CursorPosition.X = (ScreenInfo->ScreenBufferSize.X - 1)/TAB_SIZE;
                            CursorPosition.X *= TAB_SIZE;
                            CursorPosition.X += 1;
                            CursorPosition.Y -= 1;
                        }
                    }
                    else if (IS_CONTROL_CHAR(LastChar)) {
                        CursorPosition.X-=1;
                        TempNumSpaces -= 1;

                        //
                        // overwrite second character of ^x sequence.
                        //

                        if (dwFlags & WC_DESTRUCTIVE_BACKSPACE) {
                            NumChars = 1;
                            Status = WWSB_WriteOutputString(ScreenInfo,
                                Blanks, CursorPosition,
                                CONSOLE_FALSE_UNICODE, // faster than real unicode
                                &NumChars, NULL);
                            Status = WWSB_FillOutput(ScreenInfo,
                                Attributes, CursorPosition,
                                CONSOLE_ATTRIBUTE, &NumChars);
                        }
                        CursorPosition.X-=1;
                    }
#ifdef WWSB_FE
                    else if (IsConsoleFullWidth(ScreenInfo->Console->hDC,
                                                ScreenInfo->Console->OutputCP,LastChar))
                    {
                        CursorPosition.X-=1;
                        TempNumSpaces -= 1;

                        Status = WWSB_AdjustCursorPosition(ScreenInfo,CursorPosition,
                                     dwFlags & WC_KEEP_CURSOR_VISIBLE,ScrollY);
                        if (dwFlags & WC_DESTRUCTIVE_BACKSPACE) { // bug 7672
                            NumChars = 1;
                            Status = WWSB_WriteOutputString(ScreenInfo,
                                Blanks, ScreenInfo->BufferInfo.TextInfo.CursorPosition,
                                CONSOLE_FALSE_UNICODE, // faster than real unicode
                                &NumChars, NULL);
                            Status = WWSB_FillOutput(ScreenInfo,
                                Attributes, ScreenInfo->BufferInfo.TextInfo.CursorPosition,
                                CONSOLE_ATTRIBUTE, &NumChars);
                        }
                        CursorPosition.X-=1;
                    }
#endif
                    else {
                        CursorPosition.X--;
                    }
                }
                if ((dwFlags & WC_LIMIT_BACKSPACE) && (CursorPosition.X < 0)) {
                    CursorPosition.X = 0;
                    KdPrint(("CONSRV: Ignoring backspace to previous line\n"));
                }
                Status = WWSB_AdjustCursorPosition(ScreenInfo,CursorPosition,
                        (dwFlags & WC_KEEP_CURSOR_VISIBLE) != 0,ScrollY);
                if (dwFlags & WC_DESTRUCTIVE_BACKSPACE) {
                    NumChars = 1;
                    Status = WWSB_WriteOutputString(ScreenInfo,
                        Blanks, ScreenInfo->BufferInfo.TextInfo.CursorPosition,
                        CONSOLE_FALSE_UNICODE, //faster than real unicode
                        &NumChars, NULL);
                    Status = WWSB_FillOutput(ScreenInfo,
                        Attributes, ScreenInfo->BufferInfo.TextInfo.CursorPosition,
                        CONSOLE_ATTRIBUTE, &NumChars);
                }
#ifdef WWSB_FE
                if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.X == 0 &&
                    (ScreenInfo->OutputMode & ENABLE_WRAP_AT_EOL_OUTPUT) &&
                    lpBuffer > lpBufferBackupLimit) {
                    if (CheckBisectProcessW(ScreenInfo,
                                            ScreenInfo->Console->OutputCP,
                                            lpBufferBackupLimit,
                                            (ULONG)(lpBuffer+1-lpBufferBackupLimit),
                                            ScreenInfo->ScreenBufferSize.X-OriginalXPosition,
                                            OriginalXPosition,
                                            dwFlags & WC_ECHO)) {
                        CursorPosition.X = ScreenInfo->ScreenBufferSize.X-1;
                        CursorPosition.Y = (SHORT)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y-1);
                        Status = WWSB_AdjustCursorPosition(ScreenInfo,CursorPosition,
                                     dwFlags & WC_KEEP_CURSOR_VISIBLE,ScrollY);
                    }
                }
#endif
                break;
            case UNICODE_TAB:
                TabSize = NUMBER_OF_SPACES_IN_TAB(ScreenInfo->BufferInfo.TextInfo.CursorPosition.X);
                CursorPosition.X = (SHORT)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.X + TabSize);

                //
                // move cursor forward to next tab stop.  fill space with blanks.
                // we get here when the tab extends beyond the right edge of the
                // window.  if the tab goes wraps the line, set the cursor to the first
                // position in the next line.
                //

                lpBuffer++;

                TempNumSpaces += TabSize;
                if (CursorPosition.X >= ScreenInfo->ScreenBufferSize.X) {
                    NumChars = ScreenInfo->ScreenBufferSize.X - ScreenInfo->BufferInfo.TextInfo.CursorPosition.X;
                    CursorPosition.X = 0;
                    CursorPosition.Y = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y+1;
                }
                else {
                    NumChars = CursorPosition.X - ScreenInfo->BufferInfo.TextInfo.CursorPosition.X;
                    CursorPosition.Y = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
                }
                Status = WWSB_WriteOutputString(ScreenInfo,
                                                Blanks,
                                                ScreenInfo->BufferInfo.TextInfo.CursorPosition,
                                                CONSOLE_FALSE_UNICODE, // faster than real unicode
                                                &NumChars,
                                                NULL);
                Status = WWSB_FillOutput(ScreenInfo,
                                         Attributes, ScreenInfo->BufferInfo.TextInfo.CursorPosition,
                                         CONSOLE_ATTRIBUTE,
                                         &NumChars);
                Status = WWSB_AdjustCursorPosition(ScreenInfo,CursorPosition,
                        (dwFlags & WC_KEEP_CURSOR_VISIBLE) != 0,ScrollY);
                break;
            case UNICODE_CARRIAGERETURN:

                //
                // Carriage return moves the cursor to the beginning of the line.
                // We don't need to worry about handling cr or lf for
                // backspace because input is sent to the user on cr or lf.
                //

                lpBuffer++;
                CursorPosition.X = 0;
                CursorPosition.Y = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
                Status = WWSB_AdjustCursorPosition(ScreenInfo,CursorPosition,
                        (dwFlags & WC_KEEP_CURSOR_VISIBLE) != 0,ScrollY);
                break;
            case UNICODE_LINEFEED:

                //
                // move cursor to the beginning of the next line.
                //

                lpBuffer++;
                CursorPosition.X = 0;
                CursorPosition.Y = (SHORT)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y+1);
                Status = WWSB_AdjustCursorPosition(ScreenInfo,CursorPosition,
                        (dwFlags & WC_KEEP_CURSOR_VISIBLE) != 0,ScrollY);
                break;
            default:
#ifdef WWSB_FE
                Char = *lpString;
                if (Char >= (WCHAR)' ' &&
                    IsConsoleFullWidth(ScreenInfo->Console->hDC,
                                       ScreenInfo->Console->OutputCP,Char) &&
                    XPosition >= (ScreenInfo->ScreenBufferSize.X-1) &&
                    (ScreenInfo->OutputMode & ENABLE_WRAP_AT_EOL_OUTPUT)) {

                    SHORT RowIndex;
                    PROW Row;
                    PWCHAR Char;
                    COORD TargetPoint;
                    PCHAR AttrP;

                    TargetPoint = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
                    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetPoint.Y) % ScreenInfo->ScreenBufferSize.Y;
                    Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
                    Char = &Row->CharRow.Chars[TargetPoint.X];
                    AttrP = &Row->CharRow.KAttrs[TargetPoint.X];

                    if (*AttrP & ATTR_TRAILING_BYTE)
                    {
                        *(Char-1) = UNICODE_SPACE;
                        *Char = UNICODE_SPACE;
                        *AttrP = 0;
                        *(AttrP-1) = 0;

                        Region.Left = ScreenInfo->BufferInfo.TextInfo.CursorPosition.X-1;
                        Region.Right = (SHORT)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.X);
                        Region.Top = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
                        Region.Bottom = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
                        WWSB_WriteToScreen(ScreenInfo,&Region);
                    }

                    CursorPosition.X = 0;
                    CursorPosition.Y = (SHORT)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y+1);
                    Status = WWSB_AdjustCursorPosition(ScreenInfo,CursorPosition,
                                 dwFlags & WC_KEEP_CURSOR_VISIBLE,ScrollY);
                    continue;
                }
#endif
                break;
        }
        if (!NT_SUCCESS(Status)) {
            ConsoleShowCursor(ScreenInfo);
            goto ExitWriteChars;
        }

       *NumBytes += sizeof(WCHAR);
       lpString++;
       lpRealUnicodeString++;
    }

    if (ARGUMENT_PRESENT(NumSpaces)) {
        *NumSpaces = TempNumSpaces;
    }
    ConsoleShowCursor(ScreenInfo);

    Status = STATUS_SUCCESS;

ExitWriteChars:
    if (lpAllocatedString) {
        ConsoleHeapFree(lpAllocatedString);
    }
    return Status;
}

ULONG
WWSB_DoWriteConsole(
    IN OUT PCSR_API_MSG m,
    IN PCONSOLE_INFORMATION Console,
    IN PCSR_THREAD Thread
    )

//
// NOTE: console lock must be held when calling this routine
//
// string has been translated to unicode at this point
//

{
    PCONSOLE_WRITECONSOLE_MSG a = (PCONSOLE_WRITECONSOLE_MSG)&m->u.ApiMessageData;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;
    PSCREEN_INFORMATION ScreenInfo;
    DWORD NumCharsToWrite;
#ifdef WWSB_FE
    DWORD i;
    SHORT j;
#endif

    if (Console->Flags & (CONSOLE_SUSPENDED | CONSOLE_SELECTING | CONSOLE_SCROLLBAR_TRACKING)) {
        PWCHAR TransBuffer;

        TransBuffer = ConsoleHeapAlloc(TMP_TAG, a->NumBytes);
        if (TransBuffer == NULL) {
            return (ULONG)STATUS_NO_MEMORY;
        }
        RtlCopyMemory(TransBuffer,a->TransBuffer,a->NumBytes);
        a->TransBuffer = TransBuffer;
        a->StackBuffer = FALSE;
        if (!CsrCreateWait(&Console->OutputQueue,
                          WriteConsoleWaitRoutine,
                          Thread,
                          m,
                          NULL)) {
            ConsoleHeapFree(TransBuffer);
            return (ULONG)STATUS_NO_MEMORY;
        }
        return (ULONG)CONSOLE_STATUS_WAIT;
    }

    Status = DereferenceIoHandle(CONSOLE_FROMTHREADPERPROCESSDATA(Thread),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        a->NumBytes = 0;
        return((ULONG) Status);
    }

    ScreenInfo = HandleData->Buffer.ScreenBuffer;

    //
    // see if we're the typical case - a string containing no special
    // characters, optionally terminated with CRLF.  if so, skip the
    // special processing.
    //

    NumCharsToWrite=a->NumBytes/sizeof(WCHAR);
    if ((ScreenInfo->OutputMode & ENABLE_PROCESSED_OUTPUT) &&
        ((LONG)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.X + NumCharsToWrite) <
          ScreenInfo->ScreenBufferSize.X) ) {
        SMALL_RECT Region;
        COORD CursorPosition;

        if (a->Unicode) {
#ifdef WWSB_FE
            a->WriteFlags = WRITE_SPECIAL_CHARS;
#else
            a->WriteFlags = FastStreamWrite(a->TransBuffer,NumCharsToWrite);
#endif
        }
        if (a->WriteFlags == WRITE_SPECIAL_CHARS) {
            goto ProcessedWrite;
        }

        ConsoleHideCursor(ScreenInfo);

        //
        // WriteFlags is designed so that the number of special characters
        // is also the flag value.
        //

        NumCharsToWrite -= a->WriteFlags;

        if (NumCharsToWrite) {
#ifdef WWSB_FE
            PWCHAR TransBuffer,TransBufPtr,String;
            PBYTE TransBufferA,TransBufPtrA;
            BOOL fLocalHeap = FALSE;
            COORD TargetPoint;

            if (NumCharsToWrite > (ULONG)(ScreenInfo->ScreenBufferSize.X * ScreenInfo->ScreenBufferSize.Y)) {

                TransBuffer = ConsoleHeapAlloc(TMP_DBCS_TAG, NumCharsToWrite * 2 * sizeof(WCHAR));
                if (TransBuffer == NULL) {
                    return (ULONG)STATUS_NO_MEMORY;
                }
                TransBufferA = ConsoleHeapAlloc(TMP_DBCS_TAG, NumCharsToWrite * 2 * sizeof(CHAR));
                if (TransBufferA == NULL) {
                    ConsoleHeapFree(TransBuffer);
                    return (ULONG)STATUS_NO_MEMORY;
                }

                fLocalHeap = TRUE;
            }
            else {
                TransBuffer  = ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferCharacter;
                TransBufferA = ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferAttribute;
            }

            String = a->TransBuffer;
            TransBufPtr = TransBuffer;
            TransBufPtrA = TransBufferA;
            for (i = 0 , j = 0 ; i < NumCharsToWrite ; i++,j++){
                if (IsConsoleFullWidth(ScreenInfo->Console->hDC,
                                       ScreenInfo->Console->OutputCP,*String)){
                    *TransBuffer++ = *String ;
                    *TransBufferA++ = ATTR_LEADING_BYTE;
                    *TransBuffer++ = *String++ ;
                    *TransBufferA++ = ATTR_TRAILING_BYTE;
                    j++;
                }
                else{
                    *TransBuffer++ = *String++ ;
                    *TransBufferA++ = 0;
                }
            }
            TargetPoint = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
            BisectWrite(j,TargetPoint,ScreenInfo);
            if (TargetPoint.Y == ScreenInfo->ScreenBufferSize.Y-1 &&
                TargetPoint.X+j >= ScreenInfo->ScreenBufferSize.X &&
                *(TransBufPtrA+j) & ATTR_LEADING_BYTE){
                *(TransBufPtr+ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) = UNICODE_SPACE;
                *(TransBufPtrA+ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) = 0;
                if (j > ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) {
                    *(TransBufPtr+ScreenInfo->ScreenBufferSize.X-TargetPoint.X) = UNICODE_SPACE;
                    *(TransBufPtrA+ScreenInfo->ScreenBufferSize.X-TargetPoint.X) = 0;
                }
            }
            FE_StreamWriteToScreenBuffer(TransBufPtr,
                                         (SHORT)j,
                                         ScreenInfo,
                                         TransBufPtrA
                                        );
            if (fLocalHeap){
                ConsoleHeapFree(TransBufPtr);
                ConsoleHeapFree(TransBufPtrA);
            }
#else
            SB_StreamWriteToScreenBuffer(a->TransBuffer,
                                         (SHORT)NumCharsToWrite,
                                         ScreenInfo
                                        );
#endif
            Region.Left = ScreenInfo->BufferInfo.TextInfo.CursorPosition.X;
#ifdef WWSB_FE
            Region.Right = (SHORT)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.X + j - 1);
#else
            Region.Right = (SHORT)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.X + NumCharsToWrite - 1);
#endif
            Region.Top = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
            Region.Bottom = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
            ASSERT (Region.Right < ScreenInfo->ScreenBufferSize.X);
            if (ACTIVE_SCREEN_BUFFER(ScreenInfo) &&
                !(ScreenInfo->Console->Flags & CONSOLE_IS_ICONIC && ScreenInfo->Console->FullScreenFlags == 0)) {
                WWSB_WriteRegionToScreen(ScreenInfo,&Region);
            }
        }
        switch (a->WriteFlags) {
            case WRITE_NO_CR_LF:
                CursorPosition.X = (SHORT)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.X + NumCharsToWrite);
                CursorPosition.Y = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
                break;
            case WRITE_CR:
                CursorPosition.X = 0;
                CursorPosition.Y = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
                break;
            case WRITE_CR_LF:
                CursorPosition.X = 0;
                CursorPosition.Y = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y+1;
                break;
            default:
                ASSERT(FALSE);
                break;
        }
        Status = WWSB_AdjustCursorPosition(ScreenInfo,CursorPosition,FALSE,NULL);
        ConsoleShowCursor(ScreenInfo);
        return STATUS_SUCCESS;
    }
ProcessedWrite:
    return WWSB_WriteChars(ScreenInfo,
                      a->TransBuffer,
                      a->TransBuffer,
                      a->TransBuffer,
                      &a->NumBytes,
                      NULL,
                      ScreenInfo->BufferInfo.TextInfo.CursorPosition.X,
                      WC_LIMIT_BACKSPACE,
                      NULL
                     );
}

NTSTATUS
WWSB_DoSrvWriteConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCONSOLE_WRITECONSOLE_MSG a = (PCONSOLE_WRITECONSOLE_MSG)&m->u.ApiMessageData;
    PSCREEN_INFORMATION ScreenInfo;
    WCHAR StackBuffer[STACK_BUFFER_SIZE];
#ifdef WWSB_FE
    BOOL  fLocalHeap = FALSE;
#endif

    ScreenInfo = HandleData->Buffer.ScreenBuffer;

#ifdef WWSB_FE
    // Check code for must CONSOLE_TEXTMODE_BUFFER !!
    ASSERT(!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER));
#endif

    //
    // if the string was passed in the message, rather than in
    // a capture buffer, adjust the pointer.
    //

    if (a->BufferInMessage) {
        a->BufPtr = a->Buffer;
    }

    //
    // if ansi, translate string.  for speed, we don't allocate a
    // capture buffer if the ansi string was <= 80 chars.  if it's
    // greater than 80 / sizeof(WCHAR), the translated string won't
    // fit into the capture buffer, so reset a->BufPtr to point to
    // a heap buffer and set a->CaptureBufferSize so that we don't
    // think the buffer is in the message.
    //

    if (!a->Unicode) {
        PWCHAR TransBuffer;
        DWORD Length;
        DWORD SpecialChars = 0;
        UINT Codepage;
#ifdef WWSB_FE
        PWCHAR TmpTransBuffer;
        ULONG NumBytes1 = 0;
        ULONG NumBytes2 = 0;
#endif

        if (a->NumBytes <= STACK_BUFFER_SIZE) {
            TransBuffer = StackBuffer;
            a->StackBuffer = TRUE;
#ifdef WWSB_FE
            TmpTransBuffer = TransBuffer;
#endif
        }
#ifdef WWSB_FE
        else if (a->NumBytes > (ULONG)(ScreenInfo->ScreenBufferSize.X * ScreenInfo->ScreenBufferSize.Y)) {
            TransBuffer = ConsoleHeapAlloc(TMP_DBCS_TAG, (a->NumBytes + 2) * sizeof(WCHAR));
            if (TransBuffer == NULL) {
                return (ULONG)STATUS_NO_MEMORY;
            }
            TmpTransBuffer = TransBuffer;
            a->StackBuffer = FALSE;
            fLocalHeap = TRUE;
        }
        else {
            TransBuffer = ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransWriteConsole;
            TmpTransBuffer = TransBuffer;
        }
#else
        else {
            TransBuffer = ConsoleHeapAlloc(TMP_TAG, a->NumBytes * sizeof(WCHAR));
            if (TransBuffer == NULL) {
                return (ULONG)STATUS_NO_MEMORY;
            }
            a->StackBuffer = FALSE;
        }
#endif
        //a->NumBytes = ConvertOutputToUnicode(Console->OutputCP,
        //                        Buffer,
        //                        a->NumBytes,
        //                        TransBuffer,
        //                        a->NumBytes);
        // same as ConvertOutputToUnicode
#ifdef WWSB_FE
        if (! ScreenInfo->WriteConsoleDbcsLeadByte[0]) {
            NumBytes1 = 0;
            NumBytes2 = a->NumBytes;
        }
        else {
            if (*(PUCHAR)a->BufPtr < (UCHAR)' ') {
                NumBytes1 = 0;
                NumBytes2 = a->NumBytes;
            }
            else if (a->NumBytes) {
                ScreenInfo->WriteConsoleDbcsLeadByte[1] = *(PCHAR)a->BufPtr;
                NumBytes1 = sizeof(ScreenInfo->WriteConsoleDbcsLeadByte);
                if (Console->OutputCP == OEMCP) {
                    if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                            ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
                        /*
                         * Translate OEM characters into False Unicode for Window-mode
                         * OEM font. If OutputCP != OEMCP, characters will not appear
                         * correctly, because the OEM fonts are designed to support
                         * only OEMCP (we can't switch fonts in Windowed mode).
                         * Fullscreen or TT "Unicode" fonts should be used for
                         * non-OEMCP output
                         */
                        DBGCHARS(("SrvWriteConsole ACP->U %.*s\n",
                                min(NumBytes1,10), a->BufPtr));
                        Status = RtlConsoleMultiByteToUnicodeN(TransBuffer,
                                NumBytes1 * sizeof(WCHAR), &NumBytes1,
                                ScreenInfo->WriteConsoleDbcsLeadByte, NumBytes1, &SpecialChars);
                    } else {
                        /*
                         * Good! We have Fullscreen or TT "Unicode" fonts, so convert
                         * the OEM characters to real Unicode according to OutputCP.
                         * First find out if any special chars are involved.
                         */
                        DBGCHARS(("SrvWriteConsole %d->U %.*s\n", Console->OutputCP,
                                min(NumBytes1,10), a->BufPtr));
                        NumBytes1 = sizeof(WCHAR) * MultiByteToWideChar(Console->OutputCP,
                                0, ScreenInfo->WriteConsoleDbcsLeadByte, NumBytes1, TransBuffer, NumBytes1);
                        if (NumBytes1 == 0) {
                            Status = STATUS_UNSUCCESSFUL;
                        }
                    }
                }
                else {
                    if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                        !(Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
                        if (Console->OutputCP != WINDOWSCP)
                            Codepage = USACP;
                        else
                            Codepage = WINDOWSCP;
                    } else {
                        Codepage = Console->OutputCP;
                    }

                    if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                            ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
                        NumBytes1 = ConvertOutputToUnicode(Codepage,
                                                           ScreenInfo->WriteConsoleDbcsLeadByte,
                                                           NumBytes1,
                                                           TransBuffer,
                                                           NumBytes1);
                    }
                    else {
                        NumBytes1 = MultiByteToWideChar(Console->OutputCP,
                                0, ScreenInfo->WriteConsoleDbcsLeadByte, NumBytes1, TransBuffer, NumBytes1);
                        if (NumBytes1 == 0) {
                            Status = STATUS_UNSUCCESSFUL;
                        }
                    }
                    NumBytes1 *= sizeof(WCHAR);
                }
                TransBuffer++;
                (PCHAR)a->BufPtr += (NumBytes1 / sizeof(WCHAR));
                NumBytes2 = a->NumBytes - 1;
            }
            else {
                NumBytes2 = 0;
            }
            ScreenInfo->WriteConsoleDbcsLeadByte[0] = 0;
        }

        if (NumBytes2 &&
            CheckBisectStringA(Console->OutputCP,a->BufPtr,NumBytes2,&Console->OutputCPInfo)) {
            ScreenInfo->WriteConsoleDbcsLeadByte[0] = *((PCHAR)a->BufPtr+NumBytes2-1);
            NumBytes2--;
        }

        Length = NumBytes2;
#else
        Length = a->NumBytes;
        if (a->NumBytes >= 2 &&
            ((PCHAR)a->BufPtr)[a->NumBytes-1] == '\n' &&
            ((PCHAR)a->BufPtr)[a->NumBytes-2] == '\r') {
            Length -= 2;
            a->WriteFlags = WRITE_CR_LF;
        } else if (a->NumBytes >= 1 &&
                   ((PCHAR)a->BufPtr)[a->NumBytes-1] == '\r') {
            Length -= 1;
            a->WriteFlags = WRITE_CR;
        } else {
            a->WriteFlags = WRITE_NO_CR_LF;
        }
#endif

        if (Length != 0) {
            if (Console->OutputCP == OEMCP) {
                if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                        ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
                    /*
                     * Translate OEM characters into UnicodeOem for the Window-mode
                     * OEM font. If OutputCP != OEMCP, characters will not appear
                     * correctly, because the OEM fonts are designed to support
                     * only OEMCP (we can't switch fonts in Windowed mode).
                     * Fullscreen or TT "Unicode" fonts should be used for
                     * non-OEMCP output
                     */
                    DBGCHARS(("SrvWriteConsole ACP->U %.*s\n",
                            min(Length,10), a->BufPtr));
                    Status = RtlConsoleMultiByteToUnicodeN(TransBuffer,
                            Length * sizeof(WCHAR), &Length,
                            a->BufPtr, Length, &SpecialChars);
                } else {
                    /*
                     * Good! We have Fullscreen or TT "Unicode" fonts, so convert
                     * the OEM characters to real Unicode according to OutputCP.
                     * First find out if any special chars are involved.
                     */
#ifdef WWSB_NOFE
                    UINT i;
                    for (i = 0; i < Length; i++) {
                        if (((PCHAR)a->BufPtr)[i] < 0x20) {
                            SpecialChars = 1;
                            break;
                        }
                    }
#endif
                    DBGCHARS(("SrvWriteConsole %d->U %.*s\n", Console->OutputCP,
                            min(Length,10), a->BufPtr));
                    Length = sizeof(WCHAR) * MultiByteToWideChar(Console->OutputCP,
                            0, a->BufPtr, Length, TransBuffer, Length);
                    if (Length == 0) {
                        Status = STATUS_UNSUCCESSFUL;
                    }
                }
            }
            else
            {
                if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                    !(Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
                    if (Console->OutputCP != WINDOWSCP)
                        Codepage = USACP;
                    else
                        Codepage = WINDOWSCP;
                } else {
                    Codepage = Console->OutputCP;
                }

                if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                        ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
                    Length = sizeof(WCHAR) * ConvertOutputToUnicode(Codepage,
                                                                    a->BufPtr,
                                                                    Length,
                                                                    TransBuffer,
                                                                    Length);
                }
                else {
                    Length = sizeof(WCHAR) * MultiByteToWideChar(Console->OutputCP,
                            0, a->BufPtr, Length, TransBuffer, Length);
                    if (Length == 0) {
                        Status = STATUS_UNSUCCESSFUL;
                    }
                }

#ifdef WWSB_NOFE
                SpecialChars = 1;
#endif
            }
        }

#ifdef WWSB_FE
        NumBytes2 = Length;

        if ((NumBytes1+NumBytes2) == 0) {
            if (!a->StackBuffer && fLocalHeap) {
                ConsoleHeapFree(a->TransBuffer);
            }
            return Status;
        }
#else
        if (!NT_SUCCESS(Status)) {
            if (!a->StackBuffer) {
                ConsoleHeapFree(TransBuffer);
            }
            return Status;
        }
#endif

#ifdef WWSB_FE
        Console->WriteConOutNumBytesTemp = a->NumBytes;
        a->NumBytes = Console->WriteConOutNumBytesUnicode = NumBytes1 + NumBytes2;
        a->WriteFlags = WRITE_SPECIAL_CHARS;
        a->TransBuffer = TmpTransBuffer;
#else
        DBGOUTPUT(("TransBuffer=%lx, Length = %x(bytes), SpecialChars=%lx\n",
                TransBuffer, Length, SpecialChars));
        a->NumBytes = Length + (a->WriteFlags * sizeof(WCHAR));
        if (a->WriteFlags == WRITE_CR_LF) {
            TransBuffer[(Length+sizeof(WCHAR))/sizeof(WCHAR)] = UNICODE_LINEFEED;
            TransBuffer[Length/sizeof(WCHAR)] = UNICODE_CARRIAGERETURN;
        } else if (a->WriteFlags == WRITE_CR) {
            TransBuffer[Length/sizeof(WCHAR)] = UNICODE_CARRIAGERETURN;
        }
        if (SpecialChars) {
            // CRLF didn't get translated
            a->WriteFlags = WRITE_SPECIAL_CHARS;
        }
        a->TransBuffer = TransBuffer;
#endif
    } else {
        if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                    ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
            Status = RealUnicodeToFalseUnicode(a->BufPtr,
                    a->NumBytes / sizeof(WCHAR), Console->OutputCP);
            if (!NT_SUCCESS(Status)) {
                return Status;
            }
        }
        a->WriteFlags = (DWORD)-1;
        a->TransBuffer = a->BufPtr;
    }
    Status = WWSB_DoWriteConsole(m,Console,CSR_SERVER_QUERYCLIENTTHREAD());
    if (Status == CONSOLE_STATUS_WAIT) {
        *ReplyStatus = CsrReplyPending;
        return (ULONG)STATUS_SUCCESS;
    } else {
        if (!a->Unicode) {
#ifdef WWSB_FE
            if (a->NumBytes == Console->WriteConOutNumBytesUnicode)
                a->NumBytes = Console->WriteConOutNumBytesTemp;
            else
                a->NumBytes /= sizeof(WCHAR);
            if (!a->StackBuffer && fLocalHeap) {
                ConsoleHeapFree(a->TransBuffer);
            }
#else
            a->NumBytes /= sizeof(WCHAR);
            if (!a->StackBuffer) {
                ConsoleHeapFree(a->TransBuffer);
            }
#endif
        }
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\bitmap.c ===
/******************************Module*Header*******************************\
* Module Name: bitmap.c                                                    *
*                                                                          *
* Client side stubs that move bitmaps over the C/S interface.              *
*                                                                          *
* Created: 14-May-1991 11:04:49                                            *
* Author: Eric Kutter [erick]                                              *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                                 *
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

#define EXTRAPIXEL 4
//
//The default band size is set to 4Mb
//
#define BAND_SIZE (4194304)


/******************************Public*Routine******************************\
* cjBitmapBitsSize - calculate the size of the bitmap bits for the
*   given BITMAPINFO
*
* Arguments:
*
*   pbmi - pointer to BITMAPINFO
*
* Return Value:
*
*   size of bitmap bits in butes
*
* History:
*
*    11-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/


ULONG cjBitmapBitsSize(CONST BITMAPINFO *pbmi)
{
    //
    // Check for PM-style DIB
    //

    if (pbmi->bmiHeader.biSize == sizeof(BITMAPCOREHEADER))
    {
        LPBITMAPCOREINFO pbmci;
        pbmci = (LPBITMAPCOREINFO)pbmi;
        return(CJSCAN(pbmci->bmciHeader.bcWidth,pbmci->bmciHeader.bcPlanes,
                      pbmci->bmciHeader.bcBitCount) *
                      pbmci->bmciHeader.bcHeight);
    }

    //
    // not a core header
    //

    if ((pbmi->bmiHeader.biCompression == BI_RGB) ||
        (pbmi->bmiHeader.biCompression == BI_BITFIELDS) ||
        (pbmi->bmiHeader.biCompression == BI_CMYK))
    {
        return(CJSCAN(pbmi->bmiHeader.biWidth,pbmi->bmiHeader.biPlanes,
                      pbmi->bmiHeader.biBitCount) *
               ABS(pbmi->bmiHeader.biHeight));
    }
    else
    {
        return(pbmi->bmiHeader.biSizeImage);
    }
}

//
// IS_BMI_RLE
//
// Checks if the header pointed to by pv is a BITMAPINFO for a RLE4 or RLE8.
// Evaluates to TRUE if RLE, FALSE otherwise.
//

#define IS_BMI_RLE(pv) \
    ((pv) && \
     (((BITMAPINFO *)(pv))->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER)) && \
     ((((BITMAPINFO *)(pv))->bmiHeader.biCompression == BI_RLE4) || \
      (((BITMAPINFO *)(pv))->bmiHeader.biCompression == BI_RLE8) ))

//
// IS_BMI_JPEG
//
// Checks if the header pointed to by pv is a BITMAPINFO for a JPEG.
// Evaluates to TRUE if JPEG, FALSE otherwise.
//

#define IS_BMI_JPEG(pv) \
    ((pv) && \
     (((BITMAPINFO *)(pv))->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER)) && \
     (((BITMAPINFO *)(pv))->bmiHeader.biCompression == BI_JPEG))

//
// IS_BMI_PNG
//
// Checks if the header pointed to by pv is a BITMAPINFO for a PNG.
// Evaluates to TRUE if PNG, FALSE otherwise.
//

#define IS_BMI_PNG(pv) \
    ((pv) && \
     (((BITMAPINFO *)(pv))->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER)) && \
     (((BITMAPINFO *)(pv))->bmiHeader.biCompression == BI_PNG))

//
// IS_PASSTHROUGH_IMAGE
//
// Checks if the biCompression value is one of the passthrough formats that
// can be passed to devices (BI_JPEG or BI_PNG).
//

#define IS_PASSTHROUGH_IMAGE(biCompression) \
    (((biCompression) == BI_JPEG) || ((biCompression) == BI_PNG))

//
// IS_BMI_PASSTHROUGH_IMAGE
//
// Checks if the header pointed to by pv is a BITMAPINFO for a JPEG or PNG.
// Evaluates to TRUE if JPEG or PNG, FALSE otherwise.
//

#define IS_BMI_PASSTHROUGH_IMAGE(pv) \
    ((pv) && \
     (((BITMAPINFO *)(pv))->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER)) && \
     IS_PASSTHROUGH_IMAGE(((BITMAPINFO *)(pv))->bmiHeader.biCompression))


/******************************Public*Routine******************************\
* cCalculateColorTableSize(
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
cCalculateColorTableSize(
    UINT  uiBitCount,
    UINT  uiPalUsed,
    UINT  uiCompression,
    UINT  biSize,
    ULONG *piUsage,
    ULONG *pColors
    )
{
    BOOL bStatus = FALSE;
    ULONG cColorsMax = 0;

    if (uiCompression == BI_BITFIELDS)
    {
        //
        // Handle 16 and 32 bit per pel bitmaps.
        //

        if (*piUsage == DIB_PAL_COLORS)
        {
            *piUsage = DIB_RGB_COLORS;
        }

        switch (uiBitCount)
        {
        case 16:
        case 32:
            break;
        default:
            WARNING("ConvertInfo failed for BI_BITFIELDS\n");
            return(FALSE);
        }

        if (biSize <= sizeof(BITMAPINFOHEADER))
        {
            uiPalUsed = cColorsMax = 3;
        }
        else
        {
            //
            // masks are part of BITMAPV4 and greater
            //

            uiPalUsed = cColorsMax = 0;
        }
    }
    else if (uiCompression == BI_RGB)
    {
        switch (uiBitCount)
        {
        case 1:
            cColorsMax = 2;
            break;
        case 4:
            cColorsMax = 16;
            break;
        case 8:
            cColorsMax = 256;
            break;
        default:

            if (*piUsage == DIB_PAL_COLORS)
            {
                *piUsage = DIB_RGB_COLORS;
            }

            cColorsMax = 0;

            switch (uiBitCount)
            {
            case 16:
            case 24:
            case 32:
                break;
            default:
                WARNING("convertinfo failed invalid bitcount in bmi BI_RGB\n");
                return(FALSE);
            }
        }
    }
    else if (uiCompression == BI_CMYK)
    {
        if (*piUsage == DIB_PAL_COLORS)
        {
            *piUsage = DIB_RGB_COLORS;
        }

        switch (uiBitCount)
        {
        case 1:
            cColorsMax = 2;
            break;
        case 4:
            cColorsMax = 16;
            break;
        case 8:
            cColorsMax = 256;
            break;
        case 32:
            cColorsMax = 0;
            break;
        default:
            WARNING("convertinfo failed invalid bitcount in bmi BI_CMYK\n");
            return(FALSE);
        }
    }
    else if ((uiCompression == BI_RLE4) || (uiCompression == BI_CMYKRLE4))
    {
        if (uiBitCount != 4)
        {
            // WARNING("cCalculateColroTableSize invalid bitcount BI_RLE4\n");
            return(FALSE);
        }

        cColorsMax = 16;
    }
    else if ((uiCompression == BI_RLE8) || (uiCompression == BI_CMYKRLE8))
    {
        if (uiBitCount != 8)
        {
            // WARNING("cjBitmapSize invalid bitcount BI_RLE8\n");
            return(FALSE);
        }

        cColorsMax = 256;
    }
    else if ((uiCompression == BI_JPEG) || (uiCompression == BI_PNG))
    {
        cColorsMax = 0;
    }
    else
    {
        WARNING("convertinfo failed invalid Compression in header\n");
        return(FALSE);
    }

    if (uiPalUsed != 0)
    {
        if (uiPalUsed <= cColorsMax)
        {
            cColorsMax = uiPalUsed;
        }
    }

    *pColors = cColorsMax;
    return(TRUE);
}


/**********************************************************************\
* pbmiConvertInfo
*
* Does two things:
*
* 1. takes BITMAPINFO, Converts BITMAPCOREHEADER
*    into BITMAPINFOHEADER and copies the the color table
*
* 2. also return the size of the size of INFO struct if bPackedDIB is
*    FALSE otherwise pass back the size of INFO plus cjBits
*
* Arguments:
*
*  pbmi             - original bitmapinfo
*  iUsage           - iUsage from API
*  *count           - return size
*  bCopyInfoHeader  - force copy if input is BITMAPINFOHEADER
*                     and bPackedDIB is NOT set
*  bPackedDIB       - BITMAPINFO has bitmap data that must be
*                     copied also
*
* Return Value:
*
*   Converted PBITMAPINFO if successful, otherwise NULL
*
* 10-1-95 -by- Lingyun Wang [lingyunw]
\**********************************************************************/

LPBITMAPINFO
pbmiConvertInfo(
    CONST  BITMAPINFO *pbmi,
    ULONG  iUsage,
    ULONG *count,
    BOOL   bPackedDIB
    )
{
    LPBITMAPINFO pbmiNew;
    ULONG cjRGB;
    ULONG cColors;
    UINT  uiBitCount;
    UINT  uiPalUsed;
    UINT  uiCompression;
    BOOL  bCoreHeader = FALSE;
    ULONG ulSize;
    ULONG cjBits = 0;
    PVOID pjBits, pjBitsNew;
    BOOL  bStatus;

    if (pbmi == (LPBITMAPINFO) NULL)
    {
        return(0);
    }

    //
    // Checking for different bitmap headers
    //

    ulSize = pbmi->bmiHeader.biSize;

    if (ulSize == sizeof(BITMAPCOREHEADER))
    {
        cjRGB = sizeof(RGBQUAD);
        uiBitCount = ((LPBITMAPCOREINFO)pbmi)->bmciHeader.bcBitCount;
        uiPalUsed = 0;
        uiCompression =  (UINT) BI_RGB;
        bCoreHeader = TRUE;
    }
    else if ((ulSize >= sizeof(BITMAPINFOHEADER)) &&
             (ulSize <= ( 2 * sizeof(BITMAPV5HEADER))))
    {
        cjRGB    = sizeof(RGBQUAD);
        uiBitCount = pbmi->bmiHeader.biBitCount;
        uiPalUsed = pbmi->bmiHeader.biClrUsed;
        uiCompression = (UINT) pbmi->bmiHeader.biCompression;
    }
    else
    {
        WARNING("ConvertInfo failed - invalid header size\n");
        return(0);
    }

    //
    // figure out the size of the color table
    //

    bStatus = cCalculateColorTableSize(
                    uiBitCount,
                    uiPalUsed,
                    uiCompression,
                    ulSize,
                    &iUsage,
                    &cColors
                    );
    if (!bStatus)
    {
        return(NULL);
    }

    if (iUsage == DIB_PAL_COLORS)
    {
        cjRGB = sizeof(USHORT);
    }
    else if (iUsage == DIB_PAL_INDICES)
    {
        cjRGB = 0;
    }

    if (bPackedDIB)
    {
        cjBits = cjBitmapBitsSize(pbmi);
    }

    //
    // if passed COREHEADER then convert to BITMAPINFOHEADER
    //

    if (bCoreHeader)
    {
        RGBTRIPLE *pTri;
        RGBQUAD *pQuad;

        //
        // allocate new header to hold the info
        //

        ulSize = sizeof(BITMAPINFOHEADER);

        pbmiNew = (PBITMAPINFO)LOCALALLOC(ulSize +
                             cjRGB * cColors+cjBits);

        if (pbmiNew == NULL)
            return (0);

        //
        // copy COREHEADER info over
        //

        CopyCoreToInfoHeader(&pbmiNew->bmiHeader, (BITMAPCOREHEADER *)pbmi);

        //
        // copy the color table
        //

        pTri = (RGBTRIPLE *)((LPBYTE)pbmi + sizeof(BITMAPCOREHEADER));
        pQuad = (RGBQUAD *)((LPBYTE)pbmiNew + sizeof(BITMAPINFOHEADER));

        //
        // copy RGBTRIPLE to RGBQUAD
        //

        if (iUsage != DIB_PAL_COLORS)
        {
            INT cj = cColors;

            while (cj--)
            {
                pQuad->rgbRed = pTri->rgbtRed;
                pQuad->rgbGreen = pTri->rgbtGreen;
                pQuad->rgbBlue = pTri->rgbtBlue;
                pQuad->rgbReserved = 0;

                pQuad++;
                pTri++;
            }

            if (bPackedDIB)
                pjBits = (LPBYTE)pbmi + sizeof(BITMAPCOREHEADER) + cColors*sizeof(RGBTRIPLE);
        }
        else
        {
            //
            // DIB_PAL_COLORS
            //

            RtlCopyMemory((LPBYTE)pQuad,(LPBYTE)pTri,cColors * cjRGB);

            if (bPackedDIB)
                pjBits = (LPBYTE)pbmi + sizeof(BITMAPCOREHEADER) + cColors * cjRGB;
        }

        //
        // copy the packed bits
        //

        if (bPackedDIB)
        {
            pjBitsNew = (LPBYTE)pbmiNew + ulSize + cColors*cjRGB;

            RtlCopyMemory((LPBYTE)pjBitsNew,
                          (LPBYTE)pjBits,
                          cjBits);
        }
    }
    else
    {
        pbmiNew = (LPBITMAPINFO)pbmi;
    }

    *count = ((ulSize + (cjRGB * cColors) + cjBits) + 3) & ~3;

    return((LPBITMAPINFO) pbmiNew);
}


/******************************Public*Routine******************************\
* cjBitmapScanSize
*
* Arguments:
*
*   pbmi
*   nScans
*
* Return Value:
*
*   Image size based on number of scans
*
* History:
*
*    11-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/


ULONG cjBitmapScanSize(
    CONST BITMAPINFO *pbmi,
    int nScans
    )
{
    // Check for PM-style DIB

    if (pbmi->bmiHeader.biSize == sizeof(BITMAPCOREHEADER))
    {
        LPBITMAPCOREINFO pbmci;
        pbmci = (LPBITMAPCOREINFO)pbmi;

        return(CJSCAN(pbmci->bmciHeader.bcWidth,pbmci->bmciHeader.bcPlanes,
                      pbmci->bmciHeader.bcBitCount) * nScans);
    }

    // not a core header

    if ((pbmi->bmiHeader.biCompression == BI_RGB) ||
        (pbmi->bmiHeader.biCompression == BI_BITFIELDS) ||
        (pbmi->bmiHeader.biCompression == BI_CMYK))
    {
        return(CJSCAN(pbmi->bmiHeader.biWidth,pbmi->bmiHeader.biPlanes,
                      pbmi->bmiHeader.biBitCount) * nScans);
    }
    else
    {
        return(pbmi->bmiHeader.biSizeImage);
    }
}

/******************************Public*Routine******************************\
* CopyCoreToInfoHeader
*
\**************************************************************************/

VOID CopyCoreToInfoHeader(LPBITMAPINFOHEADER pbmih, LPBITMAPCOREHEADER pbmch)
{
    pbmih->biSize = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth = pbmch->bcWidth;
    pbmih->biHeight = pbmch->bcHeight;
    pbmih->biPlanes = pbmch->bcPlanes;
    pbmih->biBitCount = pbmch->bcBitCount;
    pbmih->biCompression = BI_RGB;
    pbmih->biSizeImage = 0;
    pbmih->biXPelsPerMeter = 0;
    pbmih->biYPelsPerMeter = 0;
    pbmih->biClrUsed = 0;
    pbmih->biClrImportant = 0;
}




/******************************Public*Routine******************************\
* DWORD SetDIBitsToDevice                                                  *
*                                                                          *
*   Can reduce it to 1 scan at a time.  If compressed mode, this could     *
*   gete very difficult.  There must be enough space for the header and    *
*   color table.  This will be needed for every batch.                     *
*                                                                          *
*   BITMAPINFO                                                             *
*       BITMAPINFOHEADER                                                   *
*       RGBQUAD[cEntries] | RGBTRIPLE[cEntries]                            *
*                                                                          *
*                                                                          *
*    1. compute header size (including color table)                        *
*    2. compute size of required bits                                      *
*    3. compute total size (header + bits + args)                          *
*    4. if (memory window is large enough for header + at least 1 scan     *
*                                                                          *
* History:                                                                 *
*  Tue 29-Oct-1991 -by- Patrick Haluptzok [patrickh]                       *
* Add shared memory action for large RLE's.                                *
*                                                                          *
*  Tue 19-Oct-1991 -by- Patrick Haluptzok [patrickh]                       *
* Add support for RLE's                                                    *
*                                                                          *
*  Thu 20-Jun-1991 01:41:45 -by- Charles Whitmer [chuckwh]                 *
* Added handle translation and metafiling.                                 *
*                                                                          *
*  14-May-1991 -by- Eric Kutter [erick]                                    *
* Wrote it.                                                                *
\**************************************************************************/

int SetDIBitsToDevice(
HDC          hdc,
int          xDest,
int          yDest,
DWORD        nWidth,
DWORD        nHeight,
int          xSrc,
int          ySrc,
UINT         nStartScan,
UINT         nNumScans,
CONST VOID * pBits,
CONST BITMAPINFO *pbmi,
UINT         iUsage)            // DIB_PAL_COLORS || DIB_RGB_COLORS
{
    LONG cScansCopied = 0;  // total # of scans copied
    LONG ySrcMax;           // maximum ySrc possible

    // hold info about the header

    UINT uiWidth;
    UINT uiHeight;
    PULONG pulBits = NULL;
    INT cjHeader = 0;
    LPBITMAPINFO pbmiNew = NULL;
    ULONG cjBits;

    // ICM related variables

    PCACHED_COLORSPACE pBitmapColorSpace = NULL;
    PCACHED_COLORTRANSFORM pCXform = NULL;
    HANDLE                 hcmTempXform = NULL;

    FIXUP_HANDLE(hdc);

    // Let's validate the parameters so we don't gp-fault ourselves and
    // to save checks later on.

    if ((nNumScans == 0)                   ||
        (pbmi      == (LPBITMAPINFO) NULL) ||
        (pBits     == (LPVOID) NULL)       ||
        ((iUsage   != DIB_RGB_COLORS) &&
         (iUsage   != DIB_PAL_COLORS) &&
         (iUsage   != DIB_PAL_INDICES)))
    {
        WARNING("You failed a param validation in SetDIBitsToDevice\n");
        return(0);
    }

    pbmiNew = pbmiConvertInfo(pbmi,iUsage,&cjHeader,FALSE);

    if (pbmiNew == NULL)
        return (0);

    uiWidth       = (UINT) pbmiNew->bmiHeader.biWidth;
    uiHeight      = (UINT) pbmiNew->bmiHeader.biHeight;

    // Compute the minimum nNumScans to send across csr interface.
    // It will also prevent faults as a result of overreading the source.

    ySrcMax = max(ySrc, ySrc + (int) nHeight);
    if (ySrcMax <= 0)
        return(0);
    ySrcMax = min(ySrcMax, (int) uiHeight);
    nNumScans = min(nNumScans, (UINT) ySrcMax - nStartScan);

    // NEWFRAME support for backward compatibility.
    // Ship the transform to the server side if needed.

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
        {
            cScansCopied = MF_AnyDIBits(
                   hdc,
                   xDest,yDest,0,0,
                   xSrc,ySrc,(int) nWidth,(int) nHeight,
                   nStartScan,nNumScans,
                   pBits,pbmi,
                   iUsage,
                   SRCCOPY,
                   META_SETDIBTODEV
                   );

            goto Exit;

        }

        DC_PLDC(hdc,pldc,0);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_AnyDIBits(
                    hdc,
                    xDest,yDest,0,0,
                    xSrc,ySrc,(int) nWidth,(int) nHeight,
                    nStartScan,nNumScans,
                    pBits,pbmi,
                    iUsage,
                    SRCCOPY,
                    EMR_SETDIBITSTODEVICE
                    ))
            {
                cScansCopied = 0;
                goto Exit;
            }
        }

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
        {
            cScansCopied = 0;
            goto Exit;
        }
    }

    // reset user's poll count so it counts this as output
    // put it right next to BEGINMSG so that NtCurrentTeb() is optimized

    RESETUSERPOLLCOUNT();

    //
    // Calculate bitmap bits size based on BITMAPINFO and nNumScans
    //

    cjBits = cjBitmapScanSize(pbmi,nNumScans);


    //
    // If the pBits are not dword aligned we need to allocate a buffer and
    // copy them (that's because we always guarantee display and printer
    // drivers that bitmaps are dword aligned):
    //

    cScansCopied = 1;

    if ((ULONG_PTR)pBits & (sizeof(DWORD) - 1))
    {
        pulBits = LOCALALLOC(cjBits);
        if (pulBits)
        {
            //
            // We used to simply access violate here if we had been given
            // a corrupt DIB bitmap.  This was bad because WinLogon is
            // responsible for showing the original background bitmap, and
            // if that bitmap is corrupt, and we access violate, we'll
            // cause the system to blue-screen:
            //

            try
            {
                RtlCopyMemory(pulBits,pBits,cjBits);
                pBits = pulBits;
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNING("SetDIBitsToDevice: Corrupt bitmap\n");
                cScansCopied = 0;
            }
        }
    }

    if (cScansCopied)
    {
        PDC_ATTR pdcattr;

        PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

        if (pdcattr)
        {
            //
            // ICM translation of BITMAP bits or color table
            //
            // At this moment, ensured that pBits and pbmiNew is not NULL.
            // (see above parameter validate check and NULL check !)
            //

            if (
               IS_ICM_INSIDEDC(pdcattr->lIcmMode) &&
               (iUsage != DIB_PAL_COLORS) &&
               !IS_BMI_PASSTHROUGH_IMAGE(pbmiNew))
            {
                LPBITMAPINFO pbmiIcm = NULL;
                PVOID        pvBitsIcm = NULL;
                ULONG        cjHeaderNew = 0;
                BOOL         bIcmStatus;
                VOID *pBitsBand = (VOID *)pBits;
                ULONG CurrentBandSize;
                ULONG SizeOfOneScanline;
                ULONG nBands;
                ULONG nScansInBand;
                ULONG nScansInCurrentBand;
                ULONG nScansInRemainderBand;
                ULONG CumulativeScans=0;
                ULONG i;
                LONG PositiveBandDelta=0;
                LONG NegativeBandDelta=0;
                LONG TotalBandDelta=0;
                LONG IcmSizeOfOneScanline;
                INT iRet;
                LONG HeaderHeightHack;

                SizeOfOneScanline = cjBitmapScanSize(pbmi, 1);

                //
                //pbmiNew must be initialized before getting to this point.
                //

                ASSERTGDI(pbmiNew!=NULL, "SetDIBitsToDevice cannot proceed with pbmiNew==NULL\n");                        

                nScansInBand = BAND_SIZE/SizeOfOneScanline;

                //
                // Set the number of bands provided there are enough scanlines
                // and the hdc is a printer dc.
                //
                // Else set the nubmer of bands to 1 and the scanlines in the 
                // remainder band to all of them, so the entire bitmap is printed
                // in one band (All the code below reduces to doing a single piece)
                //
                // If the bitmap is RLE compressed, we set it up to do one band
                // only. When this is the case, Start and NegativeBandDelta will be
                // computed as 0 and the SizeOfOneScanline parameter will be 
                // multiplied away to zero.
                //




                if ((nScansInBand>0)&&
                    (GetDeviceCaps(hdc, TECHNOLOGY)==DT_RASPRINTER)&&
                    (!IS_BMI_RLE(pbmiNew)))
                {
                    //
                    // Compressed images cannot be converted in this way.
                    // This should never be hit and is included as a guard against
                    // someone inventing a new compression mode and not updating 
                    // this conditional.
                    //

                    ASSERTGDI(SizeOfOneScanline*nNumScans==cjBits, "SetDIBitsToDevice, cannot band compressed image");

                    nBands = (nNumScans)/nScansInBand;
                    nScansInRemainderBand = nNumScans % nScansInBand;
                }
                else
                {
                    nBands = 0;
                    nScansInRemainderBand = (nNumScans);
                }

                if (nScansInRemainderBand>0)
                {
                    nBands++;
                    nScansInCurrentBand = nScansInRemainderBand;
                }
                else
                {
                    nScansInCurrentBand = nScansInBand;
                }


                cScansCopied = 0;

                HeaderHeightHack = pbmiNew->bmiHeader.biHeight;  
                
                for (i=0; i<nBands; i++)
                {

                    CurrentBandSize = nScansInCurrentBand*SizeOfOneScanline;
                    IcmSizeOfOneScanline = SizeOfOneScanline;

                    //
                    // The Delta refers to the number of extra scanlines to pass
                    // to the internal blting routines in order to avoid halftone
                    // seams.
                    //
                    // PositiveBandDelta is the number of scanlines to 
                    // add on to the end of the band. (relative to the start in 
                    // memory)
                    //
                    // NegativeBandDelta is the number of scanlines to 
                    // subtract from the begining of the band (ie move the start
                    // pointer back this many scanlines).
                    //
                    // Total BandDelta is simply the total number of extra scans
                    // added for this band (both at the start and end).
                    //
                    
                    PositiveBandDelta = MIN(EXTRAPIXEL, CumulativeScans);
                    NegativeBandDelta = MIN(EXTRAPIXEL, nNumScans-(CumulativeScans+nScansInCurrentBand));
                    TotalBandDelta = NegativeBandDelta+PositiveBandDelta;


                    if (nBands!=1)
                    {
                        SaveDC(hdc);


                        //
                        // Intersect the clip rectangles.
                        // This clip rectangle is designed to restrict the output to 
                        // just the displayed portion of the band.
                        // We may pass more scanlines on the top and bottom of the band 
                        // to get halftoning to merge seamlessly.
                        //

                        iRet = IntersectClipRect(
                                   hdc,
                                   xDest,
                                   nNumScans - (nStartScan+CumulativeScans+nScansInCurrentBand),
                                   xDest+nWidth,
                                   nNumScans - (nStartScan+CumulativeScans));

                        if (iRet==ERROR)
                        {
                            WARNING("SetDIBitsToDevice: error intersecting clip rect\n");
                            RestoreDC(hdc, -1);
                            goto Exit;
                        }
                        
                        //                        
                        // Empty clip rectangle 
                        // If the clip regions don't intersect, we can quit without
                        // doing anything.
                        //

                        if (iRet==NULLREGION)
                        {
                            RestoreDC(hdc, -1);
                            
                            //
                            // Nothing to do - fall through and do 
                            // initialization for next iteration.
                            //

                            goto Continue_With_Init;
                        }
                    }


                    if (HeaderHeightHack >= 0)
                    {
                        //
                        //Bottom Up
                        //

                        pBitsBand = (char *)pBits + (CumulativeScans-PositiveBandDelta)*SizeOfOneScanline;
                    }
                    else
                    {
                        //
                        //TopDown
                        //
                        
                        pBitsBand = (char *)pBits + (nNumScans-nScansInCurrentBand-CumulativeScans-NegativeBandDelta)*SizeOfOneScanline;
                    }

                    cjHeaderNew=0;
                    pbmiIcm=NULL;
                    pvBitsIcm = NULL;

                    //
                    // Call ICM with an oversized band for later halftoning by 
                    // NtGdiSetDIBitsInternal
                    //

                    bIcmStatus = IcmTranslateDIB(
                                     hdc,
                                     pdcattr,
                                     CurrentBandSize+TotalBandDelta*SizeOfOneScanline,
                                     (PVOID)pBitsBand,
                                     &pvBitsIcm,
                                     pbmiNew,
                                     &pbmiIcm,
                                     &cjHeaderNew,
                                     nScansInCurrentBand+TotalBandDelta,
                                     iUsage,
                                     ICM_FORWARD,
                                     &pBitmapColorSpace,
                                     &pCXform);

                    if (bIcmStatus)
                    {
                        if (pvBitsIcm == NULL)
                        {
                            pvBitsIcm = pBitsBand;
                        }
                        if (pbmiIcm == NULL)
                        {
                            pbmiIcm = pbmiNew;
                            cjHeaderNew = cjHeader;
                        }
                        else
                        {
                            CurrentBandSize = cjBitmapScanSize(pbmiIcm, nScansInCurrentBand);
                            IcmSizeOfOneScanline = cjBitmapScanSize(pbmiIcm, 1);
                            if (!cjHeaderNew)
                            {
                                cjHeaderNew = cjHeader;
                            }
                        }
                        if (pCXform)
                        {
                            hcmTempXform = pCXform->ColorTransform;
                        }
                    }
                    else
                    {
                        pvBitsIcm = pBitsBand;
                        pbmiIcm = pbmiNew;
                        cjHeaderNew = cjHeader;
                    }

                    cScansCopied += NtGdiSetDIBitsToDeviceInternal(
                                        hdc,
                                        xDest,
                                        yDest,
                                        nWidth,
                                        nHeight,
                                        xSrc,
                                        ySrc, 
                                        nStartScan+CumulativeScans-PositiveBandDelta,
                                        nScansInCurrentBand+TotalBandDelta,
                                        (LPBYTE)pvBitsIcm,
                                        pbmiIcm,
                                        iUsage,
                                        (UINT)CurrentBandSize+TotalBandDelta*IcmSizeOfOneScanline,
                                        (UINT)cjHeaderNew,
                                        TRUE,
                                        hcmTempXform);

                    cScansCopied -= TotalBandDelta;

                    if (pBitmapColorSpace)
                    {
                        if (pCXform)
                        {
                            IcmDeleteColorTransform(pCXform,FALSE);
                        }
                        IcmReleaseColorSpace(NULL,pBitmapColorSpace,FALSE);
                    }


                    if ((pvBitsIcm!=NULL)&&(pvBitsIcm!=pBitsBand))
                    {
                        LOCALFREE(pvBitsIcm);
                        pvBitsIcm = NULL;
                    }
                    if ((pbmiIcm!=NULL)&&(pbmiIcm!=pbmiNew))
                    {
                        LOCALFREE(pbmiIcm);
                        pbmiIcm = NULL;
                    }

                    hcmTempXform = NULL;

                    Continue_With_Init:
                    CumulativeScans += nScansInCurrentBand;
                    nScansInCurrentBand = nScansInBand;
                    if (nBands != 1)
                    {
                        RestoreDC(hdc, -1);    
                    }
                }

                //
                // We do our own NtGdiSetDIBitsToDeviceInternal
                // So we need to fall through to cleanup at this point.
                //

                goto Exit;
            }
        }

        //
        // Do the non-ICM version of the SetDIB
        //
        cScansCopied = NtGdiSetDIBitsToDeviceInternal(
                            hdc,
                            xDest,
                            yDest,
                            nWidth, 
                            nHeight,
                            xSrc,
                            ySrc,
                            nStartScan,
                            nNumScans,
                            (LPBYTE)pBits,
                            pbmiNew,
                            iUsage,
                            (UINT)cjBits,
                            (UINT)cjHeader,
                            TRUE,
                            hcmTempXform);
    }

Exit:

    if (pulBits)
    {
        //
        // Free temporary buffer, this would be the buffer which allocated
        // to align, Or to do ICM.
        //
        LOCALFREE (pulBits);
    }

    if (pbmiNew && (pbmiNew != pbmi))
    {
        LOCALFREE (pbmiNew);
    }

    return (cScansCopied);
}



/******************************Public*Routine******************************\
* DWORD GetDIBits
*
*   Can reduce it to 1 scan at a time.  There must be enough space
*   for the header and color table.  This will be needed for every chunk
*
* History:
*  Wed 04-Dec-1991 -by- Patrick Haluptzok [patrickh]
* bug fix, only check for valid DC if DIB_PAL_COLORS.
*
*  Fri 22-Nov-1991 -by- Patrick Haluptzok [patrickh]
* bug fix, copy the header into memory window for NULL bits.
*
*  Tue 20-Aug-1991 -by- Patrick Haluptzok [patrickh]
* bug fix, make iStart and cNum be in valid range.
*
*  Thu 20-Jun-1991 01:44:41 -by- Charles Whitmer [chuckwh]
* Added handle translation.
*
*  14-May-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int GetDIBits(
HDC          hdc,
HBITMAP      hbm,
UINT         nStartScan,
UINT         nNumScans,
LPVOID       pBits,
LPBITMAPINFO pbmi,
UINT         iUsage)     // DIB_PAL_COLORS || DIB_RGB_COLORS
{
    PULONG   pulBits = pBits;
    ULONG    cjBits;
    int      iRet = 0;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hbm);

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        BOOL bNeedICM = TRUE;

        cjBits  = cjBitmapScanSize(pbmi,nNumScans);

        //
        // If pbmi is a input buffer specifying image format
        // (i.e., pBits != NULL), then fail for passthrough
        // images (BI_JPEG and BI_PNG)
        //
        if (pBits && IS_BMI_PASSTHROUGH_IMAGE(pbmi))
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return 0;
        }

        if (pbmi->bmiHeader.biBitCount == 0)
        {
            //
            // no color table required.
            //
            bNeedICM = FALSE;
        }

        //
        // if the pBits are not dword aligned, we need to allocate
        // a buffer and copy them
        //
        if ((ULONG_PTR)pBits & (sizeof(DWORD) - 1))
        {
            pulBits = LOCALALLOC(cjBits);

            if (pulBits == NULL)
                return(0);
        }

        iRet = NtGdiGetDIBitsInternal(
                hdc,
                hbm,
                nStartScan,
                nNumScans,
                (LPVOID)pulBits,
                pbmi,
                iUsage,
                cjBits,
                0);

        //
        // translate DIB if needed
        //
        if (bNeedICM &&
            (IS_ICM_HOST(pdcattr->lIcmMode)) && (iUsage != DIB_PAL_COLORS))
        {
            //
            // UNDER_CONSTRUCTION: Failed on GetDIBits() from CMYK surface.
            //
            if (IS_CMYK_COLOR(pdcattr->lIcmMode))
            {
                WARNING("GetDIBits(): was called on CMYK bitmap\n");
                iRet = 0;
            }
            else
            {
                //
                // Do backward transform.
                //
                if (!IcmTranslateDIB(hdc,
                                     pdcattr,
                                     cjBits,
                                     pulBits,
                                     NULL,     // Indicates overwrite original...
                                     pbmi,
                                     NULL,     // Indicates overwrite original...
                                     NULL,
                                     nNumScans,
                                     iUsage,
                                     ICM_BACKWARD,
                                     NULL,NULL))
                {
                    //
                    // ICM translation failed.
                    //
                    iRet = 0;
                }
            }
        }

        if (pulBits != pBits)
        {
            if (iRet)
            {
                RtlCopyMemory(pBits,pulBits,cjBits);
            }

            LOCALFREE(pulBits);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* CreateDIBitmap
*
* History:
*  Mon 25-Jan-1993 -by- Patrick Haluptzok [patrickh]
* Add CBM_CREATEDIB support.
*
*  Thu 20-Jun-1991 02:14:59 -by- Charles Whitmer [chuckwh]
* Added local handle support.
*
*  23-May-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HBITMAP
CreateDIBitmap(
    HDC                hdc,
    CONST BITMAPINFOHEADER *pbmih,
    DWORD              flInit,
    CONST VOID        *pjBits,
    CONST BITMAPINFO  *pbmi,
    UINT               iUsage)
{
    LONG  cjBMI = 0;
    LONG  cjBits = 0;
    INT   cx = 0;
    INT   cy = 0;
    PULONG pulBits = NULL;
    HBITMAP hRet = (HBITMAP)-1;
    LPBITMAPINFO pbmiNew = NULL;
    PDC_ATTR pdcattr;

    // ICM related variables.

    PCACHED_COLORSPACE pBitmapColorSpace = NULL;
    PCACHED_COLORTRANSFORM pCXform = NULL;
    HANDLE hcmTempXform = NULL;

    FIXUP_HANDLEZ(hdc);

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    pbmiNew = pbmiConvertInfo(pbmi,iUsage,&cjBMI,FALSE);

    if (flInit & CBM_CREATEDIB)
    {
        // With CBM_CREATEDIB we ignore pbmih

        pbmih = (LPBITMAPINFOHEADER) pbmi;

        if (cjBMI == 0)
        {
            hRet = 0;
        }
        else if (flInit & CBM_INIT)
        {
            if (pjBits == NULL)
            {
                // doesn't make sence if they asked to initialize it but
                // didn't pass the bits.

                hRet = 0;
            }
            else
            {
                cjBits = cjBitmapBitsSize(pbmiNew);
            }
        }
        else
        {
            pjBits = NULL;
        }
    }
    else
    {
        // compute the size of the optional init bits and BITMAPINFO

        if (flInit & CBM_INIT)
        {
            if (pjBits == NULL)
            {
                // doesn't make sence if they asked to initialize it but
                // didn't pass the bits.

                flInit &= ~CBM_INIT;
            }
            else
            {
                if (cjBMI == 0)
                {
                    hRet = 0;
                }
                else
                {
                    // compute the size of the bits

                    cjBits = cjBitmapBitsSize(pbmiNew);
                }
            }
        }
        else
        {
            pjBits = NULL;
        }
    }

    //  CreateDIBitmap cannot handle passthrough image (BI_JPEG or BI_PNG)
    //  init data

    if (IS_BMI_PASSTHROUGH_IMAGE(pbmiNew))
    {
        hRet = 0;
    }

    //  if they passed us a zero height  or  zero  width
    //  bitmap then return a pointer to the stock bitmap

    if (pbmih)
    {
        if (pbmih->biSize >= sizeof(BITMAPINFOHEADER))
        {
            cx = pbmih->biWidth;
            cy = pbmih->biHeight;
        }
        else
        {
            cx = ((LPBITMAPCOREHEADER) pbmih)->bcWidth;
            cy = ((LPBITMAPCOREHEADER) pbmih)->bcHeight;
        }

        if ((cx == 0) || (cy == 0))
        {
            hRet = GetStockObject(PRIV_STOCK_BITMAP);
        }
    }

    // if hRet is still -1, then all is OK and we need to try to the bitmap

    if (hRet == (HBITMAP)-1)
    {
        BOOL bStatus = TRUE;

        // if the pJBits are not dword aligned we need to allocate a buffer and copy them

        if ((ULONG_PTR)pjBits & (sizeof(DWORD) - 1))
        {
            pulBits = LOCALALLOC(cjBits);
            if (pulBits)
            {
                RtlCopyMemory(pulBits,pjBits,cjBits);
                pjBits = pulBits;
            }
        }

        // ICM conversion
        //
        // Convert bitmap data only when ...
        //
        //  - HDC is not NULL.
        //  - ICM is enanled.
        //  - ICM is not lazy mode.
        //  - Initialize data is not Palette Index.
        //  - Initialize data is provided.

        if (pdcattr &&
            IS_ICM_INSIDEDC(pdcattr->lIcmMode) &&
            (IS_ICM_LAZY_CORRECTION(pdcattr->lIcmMode) == FALSE) &&
            (iUsage != DIB_PAL_COLORS) &&
            pjBits && pbmiNew)
        {
            PVOID       pvBitsIcm = NULL;
            PBITMAPINFO pbmiIcm = NULL;
            ULONG       cjBMINew = 0;
            BOOL        bIcmStatus;

            bIcmStatus = IcmTranslateDIB(hdc,
                                         pdcattr,
                                         cjBits,
                                         (PVOID)pjBits,
                                         &pvBitsIcm,
                                         pbmiNew,
                                         &pbmiIcm,
                                         &cjBMINew,
                                         (DWORD)-1,
                                         iUsage,
                                         ICM_FORWARD,
                                         &pBitmapColorSpace,
                                         &pCXform);

            //
            // IcmTranslateDIB will create a duplicate dib
            // pointed to by pulBits if needed.
            //

            if (bIcmStatus)
            {
                if (pvBitsIcm != NULL)
                {
                    ICMMSG(("CreateDIBitmap(): Temp bits are allocated\n"));

                    if (pulBits)
                    {
                        LOCALFREE(pulBits);
                    }

                    pjBits = (PVOID)pulBits = pvBitsIcm;
                }

                if (pbmiIcm != NULL)
                {
                    ICMMSG(("CreateDIBitmap(): Temp bmi are allocated\n"));

                    if (pbmiNew && (pbmiNew != pbmi))
                    {
                        LOCALFREE(pbmiNew);
                    }

                    pbmiNew = pbmiIcm;

                    //
                    // Calculate bitmap bits size based on BITMAPINFO and nNumScans
                    //
                    cjBits = cjBitmapBitsSize(pbmiNew);

                    //
                    // Update sizeof bitmap info (including color table)
                    //
                    if (cjBMINew)
                    {
                        cjBMI = cjBMINew;
                    }
                }

                //
                // Get color transform handle need to pass kernel
                //
                if (pCXform)
                {
                    hcmTempXform = pCXform->ColorTransform;
                }
            }
        }

        if (bStatus)
        {
            hRet = NtGdiCreateDIBitmapInternal(hdc,
                                               cx,
                                               cy,
                                               flInit,
                                               (LPBYTE) pjBits,
                                               (LPBITMAPINFO) pbmiNew,
                                               iUsage,
                                               cjBMI,
                                               cjBits,
                                               0,
                                               hcmTempXform);

#if TRACE_SURFACE_ALLOCS
            {
                PULONGLONG  pUserAlloc;

                PSHARED_GET_VALIDATE(pUserAlloc, hRet, SURF_TYPE);

                if (pUserAlloc != NULL)
                {
                    RtlWalkFrameChain((PVOID *)&pUserAlloc[1], (ULONG)*pUserAlloc, 0);
                }
            }
#endif
        }

        if (pBitmapColorSpace)
        {
            if (pCXform)
            {
                IcmDeleteColorTransform(pCXform,FALSE);
            }

            IcmReleaseColorSpace(NULL,pBitmapColorSpace,FALSE);
        }

        if (pulBits)
        {
            LOCALFREE(pulBits);
        }
    }

    if (pbmiNew && (pbmiNew != pbmi))
    {
        LOCALFREE(pbmiNew);
    }

    return(hRet);
}

/******************************Public*Routine******************************\
* Set/GetBitmapBits                                                        *
*                                                                          *
* History:                                                                 *
*  05-Jun-1991 -by- Eric Kutter [erick]                                    *
* Wrote it.                                                                *
\**************************************************************************/

LONG WINAPI SetBitmapBits(
HBITMAP      hbm,
DWORD        c,
CONST VOID *pv)
{
    LONG   lRet;

    FIXUP_HANDLE(hbm);

    lRet = (LONG)NtGdiSetBitmapBits(hbm,c,(PBYTE)pv);

    return(lRet);
}

LONG WINAPI GetBitmapBits(
HBITMAP hbm,
LONG    c,
LPVOID  pv)
{
    LONG   lRet;

    FIXUP_HANDLE(hbm);

    lRet = (LONG)NtGdiGetBitmapBits(hbm,c,(PBYTE)pv);

    return(lRet);
}

/******************************Public*Routine******************************\
* GdiGetPaletteFromDC
*
* Returns the palette for the DC, 0 for error.
*
* History:
*  04-Oct-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HANDLE GdiGetPaletteFromDC(HDC h)
{
    return((HANDLE)GetDCObject(h,LO_PALETTE_TYPE));
}

/******************************Public*Routine******************************\
* GdiGetDCforBitmap
*
* Returns the DC a bitmap is selected into, 0 if none or if error occurs.
*
* History:
*  22-Sep-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HDC GdiGetDCforBitmap(HBITMAP hbm)
{
    FIXUP_HANDLE(hbm);

    return (NtGdiGetDCforBitmap(hbm));
}

/******************************Public*Routine******************************\
* SetDIBits
*
* API to initialize bitmap with DIB
*
* History:
*  Sun 22-Sep-1991 -by- Patrick Haluptzok [patrickh]
* Make it work even if it is selected into a DC, Win3.0 compatibility.
*
*  06-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

int WINAPI SetDIBits(
HDC          hdc,
HBITMAP      hbm,
UINT         iStartScans,
UINT         cNumScans,
CONST VOID  *pInitBits,
CONST BITMAPINFO *pInitInfo,
UINT         iUsage)
{
    HDC hdcTemp;
    HBITMAP hbmTemp;
    int iReturn = 0;
    BOOL bMakeDC = FALSE;
    HPALETTE hpalTemp;
    DWORD cWidth;
    DWORD cHeight;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hbm);

    // if no bits or hbm is not a bitmap, fail

    if ((pInitBits == (PVOID) NULL) ||
        (GRE_TYPE(hbm) != SURF_TYPE))
    {
        return(0);
    }

    // if passthrough image (BI_JPEG or BI_JPEG), fail

    if (IS_BMI_PASSTHROUGH_IMAGE(pInitInfo))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

    // First we need a DC to select this bitmap into.  If he is already in a
    // DC we just use that DC temporarily to blt to (we still have to select
    // it in and out because someone might do a SaveDC and select another
    // bitmap in).  If he hasn't been stuck in a DC anywhere we just create
    // one temporarily.

    hdcTemp = GdiGetDCforBitmap(hbm);

    if (hdcTemp == (HDC) 0)
    {
        hdcTemp = CreateCompatibleDC(hdc);
        bMakeDC = TRUE;

        if (hdcTemp == (HDC) NULL)
        {
            WARNING("SetDIBits failed CreateCompatibleDC, is hdc valid?\n");
            return(0);
        }
    }
    else
    {
        if (SaveDC(hdcTemp) == 0)
            return(0);
    }

    hbmTemp = SelectObject(hdcTemp, hbm);

    if (hbmTemp == (HBITMAP) 0)
    {
        //WARNING("ERROR SetDIBits failed to Select, is bitmap valid?\n");
        goto Error_SetDIBits;
    }

    if (hdc != (HDC) 0)
    {
        hpalTemp = SelectPalette(hdcTemp, GdiGetPaletteFromDC(hdc), 0);
    }

    if (pInitInfo->bmiHeader.biSize < sizeof(BITMAPINFOHEADER))
    {
        cWidth  = ((LPBITMAPCOREHEADER)pInitInfo)->bcWidth;
        cHeight = ((LPBITMAPCOREHEADER)pInitInfo)->bcHeight;
    }
    else
    {
        cWidth  = pInitInfo->bmiHeader.biWidth;
        cHeight = ABS(pInitInfo->bmiHeader.biHeight);
    }

    iReturn = SetDIBitsToDevice(hdcTemp,
                                0,
                                0,
                                cWidth,
                                cHeight,
                                0, 0,
                                iStartScans,
                                cNumScans,
                                (VOID *) pInitBits,
                                pInitInfo,
                                iUsage);

    if (hdc != (HDC) 0)
    {
        SelectPalette(hdcTemp, hpalTemp, 0);
    }

    SelectObject(hdcTemp, hbmTemp);

Error_SetDIBits:

    if (bMakeDC)
    {
        DeleteDC(hdcTemp);
    }
    else
    {
        RestoreDC(hdcTemp, -1);
    }

    return(iReturn);
}



/******************************Public*Routine******************************\
* StretchDIBits()
*
*
* Effects:
*
* Warnings:
*
* History:
*  22-Jul-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int WINAPI StretchDIBits(
                        HDC           hdc,
                        int           xDest,
                        int           yDest,
                        int           nDestWidth,
                        int           nDestHeight,
                        int           xSrc,
                        int           ySrc,
                        int           nSrcWidth,
                        int           nSrcHeight,
                        CONST VOID   *pj,
                        CONST BITMAPINFO  *pbmi,
                        UINT          iUsage,
                        DWORD         lRop)
{


    LONG cPoints = 0;
    LONG cjHeader;
    LONG cjBits;
    ULONG ulResult = 0;
    PULONG pulBits = NULL;
    int   iRet = 0;
    BITMAPINFO * pbmiNew = NULL;
    PDC_ATTR pdcattr;

    BOOL bStatus = TRUE;

    // ICM related variables.

    PCACHED_COLORSPACE pBitmapColorSpace = NULL;
    PCACHED_COLORTRANSFORM pCXform = NULL;
    HANDLE hcmTempXform = NULL;

    FIXUP_HANDLE(hdc);

    // NEWFRAME support for backward compatibility.
    // Ship the transform to the server side if needed.

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
        {

            return (MF_AnyDIBits(
                                hdc,
                                xDest,
                                yDest,
                                nDestWidth,
                                nDestHeight,
                                xSrc,
                                ySrc,
                                nSrcWidth,
                                nSrcHeight,
                                0,
                                0,
                                (BYTE *) pj,
                                pbmi,
                                iUsage,
                                lRop,
                                META_STRETCHDIB
                                ));
        }

        DC_PLDC(hdc,pldc,ulResult);

        if (pldc->iType == LO_METADC)
        {
            //
            // speeds up cases when partial sources bits are sent
            //

            int iStart = 0;
            int iEnd = 0;
            int cScans = 0;

            if (pbmi && (pbmi->bmiHeader.biWidth == nSrcWidth) && (pbmi->bmiHeader.biHeight > nSrcHeight) &&
                (pbmi->bmiHeader.biHeight > 0) &&
                !(IS_BMI_RLE(pbmi) || IS_BMI_PASSTHROUGH_IMAGE(pbmi)))
            {
                iStart = ((ySrc - EXTRAPIXEL) > 0) ? (ySrc - EXTRAPIXEL) : 0;

                iEnd = ((ySrc+nSrcHeight + EXTRAPIXEL) > pbmi->bmiHeader.biHeight)?
                       pbmi->bmiHeader.biHeight : (ySrc+nSrcHeight + EXTRAPIXEL);

                cScans = iEnd - iStart;

            }

            if (!MF_AnyDIBits(hdc,
                              xDest,
                              yDest,
                              nDestWidth,
                              nDestHeight,
                              xSrc,
                              ySrc,
                              nSrcWidth,
                              nSrcHeight,
                              iStart,
                              cScans,
                              (BYTE *) pj,
                              pbmi,
                              iUsage,
                              lRop,
                              EMR_STRETCHDIBITS
                             ))
            {
                return (0);
            }
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return (0);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    if (pbmi != NULL)
    {
        pbmiNew = pbmiConvertInfo (pbmi, iUsage, &cjHeader,FALSE);

        if (pbmiNew == NULL)
            return (0);

        cjBits  = cjBitmapBitsSize(pbmiNew);
    }
    else
    {
        cjHeader = 0;
        cjBits   = 0;
    }

    // reset user's poll count so it counts this as output
    // put it right next to BEGINMSG so that NtCurrentTeb() is optimized

    RESETUSERPOLLCOUNT();

    // if the pj are not dword aligned we need to allocate
    // a buffer and copy them

    if ((ULONG_PTR)pj & (sizeof(DWORD) - 1))
    {
        pulBits = LOCALALLOC(cjBits);
        if (pulBits)
        {
            RtlCopyMemory(pulBits,pj,cjBits);
            pj = pulBits;
        }
    }

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        // icm tranlation
        //
        // Convert bitmap data only when ...
        //
        //  - ICM is enabled.
        //  - Bitmap is not Palette Index.
        //  - Bitmap header & data is provided.
        //  - Bitmap is not passthrough image (BI_JPEG or BI_PNG).

        if (IS_ICM_INSIDEDC(pdcattr->lIcmMode) &&
            (iUsage != DIB_PAL_COLORS) &&
            pbmiNew && pj &&
            !IS_BMI_PASSTHROUGH_IMAGE(pbmiNew))
        {

            LPBITMAPINFO pbmiIcm = NULL;
            LPBITMAPINFO pbmiSave = NULL;
            PVOID        pvBitsIcm = NULL;
            ULONG        cjHeaderNew = 0;
            ULONG        cjBitsIcm;
            BOOL         bIcmStatus;
            VOID *pBitsBand = (VOID *)pj;
            LONG CurrentBandSize;
            LONG SizeOfOneScanline;
            LONG IcmSizeOfOneScanline;
            LONG nBands;
            LONG nScansInBand;
            LONG nScansInCurrentBand;
            LONG nScansInRemainderBand;
            LONG CumulativeScans=0;
            LONG i;
            LONG PositiveBandDelta=0;
            LONG NegativeBandDelta=0;
            LONG TotalBandDelta=0;
            HRGN hrgnBandClip = NULL;
            RECT rectCurrentClip;
            LONG HeaderHeightHack;
            INT cScanCount=0;
            float lMulDivStoreY1;
            float lMulDivStoreY2;


            SizeOfOneScanline = cjBitmapScanSize(pbmiNew, 1);

            //
            //pbmiNew must be initialized before getting to this point.
            //

            ASSERTGDI(pbmiNew!=NULL, "StretchDIBits cannot proceed with pbmiNew==NULL\n");                        

            nScansInBand = BAND_SIZE/SizeOfOneScanline;

            //
            // Set the number of bands provided there are enough scanlines
            // and the hdc is a printer dc.
            //
            // Else set the nubmer of bands to 1 and the scanlines in the 
            // remainder band to all of them, so the entire bitmap is printed
            // in one band (All the code below reduces to doing a single piece)
            //
            // If the bitmap is RLE compressed, we set it up to do one band
            // only. When this is the case, Start and NegativeBandDelta will be
            // computed as 0 and the SizeOfOneScanline parameter will be 
            // multiplied away to zero.
            //

            if ((nScansInBand>0)&&
                (GetDeviceCaps(hdc, TECHNOLOGY)==DT_RASPRINTER)&&
                (!IS_BMI_RLE(pbmiNew)))
            {
                //
                // Compressed images cannot be converted in this way.
                // This should never be hit and is included as a guard against
                // someone inventing a new compression mode and not updating 
                // this conditional.
                //

                //This assert needs a rethink - cjBits refers to the whole image
                //which could be larger than the nSrcHeight portion.
                //ASSERTGDI(SizeOfOneScanline*nSrcHeight==cjBits, "StretchDIBits, cannot band compressed image");

                nBands = (nSrcHeight)/nScansInBand;
                nScansInRemainderBand = nSrcHeight % nScansInBand;
            }
            else
            {
                nBands = 0;
                nScansInRemainderBand = (nSrcHeight);
            }

            if (nScansInRemainderBand>0)
            {
                nBands++;
                nScansInCurrentBand = nScansInRemainderBand;
            }
            else
            {
                nScansInCurrentBand = nScansInBand;
            }

            if (nBands != 1)
            {
                //
                // We're going to have to modify the bmi for this image to 
                // coerce NtGdiStretchDIBitsInternal to do the banding.
                // There is a codepath that gets to this point with pbmiNew
                // set to pbmi (pointer copy) rather than local allocated space.
                // if the memory passed in the pointer to pbmi is read only, 
                // we won't be able to hack the header, so we make a local copy
                // for banding.
                //

                pbmiSave = pbmiNew;  //store the old value
                pbmiNew = (LPBITMAPINFO)LOCALALLOC(cjHeader);
                if (pbmiNew)
                {

                    RtlCopyMemory((LPBYTE)pbmiNew, 
                                  (LPBYTE)pbmiSave, 
                                  cjHeader);

                    HeaderHeightHack = pbmiNew->bmiHeader.biHeight;  
                }
                else
                {
                    //
                    // we need to bail out here. Goto the cleanup code.
                    //

                    WARNING("StretchDIBits: couldn't allocate memory for temporary BITMAPINFO\n");

                    pbmiNew = pbmiSave;
                    iRet = 0;
                    goto Exit;
                }
            }

            for (i=0; i<nBands; i++)
            {
                //
                // Initialize band specific size counters.
                //

                CurrentBandSize = nScansInCurrentBand*SizeOfOneScanline;
                IcmSizeOfOneScanline = SizeOfOneScanline;
                cjBitsIcm = cjBits;

                //
                // The Delta refers to the number of extra scanlines to pass
                // to the internal blting routines in order to avoid halftone
                // seams.
                //
                // PositiveBandDelta is usually the number of scanlines to 
                // add on to the end of the band. (relative to the start in 
                // memory)
                //
                // NegativeBandDelta is usually the number of scanlines to 
                // subtract from the begining of the band (ie move the start
                // pointer back this many scanlines).
                //
                // Total BandDelta is simply the total number of extra scans
                // added for this band (both at the start and end).
                //
                // We reverse the sense of positive and negative when rendering
                // bottom up DIBs
                //

                NegativeBandDelta = MIN(EXTRAPIXEL, CumulativeScans);
                PositiveBandDelta = MIN(EXTRAPIXEL, MAX(0, nSrcHeight-(CumulativeScans+nScansInCurrentBand)));
                TotalBandDelta = NegativeBandDelta+PositiveBandDelta;

                if (nBands != 1)
                {
                    //
                    // We're going to be doing fancy banding stuff with the clip
                    // region so we'll want to restore it after the band is done.
                    //

                    SaveDC(hdc);

                    //
                    // Intersect the clip rectangles.
                    // This clip rectangle is designed to restrict the output to 
                    // just the displayed portion of the band.
                    // We may pass more scanlines on the top and bottom of the band 
                    // to get halftoning to merge seamlessly.
                    //

                    
                    lMulDivStoreY1 = (float)nDestHeight*CumulativeScans;
                    lMulDivStoreY2 = (float)nDestHeight*(CumulativeScans+nScansInCurrentBand);


                    iRet = IntersectClipRect(
                                            hdc,
                                            xDest,
                                            yDest+(LONG)(lMulDivStoreY1/nSrcHeight+0.5),
                                            xDest+nDestWidth,
                                            yDest+(LONG)(lMulDivStoreY2/nSrcHeight+0.5));

                    if (iRet==ERROR)
                    {
                        WARNING("StretchDIBits: error intersecting clip rect\n");
                        RestoreDC(hdc, -1);
                        goto Exit;
                    }

                    //
                    // Empty clip rectangle 
                    // If the clip regions don't intersect, we can quit without
                    // doing anything.
                    //

                    if (iRet==NULLREGION)
                    {
                        RestoreDC(hdc, -1);

                        //
                        // Nothing to do - fall through and do 
                        // initialization for next iteration.
                        //

                        goto Continue_With_Init;
                    }

                    //
                    // Hack the BITMAPINFO header so that NtGdiStretchDIBitsInternal
                    // works correctly. Note that hacking it before the ICM call will
                    // carry through to the NtGdiStretchDIBitsInteral call.
                    //
                    // This code also updates the pointer to the bits, in a manner
                    // appropriate to the topdown/bottomup nature of the DIB.
                    //

                    if (HeaderHeightHack >= 0)
                    {
                        //
                        //Bottom Up
                        //

                        pBitsBand = (char *)pj + (ySrc+nSrcHeight-nScansInCurrentBand-CumulativeScans-PositiveBandDelta)*SizeOfOneScanline;
                        pbmiNew->bmiHeader.biHeight = nScansInCurrentBand+TotalBandDelta;
                    }
                    else
                    {
                        //
                        //Top Down
                        //

                        pBitsBand = (char *)pj + (ySrc+CumulativeScans-NegativeBandDelta)*SizeOfOneScanline;
                        pbmiNew->bmiHeader.biHeight = -(nScansInCurrentBand+TotalBandDelta);
                    }
                }
                else
                {
                    pBitsBand = (char *)pj;
                }

                //
                // Initialize per band ICM variables
                //

                cjHeaderNew=0;
                pbmiIcm = NULL;
                pvBitsIcm = NULL;

                //
                // Call ICM with an oversized band for later halftoning by 
                // NtGdiStretchDIBitsInternal
                //

                bIcmStatus = IcmTranslateDIB(
                                            hdc,
                                            pdcattr,
                                            (nBands==1)?cjBits:(CurrentBandSize+TotalBandDelta*SizeOfOneScanline),
                                            (PVOID)pBitsBand,
                                            &pvBitsIcm,
                                            pbmiNew,
                                            &pbmiIcm,
                                            &cjHeaderNew,
                                            (nBands==1)?((DWORD)-1):(nScansInCurrentBand+TotalBandDelta),
                                            iUsage,
                                            ICM_FORWARD,
                                            &pBitmapColorSpace,
                                            &pCXform);

                if (bIcmStatus)
                {
                    if (pvBitsIcm == NULL)
                    {
                        pvBitsIcm = pBitsBand;
                    }
                    if (pbmiIcm == NULL)
                    {
                        pbmiIcm = pbmiNew;
                        cjHeaderNew = cjHeader;
                    }
                    else
                    {
                        //
                        // new bits and header means a possibly different size bitmap
                        // and different size scanline.
                        // 
                        // if nBands==1 then nScansInCurrentBand==nNumScans and
                        // TotalBandDelta==0
                        //
                        // Also note that nNumScans is the number of scans rendered,
                        // not the number of scans in the bitmap or converted in 
                        // IcmTranslateDIB for nBands==1 case
                        //

                        if(nBands == 1) {
                          cjBitsIcm = cjBitmapBitsSize(pbmiIcm);
                        }
                        CurrentBandSize = cjBitmapScanSize(pbmiIcm, nScansInCurrentBand);
                        IcmSizeOfOneScanline = cjBitmapScanSize(pbmiIcm, 1);
                        if (!cjHeaderNew)
                        {
                            cjHeaderNew = cjHeader;
                        }
                    }
                    if (pCXform)
                    {
                        hcmTempXform = pCXform->ColorTransform;
                    }
                }
                else
                {
                    pvBitsIcm = pBitsBand;
                    pbmiIcm = pbmiNew;
                    cjHeaderNew = cjHeader;
                }

                lMulDivStoreY1 = (float)nDestHeight*(CumulativeScans-NegativeBandDelta);
                lMulDivStoreY2 = (float)nDestHeight*(nScansInCurrentBand+TotalBandDelta);
                iRet = NtGdiStretchDIBitsInternal(
                                                 hdc,                                                      
                                                 xDest,
                                                 yDest+(LONG)(lMulDivStoreY1/nSrcHeight+0.5),
                                                 nDestWidth,
                                                 (LONG)(lMulDivStoreY2/nSrcHeight+0.5),
                                                 xSrc,
                                                 (nBands==1)?ySrc:0,
                                                 nSrcWidth,
                                                 nScansInCurrentBand+TotalBandDelta,
                                                 (LPBYTE) pvBitsIcm,
                                                 (LPBITMAPINFO) pbmiIcm,
                                                 iUsage,
                                                 lRop,
                                                 (UINT)cjHeaderNew,
                                                 (nBands==1)?cjBitsIcm:(UINT)CurrentBandSize+TotalBandDelta*IcmSizeOfOneScanline,
                                                 hcmTempXform);


                if (nBands != 1)
                {
                    //
                    // Unhack the header
                    //

                    pbmiNew->bmiHeader.biHeight = HeaderHeightHack;
                }

                if (iRet==GDI_ERROR)
                {
                    WARNING("StretchDIBits: NtGdiStretchDIBitsInternal returned GDI_ERROR\n");
                    if (nBands!=1)
                    {
                        RestoreDC(hdc, -1);
                    }
                    goto Exit;  //Some GDI error and we need to quit.
                }
                cScanCount+=iRet-TotalBandDelta;

                //
                //Throw away temp storage
                //

                if (pBitmapColorSpace)
                {
                    if (pCXform)
                    {
                        IcmDeleteColorTransform(pCXform,FALSE);
                        pCXform = NULL;
                    }
                    IcmReleaseColorSpace(NULL,pBitmapColorSpace,FALSE);
                    pBitmapColorSpace = NULL;
                }
                if ((pvBitsIcm!=NULL)&&(pvBitsIcm!=pBitsBand))
                {
                    LOCALFREE(pvBitsIcm);
                    pvBitsIcm = NULL;
                }
                if ((pbmiIcm!=NULL)&&(pbmiIcm!=pbmiNew))
                {
                    LOCALFREE(pbmiIcm);
                    pbmiIcm = NULL;
                }
                hcmTempXform = NULL;


                Continue_With_Init:                
                //
                //Initialize variables for next loop.
                //

                CumulativeScans += nScansInCurrentBand;
                nScansInCurrentBand = nScansInBand;
                if (nBands != 1)
                {
                    RestoreDC(hdc, -1);
                }
            }

            if (nBands != 1)
            {
                ASSERTGDI(pbmiSave!=NULL, "StretchDIBits: pbmiSave==NULL\n");
                ASSERTGDI(pbmiNew!=NULL, "StretchDIBits: pbmiNew==NULL\n");
                LOCALFREE(pbmiNew);
                pbmiNew = pbmiSave;

                //
                // pbmiNew will be cleaned up in the 
                // regular cleanup code below.
                //
            }
            //
            // We do our own NtGdiSetDIBitsToDeviceInternal
            // So we need to fall through to cleanup at this point.
            //
            iRet=cScanCount;
            goto Exit;
        }
    }

    if (bStatus)
    {
        iRet = NtGdiStretchDIBitsInternal(hdc,
                                          xDest,
                                          yDest,
                                          nDestWidth,
                                          nDestHeight,
                                          xSrc,
                                          ySrc,
                                          nSrcWidth,
                                          nSrcHeight,
                                          (LPBYTE) pj,
                                          (LPBITMAPINFO) pbmiNew,
                                          iUsage,
                                          lRop,
                                          cjHeader,
                                          cjBits,
                                          hcmTempXform);
    }

    Exit:
    if (pulBits)
    {
        LOCALFREE(pulBits);
    }

    if (pbmiNew && (pbmiNew != pbmi))
    {
        LOCALFREE(pbmiNew);
    }

    return (iRet);
}


/******************************Public*Routine******************************\
*
* History:
*  27-Oct-2000 -by- Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

HBITMAP SetBitmapAttributes(HBITMAP hbm, DWORD dwFlags)
{
    FIXUP_HANDLE(hbm);

    if ((dwFlags & ~SBA_STOCK) != 0)
        return (HBITMAP)0;

    return (HBITMAP)NtGdiSetBitmapAttributes(hbm,dwFlags);
}

/******************************Public*Routine******************************\
*
* History:
*  27-Oct-2000 -by- Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

HBITMAP ClearBitmapAttributes(HBITMAP hbm, DWORD dwFlags)
{
    FIXUP_HANDLE(hbm);

    if ((dwFlags & ~SBA_STOCK) != 0)
        return (HBITMAP)0;

    return (HBITMAP)NtGdiClearBitmapAttributes(hbm,dwFlags);
}

/******************************Public*Routine******************************\
 *
 * History:
 *  27-Oct-2000 -by- Pravin Santiago [pravins]
 * Wrote it.
\**************************************************************************/

DWORD GetBitmapAttributes(HBITMAP hbm)
{
    DWORD dwRet = 0;
    FIXUP_HANDLE(hbm);

    if (IS_STOCKOBJ(hbm))
       dwRet |= SBA_STOCK;

    return dwRet; 
}

/******************************Public*Routine******************************\
*
* History:
*  27-Oct-2000 -by- Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

HBRUSH SetBrushAttributes(HBRUSH hbr, DWORD dwFlags)
{
    FIXUP_HANDLE(hbr);

    if ((dwFlags & ~SBA_STOCK) != 0)
        return (HBRUSH)0;

    return (HBRUSH)NtGdiSetBrushAttributes(hbr,dwFlags);
}

/******************************Public*Routine******************************\
*
* History:
*  27-Oct-2000 -by- Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

HBRUSH ClearBrushAttributes(HBRUSH hbr, DWORD dwFlags)
{
    FIXUP_HANDLE(hbr);

    if ((dwFlags & ~SBA_STOCK) != 0)
        return (HBRUSH)0;

    return (HBRUSH)NtGdiClearBrushAttributes(hbr,dwFlags);
}

/******************************Public*Routine******************************\
 *
 * History:
 *  27-Oct-2000 -by- Pravin Santiago [pravins]
 * Wrote it.
\**************************************************************************/

DWORD GetBrushAttributes(HBRUSH hbr)
{
    DWORD dwRet = 0;
    FIXUP_HANDLE(hbr);

    if (IS_STOCKOBJ(hbr))
       dwRet |= SBA_STOCK;

    return dwRet; 
}

/******************************Public*Routine******************************\
*
* History:
*  28-May-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HBITMAP CreateBitmap(
int         nWidth,
int         nHeight,
UINT        nPlanes,
UINT        nBitCount,
CONST VOID *lpBits)
{
    LONG    cj;
    HBITMAP hbm = (HBITMAP)0;
    INT     ii;

    // check if it is an empty bitmap

    if ((nWidth == 0) || (nHeight == 0))
    {
        return(GetStockObject(PRIV_STOCK_BITMAP));
    }

    // Pass call to the server

    if (lpBits == (VOID *) NULL)
        cj = 0;
    else
    {
        cj = (((nWidth*nPlanes*nBitCount + 15) >> 4) << 1) * nHeight;

        if (cj < 0)
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return((HBITMAP)0);
        }
    }

    hbm = NtGdiCreateBitmap(nWidth,
                            nHeight,
                            nPlanes,
                            nBitCount,
                            (LPBYTE) lpBits);

#if TRACE_SURFACE_ALLOCS
    {
        PULONG  pUserAlloc;

        PSHARED_GET_VALIDATE(pUserAlloc, hbm, SURF_TYPE);

        if (pUserAlloc != NULL)
        {
            pUserAlloc[1] = RtlWalkFrameChain((PVOID *)&pUserAlloc[2], pUserAlloc[0], 0);
        }
    }
#endif

    return(hbm);
}

/******************************Public*Routine******************************\
* HBITMAP CreateBitmapIndirect(CONST BITMAP * pbm)
*
* NOTE: if the bmWidthBytes is larger than it needs to be, GetBitmapBits
* will return different info than the set.
*
* History:
*  Tue 18-Jan-1994 -by- Bodin Dresevic [BodinD]
* update: added bmWidthBytes support
*  28-May-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HBITMAP CreateBitmapIndirect(CONST BITMAP * pbm)
{
    HBITMAP hbm    = (HBITMAP)0;
    LPBYTE  lpBits = (LPBYTE)NULL; // important to zero init
    BOOL    bAlloc = FALSE;        // indicates that tmp bitmap was allocated

// compute minimal word aligned scan width in bytes given the number of
// pixels in x. The width refers to one plane only. Our multi - planar
// support is broken anyway. I believe that we should take an early
// exit if bmPlanes != 1. [bodind].

    LONG cjWidthWordAligned = ((pbm->bmWidth * pbm->bmBitsPixel + 15) >> 4) << 1;

// Win 31 requires at least WORD alinged scans, have to reject inconsistent
// input, this is what win31 does

    if
    (
     (pbm->bmWidthBytes & 1)           ||
     (pbm->bmWidthBytes == 0)          ||
     (pbm->bmWidthBytes < cjWidthWordAligned)
    )
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (HBITMAP)0;
    }

// take an early exit if this is not the case we know how to handle:

    if (pbm->bmPlanes != 1)
    {
        WARNING("gdi32: can not handle bmPlanes != 1\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (HBITMAP)0;
    }

// if bmBits is nonzero and bmWidthBytes is bigger than the minimal required
// word aligned width we will first convert the bitmap to one that
// has the rows that are minimally word aligned:

    if (pbm->bmBits)
    {
        if (pbm->bmWidthBytes > cjWidthWordAligned)
        {
            PBYTE pjSrc, pjDst, pjDstEnd;
            ULONGLONG lrg;

            lrg = UInt32x32To64(
                       (ULONG)cjWidthWordAligned,
                       (ULONG)pbm->bmHeight
                       );

            if (lrg > ULONG_MAX  ||
                !(lpBits = (LPBYTE)LOCALALLOC((size_t) lrg)))
            {
            // the result does not fit in 32 bits, alloc memory will fail
            // this is too big to digest

                GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return (HBITMAP)0;
            }

        // flag that we have allocated memory so that we can free it later

            bAlloc = TRUE;

        // convert bitmap to minimally word aligned format

            pjSrc = (LPBYTE)pbm->bmBits;
            pjDst = lpBits;
            pjDstEnd = lpBits + (size_t) lrg;

            while (pjDst < pjDstEnd)
            {
                RtlCopyMemory(pjDst,pjSrc, cjWidthWordAligned);
                pjDst += cjWidthWordAligned, pjSrc += pbm->bmWidthBytes;
            }
        }
        else
        {
        // bits already in minimally aligned format, do nothing

            ASSERTGDI(
                pbm->bmWidthBytes == cjWidthWordAligned,
                "pbm->bmWidthBytes != cjWidthWordAligned\n"
                );
            lpBits = (LPBYTE)pbm->bmBits;
        }
    }

    hbm = CreateBitmap(
                pbm->bmWidth,
                pbm->bmHeight,
                (UINT) pbm->bmPlanes,
                (UINT) pbm->bmBitsPixel,
                lpBits);

#if TRACE_SURFACE_ALLOCS
    {
        PULONG  pUserAlloc;

        PSHARED_GET_VALIDATE(pUserAlloc, hbm, SURF_TYPE);

        if (pUserAlloc != NULL)
        {
            pUserAlloc[1] = RtlWalkFrameChain((PVOID *)&pUserAlloc[2], pUserAlloc[0], 0);
        }
    }
#endif

    if (bAlloc)
        LOCALFREE(lpBits);

    return(hbm);
}

/******************************Public*Routine******************************\
* CreateDIBSection
*
* Allocate a file mapping object for a DIB.  Return the pointer to it
* and the handle of the bitmap.
*
* History:
*
*  25-Aug-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

HBITMAP
WINAPI
CreateDIBSection(
    HDC hdc,
    CONST BITMAPINFO *pbmi,
    UINT iUsage,
    VOID **ppvBits,
    HANDLE hSectionApp,
    DWORD dwOffset)
{
    HBITMAP hbm = NULL;
    PVOID   pjBits = NULL;
    BITMAPINFO * pbmiNew = NULL;
    INT     cjHdr;

    FIXUP_HANDLE(hdc);

    pbmiNew = pbmiConvertInfo(pbmi, iUsage, &cjHdr ,FALSE);

    //
    // Does not support passthrough image (BI_JPEG or BI_PNG).
    // Return NULL for error.
    //

    if (IS_BMI_PASSTHROUGH_IMAGE(pbmiNew))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return hbm;
    }

    //
    // dwOffset has to be a multiple of 4 (sizeof(DWORD))
    // if there is a section.  If the section is NULL we do
    // not care
    //

    if ( (hSectionApp == NULL) ||
         ((dwOffset & 3) == 0) )
    {
        PCACHED_COLORSPACE pBitmapColorSpace = NULL;
        BOOL               bCreatedColorSpace = FALSE;

        LOGCOLORSPACEW LogColorSpace;
        PROFILE        ColorProfile;
        DWORD          dwFlags = 0;

        //
        // Check they has thier own color space or not.
        //
        if (pbmiNew && IcmGetBitmapColorSpace(pbmiNew,&LogColorSpace,&ColorProfile,&dwFlags))
        {
            //
            // Find ColorSpace from cache.
            //
            pBitmapColorSpace = IcmGetColorSpaceByColorSpace(
                                    (HGDIOBJ)hdc,
                                    &LogColorSpace,
                                    &ColorProfile,
                                    dwFlags);

            if (pBitmapColorSpace == NULL)
            {
                //
                // If we can not find the color space for this DIBSection from existing color space.
                // create new one for this, but we mark it as DIBSECTION_COLORSPACE, then associated
                // to this hdc (later hbm), so that we can make sure this color space get deleted 
                // when hbm is deleted.
                //
                dwFlags |= DIBSECTION_COLORSPACE;

                //
                // Mark we will create new colorspace for this bitmap.
                //
                bCreatedColorSpace = TRUE;

                //
                // Create new cache.
                //
                pBitmapColorSpace = IcmCreateColorSpaceByColorSpace(
                                        (HGDIOBJ)hdc,
                                        &LogColorSpace,
                                        &ColorProfile,
                                        dwFlags);
            }
        }

        hbm = NtGdiCreateDIBSection(
                                hdc,
                                hSectionApp,
                                dwOffset,
                                (LPBITMAPINFO) pbmiNew,
                                iUsage,
                                cjHdr,
                                0,
                                (ULONG_PTR)pBitmapColorSpace,
                                (PVOID *)&pjBits);

        if ((hbm == NULL) || (pjBits == NULL))
        {
            hbm = 0;
            pjBits = NULL;
            if (pBitmapColorSpace)
            {
                IcmReleaseColorSpace(NULL,pBitmapColorSpace,FALSE);
            }
        }
        else
        {
#if TRACE_SURFACE_ALLOCS
            PULONG  pUserAlloc;

            PSHARED_GET_VALIDATE(pUserAlloc, hbm, SURF_TYPE);

            if (pUserAlloc != NULL)
            {
                pUserAlloc[1] = RtlWalkFrameChain((PVOID *)&pUserAlloc[2], pUserAlloc[0], 0);
            }
#endif

            if (pBitmapColorSpace && bCreatedColorSpace)
            {
                //
                // if we created new color space for this bitmap,
                // set owner of this colorspace to the created bitmap.
                //
                pBitmapColorSpace->hObj = hbm;
            }
        }
    }

    //
    // Assign the appropriate value to the caller's pointer
    //

    if (ppvBits != NULL)
    {
        *ppvBits = pjBits;
    }

    if (pbmiNew && (pbmiNew != pbmi))
    {
        LOCALFREE(pbmiNew);
    }

    return(hbm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\cliumpd.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    cliumpd.h

Abstract:

    User-mode printer driver header file

Environment:

        Windows NT 5.0

Revision History:

        06/30/97 -davidx-
                Created it.

--*/


#ifndef _UMPD_H_
#define _UMPD_H_


//
// Critical section for user-mode printer driver
//

extern RTL_CRITICAL_SECTION semUMPD;


#define UMPDFLAG_DRVENABLEDRIVER_CALLED 0x0001

#define UMPDFLAG_METAFILE_DRIVER        0x0002

#define UMPDFLAG_NON_METAFILE_DRIVER    0x0004

//
// Data structure signature for debugging purposes
//

#define UMPD_SIGNATURE  0xfedcba98
#define VALID_UMPD(p)   ((p) != NULL && (p)->dwSignature == UMPD_SIGNATURE)

//
// User-mode printer driver support functions
//

BOOL
LoadUserModePrinterDriver(
    HANDLE  hPrinter,
    LPWSTR  pwstrPrinterName,
    PUMPD  *ppUMPD,
    PRINTER_DEFAULTSW *pdefaults
    );

BOOL
LoadUserModePrinterDriverEx(
    PDRIVER_INFO_5W     pDriverInfo5,
    LPWSTR              pwstrPrinterName,
    PUMPD               *ppUMPD,
    PRINTER_DEFAULTSW   *pdefaults,
    HANDLE              hPrinter
    );

UnloadUserModePrinterDriver(
    PUMPD   pUMPD,
    BOOL    bNotifySpooler,
    HANDLE  hPrinter
    );


/*++

Routine Description:

    This entrypoint must be exported by a user-mode printer driver DLL.
    GDI calls this function to query various information about the driver.

Arguments:

    dwMode - Specifies what information is being queried
    pBuffer - Points to an output buffer for storing the returned information
    cbBuf - Size of the output buffer in bytes
    pcbNeeded - Returns the expected size of the output buffer

Return Value:

    TRUE if successful, FALSE if there is an error

Note:

    If cbBuf is not large enough to stored the necessary return information,
    the driver should return FALSE from this function and set last error code
    to ERROR_INSUFFICIENT_BUFFER. *pcbNeeded always contains the expected
    size of the output buffer.

--*/

typedef BOOL (APIENTRY *PFN_DrvQueryDriverInfo)(
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbBuf,
    PDWORD  pcbNeeded
    );

PUMPD
UMPDDrvEnableDriver(
    PWSTR           pDriverDllName,
    ULONG           iEngineVersion
    );

#endif  // !_UMPD_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\cfont.c ===
/******************************Module*Header*******************************\
* Module Name: cfont.c
*
* Created: 28-May-1991 13:01:27
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

CFONT *pcfCreateCFONT(HDC hdc,PDC_ATTR pDcAttr,UINT iFirst,PVOID pch,UINT c,BOOL bAnsi);
BOOL bFillWidthTableForGTE( HDC, CFONT *, PVOID, UINT, BOOL);
BOOL bFillWidthTableForGCW( HDC, CFONT *, UINT, UINT);
VOID vFreeCFONTCrit(CFONT *pcf);

// If the app deletes a LOCALFONT but one or more of the CFONTs hanging
// of the local font are in use then they will be added to this list.
// anytime we try to allocate a new CFONT we will check the list and
// if there entries on that list we will free them up.

CFONT *pcfDeleteList = (CFONT*) NULL;

/******************************Public*Routine******************************\
* pcfAllocCFONT ()                                                         *
*                                                                          *
* Allocates a CFONT.  Tries to get one off the free list first.  Does not  *
* do any initialization.                                                   *
*                                                                          *
*  Sun 10-Jan-1993 01:16:04 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

#ifdef DBGCFONT
int cCfontAlloc = 0;
int cCfontMax = 0;
#endif

int cCfontFree  = 0;

CFONT *pcfFreeListCFONT = (CFONT *) NULL;

CFONT *pcfAllocCFONT()
{
    CFONT *pcf;
    CFONT **ppcf;

// first lets walk the list of deleted fonts and delete any that

    ppcf = &pcfDeleteList;

    while (*ppcf)
    {
        if ((*ppcf)->cRef == 0)
        {
            pcf = (*ppcf);

            *ppcf = pcf->pcfNext;

            vFreeCFONTCrit(pcf);
        }
        else
        {
            ppcf = &(*ppcf)->pcfNext;
        }
    }

// Try to get one off the free list.

    pcf = pcfFreeListCFONT;
    if (pcf != (CFONT *) NULL)
    {
        pcfFreeListCFONT = *((CFONT **) pcf);
        --cCfontFree;
    }

// Otherwise allocate new memory.

    if (pcf == (CFONT *) NULL)
    {
        pcf = (CFONT *) LOCALALLOC(sizeof(CFONT));

        if (pcf == (CFONT *) NULL)
        {
            GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }

    #ifdef DBGCFONT
        cCfontAlloc++;
        if (cCfontAlloc > cCfontMax)
        {
            cCfontMax = cCfontAlloc;
            DbgPrint("\n\n******************* cCfontMax = %ld\n\n",cCfontMax);
        }
    #endif
    }
    return(pcf);
}

/******************************Public*Routine******************************\
* vFreeCFONTCrit (pcf)                                                     *
*                                                                          *
* Frees a CFONT.  Actually just puts it on the free list.  We assume that  *
* we are already in a critical section.                                    *
*                                                                          *
*  Sun 10-Jan-1993 01:20:36 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

#define MAX_FREE_CFONT 10

VOID vFreeCFONTCrit(CFONT *pcf)
{
    ASSERTGDI(pcf != (CFONT *) NULL,"Trying to free NULL CFONT.\n");

    if(cCfontFree > MAX_FREE_CFONT)
    {
        LOCALFREE(pcf);
    #ifdef DBGCFONT
        cCfontAlloc--;
    #endif
    }
    else
    {
        *((CFONT **) pcf) = pcfFreeListCFONT;
        pcfFreeListCFONT = pcf;
        ++cCfontFree;
    }
}


/******************************Public*Routine******************************\
* bComputeCharWidths                                                       *
*                                                                          *
* Client side version of GetCharWidth.                                     *
*                                                                          *
*  Sat 16-Jan-1993 04:27:19 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bComputeCharWidths
(
    CFONT *pcf,
    UINT   iFirst,
    UINT   iLast,
    ULONG  fl,
    PVOID  pv
)
{
    USHORT *ps;
    UINT    ii;

    switch (fl & (GCW_INT | GCW_16BIT))
    {
    case GCW_INT:               // Get LONG widths.
        {
            LONG *pl = (LONG *) pv;
            LONG fxOverhang = 0;

        // Check for Win 3.1 compatibility.

            if (fl & GCW_WIN3)
                fxOverhang = pcf->wd.sOverhang;

        // Do the trivial no-transform case.

            if (bIsOneSixteenthEFLOAT(pcf->efDtoWBaseline))
            {
                fxOverhang += 8;    // To round the final result.

            //  for (ii=iFirst; ii<=iLast; ii++)
            //      *pl++ = (pcf->sWidth[ii] + fxOverhang) >> 4;

                ps = &pcf->sWidth[iFirst];
                ii = iLast - iFirst;
            unroll_1:
                switch(ii)
                {
                default:
                    pl[4] = (ps[4] + fxOverhang) >> 4;
                case 3:
                    pl[3] = (ps[3] + fxOverhang) >> 4;
                case 2:
                    pl[2] = (ps[2] + fxOverhang) >> 4;
                case 1:
                    pl[1] = (ps[1] + fxOverhang) >> 4;
                case 0:
                    pl[0] = (ps[0] + fxOverhang) >> 4;
                }
                if (ii > 4)
                {
                    ii -= 5;
                    pl += 5;
                    ps += 5;
                    goto unroll_1;
                }
                return(TRUE);
            }

        // Otherwise use the back transform.

            else
            {
                for (ii=iFirst; ii<=iLast; ii++)
                    *pl++ = lCvt(pcf->efDtoWBaseline,pcf->sWidth[ii] + fxOverhang);
                return(TRUE);
            }
        }

    case GCW_INT+GCW_16BIT:     // Get SHORT widths.
        {
            USHORT *psDst = (USHORT *) pv;
            USHORT  fsOverhang = 0;

        // Check for Win 3.1 compatibility.

            if (fl & GCW_WIN3)
                fsOverhang = pcf->wd.sOverhang;

        // Do the trivial no-transform case.

            if (bIsOneSixteenthEFLOAT(pcf->efDtoWBaseline))
            {
                fsOverhang += 8;    // To round the final result.

            //  for (ii=iFirst; ii<=iLast; ii++)
            //      *psDst++ = (pcf->sWidth[ii] + fsOverhang) >> 4;

                ps = &pcf->sWidth[iFirst];
                ii = iLast - iFirst;
            unroll_2:
                switch(ii)
                {
                default:
                    psDst[4] = (ps[4] + fsOverhang) >> 4;
                case 3:
                    psDst[3] = (ps[3] + fsOverhang) >> 4;
                case 2:
                    psDst[2] = (ps[2] + fsOverhang) >> 4;
                case 1:
                    psDst[1] = (ps[1] + fsOverhang) >> 4;
                case 0:
                    psDst[0] = (ps[0] + fsOverhang) >> 4;
                }
                if (ii > 4)
                {
                    ii -= 5;
                    psDst += 5;
                    ps += 5;
                    goto unroll_2;
                }
                return(TRUE);
            }

        // Otherwise use the back transform.

            else
            {
                for (ii=iFirst; ii<=iLast; ii++)
                {
                    *psDst++ = (USHORT)
                               lCvt
                               (
                                   pcf->efDtoWBaseline,
                                   (LONG) (pcf->sWidth[ii] + fsOverhang)
                               );
                }
                return(TRUE);
            }
        }

    case 0:                     // Get FLOAT widths.
        {
            LONG *pe = (LONG *) pv; // Cheat to avoid expensive copies.
            EFLOAT_S efWidth,efWidthLogical;

            for (ii=iFirst; ii<=iLast; ii++)
            {
                vFxToEf((LONG) pcf->sWidth[ii],efWidth);
                vMulEFLOAT(efWidthLogical,efWidth,pcf->efDtoWBaseline);
                *pe++ = lEfToF(efWidthLogical);
            }
            return(TRUE);
        }
    }
    RIP("bComputeCharWidths: Don't come here!\n");
    return(FALSE);
}

/******************************Public*Routine******************************\
* bComputeTextExtent (pldc,pcf,psz,cc,fl,psizl,btype)                            *
*                                                                          *
* A quick function to compute text extents on the client side.             *
*                                                                          *
*  Thu 14-Jan-1993 04:00:57 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bComputeTextExtent
(
    PDC_ATTR    pDcAttr,
    CFONT      *pcf,
    LPVOID      psz,
    int         cc,
    UINT        fl,
    SIZE       *psizl,
    BOOL        bAnsi  // TRUE is for ANSI, FALSE is for Unicode
)
{
    LONG    fxBasicExtent;
    INT     lTextExtra,lBreakExtra,cBreak;
    int     ii;
    BYTE *  pc;
    LONG    fxCharExtra = 0;
    LONG    fxBreakExtra;
    LONG    fxExtra = 0;
    BOOL    bRet = TRUE;
    WCHAR * pwc;

    lTextExtra = pDcAttr->lTextExtra;
    lBreakExtra = pDcAttr->lBreakExtra;
    cBreak = pDcAttr->cBreak;

// Compute the basic extent.

    if (pcf->wd.sCharInc == 0)
    {
        fxBasicExtent = 0;
        if(bAnsi)
            pc = (BYTE *) psz;
        else
            pwc = (WCHAR *) psz;
            
        ii = cc;

    unroll_here:
        if(bAnsi)
        {
            switch (ii)
            {
            default:
                fxBasicExtent += pcf->sWidth[pc[9]];
            case 9:
                fxBasicExtent += pcf->sWidth[pc[8]];
            case 8:
                fxBasicExtent += pcf->sWidth[pc[7]];
            case 7:
                fxBasicExtent += pcf->sWidth[pc[6]];
            case 6:
                fxBasicExtent += pcf->sWidth[pc[5]];
            case 5:
                fxBasicExtent += pcf->sWidth[pc[4]];
            case 4:
                fxBasicExtent += pcf->sWidth[pc[3]];
            case 3:
                fxBasicExtent += pcf->sWidth[pc[2]];
            case 2:
                fxBasicExtent += pcf->sWidth[pc[1]];
            case 1:
                fxBasicExtent += pcf->sWidth[pc[0]];
            }
        }
        else
        {
            switch (ii)
            {
            default:
                fxBasicExtent += pcf->sWidth[pwc[9]];
            case 9:
                fxBasicExtent += pcf->sWidth[pwc[8]];
            case 8:
                fxBasicExtent += pcf->sWidth[pwc[7]];
            case 7:
                fxBasicExtent += pcf->sWidth[pwc[6]];
            case 6:
                fxBasicExtent += pcf->sWidth[pwc[5]];
            case 5:
                fxBasicExtent += pcf->sWidth[pwc[4]];
            case 4:
                fxBasicExtent += pcf->sWidth[pwc[3]];
            case 3:
                fxBasicExtent += pcf->sWidth[pwc[2]];
            case 2:
                fxBasicExtent += pcf->sWidth[pwc[1]];
            case 1:
                fxBasicExtent += pcf->sWidth[pwc[0]];
            }
        }
        ii -= 10;
        if (ii > 0)
        {
            if(bAnsi)
                pc += 10;
            else
                pwc += 10;
            goto unroll_here;
        }
    }
    else
    {
    // Fixed pitch case.

        fxBasicExtent = cc * (LONG) pcf->wd.sCharInc;
    }

// Adjust for CharExtra.

    if (lTextExtra)
    {
        int cNoBackup = 0;

        fxCharExtra = lCvt(pcf->efM11,lTextExtra);

        if (fxCharExtra < 0)
        {
        // the layout code won't backup a characters past it's origin regardless
        // of the value of iTextCharExtra so figure out for how many values
        // we will need to ignore fxCharExtra

            if (pcf->wd.sCharInc == 0)
            {
                if(bAnsi)
                {
                    pc = (BYTE *) psz;
                    for (ii = 0; ii < cc; ii++)
                    {
                        if (pcf->sWidth[pc[ii]] + fxCharExtra <= 0)
                        {
                            cNoBackup += 1;
                        }
                    }
                }
                else
                {
                    pwc = (WCHAR *) psz;
                    for (ii = 0; ii < cc; ii++)
                    {
                        if (pcf->sWidth[pwc[ii]] + fxCharExtra <= 0)
                        {
                            cNoBackup += 1;
                        }
                    }
                }                 
            }
            else if (pcf->wd.sCharInc + fxCharExtra <= 0)
            {
                cNoBackup = cc;
            }
        }

        if ( (fl & GGTE_WIN3_EXTENT) && (pcf->hdc == 0) // hdc of zero is display DC
            && (!(pcf->flInfo & FM_INFO_TECH_STROKE)) )
            fxExtra = fxCharExtra * ((lTextExtra > 0) ? cc : (cc - 1));
        else
            fxExtra = fxCharExtra * (cc - cNoBackup);
    }

// Adjust for lBreakExtra.

    if (lBreakExtra && cBreak)
    {
        fxBreakExtra = lCvt(pcf->efM11,lBreakExtra) / cBreak;

    // Windows won't let us back up over a break.  Set up the BreakExtra
    // to just cancel out what we've already got.

        if (fxBreakExtra + pcf->wd.sBreak + fxCharExtra < 0)
            fxBreakExtra = -(pcf->wd.sBreak + fxCharExtra);

    // Add it up for all breaks.

        if(bAnsi)
        {
            pc = (BYTE *) psz;
            for (ii=0; ii<cc; ii++)
            {
                if (*pc++ == pcf->wd.iBreak)
                    fxExtra += fxBreakExtra;
            }
        }
        else
        {
            pwc = (WCHAR *) psz;
            for (ii=0; ii<cc; ii++)
            {
                if (*pwc++ == pcf->wd.iBreak)
                    fxExtra += fxBreakExtra;
            }
        }
    }

// Add in the extra stuff.

    fxBasicExtent += fxExtra;

// Add in the overhang for font simulations.

    if (fl & GGTE_WIN3_EXTENT)
        fxBasicExtent += pcf->wd.sOverhang;

// Transform the result to logical coordinates.

    if (bIsOneSixteenthEFLOAT(pcf->efDtoWBaseline))
        psizl->cx = (fxBasicExtent + 8) >> 4;
    else
        psizl->cx = lCvt(pcf->efDtoWBaseline,fxBasicExtent);

    psizl->cy = pcf->lHeight;

    return bRet;
}

/******************************Public*Routine******************************\
* pcfLocateCFONT (hdc,pDcAttr,iFirst,pch,c)
*
* Locates a CFONT for the given LDC.  First we try the CFONT last used by
* the LDC.  Then we try to do a mapping ourselves through the LOCALFONT.
* If that fails we create a new one.
*
*  Mon 11-Jan-1993 16:18:43 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

CFONT *pcfLocateCFONT(
    HDC      hdc,
    PDC_ATTR pDcAttr,
    UINT     iFirst,
    PVOID    pch,
    UINT     c,
    BOOL     bAnsi)
{
    CFONT     *pcf = NULL;
    LOCALFONT *plf;
    ULONG      fl;
    HANDLE     hf;
    int        i;
    WCHAR      *pwc;
    BYTE       *pchar;

    if (fFontAssocStatus)
        return(pcf);

    fl = pDcAttr->ulDirty_;
    hf = pDcAttr->hlfntNew;

    // Check to make sure that the XFORM is okay.  If not return FALSE and
    // mark this DC as having slow widths.

    if ((fl & SLOW_WIDTHS) || USER_XFORM_DIRTY(pDcAttr) ||
        !(pDcAttr->mxWtoD.flAccel & XFORM_SCALE))
    {
        if (!(fl & SLOW_WIDTHS))
        {
            if (!NtGdiComputeXformCoefficients(hdc))
                pDcAttr->ulDirty_ |= SLOW_WIDTHS;
        }

        if (pDcAttr->ulDirty_ & SLOW_WIDTHS)
            return(pcf);
    }

    if(guintDBCScp != 0xFFFFFFFF)
    {

        DWORD dwCodePage = GetCodePage(hdc);

    //If this is a DBCS charset but not our native one then we can not
    //compute widths and extent quickly, because gpwcDBCSCharSet[]
    //array is computed based on our NATIVE_CODEPAGE using IsDBCSLeadByte()
    //function.

        if ((guintDBCScp != dwCodePage) && IS_ANY_DBCS_CODEPAGE(dwCodePage))
        {
            pDcAttr->ulDirty_ |= SLOW_WIDTHS;
            return pcf;
        }
    }

    // now find the font

    PSHARED_GET_VALIDATE(plf,hf,LFONT_TYPE);

    if (plf == NULL)
    {
        // If there is no local font then this must be a public font or one
        // that's been deleted while still being selected into a DC.  If it's a
        // stockfont let's try to find it.

        if ((hf != NULL) &&
            !(pGdiSharedHandleTable[HANDLE_TO_INDEX(hf)].Flags & HMGR_ENTRY_LAZY_DEL) &&
            (pDcAttr->iMapMode == MM_TEXT) &&
            (fl & DC_PRIMARY_DISPLAY))
        {
            for (i = 0; i < MAX_PUBLIC_CFONT; ++i)
                if (pGdiSharedMemory->acfPublic[i].hf == hf)
                    break;

            // if we didn't find one, try to set one up

            if (i == MAX_PUBLIC_CFONT)
            {
                // this will fill in both the text metrics and widths

                i = NtGdiSetupPublicCFONT(hdc,NULL,0);
            }

            // have we found one yet

            if ((i >= 0) && (i < MAX_PUBLIC_CFONT))
            {
            // make sure mapping table is initialized before we give out a
            // public CFONT

                if ((gpwcANSICharSet == (WCHAR *) NULL) && !bGetANSISetMap())
                {
                    return((CFONT *) NULL);
                }

                pcf = &pGdiSharedMemory->acfPublic[i];
            }
        }
        else
        {
            pDcAttr->ulDirty_ |= SLOW_WIDTHS;
        }
    }
    else if (plf->fl & LF_HARDWAY)
    {
        // If the logfont has non-zero escapement or orientation then bail out.
        // Stock fonts will never have non-zero escapments or orientation so we can do
        // this now.

        pDcAttr->ulDirty_ |= SLOW_WIDTHS;
    }
    else
    {
        BOOL bRet = FALSE;

        // next loop through all the CFONTs associated with this LOGFONT to see if
        // we can find a match.

        for (pcf = plf->pcf; pcf ; pcf = pcf->pcfNext)
        {
            // if the DC's are both display DC's or the same printer DC and the
            // transform's coefficients match then we've got a winner.

            if ((((pcf->hdc == 0) && (fl & DC_PRIMARY_DISPLAY)) || (pcf->hdc == hdc)) &&
               bEqualEFLOAT(pcf->efM11, pDcAttr->mxWtoD.efM11) &&
               bEqualEFLOAT(pcf->efM22, pDcAttr->mxWtoD.efM22))
            {
                // update the refcount so we don't accidentally delete this CFONT while
                // we are using it.

                INC_CFONT_REF(pcf);
                break;
            }
        }

        if (pcf == NULL)
        {
        // don't do this under semaphore because pcfCreateCFONT will call off to
        // font drivers which in turn could access a file on the net and take a
        // very long time

            pcf = pcfCreateCFONT(hdc,pDcAttr,iFirst,pch,c,bAnsi);

            if (pcf)
            {
                // next update the REFCOUNT of the CFONT

                pcf->hf    = hf;
                pcf->hdc   = (fl & DC_PRIMARY_DISPLAY) ? (HDC) 0 : (HDC) hdc;

                // now that we have a CFONT link it in to the chain off of this
                // LOCALFONT

                pcf->pcfNext = plf->pcf;
                plf->pcf = pcf;
            }
        }
        else
        {
            // At this point we have a non-NULL pcf which is referenced by the LDC.
            // We must check it to see if it contains the widths we need.

            if (pcf->fl & CFONT_COMPLETE)
                return(pcf);

            if (pch != NULL)
            {

            // Make sure we have widths for all the chars in the string.
                if (pcf->fl & CFONT_CACHED_WIDTHS)
                {
                    if(bAnsi)
                    {
                        INT ic = (INT)c;

                        pchar = (BYTE *) pch;

                        if (pcf->fl & CFONT_DBCS)
                        {
                        // we won't have local width cache for DBCS chars in sWidth[] array.

                            for (;ic > 0; ic--,pchar++)
                            {
                                if (gpwcDBCSCharSet[*pchar] == 0xffff)
                                {
                                    // skip DBCS chars
                                    if (ic > 0)
                                    {
                                       ic--;
                                       pchar++;
                                    }
                                }
                                else if (pcf->sWidth[*pchar] == NO_WIDTH)
                                {
                                    break;
                                }
                            }
                            if (ic < 0)
                                c = 0;
                            else
                                c = (UINT)ic;
                        }
                        else
                        {
                            for (; c && (pcf->sWidth[*pchar] != NO_WIDTH); c--,pchar++)
                            {}
                        }
                        pch = (PVOID) pchar;
                    }
                    else
                    {
                        pwc = (WCHAR *) pch;
                        for (; c && (pcf->sWidth[*pwc] != NO_WIDTH); c--,pwc++)
                        {}
                        pch = (PVOID) pwc;
                    }
                }

                if (c)
                {
                    bRet = bFillWidthTableForGTE(hdc, pcf, pch, c, bAnsi);
                }
            }
            else
            {
            // Make sure we have widths for the array requested.

                if (pcf->fl & CFONT_CACHED_WIDTHS)
                {
                    if (!(iFirst & 0xffffff00) && !((iFirst + c) & 0xffffff00))
                    {
                        for (; c && (pcf->sWidth[iFirst] != NO_WIDTH); c--,iFirst++)
                        {}
                    }
                }

                if (c)
                {
                    bRet = bFillWidthTableForGCW(hdc, pcf, iFirst, c);
                }
            }

            if (bRet == GDI_ERROR)
            {
                // Something bad happened while trying to fill.  To avoid hitting this
                // problem again on the next call, we mark the LDC as slow.

                DEC_CFONT_REF(pcf);

                pDcAttr->ulDirty_ |= SLOW_WIDTHS;

                pcf = NULL;
            }
        }
    }

    return(pcf);

}

/******************************Public*Routine******************************\
* pcfCreateCFONT (pldc,iFirst,pch,c)                                       *
*                                                                          *
* Allocate and initialize a new CFONT.                                     *
*                                                                          *
* History:                                                                 *
*  Tue 19-Jan-1993 16:16:03 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

EFLOAT_S ef_1 = EFLOAT_1;

CFONT *pcfCreateCFONT(
    HDC hdc,
    PDC_ATTR pDcAttr,
    UINT iFirst,
    PVOID pch,
    UINT c,
    BOOL bAnsi)
{
    CFONT *pcfNew;
    BOOL   bRet;


// Make sure we have the UNICODE translation of the ANSI character set.
// We'll create this once and keep it around to avoid lots of conversion.

    if ((gpwcANSICharSet == (WCHAR *) NULL) && !bGetANSISetMap())
        return((CFONT *) NULL);

// Allocate a new CFONT to hold the results.

    pcfNew = pcfAllocCFONT();

    if (pcfNew != (CFONT *) NULL)
    {
		pcfNew->timeStamp = pGdiSharedMemory->timeStamp;

        pcfNew->fl    = 0;

    // if the default code page is a DBCS code page then we may need to mark this
    // as a DBCS font

        if(guintDBCScp != 0xFFFFFFFF)
        {

            DWORD dwCodePage = GetCodePage(hdc);

        //If this is a DBCS charset but not our native one then we can not
        //compute widths and extent quickly, because gpwcDBCSCharSet[]
        //array is computed based on our NATIVE_CODEPAGE using IsDBCSLeadByte()
        //function.  We should never get here because we will be doing a check
        //higher up to make sure the codepage of the font in the DC is matches
        //the current DBCS code page

            if(guintDBCScp == dwCodePage)
            {
                pcfNew->fl = CFONT_DBCS;
            }

            ASSERTGDI(guintDBCScp == dwCodePage || !IS_ANY_DBCS_CODEPAGE(dwCodePage),
                      "pcfLocateCFONT called on non-native DBCS font\n");
        }


        pcfNew->cRef  = 1;

    // Compute the back transforms.

        pcfNew->efM11 = pDcAttr->mxWtoD.efM11;
        pcfNew->efM22 = pDcAttr->mxWtoD.efM22;

        efDivEFLOAT(pcfNew->efDtoWBaseline,ef_1,pcfNew->efM11);
        vAbsEFLOAT(pcfNew->efDtoWBaseline);

        efDivEFLOAT(pcfNew->efDtoWAscent,ef_1,pcfNew->efM22);
        vAbsEFLOAT(pcfNew->efDtoWAscent);

    // Send over a request.

        if (pch != NULL)
        {
            bRet = bFillWidthTableForGTE(hdc,pcfNew,pch,c,bAnsi);
        }
        else if (c)
        {
            bRet = bFillWidthTableForGCW(hdc,pcfNew,iFirst,c);
        }
        else
        {
            // probably just creating a cache entry for text metrics.
            // FALSE just means haven't gotten all the widths.  Note
            // that GDI_ERROR is actualy -1

            bRet = FALSE;
        }

    // Clean up failed requests.

        if (bRet == GDI_ERROR)
        {
        // we will not attempt to create cfont if this failed once in the
        // past, because the chances are it will fail again with this logfont.
        // It turns out it is costly to figure out that cfont creation is going to fail
        // so we record this by setting LF_NO_CFONT flag to avoid another attempt at
        // creating cfont.

            pDcAttr->ulDirty_ |= SLOW_WIDTHS;

            vFreeCFONTCrit(pcfNew);
            pcfNew = NULL;
        }
    }

    return(pcfNew);
}

/******************************Public*Routine******************************\
* bFillWidthTableForGCW                                                    *
*                                                                          *
* Requests ANSI character widths from the server for a call to             *
* GetCharWidthA.  iFirst and c specify the characters needed by the API    *
* call, the server must return these.  In addition, it may be prudent to   *
* fill in a whole table of 256 widths at psWidthCFONT.  We will fill in    *
* the whole table and a WIDTHDATA structure if the pointer pwd is non-NULL.*
*                                                                          *
* History:                                                                 *
*  Tue 19-Jan-1993 14:29:31 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bFillWidthTableForGCW
(
    HDC    hdc,
    CFONT *pcf,
    UINT   iFirst,
    UINT   c
)
{
    BOOL   bRet = GDI_ERROR;
    BOOL   bDBCS = pcf->fl & CFONT_DBCS;
    WCHAR *pwcBuf;
    UINT   c1,c2;
    WIDTHDATA *pwd;

    if(iFirst > 256)
    {
    // this is possible for DBCS fonts, just get all the widths
        iFirst = 0;
        c = 256;
    }



    if (pcf->fl & CFONT_CACHED_WIDTHS)
    {
    // Not the first time.  Just get the important widths.

        c1  = c;
        c2  = 0;
        pwd = NULL;
    }
    else
    {
    // Get the whole table, but put the important widths at the start.

        c2  = iFirst;
        c1  = 256 - c2; // only c of those are "important"
        pwd = &pcf->wd;
    }

    pwcBuf = (WCHAR *)LocalAlloc(LMEM_FIXED,
                        (c1+c2) * (sizeof(WCHAR)+sizeof(USHORT)));

    if (pwcBuf)
    {
        USHORT *psWidths = pwcBuf + c1+c2;

        RtlCopyMemory(pwcBuf,
                      (bDBCS) ? (PBYTE)  &gpwcDBCSCharSet[iFirst] :
                                (PBYTE)  &gpwcANSICharSet[iFirst],
                      c1*sizeof(WCHAR));

        if (c2)
        {
            RtlCopyMemory(&pwcBuf[c1],
                          (bDBCS) ? (PBYTE) &gpwcDBCSCharSet[0] :
                                    (PBYTE) &gpwcANSICharSet[0],
                          c2*sizeof(WCHAR));
        }

        LEAVECRITICALSECTION(&semLocal);

        bRet = NtGdiGetWidthTable( hdc,       // The DC
                                   c,         // Number of special characters
                                   pwcBuf,    // Unicode characters requested
                                   c1+c2,     // Number of non-special chars
                                   psWidths,  // Buffer to get widths returned
                                   pwd,       // Width data
                                   &pcf->flInfo); // Font info flags

        ENTERCRITICALSECTION(&semLocal);

        if (bRet != GDI_ERROR)
        {
            if (!(pcf->fl & CFONT_CACHED_WIDTHS))
            {
                // mark this cfont as having some widths

                pcf->fl |= CFONT_CACHED_WIDTHS;

                // Precompute the height.

                pcf->lHeight = lCvt(pcf->efDtoWAscent,(LONG) pcf->wd.sHeight);
            }

            if (bRet && ((c1+c2) >= 256))
                pcf->fl |= CFONT_COMPLETE;

            // Copy the widths into the CFONT table.

            RtlCopyMemory(
                &pcf->sWidth[iFirst], psWidths, c1 * sizeof(USHORT));

            if (c2)
            {
                RtlCopyMemory (
                    pcf->sWidth, &psWidths[c1], c2 * sizeof(USHORT));
            }
        }

        LocalFree(pwcBuf);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* bFillWidthTableForGTE
*
* Requests ANSI character widths from the server for a call to
* GetTextExtentA.  pch specifies the string from the API call.  The
* server must return widths for these characters.  In addition, it may be
* prudent to fill in a whole table of 256 widths at psWidthCFONT.  We will
* fill in the whole table and a WIDTHDATA structure if the pointer pwd is
* non-NULL.
*
* History:
*  Tue 13-Jun-1995 14:29:31 -by- Gerrit van Wingerden [gerritv]
* Converted for kernel mode.
*  Tue 19-Jan-1993 14:29:31 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

BOOL bFillWidthTableForGTE
(
    HDC    hdc,
    CFONT *pcf,
    PVOID  pch,
    UINT   c,
    BOOL   bAnsi
)
{
    BOOL bRet = GDI_ERROR;
    BOOL   bDBCS = pcf->fl & CFONT_DBCS;
    UINT ii;
    UINT c1;
    WCHAR *pwcBuf;
    WCHAR *pwcXlat = (bDBCS) ? gpwcDBCSCharSet : gpwcANSICharSet;

    WIDTHDATA *pwd;

    if (pcf->fl & CFONT_CACHED_WIDTHS)
    {
        c1  = c;
        pwd = NULL;
    }
    else
    {
        c1  = c+256;
        pwd = &pcf->wd;
    }

    pwcBuf = LocalAlloc(LMEM_FIXED,c1*(sizeof(WCHAR)+sizeof(USHORT)));

    if( pwcBuf )
    {
        WCHAR     *pwc = pwcBuf;
        USHORT    *psWidths = pwcBuf + c1;

        if(bAnsi)
        {
            for( ii = 0; ii < c; ii++ )
            {
                *pwc++ = pwcXlat[((BYTE *)pch)[ii]];
            }
        }
        else
        {
            RtlCopyMemory((PBYTE)pwc, (PBYTE) pch, c * sizeof(WCHAR));
            pwc += c;
        }

        if (pwd != (WIDTHDATA *) NULL)
        {
            // Request the whole table, too.

            RtlCopyMemory((PBYTE)pwc,
                          (bDBCS) ? (PBYTE) &gpwcDBCSCharSet[0] :
                                    (PBYTE) &gpwcANSICharSet[0],
                          256*sizeof(WCHAR));
        }

        LEAVECRITICALSECTION(&semLocal);

        bRet = NtGdiGetWidthTable( hdc,          // the DC
                                   c,            // number of special characters
                                   pwcBuf,       // the requested chars in Unicode
                                   c1,           // total number of characters
                                   psWidths,     // the actual width
                                   pwd,          // useful width data
                                   &pcf->flInfo);// font info flags

        ENTERCRITICALSECTION(&semLocal);

        if (bRet != GDI_ERROR)
        {
            if (!(pcf->fl & CFONT_CACHED_WIDTHS))
            {
                // mark this cfont as having some widths

                pcf->fl |= CFONT_CACHED_WIDTHS;

                // Precompute the height.

                pcf->lHeight = lCvt(pcf->efDtoWAscent,(LONG) pcf->wd.sHeight);

				if (bRet) // bFillWidthTableForGTE() tries to get width for all 0x00 to 0xff only at the first time
                	pcf->fl |= CFONT_COMPLETE;
            }

            if( pwd != (WIDTHDATA *) NULL )
                RtlCopyMemory( pcf->sWidth,&psWidths[c],256 * sizeof(USHORT));

            // Write the hard widths into the table too.
            if (bAnsi)
            {
                for (ii=0; ii<c; ii++)
                    pcf->sWidth[((BYTE *)pch)[ii]] = psWidths[ii];
            }
            else
            {
                for (ii=0; ii<c; ii++)
                    pcf->sWidth[((WCHAR *)pch)[ii]] = psWidths[ii];
            }
        }

        LocalFree( pwcBuf );
    }

    return(bRet);
}

/***************************************************************************\
* GetCharDimensions
*
* This function loads the Textmetrics of the font currently selected into
* the hDC and returns the Average char width of the font; Pl Note that the
* AveCharWidth value returned by the Text metrics call is wrong for
* proportional fonts.  So, we compute them On return, lpTextMetrics contains
* the text metrics of the currently selected font.
*
* Legacy code imported from USER.
*
* History:
* 10-Nov-1993 mikeke   Created
\***************************************************************************/

int GdiGetCharDimensions(
    HDC hdc,
    TEXTMETRICW *lptm,
    LPINT lpcy)
{
    TEXTMETRICW tm;
    PLDC        pldc;
    PDC_ATTR    pDcAttr;
    CFONT      *pcf;
    int         iAve;

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (!pDcAttr)
    {
        WARNING("GdiGetCharDimensions: invalid DC");
        return(0);
    }

    // find the local font or create one

    if (lptm == NULL)
        lptm = &tm;

    // now find the metrics

    ENTERCRITICALSECTION(&semLocal);

    pcf = pcfLocateCFONT(hdc,pDcAttr,0,(PVOID)NULL,0, TRUE);

    if (!bGetTextMetricsWInternal(hdc, (TMW_INTERNAL *)lptm,sizeof(*lptm), pcf))
    {
        LEAVECRITICALSECTION(&semLocal);
        return(0);
    }

    LEAVECRITICALSECTION(&semLocal);

    if (lpcy != NULL)
        *lpcy = lptm->tmHeight;

    // If fixed width font

    if (lptm->tmPitchAndFamily & TMPF_FIXED_PITCH)
    {
        if (pcf && (pcf->fl & CFONT_CACHED_AVE))
        {
            iAve = (int)pcf->ulAveWidth;
        }
        else
        {
            SIZE size;

            static WCHAR wszAvgChars[] =
                    L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

            // Change from tmAveCharWidth.  We will calculate a true average
            // as opposed to the one returned by tmAveCharWidth.  This works
            // better when dealing with proportional spaced fonts.
            // legacy from USER so can't change this.

            if(!GetTextExtentPointW(hdc, wszAvgChars,
                                    (sizeof(wszAvgChars) / sizeof(WCHAR)) - 1,
                                    &size))
            {
                WARNING("GetCharDimension: GetTextExtentPointW failed\n");
                return(0);
            }

            ASSERTGDI(size.cx,
                      "GetCharDimension: GetTextExtentPointW return 0 width string\n");

            iAve = ((size.cx / 26) + 1) / 2; // round up

            // if we have a pcf, let's cache it

            if (pcf)
            {
                // if it is a public font, we need to go to the kernel because
                // the pcf is read only here.

                if (pcf->fl & CFONT_PUBLIC)
                {
                    NtGdiSetupPublicCFONT(NULL,(HFONT)pcf->hf,(ULONG)iAve);
                }
                else
                {
                    pcf->ulAveWidth = (ULONG)iAve;
                    pcf->fl |= CFONT_CACHED_AVE;
                }
            }
        }
    }
    else
    {

        iAve = lptm->tmAveCharWidth;
    }

    // pcfLocateCFONT added a reference so now we need to remove it

    if (pcf)
    {
        DEC_CFONT_REF(pcf);
    }

    return(iAve);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\csxobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: csxobj.cxx                                                  *
*                                                                          *
* CSXform object non-inline methods.                                       *
*                                                                          *
* Created: 12-Nov-1990 16:54:37                                            *
* Author: Wendy Wu [wendywu]                                               *
*                                                                          *
* Copyright (c) 1990-1999 Microsoft Corporation                            *
\**************************************************************************/

#define NO_STRICT

#if !defined(_GDIPLUS_)
    #define INITGUID    // Declare any GUIDs
#endif

extern "C" {

#if defined(_GDIPLUS_)
#include <gpprefix.h>
#endif

#include <string.h>
#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <windows.h>    // GDI function declarations.
#include <winspool.h>
#include "nlsconv.h"    // UNICODE helpers
#include "firewall.h"
#define __CPLUSPLUS
#include <winspool.h>
#include <w32gdip.h>
#include "ntgdistr.h"
#include "winddi.h"
#include "hmgshare.h"
#include "icm.h"
#include "local.h"      // Local object support.
#include "gdiicm.h"
#include "metadef.h"    // Metafile record type constants.
#include "metarec.h"
#include "mf16.h"
#include "ntgdi.h"
#include "glsup.h"
}

#include "xfflags.h"
#include "csxobj.hxx"

#if defined(_AMD64_) || defined(_IA64_) || defined(BUILD_WOW6432)
#define vSetTo1Over16(ef)   (ef.e = EFLOAT_1Over16)
#else
#define vSetTo1Over16(ef)   (ef.i.lMant = 0x040000000, ef.i.lExp = -2)
#endif

#ifndef _BASETSD_H_
typedef size_t SIZE_T;
#endif

extern "C" {
BOOL bCvtPts1(PMATRIX pmx, PPOINTL pptl, SIZE_T cPts);
BOOL bCvtPts(PMATRIX pmx, PPOINTL pSrc, PPOINTL pDest, SIZE_T cPts);
};


#define bIsIdentity(fl) ((fl & (XFORM_UNITY | XFORM_NO_TRANSLATION)) == \
                               (XFORM_UNITY | XFORM_NO_TRANSLATION))


/******************************Public*Routine******************************\
* DPtoLP()
*
* History:
*
*  12-Mar-1996 -by- Mark Enstrom [marke]
*   Use cached dc transform data
*  01-Dec-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY DPtoLP(HDC hdc, LPPOINT pptl, int c)
{
    PDC_ATTR pdcattr;
    PVOID    pvuser;
    BOOL     bRet = TRUE;

    if (c > 0)
    {
        PSHARED_GET_VALIDATE(pvuser,hdc,DC_TYPE);

        pdcattr = (PDC_ATTR)pvuser;

        if (pdcattr)
        {
            if (
                 pdcattr->flXform &
                 (
                   PAGE_XLATE_CHANGED   |
                   PAGE_EXTENTS_CHANGED |
                   WORLD_XFORM_CHANGED  |
                   DEVICE_TO_WORLD_INVALID
                 )
               )
            {
                bRet = NtGdiTransformPoints(hdc,pptl,pptl,c,XFP_DPTOLP);
            }
            else
            {
                //
                // xform is valid, transform in user mode
                //

                PMATRIX pmx = (PMATRIX)&(pdcattr->mxDtoW);

                if (!bIsIdentity(pmx->flAccel))
                {
                    if (!bCvtPts1(pmx, (PPOINTL)pptl, c))
                    {
                        GdiSetLastError(ERROR_ARITHMETIC_OVERFLOW);
                        bRet = FALSE;
                    }
                }
            }
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            bRet = FALSE;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* LPtoDP()
*
* History:
*  12-Mar-1996 -by- Mark Enstrom [marke]
*   Use cached dc transform data
*  01-Dec-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY LPtoDP(HDC hdc, LPPOINT pptl, int c)
{
    PDC_ATTR pdcattr;
    PVOID    pvuser;
    BOOL     bRet = TRUE;

    if (c > 0)
    {
        PSHARED_GET_VALIDATE(pvuser,hdc,DC_TYPE);

        pdcattr = (PDC_ATTR)pvuser;

        if (pdcattr)
        {
            if (pdcattr->flXform & (PAGE_XLATE_CHANGED | PAGE_EXTENTS_CHANGED |
                            WORLD_XFORM_CHANGED))
            {
                //
                // transform needs to be updated, call kernel
                //

                bRet = NtGdiTransformPoints(hdc,pptl,pptl,c,XFP_LPTODP);
            }
            else
            {
                //
                // transform is valid, transform points locally
                //

                PMATRIX pmx = (PMATRIX)&(pdcattr->mxWtoD);

                if (!bIsIdentity(pmx->flAccel))
                {

                    #if DBG_XFORM
                        DbgPrint("LPtoDP: NOT IDENTITY, hdc = %p, flAccel = %lx\n", hdc, pmx->flAccel);
                    #endif

                    if (!bCvtPts1(pmx, (PPOINTL)pptl, c))
                    {
                        GdiSetLastError(ERROR_ARITHMETIC_OVERFLOW);
                        bRet = FALSE;
                    }
                }
            }
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            bRet = FALSE;
        }
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\d3d.c ===
/******************************Module*Header*******************************\
* Module Name: d3d.c
*
* Client side stubs for the private Direct3D system APIs.
*
* Created: 31-May-1996
* Author: Drew Bliss [drewb]
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#undef _NO_COM
#define BUILD_DDDDK
#include <ddrawi.h>
#include "ddstub.h"
#include "d3dstub.h"

// Go from a public DirectDraw surface to a surface handle
#define DDS_HANDLE(lpDDSLcl) \
    ((HANDLE)(lpDDSLcl->hDDSurface))

// Go from a public DirectDraw surface to a surface handle, handling the
// NULL case
#define DDS_HANDLE_OR_NULL(pdds) \
    ((pdds) != NULL ? DDS_HANDLE(pdds) : NULL)

/******************************Public*Routine******************************\
*
* D3dContextCreate
*
* History:
*  Mon Jun 03 14:18:29 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DWORD WINAPI D3dContextCreate(LPD3DHAL_CONTEXTCREATEDATA pdccd)
{
    ASSERTGDI(FIELD_OFFSET(D3DNTHAL_CONTEXTCREATEI, pvBuffer) ==
              sizeof(D3DHAL_CONTEXTCREATEDATA),
              "D3DNTHAL_CONTEXTCREATEI out of sync\n");

    return NtGdiD3dContextCreate(DD_HANDLE(pdccd->lpDDLcl->hDD),
                                 DDS_HANDLE(pdccd->lpDDSLcl),
                                 DDS_HANDLE_OR_NULL(pdccd->lpDDSZLcl),
                                 (D3DNTHAL_CONTEXTCREATEI *)pdccd);
}


/******************************Public*Routine******************************\
*
* D3dDrawPrimitives2
*
* History:
*  Mon Jun 17 13:27:05 1996	-by-	Anantha Kancherla [anankan]
*   Created
*
\**************************************************************************/

DWORD WINAPI D3dDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA pdp2data)
{
    if (pdp2data->dwFlags & D3DHALDP2_USERMEMVERTICES)
    {
        return NtGdiD3dDrawPrimitives2 (
            (HANDLE)pdp2data->lpDDCommands->hDDSurface,
            NULL, // No DDraw surface, pass NULL handle
            (LPD3DNTHAL_DRAWPRIMITIVES2DATA)pdp2data,
            &pdp2data->lpDDCommands->lpGbl->fpVidMem,
            &pdp2data->lpDDCommands->lpGbl->dwLinearSize,
            NULL,
            NULL
            );
    }
    else
    {
        return NtGdiD3dDrawPrimitives2 (
            (HANDLE)pdp2data->lpDDCommands->hDDSurface,
            (HANDLE)pdp2data->lpDDVertex->hDDSurface,
            (LPD3DNTHAL_DRAWPRIMITIVES2DATA)pdp2data,
            &pdp2data->lpDDCommands->lpGbl->fpVidMem,
            &pdp2data->lpDDCommands->lpGbl->dwLinearSize,
            &pdp2data->lpDDVertex->lpGbl->fpVidMem,
            &pdp2data->lpDDVertex->lpGbl->dwLinearSize
            );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\d3dstub.h ===
/******************************Module*Header*******************************\
* Module Name: d3dstub.h
*
* Information shared between DirectDraw and Direct3D stubs
*
* Created: 04-June-1996
* Author: Drew Bliss [drewb]
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

#ifndef __D3DSTUB_H__
#define __D3DSTUB_H__

DWORD WINAPI D3dContextCreate(LPD3DHAL_CONTEXTCREATEDATA);
DWORD WINAPI D3dRenderState(LPD3DHAL_RENDERSTATEDATA);
DWORD WINAPI D3dRenderPrimitive(LPD3DHAL_RENDERPRIMITIVEDATA);
DWORD WINAPI D3dTextureCreate(LPD3DHAL_TEXTURECREATEDATA);
DWORD WINAPI D3dTextureGetSurf(LPD3DHAL_TEXTUREGETSURFDATA);
DWORD WINAPI D3dSetRenderTarget(LPD3DHAL_SETRENDERTARGETDATA);
DWORD WINAPI D3dDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA);

#endif // __D3DSTUB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\ddraw.c ===
/******************************Module*Header*******************************\
* Module Name: ddraw.c
*
* Client side stubs for the private DirectDraw system APIs.
*
* Created: 3-Dec-1995
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <ddrawi.h>
#include <ddrawgdi.h>
#undef _NO_COM
#define BUILD_DDDDK
#include <d3dhal.h>
#include <ddrawi.h>
#include "ddstub.h"
#include "d3dstub.h"


// For the first incarnation of DirectDraw on Windows NT, we are
// implementing a user-mode shared memory section between all instances
// of DirectDraw to keep track of shared state -- mostly for off-screen
// memory allocation and exclusive mode arbitration.  Hopefully future
// versions will move all this logic to kernel mode so that we can get
// rid of the shared section, which is a robustness hole.
//
// One of the ramifications of this is that DirectDraw keeps its
// global DirectDraw object in the shared memory section, where it is
// used by all processes.  Unfortunately, it is preferrable from a kernel
// point of view to keep the DirectDraw objects unique between processes
// so that proper cleanup can be done.  As a compromise, so that
// DirectDraw can keep using this global DirectDraw object, but that the
// kernel still has unique DirectDraw objects per process, we simply stash
// the unique per-process DirectDraw handle in a variable global to this
// process, and use that instead of anything pulled out of DirectDraw's
// own global DirectDraw object structure -- an advantage since the kernel
// code is already written to the future model.
//
// One result of this, however, is that we are limiting ourselves to the
// notion of only one DirectDraw device.  However, since we will not
// support multiple monitors for the NT 4.0 release, I don't consider this
// to be a serious problem, and the non-shared-section model will fix this.

HANDLE ghDirectDraw = 0;    // Process-specific kernel-mode DirectDraw object
                            //   handle that we substitute for the 'global'
                            //   DirectDraw handle whenever we see it
ULONG  gcDirectDraw = 0;    // Count of global DirectDraw instances

/*****************************Private*Routine******************************\
* CanCreateVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
DvpCanCreateVideoPort(
    LPDDHAL_CANCREATEVPORTDATA pCanCreateVideoPort
    )
{
    return(NtGdiDvpCanCreateVideoPort(DD_HANDLE(pCanCreateVideoPort->lpDD->lpGbl->hDD),
                                      (PDD_CANCREATEVPORTDATA)pCanCreateVideoPort));
}

/*****************************Private*Routine******************************\
* CreateVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
DvpCreateVideoPort(
    LPDDHAL_CREATEVPORTDATA pCreateVideoPort
    )
{
    HANDLE  h;

    h = NtGdiDvpCreateVideoPort(DD_HANDLE(pCreateVideoPort->lpDD->lpGbl->hDD),
                                (PDD_CREATEVPORTDATA)pCreateVideoPort);

    pCreateVideoPort->lpVideoPort->hDDVideoPort = h;

    return(DDHAL_DRIVER_HANDLED);
}

/*****************************Private*Routine******************************\
* DestroyVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
DvpDestroyVideoPort(
    LPDDHAL_DESTROYVPORTDATA pDestroyVideoPort
    )
{
    return(NtGdiDvpDestroyVideoPort((HANDLE) pDestroyVideoPort->lpVideoPort->hDDVideoPort,
                                    (PDD_DESTROYVPORTDATA)pDestroyVideoPort));
}

/*****************************Private*Routine******************************\
* ColorControl
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
DvpColorControl(
    LPDDHAL_VPORTCOLORDATA pColorControl
    )
{
    return(NtGdiDvpColorControl((HANDLE) pColorControl->lpVideoPort->hDDVideoPort,
                                (PDD_VPORTCOLORDATA)pColorControl));
}

/*****************************Private*Routine******************************\
* FlipVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
DvpFlipVideoPort(
    LPDDHAL_FLIPVPORTDATA pFlipVideoPort
    )
{
    return(NtGdiDvpFlipVideoPort((HANDLE) pFlipVideoPort->lpVideoPort->hDDVideoPort,
                                 (HANDLE) pFlipVideoPort->lpSurfCurr->hDDSurface,
                                 (HANDLE) pFlipVideoPort->lpSurfTarg->hDDSurface,
                                 (PDD_FLIPVPORTDATA) pFlipVideoPort));
}

/*****************************Private*Routine******************************\
* GetVideoPortBandwidth
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortBandwidth(
    LPDDHAL_GETVPORTBANDWIDTHDATA pGetVPortBandwidth
    )
{
    return(NtGdiDvpGetVideoPortBandwidth((HANDLE) pGetVPortBandwidth->lpVideoPort->hDDVideoPort,
                                         (PDD_GETVPORTBANDWIDTHDATA) pGetVPortBandwidth));
}


/*****************************Private*Routine******************************\
* GetVideoPortField
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortField(
    LPDDHAL_GETVPORTFIELDDATA pGetVideoPortField
    )
{
    return(NtGdiDvpGetVideoPortField((HANDLE) pGetVideoPortField->lpVideoPort->hDDVideoPort,
                                     (PDD_GETVPORTFIELDDATA)pGetVideoPortField));
}

/*****************************Private*Routine******************************\
* GetVideoPortFlipStatus
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortFlipStatus(
    LPDDHAL_GETVPORTFLIPSTATUSDATA pGetVPortFlipStatus
    )
{
    return(NtGdiDvpGetVideoPortFlipStatus(DD_HANDLE(pGetVPortFlipStatus->lpDD->lpGbl->hDD),
                                          (PDD_GETVPORTFLIPSTATUSDATA)pGetVPortFlipStatus));
}

/*****************************Private*Routine******************************\
* GetVideoPortInputFormats
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortInputFormats(
    LPDDHAL_GETVPORTINPUTFORMATDATA pGetVPortInputFormat
    )
{
    return(NtGdiDvpGetVideoPortInputFormats((HANDLE) pGetVPortInputFormat->lpVideoPort->hDDVideoPort,
                                            (PDD_GETVPORTINPUTFORMATDATA)pGetVPortInputFormat));
}


/*****************************Private*Routine******************************\
* GetVideoPortLine
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortLine(
    LPDDHAL_GETVPORTLINEDATA pGetVideoPortLine
    )
{
    return(NtGdiDvpGetVideoPortLine((HANDLE) pGetVideoPortLine->lpVideoPort->hDDVideoPort,
                                    (PDD_GETVPORTLINEDATA)pGetVideoPortLine));
}

/*****************************Private*Routine******************************\
* GetVideoPortOutputFormats
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortOutputFormats(
    LPDDHAL_GETVPORTOUTPUTFORMATDATA pGetVPortOutputFormats
    )
{
    return(NtGdiDvpGetVideoPortOutputFormats((HANDLE) pGetVPortOutputFormats->lpVideoPort->hDDVideoPort,
                                             (PDD_GETVPORTOUTPUTFORMATDATA)pGetVPortOutputFormats));
}

/*****************************Private*Routine******************************\
* GetVideoPortConnectInfo
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortConnectInfo(
    LPDDHAL_GETVPORTCONNECTDATA pGetVPortConnectInfo
    )
{
    return(NtGdiDvpGetVideoPortConnectInfo(DD_HANDLE(pGetVPortConnectInfo->lpDD->lpGbl->hDD),
                                           (PDD_GETVPORTCONNECTDATA)pGetVPortConnectInfo));
}

/*****************************Private*Routine******************************\
* GetVideoSignalStatus
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoSignalStatus(
    LPDDHAL_GETVPORTSIGNALDATA pGetVideoSignalStatus
    )
{
    return(NtGdiDvpGetVideoSignalStatus((HANDLE) pGetVideoSignalStatus->lpVideoPort->hDDVideoPort,
                                        (PDD_GETVPORTSIGNALDATA)pGetVideoSignalStatus));
}

/*****************************Private*Routine******************************\
* UpdateVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpUpdateVideoPort(
    LPDDHAL_UPDATEVPORTDATA pUpdateVideoPort
    )
{
    HANDLE  ahSurfaceVideo[MAX_AUTOFLIP_BUFFERS];
    HANDLE  ahSurfaceVbi[MAX_AUTOFLIP_BUFFERS];
    DWORD   dwNumAutoflip;
    DWORD   dwNumVBIAutoflip;
    ULONG   i;

    if (pUpdateVideoPort->dwFlags != DDRAWI_VPORTSTOP)
    {
        dwNumAutoflip = pUpdateVideoPort->dwNumAutoflip;
        if ((dwNumAutoflip == 0) &&
            (pUpdateVideoPort->lplpDDSurface != NULL))
        {
            dwNumAutoflip = 1;
        }
        for (i = 0; i < dwNumAutoflip; i++)
        {
            ahSurfaceVideo[i] = (HANDLE)(pUpdateVideoPort->lplpDDSurface[i]->
                                            lpLcl->hDDSurface);
        }

        dwNumVBIAutoflip = pUpdateVideoPort->dwNumVBIAutoflip;
        if ((dwNumVBIAutoflip == 0) &&
            (pUpdateVideoPort->lplpDDVBISurface != NULL))
        {
            dwNumVBIAutoflip = 1;
        }
        for (i = 0; i < dwNumVBIAutoflip; i++)
        {
            ahSurfaceVbi[i] = (HANDLE)(pUpdateVideoPort->lplpDDVBISurface[i]->
                                            lpLcl->hDDSurface);
        }
    }

    return(NtGdiDvpUpdateVideoPort((HANDLE) pUpdateVideoPort->lpVideoPort->hDDVideoPort,
                                   ahSurfaceVideo,
                                   ahSurfaceVbi,
                                   (PDD_UPDATEVPORTDATA) pUpdateVideoPort));
}

/*****************************Private*Routine******************************\
* WaitForVideoPortSync
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpWaitForVideoPortSync(
    LPDDHAL_WAITFORVPORTSYNCDATA pWaitForVideoPortSync
    )
{
    return(NtGdiDvpWaitForVideoPortSync((HANDLE) pWaitForVideoPortSync->lpVideoPort->hDDVideoPort,
                                        (PDD_WAITFORVPORTSYNCDATA)pWaitForVideoPortSync));
}

/*****************************Private*Routine******************************\
* AcquireNotification
*
* History:
*  9-Oct-2000 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpAcquireNotification(
    LPDDRAWI_DDVIDEOPORT_LCL pVideoPort,
    HANDLE * pHandle,
    LPDDVIDEOPORTNOTIFY pNotify)
{
    return(NtGdiDvpAcquireNotification((HANDLE) pVideoPort->hDDVideoPort,
                                        pHandle,
                                        pNotify));
}

/*****************************Private*Routine******************************\
* ReleaseNotification
*
* History:
*  9-Oct-2000 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpReleaseNotification(
    LPDDRAWI_DDVIDEOPORT_LCL pVideoPort,
    HANDLE Handle)
{
    return(NtGdiDvpReleaseNotification((HANDLE) pVideoPort->hDDVideoPort,
                                        Handle));
}

/*****************************Private*Routine******************************\
* GetMoCompGuids
*
* History:
*  18-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DdGetMoCompGuids(
    LPDDHAL_GETMOCOMPGUIDSDATA pGetMoCompGuids
    )
{
    return(NtGdiDdGetMoCompGuids(DD_HANDLE(pGetMoCompGuids->lpDD->lpGbl->hDD),
                                 (PDD_GETMOCOMPGUIDSDATA)pGetMoCompGuids));
}

/*****************************Private*Routine******************************\
* GetMoCompFormats
*
* History:
*  18-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DdGetMoCompFormats(
    LPDDHAL_GETMOCOMPFORMATSDATA pGetMoCompFormats
    )
{
    return(NtGdiDdGetMoCompFormats(DD_HANDLE(pGetMoCompFormats->lpDD->lpGbl->hDD),
                                   (PDD_GETMOCOMPFORMATSDATA)pGetMoCompFormats));
}

/*****************************Private*Routine******************************\
* GetMoCompBuffInfo
*
* History:
*  18-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DdGetMoCompBuffInfo(
    LPDDHAL_GETMOCOMPCOMPBUFFDATA pGetBuffData
    )
{
    return(NtGdiDdGetMoCompBuffInfo(DD_HANDLE(pGetBuffData->lpDD->lpGbl->hDD),
                                   (PDD_GETMOCOMPCOMPBUFFDATA)pGetBuffData));
}

/*****************************Private*Routine******************************\
* GetInternalMoCompInfo
*
* History:
*  18-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DdGetInternalMoCompInfo(
    LPDDHAL_GETINTERNALMOCOMPDATA pGetInternalData
    )
{
    return(NtGdiDdGetInternalMoCompInfo(DD_HANDLE(pGetInternalData->lpDD->lpGbl->hDD),
                                   (PDD_GETINTERNALMOCOMPDATA)pGetInternalData));
}

/*****************************Private*Routine******************************\
* CreateMoComp
*
* History:
*  18-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DdCreateMoComp(
    LPDDHAL_CREATEMOCOMPDATA pCreateMoComp
    )
{
    HANDLE  h;

    h = NtGdiDdCreateMoComp(DD_HANDLE(pCreateMoComp->lpDD->lpGbl->hDD),
                               (PDD_CREATEMOCOMPDATA)pCreateMoComp);

    pCreateMoComp->lpMoComp->hMoComp = h;

    return(DDHAL_DRIVER_HANDLED);

}

/*****************************Private*Routine******************************\
* DestroyMoComp
*
* History:
*  18-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DdDestroyMoComp(
    LPDDHAL_DESTROYMOCOMPDATA pDestroyMoComp
    )
{
    return(NtGdiDdDestroyMoComp((HANDLE)pDestroyMoComp->lpMoComp->hMoComp,
                                (PDD_DESTROYMOCOMPDATA)pDestroyMoComp));
}

/*****************************Private*Routine******************************\
* BeginMoCompFrame
*
* History:
*  18-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DdBeginMoCompFrame(
    LPDDHAL_BEGINMOCOMPFRAMEDATA pBeginFrame
    )
{
    LPDDRAWI_DDRAWSURFACE_LCL *lpOriginal=NULL;
    LPDDRAWI_DDRAWSURFACE_LCL lpOrigDest=NULL;
    DWORD i;
    DWORD dwRet;

    if( pBeginFrame->lpDestSurface != NULL )
    {
        lpOrigDest = pBeginFrame->lpDestSurface;
        pBeginFrame->lpDestSurface = (LPDDRAWI_DDRAWSURFACE_LCL)
            pBeginFrame->lpDestSurface->hDDSurface;
    }

    dwRet = NtGdiDdBeginMoCompFrame((HANDLE)pBeginFrame->lpMoComp->hMoComp,
                                   (PDD_BEGINMOCOMPFRAMEDATA)pBeginFrame);

    if( lpOrigDest )
    {
        pBeginFrame->lpDestSurface = lpOrigDest;
    }

    return dwRet;
}

/*****************************Private*Routine******************************\
* EndMoCompFrame
*
* History:
*  18-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DdEndMoCompFrame(
    LPDDHAL_ENDMOCOMPFRAMEDATA pEndFrame
    )
{
    return(NtGdiDdEndMoCompFrame((HANDLE)pEndFrame->lpMoComp->hMoComp,
                                 (PDD_ENDMOCOMPFRAMEDATA)pEndFrame));
}

/*****************************Private*Routine******************************\
* RenderMoComp
*
* History:
*  18-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DdRenderMoComp(
    LPDDHAL_RENDERMOCOMPDATA pRender
    )
{
    DWORD i;
    DWORD dwRet;

    for( i = 0; i < pRender->dwNumBuffers; i++ )
    {
        pRender->lpBufferInfo[i].lpPrivate =
            pRender->lpBufferInfo[i].lpCompSurface;
        pRender->lpBufferInfo[i].lpCompSurface = (LPDDRAWI_DDRAWSURFACE_LCL)
            pRender->lpBufferInfo[i].lpCompSurface->hDDSurface;
    }

    dwRet = NtGdiDdRenderMoComp((HANDLE)pRender->lpMoComp->hMoComp,
                                (PDD_RENDERMOCOMPDATA)pRender);

    for( i = 0; i < pRender->dwNumBuffers; i++ )
    {
        pRender->lpBufferInfo[i].lpCompSurface = (LPDDRAWI_DDRAWSURFACE_LCL)
            pRender->lpBufferInfo[i].lpPrivate;
    }
    return dwRet;
}

/*****************************Private*Routine******************************\
* QueryMoCompStatus
*
* History:
*  18-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DdQueryMoCompStatus(
    LPDDHAL_QUERYMOCOMPSTATUSDATA pQueryStatus
    )
{
    DWORD dwRet;
    LPDDRAWI_DDRAWSURFACE_LCL surf_lcl;

    surf_lcl = pQueryStatus->lpSurface;
    pQueryStatus->lpSurface = (LPDDRAWI_DDRAWSURFACE_LCL) surf_lcl->hDDSurface;
    dwRet = NtGdiDdQueryMoCompStatus((HANDLE)pQueryStatus->lpMoComp->hMoComp,
                                (PDD_QUERYMOCOMPSTATUSDATA)pQueryStatus);
    pQueryStatus->lpSurface = surf_lcl;

    return dwRet;
}

/*****************************Private*Routine******************************\
* DdAlphaBlt
*
* History:
*  24-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
DdAlphaBlt(
    LPDDHAL_BLTDATA pBlt
    )
{
    HANDLE hSurfaceSrc = (pBlt->lpDDSrcSurface != NULL)
                       ? (HANDLE) pBlt->lpDDSrcSurface->hDDSurface : 0;

    return(NtGdiDdAlphaBlt((HANDLE) pBlt->lpDDDestSurface->hDDSurface,
                      hSurfaceSrc,
                      (PDD_BLTDATA) pBlt));
}

/*****************************Private*Routine******************************\
* DdBlt
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
DdBlt(
    LPDDHAL_BLTDATA pBlt
    )
{
    HANDLE hSurfaceSrc = (pBlt->lpDDSrcSurface != NULL)
                       ? (HANDLE) pBlt->lpDDSrcSurface->hDDSurface : 0;

    return(NtGdiDdBlt((HANDLE) pBlt->lpDDDestSurface->hDDSurface,
                      hSurfaceSrc,
                      (PDD_BLTDATA) pBlt));
}

/*****************************Private*Routine******************************\
* DdFlip
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdFlip(
    LPDDHAL_FLIPDATA pFlip
    )
{
    HANDLE hSurfTargLeft=NULL;
    HANDLE hSurfCurrLeft=NULL;
    if (pFlip->dwFlags & DDFLIP_STEREO)
    { if (pFlip->lpSurfTargLeft!=NULL && pFlip->lpSurfCurrLeft!=NULL)
      { 
         hSurfTargLeft=(HANDLE)pFlip->lpSurfTargLeft->hDDSurface;
         hSurfCurrLeft=(HANDLE)pFlip->lpSurfCurrLeft->hDDSurface;
      }
    } 
    return(NtGdiDdFlip((HANDLE) pFlip->lpSurfCurr->hDDSurface,
                       (HANDLE) pFlip->lpSurfTarg->hDDSurface,
                       hSurfCurrLeft,
                       hSurfTargLeft,
                       (PDD_FLIPDATA) pFlip));
}

/*****************************Private*Routine******************************\
* DdLock
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdLock(
    LPDDHAL_LOCKDATA pLock
    )
{
    return(NtGdiDdLock((HANDLE) pLock->lpDDSurface->hDDSurface,
                       (PDD_LOCKDATA) pLock,
                       NULL));
}

/*****************************Private*Routine******************************\
* DdUnlock
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdUnlock(
    LPDDHAL_UNLOCKDATA pUnlock
    )
{
    return(NtGdiDdUnlock((HANDLE) pUnlock->lpDDSurface->hDDSurface,
                         (PDD_UNLOCKDATA) pUnlock));
}

/*****************************Private*Routine******************************\
* DdLockD3D
*
* History:
*  20-Jan-1998 -by- Anantha Kancherla [anankan]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdLockD3D(
    LPDDHAL_LOCKDATA pLock
    )
{
    return(NtGdiDdLockD3D((HANDLE) pLock->lpDDSurface->hDDSurface,
                       (PDD_LOCKDATA) pLock));
}

/*****************************Private*Routine******************************\
* DdUnlockD3D
*
* History:
*  20-Jan-1998 -by- Anantha Kancherla [anankan]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdUnlockD3D(
    LPDDHAL_UNLOCKDATA pUnlock
    )
{
    return(NtGdiDdUnlockD3D((HANDLE) pUnlock->lpDDSurface->hDDSurface,
                         (PDD_UNLOCKDATA) pUnlock));
}

/*****************************Private*Routine******************************\
* DdGetBltStatus
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdGetBltStatus(
    LPDDHAL_GETBLTSTATUSDATA pGetBltStatus
    )
{
    return(NtGdiDdGetBltStatus((HANDLE) pGetBltStatus->lpDDSurface->hDDSurface,
                               (PDD_GETBLTSTATUSDATA) pGetBltStatus));
}

/*****************************Private*Routine******************************\
* DdGetFlipStatus
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdGetFlipStatus(
    LPDDHAL_GETFLIPSTATUSDATA pGetFlipStatus
    )
{
    return(NtGdiDdGetFlipStatus((HANDLE) pGetFlipStatus->lpDDSurface->hDDSurface,
                               (PDD_GETFLIPSTATUSDATA) pGetFlipStatus));
}

/*****************************Private*Routine******************************\
* DdWaitForVerticalBlank
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdWaitForVerticalBlank(
    LPDDHAL_WAITFORVERTICALBLANKDATA pWaitForVerticalBlank
    )
{
    return(NtGdiDdWaitForVerticalBlank(DD_HANDLE(pWaitForVerticalBlank->lpDD->hDD),
                (PDD_WAITFORVERTICALBLANKDATA) pWaitForVerticalBlank));
}

/*****************************Private*Routine******************************\
* DdCanCreateSurface
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdCanCreateSurface(
    LPDDHAL_CANCREATESURFACEDATA pCanCreateSurface
    )
{
    return(NtGdiDdCanCreateSurface(DD_HANDLE(pCanCreateSurface->lpDD->hDD),
                                (PDD_CANCREATESURFACEDATA) pCanCreateSurface));
}

/*****************************Private*Routine******************************\
* DdCreateSurface
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdCreateSurface(
    LPDDHAL_CREATESURFACEDATA pCreateSurface
    )
{
    ULONG                       i;
    LPDDSURFACEDESC             pSurfaceDesc;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceLocal;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurfaceGlobal;
    DD_SURFACE_GLOBAL           SurfaceGlobal;
    DD_SURFACE_LOCAL            SurfaceLocal;
    DD_SURFACE_MORE             SurfaceMore;
    HANDLE                      hInSurface;
    HANDLE                      hOutSurface;
    DD_SURFACE_LOCAL*           pDDSurfaceLocal = NULL;
    DD_SURFACE_GLOBAL*          pDDSurfaceGlobal = NULL;
    DD_SURFACE_MORE*            pDDSurfaceMore = NULL;
    HANDLE*                     phInSurface = NULL;
    HANDLE*                     phOutSurface = NULL;
    DWORD                       dwRet;
    DWORD                       dwNumToCreate;

    // For every surface, convert to the kernel's surface data structure,
    // call the kernel, then convert back:

    // All video memory heaps are handled in the kernel so if
    // the kernel call cannot create a surface then user-mode can't
    // either.  Always returns DRIVER_HANDLED to enforce this.
    dwRet = DDHAL_DRIVER_HANDLED;

    // If we are only creating one, no need to allocate gobs of memory; otherwise, do it

    dwNumToCreate = pCreateSurface->dwSCnt;
    if (pCreateSurface->dwSCnt == 1)
    {
        pDDSurfaceLocal  = &SurfaceLocal;
        pDDSurfaceGlobal  = &SurfaceGlobal;
        pDDSurfaceMore  = &SurfaceMore;
        phInSurface = &hInSurface;
        phOutSurface = &hOutSurface;

        //
        // Wow64 genthnk will automatically thunk these structures, however,
        // since these structures are pointer dependent, we need to make sure
        // to NULL out these pointers so that Wow64 won't thunk them
        //

        RtlZeroMemory(pDDSurfaceLocal, sizeof(*pDDSurfaceLocal));
        RtlZeroMemory(pDDSurfaceGlobal, sizeof(*pDDSurfaceGlobal));
        RtlZeroMemory(pDDSurfaceMore, sizeof(*pDDSurfaceMore));
    }
    else
    {
        pDDSurfaceLocal = (DD_SURFACE_LOCAL*) LocalAlloc(LMEM_ZEROINIT,
            sizeof(DD_SURFACE_LOCAL) * dwNumToCreate);

        pDDSurfaceGlobal = (DD_SURFACE_GLOBAL*) LocalAlloc(LMEM_ZEROINIT,
            sizeof(DD_SURFACE_GLOBAL) * dwNumToCreate);

        pDDSurfaceMore = (DD_SURFACE_MORE*) LocalAlloc(LMEM_ZEROINIT,
            sizeof(DD_SURFACE_MORE) * dwNumToCreate);

        phInSurface = (HANDLE*) LocalAlloc(LMEM_ZEROINIT,
            sizeof(HANDLE) * dwNumToCreate);

        phOutSurface = (HANDLE*) LocalAlloc(LMEM_ZEROINIT,
            sizeof(HANDLE) * dwNumToCreate);

        if ((pDDSurfaceLocal == NULL) ||
            (pDDSurfaceGlobal == NULL) ||
            (pDDSurfaceMore == NULL) ||
            (phInSurface == NULL) ||
            (phOutSurface == NULL))
        {
            pCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
            goto CleanupCreate;
        }
    }

    for (i = 0; i < dwNumToCreate; i++)
    {
        pSurfaceLocal  = pCreateSurface->lplpSList[i];
        pSurfaceGlobal = pSurfaceLocal->lpGbl;
        pSurfaceDesc   = pCreateSurface->lpDDSurfaceDesc;

        // Make sure there's always a valid pixel format for the surface:

        if (pSurfaceLocal->dwFlags & DDRAWISURF_HASPIXELFORMAT)
        {
            pDDSurfaceGlobal[i].ddpfSurface        = pSurfaceGlobal->ddpfSurface;
            pDDSurfaceGlobal[i].ddpfSurface.dwSize = sizeof(DDPIXELFORMAT);
        }
        else
        {
            pDDSurfaceGlobal[i].ddpfSurface = pSurfaceGlobal->lpDD->vmiData.ddpfDisplay;
        }

        pDDSurfaceGlobal[i].wWidth       = pSurfaceGlobal->wWidth;
        pDDSurfaceGlobal[i].wHeight      = pSurfaceGlobal->wHeight;
        pDDSurfaceGlobal[i].lPitch       = pSurfaceGlobal->lPitch;
        pDDSurfaceGlobal[i].fpVidMem     = pSurfaceGlobal->fpVidMem;
        pDDSurfaceGlobal[i].dwBlockSizeX = pSurfaceGlobal->dwBlockSizeX;
        pDDSurfaceGlobal[i].dwBlockSizeY = pSurfaceGlobal->dwBlockSizeY;

        pDDSurfaceLocal[i].ddsCaps       = pSurfaceLocal->ddsCaps;
        // Copy the driver managed flag
        pDDSurfaceLocal[i].dwFlags      &= ~DDRAWISURF_DRIVERMANAGED;
        pDDSurfaceLocal[i].dwFlags      |= (pSurfaceLocal->dwFlags & DDRAWISURF_DRIVERMANAGED);

        // lpSurfMore will be NULL if called from dciman
        if (pSurfaceLocal->lpSurfMore)
        {
            pDDSurfaceMore[i].ddsCapsEx       = pSurfaceLocal->lpSurfMore->ddsCapsEx;
            pDDSurfaceMore[i].dwSurfaceHandle = pSurfaceLocal->lpSurfMore->dwSurfaceHandle;
        }
        else
        {
            pDDSurfaceMore[i].ddsCapsEx.dwCaps2 = 0;
            pDDSurfaceMore[i].ddsCapsEx.dwCaps3 = 0;
            pDDSurfaceMore[i].ddsCapsEx.dwCaps4 = 0;
            pDDSurfaceMore[i].dwSurfaceHandle   = 0;
        }

        phInSurface[i] = (HANDLE) pSurfaceLocal->hDDSurface;
    }

    // Preset an error in case the kernel can't write status
    // back for some reason.
    pCreateSurface->ddRVal     = DDERR_GENERIC;

    dwRet = NtGdiDdCreateSurface(DD_HANDLE(pCreateSurface->lpDD->hDD),
                                 phInSurface,
                                 pSurfaceDesc,
                                 pDDSurfaceGlobal,
                                 pDDSurfaceLocal,
                                 pDDSurfaceMore,
                                 (PDD_CREATESURFACEDATA) pCreateSurface,
                                 phOutSurface);

    ASSERTGDI(dwRet == DDHAL_DRIVER_HANDLED,
              "NtGdiDdCreateSurface returned NOTHANDLED");

    for (i = 0; i < dwNumToCreate; i++)
    {
        pSurfaceLocal  = pCreateSurface->lplpSList[i];
        pSurfaceGlobal = pSurfaceLocal->lpGbl;
        if (pCreateSurface->ddRVal != DD_OK)
        {
            // Surface creation failed.  Nothing in user-mode can
            // create video memory surfaces so this whole call
            // fails.

            // Ensure the current surface and all following surfaces
            // have a zero fpVidMem to indicate they weren't
            // allocated.
            pCreateSurface->lplpSList[i]->lpGbl->fpVidMem = 0;

            // Handle may have been allocated by DdAttachSurface
            if (pSurfaceLocal->hDDSurface != 0)
                NtGdiDdDeleteSurfaceObject((HANDLE)pSurfaceLocal->hDDSurface);            

            pSurfaceLocal->hDDSurface = 0;
        }
        else
        {
            pSurfaceLocal->hDDSurface = (ULONG_PTR) phOutSurface[i];
        }

        pSurfaceGlobal->lPitch       = pDDSurfaceGlobal[i].lPitch;
        pSurfaceGlobal->fpVidMem     = pDDSurfaceGlobal[i].fpVidMem;
        pSurfaceGlobal->dwBlockSizeX = pDDSurfaceGlobal[i].dwBlockSizeX;
        pSurfaceGlobal->dwBlockSizeY = pDDSurfaceGlobal[i].dwBlockSizeY;
        if (pSurfaceLocal->dwFlags & DDRAWISURF_HASPIXELFORMAT)
        {
            pSurfaceGlobal->ddpfSurface = pDDSurfaceGlobal[i].ddpfSurface;
        }

        pSurfaceLocal->ddsCaps = pDDSurfaceLocal[i].ddsCaps;

        if (pSurfaceLocal->lpSurfMore)
        {
            pSurfaceLocal->lpSurfMore->ddsCapsEx = pDDSurfaceMore[i].ddsCapsEx;
        }

    }

    CleanupCreate:
    if (dwNumToCreate > 1)
    {
        if (pDDSurfaceLocal != NULL)
        {
            LocalFree(pDDSurfaceLocal);
        }
        if (pDDSurfaceGlobal != NULL)
        {
            LocalFree(pDDSurfaceGlobal);
        }
        if (pDDSurfaceMore != NULL)
        {
            LocalFree(pDDSurfaceMore);
        }
        if (phInSurface != NULL)
        {
            LocalFree(phInSurface);
        }
        if (phOutSurface != NULL)
        {
            LocalFree(phOutSurface);
        }
    }

    // fpVidMem is the real per-surface return value, so for the function
    // return value we'll simply return that of the last call:

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DdDestroySurface
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdDestroySurface(
    LPDDHAL_DESTROYSURFACEDATA pDestroySurface
    )
{
    DWORD                       dwRet;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceLocal;

    dwRet = DDHAL_DRIVER_NOTHANDLED;
    pSurfaceLocal = pDestroySurface->lpDDSurface;

    if (pSurfaceLocal->hDDSurface != 0)
    {
        if((pSurfaceLocal->dwFlags & DDRAWISURF_DRIVERMANAGED) &&
            (pSurfaceLocal->dwFlags & DDRAWISURF_INVALID))
            dwRet = NtGdiDdDestroySurface((HANDLE) pSurfaceLocal->hDDSurface, FALSE);
        else
            dwRet = NtGdiDdDestroySurface((HANDLE) pSurfaceLocal->hDDSurface, TRUE);
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DdCanCreateD3DBuffer
*
* History:
*  20-Jan-1998 -by- Anantha Kancherla [anankan]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdCanCreateD3DBuffer(
    LPDDHAL_CANCREATESURFACEDATA pCanCreateSurface
    )
{
    return(NtGdiDdCanCreateD3DBuffer(DD_HANDLE(pCanCreateSurface->lpDD->hDD),
                                (PDD_CANCREATESURFACEDATA) pCanCreateSurface));
}

/*****************************Private*Routine******************************\
* DdCreateD3DBuffer
*
* History:
*  20-Jan-1998 -by- Anantha Kancherla [anankan]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdCreateD3DBuffer(
    LPDDHAL_CREATESURFACEDATA pCreateSurface
    )
{
    ULONG                       i;
    LPDDSURFACEDESC             pSurfaceDesc;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceLocal;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurfaceGlobal;
    DD_SURFACE_GLOBAL           SurfaceGlobal;
    DD_SURFACE_LOCAL            SurfaceLocal;
    DD_SURFACE_MORE             SurfaceMore;
    HANDLE                      hSurface;
    DWORD                       dwRet;

    // For every surface, convert to the kernel's surface data structure,
    // call the kernel, then convert back:

    dwRet = DDHAL_DRIVER_NOTHANDLED;

    //
    // Wow64 genthnk will automatically thunk these structures, however,
    // since these structures are pointer dependent, we need to make sure
    // to NULL out these pointers so that Wow64 won't thunk them
    //
    RtlZeroMemory(&SurfaceLocal, sizeof(SurfaceLocal));
    RtlZeroMemory(&SurfaceGlobal, sizeof(SurfaceGlobal));
    RtlZeroMemory(&SurfaceMore, sizeof(SurfaceMore));

    pSurfaceLocal  = pCreateSurface->lplpSList[0];
    pSurfaceGlobal = pSurfaceLocal->lpGbl;
    pSurfaceDesc   = pCreateSurface->lpDDSurfaceDesc;
    pCreateSurface->dwSCnt = 1;

    SurfaceGlobal.wWidth       = pSurfaceGlobal->wWidth;
    SurfaceGlobal.wHeight      = pSurfaceGlobal->wHeight;
    SurfaceGlobal.lPitch       = pSurfaceGlobal->lPitch;
    SurfaceGlobal.fpVidMem     = pSurfaceGlobal->fpVidMem;
    SurfaceGlobal.dwBlockSizeX = pSurfaceGlobal->dwBlockSizeX;
    SurfaceGlobal.dwBlockSizeY = pSurfaceGlobal->dwBlockSizeY;

    SurfaceLocal.dwFlags       = pSurfaceLocal->dwFlags;
    SurfaceLocal.ddsCaps       = pSurfaceLocal->ddsCaps;

    SurfaceMore.ddsCapsEx       = pSurfaceLocal->lpSurfMore->ddsCapsEx;
    SurfaceMore.dwSurfaceHandle = pSurfaceLocal->lpSurfMore->dwSurfaceHandle;

    dwRet = NtGdiDdCreateD3DBuffer(DD_HANDLE(pCreateSurface->lpDD->hDD),
                                 (HANDLE*) &pSurfaceLocal->hDDSurface,
                                 pSurfaceDesc,
                                 &SurfaceGlobal,
                                 &SurfaceLocal,
                                 &SurfaceMore,
                                 (PDD_CREATESURFACEDATA) pCreateSurface,
                                 &hSurface);

    pSurfaceGlobal->lPitch       = SurfaceGlobal.lPitch;
    pSurfaceGlobal->fpVidMem     = SurfaceGlobal.fpVidMem;
    pSurfaceGlobal->dwBlockSizeX = SurfaceGlobal.dwBlockSizeX;
    pSurfaceGlobal->dwBlockSizeY = SurfaceGlobal.dwBlockSizeY;
    if (hSurface)
    {
        pCreateSurface->lplpSList[0]->hDDSurface = (ULONG_PTR) hSurface;
    }

    // fpVidMem is the real per-surface return value, so for the function
    // return value we'll simply return that of the last call:

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DdDestroyD3DBuffer
*
* History:
*  20-Jan-1998 -by- Anantha Kancherla [anankan]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdDestroyD3DBuffer(
    LPDDHAL_DESTROYSURFACEDATA pDestroySurface
    )
{
    DWORD                       dwRet;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceLocal;

    dwRet = DDHAL_DRIVER_NOTHANDLED;
    pSurfaceLocal = pDestroySurface->lpDDSurface;

    if (pSurfaceLocal->hDDSurface != 0)
    {
        dwRet = NtGdiDdDestroyD3DBuffer((HANDLE) pSurfaceLocal->hDDSurface);
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DdSetColorKey
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdSetColorKey(
    LPDDHAL_SETCOLORKEYDATA pSetColorKey
    )
{
    return(NtGdiDdSetColorKey((HANDLE) pSetColorKey->lpDDSurface->hDDSurface,
                              (PDD_SETCOLORKEYDATA) pSetColorKey));
}

/*****************************Private*Routine******************************\
* DdAddAttachedSurface
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdAddAttachedSurface(
    LPDDHAL_ADDATTACHEDSURFACEDATA pAddAttachedSurface
    )
{
    return(NtGdiDdAddAttachedSurface((HANDLE) pAddAttachedSurface->lpDDSurface->hDDSurface,
                                     (HANDLE) pAddAttachedSurface->lpSurfAttached->hDDSurface,
                                     (PDD_ADDATTACHEDSURFACEDATA) pAddAttachedSurface));
}

/*****************************Private*Routine******************************\
* DdUpdateOverlay
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdUpdateOverlay(
    LPDDHAL_UPDATEOVERLAYDATA pUpdateOverlay
    )
{
    // Kernel doesn't track the color keys in the surface, so we'll always
    // convert any calls that reference them to ones where we explicitly
    // pass the key as a parameter, and pull the key out of the user-mode
    // surface:

    if (pUpdateOverlay->dwFlags & DDOVER_KEYDEST)
    {
        pUpdateOverlay->dwFlags &= ~DDOVER_KEYDEST;
        pUpdateOverlay->dwFlags |=  DDOVER_KEYDESTOVERRIDE;

        pUpdateOverlay->overlayFX.dckDestColorkey
            = pUpdateOverlay->lpDDDestSurface->ddckCKDestOverlay;
    }

    if (pUpdateOverlay->dwFlags & DDOVER_KEYSRC)
    {
        pUpdateOverlay->dwFlags &= ~DDOVER_KEYSRC;
        pUpdateOverlay->dwFlags |=  DDOVER_KEYSRCOVERRIDE;

        pUpdateOverlay->overlayFX.dckSrcColorkey
            = pUpdateOverlay->lpDDSrcSurface->ddckCKSrcOverlay;
    }

    return(NtGdiDdUpdateOverlay((HANDLE) pUpdateOverlay->lpDDDestSurface->hDDSurface,
                                (HANDLE) pUpdateOverlay->lpDDSrcSurface->hDDSurface,
                                (PDD_UPDATEOVERLAYDATA) pUpdateOverlay));
}

/*****************************Private*Routine******************************\
* DdSetOverlayPosition
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdSetOverlayPosition(
    LPDDHAL_SETOVERLAYPOSITIONDATA pSetOverlayPosition
    )
{
    return(NtGdiDdSetOverlayPosition((HANDLE) pSetOverlayPosition->lpDDSrcSurface->hDDSurface,
                            (HANDLE) pSetOverlayPosition->lpDDDestSurface->hDDSurface,
                            (PDD_SETOVERLAYPOSITIONDATA) pSetOverlayPosition));
}

/*****************************Private*Routine******************************\
* DdGetScanLine
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdGetScanLine(
    LPDDHAL_GETSCANLINEDATA pGetScanLine
    )
{
    return(NtGdiDdGetScanLine(DD_HANDLE(pGetScanLine->lpDD->hDD),
                              (PDD_GETSCANLINEDATA) pGetScanLine));
}

/*****************************Private*Routine******************************\
* DdSetExclusiveMode
*
* History:
*  22-Apr-1998 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdSetExclusiveMode(
    LPDDHAL_SETEXCLUSIVEMODEDATA pSetExclusiveMode
    )
{
    return(NtGdiDdSetExclusiveMode(
                DD_HANDLE(pSetExclusiveMode->lpDD->hDD),
                (PDD_SETEXCLUSIVEMODEDATA) pSetExclusiveMode));
}

/*****************************Private*Routine******************************\
* DdFlipToGDISurface
*
* History:
*  22-Apr-1998 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdFlipToGDISurface(
    LPDDHAL_FLIPTOGDISURFACEDATA pFlipToGDISurface
    )
{
    return(NtGdiDdFlipToGDISurface(
                DD_HANDLE(pFlipToGDISurface->lpDD->hDD),
                (PDD_FLIPTOGDISURFACEDATA) pFlipToGDISurface));
}

/*****************************Private*Routine******************************\
* DdGetAvailDriverMemory
*
* History:
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdGetAvailDriverMemory(
    LPDDHAL_GETAVAILDRIVERMEMORYDATA pGetAvailDriverMemory
    )
{
    return(NtGdiDdGetAvailDriverMemory(
                DD_HANDLE(pGetAvailDriverMemory->lpDD->hDD),
                (PDD_GETAVAILDRIVERMEMORYDATA) pGetAvailDriverMemory));
}

/*****************************Private*Routine******************************\
* DdColorControl
*
* History:
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdColorControl(
    LPDDHAL_COLORCONTROLDATA pColorControl
    )
{
    return(NtGdiDdColorControl((HANDLE) pColorControl->lpDDSurface->hDDSurface,
                               (PDD_COLORCONTROLDATA) pColorControl));
}

/*****************************Private*Routine******************************\
* DdCreateSurfaceEx
*
* History:
*  19-Feb-1999 -by- Kan Qiu [kanqiu]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdCreateSurfaceEx( 
    LPDDHAL_CREATESURFACEEXDATA pCreateSurfaceExData
    )
{
    pCreateSurfaceExData->ddRVal=NtGdiDdCreateSurfaceEx( 
        DD_HANDLE(pCreateSurfaceExData->lpDDLcl->lpGbl->hDD),
        (HANDLE)(pCreateSurfaceExData->lpDDSLcl->hDDSurface),
        pCreateSurfaceExData->lpDDSLcl->lpSurfMore->dwSurfaceHandle);
    return  DDHAL_DRIVER_HANDLED;  
}

/*****************************Private*Routine******************************\
* DdGetDriverInfo
*
* History:
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdGetDriverInfo(
    LPDDHAL_GETDRIVERINFODATA lpGetDriverInfoData
    )
{
    DD_GETDRIVERINFODATA    GetDriverInfoData;
    DWORD                   dwRet;
    HANDLE                  hDirectDraw;

    GetDriverInfoData.guidInfo = lpGetDriverInfoData->guidInfo;
    hDirectDraw = DD_HANDLE( (HANDLE) lpGetDriverInfoData->dwContext );

    if (IsEqualIID(&lpGetDriverInfoData->guidInfo, &GUID_VideoPortCallbacks))
    {
        DD_VIDEOPORTCALLBACKS           VideoPortCallBacks;
        LPDDHAL_DDVIDEOPORTCALLBACKS    lpVideoPortCallBacks;

        // Translate VideoPort call-backs to user-mode:

        lpVideoPortCallBacks             = lpGetDriverInfoData->lpvData;
        GetDriverInfoData.lpvData        = &VideoPortCallBacks;
        GetDriverInfoData.dwExpectedSize = sizeof(VideoPortCallBacks);

        dwRet = NtGdiDdGetDriverInfo(hDirectDraw, &GetDriverInfoData);

        RtlZeroMemory(lpVideoPortCallBacks, sizeof(*lpVideoPortCallBacks));
        lpGetDriverInfoData->dwActualSize = sizeof(*lpVideoPortCallBacks);
        lpVideoPortCallBacks->dwSize      = sizeof(*lpVideoPortCallBacks);
        lpVideoPortCallBacks->dwFlags = VideoPortCallBacks.dwFlags
                                       | DDHAL_VPORT32_CREATEVIDEOPORT
                                       | DDHAL_VPORT32_DESTROY
                                       | DDHAL_VPORT32_UPDATE
                                       | DDHAL_VPORT32_FLIP;
        lpVideoPortCallBacks->dwFlags &= ~(DDHAL_VPORT32_GETAUTOFLIPSURF);

        lpVideoPortCallBacks->CreateVideoPort = DvpCreateVideoPort;
        lpVideoPortCallBacks->DestroyVideoPort = DvpDestroyVideoPort;
        lpVideoPortCallBacks->UpdateVideoPort = DvpUpdateVideoPort;
        lpVideoPortCallBacks->FlipVideoPort = DvpFlipVideoPort;

        if (VideoPortCallBacks.CanCreateVideoPort)
        {
            lpVideoPortCallBacks->CanCreateVideoPort = DvpCanCreateVideoPort;
        }
        if (VideoPortCallBacks.GetVideoPortBandwidth)
        {
            lpVideoPortCallBacks->GetVideoPortBandwidth = DvpGetVideoPortBandwidth;
        }
        if (VideoPortCallBacks.GetVideoPortInputFormats)
        {
            lpVideoPortCallBacks->GetVideoPortInputFormats = DvpGetVideoPortInputFormats;
        }
        if (VideoPortCallBacks.GetVideoPortOutputFormats)
        {
            lpVideoPortCallBacks->GetVideoPortOutputFormats = DvpGetVideoPortOutputFormats;
        }
        if (VideoPortCallBacks.GetVideoPortField)
        {
            lpVideoPortCallBacks->GetVideoPortField = DvpGetVideoPortField;
        }
        if (VideoPortCallBacks.GetVideoPortLine)
        {
            lpVideoPortCallBacks->GetVideoPortLine = DvpGetVideoPortLine;
        }
        if (VideoPortCallBacks.GetVideoPortConnectInfo)
        {
            lpVideoPortCallBacks->GetVideoPortConnectInfo = DvpGetVideoPortConnectInfo;
        }
        if (VideoPortCallBacks.GetVideoPortFlipStatus)
        {
            lpVideoPortCallBacks->GetVideoPortFlipStatus = DvpGetVideoPortFlipStatus;
        }
        if (VideoPortCallBacks.WaitForVideoPortSync)
        {
            lpVideoPortCallBacks->WaitForVideoPortSync = DvpWaitForVideoPortSync;
        }
        if (VideoPortCallBacks.GetVideoSignalStatus)
        {
            lpVideoPortCallBacks->GetVideoSignalStatus = DvpGetVideoSignalStatus;
        }
        if (VideoPortCallBacks.ColorControl)
        {
            lpVideoPortCallBacks->ColorControl = DvpColorControl;
        }
    }
    else if (IsEqualIID(&lpGetDriverInfoData->guidInfo, &GUID_ColorControlCallbacks))
    {
        DD_COLORCONTROLCALLBACKS        ColorControlCallBacks;
        LPDDHAL_DDCOLORCONTROLCALLBACKS lpColorControlCallBacks;

        // Translate ColorControl call-backs to user-mode:

        lpColorControlCallBacks          = lpGetDriverInfoData->lpvData;
        GetDriverInfoData.lpvData        = &ColorControlCallBacks;
        GetDriverInfoData.dwExpectedSize = sizeof(ColorControlCallBacks);

        dwRet = NtGdiDdGetDriverInfo(hDirectDraw, &GetDriverInfoData);

        RtlZeroMemory(lpColorControlCallBacks, sizeof(*lpColorControlCallBacks));
        lpGetDriverInfoData->dwActualSize    = sizeof(*lpColorControlCallBacks);
        lpColorControlCallBacks->dwSize      = sizeof(*lpColorControlCallBacks);
        lpColorControlCallBacks->dwFlags = ColorControlCallBacks.dwFlags;

        if (ColorControlCallBacks.ColorControl)
        {
            lpColorControlCallBacks->ColorControl = DdColorControl;
        }
    }
    else if (IsEqualIID(&lpGetDriverInfoData->guidInfo, &GUID_MiscellaneousCallbacks))
    {
        DD_MISCELLANEOUSCALLBACKS           MiscellaneousCallBacks;
        LPDDHAL_DDMISCELLANEOUSCALLBACKS    lpMiscellaneousCallBacks;

        // Translate miscellaneous call-backs to user-mode:

        lpMiscellaneousCallBacks         = lpGetDriverInfoData->lpvData;
        GetDriverInfoData.lpvData        = &MiscellaneousCallBacks;
        GetDriverInfoData.dwExpectedSize = sizeof(MiscellaneousCallBacks);
        lpMiscellaneousCallBacks->dwFlags = 0;

        // Don't return what the driver returns because we always want this
        // to suceed

        NtGdiDdGetDriverInfo(hDirectDraw, &GetDriverInfoData);
        GetDriverInfoData.dwActualSize = sizeof(MiscellaneousCallBacks);
        GetDriverInfoData.ddRVal = DD_OK;
        dwRet = DDHAL_DRIVER_HANDLED;

        RtlZeroMemory(lpMiscellaneousCallBacks, sizeof(*lpMiscellaneousCallBacks));
        lpGetDriverInfoData->dwActualSize     = sizeof(*lpMiscellaneousCallBacks);
        lpMiscellaneousCallBacks->dwSize      = sizeof(*lpMiscellaneousCallBacks);
        lpMiscellaneousCallBacks->dwFlags = MiscellaneousCallBacks.dwFlags;

        //We always implement this callback now that kernel owns vidmem management
        lpMiscellaneousCallBacks->GetAvailDriverMemory = DdGetAvailDriverMemory;
        lpMiscellaneousCallBacks->dwFlags |= DDHAL_MISCCB32_GETAVAILDRIVERMEMORY;
    }
    else if (IsEqualIID(&lpGetDriverInfoData->guidInfo, &GUID_Miscellaneous2Callbacks))
    {
        DD_MISCELLANEOUS2CALLBACKS          Miscellaneous2CallBacks;
        LPDDHAL_DDMISCELLANEOUS2CALLBACKS   lpMiscellaneous2CallBacks;

        // Translate miscellaneous call-backs to user-mode:

        lpMiscellaneous2CallBacks        = lpGetDriverInfoData->lpvData;
        GetDriverInfoData.lpvData        = &Miscellaneous2CallBacks;
        GetDriverInfoData.dwExpectedSize = sizeof(Miscellaneous2CallBacks);

        dwRet = NtGdiDdGetDriverInfo(hDirectDraw, &GetDriverInfoData);

        RtlZeroMemory(lpMiscellaneous2CallBacks, sizeof(*lpMiscellaneous2CallBacks));
        lpGetDriverInfoData->dwActualSize     = sizeof(*lpMiscellaneous2CallBacks);
        lpMiscellaneous2CallBacks->dwSize      = sizeof(*lpMiscellaneous2CallBacks);
        lpMiscellaneous2CallBacks->dwFlags = Miscellaneous2CallBacks.dwFlags;

        if (Miscellaneous2CallBacks.AlphaBlt)
        {
            lpMiscellaneous2CallBacks->AlphaBlt = DdAlphaBlt;
        }
        if (Miscellaneous2CallBacks.GetDriverState)
        {
            lpMiscellaneous2CallBacks->GetDriverState = 
                (LPDDHAL_GETDRIVERSTATE)NtGdiDdGetDriverState;
        }
        if (Miscellaneous2CallBacks.CreateSurfaceEx)
        {
            lpMiscellaneous2CallBacks->CreateSurfaceEx = 
                (LPDDHAL_CREATESURFACEEX)DdCreateSurfaceEx;
        }
        // Dont pass back DestroyDDLocal
    }
    else if (IsEqualIID(&lpGetDriverInfoData->guidInfo, &GUID_NTCallbacks))
    {
        DD_NTCALLBACKS          NTCallBacks;
        LPDDHAL_DDNTCALLBACKS   lpNTCallBacks;

        // Translate NT call-backs to user-mode:

        lpNTCallBacks                    = lpGetDriverInfoData->lpvData;
        GetDriverInfoData.lpvData        = &NTCallBacks;
        GetDriverInfoData.dwExpectedSize = sizeof(NTCallBacks);

        dwRet = NtGdiDdGetDriverInfo(hDirectDraw, &GetDriverInfoData);

        RtlZeroMemory(lpNTCallBacks, sizeof(*lpNTCallBacks));
        lpGetDriverInfoData->dwActualSize = sizeof(*lpNTCallBacks);
        lpNTCallBacks->dwSize             = sizeof(*lpNTCallBacks);
        lpNTCallBacks->dwFlags            = NTCallBacks.dwFlags;

        // FreeDriverMemory is also an NTCallback but it will only be called
        // from kernel-mode, so we don't have a user-mode thunk function.

        if (NTCallBacks.SetExclusiveMode)
        {
            lpNTCallBacks->SetExclusiveMode = DdSetExclusiveMode;
        }

        if (NTCallBacks.FlipToGDISurface)
        {
            lpNTCallBacks->FlipToGDISurface = DdFlipToGDISurface;
        }
    }
    else if (IsEqualIID(&lpGetDriverInfoData->guidInfo, &GUID_D3DCallbacks2))
    {
        // Fill NULL for D3DCALLBACKS2.
        LPD3DHAL_CALLBACKS2 lpD3dCallbacks2;
        lpD3dCallbacks2 = lpGetDriverInfoData->lpvData;
        RtlZeroMemory(lpD3dCallbacks2, sizeof(*lpD3dCallbacks2));
        lpGetDriverInfoData->dwActualSize = sizeof(*lpD3dCallbacks2);
        lpD3dCallbacks2->dwSize = sizeof(*lpD3dCallbacks2);
        GetDriverInfoData.ddRVal = DDERR_GENERIC;
        dwRet = DDHAL_DRIVER_HANDLED;
    }
    else if (IsEqualIID(&lpGetDriverInfoData->guidInfo, &GUID_D3DCallbacks3))
    {
        D3DNTHAL_CALLBACKS3 D3dCallbacks3;
        LPD3DHAL_CALLBACKS3 lpD3dCallbacks3;

        // Translate D3DNTHAL_CALLBACKS3 to user-mode.

        lpD3dCallbacks3 = lpGetDriverInfoData->lpvData;
        GetDriverInfoData.lpvData = &D3dCallbacks3;
        GetDriverInfoData.dwExpectedSize = sizeof(D3dCallbacks3);

        dwRet = NtGdiDdGetDriverInfo(hDirectDraw, &GetDriverInfoData);

        RtlZeroMemory((PVOID)lpD3dCallbacks3, sizeof(*lpD3dCallbacks3));
        lpGetDriverInfoData->dwActualSize = sizeof(*lpD3dCallbacks3);
        lpD3dCallbacks3->dwSize = sizeof(*lpD3dCallbacks3);
        lpD3dCallbacks3->dwFlags = D3dCallbacks3.dwFlags;
        lpD3dCallbacks3->Clear2 = NULL;
        lpD3dCallbacks3->lpvReserved = NULL;

        if (D3dCallbacks3.ValidateTextureStageState != NULL)
        {
            lpD3dCallbacks3->ValidateTextureStageState =
                (LPD3DHAL_VALIDATETEXTURESTAGESTATECB)NtGdiD3dValidateTextureStageState;
        }
        if (D3dCallbacks3.DrawPrimitives2 != NULL)
        {
            lpD3dCallbacks3->DrawPrimitives2 =
                (LPD3DHAL_DRAWPRIMITIVES2CB)D3dDrawPrimitives2;
        }
    }
    else if (IsEqualIID(&lpGetDriverInfoData->guidInfo,
                        &GUID_D3DParseUnknownCommandCallback))
    {
        // On NT we ignore this callback
        lpGetDriverInfoData->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }
    else if (IsEqualIID(&lpGetDriverInfoData->guidInfo, &GUID_MotionCompCallbacks))
    {
        DD_MOTIONCOMPCALLBACKS         MotionCompCallbacks;
        LPDDHAL_DDMOTIONCOMPCALLBACKS  lpMotionCompCallbacks;

        // Translate Video call-backs to user-mode:

        lpMotionCompCallbacks            = lpGetDriverInfoData->lpvData;
        GetDriverInfoData.lpvData        = &MotionCompCallbacks;
        GetDriverInfoData.dwExpectedSize = sizeof(MotionCompCallbacks);

        dwRet = NtGdiDdGetDriverInfo(hDirectDraw, &GetDriverInfoData);

        RtlZeroMemory(lpMotionCompCallbacks, sizeof(*lpMotionCompCallbacks));
        lpGetDriverInfoData->dwActualSize = sizeof(*lpMotionCompCallbacks);
        lpMotionCompCallbacks->dwSize     = sizeof(*lpMotionCompCallbacks);
        lpMotionCompCallbacks->dwFlags    = MotionCompCallbacks.dwFlags
                                       | DDHAL_MOCOMP32_CREATE
                                       | DDHAL_MOCOMP32_DESTROY;
        lpMotionCompCallbacks->CreateMoComp = DdCreateMoComp;
        lpMotionCompCallbacks->DestroyMoComp = DdDestroyMoComp;

        if (MotionCompCallbacks.GetMoCompGuids)
        {
            lpMotionCompCallbacks->GetMoCompGuids = DdGetMoCompGuids;
        }
        if (MotionCompCallbacks.GetMoCompFormats)
        {
            lpMotionCompCallbacks->GetMoCompFormats = DdGetMoCompFormats;
        }
        if (MotionCompCallbacks.GetMoCompBuffInfo)
        {
            lpMotionCompCallbacks->GetMoCompBuffInfo = DdGetMoCompBuffInfo;
        }
        if (MotionCompCallbacks.GetInternalMoCompInfo)
        {
            lpMotionCompCallbacks->GetInternalMoCompInfo = DdGetInternalMoCompInfo;
        }
        if (MotionCompCallbacks.BeginMoCompFrame)
        {
            lpMotionCompCallbacks->BeginMoCompFrame = DdBeginMoCompFrame;
        }
        if (MotionCompCallbacks.EndMoCompFrame)
        {
            lpMotionCompCallbacks->EndMoCompFrame = DdEndMoCompFrame;
        }
        if (MotionCompCallbacks.RenderMoComp)
        {
            lpMotionCompCallbacks->RenderMoComp = DdRenderMoComp;
        }
        if (MotionCompCallbacks.QueryMoCompStatus)
        {
            lpMotionCompCallbacks->QueryMoCompStatus = DdQueryMoCompStatus;
        }
    }
    else if (IsEqualIID(&lpGetDriverInfoData->guidInfo, &GUID_VPE2Callbacks))
    {
        LPDDHAL_DDVPE2CALLBACKS   lpVPE2CallBacks;

        // Translate NT call-backs to user-mode:

        lpVPE2CallBacks                   = lpGetDriverInfoData->lpvData;

        RtlZeroMemory(lpVPE2CallBacks, sizeof(*lpVPE2CallBacks));
        lpGetDriverInfoData->dwActualSize = sizeof(*lpVPE2CallBacks);
        lpVPE2CallBacks->dwSize           = sizeof(*lpVPE2CallBacks);
        lpVPE2CallBacks->dwFlags          = DDHAL_VPE2CB32_ACQUIRENOTIFICATION |
                                            DDHAL_VPE2CB32_RELEASENOTIFICATION;
        lpVPE2CallBacks->AcquireNotification = DvpAcquireNotification;
        lpVPE2CallBacks->ReleaseNotification = DvpReleaseNotification;

        GetDriverInfoData.ddRVal = DD_OK;
        dwRet = DDHAL_DRIVER_HANDLED;
    }
    else
    {
        // Do data call:

        GetDriverInfoData.dwExpectedSize = lpGetDriverInfoData->dwExpectedSize;
        GetDriverInfoData.lpvData        = lpGetDriverInfoData->lpvData;

        dwRet = NtGdiDdGetDriverInfo(hDirectDraw, &GetDriverInfoData);

        lpGetDriverInfoData->dwActualSize = GetDriverInfoData.dwActualSize;
    }

    lpGetDriverInfoData->ddRVal = GetDriverInfoData.ddRVal;

    return(dwRet);
}

/******************************Public*Routine******************************\
* DdCreateDirectDrawObject
*
* When 'hdc' is 0, this function creates a 'global' DirectDraw object that
* may be used by any process, as a work-around for the DirectDraw folks.
* In reality, we still create a local DirectDraw object that is specific
* to this process, and whenever we're called with this 'special' global
* handle, we substitute the process-specific handle.  See the declaration
* of 'ghDirectDraw' for a commonet on why we do this.
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DdCreateDirectDrawObject(                       // AKA 'GdiEntry1'
    LPDDRAWI_DIRECTDRAW_GBL pDirectDrawGlobal,
    HDC                     hdc
    )
{
    BOOL b;

    b = FALSE;

    if (hdc == 0)
    {
        // Only one 'global' DirectDraw object may be active at a time.
        //
        // Note that this 'ghDirectDraw' assignment isn't thread safe;
        // DirectDraw must have its own critical section held when making
        // this call.  (Naturally, the kernel always properly synchronizes
        // itself in the NtGdi call.)

        if (ghDirectDraw == 0)
        {
            hdc = CreateDCW(L"Display", NULL, NULL, NULL);
            if (hdc != 0)
            {
                ghDirectDraw = NtGdiDdCreateDirectDrawObject(hdc);

                DeleteDC(hdc);
            }
        }

        if (ghDirectDraw)
        {
            gcDirectDraw++;
            b = TRUE;
        }

        // Mark the DirectDraw object handle stored in the DirectDraw
        // object as 'special' by making it zero:

        pDirectDrawGlobal->hDD = 0;
    }
    else
    {
        pDirectDrawGlobal->hDD = (ULONG_PTR) NtGdiDdCreateDirectDrawObject(hdc);
        b = (pDirectDrawGlobal->hDD != 0);
    }

    return(b);
}

/*****************************Private*Routine******************************\
* DdQueryDirectDrawObject
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DdQueryDirectDrawObject(                        // AKA 'GdiEntry2'
    LPDDRAWI_DIRECTDRAW_GBL     pDirectDrawGlobal,
    LPDDHALINFO                 pHalInfo,
    LPDDHAL_DDCALLBACKS         pDDCallBacks,
    LPDDHAL_DDSURFACECALLBACKS  pDDSurfaceCallBacks,
    LPDDHAL_DDPALETTECALLBACKS  pDDPaletteCallBacks,
    LPD3DHAL_CALLBACKS          pD3dCallbacks,
    LPD3DHAL_GLOBALDRIVERDATA   pD3dDriverData,
    LPDDHAL_DDEXEBUFCALLBACKS   pD3dBufferCallbacks,
    LPDDSURFACEDESC             pD3dTextureFormats,
    LPDWORD                     pdwFourCC,      // May be NULL
    LPVIDMEM                    pvmList         // May be NULL
    )
{
    DD_HALINFO      HalInfo;
    DWORD           adwCallBackFlags[3];
    DWORD           dwFlags;
    VIDEOMEMORY*    pVideoMemoryList;
    VIDEOMEMORY*    pVideoMemory;
    DWORD           dwNumHeaps;
    DWORD           dwNumFourCC;
    D3DNTHAL_CALLBACKS D3dCallbacks;
    D3DNTHAL_GLOBALDRIVERDATA D3dDriverData;
    DD_D3DBUFCALLBACKS D3dBufferCallbacks;

    pVideoMemoryList = NULL;
    if( (pvmList != NULL) && (pHalInfo->vmiData.dwNumHeaps != 0) )
    {
        pVideoMemoryList = (VIDEOMEMORY*) LocalAlloc(LMEM_ZEROINIT,
            sizeof(VIDEOMEMORY) * pHalInfo->vmiData.dwNumHeaps);

        if (pVideoMemoryList == NULL)
            return(FALSE);
    }

    //
    // Initialize to zero, so that Wow64's genthnk won't 
    // thunk bogus pointers.
    //
    RtlZeroMemory(&HalInfo, sizeof(HalInfo));
    RtlZeroMemory(&D3dCallbacks, sizeof(D3dCallbacks));
    RtlZeroMemory(&D3dDriverData, sizeof(D3dDriverData));
    RtlZeroMemory(&D3dBufferCallbacks, sizeof(D3dBufferCallbacks));

    //
    // set dwNumTextureFormats in the global driver data so that WoW64
    // can thunk the texture formats
    //
    if( (NULL != pD3dTextureFormats) &&
        (NULL != pD3dDriverData) )
    {
        D3dDriverData.dwNumTextureFormats = pD3dDriverData->dwNumTextureFormats;
    }

    if (!NtGdiDdQueryDirectDrawObject(DD_HANDLE(pDirectDrawGlobal->hDD),
                                      &HalInfo,
                                      &adwCallBackFlags[0],
                                      &D3dCallbacks,
                                      &D3dDriverData,
                                      &D3dBufferCallbacks,
                                      pD3dTextureFormats,
                                      &dwNumHeaps,
                                      pVideoMemoryList,
                                      &dwNumFourCC,
                                      pdwFourCC))
    {
        if (pVideoMemoryList != NULL)
            LocalFree(pVideoMemoryList);

        return(FALSE);
    }

    // Convert from the kernel-mode data structures to the user-mode
    // ones:

    memset(pHalInfo, 0, sizeof(DDHALINFO));

    pHalInfo->dwSize                   = sizeof(DDHALINFO);
    pHalInfo->lpDDCallbacks            = pDDCallBacks;
    pHalInfo->lpDDSurfaceCallbacks     = pDDSurfaceCallBacks;
    pHalInfo->lpDDPaletteCallbacks     = pDDPaletteCallBacks;
    if (D3dCallbacks.dwSize != 0 && D3dDriverData.dwSize != 0)
    {
        pHalInfo->lpD3DGlobalDriverData = (LPVOID)pD3dDriverData;
        pHalInfo->lpD3DHALCallbacks     = (LPVOID)pD3dCallbacks;
        if( D3dBufferCallbacks.dwSize != 0 )
            pHalInfo->lpDDExeBufCallbacks     = (LPDDHAL_DDEXEBUFCALLBACKS)pD3dBufferCallbacks;
    }
    pHalInfo->vmiData.fpPrimary        = 0;
    pHalInfo->vmiData.dwFlags          = HalInfo.vmiData.dwFlags;
    pHalInfo->vmiData.dwDisplayWidth   = HalInfo.vmiData.dwDisplayWidth;
    pHalInfo->vmiData.dwDisplayHeight  = HalInfo.vmiData.dwDisplayHeight;
    pHalInfo->vmiData.lDisplayPitch    = HalInfo.vmiData.lDisplayPitch;
    pHalInfo->vmiData.ddpfDisplay      = HalInfo.vmiData.ddpfDisplay;
    pHalInfo->vmiData.dwOffscreenAlign = HalInfo.vmiData.dwOffscreenAlign;
    pHalInfo->vmiData.dwOverlayAlign   = HalInfo.vmiData.dwOverlayAlign;
    pHalInfo->vmiData.dwTextureAlign   = HalInfo.vmiData.dwTextureAlign;
    pHalInfo->vmiData.dwZBufferAlign   = HalInfo.vmiData.dwZBufferAlign;
    pHalInfo->vmiData.dwAlphaAlign     = HalInfo.vmiData.dwAlphaAlign;
    pHalInfo->vmiData.dwNumHeaps       = dwNumHeaps;
    pHalInfo->vmiData.pvmList          = pvmList;

    ASSERTGDI(sizeof(pHalInfo->ddCaps) == sizeof(HalInfo.ddCaps),
              "DdQueryDirectDrawObject():DDCORECAPS structure size is not equal to DDNTCORECAPS\n");
    RtlCopyMemory(&(pHalInfo->ddCaps),&(HalInfo.ddCaps),sizeof(HalInfo.ddCaps));

    pHalInfo->ddCaps.dwNumFourCCCodes  = dwNumFourCC;
    pHalInfo->ddCaps.dwRops[0xCC / 32] = 1 << (0xCC % 32);     // Only SRCCOPY
    pHalInfo->lpdwFourCC               = pdwFourCC;
    pHalInfo->dwFlags                  = HalInfo.dwFlags | DDHALINFO_GETDRIVERINFOSET;
    pHalInfo->GetDriverInfo            = DdGetDriverInfo;

    if (pDDCallBacks != NULL)
    {
        memset(pDDCallBacks, 0, sizeof(DDHAL_DDCALLBACKS));

        dwFlags = adwCallBackFlags[0];

        pDDCallBacks->dwSize  = sizeof(DDHAL_DDCALLBACKS);
        pDDCallBacks->dwFlags = dwFlags;

        // Always set CreateSurface so that the kernel mode
        // heap manager has a chance to allocate the surface if
        // necessary.  It will take care of calling the driver
        // if necessary.
        pDDCallBacks->CreateSurface = DdCreateSurface;
        pDDCallBacks->dwFlags |= DDHAL_CB32_CREATESURFACE;

        if (dwFlags & DDHAL_CB32_WAITFORVERTICALBLANK)
            pDDCallBacks->WaitForVerticalBlank = DdWaitForVerticalBlank;

        if (dwFlags & DDHAL_CB32_CANCREATESURFACE)
            pDDCallBacks->CanCreateSurface = DdCanCreateSurface;

        if (dwFlags & DDHAL_CB32_GETSCANLINE)
            pDDCallBacks->GetScanLine = DdGetScanLine;
    }

    if (pDDSurfaceCallBacks != NULL)
    {
        memset(pDDSurfaceCallBacks, 0, sizeof(DDHAL_DDSURFACECALLBACKS));

        dwFlags = adwCallBackFlags[1];

        pDDSurfaceCallBacks->dwSize  = sizeof(DDHAL_DDSURFACECALLBACKS);
        pDDSurfaceCallBacks->dwFlags = (DDHAL_SURFCB32_LOCK
                                      | DDHAL_SURFCB32_UNLOCK
                                      | DDHAL_SURFCB32_SETCOLORKEY
                                      | DDHAL_SURFCB32_DESTROYSURFACE)
                                      | dwFlags;

        pDDSurfaceCallBacks->Lock = DdLock;
        pDDSurfaceCallBacks->Unlock = DdUnlock;
        pDDSurfaceCallBacks->SetColorKey = DdSetColorKey;
        pDDSurfaceCallBacks->DestroySurface = DdDestroySurface;

        if (dwFlags & DDHAL_SURFCB32_FLIP)
            pDDSurfaceCallBacks->Flip = DdFlip;

        if (dwFlags & DDHAL_SURFCB32_BLT)
            pDDSurfaceCallBacks->Blt = DdBlt;

        if (dwFlags & DDHAL_SURFCB32_GETBLTSTATUS)
            pDDSurfaceCallBacks->GetBltStatus = DdGetBltStatus;

        if (dwFlags & DDHAL_SURFCB32_GETFLIPSTATUS)
            pDDSurfaceCallBacks->GetFlipStatus = DdGetFlipStatus;

        if (dwFlags & DDHAL_SURFCB32_UPDATEOVERLAY)
            pDDSurfaceCallBacks->UpdateOverlay = DdUpdateOverlay;

        if (dwFlags & DDHAL_SURFCB32_SETOVERLAYPOSITION)
            pDDSurfaceCallBacks->SetOverlayPosition = DdSetOverlayPosition;

        if (dwFlags & DDHAL_SURFCB32_ADDATTACHEDSURFACE)
            pDDSurfaceCallBacks->AddAttachedSurface = DdAddAttachedSurface;
    }

    if (pDDPaletteCallBacks != NULL)
    {
        memset(pDDPaletteCallBacks, 0, sizeof(DDHAL_DDPALETTECALLBACKS));

        dwFlags = adwCallBackFlags[2];

        pDDPaletteCallBacks->dwSize  = sizeof(DDHAL_DDPALETTECALLBACKS);
        pDDPaletteCallBacks->dwFlags = dwFlags;
    }

    if (pD3dCallbacks != NULL)
    {
        memset(pD3dCallbacks, 0, sizeof(D3DHAL_CALLBACKS));

        if (D3dCallbacks.dwSize > 0)
        {
            pD3dCallbacks->dwSize = sizeof(D3DHAL_CALLBACKS);
            if (D3dCallbacks.ContextCreate != NULL)
            {
                pD3dCallbacks->ContextCreate = D3dContextCreate;
            }
            if (D3dCallbacks.ContextDestroy != NULL)
            {
                pD3dCallbacks->ContextDestroy =
                    (LPD3DHAL_CONTEXTDESTROYCB)NtGdiD3dContextDestroy;
            }
            if (D3dCallbacks.ContextDestroyAll != NULL)
            {
                pD3dCallbacks->ContextDestroyAll =
                    (LPD3DHAL_CONTEXTDESTROYALLCB)NtGdiD3dContextDestroyAll;
            }
            pD3dCallbacks->SceneCapture = NULL;
            pD3dCallbacks->TextureCreate = NULL;
            pD3dCallbacks->TextureDestroy = NULL;
            pD3dCallbacks->TextureSwap = NULL;
            pD3dCallbacks->TextureGetSurf = NULL;
        }
    }

    if (pD3dDriverData != NULL)
    {
        *pD3dDriverData = *(D3DHAL_GLOBALDRIVERDATA *)&D3dDriverData;
        pD3dDriverData->lpTextureFormats = pD3dTextureFormats;
    }

    if (pD3dBufferCallbacks != NULL)
    {
        memset( pD3dBufferCallbacks, 0, sizeof(DDHAL_DDEXEBUFCALLBACKS));

        if (D3dBufferCallbacks.dwSize > 0)
        {
            pD3dBufferCallbacks->dwSize  = sizeof(DDHAL_DDEXEBUFCALLBACKS);
            pD3dBufferCallbacks->dwFlags = D3dBufferCallbacks.dwFlags;
            if (D3dBufferCallbacks.CanCreateD3DBuffer != NULL)
            {
                pD3dBufferCallbacks->CanCreateExecuteBuffer =
                    (LPDDHALEXEBUFCB_CANCREATEEXEBUF)DdCanCreateD3DBuffer;
            }
            if (D3dBufferCallbacks.CreateD3DBuffer != NULL)
            {
                pD3dBufferCallbacks->CreateExecuteBuffer =
                    (LPDDHALEXEBUFCB_CREATEEXEBUF)DdCreateD3DBuffer;
            }
            if (D3dBufferCallbacks.DestroyD3DBuffer != NULL)
            {
                pD3dBufferCallbacks->DestroyExecuteBuffer =
                    (LPDDHALEXEBUFCB_DESTROYEXEBUF)DdDestroyD3DBuffer;
            }
            if (D3dBufferCallbacks.LockD3DBuffer != NULL)
            {
                pD3dBufferCallbacks->LockExecuteBuffer =
                    (LPDDHALEXEBUFCB_LOCKEXEBUF)DdLockD3D;
            }
            if (D3dBufferCallbacks.UnlockD3DBuffer != NULL)
            {
                pD3dBufferCallbacks->UnlockExecuteBuffer =
                    (LPDDHALEXEBUFCB_UNLOCKEXEBUF)DdUnlockD3D;
            }
        }
    }

    if (pVideoMemoryList != NULL)
    {
        pVideoMemory = pVideoMemoryList;

        while (dwNumHeaps-- != 0)
        {
            pvmList->dwFlags    = pVideoMemory->dwFlags;
            pvmList->fpStart    = pVideoMemory->fpStart;
            pvmList->fpEnd      = pVideoMemory->fpEnd;
            pvmList->ddsCaps    = pVideoMemory->ddsCaps;
            pvmList->ddsCapsAlt = pVideoMemory->ddsCapsAlt;
            pvmList->dwHeight   = pVideoMemory->dwHeight;

            pvmList++;
            pVideoMemory++;
        }

        LocalFree(pVideoMemoryList);
    }

    return(TRUE);
}

/*****************************Private*Routine******************************\
* DdDeleteDirectDrawObject
*
* Note that all associated surface objects must be deleted before the
* DirectDrawObject can be deleted.
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DdDeleteDirectDrawObject(                       // AKA 'GdiEntry3'
    LPDDRAWI_DIRECTDRAW_GBL pDirectDrawGlobal
    )
{
    BOOL b = FALSE;

    if (pDirectDrawGlobal->hDD != 0)
    {
        b = NtGdiDdDeleteDirectDrawObject((HANDLE) pDirectDrawGlobal->hDD);
    }
    else if (ghDirectDraw != 0)
    {
        b = TRUE;

        if (--gcDirectDraw == 0)
        {
            b = NtGdiDdDeleteDirectDrawObject(ghDirectDraw);
            ghDirectDraw = 0;
        }
    }

    return(b);
}

/*****************************Private*Routine******************************\
* bDdCreateSurfaceObject
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdCreateSurfaceObject(
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceLocal,
    BOOL                        bComplete
    )
{
    LPDDRAWI_DDRAWSURFACE_GBL   pSurfaceGlobal;
    DD_SURFACE_GLOBAL           SurfaceGlobal;
    DD_SURFACE_LOCAL            SurfaceLocal;
    DD_SURFACE_MORE             SurfaceMore;
    LPATTACHLIST                pAttach;
    BOOL                        bAttached;

    //
    // Wow64 genthnk will automatically thunk these structures, however,
    // since these structures are pointer dependent, we need to make sure
    // to NULL out these pointers so that Wow64 won't thunk them
    //
    RtlZeroMemory(&SurfaceLocal, sizeof(SurfaceLocal));
    RtlZeroMemory(&SurfaceGlobal, sizeof(SurfaceGlobal));
    RtlZeroMemory(&SurfaceMore, sizeof(SurfaceMore));

    SurfaceLocal.dwFlags      = pSurfaceLocal->dwFlags;
    SurfaceLocal.ddsCaps      = pSurfaceLocal->ddsCaps;

    SurfaceMore.ddsCapsEx       = pSurfaceLocal->lpSurfMore->ddsCapsEx;
    SurfaceMore.dwSurfaceHandle = pSurfaceLocal->lpSurfMore->dwSurfaceHandle;

    pSurfaceGlobal = pSurfaceLocal->lpGbl;

    SurfaceGlobal.fpVidMem    = pSurfaceGlobal->fpVidMem;
    SurfaceGlobal.lPitch      = pSurfaceGlobal->lPitch;
    SurfaceGlobal.wHeight     = pSurfaceGlobal->wHeight;
    SurfaceGlobal.wWidth      = pSurfaceGlobal->wWidth;

    // If HASPIXELFORMAT is not set, we have to get the pixel format out
    // of the global DirectDraw object:

    if (pSurfaceLocal->dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
        SurfaceGlobal.ddpfSurface = pSurfaceGlobal->ddpfSurface;
    }
    else
    {
        SurfaceGlobal.ddpfSurface = pSurfaceGlobal->lpDD->vmiData.ddpfDisplay;
    }

    pSurfaceLocal->hDDSurface = (ULONG_PTR)
                NtGdiDdCreateSurfaceObject(DD_HANDLE(pSurfaceGlobal->lpDD->hDD),
                                           (HANDLE) pSurfaceLocal->hDDSurface,
                                           &SurfaceLocal,
                                           &SurfaceMore,
                                           &SurfaceGlobal,
                                           bComplete);

    return(pSurfaceLocal->hDDSurface != 0);
}

/*****************************Private*Routine******************************\
* DdCreateSurfaceObject
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DdCreateSurfaceObject(                          // AKA 'GdiEntry4'
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceLocal,
    BOOL                        bUnused
    )
{
    // TRUE means surface is now complete:

    return(bDdCreateSurfaceObject(pSurfaceLocal, TRUE));
}

/*****************************Private*Routine******************************\
* DdDeleteSurfaceObject
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DdDeleteSurfaceObject(                          // AKA 'GdiEntry5'
    LPDDRAWI_DDRAWSURFACE_LCL pSurfaceLocal
    )
{
    BOOL b;

    b = TRUE;

    if (pSurfaceLocal->hDDSurface != 0)
    {
        b = NtGdiDdDeleteSurfaceObject((HANDLE) pSurfaceLocal->hDDSurface);
        pSurfaceLocal->hDDSurface = 0;  // Needed so CreateSurfaceObject works
    }

    return(b);
}

/*****************************Private*Routine******************************\
* DdResetVisrgn
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DdResetVisrgn(                                  // AKA 'GdiEntry6'
    LPDDRAWI_DDRAWSURFACE_LCL pSurfaceLocal,
    HWND                      hWnd
    )
{
    return(NtGdiDdResetVisrgn((HANDLE) pSurfaceLocal->hDDSurface, hWnd));
}

/*****************************Private*Routine******************************\
* DdGetDC
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HDC
APIENTRY
DdGetDC(                                        // AKA 'GdiEntry7'
    LPDDRAWI_DDRAWSURFACE_LCL pSurfaceLocal,
    LPPALETTEENTRY            pPalette
    )
{
    return(NtGdiDdGetDC((HANDLE) pSurfaceLocal->hDDSurface, pPalette));
}

/*****************************Private*Routine******************************\
* DdReleaseDC
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DdReleaseDC(
    LPDDRAWI_DDRAWSURFACE_LCL pSurfaceLocal     // AKA 'GdiEntry8'
    )
{
    return(NtGdiDdReleaseDC((HANDLE) pSurfaceLocal->hDDSurface));
}

/******************************Public*Routine******************************\
* DdCreateDIBSection
*
* Cloned from CreateDIBSection.
*
* The only difference from CreateDIBSection is that at 8bpp, we create the
* DIBSection to act like a device-dependent bitmap and don't create a palette.
* This way, the application is always ensured an identity translate on a blt,
* and doesn't have to worry about GDI's goofy colour matching.
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HBITMAP
APIENTRY
DdCreateDIBSection(                             // AKA 'GdiEntry9'
    HDC               hdc,
    CONST BITMAPINFO* pbmi,
    UINT              iUsage,
    VOID**            ppvBits,
    HANDLE            hSectionApp,
    DWORD             dwOffset
    )
{
    HBITMAP hbm = NULL;
    PVOID   pjBits = NULL;
    BITMAPINFO * pbmiNew = NULL;
    INT     cjHdr;

    pbmiNew = pbmiConvertInfo(pbmi, iUsage, &cjHdr, FALSE);

    // dwOffset has to be a multiple of 4 (sizeof(DWORD))
    // if there is a section.  If the section is NULL we do
    // not care

    if ( (hSectionApp == NULL) ||
         ((dwOffset & 3) == 0) )
    {
        hbm = NtGdiCreateDIBSection(
                                hdc,
                                hSectionApp,
                                dwOffset,
                                (LPBITMAPINFO) pbmiNew,
                                iUsage,
                                cjHdr,
                                CDBI_NOPALETTE,
                                0,
                                (PVOID *)&pjBits);

        if ((hbm == NULL) || (pjBits == NULL))
        {
            hbm = 0;
            pjBits = NULL;
        }
#if TRACE_SURFACE_ALLOCS
        else
        {
            PULONG  pUserAlloc;

            PSHARED_GET_VALIDATE(pUserAlloc, hbm, SURF_TYPE);

            if (pUserAlloc != NULL)
            {
                pUserAlloc[1] = RtlWalkFrameChain((PVOID *)&pUserAlloc[2], pUserAlloc[0], 0);
            }
        }
#endif

    }

    // Assign the appropriate value to the caller's pointer

    if (ppvBits != NULL)
    {
        *ppvBits = pjBits;
    }

    if (pbmiNew && (pbmiNew != pbmi))
        LocalFree(pbmiNew);

    return(hbm);
}

/*****************************Private*Routine******************************\
* DdReenableDirectDrawObject
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DdReenableDirectDrawObject(                     // AKA 'GdiEntry10'
    LPDDRAWI_DIRECTDRAW_GBL pDirectDrawGlobal,
    BOOL*                   pbNewMode
    )
{
    return(NtGdiDdReenableDirectDrawObject(DD_HANDLE(pDirectDrawGlobal->hDD),
                                           pbNewMode));
}

/*****************************Private*Routine******************************\
* DdAttachSurface
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DdAttachSurface(                                // AKA 'GdiEntry11'
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceFrom,
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceTo
    )
{
    BOOL bRet = TRUE;

    // We may be called to attach the surfaces before the kernel objects
    // have been created; if so, create a kernel surface on the fly but
    // mark it as incomplete:

    // must test failure case for leak

    if (pSurfaceFrom->hDDSurface == 0)
    {
        bRet &= bDdCreateSurfaceObject(pSurfaceFrom, FALSE);
    }
    if (pSurfaceTo->hDDSurface == 0)
    {
        bRet &= bDdCreateSurfaceObject(pSurfaceTo, FALSE);
    }
    if (bRet)
    {
        bRet = NtGdiDdAttachSurface((HANDLE) pSurfaceFrom->hDDSurface,
                                    (HANDLE) pSurfaceTo->hDDSurface);
    }

    return(bRet);
}

/*****************************Private*Routine******************************\
* DdUnattachSurface
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DdUnattachSurface(                              // AKA 'GdiEntry12'
    LPDDRAWI_DDRAWSURFACE_LCL   pSurface,
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceAttached
    )
{
    NtGdiDdUnattachSurface((HANDLE) pSurface->hDDSurface,
                           (HANDLE) pSurfaceAttached->hDDSurface);
}

/*****************************Private*Routine******************************\
* DdQueryDisplaySettingsUniqueness
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

ULONG
APIENTRY
DdQueryDisplaySettingsUniqueness(               // AKA 'GdiEntry13'
    VOID
    )
{
    return(pGdiSharedMemory->iDisplaySettingsUniqueness);
}

/*****************************Private*Routine******************************\
* DdGetDxHandle
*
* History:
*  18-Oct-1997 -by- smac
* Wrote it.
\**************************************************************************/

HANDLE
APIENTRY
DdGetDxHandle(                  // AKA 'GdiEntry14'
    LPDDRAWI_DIRECTDRAW_LCL pDDraw,
    LPDDRAWI_DDRAWSURFACE_LCL   pSurface,
    BOOL    bRelease
    )
{
    if( pSurface != NULL )
    {
        return( NtGdiDdGetDxHandle( NULL, (HANDLE)(pSurface->hDDSurface),
            bRelease ) );
    }
    return( NtGdiDdGetDxHandle( DD_HANDLE(pDDraw->lpGbl->hDD), NULL,
        bRelease ) );
}

/*****************************Private*Routine******************************\
* DdSetGammaRamp
*
* History:
*  18-Oct-1997 -by- smac
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DdSetGammaRamp(                                  // AKA 'GdiEntry15'
    LPDDRAWI_DIRECTDRAW_LCL pDDraw,
    HDC         hdc,
    LPVOID      lpGammaRamp
    )
{
    return( NtGdiDdSetGammaRamp( DD_HANDLE(pDDraw->lpGbl->hDD), hdc,
        lpGammaRamp ) );
}

/*****************************Private*Routine******************************\
* DdSwapTextureHandles
*
* History:
*  17-Nov-1998 -by- anankan
* Wrote it.
\**************************************************************************/

ULONG
APIENTRY
DdSwapTextureHandles(                            // AKA 'GdiEntry16'
    LPDDRAWI_DIRECTDRAW_LCL    pDDLcl,
    LPDDRAWI_DDRAWSURFACE_LCL  pDDSLcl1,
    LPDDRAWI_DDRAWSURFACE_LCL  pDDSLcl2
    )
{
    //this entry is going away now that CreateSurfaceEx is added
    return DDHAL_DRIVER_HANDLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\dcmod.c ===
/******************************Module*Header*******************************\
* Module Name: dcmod.c                                                     *
*                                                                          *
* Client side stubs for functions that modify the state of the DC in the   *
* server.                                                                  *
*                                                                          *
* Created: 05-Jun-1991 01:49:42                                            *
* Author: Charles Whitmer [chuckwh]                                        *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                            *
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

#include "winuserk.h"

BOOL InitDeviceInfo(PLDC pldc, HDC hdc);
VOID vComputePageXform(PLDC pldc);
DWORD GetAndSetDCDWord( HDC, UINT, UINT, UINT, WORD, UINT );

#define DBG_XFORM 0

/******************************Public*Routine******************************\
* MoveToEx                                                                 *
*                                                                          *
* Client side stub.  It's important to batch this call whenever we can.    *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI MoveToEx(HDC hdc,int x,int y,LPPOINT pptl)
{
    BOOL bRet = FALSE;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms3(hdc,x,y,META_MOVETO));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetDD(hdc,(DWORD)x,(DWORD)y,EMR_MOVETOEX))
                return(bRet);
        }
    }

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        bRet = TRUE;

        if (pptl != NULL)
        {
            // If the logical-space version of the current position is
            // invalid, then the device-space version of the current
            // position is guaranteed to be valid.  So we can reverse
            // the current transform on that to compute the logical-
            // space version:

            if (pDcAttr->ulDirty_ & DIRTY_PTLCURRENT)
            {
                *((POINTL*)pptl) = pDcAttr->ptfxCurrent;
                pptl->x = FXTOL(pptl->x);
                pptl->y = FXTOL(pptl->y);
                bRet = DPtoLP(hdc,pptl,1);
            }
            else
            {
                *((POINTL*)pptl) = pDcAttr->ptlCurrent;
            }
        }

        pDcAttr->ptlCurrent.x = x;
        pDcAttr->ptlCurrent.y = y;

        // We now know the new logical-space version of the current position
        // (but not the device-space version).  Mark it as such.  We also
        // have to reset the style-state for styled pens.

        pDcAttr->ulDirty_ &= ~DIRTY_PTLCURRENT;
        pDcAttr->ulDirty_ |= (DIRTY_PTFXCURRENT | DIRTY_STYLESTATE);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* OffsetClipRgn                                                            *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

int META WINAPI OffsetClipRgn(HDC hdc,int x,int y)
{
    int  iRet = RGN_ERROR;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParms3(hdc,x,y,META_OFFSETCLIPRGN));

        DC_PLDC(hdc,pldc,iRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_OffsetClipRgn(hdc,x,y))
                return(iRet);
        }
    }

    return(NtGdiOffsetClipRgn(hdc,x,y));

}

/******************************Public*Routine******************************\
* SetMetaRgn
*
* Client side stub.
*
* History:
*  Tue Apr 07 17:05:37 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

int WINAPI SetMetaRgn(HDC hdc)
{
    int   iRet = RGN_ERROR;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc,pldc,iRet);

        if (pldc->iType == LO_METADC && !MF_SetMetaRgn(hdc))
            return(iRet);
    }

    return(NtGdiSetMetaRgn(hdc));
}

/******************************Public*Routine******************************\
* SelectPalette                                                            *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HPALETTE META WINAPI SelectPalette(HDC hdc,HPALETTE hpal,BOOL b)
{
    ULONG_PTR hRet = 0;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hpal);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return ((HPALETTE)(ULONG_PTR)MF16_SelectPalette(hdc,hpal));

        DC_PLDC(hdc,pldc,(HPALETTE)hRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SelectAnyObject(hdc,(HANDLE)hpal,EMR_SELECTPALETTE))
                return((HPALETTE) hRet);
        }
    }

    return(NtUserSelectPalette(hdc,hpal,b));
}

/******************************Public*Routine******************************\
* SetMapperFlags                                                           *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

DWORD META WINAPI SetMapperFlags(HDC hdc,DWORD fl)
{
    DWORD dwRet;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        CHECK_AND_FLUSH_TEXT (hdc, pdcattr);

        if (fl & (~ASPECT_FILTERING))
        {
            WARNING("gdisrv!GreSetMapperFlags(): unknown flag\n");
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            dwRet = GDI_ERROR;
        }
        else
        {
            dwRet =  pdcattr->flFontMapper;
            pdcattr->flFontMapper = fl;
        }
    }
    else
    {
    WARNING("gdi32!SetMapperFlags(): invalid hdc\n");
    GdiSetLastError(ERROR_INVALID_PARAMETER);
    dwRet = GDI_ERROR;
    }

    return(dwRet);

}

// SetMapperFlagsInternal - no metafile version.

DWORD SetMapperFlagsInternal(HDC hdc,DWORD fl)
{
    return(GetAndSetDCDWord( hdc,
                             GASDDW_MAPPERFLAGS,
                             fl,
                             EMR_MAX+1,
                             EMR_MAX+1,
                             GDI_ERROR ));
}

/******************************Public*Routine******************************\
* SetSystemPaletteUse                                                      *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* This function is not metafile'd.                                         *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

UINT META WINAPI SetSystemPaletteUse(HDC hdc,UINT iMode)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiSetSystemPaletteUse(hdc,iMode));
}

/******************************Public*Routine******************************\
* SetTextJustification                                                     *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 14-Jan-1993 03:30:27 -by- Charles Whitmer [chuckwh]                 *
* Save a copy in the LDC for computing text extent.                        *
*                                                                          *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI SetTextJustification(HDC hdc,int dx,int cBreak)
{
    PDC_ATTR pdcattr;
    BOOL bRet = FALSE;
    FIXUP_HANDLE(hdc);

    if (IS_METADC16_TYPE(hdc))
        return (MF16_RecordParms3(hdc,dx,cBreak,META_SETTEXTJUSTIFICATION));

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        CHECK_AND_FLUSH_TEXT (hdc, pdcattr);

        pdcattr->lBreakExtra = dx;
        pdcattr->cBreak      = cBreak;
        bRet = TRUE;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* SetArcDirection
*
* Client side stub.  Batches the call.
*
* History:
*  20-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

int META WINAPI SetArcDirection(HDC hdc,int iArcDirection)
{
    FIXUP_HANDLE(hdc);

    return(GetAndSetDCDWord( hdc,
                             GASDDW_ARCDIRECTION,
                             iArcDirection,
                             EMR_MAX+1,
                             EMR_MAX+1,
                             ERROR));
}

/******************************Public*Routine******************************\
* SetMiterLimit
*
* Client side stub.  Batches the call whenever it can.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI SetMiterLimit(HDC hdc,FLOAT e,PFLOAT pe)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;
        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC && !MF_SetD(hdc,(DWORD)e,EMR_SETMITERLIMIT))
            return(bRet);
    }

    return(NtGdiSetMiterLimit(hdc,FLOATARG(e),FLOATPTRARG(pe)));
}

/******************************Public*Routine******************************\
* SetFontXform
*
* Client side stub.  Batches the call whenever it can.
* This is an internal function.
*
* History:
*  Tue Nov 24 09:54:15 1992     -by-    Hock San Lee    [hockl]            *
* Wrote it.
\**************************************************************************/

BOOL SetFontXform(HDC hdc,FLOAT exScale,FLOAT eyScale)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

// This function is called only by the metafile playback code.
// If hdc is an enhanced metafile DC, we need to remember the scales
// so that we can metafile it in the compatible ExtTextOut or PolyTextOut
// record that follows.

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;
        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC && !MF_SetFontXform(hdc,exScale,eyScale))
            return(bRet);
    }
    // If the dc is mirrored then do not mirror the text at play back time.
    if (GetLayout(hdc) & LAYOUT_RTL) {
        exScale = -exScale;
    }
    return(NtGdiSetFontXform(hdc,FLOATARG(exScale),FLOATARG(eyScale)));
}

/******************************Public*Routine******************************\
* SetBrushOrgEx                                                            *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI SetBrushOrgEx(HDC hdc,int x,int y,LPPOINT pptl)
{
    BOOL     bRet = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;
        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC && !MF_SetBrushOrgEx(hdc,x,y))
            return(bRet);
    }

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr != NULL)
    {
        if (pptl != (LPPOINT)NULL)
        {
            *pptl = *((LPPOINT)&pdcattr->ptlBrushOrigin);
        }

        if (
             (pdcattr->ptlBrushOrigin.x != x) ||
             (pdcattr->ptlBrushOrigin.y != y)
           )
        {
            BEGIN_BATCH_HDC(hdc,pdcattr,BatchTypeSetBrushOrg,BATCHSETBRUSHORG);

                pdcattr->ptlBrushOrigin.x = x;
                pdcattr->ptlBrushOrigin.y = y;

                pBatch->x          = x;
                pBatch->y          = y;

            COMPLETE_BATCH_COMMAND();
        }

        bRet = TRUE;

    }
    else
    {
        UNBATCHED_COMMAND:
        bRet = NtGdiSetBrushOrg(hdc,x,y,pptl);
    }
    return(bRet);
}

/******************************Public*Routine******************************\
* RealizePalette                                                           *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

UINT WINAPI RealizePalette(HDC hdc)
{
    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        UINT  uRet = 0xFFFFFFFF;
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return((UINT) MF16_RealizePalette(hdc));

        DC_PLDC(hdc,pldc,uRet);

        if (pldc->iType == LO_METADC)
        {
            HPALETTE hpal = (HPALETTE)GetDCObject(hdc,LO_PALETTE_TYPE);
            if ((pmetalink16Get(hpal) != NULL) && !MF_RealizePalette(hpal))
                return(uRet);
        }
    }

    return(UserRealizePalette(hdc));
}

/******************************Public*Routine******************************\
* GetBoundsRect
*
* Client side stub.
*
* History:
*  06-Apr-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

UINT WINAPI GetBoundsRect(HDC hdc, LPRECT lprc, UINT fl)
{
    FIXUP_HANDLE(hdc);

    // Applications can never set DCB_WINDOWMGR

    return(NtGdiGetBoundsRect(hdc, lprc, fl & ~DCB_WINDOWMGR));
}

UINT WINAPI GetBoundsRectAlt(HDC hdc, LPRECT lprc, UINT fl)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiGetBoundsRect(hdc,lprc,fl));
}

/******************************Public*Routine******************************\
* SetBoundsRect
*
* Client side stub.
*
* History:
*  06-Apr-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

UINT WINAPI SetBoundsRect(HDC hdc, CONST RECT *lprc, UINT fl)
{
    FIXUP_HANDLE(hdc);

    // Applications can never set DCB_WINDOWMGR

    return(NtGdiSetBoundsRect(hdc, (LPRECT)lprc, fl & ~DCB_WINDOWMGR));
}

UINT WINAPI SetBoundsRectAlt(HDC hdc, CONST RECT *lprc, UINT fl)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiSetBoundsRect(hdc,(LPRECT)lprc,fl));
}

/******************************Public*Routine******************************\
* CancelDC1()
*
* History:
*  14-Apr-1992 -by-  - by - Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL WINAPI CancelDC(HDC hdc)
{
    BOOL bRes = FALSE;

    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc,pldc,bRes);

        if (pldc->fl & LDC_DOC_STARTED)
        {
            pldc->fl |= LDC_DOC_CANCELLED;
        }

        bRes = NtGdiCancelDC(hdc);
    }

    // If we are in the process of playing the metafile, stop the playback.

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        pDcAttr->ulDirty_ &= ~DC_PLAYMETAFILE;
        bRes = TRUE;
    }

    return(bRes);
}

/******************************Public*Function*****************************\
* SetColorAdjustment
*
*  Set the color adjustment data for a given DC.
*
* History:
*  07-Aug-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL META APIENTRY SetColorAdjustment(HDC hdc, CONST COLORADJUSTMENT * pca)
{
    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        BOOL bRet = FALSE;
        PLDC pldc;

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC && !MF_SetColorAdjustment(hdc, pca))
        {
            return(bRet);
        }
    }

    return(NtGdiSetColorAdjustment(hdc,(COLORADJUSTMENT*)pca));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\dcquery.c ===
/******************Module*Header********************************************\
* Module Name: dcquery.c                                                   *
*                                                                          *
* Client side stubs for functions that query the DC in the server.         *
*                                                                          *
* Created: 05-Jun-1991 01:43:56                                            *
* Author: Charles Whitmer [chuckwh]                                        *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#if DBG
FLONG gflDebug = 0;
#endif

// This macro retrieves the current code page, carefully masking off the
// charset:

#define GET_CODE_PAGE(hdc,pDcAttr)                                           \
    ((!(pDcAttr->ulDirty_ & DIRTY_CHARSET) ? pDcAttr->iCS_CP                 \
                                           : NtGdiGetCharSet(hdc)) & 0xffff)
BOOL bIsDBCSString(LPCSTR psz, int cc);

/******************************Public*Routine******************************\
* vOutlineTextMetricWToOutlineTextMetricA
*
* Convert from OUTLINETEXTMETRICA (ANSI structure) to OUTLINETEXTMETRICW
* (UNICODE structure).
*
* Note:
*   This function is capable of converting in place (in and out buffers
*   can be the same).
*
* Returns:
*   TTRUE if successful, FALSE otherwise.
*
* History:
*  02-Mar-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vOutlineTextMetricWToOutlineTextMetricA (
    LPOUTLINETEXTMETRICA   potma,
    OUTLINETEXTMETRICW   * potmw,
    TMDIFF *               ptmd
    )
{
// Size.

    potma->otmSize = potmw->otmSize;

// Convert the textmetrics.

    vTextMetricWToTextMetricStrict(
        &potma->otmTextMetrics,
        &potmw->otmTextMetrics);

    potma->otmTextMetrics.tmFirstChar   = ptmd->chFirst;
    potma->otmTextMetrics.tmLastChar    = ptmd->chLast;
    potma->otmTextMetrics.tmDefaultChar = ptmd->chDefault;
    potma->otmTextMetrics.tmBreakChar   = ptmd->chBreak;

// for Win 64 we need to copy these fields one by one due to alignement difference

    potma->otmFiller                    = potmw->otmFiller;
    potma->otmPanoseNumber              = potmw->otmPanoseNumber;
    potma->otmfsSelection               = potmw->otmfsSelection;
    potma->otmfsType                    = potmw->otmfsType;
    potma->otmsCharSlopeRise            = potmw->otmsCharSlopeRise;
    potma->otmsCharSlopeRun             = potmw->otmsCharSlopeRun;
    potma->otmItalicAngle               = potmw->otmItalicAngle;
    potma->otmEMSquare                  = potmw->otmEMSquare;
    potma->otmAscent                    = potmw->otmAscent;
    potma->otmDescent                   = potmw->otmDescent;
    potma->otmLineGap                   = potmw->otmLineGap;
    potma->otmsCapEmHeight              = potmw->otmsCapEmHeight;
    potma->otmsXHeight                  = potmw->otmsXHeight;
    potma->otmrcFontBox                 = potmw->otmrcFontBox;
    potma->otmMacAscent                 = potmw->otmMacAscent;
    potma->otmMacDescent                = potmw->otmMacDescent;
    potma->otmMacLineGap                = potmw->otmMacLineGap;
    potma->otmusMinimumPPEM             = potmw->otmusMinimumPPEM;
    potma->otmptSubscriptSize           = potmw->otmptSubscriptSize;
    potma->otmptSubscriptOffset         = potmw->otmptSubscriptOffset;
    potma->otmptSuperscriptSize         = potmw->otmptSuperscriptSize;
    potma->otmptSuperscriptOffset       = potmw->otmptSuperscriptOffset;
    potma->otmsStrikeoutSize            = potmw->otmsStrikeoutSize;
    potma->otmsStrikeoutPosition        = potmw->otmsStrikeoutPosition;
    potma->otmsUnderscoreSize           = potmw->otmsUnderscoreSize;
    potma->otmsUnderscorePosition       = potmw->otmsUnderscorePosition;

// set the offsets to zero for now, this will be changed later if
// the caller wanted strings as well

    potma->otmpFamilyName = NULL;
    potma->otmpFaceName   = NULL;
    potma->otmpStyleName  = NULL;
    potma->otmpFullName   = NULL;
}

/******************************Public*Routine******************************\
*
* vGenerateANSIString
*
* Effects: Generates Ansi string which consists of consecutive ansi chars
*          [iFirst, iLast] inclusive. The string is stored in the buffer
*          puchBuf that the user must ensure is big enough
*
*
*
* History:
*  24-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vGenerateAnsiString(UINT iFirst, UINT iLast, PUCHAR puchBuf)
{
// Generate string (terminating NULL not needed).

    ASSERTGDI((iFirst <= iLast) && (iLast < 256), "gdi!_vGenerateAnsiString\n");

    for ( ; iFirst <= iLast; iFirst++)
        *puchBuf++ = (UCHAR) iFirst;
}

/******************************Public*Routine******************************\
*
* bSetUpUnicodeString
*
* Effects:
*
* Warnings:
*
* History:
*  25-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bSetUpUnicodeString(
IN  UINT    iFirst,      // first ansi char
IN  UINT    iLast,       // last char
IN  PUCHAR  puchTmp,     // buffer for an intermediate ansi string
OUT PWCHAR  pwc,         // output fuffer with a unicode string
IN  UINT    dwCP         // ansi codepage
)
{
    UINT c = iLast - iFirst + 1;
    vGenerateAnsiString(iFirst,iLast,puchTmp);
    return MultiByteToWideChar(
               dwCP, 0,
               puchTmp,c,
               pwc, c*sizeof(WCHAR));
}


/******************************Public*Routine******************************\
* GetAspectRatioFilterEx                                                   *
* GetBrushOrgEx                                                            *
*                                                                          *
* Client side stubs which all get mapped to GetPoint.                      *
*                                                                          *
*  Fri 07-Jun-1991 18:01:50 -by- Charles Whitmer [chuckwh]                 *
* Wrote them.                                                              *
\**************************************************************************/

BOOL APIENTRY GetAspectRatioFilterEx(HDC hdc,LPSIZE psizl)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiGetDCPoint(hdc,DCPT_ASPECTRATIOFILTER,(PPOINTL) psizl));
}

BOOL APIENTRY GetBrushOrgEx(HDC hdc,LPPOINT pptl)
{
    BOOL     bRet = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if ((pdcattr != NULL) && (pptl != (LPPOINT)NULL))
    {
        *pptl = *((LPPOINT)&pdcattr->ptlBrushOrigin);
        bRet = TRUE;
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }
    return(bRet);

}

BOOL APIENTRY GetDCOrgEx(HDC hdc,LPPOINT pptl)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiGetDCPoint(hdc,DCPT_DCORG,(PPOINTL)pptl));
}

// The old GetDCOrg is here because it was in the Beta and we are afraid
// to remove it now.  It would be nice to remove it.

DWORD APIENTRY GetDCOrg(HDC hdc)
{
    hdc;
    return(0);
}

/******************************Public*Routine******************************\
* Client side stub for GetCurrentPositionEx.
*
*  Wed 02-Sep-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetCurrentPositionEx(HDC hdc,LPPOINT pptl)
{
    BOOL bRet = FALSE;

    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if ((pDcAttr) && (pptl != (LPPOINT)NULL))
    {
        bRet = TRUE;

        if (pDcAttr->ulDirty_ & DIRTY_PTLCURRENT)
        {
            // If the logical-space version of the current position is invalid,
            // then the device-space version of the current position is
            // guaranteed to be valid.  So we can reverse the current transform
            // on that to compute the logical-space version:

            *((POINTL*)pptl) = pDcAttr->ptfxCurrent;

            pptl->x = FXTOL(pptl->x);
            pptl->y = FXTOL(pptl->y);
            bRet = DPtoLP(hdc,pptl,1);

            if (bRet)
            {
                pDcAttr->ptlCurrent = *((POINTL*)pptl);
                pDcAttr->ulDirty_ &= ~DIRTY_PTLCURRENT;
            }
        }
        else
        {
            *((POINTL*)pptl) = pDcAttr->ptlCurrent;
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GetPixel                                                                 *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Fri 07-Jun-1991 18:01:50 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

DWORD APIENTRY GetPixel(HDC hdc,int x,int y)
{
    PDC_ATTR pdca;
    COLORREF ColorRet = CLR_INVALID;

    FIXUP_HANDLE(hdc);
    PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

    if (pdca)
    {
        //
        // if the color is not a PaletteIndex and
        // ICM is on then translate
        //

        ColorRet = NtGdiGetPixel(hdc,x,y);

        if ( bNeedTranslateColor(pdca)
               &&
             ( IS_32BITS_COLOR(pdca->lIcmMode)
                        ||
               ((ColorRet != CLR_INVALID) &&
                 !(ColorRet & 0x01000000))
             )
           )
        {
            //
            // translate back color to original.
            //
            COLORREF NewColor;

            BOOL bStatus = IcmTranslateCOLORREF(hdc,
                                                pdca,
                                                ColorRet,
                                                &NewColor,
                                                ICM_BACKWARD);
            if (bStatus)
            {
                ColorRet = NewColor;
            }
        }
    }

    return(ColorRet);
}

/******************************Public*Routine******************************\
* GetDeviceCaps
*
* We store the device caps for primary display dc and its compatible memory dcs
* in the shared handle table.
*
* for printer dcs and meta dcs, we cache the dev info in the LDC structure.
*
*  Fri 07-Jun-1991 18:01:50 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

int APIENTRY GetDeviceCaps(HDC hdc,int iCap)
{
    BOOL bRet = FALSE;
    PDEVCAPS pCachedDevCaps = NULL;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        // For the 16-bit metafile DC, returns only technology.  return 0 for win3.1 compat.

        if (IS_METADC16_TYPE(hdc))
            return(iCap == TECHNOLOGY ? DT_METAFILE : 0);

        DC_PLDC(hdc,pldc,bRet);

        if (!(pldc->fl & LDC_CACHED_DEVCAPS))
        {
            bRet = NtGdiGetDeviceCapsAll (hdc, &pldc->DevCaps);

            if (bRet)
            {
                pCachedDevCaps = &pldc->DevCaps;
                pldc->fl |= LDC_CACHED_DEVCAPS;
            }
        }
        else
        {
           pCachedDevCaps = &pldc->DevCaps;
           bRet = TRUE;
        }
    }
    else
    {
        PDC_ATTR pDcAttr;

        PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

        if (pDcAttr)
        {
                ULONG  fl = pDcAttr->ulDirty_;

                if (!(fl & DC_PRIMARY_DISPLAY))
                {
                    return(NtGdiGetDeviceCaps(hdc,iCap));
                }
            else
            {
                pCachedDevCaps = pGdiDevCaps;
                bRet = TRUE;
            }
        }
    }

    if (!bRet)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    // actual code - copied from gre\miscgdi.cxx
    switch (iCap)
    {
    case DRIVERVERSION:                     //  Version = 0100h for now
        return(pCachedDevCaps->ulVersion);

    case TECHNOLOGY:                        //  Device classification
        return(pCachedDevCaps->ulTechnology);

    case HORZSIZE:                          //  Horizontal size in millimeters
        return(pCachedDevCaps->ulHorzSizeM);

    case VERTSIZE:                          //  Vertical size in millimeters
        return(pCachedDevCaps->ulVertSizeM);

    case HORZRES:                           //  Horizontal width in pixels
        return(pCachedDevCaps->ulHorzRes);

    case VERTRES:                           //  Vertical height in pixels
        return(pCachedDevCaps->ulVertRes);

    case BITSPIXEL:                         //  Number of bits per pixel
        return(pCachedDevCaps->ulBitsPixel);

    case PLANES:                            //  Number of planes
        return(pCachedDevCaps->ulPlanes);

    case NUMBRUSHES:                        //  Number of brushes the device has
        return(-1);

    case NUMPENS:                           //  Number of pens the device has
        return(pCachedDevCaps->ulNumPens);

    case NUMMARKERS:                        //  Number of markers the device has
        return(0);

    case NUMFONTS:                          //  Number of fonts the device has
        return(pCachedDevCaps->ulNumFonts);

    case NUMCOLORS:                         //  Number of colors in color table
        return(pCachedDevCaps->ulNumColors);

    case PDEVICESIZE:                       //  Size required for the device descriptor
        return(0);

    case CURVECAPS:                         //  Curves capabilities
        return(CC_CIRCLES    |
               CC_PIE        |
               CC_CHORD      |
               CC_ELLIPSES   |
               CC_WIDE       |
               CC_STYLED     |
               CC_WIDESTYLED |
               CC_INTERIORS  |
               CC_ROUNDRECT);

    case LINECAPS:                          //  Line capabilities
        return(LC_POLYLINE   |
               LC_MARKER     |
               LC_POLYMARKER |
               LC_WIDE       |
               LC_STYLED     |
               LC_WIDESTYLED |
               LC_INTERIORS);

    case POLYGONALCAPS:                     //  Polygonal capabilities
        return(PC_POLYGON     |
               PC_RECTANGLE   |
               PC_WINDPOLYGON |
               PC_TRAPEZOID   |
               PC_SCANLINE    |
               PC_WIDE        |
               PC_STYLED      |
               PC_WIDESTYLED  |
               PC_INTERIORS);

    case TEXTCAPS:                          //  Text capabilities
        return(pCachedDevCaps->ulTextCaps);

    case CLIPCAPS:                          //  Clipping capabilities
        return(CP_RECTANGLE);

    case RASTERCAPS:                        //  Bitblt capabilities
        return(pCachedDevCaps->ulRasterCaps);

    case SHADEBLENDCAPS:                    //  shade and blend capabilities
        return(pCachedDevCaps->ulShadeBlendCaps);

    case ASPECTX:                           //  Length of X leg
        return(pCachedDevCaps->ulAspectX);

    case ASPECTY:                           //  Length of Y leg
        return(pCachedDevCaps->ulAspectY);

    case ASPECTXY:                          //  Length of hypotenuse
        return(pCachedDevCaps->ulAspectXY);

    case LOGPIXELSX:                        //  Logical pixels/inch in X
        return(pCachedDevCaps->ulLogPixelsX);

    case LOGPIXELSY:                        //  Logical pixels/inch in Y
        return(pCachedDevCaps->ulLogPixelsY);

    case SIZEPALETTE:                       // # entries in physical palette
        return(pCachedDevCaps->ulSizePalette);

    case NUMRESERVED:                       // # reserved entries in palette
        return(20);

    case COLORRES:
        return(pCachedDevCaps->ulColorRes);

    case PHYSICALWIDTH:                     // Physical Width in device units
        return(pCachedDevCaps->ulPhysicalWidth);

    case PHYSICALHEIGHT:                    // Physical Height in device units
        return(pCachedDevCaps->ulPhysicalHeight);

    case PHYSICALOFFSETX:                   // Physical Printable Area x margin
        return(pCachedDevCaps->ulPhysicalOffsetX);

    case PHYSICALOFFSETY:                   // Physical Printable Area y margin
        return(pCachedDevCaps->ulPhysicalOffsetY);

    case VREFRESH:                          // Vertical refresh rate of the device
        return(pCachedDevCaps->ulVRefresh);

    case DESKTOPHORZRES:                    // Width of entire virtual desktop
        return(pCachedDevCaps->ulDesktopHorzRes);

    case DESKTOPVERTRES:                    // Height of entire virtual desktop
        return(pCachedDevCaps->ulDesktopVertRes);

    case BLTALIGNMENT:                      // Preferred blt alignment
        return(pCachedDevCaps->ulBltAlignment);

    case COLORMGMTCAPS:                     // Color Management capabilities
        return(pCachedDevCaps->ulColorManagementCaps);

    default:
        return(0);
    }

}


/******************************Public*Routine******************************\
* GetDeviceCapsP
*
* Private version to get HORSIZE and VERTSIZE in micrometers
* Copied from GetDeviceCaps
*
* \**************************************************************************/
int GetDeviceCapsP(HDC hdc,int iCap)
{
    BOOL bRet = FALSE;
    PDEVCAPS pCachedDevCaps = NULL;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc,pldc,bRet);

        if (!(pldc->fl & LDC_CACHED_DEVCAPS))
        {
            bRet = NtGdiGetDeviceCapsAll (hdc, &pldc->DevCaps);

            if (bRet)
            {
                pCachedDevCaps = &pldc->DevCaps;
                pldc->fl |= LDC_CACHED_DEVCAPS;
            }
        }
        else
        {
           pCachedDevCaps = &pldc->DevCaps;
           bRet = TRUE;
        }
    }
    else
    {
        PDC_ATTR pDcAttr;

        PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

        if (pDcAttr)
        {
                ULONG  fl = pDcAttr->ulDirty_;

                if (!(fl & DC_PRIMARY_DISPLAY))
                {
                    return(NtGdiGetDeviceCaps(hdc,iCap));
                }
                else
                {
                    pCachedDevCaps = pGdiDevCaps;
                    bRet = TRUE;
                }
        }
    }

    if (!bRet)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    // actual code - copied from gre\miscgdi.cxx
    switch (iCap)
    {
    case HORZSIZEP:                          //  Horizontal size
        return(pCachedDevCaps->ulHorzSize);

    case VERTSIZEP:                          //  Vertical size
        return(pCachedDevCaps->ulVertSize);


    default:
        return(0);
    }

}



/******************************Public*Routine******************************\
* GetNearestColor                                                          *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Fri 07-Jun-1991 18:01:50 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

COLORREF APIENTRY GetNearestColor(HDC hdc,COLORREF color)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiGetNearestColor(hdc,color));
}

/******************************Public*Routine******************************\
* GetArcDirection
*
* Client side stub.
*
*  Fri 09-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

int APIENTRY GetArcDirection(HDC hdc)
{
    FIXUP_HANDLE(hdc);

    return(GetDCDWord(hdc,DDW_ARCDIRECTION,0));
}

/******************************Public*Routine******************************\
* GetMiterLimit
*
* Client side stub.
*
*  Fri 09-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

int APIENTRY GetMiterLimit(HDC hdc, PFLOAT peMiterLimit)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiGetMiterLimit(hdc,FLOATPTRARG(peMiterLimit)));
}

/******************************Public*Routine******************************\
* GetSystemPaletteUse                                                      *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Fri 07-Jun-1991 18:01:50 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

UINT APIENTRY GetSystemPaletteUse(HDC hdc)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiGetSystemPaletteUse(hdc));
}

/******************************Public*Routine******************************\
* GetClipBox                                                               *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Fri 07-Jun-1991 18:01:50 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

int APIENTRY GetClipBox(HDC hdc,LPRECT prcl)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiGetAppClipBox(hdc,prcl));
}

/******************************Public*Routine******************************\
*
* BOOL APIENTRY GetTextMetrics(HDC hdc,LPTEXTMETRIC ptm)
*
*   calls to the unicode version
*
* History:
*  21-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetTextMetricsA(HDC hdc,LPTEXTMETRICA ptm)
{
    PDC_ATTR     pDcAttr;
    BOOL         bRet = FALSE;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        CFONT * pcf;
        TMW_INTERNAL tmw;

        ASSERTGDI(pDcAttr->hlfntNew,"GetTextMetricsW - hf is NULL\n");

        ENTERCRITICALSECTION(&semLocal);

        pcf = pcfLocateCFONT(hdc,pDcAttr,0,(PVOID)NULL,0, TRUE);

        bRet = bGetTextMetricsWInternal(hdc,&tmw,sizeof(tmw),pcf);

        // pcfLocateCFONT added a reference so now we need to remove it

        if (pcf)
        {
            DEC_CFONT_REF(pcf);
        }

        LEAVECRITICALSECTION(&semLocal);

        if (bRet)
        {
            vTextMetricWToTextMetric(ptm, &tmw);
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
*
* BOOL APIENTRY GetTextMetricsW(HDC hdc,LPTEXTMETRICW ptmw)
*
* History:
*  21-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetTextMetricsW(HDC hdc,LPTEXTMETRICW ptmw)
{
    PDC_ATTR    pDcAttr;
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);
    if (pDcAttr)
    {
        CFONT * pcf;

        ASSERTGDI(pDcAttr->hlfntNew,"GetTextMetricsW - hf is NULL\n");

        ENTERCRITICALSECTION(&semLocal);

        pcf = pcfLocateCFONT(hdc,pDcAttr,0,(PVOID) NULL,0, TRUE);

        bRet = bGetTextMetricsWInternal(hdc,(TMW_INTERNAL *)ptmw,sizeof(TEXTMETRICW),pcf);

        // pcfLocateCFONT added a reference so now we need to remove it

        if (pcf)
        {
            DEC_CFONT_REF(pcf);
        }

        LEAVECRITICALSECTION(&semLocal);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
*
* BOOL APIENTRY GetTextMetricsW(HDC hdc,LPTEXTMETRICW ptmw)
*
* History:
*  21-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bGetTextMetricsWInternal(
    HDC hdc,
    TMW_INTERNAL *ptmw,
    int cjTM,
    CFONT *pcf
    )
{
    BOOL bRet = FALSE;

    if (ptmw)
    {
        // if no pcf or we havn't cached the metrics

        if ((pcf == NULL) || !(pcf->fl & CFONT_CACHED_METRICS))
        {
            TMW_INTERNAL tmw;
            PDC_ATTR    pDcAttr;

            PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

            bRet = NtGdiGetTextMetricsW(hdc,&tmw,sizeof(tmw));

            if (bRet)
            {
                memcpy(ptmw,&tmw,cjTM);

                if (pcf)
                {
                    // we succeeded and we have a pcf so cache the data

                    pcf->tmw = tmw;

                    pcf->fl |= CFONT_CACHED_METRICS;
                }
            }
        }
        else
        {
            memcpy(ptmw,&pcf->tmw,cjTM);
            bRet  = TRUE;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GetTextExtentPoint32A (hdc,psz,c,psizl)                                  *
* GetTextExtentPointA   (hdc,psz,c,psizl)                                  *
*                                                                          *
* Computes the text extent.  The new 32 bit version returns the "correct"  *
* extent without an extra per for bitmap simulations.  The other is        *
* Windows 3.1 compatible.  Both just set a flag and pass the call to       *
* bGetTextExtentA.                                                         *
*                                                                          *
* History:                                                                 *
*  Thu 14-Jan-1993 04:11:26 -by- Charles Whitmer [chuckwh]                 *
* Added code to compute it on the client side.                             *
*                                                                          *
*  07-Aug-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/

// not in kernel, it is ok to do this much on the stack:
#define CAPTURE_STRING_SIZE 130

BOOL GetTextExtentPointAInternal(HDC hdc,LPCSTR psz,int c,LPSIZE psizl, FLONG fl)
{
    CFONT       *pcf;
    INT         bRet;
    PWSZ        pwszCapt;
    PDC_ATTR    pDcAttr;
    DWORD       dwCP;
    WCHAR awcCaptureBuffer[CAPTURE_STRING_SIZE];

    FIXUP_HANDLE(hdc);

    if (c <= 0)
    {
    // empty string, just return 0 for the extent

        if (c == 0)
        {
            psizl->cx = 0;
            psizl->cy = 0;
            bRet = TRUE;
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            bRet = FALSE;
        }
        return(bRet);
    }

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);
    if (!pDcAttr)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
        return(bRet);
    }

    dwCP = GET_CODE_PAGE(hdc, pDcAttr);

    if(guintDBCScp == dwCP)
    {
        QueryFontAssocStatus();

        if(fFontAssocStatus &&
           ((c == 1) || ((c == 2 && *(psz) && *((LPCSTR)(psz + 1)) == '\0'))))
        {
        //
        // If this function is called with only 1 char, and font association
        // is enabled, we should forcely convert the chars to Unicode with
        // codepage 1252.
        // This is for enabling to output Latin-1 chars ( > 0x80 in Ansi codepage )
        // Because, normally font association is enabled, we have no way to output
        // those charactres, then we provide the way, if user call TextOutA() with
        // A character and ansi font, we tempotary disable font association.
        // This might be Windows 3.1 (Korean/Taiwanese) version compatibility..
        //
            dwCP = 1252;
        }
    }


    if((dwCP == CP_ACP)     ||
       (dwCP == guintAcp)   ||
       (dwCP == guintDBCScp)
      )
    {
#ifdef LANGPACK
        if (!gbLpk || (*fpLpkUseGDIWidthCache)(hdc, psz, c, pDcAttr->lTextAlign , FALSE))
        {
#endif
            ENTERCRITICALSECTION(&semLocal);

            pcf = pcfLocateCFONT(hdc,pDcAttr,0,(PVOID)psz,c,TRUE);
            if (pcf != NULL)
            {
                BOOL bExit = TRUE;

                if(dwCP == guintDBCScp)
                {
                    if (pcf->wd.sDBCSInc) // dbcs fixed pitch base font
                    {
                        bRet = bComputeTextExtentDBCS(pDcAttr,pcf,psz,c,fl,psizl);
                    }
                    else if (!bIsDBCSString(psz,c))
                    {
                    // linked case, base font is a latin font, but linked font
                    // perhaps is a FE font. We know that base font is a latin font
                    // because for FE proportional fonts we would never create pcf.
                    // We are looking for this special case when the application asked
                    // for Latin Face Name in the logfont, and a FE charset, but the string
                    // passed in lackily does not contain DBCS glyphs.

                        bRet = bComputeTextExtent(pDcAttr,pcf,(PVOID) psz,c,fl,psizl,TRUE);
                    }
                    else
                    {
                        bExit = FALSE;
                    }
                }
                else
                {
                    bRet = bComputeTextExtent(pDcAttr,pcf,(PVOID) psz,c,fl,psizl,TRUE);
                }

                DEC_CFONT_REF(pcf);

                if(bExit)
                {
                    LEAVECRITICALSECTION(&semLocal);
                    return(bRet);
                }
            }

            LEAVECRITICALSECTION(&semLocal);
#ifdef LANGPACK
        }
#endif
    }

// Allocate the string buffer

    if (c <= CAPTURE_STRING_SIZE)
    {
        pwszCapt = awcCaptureBuffer;
    }
    else
    {
        pwszCapt = LOCALALLOC(c * sizeof(WCHAR));
    }

    if (pwszCapt)
    {

        c = MultiByteToWideChar(dwCP, 0, psz,c, pwszCapt, c*sizeof(WCHAR));

        if (c)
        {
#ifdef LANGPACK
            if(gbLpk)
            {
                bRet = (*fpLpkGetTextExtentExPoint)(hdc, pwszCapt, c, -1, NULL, NULL,
                                                    psizl, fl, 0);
            }
            else
#endif
            bRet = NtGdiGetTextExtent(hdc,
                                     (LPWSTR)pwszCapt,
                                     c,
                                     psizl,
                                     fl);
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            bRet = FALSE;
        }

        if (pwszCapt != awcCaptureBuffer)
            LOCALFREE(pwszCapt);
    }
    else
    {
        GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        bRet = FALSE;
    }

    return(bRet);
}

BOOL APIENTRY GetTextExtentPointA(HDC hdc,LPCSTR psz,int c,LPSIZE psizl)
{
    return GetTextExtentPointAInternal(hdc,psz,c,psizl,GGTE_WIN3_EXTENT);
}


BOOL APIENTRY GetTextExtentPoint32A(HDC hdc,LPCSTR psz,int c,LPSIZE psizl)
{
    return GetTextExtentPointAInternal(hdc,psz,c,psizl,0);
}


/******************************Public*Routine******************************\
*
* DWORD WINAPI GetCharacterPlacementA
*
* Effects:
*
* Warnings:
*
* History:
*  27-Jul-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



DWORD WINAPI GetCharacterPlacementA
(
    HDC     hdc,
    LPCSTR  psz,
    int     nCount,
    int     nMaxExtent,
    LPGCP_RESULTSA   pgcpa,
    DWORD   dwFlags
)
{
#define GCP_GLYPHS 80

    WCHAR       *pwsz = NULL;
    WCHAR        awc[GCP_GLYPHS];
    GCP_RESULTSW gcpw;
    DWORD        dwRet;
    BOOL         bOk = TRUE;
    int          nBuffer;
    SIZE         size;
    DWORD        dwCP;

    FIXUP_HANDLE(hdc);

    size.cx = size.cy = 0;

// nMaxExtent == -1 means that there is no MaxExtent

    if (!psz || (nCount <= 0) || ((nMaxExtent < 0) && (nMaxExtent != -1)))
    {
        WARNING("gdi!_GetCharactherPlacementA, bad parameters \n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    if (!pgcpa)
    {
    // just call GetTextExtentA, can usually be done on the client side

        if (!GetTextExtentPointA(hdc, psz, nCount, &size))
        {
            WARNING("GetCharacterPlacementW, GetTextExtentPointA failed\n");
            return 0;
        }

    // now backwards compatible win95 hack, chop off 32 bit values to 16 bits

        return (DWORD)((USHORT)size.cx) | (DWORD)(size.cy << 16);
    }

// chop off nCount, win95 does it

    if (nCount > (int)pgcpa->nGlyphs)
        nCount = (int)pgcpa->nGlyphs;

// unicode string buffer will at least be this many WCHAR's long:

    nBuffer = nCount;

// now go on to compute the size of the GCP_RESULTSW that is required
// to receive the results. If lpOutString is not NULL the structures
// will have different pointers else they will be the same.

    gcpw.lpOrder    = pgcpa->lpOrder   ;
    gcpw.lpDx       = pgcpa->lpDx      ;
    gcpw.lpCaretPos = pgcpa->lpCaretPos;
    gcpw.lpClass    = pgcpa->lpClass   ;
    gcpw.lpGlyphs   = pgcpa->lpGlyphs  ;
    gcpw.nGlyphs    = pgcpa->nGlyphs   ;
    gcpw.nMaxFit    = pgcpa->nMaxFit   ;

    if (pgcpa->lpOutString)
    {
        nBuffer += nBuffer; // take into account space for gcpw.lpOutString
    }
    else
    {
        gcpw.lpOutString = NULL;
        gcpw.lStructSize = pgcpa->lStructSize;
    }

// now allocate memory (if needed) for the unicode string and for
// gcpw.lpOutString if needed.

    if (nBuffer <= GCP_GLYPHS)
        pwsz = awc;
    else
        pwsz = LOCALALLOC(nBuffer * sizeof(WCHAR));

    if (pwsz)
    {
        if (pgcpa->lpOutString)
        {
            gcpw.lpOutString = &pwsz[nCount];

        // we have replaced the ansi string by unicode string, this adds
        // nCount bytes to the size of the structure.

            gcpw.lStructSize = pgcpa->lStructSize + nCount;
        }

    // convert Ansi To Unicode based on the code page of the font selected in DC

        if
        (
            gcpw.nGlyphs = MultiByteToWideChar((dwCP = GetCodePage(hdc)), 0,
                                psz, nCount,
                                pwsz, nCount*sizeof(WCHAR))
        )
        {

        // If this is a DBCS font then we need to patch up the DX array since
        // there will be two DX values for each DBCS character.  It is okay
        // to do this in place since GetCharacterPlacement modifies the DX
        // array anyway.

            if((dwFlags & GCP_JUSTIFYIN) &&
               (gcpw.lpDx) &&
               IS_ANY_DBCS_CODEPAGE(dwCP))
            {
                INT *pDxNew, *pDxOld;
                const char *pDBCSString;

                for(pDxNew = pDxOld = gcpw.lpDx, pDBCSString = psz;
                    pDBCSString < psz + nCount;
                    pDBCSString++
                    )
                {
                    if(IsDBCSLeadByteEx(dwCP,*pDBCSString))
                    {
                        pDBCSString++;
                        pDxOld++;
                    }
                    *pDxNew++ = *pDxOld++;
                }
            }

#ifdef LANGPACK
             if (gbLpk)
             {
                 // If the LPK is loaded then pass the caller nGlyphs because it may generate
                 // Glyphs more than nCount.
                 gcpw.nGlyphs = pgcpa->nGlyphs;
                 dwRet = (*fpLpkGetCharacterPlacement)(hdc, pwsz, nCount,nMaxExtent,
                                                        &gcpw, dwFlags, 0);
             }
             else
#endif
             {
                 dwRet = NtGdiGetCharacterPlacementW(hdc,pwsz,nCount,nMaxExtent,
                                                 &gcpw, dwFlags);
             }


            if (dwRet)
            {
            // copy out the data.... we use the original value of nCount
            // when specifying an output buffer size for the lpOutString buffer
            // since nCount on return will be Unicode character count which
            // may not be the same as DBCS character count

                int nOriginalCount = nCount;

                pgcpa->nGlyphs = nCount = gcpw.nGlyphs;
                pgcpa->nMaxFit = gcpw.nMaxFit;
                if (pgcpa->lpOutString)
                {
                    if
                    (
                        !WideCharToMultiByte(
                             (UINT)dwCP,            // UINT CodePage
                             0,                     // DWORD dwFlags
                             gcpw.lpOutString,      // LPWSTR lpWideCharStr
                             gcpw.nMaxFit,          // int cchWideChar
                             pgcpa->lpOutString,    // LPSTR lpMultiByteStr
                             nOriginalCount,        // int cchMultiByte
                             NULL,                  // LPSTR lpDefaultChar
                             NULL)                  // LPBOOL lpUsedDefaultChar
                    )
                    {
                        bOk = FALSE;
                    }
                }
            }
            else
            {
                bOk = FALSE;
            }
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            bOk = FALSE;
        }

        if (pwsz != awc)
            LOCALFREE(pwsz);
    }
    else
    {
        bOk = FALSE;
    }

    return (bOk ? dwRet : 0);
}

/******************************Public*Routine******************************\
*
* DWORD WINAPI GetCharacterPlacementW
* look at gdi32.def, just points to NtGdiGetCharacterPlacementW
*
* History:
*  26-Jul-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


#if LANGPACK

DWORD WINAPI GetCharacterPlacementW
(
    HDC     hdc,
    LPCWSTR pwsz,
    int     nCount,
    int     nMaxExtent,
    LPGCP_RESULTSW   pgcpw,
    DWORD   dwFlags
)
{
    SIZE         size;

    FIXUP_HANDLE(hdc);

    size.cx = size.cy = 0;

    // nMaxExtent == -1 means that there is no MaxExtent

    if (!pwsz || (nCount <= 0) || ((nMaxExtent < 0) && (nMaxExtent != -1)))
    {
       WARNING("gdi!_GetCharactherPlacementW, bad parameters \n");
       GdiSetLastError(ERROR_INVALID_PARAMETER);
       return 0;
    }

    if (!pgcpw)
    {
    // just call GetTextExtentW, can usually be done on the client side

       if (!GetTextExtentPointW(hdc, pwsz, nCount, &size))
       {
           WARNING("GetCharacterPlacementW, GetTextExtentPointW failed\n");
           return 0;
       }

    // now backwards compatible win95 hack, chop off 32 bit values to 16 bits

       return (DWORD)((USHORT)size.cx) | (DWORD)(size.cy << 16);
    }

// chop off nCount, win95 does it

    if (nCount > (int)pgcpw->nGlyphs)
        nCount = (int)pgcpw->nGlyphs;

    if(gbLpk)
    {
        return((*fpLpkGetCharacterPlacement)(hdc,pwsz,nCount,nMaxExtent,pgcpw,
                                             dwFlags,-1));
    }
    else
    {

        return  NtGdiGetCharacterPlacementW(hdc,
                                            (LPWSTR) pwsz,
                                            nCount,
                                            nMaxExtent,
                                            pgcpw,
                                            dwFlags);
    }
}

#endif


/******************************Public*Routine******************************\
* BOOL bGetCharWidthA                                                      *
*                                                                          *
* Client side stub for the various GetCharWidth*A functions.               *
*                                                                          *
* History:                                                                 *
*  Sat 16-Jan-1993 03:08:42 -by- Charles Whitmer [chuckwh]                 *
* Added code to do it on the client side.                                  *
*                                                                          *
*  28-Aug-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/

#define GCW_WIN3_INT   (GCW_WIN3 | GCW_INT)
#define GCW_WIN3_16INT (GCW_WIN3 | GCW_INT | GCW_16BIT)

#define GCW_SIZE(fl)          ((fl >> 16) & 0xffff)
#define GCWFL(fltype,szType)  (fltype | (sizeof(szType) << 16))

BOOL bGetCharWidthA
(
    HDC   hdc,
    UINT  iFirst,
    UINT  iLast,
    ULONG fl,
    PVOID pvBuf
)
{
    PDC_ATTR    pDcAttr;
    LONG        cwc;
    CFONT      *pcf = NULL;
    PUCHAR      pch;
    PWCHAR      pwc;
    BOOL        bRet = FALSE;
    ULONG       cjWidths;
    DWORD       dwCP;
    BOOL        bDBCSCodePage;
    WCHAR       awc[MAX_PATH];
    PVOID       pvResultBuffer;


    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (!pDcAttr)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    dwCP = GET_CODE_PAGE(hdc, pDcAttr);

    bDBCSCodePage = IS_ANY_DBCS_CODEPAGE(dwCP);

// do parameter validation, check that in chars are indeed ascii


    if ((bDBCSCodePage && !IsValidDBCSRange(iFirst,iLast)) ||
        (!bDBCSCodePage &&
         ((iFirst > iLast) || (iLast & 0xffffff00))) ||
        (pvBuf == NULL))
    {
        WARNING("gdi!_bGetCharWidthA parameters \n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(bRet);
    }
    cwc = (LONG)(iLast - iFirst + 1);

    ENTERCRITICALSECTION(&semLocal);

    if ((dwCP == CP_ACP) ||
        (dwCP == guintAcp)
        || (dwCP == guintDBCScp)
    )

    {
        pcf = pcfLocateCFONT(hdc,pDcAttr,iFirst,(PVOID) NULL,(UINT) cwc, TRUE);
    }

    if (pcf != (CFONT *) NULL)
    {
        BOOL bExit = TRUE;

        if(dwCP == guintDBCScp)
        {
            if (pcf->wd.sDBCSInc) // dbcs fixed pitch base font
            {
                bRet = bComputeCharWidthsDBCS (pcf,iFirst,iLast,fl,pvBuf);
            }
            else if (iLast < 0x80)
            {
                // linked case, base font is a latin font, but linked font
                // perhaps is a FE font. We know that base font is a latin font
                // because for FE proportional fonts we would never create pcf.
                // We are looking for this special case when the application asked
                // for Latin Face Name in the logfont, and a FE charset, but the string
                // passed in lackily does not contain DBCS glyphs.

                bRet = bComputeCharWidths(pcf,iFirst,iLast,fl,pvBuf);
            }
            else
            {
                bExit = FALSE;
            }
        }
        else
        {
            bRet = bComputeCharWidths(pcf,iFirst,iLast,fl,pvBuf);
        }

        DEC_CFONT_REF(pcf);

        if(bExit)
        {
            LEAVECRITICALSECTION(&semLocal);
            return(bRet);
        }
    }

    LEAVECRITICALSECTION(&semLocal);

    // Let the server do it.

    cjWidths = cwc * GCW_SIZE(fl);

    //
    // Non kernel mode call
    //

    // What if user's buffer is set up for 16 bit return?? Then we need
    // to allocate buffer for 32 bit date and convert to user's buffer after
    // the call

    pvResultBuffer = pvBuf;


    if (fl & GCW_16BIT)
    {
        // User's buffer is 16 bit, make 32 a bit
        // temp buffer

        pvResultBuffer = LOCALALLOC(cwc * sizeof(LONG));
    
        if (pvResultBuffer == NULL) {
            GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(bRet);
        }
    }

    // Kernel mode, use users buffer for return data
    // convert to unicode

    if(bDBCSCodePage)
    {
        bRet = bSetUpUnicodeStringDBCS(iFirst,
                                        iLast,
                                        (PUCHAR) pvResultBuffer,
                                        awc,
                                        dwCP,
                                        GetCurrentDefaultChar(hdc));
    }
    else
    {
        bRet = bSetUpUnicodeString(iFirst,iLast,pvResultBuffer,awc,dwCP);
    }

    if(bRet)
    {
        bRet = NtGdiGetCharWidthW(hdc,
                                  0,
                                  cwc,
                                  awc,
                                  (LONG)(fl & (GCW_INT | GCW_WIN3)),
                                  pvResultBuffer);
    }

    if (bRet)
    {
    //
    // May need to convert to 16 bit user buffer
    //

        if (fl & GCW_16BIT)
        {

            PWORD   pw = pvBuf;
            PDWORD  pi = (int *)pvResultBuffer;
            PDWORD  piEnd = pi + cwc;

            ASSERTGDI(pvResultBuffer != pvBuf, "Local buffer not allocated properly");

            while (pi != piEnd)
            {
                *pw++ = (WORD)(*pi++);
            }

            LOCALFREE(pvResultBuffer);

        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
*
* BOOL APIENTRY GetCharWidthA
*
* History:
*  25-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetCharWidthA
(
IN  HDC   hdc,
IN  UINT  iFirst,
IN  UINT  iLast,
OUT LPINT lpWidths
)
{
    FIXUP_HANDLE(hdc);
    return bGetCharWidthA(hdc,iFirst,iLast,GCWFL(GCW_WIN3_INT,int),(PVOID)lpWidths);
}

BOOL APIENTRY GetCharWidth32A
(
IN  HDC   hdc,
IN  UINT  iFirst,
IN  UINT  iLast,
OUT LPINT lpWidths
)
{
    FIXUP_HANDLE(hdc);

    return bGetCharWidthA(hdc,iFirst,iLast,GCWFL(GCW_INT,int),(PVOID)lpWidths);
}

/******************************Public*Routine******************************\
*
* GetCharWidthFloatA
*
* History:
*  22-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetCharWidthFloatA
(
IN  HDC    hdc,
IN  UINT   iFirst,
IN  UINT   iLast,
OUT PFLOAT lpWidths
)
{
    FIXUP_HANDLE(hdc);
    return bGetCharWidthA(hdc,iFirst,iLast,GCWFL(0,FLOAT),(PVOID)lpWidths);
}

/******************************Public*Routine******************************\
*
* BOOL bGetCharWidthW
*
* GetCharWidthW and GetCharWidthFloatW
*
* History:
*  28-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bGetCharWidthW
(
HDC   hdc,
UINT  iFirst,     // unicode value
UINT  iLast,      // unicode value
ULONG fl,
PVOID pvBuf
)
{
    LONG        cwc;
    BOOL        bRet = FALSE;

// do parameter validation, check that in chars are indeed unicode

    if ((pvBuf == (PVOID)NULL) || (iFirst > iLast) || (iLast & 0xffff0000))
    {
        WARNING("gdi!_bGetCharWidthW parameters \n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    cwc = (LONG)(iLast - iFirst + 1);

    if(iLast < 0x80)
    {
        CFONT       *pcf = NULL;
        PDC_ATTR    pDcAttr;
        DWORD       dwCP;

        PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

        if (!pDcAttr)
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }

        dwCP = GET_CODE_PAGE(hdc, pDcAttr);

        ENTERCRITICALSECTION(&semLocal);

        if ((dwCP == CP_ACP) ||
            (dwCP == guintAcp)
            || (dwCP == guintDBCScp)
        )

        {
            pcf = pcfLocateCFONT(hdc,pDcAttr,iFirst,(PVOID) NULL,(UINT) cwc, TRUE);
        }

        if (pcf != NULL)
        {
            bRet = bComputeCharWidths(pcf,iFirst,iLast,fl,pvBuf);

            DEC_CFONT_REF(pcf);

            if(bRet)
            {
                LEAVECRITICALSECTION(&semLocal);
                return (bRet);
            }
        }

        LEAVECRITICALSECTION(&semLocal);
    }

    //
    // kernel mode
    //

    bRet = NtGdiGetCharWidthW(
                hdc,
                iFirst,
                cwc,
                NULL,
                (LONG)(fl & (GCW_INT | GCW_WIN3)),
                pvBuf);

    return(bRet);

}

/******************************Public*Routine******************************\
*
* BOOL APIENTRY GetCharWidthFloatW
*
* History:
*  22-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetCharWidthFloatW
(
HDC    hdc,
UINT   iFirst,
UINT   iLast,
PFLOAT lpWidths
)
{
    FIXUP_HANDLE(hdc);
    return bGetCharWidthW(hdc,iFirst,iLast,0,(PVOID)lpWidths);
}

/******************************Public*Routine******************************\
*
* BOOL APIENTRY GetCharWidthW
*
* History:
*  25-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetCharWidthW
(
HDC    hdc,
UINT   iFirst,
UINT   iLast,
LPINT  lpWidths
)
{
    FIXUP_HANDLE(hdc);
    return bGetCharWidthW(hdc,iFirst,iLast,GCW_WIN3_INT,(PVOID)lpWidths);
}

BOOL APIENTRY GetCharWidth32W
(
HDC    hdc,
UINT   iFirst,
UINT   iLast,
LPINT  lpWidths
)
{
    FIXUP_HANDLE(hdc);
    return bGetCharWidthW(hdc,iFirst,iLast,GCW_INT,(PVOID)lpWidths);
}


/******************************Public*Routine******************************\
*
* WINGDIAPI BOOL  WINAPI GetCharWidthI(HDC, UINT, UINT, PWCHAR, LPINT);
*
* if pgi == NULL use the consecutive range
*   giFirst, giFirst + 1, ...., giFirst + cgi - 1
*
* if pgi != NULL ignore giFirst and use cgi indices pointed to by pgi
*
* History:
*  28-Aug-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL  WINAPI GetCharWidthI(
    HDC    hdc,
    UINT   giFirst,
    UINT   cgi,
    LPWORD pgi,
    LPINT  piWidths
)
{
    BOOL   bRet = FALSE;

// do parameter validation

    if (!piWidths || (!pgi && (giFirst & 0xffff0000)))
    {
        WARNING("gdi! GetCharWidthI parameters \n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    if (!cgi)
        return TRUE; // quick exit

// kernel mode

    bRet = NtGdiGetCharWidthW(
                hdc,
                giFirst,
                cgi,
                (PWCHAR)pgi,
                (GCW_INT | GCW_GLYPH_INDEX),
                (PVOID)piWidths);

    return bRet;
}




/******************************Public*Routine******************************\
*
* BOOL APIENTRY GetTextExtentPointW(HDC hdc,LPWSTR pwsz,DWORD cwc,LPSIZE psizl)
*
*
* History:
*  07-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#define QUICK_BUFSIZE   0xFF

BOOL GetTextExtentPointWInternal(
         HDC hdc,LPCWSTR pwsz,int cwc,LPSIZE psizl, FLONG fl
         )
{
    WCHAR       *pwc;
    CFONT       *pcf;
    INT         bRet;
    PDC_ATTR    pDcAttr;
    BOOL        bCache;
    INT         i;
    WCHAR       wcTest = 0;
    int         ii = cwc;

    FIXUP_HANDLE(hdc);

    if (cwc <= 0)
    {

    // empty string, just return 0 for the extent

        if (cwc == 0)
        {
            psizl->cx = 0;
            psizl->cy = 0;
            return(TRUE);
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }
    }

    // Let's see if we can take advantage of the ANSI client side GetTextExtent
    // code.  If we can convert everything from Unicode to ANSI by ignoring the
    // high byte and it fits into our quick buffer then we can.  In the future
    // we will probably want to do a quick Unicode to ANSI conversion using
    // something other than sign extension so we don't mess up non 1252 CP locales
    // by making them go through the slow code all the time.

    // We need to use this performance optimization if an LPK is installed
    // and some condiditions are met (LTR text alignment, ..etc)

    pwc = (WCHAR *) pwsz;

    unroll_here:
    switch(ii)
    {
        default:
            wcTest |= pwc[9];
        case 9:
            wcTest |= pwc[8];
        case 8:
            wcTest |= pwc[7];
        case 7:
            wcTest |= pwc[6];
        case 6:
            wcTest |= pwc[5];
        case 5:
            wcTest |= pwc[4];
        case 4:
            wcTest |= pwc[3];
        case 3:
            wcTest |= pwc[2];
        case 2:
            wcTest |= pwc[1];
        case 1:
            wcTest |= pwc[0];
    }

    if ((ii > 10) && !(wcTest & 0xFF80))
    {
        ii -= 10;
        pwc += 10;
        goto unroll_here;
    }

    if (!(wcTest & 0xFF80))
    {
        PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);
        if (!pDcAttr)
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }
#ifdef LANGPACK
        if (!gbLpk || (*fpLpkUseGDIWidthCache)(hdc, (LPCSTR) pwsz,cwc, pDcAttr->lTextAlign , TRUE)) {
#endif

        ENTERCRITICALSECTION(&semLocal);

        pcf = pcfLocateCFONT(hdc,pDcAttr,0,(PVOID)pwsz,cwc, FALSE);

        if (pcf != NULL)
        {
            bRet = bComputeTextExtent(pDcAttr,pcf,(PVOID) pwsz,cwc,fl,psizl,FALSE);

            DEC_CFONT_REF(pcf);

            if(bRet)
            {
                LEAVECRITICALSECTION(&semLocal);
                return (bRet);
            }
        }


        LEAVECRITICALSECTION(&semLocal);
#ifdef LANGPACK
       }
#endif
    }

#ifdef LANGPACK
    if(gbLpk)
    {
        return(*fpLpkGetTextExtentExPoint)(hdc, pwsz, cwc, -1, NULL, NULL,
                                           psizl, fl, -1);
    }
#endif

    return NtGdiGetTextExtent(hdc,
                              (LPWSTR)pwsz,
                              cwc,
                              psizl,
                              fl);

}


BOOL APIENTRY GetTextExtentPointW(HDC hdc,LPCWSTR pwsz,int cwc,LPSIZE psizl)
{
    return GetTextExtentPointWInternal(hdc, pwsz, cwc, psizl, GGTE_WIN3_EXTENT);
}


BOOL APIENTRY GetTextExtentPoint32W(HDC hdc,LPCWSTR pwsz,int cwc,LPSIZE psizl)
{
    return GetTextExtentPointWInternal(hdc, pwsz, cwc, psizl, 0);
}

/******************************Public*Routine******************************\
*
* GetTextExtentPointI, index version
*
* History:
*  28-Aug-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL  APIENTRY GetTextExtentPointI(HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize)
{
    return NtGdiGetTextExtent(hdc, (LPWSTR)pgiIn, cgi , psize, GGTE_GLYPH_INDEX);
}

/******************************Public*Routine******************************\
*
* GetFontUnicodeRanges(HDC, LPGLYPHSET)
*
* return Unicode content of the font.
*
* History:
*  28-Aug-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#if 0

DWORD WINAPI GetFontUnicodeRanges(HDC hdc, LPGLYPHSET pgs)
{
    return NtGdiGetFontUnicodeRanges(hdc, pgs);
}

#endif

/******************************Public*Routine******************************\
*
* GetGlyphIndicesA(HDC, LPCSTR, int, LPWORD, DWORD mode);
*
* cmap based conversion, if (mode) indicate that glyph is not supported in the
* font by putting FFFF in the output array
*
* If successfull, the function returns the number of indicies in pgi buffer.
*
* History:
*  28-Aug-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

DWORD WINAPI GetGlyphIndicesA(
    HDC    hdc,
    LPCSTR psz,
    int    c,
    LPWORD pgi,
    DWORD  iMode)
{
    DWORD       dwRet = GDI_ERROR;
    PWSZ        pwszCapt;
    PDC_ATTR    pDcAttr;
    DWORD       dwCP;
    WCHAR awcCaptureBuffer[CAPTURE_STRING_SIZE];

    FIXUP_HANDLE(hdc);

    if (c <= 0)
    {
    // empty string, just return 0 for the extent

        if (c == 0)
        {
            dwRet = 0;
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            dwRet = GDI_ERROR;
        }
        return(dwRet);
    }

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);
    if (!pDcAttr)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        dwRet = GDI_ERROR;
        return dwRet;
    }

    dwCP = GET_CODE_PAGE(hdc, pDcAttr);

    if(guintDBCScp == dwCP)
    {
        QueryFontAssocStatus();

        if(fFontAssocStatus &&
           ((c == 1) || ((c == 2 && *(psz) && *((LPCSTR)(psz + 1)) == '\0'))))
        {
        //
        // If this function is called with only 1 char, and font association
        // is enabled, we should forcely convert the chars to Unicode with
        // codepage 1252.
        // This is for enabling to output Latin-1 chars ( > 0x80 in Ansi codepage )
        // Because, normally font association is enabled, we have no way to output
        // those charactres, then we provide the way, if user call TextOutA() with
        // A character and ansi font, we tempotary disable font association.
        // This might be Windows 3.1 (Korean/Taiwanese) version compatibility..
        //
            dwCP = 1252;
        }
    }

// Allocate the string buffer

    if (c <= CAPTURE_STRING_SIZE)
    {
        pwszCapt = awcCaptureBuffer;
    }
    else
    {
        pwszCapt = LOCALALLOC(c * sizeof(WCHAR));
    }

    if (pwszCapt)
    {

        c = MultiByteToWideChar(dwCP, 0, psz,c, pwszCapt, c*sizeof(WCHAR));

        if (c)
        {
            dwRet =  NtGdiGetGlyphIndicesW(hdc,
                                      (LPWSTR)pwszCapt,
                                      c,
                                      pgi,
                                      iMode);
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            dwRet = GDI_ERROR;
        }

        if (pwszCapt != awcCaptureBuffer)
            LOCALFREE(pwszCapt);
    }
    else
    {
        GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        dwRet = GDI_ERROR;
    }

    return dwRet;
}

/******************************Public*Routine******************************\
*
* GetGlyphIndicesW(HDC, LPCSTR, int, LPWORD, DWORD);
*
* cmap based conversion, if (mode) indicate that glyph is not supported in the
* font by putting FFFF in the output array
*
* History:
*  28-Aug-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#if 0

DWORD WINAPI GetGlyphIndicesW(
    HDC     hdc,
    LPCWSTR pwc,
    int     cwc,
    LPWORD  pgi,
    DWORD   iMode)
{
    return NtGdiGetGlyphIndicesW(hdc, pwc, cwc, pgi, iMode);
}

#endif

/******************************Public*Routine******************************\
*
* int APIENTRY GetTextFaceA(HDC hdc,int c,LPSTR psz)
*
* History:
*  30-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

int APIENTRY GetTextFaceA(HDC hdc,int c,LPSTR psz)
{
    ULONG cRet = 0;
    ULONG cbAnsi = 0;

    FIXUP_HANDLE(hdc);

    if ( (psz != (LPSTR) NULL) && (c <= 0) ) 
    {
        WARNING("gdi!GetTextFaceA(): invalid parameter\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return cRet;
    }

    {
        //
        // Kernel mode, allocate a buffer for WCAHR return
        //
        // WINBUG #82833 2-7-2000 bhouse Possible cleanup work in GetTextFaceA
        // Old Comment:
        //    - This allocates a temp buffer, then NtGdi does it again
        //

        PWCHAR pwch = (PWCHAR)NULL;

        if (c > 0)
        {
            pwch = (WCHAR *)LOCALALLOC(c * sizeof(WCHAR));
            if (pwch == (WCHAR *)NULL)
            {
                WARNING("gdi!GetTextFaceA(): Memory allocation error\n");
                cRet = 0;
                return(cRet);
            }
        }

        cRet = NtGdiGetTextFaceW(hdc,c,(LPWSTR)pwch,FALSE);

        if(cRet && (guintDBCScp != 0xFFFFFFFF) && !psz )
        {
            WCHAR *pwcTmp;

        // now we need to actually need to get the string for DBCS code pages
        // so that we can compute the proper multi-byte length

            if(pwcTmp = (WCHAR*)LOCALALLOC(cRet*sizeof(WCHAR)))
            {
                UINT cwTmp;

                cwTmp = NtGdiGetTextFaceW(hdc,cRet,pwcTmp, FALSE);

                RtlUnicodeToMultiByteSize(&cbAnsi,pwcTmp,cwTmp*sizeof(WCHAR));
                LOCALFREE(pwcTmp);
            }
            else
            {
                WARNING("gdi!GetTextFaceA(): UNICODE to ANSI conversion failed\n");
                cRet = 0;
            }
        }
        else
        {
            cbAnsi = cRet;
        }

        //
        // If successful and non-NULL buffer, convert back to ANSI.
        //

        if ( (cRet != 0) && (psz != (LPSTR) NULL) && (pwch != (WCHAR*)NULL))
        {

            if(!(cbAnsi = WideCharToMultiByte(CP_ACP,0,pwch,cRet,psz,c,NULL,NULL)))
            {
                WARNING("gdi!GetTextFaceA(): UNICODE to ANSI conversion failed\n");
                cRet = 0;
            }
        }

        if (pwch != (PWCHAR)NULL)
        {
            LOCALFREE(pwch);
        }

    }


    //
    // return for user and kernel mode
    //

    return( ((cRet == 0 ) || (psz == NULL) || psz[cbAnsi-1] != 0 ) ? cbAnsi : cbAnsi-1 );

}

/******************************Public*Routine******************************\
*
* DWORD APIENTRY GetTextFaceAliasW(HDC hdc,DWORD c,LPWSTR pwsz)
*
* History:
*  24-Feb-1998 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

int APIENTRY GetTextFaceAliasW(HDC hdc,int c,LPWSTR pwsz)
{
    int cRet = 0;

    FIXUP_HANDLE(hdc);

    if ( (pwsz != (LPWSTR) NULL) && (c == 0) )
    {
        WARNING("gdi!GetTextFaceAliasW(): invalid parameter\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return cRet;
    }

    cRet = NtGdiGetTextFaceW(hdc,c,pwsz,TRUE);

    return(cRet);
}


/******************************Public*Routine******************************\
*
* DWORD APIENTRY GetTextFaceW(HDC hdc,DWORD c,LPWSTR pwsz)
*
* History:
*  13-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

int APIENTRY GetTextFaceW(HDC hdc,int c,LPWSTR pwsz)
{
    int cRet = 0;

    FIXUP_HANDLE(hdc);

    if ( (pwsz != (LPWSTR) NULL) && (c <= 0) )
    {
        WARNING("gdi!GetTextFaceW(): invalid parameter\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return cRet;
    }

    cRet = NtGdiGetTextFaceW(hdc,c,pwsz,FALSE);

    return(cRet);
}

/******************************Public*Routine******************************\
*
* vTextMetricWToTextMetricStrict (no char conversion)
*
* Effects: return FALSE if UNICODE chars have no ASCI equivalents
*
*
* History:
*  20-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID FASTCALL vTextMetricWToTextMetricStrict
(
LPTEXTMETRICA  ptm,
LPTEXTMETRICW  ptmw
)
{

    ptm->tmHeight           = ptmw->tmHeight             ; // DWORD
    ptm->tmAscent           = ptmw->tmAscent             ; // DWORD
    ptm->tmDescent          = ptmw->tmDescent            ; // DWORD
    ptm->tmInternalLeading  = ptmw->tmInternalLeading    ; // DWORD
    ptm->tmExternalLeading  = ptmw->tmExternalLeading    ; // DWORD
    ptm->tmAveCharWidth     = ptmw->tmAveCharWidth       ; // DWORD
    ptm->tmMaxCharWidth     = ptmw->tmMaxCharWidth       ; // DWORD
    ptm->tmWeight           = ptmw->tmWeight             ; // DWORD
    ptm->tmOverhang         = ptmw->tmOverhang           ; // DWORD
    ptm->tmDigitizedAspectX = ptmw->tmDigitizedAspectX   ; // DWORD
    ptm->tmDigitizedAspectY = ptmw->tmDigitizedAspectY   ; // DWORD
    ptm->tmItalic           = ptmw->tmItalic             ; // BYTE
    ptm->tmUnderlined       = ptmw->tmUnderlined         ; // BYTE
    ptm->tmStruckOut        = ptmw->tmStruckOut          ; // BYTE

    ptm->tmPitchAndFamily   = ptmw->tmPitchAndFamily     ; //        BYTE
    ptm->tmCharSet          = ptmw->tmCharSet            ; //               BYTE

}


VOID FASTCALL vTextMetricWToTextMetric
(
LPTEXTMETRICA  ptma,
TMW_INTERNAL   *ptmi
)
{
    vTextMetricWToTextMetricStrict(ptma,&ptmi->tmw);

    ptma->tmFirstChar    =  ptmi->tmdTmw.chFirst  ;
    ptma->tmLastChar     =  ptmi->tmdTmw.chLast   ;
    ptma->tmDefaultChar  =  ptmi->tmdTmw.chDefault;
    ptma->tmBreakChar    =  ptmi->tmdTmw.chBreak  ;
}


/******************************Public*Routine******************************\
* GetTextExtentExPointA
*
* History:
*  06-Jan-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetTextExtentExPointA (
    HDC     hdc,
    LPCSTR  lpszString,
    int     cchString,
    int     nMaxExtent,
    LPINT   lpnFit,
    LPINT   lpnDx,
    LPSIZE  lpSize
    )
{
    WCHAR       *pwsz = NULL;
    WCHAR        awc[GCP_GLYPHS];
    INT          aiDx[GCP_GLYPHS];
    INT          *pDx;
    BOOL         bRet = FALSE;
    DWORD        dwCP;
    BOOL		 bZeroSize = FALSE;

    FIXUP_HANDLE(hdc);

// some parameter checking. In a single check we will both make sure that
// cchString is not negative and if positive, that it is not bigger than
// ULONG_MAX / (sizeof(ULONG) + sizeof(WCHAR)). This restriction is necessary
// for one of the memory allocations in ntgdi.c allocates
//           cchString * (sizeof(ULONG) + sizeof(WCHAR)).
// Clearly, the result of this multiplication has to fit in ULONG for the
// alloc to make sense:

// also there is a validity check to be performed on nMaxExtent. -1 is the only
// legal negative value of nMaxExtent, this basically means
// that nMaxExtent can be ignored. All other negative values of nMaxExtent are
// not considered legal input.


    if
    (
        ((ULONG)cchString > (ULONG_MAX / (sizeof(ULONG)+sizeof(WCHAR))))
        ||
        (nMaxExtent < -1)
    )
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return bRet;
    }

    if(cchString == 0)
    	bZeroSize = TRUE;

// now allocate memory (if needed) for the unicode string if needed

    if (cchString <= GCP_GLYPHS)
    {
        pwsz = awc;
        pDx = aiDx;
    }
    else
    {
        pwsz = LOCALALLOC((cchString+1) * (sizeof(WCHAR) + sizeof(INT)));
        pDx = (INT*) &pwsz[(cchString+1)&~1];
    }


    if (pwsz)
    {
        UINT cwcWideChars;

    // convert Ansi To Unicode based on the code page of the font selected in DC

        dwCP = GetCodePage(hdc);
        if( bZeroSize || ( cwcWideChars = MultiByteToWideChar(dwCP,
                                              0,
                                              lpszString, cchString,
                                              pwsz, cchString*sizeof(WCHAR))) )
        {
            BOOL bDBCSFont = IS_ANY_DBCS_CODEPAGE(dwCP) ? TRUE : FALSE;

            if(bZeroSize){
            	cwcWideChars = 0;
            	pwsz[0] = (WCHAR) 0x0;
            }

#ifdef LANGPACK
            if(gbLpk)
            {
                bRet = (*fpLpkGetTextExtentExPoint)(hdc, pwsz, cwcWideChars, nMaxExtent,
                                                    lpnFit, bDBCSFont ? pDx : lpnDx,
                                                    lpSize, 0, 0);
            }
            else
#endif
            bRet = NtGdiGetTextExtentExW(hdc,
                                         pwsz,
                                         cwcWideChars,
                                         nMaxExtent,
                                         lpnFit,
                                         bDBCSFont ? pDx : lpnDx,
                                         lpSize,
                                         0);

            if (bDBCSFont && bRet)
            {
            // if this is a DBCS font then we need to make some adjustments

                int i, j;
                int cchFit, cwc;

            // first compute return the proper fit in multi byte characters

                if (lpnFit)
                {
                    cwc = *lpnFit;
                    cchFit = WideCharToMultiByte(dwCP, 0, pwsz, cwc, NULL, 0, NULL, NULL);
                    *lpnFit = cchFit;
                }
                else
                {
                    cwc = cwcWideChars;
                    cchFit = cchString;
                }

            // next copy the dx array.  we duplicate the dx value for the high
            // and low byte of DBCS characters.

                if(lpnDx)
                {
                    for(i = 0, j = 0; i < cchFit; j++)
                    {
                        if(IsDBCSLeadByteEx(dwCP,lpszString[i]))
                        {
                            lpnDx[i++] = pDx[j];
                            lpnDx[i++] = pDx[j];
                        }
                        else
                        {
                            lpnDx[i++] = pDx[j];
                        }
                    }

                // I claim that we should be at exactly at the end of the Unicode
                // string once we are here if not we need to examine the above loop
                // to make sure it works properly [gerritv]

                    ASSERTGDI(j == cwc,
                          "GetTextExtentExPointA: problem converting DX array\n");
                }
            }
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }

        if (pwsz != awc)
            LOCALFREE(pwsz);

    }

    return bRet;
}


/******************************Public*Routine******************************\
* GetTextExtentExPointW
*
* History:
*  06-Jan-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/


BOOL APIENTRY GetTextExtentExPointW (
    HDC     hdc,
    LPCWSTR lpwszString,
    int     cwchString,
    int     nMaxExtent,
    LPINT   lpnFit,
    LPINT   lpnDx,
    LPSIZE  lpSize
    )
{

#ifdef LANGPACK
    if(gbLpk)
    {
        return (*fpLpkGetTextExtentExPoint)(hdc, lpwszString, cwchString, nMaxExtent,
                                            lpnFit, lpnDx, lpSize, 0, -1);
    }
    else
#endif
    return NtGdiGetTextExtentExW(hdc,
                                (LPWSTR)lpwszString,
                                cwchString,
                                nMaxExtent,
                                lpnFit,
                                lpnDx,
                                lpSize,
                                0);

}


/******************************Public*Routine******************************\
*
*  GetTextExtentExPointWPri,
*  The same as  GetTextExtentExPointW, the only difference is that
*  lpk is bypassed, whether installed or not. This routine is actually called
*  by lpk when it is installed.
*
* History:
*  03-Jun-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL APIENTRY GetTextExtentExPointWPri (
    HDC     hdc,
    LPCWSTR lpwszString,
    int     cwchString,
    int     nMaxExtent,
    LPINT   lpnFit,
    LPINT   lpnDx,
    LPSIZE  lpSize
    )
{

    return NtGdiGetTextExtentExW(hdc,
                                (LPWSTR)lpwszString,
                                cwchString,
                                nMaxExtent,
                                lpnFit,
                                lpnDx,
                                lpSize,
                                0);

}




/******************************Public*Routine******************************\
*
* BOOL APIENTRY GetTextExtentExPointI
*
*
* History:
*  09-Sep-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL APIENTRY GetTextExtentExPointI (
    HDC     hdc,
    LPWORD  lpwszString,
    int     cwchString,
    int     nMaxExtent,
    LPINT   lpnFit,
    LPINT   lpnDx,
    LPSIZE  lpSize
    )
{
    return NtGdiGetTextExtentExW(hdc,
                                (LPWSTR)lpwszString,
                                cwchString,
                                nMaxExtent,
                                lpnFit,
                                lpnDx,
                                lpSize,
                                GTEEX_GLYPH_INDEX);
}

/******************************Public*Routine******************************\
*
* bGetCharABCWidthsA
*
* works for both floating point and integer version depending on bInt
*
* History:
*  24-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bGetCharABCWidthsA (
    HDC      hdc,
    UINT     wFirst,
    UINT     wLast,
    FLONG    fl,
    PVOID    pvBuf        // if (fl & GCABCW_INT) pabc else  pabcf,
    )
{
    BOOL    bRet = FALSE;
    ULONG   cjData, cjWCHAR, cjABC;
    ULONG   cChar = wLast - wFirst + 1;
    DWORD   dwCP = GetCodePage(hdc);
    BOOL        bDBCSCodePage;

    bDBCSCodePage = IS_ANY_DBCS_CODEPAGE(dwCP);

// Parameter checking.
    FIXUP_HANDLE(hdc);

    if((pvBuf  == (PVOID) NULL) ||
       (bDBCSCodePage && !IsValidDBCSRange(wFirst,wLast)) ||
       (!bDBCSCodePage && ((wFirst > wLast) || (wLast > 255))))
    {
        WARNING("gdi!_GetCharABCWidthsA(): bad parameter\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

// Compute buffer space needed in memory window.
// Buffer will be input array of WCHAR followed by output arrary of ABC.
// Because ABC need 32-bit alignment, cjWCHAR is rounded up to DWORD boundary.

    cjABC  = cChar * ((fl & GCABCW_INT) ? sizeof(ABC) : sizeof(ABCFLOAT));
    cjWCHAR = ALIGN4(cChar * sizeof(WCHAR));
    cjData = cjWCHAR + cjABC;


    //
    // WINBUG 82840 2-7-2000 bhouse Possible cleanup in bGetCharABCWidthsA
    // Old Comment:
    //    - if vSetUpUnicodeString,x could be moved to ntgdi,
    //      we wouldn't need to allocated temp buffers twice
    //
    // Allocate memory for temp buffer, fill in with proper char values
    //
    // Write the unicode string [wFirst,wLast] at the top of the buffer.
    // vSetUpUnicodeString requires a tmp CHAR buffer; we'll cheat a little
    // and use the ABC return buffer (this assumes that ABC is bigger
    // than a CHAR or USHORT in the case of DBCS).  We can get away with this b
    // because this memory is an output buffer for the server call.
    //

    {
        PUCHAR pjTempBuffer = LOCALALLOC(cjData);
        PUCHAR pwcABC = pjTempBuffer + cjWCHAR;
        PWCHAR pwcCHAR  = (PWCHAR)pjTempBuffer;

        if (pjTempBuffer == (PUCHAR)NULL)
        {
            bRet = FALSE;
        }
        else
        {

            if(bDBCSCodePage)
            {
                bRet = bSetUpUnicodeStringDBCS(wFirst,
                                               wLast,
                                               pwcABC,
                                               pwcCHAR,
                                               dwCP,
                                               GetCurrentDefaultChar(hdc));
            }
            else
            {
                bRet = bSetUpUnicodeString(wFirst,
                                           wLast,
                                           pwcABC,
                                           pwcCHAR, dwCP);
            }

            //
            // call GDI
            //

            if(bRet)
            {
                bRet = NtGdiGetCharABCWidthsW(hdc,
                                              wFirst,
                                              cChar,
                                              (PWCHAR)pwcCHAR,
                                              (fl & GCABCW_INT),
                                              (PVOID)pwcABC);
            }

            //
            // If OK, then copy return data out of window.
            //

            if (bRet)
            {
                RtlCopyMemory((PBYTE) pvBuf,pwcABC, cjABC);
            }

            LOCALFREE(pjTempBuffer);
        }
    }
    return bRet;
}


/******************************Public*Routine******************************\
* BOOL APIENTRY GetCharABCWidthsA (
*
* We want to get ABC spaces
* for a contiguous set of input codepoints (that range from wFirst to wLast).
* The set of corresponding UNICODE codepoints is not guaranteed to be
* contiguous.  Therefore, we will translate the input codepoints here and
* pass the server a buffer of UNICODE codepoints.
*
* History:
*  20-Jan-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetCharABCWidthsA (
    HDC      hdc,
    UINT     wFirst,
    UINT     wLast,
    LPABC   lpABC
    )
{
    return bGetCharABCWidthsA(hdc,wFirst,wLast,GCABCW_INT,(PVOID)lpABC);
}


/******************************Public*Routine******************************\
*
* GetCharABCWidthsFloatA
*
* History:
*  22-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetCharABCWidthsFloatA
(
IN HDC           hdc,
IN UINT          iFirst,
IN UINT          iLast,
OUT LPABCFLOAT   lpABCF
)
{
    return bGetCharABCWidthsA(hdc,iFirst,iLast,0,(PVOID)lpABCF);
}


/******************************Public*Routine******************************\
*
* bGetCharABCWidthsW
*
* History:
*  22-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bGetCharABCWidthsW (
    IN HDC      hdc,
    IN UINT     wchFirst,
    IN UINT     wchLast,
    IN FLONG    fl,
    OUT PVOID   pvBuf
    )
{
    BOOL    bRet = FALSE;
    ULONG   cwch = wchLast - wchFirst + 1;

// Parameter checking.
    FIXUP_HANDLE(hdc);

    if ( (pvBuf == (PVOID)NULL) || (wchFirst > wchLast) )
    {
        WARNING("gdi!GetCharABCWidthsW(): bad parameter\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // kernel mode
    //

    bRet = NtGdiGetCharABCWidthsW(
                            hdc,
                            wchFirst,
                            cwch,
                            (PWCHAR)NULL,
                            fl,
                            (PVOID)pvBuf);

    return(bRet);

}


/******************************Public*Routine******************************\
* BOOL APIENTRY GetCharABCWidthsW (
*     IN HDC      hdc,
*     IN WORD     wchFirst,
*     IN WORD     wchLast,
*     OUT LPABC   lpABC
*     )
*
* For this case, we can truly assume that we want to get ABC character
* widths for a contiguous set of UNICODE codepoints from wchFirst to
* wchLast (inclusive).  So we will call the server using wchFirst, but
* with an empty input buffer.
*
* History:
*  20-Jan-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetCharABCWidthsW (
    HDC     hdc,
    UINT    wchFirst,
    UINT    wchLast,
    LPABC   lpABC
    )
{
    return bGetCharABCWidthsW(hdc,wchFirst,wchLast,GCABCW_INT,(PVOID)lpABC);
}


/******************************Public*Routine******************************\
*
* GetCharABCWidthsFloatW
*
* Effects:
*
* Warnings:
*
* History:
*  22-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetCharABCWidthsFloatW
(
HDC         hdc,
UINT        iFirst,
UINT        iLast,
LPABCFLOAT  lpABCF
)
{
    return bGetCharABCWidthsW(hdc,iFirst,iLast,0,(PVOID)lpABCF);
}


/******************************Public*Routine******************************\
*
* GetCharABCWidthsI, index version
*
* if pgi == NULL use the consecutive range
*   giFirst, giFirst + 1, ...., giFirst + cgi - 1
*
* if pgi != NULL ignore giFirst and use cgi indices pointed to by pgi
*
* History:
*  28-Aug-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL  APIENTRY GetCharABCWidthsI(
    HDC    hdc,
    UINT   giFirst,
    UINT   cgi,
    LPWORD pgi,
    LPABC  pabc
)
{
    return NtGdiGetCharABCWidthsW(hdc,
                                  giFirst,
                                  cgi,
                                  pgi,
                                  GCABCW_INT | GCABCW_GLYPH_INDEX,
                                  pabc
                                  );
}




/******************************Public*Routine******************************\
* GetFontData
*
* Client side stub to GreGetFontData.
*
* History:
*  17-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

DWORD APIENTRY GetFontData (
    HDC     hdc,
    DWORD   dwTable,
    DWORD   dwOffset,
    PVOID   pvBuffer,
    DWORD   cjBuffer
    )
{
    DWORD dwRet = (DWORD) -1;

    FIXUP_HANDLE(hdc);

// if there is no buffer to copy data to, ignore possibly different
// from zero cjBuffer parameter. This is what win95 is doing.

    if (cjBuffer && (pvBuffer == NULL))
        cjBuffer = 0;

    dwRet = NtGdiGetFontData(
                        hdc,
                        dwTable,
                        dwOffset,
                        pvBuffer,
                        cjBuffer);

    return(dwRet);
}


/******************************Public*Routine******************************\
* GetGlyphOutline
*
* Client side stub to GreGetGlyphOutline.
*
* History:
*  17-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

DWORD GetGlyphOutlineInternalW (
    HDC             hdc,
    UINT            uChar,
    UINT            fuFormat,
    LPGLYPHMETRICS  lpgm,
    DWORD           cjBuffer,
    LPVOID          pvBuffer,
    CONST MAT2     *lpmat2,
    BOOL            bIgnoreRotation
    )
{
    DWORD dwRet = (DWORD) -1;

// Parameter validation.
    FIXUP_HANDLE(hdc);

    if ( (lpmat2 == (LPMAT2) NULL)
         || (lpgm == (LPGLYPHMETRICS) NULL)
       )
    {
        WARNING("gdi!GetGlyphOutlineW(): bad parameter\n");
        return (dwRet);
    }

    if (pvBuffer == NULL)
        cjBuffer = 0;

// Compute buffer space needed in memory window.

    dwRet = NtGdiGetGlyphOutline(
                            hdc,
                            (WCHAR)uChar,
                            fuFormat,
                            lpgm,
                            cjBuffer,
                            pvBuffer,
                            (LPMAT2)lpmat2,
                            bIgnoreRotation);

    return(dwRet);
}


DWORD APIENTRY GetGlyphOutlineW (
    HDC             hdc,
    UINT            uChar,
    UINT            fuFormat,
    LPGLYPHMETRICS  lpgm,
    DWORD           cjBuffer,
    LPVOID          pvBuffer,
    CONST MAT2     *lpmat2
)
{

    return( GetGlyphOutlineInternalW( hdc,
                                      uChar,
                                      fuFormat,
                                      lpgm,
                                      cjBuffer,
                                      pvBuffer,
                                      lpmat2,
                                      FALSE ) );
}



DWORD APIENTRY GetGlyphOutlineInternalA (
    HDC             hdc,
    UINT            uChar,
    UINT            fuFormat,
    LPGLYPHMETRICS  lpgm,
    DWORD           cjBuffer,
    LPVOID          pvBuffer,
    CONST MAT2     *lpmat2,
    BOOL            bIgnoreRotation
    )
{
    WCHAR wc;
    BOOL  bRet;


    FIXUP_HANDLE(hdc);

    // The ANSI interface is compatible with Win 3.1 and is intended
    // to take a 2 byte uChar.  Since we are 32-bit, this 16-bit UINT
    // is now 32-bit.  So we are only interested in the least significant
    // word of the uChar passed into the 32-bit interface.

    if (!(fuFormat & GGO_GLYPH_INDEX))
    {
    // the conversion needs to be done based on
    // the current code page of the font selected in the dc
        UCHAR Mbcs[2];
        UINT Convert;
        DWORD dwCP = GetCodePage(hdc);


        if(IS_ANY_DBCS_CODEPAGE(dwCP) &&
           IsDBCSLeadByteEx(dwCP, (char) (uChar >> 8)))
        {
            Mbcs[0] = (uChar >> 8) & 0xFF;
            Mbcs[1] = uChar & 0xFF;
            Convert = 2;
        }
        else
        {
            Mbcs[0] = uChar & 0xFF;
            Convert = 1;
        }

        if(!(bRet = MultiByteToWideChar(dwCP, 0,
                                       (LPCSTR)Mbcs,Convert,
                                       &wc, sizeof(WCHAR))))
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }

    }
    else
    {
    // The uChar value is to be interpreted as glyph index and
    // no conversion is necessary

        wc = (WCHAR)uChar;
        bRet = TRUE;
    }


    if (bRet)
    {
        bRet = GetGlyphOutlineInternalW(
                   hdc,
                   (UINT) wc,
                   fuFormat,
                   lpgm,
                   cjBuffer,
                   pvBuffer,
                   lpmat2,
                   bIgnoreRotation);
    }

    return bRet;
}


DWORD APIENTRY GetGlyphOutlineA (
    HDC             hdc,
    UINT            uChar,
    UINT            fuFormat,
    LPGLYPHMETRICS  lpgm,
    DWORD           cjBuffer,
    LPVOID          pvBuffer,
    CONST MAT2     *lpmat2
)
{

    return( GetGlyphOutlineInternalA( hdc,
                                      uChar,
                                      fuFormat,
                                      lpgm,
                                      cjBuffer,
                                      pvBuffer,
                                      lpmat2,
                                      FALSE ) );
}


DWORD APIENTRY GetGlyphOutlineWow (
    HDC             hdc,
    UINT            uChar,
    UINT            fuFormat,
    LPGLYPHMETRICS  lpgm,
    DWORD           cjBuffer,
    LPVOID          pvBuffer,
    CONST MAT2     *lpmat2
)
{

    return( GetGlyphOutlineInternalA( hdc,
                                      uChar,
                                      fuFormat,
                                      lpgm,
                                      cjBuffer,
                                      pvBuffer,
                                      lpmat2,
                                      TRUE ) );
}




/******************************Public*Routine******************************\
* GetOutlineTextMetricsW
*
* Client side stub to GreGetOutlineTextMetrics.
*
* History:
*
*  Tue 20-Apr-1993 -by- Gerrit van Wingerden [gerritv]
* update: added bTTOnly stuff for Aldus escape in the WOW layer
*
*  Thu 28-Jan-1993 -by- Bodin Dresevic [BodinD]
* update: added TMDIFF * stuff
*
*  17-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

UINT APIENTRY GetOutlineTextMetricsWInternal (
    HDC  hdc,
    UINT cjCopy,     // refers to OTMW_INTERNAL, not to OUTLINETEXTMETRICSW
    OUTLINETEXTMETRICW * potmw,
    TMDIFF             * ptmd
    )
{
    DWORD cjRet = (DWORD) 0;

    FIXUP_HANDLE(hdc);

    if (potmw == (OUTLINETEXTMETRICW *) NULL)
        cjCopy = 0;

    cjRet = NtGdiGetOutlineTextMetricsInternalW(
                        hdc,
                        cjCopy,
                        potmw,
                        ptmd);

    return(cjRet);

}

/******************************Public*Routine******************************\
*
* UINT APIENTRY GetOutlineTextMetricsW (
*
* wrote the wrapper to go around the corresponding internal routine
*
* History:
*  28-Jan-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


UINT APIENTRY GetOutlineTextMetricsW (
    HDC  hdc,
    UINT cjCopy,
    LPOUTLINETEXTMETRICW potmw
    )
{
    TMDIFF  tmd;

    return GetOutlineTextMetricsWInternal(hdc, cjCopy, potmw, &tmd);
}


#define bAnsiSize(a,b,c) (NT_SUCCESS(RtlUnicodeToMultiByteSize((a),(b),(c))))

// vAnsiSize macro should only be used within GetOTMA, where bAnsiSize
// is not supposed to fail [bodind]

#if DBG

#define vAnsiSize(a,b,c)                                              \
{                                                                     \
    BOOL bTmp = bAnsiSize(&cjString, pwszSrc, sizeof(WCHAR) * cwc);   \
    ASSERTGDI(bTmp, "gdi32!GetOTMA: bAnsiSize failed \n");            \
}

#else

#define vAnsiSize(a,b,c)    bAnsiSize(a,b,c)

#endif  //, non debug version



/******************************Public*Routine******************************\
* GetOutlineTextMetricsInternalA
*
* Client side stub to GreGetOutlineTextMetrics.
*
* History:
*
*  20-Apr-1993 -by- Gerrit van Wingerden [gerritv]
*   Changed to GetOutlineTextMetricsInternalA from GetOutlineTextMetricsA
*   to support all fonts mode for Aldus escape.
*
*  17-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

UINT APIENTRY GetOutlineTextMetricsInternalA (
    HDC  hdc,
    UINT cjCopy,
    LPOUTLINETEXTMETRICA potma
    )
{
    UINT   cjRet = 0;
    UINT   cjotma, cjotmw;

    TMDIFF               tmd;
    OUTLINETEXTMETRICW  *potmwTmp;
    OUTLINETEXTMETRICA   otmaTmp; // tmp buffer on the stack

    FIXUP_HANDLE(hdc);

// Because we need to be able to copy cjCopy bytes of data from the
// OUTLINETEXTMETRICA structure, we need to allocate a temporary buffer
// big enough for the entire structure.  This is because the UNICODE and
// ANSI versions of OUTLINETEXTMETRIC have mismatched offsets to their
// corresponding fields.

// Determine size of the buffer.

    if ((cjotmw = GetOutlineTextMetricsWInternal(hdc, 0, NULL,&tmd)) == 0 )
    {
        WARNING("gdi!GetOutlineTextMetricsInternalA(): unable to determine size of buffer needed\n");
        return (cjRet);
    }

// get cjotma from tmd.

    cjotma = (UINT)tmd.cjotma;

// if cjotma == 0, this is HONEST to God unicode font, can not convert
// strings to ansi

    if (cjotma == 0)
    {
        WARNING("gdi!GetOutlineTextMetricsInternalA(): unable to determine cjotma\n");
        return (cjRet);
    }

// Early out.  If NULL buffer, then just return the size.

    if (potma == (LPOUTLINETEXTMETRICA) NULL)
        return (cjotma);

// Allocate temporary buffers.

    if ((potmwTmp = (OUTLINETEXTMETRICW*) LOCALALLOC(cjotmw)) == (OUTLINETEXTMETRICW*)NULL)
    {
        WARNING("gdi!GetOutlineTextMetricA(): memory allocation error OUTLINETEXTMETRICW buffer\n");
        GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return (cjRet);
    }

// Call the UNICODE version of the call.

    if (GetOutlineTextMetricsWInternal(hdc, cjotmw, potmwTmp,&tmd) == 0 )
    {
        WARNING("gdi!GetOutlineTextMetricsInternalA(): call to GetOutlineTextMetricsW() failed\n");
        LOCALFREE(potmwTmp);
        return (cjRet);
    }

// Convert from OUTLINETEXTMETRICW to OUTLINETEXTMETRICA

    vOutlineTextMetricWToOutlineTextMetricA(&otmaTmp, potmwTmp,&tmd);

// Copy data into return buffer.  Do not copy strings.

    cjRet = min(cjCopy, sizeof(OUTLINETEXTMETRICA));
    RtlMoveMemory(potma,&otmaTmp,cjRet);

// Note that if
// offsetof(OUTLINETEXTMETRICA,otmpFamilyName) < cjCopy <= sizeof(OUTLINETEXTMETRICA)
// the offsets to strings have been set to zero [BodinD]

// If strings wanted, convert the strings to ANSI.

    if (cjCopy > sizeof(OUTLINETEXTMETRICA))
    {
        ULONG      cjString,cwc;
        ULONG_PTR   dpString;
        ULONG_PTR   dpStringEnd;
        PWSZ       pwszSrc;

    // first have to make sure that we will not overwrite the end
    // of the caller's buffer, if that is the case

        if (cjCopy < cjotma)
        {
        // Win 31 spec is ambiguous about this case
        // and by looking into the source code, it seems that
        // they just overwrite the end of the buffer without
        // even doing this check.

            GdiSetLastError(ERROR_CAN_NOT_COMPLETE);
            cjRet = 0;
            goto GOTMA_clean_up;
        }

    // now we know that all the strings can fit, moreover we know that
    // all string operations will succeed since we have called
    // cjOTMA to do these same operations on the server side to give us
    // cjotma [bodind]

    // Note: have to do the backwards compatible casting below because Win 3.1 insists
    //       on using a PSTR as PTRDIFF (i.e., an offset).

    // FAMILY NAME ------------------------------------------------------------

        pwszSrc = (PWSZ) (((PBYTE) potmwTmp) + (ULONG_PTR) potmwTmp->otmpFamilyName);
        cwc = wcslen(pwszSrc) + 1;
        vAnsiSize(&cjString, pwszSrc, sizeof(WCHAR) * cwc);

    // Convert from Unicode to ASCII.

        dpString = sizeof(OUTLINETEXTMETRICA);
        dpStringEnd = dpString + cjString;

        ASSERTGDI(dpStringEnd <= cjCopy, "gdi32!GetOTMA: string can not fit1\n");

        if (!bToASCII_N ((PBYTE)potma + dpString,cjString,pwszSrc,cwc))
        {
            WARNING("gdi!GetOutlineTextMetricsInternalA(): UNICODE->ASCII conv error \n");
            cjRet = 0;
            goto GOTMA_clean_up;
        }

    // Store string offset in the return structure.

        potma->otmpFamilyName = (PSTR) dpString;

    // FACE NAME --------------------------------------------------------------

        pwszSrc = (PWSZ) (((PBYTE) potmwTmp) + (ULONG_PTR) potmwTmp->otmpFaceName);
        cwc = wcslen(pwszSrc) + 1;
        vAnsiSize(&cjString, pwszSrc, sizeof(WCHAR) * cwc);

        dpString = dpStringEnd;
        dpStringEnd = dpString + cjString;

        ASSERTGDI(dpStringEnd <= cjCopy, "gdi32!GetOTMA: string can not fit2\n");

    // Convert from Unicode to ASCII.

        if (!bToASCII_N ((PBYTE)potma + dpString,cjString,pwszSrc,cwc))
        {
            WARNING("gdi!GetOutlineTextMetricsInternalA(): UNICODE->ASCII conv error \n");
            cjRet = 0;
            goto GOTMA_clean_up;
        }

    // Store string offset in return structure.  Move pointers to next string.

        potma->otmpFaceName = (PSTR) dpString;

    // STYLE NAME -------------------------------------------------------------

        pwszSrc = (PWSZ) (((PBYTE) potmwTmp) + (ULONG_PTR) potmwTmp->otmpStyleName);
        cwc = wcslen(pwszSrc) + 1;
        vAnsiSize(&cjString, pwszSrc, sizeof(WCHAR) * cwc);

        dpString = dpStringEnd;
        dpStringEnd = dpString + cjString;

        ASSERTGDI(dpStringEnd <= cjCopy, "gdi32!GetOTMA: string can not fit3\n");

    // Convert from Unicode to ASCII.

        if (!bToASCII_N ((PBYTE)potma + dpString,cjString,pwszSrc,cwc))
        {
            WARNING("gdi!GetOutlineTextMetricsInternalA(): UNICODE->ASCII conv error \n");
            cjRet = 0;
            goto GOTMA_clean_up;
        }

    // Store string offset in return structure.  Move pointers to next string.

        potma->otmpStyleName = (PSTR)dpString;

    // FULL NAME --------------------------------------------------------------

        pwszSrc = (PWSZ) (((PBYTE) potmwTmp) + (ULONG_PTR) potmwTmp->otmpFullName);
        cwc = wcslen(pwszSrc) + 1;
        vAnsiSize(&cjString, pwszSrc, sizeof(WCHAR) * cwc);

        dpString = dpStringEnd;
        dpStringEnd = dpString + cjString;

        ASSERTGDI(dpStringEnd <= cjCopy, "gdi32!GetOTMA: string can not fit4\n");

    // Convert from Unicode to ASCII.

        if (!bToASCII_N ((PBYTE)potma + dpString,cjString,pwszSrc,cwc))
        {
            WARNING("gdi!GetOutlineTextMetricsInternalA(): UNICODE->ASCII conv error \n");
            cjRet = 0;
            goto GOTMA_clean_up;
        }

    // Store string offset in return structure.

        potma->otmpFullName = (PSTR) dpString;

        //Sundown: safe to truncate ULONG
        cjRet = (ULONG)dpStringEnd;
        ASSERTGDI(cjRet == cjotma, "gdi32!GetOTMA: cjRet != dpStringEnd\n");

    }

GOTMA_clean_up:

// Free temporary buffer.

    LOCALFREE(potmwTmp);

// Fixup size field.

    if (cjCopy >= sizeof(UINT))  // if it is possible to store otmSize
        potma->otmSize = cjRet;

// Successful, so return size.

    return (cjRet);
}



/******************************Public*Routine******************************\
* GetOutlineTextMetricsA
*
* Client side stub to GreGetOutlineTextMetrics.
*
* History:
*  Tue 02-Nov-1993 -by- Bodin Dresevic [BodinD]
\**************************************************************************/


UINT APIENTRY GetOutlineTextMetricsA (
    HDC  hdc,
    UINT cjCopy,
    LPOUTLINETEXTMETRICA potma
    )
{
    return GetOutlineTextMetricsInternalA(hdc, cjCopy, potma);
}


/******************************Public*Routine******************************\
*                                                                          *
* GetKerningPairs                                                          *
*                                                                          *
* History:                                                                 *
*  Sun 23-Feb-1992 09:48:55 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

DWORD APIENTRY
GetKerningPairsW(
    IN HDC              hdc,        // handle to application's DC
    IN DWORD            nPairs,     // max no. KERNINGPAIR to be returned
    OUT LPKERNINGPAIR   lpKernPair  // pointer to receiving buffer
    )
{
    ULONG     sizeofMsg;
    DWORD     cRet = 0;

    FIXUP_HANDLE(hdc);

    if (nPairs == 0 && lpKernPair != (KERNINGPAIR*) NULL)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

    cRet = NtGdiGetKerningPairs(
                        hdc,
                        nPairs,
                        lpKernPair);

    return(cRet);
}


/******************************Public*Routine******************************\
* GetKerningPairsA
*
* filters out pairs that are not contained in the code page of the font
* selected in DC
*
* History:
*  14-Mar-1996 -by- Xudong Wu [TessieW]
* Wrote it.
\**************************************************************************/


DWORD APIENTRY GetKerningPairsA
(
    HDC              hdc,        // handle to application's DC
    DWORD            nPairs,     // max no. KERNINGPAIR to be returned
    LPKERNINGPAIR    lpKernPair  // pointer to receiving buffer
)
{
    #define       MAXKERNPAIR     300
    DWORD         i;
    DWORD         dwCP;
    KERNINGPAIR   tmpKernPair[MAXKERNPAIR];
    DWORD         cRet, cRet1;
    KERNINGPAIR   *pkp, *pkrn;
    KERNINGPAIR UNALIGNED *pkrnLast;
    BOOL           bDBCS;

    FIXUP_HANDLE(hdc);

    if ((nPairs == 0) && (lpKernPair != (KERNINGPAIR*) NULL))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

    cRet = NtGdiGetKerningPairs(hdc, 0, NULL);

    if (cRet == 0)
        return(cRet);

    if (cRet <= MAXKERNPAIR)
        pkrn = tmpKernPair;
    else
        pkrn =  LOCALALLOC(cRet * sizeof(KERNINGPAIR));

    if (!pkrn)
    {
        GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    cRet1 = NtGdiGetKerningPairs(hdc, cRet, pkrn);

    if (cRet1 == 0 || cRet1 != cRet)
    {
        ASSERTGDI(FALSE, "NtGdiGetKerningPairs returns different values\n");
        cRet = 0;
        goto Cleanup;
    }

    pkp = pkrn;
    pkrnLast = lpKernPair;
    cRet = 0;

// GDI has returned iFirst and iSecond of the KERNINGPAIR structure in Unicode
// It is at this point that we translate them to the current code page

    dwCP = GetCodePage(hdc);

    bDBCS = IS_ANY_DBCS_CODEPAGE(dwCP);

    for (i = 0; i < cRet1; i++,pkp++)
    {
        UCHAR ach[2], ach2[2];
        BOOL bUsedDef[2];

        ach[0] = ach[1] = 0;        // insure zero extension

        WideCharToMultiByte(dwCP,
                            0,
                            &(pkp->wFirst),
                            1,
                            ach,
                            sizeof(ach),
                            NULL,
                            &bUsedDef[0]);
        if (!bUsedDef[0])
        {
            ach2[0] = ach2[1] = 0;

            WideCharToMultiByte(dwCP,
                                0,
                                &(pkp->wSecond),
                                1,
                                ach2,
                                sizeof(ach2),
                                NULL,
                                &bUsedDef[1]);

            if (!bUsedDef[1])
            {
                if (lpKernPair)
                {
                // do not overwrite the end of the buffer if it is provided

                    if (cRet >= nPairs)
                        break;

                    if (bDBCS)
                    {
                        if (IsDBCSLeadByteEx(dwCP,ach[0]))
                        {
                            pkrnLast->wFirst = (WORD)(ach[0] << 8 | ach[1]);
                        }
                        else
                        {
                            pkrnLast->wFirst = ach[0];
                        }

                        if (IsDBCSLeadByteEx(dwCP,ach2[0]))
                        {
                            pkrnLast->wSecond = (WORD)(ach2[0] << 8 | ach2[1]);
                        }
                        else
                        {
                            pkrnLast->wSecond = ach2[0];
                        }
                    }
                    else
                    {
                        pkrnLast->wFirst  = ach[0];
                        pkrnLast->wSecond = ach2[0];
                    }

                    pkrnLast->iKernAmount = pkp->iKernAmount;
                    pkrnLast++;

                }
                cRet++;
            }
        }
    }
Cleanup:
    if (pkrn != tmpKernPair)
        LOCALFREE(pkrn);

    return cRet;
}




/*****************************Public*Routine******************************\
* FixBrushOrgEx
*
* for win32s
*
* History:
*  04-Jun-1992 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL FixBrushOrgEx(HDC hdc, int x, int y, LPPOINT ptl)
{
    return(FALSE);
}

/******************************Public*Function*****************************\
* GetColorAdjustment
*
*  Get the color adjustment data for a given DC.
*
* History:
*  07-Aug-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetColorAdjustment(HDC hdc, LPCOLORADJUSTMENT pclradj)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiGetColorAdjustment(hdc,pclradj));
}

/******************************Public*Routine******************************\
* GetETM
*
* Aldus Escape support
*
* History:
*  20-Oct-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetETM (HDC hdc, EXTTEXTMETRIC * petm)
{
    BOOL  bRet = FALSE;

    FIXUP_HANDLE(hdc);

    bRet = NtGdiGetETM(hdc,petm);

// path up the number of KerningPairs to match GetKerningPairsA

    if (bRet && petm)
    {
        petm->etmNKernPairs = (WORD)GetKerningPairsA(hdc, 0, NULL);
    }

    return(bRet);
}

#if 0
/****************************Public*Routine********************************\
* GetCharWidthInfo
*
* Get the lMaxNegA lMaxNegC and lMinWidthD
*
* History:
* 09-Feb-1996 -by- Xudong Wu [tessiew]
* Wrote it
\***************************************************************************/

BOOL APIENTRY GetCharWidthInfo (HDC hdc, PCHWIDTHINFO pChWidthInfo)
{
   return ( NtGdiGetCharWidthInfo(hdc, pChWidthInfo) );
}
#endif

#ifdef LANGPACK
/******************************Public*Routine******************************\
*
* bGetRealizationInfoInternal
*
* Retreives the realization_info from kernel, if not cached in shared
* memory
*
* History:
*  18-Aug-1997 -by- Samer Arafeh [SamerA]
* Wrote it.
\**************************************************************************/

BOOL bGetRealizationInfoInternal(
    HDC hdc,
    REALIZATION_INFO *pri,
    CFONT *pcf
    )
{
    BOOL bRet = FALSE;

    if (pri)
    {
        // if no pcf or we havn't cached the metrics

        if ((pcf == NULL) || !(pcf->fl & CFONT_CACHED_RI) || pcf->timeStamp != pGdiSharedMemory->timeStamp)
        {
            REALIZATION_INFO ri;
            PDC_ATTR    pDcAttr;

            PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

			if( pcf != NULL && (pcf->fl & CFONT_PUBLIC) )
	            bRet = NtGdiGetRealizationInfo(hdc,&ri, pcf->hf);
	        else
	            bRet = NtGdiGetRealizationInfo(hdc,&ri, 0);

            if (bRet)
            {
                *pri = ri;

                if (pcf && !(pcf->fl & CFONT_PUBLIC))
                {
                    // we succeeded and we have a pcf so cache the data

                    pcf->ri = ri;

                    pcf->fl |= CFONT_CACHED_RI;

                    pcf->timeStamp = pGdiSharedMemory->timeStamp;
                }
                
            }
        }
        else
        {
            *pri = pcf->ri;
            bRet  = TRUE;
        }

    }

    return(bRet);
}

/******************************Public*Routine******************************\
*
* GdiRealizationInfo
*
* Try retreive the RealizationInfo from shared memory
*
* History:
*  18-Aug-1997 -by- Samer Arafeh [SamerA]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GdiRealizationInfo(HDC hdc,REALIZATION_INFO *pri)
{
    BOOL bRet = FALSE;
    PDC_ATTR    pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        CFONT * pcf;

        ENTERCRITICALSECTION(&semLocal);

        pcf = pcfLocateCFONT(hdc,pDcAttr,0,(PVOID) NULL,0,TRUE);

        bRet = bGetRealizationInfoInternal(hdc,pri,pcf);

        // pcfLocateCFONT added a reference so now we need to remove it

        if (pcf)
        {
            DEC_CFONT_REF(pcf);
        }

        LEAVECRITICALSECTION(&semLocal);
    }
    else
    {
    // it could a public DC -OBJECT_OWNER_PUBLIC- (in which gpGdiShareMemory[hDC].pUser=NULL)
    // so let's do it the expensive way by doing the kernel-transition...

        bRet = NtGdiGetRealizationInfo(hdc,pri,0);
    }

    return(bRet);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\ddstub.h ===
/******************************Module*Header*******************************\
* Module Name: ddstub.h
*
* Information shared between DirectDraw and Direct3D stubs
*
* Created: 31-May-1996
* Author: Drew Bliss [drewb]
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

#ifndef __DDSTUB_H__
#define __DDSTUB_H__

extern HANDLE ghDirectDraw;
#define DD_HANDLE(h) ((h) != 0 ? (HANDLE) (h) : ghDirectDraw)

#endif // __DDSTUB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\dvpe.c ===
/******************************Module*Header*******************************\
* Module Name: ddraw.c
*
* Client side stubs for the private DirectDraw VPE system APIs.
*
* Created: 2-Oct-1996
* Author: Lingyun Wang [LingyunW]
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <ddrawi.h>
#include <dvpp.h>

/*****************************Private*Routine******************************\
* CanCreateVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
DvpCanCreateVideoPort(
    LPDDHAL_CANCREATEVPORTDATA pCanCreateVideoPort
    )
{
    return(NtGdiDvpCanCreateVideoPort((HANDLE) pCanCreateVideoPort->lpDD->lpGbl->hDD,
                                     (PDD_CANCREATEVPORTDATA)pCanCreateVideoPort));
}

/*****************************Private*Routine******************************\
* CanCreateVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
DvpColorControl (
    LPDDHAL_VPORTCOLORDATA pColorControl
    )
{
    return(NtGdiDvpColorControl((HANDLE) pColorControl->lpDD->lpGbl->hDD,
                               (PDD_VPORTCOLORDATA)pColorControl));
}

/*****************************Private*Routine******************************\
* CreateVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
DvpCreateVideoPort (
    LPDDHAL_CREATEVPORTDATA pCreateVideoPort
    )
{
    return(NtGdiDvpCreateVideoPort((HANDLE) pCreateVideoPort->lpDD->lpGbl->hDD,
                                  (PDD_CREATEVPORTDATA)pCreateVideoPort));
}

/*****************************Private*Routine******************************\
* DestroyVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpDestroyVideoPort (
    LPDDHAL_DESTROYVPORTDATA pDestroyVideoPort
)
{
    return(NtGdiDvpDestroyVideoPort((HANDLE) pDestroyVideoPort->lpDD->lpGbl->hDD,
                                  (PDD_DESTROYVPORTDATA)pDestroyVideoPort));
}

/*****************************Private*Routine******************************\
* FlipVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpFlipVideoPort (
    LPDDHAL_FLIPVPORTDATA pFlipVideoPort
)
{
    return(NtGdiDvpFlipVideoPort((HANDLE) pFlipVideoPort->lpDD->lpGbl->hDD,
                                (HANDLE) pFlipVideoPort->lpSurfCurr->hDDSurface,
                                (HANDLE) pFlipVideoPort->lpSurfTarg->hDDSurface,
                                (PDD_FLIPVPORTDATA)pFlipVideoPort));
}

/*****************************Private*Routine******************************\
* GetCurrentAutoflipSurface
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetCurrentAutoflipSurface (
    LPDDHAL_GETVPORTAUTOFLIPSURFACEDATA pGetCurrentflipSurface)
{
    return(NtGdiDvpGetCurrentAutoflipSurface((HANDLE) pGetCurrentflipSurface->lpDD->lpGbl->hDD,
                                      (PDD_GETVPORTAUTOFLIPSURFACEDATA)pGetCurrentflipSurface));
}

/*****************************Private*Routine******************************\
* GetVideoPortBandwidthInfo
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortBandwidthInfo (
    LPDDHAL_GETVPORTBANDWIDTHDATA pGetVPortBandwidthInfo)
{
    return(NtGdiDvpGetVideoPortBandwidthInfo((HANDLE) pGetVPortBandwidthInfo->lpDD->lpGbl->hDD,
                                      (PDD_GETVPORTBANDWIDTHDATA)pGetVPortBandwidthInfo));
}


/*****************************Private*Routine******************************\
* GetVideoPortField
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortField (
    LPDDHAL_GETVPORTFIELDDATA pGetVideoPortField)
{
    return(NtGdiDvpGetVideoPortField((HANDLE) pGetVideoPortField->lpDD->lpGbl->hDD,
                                     (PDD_GETVPORTFIELDDATA)pGetVideoPortField));
}

/*****************************Private*Routine******************************\
* GetVideoPortFlipStatus
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortFlipStatus (
    LPDDHAL_GETVPORTFLIPSTATUSDATA pGetVPortFlipStatus)
{
    return(NtGdiDvpGetVideoPortFlipStatus((HANDLE) pGetVPortFlipStatus->lpDD->lpGbl->hDD,
                                     (PDD_GETVPORTFLIPSTATUSDATA)pGetVPortFlipStatus));
}

/*****************************Private*Routine******************************\
* GetVideoPortInputFormats
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortInputFormats (
    LPDDHAL_GETVPORTINPUTFORMATDATA pGetVPortInputFormats)
{
    return(NtGdiDvpGetVideoPortInputFormats((HANDLE) pGetVPortInputFormats->lpDD->lpGbl->hDD,
                                     (PDD_GETVPORTINPUTFORMATDATA)pGetVPortInputFormats));
}


/*****************************Private*Routine******************************\
* GetVideoPortLine
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortLine (
    LPDDHAL_GETVPORTLINEDATA pGetVideoPortLine)
{
    return(NtGdiDvpGetVideoPortLine((HANDLE) pGetVideoPortLine->lpDD->lpGbl->hDD,
                                   (PDD_GETVPORTLINEDATA)pGetVideoPortLine));
}

/*****************************Private*Routine******************************\
* GetVideoPortOutputFormats
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortOutputFormats (
    LPDDHAL_GETVPORTOUTPUTFORMATDATA pGetVPortOutputFormats)
{
    return(NtGdiDvpGetVideoPortOutputFormats((HANDLE) pGetVPortOutputFormats->lpDD->lpGbl->hDD,
                                   (PDD_GETVPORTOUTPUTFORMATDATA)pGetVPortOutputFormats));
}

/*****************************Private*Routine******************************\
* GetVideoPortConnectInfo
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortConnectInfo (
    LPDDHAL_GETVPORTCONNECTDATA pGetVPortConnectInfo)
{
    return(NtGdiDvpGetVideoPortConnectInfo((HANDLE) pGetVPortConnectInfo->lpDD->lpGbl->hDD,
                                   (PDD_GETVPORTCONNECTDATA)pGetVPortConnectInfo));
}

/*****************************Private*Routine******************************\
* GetVideoSignalStatus
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoSignalStatus (
    LPDDHAL_GETVPORTSIGNALDATA pGetVideoSignalStatus)
{
    return(NtGdiDvpVideoSignalStatus((HANDLE) pGetVideoSignalStatus->lpDD->lpGbl->hDD,
                                   (PDD_GETVPORTSIGNALDATA)pGetVideoSignalStatus));
}

/*****************************Private*Routine******************************\
* UpdateVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpUpdateVideoPort (
    LPDDHAL_UPDATEVPORTDATA pUpdateVideoPort)
{
    // WINBUG #82842 2-7-2000 bhouse Code cleanup in DvpUpdateVideoPort
    // Instead of 100, we should declare (if one does not already exist) a
    // constant for the maximum number of autoflip surfaces.  This value should
    // be checked when pUpdateVideoPort->dwNumAutoflip is set.  An assertion
    // should perhaps be made here to ensure we will not walk pass the end
    // of the stack based arrary.

    HANDLE phDDSurface[100];
    DWORD  i;

    // WINBUG #82844 2-7-2000 bhouse Investigate question in old comment
    // Old Comment
    //   - seems the driver only use lplpDDSurface, why lplpBBVBSurface there?
    
    for (i=0; i< pUpdateVideoPort->dwNumAutoflip; i++)
    {
        phDDSurface[i] = (HANDLE)(pUpdateVideoPort->lplpDDSurface[i]->lpLcl->hDDSurface);
    }

    return(NtGdiDvpUpdateVideoPort((HANDLE) pUpdateVideoPort->lpDD->lpGbl->hDD,
                                  (HANDLE *)phDDSurface,
                                  (PDD_UPDATEVPORTDATA)pUpdateVideoPort));
}


/*****************************Private*Routine******************************\
* WaitForVideoPortSync
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpWaitForVideoPortSync (
    LPDDHAL_WAITFORVPORTSYNCDATA pWaitForVideoPortSync)
{
    return(NtGdiDvpWaitForVideoPortSync((HANDLE) pWaitForVideoPortSync->lpDD->lpGbl->hDD,
                                  (PDD_WAITFORVPORTSYNCDATA)pWaitForVideoPortSync));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\drawstream.c ===
/******************************Module*Header*******************************\
* Module Name: drawstream.c                                                *
*                                                                          *
* Client side draw stream support.  Handles metafiling if primary          *
* is a metafile.                                                           *
*                                                                          *
* Created: 03-Mar-2001                                                     *
* Author: Barton House [bhouse]                                            *
*                                                                          *
* Copyright (c) 1991-2001 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop
/******************************Public*Routine******************************\
* GdiDrawStream
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    3/21/2001 Barton House
*
\**************************************************************************/

BOOL
GdiDrawStream(
                 HDC   hdcDst,
                 ULONG cjIn,
                 VOID *pvIn)
{
    BOOL bRet = FALSE;
    PDC_ATTR pdca;

    FIXUP_HANDLE(hdcDst);
    
    if (IS_ALTDC_TYPE(hdcDst))
    {
        HBITMAP hbmSource = NULL;
        HRGN    hrgnSaved  = NULL;
        HBITMAP hbmScratch = NULL;
        HDC     hdcScratch = NULL;
        int     iDstClip = -1;
        ULONG * pul = (ULONG *) pvIn;
    
        if(cjIn < sizeof(ULONG))
            return FALSE;
    
        if(*pul++ != 'DrwS')
            return FALSE;
    
        cjIn -= sizeof(ULONG);
    
        while(cjIn >= sizeof(ULONG))
        {
            ULONG   command = *pul;
            ULONG   commandSize;
            RECTL   rclDstClip;
    
            switch(command)
            {
            case DS_SETTARGETID: // set target
                {
                    DS_SETTARGET *  cmd = (DS_SETTARGET *) pul;
    
                    commandSize = sizeof(*cmd);
    
                    if(cjIn < commandSize)
                        goto altExit;
    
                    if((HDC) ULongToHandle(cmd->hdc) != hdcDst)
                    {
                        // NOTE: This restriction is only in place for the
                        //       initial implementation of GdiDrawStream.

                        WARNING("GdiDrawStream: target must match primary target");
                        goto altExit;
                    }
    
                    rclDstClip = cmd->rclDstClip;

                    if(hrgnSaved == NULL)
                    {
                        int iRet;

                        hrgnSaved = CreateRectRgn(0,0,0,0);
                        
                        if(hrgnSaved == NULL)
                        {
                            WARNING("GdiDrawStream: unable to create saved region");
                            goto altExit;
                        }

                        iDstClip = GetClipRgn(hdcDst, hrgnSaved);

                        if(iDstClip == -1)
                        {
                            WARNING("GdiDrawStream: failed to get DC application clip");
                            goto altExit;
                        }

                    }
                    else
                    {
                        // need to restore target clip

                        if(iDstClip)
                        {
                            SelectClipRgn(hdcDst, hrgnSaved);
                        }
                        else
                        {
                            SelectClipRgn(hdcDst, NULL);
                        }
                    }
    
                    IntersectClipRect(hdcDst, rclDstClip.left, rclDstClip.top, rclDstClip.right, rclDstClip.bottom);
                }
                break;
    
            case DS_SETSOURCEID: // set source
    
                {
                    DS_SETSOURCE *  cmd = (DS_SETSOURCE *) pul;
    
                    commandSize = sizeof(*cmd);
    
                    if(cjIn < commandSize)
                        goto altExit;
    
                    hbmSource = (HBITMAP) ULongToHandle(cmd->hbm);
    
                }
                break;
    
            case DS_NINEGRIDID:
                {
                    DS_NINEGRID * cmd = (DS_NINEGRID *) pul;
                    LONG  lSrcWidth = cmd->rclSrc.right - cmd->rclSrc.left;
                    LONG  lSrcHeight = cmd->rclSrc.bottom - cmd->rclSrc.top;
                    LONG  lDstWidth = cmd->rclDst.right - cmd->rclDst.left;
                    LONG  lDstHeight = cmd->rclDst.bottom - cmd->rclDst.top;
                    BOOL  bRenderRet;
                    RECTL rclDst = cmd->rclDst;

                    struct {
                        BITMAPINFOHEADER    bmih;
                        ULONG               masks[3];
                    } bmi;
    
                    struct {
                        DS_HEADER       hdr;
                        DS_SETTARGET    setTarget;
                        DS_SETSOURCE    setSource;
                        DS_NINEGRID     ng;
                    } scratchStream;
    
                    RECTL   rclScratch;
    
                    commandSize = sizeof(DS_NINEGRID);
    
                    // validate nine grid
    
                    #define DSDNG_MASK  0x007F      // move to wingdip.h
    
                    if(cmd->ngi.flFlags & ~DSDNG_MASK)
                    {
                        WARNING("GreDrawStream: unrecognized nine grid flags set\n");
                        goto altExit;
                    }
    
                    if(lSrcWidth < 0 || lSrcHeight < 0)
                    {
                        WARNING("GreDrawStream: nine grid rclSrc is not well ordered\n");
                        goto altExit;
                    }
    
                    if(cmd->ngi.flFlags & DSDNG_TRUESIZE)
                    {
                        if(lDstWidth > lSrcWidth) 
                        {
                            lDstWidth = lSrcWidth;
                            rclDst.right = rclDst.left + lDstWidth;
                        }

                        if(lDstHeight > lSrcHeight)
                        {
                            lDstHeight = lSrcHeight;
                            rclDst.bottom = rclDst.top + lDstHeight;
                        }
                    }
                    else
                    {
                        // NOTE: we have to check individual first then sum due to possible
                        //       numerical overflows that could occur in the sum that might
                        //       not be detected otherwise.
    
                        if(cmd->ngi.ulLeftWidth < 0 ||
                           cmd->ngi.ulRightWidth < 0 ||
                           cmd->ngi.ulTopHeight < 0 ||
                           cmd->ngi.ulBottomHeight < 0 ||
                           cmd->ngi.ulLeftWidth > lSrcWidth ||
                           cmd->ngi.ulRightWidth > lSrcWidth ||
                           cmd->ngi.ulTopHeight > lSrcHeight ||
                           cmd->ngi.ulBottomHeight > lSrcHeight ||
                           cmd->ngi.ulLeftWidth + cmd->ngi.ulRightWidth > lSrcWidth ||
                           cmd->ngi.ulTopHeight + cmd->ngi.ulBottomHeight > lSrcHeight)
                        {
                            WARNING("GreDrawStream: nine grid width is greater then rclSrc width or negative\n");
                            goto altExit;
                        }
                    }
    
                    if((cmd->ngi.flFlags & (DSDNG_TRANSPARENT | DSDNG_PERPIXELALPHA)) == (DSDNG_TRANSPARENT | DSDNG_PERPIXELALPHA))
                    {
                        WARNING("GreDrawStream: nine grid attempt to set both transparency and per pixel alpha\n");
                        goto altExit;
                    }
    
                    // create temporary to render nine grid into
    
                    bmi.bmih.biSize = sizeof(bmi.bmih);
                    bmi.bmih.biWidth = lDstWidth;
                    bmi.bmih.biHeight = lDstHeight;
                    bmi.bmih.biPlanes = 1;
                    bmi.bmih.biBitCount = 32;
                    bmi.bmih.biCompression = BI_BITFIELDS;
                    bmi.bmih.biSizeImage = 0;
                    bmi.bmih.biXPelsPerMeter = 0;
                    bmi.bmih.biYPelsPerMeter = 0;
                    bmi.bmih.biClrUsed = 3;
                    bmi.bmih.biClrImportant = 0;
                    bmi.masks[0] = 0xff0000;    // red
                    bmi.masks[1] = 0x00ff00;    // green
                    bmi.masks[2] = 0x0000ff;    // blue
    
                    if(hbmScratch != NULL)
                        DeleteObject(hbmScratch);
    
                    hbmScratch = CreateDIBitmap(hdcDst, &bmi.bmih, CBM_CREATEDIB , NULL, (BITMAPINFO*)&bmi.bmih, DIB_RGB_COLORS);
                    
                    if(hbmScratch == NULL)
                    {
                        WARNING("GdiDrawStream: unable to create temporary\n");
                        goto altExit;
                    }
                    
                    if(hdcScratch == NULL)
                    {
                        hdcScratch = CreateCompatibleDC(hdcDst);

                        if(hdcScratch == NULL)
                        {
                            WARNING("GdiDrawStream: unable to create temporary dc\n");
                            goto altExit;
                        }
                    }

                    SelectObject(hdcScratch, hbmScratch);
    
                    rclScratch.left = 0;
                    rclScratch.top = 0;
                    rclScratch.right = lDstWidth;
                    rclScratch.bottom = lDstHeight;
                    
                    scratchStream.hdr.magic = DS_MAGIC;
                    scratchStream.setTarget.ulCmdID = DS_SETTARGETID;
                    scratchStream.setTarget.hdc = HandleToULong(hdcScratch);
                    scratchStream.setTarget.rclDstClip = rclScratch;
                    scratchStream.setSource.ulCmdID = DS_SETSOURCEID;
                    scratchStream.setSource.hbm = HandleToULong(hbmSource);
                    scratchStream.ng.ulCmdID = DS_NINEGRIDID;
                    scratchStream.ng.rclDst = rclScratch;
                    scratchStream.ng.rclSrc = cmd->rclSrc;
                    scratchStream.ng.ngi = cmd->ngi;
                    scratchStream.ng.ngi.flFlags &= ~(DSDNG_TRANSPARENT | DSDNG_PERPIXELALPHA);
    
                    NtGdiDrawStream(hdcScratch, sizeof(scratchStream), &scratchStream);

                    if(cmd->ngi.flFlags & DSDNG_TRANSPARENT)
                    {
                        bRenderRet = GdiTransparentBlt(hdcDst,
                                          rclDst.left, 
                                          rclDst.top,
                                          lDstWidth,
                                          lDstHeight,
                                          hdcScratch,
                                          0,
                                          0,
                                          lDstWidth,
                                          lDstHeight,
                                          cmd->ngi.crTransparent);
                    }
                    else if(cmd->ngi.flFlags & DSDNG_PERPIXELALPHA)
                    {
                        // alpha blend
                        BLENDFUNCTION   bfx;

                        bfx.AlphaFormat = AC_SRC_ALPHA;
                        bfx.BlendFlags = 0;
                        bfx.BlendOp = AC_SRC_OVER;
                        bfx.SourceConstantAlpha = 255;

                        bRenderRet = GdiAlphaBlend(hdcDst,
                                          rclDst.left, 
                                          rclDst.top,
                                          lDstWidth,
                                          lDstHeight,
                                          hdcScratch,
                                          0,
                                          0,
                                          lDstWidth,
                                          lDstHeight,
                                          bfx);
                    }
                    else
                    {
                        // bitblt

                        bRenderRet = BitBlt(hdcDst,
                                          rclDst.left, 
                                          rclDst.top,
                                          lDstWidth,
                                          lDstHeight,
                                          hdcScratch,
                                          0,
                                          0,
                                  SRCCOPY);
                    }

                    if(!bRenderRet)
                    {
                        WARNING("GdiDrawStream: failed to render temporary to destination");
                        goto altExit;
                    }
                }
                break;
    
            default:
                WARNING("GdiDrawStream: unrecognized command");
                goto altExit;
            }

            pul += commandSize  / sizeof(ULONG);
            cjIn -= commandSize;

        }

        bRet = TRUE;

    altExit:

        if(iDstClip == 1)
        {
            SelectClipRgn(hdcDst, hrgnSaved);
        }
        else if(iDstClip == 0)
        {
            SelectClipRgn(hdcDst, NULL);
        }
        
        if(hbmScratch != NULL)
            DeleteObject(hbmScratch);

        if(hdcScratch != NULL)
            DeleteDC(hdcScratch);

        if(hrgnSaved != NULL)
            DeleteObject(hrgnSaved);

        return bRet;
    }

    RESETUSERPOLLCOUNT();

    bRet = NtGdiDrawStream(
                      hdcDst,
                      cjIn,
                      pvIn);
    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\emfspool.cxx ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    emfspool.cxx

Abstract:

    EMF spooling functions

Environment:

    Windows NT GDI

Revision History:

    01/09/97 -davidx-
        Created it.

--*/

#define NO_STRICT

extern "C" {
#if defined(_GDIPLUS_)
#include    <gpprefix.h>
#endif

#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <stddef.h>
#include    <windows.h>    // GDI function declarations.
#include    <winerror.h>
#include    "firewall.h"
#define __CPLUSPLUS
#include    <winspool.h>
#include    <wingdip.h>
#include    "ntgdistr.h"
#include    "winddi.h"
#include    "hmgshare.h"
#include    "icm.h"
#include    "local.h"   // Local object support.
#include    "gdiicm.h"
#include    "metadef.h" // Metafile record type constants.

}

#include    "rectl.hxx"
#include    "mfdc.hxx"  // Metafile DC class declarations.


//
// Class for representing extra information used during EMF spooling
//

BOOL
EMFSpoolData::Init(
    HANDLE      hSpooler,
    BOOL        banding
    )

/*++

Routine Description:

    Initialize an EMFSpoolData object

Arguments:

    hSpooler - Spooler handle to the current printer
    banding - Whether GDI is doing banding on the current DC

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    TRACE_EMFSPL(("EMFSpoolData::Init - banding = %d ...\n", banding));

    //
    // initialize all fields to default values
    //

    signature = 'LPSE';
    hPrinter = hSpooler;
    bBanding = banding;
    pmdcActive = NULL;
    scratchBuf = fontBuf = NULL;

    ResetMappingState();

    //
    // Get a handle to the EMF spool file
    //

    hFile = bBanding ?
                GetTempSpoolFileHandle() :
                fpGetSpoolFileHandle(hPrinter);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        WARNING("GetSpoolFileHandle failed\n");
        return FALSE;
    }

    //
    // Map the spooler file
    //

    return MapFile();
}


VOID
EMFSpoolData::Cleanup()
{
    UnmapFile();
    FreeTempBuffers();
}


PVOID
EMFSpoolData::GetPtr(UINT32 inOffset, UINT32 inSize)
{

    PVOID ptr = emfc.ObtainPtr(currentOffset + inOffset, inSize);
    return ptr;
}

VOID
EMFSpoolData::ReleasePtr(PVOID inPtr)
{
    emfc.ReleasePtr(inPtr);
}

PVOID
EMFSpoolData::GetPtrUsingSignedOffset(INT32 inOffset, UINT32 inSize)
{
    if((inOffset + (INT32) currentOffset) < 0)
    {
        WARNING("EMFSpoolData::GetPtrUsingSignedOffset() Bad offset\n");
        return NULL;
    }

    PVOID ptr = emfc.ObtainPtr((UINT32) (currentOffset + inOffset), inSize);
    
    return ptr;
}

BOOL
EMFSpoolData::WriteData(
    PVOID   buffer,
    DWORD   size
    )

/*++

Routine Description:

    Write data to the end of mapped file

Arguments:

    buffer - Pointer to data buffer
    size - Size of data buffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    ASSERTGDI(size != 0, "WriteData: size is 0\n");

    if(!bMapping)
        return FALSE;

    //
    // Check if the current buffer is used for recording EMF data
    //

    if (!pmdcActive)
    {
        //
        // Make sure we have enough space left and remap if necessary
        //

        if ((size > mapSize - currentOffset) &&
            !ResizeCurrentBuffer(size))
        {
            return FALSE;
        }

        //
        // If the current buffer is NOT used for recording EMF data,
        // we simply copy the input data buffer to the end of mapped file
        //
        
        PVOID pvBuf = GetPtr(0, size);

        if(pvBuf)
        {
            CopyMemory(pvBuf, buffer, size);

            ReleasePtr(pvBuf);

            CompleteCurrentBuffer(size);
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        TRACE_EMFSPL(("WriteData called while recording EMF data: %d ...\n", size));

        //
        // If we have an actively mapped view for recording EMF data,
        // then we need to cache the input buffer into a temporary buffer.
        //

        ASSERTGDI(size % sizeof(DWORD) == 0, "WriteData: misalignment\n");

        return WriteTempData(&scratchBuf, buffer, size);
    }

    return TRUE;
}


BOOL
EMFSpoolData::ResizeCurrentBuffer(
    DWORD   newsize
    )

/*++

Routine Description:

    Resize the current buffer so that its size is at least newsize

Arguments:

    newsize - New size for the current buffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    UINT64  newMapStart, newFileSize;
    DWORD   newMapSize, newOffset;
    HANDLE  hNewMap;
    PVOID   pNewMap;
    BOOL    success = FALSE;

    TRACE_EMFSPL(("ResizeCurrentBuffer: %d\n", newsize));

    //
    // Don't need to do anything if we're just shrinking the current buffer
    //

    if (newsize <= mapSize - currentOffset)
        return TRUE;

    if (hFile == INVALID_HANDLE_VALUE)
        return FALSE;

    //
    // We should always start file mapping at an offset that's
    // a multiple of file mapping block size. Similarly, mapping
    // size should also be a multiple of block size.
    //
    // Make sure the content of the current page are always mapped in view.
    //

    DWORD blockSize = GetFileMappingAlignment();

    if (emfrOffset == INVALID_EMFROFFSET)
        newOffset = currentOffset % blockSize;
    else
        newOffset = currentOffset;

    newMapStart = mapStart + (currentOffset - newOffset);
    newMapSize = ((newsize + newOffset + blockSize - 1) / blockSize) * blockSize;
    newFileSize = newMapStart + newMapSize;

    // WINBUG 365006 04-10-2001 pravins Further cleanup needed in EMFSpoolData
    // We wanted to minimize the number of changes to this class to support
    // arbitrary sized EMF streams.  There is further cleanup that is needed
    // in this code (removing cruft) to help reduce support costs in the furture.

    if(bMapping)
        emfc.Term();

    bMapping = emfc.Init(hFile, newMapStart, newFileSize);

    if(bMapping)
    {
        mapStart = newMapStart;
        mapSize = newMapSize;
        currentOffset = newOffset;
        bMapping = TRUE;
        success = TRUE;
    }
    else
    {
        // try to get back the old mapping ... hope this works :-)
        bMapping = emfc.Init(hFile, mapStart, mapSize);
        WARNING("ResizeCurrentBuffer: emfc intialization failed\n");
    }

    return success;
}


BOOL
EMFSpoolData::GetEMFData(
    MDC *pmdc
    )

/*++

Routine Description:

    Return a pointer to the start the current buffer for recording EMF data.

Arguments:

    pmdc - Pointer to the MDC object used for EMF recording

Return Value:

    Pointer to beginning of EMF data buffer
    NULL if there is an error

--*/

{
    TRACE_EMFSPL(("GetEMFData: %x ...\n", pmdc));

    if (pmdcActive)
    {
        WARNING("GetEMFData: overlapping EMF data buffer\n");
        return (FALSE);
    }

    if (!ResizeCurrentBuffer(sizeof(EMFITEMHEADER) + MF_BUFSIZE_INIT))
        return (FALSE);

    //
    // If we're not banding, write out an incomplete EMFITEMHEADER
    // for an EMF_METAFILE_DATA record.
    //

    emfrOffset = mapStart + currentOffset;

    if (!IsBanding())
    {
        EMFITEMHEADER emfr = { EMRI_METAFILE_DATA, 0 };

        if (!WriteData(&emfr, sizeof(emfr)))
        {
            emfrOffset = INVALID_EMFROFFSET;
            return (FALSE);
        }
    }

    pmdcActive = pmdc;
    return(TRUE);
}


BOOL
EMFSpoolData::ResizeEMFData(
    DWORD   newsize
    )

/*++

Routine Description:

    Resize current EMF data buffer

Arguments:

    newsize - new size of EMF data buffer

Return Value:

    Pointer to the beginning of EMF data buffer
    NULL if there is an error

--*/

{
    TRACE_EMFSPL(("ResizeEMFData: 0x%x ...\n", newsize));

    ASSERTGDI(pmdcActive, "ResizeEMFData: pmdcActive is NULL\n");

    return ResizeCurrentBuffer(newsize);
}


BOOL
EMFSpoolData::CompleteEMFData(
    DWORD   size,
    HANDLE* outFile,
    UINT64* outOffset
    )

/*++

Routine Description:

    Finish recording EMF data

Arguments:

    size - size of EMF data recorded

Return Value:

    Pointer to beginning of EMF data, NULL if there is an error

--*/

{
    DWORD   emfHeaderOffset = currentOffset;

    TRACE_EMFSPL(("CompleteEMFData: 0x%x ...\n", size));

    if (!pmdcActive)
        return FALSE;

    //
    // If size parameter is 0, the caller wants us to discard
    // any data recorded in the current EMF data buffer.
    //

    if (size == 0)
    {
        //
        // If we're not banding, we need to back over the incomplete
        // EMFITEMHEADER structure.
        //

        if (!IsBanding())
            currentOffset -= sizeof(EMFITEMHEADER);

        //
        // Get rid of any data collected in the temporary buffers as well
        //

        if ((scratchBuf && scratchBuf->currentSize) ||
            (fontBuf && fontBuf->currentSize))
        {
            WARNING("CompleteEMFData: temp buffers not empty\n");
        }

        FreeTempBuffers(FALSE);
        pmdcActive = NULL;

        *outOffset = emfHeaderOffset + mapStart;
        *outFile = hFile;

        return TRUE;
    }

    //
    // If we're not banding, fill out the incomplete EMF_METAFILE_DATA
    // record that we inserted earlier during GetEMFData()
    //

    if (!IsBanding())
    {
        EMFITEMHEADER *pemfr;

        pemfr = (EMFITEMHEADER *) GetPtrUsingSignedOffset(-((INT32) sizeof(EMFITEMHEADER)), sizeof(EMFITEMHEADER));

        if(pemfr)
        {
            pemfr->cjSize = size;
            ReleasePtr(pemfr);
        }
        else
        {
            WARNING("CompleteEMFData: failed to get EMFITEMHEADER pointer\n");
            return FALSE;
        }

    }

    //
    // Mark the current EMF data buffer as complete
    //

    CompleteCurrentBuffer(size);
    pmdcActive = NULL;

    //
    // Flush and empty the content of temporary buffers
    //

    BOOL result;

    result = FlushFontExtRecords() &&
             FlushTempBuffer(scratchBuf);

    FreeTempBuffers(FALSE);

    if(result)
    {
        *outOffset = emfHeaderOffset + mapStart;
        *outFile = hFile;
    }

    return result;
}


BOOL
EMFSpoolData::AbortEMFData()

/*++

Routine Description:

    Ensure we're not actively recording EMF data

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is a problem

--*/

{
//    if (pMapping == NULL)
    if(!bMapping)
        return FALSE;

    FreeTempBuffers(FALSE);

    if (pmdcActive != NULL)
    {
        WARNING("AbortEMFData: pmdcActive is not NULL\n");

        pmdcActive = NULL;
        emfrOffset = INVALID_EMFROFFSET;
        return FALSE;
    }

    return TRUE;
}


BOOL
EMFSpoolData::MapFile()

/*++

Routine Description:

    Map the EMF spool file into the current process' address space

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    if (hFile == INVALID_HANDLE_VALUE)
        return FALSE;
    else
    {
        //
        // Map in 64KB to start with
        //

        ResetMappingState();

        return ResizeCurrentBuffer(GetFileMappingAlignment());
    }
}


VOID
EMFSpoolData::UnmapFile(
    BOOL    bCloseHandle
    )

/*++

Routine Description:

    Unmap the currently mapped EMF spool file

Arguments:

    bCloseHandle - Whether to close the EMF spool file handle

Return Value:

    NONE

--*/

{
    TRACE_EMFSPL(("EMFSpoolData::UnmapFile(%d) ...\n", bCloseHandle));

    if(bMapping)
    {
        emfc.Term();
        bMapping = FALSE;
    }

    if (bCloseHandle && hFile != INVALID_HANDLE_VALUE)
    {
        if (IsBanding())
        {
            //
            // Close the temporary spool file (it's be deleted automatically)
            //

            if (!CloseHandle(hFile))
            {
                WARNING("Failed to close temporary spool file\n");
            }
        }
        else
        {
            if (!fpCloseSpoolFileHandle(hPrinter, hFile))
            {
                WARNING("CloseSpoolFileHandle failed\n");
            }
        }

        hFile = INVALID_HANDLE_VALUE;
    }

    ResetMappingState();
}


BOOL
EMFSpoolData::FlushPage(
    DWORD   pageType
    )

/*++

Routine Description:

    Finish the current page and flush the content of
    EMF spool file to the spooler

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
//    ASSERTGDI(pMapping && !pmdcActive, "FlushFile: inconsistent state\n");
    ASSERTGDI(bMapping && !pmdcActive, "FlushFile: inconsistent state\n");

    //
    // Output an EMRI_METAFILE_EXT or EMRI_BW_METAFILE_EXT record
    //

    EMFITEMHEADER_EXT endpage;

    endpage.emfi.ulID = (pageType == EMRI_BW_METAFILE) ?
                            EMRI_BW_METAFILE_EXT :
                            EMRI_METAFILE_EXT;

    endpage.emfi.cjSize = sizeof(endpage.offset);
    endpage.offset = mapStart + currentOffset - emfrOffset ;

    emfrOffset = INVALID_EMFROFFSET;

    if (!WriteData(&endpage, sizeof(endpage)))
    {
        WARNING("Failed to write out ENDPAGE record\n");
        return FALSE;
    }

    //
    // Commit the data for the current page to the spooler
    //

    DWORD   size;
    HANDLE  hNewFile;

    size = (DWORD) (GetTotalSize() - committedSize);

    TRACE_EMFSPL(("CommitSpoolData: %d bytes...\n", size));

    hNewFile = fpCommitSpoolData(hPrinter, hFile, size);

    if (hNewFile == INVALID_HANDLE_VALUE)
    {
        WARNING("CommitSpoolData failed\n");
    }

    if (hNewFile == hFile)
    {
        //
        // If the new handle is the same as the old handle, we
        // don't need to do any remapping. Simply proceed as usual.
        //

        committedSize += size;
        return TRUE;
    }
    else
    {
        //
        // Otherwise, we need to unmap the existing file
        // and remap the new file.
        //
        // We don't need to close existing handle here
        // because CommitSpoolData had already done so.
        //

        UnmapFile(FALSE);

        hFile = hNewFile;
        return MapFile();
    }
}


BOOL
EMFSpoolData::WriteTempData(
    PTempSpoolBuf  *ppBuf,
    PVOID           data,
    DWORD           size
    )

/*++

Routine Description:

    Write data into a temporary buffer

Arguments:

    ppBuf - Points to the temporary buffer pointer
    data - Points to data
    size - Size of data to be written

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define TEMPBLOCKSIZE       (4*1024)
#define ALIGNTEMPBLOCK(n)   (((n) + TEMPBLOCKSIZE - 1) / TEMPBLOCKSIZE * TEMPBLOCKSIZE)

{
    PTempSpoolBuf   buf = *ppBuf;
    DWORD           bufsize;

    //
    // Check if we need to allocate or grow the temporary buffer
    //

    if (!buf || size+buf->currentSize > buf->maxSize)
    {
        if (buf == NULL)
        {
            //
            // Allocate a new temporary buffer
            //

            bufsize = ALIGNTEMPBLOCK(size + TEMPBUF_DATAOFFSET);
            buf = (PTempSpoolBuf) LocalAlloc(LMEM_FIXED, bufsize);

            if (buf != NULL)
                buf->currentSize = 0;
        }
        else
        {
            //
            // Reallocate an existing memory buffer
            //

            WARNING("WriteTempData: reallocating temporary buffer\n");

            bufsize = ALIGNTEMPBLOCK(size + TEMPBUF_DATAOFFSET + buf->currentSize);
            buf = (PTempSpoolBuf) LocalReAlloc((HLOCAL) *ppBuf, bufsize, LMEM_MOVEABLE);
        }

        if (buf == NULL)
        {
            WARNING("WriteTempData: memory allocation failed\n");
            return FALSE;
        }

        buf->maxSize = bufsize - TEMPBUF_DATAOFFSET;
        *ppBuf = buf;
    }

    //
    // Copy the data into the temporary buffer
    //

    CopyMemory(&buf->data[buf->currentSize], data, size);
    buf->currentSize += size;
    return TRUE;
}


VOID
EMFSpoolData::FreeTempBuffers(
    BOOL    freeMem
    )

/*++

Routine Description:

    Free temporary buffers

Arguments:

    freeMem - Whether to keep or free the temporary buffer memory

Return Value:

    NONE

--*/

{
    if (freeMem)
    {
        //
        // Dispose of temparary buffers
        //

        if (scratchBuf)
        {
            LocalFree((HLOCAL) scratchBuf);
            scratchBuf = NULL;
        }

        if (fontBuf)
        {
            LocalFree((HLOCAL) fontBuf);
            fontBuf = NULL;
        }
    }
    else
    {
        //
        // Empty the temporary buffers but keep the memory
        //

        if (scratchBuf)
            scratchBuf->currentSize = 0;

        if (fontBuf)
            fontBuf->currentSize = 0;
    }
}


BOOL
EMFSpoolData::FlushTempBuffer(
    PTempSpoolBuf buf
    )

/*++

Routine Description:

    Copy the content of the temporary buffer into the spool file

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    if (pmdcActive)
    {
        WARNING("FlushTempBuffer called while recording EMF data\n");
        return FALSE;
    }

    return (buf == NULL) ||
           (buf->currentSize == 0) ||
           WriteData(buf->data, buf->currentSize);
}


BOOL
EMFSpoolData::AddFontExtRecord(
    DWORD   recType,
    DWORD   offset
    )

/*++

Routine Description:

    Remember where a font related EMFITEMHEADER_EXT record is

Arguments:

    recType - Spool record type
    offset - Offset relative to the beginning of EMF data

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    EMFITEMHEADER_EXT extrec;

    if (!pmdcActive)
    {
        WARNING("AddFontExtRecord: pmdcActive is NULL\n");
        return FALSE;
    }

    //
    // Map record type to its *_EXT counterpart
    //

    switch (recType)
    {
    case EMRI_ENGINE_FONT:
        recType = EMRI_ENGINE_FONT_EXT;
        break;

    case EMRI_TYPE1_FONT:
        recType = EMRI_TYPE1_FONT_EXT;
        break;

    case EMRI_DESIGNVECTOR:
        recType = EMRI_DESIGNVECTOR_EXT;
        break;

    case EMRI_SUBSET_FONT:
        recType = EMRI_SUBSET_FONT_EXT;
        break;

    case EMRI_DELTA_FONT:
        recType = EMRI_DELTA_FONT_EXT;
        break;

    case EMRI_EMBED_FONT_EXT:
        break;

    default:
        ASSERTGDI(FALSE, "AddFontExtRecord: illegal record type\n");
        return FALSE;
    }

    extrec.emfi.ulID = recType;
    extrec.emfi.cjSize = sizeof(extrec.offset);

    //
    // Remember the absolute offset relative to the beginning of file
    //

    extrec.offset = mapStart + currentOffset + offset;

    return WriteTempData(&fontBuf, &extrec, sizeof(extrec));
}


BOOL
EMFSpoolData::FlushFontExtRecords()

/*++

Routine Description:


Arguments:

    NONE

Return Value:

    NONE

--*/

{
    EMFITEMHEADER_EXT  *pExtRec;
    DWORD               count;
    UINT64              offset;

    //
    // Don't need to do anything if the temporary font buffer is empty
    //

    if (!fontBuf || fontBuf->currentSize == 0)
        return TRUE;

    ASSERTGDI(fontBuf->currentSize % sizeof(EMFITEMHEADER_EXT) == 0,
              "FlushFontExtRecords: invalid size info\n");

    count = fontBuf->currentSize / sizeof(EMFITEMHEADER_EXT);
    pExtRec = (EMFITEMHEADER_EXT *) fontBuf->data;
    offset = mapStart + currentOffset;

    //
    // Patch the offset field in the cached EMFITEMHEADER_EXT's
    //

    while (count--)
    {
        pExtRec->offset = offset - pExtRec->offset;
        offset += sizeof(EMFITEMHEADER_EXT);
        pExtRec++;
    }

    return FlushTempBuffer(fontBuf);
}


/*++

Routine Description:

    Create a temporary EMF spool file

Arguments:

    NONE

Return Value:

    Handle to the temporary spool file
    INVALID_HANDLE_VALUE if there is an error

--*/

HANDLE
CreateTempSpoolFile()
{
    WCHAR   tempPath[MAX_PATH];
    WCHAR   tempFilename[MAX_PATH];
    HANDLE  hFile;

    //
    // Get a unique temporary filename
    //

    if (!GetTempPathW(MAX_PATH, tempPath) ||
        !GetTempFileNameW(tempPath, L"SPL", 0, tempFilename))
    {
        return INVALID_HANDLE_VALUE;
    }

    //
    // Open a Read/Write handle to the temporary file
    //

    hFile = CreateFileW(tempFilename,
                        GENERIC_READ|GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NOT_CONTENT_INDEXED|FILE_ATTRIBUTE_TEMPORARY|FILE_FLAG_SEQUENTIAL_SCAN|FILE_FLAG_DELETE_ON_CLOSE,
                        NULL);

    //
    // If we fail to open the file, make sure to delete it
    //

    if (hFile == INVALID_HANDLE_VALUE)
    {
        WARNING("Failed to create temporary spool file\n");
        DeleteFileW(tempFilename);
    }

    return hFile;
}

HANDLE
EMFSpoolData::GetTempSpoolFileHandle()

/*++

Routine Description:

    Create a temporary EMF spool file used for banding

Arguments:

    NONE

Return Value:

    Handle to the temporary spool file
    INVALID_HANDLE_VALUE if there is an error

--*/
{
    return CreateTempSpoolFile();
}


//
// C helper functions for working with EMFSpoolData object
// (stored in the hEMFSpool field in LDC).
//
// NOTE: GDI doesn't new and delete operators.
// So we allocate and deallocate object memory manually here.
//

BOOL
AllocEMFSpoolData(
    PLDC    pldc,
    BOOL    banding
    )

{
    EMFSpoolData   *pEMFSpool;

    TRACE_EMFSPL(("AllocEMFSpoolData...\n"));

    //
    // Make sure we don't have an EMFSpoolData object
    // attached to LDC already
    //

    if (pldc->hEMFSpool != NULL)
    {
        WARNING("AllocEMFSpoolData: pldc->hEMFSpool is not NULL\n");
        DeleteEMFSpoolData(pldc);
    }

    //
    // Create a new EMFSpoolData object and initialize it
    //

    pEMFSpool = (EMFSpoolData *) LOCALALLOC(sizeof(EMFSpoolData));

    if (pEMFSpool != NULL)
    {
        if (!pEMFSpool->Init(pldc->hSpooler, banding))
        {
            pEMFSpool->Cleanup();
            LOCALFREE(pEMFSpool);
            pEMFSpool = NULL;
        }
        else
            pldc->hEMFSpool = (HANDLE) pEMFSpool;
    }

    return (pEMFSpool != NULL);
}


VOID
DeleteEMFSpoolData(
    PLDC    pldc
    )

{
    EMFSpoolData *pEMFSpool = (EMFSpoolData *) pldc->hEMFSpool;

    TRACE_EMFSPL(("DeleteEMFSpoolData...\n"));

    if (pEMFSpool != NULL)
    {
        pldc->hEMFSpool = NULL;

        pEMFSpool->Cleanup();
        LOCALFREE(pEMFSpool);
    }
}


BOOL
WriteEMFSpoolData(
    PLDC    pldc,
    PVOID   buffer,
    DWORD   size
    )

{
    EMFSpoolData *pEMFSpool = (EMFSpoolData *) pldc->hEMFSpool;

    TRACE_EMFSPL(("WriteEMFSpoolData...\n"));

    if (pEMFSpool == NULL)
    {
        ASSERTGDI(FALSE, "WriteEMFSpoolData: pldc->hEMFSpool is NULL\n");
        return FALSE;
    }
    else
        return pEMFSpool->WriteData(buffer, size);
}


BOOL
FlushEMFSpoolData(
    PLDC    pldc,
    DWORD   pageType
    )

{
    EMFSpoolData *pEMFSpool = (EMFSpoolData *) pldc->hEMFSpool;

    TRACE_EMFSPL(("FlushEMFSpoolData...\n"));

    if (pEMFSpool == NULL)
    {
        WARNING("FlushEMFSpoolData: pldc->hEMFSpool is NULL\n");
        return FALSE;
    }

    //
    // Ensure sure we're not actively recording EMF data
    //

    if (!pEMFSpool->AbortEMFData())
        return FALSE;

    //
    // If GDI is doing banding on the current DC, then
    // we don't need to send data to spooler. Instead,
    // we'll simply reuse the spool file as scratch space.
    //

    if (pEMFSpool->IsBanding())
    {
        pEMFSpool->UnmapFile(FALSE);
        return TRUE;
    }

    //
    // Finish the current page and prepare to record the next page
    //

    return pEMFSpool->FlushPage(pageType);
}

//
// Debug code for emulating spool file handle interface
//

#ifdef EMULATE_SPOOLFILE_INTERFACE

HANDLE  emPrinterHandle = NULL;
HANDLE  emFileHandle = INVALID_HANDLE_VALUE;
DWORD   emAccumCommitSize = 0;
DWORD   emFileFlags = FILE_FLAG_SEQUENTIAL_SCAN;

HANDLE WINAPI
GetSpoolFileHandle(
    HANDLE  hPrinter
    )

{
    WCHAR   tempPath[MAX_PATH];
    WCHAR   tempFilename[MAX_PATH];
    HANDLE  hFile;

    ASSERTGDI(emPrinterHandle == NULL && emFileHandle == INVALID_HANDLE_VALUE,
              "GetSpoolFileHandle: overlapped calls not allowed\n");

    if (!GetTempPathW(MAX_PATH, tempPath) ||
        !GetTempFileNameW(tempPath, L"SPL", 0, tempFilename))
    {
        return INVALID_HANDLE_VALUE;
    }

    hFile = CreateFileW(tempFilename,
                        GENERIC_READ|GENERIC_WRITE,
                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        emFileFlags,
                        NULL);
    
    if (hFile == INVALID_HANDLE_VALUE)
    {
        WARNING("Failed to create temporary spool file\n");
        DeleteFileW(tempFilename);
    }
    else
    {
        emAccumCommitSize = 0;
        emPrinterHandle = hPrinter;
        emFileHandle = hFile;
    }

    return hFile;
}


HANDLE WINAPI
CommitSpoolData(
    HANDLE  hPrinter,
    HANDLE  hSpoolFile,
    DWORD   cbCommit
    )

{
    ASSERTGDI(hPrinter == emPrinterHandle && hSpoolFile == emFileHandle,
              "CloseSpoolFileHandle: Bad handles\n");

    emAccumCommitSize += cbCommit;
    return hSpoolFile;
}

BOOL WINAPI
CloseSpoolFileHandle(
    HANDLE  hPrinter,
    HANDLE  hSpoolFile
    )

{
    ASSERTGDI(hPrinter == emPrinterHandle && hSpoolFile == emFileHandle,
              "CloseSpoolFileHandle: Bad handles\n");

    if (SetFilePointer(hSpoolFile, emAccumCommitSize, NULL, FILE_BEGIN) == 0xffffffff ||
        !SetEndOfFile(hSpoolFile))
    {
        WARNING("Couldn't set end-of-file pointer\n");
    }

    CloseHandle(hSpoolFile);
    emPrinterHandle = NULL;
    emFileHandle = INVALID_HANDLE_VALUE;

    return TRUE;
}

#endif // EMULATE_SPOOLFILE_INTERFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\firewall.h ===
/***************************************************************************\
* Module Name: FIREWALL.HXX                                                 *
*                                                                           *
* Contains FIREWALL macros.  These are like assert() functions that go away *
* when FIREWALLS is not defined.                                            *
*                                                                           *
* Created: Sat 24-Sep-1988 22:45:53                                         *
* Author:  Charles Whitmer [chuckwh]                                        *
*                                                                           *
* Copyright (c) 1988-1999 Microsoft Corporation                             *
\***************************************************************************/

// Define the RIP and ASSERT macros.

#if DBG

extern  ULONG   gdi_dbgflags;
#define GDI_DBGFLAGS_VERBOSE    0x0001
#define GDI_DBGFLAGS_ERRORRIP   0x0002

#define RIP(x) {DbgPrint(x); DbgBreakPoint();}
#ifndef ASSERTGDI
#define ASSERTGDI(x,y) if(!(x)) RIP(y)
#endif
#define VERIFYGDI(x,y)                                                      \
        {if(!(x))                                                           \
         {DbgPrint(y);                                                      \
          if(gdi_dbgflags & (GDI_DBGFLAGS_VERBOSE|GDI_DBGFLAGS_ERRORRIP))   \
            DbgBreakPoint();}}
#define ERROR_ASSERT(x,y)                                                   \
        {if((gdi_dbgflags & (GDI_DBGFLAGS_VERBOSE|GDI_DBGFLAGS_ERRORRIP))   \
            && !(x))                                                        \
            RIP(y)}
#define PUTS(x) {if (gdi_dbgflags & GDI_DBGFLAGS_VERBOSE) DbgPrint(x);}
#define PUTSX(x,y) {if (gdi_dbgflags & GDI_DBGFLAGS_VERBOSE) DbgPrint(x,y);}
#define USE(x)  x = x
#define WARNING(x) DbgPrint(x)
#define WARNING1(x) DbgPrint(x)
#else
#define RIP(x)
#define ASSERTGDI(x,y)
#define VERIFYGDI(x,y)
#define ERROR_ASSERT(x,y)
#define PUTS(x)
#define PUTSX(x,y)
#define USE(x)
#define WARNING(x)
#define WARNING1(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\dllinit.c ===
/******************************Module*Header*******************************\
* Module Name: dllinit.c                                                   *
*                                                                          *
* Contains the GDI library initialization routines.                        *
*                                                                          *
* Created: 07-Nov-1990 13:30:31                                            *
* Author: Eric Kutter [erick]                                              *
*                                                                          *
* Copyright (c) 1990-1999 Microsoft Corporation                            *
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

#include "glsup.h"

extern PVOID pAFRTNodeList;
extern VOID vSetCheckDBCSTrailByte(DWORD dwCodePage);
NTSTATUS GdiProcessSetup();
VOID GdiProcessShutdown();

#ifdef LANGPACK
#include "winuserp.h"
#endif

HBRUSH ghbrDCBrush;
HPEN   ghbrDCPen;

BOOL  gbWOW64 = FALSE;

/******************************Public*Routine******************************\
* GdiDllInitialize                                                         *
*                                                                          *
* This is the init procedure for GDI.DLL, which is called each time a new  *
* process links to it.                                                     *
*                                                                          *
* History:                                                                 *
*  Thu 30-May-1991 18:08:00 -by- Charles Whitmer [chuckwh]                 *
* Added Local Handle Table initialization.                                 *
\**************************************************************************/

#if defined(_GDIPLUS_)

    //
    // The following are globals kept in 'gre':
    //

    extern PGDI_SHARED_MEMORY gpGdiSharedMemory;
    extern PENTRY gpentHmgr;
    extern PDEVCAPS gpGdiDevCaps;

#endif

PGDI_SHARED_MEMORY pGdiSharedMemory = NULL;
PENTRY          pGdiSharedHandleTable = NULL;
PDEVCAPS        pGdiDevCaps = NULL;
W32PID          gW32PID;
UINT            guintAcp;
UINT            guintDBCScp;

PGDIHANDLECACHE pGdiHandleCache;

BOOL gbFirst = TRUE;

#ifdef LANGPACK
BOOL gbLpk = FALSE;
FPLPKEXTEXTOUT              fpLpkExtTextOut;
FPLPKGETCHARACTERPLACEMENT  fpLpkGetCharacterPlacement;
FPLPKGETTEXTEXTENTEXPOINT   fpLpkGetTextExtentExPoint;
FPLPKUSEGDIWIDTHCACHE       fpLpkUseGDIWidthCache;

VOID GdiInitializeLanguagePack(DWORD);
#endif

NTSTATUS GdiDllInitialize(
    PVOID pvDllHandle,
    ULONG ulReason)
{
    NTSTATUS Status = STATUS_SUCCESS;
    INT i;
    PTEB pteb = NtCurrentTeb();

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(pvDllHandle);

        //
        // force the kernel to initialize.  This should be done last
        // since ClientThreadSetup is going to get called before this returns.
        //

        if (NtGdiInit() != TRUE)
        {
            return(STATUS_NO_MEMORY);
        }

        Status = GdiProcessSetup();

        ghbrDCBrush = GetStockObject (DC_BRUSH);
        ghbrDCPen = GetStockObject (DC_PEN);

#ifdef BUILD_WOW6432
        gbWOW64 = TRUE;
#endif
        break;

    case DLL_PROCESS_DETACH:

        GdiProcessShutdown();
        break;
    }

    return(Status);
}

/******************************Public*Routine******************************\
* GdiProcessSetup()
*
* This gets called from two places.  Once at dll init time and another when
* USER gets called back when the kernel initializes itself for this process.
* It is only after the kernel is initialized that the GdiSharedHandleTable
* is available but the other globals need to be setup right away.
*
* History:
*  11-Sep-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

NTSTATUS GdiProcessSetup()
{
    NTSTATUS Status = STATUS_SUCCESS;
    PTEB pteb = NtCurrentTeb();

    // who ever calls this first needs to initialize the global variables.

    if (gbFirst)
    {
        //
        // Initialize the GL metafile support semaphore
        //

        Status = (NTSTATUS)INITIALIZECRITICALSECTION(&semGlLoad);
        if (!NT_SUCCESS(Status))
        {
            WARNING("InitializeCriticalSection failed\n");
            return(Status);
        }

        //
        // Initialize the local semaphore and reserve the Local Handle Table
        // for the process.
        //

        Status = (NTSTATUS)INITIALIZECRITICALSECTION(&semLocal);
        if (!NT_SUCCESS(Status))
        {
            WARNING("InitializeCriticalSection failed\n");
            return(Status);
        }

        //
        // Initialize critical sections for ICM
        //

        Status = (NTSTATUS)INITIALIZECRITICALSECTION(&semListIcmInfo);
        if (!NT_SUCCESS(Status))
        {
            WARNING("InitializeCriticalSection failed\n");
            return(Status);
        }

        Status = (NTSTATUS)INITIALIZECRITICALSECTION(&semColorTransformCache);
        if (!NT_SUCCESS(Status))
        {
            WARNING("InitializeCriticalSection failed\n");
            return(Status);
        }

        Status = (NTSTATUS)INITIALIZECRITICALSECTION(&semColorSpaceCache);
        if (!NT_SUCCESS(Status))
        {
            WARNING("InitializeCriticalSection failed\n");
            return(Status);
        }

        //
        // Initialize critical section for UMPD
        //

        Status = (NTSTATUS)INITIALIZECRITICALSECTION(&semUMPD);
        if (!NT_SUCCESS(Status))
        {
            WARNING("InitializeCriticalSection failed\n");
            return(Status);
        }

        pAFRTNodeList = NULL;
        guintAcp = GetACP();

        if(IS_ANY_DBCS_CODEPAGE(guintAcp))
        {
        // if the default code page is a DBCS code page then set guintACP to 1252
        // since we want to compute client wide widths for SBCS fonts for code page
        // 1252 in addition to DBCS fonts for the default code page

            vSetCheckDBCSTrailByte(guintAcp);
            guintDBCScp = guintAcp;
            guintAcp = 1252;
        }
        else
        {
            guintDBCScp = 0xFFFFFFFF;  // assume this will never be a valid CP
        }

#ifdef FE_SB
        fFontAssocStatus = NtGdiQueryFontAssocInfo(NULL);
#endif

        // assign unique process ID

        gW32PID = (W32PID)((ULONG)((ULONG_PTR)pteb->ClientId.UniqueProcess & PID_BITS));

#ifdef LANGPACK
        if(((PGDI_SHARED_MEMORY) NtCurrentPebShared()->GdiSharedHandleTable)->dwLpkShapingDLLs)
        {
            GdiInitializeLanguagePack(
                ((PGDI_SHARED_MEMORY)
                 NtCurrentPebShared()->GdiSharedHandleTable)->dwLpkShapingDLLs);
        }
#endif

        gbFirst = FALSE;

        //
        // ICM has not been initialized
        //

        ghICM = NULL;

        InitializeListHead(&ListIcmInfo);
        InitializeListHead(&ListCachedColorSpace);
        InitializeListHead(&ListCachedColorTransform);
    }

    // The pshared handle table needs to be set everytime this routine gets
    // called in case the PEB doesn't have it yet for the first.

#if !defined(_GDIPLUS_)

    pGdiSharedMemory      = (PGDI_SHARED_MEMORY) NtCurrentPebShared()->GdiSharedHandleTable;
    pGdiSharedHandleTable = pGdiSharedMemory->aentryHmgr;
    pGdiDevCaps           = &pGdiSharedMemory->DevCaps;

    if (GetAppCompatFlags2(VER40) & GACF2_NOBATCHING)
    {
        GdiBatchLimit = 0;
    }
    else
    {
        GdiBatchLimit         = (NtCurrentPebShared()->GdiDCAttributeList) & 0xff;
    }

    pGdiHandleCache       = (PGDIHANDLECACHE)(&NtCurrentPebShared()->GdiHandleBuffer[0]);

#else

    pGdiSharedMemory      = gpGdiSharedMemory;
    pGdiSharedHandleTable = gpentHmgr;
    pGdiDevCaps           = gpGdiDevCaps;

    //
    // Be sure to disable batching and handle caching.
    //

    GdiBatchLimit = 0;
    pGdiHandleCache = NULL;

#endif

    // @@@ Add TrueType fonts

    #if defined(_GDIPLUS_)

    AddFontResourceW(L"arial.ttf");
    AddFontResourceW(L"cour.ttf");

    #endif // _GDIPLUS_

    return(Status);
}


/******************************Public*Routine******************************\
* GdiProcessShutdown()
*
* Historically, gdi32.dll has allowed process termination to release the
* user-mode resources.  However, some apps may use LoadLibrary/FreeLibrary
* to hook gdi32.dll, in which case the FreeLibrary will not free any of
* the resources.
*
* As a system component, we should do a good job and cleanup after ourselves
* instead of relying on process termination.
*
\**************************************************************************/

VOID GdiProcessShutdown()
{
    if (gbWOW64)
    {
        vUMPDWow64Shutdown();
    }
    DELETECRITICALSECTION(&semUMPD);
    DELETECRITICALSECTION(&semColorSpaceCache);
    DELETECRITICALSECTION(&semColorTransformCache);
    DELETECRITICALSECTION(&semListIcmInfo);
    DELETECRITICALSECTION(&semLocal);
    DELETECRITICALSECTION(&semGlLoad);
}


#ifdef LANGPACK
VOID GdiInitializeLanguagePack(DWORD dwLpkShapingDLLs)
{
    FPLPKINITIALIZE fpLpkInitialize;

    HANDLE hLpk = LoadLibraryW(L"LPK.DLL");

    if (hLpk != NULL)
    {
        FARPROC fpUser[4];

        fpLpkInitialize = (FPLPKINITIALIZE)
          GetProcAddress(hLpk,"LpkInitialize");

        fpLpkExtTextOut = (FPLPKEXTEXTOUT)
          GetProcAddress(hLpk,"LpkExtTextOut");

        fpLpkGetCharacterPlacement = (FPLPKGETCHARACTERPLACEMENT)
          GetProcAddress(hLpk,"LpkGetCharacterPlacement");


        fpLpkGetTextExtentExPoint = (FPLPKGETTEXTEXTENTEXPOINT)
          GetProcAddress(hLpk,"LpkGetTextExtentExPoint");

        fpLpkUseGDIWidthCache = (FPLPKUSEGDIWIDTHCACHE)
          GetProcAddress(hLpk,"LpkUseGDIWidthCache");

        fpUser[LPK_TABBED_TEXT_OUT] =
          GetProcAddress(hLpk,"LpkTabbedTextOut");


        fpUser[LPK_PSM_TEXT_OUT] =
          GetProcAddress(hLpk,"LpkPSMTextOut");


        fpUser[LPK_DRAW_TEXT_EX] =
          GetProcAddress(hLpk,"LpkDrawTextEx");

        fpUser[LPK_EDIT_CONTROL] =
          GetProcAddress(hLpk,"LpkEditControl");


        if(fpLpkInitialize &&
           fpLpkExtTextOut &&
           fpLpkGetCharacterPlacement &&
           fpLpkGetTextExtentExPoint &&
           fpLpkUseGDIWidthCache &&
           fpUser[LPK_TABBED_TEXT_OUT] &&
           fpUser[LPK_PSM_TEXT_OUT] &&
           fpUser[LPK_DRAW_TEXT_EX] &&
           fpUser[LPK_EDIT_CONTROL])
        {
            if((*fpLpkInitialize)(dwLpkShapingDLLs))
            {
                gbLpk = TRUE;
                InitializeLpkHooks(fpUser);
            }
            else
            {
                WARNING("gdi32: LPK initialization routine return FALSE\n");
                FreeLibrary(hLpk);
            }
        }
        else
        {
            WARNING("gdi32: one or more require LPK functions missing\n");
            FreeLibrary(hLpk);
        }
    }
    else
    {
        WARNING("gdi32: unable to load LPK\n");
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\font.h ===
/*******************************************************************************
 * font.h
 *
 * Structures for client side caching of char widths.
 *
 * Copyright (c) 1994-1999 Microsoft Corporation
 *
 *******************************************************************************/


/**************************************************************************\
*
*   CFONT's are a client side cache of font metric information.  This includes
*   character widths for the first 256 glyphs as well as textmetric's and
*   average character width used by USER's GetCharDimensions.  There are two
*   flavors of this cache, public and private.
*
*   private:
*       for private fonts, the pUser field in the handle table points to a
*       LOCALFONT.  The LOCALFONT has a chain of CFONT's hanging off it for
*       accumulating information per transform.
*
*   public:
*       For public fonts which include both stock fonts and fonts USER makes
*       public, the CFONT structures live in a shared memory area in the
*       GDI_SHARED_MEMORY structure which is mapped into all processes with
*       the handle manager table.  For these fonts, we only cache data for
*       the primary display and a 1-to-1 mapping (MM_TEXT).  This way, there
*       is only CFONT per public font.
*
\**************************************************************************/


// Flags for LOCALFONT.fl:

#define LF_HARDWAY        0x0001    // Font not worth mapping client side.

typedef struct _LOCALFONT
{
    FLONG              fl;
    CFONT             *pcf;
} LOCALFONT;



LOCALFONT *plfCreateLOCALFONT(FLONG fl);
VOID       vDeleteLOCALFONT(LOCALFONT *plf);

CFONT     *pcfLocateCFONT(HDC hdc,PDC_ATTR pDcAttr,UINT iFirst,PVOID pch,UINT c,BOOL bType);
BOOL       bGetTextExtentA(HDC hdc,LPCSTR psz,int c,LPSIZE psizl,UINT fl);
BOOL       bGetTextExtentW(HDC hdc,LPCWSTR pwsz,int cwc,LPSIZE psizl,UINT fl);
BOOL       bComputeTextExtent(PDC_ATTR pDcAttr,CFONT *pcf,PVOID psz,int cc,UINT fl,SIZE *psizl, BOOL bType);
BOOL       bComputeCharWidths(CFONT *pcf,UINT iFirst, UINT iLast,ULONG fl,PVOID pv);
BOOL       bGetTextMetricsWInternal(HDC hdc,TMW_INTERNAL * ptmw,int cjTM,CFONT *pcf);

VOID FASTCALL vTextMetricWToTextMetric(LPTEXTMETRICA,TMW_INTERNAL *);
VOID FASTCALL vTextMetricWToTextMetricStrict(LPTEXTMETRICA,LPTEXTMETRICW);

VOID vConvertEnumLogFontExDvAtoW(ENUMLOGFONTEXDVW *pelfw, ENUMLOGFONTEXDVA *pelfa);
VOID vConvertLogFontW(ENUMLOGFONTEXDVW *pelfw, LOGFONTW *plfw);
VOID vConvertLogFont(ENUMLOGFONTEXDVW *pelfw, LOGFONTA *plf);
BOOL bConvertEnumLogFontExWToEnumLogFontExA(ENUMLOGFONTEXA *,ENUMLOGFONTEXW *);
BOOL bConvertLogFontWToLogFontA(LOGFONTA *, LOGFONTW *);

typedef struct _CLIENT_SIDE_FILEVIEW    // fvw
{
    HANDLE hf;       // file handle
    HANDLE hSection; // section handle
    PVOID  pvView;           // pointer to the view of the memory mapped file
    ULONG  cjView;           // size, really end of the file information
} CLIENT_SIDE_FILEVIEW, *PCLIENT_SIDE_FILEVIEW;

BOOL bMapFileUNICODEClideSide(PWSTR pwszFileName, CLIENT_SIDE_FILEVIEW *pfvw, BOOL bNtPath);
VOID vUnmapFileClideSide(PCLIENT_SIDE_FILEVIEW pfvw);

#define WVT_PERF_EVAL
VOID vGetWvtPerf(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\fareast.c ===
/******************************Module*Header*******************************\
* Module Name: nlsconv.c                                                   *
*                                                                          *
* DBCS specific routines                                                   *
*                                                                          *
* Created: 15-Mar-1994 15:56:30                                            *
* Author: Gerrit van Wingerden [gerritv]                                   *
*                                                                          *
* Copyright (c) 1994-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

UINT fFontAssocStatus = 0;

BYTE cLowTrailByteSet1 = 0xff;
BYTE cHighTrailByteSet1 = 0x0;
BYTE cLowTrailByteSet2 =  0xff;
BYTE cHighTrailByteSet2 = 0x0;

/******************************Public*Routine******************************\
*                                                                          *
* DBCS Trailling Byte validate check functions.                            *
*                                                                          *
\**************************************************************************/


#define IS_DBCS_TRAIL_BYTE(Char) (\
                                   ((Char >= cLowTrailByteSet1) && (Char <= cHighTrailByteSet1)) \
                                 ||((Char >= cLowTrailByteSet2) && (Char <= cHighTrailByteSet2)) \
                                 )

/**************************************************************************\
*                                                                          *
* SHIFT-JIS (Japanese) character set : CodePage 932                        *
*                                                                          *
*  Valid LeadByte Range   | Valid TailByte Range                           *
*  -----------------------+---------------------                           *
*  From  -> To            |  From  -> To                                   *
*  - - - - - - - - - - - - - - - - - - - - - - -                           *
*  0x81  -> 0x9F          |  0x40  -> 0xFC                                 *
*  0xE0  -> 0xFC          |                                                *
*                                                                          *
\**************************************************************************/

/**************************************************************************\
*                                                                          *
* WANSANG (Korean) character set : CodePage 949                            *
*                                                                          *
*  Valid LeadByte Range   | Valid TailByte Range                           *
*  -----------------------+---------------------                           *
*  From  -> To            |  From  -> To                                   *
*  - - - - - - - - - - - - - - - - - - - - - - -                           *
*  0xA1  -> 0xAC          |  0x40  -> 0xFC                                 *
*  0xB0  -> 0xC8          |                                                *
*  0xCA  -> 0xFD          |                                                *
*                                                                          *
\**************************************************************************/

/**************************************************************************\
*                                                                          *
* GB2312 (PRC Chinese) character set : CodePage 936                        *
*                                                                          *
*  Valid LeadByte Range   | Valid TailByte Range                           *
*  -----------------------+---------------------                           *
*  From  -> To            |  From  -> To                                   *
*  - - - - - - - - - - - - - - - - - - - - - - -                           *
*  0xA1  -> 0xA9          |  0xA1  -> 0xFE                                 *
*  0xB0  -> 0xF7          |                                                *
*                                                                          *
\**************************************************************************/

/**************************************************************************\
*                                                                          *
* Big 5 (Taiwan,Hong Kong Chinese) character set : CodePage 950            *
*                                                                          *
*  Valid LeadByte Range   | Valid TailByte Range                           *
*  -----------------------+---------------------                           *
*  From  -> To            |  From  -> To                                   *
*  - - - - - - - - - - - - - - - - - - - - - - -                           *
*  0x81  -> 0xFE          |  0x40  -> 0x7E                                 *
*                         |  0xA1  -> 0xFE                                 *
*                                                                          *
\**************************************************************************/

/******************************Public*Routine******************************\
* vSetCheckDBCSTrailByte()
*
* This function setup function for the DBCS trailling byte validation of
* specified character with specified Fareast codepage.
*
*  Thu-15-Feb-1996 11:59:00 -by- Gerrit van Wingerden
* Moved function pointer out of CFONT and into a global variable.
*
*  Wed 20-Dec-1994 10:00:00 -by- Hideyuki Nagase [hideyukn]
* Write it.
\**************************************************************************/

VOID vSetCheckDBCSTrailByte(DWORD dwCodePage)
{
    switch( dwCodePage )
    {
    case 932:
        cLowTrailByteSet1 = (CHAR) 0x40;
        cHighTrailByteSet1 = (CHAR) 0xfc;
        cLowTrailByteSet2 = (CHAR) 0x40;
        cHighTrailByteSet2 = (CHAR) 0xfc;
        break;

    case 949:
        cLowTrailByteSet1 = (CHAR) 0x40;
        cHighTrailByteSet1 = (CHAR) 0xfc;
        cLowTrailByteSet2 = (CHAR) 0x40;
        cHighTrailByteSet2 = (CHAR) 0xfc;
        break;

    case  936:
        cLowTrailByteSet1 = (CHAR) 0xa1;
        cHighTrailByteSet1 = (CHAR) 0xfe;
        cLowTrailByteSet2 = (CHAR) 0xa1;
        cHighTrailByteSet2 = (CHAR) 0xfe;
        break;

    case 950:
        cLowTrailByteSet1 = (CHAR) 0x40;
        cHighTrailByteSet1 = (CHAR) 0x7e;
        cLowTrailByteSet2 = (CHAR) 0xa1;
        cHighTrailByteSet2 = (CHAR) 0xfe;
        break;

    default:
        cLowTrailByteSet1 = (CHAR) 0xff;
        cHighTrailByteSet1 = (CHAR) 0x0;
        cLowTrailByteSet2 = (CHAR) 0xff;
        cHighTrailByteSet2 = (CHAR) 0x0;
        WARNING("GDI32!INVALID DBCS codepage\n");
        break;
    }
}


/******************************Public*Routine******************************\
* bComputeCharWidthsDBCS
*
* Client side version of GetCharWidth for DBCS fonts
*
*  Wed 18-Aug-1993 10:00:00 -by- Gerrit van Wingerden [gerritv]
* Stole it and converted for DBCS use.
*
*  Sat 16-Jan-1993 04:27:19 -by- Charles Whitmer [chuckwh]
* Wrote bComputeCharWidths on which this is based.
\**************************************************************************/

BOOL bComputeCharWidthsDBCS
(
    CFONT *pcf,
    UINT   iFirst,
    UINT   iLast,
    ULONG  fl,
    PVOID  pv
)
{
    USHORT *ps;
    USHORT ausWidths[256];
    UINT    ii, cc;

    if( iLast - iFirst  > 0xFF )
    {
        WARNING("bComputeCharWidthsDBCS iLast - iFirst > 0xFF" );
        return(FALSE);
    }

    if( iLast < iFirst )
    {
        WARNING("bComputeCharWidthsDBCS iLast < iFirst" );
        return(FALSE);
    }

    // We want to compute the same widths that would be computed if
    // vSetUpUnicodeStringx were called with this first and last and then
    // GetCharWidthsW was called. The logic may be wierd but I assume it is
    // there for Win 3.1J char widths compatability. To do this first fill
    // in the plain widths in ausWidths and then do all the neccesary
    // computation on them.

    if ( gpwcDBCSCharSet[(UCHAR)(iFirst>>8)] == 0xFFFF )
    {
        for( cc = 0 ; cc <= iLast - iFirst; cc++ )
        {
        // If this is a legitimate DBCS character then use
        // MaxCharInc.

            ausWidths[cc] = pcf->wd.sDBCSInc;
        }
    }
    else
    {
        for( ii = (iFirst & 0x00FF), cc = 0; ii <= (iLast & 0x00FF); cc++, ii++ )
        {
        // Just treat everything as a single byte unless we
        // encounter a DBCS lead byte which we will treat as a
        // default character.

            if( gpwcDBCSCharSet[ii] == 0xFFFF )
            {
                ausWidths[cc] = pcf->wd.sDefaultInc;
            }
            else
            {
                ausWidths[cc] = pcf->sWidth[ii];
            }
        }
    }

    switch (fl & (GCW_INT | GCW_16BIT))
    {
    case GCW_INT:               // Get LONG widths.
        {
            LONG *pl = (LONG *) pv;
            LONG fxOverhang = 0;

        // Check for Win 3.1 compatibility.

            if (fl & GCW_WIN3)
                fxOverhang = pcf->wd.sOverhang;

        // Do the trivial no-transform case.

            if (bIsOneSixteenthEFLOAT(pcf->efDtoWBaseline))
            {
                fxOverhang += 8;    // To round the final result.

            //  for (ii=iFirst; ii<=iLast; ii++)
            //      *pl++ = (pcf->sWidth[ii] + fxOverhang) >> 4;

                ps = ausWidths;
                ii = iLast - iFirst;
            unroll_1:
                switch(ii)
                {
                default:
                    pl[4] = (ps[4] + fxOverhang) >> 4;
                case 3:
                    pl[3] = (ps[3] + fxOverhang) >> 4;
                case 2:
                    pl[2] = (ps[2] + fxOverhang) >> 4;
                case 1:
                    pl[1] = (ps[1] + fxOverhang) >> 4;
                case 0:
                    pl[0] = (ps[0] + fxOverhang) >> 4;
                }
                if (ii > 4)
                {
                    ii -= 5;
                    pl += 5;
                    ps += 5;
                    goto unroll_1;
                }
                return(TRUE);
            }

        // Otherwise use the back transform.

            else
            {
                for (ii=0; ii<=iLast-iFirst; ii++)
                    *pl++ = lCvt(pcf->efDtoWBaseline,ausWidths[ii] + fxOverhang);
                return(TRUE);
            }
        }

    case GCW_INT+GCW_16BIT:     // Get SHORT widths.
        {
            USHORT *psDst = (USHORT *) pv;
            USHORT  fsOverhang = 0;

        // Check for Win 3.1 compatibility.

            if (fl & GCW_WIN3)
                fsOverhang = pcf->wd.sOverhang;

        // Do the trivial no-transform case.

            if (bIsOneSixteenthEFLOAT(pcf->efDtoWBaseline))
            {
                fsOverhang += 8;    // To round the final result.

            //  for (ii=iFirst; ii<=iLast; ii++)
            //      *psDst++ = (pcf->sWidth[ii] + fsOverhang) >> 4;

                ps = ausWidths;
                ii = iLast - iFirst;
            unroll_2:
                switch(ii)
                {
                default:
                    psDst[4] = (ps[4] + fsOverhang) >> 4;
                case 3:
                    psDst[3] = (ps[3] + fsOverhang) >> 4;
                case 2:
                    psDst[2] = (ps[2] + fsOverhang) >> 4;
                case 1:
                    psDst[1] = (ps[1] + fsOverhang) >> 4;
                case 0:
                    psDst[0] = (ps[0] + fsOverhang) >> 4;
                }
                if (ii > 4)
                {
                    ii -= 5;
                    psDst += 5;
                    ps += 5;
                    goto unroll_2;
                }
                return(TRUE);
            }

        // Otherwise use the back transform.

            else
            {
                for (ii=0; ii<=iLast-iFirst; ii++)
                {
                    *psDst++ = (USHORT)
                               lCvt
                               (
                                   pcf->efDtoWBaseline,
                                   (LONG) (ausWidths[ii] + fsOverhang)
                               );
                }
                return(TRUE);
            }
        }

    case 0:                     // Get FLOAT widths.
        {
            LONG *pe = (LONG *) pv; // Cheat to avoid expensive copies.
            EFLOAT_S efWidth,efWidthLogical;

            for (ii=0; ii<=iLast-iFirst; ii++)
            {
                vFxToEf((LONG) ausWidths[ii],efWidth);
                vMulEFLOAT(efWidthLogical,efWidth,pcf->efDtoWBaseline);
                *pe++ = lEfToF(efWidthLogical);
            }
            return(TRUE);
        }
    }
    RIP("bComputeCharWidths: Don't come here!\n");
    return(FALSE);
}

BOOL bIsDBCSString
(
    LPCSTR psz,
    int    cc
)
{
    int   ii;
    BYTE *pc;

    pc = (BYTE *) psz;

    cc--; // do not go off the edge !

    for (ii=0; ii<cc; ii++)
    {
    // if DBCS lead byte add in DBCS width

        if((gpwcDBCSCharSet[pc[ii]] == 0xFFFF)) // is this a DBCS LeadByte
        {
            return TRUE;
        }
    }

    return FALSE;
}

/******************************Public*Routine******************************\
* bComputeTextExtentDBCS (pldc,pcf,psz,cc,fl,psizl)
*
* A quick function to compute text extents on the client side for DBCS
* fonts.
*
*  Tue 17-Aug-1993 10:00:00 -by- Gerrit van Wingerden [gerritv]
* Stole it and converted for DBCS use.
*
*  Thu 14-Jan-1993 04:00:57 -by- Charles Whitmer [chuckwh]
* Wrote bComputeTextExtent from which this was stolen.
\**************************************************************************/

BOOL bComputeTextExtentDBCS
(
    PDC_ATTR    pDcAttr,
    CFONT *pcf,
    LPCSTR psz,
    int    cc,
    UINT   fl,
    SIZE  *psizl
)
{
    LONG  fxBasicExtent;
    INT   lTextExtra,lBreakExtra,cBreak;
    INT   cChars = 0;
    int   ii;
    BYTE *pc;
    FIX   fxCharExtra = 0;
    FIX   fxBreakExtra;
    FIX   fxExtra = 0;

    lTextExtra = pDcAttr->lTextExtra;
    lBreakExtra = pDcAttr->lBreakExtra;
    cBreak = pDcAttr->cBreak;

    pc = (BYTE *) psz;

// Compute the basic extent.

    fxBasicExtent = 0;
    pc = (BYTE *) psz;

    for (ii=0; ii<cc; ii++)
    {
    // if DBCS lead byte add in DBCS width

        if( /* Check the string has two bytes or more ? */
            cc - ii - 1 &&
            /* Check Is this a DBCS LeadByte ? */
            gpwcDBCSCharSet[*pc] == 0xFFFF &&
            /* Check Is this a DBCS TrailByte ? */
            IS_DBCS_TRAIL_BYTE((*(pc+sizeof(CHAR))))
          )
        {
            ii++;
            pc += 2;
            fxBasicExtent += pcf->wd.sDBCSInc;
        }
        else
        {
            fxBasicExtent += pcf->sWidth[*pc++];
        }

        cChars += 1;
    }

// Adjust for CharExtra.

    if (lTextExtra)
    {
        int cNoBackup = 0;

        fxCharExtra = lCvt(pcf->efM11,lTextExtra);

        if( fxCharExtra < 0 )
        {
        // the layout code won't backup a characters past it's origin regardless
        // of the value of iTextCharExtra so figure out for how many values
        // we will need to ignore fxCharExtra

            if( pcf->wd.sCharInc == 0 )
            {
                for( ii = 0; ii < cc; ii++ )
                {
                    if( gpwcDBCSCharSet[(BYTE)psz[ii]] == 0xFFFF )
                    {
                        if( pcf->wd.sDBCSInc + fxCharExtra <= 0 )
                        {
                            cNoBackup += 1;
                        }
                        ii++;
                    }
                    else
                    {
                        if( pcf->sWidth[(BYTE)psz[ii]] + fxCharExtra <= 0 )
                        {
                            cNoBackup += 1;
                        }
                    }
                }
            }
            else
            if( pcf->wd.sCharInc + fxCharExtra <= 0 )
            {
                cNoBackup = cChars;
            }
        }

        if ( (fl & GGTE_WIN3_EXTENT) && (pcf->hdc == 0)
            && (!(pcf->flInfo & FM_INFO_TECH_STROKE)) )
            fxExtra = fxCharExtra * ((lTextExtra > 0) ? cChars : (cChars - 1));
        else
            fxExtra = fxCharExtra * ( cChars - cNoBackup );
    }

// Adjust for lBreakExtra.

    if (lBreakExtra && cBreak)
    {
        fxBreakExtra = lCvt(pcf->efM11,lBreakExtra) / cBreak;

    // Windows won't let us back up over a break.  Set up the BreakExtra
    // to just cancel out what we've already got.

        if (fxBreakExtra + pcf->wd.sBreak + fxCharExtra < 0)
            fxBreakExtra = -(pcf->wd.sBreak + fxCharExtra);

    // Add it up for all breaks.

        pc = (BYTE *) psz;
        for (ii=0; ii<cc; ii++)
        {
            if (gpwcDBCSCharSet[*pc] == 0xFFFF)
            {
                ii++;
                pc += 2;
            }
            else if (*pc++ == pcf->wd.iBreak)
            {
                fxExtra += fxBreakExtra;
            }
        }
    }

// Add in the extra stuff.

    fxBasicExtent += fxExtra;

// Add in the overhang for font simulations.

    if (fl & GGTE_WIN3_EXTENT)
        fxBasicExtent += pcf->wd.sOverhang;

// Transform the result to logical coordinates.

    if (bIsOneSixteenthEFLOAT(pcf->efDtoWBaseline))
        psizl->cx = (fxBasicExtent + 8) >> 4;
    else
        psizl->cx = lCvt(pcf->efDtoWBaseline,fxBasicExtent);

    psizl->cy = pcf->lHeight;

    return(TRUE);
}


/******************************Public*Routine*****************************\
* QueryFontAssocStatus()                                                  *
*                                                                         *
* History:                                                                *
*  05-Jan-1994 -by- Pi-Sui Hsu [pisuih]                                   *
* Wrote it.                                                               *
\*************************************************************************/

UINT APIENTRY QueryFontAssocStatus( VOID )
{
    return(fFontAssocStatus);
}

INT APIENTRY GetFontAssocStatus( HDC hdc )
{
    if(hdc == NULL)
    {
        return(0);
    }
    else
    {
        return(NtGdiQueryFontAssocInfo(hdc));
    }
}


BOOL bToUnicodeNx(LPWSTR pwsz, LPCSTR psz, DWORD c, UINT codepage)
{

    if(fFontAssocStatus &&
       ((codepage == GetACP() || codepage == CP_ACP)) &&
       ((c == 1) || ((c == 2 && *(psz) && *((LPCSTR)(psz + 1)) == '\0'))))
    {
    //
    // If this function is called with only 1 char, and font association
    // is enabled, we should forcely convert the chars to Unicode with
    // codepage 1252.
    // This is for enabling to output Latin-1 chars ( > 0x80 in Ansi codepage )
    // Because, normally font association is enabled, we have no way to output
    // those charactres, then we provide the way, if user call TextOutA() with
    // A character and ansi font, we tempotary disable font association.
    // This might be Windows 3.1 (Korean/Taiwanese) version compatibility..
    //

        codepage = 1252;
    }

    if(MultiByteToWideChar(codepage, 0, psz, c, pwsz, c))
    {
        return(TRUE);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
}




/******************************Public*Routine******************************\
*
* vSetUpUnicodeStringx
*
* Effects:
*
* Warnings:
*
* History:
*  14-Mar-1993 -by- Hideyuki Nagase [hideyukn]
* Change hardcoded default character to defulat char is given as a parameter.
*
*  01-Mar-1993 -by- Takao Kitano [takaok]
* Wrote it.
\**************************************************************************/

BOOL bSetUpUnicodeStringDBCS
(
IN  UINT    iFirst,       // first ansi char
IN  UINT    iLast,        // last char
IN  PUCHAR  puchTmp,      // temporary buffer
OUT PWCHAR  pwc,          // output fuffer with a unicode string
IN  UINT    uiCodePage,   // ansi codepage
IN  CHAR    chDefaultChar // default character
)
{
    PUCHAR  puchBuf;
    BOOL bRet = FALSE;

    puchBuf = puchTmp;

    if(IsDBCSLeadByteEx(uiCodePage,(UCHAR)(iFirst >> 8)))
    {

        // This is DBCS character strings.

        for (; iFirst <= iLast; iFirst++ )
        {
            *puchBuf++ = (UCHAR)(iFirst >> 8);
            *puchBuf++ = (UCHAR)(iFirst);
        }
    }
    else
    {

    // This is SBCS character strings.
    // if Hi-byte of iFirst is not valid DBCS LeadByte , we use only
    // lo-byte of it.

        for ( ; iFirst <= iLast; iFirst++ )
        {

        // If this SBCS code in LeadByte area . It replce with default
        // character

            if ( IsDBCSLeadByteEx(uiCodePage,(UCHAR)iFirst) )
              *puchBuf++ = chDefaultChar;
            else
              *puchBuf++ = (UCHAR)iFirst;
        }
    }

    //Sundown: safe to truncate to DWORD since puchBug - puchTmp won't exceed iLast
    bRet = bToUnicodeNx(pwc, puchTmp, (DWORD)(puchBuf - puchTmp), uiCodePage);

    return(bRet);
}


BOOL IsValidDBCSRange( UINT iFirst , UINT iLast )
{
// DBCS & SBCS char parameter checking for DBCS font

    if( iFirst > 0x00ff )
    {
        // DBCS char checking for DBCS font
        if (
           // Check limit
             (iFirst > 0xffff) || (iLast > 0xffff) ||

           // DBCSLeadByte shoud be same
             (iFirst & 0xff00) != (iLast & 0xff00) ||

           // DBCSTrailByte of the First should be >= one of the Last
             (iFirst & 0x00ff) >  (iLast & 0x00ff)
           )
        {
            return(FALSE);
        }
    }

// DBCS char checking for DBCS font

    else if( (iFirst > iLast) || (iLast & 0xffffff00) )
    {
        return(FALSE);
    }

    return(TRUE);
}


/******************************Private*Routine*****************************\
* GetCurrentDefaultChar()
*
* History:
*
*  Mon 15-Mar-1993 18:14:00 -by- Hideyuki Nagase
* wrote it.
***************************************************************************/

BYTE GetCurrentDefaultChar(HDC hdc)
{

    // WINBUG 365031 4-10-2001 pravins Consider optimization in GetCurrentDeafultChar
    //
    // Old Comment:
    //   - This is slow for now.  We should cache this value locally in the dcattr
    //     but want to get other things working for now. [gerritv] 2-22-96

    TEXTMETRICA tma;

    GetTextMetricsA( hdc , &tma );

    return(tma.tmDefaultChar);
}


/***************************************************************************
 * ConvertDxArray(UINT, char*, INT*, UINT, INT*)
 *
 * Tue 27-Feb-1996 23:45:00 -by- Gerrit van Wingerden [gerritv]
 *
 ***************************************************************************/

void ConvertDxArray(UINT CodePage,
                    char *pDBCSString,
                    INT *pDxDBCS,
                    UINT Count,
                    INT *pDxUnicode,
                    BOOL bPdy
)
{
    char *pDBCSStringEnd;

    if (!bPdy)
    {

        for(pDBCSStringEnd = pDBCSString + Count;
            pDBCSString < pDBCSStringEnd;
            )
        {
            if(IsDBCSLeadByteEx(CodePage,*pDBCSString))
            {
                pDBCSString += 2;
                *pDxUnicode = *pDxDBCS++;
                *pDxUnicode += *pDxDBCS++;
            }
            else
            {
                pDBCSString += 1;
                *pDxUnicode = *pDxDBCS++;
            }

            pDxUnicode += 1;
        }
    }
    else
    {
        POINTL *pdxdyUnicode = (POINTL *)pDxUnicode;
        POINTL *pdxdyDBCS    = (POINTL *)pDxDBCS;

        for(pDBCSStringEnd = pDBCSString + Count;
            pDBCSString < pDBCSStringEnd;
            )
        {
            if(IsDBCSLeadByteEx(CodePage,*pDBCSString))
            {
                pDBCSString += 2;
                *pdxdyUnicode = *pdxdyDBCS++;
                pdxdyUnicode->x += pdxdyDBCS->x;
                pdxdyUnicode->y += pdxdyDBCS->y;
                pdxdyDBCS++;
            }
            else
            {
                pDBCSString += 1;
                *pdxdyUnicode = *pdxdyDBCS++;
            }

            pdxdyUnicode++;
        }
    }
}





ULONG APIENTRY EudcLoadLinkW
(
    LPCWSTR  pBaseFaceName,
    LPCWSTR  pEudcFontPath,
    INT      iPriority,
    INT      iFontLinkType
)
{
    return(NtGdiEudcLoadUnloadLink(pBaseFaceName,
                                   (pBaseFaceName) ? wcslen(pBaseFaceName) : 0,
                                   pEudcFontPath,
                                   wcslen(pEudcFontPath),
                                   iPriority,
                                   iFontLinkType,
                                   TRUE));
}



BOOL APIENTRY EudcUnloadLinkW
(
    LPCWSTR  pBaseFaceName,
    LPCWSTR  pEudcFontPath
)
{
    return(NtGdiEudcLoadUnloadLink(pBaseFaceName,
                                  (pBaseFaceName) ? wcslen(pBaseFaceName) : 0,
                                  pEudcFontPath,
                                  wcslen(pEudcFontPath),
                                  0,
                                  0,
                                  FALSE));

}



ULONG APIENTRY GetEUDCTimeStampExW
(
    LPCWSTR pBaseFaceName
)
{
    return(NtGdiGetEudcTimeStampEx((LPWSTR) pBaseFaceName,
                                   (pBaseFaceName) ? wcslen(pBaseFaceName) : 0,
                                   FALSE));

}


ULONG APIENTRY GetEUDCTimeStamp()
{
    return(NtGdiGetEudcTimeStampEx(NULL,0,TRUE));
}

UINT
GetStringBitmapW(
    HDC             hdc,
    LPWSTR          pwc,
    UINT            cwc,
    UINT            cbData,
    BYTE            *pSB
)
{
    if(cwc != 1)
    {
        return(0);
    }

    return(NtGdiGetStringBitmapW(hdc,pwc,1,(PBYTE) pSB,cbData));
}


UINT
GetStringBitmapA(
    HDC             hdc,
    LPSTR           pc,
    UINT            cch,
    UINT            cbData,
    BYTE            *pSB
)
{
    WCHAR Character[2];

    if(cch > 2 )
    {
        return(0);
    }


    if(MultiByteToWideChar(CP_ACP,0,pc,cch,Character,2)!=1)
    {
        return(0);
    }

    return(GetStringBitmapW(hdc,Character,1,cbData,pSB));
}


DWORD FontAssocHack(DWORD dwCodePage, CHAR *psz, UINT c)
{
// If a Text function is called with only 1 char, and font association
// is enabled, we should forcely convert the chars to Unicode with
// codepage 1252.
// This is for enabling to output Latin-1 chars ( > 0x80 in Ansi codepage )
// Because, normally font association is enabled, we have no way to output
// those charactres, then we provide the way, if user call TextOutA() with
// A character and ansi font, we tempotary disable font association.
// This might be Windows 3.1 (Korean/Taiwanese) version compatibility..


    ASSERTGDI(fFontAssocStatus,
              "FontAssocHack called with FontAssocStatus turned off\n");

    if(((dwCodePage == GetACP() || dwCodePage == CP_ACP)) &&
       ((c == 1) || ((c == 2 && *(psz) && *((LPCSTR)(psz + 1)) == '\0'))))
    {
        return(1252);
    }
    else
    {
        return(dwCodePage);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\font.c ===
/******************************Module*Header*******************************\
* Module Name: font.c
*
* Created: 28-May-1991 13:01:27
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "exehdr.h"
#include "fot16.h"
#include "winfont.h"

// Stuf for CreateScaleableFontResource

#define ALIGNMENTSHIFT  4
#define ALIGNMENTCOUNT  (1 << ALIGNMENTSHIFT)
#define CODE_OFFSET     512
#define RESOURCE_OFFSET 1024
#define PRIVRESSIZE     0x80
#define FONTDIRSIZINDEX 6
#define NE_WINDOWS      2

static
WCHAR * pwszAllocNtMultiplePath(
LPWSTR  pwszFileName,
FLONG  *pfl,
ULONG  *pcwc,
ULONG  *pcFiles,
BOOL    bAddFR,     // called by add or remove fr
DWORD  *pdwPidTid,   // PID/TID for embedded font
BOOL   bChkFOT
);


// Define an EXE header.  This will be hardcoded into the resource file.

#define SIZEEXEHEADER   (CJ_EXE_HDR + 25 + 39)  // should be 0x80

CONST static BYTE ajExeHeader[SIZEEXEHEADER] = {
            0x4d, 0x5a,             // unsigned short e_magic;
            0x01, 0x00,             // unsigned short e_cblp;
            0x02, 0x00,             // unsigned short e_cp;
            0x00, 0x00,             // unsigned short e_crlc;
            0x04, 0x00,             // unsigned short e_cparhdr;
            0x0f, 0x00,             // unsigned short e_minalloc;
            0xff, 0xff,             // unsigned short e_maxalloc;
            0x00, 0x00,             // unsigned short e_ss;
            0xb8, 0x00,             // unsigned short e_sp;
            0x00, 0x00,             // unsigned short e_csum;
            0x00, 0x00,             // unsigned short e_ip;
            0x00, 0x00,             // unsigned short e_cs;
            0x40, 0x00,             // unsigned short e_lfarlc;
            0x00, 0x00,             // unsigned short e_ovno;
            0x00, 0x00, 0x00, 0x00, // unsigned short e_res[ERESWDS];
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            SIZEEXEHEADER, 0x00, 0x00, 0x00, // long  e_lfanew;


            // [gilmanw]
            // I don't know what the rest of this stuff is.  Its not
            // in the definition of EXE_HDR that we have in gdi\inc\exehdr.h.
            // The string is 39 bytes, the other stuff is 25 bytes.

            0x0e, 0x1f, 0xba, 0x0e, 0x00, 0xb4, 0x09, 0xcd,
            0x21, 0xb8, 0x01, 0x4c, 0xcd, 0x21,

            'T','h','i','s',' ',
            'i','s',' ',
            'a',' ',
            'T','r','u','e','T','y','p','e',' ',
            'f','o','n','t',',',' ',
            'n','o','t',' ',
            'a',' ',
            'p','r','o','g','r','a','m','.',

            0x0d, 0x0d, 0x0a, 0x24, 0x00, 0x4b, 0x69, 0x65,
            0x73, 0x61, 0x00
            };


// Define a resource table.  This will be hardcoded into the resource file.

#define SIZEFAKERESTBL  52

CONST static USHORT ausFakeResTable[SIZEFAKERESTBL/2] = {
            ALIGNMENTSHIFT, 0x8007, 1, 0, 0,
            (RESOURCE_OFFSET+PRIVRESSIZE) >> ALIGNMENTSHIFT,
            (0x90 >> ALIGNMENTSHIFT), 0x0c50,
            0x002c, 0, 0, 0x80cc, 1, 0, 0,
            RESOURCE_OFFSET >> ALIGNMENTSHIFT,
            (PRIVRESSIZE >> ALIGNMENTSHIFT), 0x0c50, 0x8001, 0, 0, 0,
            0x4607, 0x4e4f, 0x4454, 0x5249 // counted string 'FONTDIR'
            };


// Define a New EXE header.  This will be hardcoded into the resource file.

#define SIZENEWEXE  (CJ_NEW_EXE)

CONST static USHORT ausNewExe[SIZENEWEXE/2] = {
            NEMAGIC,                    //dw  NEMAGIC   ;magic number
            0x1005,                     //db  5, 10h    ;version #, revision #
            0xffff,                     //dw  -1        ;offset to table entry (to be filled)
            0x0002,                     //dw  2         ;# of bytes in entry table
            0x0000, 0x0000,             //dd  0         ;checksum of whole file
            0x8000, 0x0000,             //dw  8000h, 0, 0, 0
            0x0000, 0x0000,
            0x0000, 0x0000,             //dd  0, 0
            0x0000, 0x0000,
            0x0000, 0x0000,             //dw  0, 0
            0xffff,                     //dw  -1        ;size of non-resident name table
            SIZENEWEXE,                 //dw  (size NewExe)   ;offset to segment table
            SIZENEWEXE,                 //dw  (size NewExe)   ;offset to resource table
            SIZENEWEXE+SIZEFAKERESTBL,  //dw  (size NewExe)+SIZEFAKERESTBL    ;off to resident name table
            0xffff,                     //dw  -1        ;offset to module reference table
            0xffff,                     //dw  -1        ;offset to imported names table
            0xffff, 0x0000,             //dd  0ffffh    ;offset to non-resident names table
            0x0000, ALIGNMENTSHIFT,     //dw  0, ALIGNMENTSHIFT, 2
            0x0002,
            NE_WINDOWS,                 //db  NE_WINDOWS, 0
            0x0000, 0x0000,             //dw  0, 0, 0, 300h
            0x0000, 0x0300
            };


#define OFF_FONTDIRSIZINDEX  ((2*FONTDIRSIZINDEX)+SIZEEXEHEADER+SIZENEWEXE)


// Define font res string.

#define SIZEFONTRES 8

CONST static BYTE ajFontRes[SIZEFONTRES] = {
    'F','O','N','T','R','E','S',':'
    };

#define CJ_OUTOBJ  (SIZEFFH + LF_FACESIZE + LF_FULLFACESIZE + LF_FACESIZE + PRIVRESSIZE + 1024 + 16)




static
VOID vNewTextMetricExWToNewTextMetricExA (
NEWTEXTMETRICEXA  *pntm,
NTMW_INTERNAL     *pntmi
);

typedef struct _AFRTRACKNODE
{
    WCHAR                   *pwszPath;
    struct _AFRTRACKNODE    *pafrnNext;
    UINT                    id;
    UINT                    cLoadCount;
} AFRTRACKNODE;

extern AFRTRACKNODE *pAFRTNodeList;

AFRTRACKNODE *pAFRTNodeList;


static
VOID vConvertLogicalFont(
    ENUMLOGFONTEXDVW *pelfw,
    PVOID pv
    );



ULONG cchCutOffStrLen(PSZ psz, ULONG cCutOff);

ULONG
cwcCutOffStrLen (
    PWSZ pwsz,
    ULONG cCutOff
    );


// GETS ushort at (PBYTE)pv + off. both pv and off must be even

#define  US_GET(pv,off) ( *(PUSHORT)((PBYTE)(pv) + (off)) )
#define  S_GET(pv,off)  ((SHORT)US_GET((pv),(off)))

#if TRACK_GDI_ALLOC

// Now access to these guys insn't sycnronized but they
// don't ever collide anyhow, and since it's debug stuff who cares.

ULONG bmgulNumMappedViews = 0;
ULONG bmgulTotalSizeViews = 0;

#endif

/******************************Public*Routine******************************\
* BOOL bMapFileUNICODEClideSide
*
* Similar to PosMapFile except that it takes unicode file name
*
* History:
*  Feb-05-1997 -by- Xudong Wu   [tessiew]
* Extend the function by adding an extra parameter bNtPath to handle the
* NT path name for file mapping.
*
*  21-May-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bMapFileUNICODEClideSide
(
PWSTR     pwszFileName,
CLIENT_SIDE_FILEVIEW  *pfvw,
BOOL    bNtPath
)
{
    UNICODE_STRING ObFileName;
    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS rc = 0L;
    IO_STATUS_BLOCK     iosb;           // IO Status Block

    PWSTR pszFilePart = NULL;

// NOTE PERF: this is the mode I want, but appears to be broken, so I had to
// put the slower FILE_STANDARD_INFORMATION mode of query which appears to
// work correctly [bodind]
// FILE_END_OF_FILE_INFORMATION    eof;

    FILE_STANDARD_INFORMATION    eof;
    SIZE_T  cjView;

    pfvw->hf       = (HANDLE)0;            // file handle
    pfvw->hSection = (HANDLE)0;            // section handle

    ObFileName.Buffer = NULL;

// section offset must be initialized to 0 for NtMapViewOfSection to work

    if (bNtPath)
    {
        RtlInitUnicodeString(&ObFileName, pwszFileName);
    }
    else        //Dos path name converted to NtpathName
    {
        RtlDosPathNameToNtPathName_U(pwszFileName, &ObFileName, &pszFilePart, NULL);
    }

    InitializeObjectAttributes( &ObjA,
                            &ObFileName,
                            OBJ_CASE_INSENSITIVE,  // case insensitive file search
                            NULL,
                            NULL );

// NtOpenFile fails for some reason if the file is on the net unless I put this
// InpersonateClient/RevertToSelf stuff around it

// peform open call

    rc = NtOpenFile
         (
          &pfvw->hf,                            // store file handle here
          FILE_READ_DATA | SYNCHRONIZE,         // desired read access
          &ObjA,                                // filename
          &iosb,                                // io result goes here
          FILE_SHARE_READ,
          FILE_SYNCHRONOUS_IO_NONALERT
         );

    if (!bNtPath && ObFileName.Buffer)
    {
        RtlFreeHeap(RtlProcessHeap(),0,ObFileName.Buffer);
    }

// check success or fail

    if (!NT_SUCCESS(rc) || !NT_SUCCESS(iosb.Status))
    {
#ifdef DEBUG_THIS_JUNK
DbgPrint("bMapFileUNICODEClideSide(): NtOpenFile error code , rc = 0x%08lx , 0x%08lx\n", rc, iosb.Status);
#endif // DEBUG_THIS_JUNK
        return FALSE;
    }

// get the size of the file, the view should be size of the file rounded up
// to a page bdry

    rc = NtQueryInformationFile
         (
          pfvw->hf,                // IN  file handle
          &iosb,                   // OUT io status block
          (PVOID)&eof,             // OUT buffer to retrun info into
          sizeof(eof),             // IN  size of the buffer
          FileStandardInformation  // IN  query mode
         );

// dont really want the view size, but eof file

    pfvw->cjView = eof.EndOfFile.LowPart;

    if (!NT_SUCCESS(rc))
    {
#ifdef DEBUG_THIS_JUNK
DbgPrint("bMapFileUNICODEClideSide(): NtQueryInformationFile error code 0x%08lx\n", rc);
#endif // DEBUG_THIS_JUNK
        NtClose(pfvw->hf);
        return FALSE;
    }

    rc = NtCreateSection
         (
          &pfvw->hSection,          // return section handle here
          SECTION_MAP_READ,         // read access to the section
          (POBJECT_ATTRIBUTES)NULL, // default
          NULL,                     // size is set to the size of the file when hf != 0
          PAGE_READONLY,            // read access to commited pages
          SEC_COMMIT,               // all pages set to the commit state
          pfvw->hf                  // that's the file we are mapping
         );

// check success, close the file if failed

    if (!NT_SUCCESS(rc))
    {
#ifdef DEBUG_THIS_JUNK
DbgPrint("bMapFileUNICODEClideSide(): NtCreateSection error code 0x%08lx\n", rc);
#endif // DEBUG_THIS_JUNK
        NtClose(pfvw->hf);
        return FALSE;
    }

// zero out *ppv so as to force the operating system to determine
// the base address to be returned

    pfvw->pvView = (PVOID)NULL;
    cjView = 0L;

    rc = NtMapViewOfSection
         (
          pfvw->hSection,           // section we are mapping
          NtCurrentProcess(),       // process handle
          &pfvw->pvView,            // place to return the base address of view
          0L,                       // requested # of zero bits in the base address
          0L,                       // commit size, (all of them commited already)
          NULL,
          &cjView,                  // size of the view should is returned here
          ViewUnmap,                // do not map the view to child processess
          0L,                       // allocation type flags
          PAGE_READONLY             // read access to commited pages
         );

    if (!NT_SUCCESS(rc))
    {
#ifdef DEBUG_THIS_JUNK
DbgPrint("bMapFileUNICODEClideSide(): NtMapViewOfSection error code 0x%08lx\n", rc);
#endif // DEBUG_THIS_JUNK

        NtClose(pfvw->hSection);
        NtClose(pfvw->hf);
        return FALSE;
    }

    #ifdef DEBUG_THIS_JUNK
        DbgPrint("cjView = 0x%lx, eof.Low = 0x%lx, eof.High = 0x%lx\n",
                  cjView,
                  eof.EndOfFile.LowPart,
                  eof.EndOfFile.HighPart);
    #endif // DEBUG_THIS_JUNK

// #define PAGE_SIZE 4096 --- this is now defined in local.h
#define PAGE_ROUNDUP(x) (((x) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

    if (
        (eof.EndOfFile.HighPart != 0) ||
        (PAGE_ROUNDUP(eof.EndOfFile.LowPart) > cjView)
       )
    {
#ifdef DEBUG_THIS_JUNK
DbgPrint(
    "bMapFileUNICODEClideSide(): eof.HighPart = 0x%lx, eof.LowPart = 0x%lx, cjView = 0x%lx\n",
    eof.EndOfFile.HighPart, PAGE_ROUNDUP(eof.EndOfFile.LowPart), cjView
    );
#endif // DEBUG_THIS_JUNK

        rc = STATUS_UNSUCCESSFUL;
    }

    if (!NT_SUCCESS(rc) || (pfvw->cjView == 0))
    {
        NtClose(pfvw->hSection);
        NtClose(pfvw->hf);
        return FALSE;
    }
    else if (pfvw->cjView == 0)
    {
        #if DBG
        DbgPrint("gdisrvl!bMapFileUNICODEClideSide(): WARNING--empty file %ws\n", pwszFileName);
        #endif

        vUnmapFileClideSide(pfvw);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}




/******************************Public*Routine******************************\
* vUnmapFileClideSide
*
* Unmaps file whose view is based at pv
*
*  14-Dec-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vUnmapFileClideSide(PCLIENT_SIDE_FILEVIEW pfvw)
{

#if TRACK_GDI_ALLOC

// Now access to these guys insn't sycnronized but they (we hope)
// don't ever collide anyhow, and since it's debug stuff who cares.

      bmgulNumMappedViews -= 1;
      bmgulTotalSizeViews -= PAGE_ROUNDUP(pfvw->cjView);
      // DbgPrint("UnMapping %lu %lu\n",pfvw->cjView,PAGE_ROUNDUP(pfvw->cjView));

#endif

    NtUnmapViewOfSection(NtCurrentProcess(),pfvw->pvView);

    //
    // now close section handle
    //

    NtClose(pfvw->hSection);

    //
    // close file handle. other processes can now open this file for access
    //

    NtClose(pfvw->hf);

    //
    // prevent accidental use
    //

    pfvw->pvView   = NULL;
    pfvw->hf       = (HANDLE)0;
    pfvw->hSection = (HANDLE)0;
    pfvw->cjView   = 0;
}


/******************************Public*Routine******************************\
*
* BOOL   bVerifyFOT
*
* Effects: verify that that a file is valid fot file
*
*
* History:
*  29-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



static
BOOL   bVerifyFOT
(
PCLIENT_SIDE_FILEVIEW   pfvw,
PWINRESDATA pwrd,
FLONG       *pflEmbed,
DWORD       *pdwPidTid
)
{
    PBYTE pjNewExe;     // ptr to the beginning of the new exe hdr
    PBYTE pjResType;    // ptr to the beginning of TYPEINFO struct
    ULONG iResID;       // resource type id
    PBYTE pjData;
    ULONG ulLength;
    ULONG ulNameID;
    ULONG crn;

    pwrd->pvView = pfvw->pvView;
    pwrd->cjView = pfvw->cjView;

// Initialize embed flag to FALSE (not hidden).

    *pflEmbed = 0;
    *pdwPidTid = 0;

// check the magic # at the beginning of the old header

// *.TTF FILES are eliminated on the following check

    if (US_GET(pfvw->pvView, OFF_e_magic) != EMAGIC)
    {
        return (FALSE);
    }

    pwrd->dpNewExe = (PTRDIFF)READ_DWORD((PBYTE)pfvw->pvView + OFF_e_lfanew);

// make sure that offset is consistent

    if ((ULONG)pwrd->dpNewExe > pwrd->cjView)
    {
        return FALSE;
    }

    pjNewExe = (PBYTE)pfvw->pvView + pwrd->dpNewExe;

    if (US_GET(pjNewExe, OFF_ne_magic) != NEMAGIC)
    {
        return (FALSE);
    }

    pwrd->cjResTab = (ULONG)(US_GET(pjNewExe, OFF_ne_restab) -
                             US_GET(pjNewExe, OFF_ne_rsrctab));

    if (pwrd->cjResTab == 0L)
    {
    // The following test is applied by DOS,  so I presume that it is
    // legitimate.  The assumption is that the resident name table
    // FOLLOWS the resource table directly,  and that if it points to
    // the same location as the resource table,  then there are no
    // resources. [bodind]

        WARNING("No resources in *.fot file\n");
        return(FALSE);
    }

// want offset from pvView, not from pjNewExe => must add dpNewExe

    pwrd->dpResTab = (PTRDIFF)US_GET(pjNewExe, OFF_ne_rsrctab) + pwrd->dpNewExe;

// make sure that offset is consistent

    if ((ULONG)pwrd->dpResTab > pwrd->cjView)
    {
        return FALSE;
    }

// what really lies at the offset OFF_ne_rsrctab is a NEW_RSRC.rs_align field
// that is used in computing resource data offsets and sizes as a  shift factor.
// This field occupies two bytes on the disk and the first TYPEINFO structure
// follows right after. We want pwrd->dpResTab to point to the first
// TYPEINFO structure, so we must add 2 to get there and subtract 2 from
// the length

    pwrd->ulShift = (ULONG) US_GET(pfvw->pvView, pwrd->dpResTab);
    pwrd->dpResTab += 2;
    pwrd->cjResTab -= 2;

// Now we want to determine where the resource data is located.
// The data consists of a RSRC_TYPEINFO structure, followed by
// an array of RSRC_NAMEINFO structures,  which are then followed
// by a RSRC_TYPEINFO structure,  again followed by an array of
// RSRC_NAMEINFO structures.  This continues until an RSRC_TYPEINFO
// structure which has a 0 in the rt_id field.

    pjResType = (PBYTE)pfvw->pvView + pwrd->dpResTab;
    iResID = (ULONG) US_GET(pjResType,OFF_rt_id);

    while(iResID)
    {
    // # of NAMEINFO structures that follow = resources of this type

        crn = (ULONG)US_GET(pjResType, OFF_rt_nres);

        if ((crn == 1) && ((iResID == RT_FDIR) || (iResID == RT_PSZ)))
        {
        // this is the only interesting case, we only want a single
        // font directory and a single string resource for a ttf file name

            pjData = (PBYTE)pfvw->pvView +
                     (US_GET(pjResType,CJ_TYPEINFO + OFF_rn_offset) << pwrd->ulShift);
            ulLength = (ULONG)US_GET(pjResType,CJ_TYPEINFO + OFF_rn_length) << pwrd->ulShift;
            ulNameID = (ULONG)US_GET(pjResType,CJ_TYPEINFO + OFF_rn_id);

            if (iResID == RT_FDIR)
            {
                if (ulNameID != RN_ID_FDIR)
                {
                    return (FALSE); // *.fon files get eliminated here
                }

                pwrd->pjHdr = pjData + 4;   // 4 bytes to the beginning of font device header
                pwrd->cjHdr = ulLength - 4;

                //
                // Used to check if the client thread or process is allowed to
                // load this font and get the FRW_EMB_PID and FRW_EMB_TID flags
                //
                // Any client thread or process is authorized to load a font if
                // the font isn't ebmeded ( i.e. hidden ).  If
                // FRW_EMB_PID is set then the PID written in the
                // copyright string of the must equal that of the client
                // process.  If the FRW_EMB_TID flag is set then the
                // TID written into the copyright
                // string must equal that of the client thread.
                //
                // Returns TRUE if this client process or thread is authorized
                // to load this font or FALSE if it isn't.
                //

                // Note: Win 3.1 hack.  The LSB of Type is used by Win 3.1 as an engine type
                //       and font embedding flag.  Font embedding is a form of a "hidden
                //       font file".  The MSB of Type is the same as the fsSelection from
                //       IFIMETRICS.  (Strictly speaking, the MSB of Type is equal to the
                //       LSB of IFIMETRICS.fsSelection).

                // now convert flags from the font file format to the ifi format

                *pflEmbed = ((READ_WORD(pwrd->pjHdr + OFF_Type) & 0x00ff) &
                               ( PF_TID | PF_ENCAPSULATED));

                if (*pflEmbed)
                {
                    *pflEmbed = (*pflEmbed & PF_TID) ? FRW_EMB_TID : FRW_EMB_PID;

                    WARNING("bVerifyFOT(): notification--embedded (hidden) TT font\n");

                    *pdwPidTid = READ_DWORD( pwrd->pjHdr + OFF_Copyright );
                }
            }
            else  // iResID == RT_PSZ
            {
                ASSERTGDI(iResID == RT_PSZ, "bVerifyFOT!_not RT_PSZ\n");

                if (ulNameID != RN_ID_PSZ)
                {
                    WARNING("bVerifyFOT!_RN_ID_PSZ\n");
                    return(FALSE);
                }

                pwrd->pszNameTTF = (PSZ)pjData;
                pwrd->cchNameTTF = strlen(pwrd->pszNameTTF);

                if (ulLength < (pwrd->cchNameTTF + 1))   // 1 for terminating '\0'
                {
                    WARNING("bVerifyFOT!_ pwrd->cchNameTTF\n");
                    return(FALSE);
                }
            }
        }
        else // this is something we do not recognize as an fot file
        {
            WARNING("bVerifyFOT!_fot file with crn != 1\n");
            return(FALSE);
        }

    // get ptr to the new TYPEINFO struc and the new resource id

        pjResType = pjResType + CJ_TYPEINFO + crn * CJ_NAMEINFO;
        iResID = (ULONG) US_GET(pjResType,OFF_rt_id);
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* cGetTTFFromFOT
*
* Attempts to extract the TTF pathname from a given FOT file.  If a return
* buffer is provided (pwszTTFName !NULL), then the pathname is copied into
* the buffer.  Otherwise, if the buffer is NULL, the size of the buffer
* (in WCHARs) needed is returned.
*
* Returns:
*   The number of characters copied into the return buffer.  The number
*   of WCHARs needed in the buffer if the buffer is NULL.  If an error
*   occurs, zero is returned.
*
* History:
*  22-Apr-1992 -by- Gilman Wong [gilmanw]
* Adapted from TTFD.
\**************************************************************************/

#define FOT_EXCEPTED  0
#define FOT_NOT_FOT   1
#define FOT_IS_FOT    2

ULONG cGetTTFFromFOT (
    WCHAR *pwszFOT,       // pointer to incoming FOT name
    ULONG  cwcTTF,        // size of buffer (in WCHAR)
    WCHAR *pwszTTF,       // return TTF name in this buffer
    FLONG *pfl,           // flags, indicate the location of the .ttf
    FLONG *pflEmbed,      // flag, indicating PID or TID
    DWORD *pdwPidTid,      // PID/TID for embedded font
    BOOL  bChkFOT
    )
{
    CLIENT_SIDE_FILEVIEW   fvw;
    WINRESDATA wrd;
    UINT Result;
    WCHAR      awcPath[MAX_PATH],awcFile[MAX_PATH];
    ULONG      cNeed = 0;
    WCHAR      *pwszTmp = NULL;

    ULONG      cwcFOT = wcslen(pwszFOT);

    if (cwcFOT >= 5) // fot file has to have a form x.fot, which is at least 5 wchars long
        pwszTmp = &pwszFOT[cwcFOT - 4];

// here we are making the exception for FOT files and we require that the file has an .FOT
// extension for us to even try to recognize it as a valid FOT file.

    if
    (bChkFOT || ( pwszTmp && 
        (pwszTmp[0] == L'.')            &&
        (pwszTmp[1] == L'F' || pwszTmp[1] == L'f') &&
        (pwszTmp[2] == L'O' || pwszTmp[2] == L'o') &&
        (pwszTmp[3] == L'T' || pwszTmp[3] == L't'))
    )
    {
        // Map the file into memory.

        if (bMapFileUNICODEClideSide(pwszFOT,&fvw,FALSE))
        {
        //
        // Check the validity of this file as fot file
        // and if a valid fot file, must extract the name of an underlining ttf
        // file.  The file could be on the net so we need try excepts.
        //

            try
            {
                if(bVerifyFOT(&fvw,&wrd,pflEmbed,pdwPidTid))
                {
                 // this could except which is why we do it here
                    vToUnicodeN(awcFile, MAX_PATH, wrd.pszNameTTF, strlen(wrd.pszNameTTF)+1);
                    Result = FOT_IS_FOT;
                }
                else
                {
                    Result = FOT_NOT_FOT;
                }
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNING("bVerifyFOT exception accessing font file\n");
                Result = FOT_EXCEPTED;
            }

            if(Result == FOT_IS_FOT)
            {

                if (bMakePathNameW(awcPath,awcFile,NULL, pfl))
                {
                    //
                    // Determine pathname length
                    //

                    cNeed = wcslen(awcPath) + 1;
                    pwszFOT = awcPath;
                }

                // cGetTTFFromFOT called by font sweeper.
                // TTF file might exist over net but connection has not been established yet.

                else if (pfl)
                {
                   cNeed = wcslen(awcFile) + 1;
                   pwszFOT = awcFile;
                }
            }
            else if(Result != FOT_EXCEPTED)
            {
                //
                // We have to assume it is another type of file.
                // just copy the name in the buffer
                //

                cNeed = wcslen(pwszFOT) + 1;

                if (pfl)
                {
                    KdPrint(("cGetTTFFromFOT: Invalid FOT file: %ws\n", pwszFOT));
                    *pfl |= FONT_ISNOT_FOT;
                }
            }

            vUnmapFileClideSide(&fvw);
        }
    }
    else
    {
        cNeed = cwcFOT + 1;

        if (pfl)
        {
            KdPrint(("cGetTTFFromFOT: Invalid FOT file: %ws\n", pwszFOT));
            *pfl |= FONT_ISNOT_FOT;
        }
    }

    if (cNeed == 0)
    {
        KdPrint(("cGetTTFFromFOT failed for font file %ws\n", pwszFOT));
    }

    //
    // If return buffer exists and we succeded, copy pathname to it.
    //

    if (cNeed &&
        (pwszTTF != (PWSZ) NULL))
    {
        if (cNeed <= cwcTTF)
        {
            wcscpy(pwszTTF, pwszFOT);
        }
        else
        {
            WARNING("gdisrv!cGetTTFFromFOT(): buffer too small\n");
            cNeed = 0;
        }
    }
    else
    {
        //
        // Otherwise, caller just wants us to return the number of characters.
        //
    }

    return cNeed;

}

/******************************Public*Routine******************************\
*
* BOOL bInitSystemAndFontsDirectoriesW(WCHAR **ppwcSystemDir, WCHAR **ppwcFontsDir)
*
* Effects:
*
* Warnings:
*
* History:
*  30-Oct-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


WCHAR *gpwcSystemDir = NULL;
WCHAR *gpwcFontsDir = NULL;

#define WSTR_SYSTEM_SUBDIR   L"\\system"
#define WSTR_FONT_SUBDIR     L"\\fonts"

BOOL bInitSystemAndFontsDirectoriesW(WCHAR **ppwcSystemDir, WCHAR **ppwcFontsDir)
{
    WCHAR  awcWindowsDir[MAX_PATH];
    UINT   cwchWinPath, cwchSystem, cwchFonts;
    BOOL   bRet = TRUE;

// see if already initialized, if yes we are done.

    if (!(*ppwcSystemDir))
    {
    // Compute the windows and font directory pathname lengths (including NULL).
    // Note that cwchWinPath may have a trailing '\', in which case we will
    // have computed the path length to be one greater than it should be.

		cwchWinPath = GetSystemWindowsDirectoryW(awcWindowsDir, MAX_PATH);
		
        if( cwchWinPath ){

    	// the cwchWinPath value does not include the terminating zero

        	if (awcWindowsDir[cwchWinPath - 1] == L'\\')
        	{
            	cwchWinPath -= 1;
        	}
        	awcWindowsDir[cwchWinPath] = L'\0'; // make sure to zero terminate

        	cwchSystem = cwchWinPath + sizeof(WSTR_SYSTEM_SUBDIR)/sizeof(WCHAR);
        	cwchFonts  = cwchWinPath + sizeof(WSTR_FONT_SUBDIR)/sizeof(WCHAR);

        	if (*ppwcSystemDir = LocalAlloc(LMEM_FIXED, (cwchSystem+cwchFonts) * sizeof(WCHAR)))
        	{
            	*ppwcFontsDir = &((*ppwcSystemDir)[cwchSystem]);
            	wcscpy(*ppwcSystemDir,awcWindowsDir);
            	wcscpy(*ppwcFontsDir,awcWindowsDir);

        	// Append the system and font subdirectories

            	lstrcatW(*ppwcSystemDir, WSTR_SYSTEM_SUBDIR);
            	lstrcatW(*ppwcFontsDir, WSTR_FONT_SUBDIR);
        	}
        	else
        	{
            	bRet = FALSE;
        	}
        }
        else
        {
            bRet = FALSE;
        }
    }
    return bRet;
}



/******************************Public*Routine******************************\
* vConverLogFont                                                           *
*                                                                          *
* Converts a LOGFONTA into an equivalent ENUMLOGFONTEXDVW structure.            *
*                                                                          *
* History:                                                                 *
*  Thu 15-Aug-1991 13:01:33 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID vConvertLogFont(
    ENUMLOGFONTEXDVW *pelfexdvw,
    LOGFONTA    *plf
    )
{
    ENUMLOGFONTEXW *pelfw = &pelfexdvw->elfEnumLogfontEx;
    ULONG cchMax;

// this one does everyting but the lfFaceName;

    vConvertLogicalFont(pelfexdvw,plf);

// do lfFaceName

    cchMax = cchCutOffStrLen((PSZ) plf->lfFaceName, LF_FACESIZE);
    RtlZeroMemory(pelfw->elfLogFont.lfFaceName , LF_FACESIZE * sizeof(WCHAR) );

// translate the face name

    vToUnicodeN((LPWSTR) pelfw->elfLogFont.lfFaceName,
                cchMax,
                (LPSTR) plf->lfFaceName,
                cchMax);
    if (cchMax == LF_FACESIZE)
        pelfw->elfLogFont.lfFaceName[LF_FACESIZE - 1] = L'\0';  // truncate so NULL will fit
    else
        pelfw->elfLogFont.lfFaceName[cchMax] = L'\0';

}

/******************************Public*Routine******************************\
* vConvertLogFontW                                                         *
*                                                                          *
* Converts a LOGFONTW to an ENUMLOGFONTEXDVW                               *
*                                                                          *
* History:                                                                 *
*  Fri 16-Aug-1991 14:02:05 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID
vConvertLogFontW(
     ENUMLOGFONTEXDVW *pelfw,
     LOGFONTW *plfw
    )
{
// this one does everything except for lfFaceName

    vConvertLogicalFont(pelfw,plfw);

// do lfFaceName

    RtlCopyMemory(
        pelfw->elfEnumLogfontEx.elfLogFont.lfFaceName,
        plfw->lfFaceName,
        LF_FACESIZE * sizeof(WCHAR)
        );

}

/******************************Public*Routine******************************\
* vConvertLogicalFont                                                      *
*                                                                          *
* Simply copies over all of the fields of a LOGFONTA or LOGFONTW           *
* to the fields of a target ENUMLOGFONTEXDVW. The only exception is        *
* the FaceName which must be dealt with by another routine.                *
*                                                                          *
* History:                                                                 *
*  Fri 16-Aug-1991 14:02:14 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/
static
VOID vConvertLogicalFont(
    ENUMLOGFONTEXDVW *pelfw,
    PVOID pv
    )
{
    pelfw->elfEnumLogfontEx.elfLogFont.lfHeight         = ((LOGFONTA*)pv)->lfHeight;
    pelfw->elfEnumLogfontEx.elfLogFont.lfWidth          = ((LOGFONTA*)pv)->lfWidth;
    pelfw->elfEnumLogfontEx.elfLogFont.lfEscapement     = ((LOGFONTA*)pv)->lfEscapement;
    pelfw->elfEnumLogfontEx.elfLogFont.lfOrientation    = ((LOGFONTA*)pv)->lfOrientation;
    pelfw->elfEnumLogfontEx.elfLogFont.lfWeight         = ((LOGFONTA*)pv)->lfWeight;
    pelfw->elfEnumLogfontEx.elfLogFont.lfItalic         = ((LOGFONTA*)pv)->lfItalic;
    pelfw->elfEnumLogfontEx.elfLogFont.lfUnderline      = ((LOGFONTA*)pv)->lfUnderline;
    pelfw->elfEnumLogfontEx.elfLogFont.lfStrikeOut      = ((LOGFONTA*)pv)->lfStrikeOut;
    pelfw->elfEnumLogfontEx.elfLogFont.lfCharSet        = ((LOGFONTA*)pv)->lfCharSet;
    pelfw->elfEnumLogfontEx.elfLogFont.lfOutPrecision   = ((LOGFONTA*)pv)->lfOutPrecision;
    pelfw->elfEnumLogfontEx.elfLogFont.lfClipPrecision  = ((LOGFONTA*)pv)->lfClipPrecision;
    pelfw->elfEnumLogfontEx.elfLogFont.lfQuality        = ((LOGFONTA*)pv)->lfQuality;
    pelfw->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily = ((LOGFONTA*)pv)->lfPitchAndFamily;

    // lfFaceName is done in the calling routine

    pelfw->elfEnumLogfontEx.elfFullName[0] = 0;
    pelfw->elfEnumLogfontEx.elfStyle[0]    = 0;
    pelfw->elfEnumLogfontEx.elfScript[0]   = 0;

    pelfw->elfDesignVector.dvReserved = STAMP_DESIGNVECTOR;
    pelfw->elfDesignVector.dvNumAxes  = 0;

}



/******************************Public*Routine******************************\
*
* BOOL bConvertLogFontWToLogFontA(LOGFONTA *plfw, LOGFONTW *plfa)
*
* History:
*  10-Dec-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




BOOL bConvertLogFontWToLogFontA(LOGFONTA *plfa, LOGFONTW *plfw)
{
    ULONG cchMax;

    plfa->lfHeight         = plfw->lfHeight         ;
    plfa->lfWidth          = plfw->lfWidth          ;
    plfa->lfEscapement     = plfw->lfEscapement     ;
    plfa->lfOrientation    = plfw->lfOrientation    ;
    plfa->lfWeight         = plfw->lfWeight         ;
    plfa->lfItalic         = plfw->lfItalic         ;
    plfa->lfUnderline      = plfw->lfUnderline      ;
    plfa->lfStrikeOut      = plfw->lfStrikeOut      ;
    plfa->lfCharSet        = plfw->lfCharSet        ;
    plfa->lfOutPrecision   = plfw->lfOutPrecision   ;
    plfa->lfClipPrecision  = plfw->lfClipPrecision  ;
    plfa->lfQuality        = plfw->lfQuality        ;
    plfa->lfPitchAndFamily = plfw->lfPitchAndFamily ;

    cchMax = cwcCutOffStrLen(plfw->lfFaceName, LF_FACESIZE);

    return (bToASCII_N(plfa->lfFaceName,  LF_FACESIZE,
                       plfw->lfFaceName, cchMax));
}


/******************************Public*Routine******************************\
* bConvertEnumLogFontExWToEnumLogFontExA                                   *
*                                                                          *
* Simply copies over all of the fields of ENUMLOGFONTEXDVW                 *
* to the fields of a target ENUMLOGFONTEXDVA.  It is all wrapped up here   *
* because the ENUMLOGFONTEXDV may move around a bit.  This makes           *
* using MOVEMEM a little tricky.                                           *
*                                                                          *
* History:                                                                 *
*  Fri 16-Aug-1991 14:02:14 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bConvertEnumLogFontExWToEnumLogFontExA(ENUMLOGFONTEXA *pelfexa,ENUMLOGFONTEXW *pelfexw)
{
    ULONG cchMax;

    if (!bConvertLogFontWToLogFontA(&pelfexa->elfLogFont,
                                    &pelfexw->elfLogFont))
    {
    // conversion to ascii  failed, return error

        WARNING("bConvertLogFontWToLogFontA failed\n");
        return(FALSE);
    }

    cchMax = cwcCutOffStrLen(pelfexw->elfFullName, LF_FULLFACESIZE);

    if(!bToASCII_N(pelfexa->elfFullName, LF_FULLFACESIZE,
                   pelfexw->elfFullName, cchMax
                   ))
    {
    // conversion to ascii  failed, return error
        WARNING("bConvertEnumLogFontExWToEnumLogFontExA: bToASCII failed\n");
        return(FALSE);
    }
    pelfexa->elfFullName[LF_FULLFACESIZE-1]=0; // zero terminate


    cchMax = cwcCutOffStrLen(pelfexw->elfStyle, LF_FACESIZE);

    if(!bToASCII_N(pelfexa->elfStyle, LF_FACESIZE,
                   pelfexw->elfStyle, cchMax))
    {
    // conversion to ascii  failed, return error

        WARNING("bConvertEnumLogFontExWToEnumLogFontExA: bToASCII failed\n");
        return(FALSE);
    }


    cchMax = cwcCutOffStrLen(pelfexw->elfScript, LF_FACESIZE);

    if(!bToASCII_N(pelfexa->elfScript, LF_FACESIZE,
                   pelfexw->elfScript, cchMax
                   ))
    {
    // conversion to ascii  failed, return error
        WARNING("bConvertEnumLogFontExWToEnumLogFontExA: bToASCII_N failed\n");
        return(FALSE);
    }

    return (TRUE);
}

/******************************Public*Routine******************************\
* bConvertEnumLogFontExDv_AtoW                                             *
*                                                                          *
* Simply copies over all of the fields of ENUMLOGFONTEXDVW                 *
* to the fields of a target ENUMLOGFONTEXDV.  It is all wrapped up here    *
* because the fields may move around a bit.  This make                     *
* using MOVEMEM a little tricky.                                           *
*                                                                          *
* History:                                                                 *
*  Fri 16-Aug-1991 14:02:14 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/


VOID vConvertEnumLogFontExDvAtoW(
    ENUMLOGFONTEXDVW *pelfw,
    ENUMLOGFONTEXDVA *pelfa
    )
{
    ULONG cchMax;

    pelfw->elfEnumLogfontEx.elfLogFont.lfHeight         = pelfa->elfEnumLogfontEx.elfLogFont.lfHeight         ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfWidth          = pelfa->elfEnumLogfontEx.elfLogFont.lfWidth          ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfEscapement     = pelfa->elfEnumLogfontEx.elfLogFont.lfEscapement     ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfOrientation    = pelfa->elfEnumLogfontEx.elfLogFont.lfOrientation    ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfWeight         = pelfa->elfEnumLogfontEx.elfLogFont.lfWeight         ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfItalic         = pelfa->elfEnumLogfontEx.elfLogFont.lfItalic         ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfUnderline      = pelfa->elfEnumLogfontEx.elfLogFont.lfUnderline      ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfStrikeOut      = pelfa->elfEnumLogfontEx.elfLogFont.lfStrikeOut      ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfCharSet        = pelfa->elfEnumLogfontEx.elfLogFont.lfCharSet        ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfOutPrecision   = pelfa->elfEnumLogfontEx.elfLogFont.lfOutPrecision   ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfClipPrecision  = pelfa->elfEnumLogfontEx.elfLogFont.lfClipPrecision  ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfQuality        = pelfa->elfEnumLogfontEx.elfLogFont.lfQuality        ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily = pelfa->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily ;


    RtlZeroMemory( pelfw->elfEnumLogfontEx.elfLogFont.lfFaceName , LF_FACESIZE * sizeof(WCHAR) );
    cchMax = cchCutOffStrLen((PSZ)pelfa->elfEnumLogfontEx.elfLogFont.lfFaceName, LF_FACESIZE);

    vToUnicodeN (
        pelfw->elfEnumLogfontEx.elfLogFont.lfFaceName, cchMax,
        pelfa->elfEnumLogfontEx.elfLogFont.lfFaceName, cchMax
        );

    if (cchMax == LF_FACESIZE)
    {
    // truncate so NULL will fit
        pelfw->elfEnumLogfontEx.elfLogFont.lfFaceName[LF_FACESIZE - 1] = L'\0';
    }
    else
    {
        pelfw->elfEnumLogfontEx.elfLogFont.lfFaceName[cchMax] = L'\0';
    }

    RtlZeroMemory( pelfw->elfEnumLogfontEx.elfFullName , LF_FACESIZE * sizeof(WCHAR) );

    cchMax = cchCutOffStrLen((PSZ)pelfa->elfEnumLogfontEx.elfFullName, LF_FULLFACESIZE);
    vToUnicodeN (
        pelfw->elfEnumLogfontEx.elfFullName, cchMax,
        pelfa->elfEnumLogfontEx.elfFullName, cchMax
        );

    if (cchMax == LF_FULLFACESIZE)
    {
        // truncate so NULL will fit
        pelfw->elfEnumLogfontEx.elfFullName[LF_FULLFACESIZE - 1] = L'\0';
    }
    else
    {
        pelfw->elfEnumLogfontEx.elfFullName[cchMax] = L'\0';
    }

    RtlZeroMemory( pelfw->elfEnumLogfontEx.elfStyle , LF_FACESIZE * sizeof(WCHAR) );
    cchMax = cchCutOffStrLen((PSZ)pelfa->elfEnumLogfontEx.elfStyle, LF_FACESIZE);
    vToUnicodeN (
        pelfw->elfEnumLogfontEx.elfStyle, cchMax,
        pelfa->elfEnumLogfontEx.elfStyle, cchMax
        );
    if (cchMax == LF_FACESIZE)
    {
        // truncate so NULL will fit
        pelfw->elfEnumLogfontEx.elfStyle[LF_FACESIZE - 1] = L'\0';
    }
    else
    {
        pelfw->elfEnumLogfontEx.elfStyle[cchMax] = L'\0';
    }

    RtlZeroMemory( pelfw->elfEnumLogfontEx.elfScript , LF_FACESIZE * sizeof(WCHAR) );
    cchMax = cchCutOffStrLen((PSZ)pelfa->elfEnumLogfontEx.elfScript, LF_FACESIZE);
    vToUnicodeN (
        pelfw->elfEnumLogfontEx.elfScript, cchMax,
        pelfa->elfEnumLogfontEx.elfScript, cchMax
        );
    if (cchMax == LF_FACESIZE)
    {
        // truncate so NULL will fit
        pelfw->elfEnumLogfontEx.elfScript[LF_FACESIZE - 1] = L'\0';
    }
    else
    {
        pelfw->elfEnumLogfontEx.elfScript[cchMax] = L'\0';
    }

// copy minimal amount of stuff from design vector

    RtlCopyMemory(&pelfw->elfDesignVector,
                  &pelfa->elfDesignVector,
                  SIZEOFDV(pelfa->elfDesignVector.dvNumAxes));
}

/******************************Public*Routine******************************\
* ulEnumFontsOpen
*
* History:
*  08-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG_PTR ulEnumFontsOpen (
    HDC     hdc,
    LPWSTR  pwszFaceName,
    ULONG   lfCharSet,
    ULONG   iEnumType,    // enumfonts, enumfontfamilies or enumfontfamiliesex
    FLONG   flWin31Compat,
    ULONG   *pulCount
    )
{


    ULONG  cwchFaceName;

    ULONG  cjData;

    cwchFaceName = (pwszFaceName != (PWSZ) NULL) ? (wcslen(pwszFaceName) + 1) : 0;

    return NtGdiEnumFontOpen(hdc,iEnumType,flWin31Compat,
             cwchFaceName,pwszFaceName, lfCharSet,pulCount);

}


/******************************Public*Routine******************************\
* vEnumFontsClose
*
* History:
*  08-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vEnumFontsClose (ULONG_PTR ulEnumHandle)
{
    NtGdiEnumFontClose(ulEnumHandle);
}

/******************************Public*Routine******************************\
*
*    vConvertAxesListW2AxesListA
*
*
* History:
*  18-Nov-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID vConvertAxesListW2AxesListA(AXESLISTA *paxlA, AXESLISTW *paxlW)
{
    ULONG iAxis = 0;

    paxlA->axlReserved = paxlW->axlReserved;
    paxlA->axlNumAxes  = paxlW->axlNumAxes;

    for (iAxis = 0; iAxis < paxlW->axlNumAxes; iAxis ++)
    {
        ULONG cch;

        paxlA->axlAxisInfo[iAxis].axMinValue = paxlW->axlAxisInfo[iAxis].axMinValue;
        paxlA->axlAxisInfo[iAxis].axMaxValue = paxlW->axlAxisInfo[iAxis].axMaxValue;

        cch = cwcCutOffStrLen(paxlW->axlAxisInfo[iAxis].axAxisName,
                              MM_MAX_AXES_NAMELEN);

        bToASCII_N(paxlA->axlAxisInfo[iAxis].axAxisName, MM_MAX_AXES_NAMELEN,
                   paxlW->axlAxisInfo[iAxis].axAxisName, cch);

    }
}




/******************************Public*Routine******************************\
*
* int  iAnsiCallback (
*
* History:
*  28-Jan-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


int  iAnsiCallback (
    ENUMFONTDATAW *pefdw,
    ULONG          iEnumType,
    FONTENUMPROCA  lpFontFunc,
    LPARAM lParam
    )
{
// full size structures with MAX_MM_AXES arrays
// on the stack, probably bigger then needed.

    ENUMLOGFONTEXDVA     elfexa ;
    ENUMTEXTMETRICA      ntma;

    NTMW_INTERNAL *pntmi = (NTMW_INTERNAL *)((BYTE*)pefdw + pefdw->dpNtmi);
    DESIGNVECTOR  *pdvSrc = &(pefdw->elfexw.elfDesignVector);

// copy out design vector

    RtlCopyMemory(&elfexa.elfDesignVector, pdvSrc, SIZEOFDV(pdvSrc->dvNumAxes));

// convert AXESLIST to ansi

    vConvertAxesListW2AxesListA(&ntma.etmAxesList, &pntmi->entmw.etmAxesList);

// Convert ENUMLOGFONTEX

    if (!bConvertEnumLogFontExWToEnumLogFontExA(&elfexa.elfEnumLogfontEx, &pefdw->elfexw.elfEnumLogfontEx))
    {
        WARNING("gdi32!EFCallbackWtoA(): ENUMLOGFONT conversion failed\n");
        return 0;
    }

// Convert NEWTEXTMETRIC.

    vNewTextMetricExWToNewTextMetricExA(&ntma.etmNewTextMetricEx, pntmi);

    return lpFontFunc(
                (LOGFONTA *)&elfexa,
                (TEXTMETRICA *)&ntma,
                pefdw->flType,
                lParam
                );

}


/******************************Public*Routine******************************\
* iScaleEnum
*
* The Win95 Universal printer driver (UNIDRV) has scalable fonts, but does
* not set the scalable capability flags in TEXTCAPS.  Instead, it enumerates
* back scalable printer fonts at several different (fixed) point sizes.
*
* We support this by detecting, on the server-side, when we are enumerating
* a scalable printer and setting the ENUMFONT_SCALE_HACK flag in the flType
* field of the ENUMFONTDATAW structure.
*
* For more details, refer to the Win95 sources found on \\tal\msdos in
* \src\win\drivers\printer\universa\unidrv\enumobj.c.  Specifically, the
* function of interest is UniEnumDFonts().
*
* Returns:
*   Value returned by callback if successful, 0 otherwise.
*
* History:
*  08-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

#define EFI_UNICODE 1

CONST int giEnumPointList[] =
    {6, 8, 10, 11, 12, 14, 18, 24, 30, 36, 48};

int iScaleEnum(
    HDC           hdc,
    FONTENUMPROCW lpFontFunc,
    ENUMFONTDATAW *pefd,
    LPARAM        lParam,
    ULONG         iEnumType,
    FLONG         fl
    )
{
    int i, cPointSizes = sizeof(giEnumPointList) / sizeof(int);
    int iHeight;
    int iXdpi, iYdpi;
    int iRet;

// make the structure on the stack is DWORD aligned

    DWORD efd[CJ_EFDW0/sizeof(DWORD)];

    ENUMFONTDATAW *pefdLocal = (ENUMFONTDATAW *)efd;

    iXdpi = GetDeviceCaps(hdc, LOGPIXELSX);
    iYdpi = GetDeviceCaps(hdc, LOGPIXELSY);

    for (i = 0; i < cPointSizes; i++)
    {
    // this has to be true because for these device fonts no
    // extra mm data will ever be needed, only logfont and ntmi

        NTMW_INTERNAL *pntmi, *pntmiDef;
        TEXTMETRICW   *ptmw,  *ptmwDef;
        LOGFONTW      *plfw,  *plfwDef;

        ASSERTGDI(pefd->cjEfdw <= sizeof(efd), "iScaleEnum size problem\n");
        RtlCopyMemory(pefdLocal, pefd, pefd->cjEfdw);

        pntmi      = (NTMW_INTERNAL *)((BYTE*)pefdLocal + pefdLocal->dpNtmi);
        pntmiDef   = (NTMW_INTERNAL *)((BYTE*)pefd + pefd->dpNtmi);
        ptmw       = (TEXTMETRICW *) &pntmi->entmw.etmNewTextMetricEx;
        ptmwDef    = (TEXTMETRICW *) &pntmiDef->entmw.etmNewTextMetricEx;
        plfw       = (LOGFONTW *) &pefdLocal->elfexw;
        plfwDef    = (LOGFONTW *) &pefd->elfexw;

    // Scale TEXTMETRIC to match enumerated height.

        iHeight = MulDiv(giEnumPointList[i], iYdpi, 72);
        ptmw->tmHeight = iHeight;
        ptmw->tmAscent = MulDiv(ptmwDef->tmAscent, iHeight, ptmwDef->tmHeight);
        ptmw->tmInternalLeading = MulDiv(ptmwDef->tmInternalLeading, iHeight,
                                         ptmwDef->tmHeight);
        ptmw->tmExternalLeading = MulDiv(ptmwDef->tmExternalLeading, iHeight,
                                         ptmwDef->tmHeight);
        ptmw->tmAveCharWidth = MulDiv(ptmwDef->tmAveCharWidth, iHeight,
                                      ptmwDef->tmHeight);
        ptmw->tmMaxCharWidth = MulDiv(ptmwDef->tmMaxCharWidth, iHeight,
                                      ptmwDef->tmHeight);

    // Scale LOGFONT to match enumerated height.

        plfw->lfHeight = MulDiv(plfwDef->lfHeight, iHeight, ptmwDef->tmHeight);
        plfw->lfWidth = MulDiv(plfwDef->lfWidth, iHeight, ptmwDef->tmHeight);

    // Invoke the callback function.

        if (fl & EFI_UNICODE)
        {
            iRet = lpFontFunc(
                       (LOGFONTW *) plfw,
                       (TEXTMETRICW *) ptmw,
                       pefd->flType,
                       lParam );
        }
        else
        {
            iRet = iAnsiCallback (pefdLocal,
                                  iEnumType,
                                  (FONTENUMPROCA)lpFontFunc,
                                  lParam);
        }

    // Break out early if callback returned error.

        if (!iRet)
            break;
    }

    return iRet;
}


/******************************Public*Routine******************************\
* EnumFontsInternalW
*
* History:
*  Mon 17-Aug-1998 -by- Bodin Dresevic [BodinD]
* update: since 1992 this function was rewritten quite a few times
*
*  08-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int WINAPI EnumFontsInternalW (
    HDC           hdc,           // enumerate for this device
    LPCWSTR       pwszFaceName,  // use this family name (but Windows erroneously calls in face name *sigh*)
    ULONG         lfCharSet,     // only used with EnumFontFamiliesEx,
    FONTENUMPROCW lpFontFunc,    // callback
    LPARAM        lParam,        // user defined data
    ULONG         iEnumType,     // who is calling....
    FLONG         fl
    )
{
    BOOL         bMore;         // set TRUE if more data to process
    ULONG_PTR     ulEnumID;      // server side font enumeration handle
    int          iRet = 1;      // return value from callback
    ULONG        cjEfdw;        // capacity of memory data window
    ULONG        cjEfdwRet;     // size of data returned

    PENUMFONTDATAW  pefdw;      // font enumeration data buffer
    PENUMFONTDATAW  pefdwScan;  // use to parse data buffer
    PENUMFONTDATAW  pefdwEnd;   // limit of data buffer

    FLONG        flWin31Compat; // Win3.1 app hack backward compatibility flags

// Get the compatibility flags.

    flWin31Compat = (FLONG) GetAppCompatFlags(NULL);

// Open a font enumeration.  The font enumeration is uniquely identified
// by the identifier returned by ulEnumFontOpen().

    ulEnumID = ulEnumFontsOpen(
                     hdc, (LPWSTR)pwszFaceName, lfCharSet,
                     iEnumType, flWin31Compat, &cjEfdw);

    if (!ulEnumID)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return 0;
    }

    if (cjEfdw == 0)
    {
        vEnumFontsClose(ulEnumID);
        return iRet;
    }

// alloc memory

    if (!(pefdw = (PENUMFONTDATAW) LOCALALLOC(cjEfdw)))
    {
        WARNING("gdi32!EnumFontsInternalW(): could not allocate memory for enumeration\n");
        GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        vEnumFontsClose(ulEnumID);
        return 0;
    }

    if (NtGdiEnumFontChunk(hdc,ulEnumID,cjEfdw,&cjEfdwRet,pefdw))
    {

    // Scan through the data buffer.

        ASSERTGDI(cjEfdwRet <= cjEfdw, "NtGdiEnumFontChunk problem\n");

        pefdwScan = pefdw;
        pefdwEnd = (ENUMFONTDATAW *)((BYTE *)pefdw + cjEfdwRet);

        while (pefdwScan < pefdwEnd)
        {
        // GACF_ENUMTTNOTDEVICE backward compatibility hack.
        // If this flag is set, we need to mask out the DEVICE_FONTTYPE
        // if this is a TrueType font.

            if ( (flWin31Compat & GACF_ENUMTTNOTDEVICE)
                 && (pefdwScan->flType & TRUETYPE_FONTTYPE) )
                pefdwScan->flType &= ~DEVICE_FONTTYPE;

        // The Win95 UNIDRV printer driver enumerates scalable fonts at
        // several different sizes.  The server sets the ENUMFONT_SCALE_HACK
        // flag if we need to emulate that behavior.

            if ( pwszFaceName && (pefdwScan->flType & ENUMFONT_SCALE_HACK))
            {
            // Clear the hack flag before calling.  Caller doesn't need to
            // see this (internal use only) flag.

                pefdwScan->flType &= ~ENUMFONT_SCALE_HACK;

                iRet = iScaleEnum(hdc, lpFontFunc, pefdwScan, lParam,
                                  iEnumType, fl);

            }
            else
            {
            // Do the callback with data pointed to by pefdwScan.

                if (fl & EFI_UNICODE)
                {
                    NTMW_INTERNAL *pntmi =
                        (NTMW_INTERNAL *)((BYTE*)pefdwScan + pefdwScan->dpNtmi);

                    iRet = lpFontFunc(
                               (LOGFONTW *)&pefdwScan->elfexw,
                               (TEXTMETRICW *)&pntmi->entmw,
                               pefdwScan->flType,
                               lParam );

                }
                else
                {
                    iRet = iAnsiCallback (pefdwScan,
                                          iEnumType,
                                          (FONTENUMPROCA)lpFontFunc,
                                          lParam);

                }
            }

        // Break out of for-loop if callback returned 0.

            if (!iRet)
            {
                break;
            }

        // Next ENUMFONTDATAW.

            pefdwScan = (ENUMFONTDATAW *)((BYTE *)pefdwScan + pefdwScan->cjEfdw);
        }
    }

// Deallocate font enumeration data.

    LOCALFREE(pefdw);

// Remember to close the font enumeration handle.

    vEnumFontsClose(ulEnumID);

// Leave.

    return iRet;
}


/******************************Public*Routine******************************\
* EnumFontsW
*
* History:
*  08-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int WINAPI EnumFontsW
(
    HDC           hdc,           // enumerate for this device
    LPCWSTR       pwszFaceName,  // use this family name (but Windows erroneously calls in face name *sigh*)
    FONTENUMPROCW lpFontFunc,    // callback
    LPARAM        lParam         // user defined data
)
{
    FIXUP_HANDLE(hdc);

    return EnumFontsInternalW(
               hdc,
               pwszFaceName,
               DEFAULT_CHARSET,
               lpFontFunc,
               lParam,
               TYPE_ENUMFONTS,
               EFI_UNICODE
               );
}


/******************************Public*Routine******************************\
* EnumFontFamiliesW
*
* History:
*  08-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int WINAPI EnumFontFamiliesW
(
    HDC           hdc,           // enumerate for this device
    LPCWSTR       pwszFaceName,  // use this family name (but Windows erroneously calls in face name *sigh*)
    FONTENUMPROCW lpFontFunc,    // callback
    LPARAM        lParam         // user defined data
)
{
    FIXUP_HANDLE(hdc);

    return EnumFontsInternalW(
               hdc,
               pwszFaceName,
               DEFAULT_CHARSET,
               lpFontFunc,
               lParam,
               TYPE_ENUMFONTFAMILIES,
               EFI_UNICODE
               );

}


/******************************Public*Routine******************************\
* EnumFontFamiliesExW
*
* History:
*
*  Mon 10-Jul-1995 -by- Bodin Dresevic [BodinD]
* Wrote it:
*
\**************************************************************************/

int WINAPI EnumFontFamiliesExW
(
    HDC           hdc,
    LPLOGFONTW    plf,
    FONTENUMPROCW lpFontFunc,
    LPARAM        lParam,
    DWORD         dw
)
{
    PWSZ  pwszFaceName = NULL;

    FIXUP_HANDLE(hdc);

    if (plf && (plf->lfFaceName[0] != L'\0'))
        pwszFaceName = plf->lfFaceName;


    return EnumFontsInternalW(
               hdc,
               pwszFaceName,
               plf ? plf->lfCharSet : DEFAULT_CHARSET,
               lpFontFunc,
               lParam,
               TYPE_ENUMFONTFAMILIESEX,
               EFI_UNICODE
               );

}

/******************************Public*Routine******************************\
*
* int  EnumFontsInternalA
*
* History:
*  28-Jan-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

int  EnumFontsInternalA
(
    HDC           hdc,           // enumerate for this device
    LPCSTR        pszFaceName,   // use this family name (but Windows erroneously calls in face name *sigh*),
    ULONG         lfCharSet,
    FONTENUMPROCA lpFontFunc,    // callback
    LPARAM        lParam,        // user defined data
    ULONG         iEnumType
)
{
    PWSZ pwszFaceName;
    int iRet;
    ULONG cchFaceName;

// If a string was passed in, we need to convert it to UNICODE.

    if ( pszFaceName != (PSZ) NULL )
    {
    // Allocate memory for Unicode string.

        cchFaceName = lstrlenA(pszFaceName) + 1;

        if ( (pwszFaceName = (PWSZ) LOCALALLOC(cchFaceName * sizeof(WCHAR))) == (PWSZ) NULL )
        {
            WARNING("gdi32!EnumFontsA(): could not allocate memory for Unicode string\n");
            GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return 0;
        }

    // Convert string to Unicode.

        vToUnicodeN (
            pwszFaceName,
            cchFaceName,
            pszFaceName,
            cchFaceName
            );
    }

// Otherwise, keep it NULL.

    else
    {
        pwszFaceName = (PWSZ) NULL;
    }

// Call Unicode version.

    iRet = EnumFontsInternalW(
                hdc,
                pwszFaceName,
                lfCharSet,
                (FONTENUMPROCW)lpFontFunc,
                lParam,
                iEnumType,
                0  // not unicode
                );

// Release Unicode string buffer.

    if ( pwszFaceName != (PWSZ) NULL )
    {
        LOCALFREE(pwszFaceName);
    }

    return iRet;
}


/******************************Public*Routine******************************\
*
* int WINAPI EnumFontsA
*
*
* History:
*  28-Jan-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

int WINAPI EnumFontsA
(
    HDC           hdc,           // enumerate for this device
    LPCSTR        pszFaceName,   // use this family name (but Windows erroneously calls in face name *sigh*)
    FONTENUMPROCA lpFontFunc,    // callback
    LPARAM        lParam         // user defined data
)
{
    FIXUP_HANDLE(hdc);

    return  EnumFontsInternalA (
                hdc,
                pszFaceName,
                DEFAULT_CHARSET,
                lpFontFunc,
                lParam,
                TYPE_ENUMFONTS
                );

}


/******************************Public*Routine******************************\
* EnumFontFamiliesA
*
* History:
*  28-Jan-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

int WINAPI EnumFontFamiliesA
(
    HDC           hdc,           // enumerate for this device
    LPCSTR        pszFaceName,   // use this family name (but Windows erroneously calls in face name *sigh*)
    FONTENUMPROCA lpFontFunc,    // callback
    LPARAM        lParam         // user defined data
)
{
    return  EnumFontsInternalA (
                hdc,           // enumerate for this device
                pszFaceName,   // use this family name (but Windows erroneously calls in face name *sigh*)
                DEFAULT_CHARSET,
                lpFontFunc,    // callback
                lParam,        // user defined data
                TYPE_ENUMFONTFAMILIES
                );
}

/******************************Public*Routine******************************\
* EnumFontFamiliesExA
*
* History:
*
*  Mon 10-Jul-1995 -by- Bodin Dresevic [BodinD]
* Wrote it:
*
\**************************************************************************/

int WINAPI EnumFontFamiliesExA
(
    HDC           hdc,
    LPLOGFONTA    plf,
    FONTENUMPROCA lpFontFunc,
    LPARAM        lParam,
    DWORD         dw
)
{
    LPSTR pszFaceName = NULL;

    FIXUP_HANDLE(hdc);

    if (plf && (plf->lfFaceName[0] != '\0'))
        pszFaceName = plf->lfFaceName;

    return  EnumFontsInternalA (
                hdc,           // enumerate for this device
                pszFaceName,   // use this family name (but Windows erroneously calls in face name *sigh*)
                plf ? plf->lfCharSet : DEFAULT_CHARSET,
                lpFontFunc,    // callback
                lParam,        // user defined data
                TYPE_ENUMFONTFAMILIESEX
                );
}


/******************************Public*Routine******************************\
* GetFontResourceInfoW
*
* Client side stub.
*
* History:
*   2-Sep-1993 -by- Gerrit van Wingerden [gerritv]
* Made this a "W" function.
*  15-Jul-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/


BOOL GetFontResourceInfoW (
    LPWSTR   lpPathname,
    LPDWORD  lpBytes,
    LPVOID   lpBuffer,
    DWORD    iType)
{
    ULONG   cjBuffer = *lpBytes;
    int cRet = 0;
    FLONG flEmbed;
    DWORD dwPidTid;

    if ( (lpPathname !=  NULL) &&
         ((cjBuffer == 0) || (lpBuffer != NULL)) )
    {
        if( iType == GFRI_TTFILENAME )
        {
            WCHAR awcPathname[MAX_PATH];
            WCHAR awcTTF[MAX_PATH];

            if (bMakePathNameW(awcPathname, lpPathname, NULL, NULL))
            {
                ULONG size;

                if (size = cGetTTFFromFOT(awcPathname, MAX_PATH, awcTTF, NULL, &flEmbed, &dwPidTid, TRUE))
                {
                // For the case of GFRI_TTFILENAME, the file need not be already
                // loaded. Which means a PFF may or may not exist for this file.

                    *lpBytes = size * sizeof(WCHAR);

                    if (cjBuffer)
                    {
                    // Also return the name if it fits

                    // if awcPathnmae points to a bad FOT file, awcTTF will contain the same FOT file name
                    // passed to the cGetTTTFromFOT. In this case, we want to return FALSE.

                        if ((cjBuffer >= *lpBytes) &&
                            ((size < 5) || _wcsicmp(&awcTTF[size-5], L".FOT")))
                        {
                            RtlMoveMemory(lpBuffer, awcTTF, *lpBytes);
                        }
                        else
                        {
                        // Buffer is too small - error !
                        // or bad FOT file, no TTF file

                            *lpBytes = 0;
                        }
                    }

                    cRet = (*lpBytes != 0);
                }
            }
        }
        else
        {
        // First get a real NT path Name before calling to the kernel

            ULONG  cwc,cFiles;
            FLONG  fl = 0;         // essential initialization
            WCHAR *pwszNtPath;

            if (pwszNtPath = pwszAllocNtMultiplePath(lpPathname,
                                                     &fl,
                                                     &cwc,
                                                     &cFiles,
                                                     FALSE,
                                                     &dwPidTid,
                                                     TRUE))
            {
                cRet = NtGdiGetFontResourceInfoInternalW(
                                                    pwszNtPath,
                                                    cwc,
                                                    cFiles,
                                                    cjBuffer,
                                                    lpBytes,
                                                    lpBuffer,
                                                    iType);
                LOCALFREE(pwszNtPath);
            }
        }
    }

    return( cRet );
}



/******************************Public*Routine******************************\
* bMakePathNameW (PWSZ pwszDst, PWSZ pwszSrc, PWSZ *ppwszFilePart)
*
* Converts the filename pszSrc into a fully qualified pathname pszDst.
* The parameter pszDst must point to a WCHAR buffer at least
* MAX_PATH*sizeof(WCHAR) bytes in size.
*
* An attempt is made find the file first in the new win95 directory
* %windows%\fonts (which also is the first directory in secure font path,
* if one is defined) and then we do the old fashioned windows stuff
* where SearchPathW searches directories in usual order
*
* ppwszFilePart is set to point to the last component of the pathname (i.e.,
* the filename part) in pwszDst.  If this is null it is ignored.
*
* Returns:
*   TRUE if sucessful, FALSE if an error occurs.
*
* History:
*  Mon 02-Oct-1995 -by- Bodin Dresevic [BodinD]
* update: added font path stuff
*  30-Sep-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/



BOOL bMakePathNameW (
    WCHAR  *pwszDst,
    WCHAR  *pwszSrc,
    WCHAR **ppwszFilePart,
    FLONG  *pfl
)
{
    WCHAR * pwszD, * pwszS, * pwszF;
    BOOL    bOk;
    ULONG   ulPathLength = 0;    // essential to initialize
    ULONG   cwcSystem;
    ULONG   cwcDst;
    WCHAR  *pwcTmp;

    if (pfl)
        *pfl = 0;

    if (ppwszFilePart == NULL)
    {
        ppwszFilePart = &pwszF;
    }

// init unicode path for the fonts directory, %windir%\fonts that is:
// This is always defined in NT versions > 3.51.

    ENTERCRITICALSECTION(&semLocal);
    bOk = bInitSystemAndFontsDirectoriesW(&gpwcSystemDir, &gpwcFontsDir);
    LEAVECRITICALSECTION(&semLocal);

// bInitFontDirectoryW logs the error code and prints warning, just exit

    if (!bOk)
        return FALSE;

    ASSERTGDI(gpwcFontsDir, "gpwcFontsDir not initialized\n");

// if relative path

    if
    (
        (pwszSrc[0] != L'\\') &&
        !((pwszSrc[1] == L':') && (pwszSrc[2] == L'\\'))
    )
    {
        if (pfl)
        {
            *pfl |= FONT_RELATIVE_PATH;
        }

    // find out if the font file is in %windir%\fonts

        ulPathLength = SearchPathW (
                            gpwcFontsDir,
                            pwszSrc,
                            NULL,
                            MAX_PATH,
                            pwszDst,
                            ppwszFilePart);

        if (ulPathLength >= MAX_PATH)
        {
            WARNING("bMakePathNameW: path from SearchPathW is too long\n");
            return FALSE;
        }

#ifdef DEBUG_PATH
        DbgPrint("SPW1: pwszSrc = %ws\n", pwszSrc);
        if (ulPathLength)
            DbgPrint("SPW1: pwszDst = %ws\n", pwszDst);
#endif // DEBUG_PATH
    }

// Search for file using default windows path and return full pathname.
// We will only do so if we did not already find the font in the
// %windir%\fonts directory or if pswzSrc points to the full path
// in which case search path is ignored

    if (ulPathLength == 0)
    {
        if (ulPathLength = SearchPathW (
                            NULL,
                            pwszSrc,
                            NULL,
                            MAX_PATH,
                            pwszDst,
                            ppwszFilePart))
        {
            if (ulPathLength >= MAX_PATH)
            {
                WARNING("bMakePathNameW: path from SearchPathW is too long\n");
                return FALSE;
            }

            // let us figure it out if the font is in the
            // system directory, or somewhere else along the path:

            if (pfl)
            {
                cwcSystem = wcslen(gpwcSystemDir);
                cwcDst = wcslen(pwszDst);

                if (cwcDst > (cwcSystem + 1)) // + 1 for L'\\'
                {
                    if (!_wcsnicmp(pwszDst, gpwcSystemDir, cwcSystem))
                    {
                        pwcTmp = &pwszDst[cwcSystem];
                        if (*pwcTmp == L'\\')
                        {
                            pwcTmp++; // skip it and see if there are any more of these in pszDst
                            for (;(pwcTmp < &pwszDst[cwcDst]) && (*pwcTmp != L'\\'); pwcTmp++)
                                ;
                            if (*pwcTmp != L'\\')
                                *pfl |= FONT_IN_SYSTEM_DIR;
                        }
                    }
                }
            }

        }

#ifdef DEBUG_PATH
        DbgPrint("SPW2: pwszSrc = %ws\n", pwszSrc);
        if (ulPathLength)
            DbgPrint("SPW2: pwszDst = %ws\n", pwszDst);
#endif // DEBUG_PATH
    }
    else
    {
        if (pfl)
        {
            *pfl |= FONT_IN_FONTS_DIR;
        }
    }

// finally we test to see if this is one of these fonts that were moved
// by setup  during upgrade from system to fonts dir,
// but the registry entry for that font
// contained full path to system so that the code above would not have found
// this font. This code is only called by font sweeper as signified by
// pfl != NULL. More desription follows below

// This part of routine handles the upgrade situation where NT 3.51 font applet
// wrote the full path of the .fot file that lives in %windir%\system
// directory in the registry. This redundant situation happens
// when tt fonts are installed under 3.51 but ttf's are not copied
// to %windir%\system directory. Some ill behaved  apps also write the
// full path of .fot files in the system directory in the registry.
// On upgrade for 4.0 the system setup copies all .fot files from
// system to fonts directory. bMakePathNameW will therefore fail to find
// the fot file because the file was moved to fonts by setup AND full,
// no longer correct path to fot file, is passed to this routine.
// That is why we try to find out if the full path is the one
// describing system dir and if so, retry to find .fot in fonts dir.

    if (pfl && (ulPathLength == 0))
    {
    // first check if the full path to .fot file points to the
    // file which USED to be in the system directory.

        ULONG cwcFileName = wcslen(pwszSrc);
        cwcSystem   = wcslen(gpwcSystemDir);

        if ((cwcFileName + 1) > cwcSystem) // + 1 for L'\\'
        {
            if (!_wcsnicmp(gpwcSystemDir, pwszSrc, cwcSystem))
            {
                pwszSrc += cwcSystem;
                if (pwszSrc[0] == L'\\')
                {
                    pwszSrc += 1; // skip L'\\'

                // make sure there are no more directory separators L'\\' in
                // the remaining path, ie. that this is indeed a relative path

                    for (pwcTmp = pwszSrc; *pwcTmp != L'\0'; pwcTmp++)
                        if (*pwcTmp == L'\\')
                            break;

                // now check if the .fot file has been moved to fonts dir

                    if (*pwcTmp == L'\0')
                    {
                        ulPathLength = SearchPathW (
                                            gpwcFontsDir,
                                            pwszSrc,
                                            NULL,
                                            MAX_PATH,
                                            pwszDst,
                                            ppwszFilePart);

                        if (ulPathLength >= MAX_PATH)
                        {
                            WARNING("bMakePathNameW: path from SearchPathW is too long\n");
                            return FALSE;
                        }

                        if (ulPathLength)
                            *pfl |= FONT_IN_FONTS_DIR;
                    }
                }
            }
        }
    }

// If search was successful return TRUE:

    return (ulPathLength != 0);
}


/******************************Private*Routine******************************\
*
* BOOL IsWinPERemoteBootDrive( PCWSTR Drive )
*
* History:
*  July 19, 2001.  acosma - Added routine. 
* 
\**************************************************************************/

static BOOL IsWinPERemoteBootDrive( PCWSTR Drive )
/*++

Routine Description:

    Finds out if we are currently running on WinPE booted remotely.

Arguments:

    None.

Return value:

    TRUE if this is a WinPE remote boot otherwise FALSE.

--*/    
{
    static BOOL Result = FALSE;
    static BOOL Initialized = FALSE;
    static WCHAR WindowsDrive = 0;
      

    if (!Initialized) {    
        WCHAR WindowsDir[MAX_PATH] = {0};

        Initialized = TRUE;
	
	    if (GetWindowsDirectoryW(WindowsDir, sizeof(WindowsDir)/sizeof(WCHAR))) {
            WindowsDir[3] = 0;

            WindowsDrive = WindowsDir[0];
            
            //
            // If the drive type is DRIVE_REMOTE then we have booted from
            // network.
            //
            Result = (GetDriveTypeW(WindowsDir) == DRIVE_REMOTE);
            
            if (Result) {
                OBJECT_ATTRIBUTES   Obja;
                UNICODE_STRING      KeyName;
                HKEY                hKey = NULL;
                NTSTATUS            Status;

                RtlInitUnicodeString(&KeyName, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\MiniNT");
                InitializeObjectAttributes(&Obja, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL);

                Status = NtOpenKey(&hKey, KEY_READ, &Obja);

                if ( NT_SUCCESS (Status) ) {
                    Result = TRUE;
                    NtClose(hKey);
                } else {
                    Result = FALSE;
                }                    
            }
        }    
    }

    //
    // Is this WinPE remote boot and is the passed in drive valid & its windows drive?
    //
    return (Result && Drive && Drive[0] && (WindowsDrive == Drive[0]));
}



/******************************Public*Routine******************************\
*
* BOOL bFileIsOnTheHardDrive(PWCHAR pwszFullPathName)
*
* History:
*  Fri 22-Jul-1994 -by- Gerrit van Wingerden [gerritv]
* Stole it from BodinD
\**************************************************************************/



BOOL bFileIsOnTheHardDrive(WCHAR *inputpwszFullPathName)
{
    const WCHAR * pwszFullPathName = inputpwszFullPathName;
    WCHAR awcDrive[4];
    
    if (pwszFullPathName[1] != (WCHAR)':')
    {
    // the file path has the form \\foo\goo. Even though this could be
    // a share on the local hard drive, this is not very likely. It is ok
    // for the sake of simplicity to consider this a remote drive.
    // The only side effect of this is that in this unlikely case the font
    // would get unloaded at logoff and reloaded at logon time

        return FALSE;
    }


// make a zero terminated string with drive string
// to be feed into GetDriveType api. The string has to have the form: "x:\"

    awcDrive[0] = pwszFullPathName[0]; // COPY DRIVE LETTER
    awcDrive[1] = pwszFullPathName[1]; // COPY ':'
    awcDrive[2] = (CHAR)'\\';         // obvious
    awcDrive[3] = (CHAR)'\0';         // zero terminate

    if ( IsWinPERemoteBootDrive(awcDrive) )
    {
        // If we are in WinPE and this is a remote boot then always return true
        // to this so that we don't wait until logon to load fonts, since in 
        // WinPE we don't logon, and the system drive is a net drive but we 
        // already have credentials to access it since the OS is booting from
        // there
        // Doing this after checking for the \\foo\goo so that we don't accidentaly
        // try to load fonts that ARE really on some net share in the
        // Remote boot WinPE case.
        //
        return TRUE;
    }

// for this pupose, only net drives are not considered hard drives
// so that we can boot of Bernoulli removable drives

    switch (GetDriveTypeW((LPCWSTR)awcDrive))
    {
    case DRIVE_REMOVABLE:
    case DRIVE_FIXED:
    case DRIVE_CDROM:
    case DRIVE_RAMDISK:
        return 1;
    default:
        return 0;
    }

}

static
WCHAR * pwszAllocNtMultiplePath(
LPWSTR  pwszFileName,
FLONG  *pfl,
ULONG  *pcwc,
ULONG  *pcFiles,
BOOL    bAddFR,     // called by add or remove fr
DWORD   *pdwPidTid,  // PID/TID for embedded font
BOOL    bChkFOT
)
{

    BOOL  bDoIt = FALSE;
    BOOL  bReturn = TRUE;      
    ULONG cwc;
    ULONG iFile;
    ULONG cFiles = 1;  // number of paths separated by | separator
    WCHAR *pwszOneFile;
    WCHAR *pwchMem;
    WCHAR *pwcNtPaths;
    FLONG flTmp = 0; // essential initialization
    FLONG fl = (pfl ? *pfl : 0); // essential initialization
    FLONG flEmbed = 0;
    UINT cbCombinedPaths = 0;

// scan the string to figure out how many individual file names are
// in the input string:

    for (pwszOneFile = pwszFileName; *pwszOneFile; pwszOneFile++)
    {
        if (*pwszOneFile == PATH_SEPARATOR)
            cFiles++;
    }

    // allocate memory where NtPathNames are going to be stored:
    // we allow only file names with MAX_PATH-1 characters or less
    // after all the path transformations
    cbCombinedPaths = cFiles * sizeof(WCHAR) * MAX_PATH;
    pwchMem = (WCHAR *)LOCALALLOC(cbCombinedPaths);

    if (pwchMem)
    {
    // set the pointers for the loop:

        pwcNtPaths  = pwchMem;
        pwszOneFile = pwszFileName;   // reset this from the loop above
        cwc         = 0;              // measure the whole NtPaths string
        bDoIt       = TRUE;

        for (iFile = 0; iFile < cFiles; iFile++)
        {
            WCHAR awchOneFile[MAX_PATH];
            WCHAR awcPathName[MAX_PATH];
            WCHAR awcTTF[MAX_PATH];

            WCHAR *pwcTmp = awchOneFile;

            // copy the file to the buffer on the stack and zero terminate it
            // the whole point of this is just to ensure zero termination
            while ((*pwszOneFile != L'\0') && (*pwszOneFile != PATH_SEPARATOR))
            {
                *pwcTmp = *pwszOneFile;
                ++pwcTmp, ++pwszOneFile;

                if (pwcTmp - awchOneFile >= MAX_PATH)
                {
                    WARNING("pwszAllocNtMultiplePath: source path is too long\n");
                    bDoIt = FALSE;
                    goto failure;
                }
            }

            pwszOneFile++; // skip the separator or terminating zero

            *pwcTmp = L'\0'; // zero terminate

            if
            (
                bMakePathNameW(awcPathName, awchOneFile,NULL,NULL) &&
                cGetTTFFromFOT(awcPathName, MAX_PATH, awcTTF, NULL, &flEmbed, pdwPidTid, bChkFOT)
            )
            {
            // we have to make sure that the font lies in the font path
            // if one is defined. This needs to be done before converting
            // to NtPathNames because the names in the registry are "dos"
            // path names, not Nt path names

                UNICODE_STRING UniStr;
                ULONG          cwcThis;

            // the next portion of code is only done for AddFontResourceCase

                if (bAddFR)
                {
                    if (bFileIsOnTheHardDrive(awcTTF))
                        flTmp |= AFRW_ADD_LOCAL_FONT;
                    else
                        flTmp |= AFRW_ADD_REMOTE_FONT;
                }

                // let us check the error return here:

                bReturn = RtlDosPathNameToNtPathName_U(awcTTF,
                                             &UniStr,
                                             NULL,
                                             NULL);

            // get the size out of the unicode string,
            // update cwc, copy out, and then free the memory

                if (bReturn && (UniStr.Buffer))
                {
                    cwcThis = (UniStr.Length/sizeof(WCHAR) + 1);
                    if (cwcThis <= MAX_PATH)
                    {
                        cwc += cwcThis;

                        RtlCopyMemory(pwcNtPaths, UniStr.Buffer, UniStr.Length);

                        if (iFile < (cFiles - 1))
                            pwcNtPaths[cwcThis - 1] = PATH_SEPARATOR;
                        else
                            pwcNtPaths[cwcThis - 1] = L'\0';


                        pwcNtPaths += cwcThis;
                    }
                    else
                    {
                        WARNING("pwszAllocNtMultiplePath: path from RtlDosPathNameToNtPathName_U is too long\n");
                        bDoIt = FALSE;
                    }

                    RtlFreeHeap(RtlProcessHeap(),0,UniStr.Buffer);
                }
                else
                {
                    bDoIt = FALSE;
                }
            }
            else
            {
                bDoIt = FALSE;
            }
            if (!bDoIt)
                break;
        }  // end of the "for" loop

failure:

    // now check if we are going to reject the font because
    // only local or only remote fonts are requested to be loaded

        if (bDoIt && bAddFR)
        {
            switch (fl & (AFRW_ADD_REMOTE_FONT|AFRW_ADD_LOCAL_FONT))
            {
            case AFRW_ADD_REMOTE_FONT:
            // we say that the font is remote if AT LEAST ONE of the files
            // is remote.

                if (!(flTmp & AFRW_ADD_REMOTE_FONT))
                    bDoIt = FALSE;
                break;
            case AFRW_ADD_LOCAL_FONT:
            // conversely, we say that it is local when it is not remote,
            // that is when ALL files are local

                if (flTmp & AFRW_ADD_REMOTE_FONT)
                    bDoIt = FALSE;
                break;

            case (AFRW_ADD_REMOTE_FONT|AFRW_ADD_LOCAL_FONT):
                RIP("AddFontResourceW, bogus flag combination");
                bDoIt = FALSE;
                break;
            default:

            // flag if this font should be removed at the log off time

                if (flTmp & AFRW_ADD_REMOTE_FONT)
                {
                // always remove fonts on the net on the log off,
                // whether they be listed in the registry or not.
                // The point is that even if they are listed, drive letters
                // may change if a different user logs on. If this font is
                // NOT in the registry, it is a temporary remote font added
                // by an app, so we want it removed on the next log off.

                    *pfl |= AFRW_ADD_REMOTE_FONT;
                }
                else
                {
                // do not remove, even if not in the registry, i.e. even
                // if this is a temp. font added by some app. This is ok
                // since this is a local font, drive letter destinations
                // do not change even when a different user logs on. Note
                // that this is little bit different that 3.51 behavior.
                // This way every font is marked at AddFontResource time
                // for whether it should be removed or not at log off time.
                // This makes time consuming registry searches at log off
                // time unnecessary. The drawback is that the next user
                // to log on may still have local temp fonts loaded
                // from a previous user's session

                    *pfl |= AFRW_ADD_LOCAL_FONT;
                }
                break;
            }
        }
    }

    if (!bDoIt)
    {
        *pcwc    = 0;
        *pcFiles = 0;

        if (pwchMem)
        {
            LOCALFREE(pwchMem);
            pwchMem = NULL;
        }
    }
    else // success
    {
        *pcwc    = cwc;
        *pcFiles = cFiles;

    // set flag for embedded fonts

        *pfl |= flEmbed;

        ASSERTGDI((flEmbed & (FRW_EMB_PID|FRW_EMB_TID)) == flEmbed, "Embedded fonts: flEmbed\n");
        ASSERTGDI((!flEmbed) || (cFiles == 1), "Embedded fonts but cFiles != 1\n");
    }

    return pwchMem;
}


int GdiAddFontResourceW (
    LPWSTR  pwszFileName,            // ptr. to unicode filename string
    FLONG   fl,
    DESIGNVECTOR *pdv
    )
{
    int   iRet = 0;
    ULONG cFiles, cwc;
    WCHAR *pwszNtPath;
    DWORD dwPidTid;


    if (pwszNtPath = pwszAllocNtMultiplePath(pwszFileName,
                                             &fl,
                                             &cwc,
                                             &cFiles,
                                             TRUE,
                                             &dwPidTid, FALSE))
    {

        iRet = NtGdiAddFontResourceW(pwszNtPath,cwc,
                                     cFiles,fl,dwPidTid, pdv);

        LOCALFREE(pwszNtPath);

        if (!iRet)
        {
            pwszNtPath = NULL;
            cFiles = 0;
            cwc = 0;
            dwPidTid = 0;
            if (pwszNtPath = pwszAllocNtMultiplePath(pwszFileName,
                                                     &fl,
                                                     &cwc,
                                                     &cFiles,
                                                     TRUE,
                                                     &dwPidTid, TRUE))
            {

                iRet = NtGdiAddFontResourceW(pwszNtPath,cwc,
                                             cFiles,fl,dwPidTid, pdv);
    
                LOCALFREE(pwszNtPath);

            }
        }
    }

    
    return iRet;
}


/******************************Public*Routine******************************\
*
* int WINAPI AddFontResource(LPSTR psz)
*
* History:
*  13-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


int WINAPI AddFontResourceA(LPCSTR psz)
{
    return AddFontResourceExA(psz,0, NULL);
}


/******************************Public*Routine******************************\
*
* int WINAPI AddFontResourceExA(LPSTR psz, DWORD dwFlag, PVOID NULL)
*
* History:
*  29-Aug-1996 -by- Xudong Wu [TessieW]
* Wrote it.
\**************************************************************************/


int WINAPI AddFontResourceExA(LPCSTR psz, DWORD fl, PVOID pvResrved)
{
    int     iRet = 0;
    WCHAR   awcPathName[MAX_PATH];
    ULONG   cch, cwc;
    WCHAR  *pwcPathName = NULL;
    DESIGNVECTOR * pdv = NULL;

// check invalid flag

    if ( fl & ~(FR_PRIVATE | FR_NOT_ENUM) )
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

// protect ourselves from bogus pointers, win95 does it

    try
    {
        cch = lstrlenA(psz) + 1;
        if (cch <= MAX_PATH)
        {
            pwcPathName = awcPathName;
            cwc = MAX_PATH;
        }
        else
        {
            pwcPathName = (WCHAR *)LOCALALLOC(cch * sizeof(WCHAR));
            cwc = cch;
        }

        if (pwcPathName)
        {
            vToUnicodeN(pwcPathName, cwc, psz, cch);
            iRet = 1;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        iRet = 0;
    }

    if (iRet)
        iRet = GdiAddFontResourceW(pwcPathName,(FLONG)fl, pdv);

    if (pwcPathName && (pwcPathName != awcPathName))
        LOCALFREE(pwcPathName);

    return iRet;
}


/**************************Public*Routine************************\
* int WINAPI AddFontMemResourceEx()
*
* Font image pointed by pFileView is loaded as private font
* (FR_PRIVATE | FR_NOT_ENUM) to the system private font tale.
*
* If succeeds, it returns an index to the global memory font
* link list, otherwise it returns zero.
*
* History:
*  20-May-1997 -by- Xudong Wu [TessieW]
* Wrote it.
\****************************************************************/

HANDLE WINAPI AddFontMemResourceEx
(
    PVOID pFileView,
    DWORD cjSize,
    PVOID pvResrved,
    DWORD* pNumFonts)
{
    DWORD   cjDV = 0;
    DESIGNVECTOR * pdv = NULL;

    // check size and pointer

    if ((cjSize == 0) || (pFileView == NULL) || (pNumFonts == NULL))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    if (pdv)
    {
        cjDV = SIZEOFDV(pdv->dvNumAxes);
    }

    return (NtGdiAddFontMemResourceEx(pFileView, cjSize, pdv, cjDV, pNumFonts));
}


/******************************Public*Routine******************************\
*
* int WINAPI AddFontResourceTracking(LPSTR psz)
*
* This routine calls AddFontResource and, if succesful, keeps track of the
* call along with an unique id identifying the apps.  Later when the app
* goes away, WOW will call RemoveNetFonts to remove all of these added fonts
* if there are on a net share.
*
* History:
*  Fri 22-Jul-1994 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

int AddFontResourceTracking(LPCSTR psz, UINT id)
{
    INT iRet;
    AFRTRACKNODE *afrtnNext;
    WCHAR awcPathBuffer[MAX_PATH],*pTmp;
    WCHAR   awcPathName[MAX_PATH];
    BOOL bResult;

    vToUnicodeN(awcPathName, MAX_PATH, psz, lstrlenA(psz) + 1);

    iRet = GdiAddFontResourceW(awcPathName, 0 , NULL);

    if( iRet == 0 )
    {
    // we failed so just return

        return(iRet);
    }

// now get the full pathname of the font

    if (!bMakePathNameW(awcPathBuffer,awcPathName, &pTmp, NULL))
    {
        WARNING("AddFontResourceTracking unable to create path\n");
        return(iRet);
    }

// if this isn't a network font just return

    if( bFileIsOnTheHardDrive( awcPathBuffer ) )
    {
        return(iRet);
    }

// now search the list

    for( afrtnNext = pAFRTNodeList;
         afrtnNext != NULL;
         afrtnNext = afrtnNext->pafrnNext
       )
    {
        if( ( !_wcsicmp( awcPathBuffer, afrtnNext->pwszPath ) ) &&
            ( id == afrtnNext->id ))
        {
        // we've found an entry so update the count and get out of here

            afrtnNext->cLoadCount += 1;
            return(iRet);
        }
    }

// if we got here this font isn't yet in the list so we need to add it

    afrtnNext = (AFRTRACKNODE *) LOCALALLOC( sizeof(AFRTRACKNODE) +
                ( sizeof(WCHAR) * ( wcslen( awcPathBuffer ) + 1)) );

    if( afrtnNext == NULL )
    {
        WARNING("AddFontResourceTracking unable to allocate memory\n");
        return(iRet);
    }

// link it in

    afrtnNext->pafrnNext = pAFRTNodeList;
    pAFRTNodeList = afrtnNext;

// the path string starts just past afrtnNext in our recently allocated buffer

    afrtnNext->pwszPath = (WCHAR*) (&afrtnNext[1]);
    lstrcpyW( afrtnNext->pwszPath, awcPathBuffer );

    afrtnNext->id = id;
    afrtnNext->cLoadCount = 1;

    return(iRet);

}


/******************************Public*Routine******************************\
*
* int RemoveFontResourceEntry( UINT id, CHAR *pszFaceName )
*
* Either search for an entry for a particlur task id and font file or and
* decrement the load count for it or, if pszPathName is NULL unload all
* fonts loaded by the task.
*
* History:
*  Fri 22-Jul-1994 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/


void RemoveFontResourceEntry( UINT id, WCHAR *pwszPathName )
{
    AFRTRACKNODE *afrtnNext,**ppafrtnPrev;
    BOOL bMore = TRUE;

    while( bMore )
    {

        for( afrtnNext = pAFRTNodeList, ppafrtnPrev = &pAFRTNodeList;
            afrtnNext != NULL;
            afrtnNext = afrtnNext->pafrnNext )
        {
            if( (( pwszPathName == NULL ) ||
                 ( !_wcsicmp( pwszPathName, afrtnNext->pwszPath ))) &&
                 ( id == afrtnNext->id ))
            {
            // we've found an entry so break
                break;
            }

            ppafrtnPrev = &(afrtnNext->pafrnNext);

        }

        if( afrtnNext == NULL )
        {
            bMore = FALSE;
        }
        else
        {
            if( pwszPathName == NULL )
            {
            // we need to call RemoveFontResource LoadCount times to remove this font

                while( afrtnNext->cLoadCount )
                {
                    RemoveFontResourceW( afrtnNext->pwszPath );
                    afrtnNext->cLoadCount -= 1;
                }
            }
            else
            {
                afrtnNext->cLoadCount -= 1;

            // we're only decrementing the ref count so we are done

                bMore = FALSE;
            }

            // now unlink it and a free the memory if the ref count is zero

            if( afrtnNext->cLoadCount == 0 )
            {
                *ppafrtnPrev = afrtnNext->pafrnNext;
                LOCALFREE(afrtnNext);
            }

        }

    }

}




/******************************Public*Routine******************************\
*
* int RemoveFontResourceTracking(LPSTR psz)
*
* History:
*  Fri 22-Jul-1994 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

int RemoveFontResourceTracking(LPCSTR psz, UINT id)
{
    INT iRet;
    WCHAR awcPathBuffer[MAX_PATH],*pTmp;
    WCHAR   awcPathName[MAX_PATH];
    BOOL bResult;

    vToUnicodeN(awcPathName, MAX_PATH, psz, lstrlenA(psz) + 1);

#if DBG
    DbgPrint("We made it to RemoveFontsResourceTracking %s\n", psz);
#endif
    iRet = RemoveFontResourceW( awcPathName );

    if( iRet == 0 )
    {
    // we failed so just return

        return(iRet);
    }

// now get the full pathname of the font

    if (!bMakePathNameW(awcPathBuffer, awcPathName, &pTmp, NULL))
    {
        WARNING("RemoveFontResourceTracking unable to create path\n");
        return(iRet);
    }

#if DBG
    DbgPrint("Path is %ws\n", awcPathBuffer);
#endif

// if this isn't a network font just return

    if( bFileIsOnTheHardDrive( awcPathBuffer ) )
    {
        return(iRet);
    }

// now search the list decrement the reference count

    RemoveFontResourceEntry( id, awcPathBuffer );

    return(iRet);
}


void UnloadNetworkFonts( UINT id )
{
    RemoveFontResourceEntry( id, NULL );
}



/******************************Public*Routine******************************\
*
* int WINAPI AddFontResourceW(LPWSTR pwsz)
*
* History:
*  13-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

int WINAPI AddFontResourceW(LPCWSTR pwsz)
{
    return GdiAddFontResourceW((LPWSTR) pwsz, 0 , NULL);
}


/******************************Public*Routine******************************\
*
* int WINAPI AddFontResourceExW
*
* History:
*  29-Aug-1996 -by- Xudong Wu [TessieW]
* Wrote it.
\**************************************************************************/

int WINAPI AddFontResourceExW(LPCWSTR pwsz, DWORD fl, PVOID pvResrved)
{
    DESIGNVECTOR * pdv = NULL;
    
// check invalid flag

    if (fl & ~(FR_PRIVATE | FR_NOT_ENUM))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    return GdiAddFontResourceW((LPWSTR) pwsz, (FLONG)fl , pdv);
}


/******************************Public*Routine******************************\
*
* BOOL WINAPI RemoveFontResource(LPSTR psz)
*
*
* History:
*  13-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL WINAPI RemoveFontResourceA(LPCSTR psz)
{
    return RemoveFontResourceExA(psz,0, NULL);
}

/******************************Public*Routine******************************\
*
* BOOL WINAPI RemoveFontResourceExA
*
* Note: Process should use the same flag with the one for AddFontResourceExA
*       to remove the font resource
*
* History:
*  27-Sept-1996 -by- Xudong Wu [TessieW]
* Wrote it.
\**************************************************************************/

BOOL WINAPI RemoveFontResourceExA(LPCSTR psz, DWORD fl, PVOID pvResrved)
{
    BOOL bRet = FALSE;
    WCHAR awcPathName[MAX_PATH];
    ULONG cch, cwc;
    WCHAR *pwcPathName = NULL;
    DESIGNVECTOR * pdv = NULL;
    
// check invalid flag

    if (fl & ~(FR_PRIVATE | FR_NOT_ENUM))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

// protect ourselves from bogus pointers, win95 does it

    try
    {
        cch = lstrlenA(psz) + 1;
        if (cch <= MAX_PATH)
        {
            pwcPathName = awcPathName;
            cwc = MAX_PATH;
        }
        else
        {
            pwcPathName = (WCHAR *)LOCALALLOC(cch * sizeof(WCHAR));
            cwc = cch;
        }

        if (pwcPathName)
        {
            vToUnicodeN(pwcPathName, cwc, psz, lstrlenA(psz) + 1);
            bRet = 1;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        bRet = 0;
    }

    if (bRet)
        bRet = RemoveFontResourceExW(pwcPathName,fl, NULL);

    if (pwcPathName && (pwcPathName != awcPathName))
        LOCALFREE(pwcPathName);

    return bRet;
}




/******************************Public*Routine******************************\
*
* BOOL WINAPI RemoveFontResourceW(LPWSTR pwsz)
*
* History:
*  13-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL WINAPI RemoveFontResourceW(LPCWSTR pwsz)
{
    return RemoveFontResourceExW(pwsz,0, NULL);
}


/******************************Public*Routine******************************\
*
* BOOL WINAPI RemoveFontResourceExW
*
* Note:  needs to pass fl and dwPidTid for Embedded fonts
* History:
*  27-Sept-1996 -by- Xudong Wu [TessieW]
* Wrote it.
\**************************************************************************/


BOOL WINAPI RemoveFontResourceExW(LPCWSTR pwsz, DWORD dwfl, PVOID pvResrved)
{

    BOOL bRet = FALSE;
    ULONG cFiles, cwc;
    FLONG fl = dwfl;
    WCHAR *pwszNtPath;
    DWORD dwPidTid;
    DESIGNVECTOR * pdv = NULL;
    
// check invalid flag

    if (fl & ~(FR_PRIVATE | FR_NOT_ENUM))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    if (pwsz)
    {
        if (pwszNtPath = pwszAllocNtMultiplePath((LPWSTR)pwsz,
                                                 &fl,
                                                 &cwc,
                                                 &cFiles,
                                                 FALSE,
                                                 &dwPidTid, TRUE))
        {
            bRet = NtGdiRemoveFontResourceW(pwszNtPath, cwc,
                                            cFiles, fl, dwPidTid,
                                            pdv);
            LOCALFREE(pwszNtPath);
        }
    }
    return bRet;

}


/**************************Public*Routine************************\
*
* BOOL WINAPI RemoveFontMemResourceEx()
*
* Note: current process can only remove the memory fonts loaded
* by itself.
*
* History:
*  20-May-1997 -by- Xudong Wu [TessieW]
* Wrote it.
\****************************************************************/

BOOL WINAPI RemoveFontMemResourceEx(HANDLE hMMFont)
{
    if (hMMFont == 0)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return (NtGdiRemoveFontMemResourceEx(hMMFont));
}

/******************************Public*Routine******************************\
* CreateScalableFontResourceA
*
* Client side stub (ANSI version) to GreCreateScalableFontResourceW.
*
* History:
*  16-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY CreateScalableFontResourceA(
DWORD    flHidden,              // mark file as embedded font
LPCSTR   lpszResourceFile,      // name of file to create
LPCSTR   lpszFontFile,          // name of font file to use
LPCSTR    lpszCurrentPath)       // path to font file
{
// Allocate stack space for UNICODE version of input strings.

    WCHAR   awchResourceFile[MAX_PATH];
    WCHAR   awchFontFile[MAX_PATH];
    WCHAR   awchCurrentPath[MAX_PATH];

// Parameter checking.

    if ( (lpszFontFile == (LPSTR) NULL) ||
         (lpszResourceFile == (LPSTR) NULL)
       )
    {
        WARNING("gdi!CreateScalableFontResourceA(): bad parameter\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

// Convert input strings to UNICODE.

    vToUnicodeN(awchResourceFile, MAX_PATH, lpszResourceFile, lstrlenA(lpszResourceFile)+1);
    vToUnicodeN(awchFontFile, MAX_PATH, lpszFontFile, lstrlenA(lpszFontFile)+1);

    // Note: Whereas the other parameters may be not NULL, lpszCurrentPath
    //       may be NULL.  Therefore, we need to treat it a little
    //       differently.

    if ( lpszCurrentPath != (LPSTR) NULL )
    {
        vToUnicodeN(awchCurrentPath, MAX_PATH, lpszCurrentPath, lstrlenA(lpszCurrentPath)+1);
    }
    else
    {
        awchCurrentPath[0] = L'\0';     // equivalent to NULL pointer for this call
    }

// Call to UNICODE version of call.

    return (CreateScalableFontResourceW (
                flHidden,
                awchResourceFile,
                awchFontFile,
                awchCurrentPath
                )
           );
}

/******************************Public*Routine******************************\
* CreateScalableFontResourceInternalW
*
* Creates a font resource file that contains the font directory and the name
* of the name of the scalable font file.
*
* The flEmbed flag marks the created file as hidden (or embedded).  When an
* embedded font file is added to the system, it is hidden from enumeration
* and may be mapped to only if the bit is set in the LOGFONT.
*
* With regard to pwszCurrentPath and pwszFontFile, two cases are valid:
*
* 1.  pwszCurrentPath is a path (relative, full, etc.)
*     pwszFontFile is only FILENAME.EXT
*
*     In this case, pwszFontFile is stored in the resource file.  The caller
*     is responsible for copying the .TTF file to the \windows\system
*     directory.
*
* 2.  pwszCurrentPath is NULL or a pointer to NULL
*     pwszFontFile is a FULL pathname
*
*     In this case, pwszFontFile is stored in the resource file.  The
*     file must always exist at this pathname.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  12-Apr-1995 Gerrit van Wingerden [gerritv]
*   Moved it to client side for kernel mode.
*  10-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

#define vToASCIIN( pszDst, cch, pwszSrc, cwch)                                \
    {                                                                         \
        RtlUnicodeToMultiByteN((PCH)(pszDst), (ULONG)(cch), (PULONG)NULL,     \
              (PWSZ)(pwszSrc), (ULONG)((cwch)*sizeof(WCHAR)));                \
        (pszDst)[(cch)-1] = 0;                                                \
    }

BOOL CreateScalableFontResourceInternalW (
    FLONG    flEmbed,            // fl
    LPCWSTR   lpwszResourceFile,
    LPCWSTR   lpwszFontFile,
    LPCWSTR   lpwszCurrentPath
)
{
    BOOL    bFullPath = TRUE;           //!localW  nIsNotFullPath
    ULONG   cwchFileName = 0;           // localW  nFileNameLength
    ULONG   cwchFullPath = 0;           // localW  nFullPathLength
    ULONG   cwchModuleName = 0;         // localW  nModuleNameLength
    PWSZ    pwszModuleName;             // localD  lpModuleName
    PTRDIFF dpwszFullPath;              // lovalW  wFullPath
    ULONG   cjFontDir;                  // localW  nSizeFontDir
    ULONG   cchFaceName;                // localW  nFaceNameLength
    PSZ     pszFaceName;                // localD  lpFaceName
    PBYTE   pjOutObj;                   // localD  <lpFontDir, lpOutObj>
    HANDLE  hResFile;                   // localW  hResFile
    WCHAR   awchFullPath[MAX_PATH];  // localV  pFullPath, PATH_LENGTH
    PWSZ    pwszFullPath;
    PWSZ    pwszTmp;
    ULONG   cwch;
    BYTE    ajFontDir[CJ_FONTDIR];
    PSZ     pszTmp;
    BYTE    ajOutObj[CJ_OUTOBJ];
    USHORT  usTmp;

// Parameter check.

    if ( (lpwszFontFile == (LPWSTR) NULL) ||
         (lpwszResourceFile == (LPWSTR) NULL)
       )
    {
        WARNING("CreateScalableFontResourceInternalW(): bad parameter\n");
        return (FALSE);
    }

// If not a NULL ptr, put current path in the full path.

    pwszFullPath = awchFullPath;

    if ( lpwszCurrentPath != (LPWSTR) NULL )
    {
    // Copy current path including the NULL.

        pwszTmp = (PWSZ) lpwszCurrentPath;

        while ( *pwszFullPath++ = *pwszTmp++ );
        cwchFullPath = (ULONG) (pwszTmp - lpwszCurrentPath);   // number of characters copied

    // Back up pointer to the terminating NULL (we have to append here).

        pwszFullPath--;
        cwchFullPath--;

    // If any non-NULL characters were copied, then check to make sure path ends with '\'.

        if (cwchFullPath != 0)
        {
            if (awchFullPath[cwchFullPath - 1] != L'\\')
            {
            // Put in the '\' and NULL and update character count.

                *pwszFullPath++ = L'\\';
                *pwszFullPath = 0x0000;
                cwchFullPath++;

            }

        // Path info was copied, so we didn't have a full path.

            bFullPath = FALSE;
        }

    }

// Append the file name

    pwszTmp = (PWSZ) lpwszFontFile;

    while ( *pwszFullPath++ = *pwszTmp++ );

    // Note: lengths include the NULL.
    cwchFullPath += (ULONG) (pwszTmp - lpwszFontFile);  // add on number of characters copied
    cwchFileName = (ULONG) (pwszTmp - lpwszFontFile);   // number of characters copied

// [Win 3.1 compatibility]
//     Win 3.1 is paranoid.  They parse the full pathname backward to look for
//     filename (without path), just in case both lpwszCurrentPath and
//     pwszFileName (with a path) is passed in.

// Adjust pointer to terminating NULL.

    pwszFullPath--;

// Move pointer to beginning of filename alone.  Figure out the length
// of just the filename.

    pwszTmp = pwszFullPath;

    // Note: loop terminates when beginning of string is reached or
    // the first '\' is encountered.

    for (cwch = cwchFullPath;
         (cwch != 0) && (*pwszTmp != L'\\');
         cwch--, pwszTmp--
        );

    pwszTmp++;                          // backed up one too far

    cwchFileName = cwchFullPath - cwch; // cwch is length of just path

// The filename is the module name, so set the pointer at current position.

    pwszModuleName = pwszTmp;

// Figure out the length of module name (filename with no extention).
// NULL is not counted (nor does it exist!).

    // Note: loop terminates when end of string is reached or
    // '.' is encountered.

    for (cwch = 0;
         (cwch < cwchFileName) && (*pwszTmp != L'.');
         cwch++, pwszTmp++
        );

    // Truncate length to 8 because Win 3.1 does (probably an EXE format
    // requirement).

    cwchModuleName = min(cwch, 8);

// If a full path was passed in via pwszFileName, then set offset to it.

    if ( bFullPath )
    {
        dpwszFullPath = 0;
    }

// Otherwise, set offset to filename alone.

    else
    {
        dpwszFullPath = (PTRDIFF)(pwszModuleName - awchFullPath); // this is win64 safe cast!
        cwchFullPath = cwchFileName;
    }

// Allocate memory on the stack for the Font Directory resource structure.

    RtlZeroMemory((PVOID) ajFontDir, (UINT) CJ_FONTDIR);

// Call GreMakeFontDir to create a Font Directory resource.

    {
        UNICODE_STRING unicodeString;
        PWSZ pwsz;

        RtlDosPathNameToNtPathName_U(awchFullPath,
                                     &unicodeString,
                                     NULL,
                                     NULL);

        cjFontDir = NtGdiMakeFontDir(flEmbed,
                                    ajFontDir,
                                    sizeof(ajFontDir),
                                    unicodeString.Buffer,
                                    (unicodeString.Length + 1) * sizeof(*(unicodeString.Buffer))
                                    );

        if (unicodeString.Buffer)
        {
            RtlFreeHeap(RtlProcessHeap(),0,unicodeString.Buffer);
        }
    }

    if ( cjFontDir == (ULONG ) 0 )
    {
        WARNING("CreateScalableFontResourceInternalW(): fontdir creation failed\n");
        return (FALSE);
    }

// Find the facename and facename length in the font directory.

    pszTmp = (PSZ) (ajFontDir + SIZEFFH + 4 + 1);

    while (*pszTmp++);              // skip the family name.

    pszFaceName = pszTmp;

    // Note: count does not include NULL in this case.

    for (cchFaceName = 0; *pszTmp; pszTmp++, cchFaceName++);

// Allocate memory on the stack for the font resource file memory image.

    RtlZeroMemory((PVOID) ajOutObj, (UINT) CJ_OUTOBJ);

    pjOutObj = ajOutObj;

// Copy generic EXE header into output image.

    RtlCopyMemory(pjOutObj, ajExeHeader, SIZEEXEHEADER);

// Copy generic New EXE header into output image.

    RtlCopyMemory(pjOutObj + SIZEEXEHEADER, ausNewExe, SIZENEWEXE);

// Copy the fake resource table into output image.

    RtlCopyMemory(pjOutObj + SIZEEXEHEADER + SIZENEWEXE, ausFakeResTable, SIZEFAKERESTBL);

// Patch up field, Font Directory Size Index (as a count of aligned pages).

    WRITE_WORD(pjOutObj + OFF_FONTDIRSIZINDEX, (cjFontDir + ALIGNMENTCOUNT - 1) >> ALIGNMENTSHIFT);

// Patch offsets to imported names table and module reference table.

    usTmp = (USHORT) (cwchModuleName +
            READ_WORD(pjOutObj + SIZEEXEHEADER + OFF_ne_restab) +
            6);

    WRITE_WORD((pjOutObj + SIZEEXEHEADER + OFF_ne_imptab), usTmp);
    WRITE_WORD((pjOutObj + SIZEEXEHEADER + OFF_ne_modtab), usTmp);

// Patch offset to entry table.

    usTmp += (USHORT) cwchFileName + 1;
    WRITE_WORD((pjOutObj + SIZEEXEHEADER + OFF_ne_enttab), usTmp);

// Patch offset to and size of non-resident name table.

    usTmp += SIZEEXEHEADER + 4;
    WRITE_DWORD((pjOutObj + SIZEEXEHEADER + OFF_ne_nrestab), (DWORD) usTmp);

    WRITE_WORD((pjOutObj + SIZEEXEHEADER + OFF_ne_cbnrestab), SIZEFONTRES + 4 + cchFaceName);

// Now write some data after the exe headers and fake resource table.

    pjOutObj += SIZEEXEHEADER + SIZENEWEXE + SIZEFAKERESTBL;

// Write out module name length and module name.

    *pjOutObj++ = (BYTE) cwchModuleName;    // win 3.1 assumes < 256, so will we

    // Note: Writing cwchModuleName+1 characters because cwchModuleName
    //       does not include space for a NULL character.

    vToASCIIN((PSZ) pjOutObj, (UINT) cwchModuleName + 1, pwszModuleName, (UINT) cwchModuleName + 1);

    pjOutObj += cwchModuleName & 0x00ff;    // enforce < 256 assumption

// Pad with 5 bytes of zeroes.

    *pjOutObj++ = 0;
    *pjOutObj++ = 0;
    *pjOutObj++ = 0;
    *pjOutObj++ = 0;
    *pjOutObj++ = 0;

// Write out file name length and file name.

    *pjOutObj++ = (BYTE) cwchFileName;      // win 3.1 assumes < 256, so will we

    vToASCIIN((PSZ) pjOutObj, (UINT) cwchFileName, pwszModuleName, (UINT) cwchFileName);

    pjOutObj += cwchFileName & 0x00ff;      // enforce < 256 assumption

// Pad with 4 bytes of zeroes.

    *pjOutObj++ = 0;
    *pjOutObj++ = 0;
    *pjOutObj++ = 0;
    *pjOutObj++ = 0;

// Write out size of non-resident name table and the table itself.

    *pjOutObj++ = (BYTE) (SIZEFONTRES + 4 + cchFaceName);

    RtlCopyMemory(pjOutObj, ajFontRes, SIZEFONTRES);
    pjOutObj += SIZEFONTRES;

    RtlCopyMemory(pjOutObj, pszFaceName, (UINT) cchFaceName);
    pjOutObj += cchFaceName;

// Pad with 8 bytes of zeroes.

    RtlZeroMemory(pjOutObj, 8);
    pjOutObj += 8;

// Store some bogus code.  (Just an x86 RET instruction).

    pjOutObj = ajOutObj + CODE_OFFSET;
    *pjOutObj++ = 0xc3;                 // RET OpCode.
    *pjOutObj++ = 0x00;

// Copy the "full path name" into the resource position.

    pjOutObj = ajOutObj + RESOURCE_OFFSET;

    vToASCIIN((PSZ) pjOutObj, (UINT) cwchFullPath, awchFullPath + dpwszFullPath, (UINT) cwchFullPath);

    pjOutObj += cwchFullPath;

// Pad to paragraph boundary with zeroes.

    RtlZeroMemory(pjOutObj, PRIVRESSIZE - cwchFullPath);

    pjOutObj += PRIVRESSIZE - cwchFullPath;

// Finally, copy the font directory.

    RtlCopyMemory(pjOutObj, ajFontDir, cjFontDir);
    pjOutObj += cjFontDir;

// Add add a one paragraph padding of zeroes.

    RtlZeroMemory(pjOutObj, 16);

// Create the file.

    if ( (hResFile = CreateFileW(lpwszResourceFile,
                                 GENERIC_WRITE | GENERIC_READ,
                                 FILE_SHARE_READ,
                                 NULL,
                                 CREATE_NEW,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL)) != (HANDLE) -1 )
    {
        //
        // Write memory image to the file.
        //

        ULONG  cjWasWritten;

        if (WriteFile(hResFile,
                      ajOutObj,
                      CJ_OUTOBJ,
                      (LPDWORD) &cjWasWritten,
                      NULL) )
        {
            if (CloseHandle(hResFile) != 0)
            {
                return (TRUE);
            }
            else
            {
                WARNING("CreateScalableFontResourceInternalW(): error closing file\n");
            }
        }
        else
        {
            WARNING("CreateScalableFontResourceInternalW(): error writing to file\n");
        }

        //
        // Close the file on error
        //

        CloseHandle(hResFile);
    }

    return (FALSE);

}



/******************************Public*Routine******************************\
* CreateScalableFontResourceW
*
* Client side stub to GreCreateScalableFontResourceW.
*
* History:
*  16-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY CreateScalableFontResourceW (
DWORD    flHidden,              // mark file as embedded font
LPCWSTR  lpwszResourceFile,     // name of file to create
LPCWSTR  lpwszFontFile,         // name of font file to use
LPCWSTR  lpwszCurrentPath)      // path to font file
{
    BOOL    bRet = FALSE;
    ULONG   cjData;

    ULONG   cwchResourceFile;
    ULONG   cwchFontFile;
    ULONG   cwchCurrentPath;

    WCHAR   awchResourcePathName[MAX_PATH];
    WCHAR   awcPathName[MAX_PATH];
    WCHAR   awcFileName[MAX_PATH];
    PWSZ    pwszFilePart;
    BOOL    bMadePath;

// Parameter checking.

    if ( (lpwszFontFile == (LPWSTR) NULL) ||
         (lpwszResourceFile == (LPWSTR) NULL)
       )
    {
        WARNING("gdi!CreateScalableFontResourceW(): bad parameter\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

// To simplify the client server parameter validation, if lpwszCurrentPath
// is NULL, make it instead point to NULL.

    if ( lpwszCurrentPath == (LPWSTR) NULL )
        lpwszCurrentPath = L"";

// Need to convert paths and pathnames to full qualified paths and pathnames
// here on the client side because the "current directory" is not the same
// on the server side.

// Case 1: lpwszCurrentPath is NULL, so we want to transform lpwszFontFile
//         into a fully qualified path name and keep lpwszCurrentPath NULL.

    if ( *lpwszCurrentPath == L'\0' )
    {
    // Construct a fully qualified path name.

        if (!bMakePathNameW(awcPathName, (LPWSTR) lpwszFontFile, &pwszFilePart, NULL))
        {
            WARNING("gdi!CreateScalableFontResourceW(): could not construct src full pathname (1)\n");
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return (FALSE);
        }

        lpwszFontFile = awcPathName;
    }

// Case 2: lpwszCurrentPath points to path of font file, so we want to make
//         lpwszCurrentPath into a fully qualified path (not pathnmame) and
//         lpwszFontFile into the file part of the fully qualified path NAME.

    else
    {
    // Concatenate lpwszCurrentPath and lpwszFontFile to make a partial (maybe
    // even full) path.  Keep it temporarily in awcFileName.

        lstrcpyW(awcFileName, lpwszCurrentPath);
        if ( lpwszCurrentPath[wcslen(lpwszCurrentPath) - 1] != L'\\' )
            lstrcatW(awcFileName, L"\\");   // append '\' to path if needed
        lstrcatW(awcFileName, lpwszFontFile);

    // Construct a fully qualified path name.

        if (!bMakePathNameW(awcPathName, awcFileName, &pwszFilePart,NULL))
        {
            WARNING("gdi!CreateScalableFontResourceW(): could not construct src full pathname (2)\n");
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return (FALSE);
        }

    // Copy out the filename part.

        lstrcpyW(awcFileName, pwszFilePart);

    // Remove the filename part from the path name (so that it is now just
    // a fully qualified PATH).  We do this by turning the first character
    // of the filename part into a NULL, effectively cutting this part off.

        *pwszFilePart = L'\0';

    // Change the pointers to point at our buffers.

        lpwszCurrentPath = awcPathName;
        lpwszFontFile = awcFileName;
    }

// Convert the resource filename to a fully qualified path name.

    if ( !GetFullPathNameW(lpwszResourceFile, MAX_PATH, awchResourcePathName, &pwszFilePart) )
    {
        WARNING("gdi!CreateScalableFontResourceW(): could not construct dest full pathname\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }
    else
    {
        lpwszResourceFile = awchResourcePathName;
    }

    return(CreateScalableFontResourceInternalW( flHidden,
                                                lpwszResourceFile,
                                                lpwszFontFile,
                                                lpwszCurrentPath ));
}


/******************************Public*Routine******************************\
* GetRasterizerCaps
*
* Client side stub to GreGetRasterizerCaps.
*
* History:
*  17-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL  APIENTRY GetRasterizerCaps (
    OUT LPRASTERIZER_STATUS lpraststat, // pointer to struct
    IN UINT                 cjBytes     // copy this many bytes into struct
    )
{
    return(NtGdiGetRasterizerCaps(lpraststat,cjBytes));
}


/******************************Public*Routine******************************\
* SetFontEnumeration                                                       *
*                                                                          *
* Client side stub to GreSetFontEnumeration.                               *
*                                                                          *
* History:                                                                 *
*  09-Mar-1992 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

ULONG SetFontEnumeration(ULONG ulType)
{
    return(NtGdiSetFontEnumeration(ulType));
}

/******************************Public*Routine******************************\
* vNewTextMetricWToNewTextMetric
*
* History:
*  20-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/
static
VOID vNewTextMetricExWToNewTextMetricExA (
NEWTEXTMETRICEXA    *pntmexa,
NTMW_INTERNAL       *pntmi
)
{
    NEWTEXTMETRICW  *pntmw = &pntmi->entmw.etmNewTextMetricEx.ntmTm;
    NEWTEXTMETRICA  *pntma = &pntmexa->ntmTm;

    pntma->tmHeight           = pntmw->tmHeight             ; // DWORD
    pntma->tmAscent           = pntmw->tmAscent             ; // DWORD
    pntma->tmDescent          = pntmw->tmDescent            ; // DWORD
    pntma->tmInternalLeading  = pntmw->tmInternalLeading    ; // DWORD
    pntma->tmExternalLeading  = pntmw->tmExternalLeading    ; // DWORD
    pntma->tmAveCharWidth     = pntmw->tmAveCharWidth       ; // DWORD
    pntma->tmMaxCharWidth     = pntmw->tmMaxCharWidth       ; // DWORD
    pntma->tmWeight           = pntmw->tmWeight             ; // DWORD
    pntma->tmOverhang         = pntmw->tmOverhang           ; // DWORD
    pntma->tmDigitizedAspectX = pntmw->tmDigitizedAspectX   ; // DWORD
    pntma->tmDigitizedAspectY = pntmw->tmDigitizedAspectY   ; // DWORD
    pntma->tmItalic           = pntmw->tmItalic             ; // BYTE
    pntma->tmUnderlined       = pntmw->tmUnderlined         ; // BYTE
    pntma->tmStruckOut        = pntmw->tmStruckOut          ; // BYTE
    pntma->ntmFlags           = pntmw->ntmFlags             ;
    pntma->ntmSizeEM          = pntmw->ntmSizeEM            ;
    pntma->ntmCellHeight      = pntmw->ntmCellHeight        ;
    pntma->ntmAvgWidth        = pntmw->ntmAvgWidth          ;
    pntma->tmPitchAndFamily   = pntmw->tmPitchAndFamily     ; //        BYTE
    pntma->tmCharSet          = pntmw->tmCharSet            ; //               BYTE

    pntma->tmFirstChar   = pntmi->tmdNtmw.chFirst;
    pntma->tmLastChar    = pntmi->tmdNtmw.chLast ;
    pntma->tmDefaultChar = pntmi->tmdNtmw.chDefault;
    pntma->tmBreakChar   = pntmi->tmdNtmw.chBreak;

// finally copy font signature, required by EnumFontFamiliesEx

    pntmexa->ntmFontSig = pntmi->entmw.etmNewTextMetricEx.ntmFontSig;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\glsup.h ===
/******************************Header*File*********************************\
*
* glsup.h
*
* Header file for GL metafiling and printing support
*
* History:
*  Wed Mar 15 15:20:49 1995	-by-	Drew Bliss [drewb]
*   Created
* Copyright (c) 1995-1999 Microsoft Corporation                            
*
\**************************************************************************/

#ifndef __GLSUP_H__
#define __GLSUP_H__

// Critical section for GL support
extern RTL_CRITICAL_SECTION semGlLoad;

BOOL LoadOpenGL(void);
void UnloadOpenGL(void);

// Track the current banded rendering session
typedef struct
{
    HDC hdcDest;
    HDC hdcDib;
    HBITMAP hbmDib;
    HGLRC hrc;
    int iBandWidth;
    int iBandHeight;
    int iReducedBandWidth;
    int iReducedBandHeight;
    int xSource;
    int ySource;
    int iSourceWidth;
    int iSourceHeight;
    int iReduceFactor;
    int iReducedWidth;
    int iReducedHeight;
    int iStretchMode;
    POINT ptBrushOrg;
    BOOL bBrushOrgSet;
} GLPRINTSTATE;

BOOL InitGlPrinting(HENHMETAFILE hemf, HDC hdcDest, RECT *rc,
                    DEVMODEW *pdm, GLPRINTSTATE *pgps);
void EndGlPrinting(GLPRINTSTATE *pgps);
BOOL PrintMfWithGl(HENHMETAFILE hemf, GLPRINTSTATE *pgps,
                   POINTL *pptlBand, SIZE *pszBand);
BOOL IsMetafileWithGl(HENHMETAFILE hemf);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\glsup.c ===
/******************************Header*File*********************************\
*
* glsup.c
*
* GL metafiling and printing support
*
* History:
*  Wed Mar 15 15:20:49 1995 -by-    Drew Bliss [drewb]
*   Created
*
* Copyright (c) 1995-1999 Microsoft Corporation                            
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "glsup.h"


// GL metafile callbacks in opengl32
typedef struct _GLMFCALLBACKS
{
    BOOL  (APIENTRY *GlmfInitPlayback)(HDC, ENHMETAHEADER *, LPRECTL);
    BOOL  (APIENTRY *GlmfBeginGlsBlock)(HDC);
    BOOL  (APIENTRY *GlmfPlayGlsRecord)(HDC, DWORD, BYTE *, LPRECTL);
    BOOL  (APIENTRY *GlmfEndGlsBlock)(HDC);
    BOOL  (APIENTRY *GlmfEndPlayback)(HDC);
    BOOL  (APIENTRY *GlmfCloseMetaFile)(HDC);
    HGLRC (APIENTRY *wglCreateContext)(HDC);
    BOOL  (APIENTRY *wglDeleteContext)(HGLRC);
    BOOL  (APIENTRY *wglMakeCurrent)(HDC, HGLRC);
    HGLRC (APIENTRY *wglGetCurrentContext)(void);
} GLMFCALLBACKS;
#define GL_MF_CALLBACKS (sizeof(GLMFCALLBACKS)/sizeof(PROC))

static char *pszGlmfEntryPoints[] =
{
    "GlmfInitPlayback",
    "GlmfBeginGlsBlock",
    "GlmfPlayGlsRecord",
    "GlmfEndGlsBlock",
    "GlmfEndPlayback",
    "GlmfCloseMetaFile",
    "wglCreateContext",
    "wglDeleteContext",
    "wglMakeCurrent",
    "wglGetCurrentContext"
};
#define GL_MF_ENTRYPOINTS (sizeof(pszGlmfEntryPoints)/sizeof(char *))

RTL_CRITICAL_SECTION semGlLoad;

static GLMFCALLBACKS gmcGlFuncs = {NULL};
static HMODULE hOpenGL = NULL;
static LONG lLoadCount = 0;

/*****************************Private*Routine******************************\
*
* LoadOpenGL
*
* Loads opengl32.dll if necessary
*
* History:
*  Wed Mar 01 10:41:59 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL LoadOpenGL(void)
{
    HMODULE hdll;
    BOOL fRet;
    PROC *ppfn;
    int i;
    GLMFCALLBACKS gmc;

    ASSERTGDI(GL_MF_CALLBACKS == GL_MF_ENTRYPOINTS,
              "Glmf callback/entry points mismatch\n");
    
    ENTERCRITICALSECTION(&semGlLoad);

    if (hOpenGL != NULL)
    {
        goto Success;
    }
    
    fRet = FALSE;

    hdll = LoadLibrary("opengl32.dll");
    if (hdll == NULL)
    {
        WARNING("Unable to load opengl32.dll\n");
        goto Exit;
    }

    ppfn = (PROC *)&gmc;
    for (i = 0; i < GL_MF_CALLBACKS; i++)
    {
        if (!(*ppfn = (PROC)GetProcAddress(hdll,
                                           pszGlmfEntryPoints[i])))
        {
            WARNING("opengl32 missing '");
            WARNING(pszGlmfEntryPoints[i]);
            WARNING("'\n");
            FreeLibrary(hdll);
            goto Exit;
        }

        ppfn++;
    }

    gmcGlFuncs = gmc;
    hOpenGL = hdll;
    
 Success:
    fRet = TRUE;
    lLoadCount++;

 Exit:
    LEAVECRITICALSECTION(&semGlLoad);
    return fRet;
}

/*****************************Private*Routine******************************\
*
* UnloadOpenGL
*
* Unloads opengl32.dll if necessary
*
* History:
*  Wed Mar 01 11:02:06 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void UnloadOpenGL(void)
{
    ENTERCRITICALSECTION(&semGlLoad);

    ASSERTGDI(lLoadCount > 0, "UnloadOpenGL called without Load\n");
    
    if (--lLoadCount == 0)
    {
        HMODULE hdll;

        ASSERTGDI(hOpenGL != NULL, "Positive load count with no DLL\n");
        
        hdll = hOpenGL;
        hOpenGL = NULL;
        memset(&gmcGlFuncs, 0, sizeof(gmcGlFuncs));
        FreeLibrary(hdll);
    }

    LEAVECRITICALSECTION(&semGlLoad);
}

/*****************************Private*Routine******************************\
*
* GlmfInitPlayback
*
* Stub to forward call to opengl
*
* History:
*  Wed Mar 01 11:02:31 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfInitPlayback(HDC hdc, ENHMETAHEADER *pemh, LPRECTL prclDest)
{
    ASSERTGDI(gmcGlFuncs.GlmfInitPlayback != NULL,
              "GlmfInitPlayback not set\n");
    return gmcGlFuncs.GlmfInitPlayback ? gmcGlFuncs.GlmfInitPlayback(hdc, pemh, prclDest) : FALSE;
}

/*****************************Private*Routine******************************\
*
* GlmfBeginGlsBlock
*
* Stub to forward call to opengl
*
* History:
*  Mon Apr 10 11:38:13 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfBeginGlsBlock(HDC hdc)
{
    ASSERTGDI(gmcGlFuncs.GlmfBeginGlsBlock != NULL,
              "GlmfBeginGlsBlock not set\n");
    return gmcGlFuncs.GlmfBeginGlsBlock ? gmcGlFuncs.GlmfBeginGlsBlock(hdc) : FALSE;
}

/*****************************Private*Routine******************************\
*
* GlmfPlayGlsRecord
*
* Stub to forward call to opengl
*
* History:
*  Wed Mar 01 11:02:49 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfPlayGlsRecord(HDC hdc, DWORD cb, BYTE *pb,
                                LPRECTL prclBounds)
{
    ASSERTGDI(gmcGlFuncs.GlmfPlayGlsRecord != NULL,
              "GlmfPlayGlsRecord not set\n");
    return gmcGlFuncs.GlmfPlayGlsRecord ? gmcGlFuncs.GlmfPlayGlsRecord(hdc, cb, pb, prclBounds) : FALSE;
}

/*****************************Private*Routine******************************\
*
* GlmfEndGlsBlock
*
* Stub to forward call to opengl
*
* History:
*  Mon Apr 10 11:38:13 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfEndGlsBlock(HDC hdc)
{
    ASSERTGDI(gmcGlFuncs.GlmfEndGlsBlock != NULL,
              "GlmfEndGlsBlock not set\n");
    return gmcGlFuncs.GlmfEndGlsBlock ? gmcGlFuncs.GlmfEndGlsBlock(hdc) : FALSE;
}

/*****************************Private*Routine******************************\
*
* GlmfEndPlayback
*
* Stub to forward call to opengl
*
* History:
*  Wed Mar 01 11:03:02 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfEndPlayback(HDC hdc)
{
    BOOL fRet;

    ASSERTGDI(gmcGlFuncs.GlmfEndPlayback != NULL,
              "GlmfEndPlayback not set\n");
    fRet = gmcGlFuncs.GlmfEndPlayback ? gmcGlFuncs.GlmfEndPlayback(hdc) : FALSE;

    // WINBUG #82850 2-7-2000 bhouse We might was to unload opengl32.dll
    // This is not really a problem . This WINBUG is actually asking about
    // if we should unload("opengl32.dll"). The opengl32.dll is loaded as
    // a side effect of calling InitGlPrinting() call. This will only cause
    // a ref count leak. Also as this is user mode code on the client side.
    
    return fRet;
}

/*****************************Private*Routine******************************\
*
* GlmfCloseMetaFile
*
* Stub to forward call to opengl
*
* History:
*  Fri Mar 03 17:50:57 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfCloseMetaFile(HDC hdc)
{
    if (!LoadOpenGL())
    {
        return FALSE;
    }
    
    ASSERTGDI(gmcGlFuncs.GlmfCloseMetaFile != NULL,
              "GlmfCloseMetaFile not set\n");

    // WINBUG #82850 2-7-2000 bhouse Investigate need to unload
    // Old Comment:
    //    - Unload?
    // This is not really a problem . The WINBUG is actually asking about
    // if we should unload("opengl32.dll"). The opengl32.dll is loaded as
    // a side effect of calling InitGlPrinting() call. This will only cause
    // a ref count leak. Also as this is user mode code on the client side.
    return gmcGlFuncs.GlmfCloseMetaFile(hdc);
}

// WINBUG #82854 2-7-2000 bhouse Investigate magic value used for band memory limit
static DWORD cbBandMemoryLimit = 0x400000;

#define RECT_CB(w, h, cbp) ((cbp)*(w)*(h))

// GL has hardcoded limits on maximum rendering size
#define GL_WIDTH_LIMIT 16384
#define GL_HEIGHT_LIMIT 16384

/******************************Public*Routine******************************\
*
* EndGlPrinting
*
* Cleans up resources used while printing OpenGL metafiles
*
* History:
*  Wed Apr 12 17:51:24 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void EndGlPrinting(GLPRINTSTATE *pgps)
{
    ASSERTGDI(hOpenGL != NULL, "EndGlPrinting: No opengl\n");

    if (pgps->iReduceFactor > 1)
    {
        if (pgps->bBrushOrgSet)
        {
            SetBrushOrgEx(pgps->hdcDest,
                          pgps->ptBrushOrg.x, pgps->ptBrushOrg.y,
                          NULL);
        }
        if (pgps->iStretchMode != 0)
        {
            SetStretchBltMode(pgps->hdcDest, pgps->iStretchMode);
        }
    }
    
    if (gmcGlFuncs.wglGetCurrentContext() != NULL)
    {
        gmcGlFuncs.wglMakeCurrent(pgps->hdcDib, NULL);
    }
    if (pgps->hrc != NULL)
    {
        gmcGlFuncs.wglDeleteContext(pgps->hrc);
    }
    if (pgps->hdcDib != NULL)
    {
        DeleteDC(pgps->hdcDib);
    }
    if (pgps->hbmDib != NULL)
    {
        DeleteObject(pgps->hbmDib);
    }

    // WINBUG #82850 2-7-2000 bhouse Investigate need to unload
    // Old Comment:
    //    - Unload?
    // This is not really a problem . The WINBUG is actually asking about
    // if we should unload("opengl32.dll"). The opengl32.dll is loaded as
    // a side effect of calling InitGlPrinting() call. This will only cause
    // a ref count leak. Also as this is user mode code on the client side.
}

/******************************Public*Routine******************************\
*
* InitGlPrinting
*
* Performs all setup necessary for OpenGL printing
*
* History:
*  Wed Apr 12 17:51:46 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL InitGlPrinting(HENHMETAFILE hemf, HDC hdcDest, RECT *rc,
                    DEVMODEW *pdm, GLPRINTSTATE *pgps)
{
    PIXELFORMATDESCRIPTOR pfd;
    int iFmt;
    BITMAPINFO *pbmi;
    BITMAPINFOHEADER *pbmih;
    int iWidth, iHeight;
    DWORD cbMeta;
    POINT pt;
    UINT cbPixelFormat;
    UINT cbPixel;
    UINT nColors;
    PVOID pvBits;

    // Zero out in case we need to do cleanup
    memset(pgps, 0, sizeof(*pgps));
    pgps->hdcDest = hdcDest;

    if (!LoadOpenGL())
    {
        return FALSE;
    }
    
    pbmi = NULL;

    // Set the reduction factor according to the dithering setting
    // for the DC
    switch(pdm->dmDitherType)
    {
    case DMDITHER_NONE:
    case DMDITHER_LINEART:
        pgps->iReduceFactor = 1;
        break;
    case DMDITHER_COARSE:
        pgps->iReduceFactor = 2;
        break;
    default:
        pgps->iReduceFactor = 4;
        break;
    }
    
    // Put the destination DC into the mode we need for rendering
    if (pgps->iReduceFactor > 1)
    {
        pgps->iStretchMode = SetStretchBltMode(hdcDest, HALFTONE);
        if (pgps->iStretchMode == 0)
        {
            goto EH_Cleanup;
        }

        // Need to reset the brush origin after changing the stretch mode
        if (!SetBrushOrgEx(hdcDest, 0, 0, &pgps->ptBrushOrg))
        {
            goto EH_Cleanup;
        }
        pgps->bBrushOrgSet = TRUE;
    }
    
    // Get the pixel format in the metafile if one exists
    cbPixelFormat = GetEnhMetaFilePixelFormat(hemf, sizeof(pfd), &pfd);
    if (cbPixelFormat == GDI_ERROR ||
        (cbPixelFormat != 0 && cbPixelFormat != sizeof(pfd)))
    {
        goto EH_Cleanup;
    }

    // No pixel format in the header, so use a default
    if (cbPixelFormat == 0)
    {
        pfd.nSize = sizeof(pfd);
        pfd.nVersion = 1;
        pfd.dwFlags = PFD_DRAW_TO_BITMAP | PFD_SUPPORT_OPENGL;
        pfd.iPixelType = PFD_TYPE_RGBA;
        pfd.cColorBits = 16;
        pfd.cRedBits = 5;
        pfd.cRedShift = 0;
        pfd.cGreenBits = 5;
        pfd.cGreenShift = 5;
        pfd.cBlueBits = 5;
        pfd.cBlueShift = 10;
        pfd.cAlphaBits = 0;
        pfd.cAccumBits = 0;
        pfd.cDepthBits = 16;
        pfd.cStencilBits = 0;
        pfd.cAuxBuffers = 0;
        pfd.iLayerType = PFD_MAIN_PLANE;
    }
    else
    {
        // Force draw-to-bitmap and single buffered
        // Turn off flags not supported
        pfd.dwFlags = (pfd.dwFlags &
                       ~(PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER |
                         PFD_STEREO | PFD_SUPPORT_GDI)) |
                         PFD_DRAW_TO_BITMAP | PFD_SUPPORT_OPENGL;

        // What happens in color index mode?
        if (pfd.iPixelType == PFD_TYPE_RGBA)
        {
            pfd.cColorBits = 16;
            pfd.cRedBits = 5;
            pfd.cRedShift = 0;
            pfd.cGreenBits = 5;
            pfd.cGreenShift = 5;
            pfd.cBlueBits = 5;
            pfd.cBlueShift = 10;
        }

        pfd.iLayerType = PFD_MAIN_PLANE;
    }
    
    // Determine the amount of memory used per pixel
    // This rounds 4bpp to one byte per pixel but that's close
    // enough
    cbPixel =
        (pfd.cColorBits+7)/8+
        (pfd.cAlphaBits+7)/8+
        (pfd.cAccumBits+7)/8+
        (pfd.cDepthBits+7)/8+
        (pfd.cStencilBits+7)/8;
    
    // Determine the size of the band based on smaller of:
    //   The biggest DIB that can fit in cbBandMemoryLimit
    //   The size of the metafile

    // The given rectangle is the size the metafile is supposed to
    // be rendered into so base our computations on it
    pgps->xSource = rc->left;
    pgps->ySource = rc->top;
    iWidth = rc->right-rc->left;
    iHeight = rc->bottom-rc->top;

    if (iWidth == 0 || iHeight == 0)
    {
        WARNING("InitGlPrinting: Metafile has no size\n");
        return FALSE;
    }

    pgps->iSourceWidth = iWidth;
    pgps->iSourceHeight = iHeight;
    
    // Reduce the resolution somewhat to allow halftoning space to work
    iWidth = iWidth/pgps->iReduceFactor;
    iHeight = iHeight/pgps->iReduceFactor;

    pgps->iReducedWidth = iWidth;
    pgps->iReducedHeight = iHeight;

    if (iWidth > GL_WIDTH_LIMIT)
    {
        iWidth = GL_WIDTH_LIMIT;
    }
    if (iHeight > GL_HEIGHT_LIMIT)
    {
        iHeight = GL_HEIGHT_LIMIT;
    }
    
    cbMeta = RECT_CB(iWidth, iHeight, cbPixel);

    // Shrink the rectangle until it fits in our memory limit
    if (cbMeta > cbBandMemoryLimit)
    {
        // How many scanlines will fit
        iHeight = cbBandMemoryLimit/RECT_CB(iWidth, 1, cbPixel);
        if (iHeight == 0)
        {
            // Can't fit a full scanline, so figure out how much
            // of a scanline will fit
            iWidth = cbBandMemoryLimit/cbPixel;
            iHeight = 1;
        }
    }
    
    if (iWidth < 1 || iHeight < 1)
    {
        WARNING("InitGlPrinting: "
                "Not enough memory to render anything\n");
        return FALSE;
    }

    // Create a DIB for the band
    switch(pfd.cColorBits)
    {
    case 4:
        nColors = 16;
        break;
    case 8:
        nColors = 256;
        break;
    case 16:
    case 32:
        nColors = 3;
        break;
    case 24:
        // Use one since it's already included in the BITMAPINFO definition
        nColors = 1;
        break;
    }
    pbmi = (BITMAPINFO *)LocalAlloc(LMEM_FIXED,
                                    sizeof(BITMAPINFO)+(nColors-1)*
                                    sizeof(RGBQUAD));
    if (pbmi == NULL)
    {
        goto EH_Cleanup;
    }
    
    pbmih = &pbmi->bmiHeader;
    pbmih->biSize = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth = iWidth;
    pbmih->biHeight = iHeight;
    pbmih->biPlanes = 1;
    pbmih->biBitCount = pfd.cColorBits;
    if (pfd.cColorBits == 16 || pfd.cColorBits == 32)
    {
        pbmih->biCompression = BI_BITFIELDS;
        *((DWORD *)pbmi->bmiColors+0) =
            ((1 << pfd.cRedBits)-1) << pfd.cRedShift;
        *((DWORD *)pbmi->bmiColors+1) = 
            ((1 << pfd.cGreenBits)-1) << pfd.cGreenShift;
        *((DWORD *)pbmi->bmiColors+2) = 
            ((1 << pfd.cBlueBits)-1) << pfd.cBlueShift;
    }
    else if (pfd.cColorBits == 24)
    {
        pbmih->biCompression = BI_RGB;
    }
    else
    {
        UINT nEnt, i;
        
        pbmih->biCompression = BI_RGB;
        nEnt = GetEnhMetaFilePaletteEntries(hemf, nColors,
                                            (PALETTEENTRY *)pbmi->bmiColors);
        if (nEnt == GDI_ERROR)
        {
            goto EH_Cleanup;
        }

        // Force the flags byte to zero just to make sure
        for (i = 0; i < nEnt; i++)
        {
            pbmi->bmiColors[i].rgbReserved = 0;
        }
    }
    pbmih->biSizeImage= 0;
    pbmih->biXPelsPerMeter = 0;
    pbmih->biYPelsPerMeter = 0;
    pbmih->biClrUsed = 0;
    pbmih->biClrImportant = 0;

    // It doesn't matter what this DC is compatible with because that
    // will be overridden when we select the DIB into it
    pgps->hdcDib = CreateCompatibleDC(NULL);
    if (pgps->hdcDib == NULL)
    {
        WARNING("InitGlPrinting: CreateCompatibleDC failed\n");
        goto EH_Cleanup;
    }

    pgps->hbmDib = CreateDIBSection(pgps->hdcDib, pbmi, DIB_RGB_COLORS,
                                    &pvBits, NULL, 0);
    if (pgps->hbmDib == NULL)
    {
        WARNING("InitGlPrinting: CreateDibSection failed\n");
        goto EH_Cleanup;
    }

    if (SelectObject(pgps->hdcDib, pgps->hbmDib) == NULL)
    {
        WARNING("InitGlPrinting: SelectObject failed\n");
        goto EH_Cleanup;
    }
    
    // Set the pixel format for the DC
    
    iFmt = ChoosePixelFormat(pgps->hdcDib, &pfd);
    if (iFmt == 0)
    {
        WARNING("InitGlPrinting: ChoosePixelFormat failed\n");
        goto EH_Cleanup;
    }

    if (!SetPixelFormat(pgps->hdcDib, iFmt, &pfd))
    {
        WARNING("InitGlPrinting: SetPixelFormat failed\n");
        goto EH_Cleanup;
    }

    pgps->hrc = gmcGlFuncs.wglCreateContext(pgps->hdcDib);
    if (pgps->hrc == NULL)
    {
        WARNING("InitGlPrinting: wglCreateContext failed\n");
        goto EH_Cleanup;
    }

    if (!gmcGlFuncs.wglMakeCurrent(pgps->hdcDib, pgps->hrc))
    {
        WARNING("InitGlPrinting: wglMakeCurrent failed\n");
        goto EH_Cleanup;
    }

    pgps->iReducedBandWidth = iWidth;
    pgps->iBandWidth = iWidth*pgps->iReduceFactor;
    pgps->iReducedBandHeight = iHeight;
    pgps->iBandHeight = iHeight*pgps->iReduceFactor;
    
    return TRUE;

 EH_Cleanup:
    if (pbmi != NULL)
    {
        LocalFree(pbmi);
    }
    EndGlPrinting(pgps);
    return FALSE;
}

/*****************************Private*Routine******************************\
*
* RenderGlBand
*
* Plays the metafile and stretches the resulting band into the
* appropriate location in the destination
*
* Uses PlayEnhMetaFile-style error reporting, where we remember errors
* but continue to complete processing.  This avoids complete failure
* in cases where metafiles contain minor errors
*
* History:
*  Wed Apr 12 18:22:08 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

static BOOL RenderGlBand(HENHMETAFILE hemf, GLPRINTSTATE *pgps, int x, int y)
{
    RECT rcBand;
    int iWidth, iHeight;
    int iReducedWidth, iReducedHeight;
    int ySrc;
    BOOL fSuccess = TRUE;

    // We want to render a band-size rectangle of the source metafile
    // at (x,y), so we need to do a negative translation by (x,y)
    // Size remains constant since we don't want any scaling
    //
    // The caller of this routine may have already shifted the
    // viewport with SetViewport so we don't attempt to use it
    // to do our translation

    // WINBUG #82858 2-7-2000 bhouse Investigate propoer metafile handling
    // Old Comment:
    //     - Proper handling of metafile left,top?

    // x and y are guaranteed to be even multiples of pgps->iReduceFactor
    rcBand.left = -x/pgps->iReduceFactor;
    rcBand.right = rcBand.left+pgps->iReducedWidth;
    rcBand.top = -y/pgps->iReduceFactor;
    rcBand.bottom = rcBand.top+pgps->iReducedHeight;

    if (!PlayEnhMetaFile(pgps->hdcDib, hemf, &rcBand))
    {
        WARNING("RenderBand: PlayEnhMetaFile failed\n");
        fSuccess = FALSE;
    }

    // Copy the DIB bits to the destination
    // Compute minimal width and height to avoid clipping problems

    iWidth = pgps->iBandWidth;
    iReducedWidth = pgps->iReducedBandWidth;
    iHeight = pgps->iBandHeight;
    iReducedHeight = pgps->iReducedBandHeight;
    ySrc = 0;

    // Check for X overflow
    if (x+iWidth > pgps->iSourceWidth)
    {
        iWidth = pgps->iSourceWidth-x;
        // If iWidth is not an even multiple of pgps->iReduceFactor then
        // this can result in a different stretch factor
        // I think this is more or less unavoidable
        iReducedWidth = (iWidth+pgps->iReduceFactor-1)/pgps->iReduceFactor;
    }

    // Invert destination Y
    y = pgps->iSourceHeight-pgps->iBandHeight-y;
    
    // Check for Y underflow
    if (y < 0)
    {
        iHeight += y;
        iReducedHeight = (iHeight+pgps->iReduceFactor-1)/pgps->iReduceFactor;
        // This can cause registration problems when y is not a
        // multiple of pgps->iReduceFactor.  Again, I'm not sure that
        // anything can be done
        ySrc -= (y+pgps->iReduceFactor-1)/pgps->iReduceFactor;
        y = 0;
    }

#if 0
    DbgPrint("GL band (%d,%d - %d,%d)\n", x, y, iWidth, iHeight);
#endif
    
    if (!StretchBlt(pgps->hdcDest,
                    x+pgps->xSource, y+pgps->ySource, iWidth, iHeight,
                    pgps->hdcDib,
                    0, ySrc, iReducedWidth, iReducedHeight,
                    SRCCOPY))
    {
        WARNING("RenderBand: StretchBlt failed\n");
        fSuccess = FALSE;
    }

    return fSuccess;
}

/******************************Public*Routine******************************\
*
* PrintMfWithGl
*
* Prints a metafile that contains OpenGL records by rendering bands
* in a DIB and then stretching them to the printer DC
*
* Uses PlayEnhMetaFile-style error reporting, where we remember errors
* but continue to complete processing.  This avoids complete failure
* in cases where metafiles contain minor errors
*
* History:
*  Wed Apr 12 18:22:41 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL PrintMfWithGl(HENHMETAFILE hemf, GLPRINTSTATE *pgps,
                   POINTL *pptlBand, SIZE *pszBand)
{
    int iHorzBands, iVertBands;
    int iH, iV;
    int x, y;
    BOOL fSuccess = TRUE;
    int iStretchMode;
    POINT ptBrushOrg;

    ASSERTGDI(hOpenGL != NULL, "PrintMfWithGl: No opengl\n");
    
    // To render banded to a destination we create a 24-bit DIB and
    // play the metafile into that, then blt the DIB to
    // the destination DC
    //
    // The DIB and Z buffer take a large amount of memory
    // so the playback is banded into bands whose size is
    // determined by the amount of memory we want to consume

    iHorzBands = (pgps->iSourceWidth+pgps->iBandWidth-1)/pgps->iBandWidth;
    iVertBands = (pgps->iSourceHeight+pgps->iBandHeight-1)/pgps->iBandHeight;

    // Render high to low because the Y axis is positive up and
    // we want to go down the page
    y = (iVertBands-1)*pgps->iBandHeight;
    for (iV = 0; iV < iVertBands; iV++)
    {
        x = 0;
        for (iH = 0; iH < iHorzBands; iH++)
        {
            // If the current OpenGL band doesn't overlap any of the
            // current printer band, there's no point in drawing anything
            if (pptlBand != NULL &&
                pszBand != NULL &&
                (x+pgps->iBandWidth <= pptlBand->x ||
                 x >= pptlBand->x+pszBand->cx ||
                 y+pgps->iBandHeight <= pptlBand->y ||
                 y >= pptlBand->y+pszBand->cy))
            {
                // No band overlap
            }
            else if (!RenderGlBand(hemf, pgps, x, y))
            {
                fSuccess = FALSE;
            }

            x += pgps->iBandWidth;
        }
        
        y -= pgps->iBandHeight;
    }

    return fSuccess;
}

/******************************Public*Routine******************************\
*
* IsMetafileWithGl()
*
* IsMetafileWithGl will determines the matafile contains
* OpenGL records or not.
*
* History:
*  Wed Jan 29 00:00:00 1997 -by- Hideyuki Nagase [hideyukn]
* Created.
*
\**************************************************************************/

BOOL IsMetafileWithGl(HENHMETAFILE hmeta)
{
    ENHMETAHEADER emh;
    UINT cbEmh;

    cbEmh = GetEnhMetaFileHeader(hmeta, sizeof(emh), &emh);
    if (cbEmh == 0)
    {
        WARNING("IsMetafileWithGl(): GetEnhMetaFileHeader failed\n");
        return FALSE;
    }

    if (cbEmh >= META_HDR_SIZE_VERSION_2)
    {
        return emh.bOpenGL;
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\image.c ===
/******************************Module*Header*******************************\
* Module Name: image .c                                                    *
*                                                                          *
* Client side stubs for Alpha, Transparent and GradientFill                *
*                                                                          *
* Created: 05-Jun-1997                                                     *
* Author: Mark Enstrom [marke]                                             *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

/******************************Public*Routine******************************\
* GdiAlphaBlend
*
*   DC to DC alpha blt
*
* Arguments:
*
*   hdcDst        - dst dc
*   DstX          - dst x origin
*   DstY          - dst y origin
*   DstCx         - dst width
*   DstCy         - dst height
*   hdcSrc        - src dc
*   SrcX          - src x origin
*   SrcY          - src y origin
*   SrcCx         - src width
*   SrcCy         - src height
*   BlendFunction - blend function
*
* Return Value:
*
*   Status
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
GdiAlphaBlend(
    HDC           hdcDest,
    int           DstX,
    int           DstY,
    int           DstCx,
    int           DstCy,
    HDC           hdcSrc,
    int           SrcX,
    int           SrcY,
    int           SrcCx,
    int           SrcCy,
    BLENDFUNCTION BlendFunction
    )
{
    BOOL bRet = FALSE;
    BLENDULONG Blend;
    FIXUP_HANDLE(hdcDest);
    FIXUP_HANDLE(hdcSrc);

    Blend.Blend = BlendFunction;

    //
    // check for metafile
    //

    if (!hdcSrc || IS_METADC16_TYPE(hdcSrc))
        return(bRet);

    if (IS_ALTDC_TYPE(hdcDest))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdcDest))
            return(bRet);

        DC_PLDC(hdcDest,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_AnyBitBlt(hdcDest,
                              DstX,
                              DstY,
                              DstCx,
                              DstCy,
                              (LPPOINT)NULL,
                              hdcSrc,
                              SrcX,
                              SrcY,
                              SrcCx,
                              SrcCy,
                              (HBITMAP)NULL,
                              0,
                              0,
                              Blend.ul,
                              EMR_ALPHABLEND))
            {
                return(bRet);
            }
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
        {
            vSAPCallback(pldc);
        }

        if (pldc->fl & LDC_DOC_CANCELLED)
        {
            return(bRet);
        }

        if (pldc->fl & LDC_CALL_STARTPAGE)
        {
            StartPage(hdcDest);
        }
    }

    RESETUSERPOLLCOUNT();

    //
    // call kernel to draw
    //

    bRet = NtGdiAlphaBlend(
                      hdcDest,
                      DstX,
                      DstY,
                      DstCx,
                      DstCy,
                      (HDC)hdcSrc,
                      SrcX,
                      SrcY,
                      SrcCx,
                      SrcCy,
                      BlendFunction,
                      NULL
                      );
    return(bRet);
}

/******************************Public*Routine******************************\
* GdiGradientFill
*
*   metafile or call kernel
*
* Arguments:
*
*   hdc      - hdc
*   pVertex  - pointer to vertex array
*   nVertex  - number of elements in vertex array
*   pMesh    - pointer to mesh array
*   nCount   - number of elements in mesh array
*   ulMode   - drawing mode
*
* Return Value:
*
*   status
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
GdiGradientFill(
    HDC         hdc,
    PTRIVERTEX  pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nCount,
    ULONG       ulMode
    )
{
    BOOL bRet = TRUE;
    PTRIVERTEX pTempVertex = pVertex;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        //
        // NT metafile
        //

        if (IS_ALTDC_TYPE(hdc))
        {
            PLDC pldc;

            if (IS_METADC16_TYPE(hdc))
                return(bRet);

            DC_PLDC(hdc,pldc,bRet);

            if (pldc->iType == LO_METADC)
            {
                bRet = MF_GradientFill(hdc,pVertex,nVertex,pMesh,nCount,ulMode);
                if (!bRet)
                {
                    return(bRet);
                }
            }

            if (pldc->fl & LDC_SAP_CALLBACK)
            {
                vSAPCallback(pldc);
            }

            if (pldc->fl & LDC_DOC_CANCELLED)
            {
                return(bRet);
            }

            if (pldc->fl & LDC_CALL_STARTPAGE)
            {
                StartPage(hdc);
            }
        }

        RESETUSERPOLLCOUNT();

        //
        // if icm is on, tanslate vertex array
        //

        if (
             (IS_ICM_INSIDEDC(pdcattr->lIcmMode)) &&
             (pVertex != NULL)              &&
             (nVertex > 0)                  &&
             (nVertex <  0x80000000)
           )
        {
            pTempVertex = (PTRIVERTEX)LOCALALLOC(nVertex * sizeof(TRIVERTEX));

            if (pTempVertex != NULL)
            {
                //
                // copy to new vertex array
                //

                memcpy(pTempVertex,pVertex,nVertex * sizeof(TRIVERTEX));

                bRet = IcmTranslateTRIVERTEX(hdc,pdcattr,pTempVertex,nVertex);
            }
            else
            {
                bRet = FALSE;
                GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
            }
        }

        if (bRet)
        {
            //
            // call kernel to draw
            //

            bRet = NtGdiGradientFill(hdc,
                                     pTempVertex,
                                     nVertex,
                                     pMesh,
                                     nCount,
                                     ulMode
                                     );
        }

        //
        // free temp buffer
        //

        if (pTempVertex != pVertex)
        {
            LOCALFREE(pTempVertex);
        }
    }
    else
    {
        bRet = FALSE;
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GdiTransparentBlt
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/3/1996 Lingyun Wang
*
\**************************************************************************/

BOOL
GdiTransparentBlt(
                 HDC   hdcDest,
                 int   DstX,
                 int   DstY,
                 int   DstCx,
                 int   DstCy,
                 HDC   hSrc,
                 int   SrcX,
                 int   SrcY,
                 int   SrcCx,
                 int   SrcCy,
                 UINT  Color
                 )
{
    BOOL bRet = FALSE;
    PDC_ATTR pdca;

    if ((DstCx <= 0) || (DstCy <= 0) || (SrcCx <= 0) || (SrcCy <= 0))
    {
        return (FALSE);
    }

    FIXUP_HANDLE(hdcDest);
    FIXUP_HANDLE(hSrc);

    if (!hSrc || IS_METADC16_TYPE(hSrc))
        return(bRet);

    if (IS_ALTDC_TYPE(hdcDest))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdcDest))
            return(bRet);

        DC_PLDC(hdcDest,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_AnyBitBlt(hdcDest,
                              DstX,
                              DstY,
                              DstCx,
                              DstCy,
                              (LPPOINT)NULL,
                              hSrc,
                              SrcX,
                              SrcY,
                              SrcCx,
                              SrcCy,
                              (HBITMAP)NULL,
                              0,
                              0,
                              Color,
                              EMR_TRANSPARENTBLT))
            {
                return(bRet);
            }
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
        {
            vSAPCallback(pldc);
        }

        if (pldc->fl & LDC_DOC_CANCELLED)
        {
            return(bRet);
        }

        if (pldc->fl & LDC_CALL_STARTPAGE)
        {
            StartPage(hdcDest);
        }
    }


    RESETUSERPOLLCOUNT();

    bRet = NtGdiTransparentBlt(
                      hdcDest,
                      DstX,
                      DstY,
                      DstCx,
                      DstCy,
                      hSrc,
                      SrcX,
                      SrcY,
                      SrcCx,
                      SrcCy,
                      Color);
    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\ldc.c ===
/******************************Module*Header*******************************\
* Module Name: ldc.c
*
* GDI functions that are handled on the client side.
*
* Created: 05-Jun-1991 01:45:21
* Author: Charles Whitmer [chuckwh]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "wowgdip.h"
#define MIRRORED_DC(pDcAttr)     (pDcAttr->dwLayout & LAYOUT_RTL)

BOOL MF16_RecordParms2( HDC hdc, int parm2, WORD Func);

/******************************Public*Routine******************************
 * GetAndSetDCDWord( HDC, UINT, UINT, UINT, UINT, UINT )
 *
 * Gerrit van Wingerden [gerritv]
 *  11-9-94     Wrote It.
 *
 **************************************************************************/

DWORD GetAndSetDCDWord(
 HDC hdc,
 UINT uIndex,
 UINT uValue,
 UINT uEmr,
 WORD wEmr16,
 UINT uError )
{
    DWORD uRet=0;

    DWORD retData;

    // Metafile the call.

    if( IS_ALTDC_TYPE(hdc) && ( uEmr != EMR_MAX+1 ) )
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsD(hdc,uValue,wEmr16));

        DC_PLDC(hdc,pldc,uError)

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetD(hdc,(DWORD)uValue,uEmr))
                return(uRet);
        }
    }

    uRet = NtGdiGetAndSetDCDword(hdc,
                                 uIndex,
                                 uValue,
                                 &retData);

    return (( uRet ) ? retData : uError);

}
/******************************Public*Routine******************************\
* SetBkMode
*
* Arguments:
*
*   hdc   - DC handle
*   iMode - new mode
*
* Return Value:
*
*   Old mode value or 0 for failure
*
\**************************************************************************/

int
META
APIENTRY
SetBkMode(
    HDC hdc,
    int iMode
    )
{
    int iModeOld = 0;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if( IS_ALTDC_TYPE(hdc) )
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsD(hdc,iMode,META_SETBKMODE));

        DC_PLDC(hdc,pldc,iModeOld)

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetD(hdc,(DWORD)iMode,EMR_SETBKMODE))
                return(iModeOld);
        }
    }

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        iModeOld = pDcAttr->lBkMode;
        pDcAttr->jBkMode = (iMode == OPAQUE) ? OPAQUE : TRANSPARENT;
        pDcAttr->lBkMode = iMode;
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(iModeOld);
}

/******************************Public*Routine******************************\
* SetPolyFillMode
*
* Arguments:
*
*   hdc   - DC handle
*   iMode - new mode
*
* Return Value:
*
*   Old mode value or 0 for failure
*
\**************************************************************************/

int META APIENTRY SetPolyFillMode(HDC hdc,int iMode)
{
    int iModeOld = 0;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if( IS_ALTDC_TYPE(hdc) )
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsD(hdc,iMode,META_SETPOLYFILLMODE));

        DC_PLDC(hdc,pldc,iModeOld)

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetD(hdc,(DWORD)iMode,EMR_SETPOLYFILLMODE))
                return(iModeOld);
        }
    }

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        CHECK_AND_FLUSH(hdc, pDcAttr);

        iModeOld = pDcAttr->lFillMode;
        pDcAttr->jFillMode = (iMode == WINDING) ? WINDING : ALTERNATE;
        pDcAttr->lFillMode = iMode;

    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(iModeOld);
}

/******************************Public*Routine******************************\
* SetROP2
*
* Arguments:
*
*   hdc   - DC handle
*   iMode - new mode
*
* Return Value:
*
*   Old mode value or 0 for failure
*
\**************************************************************************/

int META APIENTRY SetROP2(HDC hdc,int iMode)
{
    int iOldROP2 = 0;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if( IS_ALTDC_TYPE(hdc) )
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsD(hdc,iMode,META_SETROP2));

        DC_PLDC(hdc,pldc,iOldROP2)

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetD(hdc,(DWORD)iMode,EMR_SETROP2))
                return(iOldROP2);
        }
    }

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        CHECK_AND_FLUSH(hdc, pDcAttr);

        iOldROP2 = pDcAttr->jROP2;
        pDcAttr->jROP2 = (BYTE)iMode;
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(iOldROP2);
}

/******************************Public*Routine******************************\
* SetStretchBltMode
*
* Arguments:
*
*   hdc   - DC handle
*   iMode - new mode
*
* Return Value:
*
*   Old mode value or 0 for failure
*
\**************************************************************************/

int META APIENTRY SetStretchBltMode(HDC hdc,int iMode)
{
    int iModeOld = 0;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if( IS_ALTDC_TYPE(hdc) )
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsD(hdc,iMode,META_SETSTRETCHBLTMODE));

        DC_PLDC(hdc,pldc,iModeOld)

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetD(hdc,(DWORD)iMode,EMR_SETSTRETCHBLTMODE))
                return(iModeOld);
        }
    }

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        iModeOld = pDcAttr->lStretchBltMode;
        pDcAttr->lStretchBltMode = iMode;

        if ((iMode <= 0) || (iMode > MAXSTRETCHBLTMODE))
        {
            iMode = (DWORD) WHITEONBLACK;
        }

        pDcAttr->jStretchBltMode = (BYTE)iMode;
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(iModeOld);
}

/******************************Public*Routine******************************\
* SetTextAlign
*
* Arguments:
*
*   hdc   - DC handle
*   iMode - new mode
*
* Return Value:
*
*   Old mode value or 0 for failure
*
\**************************************************************************/

UINT META APIENTRY SetTextAlign(HDC hdc,UINT iMode)
{
    int iModeOld = GDI_ERROR;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if( IS_ALTDC_TYPE(hdc) )
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsD(hdc,iMode,META_SETTEXTALIGN));

        DC_PLDC(hdc,pldc,iModeOld)

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetD(hdc,(DWORD)iMode,EMR_SETTEXTALIGN))
                return(iModeOld);
        }
    }

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        iModeOld = pDcAttr->lTextAlign;
        pDcAttr->lTextAlign = iMode;
        if (MIRRORED_DC(pDcAttr) && (iMode & TA_CENTER) != TA_CENTER) {
            iMode = iMode ^ TA_RIGHT;
        }
        pDcAttr->flTextAlign = iMode & (TA_UPDATECP | TA_CENTER | TA_BASELINE);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(iModeOld);
}

/******************************Public*Routine******************************\
* SetRelAbs (hdc,iMode)
*
* Client side attribute setting routine.
*
* History:
*  5-11-94 -by- Lingyun Wang [lingyunw]
* Moved client side attr to server side
*
*  09-Jun-1992 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int APIENTRY SetRelAbs(HDC hdc,int iMode)
{
    FIXUP_HANDLE(hdc);

    return((int) GetAndSetDCDWord( hdc,
                                   GASDDW_RELABS,
                                   iMode,
                                   EMR_MAX+1,
                                   EMR_MAX+1,
                                   0 ));
}

/******************************Public*Routine******************************\
* SetTextCharacterExtra (hdc,dx)
*
* Client side attribute setting routine.
*
*  5-11-94 -by- Lingyun Wang [lingyunw]
* Moved client side attr to server side
*
*  Sat 08-Jun-1991 00:53:45 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

int META APIENTRY SetTextCharacterExtra(HDC hdc,int dx)
{
    int  iRet = 0x80000000L;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

// Validate the spacing.

    if (dx == 0x80000000)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(iRet);
    }

    // Metafile the call for 16-bit only.
    // For enhanced metafiles, the extras are included in the textout records.

    if (IS_METADC16_TYPE(hdc))
        return(MF16_RecordParms2(hdc,dx,META_SETTEXTCHAREXTRA));

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        CHECK_AND_FLUSH_TEXT(hdc, pDcAttr);

        iRet = pDcAttr->lTextExtra;
        pDcAttr->lTextExtra = dx;
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return (iRet);
}

/******************************Public*Routine******************************\
* SetTextColor
*
* Arguments:
*
*   hdc   - DC handle
*   color - new color
*
* Return Value:
*
*   Old mode value or 0 for failure
*
\**************************************************************************/

COLORREF META APIENTRY SetTextColor(HDC hdc,COLORREF color)
{
    COLORREF crRet = CLR_INVALID;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    if( IS_ALTDC_TYPE(hdc) )
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsD(hdc,color,META_SETTEXTCOLOR));

        DC_PLDC(hdc,pldc,crRet)

        if (pldc->iType == LO_METADC)
        {
            CHECK_COLOR_PAGE(pldc,color);
            if (!MF_SetD(hdc,(DWORD)color,EMR_SETTEXTCOLOR))
                return(crRet);
        }
    }

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        crRet = pdcattr->ulForegroundClr;
        pdcattr->ulForegroundClr = color;

        color &= 0x13ffffff;

        if (!(color & 0x01000000) && bNeedTranslateColor(pdcattr))
        {
            COLORREF NewColor;

            BOOL bStatus = IcmTranslateCOLORREF(hdc,
                                                pdcattr,
                                                color,
                                                &NewColor,
                                                ICM_FORWARD);
            if (bStatus)
            {
                color = NewColor;
            }
        }

        if (pdcattr->crForegroundClr != color)
        {
            pdcattr->crForegroundClr = color;
            pdcattr->ulDirty_ |= (DIRTY_FILL|DIRTY_LINE|DIRTY_TEXT);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(crRet);
}
/******************************Public*Routine******************************\
* SetBkColor
*
* Arguments:
*
*   hdc   - DC handle
*   color - new color
*
* Return Value:
*
*   Old mode value or 0 for failure
*
\**************************************************************************/


COLORREF META APIENTRY SetBkColor(HDC hdc,COLORREF color)
{
    COLORREF crRet = CLR_INVALID;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    if( IS_ALTDC_TYPE(hdc) )
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsD(hdc,color,META_SETBKCOLOR));

        DC_PLDC(hdc,pldc,crRet)

        if (pldc->iType == LO_METADC)
        {
            CHECK_COLOR_PAGE(pldc,color);
            if (!MF_SetD(hdc,(DWORD)color,EMR_SETBKCOLOR))
                return(crRet);
        }
    }

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        //
        // set app specified color
        //

        crRet = pdcattr->ulBackgroundClr;
        pdcattr->ulBackgroundClr = color;

        color &= 0x13ffffff;

        //
        // check icm if not PALINDEX
        //

        if (!(color & 0x01000000) && bNeedTranslateColor(pdcattr))
        {
            COLORREF NewColor;

            BOOL bStatus = IcmTranslateCOLORREF(hdc,
                                                pdcattr,
                                                color,
                                                &NewColor,
                                                ICM_FORWARD);
            if (bStatus)
            {
                color = NewColor;
            }
        }

        if (color != pdcattr->crBackgroundClr)
        {
            pdcattr->crBackgroundClr = color;
            pdcattr->ulDirty_ |= (DIRTY_FILL|DIRTY_LINE|DIRTY_BACKGROUND);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(crRet);
}

/******************************Public*Routine******************************\
* SetDCBrushColor
*
* Arguments:
*
*   hdc   - DC handle
*   color - new color
*
* Return Value:
*
*   Old mode value or 0 for failure
*
* History :
*
*  Feb.16.1997 -by- Hideyuki Nagase [hideyukn]
* ICM-aware version.
\**************************************************************************/

COLORREF META APIENTRY SetDCBrushColor(HDC hdc,COLORREF color)
{
    COLORREF crRet = CLR_INVALID;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        if (IS_ALTDC_TYPE(hdc))
        {
            if (!IS_METADC16_TYPE(hdc))
            {
                PLDC pldc;

                DC_PLDC(hdc,pldc,crRet);

                if (pldc->iType == LO_METADC)
                {
                    CHECK_COLOR_PAGE(pldc,color);

                    if (pdcattr->hbrush == ghbrDCBrush)
                    {
                         BOOL   bRet = FALSE;
                         HBRUSH hbr  = CreateSolidBrush (color);

                         if (hbr != NULL)
                         {
                             // If there is an old DCbrush, delete it now
                             if (pldc->oldSetDCBrushColorBrush)
                                 DeleteObject (pldc->oldSetDCBrushColorBrush);

                             bRet = MF_SelectAnyObject (hdc, hbr, EMR_SELECTOBJECT);
                             // Store the new tmp DC brush in the LDC.
                             pldc->oldSetDCBrushColorBrush = hbr;
                         }

                         if (!bRet)
                             return (CLR_INVALID);
                    }
                 }

              }
        }

        //
        // set app specified color
        //

        crRet = pdcattr->ulDCBrushClr;
        pdcattr->ulDCBrushClr = color;

        color &= 0x13ffffff;

        //
        // check icm if not PALINDEX
        //

        if (!(color & 0x01000000) && bNeedTranslateColor(pdcattr))
        {
            COLORREF NewColor;

            BOOL bStatus = IcmTranslateCOLORREF(hdc,
                                                pdcattr,
                                                color,
                                                &NewColor,
                                                ICM_FORWARD);
            if (bStatus)
            {
                color = NewColor;
            }
        }

        if (color != pdcattr->crDCBrushClr)
        {
            pdcattr->crDCBrushClr = color;
            pdcattr->ulDirty_ |= DIRTY_FILL;
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(crRet);
}

/******************************Public*Routine******************************\
* GetDCBrushColor
*
* Arguments:
*
*   hdc   - DC handle
*
* Return Value:
*
*   Old mode value or 0 for failure
*
\**************************************************************************/

COLORREF META APIENTRY GetDCBrushColor(HDC hdc)
{
    COLORREF crRet = CLR_INVALID;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        crRet = pDcAttr->ulDCBrushClr;
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(crRet);
}


/******************************Public*Routine******************************\
* SetDCPenColor
*
* Arguments:
*
*   hdc   - DC handle
*   color - new color
*
* Return Value:
*
*   Old mode value or 0 for failure
*
* History :
*
*  Feb.16.1997 -by- Hideyuki Nagase [hideyukn]
* ICM-aware version.
\**************************************************************************/

COLORREF META APIENTRY SetDCPenColor(HDC hdc,COLORREF color)
{
    COLORREF crRet = CLR_INVALID;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        if(IS_ALTDC_TYPE(hdc))
        {
            if (!IS_METADC16_TYPE(hdc))
            {
                PLDC pldc;

                DC_PLDC(hdc,pldc,crRet);

                if (pldc->iType == LO_METADC)
                {
                    CHECK_COLOR_PAGE(pldc,color);

                    if (pdcattr->hpen == ghbrDCPen)
                    {
                         BOOL bRet = FALSE;
                         HPEN hpen = CreatePen (PS_SOLID,0,color);

                         if (hpen != NULL)
                         {
                             // If there is a old temp DC pen, delete it.
                             if (pldc->oldSetDCPenColorPen)
                                 DeleteObject(pldc->oldSetDCPenColorPen);

                             bRet = MF_SelectAnyObject (hdc, hpen, EMR_SELECTOBJECT);
                             // Store the new tmp pen in the LDC.
                             pldc->oldSetDCPenColorPen = hpen;
                         }

                         if (!bRet)
                             return (CLR_INVALID);
                    }
                }
            }
        }

        //
        // set app specified color
        //

        crRet = pdcattr->ulDCPenClr;
        pdcattr->ulDCPenClr = color;

        color &= 0x13ffffff;

        //
        // check icm if not PALINDEX
        //

        if (!(color & 0x01000000) && bNeedTranslateColor(pdcattr))
        {
            COLORREF NewColor;

            BOOL bStatus = IcmTranslateCOLORREF(hdc,
                                                pdcattr,
                                                color,
                                                &NewColor,
                                                ICM_FORWARD);
            if (bStatus)
            {
                color = NewColor;
            }
        }

        if (color != pdcattr->crDCPenClr)
        {
            pdcattr->crDCPenClr = color;
            pdcattr->ulDirty_ |= DIRTY_LINE;
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(crRet);
}

/******************************Public*Routine******************************\
* GetDCPenColor
*
* Arguments:
*
*   hdc   - DC handle
*
* Return Value:
*
*   Old mode value or 0 for failure
*
\**************************************************************************/

COLORREF META APIENTRY GetDCPenColor(HDC hdc)
{
    COLORREF crRet = CLR_INVALID;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        crRet = pDcAttr->ulDCPenClr;
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(crRet);
}

/******************************Public*Routine******************************
 * GetDCDWord( HDC hdc, UINT index, UINT error )
 *
 * This routine can be used to return a DWORD of information about a DC
 * from the server side.  The parameter index is used to specify which
 * one.  The values for indext are define in "ntgdi.h"
 *
 * Gerrit van Wingerden [gerritv]
 *  11-9-94     Wrote It.
 *
 **************************************************************************/

DWORD GetDCDWord( HDC hdc, UINT index, INT error )
{
    DWORD uRet=0;

    DWORD retData;

    uRet = NtGdiGetDCDword(hdc,
                           index,
                           &retData);

    return (uRet ? retData : error);

}

/******************************Public*Routine******************************\
* GetGraphicsMode(hdc)
* GetROP2(hdc)
* GetBkMode(hdc)
* GetPolyFillMode(hdc)
* GetStretchBltMode(hdc)
* GetTextAlign(hdc)
* GetTextCharacterExtra(hdc)
* GetTextColor(hdc)
* GetBkColor(hdc)
* GetRelAbs(hdc)
* GetFontLanguageInfo(hdc)
*
* added by Lingyunw:
* GetBreakExtra   (hdc)
* GetcBreak       (hdc)
*
* Simple client side handlers that just retrieve data from the LDC.
*
*  Mon 19-Oct-1992 -by- Bodin Dresevic [BodinD]
* update: GetGraphicsMode
*
*  Sat 08-Jun-1991 00:47:52 -by- Charles Whitmer [chuckwh]
* Wrote them.
\**************************************************************************/


#define BIDI_MASK (GCP_DIACRITIC|GCP_GLYPHSHAPE|GCP_KASHIDA|GCP_LIGATE|GCP_REORDER)


DWORD APIENTRY GetFontLanguageInfo(HDC hdc)
{
    DWORD dwRet = 0;
    DWORD dwRet1;

    FIXUP_HANDLE(hdc);

#ifdef LANGPACK
    if (gbLpk)
    {
        int iCharSet = NtGdiGetTextCharsetInfo(hdc, NULL, 0);
        if ((iCharSet == ARABIC_CHARSET) || (iCharSet == HEBREW_CHARSET))
            dwRet |= BIDI_MASK;
    }
#endif

    dwRet1 = GetDCDWord(hdc, DDW_FONTLANGUAGEINFO, (DWORD)GCP_ERROR);

    if (dwRet1 != GCP_ERROR)
    {
        dwRet |= dwRet1;
    }
    else
    {
        dwRet = dwRet1;
    }

    return dwRet;
}

int APIENTRY GetGraphicsMode(HDC hdc)
{
    int mode = 0;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        mode = pDcAttr->iGraphicsMode;
    }
    return(mode);
}

int APIENTRY GetROP2(HDC hdc)
{
    int rop = 0;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        rop = pDcAttr->jROP2;
    }

    return(rop);
}

int APIENTRY GetBkMode(HDC hdc)
{
    int mode = 0;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        mode = pDcAttr->lBkMode;
    }
    return(mode);
}

int APIENTRY GetPolyFillMode(HDC hdc)
{
    int mode = 0;

    PDC_ATTR pDcAttr;
    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        mode = pDcAttr->lFillMode;
    }
    return(mode);
}

int APIENTRY GetStretchBltMode(HDC hdc)
{
    int mode = 0;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        mode = pDcAttr->lStretchBltMode;
    }
    return(mode);
}

UINT APIENTRY GetTextAlign(HDC hdc)
{
    UINT al = GDI_ERROR;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        al = pDcAttr->lTextAlign;
    }
    return(al);
}

int APIENTRY GetTextCharacterExtra(HDC hdc)
{
    int iExtra = 0x80000000;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        iExtra = pDcAttr->lTextExtra;
    }

    return(iExtra);
}

COLORREF APIENTRY GetTextColor(HDC hdc)
{
    COLORREF co = CLR_INVALID;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        co = pDcAttr->ulForegroundClr;
    }
    return(co);
}

COLORREF APIENTRY GetBkColor(HDC hdc)
{
    COLORREF co = CLR_INVALID;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        co = pDcAttr->ulBackgroundClr;
    }

    return(co);
}

int APIENTRY GetRelAbs(HDC hdc,int iMode)
{
    iMode;

    FIXUP_HANDLE(hdc);

    return( (int) GetDCDWord( hdc, DDW_RELABS,(DWORD) 0 ));
}

//added for retrieve lBreakExtra from server side
int GetBreakExtra (HDC hdc)
{
    return( (int) GetDCDWord( hdc, DDW_BREAKEXTRA,(DWORD) 0 ));
}

//added for retrieve cBreak from server side
int GetcBreak (HDC hdc)
{
    return( (int) GetDCDWord( hdc, DDW_CBREAK,(DWORD) 0 ));
}

//added to retrieve hlfntNew for USER
HFONT APIENTRY GetHFONT (HDC hdc)
{
    HFONT hfnt = NULL;

    PDC_ATTR pDcAttr;
    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        hfnt = (HFONT)pDcAttr->hlfntNew;
    }

    return(hfnt);
}

/******************************Public*Routine******************************\
* GdiIsPlayMetafileDC
*
* Arguments:
*
*   hdc   - DC handle
*
* Return Value:
*
*   True if we are playing a metafile on DC, FALSE otherwise
*
* History :
*  Aug-31-97 -by- Samer Arafeh [SamerA]
\**************************************************************************/
BOOL APIENTRY GdiIsPlayMetafileDC(HDC hdc)
{
    PDC_ATTR pDcAttr;
    BOOL     bRet=FALSE;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        bRet = (pDcAttr->ulDirty_&DC_PLAYMETAFILE) ? TRUE : FALSE;
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\gdiicm.h ===
/******************************Module*Header*******************************\
* Module Name: gdiicm                                                      *
*                                                                          *
* Definitions needed for client side objects.                              *
*                                                                          *
* Copyright (c) 1993-1999 Microsoft Corporation                            *
\**************************************************************************/

//
// ICM
//
#if DBG
#define DBG_ICM 1
#else
#define DBG_ICM 0
#endif

#if DBG_ICM

#define DBG_ICM_API          0x00000001
#define DBG_ICM_WRN          0x00000002
#define DBG_ICM_MSG          0x00000004
#define DBG_ICM_COMPATIBLEDC 0x00000008
#define DBG_ICM_METAFILE     0x00000010

extern ULONG DbgIcm;

//
// trace APIs
//

#define ICMAPI(s)                \
    if (DbgIcm & DBG_ICM_API)    \
    {                            \
        DbgPrint ## s;           \
    }

#define ICMMSG(s)                \
    if (DbgIcm & DBG_ICM_MSG)    \
    {                            \
        DbgPrint ## s;           \
    }

#define ICMWRN(s)                \
    if (DbgIcm & DBG_ICM_WRN)    \
    {                            \
        DbgPrint ## s;           \
    }

#else

#define ICMAPI(s)
#define ICMMSG(s)
#define ICMWRN(s)

#endif

#define LOAD_ICMDLL(errCode) if ((ghICM == NULL) && (!IcmInitialize())) {   \
                                  WARNING("gdi32: Can't load mscms.dll\n"); \
                                  return((errCode));                        \
                             }

//
// The direction of color transform
//
#define ICM_FORWARD   0x0001
#define ICM_BACKWARD  0x0002

//
// Default intents
//
#define LCS_DEFAULT_INTENT LCS_GM_IMAGES
#define DM_DEFAULT_INTENT  DMICM_CONTRAST

typedef struct _PROFILECALLBACK_DATA
{
    PWSTR pwszFileName;
    BOOL  bFound;
} PROFILECALLBACK_DATA, *PPROFILECALLBACK_DATA;

//
// The flags for DIB_TRANSLATE_INFO.TranslateType
//
#define TRANSLATE_BITMAP               0x0001
#define TRANSLATE_HEADER               0x0002

typedef struct _DIB_TRANSLATE_INFO
{
    ULONG        TranslateType;
    BMFORMAT     SourceColorType;
    BMFORMAT     TranslateColorType;
    ULONG        SourceWidth;
    ULONG        SourceHeight;
    ULONG        SourceBitCount;
    LPBITMAPINFO TranslateBitmapInfo;
    ULONG        TranslateBitmapInfoSize;
    PVOID        pvSourceBits;
    ULONG        cjSourceBits;
    PVOID        pvTranslateBits;
    ULONG        cjTranslateBits;
} DIB_TRANSLATE_INFO, *PDIB_TRANSLATE_INFO;

//
// Cached Color Space Structure
//
typedef struct _CACHED_COLORSPACE
{
    LIST_ENTRY     ListEntry;
    HGDIOBJ        hObj;
    FLONG          flInfo;
    ULONG          cRef;
    HPROFILE       hProfile;
    DWORD          ColorIntent;
    BMFORMAT       ColorFormat;
    PROFILE        ColorProfile;
    LOGCOLORSPACEW LogColorSpace;
} CACHED_COLORSPACE, *PCACHED_COLORSPACE;

//
// CACHED_COLORSPACE.flInfo
//
#define HGDIOBJ_SPECIFIC_COLORSPACE    0x010000
#define NOT_CACHEABLE_COLORSPACE       0x020000
#define NEED_TO_FREE_PROFILE           0x040000 // ColorProfile.pProfileData must be GlobalFree()
#define NEED_TO_DEL_PROFILE            0x080000
#define NEED_TO_DEL_PROFILE_WITH_HOBJ  0x100000
#define ON_MEMORY_PROFILE              0x200000

#define DEVICE_CALIBRATE_COLORSPACE    0x000001 // Enable "DeviceColorCalibration" during halftoning
#define METAFILE_COLORSPACE           (0x000002 | HGDIOBJ_SPECIFIC_COLORSPACE) // DC (metafile)
#define DRIVER_COLORSPACE             (0x000004 | HGDIOBJ_SPECIFIC_COLORSPACE) // DC (source)
#define DIBSECTION_COLORSPACE         (0x000010 | HGDIOBJ_SPECIFIC_COLORSPACE) // DIBSection

#define GET_COLORSPACE_TYPE(x)  ((x) & 0x000FFF)

//
// Cached Color Transform Structure
//
typedef struct _CACHED_COLORTRANSFORM
{
    LIST_ENTRY         ListEntry;
    FLONG              flInfo;
    HDC                hdc;
    ULONG              cRef;
    HANDLE             ColorTransform;
    PCACHED_COLORSPACE SourceColorSpace;
    PCACHED_COLORSPACE DestinationColorSpace;
    PCACHED_COLORSPACE TargetColorSpace;
} CACHED_COLORTRANSFORM, *PCACHED_COLORTRANSFORM;

//
// CACHED_COLORTRANSFORM.flInfo
//
#define DEVICE_COLORTRANSFORM      0x0004
#define CACHEABLE_COLORTRANSFORM   0x0010

//
// Matafiled ICC profile
//
typedef struct _MATAFILE_COLORPROFILE
{
    LIST_ENTRY    ListEntry;
    WCHAR         ColorProfile[MAX_PATH];
} METAFILE_COLORPROFILE, *PMETAFILE_COLORPROFILE;

#define IDENT_COLORTRANSFORM  ((PCACHED_COLORTRANSFORM)-1)

//
// Saved ICMINFO for SaveDC and RestoreDC API.
//
typedef struct _SAVED_ICMINFO
{
    LIST_ENTRY             ListEntry;
    DWORD                  dwSavedDepth;      // Saved depth
    PCACHED_COLORSPACE     pSourceColorSpace; // Pointer to source profile data
    PCACHED_COLORSPACE     pDestColorSpace;   // Pointer to destination profile data
    PCACHED_COLORSPACE     pTargetColorSpace; // Pointer to target profile data
    PCACHED_COLORTRANSFORM pCXform;      // Pointer to color transform
    PCACHED_COLORTRANSFORM pBackCXform;  // Pointer to Backward color transform for GetXXX API
    PCACHED_COLORTRANSFORM pProofCXform; // Pointer to Proofing color transform for ColorMatchToTarget()
} SAVED_ICMINFO, *PSAVED_ICMINFO;

//
// ICM related info associated to DC.
//
typedef struct _GDI_ICMINFO
{
    LIST_ENTRY             ListEntry;
    HDC                    hdc;               // hdc who owns this ICM info.
    PVOID                  pvdcattr;          // pointer to dcattr
    FLONG                  flInfo;            // Flags
    PCACHED_COLORSPACE     pSourceColorSpace; // Pointer to source profile data
    PCACHED_COLORSPACE     pDestColorSpace;   // Pointer to destination profile data
    PCACHED_COLORSPACE     pTargetColorSpace; // Pointer to target profile data
    PCACHED_COLORTRANSFORM pCXform;           // Pointer to color transform
    PCACHED_COLORTRANSFORM pBackCXform;       // Pointer to Backward color transform for GetXXX API
    PCACHED_COLORTRANSFORM pProofCXform;      // Pointer to Proofing color transform for ColorMatchToTarget()
    HCOLORSPACE            hDefaultSrcColorSpace; // Handle (kernel-mode) to default source color space
    DWORD                  dwDefaultIntent;   // default intent in LOGCOLORSPACE
    LIST_ENTRY             SavedIcmInfo;      // Saved ICMINFO for SaveDC and RestoreDC API
    WCHAR                  DefaultDstProfile[MAX_PATH]; // DC's default source color profile
} GDI_ICMINFO, *PGDI_ICMINFO;

//
// GDI_ICMINFO.flInfo
//
#define ICM_VALID_DEFAULT_PROFILE    0x0001
#define ICM_VALID_CURRENT_PROFILE    0x0002
#define ICM_DELETE_SOURCE_COLORSPACE 0x0004
#define ICM_ON_ICMINFO_LIST          0x0008
#define ICM_UNDER_INITIALIZING       0x0010
#define ICM_UNDER_CHANGING           0x0020
#define ICM_IN_USE                   (ICM_UNDER_INITIALIZING|ICM_UNDER_CHANGING)

//
// PGDI_ICMINFO INIT_ICMINFO(hdc,pdcattr)
//
#define INIT_ICMINFO(hdc,pdcattr) (IcmInitIcmInfo((hdc),(pdcattr)))

//
// PGDI_ICMINFO GET_ICMINFO(PDC_ATTR)
//
#define GET_ICMINFO(pdcattr)      ((PGDI_ICMINFO)((pdcattr)->pvICM))

//
// BOOL BEXIST_ICMINFO(PDC_ATTR)
//
#define BEXIST_ICMINFO(pdcattr)   (((pdcattr)->pvICM != NULL) ? TRUE : FALSE)

//
// BOOL bNeedTranslateColor(PDC_ATTR)
//
#define bNeedTranslateColor(pdcattr)                     \
        (IS_ICM_HOST(pdcattr->lIcmMode) &&               \
         (!IS_ICM_LAZY_CORRECTION(pdcattr->lIcmMode)) && \
         (pdcattr->hcmXform != NULL))

//
// VOID IcmMarkInUseIcmInfo(PGDI_ICMINFO,BOOL)
//
#define IcmMarkInUseIcmInfo(pIcmInfo,bInUse)           \
        ENTERCRITICALSECTION(&semListIcmInfo);         \
        if ((bInUse))                                  \
            (pIcmInfo)->flInfo |= ICM_UNDER_CHANGING;  \
        else                                           \
            (pIcmInfo)->flInfo &= ~ICM_UNDER_CHANGING; \
        LEAVECRITICALSECTION(&semListIcmInfo);

//
// Functions exports from MSCMS.DLL
//

//
// HPROFILE
// OpenColorProfile(
//    PROFILE pProfile,
//    DWORD   dwDesiredAccess,
//    DWORD   dwShareMode,
//    DWORD   dwCreationMode
//    );  
//
typedef HPROFILE (FAR WINAPI * FPOPENCOLORPROFILEA)(PPROFILE, DWORD, DWORD, DWORD);
typedef HPROFILE (FAR WINAPI * FPOPENCOLORPROFILEW)(PPROFILE, DWORD, DWORD, DWORD);

//
// BOOL
// CloseColorProfile(
//     HPROFILE hProfile
//     );
//
typedef BOOL (FAR WINAPI * FPCLOSECOLORPROFILE)(HPROFILE);

//
// BOOL
// IsColorProfileValid(
//     HPROFILE hProfile
//     );
//
typedef BOOL (FAR WINAPI * FPISCOLORPROFILEVALID)(HPROFILE);

//
// BOOL
// CreateDeviceLinkProfile(
//     PHPROFILE  pahProfile,
//     DWORD      nProfiles,
//     PBYTE     *nProfileData,
//     DWORD      indexPreferredCMM
//     );
//     
typedef BOOL (FAR WINAPI * FPCREATEDEVICELINKPROFILE)(PHPROFILE, DWORD, PBYTE *, DWORD);

//
// HTRANSFORM
// CreateColorTransform(
//     LPLOGCOLORSPACE[A|W] pLogColorSpace,
//     HPROFILE             hDestProfile,
//     HPROFILE             hTargetProfile,
//     DWORD                dwFlags
//     );
//
typedef HTRANSFORM (FAR WINAPI * FPCREATECOLORTRANSFORMA)(LPLOGCOLORSPACEA, HPROFILE, HPROFILE, DWORD);
typedef HTRANSFORM (FAR WINAPI * FPCREATECOLORTRANSFORMW)(LPLOGCOLORSPACEW, HPROFILE, HPROFILE, DWORD);

//
// HTRANSFORM
// CreateMultiProfileTransform(
//     PHPROFILE phProfile,
//     DWORD     nProfiles,
//     PDWORD    padwIntent,
//     DWORD     nIntents,
//     DWORD     dwFlags,
//     DWORD     indexPreferredCMM
//     );
//
typedef HTRANSFORM (FAR WINAPI * FPCREATEMULTIPROFILETRANSFORM)(PHPROFILE, DWORD, PDWORD, DWORD, DWORD, DWORD);

//
// BOOL
// DeleteColorTransform(
//     HTRANSFORM hxform
//     );
//
typedef BOOL (FAR WINAPI * FPDELETECOLORTRANSFORM)(HTRANSFORM);

//
// BOOL
// TranslateBitmapBits(
//     HTRANSFORM    hxform,
//     PVOID         pSrcBits,
//     BMFORMAT      bmInput,
//     DWORD         dwWidth,
//     DWORD         dwHeight,
//     DWORD         dwInputStride,
//     PVOID         pDestBits,
//     BMFORMAT      bmOutput,
//     DWORD         dwOutputStride,
//     PBMCALLBACKFN pfnCallback,
//     ULONG         ulCallbackData
//     );
//
typedef BOOL (FAR WINAPI * FPTRANSLATEBITMAPBITS)(HTRANSFORM, PVOID, BMFORMAT, DWORD, DWORD, DWORD, PVOID, BMFORMAT, DWORD, PBMCALLBACKFN, ULONG);

//
// BOOL
// TranslateColors(
//     HTRANSFORM  hxform,        
//     PCOLOR      paInputColors, 
//     DWORD       nColors,       
//     COLORTYPE   ctInput,       
//     PCOLOR      paOutputColors,
//     COLORTYPE   ctOutput
//     );
//
typedef BOOL (FAR WINAPI * FPTRANSLATECOLORS)(HTRANSFORM, PCOLOR, DWORD, COLORTYPE, PCOLOR, COLORTYPE);

//
// BOOL
// CheckBitmapBits(
//     HTRANSFORM     hxform,
//     PVOID          pSrcBits,
//     BMFORMAT       bmInput,
//     DWORD          dwWidth,
//     DWORD          dwHeight,
//     DWORD          dwStride,
//     PBYTE          paResult,
//     PBMCALLBACKFN  pfnCallback,
//     ULONG          ulCallbackData
//     );
//
typedef BOOL (FAR WINAPI * FPCHECKBITMAPBITS)(HTRANSFORM , PVOID, BMFORMAT, DWORD, DWORD, DWORD, PBYTE, PBMCALLBACKFN, ULONG);

//
// BOOL
// TranslateColors(
//     HTRANSFORM  hxform,
//     PCOLOR      paInputColors,
//     DWORD       nColors,
//     COLORTYPE   ctInput,
//     PCOLOR      paOutputColors,
//     COLORTYPE   ctOutput
//     );
//
typedef BOOL (FAR WINAPI * FPTRANSLATECOLORS)(HTRANSFORM, PCOLOR, DWORD, COLORTYPE, PCOLOR, COLORTYPE);

//
// BOOL
// CheckColors(
//     HTRANSFORM      hxform,
//     PCOLOR          paInputColors,
//     DWORD           nColors,
//     COLORTYPE       ctInput,
//     PBYTE           paResult
//     );
//
typedef BOOL (FAR WINAPI * FPCHECKCOLORS)(HTRANSFORM, PCOLOR, DWORD, COLORTYPE, PBYTE);

//
// DWORD
// GetCMMInfo(
//     HTRANSFORM      hxform,
//     DWORD           dwInfo
//     );
//
typedef DWORD (FAR WINAPI * FPGETCMMINFO)(HTRANSFORM, DWORD);

//
// BOOL
// RegisterCMM(
//     PCTSTR      pMachineName,
//     DWORD       cmmID,
//     PCTSTR       pCMMdll
//     );
//
typedef BOOL (FAR WINAPI * FPREGISTERCMMA)(PCSTR, DWORD, PCSTR);
typedef BOOL (FAR WINAPI * FPREGISTERCMMW)(PCWSTR, DWORD, PCWSTR);

//
// BOOL
// UnregisterCMM(
//    PCTSTR  pMachineName,
//    DWORD   cmmID
//    );
//
typedef BOOL (FAR WINAPI * FPUNREGISTERCMMA)(PCSTR, DWORD);
typedef BOOL (FAR WINAPI * FPUNREGISTERCMMW)(PCWSTR, DWORD);

//
// BOOL
// SelectCMM(
//    DWORD   dwCMMType
//    );
//
typedef BOOL (FAR WINAPI * FPSELECTCMM)(DWORD);

//
// BOOL
// InstallColorProfile(
//    PCTSTR   pMachineName,
//    PCTSTR   pProfileName
//    );
//
typedef BOOL (FAR WINAPI * FPINSTALLCOLORPROFILEA)(PCSTR, PCSTR);
typedef BOOL (FAR WINAPI * FPINSTALLCOLORPROFILEW)(PCWSTR, PCWSTR);

//
// BOOL
// UninstallColorProfile(
//    PCTSTR  pMachineName,
//    PCTSTR  pProfileName,
//    BOOL    bDelete
//    );
//
typedef BOOL (FAR WINAPI * FPUNINSTALLCOLORPROFILEA)(PCSTR, PCSTR, BOOL);
typedef BOOL (FAR WINAPI * FPUNINSTALLCOLORPROFILEW)(PCWSTR, PCWSTR, BOOL);

//
// BOOL
// EnumColorProfiles(
//    PCTSTR          pMachineName,
//    PENUMTYPE[A|W]  pEnumRecord,
//    PBYTE           pBuffer,
//    PDWORD          pdwSize,
//    PDWORD          pnProfiles
//    );
//
typedef BOOL (FAR WINAPI * FPENUMCOLORPROFILESA)(PCSTR, PENUMTYPEA, PBYTE, PDWORD, PDWORD);
typedef BOOL (FAR WINAPI * FPENUMCOLORPROFILESW)(PCWSTR, PENUMTYPEW, PBYTE, PDWORD, PDWORD);

//
// BOOL
// GetStandardColorSpaceProfile(
//    PCTSTR          pMachineName,
//    DWORD           dwSCS,
//    PSTR            pBuffer,
//    PDWORD          pdwSize
//    );
//
typedef BOOL (FAR WINAPI * FPGETSTANDARDCOLORSPACEPROFILEA)(PCSTR, DWORD, PSTR, PDWORD);
typedef BOOL (FAR WINAPI * FPGETSTANDARDCOLORSPACEPROFILEW)(PCWSTR, DWORD, PWSTR, PDWORD);

//
// BOOL
// GetColorProfileHeader(
//    HPROFILE        hProfile,
//    PPROFILEHEADER  pProfileHeader
//    );
//
typedef BOOL (FAR WINAPI * FPGETCOLORPROFILEHEADER)(HPROFILE, PPROFILEHEADER);

//
// BOOL
// GetColorDirectory(
//    PCTSTR          pMachineName,
//    PTSTR           pBuffer,
//    PDWORD          pdwSize
//    );
typedef BOOL (FAR WINAPI * FPGETCOLORDIRECTORYA)(PCSTR, PSTR, PDWORD);
typedef BOOL (FAR WINAPI * FPGETCOLORDIRECTORYW)(PCWSTR, PWSTR, PDWORD);

//
// BOOL WINAPI CreateProfileFromLogColorSpaceA(
//    LPLOGCOLORSPACEA pLogColorSpace,
//    PBYTE            *pBuffer
//    );
//
typedef BOOL (FAR WINAPI * FPCREATEPROFILEFROMLOGCOLORSPACEA)(LPLOGCOLORSPACEA,PBYTE *);
typedef BOOL (FAR WINAPI * FPCREATEPROFILEFROMLOGCOLORSPACEW)(LPLOGCOLORSPACEW,PBYTE *);

//
// BOOL InternalGetDeviceConfig(
//    LPCTSTR pDeviceName,
//    DWORD   dwDeviceClass
//    DWORD   dwConfigType,
//    PVOID   pConfig,
//    PDWORD  pdwSize
//    );
//
typedef BOOL (FAR * FPINTERNALGETDEVICECONFIG)(LPCWSTR,DWORD,DWORD,PVOID,PDWORD);

extern HINSTANCE  ghICM;
extern BOOL       gbICMEnabledOnceBefore;

extern RTL_CRITICAL_SECTION semListIcmInfo;
extern RTL_CRITICAL_SECTION semColorTransformCache;
extern RTL_CRITICAL_SECTION semColorSpaceCache;

extern LIST_ENTRY ListIcmInfo;
extern LIST_ENTRY ListCachedColorSpace;
extern LIST_ENTRY ListCachedColorTransform;

//
// ANSI version function in MSCMS.DLL will not called.
//
// extern FPOPENCOLORPROFILEA           fpOpenColorProfileA;
// extern FPCREATECOLORTRANSFORMA       fpCreateColorTransformA;
// extern FPREGISTERCMMA                fpRegisterCMMA;
// extern FPUNREGISTERCMMA              fpUnregisterCMMA;
// extern FPINSTALLCOLORPROFILEA        fpInstallColorProfileA;
// extern FPUNINSTALLCOLORPROFILEA      fpUninstallColorProfileA;
// extern FPGETSTANDARDCOLORSPACEPROFILEA fpGetStandardColorSpaceProfileA;
// extern FPENUMCOLORPROFILESA          fpEnumColorProfilesA;
// extern FPGETCOLORDIRECTORYA          fpGetColorDirectoryA;
//
// And Following function does not used from gdi32.dll
//
// extern FPISCOLORPROFILEVALID         fpIsColorProfileValid;
// extern FPCREATEDEVICELINKPROFILE     fpCreateDeviceLinkProfile;
// extern FPTRANSLATECOLORS             fpTranslateColors;
// extern FPCHECKCOLORS                 fpCheckColors;
// extern FPGETCMMINFO                  fpGetCMMInfo;
// extern FPSELECTCMM                   fpSelectCMM;
//

extern FPOPENCOLORPROFILEW           fpOpenColorProfileW;
extern FPCLOSECOLORPROFILE           fpCloseColorProfile;
extern FPCREATECOLORTRANSFORMW       fpCreateColorTransformW;
extern FPDELETECOLORTRANSFORM        fpDeleteColorTransform;
extern FPTRANSLATECOLORS             fpTranslateColors;
extern FPTRANSLATEBITMAPBITS         fpTranslateBitmapBits;
extern FPCHECKBITMAPBITS             fpCheckBitmapBits;
extern FPREGISTERCMMW                fpRegisterCMMW;
extern FPUNREGISTERCMMW              fpUnregisterCMMW;
extern FPINSTALLCOLORPROFILEW        fpInstallColorProfileW;
extern FPUNINSTALLCOLORPROFILEW      fpUninstallColorProfileW;
extern FPENUMCOLORPROFILESW            fpEnumColorProfilesW;
extern FPGETSTANDARDCOLORSPACEPROFILEW fpGetStandardColorSpaceProfileW;
extern FPGETCOLORPROFILEHEADER       fpGetColorProfileHeader;
extern FPGETCOLORDIRECTORYW          fpGetColorDirectoryW;
extern FPCREATEPROFILEFROMLOGCOLORSPACEW fpCreateProfileFromLogColorSpaceW;
extern FPCREATEMULTIPROFILETRANSFORM fpCreateMultiProfileTransform;
extern FPINTERNALGETDEVICECONFIG     fpInternalGetDeviceConfig;

//
// Functions GDI internal use (defined in icm.c)
//

//
// Color Translation Functions
//

BOOL
IcmTranslateDIB(
    HDC          hdc,
    PDC_ATTR     pdcattr,
    ULONG        nColors,
    PVOID        pBitsIn,
    PVOID       *ppBitsOut,
    PBITMAPINFO  pbmi,
    PBITMAPINFO *pbmiNew,
    DWORD       *pcjbmiNew,
    DWORD        dwNumScan,
    UINT         iUsage,
    DWORD        dwFlags,
    PCACHED_COLORSPACE *ppBitmapColorSpace,
    PCACHED_COLORTRANSFORM *ppCXform
    );

BOOL
IcmTranslateCOLORREF(
    HDC      hdc,
    PDC_ATTR pdcattr,
    COLORREF ColorIn,
    COLORREF *ColorOut,
    DWORD    Flags
    );

BOOL
IcmTranslateBrushColor(
    HDC      hdc,
    PDC_ATTR pdcattr,
    HBRUSH   hbrush
    );

BOOL
IcmTranslatePenColor(
    HDC      hdc,
    PDC_ATTR pdcattr,
    HPEN     hpen
    );

BOOL
IcmTranslateExtPenColor(
    HDC      hdc,
    PDC_ATTR pdcattr,
    HPEN     hpen
    );

BOOL
IcmTranslateColorObjects(
    HDC      hdc,
    PDC_ATTR pdcattr,
    BOOL     bICMEnable
    );

BOOL
IcmTranslateTRIVERTEX(
    HDC         hdc,
    PDC_ATTR    pdcattr,
    PTRIVERTEX  pVertex,
    ULONG       nVertex
    );

BOOL
IcmTranslatePaletteEntry(
    HDC           hdc,
    PDC_ATTR      pdcattr,
    PALETTEENTRY *pColorIn,
    PALETTEENTRY *pColorOut,
    UINT          NumberOfEntries
    );

//
// DC related functions
//

PGDI_ICMINFO
IcmInitIcmInfo(
    HDC      hdc,
    PDC_ATTR pdcattr
    );

BOOL
IcmCleanupIcmInfo(
    PDC_ATTR     pdcattr,
    PGDI_ICMINFO pIcmInfo
    );

PGDI_ICMINFO
IcmGetUnusedIcmInfo(
    HDC hdc
    );

BOOL
IcmInitLocalDC(
    HDC             hdc,
    HANDLE          hPrinter,
    CONST DEVMODEW *pdm,
    BOOL            bReset
    );

BOOL
IcmDeleteLocalDC(
    HDC          hdc,
    PDC_ATTR     pdcattr,
    PGDI_ICMINFO pIcmInfo
    );

BOOL
IcmUpdateLocalDCColorSpace(
    HDC      hdc,
    PDC_ATTR pdcattr
    );

VOID 
IcmReleaseDCColorSpace(
    PGDI_ICMINFO pIcmInfo,
    BOOL         bReleaseDC
    );

BOOL
IcmUpdateDCColorInfo(
    HDC      hdc,
    PDC_ATTR pdcattr
    );

BOOL
IcmEnableForCompatibleDC(
    HDC      hdcCompatible,
    HDC      hdcDevice,
    PDC_ATTR pdcaDevice
    );

BOOL
IcmSaveDC(
    HDC hdc,
    PDC_ATTR pdcattr,
    PGDI_ICMINFO pIcmInfo
    );

VOID
IcmRestoreDC(
    PDC_ATTR pdcattr,
    int iLevel,
    PGDI_ICMINFO pIcmInfo
    );

//
// SelectObject functions
//

BOOL
IcmSelectColorTransform (
    HDC                    hdc,
    PDC_ATTR               pdcattr,
    PCACHED_COLORTRANSFORM pCXform,
    BOOL                   bDeviceCalibrate
    );

HBRUSH
IcmSelectBrush (
    HDC      hdc,
    PDC_ATTR pdcattr,
    HBRUSH   hbrushNew
    );

HPEN
IcmSelectPen(
    HDC      hdc,
    PDC_ATTR pdcattr,
    HPEN     hpenNew
    );

HPEN
IcmSelectExtPen(
    HDC      hdc,
    PDC_ATTR pdcattr,
    HPEN     hpenNew
    );

//
// Profile Enumuration related
//

int
IcmEnumColorProfile(
    HDC       hdc,
    PVOID     pvCallBack,
    LPARAM    lParam,
    BOOL      bAnsiCallBack,
    PDEVMODEW pDevModeW,
    DWORD    *pdwColorSpaceFlag
    );

int CALLBACK
IcmQueryProfileCallBack(
    LPWSTR lpFileName,
    LPARAM lAppData
    );

int CALLBACK
IcmFindProfileCallBack(
    LPWSTR lpFileName,
    LPARAM lAppData
    );

BOOL
IcmCreateTemporaryColorProfile(
    LPWSTR TemporaryColorProfile,
    LPBYTE ProfileData,
    DWORD  ProfileDataSize
    );

//
// Filename/Path related.
//

PWSTR
GetFileNameFromPath(
    PWSTR pwszFileName
    );

PWSZ
BuildIcmProfilePath(
    PWSZ  FileName,
    PWSZ  FullPathFileName,
    ULONG BufferSize
    );

//
// Color Transform management
//

PCACHED_COLORTRANSFORM
IcmGetFirstNonUsedColorTransform(
    VOID
);

PCACHED_COLORTRANSFORM
IcmGetColorTransform(
    HDC                hdc,
    PCACHED_COLORSPACE pSourceColorSpace,
    PCACHED_COLORSPACE pDestColorSpace,
    PCACHED_COLORSPACE pTargetColorSpace,
    BOOL               bNeedDeviceXform
    );

PCACHED_COLORTRANSFORM
IcmCreateColorTransform(
    HDC                hdc,
    PDC_ATTR           pdcattr,
    PCACHED_COLORSPACE lpOptionalColorSpace,
    DWORD              dwFlags
    );

BOOL
IcmDeleteColorTransform(
    HANDLE   hcmXformToBeDeleted,
    BOOL     bForceDelete
    );

BOOL
IcmDeleteDCColorTransforms(
    PGDI_ICMINFO pIcmInfo
    );

BOOL
IcmDeleteCachedColorTransforms(
    HDC          hdc
    );

BOOL 
IcmIsCacheable(
    PCACHED_COLORSPACE pColorSpace
);

//
// Color Space/Profile management
//

HCOLORSPACE WINAPI
CreateColorSpaceInternalW(
    LPLOGCOLORSPACEW lpLogColorSpace,
    DWORD            dwCreateFlags
    );

BOOL
SetICMProfileInternalA(
    HDC                hdc,
    LPSTR              pszFileName,
    PCACHED_COLORSPACE pColorSpace,
    DWORD              dwFlags
    );

BOOL
SetICMProfileInternalW(
    HDC                hdc,
    LPWSTR             pwszFileName,
    PCACHED_COLORSPACE pColorSpace,
    DWORD              dwFlags
    );

BOOL WINAPI
ColorMatchToTargetInternal(
    HDC                hdc,
    PCACHED_COLORSPACE pTargetColorSpace,
    DWORD              uiAction
    );

HCOLORSPACE
IcmSetSourceColorSpace(
    HDC hdc,
    HCOLORSPACE        hColorSpace,
    PCACHED_COLORSPACE pColorSpace,
    DWORD              dwFlags
    );

BOOL
IcmSetDestinationColorSpace(
    HDC                hdc,
    LPWSTR             pwszFileName,
    PCACHED_COLORSPACE pColorSpace,
    DWORD              dwFlags
    );

BOOL 
IcmSetTargetColorSpace(
    HDC                hdc,
    PCACHED_COLORSPACE pColorSpace,
    DWORD              uiAction
    );

BMFORMAT
IcmGetProfileColorFormat(
    HPROFILE hProfile
    );

BOOL
IcmCreateProfileFromLCS(
    LPLOGCOLORSPACEW  lpLogColorSpaceW,
    PVOID            *ppvProfileData,
    PULONG            pulProfileSize
    );

PCACHED_COLORSPACE
IcmCreateColorSpaceByColorSpace(
    HGDIOBJ          hObj,
    LPLOGCOLORSPACEW lpLogColorSpace,
    PPROFILE         pProfileData,
    DWORD            dwFlags
    );

PCACHED_COLORSPACE
IcmCreateColorSpaceByName(
    HGDIOBJ hObj,
    PWSZ    ColorProfileName,
    DWORD   dwIntent,
    DWORD   dwFlags
    );

PCACHED_COLORSPACE
IcmGetColorSpaceByHandle(
    HGDIOBJ          hObj,
    HCOLORSPACE      hColorSpace,
    LPLOGCOLORSPACEW lpLogColorSpace,
    DWORD            dwFlags
    );

PCACHED_COLORSPACE
IcmGetColorSpaceByColorSpace(
    HGDIOBJ          hObj,
    LPLOGCOLORSPACEW lpLogColorSpace,
    PPROFILE         pProfileData,
    DWORD            dwFlags
    );

PCACHED_COLORSPACE
IcmGetColorSpaceByName(
    HGDIOBJ hObj,
    PWSZ    ColorProfileName,
    DWORD   dwIntent,
    DWORD   dwFlags
    );

BOOL
IcmSameColorSpace(
    PCACHED_COLORSPACE pColorSpaceA,
    PCACHED_COLORSPACE pColorSapceB
    );

VOID
IcmReleaseColorSpace(
    HGDIOBJ            hObj,
    PCACHED_COLORSPACE pColorSpace,
    BOOL               bReleaseDC
    );

BOOL
IcmReleaseCachedColorSpace(
    HGDIOBJ hObj
    );

int
IcmAskDriverForColorProfile(
    PLDC       pldc,
    ULONG      ulQueryMode,
    PDEVMODEW  pDevMode,
    PWSTR      pProfileName,
    DWORD     *pdwColorSpaceFlag
);

BOOL
IcmRealizeColorProfile(
    PCACHED_COLORSPACE pColorSpace,
    BOOL               bCheckColorFormat
);

VOID
IcmUnrealizeColorProfile(
    PCACHED_COLORSPACE pColorSpace
);

//
// Metafile related
//
VOID
IcmInsertMetafileList(
    PLIST_ENTRY pAttachedColorProfile,
    PWSZ        ProfileName
    );

BOOL
IcmCheckMetafileList(
    PLIST_ENTRY pAttachedColorProfile,
    PWSZ        ProfileName
    );

VOID
IcmFreeMetafileList(
    PLIST_ENTRY pAttachedColorProfile
    );

//
// Bitmap color space
//
BOOL
IcmGetBitmapColorSpace(
    LPBITMAPINFO     pbmi,
    LPLOGCOLORSPACEW plcspw,
    PPROFILE         pProfileData,
    PDWORD           pdwFlags
    );

PCACHED_COLORSPACE
IcmGetColorSpaceforBitmap(
    HBITMAP hbm
    );

//
// Icm Blting
//
BOOL
IcmStretchBlt(HDC hdc, int x, int y, int cx, int cy,
              HDC hdcSrc, int x1, int y1, int cx1, int cy1, DWORD rop,
              PDC_ATTR pdcattr, PDC_ATTR pdcattrSrc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\icm.c ===
/******************************Module*Header*******************************\
* Module Name: icm.c
*
* Created: 4-Jun-1996
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1996-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include "winuserk.h"

#if DBG_ICM

ULONG DbgIcm = 0x0;

#endif

//
// Instance of MSCMS.DLL
//
HINSTANCE ghICM;

//
// Color Profile Directory
//
WCHAR ColorDirectory[MAX_PATH];
DWORD ColorDirectorySize;

//
// Primary display DC color profile filename.
//
WCHAR PrimaryDisplayProfile[MAX_PATH];

//
// List of ICMINFO
//
LIST_ENTRY ListIcmInfo;

//
// Semaphore to protect ICMINFO list
//
RTL_CRITICAL_SECTION semListIcmInfo;

//
// Per process color space and color transform cache list
//
LIST_ENTRY ListCachedColorSpace;
LIST_ENTRY ListCachedColorTransform;

ULONG      cCachedColorSpace = 0;
ULONG      cCachedColorTransform = 0;

//
// Semaphore to protect Cache list
//
RTL_CRITICAL_SECTION semColorTransformCache;
RTL_CRITICAL_SECTION semColorSpaceCache;

BOOL gbICMEnabledOnceBefore = FALSE;

//
// ANSI version function in MSCMS.DLL will not called.
//
// FPOPENCOLORPROFILEA           fpOpenColorProfileA;
// FPCREATECOLORTRANSFORMA       fpCreateColorTransformA;
// FPREGISTERCMMA                fpRegisterCMMA;
// FPUNREGISTERCMMA              fpUnregisterCMMA;
// FPINSTALLCOLORPROFILEA        fpInstallColorProfileA;
// FPUNINSTALLCOLORPROFILEA      fpUninstallColorProfileA;
// FPGETSTANDARDCOLORSPACEPROFILEA fpGetStandardColorSpaceProfileA;
// FPENUMCOLORPROFILESA          fpEnumColorProfilesA;
// FPGETCOLORDIRECTORYA          fpGetColorDirectoryA;
//
// And Following function does not used from gdi32.dll
//
// FPISCOLORPROFILEVALID         fpIsColorProfileValid;
// FPCREATEDEVICELINKPROFILE     fpCreateDeviceLinkProfile;
// FPTRANSLATECOLORS             fpTranslateColors;
// FPCHECKCOLORS                 fpCheckColors;
// FPGETCMMINFO                  fpGetCMMInfo;
// FPSELECTCMM                   fpSelectCMM;
//

FPOPENCOLORPROFILEW           fpOpenColorProfileW;
FPCLOSECOLORPROFILE           fpCloseColorProfile;
FPCREATECOLORTRANSFORMW       fpCreateColorTransformW;
FPDELETECOLORTRANSFORM        fpDeleteColorTransform;
FPTRANSLATEBITMAPBITS         fpTranslateBitmapBits;
FPTRANSLATECOLORS             fpTranslateColors;
FPCHECKBITMAPBITS             fpCheckBitmapBits;
FPREGISTERCMMW                fpRegisterCMMW;
FPUNREGISTERCMMW              fpUnregisterCMMW;
FPINSTALLCOLORPROFILEW        fpInstallColorProfileW;
FPUNINSTALLCOLORPROFILEW      fpUninstallColorProfileW;
FPENUMCOLORPROFILESW          fpEnumColorProfilesW;
FPGETSTANDARDCOLORSPACEPROFILEW fpGetStandardColorSpaceProfileW;
FPGETCOLORPROFILEHEADER         fpGetColorProfileHeader;
FPGETCOLORDIRECTORYW            fpGetColorDirectoryW;
FPCREATEPROFILEFROMLOGCOLORSPACEW fpCreateProfileFromLogColorSpaceW;
FPCREATEMULTIPROFILETRANSFORM fpCreateMultiProfileTransform;
FPINTERNALGETDEVICECONFIG     fpInternalGetDeviceConfig;

//
// MS COLOR MATCH DLL name
//
#define MSCMS_DLL_NAME        L"mscms.dll"

//
// Misc. macros
//
#define ALIGN_DWORD(nBytes)   (((nBytes) + 3) & ~3)

//
// sRGB color profile name
//
#define sRGB_PROFILENAME      L"sRGB Color Space Profile.icm"

//
// DWORD 0x12345678 ---> 0x78563412
//
#define IcmSwapBytes(x) ((((x) & 0xFF000000) >> 24) | (((x) & 0x00FF0000) >>  8) | \
                         (((x) & 0x0000FF00) <<  8) | (((x) & 0x000000FF) << 24))

//
// Macro to check color DC or not.
//
// LATER: We can improve performance by caching this in client, since
//        GetDeviceCaps() goes to kernel in most cases.
//
#define IsColorDeviceContext(hdcThis) \
                        (2 < (unsigned) GetDeviceCaps((hdcThis), NUMCOLORS))

//
// Macro to check the color space is GDI object dependent.
//
#define IsColorSpaceOwnedByGDIObject(pColorSpace,hGDIObj)         \
            ((pColorSpace) ?                                      \
              (((pColorSpace)->hObj == (hGDIObj)) ? TRUE : FALSE) \
               : FALSE)

//
// Macro to get current color tranform in DC.
//
#define GetColorTransformInDC(pdcattr) ((pdcattr)->hcmXform)

//
// if the color space has DEVICE_CALIBRATE_COLORSPACE flag, returns TRUE, otherwise FALSE.
//
#define bDeviceCalibrate(pColorSpace)                                                \
            ((pColorSpace) ?                                                         \
              (((pColorSpace)->flInfo & DEVICE_CALIBRATE_COLORSPACE) ? TRUE : FALSE) \
                : FALSE)

//
// Increment reference count of colorpsace/colortransform.
//

#define IcmReferenceColorSpace(pColorSpace)                 \
            if ((pColorSpace))                              \
            {                                               \
                ENTERCRITICALSECTION(&semColorSpaceCache);  \
                (pColorSpace)->cRef++;                      \
                LEAVECRITICALSECTION(&semColorSpaceCache);  \
            }

#define IcmReferenceColorTransform(pCXfrom)                     \
            if ((pCXform))                                      \
            {                                                   \
                ENTERCRITICALSECTION(&semColorTransformCache);  \
                (pCXform)->cRef++;                              \
                LEAVECRITICALSECTION(&semColorTransformCache);  \
            }

//
// Invalid color space handle
//
#define INVALID_COLORSPACE                 ((HCOLORSPACE)-1)

//
// Maximum number of cached color transform in list.
//
#define MAX_COLORTRANSFORM_CACHE           10

//
// Maximum size of "on memory profile" which be able to cache.
//
#define MAX_SIZE_OF_COLORPROFILE_TO_CACHE  (1024*3)

/******************************Public*Routine******************************\
* GDI initialization routine called from dll init
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
* History:
*
*    3-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
IcmInitialize()
{
    BOOL bStatus = TRUE;

    ICMAPI(("gdi32: IcmInitialize\n"));

    ENTERCRITICALSECTION(&semLocal);

    //
    // load MCSCM.DLL and get function addresses
    //
    if (ghICM == NULL)
    {
        HANDLE hmscms = LoadLibraryW(MSCMS_DLL_NAME);

        if (hmscms != NULL)
        {
            fpOpenColorProfileW =
                (FPOPENCOLORPROFILEW)GetProcAddress(hmscms,"OpenColorProfileW");
            fpCloseColorProfile =
                (FPCLOSECOLORPROFILE)GetProcAddress(hmscms,"CloseColorProfile");
            fpCreateColorTransformW =
                (FPCREATECOLORTRANSFORMW)GetProcAddress(hmscms,"CreateColorTransformW");
            fpDeleteColorTransform =
                (FPDELETECOLORTRANSFORM)GetProcAddress(hmscms,"DeleteColorTransform");
            fpTranslateBitmapBits =
                (FPTRANSLATEBITMAPBITS)GetProcAddress(hmscms,"TranslateBitmapBits");
            fpTranslateColors =
                (FPTRANSLATECOLORS)GetProcAddress(hmscms,"TranslateColors");
            fpCheckBitmapBits =
                (FPCHECKBITMAPBITS)GetProcAddress(hmscms,"CheckBitmapBits");
            fpRegisterCMMW =
                (FPREGISTERCMMW)GetProcAddress(hmscms,"RegisterCMMW");
            fpUnregisterCMMW =
                (FPUNREGISTERCMMW)GetProcAddress(hmscms,"UnregisterCMMW");
            fpInstallColorProfileW =
                (FPINSTALLCOLORPROFILEW)GetProcAddress(hmscms,"InstallColorProfileW");
            fpUninstallColorProfileW =
                (FPUNINSTALLCOLORPROFILEW)GetProcAddress(hmscms,"UninstallColorProfileW");
            fpEnumColorProfilesW =
                (FPENUMCOLORPROFILESW)GetProcAddress(hmscms,"EnumColorProfilesW");
            fpGetStandardColorSpaceProfileW =
                (FPGETSTANDARDCOLORSPACEPROFILEW)GetProcAddress(hmscms,"GetStandardColorSpaceProfileW");
            fpGetColorProfileHeader =
                (FPGETCOLORPROFILEHEADER)GetProcAddress(hmscms,"GetColorProfileHeader");
            fpGetColorDirectoryW =
                (FPGETCOLORDIRECTORYW)GetProcAddress(hmscms,"GetColorDirectoryW");
            fpCreateProfileFromLogColorSpaceW =
                (FPCREATEPROFILEFROMLOGCOLORSPACEW)GetProcAddress(hmscms,"CreateProfileFromLogColorSpaceW");
            fpCreateMultiProfileTransform =
                (FPCREATEMULTIPROFILETRANSFORM)GetProcAddress(hmscms,"CreateMultiProfileTransform");
            fpInternalGetDeviceConfig =
                (FPINTERNALGETDEVICECONFIG)GetProcAddress(hmscms,"InternalGetDeviceConfig");

            if ((fpOpenColorProfileW           == NULL) ||
                (fpCloseColorProfile           == NULL) ||
                (fpCreateColorTransformW       == NULL) ||
                (fpDeleteColorTransform        == NULL) ||
                (fpTranslateBitmapBits         == NULL) ||
                (fpTranslateColors             == NULL) ||
                (fpCheckBitmapBits             == NULL) ||
                (fpRegisterCMMW                == NULL) ||
                (fpUnregisterCMMW              == NULL) ||
                (fpInstallColorProfileW        == NULL) ||
                (fpUninstallColorProfileW      == NULL) ||
                (fpEnumColorProfilesW          == NULL) ||
                (fpGetStandardColorSpaceProfileW == NULL) ||
                (fpGetColorProfileHeader       == NULL) ||
                (fpGetColorDirectoryW          == NULL) ||
                (fpCreateProfileFromLogColorSpaceW == NULL) ||
                (fpCreateMultiProfileTransform == NULL) ||
                (fpInternalGetDeviceConfig     == NULL)
               )
            {
                WARNING("LoadLibrary of mscms.dll failed to associate all proc addresses\n");
                FreeLibrary(hmscms);
                hmscms = NULL;
            }
            else
            {
                //
                // Initialize Color Directory
                //
                ColorDirectorySize = sizeof(ColorDirectory) / sizeof(WCHAR);

                bStatus = (*fpGetColorDirectoryW)(NULL,ColorDirectory,&ColorDirectorySize);

                if (bStatus)
                {
                    ColorDirectorySize = wcslen(ColorDirectory);
                }

                if (bStatus && ColorDirectorySize)
                {
                    ICMMSG(("IcmInitialize():ColorDirectory = %ws\n",ColorDirectory));

                    //
                    // Counts null-terminated char.
                    //
                    ColorDirectorySize += 1;

                    //
                    // Initialize Primary display color profile.
                    //
                    PrimaryDisplayProfile[0] = UNICODE_NULL;
                }
                else
                {
                    WARNING("LoadLibrary of mscms.dll failed to obtain color directory\n");
                    FreeLibrary(hmscms);
                    hmscms = NULL;
                }
            }

            //
            // Keep the handle to global veriable.
            //
            ghICM = hmscms;
        }
    }

    LEAVECRITICALSECTION(&semLocal);

    if (ghICM == NULL)
    {
        GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        bStatus = FALSE;
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
*
* SetIcmMode - turn ICM on or off in a DC
*
* Arguments:
*
*   hdc - device context
*   mode - ICM_ON,ICM_OFF,ICM_QUERY
*
* Return Value:
*
*   status
*
* History:
*
* Rewrite it:
*   20-Jan-1997 -by- Hideyuki Nagase [hideyukn]
* Write it:
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

int META WINAPI
SetICMMode(
    HDC       hdc,
    int       mode
    )
{
    int      iRet = (int)FALSE;
    PDC_ATTR pdcattr;

    ICMAPI(("gdi32: SetICMMode\n"));

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    //
    // metafile (only for ICM_ON and ICM_OFF)
    //
    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        //
        // No ICM with Windows MetaFile.
        //
        if (IS_METADC16_TYPE(hdc))
            return(iRet);

        DC_PLDC(hdc,pldc,iRet)

        #if DBG_ICM
            ICMMSG(("SetICMMode():%s ICM for %s\n", \
                    ((mode == ICM_ON) ? "Enable" : \
                     ((mode == ICM_OFF) ? "Disable" : "Query")), \
                    ((pldc->iType == LO_METADC) ? "Enhanced Metafile" :   \
                     (!IsColorDeviceContext(hdc) ? "Monochrome Printer" : "Color Printer")) \
                  ));
        #endif

        //
        // If this is Enhanced Metafile, OR non-color printer device, don't enable ICM "really".
        //
        if (pldc->iType == LO_METADC || (!IsColorDeviceContext(hdc)))
        {
            switch (mode)
            {
            case ICM_ON:
            case ICM_OFF:
            case ICM_DONE_OUTSIDEDC:

                //
                // Record ICM ON/OFF only to metafile.
                //
                if (pldc->iType == LO_METADC)
                {
                    if (!MF_SetD(hdc,(DWORD)mode,EMR_SETICMMODE))
                    {
                        return((int)FALSE);
                    }
                }

                //
                // We don't "really" turn-on ICM for metafile, metafile
                // should be device-independent, thus, non-ICMed color/images
                // will be metafiled. But still need to keep its status for ICM_QUERY.
                // And "real" image correction happen at play-back time.
                //
                if(pdcattr)
                {
                    if (mode == ICM_ON)
                    {
                        pdcattr->lIcmMode |= DC_ICM_METAFILING_ON;
                    }
                    else if (mode == ICM_DONE_OUTSIDEDC)
                    {
                        pdcattr->lIcmMode |= (DC_ICM_METAFILING_ON |
                                              CTX_ICM_METAFILING_OUTSIDEDC);
                    }
                    else // if ((mode == ICM_OFF)
                    {
                        pdcattr->lIcmMode &= ~(DC_ICM_METAFILING_ON |
                                               CTX_ICM_METAFILING_OUTSIDEDC);
                    }
                    iRet = (int)TRUE;
                }
                break;

            case ICM_QUERY:

                if (pdcattr)
                {
                    if (IS_ICM_METAFILING_ON(pdcattr->lIcmMode))
                    {
                        iRet = ((pdcattr->lIcmMode & CTX_ICM_METAFILING_OUTSIDEDC) ? \
                                ICM_DONE_OUTSIDEDC : ICM_ON);
                    }
                    else
                    {
                        iRet = ICM_OFF;
                    }
                }
                break;

            default:
                iRet = (int)FALSE;
                break;
            }

            return (iRet);
        }
    }

    if (pdcattr)
    {
        ULONG        iPrevMode;

        //
        // Before change ICM mode, we need to flush batched gdi functions.
        //
        CHECK_AND_FLUSH(hdc,pdcattr);

        //
        // Get current mode.
        //
        iPrevMode = pdcattr->lIcmMode;

        //
        // validate input parameter
        //
        switch (ICM_MODE(mode))
        {
        case ICM_QUERY:

            //
            // return current mode
            //
            if (IS_ICM_INSIDEDC(iPrevMode))
            {
                iRet = ICM_ON;
            }
            else if (IS_ICM_OUTSIDEDC(iPrevMode))
            {
                iRet = ICM_DONE_OUTSIDEDC;
            }
            else
            {
                iRet = ICM_OFF;
            }

            break;

        case ICM_ON:

            if (!IS_ICM_INSIDEDC(iPrevMode))
            {
                //
                // As default, ICM will be done on HOST.
                //
                ULONG lReqMode = REQ_ICM_HOST;

                PGDI_ICMINFO pIcmInfo = INIT_ICMINFO(hdc,pdcattr);

                //
                // Initialize ICMINFO
                //
                if (pIcmInfo == NULL)
                {
                    WARNING("gdi32: SetICMMode: Can't init icm info\n");
                    return((int)FALSE);
                }

                //
                // Load external ICM dlls.
                //
                LOAD_ICMDLL((int)FALSE);

                //
                // ICM is not enabled,yet. Let's enable ICM.
                //
                ASSERTGDI(GetColorTransformInDC(pdcattr) == NULL,"SetIcmMode: hcmXform is not NULL\n");

                if (IS_DEVICE_ICM_DEVMODE(iPrevMode))
                {
                    ICMMSG(("SetIcmMode: Device ICM is requested\n"));

                    //
                    // if ICM on Device was requested by CreateDC(), let force do
                    // ICM on device, if possible.
                    //
                    lReqMode = REQ_ICM_DEVICE;
                }
                else
                {
                    ICMMSG(("SetIcmMode: Host ICM is requested\n"));
                }

                //
                // Turn ICM on for this DC.
                //
                if (!NtGdiSetIcmMode(hdc,ICM_SET_MODE,lReqMode))
                {
                    //
                    // something wrong... we are fail to enable ICM.
                    //
                    iRet = (int)FALSE;
                    break;
                }

                //
                // If we have cached transform and it is not dirty, we can use that.
                //
                if ((pIcmInfo->pCXform == NULL) || (pdcattr->ulDirty_ & DIRTY_COLORTRANSFORM))
                {
                    if (IcmUpdateDCColorInfo(hdc,pdcattr))
                    {
                        //
                        // Mark this process has experience about ICM ON.
                        //
                        gbICMEnabledOnceBefore = TRUE;
                        iRet = (int)TRUE;
                    }
                    else
                    {
                        WARNING("SetIcmMode():IcmUpdateDCInfo failed\n");

                        //
                        // Fail to create new transform
                        //
                        NtGdiSetIcmMode(hdc,ICM_SET_MODE,REQ_ICM_OFF);
                        iRet = (int)FALSE;
                    }
                }
                else
                {
                    ICMMSG(("SetIcmMode: Use cached Color Transform\n"));

                    //
                    // Use cached transform, because since last time when we disabled ICM,
                    // NO profile(s) and logical color space has been changed.
                    //
                    if (IcmSelectColorTransform(
                            hdc,pdcattr,pIcmInfo->pCXform,
                            bDeviceCalibrate(pIcmInfo->pCXform->DestinationColorSpace)))
                    {
                        //
                        // Translate all DC objects to ICM colors. Must
                        // force brush/pens to be re-realized when used next
                        //
                        IcmTranslateColorObjects(hdc,pdcattr,TRUE);
                        iRet = (int)TRUE;
                    }
                    else
                    {
                        //
                        // Fail to select cached transform to the DC.
                        //
                        NtGdiSetIcmMode(hdc,ICM_SET_MODE,REQ_ICM_OFF);
                        iRet = (int)FALSE;
                    }
                }
            }
            else
            {
                ICMMSG(("SetIcmMode: ICM has been enabled already\n"));
                iRet = (int)TRUE;
            }

            break;

        case ICM_DONE_OUTSIDEDC:

            if (!IS_ICM_OUTSIDEDC(iPrevMode))
            {
                //
                // if inside-DC ICM is enabled, turned off it.
                //
                if (IS_ICM_INSIDEDC(iPrevMode))
                {
                    //
                    // Invalidate current color tansform (but the cache in ICMINFO is still valid).
                    //
                    IcmSelectColorTransform(hdc,pdcattr,NULL,FALSE);

                    //
                    // Restore color data for ICM disable.
                    //
                    IcmTranslateColorObjects(hdc,pdcattr,FALSE);
                }

                //
                // Tell the kernel to disable color adjustment during halftone.
                //
                NtGdiSetIcmMode(hdc,ICM_SET_MODE,REQ_ICM_OUTSIDEDC);
            }
            else
            {
                ICMMSG(("SetIcmMode: OutsideDC ICM has been enabled already\n"));
            }

            iRet = (int)TRUE;
            break;

        case ICM_OFF:

            //
            // Is there any kind of ICM is enabled ?
            //
            if (IS_ICM_ON(iPrevMode))
            {
                if (IS_ICM_INSIDEDC(iPrevMode))
                {
                    //
                    // Invalidate current color tansform (but the cache in ICMINFO is still valid).
                    //
                    IcmSelectColorTransform(hdc,pdcattr,NULL,TRUE);

                    //
                    // Restore color data for ICM disable.
                    //
                    IcmTranslateColorObjects(hdc,pdcattr,FALSE);
                }

                //
                // Tell the kernel to disable ICM.
                //
                NtGdiSetIcmMode(hdc,ICM_SET_MODE,REQ_ICM_OFF);
            }
            else
            {
                ICMMSG(("SetIcmMode: ICM has been disabled already\n"));
            }

            iRet = (int)TRUE;
            break;

        default:

            GdiSetLastError(ERROR_INVALID_PARAMETER);
            iRet = (int)FALSE;
            break;
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        iRet = (int)FALSE;
    }

    return((int)iRet);
}

/******************************Public*Routine******************************\
* CreateColorSpaceA
*
* Arguments:
*
*   lpLogColorSpace - apps log color space
*
* Return Value:
*
*   handle of color space or NULL
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

HCOLORSPACE WINAPI
CreateColorSpaceA(
    LPLOGCOLORSPACEA lpLogColorSpace
    )
{
    HCOLORSPACE    hRet;
    LOGCOLORSPACEW LogColorSpaceW;

    ICMAPI(("gdi32: CreateColorSpaceA\n"));

    if (lpLogColorSpace == NULL)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    //
    // convert ascii to long character version
    //
    if ((lpLogColorSpace->lcsSignature != LCS_SIGNATURE)    ||
        (lpLogColorSpace->lcsVersion   != 0x400)            ||
        (lpLogColorSpace->lcsSize      != sizeof(LOGCOLORSPACEA)))
    {
        ICMWRN(("CreateColorSpaceA: Incorrect signature,version or size \n"));
        GdiSetLastError(ERROR_INVALID_COLORSPACE);
        return(NULL);
    }

    RtlZeroMemory(&LogColorSpaceW,sizeof(LOGCOLORSPACEW));

    LogColorSpaceW.lcsSignature   = lpLogColorSpace->lcsSignature;
    LogColorSpaceW.lcsVersion     = lpLogColorSpace->lcsVersion;
    LogColorSpaceW.lcsCSType      = lpLogColorSpace->lcsCSType;
    LogColorSpaceW.lcsIntent      = lpLogColorSpace->lcsIntent;
    LogColorSpaceW.lcsEndpoints   = lpLogColorSpace->lcsEndpoints;
    LogColorSpaceW.lcsGammaRed    = lpLogColorSpace->lcsGammaRed;
    LogColorSpaceW.lcsGammaGreen  = lpLogColorSpace->lcsGammaGreen;
    LogColorSpaceW.lcsGammaBlue   = lpLogColorSpace->lcsGammaBlue;

    LogColorSpaceW.lcsSize        = sizeof(LOGCOLORSPACEW);

    vToUnicodeN(
                LogColorSpaceW.lcsFilename,MAX_PATH,
                lpLogColorSpace->lcsFilename,strlen(lpLogColorSpace->lcsFilename)+1
               );

    hRet = CreateColorSpaceInternalW(&LogColorSpaceW,LCSEX_ANSICREATED);

    return(hRet);
}

/******************************Public*Routine******************************\
* CreateColorSpaceW
*
*   ColorSpace is a KERNEL mode object
*
* Arguments:
*
*   lpLogColorSpace - apps log color space
*
* Return Value:
*
*   Handle of color space or NULL
*
* History:
*
*   18-Apr-1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

HCOLORSPACE WINAPI
CreateColorSpaceW(
    LPLOGCOLORSPACEW lpLogColorSpace
    )
{
    return (CreateColorSpaceInternalW(lpLogColorSpace,0));
}

HCOLORSPACE WINAPI
CreateColorSpaceInternalW(
    LPLOGCOLORSPACEW lpLogColorSpace,
    DWORD            dwCreateFlags
    )
{
    HCOLORSPACE      hRet = NULL;
    LOGCOLORSPACEEXW LogColorSpaceExOnStack;

    ICMAPI(("gdi32: CreateColorSpaceW\n"));

    if (lpLogColorSpace == NULL)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    //
    // validate color space
    //
    if ((lpLogColorSpace->lcsSignature != LCS_SIGNATURE) ||
        (lpLogColorSpace->lcsVersion   != 0x400)         ||
        (lpLogColorSpace->lcsSize      != sizeof(LOGCOLORSPACEW)))
    {
        goto InvalidColorSpaceW;
    }

    //
    // validate lcsIntent
    //
    if ((lpLogColorSpace->lcsIntent != LCS_GM_BUSINESS) &&
        (lpLogColorSpace->lcsIntent != LCS_GM_GRAPHICS) &&
        (lpLogColorSpace->lcsIntent != LCS_GM_IMAGES)   &&
        (lpLogColorSpace->lcsIntent != LCS_GM_ABS_COLORIMETRIC))
    {
        goto InvalidColorSpaceW;
    }

    //
    // We can not modify apps LOGCOLORSPACEW, so that make a copy on stack.
    //
    LogColorSpaceExOnStack.lcsColorSpace = *lpLogColorSpace;
    LogColorSpaceExOnStack.dwFlags       = dwCreateFlags;

    //
    // validate lcsCSTYPE
    //
    if ((lpLogColorSpace->lcsCSType == LCS_CALIBRATED_RGB) ||
        (lpLogColorSpace->lcsCSType == PROFILE_LINKED))
    {
        //
        // Replace CSType in case PROFILE_LINKED.
        //
        LogColorSpaceExOnStack.lcsColorSpace.lcsCSType = LCS_CALIBRATED_RGB;

        if (lpLogColorSpace->lcsFilename[0] != L'\0')
        {
            HANDLE hFile;

            //
            // Normalize profile filename. but we will not over-write app's
            // path with our normalized path.
            //
            BuildIcmProfilePath(lpLogColorSpace->lcsFilename,
                                LogColorSpaceExOnStack.lcsColorSpace.lcsFilename,
                                MAX_PATH);

            //
            // profile name given, verify it exists
            //
            hFile = CreateFileW(
                        LogColorSpaceExOnStack.lcsColorSpace.lcsFilename,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

            if (hFile != INVALID_HANDLE_VALUE)
            {
                //
                // Yes, file is really exits.
                //
                CloseHandle(hFile);
            }
            else
            {
                ICMWRN(("CreateColorSpaceW: Couldn't open file specified by lcsFilename\n"));
                GdiSetLastError(ERROR_PROFILE_NOT_FOUND);
                return(NULL);
            }
        }
    }
    else // any other CSType
    {
        ULONG ulSize = MAX_PATH;

        //
        // Load external ICM dlls.
        //
        LOAD_ICMDLL(NULL);

        //
        // if CSType is not LCS_CALIBRATED_RGB, we should go to MSCMS.DLL to get color profile
        // for corresponding LCSType, then any given profile name from application is IGNORED.
        //
        if (!(*fpGetStandardColorSpaceProfileW)(
                   NULL, lpLogColorSpace->lcsCSType,
                   LogColorSpaceExOnStack.lcsColorSpace.lcsFilename, &ulSize))
        {
            ICMWRN(("CreateColorSpaceW:Error CSType = %x\n",lpLogColorSpace->lcsCSType));
            goto InvalidColorSpaceW;
        }
    }

    //
    // Call kernel to create this colorspace.
    //
    hRet = NtGdiCreateColorSpace(&LogColorSpaceExOnStack);

    return(hRet);

InvalidColorSpaceW:

    ICMWRN(("CreateColorSpaceW: Incorrect ColorSpace parameter\n"));
    GdiSetLastError(ERROR_INVALID_COLORSPACE);
    return(NULL);
}

/******************************Public*Routine******************************\
* DeleteColorSpace - delete user object
*
* Arguments:
*
*   hColorSpace - color space handle
*
* Return Value:
*
*   status
*
* History:
*
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL WINAPI
DeleteColorSpace(
    HCOLORSPACE hColorSpace
    )
{
    ICMAPI(("gdi32: DeleteColorSpace\n"));

    FIXUP_HANDLE(hColorSpace);

    //
    // validate handle, delete
    //
    return (NtGdiDeleteColorSpace(hColorSpace));
}

/******************************Public*Routine******************************\
* SetColorSpace - set logical color space into DC, force new xform to be
* created and all objects re-realized
*
* Arguments:
*
*   hdc         - dc handle
*   hColorSpace - logical color space  handle
*
* Return Value:
*
*   Status
*
* History:
*
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

HCOLORSPACE META WINAPI
SetColorSpace(
    HDC             hdc,
    HCOLORSPACE     hColorSpace
    )
{
    HANDLE   hRet = NULL;

    ICMAPI(("gdi32: SetColorSpace\n"));

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hColorSpace);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(hRet);

        DC_PLDC(hdc,pldc,hRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SelectAnyObject(hdc,(HANDLE)hColorSpace,EMR_SETCOLORSPACE))
                return(hRet);
        }
    }

    //
    // Update source color space
    //
    hRet = IcmSetSourceColorSpace(hdc,hColorSpace,NULL,0);

    return(hRet);
}

/******************************Public*Routine******************************\
* GetColorSpace - return color space from DC
*
* Arguments:
*
*   hdc
*
* Return Value:
*
*   hColorSpace or NULL
*
* History:
*
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

HCOLORSPACE WINAPI
GetColorSpace(
    HDC hdc
    )
{
    HANDLE      hRet = NULL;
    PDC_ATTR    pdcattr;

    ICMAPI(("gdi32: GetColorSpace\n"));

    FIXUP_HANDLE(hdc);

    //
    // validate and access hdc
    //
    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        //
        // get hColorSpace
        //
        hRet = (HANDLE)pdcattr->hColorSpace;
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(hRet);
}

/******************************Public*Routine******************************\
*   GetLogColorSpaceA - get colorspace and convert to ASCII
*
*   typedef struct tagLOGCOLORSPACEW {
*       DWORD lcsSignature;
*       DWORD lcsVersion;
*       DWORD lcsSize;
*       LCSCSTYPE lcsCSType;
*       LCSGAMUTMATCH lcsIntent;
*       CIEXYZTRIPLE lcsEndpoints;
*       DWORD lcsGammaRed;
*       DWORD lcsGammaGreen;
*       DWORD lcsGammaBlue;
*       WCHAR  lcsFilename[MAX_PATH];
*   } LOGCOLORSPACEW, *LPLOGCOLORSPACEW;
*
* Arguments:
*
*   hColorSpace - handle to color space
*   lpBuffer    - buffer to hold logcolorspace
*   nSize       - buffer size
*
* Return Value:
*
*   status
*
* History:
*
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL WINAPI
GetLogColorSpaceA(
    HCOLORSPACE         hColorSpace,
    LPLOGCOLORSPACEA    lpBuffer,
    DWORD               nSize
    )
{
    BOOL            bRet = FALSE;
    LOGCOLORSPACEW  LogColorSpaceW;

    ICMAPI(("gdi32: GetLogColorSpaceA\n"));

    if ((lpBuffer != NULL) && (nSize >= sizeof(LOGCOLORSPACEA)))
    {
        //
        // get info using W version
        //
        bRet = GetLogColorSpaceW(hColorSpace,&LogColorSpaceW,sizeof(LOGCOLORSPACEW));

        if (bRet)
        {
            //
            // copy to user buffer
            //
            lpBuffer->lcsSignature  = LogColorSpaceW.lcsSignature;
            lpBuffer->lcsVersion    = LogColorSpaceW.lcsVersion;
            lpBuffer->lcsSize       = sizeof(LOGCOLORSPACEA);
            lpBuffer->lcsCSType     = LogColorSpaceW.lcsCSType;
            lpBuffer->lcsIntent     = LogColorSpaceW.lcsIntent;
            lpBuffer->lcsEndpoints  = LogColorSpaceW.lcsEndpoints;
            lpBuffer->lcsGammaRed   = LogColorSpaceW.lcsGammaRed;
            lpBuffer->lcsGammaGreen = LogColorSpaceW.lcsGammaGreen;
            lpBuffer->lcsGammaBlue  = LogColorSpaceW.lcsGammaBlue;

            //
            // convert W to A
            //
            bRet = bToASCII_N(lpBuffer->lcsFilename,
                              MAX_PATH,
                              LogColorSpaceW.lcsFilename,
                              wcslen(LogColorSpaceW.lcsFilename)+1);
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GetLogColorSpaceW - return logical color space info.
*
* Arguments:
*
*   hColorSpace - handle to color space
*   lpBuffer    - buffer to hold logcolorspace
*   nSize       - buffer size
*
* Return Value:
*
*   status
*
* History:
*
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL WINAPI
GetLogColorSpaceW(
    HCOLORSPACE         hColorSpace,
    LPLOGCOLORSPACEW    lpBuffer,
    DWORD               nSize
    )
{
    BOOL bRet = FALSE;

    ICMAPI(("gdi32: GetLogColorSpaceW\n"));

    if ((lpBuffer != NULL) && (nSize >= sizeof(LOGCOLORSPACEW)))
    {
        FIXUP_HANDLE(hColorSpace);

        //
        // Call kernel to get contents
        //
        if (NtGdiExtGetObjectW(hColorSpace,sizeof(LOGCOLORSPACEW),lpBuffer)
                                                    == sizeof(LOGCOLORSPACEW))
        {
            //
            // Only for stock color space object.
            //
            if ((hColorSpace == GetStockObject(PRIV_STOCK_COLORSPACE)) &&
                (lpBuffer->lcsCSType != LCS_CALIBRATED_RGB))
            {
                ULONG ulSize = MAX_PATH;

                //
                // Load ICM DLL.
                //
                LOAD_ICMDLL(FALSE);

                //
                // Get corresponding profile name from CSType.
                //
                if (!(*fpGetStandardColorSpaceProfileW)(
                         NULL,
                         lpBuffer->lcsCSType,
                         lpBuffer->lcsFilename,
                         &ulSize))
                {
                    ICMMSG(("GetLogColorSpaceW():Fail to SCS(%x), leave it as is\n",
                                                                lpBuffer->lcsCSType));
                }
            }

            bRet = TRUE;
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* CheckColorsInGamut
*
* Arguments:
*
*  hdc        - DC
*  lpRGBQuad  - Buffer of colors to check
*  dlpBuffer  - result buffer
*  nCount     - number of colors
*
* Return Value:
*
*   status
*
* History:
*
* Rewrite it:
*   26-Jan-1997 -by- Hideyuki Nagase [hideyukn]
* Write it:
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL WINAPI
CheckColorsInGamut(
    HDC             hdc,
    LPVOID          lpRGBTriple,
    LPVOID          dlpBuffer,
    DWORD           nCount
    )
{
    BOOL     bRet = FALSE;
    PDC_ATTR pdcattr;

    ICMAPI(("gdi32: CheckColorsInGamut\n"));

    FIXUP_HANDLE(hdc);

    //
    // Check parameter
    //
    if ((lpRGBTriple == NULL) || (dlpBuffer == NULL) || (nCount == 0))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    // validate and access hdc
    //
    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        if (IS_ICM_HOST(pdcattr->lIcmMode) ||
            IS_ICM_DEVICE(pdcattr->lIcmMode))
        {
            ASSERTGDI(ghICM,"CheckColorsInGamut(): mscms.dll is not loaded\n");

            if (GetColorTransformInDC(pdcattr))
            {
                //
                // The input buffer may not be DWORD-aligned, And it buffer size
                // might be exactly nCount * sizeof(RGBTRIPLE).
                // So that, allocate DWORD-aligned buffer here.
                //
                PVOID pvBuf = LOCALALLOC(ALIGN_DWORD(nCount*sizeof(RGBTRIPLE)));

                if (!pvBuf)
                {
                    GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return (FALSE);
                }

                //
                // Make a copy, here
                //
                RtlZeroMemory(pvBuf,ALIGN_DWORD(nCount*sizeof(RGBTRIPLE)));
                RtlCopyMemory(pvBuf,lpRGBTriple,nCount*sizeof(RGBTRIPLE));

                if (IS_ICM_HOST(pdcattr->lIcmMode))
                {
                    //
                    // we handle RGBTRIPLE array as nCount x 1 pixel bitmap.
                    //
                    bRet = (*fpCheckBitmapBits)(
                               (HANDLE)GetColorTransformInDC(pdcattr),
                               pvBuf,
                               BM_RGBTRIPLETS,
                               nCount,1,
                               ALIGN_DWORD(nCount*sizeof(RGBTRIPLE)),
                               dlpBuffer,
                               NULL,0);
                }
                else // if (IS_ICM_DEVICE(pdcattr->lIcmMode))
                {
                    //
                    // Call device driver via kernel.
                    //
                    bRet = NtGdiCheckBitmapBits(
                               hdc,
                               (HANDLE)GetColorTransformInDC(pdcattr),
                               (PVOID)lpRGBTriple,
                               (ULONG)BM_RGBTRIPLETS,
                               nCount,1,
                               ALIGN_DWORD(nCount*sizeof(RGBTRIPLE)),
                               dlpBuffer);
                }

                LOCALFREE(pvBuf);
            }
            else
            {
                //
                // There is no valid color transform,
                // so it is assume ident. color transform,
                // then that every color in the gamut.
                //
                RtlZeroMemory(dlpBuffer,nCount);
                bRet = TRUE;
            }
        }
        else
        {
            WARNING("CheckColorsInGamut():ICM mode is invalid\n");
            GdiSetLastError(ERROR_ICM_NOT_ENABLED);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* ColorMatchToTarget
*
* Arguments:
*
*   hdc,
*   hdcTarget
*   uiAction
*
* Return Value:
*
*   status
*
* History:
*
* Rewrite it:
*   26-Jan-1997 -by- Hideyuki Nagase [hideyukn]
* Write it:
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL META WINAPI
ColorMatchToTarget(
    HDC   hdc,
    HDC   hdcTarget,
    DWORD uiAction
    )
{
    BOOL     bRet = FALSE;
    PDC_ATTR pdcattrTarget;

    ICMAPI(("gdi32: ColorMatchToTarget\n"));

    FIXUP_HANDLE(hdcTarget);

    //
    // Verify Target DC. No ICM with Windows MetaFile.
    //
    if (IS_METADC16_TYPE(hdcTarget))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    PSHARED_GET_VALIDATE(pdcattrTarget,hdcTarget,DC_TYPE);

    if (pdcattrTarget != NULL)
    {
        PCACHED_COLORSPACE pTargetColorSpace = NULL;

        PLDC pldcTarget = (PLDC)(pdcattrTarget->pvLDC);

        if (!IS_ICM_INSIDEDC(pdcattrTarget->lIcmMode))
        {
            GdiSetLastError(ERROR_ICM_NOT_ENABLED);
            return (FALSE);
        }

        //
        // No Enhanced metafile DC as target DC.
        //
        if (pldcTarget && pldcTarget->iType == LO_METADC)
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return(bRet);
        }

        //
        // ICMINFO should be exist.
        //
        if (!BEXIST_ICMINFO(pdcattrTarget))
        {
            GdiSetLastError(ERROR_ICM_NOT_ENABLED);
            return(bRet);
        }

        if (uiAction == CS_ENABLE)
        {
            //
            // Hold critical section for color space to make sure pTargetColorSpace won't be deleted
            //
            ENTERCRITICALSECTION(&semColorSpaceCache);

            //
            // Target DC has LDC and ICMINFO, pick up colorspace data from there.
            //
            pTargetColorSpace = ((PGDI_ICMINFO)(pdcattrTarget->pvICM))->pDestColorSpace;

            //
            // Select it to target. the ref count of pTargetColorSpace will be incremented
            // if we suceed to select.
            //
            bRet = ColorMatchToTargetInternal(hdc,pTargetColorSpace,uiAction);

            LEAVECRITICALSECTION(&semColorSpaceCache);
        }
        else
        {
            bRet = ColorMatchToTargetInternal(hdc,NULL,uiAction);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return (bRet);
}

BOOL WINAPI
ColorMatchToTargetInternal(
    HDC                hdc,
    PCACHED_COLORSPACE pTargetColorSpace,
    DWORD              uiAction
    )
{
    BOOL     bRet = FALSE;
    BOOL     bEhnMetafile = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    //
    // Verify destination DC. No ICM with Windows MetaFile.
    //
    if (IS_METADC16_TYPE(hdc))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr != NULL)
    {
        PLDC pldc = (PLDC)(pdcattr->pvLDC);

        //
        // Check ICM is enabled on hdc properly.
        //
        if (pldc && (pldc->iType == LO_METADC))
        {
            //
            // ICM should be turned on "fakely" on metafile hdc
            //
            if (!IS_ICM_METAFILING_ON(pdcattr->lIcmMode))
            {
                GdiSetLastError(ERROR_ICM_NOT_ENABLED);
                return (FALSE);
            }

            //
            // Mark we are recording into Enhanced metafile.
            //
            bEhnMetafile = TRUE;
        }
        else
        {
            if (!IS_ICM_INSIDEDC(pdcattr->lIcmMode))
            {
                GdiSetLastError(ERROR_ICM_NOT_ENABLED);
                return (FALSE);
            }
        }

        switch (uiAction)
        {
        case CS_ENABLE:

            //
            // Fail, if we are in proofing mode, already.
            //
            if (!IS_ICM_PROOFING(pdcattr->lIcmMode))
            {
                if (pTargetColorSpace)
                {
                    if (bEhnMetafile)
                    {
                        //
                        // Set the data to metafile.
                        //
                        bRet = MF_ColorMatchToTarget(
                                    hdc, uiAction,
                                    (PVOID) pTargetColorSpace,
                                    EMR_COLORMATCHTOTARGETW);
                    }
                    else
                    {
                        //
                        // Set Target color space.
                        //
                        // (this increments ref count of pTargetColorSpace)
                        //
                        bRet = IcmSetTargetColorSpace(hdc,pTargetColorSpace,uiAction);
                    }
                }
            }
            else
            {
                WARNING("ColorMatchToTargetInternal(): DC is proofing mode already\n");
                GdiSetLastError(ERROR_INVALID_PARAMETER);
            }

            break;

        case CS_DISABLE:
        case CS_DELETE_TRANSFORM:

            if (IS_ICM_PROOFING(pdcattr->lIcmMode))
            {
                if (bEhnMetafile)
                {
                    //
                    // Set the data to metafile.
                    //
                    bRet = MF_ColorMatchToTarget(
                                   hdc, uiAction, NULL,
                                   EMR_COLORMATCHTOTARGETW);
                }
                else
                {
                    //
                    // Reset Target color space
                    //
                    bRet = IcmSetTargetColorSpace(hdc,NULL,uiAction);
                }
            }
            else
            {
                //
                // we are not in proofing mode, never called with CS_ENABLE before.
                //
                WARNING("ColorMatchToTarget: DC is not proofing mode\n");
                GdiSetLastError(ERROR_INVALID_PARAMETER);
            }

            break;

        default:

            WARNING("ColorMatchToTarget: uiAction is invalid\n");
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        WARNING("ColorMatchToTarget: invalid DC\n");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GetICMProfileA - get current profile from DC
*
* Arguments:
*
*   hdc       - DC
*   szBuffer  - size of buffer
*   pBuffer   - user buffer
*
* Return Value:
*
*   status
*
* History:
*
* Rewrite it:
*   05-Feb-1996 -by- Hideyuki Nagase [hideyukn]
* Write it:
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL WINAPI
GetICMProfileA(
    HDC     hdc,
    LPDWORD pBufSize,
    LPSTR   pszFilename
    )
{
    BOOL      bRet = FALSE;
    WCHAR     wchProfile[MAX_PATH];
    DWORD     BufSizeW = MAX_PATH;

    ICMAPI(("gdi32: GetICMProfileA\n"));

    if (pBufSize == NULL)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Call W version.
    //
    if (GetICMProfileW(hdc,&BufSizeW,wchProfile))
    {
        CHAR  chProfile[MAX_PATH];
        DWORD BufSizeA = MAX_PATH;

        if (BufSizeW)
        {
            //
            // Unicode to Ansi convertion
            //
            BufSizeA = WideCharToMultiByte(CP_ACP,0,
                                           wchProfile,BufSizeW,
                                           chProfile,BufSizeA,
                                           NULL,NULL);

            if ((pszFilename == NULL) || (*pBufSize < BufSizeA))
            {
                //
                // if the buffer is not given or not enough, return nessesary buffer size and error.
                //
                *pBufSize = BufSizeA;
                GdiSetLastError(ERROR_INSUFFICIENT_BUFFER);
            }
            else
            {
                //
                // copy converted string to buffer.
                //
                lstrcpyA(pszFilename,chProfile);
                *pBufSize = BufSizeA;
                bRet = TRUE;
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GetICMProfileW - read icm profile from DC
*
* Arguments:
*
*   hdc      - DC
*   szBuffer - size of user buffer
*   pszFilename  - user W buffer
*
* Return Value:
*
*   Boolean
*
* History:
*
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL WINAPI
GetICMProfileW(
    HDC     hdc,
    LPDWORD pBufSize,
    LPWSTR  pszFilename
    )
{
    PDC_ATTR  pdcattr;

    ICMAPI(("gdi32: GetICMProfileW\n"));

    FIXUP_HANDLE(hdc);

    if (pBufSize == NULL)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        PGDI_ICMINFO pIcmInfo;
        PWSZ         pwszProfile = NULL;
        ULONG        ulSize = 0;

        //
        // Initialize ICMINFO
        //
        if ((pIcmInfo = INIT_ICMINFO(hdc,pdcattr)) == NULL)
        {
            WARNING("gdi32: GetICMProfileW: Can't init icm info\n");
            return(FALSE);
        }

        if (IsColorDeviceContext(hdc))
        {
            //
            // Load external ICM dll
            //
            LOAD_ICMDLL(FALSE);

            //
            // if there is no destination profile for the DC, then load
            // the defualt
            //
            IcmUpdateLocalDCColorSpace(hdc,pdcattr);

            if (pIcmInfo->pDestColorSpace)
            {
                //
                // Get profile name in destination colorspace.
                //
                pwszProfile = pIcmInfo->pDestColorSpace->LogColorSpace.lcsFilename;
            }
        }
        else
        {
            ICMMSG(("GetICMProfile(): for Mono-device\n"));

            //
            // There is no destination profile AS default,
            // *BUT* if Apps set it by calling SetICMProfile(), return it.
            //
            if (pIcmInfo->flInfo & ICM_VALID_CURRENT_PROFILE)
            {
                pwszProfile = pIcmInfo->DefaultDstProfile;
            }
        }

        if (pwszProfile)
        {
            ulSize = lstrlenW(pwszProfile) + 1; // + 1 for null-terminated
        }

        if (ulSize <= 1)
        {
            //
            // No profile, Or only NULL character.
            //
            GdiSetLastError(ERROR_PROFILE_NOT_FOUND);
            return(FALSE);
        }
        else if (*pBufSize >= ulSize)
        {
            //
            // There is enough buffer, copy filename.
            //
            lstrcpyW(pszFilename,pwszProfile);
            *pBufSize = ulSize;
            return (TRUE);
        }
        else
        {
            //
            // if buffer is not presented or it's too small,
            // returns the nessesary buffer size.
            //
            GdiSetLastError(ERROR_INSUFFICIENT_BUFFER);
            *pBufSize = ulSize;
            return (FALSE);
        }
    }

    //
    // something error.
    //
    GdiSetLastError(ERROR_INVALID_PARAMETER);
    return(FALSE);
}

/******************************Public*Routine******************************\
* SetICMProfileA - convert the profile string to WCHAR and save in DC
*
* Arguments:
*
*   hdc         - DC
*   pszFileName - Profile name
*
* Return Value:
*
*   status
*
* History:
*
* Rewrite it:
*   23-Jan-1996 -by- Hideyuki Nagase [hideyukn]
* Write it:
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL META WINAPI
SetICMProfileA(
    HDC   hdc,
    LPSTR pszFileName
    )
{
    ICMAPI(("gdi32: SetICMProfileA\n"));

    return (SetICMProfileInternalA(hdc,pszFileName,NULL,0));
}

BOOL
SetICMProfileInternalA(
    HDC                hdc,
    LPSTR              pszFileName,
    PCACHED_COLORSPACE pColorSpace,
    DWORD              dwFlags
    )
{
    BOOL bRet = FALSE;

    //
    // Check parameter either pColorSpace or pszFilename should be given.
    //
    if (pColorSpace)
    {
        ICMAPI(("gdi32: SetICMProfileA by ColorSpace (%ws):dwFlags - %d\n",
                           pColorSpace->LogColorSpace.lcsFilename,dwFlags));
    }
    else if (pszFileName)
    {
        ICMAPI(("gdi32: SetICMProfileA by profile name (%s):dwFlags - %x\n",
                                                      pszFileName,dwFlags));
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet)

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetICMProfile(hdc,
                                  (LPBYTE)pszFileName,
                                  (PVOID)pColorSpace,
                                  EMR_SETICMPROFILEA))
            {
                return((int)FALSE);
            }
        }
    }

    if (pColorSpace)
    {
        //
        // Select the given profile into DC.
        //
        // (this increments ref count of pColorSpace)
        //
        bRet = IcmSetDestinationColorSpace(hdc,NULL,pColorSpace,dwFlags);
    }
    else if (pszFileName)
    {
        ULONG ulSize = lstrlenA(pszFileName);

        if (ulSize && (ulSize < MAX_PATH))
        {
            WCHAR pwszCapt[MAX_PATH];

            //
            // let me count null-terminate char.
            //
            ulSize += 1;

            //
            // Convert to Unicode.
            //
            vToUnicodeN(pwszCapt,MAX_PATH,pszFileName,ulSize);

            //
            // Select the given profile into DC.
            //
            bRet = IcmSetDestinationColorSpace(hdc,pwszCapt,NULL,dwFlags);
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* SetICMProfileW - set profile name into DC
*
* Arguments:
*
* Return Value:
*
* History:
*
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL META WINAPI
SetICMProfileW(
    HDC hdc,
    LPWSTR pwszFileName
    )
{
    ICMAPI(("gdi32: SetICMProfileW\n"));

    return (SetICMProfileInternalW(hdc,pwszFileName,NULL,0));
}

BOOL
SetICMProfileInternalW(
    HDC                hdc,
    LPWSTR             pwszFileName,
    PCACHED_COLORSPACE pColorSpace,
    DWORD              dwFlags
    )
{
    BOOL      bRet = FALSE;

    //
    // Check parameter either pColorSpace or pszFilename should be given.
    //
    if (pColorSpace)
    {
        ICMAPI(("gdi32: SetICMProfileW by ColorSpace (%ws):dwFlags - %x\n",
                           pColorSpace->LogColorSpace.lcsFilename,dwFlags));
    }
    else if (pwszFileName)
    {
        ICMAPI(("gdi32: SetICMProfileW by profile name (%ws):dwFlags - %d\n",
                                                      pwszFileName,dwFlags));
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet)

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetICMProfile(hdc,
                                  (LPBYTE)pwszFileName,
                                  (PVOID)pColorSpace,
                                  EMR_SETICMPROFILEW))
            {
                return((int)FALSE);
            }
        }
    }

    //
    // Select the given profile into DC.
    //
    // (this increments ref count of pColorSpace)
    //
    bRet = IcmSetDestinationColorSpace(hdc,pwszFileName,pColorSpace,dwFlags);

    return (bRet);
}

/******************************Public*Routine******************************\
* EnumICMProfilesA
*
* Arguments:
*
*   hdc
*   lpEnumGamutMatchProc
*   lParam
*
* Return Value:
*
* History:
*
* Write it:
*  13-Feb-1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

int WINAPI
EnumICMProfilesA(
    HDC                hdc,
    ICMENUMPROCA       lpEnumGamutMatchProc,
    LPARAM             lParam
    )
{
    int  iRet = -1;
    BOOL bRet;

    ICMAPI(("gdi32: EnumICMProfileA\n"));

    FIXUP_HANDLE(hdc);

    VALIDATE_HANDLE(bRet,hdc,DC_TYPE);

    if (bRet && (lpEnumGamutMatchProc != NULL))
    {
        iRet = IcmEnumColorProfile(hdc,lpEnumGamutMatchProc,lParam,TRUE,NULL,NULL);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* EnumICMProfilesW
*
* Arguments:
*
*   hdc
*   lpEnumGamutMatchProc
*   lParam
*
* Return Value:
*
* History:
*
* Write it:
*  13-Feb-1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

int WINAPI
EnumICMProfilesW(
    HDC                hdc,
    ICMENUMPROCW       lpEnumGamutMatchProc,
    LPARAM             lParam
    )
{
    int  iRet = -1;
    BOOL bRet;

    ICMAPI(("gdi32: EnumICMProfileW\n"));

    FIXUP_HANDLE(hdc);

    VALIDATE_HANDLE(bRet,hdc,DC_TYPE);

    if (bRet && (lpEnumGamutMatchProc != NULL))
    {
        iRet = IcmEnumColorProfile(hdc,lpEnumGamutMatchProc,lParam,FALSE,NULL,NULL);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* UpdateICMRegKeyW()
*
* History:
*    8-Jan-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL WINAPI
UpdateICMRegKeyW(
    DWORD  Reserved,
    PWSTR  pwszICMMatcher,
    PWSTR  pwszFileName,
    UINT   Command
    )
{
    BOOL bRet = FALSE;

    int iRet;

    ICMAPI(("gdi32: UpdateICMRegKeyW\n"));

    if (Reserved != 0)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Load external ICM dlls
    //
    LOAD_ICMDLL(FALSE);

    switch (Command)
    {
    case ICM_ADDPROFILE:

        if (pwszFileName)
        {
            //
            // Call InstallColorProfileA() in mscms.dll
            //
            bRet = (*fpInstallColorProfileW)(NULL, pwszFileName);
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
        break;

    case ICM_DELETEPROFILE:

        if (pwszFileName)
        {
            //
            // Call UninstallColorProfileW() in mscms.dll
            //
            bRet = (*fpUninstallColorProfileW)(NULL, pwszFileName, FALSE);
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
        break;

    case ICM_QUERYPROFILE:

        if (pwszFileName)
        {
            PROFILECALLBACK_DATA QueryProfile;

            QueryProfile.pwszFileName = GetFileNameFromPath(pwszFileName);
            QueryProfile.bFound       = FALSE;

            if (QueryProfile.pwszFileName != NULL)
            {
                //
                // Enumrate all registered profile to find this profile.
                //
                IcmEnumColorProfile(NULL,IcmQueryProfileCallBack,(LPARAM)(&QueryProfile),FALSE,NULL,NULL);

                //
                // Is that found ?
                //
                bRet = QueryProfile.bFound;
            }
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
        break;

    case ICM_SETDEFAULTPROFILE:

        //
        // Not supported.
        //
        GdiSetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        break;

    case ICM_REGISTERICMATCHER:

        if (pwszICMMatcher && pwszFileName)
        {
            DWORD dwCMM = *((DWORD *)pwszICMMatcher);

            //
            // Call RegisterCMMW() in mscms.dll
            //
            bRet = (*fpRegisterCMMW)(NULL, IcmSwapBytes(dwCMM), pwszFileName);
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
        break;

    case ICM_UNREGISTERICMATCHER:

        if (pwszICMMatcher)
        {
            DWORD dwCMM = *((DWORD *)pwszICMMatcher);

            //
            // Call UnregisterCMMW() in mscms.dll
            //
            bRet = (*fpUnregisterCMMW)(NULL, IcmSwapBytes(dwCMM));
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
        break;

    case ICM_QUERYMATCH:

        if (pwszFileName)
        {
            //
            // Find match profile.
            //
            iRet = IcmEnumColorProfile(NULL,NULL,0,FALSE,(PDEVMODEW)pwszFileName,NULL);

            //
            // Adjust return value, because IcmEnumColorProfile returns -1 if not found.
            // and 0 for error (since no callback function)
            //
            if (iRet > 0)
            {
                bRet = TRUE;
            }
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
        break;

    default:

        WARNING("gdi32!UpdateICMRegKeyW():Invalid Command\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        break;
    }

    return bRet;
}

/******************************Public*Routine******************************\
* UpdateICMRegKeyA
*
* Arguments:
*
*   Reserved
*   szICMMatcher
*   szFileName
*   Command
*
* Return Value:
*
*   Status
*
* History:
*
*    8-Jan-1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

BOOL WINAPI
UpdateICMRegKeyA(
    DWORD Reserved,
    PSTR  szICMMatcher,
    PSTR  szFileName,
    UINT  Command
    )
{
    BOOL bRet = FALSE;
    BOOL bError = FALSE;

    PWSTR pwszFileName = NULL;

    //
    // szICMMatcher points to 4 bytes CMM ID, actually it is not "string".
    // Ansi to Unicode conversion is not needed.
    //
    PWSTR pwszICMMatcher = (PWSTR) szICMMatcher;

    ULONG cjSize;

    ICMAPI(("gdi32: UpdateICMRegKeyA\n"));

    if (Reserved != 0)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    switch (Command)
    {
    case ICM_ADDPROFILE:
    case ICM_DELETEPROFILE:
    case ICM_QUERYPROFILE:
    case ICM_REGISTERICMATCHER:

        //
        // szFileName should be presented.
        //
        if (szFileName)
        {
            //
            // szFileName points to ansi string, just convert to Unicode.
            //
            cjSize = lstrlenA(szFileName)+1;

            pwszFileName = LOCALALLOC((cjSize)*sizeof(WCHAR));
            if (pwszFileName == NULL)
            {
                GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return (bRet);
            }

            vToUnicodeN(pwszFileName,cjSize,szFileName,cjSize);
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            bError = TRUE;
        }
        break;

    case ICM_QUERYMATCH:

        //
        // szFileName should be presented.
        //
        if (szFileName)
        {
            //
            // szFileName points to DEVMODEA structure, convert it to DEVMODEW
            //
            pwszFileName = (PWSTR) GdiConvertToDevmodeW((DEVMODEA *)szFileName);
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            bError = TRUE;
        }
        break;

    case ICM_SETDEFAULTPROFILE:

        GdiSetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        bError = TRUE;
        break;

    case ICM_UNREGISTERICMATCHER:

        //
        // Nothing to convert to Unicode.
        //
        ASSERTGDI(szFileName==NULL,"UpdateICMRegKeyA():szFileName is not null\n");
        break;

    default:

        WARNING("GDI:UpdateICMRegKeyA():Command is invalid\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        bError = TRUE;
        break;
    }

    if (!bError)
    {
        //
        // Call W version.
        //
        bRet = UpdateICMRegKeyW(Reserved,pwszICMMatcher,pwszFileName,Command);
    }

    if (pwszFileName)
    {
        LOCALFREE(pwszFileName);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GetDeviceGammaRamp
*
* Arguments:
*
*   hdc
*   lpGammaRamp
*
* Return Value:
*
*   Status
*
* History:
*
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL WINAPI
GetDeviceGammaRamp(
    HDC             hdc,
    LPVOID          lpGammaRamp
    )
{
    BOOL    bRet = FALSE;

    ICMAPI(("gdi32: GetDeviceGammaRamp\n"));

    if (lpGammaRamp == NULL)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }
    else
    {
        //
        // Call kernel to get current Gamma ramp array for this DC.
        //
        bRet = NtGdiGetDeviceGammaRamp(hdc,lpGammaRamp);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* SetDeviceGammaRamp
*
* Arguments:
*
*   hdc
*   lpGammaRamp
*
* Return Value:
*
*   Status
*
* History:
*
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL WINAPI
SetDeviceGammaRamp(
    HDC             hdc,
    LPVOID          lpGammaRamp
    )
{
    BOOL    bRet = FALSE;

    ICMAPI(("gdi32: SetDeviceGammaRamp\n"));

    if (lpGammaRamp == NULL)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }
    else
    {
        //
        // Call kernel to set new Gamma ramp array for this DC.
        //
        bRet = NtGdiSetDeviceGammaRamp(hdc,lpGammaRamp);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* ColorCorrectPalette
*
*   If this is not the default palette and ICM is turned on in the DC
*   then translate the specified palette entries according to the color
*   transform in the DC
*
* Arguments:
*
*   hdc             -  DC handle
*   hpal            -  PALETTE handle
*   FirsrEntry      -  first entry in palette to translate
*   NumberOfEntries -  number of entries to translate
*
* Return Value:
*
*   Status
*
* History:
*
* Write it:
*  13-Feb-1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

BOOL META WINAPI
ColorCorrectPalette(
    HDC      hdc,
    HPALETTE hpal,
    ULONG    FirstEntry,
    ULONG    NumberOfEntries
    )
{
    BOOL bStatus = FALSE;
    PDC_ATTR pdcattr = NULL;

    ICMAPI(("gdi32: ColorCorrectPalette\n"));

    //
    // Parameter check (max entry of log palette is 0x65536)
    //
    if ((hdc == NULL) || (hpal == NULL) ||
        (NumberOfEntries == 0) || (NumberOfEntries > 65536) ||
        (FirstEntry >= 65536) || (65536 - NumberOfEntries < FirstEntry))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    // default palette could not be changed...
    //
    if (hpal != (HPALETTE)GetStockObject(DEFAULT_PALETTE))
    {
        //
        // metafile call
        //
        if (IS_ALTDC_TYPE(hdc))
        {
            PLDC pldc;

            if (IS_METADC16_TYPE(hdc))
                return(bStatus);

            DC_PLDC(hdc,pldc,bStatus);

            if (pldc->iType == LO_METADC)
            {
                if (!MF_ColorCorrectPalette(hdc,hpal,FirstEntry,NumberOfEntries))
                {
                    return(FALSE);
                }
            }
        }

        PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

        if (pdcattr)
        {
            //
            // Load external ICM dlls
            //
            LOAD_ICMDLL(FALSE);

            if (IS_ICM_HOST(pdcattr->lIcmMode))
            {
                if (bNeedTranslateColor(pdcattr))
                {
                    PPALETTEENTRY ppalEntrySrc = NULL;
                    PPALETTEENTRY ppalEntryDst = NULL;
                    ULONG         NumEntriesRetrieved = 0;

                    //
                    // Make sure palette can be color corrected, get requested entries
                    //
                    ULONG Index;

                    ppalEntrySrc = LOCALALLOC((NumberOfEntries * sizeof(PALETTEENTRY)) * 2);

                    if (ppalEntrySrc == NULL)
                    {
                        WARNING("ColorCorrectPalette: ppalEntry = NULL\n");
                        GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        return(bStatus);
                    }

                    NumEntriesRetrieved = NtGdiColorCorrectPalette(hdc,
                                                                   hpal,
                                                                   FirstEntry,
                                                                   NumberOfEntries,
                                                                   ppalEntrySrc,
                                                                   ColorPaletteQuery);

                    if (NumEntriesRetrieved > 0)
                    {
                        ppalEntryDst = ppalEntrySrc + NumberOfEntries;

                        //
                        // Translate palette entry colors
                        //
                        IcmTranslatePaletteEntry(hdc,pdcattr,ppalEntrySrc,ppalEntryDst,NumEntriesRetrieved);

                        //
                        // set new palette entries
                        //
                        NumEntriesRetrieved = NtGdiColorCorrectPalette(hdc,
                                                                       hpal,
                                                                       FirstEntry,
                                                                       NumEntriesRetrieved,
                                                                       ppalEntryDst,
                                                                       ColorPaletteSet);

                        if (NumEntriesRetrieved > 0)
                        {
                            bStatus = TRUE;
                        }
                    }
                    else
                    {
                        GdiSetLastError(ERROR_INVALID_PARAMETER);
                    }

                    LOCALFREE(ppalEntrySrc);
                }
                else
                {
                    //
                    // Don't need to translate color.
                    //
                    bStatus = TRUE;
                }
            }
            else if (IS_ICM_DEVICE(pdcattr->lIcmMode))
            {
                //
                // for device ICM, don't need to do anything.
                //
                bStatus = TRUE;
            }
            else
            {
                WARNING("ColorCorrectPalette():ICM mode is not enabled\n");
                GdiSetLastError(ERROR_ICM_NOT_ENABLED);
            }
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return bStatus;
}

/******************************Public*Routine******************************\
* IcmTranslateColorObjects - called when there is a change in ICM color transfrom
*                  state
*
* Arguments:
*
*   hdc     - input DC
*   pdcattr - DC's attrs
*
* Return Value:
*
*   status
*
* History:
*
* Rewrite it:
*   13-Feb-1997 -by- Hideyuki Nagase [hideyukn]
* Write it:
*    9-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
IcmTranslateColorObjects(
    HDC      hdc,
    PDC_ATTR pdcattr,
    BOOL     bICMEnable
    )
{
    BOOL bStatus = TRUE;

    COLORREF OldColor;
    COLORREF NewColor;

    ICMAPI(("gdi32: IcmTranslateColorObjects\n"));

    //
    // Invalidate IcmPenColor/IcmBrushColor
    //
    pdcattr->ulDirty_ &= ~(ICM_PEN_TRANSLATED | ICM_BRUSH_TRANSLATED);

    if (bICMEnable)
    {
        if(bNeedTranslateColor(pdcattr))
        {
            if (GetColorTransformInDC(pdcattr) == NULL)
            {
                WARNING("Error in IcmTranslateColorObjects: called when hcmXform == NULL");
                return FALSE;
            }

            //
            // translate Foreground to new icm mode if not paletteindex
            //
            if (!(pdcattr->ulForegroundClr & 0x01000000))
            {
                OldColor = pdcattr->ulForegroundClr;

                bStatus = IcmTranslateCOLORREF(hdc,
                                               pdcattr,
                                               OldColor,
                                               &NewColor,
                                               ICM_FORWARD);

                if (bStatus)
                {
                    pdcattr->crForegroundClr = NewColor;
                }
                else
                {
                    pdcattr->crForegroundClr = OldColor;
                }
            }

            //
            // translate Background to new icm mode if not paletteindex
            //
            if (!(pdcattr->ulBackgroundClr & 0x01000000))
            {
                OldColor = pdcattr->ulBackgroundClr;

                bStatus = IcmTranslateCOLORREF(hdc,
                                               pdcattr,
                                               OldColor,
                                               &NewColor,
                                               ICM_FORWARD);

                if (bStatus)
                {
                    pdcattr->crBackgroundClr = NewColor;
                }
                else
                {
                    pdcattr->crBackgroundClr = OldColor;
                }
            }

            //
            // translate DCBrush to new icm mode if not paletteindex
            //
            if (!(pdcattr->ulDCBrushClr & 0x01000000))
            {
                OldColor = pdcattr->ulDCBrushClr;

                bStatus = IcmTranslateCOLORREF(hdc,
                                               pdcattr,
                                               OldColor,
                                               &NewColor,
                                               ICM_FORWARD);

                if (bStatus)
                {
                    pdcattr->crDCBrushClr = NewColor;
                }
                else
                {
                    pdcattr->crDCBrushClr = OldColor;
                }
            }

            //
            // translate DCPen to new icm mode if not paletteindex
            //
            if (!(pdcattr->ulDCPenClr & 0x01000000))
            {
                OldColor = pdcattr->ulDCPenClr;

                bStatus = IcmTranslateCOLORREF(hdc,
                                               pdcattr,
                                               OldColor,
                                               &NewColor,
                                               ICM_FORWARD);

                if (bStatus)
                {
                    pdcattr->crDCPenClr = NewColor;
                }
                else
                {
                    pdcattr->crDCPenClr = OldColor;
                }
            }

            //
            // set icm color of selected logical brush
            //
            IcmTranslateBrushColor(hdc,pdcattr,(HANDLE)pdcattr->hbrush);

            //
            // set icm color of selected logical pen/extpen
            //
            if (LO_TYPE(pdcattr->hpen) == LO_EXTPEN_TYPE)
            {
                IcmTranslateExtPenColor(hdc,pdcattr,(HANDLE)pdcattr->hpen);
            }
            else
            {
                IcmTranslatePenColor(hdc,pdcattr,(HANDLE)pdcattr->hpen);
            }
        }
    }
    else
    {
        PBRUSHATTR pbrushattr;

        //
        // ICM is off, restore colors (non device icm only)
        //
        pdcattr->crForegroundClr = pdcattr->ulForegroundClr & 0x13ffffff;
        pdcattr->crBackgroundClr = pdcattr->ulBackgroundClr & 0x13ffffff;
        pdcattr->crDCBrushClr    = pdcattr->ulDCBrushClr    & 0x13ffffff;
        pdcattr->crDCPenClr      = pdcattr->ulDCPenClr      & 0x13ffffff;

        //
        // set icm color of selected logical brush
        //
        PSHARED_GET_VALIDATE(pbrushattr,pdcattr->hbrush,BRUSH_TYPE);

        if (pbrushattr)
        {
            pdcattr->IcmBrushColor = pbrushattr->lbColor;
        }

        //
        // set icm color of selected logical pen
        //
        PSHARED_GET_VALIDATE(pbrushattr,pdcattr->hpen,BRUSH_TYPE);

        if (pbrushattr)
        {
            pdcattr->IcmPenColor = pbrushattr->lbColor;
        }
    }

    //
    // set DC dirty flags to force re-realization of color objects
    //
    pdcattr->ulDirty_ |= (DIRTY_BRUSHES|DC_BRUSH_DIRTY|DC_PEN_DIRTY);

    return(bStatus);
}

/******************************Public*Routine******************************\
* IcmCreateTemporaryColorProfile()
*
* History:
*
* Wrote it:
*     7.May.1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmCreateTemporaryColorProfile(
    LPWSTR TemporaryColorProfile,
    LPBYTE ProfileData,
    DWORD  ProfileDataSize
    )
{
    BOOL  bRet = FALSE;

    WCHAR TempPath[MAX_PATH];
    WCHAR TempFile[MAX_PATH];

    //
    // make temp file for profile, include name in lcspw
    //
    if (GetTempPathW(MAX_PATH,(LPWSTR)TempPath))
    {
        BOOL bPathOK = TRUE;

        if (TemporaryColorProfile[0] != UNICODE_NULL)
        {
            wcscpy(TempFile,TempPath);
            wcscat(TempFile,TemporaryColorProfile);
        }
        else
        {
            bPathOK = GetTempFileNameW((LPWSTR)TempPath,L"ICM",0,(LPWSTR)TempFile);
        }

        if (bPathOK)
        {
            if (ProfileDataSize == 0)
            {
                //
                // Nothing needs to save, just return with created filename
                //
                lstrcpyW(TemporaryColorProfile,TempFile);

                bRet = TRUE;
            }
            else
            {
                HANDLE hFile = CreateFileW((LPWSTR)TempFile,
                                    GENERIC_READ | GENERIC_WRITE,
                                    0,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);

                if (hFile != INVALID_HANDLE_VALUE)
                {
                    ULONG ulWritten;

                    if (WriteFile(hFile,ProfileData,ProfileDataSize,&ulWritten,NULL))
                    {
                        //
                        // Put the created file name into LOGCOLORSPACE
                        //
                        lstrcpyW(TemporaryColorProfile,TempFile);

                        //
                        // Close file handle
                        //
                        CloseHandle(hFile);

                        //
                        // Everything O.K.
                        //
                        bRet = TRUE;
                    }
                    else
                    {
                        ICMWRN(("IcmCreateTemporaryColorProfile(): Failed WriteFile\n"));

                        //
                        // Failed, close handle and delete it.
                        //
                        CloseHandle(hFile);
                        DeleteFileW(TempFile);
                    }
                }
                else
                {
                    ICMWRN(("IcmCreateTemporaryColorProfile(): Failed CreateFile\n"));
                }
            }
        }
        else
        {
            ICMWRN(("IcmCreateTemporaryColorProfile(): Failed CreateTempFileName\n"));
        }
    }
    else
    {
        ICMWRN(("IcmCreateTemporayColorProfile(): Failed GetTempPath\n"));
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* IcmGetBitmapColorSpace()
*
* History:
*
* Wrote it:
*     13.March.1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmGetBitmapColorSpace(
    LPBITMAPINFO     pbmi,
    LPLOGCOLORSPACEW plcspw,
    PPROFILE         pColorProfile,
    PDWORD           pdwFlags
)
{
    BOOL bBitmapColorSpace = FALSE;

    ICMAPI(("gdi32: IcmGetBitmapColorSpace\n"));

    //
    // Init output buffers with zero.
    //
    *pdwFlags = 0;
    ZeroMemory(plcspw,sizeof(LOGCOLORSPACE));
    ZeroMemory(pColorProfile,sizeof(PROFILE));

    //
    // check for BITMAPV4 OR BITMAPV5
    //
    if (pbmi->bmiHeader.biSize == sizeof(BITMAPV4HEADER))
    {
        PBITMAPV4HEADER pbmih4 = (PBITMAPV4HEADER)&pbmi->bmiHeader;

        ICMMSG(("IcmGetBitmapColorSpace: BITMAPV4HEADER\n"));

        //
        // if CIEXYZ endpoints are given, create a new color transform
        // to use.
        //
        plcspw->lcsSignature = LCS_SIGNATURE;
        plcspw->lcsVersion   = 0x400;
        plcspw->lcsSize      = sizeof(LOGCOLORSPACEW);
        plcspw->lcsCSType    = pbmih4->bV4CSType;
        plcspw->lcsIntent    = LCS_GM_IMAGES;
        plcspw->lcsEndpoints = pbmih4->bV4Endpoints;
        plcspw->lcsGammaRed   = pbmih4->bV4GammaRed;
        plcspw->lcsGammaGreen = pbmih4->bV4GammaGreen;
        plcspw->lcsGammaBlue  = pbmih4->bV4GammaBlue;

        if (pbmih4->bV4CSType == LCS_CALIBRATED_RGB)
        {
            ICMMSG(("IcmGetBitmapColorSpace: BITMAPv4 CALIBRATED RGB\n"));
            ICMMSG(("  lcspw.lcsCSType     = %x\n",pbmih4->bV4CSType));
            ICMMSG(("  lcspw.lcsIntent     = %d\n",LCS_GM_IMAGES));
            ICMMSG(("  lcspw.lcsGammaRed   = %d\n",pbmih4->bV4GammaRed));
            ICMMSG(("  lcspw.lcsGammaGreen = %d\n",pbmih4->bV4GammaGreen));

            //
            // There is no profile specified.
            //
            plcspw->lcsFilename[0] = UNICODE_NULL;

            bBitmapColorSpace = TRUE;
        }
        else // any other CSType
        {
            DWORD dwSize = MAX_PATH;

            ICMMSG(("IcmGetBitmapColorSpace: BITMAPv4 lcsType = %x\n",pbmih4->bV4CSType));

            //
            // Load external ICM dlls.
            //
            LOAD_ICMDLL((int)FALSE);

            //
            // Get corresponding colorspace profile.
            //
            bBitmapColorSpace =
                (*fpGetStandardColorSpaceProfileW)(NULL,
                                                   pbmih4->bV4CSType,
                                                   plcspw->lcsFilename,
                                                   &dwSize);
        }
    }
    else if (pbmi->bmiHeader.biSize == sizeof(BITMAPV5HEADER))
    {
        PBITMAPV5HEADER pbmih5 = (PBITMAPV5HEADER)&pbmi->bmiHeader;

        ICMMSG(("IcmGetBitmapColorSpace: BITMAPV5HEADER\n"));
        ICMMSG(("  lcspw.lcsCSType  = %x\n",pbmih5->bV5CSType));
        ICMMSG(("  lcspw.lcsIntent  = %d\n",pbmih5->bV5Intent));

        //
        // fill in common logcolorspace info
        //
        plcspw->lcsSignature = LCS_SIGNATURE;
        plcspw->lcsVersion   = 0x400;
        plcspw->lcsSize      = sizeof(LOGCOLORSPACEW);
        plcspw->lcsCSType    = pbmih5->bV5CSType;
        plcspw->lcsIntent    = pbmih5->bV5Intent;
        plcspw->lcsEndpoints = pbmih5->bV5Endpoints;
        plcspw->lcsGammaRed   = pbmih5->bV5GammaRed;
        plcspw->lcsGammaGreen = pbmih5->bV5GammaGreen;
        plcspw->lcsGammaBlue  = pbmih5->bV5GammaBlue;

        //
        // validate Intent
        //
        if ((plcspw->lcsIntent != LCS_GM_BUSINESS) &&
            (plcspw->lcsIntent != LCS_GM_GRAPHICS) &&
            (plcspw->lcsIntent != LCS_GM_IMAGES)   &&
            (plcspw->lcsIntent != LCS_GM_ABS_COLORIMETRIC))
        {
            //
            // Intent is invalid, just use LCS_GM_IMAGES
            //
            plcspw->lcsIntent = LCS_GM_IMAGES;
        }

        //
        // If a profile is linked or embedded then use it.
        // otherwise:
        // If CIEXYZ endpoints are given, create a new color transform
        // to use.
        //
        if (pbmih5->bV5CSType == PROFILE_EMBEDDED)
        {
            PVOID pProfileEmbedded = NULL;

            ICMMSG(("IcmGetBitmapColorSpace: Embedded profile\n"));

            //
            // Update CSType to Calibrated_RGB from Profile_Embedded
            //
            plcspw->lcsCSType = LCS_CALIBRATED_RGB;

            //
            // Get pointer to embeded profile.
            //
            pProfileEmbedded = (PVOID)((PBYTE)pbmi + pbmih5->bV5ProfileData);

            if (pProfileEmbedded)
            {
                //
                // Fill up PROFILE structure for "on memory" profile.
                //
                pColorProfile->dwType = PROFILE_MEMBUFFER;
                pColorProfile->pProfileData = pProfileEmbedded;
                pColorProfile->cbDataSize = pbmih5->bV5ProfileSize;

                //
                // Mark as on memory profile.
                //
                *pdwFlags |= ON_MEMORY_PROFILE;
            }
            else
            {
                //
                // This bitmap marked as "Embedded", but no profile there, just go with LOGCOLORSPACE.
                //
                ICMWRN(("IcmGetBitmapColorSpace(): Embedded profile, but no profile embedded\n"));
            }

            bBitmapColorSpace = TRUE;
        }
        else if (pbmih5->bV5CSType == PROFILE_LINKED)
        {
            WCHAR LinkedProfile[MAX_PATH];

            ICMMSG(("IcmGetBitmapColorSpace(): linked profile\n"));

            //
            // Update CSType to Calibrated_RGB from Profile_Linked
            //
            plcspw->lcsCSType = LCS_CALIBRATED_RGB;

            //
            // Convert profile name to Unicode.
            //
            vToUnicodeN(
                        LinkedProfile, MAX_PATH,
                        (CONST CHAR *)((PBYTE)pbmih5 + pbmih5->bV5ProfileData),
                        strlen((CONST CHAR *)((PBYTE)pbmih5 + pbmih5->bV5ProfileData))+1
                       );

            //
            // Normalize profile path.
            //
            BuildIcmProfilePath(LinkedProfile,plcspw->lcsFilename,MAX_PATH);

            ICMMSG(("lcspw.lcsFilename = %ws\n",plcspw->lcsFilename));

            bBitmapColorSpace = TRUE;
        }
        else if (pbmih5->bV5CSType == LCS_CALIBRATED_RGB)
        {
            ICMMSG(("IcmGetBitmapColorSpace(): calibrated RGB\n"));
            ICMMSG(("  lcspw.lcsGammaRed   = %d\n",pbmih5->bV5GammaRed));
            ICMMSG(("  lcspw.lcsGammaGreen = %d\n",pbmih5->bV5GammaGreen));
            ICMMSG(("  lcspw.lcsGammaBlue  = %d\n",pbmih5->bV5GammaBlue));

            //
            // There is profile specified.
            //
            plcspw->lcsFilename[0] = UNICODE_NULL;

            bBitmapColorSpace = TRUE;
        }
        else // any other CSType
        {
            DWORD dwSize = MAX_PATH;

            ICMMSG(("IcmGetBitmapColorSpace: BITMAPv5 lcsType = %x\n",pbmih5->bV5CSType));

            //
            // Load external ICM dlls.
            //
            LOAD_ICMDLL((int)FALSE);

            //
            // Get corresponding colorspace profile.
            //
            bBitmapColorSpace =
                (*fpGetStandardColorSpaceProfileW)(NULL,
                                                   pbmih5->bV5CSType,
                                                   plcspw->lcsFilename,
                                                   &dwSize);
        }
    }
    else
    {
        ICMMSG(("IcmGetBitmapColorSpace(): no color space specified\n"));
    }

    return (bBitmapColorSpace);
}

/******************************Public*Routine******************************\
* IcmGetTranslateInfo()
*
* History:
*
* Wrote it:
*     13.March.1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmGetTranslateInfo(
    PDC_ATTR            pdcattr,
    LPBITMAPINFO        pbmi,
    PVOID               pvBits,
    ULONG               cjBits,
    DWORD               dwNumScan,
    PDIB_TRANSLATE_INFO pdti,
    DWORD               dwFlags
)
{
    BMFORMAT    ColorType;
    PVOID       pOutput;
    ULONG       nColors;
    ULONG       cjTranslateBits;

    PBITMAPINFO pbmiNew    = NULL;
    BOOL        bCMYKColor = IS_CMYK_COLOR(pdcattr->lIcmMode);

    ICMAPI(("gdi32: IcmGetTranslateInfo\n"));
    ICMAPI(("-----: CMYK Color = %s\n",(bCMYKColor ? "Yes" : "No")));
    ICMAPI(("-----: Backward   = %s\n",((dwFlags & ICM_BACKWARD) ? "Yes" : "No")));

    UNREFERENCED_PARAMETER(dwFlags);

    if (dwNumScan == (DWORD)-1)
    {
        dwNumScan = ABS(pbmi->bmiHeader.biHeight);
    }

    //
    // determine whether this is a palettized DIB
    //
    if (pbmi->bmiHeader.biCompression == BI_RGB)
    {
        if (pbmi->bmiHeader.biBitCount > 8)
        {
            //
            // we will translate bitmap, pvBits should be presented.
            //
            if (pvBits == NULL)
            {
                return (FALSE);
            }

            //
            // must translate DIB, standard 16,24,32 format
            //
            if (pbmi->bmiHeader.biBitCount == 16)
            {
                ICMMSG(("IcmGetTranslateInfo():BI_RGB 16 bpp\n"));

                ColorType = BM_x555RGB;
            }
            else if (pbmi->bmiHeader.biBitCount == 24)
            {
                ICMMSG(("IcmGetTranslateInfo():BI_RGB 24 bpp\n"));

                ColorType = BM_RGBTRIPLETS;
            }
            else if (pbmi->bmiHeader.biBitCount == 32)
            {
                ICMMSG(("IcmGetTranslateInfo():BI_RGB 32 bpp\n"));

                ColorType = BM_xRGBQUADS;
            }
            else
            {
                ICMMSG(("IcmGetTranslateInfo():BI_RGB Invalid bpp\n"));

                return (FALSE);
            }

            //
            // Fill up source bitmap information.
            //
            pdti->SourceWidth     = pbmi->bmiHeader.biWidth;
            pdti->SourceHeight    = dwNumScan;
            pdti->SourceBitCount  = pbmi->bmiHeader.biBitCount;
            pdti->SourceColorType = ColorType;
            pdti->pvSourceBits    = pvBits;
            pdti->cjSourceBits    = cjBits;

            //
            // CMYK Color ?
            //
            if (bCMYKColor)
            {
                pdti->TranslateType = (TRANSLATE_BITMAP|TRANSLATE_HEADER);

                //
                // CMYK bitmap color bitmap is 32 BPP (4 bytes per pixel).
                //
                cjTranslateBits = (pdti->SourceWidth * 4) * pdti->SourceHeight;

                //
                // We need new bitmap info header for CMYK.
                //
                pbmiNew = LOCALALLOC(pbmi->bmiHeader.biSize);

                if (!pbmiNew)
                {
                    WARNING("IcmGetTranslateInfo():LOCALALLOC() failed\n");
                    return (FALSE);
                }

                //
                // Make a copy of source, first.
                //
                RtlCopyMemory(pbmiNew,pbmi,pbmi->bmiHeader.biSize);

                //
                // Update header for CMYK color.
                //
                pbmiNew->bmiHeader.biBitCount = 32;
                pbmiNew->bmiHeader.biCompression = BI_CMYK;
                pbmiNew->bmiHeader.biSizeImage = cjTranslateBits;
                pbmiNew->bmiHeader.biClrUsed = 0;
                pbmiNew->bmiHeader.biClrImportant = 0;

                //
                // We have new BITMAPINFO header
                //
                pdti->TranslateBitmapInfo     = pbmiNew;
                pdti->TranslateBitmapInfoSize = pbmi->bmiHeader.biSize;

                //
                // Translate bitmap color type is CMYK.
                //
                pdti->TranslateColorType = BM_KYMCQUADS;
            }
            else
            {
                pdti->TranslateType = TRANSLATE_BITMAP;

                //
                // Translate bitmap size is same as source.
                //
                cjTranslateBits = cjBits;

                //
                // Translate bitmap color type is same source.
                //
                pdti->TranslateColorType = ColorType;

                pdti->TranslateBitmapInfo     = NULL;
                pdti->TranslateBitmapInfoSize = 0;
            }

            //
            // Allocate translate buffer
            //
            pOutput = LOCALALLOC(cjTranslateBits);

            if (!pOutput)
            {
                if (pbmiNew)
                {
                    LOCALFREE(pbmiNew);
                }
                WARNING("IcmGetTranslateInfo():LOCALALLOC() failed\n");
                return (FALSE);
            }

            //
            // Setup translation buffer.
            //
            pdti->pvTranslateBits = pOutput;
            pdti->cjTranslateBits = cjTranslateBits;
        }
        else if (
                 ((pbmi->bmiHeader.biBitCount == 8) ||
                  (pbmi->bmiHeader.biBitCount == 4) ||
                  (pbmi->bmiHeader.biBitCount == 1))
                )
        {
            ULONG nMaxColors = (1 << pbmi->bmiHeader.biBitCount);

            ICMMSG(("IcmGetTranslateInfo():BI_RGB 8/4/1 bpp\n"));

            //
            // validate number of colors
            //
            nColors = pbmi->bmiHeader.biClrUsed;

            if ((nColors == 0) || (nColors > nMaxColors))
            {
                nColors = nMaxColors;
            }

            //
            // Allocate new bitmap info header and color table.
            //
            pbmiNew = LOCALALLOC(pbmi->bmiHeader.biSize + (nColors * sizeof(RGBQUAD)));

            if (!pbmiNew)
            {
                WARNING("IcmGetTranslateInfo():LOCALALLOC() failed\n");
                return (FALSE);
            }

            //
            // Copy source BITMAPINFO to new
            //
            RtlCopyMemory(pbmiNew,pbmi,pbmi->bmiHeader.biSize);

            pdti->TranslateType           = TRANSLATE_HEADER;
            pdti->SourceColorType         = BM_xRGBQUADS;
            pdti->SourceWidth             = nColors;
            pdti->SourceHeight            = 1;
            pdti->SourceBitCount          = sizeof(RGBQUAD);
            pdti->TranslateBitmapInfo     = pbmiNew;
            pdti->TranslateBitmapInfoSize = 0; // size will not change from original
            pdti->pvSourceBits            = (PBYTE)pbmi + pbmi->bmiHeader.biSize;
            pdti->cjSourceBits            = nColors;
            pdti->pvTranslateBits         = (PBYTE)pbmiNew + pbmiNew->bmiHeader.biSize;
            pdti->cjTranslateBits         = nColors * sizeof(RGBQUAD);

            if (bCMYKColor)
            {
                pdti->TranslateColorType = BM_KYMCQUADS;

                //
                // Update header for CMYK color.
                //
                pbmiNew->bmiHeader.biCompression = BI_CMYK;
            }
            else
            {
                pdti->TranslateColorType = BM_xRGBQUADS;
            }
        }
        else
        {
            ICMWRN(("IcmGetTranslateInfo: Illegal biBitCount\n"));
            return (FALSE);
        }
    }
    else if (
             (pbmi->bmiHeader.biCompression == BI_BITFIELDS) &&
              (
                (pbmi->bmiHeader.biBitCount == 16) ||
                (pbmi->bmiHeader.biBitCount == 32)
              )
            )
    {
        PULONG pulColors = (PULONG)pbmi->bmiColors;

        ICMMSG(("IcmGetTranslateInfo():BI_BITFIELDS 16/32 bpp\n"));

        //
        // we will translate bitmap, pvBits should be presented.
        //
        if (pvBits == NULL)
        {
            return (FALSE);
        }

        if (pbmi->bmiHeader.biBitCount == 32)
        {
            if ((pulColors[0] == 0x0000ff) &&  /* Red */
                (pulColors[1] == 0x00ff00) &&  /* Green */
                (pulColors[2] == 0xff0000))    /* Blue */
            {
                ColorType = BM_xBGRQUADS;
            }
            else if ((pulColors[0] == 0xff0000) &&  /* Red */
                     (pulColors[1] == 0x00ff00) &&  /* Green */
                     (pulColors[2] == 0x0000ff))    /* Blue */
            {
                ColorType = BM_xRGBQUADS;
            }
            else
            {
                ICMWRN(("IcmGetTranslateInfo: Illegal Bitfields fields for 32 bpp\n"));
                return (FALSE);
            }
        }
        else
        {
            if ((pulColors[0] == 0x007c00) &&
                (pulColors[1] == 0x0003e0) &&
                (pulColors[2] == 0x00001f))
            {
                ColorType = BM_x555RGB;
            }
            else if ((pulColors[0] == 0x00f800) &&
                     (pulColors[1] == 0x0007e0) &&
                     (pulColors[2] == 0x00001f))
            {
                ColorType = BM_565RGB;
            }
            else
            {
                ICMWRN(("IcmGetTranslateInfo: Illegal Bitfields fields for 16 bpp\n"));
                return (FALSE);
            }
        }

        //
        // Fill up source bitmap information.
        //
        pdti->SourceWidth     = pbmi->bmiHeader.biWidth;
        pdti->SourceHeight    = dwNumScan;
        pdti->SourceBitCount  = pbmi->bmiHeader.biBitCount;
        pdti->SourceColorType = ColorType;
        pdti->pvSourceBits    = pvBits;
        pdti->cjSourceBits    = cjBits;

        //
        // CMYK Color ?
        //
        if (bCMYKColor)
        {
            pdti->TranslateType = (TRANSLATE_BITMAP|TRANSLATE_HEADER);

            //
            // CMYK bitmap color bitmap is 32 BPP (4 bytes per pixel).
            //
            cjTranslateBits = (pdti->SourceWidth * 4) * pdti->SourceHeight;

            //
            // We need new bitmap info header for CMYK.
            //
            pbmiNew = LOCALALLOC(pbmi->bmiHeader.biSize);

            if (!pbmiNew)
            {
                WARNING("IcmGetTranslateInfo():LOCALALLOC() failed\n");
                return (FALSE);
            }

            //
            // Make a copy of source, first.
            //
            RtlCopyMemory(pbmiNew,pbmi,pbmi->bmiHeader.biSize);

            //
            // Update header for CMYK color.
            //
            pbmiNew->bmiHeader.biBitCount = 32;
            pbmiNew->bmiHeader.biCompression = BI_CMYK;
            pbmiNew->bmiHeader.biSizeImage = cjTranslateBits;
            pbmiNew->bmiHeader.biClrUsed = 0;
            pbmiNew->bmiHeader.biClrImportant = 0;

            //
            // We have new BITMAPINFO header
            //
            pdti->TranslateBitmapInfo     = pbmiNew;
            pdti->TranslateBitmapInfoSize = pbmi->bmiHeader.biSize;

            //
            // Translate bitmap color type is CMYK.
            //
            pdti->TranslateColorType = BM_KYMCQUADS;
        }
        else
        {
            pdti->TranslateType = TRANSLATE_BITMAP;

            //
            // Translate bitmap size is same as source.
            //
            cjTranslateBits = cjBits;

            //
            // Translate bitmap color type is same source.
            //
            pdti->TranslateColorType = ColorType;

            pdti->TranslateBitmapInfo     = NULL;
            pdti->TranslateBitmapInfoSize = 0;
        }

        //
        // Allocate translate buffer
        //
        pOutput = LOCALALLOC(cjTranslateBits);

        if (!pOutput)
        {
            if (pbmiNew)
            {
                LOCALFREE(pbmiNew);
            }
            WARNING("IcmGetTranslateInfo():LOCALALLOC() failed\n");
            return (FALSE);
        }

        //
        // Setup translation buffer.
        //
        pdti->pvTranslateBits = pOutput;
        pdti->cjTranslateBits = cjTranslateBits;
    }
    else if (
             (pbmi->bmiHeader.biCompression == BI_RLE8) ||
             (pbmi->bmiHeader.biCompression == BI_RLE4)
            )
    {
        //
        // translate 256 for RLE8, 16 for RLE4 entry color palette
        //
        ULONG nMaxColors;

        if (pbmi->bmiHeader.biCompression == BI_RLE8)
        {
            ICMMSG(("IcmGetTranslateInfo():BI_RLE 8\n"));

            nMaxColors = 256;
        }
        else
        {
            ICMMSG(("IcmGetTranslateInfo():BI_RLE 4\n"));

            nMaxColors = 16;
        }

        //
        // validate number of colors
        //
        nColors = pbmi->bmiHeader.biClrUsed;

        if ((nColors == 0) || (nColors > nMaxColors))
        {
            nColors = nMaxColors;
        }

        //
        // Allocate new bitmap info header and color table.
        //
        pbmiNew = LOCALALLOC(pbmi->bmiHeader.biSize + (nColors * sizeof(RGBQUAD)));

        if (!pbmiNew)
        {
            WARNING("IcmGetTranslateInfo():LOCALALLOC() failed\n");
            return (FALSE);
        }

        //
        // Copy source BITMAPINFO to new
        //
        RtlCopyMemory(pbmiNew,pbmi,pbmi->bmiHeader.biSize);

        pdti->TranslateType           = TRANSLATE_HEADER;
        pdti->SourceColorType         = BM_xRGBQUADS;
        pdti->SourceWidth             = nColors;
        pdti->SourceHeight            = 1;
        pdti->SourceBitCount          = sizeof(RGBQUAD);
        pdti->TranslateBitmapInfo     = pbmiNew;
        pdti->TranslateBitmapInfoSize = 0; // size will not change from original
        pdti->pvSourceBits            = (PBYTE)pbmi + pbmi->bmiHeader.biSize;
        pdti->cjSourceBits            = nColors;
        pdti->pvTranslateBits         = (PBYTE)pbmiNew + pbmiNew->bmiHeader.biSize;
        pdti->cjTranslateBits         = nColors * sizeof(RGBQUAD);

        if (bCMYKColor)
        {
            pdti->TranslateColorType = BM_KYMCQUADS;

            //
            // Update header for CMYK color.
            //
            if (pbmi->bmiHeader.biCompression == BI_RLE8)
            {
                ICMMSG(("IcmGetTranslateInfo():BI_CMYKRLE 8\n"));

                pbmiNew->bmiHeader.biCompression = BI_CMYKRLE8;
            }
            else
            {
                ICMMSG(("IcmGetTranslateInfo():BI_CMYKRLE 4\n"));

                pbmiNew->bmiHeader.biCompression = BI_CMYKRLE4;
            }
        }
        else
        {
            pdti->TranslateColorType = BM_xRGBQUADS;
        }
    }
    else
    {
        WARNING("IcmGetTranslateInfo():Illegal bitmap format\n");
        return (FALSE);
    }

    return (TRUE);
}

/******************************Public*Routine******************************\
* IcmTranslateDIB
*
* History:
*
* Rewrote it for CMYK color support:
*   13-Mar-1997 -by- Hideyuki Nagase [hideyukn]
* Wrote it:
*    3-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
IcmTranslateDIB(
    HDC          hdc,
    PDC_ATTR     pdcattr,
    ULONG        cjBits,
    PVOID        pBitsIn,
    PVOID       *ppBitsOut,
    PBITMAPINFO  pbmi,
    PBITMAPINFO *ppbmiNew,
    DWORD       *pcjbmiNew,
    DWORD        dwNumScan,
    UINT         iUsage,
    DWORD        dwFlags,
    PCACHED_COLORSPACE *ppColorSpace, // used only for device ICM case.
    PCACHED_COLORTRANSFORM *ppCXform  // used only for device ICM case.
    )
{
    //
    // translate DIB or color table
    //
    BOOL   bStatus = TRUE;
    DWORD  dwColorSpaceFlags = 0;
    PCACHED_COLORSPACE pBitmapColorSpace = NULL;

    LOGCOLORSPACEW     LogColorSpace;
    PROFILE            ColorProfile;

    DIB_TRANSLATE_INFO TranslateInfo;

    PCACHED_COLORTRANSFORM pCXform;

    PGDI_ICMINFO pIcmInfo;

    UNREFERENCED_PARAMETER(iUsage);

    ICMAPI(("gdi32: IcmTranslateDIB\n"));

    //
    // Parameter check
    //
    if (pbmi == NULL)
    {
        WARNING("gdi32: IcmTranslateDIB(): pbmi is NULL\n");
        return FALSE;
    }

    //
    // Load external ICM dlls.
    //
    LOAD_ICMDLL(FALSE);

    //
    // Initialize ICMINFO
    //
    if ((pIcmInfo = GET_ICMINFO(pdcattr)) == NULL)
    {
        WARNING("gdi32: IcmTranslateDIB: Can't init icm info\n");
        return FALSE;
    }

    //
    // Initialized returned info.
    //
    if (ppColorSpace)
        *ppColorSpace = NULL;
    if (ppCXform)
        *ppCXform = NULL;

    //
    // Get LOGCOLORSPACE from bitmap if specified.
    //
    if (IcmGetBitmapColorSpace(pbmi,&LogColorSpace,&ColorProfile,&dwColorSpaceFlags))
    {
        //
        // Find ColorSpace from cache.
        //
        pBitmapColorSpace = IcmGetColorSpaceByColorSpace(
                                (HGDIOBJ)hdc,
                                &LogColorSpace,
                                &ColorProfile,
                                dwColorSpaceFlags);

        if (pBitmapColorSpace == NULL)
        {
            //
            // Create new cache.
            //
            pBitmapColorSpace = IcmCreateColorSpaceByColorSpace(
                                    (HGDIOBJ)hdc,
                                    &LogColorSpace,
                                    &ColorProfile,
                                    dwColorSpaceFlags);
        }
    }

    //
    // Create Color Transform, if nessesary.
    //
    if (IS_ICM_DEVICE(pdcattr->lIcmMode))
    {
        //
        // just create a new hcmXform for use with BITMAPV4 AND BITMAPV5s.
        //
        if (pBitmapColorSpace)
        {
            ICMMSG(("IcmTranslateDIB():Bitmap color space used for DEVICE ICM\n"));

            if ((ppCXform != NULL) && (ppColorSpace != NULL))
            {
                //
                // for DEVICE managed ICM, call device driver to create a temp xform
                //
                pCXform = IcmCreateColorTransform(hdc,pdcattr,pBitmapColorSpace,dwFlags);

                if (pCXform == NULL)
                {
                    WARNING("IcmTranslateDIB():Fail to create temporay Xfrom with V4V5 Bitmap\n");

                    //
                    // Failed to create color transfrom, release bitmap color space,
                    // and null-color transform.
                    //
                    IcmReleaseColorSpace(NULL,pBitmapColorSpace,FALSE);
                    bStatus = FALSE;
                }
                else
                {
                    if (pCXform == IDENT_COLORTRANSFORM)
                    {
                        //
                        // Source and destination color space are same, so no color transform is
                        // required, and of course we don't need to keep bitmap color space.
                        //
                        IcmReleaseColorSpace(NULL,pBitmapColorSpace,FALSE);
                    }
                    else
                    {
                        //
                        // Return to the color transform to callee...
                        // (these should be deleted by callee)
                        //
                        *ppCXform = pCXform;
                        *ppColorSpace = pBitmapColorSpace;
                    }

                    bStatus = TRUE;
                }
            }
            else
            {
                WARNING("IcmTranslateDIB():No device ICM will happen for this V4V5 Bitmap\n");

                IcmReleaseColorSpace(NULL,pBitmapColorSpace,FALSE);
                bStatus = TRUE;
            }

            return (bStatus);
        }
        else
        {
            ICMMSG(("IcmTranslateDIB():DC color space used for DEVICE ICM\n"));

            //
            // We don't need to create new transform, just use the transform in DC.
            //
            return (TRUE);
        }
    }
    else if (IS_ICM_HOST(pdcattr->lIcmMode))
    {
        HANDLE hcmXform = NULL;

        if (pBitmapColorSpace)
        {
            ICMMSG(("IcmTranslateDIB():Bitmap color space used for HOST ICM\n"));

            pCXform = IcmCreateColorTransform(hdc,pdcattr,pBitmapColorSpace,dwFlags);

            if ((pCXform == IDENT_COLORTRANSFORM) || (pCXform == NULL))
            {
                //
                // unable or not nessesary to translate DIB
                //
                ICMWRN(("Bitmap V4 or V5: CreateColorTransform failed or ident.\n"));
                goto TranslateDIB_Cleanup;
            }
            else
            {
                hcmXform = pCXform->ColorTransform;
            }
        }
        else
        {
            ICMMSG(("IcmTranslateDIB():DC color space used for HOST ICM\n"));

            if (dwFlags & ICM_BACKWARD)
            {
                ICMMSG(("IcmTranslateDIB():Backward Color transform\n"));

                //
                // If there is cached handle, use that.
                //
                if (pIcmInfo->pBackCXform)
                {
                    ICMMSG(("IcmTranslateDIB():Use cached transform for Backward Color transform\n"));

                    hcmXform = pIcmInfo->pBackCXform->ColorTransform;
                }
                else
                {
                    PCACHED_COLORTRANSFORM pCXform;

                    ICMMSG(("IcmTranslateDIB():Create cached transform for Backward Color transform\n"));

                    //
                    // Create backward color transform.
                    //
                    pCXform = IcmCreateColorTransform(hdc,
                                                      pdcattr,
                                                      NULL,
                                                      ICM_BACKWARD);

                    if ((pCXform == NULL) || (pCXform == IDENT_COLORTRANSFORM))
                    {
                        ICMWRN(("IcmTranslateDIB():ColorTransform is NULL or ident.\n"));
                        goto TranslateDIB_Cleanup;
                    }

                    //
                    // Cache created color transform.
                    //
                    pIcmInfo->pBackCXform = pCXform;

                    //
                    // We will delete this cached transform, when we don't need this anymore.
                    //
                    hcmXform = pCXform->ColorTransform;
                }
            }
            else
            {
                //
                // Use DC's colortransform
                //
                hcmXform = pdcattr->hcmXform;
            }
        }

        if (hcmXform == NULL)
        {
            //
            // if we don't have any colortransform, we will not translate anything.
            // just fail and let use original image.
            //
            ICMWRN(("IcmTranslateDIB():No colortransform, might be ident.\n"));
            goto TranslateDIB_Cleanup;
        }

        //
        // Get bitmap translate information.
        //
        bStatus = IcmGetTranslateInfo(pdcattr,pbmi,pBitsIn,cjBits,dwNumScan,&TranslateInfo,dwFlags);

        if (bStatus)
        {
            LONG nLineBytes = ((TranslateInfo.SourceWidth *
                                TranslateInfo.SourceBitCount) + 7) / 8;

            bStatus = (*fpTranslateBitmapBits)(
                            hcmXform,
                            TranslateInfo.pvSourceBits,
                            TranslateInfo.SourceColorType,
                            TranslateInfo.SourceWidth,
                            TranslateInfo.SourceHeight,
                            ALIGN_DWORD(nLineBytes),
                            TranslateInfo.pvTranslateBits,
                            TranslateInfo.TranslateColorType,
                               //
                            0, // We need pass 0 here, to let Kodak CMM works
                               //
                            NULL,0);

            if (bStatus)
            {
                //
                // Pass new bitmap and/or header to caller.
                //
                if (TranslateInfo.TranslateType & TRANSLATE_BITMAP)
                {
                    if (ppBitsOut)
                    {
                        *ppBitsOut = TranslateInfo.pvTranslateBits;
                    }
                    else
                    {
                        //
                        // Overwrite original (when input color and output color type is same)
                        //
                        if (TranslateInfo.SourceColorType == TranslateInfo.TranslateColorType)
                        {
                            RtlCopyMemory(TranslateInfo.pvSourceBits,
                                          TranslateInfo.pvTranslateBits,
                                          TranslateInfo.cjTranslateBits);
                        }
                        else
                        {
                            WARNING("IcmTranslateDIB():Input color != Output color\n");
                        }

                        LOCALFREE(TranslateInfo.pvTranslateBits);
                    }
                }

                if (TranslateInfo.TranslateType & TRANSLATE_HEADER)
                {
                    if (ppbmiNew)
                    {
                        *ppbmiNew  = TranslateInfo.TranslateBitmapInfo;
                    }
                    else
                    {
                        //
                        // Overwrite original (when input color and output color type is same)
                        //
                        if (TranslateInfo.SourceColorType == TranslateInfo.TranslateColorType)
                        {
                            RtlCopyMemory(TranslateInfo.pvSourceBits,
                                          TranslateInfo.pvTranslateBits,
                                          TranslateInfo.cjTranslateBits);
                        }
                        else
                        {
                            WARNING("IcmTranslateDIB():Input color != Output color\n");
                        }

                        LOCALFREE(TranslateInfo.TranslateBitmapInfo);
                    }

                    if (pcjbmiNew)
                    {
                        *pcjbmiNew = TranslateInfo.TranslateBitmapInfoSize;
                    }
                }
            }
            else
            {
                WARNING("IcmTranslateDIB():Fail TranslateBitmapBits\n");

                //
                // Free memory which allocated inside IcmGetTranslateInfo().
                //
                if (TranslateInfo.TranslateType & TRANSLATE_BITMAP)
                {
                    LOCALFREE(TranslateInfo.pvTranslateBits);
                }

                if (TranslateInfo.TranslateType & TRANSLATE_HEADER)
                {
                    LOCALFREE(TranslateInfo.TranslateBitmapInfo);
                }
            }
        }

TranslateDIB_Cleanup:

        //
        // Free temp transform and temp file
        //
        // Only delete hcmXform when it based on bitmap colorspace.
        //
        if (pBitmapColorSpace)
        {
            if (hcmXform)
            {
                IcmDeleteColorTransform(pCXform,FALSE);
            }

            IcmReleaseColorSpace(NULL,pBitmapColorSpace,FALSE);
        }
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* IcmGetFirstNonUsedColorTransform()
*
* History:
*
* Write it:
*   12-Mar-1998 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PCACHED_COLORTRANSFORM
IcmGetFirstNonUsedColorTransform(
    VOID
)
{
    PCACHED_COLORTRANSFORM pCXform = NULL;
    PLIST_ENTRY p;

    ICMAPI(("gdi32: IcmGetFirstNonUsedColorTransform\n"));

    ENTERCRITICALSECTION(&semColorTransformCache);

    p = ListCachedColorTransform.Flink;

    while(p != &ListCachedColorTransform)
    {
        pCXform = CONTAINING_RECORD(p,CACHED_COLORTRANSFORM,ListEntry);

        if (pCXform->cRef == 0)
        {
            ICMMSG(("IcmGetFirstNonUsedColorTransform():Find non-used color transform in cache !\n"));

            //
            // No one use this color transform at this moment.
            //
            break;
        }

        p = p->Flink;
        pCXform = NULL;
    }

    LEAVECRITICALSECTION(&semColorTransformCache);

    return (pCXform);
}

/******************************Public*Routine******************************\
* IcmGetColorTransform()
*
* History:
*
* Write it:
*   21-Apr-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PCACHED_COLORTRANSFORM
IcmGetColorTransform(
    HDC                hdcRequest,
    PCACHED_COLORSPACE pSource,
    PCACHED_COLORSPACE pDestination,
    PCACHED_COLORSPACE pTarget,
    BOOL               bNeedDeviceXform
)
{
    PCACHED_COLORTRANSFORM pCXform = NULL;
    PLIST_ENTRY p;

    ICMAPI(("gdi32: IcmGetColorTransform\n"));

    ENTERCRITICALSECTION(&semColorTransformCache);

    p = ListCachedColorTransform.Flink;

    while(p != &ListCachedColorTransform)
    {
        pCXform = CONTAINING_RECORD(p,CACHED_COLORTRANSFORM,ListEntry);

        if (IcmSameColorSpace(pSource,pCXform->SourceColorSpace) &&
            IcmSameColorSpace(pDestination,pCXform->DestinationColorSpace) &&
            IcmSameColorSpace(pTarget,pCXform->TargetColorSpace))
        {
            //
            // If callee needs device color tansform,
            // of course, we should return device color transform.
            //
            if ((bNeedDeviceXform ? 1 : 0) ==
                ((pCXform->flInfo & DEVICE_COLORTRANSFORM) ? 1 : 0))
            {
                //
                // if Cached color transform depends on specific DC, check it.
                //
                if ((pCXform->hdc == NULL) || (pCXform->hdc == hdcRequest))
                {
                    ICMMSG(("IcmGetColorTransform():Find in cache !\n"));

                    //
                    // Match !, use this color transform, increment ref. count
                    //
                    pCXform->cRef++;

                    break;
                }
            }
        }

        p = p->Flink;
        pCXform = NULL;
    }

    LEAVECRITICALSECTION(&semColorTransformCache);

    return (pCXform);
}

/******************************Public*Routine******************************\
* IcmCreateColorTransform
*
*   Decide whether to call the device driver or mscms.dll to delete a
*   color transform.
*
* Arguments:
*
*   hdc
*   pdcattr
*   pLogColorSpaceW
*
* Return Value:
*
*   handle of new transform
*
* History:
*
* Write it:
*   24-Jan-1996 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

PCACHED_COLORTRANSFORM
IcmCreateColorTransform(
    HDC                hdc,
    PDC_ATTR           pdcattr,
    PCACHED_COLORSPACE pInputColorSpace,
    DWORD              dwFlags
    )
{
    PCACHED_COLORTRANSFORM pCXform = NULL;
    PCACHED_COLORSPACE pSourceColorSpace = NULL;

    BOOL   bDCSourceColorSpace = (pInputColorSpace == NULL ? TRUE : FALSE);

    BOOL   bAnyNewColorSpace = FALSE;

    PGDI_ICMINFO pIcmInfo;

    ICMAPI(("gdi32: IcmCreateColorTransform\n"));

    ASSERTGDI(pdcattr != NULL,"IcmCreateColorTransform: pdcattr == NULL\n");

    //
    // If this is Lazy color correction case, the destination surface
    // will have image in source color space, so the color transform
    // is identical.
    //
    if (IS_ICM_LAZY_CORRECTION(pdcattr->lIcmMode))
    {
        return (IDENT_COLORTRANSFORM);
    }

    //
    // Load external ICM dlls.
    //
    LOAD_ICMDLL(NULL);

    //
    // Initialize ICMINFO
    //
    if ((pIcmInfo = GET_ICMINFO(pdcattr)) == NULL)
    {
        WARNING("gdi32: IcmCreateColorTransform: Can't init icm info\n");
        return(NULL);
    }

    if (bDCSourceColorSpace && (pIcmInfo->pSourceColorSpace == NULL))
    {
        //
        // If we haven't gotton DC source color space, get it there.
        //
        LOGCOLORSPACEW LogColorSpaceW;

        ICMMSG(("IcmCreateColorTransform(): Call getobject to get source color space in DC\n"));

        //
        // Filled with zero.
        //
        RtlZeroMemory(&LogColorSpaceW,sizeof(LOGCOLORSPACEW));

        //
        // Find ColorSpace from cache.
        //
        pSourceColorSpace = IcmGetColorSpaceByHandle(
                                (HGDIOBJ)hdc,
                                (HANDLE)pdcattr->hColorSpace,
                                &LogColorSpaceW,0);

        //
        // If we can not find from cache, but succeeded to obtain
        // valid logcolorspace from handle, create new one.
        //
        if ((pSourceColorSpace == NULL) &&
            (LogColorSpaceW.lcsSignature == LCS_SIGNATURE))
        {
            //
            // Create new cache.
            //
            pSourceColorSpace = IcmCreateColorSpaceByColorSpace(
                                    (HGDIOBJ)hdc,
                                    &LogColorSpaceW,
                                    NULL, 0);

            //
            // we are using new color space
            //
            bAnyNewColorSpace = TRUE;
        }

        //
        // And this is DC's color space, keep it for cache.
        //
        pIcmInfo->pSourceColorSpace = pSourceColorSpace;
    }
    else if (bDCSourceColorSpace)
    {
        ICMMSG(("IcmCreateColorTransform(): Use cached source color space in DC\n"));

        //
        // Get this from client cache !
        //
        pSourceColorSpace = pIcmInfo->pSourceColorSpace;
    }
    else
    {
        ICMMSG(("IcmCreateColorTransform(): Use given source color space\n"));

        //
        // Just use given color space.
        //
        pSourceColorSpace = pInputColorSpace;
    }

    if (pSourceColorSpace)
    {
        HANDLE hColorTransform = NULL;

        PCACHED_COLORSPACE pDestColorSpace   = pIcmInfo->pDestColorSpace;
        PCACHED_COLORSPACE pTargetColorSpace = NULL;

        //
        // if we are in proofing mode, consider target profile.
        //
        if (IS_ICM_PROOFING(pdcattr->lIcmMode))
        {
            pTargetColorSpace = pIcmInfo->pTargetColorSpace;
        }

        #if DBG_ICM
        //
        // Dump current color space for the DC.
        //
        if ((pSourceColorSpace->LogColorSpace.lcsFilename[0]) != UNICODE_NULL)
        {
            ICMMSG(("IcmCreateColorTransform(): Source Profile = %ws\n",
                     pSourceColorSpace->LogColorSpace.lcsFilename));
        }

        if ((pDestColorSpace) &&
            ((pDestColorSpace->LogColorSpace.lcsFilename[0]) != UNICODE_NULL))
        {
            ICMMSG(("IcmCreateColorTransform(): Destination Profile = %ws\n",
                     pDestColorSpace->LogColorSpace.lcsFilename));
        }

        if ((pTargetColorSpace) &&
            ((pTargetColorSpace->LogColorSpace.lcsFilename[0]) != UNICODE_NULL))
        {
            ICMMSG(("IcmCreateColorTransform(): Target Profile = %ws\n",
                     pTargetColorSpace->LogColorSpace.lcsFilename));
        }

        ICMMSG(("IcmCreateColorTransform(): Intent = %d\n",
                 pSourceColorSpace->ColorIntent));
        #endif // DBG

        //
        // At this moment, we have any source colorspace.
        //
        if (IcmSameColorSpace(pSourceColorSpace,pDestColorSpace))
        {
            if (pTargetColorSpace)
            {
                if (IcmSameColorSpace(pSourceColorSpace,pTargetColorSpace))
                {
                    ICMMSG(("IcmCreateColorTransform(): Src == Dest == Trg colorspace\n"));

                    //
                    // Source ColorSpace == Destination ColorSpace == Target ColorSpace
                    // No color transform needed.
                    //
                    return (IDENT_COLORTRANSFORM);
                }
            }
            else
            {
                ICMMSG(("IcmCreateColorTransform(): Src == Dest colorspace\n"));

                //
                // Source ColorSpace == Destination ColorSpace,
                // and there is no target profile.
                // That means we don't need translate color
                //
                return (IDENT_COLORTRANSFORM);
            }
        }

        //
        // We need to have proper colortransform to adjust color between each colorspace.
        //
        if (dwFlags & ICM_BACKWARD)
        {
            //
            // This is backward transform. (swap source and destination)
            //
            PCACHED_COLORSPACE pSwapColorSpace;
            pSwapColorSpace = pSourceColorSpace;
            pSourceColorSpace = pDestColorSpace;
            pDestColorSpace = pSwapColorSpace;
        }

        //
        // At this moment, at least, we should have Source and Destination color space.
        // And target color space is optional.
        //
        if (pDestColorSpace)
        {
            if (!bAnyNewColorSpace)
            {
                //
                // Find colortransform from cache
                //
                // if this is device ICM, hdc also should matched.
                //
                pCXform = IcmGetColorTransform(
                              hdc,
                              pSourceColorSpace,
                              pDestColorSpace,
                              pTargetColorSpace,
                              (IS_ICM_DEVICE(pdcattr->lIcmMode)));

                if (pCXform)
                {
                    return (pCXform);
                }
            }

            //
            // Allocate CACHED_COLORTRANSFORM
            //
            pCXform = LOCALALLOC(sizeof(CACHED_COLORTRANSFORM));

            if (pCXform)
            {
                ENTERCRITICALSECTION(&semColorSpaceCache);

                //
                // Make sure all color space has been realized
                //
                if (IcmRealizeColorProfile(pSourceColorSpace,TRUE) &&
                    IcmRealizeColorProfile(pDestColorSpace,TRUE) &&
                    IcmRealizeColorProfile(pTargetColorSpace,TRUE))
                {
                    //
                    // call ICM dll or device driver to create a color transform
                    //
                    if (IS_ICM_HOST(pdcattr->lIcmMode))
                    {
                        DWORD    ahIntents[3];
                        HPROFILE ahProfiles[3];
                        DWORD    chProfiles = 0;

                        ICMMSG(("Creating Host ICM Transform...\n"));

                        //
                        // Put source profile in first entry.
                        //
                        ahIntents[chProfiles]  = INTENT_RELATIVE_COLORIMETRIC;
                        ahProfiles[chProfiles] = pSourceColorSpace->hProfile;
                        chProfiles++;

                        ahIntents[chProfiles]  = pSourceColorSpace->ColorIntent;

                        //
                        // If target profile (proofing) is used, insert it
                        // between source and destination.
                        //
                        if (pTargetColorSpace)
                        {
                            ahProfiles[chProfiles] = pTargetColorSpace->hProfile;
                            chProfiles++;

                            ahIntents[chProfiles]  = INTENT_ABSOLUTE_COLORIMETRIC;
                        }

                        //
                        // Finally, set destination profile.
                        //
                        ahProfiles[chProfiles] = pDestColorSpace->hProfile;
                        chProfiles++;

                        //
                        // Call MSCMS to create color transform.
                        //
                        hColorTransform = (*fpCreateMultiProfileTransform)(
                                              ahProfiles, chProfiles,
                                              ahIntents, chProfiles,
                                              NORMAL_MODE | ENABLE_GAMUT_CHECKING,
                                              INDEX_DONT_CARE);
                    }
                    else if (IS_ICM_DEVICE(pdcattr->lIcmMode))
                    {
                        CLIENT_SIDE_FILEVIEW fvwSrcProfile;
                        CLIENT_SIDE_FILEVIEW fvwDstProfile;
                        CLIENT_SIDE_FILEVIEW fvwTrgProfile;

                        ICMMSG(("Creating Device ICM Transform...\n"));

                        //
                        // Invalidate FILEVIEW.
                        //
                        RtlZeroMemory(&fvwSrcProfile,sizeof(CLIENT_SIDE_FILEVIEW));
                        RtlZeroMemory(&fvwDstProfile,sizeof(CLIENT_SIDE_FILEVIEW));
                        RtlZeroMemory(&fvwTrgProfile,sizeof(CLIENT_SIDE_FILEVIEW));

                        //
                        // Map color profile(s) into memory.
                        //
                        if (pSourceColorSpace->ColorProfile.dwType == PROFILE_FILENAME)
                        {
                            if (!bMapFileUNICODEClideSide(
                                     (PWSTR)(pSourceColorSpace->ColorProfile.pProfileData),
                                     &fvwSrcProfile,FALSE))
                            {
                                WARNING("IcmCreateColorTransform(): Fail to map source profile\n");
                                goto IcmCreateColorTransform_Cleanup;
                            }
                        }
                        else if (pSourceColorSpace->ColorProfile.dwType == PROFILE_MEMBUFFER)
                        {
                            ICMMSG(("Source Profile is memory buffer\n"));

                            fvwSrcProfile.pvView = pSourceColorSpace->ColorProfile.pProfileData;
                            fvwSrcProfile.cjView = pSourceColorSpace->ColorProfile.cbDataSize;
                        }
                        else
                        {
                            WARNING("IcmCreateColorTransform():src profile type is not supported\n");
                            goto IcmCreateColorTransform_Cleanup;
                        }

                        if (pDestColorSpace->ColorProfile.dwType == PROFILE_FILENAME)
                        {
                            if (!bMapFileUNICODEClideSide(
                                     (PWSTR)(pDestColorSpace->ColorProfile.pProfileData),
                                     &fvwDstProfile,FALSE))
                            {
                                WARNING("IcmCreateColorTransform(): Fail to map destination profile\n");
                                goto IcmCreateColorTransform_Cleanup;
                            }
                        }
                        else if (pDestColorSpace->ColorProfile.dwType == PROFILE_MEMBUFFER)
                        {
                            ICMMSG(("Destination Profile is memory buffer\n"));

                            fvwDstProfile.pvView = pDestColorSpace->ColorProfile.pProfileData;
                            fvwDstProfile.cjView = pDestColorSpace->ColorProfile.cbDataSize;
                        }
                        else
                        {
                            WARNING("IcmCreateColorTransform():dst profile type is not supported\n");
                            goto IcmCreateColorTransform_Cleanup;
                        }

                        //
                        // Target color space is optional
                        //
                        if (pTargetColorSpace)
                        {
                            if (pTargetColorSpace->ColorProfile.dwType == PROFILE_FILENAME)
                            {
                                if (!bMapFileUNICODEClideSide(
                                         (PWSTR)(pTargetColorSpace->ColorProfile.pProfileData),
                                         &fvwTrgProfile,FALSE))
                                {
                                    WARNING("IcmCreateColorTransform(): Fail to map target profile\n");
                                    goto IcmCreateColorTransform_Cleanup;
                                }
                            }
                            else if (pTargetColorSpace->ColorProfile.dwType == PROFILE_MEMBUFFER)
                            {
                                ICMMSG(("Target Profile is memory buffer\n"));

                                fvwTrgProfile.pvView = pTargetColorSpace->ColorProfile.pProfileData;
                                fvwTrgProfile.cjView = pTargetColorSpace->ColorProfile.cbDataSize;
                            }
                            else
                            {
                                WARNING("IcmCreateColorTransform():trg profile type is not supported\n");
                                goto IcmCreateColorTransform_Cleanup;
                            }
                        }

                        //
                        // Call kernel.
                        //
                        hColorTransform = NtGdiCreateColorTransform(hdc,
                                                 &(pSourceColorSpace->LogColorSpace),
                                                 fvwSrcProfile.pvView, // Source Profile memory mapped file.
                                                 fvwSrcProfile.cjView,
                                                 fvwDstProfile.pvView, // Destination Profile memory mapped file.
                                                 fvwDstProfile.cjView,
                                                 fvwTrgProfile.pvView, // Target Profile memory mapped file.
                                                 fvwTrgProfile.cjView);

IcmCreateColorTransform_Cleanup:

                        //
                        // if we mapped file, unmap here.
                        //
                        if (fvwSrcProfile.hSection)
                        {
                            vUnmapFileClideSide(&fvwSrcProfile);
                        }

                        if (fvwDstProfile.hSection)
                        {
                            vUnmapFileClideSide(&fvwDstProfile);
                        }

                        if (fvwTrgProfile.hSection)
                        {
                            vUnmapFileClideSide(&fvwTrgProfile);
                        }
                    }
                }

                //
                // Once after create tranform, we don't need realized color space,
                // so just unrealize it.
                //
                IcmUnrealizeColorProfile(pSourceColorSpace);
                IcmUnrealizeColorProfile(pDestColorSpace);
                IcmUnrealizeColorProfile(pTargetColorSpace);

                LEAVECRITICALSECTION(&semColorSpaceCache);

                if (hColorTransform)
                {
                    BOOL bCacheable = TRUE;

                    //
                    // Initialize CACHED_COLORTRANSFORM with zero
                    //
                    RtlZeroMemory(pCXform,sizeof(CACHED_COLORTRANSFORM));

                    //
                    // Fill up CACHED_COLORTRANSFORM
                    //
                    pCXform->ColorTransform   = hColorTransform;
                    pCXform->SourceColorSpace = pSourceColorSpace;
                    pCXform->DestinationColorSpace = pDestColorSpace;
                    pCXform->TargetColorSpace = pTargetColorSpace;

                    if (IS_ICM_DEVICE(pdcattr->lIcmMode))
                    {
                        //
                        // if this is device colortransform, mark it and
                        // put DC in CACHED_COLORTRANSFORM strcuture
                        //
                        pCXform->flInfo |= DEVICE_COLORTRANSFORM;

                        //
                        // And device color transform is not cacheable.
                        //
                        bCacheable = FALSE;
                    }

                    ENTERCRITICALSECTION(&semColorSpaceCache);

                    //
                    // Increment transform ref. count in each color space.
                    //
                    if (pSourceColorSpace)
                    {
                        pSourceColorSpace->cRef++;

                        if (bCacheable)
                        {
                            //
                            // Check this color space is cacheable.
                            //
                            bCacheable &= IcmIsCacheable(pSourceColorSpace);
                        }
                    }

                    if (pDestColorSpace)
                    {
                        pDestColorSpace->cRef++;

                        if (bCacheable)
                        {
                            //
                            // Check this color space is cacheable.
                            //
                            bCacheable &= IcmIsCacheable(pDestColorSpace);
                        }
                    }

                    if (pTargetColorSpace)
                    {
                        pTargetColorSpace->cRef++;

                        if (bCacheable)
                        {
                            //
                            // Check this color space is cacheable.
                            //
                            bCacheable &= IcmIsCacheable(pTargetColorSpace);
                        }
                    }

                    LEAVECRITICALSECTION(&semColorSpaceCache);

                    //
                    // Initialize ref. counter.
                    //
                    pCXform->cRef = 1;

                    //
                    // Set cache-able bit, if possible.
                    //
                    if (bCacheable)
                    {
                        ICMMSG(("IcmCreateColorTransform(): ColorTransform is cacheable\n"));

                        pCXform->flInfo |= CACHEABLE_COLORTRANSFORM;
                    }
                    else
                    {
                        ICMMSG(("IcmCreateColorTransform(): ColorTransform is *NOT* cacheable\n"));

                        //
                        // If this is not cacheable, make sure this get deleted when DC gone.
                        //
                        pCXform->hdc = hdc;
                    }

                    //
                    // Insert new CACHED_COLORTRANSFORM to list
                    //
                    ENTERCRITICALSECTION(&semColorTransformCache);

                    InsertTailList(&ListCachedColorTransform,&(pCXform->ListEntry));
                    cCachedColorTransform++;

                    LEAVECRITICALSECTION(&semColorTransformCache);
                }
                else
                {
                    ICMWRN(("IcmCreateColorTransform(): Fail to create color transform\n"));

                    //
                    // Fail to get transform handle
                    //
                    LOCALFREE(pCXform);
                    pCXform = NULL;
                }
            }
            else
            {
                WARNING("IcmCreateColorTransform(): LOCALALLOC() failed\n");
            }
        }
        else
        {
            WARNING("IcmCreateColorTransform(): Dest color space is required\n");
        }
    }
    else
    {
        WARNING("IcmCreateColorTransform(): Fail to get source colorspace\n");
    }

    return(pCXform);
}

/******************************Public*Routine******************************\
* IcmTranslateCOLORREF
*
* Arguments:
*
*   hdc
*   pdcattr
*   ColorIn
*   *ColorOut
*
* Return Value:
*
*   Status
*
* History:
*
* Write it:
*   13-Feb-1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

BOOL
IcmTranslateCOLORREF(
    HDC      hdc,
    PDC_ATTR pdcattr,
    COLORREF ColorIn,
    COLORREF *ColorOut,
    DWORD    Flags
    )
{
    COLORREF OldColor = ColorIn;
    COLORREF NewColor;
    BOOL     bStatus = TRUE;

    ICMAPI(("gdi32: IcmTranslateCOLORREF\n"));

    ASSERTGDI(ColorOut != NULL,"IcmTranslateCOLORREF(): ColorOut == NULL\n");

    if (bNeedTranslateColor(pdcattr))
    {
        PGDI_ICMINFO pIcmInfo;

        LOAD_ICMDLL(FALSE);

        if ((pIcmInfo = GET_ICMINFO(pdcattr)) == NULL)
        {
            WARNING("gdi32: IcmTranslateCOLORREF: Can't init icm info\n");
            return((int)FALSE);
        }
        else
        {
            ULONG  SrcColorFormat;
            ULONG  DstColorFormat;
            HANDLE hcmXform = NULL;

            if (Flags & ICM_BACKWARD)
            {
                ICMMSG(("IcmTranslateCOLORREF():Backward Color transform\n"));

                //
                // AnyColorFormat ----> COLORREF (0x00bbggrr)
                //
                // Setup src & dest color type.
                //
                SrcColorFormat = pIcmInfo->pDestColorSpace->ColorFormat;
                DstColorFormat = BM_xBGRQUADS;

                //
                // If there is cached handle, use that.
                //
                if (pIcmInfo->pBackCXform)
                {
                    ICMMSG(("IcmTranslateCOLORREF():Use cached transform for Backward Color transform\n"));

                    hcmXform = pIcmInfo->pBackCXform->ColorTransform;
                }
                else
                {
                    PCACHED_COLORTRANSFORM pCXform;

                    ICMMSG(("IcmTranslateCOLORREF():Create cached transform for Backward Color transform\n"));

                    //
                    // Create backward color transform.
                    //
                    pCXform = IcmCreateColorTransform(hdc,
                                                      pdcattr,
                                                      NULL,
                                                      ICM_BACKWARD);

                    if ((pCXform == NULL) || (pCXform == IDENT_COLORTRANSFORM))
                    {
                        return (FALSE);
                    }

                    //
                    // Cache created color transform.
                    //
                    pIcmInfo->pBackCXform = pCXform;

                    //
                    // We will delete this cached transform, when we don't need this anymore.
                    //
                    hcmXform = pCXform->ColorTransform;
                }
            }
            else
            {
                //
                // COLORREF (0x00bbggrr) ----> AnyColorFormat
                //
                // Setup src & dest color type.
                //
                SrcColorFormat = BM_xBGRQUADS;
                DstColorFormat = pIcmInfo->pDestColorSpace->ColorFormat;

                //
                // Use foaward color transform.
                //
                hcmXform = GetColorTransformInDC(pdcattr);

                //
                // Source is COLORREF. then, Mask off gdi internal infomation.
                //
                // COLORREF = 0x00bbggrr;
                //
                OldColor &= 0x00ffffff;
            }

            if (hcmXform)
            {
                //
                // We handle COLORREF as 1x1 pixel bitmap data.
                //
                bStatus = (*fpTranslateBitmapBits)(hcmXform,
                                                   (PVOID)&OldColor,
                                                   SrcColorFormat,
                                                   1,1,
                                                   ALIGN_DWORD(sizeof(COLORREF)),
                                                   (PVOID)&NewColor,
                                                   DstColorFormat,
                                                      //
                                                   0, // We need pass 0 here, to let Kodak CMM works
                                                      //
                                                   NULL,0);
            }
            else
            {
                //
                // It seems hcmXform is invalid
                //
                ICMWRN(("IcmTranslateCOLORREF():hcmXform is invalid\n"));
                bStatus = FALSE;
            }

            if (bStatus)
            {
                if (Flags & ICM_BACKWARD)
                {
                    //
                    // OldColor: AnyColorFormat
                    // NewColor: COLORREF (0x00bbggrr)
                    //
                    // [NOTE:]
                    //  We could not restore flags.
                    //
                    *ColorOut = NewColor;
                }
                else
                {
                    //
                    // OldColor: COLORREF (0x00bbggrr)
                    // NewColor: AnyColorFormat
                    //
                    if (!(IS_32BITS_COLOR(pdcattr->lIcmMode)))
                    {
                        //
                        // The distination is not 32Bits Color, Restore assign and preserve flags.
                        //
                        *ColorOut = (NewColor & 0x00ffffff) | (ColorIn & 0xff000000);
                    }
                    else
                    {
                        //
                        // The distination is 32bits color.
                        //
                        // [NOTE:]
                        //  We will lost flags here.
                        //
                        *ColorOut = NewColor;

                        ICMMSG(("IcmTranslateCOLORREF(): 32 bits color !\n"));
                    }
                }
            }
            else
            {
                WARNING("IcmTranslateCOLORREF():Fail TranslateBitmapBits()\n");
            }
        }
    }
    else
    {
        //
        // Just return original color
        //
        *ColorOut = ColorIn;
        bStatus = TRUE;
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* IcmTranslateTRIVERTEX
*
*   Translate TRIVERTEX in place. No need for a general routine with
*   separate input and output pointers
*
* Arguments:
*
*   hdc        - hdc
*   pdcattr    - verified dcattr
*   pVertex    - input and output pointer
*
* Return Value:
*
*   Status
*
* History:
*
* Write it:
*   13-Feb-1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

BOOL
IcmTranslateTRIVERTEX(
    HDC         hdc,
    PDC_ATTR    pdcattr,
    PTRIVERTEX  pVertex,
    ULONG       nVertex
    )
{
    BOOL     bStatus = TRUE;

    ICMAPI(("gdi32: IcmTranslateTRIVERTEX\n"));

    ASSERTGDI(pVertex != NULL,"IcmTranslateTrivertex(): pVertex == NULL\n");

    if (bNeedTranslateColor(pdcattr))
    {
        PGDI_ICMINFO pIcmInfo;

        LOAD_ICMDLL(FALSE);

        if ((pIcmInfo = GET_ICMINFO(pdcattr)) == NULL)
        {
            WARNING("gdi32: IcmTranslateTRIVERTEX: Can't init icm info\n");
            return((int)FALSE);
        }
        else
        {
            //
            // Use foaward color transform.
            //
            if (GetColorTransformInDC(pdcattr))
            {
                //
                // use 16 bit per channel COLOR_RGB to translate trivertex
                //

                while (nVertex--)
                {
                    COLOR Color;

                    Color.rgb.red   = pVertex->Red;
                    Color.rgb.green = pVertex->Green;
                    Color.rgb.blue  = pVertex->Blue;

                    bStatus = (*fpTranslateColors)(
                                  (HANDLE)GetColorTransformInDC(pdcattr),
                                  &Color,
                                  1,
                                  COLOR_RGB,
                                  &Color,
                                  COLOR_RGB);

                    if (bStatus)
                    {
                        //
                        // assign output
                        //
                        pVertex->Red   = Color.rgb.red;
                        pVertex->Green = Color.rgb.green;
                        pVertex->Blue  = Color.rgb.blue;
                    }
                    else
                    {
                        WARNING("IcmTranslateTRIVERTEX():Fail TranslateColors()\n");
                        break;
                    }

                    pVertex++;
                }

            }
            else
            {
                //
                // It seems hcmXform is invalid
                //
                ICMWRN(("IcmTranslateTRIVERTEX():hcmXform is invalid\n"));
                bStatus = FALSE;
            }
        }
    }
    else
    {
        bStatus = TRUE;
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* IcmTranslatePaletteEntry
*
* Arguments:
*
*   hdc
*   pdcattr
*   ColorIn
*   pColorOut
*
* Return Value:
*
*   Status
*
* History:
*
* Rewrite it:
*   21-Jan-1997 -by- Hideyuki Nagase [hideyukn]
* Write it:
*    5-Aug-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
IcmTranslatePaletteEntry(
    HDC           hdc,
    PDC_ATTR      pdcattr,
    PALETTEENTRY *pColorIn,
    PALETTEENTRY *pColorOut,
    UINT          NumberOfEntries
    )
{
    BOOL bStatus = FALSE;

    ICMAPI(("gdi32: IcmTranslatePaletteEntry\n"));

    if (bNeedTranslateColor(pdcattr))
    {
        PGDI_ICMINFO pIcmInfo = GET_ICMINFO(pdcattr);

        if (pIcmInfo)
        {
            LOAD_ICMDLL(FALSE);

            //
            // We handle PALETTEENTRYs as NumberOfEntries x 1 pixels bitmap data.
            //
            bStatus = (*fpTranslateBitmapBits)((HANDLE)GetColorTransformInDC(pdcattr),
                                               (PVOID)pColorIn,
                                                             //
                                               BM_xBGRQUADS, // PALETTEENTRY is 0x00bbggrr format
                                                             //
                                               NumberOfEntries,1,
                                               ALIGN_DWORD(NumberOfEntries*sizeof(COLORREF)),
                                               (PVOID)pColorOut,
                                                                                       //
                                               pIcmInfo->pDestColorSpace->ColorFormat, // BM_xBGRQUADS or BM_KYMCQUADS
                                                                                       //
                                                  //
                                               0, // We need pass 0 here, to let Kodak CMM works
                                                  //
                                               NULL,0);

            if (!bStatus)
            {
                WARNING("IcmTranslatePaletteEntry():Fail TranslateBitmapBits()\n");
            }
        }
    }
    else
    {
        //
        // Just return original color.
        //
        RtlCopyMemory(pColorIn,pColorOut,sizeof(PALETTEENTRY) * NumberOfEntries);
        bStatus = TRUE;
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* IcmDeleteColorTransform
*
*   Decide whether to call the device driver or mscms.dll to delete a
*   color transform.
*
* Arguments:
*
* Return Value:
*
* History:
*
*     Mar.12.1998 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

BOOL
IcmDeleteColorTransform(
    PCACHED_COLORTRANSFORM pCXform,
    BOOL                   bForceDelete
    )
{
    BOOL bStatus = TRUE;

    ICMAPI(("gdi32: IcmDeleteColorTransform\n"));

    if (pCXform)
    {
        ENTERCRITICALSECTION(&semColorTransformCache);

        //
        // Decrement ref. counter.
        //
        pCXform->cRef--;

        if ((pCXform->cRef == 0) || bForceDelete)
        {
            PCACHED_COLORTRANSFORM pCXformVictim = NULL;

            if ((pCXform->flInfo & CACHEABLE_COLORTRANSFORM) && !bForceDelete)
            {
                if (cCachedColorTransform < MAX_COLORTRANSFORM_CACHE)
                {
                    ICMMSG(("IcmDeleteColorTransform(): colortransform can be cached !\n"));

                    //
                    // The color transform can be cached. so just keep it in list.
                    // And don't need to delete anything here.
                    //
                    pCXformVictim = NULL;
                }
                else
                {
                    //
                    // Find any cache can delete from list.
                    //
                    if ((pCXformVictim = IcmGetFirstNonUsedColorTransform()) == NULL)
                    {
                        ICMMSG(("IcmDeleteColorTransform(): colortransform cache is full, delete myself\n"));

                        //
                        // Nothing can be deleted from list, so delete myself.
                        //
                        pCXformVictim = pCXform;
                    }
                    else
                    {
                        ICMMSG(("IcmDeleteColorTransform(): colortransform cache is full, delete victim\n"));
                    }
                }
            }
            else
            {
                //
                // The colortransform can not be kept, or force delete, so just delete this.
                //
                pCXformVictim = pCXform;
            }

            if (pCXformVictim)
            {
                //
                // Unref color space count.
                //
                if (pCXformVictim->SourceColorSpace)
                {
                    IcmReleaseColorSpace(NULL,pCXformVictim->SourceColorSpace,FALSE);
                }

                if (pCXformVictim->DestinationColorSpace)
                {
                    IcmReleaseColorSpace(NULL,pCXformVictim->DestinationColorSpace,FALSE);
                }

                if (pCXformVictim->TargetColorSpace)
                {
                    IcmReleaseColorSpace(NULL,pCXformVictim->TargetColorSpace,FALSE);
                }

                //
                // Delete color transform
                //
                if (pCXformVictim->flInfo & DEVICE_COLORTRANSFORM)
                {
                    //
                    // call device driver to delete transform.
                    //
                    bStatus = NtGdiDeleteColorTransform(pCXformVictim->hdc,pCXformVictim->ColorTransform);
                }
                else
                {
                    //
                    // call color match dll to delete transform.
                    //
                    bStatus = (*fpDeleteColorTransform)(pCXformVictim->ColorTransform);
                }

                //
                // Remove from list
                //

                RemoveEntryList(&(pCXformVictim->ListEntry));
                cCachedColorTransform--;

                //
                // free CACHED_COLORTRANSFORM
                //
                LOCALFREE(pCXformVictim);
            }
        }

        LEAVECRITICALSECTION(&semColorTransformCache);
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* IcmDeleteDCColorTransforms
*
* Arguments:
*
* Return Value:
*
* History:
*
*    Feb.17.1997 Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL IcmDeleteDCColorTransforms(
    PGDI_ICMINFO pIcmInfo
    )
{
    ICMAPI(("gdi32: IcmDeleteDCColorTransforms\n"));

    ASSERTGDI(pIcmInfo != NULL,"IcmDeleteDCColorTransform():pIcmInfo == NULL\n");

    //
    // Delete transform selected in DC.
    //
    if (pIcmInfo->pCXform)
    {
        IcmDeleteColorTransform(pIcmInfo->pCXform,FALSE);
    }

    if (pIcmInfo->pBackCXform)
    {
        IcmDeleteColorTransform(pIcmInfo->pBackCXform,FALSE);
    }

    if (pIcmInfo->pProofCXform)
    {
        IcmDeleteColorTransform(pIcmInfo->pProofCXform,FALSE);
    }

    //
    // Invalidate colortransforms
    //
    pIcmInfo->pCXform = pIcmInfo->pBackCXform = pIcmInfo->pProofCXform = NULL;

    return (TRUE);
}

/******************************Public*Routine******************************\
* IcmDeleteCachedColorTransforms
*
* Arguments:
*
* Return Value:
*
* History:
*
*    May.06.1997 Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmDeleteCachedColorTransforms(
    HDC          hdc
    )
{
    PCACHED_COLORTRANSFORM pCXform = NULL;
    PLIST_ENTRY p;

    ICMAPI(("gdi32: IcmDeleteCachedColorTransforms\n"));

    ENTERCRITICALSECTION(&semColorTransformCache);

    p = ListCachedColorTransform.Flink;

    while(p != &ListCachedColorTransform)
    {
        //
        // Get cached color transform
        //
        pCXform = CONTAINING_RECORD(p,CACHED_COLORTRANSFORM,ListEntry);

        //
        // Let 'p' points next cell. (this prefer to be done BEFORE un-chain this cell)
        //
        p = p->Flink;

        //
        // Is this color transform is specific to this DC ?
        //
        if (pCXform->hdc == hdc)
        {
            ICMMSG(("IcmDeleteCachedColorTransform():Delete colortransform in cache !\n"));

            //
            // Delete color transform (this call will un-chain this cell)
            //
            IcmDeleteColorTransform(pCXform,TRUE);
        }
    }

    LEAVECRITICALSECTION(&semColorTransformCache);

    return (TRUE);
}

/******************************Public*Routine******************************\
* IcmIsCacheable
*
* Arguments:
*
* Return Value:
*
* History:
*
*    Mar.12.1998 Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmIsCacheable(
    PCACHED_COLORSPACE pColorSpace
)
{
    //
    // If this color space can not be cached, don't cache it.
    //
    if (pColorSpace->flInfo & NOT_CACHEABLE_COLORSPACE)
    {
        return (FALSE);
    }

    //
    // If this is any GDI object specific color space, also can not cache.
    //
    if (pColorSpace->hObj)
    {
        return (FALSE);
    }

    return (TRUE);
}

/******************************Public*Routine******************************\
* IcmReleaseCachedColorSpace
*
* Arguments:
*
* Return Value:
*
* History:
*
*    May.06.1997 Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmReleaseCachedColorSpace(
    HGDIOBJ  hObj
    )
{
    PCACHED_COLORSPACE pColorSpace = NULL;
    PLIST_ENTRY p;

    ICMAPI(("gdi32: IcmReleaseCachedColorSpace\n"));

    ENTERCRITICALSECTION(&semColorSpaceCache);

    p = ListCachedColorSpace.Flink;

    while(p != &ListCachedColorSpace)
    {
        //
        // Get cached color space
        //
        pColorSpace = CONTAINING_RECORD(p,CACHED_COLORSPACE,ListEntry);

        //
        // Let 'p' points next cell. (this prefer to be done BEFORE un-chain this cell)
        //
        p = p->Flink;

        //
        // Is this color transform is related to this DC ?
        //
        if (pColorSpace->hObj == hObj)
        {
            ICMMSG(("IcmReleaseCachedColorSpace():Delete colorspace in cache !\n"));

            //
            // Delete color space (this call will un-chain this cell)
            //
            IcmReleaseColorSpace(hObj,pColorSpace,TRUE);
        }
    }

    LEAVECRITICALSECTION(&semColorSpaceCache);

    return (TRUE);
}

/******************************Public*Routine******************************\
* IcmReleaseColorSpace
*
* Arguments:
*
* Return Value:
*
* History:
*
*    Feb.17.1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

VOID IcmReleaseColorSpace(
    HGDIOBJ            hObj,        /* Must be given if bForceDelete is TRUE */
    PCACHED_COLORSPACE pColorSpace,
    BOOL               bForceDelete
    )
{
    ICMAPI(("gdi32: IcmReleaseColorSpace\n"));

    if (pColorSpace)
    {
        ENTERCRITICALSECTION(&semColorSpaceCache);

        //
        // Decrement ref. counter.
        //
        pColorSpace->cRef--;

        //
        // If this profile associated with other GDI objects (driver, metafile or bitmap)
        // we won't delete until the object is deleted 
        //
        if (
            (pColorSpace->flInfo & HGDIOBJ_SPECIFIC_COLORSPACE)
                    &&
            (bForceDelete == FALSE)
           )
        {
            ICMWRN(("IcmReleaseColorSpace: Delay Delete for Metafile/Driver/Bitmap profile - %ws\n",\
                (pColorSpace->LogColorSpace.lcsFilename[0] ? \
                                   pColorSpace->LogColorSpace.lcsFilename : L"no profile")));
        }
        else
        {
            if ((pColorSpace->cRef == 0)      // No one uses this profile.
                         ||                   //     OR
                (bForceDelete && IsColorSpaceOwnedByGDIObject(pColorSpace,hObj))
                                              // DC or Owner GDI object is going to delete and
                                              // colorspace is designed for this GDI object.
               )
            {
                ICMMSG(("IcmReleaseColorSpace: Delete - %ws\n",    \
                      (pColorSpace->LogColorSpace.lcsFilename[0] ? \
                                       pColorSpace->LogColorSpace.lcsFilename : L"no profile")));

                if (pColorSpace->hProfile)
                {
                    IcmUnrealizeColorProfile(pColorSpace);
                }

                if (pColorSpace->flInfo & NEED_TO_FREE_PROFILE)
                {
                    ICMMSG(("IcmReleaseColorSpace: Free on memory profile\n"));

                    GlobalFree(pColorSpace->ColorProfile.pProfileData);
                }

                if (pColorSpace->flInfo & NEED_TO_DEL_PROFILE)
                {
                    ICMMSG(("IcmReleaseColorSpace: Delete TempFile - %ws\n",
                                    pColorSpace->LogColorSpace.lcsFilename));

                    DeleteFileW(pColorSpace->LogColorSpace.lcsFilename);
                }

                //
                // Remove from list
                //
                RemoveEntryList(&(pColorSpace->ListEntry));
                cCachedColorSpace--;

                //
                // Free colorspace.
                //
                LOCALFREE(pColorSpace);
            }
            else
            {
                ICMWRN(("IcmReleaseColorSpace: Still in USE - %ws\n",    \
                    (pColorSpace->LogColorSpace.lcsFilename[0] ? \
                                       pColorSpace->LogColorSpace.lcsFilename : L"no profile")));
            }
        }

        LEAVECRITICALSECTION(&semColorSpaceCache);
    }
}

/******************************Public*Routine******************************\
* IcmReleaseDCColorSpace
*
* Arguments:
*
* Return Value:
*
* History:
*
*    Feb.17.1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

VOID IcmReleaseDCColorSpace(
    PGDI_ICMINFO pIcmInfo,
    BOOL         bReleaseDC
    )
{
    INT i   = 0;
    HDC hdc = pIcmInfo->hdc;
    PCACHED_COLORSPACE DeleteColorSpaces[4];

    ICMAPI(("gdi32: IcmReleaseDCColorSpace\n"));

    ASSERTGDI(pIcmInfo != NULL,"IcmReleaseDCColorSpace pIcmInfo == NULL\n");

    //
    // Fill up the table to delete color color spaces.
    //
    DeleteColorSpaces[i++] = pIcmInfo->pSourceColorSpace;

    if (bReleaseDC)
    {
        ICMMSG(("IcmReleaseDCColorSpace: Force Delete\n"));

        //
        // If we are in "force deletion" mode, don't delete twice.
        // since if the color space owned by this HDC, and this DC is going to be
        // deleted, we will delete the color space forcely.
        //
        if (IsColorSpaceOwnedByGDIObject(pIcmInfo->pDestColorSpace,hdc) &&
            IcmSameColorSpace(pIcmInfo->pSourceColorSpace,pIcmInfo->pDestColorSpace))

        {
            ICMMSG(("IcmReleaseDCColorSpace: Force Delete - skip destination (same as source)\n"));
        }
        else
        {
            DeleteColorSpaces[i++] = pIcmInfo->pDestColorSpace;
        }

        if (IsColorSpaceOwnedByGDIObject(pIcmInfo->pTargetColorSpace,hdc) &&
            (IcmSameColorSpace(pIcmInfo->pSourceColorSpace,pIcmInfo->pTargetColorSpace) ||
             IcmSameColorSpace(pIcmInfo->pDestColorSpace,pIcmInfo->pTargetColorSpace)))
        {
            ICMMSG(("IcmReleaseDCColorSpace: Force Delete - skip target (same as source/dest)\n"));
        }
        else
        {
            DeleteColorSpaces[i++] = pIcmInfo->pTargetColorSpace;
        }
    }
    else
    {
        DeleteColorSpaces[i++] = pIcmInfo->pDestColorSpace;
        DeleteColorSpaces[i++] = pIcmInfo->pTargetColorSpace;
    }

    DeleteColorSpaces[i] = NULL;

    for (i = 0; DeleteColorSpaces[i] != NULL; i++)
    {
        IcmReleaseColorSpace((HGDIOBJ)hdc,DeleteColorSpaces[i],bReleaseDC);
    }

    pIcmInfo->pSourceColorSpace = NULL;
    pIcmInfo->pDestColorSpace   = NULL;
    pIcmInfo->pTargetColorSpace = NULL;
}

/******************************Public*Routine******************************\
* IcmInitIcmInfo()
*
* Arguments:
*
* Return Value:
*
* History:
*
*    Jan.31,1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

PGDI_ICMINFO
IcmInitIcmInfo(
    HDC      hdc,
    PDC_ATTR pdcattr
    )
{
    ICMAPI(("gdi32: IcmInitIcmInfo\n"));

    if (pdcattr == NULL)
    {
        WARNING("IcmInitIcmInfo():pdcattr is NULL\n");
        return (NULL);
    }

    if (pdcattr->pvICM == NULL)
    {
        PGDI_ICMINFO pIcmInfo = NULL;
        PLDC         pldc = (PLDC) pdcattr->pvLDC;
        BOOL         bDisplay = ((pldc && pldc->hSpooler) ? FALSE : TRUE);
        BOOL         bInsertList = bDisplay;

        ENTERCRITICALSECTION(&semListIcmInfo);

        //
        // First try to get ICMINFO from list. if not nothing can be re-used,
        // allocate new one.
        //
        if (bDisplay)
        {
            if ((pIcmInfo = IcmGetUnusedIcmInfo(hdc)) != NULL)
            {
                LIST_ENTRY ListEntry;

                //
                // Save ListEntry.
                //
                ListEntry = pIcmInfo->ListEntry;

                //
                // Init with zero.
                //
                RtlZeroMemory(pIcmInfo,sizeof(GDI_ICMINFO));

                //
                // Restore ListEntry
                //
                pIcmInfo->ListEntry = ListEntry;

                //
                // This ICMInfo already on list, don't need to insert.
                //
                bInsertList = FALSE;

                //
                // Mark this cell in on ListIcmInfo.
                //
                pIcmInfo->flInfo = ICM_ON_ICMINFO_LIST;

                ICMMSG(("IcmInitIcmInfo():Get unused ICMINFO structure = %p\n",pIcmInfo));
            }
        }

        if (pIcmInfo == NULL)
        {
            //
            // ICMINFO is not allocated, yet. then allocate it.
            //
            pIcmInfo = (PGDI_ICMINFO) LOCALALLOC(sizeof(GDI_ICMINFO));

            //
            // Init with zero.
            //
        if (pIcmInfo != NULL) {
        RtlZeroMemory(pIcmInfo,sizeof(GDI_ICMINFO));
        }

            ICMMSG(("IcmInitIcmInfo():Allocate new ICMINFO structure = %p\n",pIcmInfo));
        }

        if (pIcmInfo)
        {
            PDEVMODEW pDevModeW = NULL;

            //
            // Set owner information (hdc and pdcattr).
            //
            pIcmInfo->hdc      = hdc;
            pIcmInfo->pvdcattr = (PVOID) pdcattr;

            //
            // initialize LIST_ENTRY for saved icm info.
            //
            InitializeListHead(&(pIcmInfo->SavedIcmInfo));

            //
            // Default is LCS_DEFAULT_INTENT (aka LCS_GM_IMAGES)
            //
            pIcmInfo->dwDefaultIntent = LCS_DEFAULT_INTENT;

            //
            // If this is printer, set default Intent from devmode.
            //
            if (pldc && pldc->hSpooler)
            {
                PVOID pvFree = NULL;

                if (pldc->pDevMode)
                {
                    pDevModeW = pldc->pDevMode;
                }
                else
                {
                    pDevModeW = pdmwGetDefaultDevMode(pldc->hSpooler,NULL,&pvFree);
                }

                if (pDevModeW && (pDevModeW->dmFields & DM_ICMINTENT))
                {
                    DWORD dwIntent = pDevModeW->dmICMIntent;

                    ICMMSG(("IcmInitIcmInfo():Intent in devmode = %d\n",dwIntent));

                    //
                    // Convert intent for devmode to intent for LOGCOLORSPACE.
                    //
                    switch (dwIntent)
                    {
                    case DMICM_SATURATE:
                        pIcmInfo->dwDefaultIntent = LCS_GM_BUSINESS;
                        break;

                    case DMICM_COLORIMETRIC:
                        pIcmInfo->dwDefaultIntent = LCS_GM_GRAPHICS;
                        break;

                    case DMICM_ABS_COLORIMETRIC:
                        pIcmInfo->dwDefaultIntent = LCS_GM_ABS_COLORIMETRIC;
                        break;

                    case DMICM_CONTRAST:
                    default:
                        pIcmInfo->dwDefaultIntent = LCS_DEFAULT_INTENT;
                        break;
                    }
                }

                ICMMSG(("IcmInitIcmInfo():Default Intent = %d\n",pIcmInfo->dwDefaultIntent));

                //
                // Free devmode buffer.
                //
                if (pvFree)
                {
                    LOCALFREE(pvFree);
                }
            }

            //
            // Only ICMINFO for Display ICM put on to the list.
            //
            if (bInsertList)
            {
                //
                // This ICMINFO is newly allocated, so put this on list.
                //
                InsertTailList(&ListIcmInfo,&(pIcmInfo->ListEntry));

                //
                // Mark this cell in on ListIcmInfo.
                //
                pIcmInfo->flInfo |= ICM_ON_ICMINFO_LIST;
            }
        }

        //
        // Store pointer to ICMINFO to DC_ATTR.
        //
        pdcattr->pvICM = (PVOID) pIcmInfo;

        LEAVECRITICALSECTION(&semListIcmInfo);
    }

    return ((PGDI_ICMINFO)(pdcattr->pvICM));
}

/******************************Public*Routine******************************\
* IcmGetUnusedIcmInfo()
*
* ATTENTION: semListIcmInfo should be held by caller
*
* History:
*    17-Feb-1999 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PGDI_ICMINFO
IcmGetUnusedIcmInfo(
    HDC hdcNew
    )
{
    PLIST_ENTRY  p;

    PGDI_ICMINFO pInvalidIcmInfo = NULL;

    ICMAPI(("gdi32: IcmGetUnusedIcmInfo\n"));

    p = ListIcmInfo.Flink;

    //
    // First Loop - Find ICMINFO which has same hdc.
    //
    while(p != &ListIcmInfo)
    {
        pInvalidIcmInfo = CONTAINING_RECORD(p,GDI_ICMINFO,ListEntry);

        if (pInvalidIcmInfo->flInfo & ICM_IN_USE)
        {
            //
            // Skip this one, since it's under initializing.
            //
        }
        else
        {
            //
            // If this is same hdc, break.
            //
            if (pInvalidIcmInfo->hdc == hdcNew)
            {
                ICMMSG(("IcmGetUnusedIcmInfo(): ICMINFO at %p is invalid (same hdc)\n",
                         pInvalidIcmInfo));

                //
                // break loop.
                //
                break;
            }
        }

        //
        // Move on next.
        //
        p = p->Flink;
        pInvalidIcmInfo = NULL;
    }

    //
    // If not find in first loop, go to second loop.
    //
    if (pInvalidIcmInfo == NULL)
    {
        p = ListIcmInfo.Flink;

        //
        // Second Loop - Find unused ICMINFO.
        //
        while(p != &ListIcmInfo)
        {
            pInvalidIcmInfo = CONTAINING_RECORD(p,GDI_ICMINFO,ListEntry);

            if (pInvalidIcmInfo->flInfo & ICM_IN_USE)
            {
                //
                // Skip this one, since it's under initializing.
                //
            }
            else
            {
                PDC_ATTR pdcattr;

                //
                // Make sure this ICMINFO and hdc is stil effective.
                //

                //
                // Check below by calling PSHARED_GET_VALIDATE.
                //
                // 1) Is this DC handle ?
                // 2) Is this DC handle belonging to this process ?
                // 3) Does this DC has valid user mode DC_ATTR ?
                //
                PSHARED_GET_VALIDATE(pdcattr,pInvalidIcmInfo->hdc,DC_TYPE);

                if (pdcattr == NULL)
                {
                    ICMMSG(("IcmGetUnusedIcmInfo(): ICMINFO at %p is invalid (no pdcattr)\n",
                            pInvalidIcmInfo));

                    //
                    // break loop.
                    //
                    break;
                }
                else
                {
                    //
                    // Make sure the pointer points each other.
                    //
                    if ((pdcattr->pvICM != pInvalidIcmInfo          ) ||
                        (pdcattr        != pInvalidIcmInfo->pvdcattr))
                    {
                        ICMMSG(("IcmGetUnusedIcmInfo(): ICMINFO at %p is invalid (pointer mismatch)\n",
                                pInvalidIcmInfo));

                        //
                        // break loop.
                        //
                        break;
                    }
                }
            }

            //
            // Move on next.
            //
            p = p->Flink;
            pInvalidIcmInfo = NULL;
        }
    }

    if (pInvalidIcmInfo)
    {
        //
        // This ICMINFO is invalid, clean up this ICMINFO.
        //
        IcmCleanupIcmInfo(NULL,pInvalidIcmInfo);
    }
    else
    {
        ICMMSG(("IcmGetUnusedIcmInfo(): Unused ICMINFO is not in list\n"));
    }

    return (pInvalidIcmInfo);
}

/******************************Public*Routine******************************\
* IcmInitDC()
*
* Arguments:
*
* Return Value:
*
* History:
*
*    Jan.31.1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

BOOL
IcmInitLocalDC(
    HDC             hdc,
    HANDLE          hPrinter,
    CONST DEVMODEW *pdm,
    BOOL            bReset
    )
{
    BOOL         bRet = TRUE;
    PDC_ATTR     pdcattr;
    PLDC         pldc;

    ICMAPI(("gdi32: IcmInitLocalDC\n"));

    //
    // all these stuff is for only Printer.
    //

    if (hPrinter == NULL)
    {
        return (TRUE);
    }

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (!pdcattr)
    {
        WARNING("IcmInitDC(): pdcattr is NULL\n");
        return (FALSE);
    }

    if (bReset)
    {
        //
        // Release existing ICMINFO
        //
        if (ghICM || BEXIST_ICMINFO(pdcattr))
        {
            //
            // Delete ICM stuff in this DC.
            //
            IcmDeleteLocalDC(hdc,pdcattr,NULL);
        }
    }

    if (!pdm)
    {
        //
        // DEVMODE are not presented.
        //
        ICMMSG(("IcmInitLocalDC():DEVMODE is not presented\n"));
        return (TRUE);
    }

    //
    // Check pointer to DEVMODE is valid or not. Check validation until
    // DEVMODE.dmSize first, then check whole devmode size specified in dmSize.
    //
    if (IsBadReadPtr((CONST VOID *)pdm, offsetof(DEVMODEW,dmDriverExtra)) ||
        IsBadReadPtr((CONST VOID *)pdm, pdm->dmSize))
    {
        WARNING("IcmInitLocalDC(): Invalid pointer given as PDEVMODEW\n");
        return (FALSE);
    }

    //
    // Check color or mono mode.
    //
    if ((pdm->dmFields & DM_COLOR) && (pdm->dmColor == DMCOLOR_MONOCHROME))
    {
        //
        // This is monochrome mode, don't enable ICM as default.
        // And NEVER enable ICM.
        //
        ICMMSG(("IcmInitLocalDC():DEVMODE says MONOCHROME mode\n"));
        return (TRUE);
    }

    //                                                                           
    // ATTENTION: AFTER HERE, WE HAVE A DEVMODE WHICH POSSIBLE TO ENABLE ICM LATER OR NOW.
    //                                                                          

    //
    // Check DM fields
    //
    if (!(pdm->dmFields & DM_ICMMETHOD))
    {
        //
        // DEVMODE does not have ICMMETHOD.
        //
        ICMMSG(("IcmInitLocalDC():DEVMODE does not have ICMMETHOD\n"));
        return (TRUE);
    }

    //
    // NOTE:
    //
    // DEVMODEW structure.
    //
    // ... [omitted]
    // DWORD  dmDisplayFrequency;
    // #if(WINVER >= 0x0400)
    // DWORD  dmICMMethod;         // Windows 95 only / Windows NT 5.0
    // DWORD  dmICMIntent;         // Windows 95 only / Windows NT 5.0
    // DWORD  dmMediaType;         // Windows 95 only / Windows NT 5.0
    // ....
    //
    // Then DEVMODE structure should be larger than offset of dmMediaType
    // to access ICM stuff.
    //
    if (pdm->dmSize < offsetof(DEVMODEW,dmMediaType))
    {
        //
        // DEVMODE version might not matched.
        //
        WARNING("IcmInitLocalDC():DEVMODE is small\n");
        return (TRUE);
    }

    //
    // Check requested ICM mode.
    //
    switch (pdm->dmICMMethod)
    {
        case DMICMMETHOD_NONE:

            ICMMSG(("IcmInitDC(): ICM is disabled by default\n"));
            //
            // ICM is not enabled at this time.
            //
            // no more process is needed, just return here...
            //
            return (TRUE);

        case DMICMMETHOD_SYSTEM:

            ICMMSG(("IcmInitDC(): HOST ICM is requested\n"));
            //
            // ICM on Host, is requested.
            //
            SET_HOST_ICM_DEVMODE(pdcattr->lIcmMode);
            break;

        case DMICMMETHOD_DRIVER:
        case DMICMMETHOD_DEVICE:

            ICMMSG(("IcmInitDC(): DEVICE ICM is requested\n"));
            //
            // ICM on device, is requested.
            //
            SET_DEVICE_ICM_DEVMODE(pdcattr->lIcmMode);
            break;

        default:

            //
            // And we treat as Device ICM greater DMICMMETHOD_USER also.
            //
            if (pdm->dmICMMethod >= DMICMMETHOD_USER)
            {
                ICMMSG(("IcmInitDC(): DEVICE ICM (USER) is requested\n"));
                //
                // ICM on device (user defined), is requested.
                //
                SET_DEVICE_ICM_DEVMODE(pdcattr->lIcmMode);
            }
            else
            {
                ICMMSG(("IcmInitDC(): Unknown ICM mode\n"));
                //
                // return with error.
                //
                return (FALSE);
            }
            break;
    }

    //
    // Finally, enabled ICM.
    //
    bRet = SetICMMode(hdc,ICM_ON);

    if (!bRet)
    {
        ICMWRN(("InitLocalDC():FAILED to turn on ICM\n"));
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* IcmUpdateDCColorInfo()
*
* Arguments:
*
* Return Value:
*
* History:
*
*    May.28.1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

BOOL
IcmUpdateDCColorInfo(
    HDC      hdc,
    PDC_ATTR pdcattr
    )
{
    BOOL bRet = TRUE;
    PGDI_ICMINFO pIcmInfo;

    ICMAPI(("gdi32: IcmUpdateDCColorInfo\n"));

    pIcmInfo = GET_ICMINFO(pdcattr);

    ASSERTGDI(pIcmInfo != NULL,"IcmUpdateDCColorInfo(): pIcmInfo == NULL\n");

    //
    // Get the ColorSpace for this DC.
    //
    if (!IcmUpdateLocalDCColorSpace(hdc,pdcattr))
    {
        return (FALSE);
    }

    if ((pIcmInfo->pCXform == NULL) || (pdcattr->ulDirty_ & DIRTY_COLORTRANSFORM))
    {
        //
        // if TRUE in above, new color space (or no) has been selected,
        // then updates color transforms.
        //
        PCACHED_COLORTRANSFORM pCXform;

        //
        // At this momernt, we should have destination color space.
        // if this is null, we may fail to update color space in
        // IcmUpdateLocalDCColorSpace()
        //
        if (pIcmInfo->pDestColorSpace)
        {
            //
            // Create the color transform.
            //
            pCXform = IcmCreateColorTransform(hdc,pdcattr,NULL,ICM_FORWARD);

            if (pCXform)
            {
                if (pCXform == IDENT_COLORTRANSFORM)
                {
                    ICMMSG(("IcmUpdateDCInfo():Input & Output colorspace is same\n"));

                    //
                    // Input and Output colorspace is same, could be optimize.
                    //

                    //
                    // Set new color transform to DC.
                    //
                    IcmSelectColorTransform(hdc,pdcattr,NULL,
                                            bDeviceCalibrate(pIcmInfo->pDestColorSpace));

                    //
                    // Delete cached dirty color transform, if we have.
                    //
                    IcmDeleteDCColorTransforms(pIcmInfo);

                    //
                    // Set new color transform to ICMINFO.
                    //
                    pIcmInfo->pCXform = NULL;
                }
                else
                {
                    //
                    // Select the color transform to DC.
                    //
                    IcmSelectColorTransform(hdc,pdcattr,pCXform,
                                            bDeviceCalibrate(pCXform->DestinationColorSpace));

                    //
                    // Delete cached dirty color transform, if we have.
                    //
                    IcmDeleteDCColorTransforms(pIcmInfo);

                    //
                    // Set new color transform to ICMINFO.
                    //
                    pIcmInfo->pCXform = pCXform;

                    //
                    // Translate all DC objects to ICM colors. Must
                    // force brush/pens to be re-realized when used next
                    //
                    IcmTranslateColorObjects(hdc,pdcattr,TRUE);
                }
            }
            else
            {
                WARNING("IcmUpdateDCInfo():CreateColorTransform failed\n");

                //
                // Fail to create new transform, keep as is.
                //
                bRet = FALSE;
            }
        }
        else
        {
            WARNING("IcmUpdateDCInfo():No destination color space\n");
            bRet = FALSE;
        }
    }
    else
    {
        ICMMSG(("IcmUpdateDCColorInfo(): Color space does not change or not found\n"));
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* IcmUpdateLocalDCColorSpace
*
* Arguments:
*
* Return Value:
*
* History:
*
*    26.Feb.1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

BOOL
IcmUpdateLocalDCColorSpace(
    HDC      hdc,
    PDC_ATTR pdcattr
    )
{
    BOOL bRet = FALSE;
    BOOL bDirtyXform = FALSE;

    PLDC         pldc;
    PGDI_ICMINFO pIcmInfo;

    WCHAR ProfileName[MAX_PATH];
    DWORD dwColorSpaceFlag;

    PCACHED_COLORSPACE pNewColorSpace = NULL;

    ICMAPI(("gdi32: IcmUpdateLocalDCColorSpace\n"));

    ASSERTGDI(pdcattr != NULL,"IcmUpdateLocalDCColorSpace(): pdcattr == NULL\n");

    pldc = pdcattr->pvLDC;
    pIcmInfo = GET_ICMINFO(pdcattr);

    ASSERTGDI(pIcmInfo != NULL,"IcmUpdateLocalDCColorSpace(): pIcmInfo == NULL\n");

    //
    // if the DC already has a destination colorspace, then return TRUE
    //
    if ((pIcmInfo->pDestColorSpace == NULL) || (pdcattr->ulDirty_ & DIRTY_COLORSPACE))
    {
        HCOLORSPACE hDIBColorSpace;

        //
        // Invalidate profilename.
        //
        ProfileName[0]   = UNICODE_NULL;
        dwColorSpaceFlag = 0;
        hDIBColorSpace   = NULL;

        //
        // if the target DC has DIBSection. it will be DIBsection's color space
        // OR sRGB color space.
        //
        if (bDIBSectionSelected(pdcattr))
        {
            ENTERCRITICALSECTION(&semColorSpaceCache);

            if (pdcattr->dwDIBColorSpace)
            {
                ICMMSG(("IcmUpdateLocalDCColorSpace(): DIB section in DC (V4/V5)\n"));

                //
                // The DIB currently selected, has thier own color space.
                // This case happens when CreateDIBSection called with
                // BITMAPV4/V5 header.
                //
                pNewColorSpace = (PCACHED_COLORSPACE) pdcattr->dwDIBColorSpace;

                //
                // Inc. ref. count.
                //
                pNewColorSpace->cRef++;
            }
            else
            {
                ICMMSG(("IcmUpdateLocalDCColorSpace(): DIB section in DC (no color space)\n"));

                // [This is Win98 compatible behave]
                //
                // If the DIBitmap does not have any specific color space,
                // keep same color space as current DC.
                //
            }

            LEAVECRITICALSECTION(&semColorSpaceCache);
        }
        else if ((pdcattr->ulDirty_ & DC_PRIMARY_DISPLAY) &&
                 (PrimaryDisplayProfile[0] != UNICODE_NULL))
        {
            //
            // Use cached color profile.
            //
            lstrcpyW(ProfileName,PrimaryDisplayProfile);
        }
        else if (pIcmInfo->flInfo & ICM_VALID_DEFAULT_PROFILE)
        {
            //
            // Use cached color profile.
            //
            lstrcpyW(ProfileName,pIcmInfo->DefaultDstProfile);
        }
        else
        {
            int iRet;

            //
            // Still couldn't find yet ??. Ask MSCMS to find out profile. (go slow way)
            //
            iRet = IcmEnumColorProfile(hdc,IcmFindProfileCallBack,
                                       (LPARAM)ProfileName,FALSE,NULL,&dwColorSpaceFlag);

            //
            // if you could not find any profile for this DC, just use sRGB.
            //
            if ((iRet == -1) || (ProfileName[0] == UNICODE_NULL))
            {
                ULONG ulSize = MAX_PATH;

                if (!(*fpGetStandardColorSpaceProfileW)(NULL,LCS_sRGB,ProfileName,&ulSize))
                {
                    ICMMSG(("IcmUpdateLocalDCColorSpace():Fail to SCS(sRGB), use hardcode\n"));

                    //
                    // If error, use hardcoded profile name.
                    //
                    wcscpy(ProfileName,sRGB_PROFILENAME);
                }
            }

            //
            // Create cache for next usage
            //
            if ((pdcattr->ulDirty_ & DC_PRIMARY_DISPLAY) &&
                (PrimaryDisplayProfile[0] == UNICODE_NULL))
            {
                lstrcpyW(PrimaryDisplayProfile,ProfileName);
            }
            else // otherwise put it into default profile.
            {
                lstrcpyW(pIcmInfo->DefaultDstProfile,ProfileName);
                pIcmInfo->flInfo |= (ICM_VALID_DEFAULT_PROFILE|
                                     ICM_VALID_CURRENT_PROFILE);
            }
        }

        //
        // If default device profile could be found, associate it into this DC.
        //
        if ((ProfileName[0] != UNICODE_NULL) || (pNewColorSpace != NULL))
        {
        #if DBG
            if (ProfileName[0] != UNICODE_NULL)
            {
                ICMMSG(("IcmUpdateLocalDCColorSpace():Default Device Profile = %ws\n",ProfileName));
            }
        #endif

            //
            // try to find desired color space from cache.
            //
            if (pNewColorSpace == NULL)
            {
                pNewColorSpace = IcmGetColorSpaceByName(
                                     (HGDIOBJ)hdc,
                                     ProfileName,
                                     pIcmInfo->dwDefaultIntent,
                                     dwColorSpaceFlag);

                if (pNewColorSpace == NULL)
                {
                    //
                    // create new one.
                    //
                    pNewColorSpace = IcmCreateColorSpaceByName(
                                         (HGDIOBJ)hdc,
                                         ProfileName,
                                         pIcmInfo->dwDefaultIntent,
                                         dwColorSpaceFlag);
                }
            }

            if (pNewColorSpace)
            {
                //
                // Is this same destination color space as currently selected in DC ?
                //
                if (IcmSameColorSpace(pNewColorSpace,pIcmInfo->pDestColorSpace))
                {
                    ICMMSG(("IcmUpdateLocalDCColorSpace():Same color space is selected already\n"));

                    //
                    // Color space does NOT changed.
                    //
                    IcmReleaseColorSpace(NULL,pNewColorSpace,FALSE);

                    bRet = TRUE;
                }
                else
                {
                    //
                    // Notify new color format to kernel.
                    //
                    if (NtGdiSetIcmMode(hdc,ICM_CHECK_COLOR_MODE,pNewColorSpace->ColorFormat))
                    {
                        //
                        // if we have some color space currently selected, delete it.
                        //
                        if (pIcmInfo->pDestColorSpace)
                        {
                            IcmReleaseColorSpace(NULL,pIcmInfo->pDestColorSpace,FALSE);
                        }

                        //
                        // DC can accept this color space, Set new colorspace to destination.
                        //
                        pIcmInfo->pDestColorSpace = pNewColorSpace;

                        //
                        // Color space is changed. so color transform should be updated.
                        //
                        bDirtyXform = TRUE;

                        bRet = TRUE;
                    }
                    else
                    {
                        WARNING("ICM:Detected colorspace was not accepted by target DC\n");

                        //
                        // This color space does not match to this DC.
                        //
                        IcmReleaseColorSpace(NULL,pNewColorSpace,FALSE);
                    }
                }
            }
            else
            {
                WARNING("Failed IcmUpdateLocalDCColorSpace(), Failed to create new color space.\n");
            }
        }
        else
        {
            WARNING("Failed IcmUpdateLocalDCColorSpace(), no device profile is detected.\n");
        }
    }
    else
    {
        ICMMSG(("IcmUpdateLocalDCColoSpace(): Destination Color Space cache is valid\n"));

        bRet = TRUE;
    }

    //
    // [Only for Printer]
    //
    // If we haven't asked default source color profile for this Printer DC,
    // Now is the time to ask it. Only do this when apps does NOT specified
    // thier own color space.
    //
    if (bRet && pldc && pldc->hSpooler)
    {
        if ((pdcattr->hColorSpace == GetStockObject(PRIV_STOCK_COLORSPACE)) &&
            (pIcmInfo->hDefaultSrcColorSpace == NULL))
        {
            PDEVMODEW pDevModeW = NULL;
            PVOID     pvFree = NULL;
            BOOL      bRetSource = FALSE;

            //
            // Default is no DC specific source color space (= INVALID_COLORSPACE),
            // this also make sure we will not come here again.
            //
            pIcmInfo->hDefaultSrcColorSpace = INVALID_COLORSPACE;

            //
            // Invalidate profilename.
            //
            ProfileName[0]   = UNICODE_NULL;
            dwColorSpaceFlag = 0;

            if (pldc->pDevMode)
            {
                ICMMSG(("IcmUpdateLocalDCColorSpace():Cached DEVMODE used\n"));

                pDevModeW = pldc->pDevMode;
            }
            else
            {
                ICMMSG(("IcmUpdateLocalDCColorSpace():Get default DEVMODE\n"));

                pDevModeW = pdmwGetDefaultDevMode(pldc->hSpooler,NULL,&pvFree);
            }

            if (pDevModeW)
            {
                //
                // Get source color proflie from driver.
                //
                if (IcmAskDriverForColorProfile(pldc,QCP_SOURCEPROFILE,
                                                pDevModeW,ProfileName,&dwColorSpaceFlag) <= 0)
                {
                    //
                    // No source profile specified.
                    //
                    ProfileName[0] = UNICODE_NULL;
                }
            }

            //
            // Free devmode buffer.
            //
            if (pvFree)
            {
                LOCALFREE(pvFree);
            }

            //
            // 1) If default source profile could be found, or
            // 2) the default intent in devmode is different from LCS_DEFAULT_INTENT,
            //
            // we need to create new source color space, then associate it into this DC.
            //
            if ((ProfileName[0] != UNICODE_NULL) ||
                (pIcmInfo->dwDefaultIntent != LCS_DEFAULT_INTENT))
            {
                HCOLORSPACE hColorSpace = NULL;

                ICMMSG(("IcmUpdateLocalDCColorSpace():Default devmode Intent = %d\n",
                                                      pIcmInfo->dwDefaultIntent));

                //
                // If no color profile specified, use sRGB.
                //
                if (ProfileName[0] == UNICODE_NULL)
                {
                    ULONG ulSize = MAX_PATH;

                    if (!(*fpGetStandardColorSpaceProfileW)(NULL,LCS_sRGB,ProfileName,&ulSize))
                    {
                        ICMMSG(("IcmUpdateLocalDCColorSpace():Fail to SCS(sRGB), use hardcode\n"));

                        //
                        // If error, use hardcoded profile name.
                        //
                        wcscpy(ProfileName,sRGB_PROFILENAME);
                    }
                }

                ICMMSG(("IcmUpdateLocalDCColorSpace():Default Source Profile = %ws\n",ProfileName));

                //
                // Find from cache first.
                //
                pNewColorSpace = IcmGetColorSpaceByName(
                                     (HGDIOBJ)hdc,
                                     ProfileName,
                                     pIcmInfo->dwDefaultIntent,
                                     dwColorSpaceFlag);

                if (pNewColorSpace == NULL)
                {
                    //
                    // create new one.
                    //
                    pNewColorSpace = IcmCreateColorSpaceByName(
                                         (HGDIOBJ)hdc,
                                         ProfileName,
                                         pIcmInfo->dwDefaultIntent,
                                         dwColorSpaceFlag);
                }

                if (pNewColorSpace)
                {
                    //
                    // Create kernel-mode handle.
                    //
                    hColorSpace = CreateColorSpaceW(&(pNewColorSpace->LogColorSpace));

                    if (hColorSpace)
                    {
                        //
                        // Select this into DC.
                        //
                        if (IcmSetSourceColorSpace(hdc,hColorSpace,pNewColorSpace,0))
                        {
                            //
                            // IcmSetSourceColorSpace increments ref. count of colorspace.
                            // but we have done it by Icm[Get|Create]ColorSpaceByName, so
                            // decrement ref count of color space here.
                            //
                            IcmReleaseColorSpace(NULL,pNewColorSpace,FALSE);

                            //
                            // Keep these into ICMINFO.
                            //
                            pIcmInfo->hDefaultSrcColorSpace = hColorSpace;

                            //
                            // This color space should be deleted later.
                            //
                            pIcmInfo->flInfo |= ICM_DELETE_SOURCE_COLORSPACE;

                            //
                            // Source color space has been changed.
                            // (color transform is updated inside IcmSetSourceColorSpace().
                            //  so not nessesary to set bDirtyXfrom to TRUE)
                            //
                            bRetSource = TRUE;
                        }
                        else
                        {
                            WARNING("Failed IcmUpdateLocalDCColorSpace(), Failed to select new source color space.\n");
                        }
                    }
                    else
                    {
                        WARNING("Failed IcmUpdateLocalDCColorSpace(), Failed to create new source color space.\n");
                    }
                }
                else
                {
                    WARNING("Failed IcmUpdateLocalDCColorSpace(), Failed to create new source color space cache.\n");
                }

                if (!bRetSource)
                {
                    if (hColorSpace)
                    {
                        DeleteColorSpace(hColorSpace);
                    }

                    if (pNewColorSpace)
                    {
                        IcmReleaseColorSpace(NULL,pNewColorSpace,FALSE);
                    }
                }
            }
            else
            {
                ICMMSG(("IcmUpdateLocalDCColoSpace(): No default source color Space cache specified\n"));
            }
        }
    }

    //
    // Now color space is valid.
    //
    if (bRet)
    {
        pdcattr->ulDirty_ &= ~DIRTY_COLORSPACE;
    }

    if (bDirtyXform)
    {
        pdcattr->ulDirty_ |= DIRTY_COLORTRANSFORM;
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* IcmCleanupIcmInfo()
*
* ATTENTION: semListIcmInfo must be hold by caller
*
* History:
*   16-Feb-1999 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmCleanupIcmInfo(
    PDC_ATTR     pdcattr, // This can be NULL for clean up case.
    PGDI_ICMINFO pIcmInfo // This can *NOT* be NULL at any rate.
    )
{
    if (ghICM)
    {
        //
        // Delete Saved ICMINFO data (if present)
        //
        IcmRestoreDC(pdcattr,1,pIcmInfo);
    }

    //
    // If there is any default source profile (kernel-side), do something here.
    //
    if ((pIcmInfo->hDefaultSrcColorSpace != NULL) &&
        (pIcmInfo->hDefaultSrcColorSpace != INVALID_COLORSPACE))
    {
        ICMMSG(("IcmCleanupIcmInfo():Delete/Unselect default source color space\n"));

        if (pdcattr)
        {
            //
            // If it is currently selected into this DC, un-select it.
            //
            if (pIcmInfo->hDefaultSrcColorSpace == pdcattr->hColorSpace)
            {
                NtGdiSetColorSpace(pIcmInfo->hdc,GetStockObject(PRIV_STOCK_COLORSPACE));
            }
        }

        //
        // And it should be delete it.
        //
        if (pIcmInfo->flInfo & ICM_DELETE_SOURCE_COLORSPACE)
        {
            DeleteColorSpace(pIcmInfo->hDefaultSrcColorSpace);
        }

        pIcmInfo->hDefaultSrcColorSpace = NULL;
    }

    if (ghICM)
    {
        //
        // Delete Color transforms
        //
        IcmDeleteDCColorTransforms(pIcmInfo);

        //
        // Delete Cached color transform related to this DC.
        // (like device color transform)
        //
        IcmDeleteCachedColorTransforms(pIcmInfo->hdc);

        //
        // Free ICM colorspace datas.
        //
        IcmReleaseDCColorSpace(pIcmInfo,TRUE);

        //
        // Delete Cached color space which related to this DC.
        // (like color space in metafile)
        //
        IcmReleaseCachedColorSpace((HGDIOBJ)(pIcmInfo->hdc));
    }

    pIcmInfo->hdc      = NULL;
    pIcmInfo->pvdcattr = NULL;
    pIcmInfo->flInfo   = 0;

    return(TRUE);
}

/******************************Public*Routine******************************\
* IcmDeleteLocalDC()
*
* Arguments:
*
* Return Value:
*
* History:
*
*    Jan.31.1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmDeleteLocalDC(
    HDC          hdc,
    PDC_ATTR     pdcattr,
    PGDI_ICMINFO pIcmInfo
    )
{
    ICMAPI(("gdi32: IcmDeleteLocalDC\n"));

    ASSERTGDI(pdcattr != NULL,"IcmDeleteLocalDC():pdcattr == NULL\n");

    //
    // If callee does not provide ICMINFO, get it from pdcattr.
    //
    if (pIcmInfo == NULL)
    {
        pIcmInfo = GET_ICMINFO(pdcattr);
    }

    //
    // Invalidate current color tansform.
    //
    // (but the cache in ICMINFO is still valid, and will be delete
    //  inside IcmDeleteDCColorTransforms() called from IcmCleanupIcmInfo().)
    //
    IcmSelectColorTransform(hdc,pdcattr,NULL,TRUE);

    if (IS_ICM_INSIDEDC(pdcattr->lIcmMode))
    {
        //
        // Tell the kernel to disable ICM before delete client side data.
        //
        NtGdiSetIcmMode(hdc,ICM_SET_MODE,REQ_ICM_OFF);
    }

    //
    // Clean up ICMINFO.
    //
    if (pIcmInfo != NULL)
    {
        ENTERCRITICALSECTION(&semListIcmInfo);

        if (pIcmInfo->flInfo & ICM_ON_ICMINFO_LIST)
        {
            //
            // Remove this ICMINFO from list. (since this will be deleted).
            //
            RemoveEntryList(&(pIcmInfo->ListEntry));
        }

        //
        // Clean up ICMINFO.
        //
        IcmCleanupIcmInfo(pdcattr,pIcmInfo);

        //
        // Invalidate ICM info in DC_ATTR.
        //
        pdcattr->pvICM = NULL;

        LEAVECRITICALSECTION(&semListIcmInfo);

        //
        // Free ICM structure.
        //
        LOCALFREE(pIcmInfo);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL IcmSelectColorTransform (HDC, PDC_ATTR, PCACHED_COLORTRANSFORM)
*
* History:
*  23-Sep-1997 -by-  Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

BOOL
IcmSelectColorTransform(
    HDC                    hdc,
    PDC_ATTR               pdcattr,
    PCACHED_COLORTRANSFORM pCXform,
    BOOL                   bDeviceCalibrate)
{
    if (pCXform)
    {
        BMFORMAT ColorFormat = pCXform->DestinationColorSpace->ColorFormat;

        // LATER :
        //
        // if (GET_COLORTYPE(pdcattr->lIcmMode) != IcmConvertColorFormat(ColorFormat))
        //
        if (TRUE)
        {
            if (!NtGdiSetIcmMode(hdc,ICM_SET_COLOR_MODE,ColorFormat))
            {
                //
                // The transform color format is not accepted by DC.
                //
                return (FALSE);
            }
        }

        //
        // Select into the color transform to DC_ATTR.
        //
        pdcattr->hcmXform = pCXform->ColorTransform;
    }
    else
    {
        //
        // If curent color type is not RGB, call kernel to reset.
        //
        if (GET_COLORTYPE(pdcattr->lIcmMode) != DC_ICM_RGB_COLOR)
        {
            //
            // Reset current color mode to RGB (default).
            //
            NtGdiSetIcmMode(hdc,ICM_SET_COLOR_MODE,BM_xBGRQUADS);
        }

        //
        // Select null-color transfrom into the DC_ATTR.
        //
        pdcattr->hcmXform = NULL;
    }

    //
    // If device calibration mode need to updated, call kernel to update it.
    //

    if ((bDeviceCalibrate ? 1 : 0) !=
        (IS_ICM_DEVICE_CALIBRATE(pdcattr->lIcmMode) ? 1 : 0))
    {
        NtGdiSetIcmMode(hdc,ICM_SET_CALIBRATE_MODE,bDeviceCalibrate);
    }

    //
    // Remove dirty transform flag.
    //
    pdcattr->ulDirty_ &= ~DIRTY_COLORTRANSFORM;

    return(TRUE);
}

/******************************Public*Routine******************************\
* HBRUSH IcmSelectBrush (HDC hdc, HBRUSH hbrush)
*
* History:
*  04-June-1995 -by-  Lingyun Wang [lingyunW]
* Wrote it.
\**************************************************************************/

HBRUSH
IcmSelectBrush (
    HDC      hdc,
    PDC_ATTR pdcattr,
    HBRUSH   hbrushNew)
{
    HBRUSH hbrushOld = pdcattr->hbrush;

    ICMAPI(("gdi32: IcmSelectBrush\n"));

    //
    // Mark brush as dirty, select new brush in dcattr.
    // Color translation may fail, but still select brush
    //
    pdcattr->ulDirty_ |= DC_BRUSH_DIRTY;
    pdcattr->hbrush = hbrushNew;

    if (bNeedTranslateColor(pdcattr))
    {
        IcmTranslateBrushColor(hdc,pdcattr,hbrushNew);
    }

    return (hbrushOld);
}

/******************************Public*Routine******************************\
* HBRUSH IcmTranslateBrushColor(HDC hdc, PDC_ATTR pdcattr, HBRUSH hbrush)
*
* History:
*  10-Apr-1997 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

BOOL
IcmTranslateBrushColor(
    HDC      hdc,
    PDC_ATTR pdcattr,
    HBRUSH   hbrush)
{
    BOOL       bStatus = FALSE;
    COLORREF   OldColor;
    COLORREF   NewColor;
    PBRUSHATTR pbra;

    //
    // Invalidate BRUSH_TRANSLATED
    //
    pdcattr->ulDirty_ &= ~ICM_BRUSH_TRANSLATED;

    PSHARED_GET_VALIDATE(pbra,hbrush,BRUSH_TYPE);

    if (pbra)
    {
        //
        // translate to new icm mode if not paletteindex
        //
        OldColor = pbra->lbColor;

        if (!(OldColor & 0x01000000))
        {
            bStatus = IcmTranslateCOLORREF(hdc,
                                           pdcattr,
                                           OldColor,
                                           &NewColor,
                                           ICM_FORWARD);
            if (bStatus)
            {
                pdcattr->IcmBrushColor = NewColor;
            }
            else
            {
                pdcattr->IcmBrushColor = OldColor;
            }
        }
        else
        {
            pdcattr->IcmBrushColor = OldColor;
        }

        //
        // Somehow, IcmBrushColor is initialized.
        //
        pdcattr->ulDirty_ |= ICM_BRUSH_TRANSLATED;
    }
    else
    {
        LOGBRUSH lbrush;

        //
        // stock brush or bitmap/hatch/dib brush
        //
        if(GetObjectW(hbrush,sizeof(LOGBRUSH),&lbrush))
        {
            if ((lbrush.lbStyle == BS_SOLID) || (lbrush.lbStyle == BS_HATCHED))
            {
                //
                // try to translate color
                //
                OldColor = lbrush.lbColor;

                if (!(OldColor & 0x01000000))
                {
                    bStatus = IcmTranslateCOLORREF(hdc,
                                                   pdcattr,
                                                   OldColor,
                                                   &NewColor,
                                                   ICM_FORWARD);

                    if (bStatus)
                    {
                        pdcattr->IcmBrushColor = NewColor;
                    }
                    else
                    {
                        pdcattr->IcmBrushColor = OldColor;
                    }
                }
                else
                {
                    pdcattr->IcmBrushColor = OldColor;
                }

                //
                // IcmBrushColor is initialized.
                //
                pdcattr->ulDirty_ |= ICM_BRUSH_TRANSLATED;
            }
            else if (lbrush.lbStyle == BS_DIBPATTERN)
            {
                PBITMAPINFO pbmiDIB;

                //
                // Allocate temorary bitmap info header to get brush bitmap
                //
                pbmiDIB = (PBITMAPINFO)LOCALALLOC(sizeof(BITMAPINFO)+((256-1)*sizeof(RGBQUAD)));

                if (pbmiDIB)
                {
                    ULONG iColorUsage;
                    BOOL  bAlreadyTran;
                    BOOL  bStatus;

                    PVOID pvBits = NULL;
                    ULONG cjBits = 0;

                    //
                    // Get brush bitmap information, colortype, size, etc.
                    //
                    bStatus = NtGdiIcmBrushInfo(hdc,
                                                hbrush,
                                                pbmiDIB,
                                                pvBits,
                                                &cjBits,
                                                &iColorUsage,
                                                &bAlreadyTran,
                                                IcmQueryBrush);

                    if (bStatus)
                    {
                        if ((iColorUsage == DIB_RGB_COLORS) &&
                            (!bAlreadyTran) && (cjBits))
                        {
                            pvBits = (PVOID) LOCALALLOC(cjBits);

                            if (pvBits)
                            {
                                //
                                // Get brush bitmap bits.
                                //
                                bStatus = NtGdiIcmBrushInfo(hdc,
                                                            hbrush,
                                                            pbmiDIB,
                                                            pvBits,
                                                            &cjBits,
                                                            NULL,
                                                            NULL,
                                                            IcmQueryBrush);

                                if (bStatus)
                                {
                                    //
                                    // IcmTranslateDIB may create new copy of bitmap bits and/or
                                    // bitmap info header, if nessesary.
                                    //
                                    PVOID       pvBitsNew = NULL;
                                    PBITMAPINFO pbmiDIBNew = NULL;

                                    bStatus = IcmTranslateDIB(hdc,
                                                              pdcattr,
                                                              cjBits,
                                                              pvBits,
                                                              &pvBitsNew,
                                                              pbmiDIB,
                                                              &pbmiDIBNew,
                                                              NULL,
                                                              (DWORD)-1,
                                                              iColorUsage,
                                                              ICM_FORWARD,
                                                              NULL,NULL);

                                    if (bStatus)
                                    {
                                        if (pvBitsNew != NULL)
                                        {
                                            //
                                            // IcmTranslateDIB creates new bitmap buffer, then
                                            // free original buffer and set new one.
                                            //
                                            LOCALFREE(pvBits);
                                            pvBits = pvBitsNew;
                                        }

                                        if (pbmiDIBNew != NULL)
                                        {
                                            //
                                            // If bitmapInfo header is updated, use new one.
                                            // And, need to compute bitmap bits size based
                                            // on new bitmap header.
                                            //
                                            LOCALFREE(pbmiDIB);
                                            pbmiDIB = pbmiDIBNew;

                                            //
                                            // Calculate bitmap bits size based on BITMAPINFO and nNumScans
                                            //
                                            cjBits = cjBitmapBitsSize(pbmiDIB);
                                        }

                                        //
                                        // Set ICM-translated DIB into brush
                                        //
                                        bStatus = NtGdiIcmBrushInfo(hdc,
                                                                    hbrush,
                                                                    pbmiDIB,
                                                                    pvBits,
                                                                    &cjBits,
                                                                    NULL,
                                                                    NULL,
                                                                    IcmSetBrush);

                                        if (bStatus)
                                        {
                                            //
                                            // The color is translated.
                                            //
                                            bAlreadyTran = TRUE;
                                        }
                                        else
                                        {
                                            WARNING("IcmSelectBrush():NtGdiIcmBrushInfo(SET) Failed\n");
                                        }
                                    }
                                    else
                                    {
                                        WARNING("IcmSelectBrush():IcmTranslateDIB() Failed\n");
                                    }
                                }
                                else
                                {
                                    WARNING("IcmSelectBrush():NtGdiIcmBrushInfo(GET) Failed\n");
                                }

                                LOCALFREE(pvBits);
                            }
                            else
                            {
                                WARNING("IcmSelectBrush(): LOCALALLOC(pvBits) failed\n");
                            }
                        }

                        if (bAlreadyTran)
                        {
                            //
                            // Eventually, IcmBrushColor is initialized.
                            //
                            pdcattr->ulDirty_ |= ICM_BRUSH_TRANSLATED;
                        }
                    }
                    else
                    {
                        ICMWRN(("IcmSelectBrush(): Fail to get brush bitmap size or bitmap is DIB_PAL_COLORS\n"));
                    }

                    LOCALFREE(pbmiDIB);
                }
                else
                {
                    WARNING("IcmSelectBrush(): LOCALALLOC(pbmi) failed\n");
                }
            }
            else
            {
                ICMMSG(("IcmSelectBrush(): ICM will not done for this style - %d\n",lbrush.lbStyle));
            }
        }
        else
        {
            WARNING("IcmSelectBrush(): GetObject failed on hbrush\n");
            pdcattr->IcmBrushColor = CLR_INVALID;
        }
    }

    return (bStatus);
}

/******************************Public*Routine******************************\
* IcmSelectPen()
*
* History:
*
* Wrote it:
*  31-Jul-1996 -by- Mark Enstrom [marke]
\**************************************************************************/

HPEN
IcmSelectPen(
    HDC      hdc,
    PDC_ATTR pdcattr,
    HPEN     hpenNew
    )
{
    HPEN     hpenOld = pdcattr->hpen;

    ICMAPI(("gdi32: IcmSelectPen\n"));

    pdcattr->ulDirty_ |= DC_PEN_DIRTY;
    pdcattr->hpen = hpenNew;

    if (bNeedTranslateColor(pdcattr))
    {
        IcmTranslatePenColor(hdc,pdcattr,hpenNew);
    }

    return (hpenOld);
}

/******************************Public*Routine******************************\
* BOOL IcmTranslatePenColor(HDC hdc, PDC_ATTR pdcattr, HBRUSH hbrush)
*
* History:
*  10-Apr-1997 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

BOOL
IcmTranslatePenColor(
    HDC      hdc,
    PDC_ATTR pdcattr,
    HPEN     hpen
    )
{
    BOOL     bStatus = FALSE;
    COLORREF OldColor;
    COLORREF NewColor;
    PBRUSHATTR pbra;

    //
    // Invalidate PEN_TRANSLATED
    //
    pdcattr->ulDirty_ &= ~ICM_PEN_TRANSLATED;

    PSHARED_GET_VALIDATE(pbra,hpen,BRUSH_TYPE);

    if (pbra)
    {
        OldColor = pbra->lbColor;

        //
        // translate to new icm mode if not paletteindex
        //
        if (!(OldColor & 0x01000000))
        {
            bStatus = IcmTranslateCOLORREF(hdc,
                                           pdcattr,
                                           OldColor,
                                           &NewColor,
                                           ICM_FORWARD);

            if (bStatus)
            {
                pdcattr->IcmPenColor = NewColor;
            }
            else
            {
                pdcattr->IcmPenColor = OldColor;
            }
        }
        else
        {
            pdcattr->IcmPenColor = OldColor;
        }

        //
        // IcmPenColor is initialized.
        //
        pdcattr->ulDirty_ |= ICM_PEN_TRANSLATED;
    }
    else
    {
        LOGPEN logpen;

        //
        // stock brush or bitmap/hatch/dib brush
        //
        if(GetObjectW(hpen,sizeof(LOGPEN),&logpen))
        {
            if (logpen.lopnStyle != PS_NULL)
            {
                //
                // try to translate color
                //
                OldColor = logpen.lopnColor;

                if (!(OldColor & 0x01000000))
                {
                    bStatus = IcmTranslateCOLORREF(hdc,
                                                   pdcattr,
                                                   OldColor,
                                                   &NewColor,
                                                   ICM_FORWARD);

                    if (bStatus)
                    {
                        pdcattr->IcmPenColor = NewColor;
                    }
                    else
                    {
                        pdcattr->IcmPenColor = OldColor;
                    }
                }
                else
                {
                    pdcattr->IcmPenColor = OldColor;
                }

                //
                // IcmPenColor is initialized.
                //
                pdcattr->ulDirty_ |= ICM_PEN_TRANSLATED;
            }
            else
            {
                ICMMSG(("IcmSelectPen():Pen style is PS_NULL\n"));
                pdcattr->IcmPenColor = CLR_INVALID;
            }
        }
        else
        {
            WARNING("GetObject failed on hbrush\n");
            pdcattr->IcmPenColor = CLR_INVALID;
        }
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* IcmSelectExtPen()
*
* History:
*
* Wrote it:
*  11-Mar-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

HPEN
IcmSelectExtPen(
    HDC      hdc,
    PDC_ATTR pdcattr,
    HPEN     hpenNew
    )
{
    HPEN     hpenOld;

    ICMAPI(("gdi32: IcmSelectExtPen\n"));

    //
    // Invalidate PEN_TRANSLATED
    //
    pdcattr->ulDirty_ &= ~ICM_PEN_TRANSLATED;

    //
    // Call kernel to select this object.
    //
    hpenOld = NtGdiSelectPen(hdc,hpenNew);

    if (hpenOld && bNeedTranslateColor(pdcattr))
    {
        IcmTranslateExtPenColor(hdc,pdcattr,hpenNew);
    }

    return (hpenOld);
}

/******************************Public*Routine******************************\
* BOOL IcmTranslateExtPenColor(HDC hdc, PDC_ATTR pdcattr, HBRUSH hbrush)
*
* History:
*  10-Apr-1997 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

BOOL
IcmTranslateExtPenColor(
    HDC      hdc,
    PDC_ATTR pdcattr,
    HPEN     hpen
    )
{
    BOOL     bStatus = FALSE;
    COLORREF OldColor;
    COLORREF NewColor;

    EXTLOGPEN logpenLocal;
    EXTLOGPEN *plogpen = &logpenLocal;

    if (!GetObjectW(hpen,sizeof(EXTLOGPEN),plogpen))
    {
        ULONG cbNeeded;

        //
        // It might be PS_USERSTYLE (go slow way...)
        //
        cbNeeded = GetObjectW(hpen,0,NULL);

        if (cbNeeded)
        {
            plogpen = LOCALALLOC(cbNeeded);

            if (plogpen)
            {
                if (!GetObjectW(hpen,cbNeeded,plogpen))
                {
                    LOCALFREE(plogpen);
                    plogpen = NULL;
                }
            }
        }
        else
        {
            plogpen = NULL;
        }
    }

    if (plogpen)
    {
        if ((plogpen->elpBrushStyle == BS_SOLID) || (plogpen->elpBrushStyle == BS_HATCHED))
        {
            ICMMSG(("IcmSelectExtPen:BS_SOLID or BS_HATCHED\n"));

            //
            // try to translate color
            //
            OldColor = plogpen->elpColor;

            if (!(OldColor & 0x01000000))
            {
                bStatus = IcmTranslateCOLORREF(hdc,
                                               pdcattr,
                                               OldColor,
                                               &NewColor,
                                               ICM_FORWARD);

                if (bStatus)
                {
                    pdcattr->IcmPenColor = NewColor;
                }
                else
                {
                    pdcattr->IcmPenColor = OldColor;
                }
            }
            else
            {
                pdcattr->IcmPenColor = OldColor;
            }

            //
            // Somehow, IcmPenColor is initialized.
            //
            pdcattr->ulDirty_ |= ICM_PEN_TRANSLATED;
        }
        else if ((plogpen->elpBrushStyle == BS_DIBPATTERN) || (plogpen->elpBrushStyle == BS_DIBPATTERNPT))
        {
            PBITMAPINFO pbmiDIB;

            ICMMSG(("IcmSelectExtPen:BS_DIBPATTERN or BS_DIBPATTERNPT\n"));

            //
            // Allocate temorary bitmap info header to get brush bitmap
            //
            pbmiDIB = (PBITMAPINFO)LOCALALLOC(sizeof(BITMAPINFO)+((256-1)*sizeof(RGBQUAD)));

            if (pbmiDIB)
            {
                ULONG iColorUsage;
                BOOL  bAlreadyTran;

                PVOID pvBits = NULL;
                ULONG cjBits = 0;

                //
                // Get brush bitmap information, colortype, size, etc.
                //
                bStatus = NtGdiIcmBrushInfo(hdc,
                                            (HBRUSH)hpen,
                                            pbmiDIB,
                                            pvBits,
                                            &cjBits,
                                            &iColorUsage,
                                            &bAlreadyTran,
                                            IcmQueryBrush);

                if (bStatus)
                {
                    if ((iColorUsage == DIB_RGB_COLORS) &&
                        (!bAlreadyTran) &&
                        (cjBits))
                    {
                        pvBits = (PVOID) LOCALALLOC(cjBits);

                        if (pvBits)
                        {
                            //
                            // Get brush bitmap bits.
                            //
                            bStatus = NtGdiIcmBrushInfo(hdc,
                                                        (HBRUSH)hpen,
                                                        pbmiDIB,
                                                        pvBits,
                                                        &cjBits,
                                                        NULL,
                                                        NULL,
                                                        IcmQueryBrush);

                            if (bStatus)
                            {
                                //
                                // must make a copy of the DIB data
                                //
                                DWORD dwNumScan = ABS(pbmiDIB->bmiHeader.biHeight);
                                ULONG nColors   = pbmiDIB->bmiHeader.biWidth *
                                                  dwNumScan * (pbmiDIB->bmiHeader.biBitCount/8);

                                //
                                // IcmTranslateDIB may create new copy of bitmap bits and/or
                                // bitmap info header, if nessesary.
                                //
                                PVOID       pvBitsNew = NULL;
                                PBITMAPINFO pbmiDIBNew = NULL;

                                bStatus = IcmTranslateDIB(hdc,
                                                          pdcattr,
                                                          nColors,
                                                          pvBits,
                                                          &pvBitsNew,
                                                          pbmiDIB,
                                                          &pbmiDIBNew,
                                                          NULL,
                                                          dwNumScan,
                                                          iColorUsage,
                                                          ICM_FORWARD,
                                                          NULL,NULL);

                                if (bStatus)
                                {
                                    if (pvBitsNew != NULL)
                                    {
                                        //
                                        // IcmTranslateDIB creates new bitmap buffer, then
                                        // free original buffer and set new one.
                                        //
                                        LOCALFREE(pvBits);
                                        pvBits = pvBitsNew;
                                    }

                                    if (pbmiDIBNew != NULL)
                                    {
                                        //
                                        // If bitmapInfo header is updated, use new one.
                                        // And, need to compute bitmap bits size based
                                        // on new bitmap header.
                                        //
                                        LOCALFREE(pbmiDIB);
                                        pbmiDIB = pbmiDIBNew;

                                        //
                                        // Calculate bitmap bits size based on BITMAPINFO and nNumScans
                                        //
                                        cjBits = cjBitmapBitsSize(pbmiDIB);
                                    }

                                    //
                                    // Set ICM-translated DIB into brush
                                    //
                                    bStatus = NtGdiIcmBrushInfo(hdc,
                                                                (HBRUSH)hpen,
                                                                pbmiDIB,
                                                                pvBits,
                                                                &cjBits,
                                                                NULL,
                                                                NULL,
                                                                IcmSetBrush);

                                    if (bStatus)
                                    {
                                        //
                                        // Translated.
                                        //
                                        bAlreadyTran = TRUE;
                                    }
                                    else
                                    {
                                        WARNING("IcmSelectExtPen():NtGdiIcmBrushInfo(SET) Failed\n");
                                    }
                                }
                                else
                                {
                                    WARNING("IcmSelectBrush():IcmTranslateDIB() Failed\n");
                                }
                            }
                            else
                            {
                                WARNING("IcmSelectExtPen():NtGdiIcmBrushInfo(GET) Failed\n");
                            }

                            LOCALFREE(pvBits);
                        }
                        else
                        {
                            WARNING("IcmSelectExtPen(): LOCALALLOC(pvBits) failed\n");
                        }
                    }

                    if (bAlreadyTran)
                    {
                        //
                        // Eventually, IcmPenColor is initialized.
                        //
                        pdcattr->ulDirty_ |= ICM_PEN_TRANSLATED;
                    }
                }
                else
                {
                    ICMWRN(("IcmSelectBrush(): Fail to get brush bitmap size or bitmap is DIB_PAL_COLORS\n"));
                }

                LOCALFREE(pbmiDIB);
            }
            else
            {
                WARNING("IcmSelectExtPen(): LOCALALLOC(pbmi) failed\n");
            }
        }
        else
        {
        #if DBG_ICM
            DbgPrint("IcmSelectExtPen:ICM does not support this style (%d), yet\n",plogpen->elpBrushStyle);
        #endif
        }

        if (plogpen != &logpenLocal)
        {
            LOCALFREE(plogpen);
        }
    }
    else
    {
        WARNING("IcmSelectExtPen():GetObjectW() failed on hextpen\n");
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* IcmGetProfileColorFormat()
*
* History:
*
* Write it:
*   12-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BMFORMAT
IcmGetProfileColorFormat(
    HPROFILE   hProfile
    )
{
    //
    // defaut is RGB
    //
    ULONG ColorFormat = BM_xBGRQUADS;

    PROFILEHEADER ProfileHeader;

    ICMAPI(("gdi32: IcmGetProfileColorFormat\n"));

    //
    // Get profile header information.
    //
    if (((*fpGetColorProfileHeader)(hProfile,&ProfileHeader)))
    {
        DWORD ColorSpace;

        //
        // Yes, we succeed to get profile header.
        //
        ColorSpace = ProfileHeader.phDataColorSpace;

        //
        // Figure out color format from color space.
        //
        switch (ColorSpace)
        {
        case SPACE_CMYK:

            ICMMSG(("IcmGetProfileColorFormat(): CMYK Color Space\n"));

            //
            // Output format is CMYK color.
            //
            ColorFormat = BM_KYMCQUADS;
            break;

        case SPACE_RGB:

            ICMMSG(("IcmGetProfileColorFormat(): RGB Color Space\n"));

            //
            // Output format is same as COLORREF (0x00bbggrr)
            //
            ColorFormat = BM_xBGRQUADS;
            break;

        default:

            WARNING("IcmGetProfileColorFormat(): Unknown color space\n");

            ColorFormat = 0xFFFFFFFF;
            break;
        }
    }

    return (ColorFormat);
}

/******************************Public*Routine******************************\
* IcmEnumColorProfile()
*
* History:
*
* Write it:
*   12-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

int
IcmEnumColorProfile(
    HDC       hdc,
    PVOID     pvCallBack,
    LPARAM    lParam,
    BOOL      bAnsiCallBack,
    PDEVMODEW pDevModeW,
    DWORD    *pdwColorSpaceFlag
    )
{
    int       iRet        = -1; // -1 means fail.
    int       iRetFromCMS = -1;

    BYTE      StackDeviceData[MAX_PATH*2*sizeof(WCHAR)];
    WCHAR     StackProfileData[MAX_PATH];
    WCHAR     StackTempBuffer[MAX_PATH];
    CHAR      StackTempBufferA[MAX_PATH];

    PVOID     pvFree = NULL;

    PWSTR     ProfileNames = StackProfileData;
    DWORD     cjAllocate = 0;

    LPWSTR    pDeviceName = NULL;
    DWORD     dwDeviceClass = 0L;

    PLDC      pldc = NULL;

    DWORD     bDontAskDriver = FALSE;
    DWORD     dwSize;

    ICMAPI(("gdi32: IcmEnumColorProfile\n"));

    //
    // Load external ICM dlls
    //
    LOAD_ICMDLL(iRet);

    //
    // Try to identify device name, class and devmode (if hdc is given)
    //
    if (hdc)
    {
        pldc = GET_PLDC(hdc);

        if (pldc && pldc->hSpooler)
        {
            DWORD cbFilled;

            //
            // This is printer.
            //
            dwDeviceClass = CLASS_PRINTER;

            //
            // Get current DEVMODE for printer (if devmode is not given)
            //
            if (!pDevModeW)
            {
                if (pldc->pDevMode)
                {
                    ICMMSG(("IcmEnumColorProfile():Cached DEVMODE used\n"));

                    pDevModeW = pldc->pDevMode;
                }
                else
                {
                    ICMMSG(("IcmEnumColorProfile():Get default DEVMODE\n"));

                    //
                    // UNDER_CONSTRUCTION: NEED TO USE CURRENT DEVMODE, NOT DEFAULT DEVMODE.
                    //
                    pDevModeW = pdmwGetDefaultDevMode(pldc->hSpooler,NULL,&pvFree);
                }
            }

            //
            // Get printer device name, Try level 1 information.
            //
            if ((*fpGetPrinterW)(pldc->hSpooler,1,
                                 (BYTE *) &StackDeviceData,sizeof(StackDeviceData),
                                 &cbFilled))
            {
                PRINTER_INFO_1W *pPrinterInfo1 = (PRINTER_INFO_1W *) &StackDeviceData;

                //
                // Device name is in there.
                //
                pDeviceName = pPrinterInfo1->pName;
            }
            else
            {
                ICMMSG(("IcmEnumColorProfile():FAILED on GetPrinterW(INFO_1) - %d\n",GetLastError()));

                //
                // Failed on GetPrinter, So get device name from DEVMODE
                // (this will be limited to 32 character, but better than nothing.)
                //
                if (pDevModeW)
                {
                    pDeviceName = pDevModeW->dmDeviceName;
                }
            }

            //
            // Get configuration about we need to ask driver for profile or not.
            //
            dwSize = sizeof(DWORD);

            if ((*fpInternalGetDeviceConfig)(pDeviceName, CLASS_PRINTER, MSCMS_PROFILE_ENUM_MODE,
                                             &bDontAskDriver, &dwSize))
            {
                ICMMSG(("IcmEnumColorProfile():EnumMode = %d\n",bDontAskDriver));
            }
            else
            {
                bDontAskDriver = FALSE; // if error, set back as default.
            }
        }
        else if (GetDeviceCaps(hdc,TECHNOLOGY) == DT_RASDISPLAY)
        {
            //
            // This is display.
            //
            dwDeviceClass = CLASS_MONITOR;

            //
            // Get monitor name for this DC.
            //
            if (NtGdiGetMonitorID(hdc,sizeof(StackDeviceData), (LPWSTR) StackDeviceData))
            {
                pDeviceName = (LPWSTR) StackDeviceData;
            }
            else
            {
                WARNING("NtGdiGetMonitorID failed, use hardcoded data\n");

                //
                // If failed, use "DISPLAY"
                //
                pDeviceName = L"DISPLAY";
            }
        }
    }
    else if (pDevModeW)
    {
        pDeviceName = pDevModeW->dmDeviceName;
    }

    if (pDeviceName)
    {
        ICMMSG(("IcmEnumColorProfile() DeviceName = %ws\n",pDeviceName));
    }

    //
    // If we have devmode, call printer driver UI first to obtain color profile.
    //
    if (pDevModeW &&               /* devmode should be given      */
        pdwColorSpaceFlag &&       /* no query context             */
        pldc && pldc->hSpooler &&  /* only for printer driver      */
        !bDontAskDriver)           /* only when we need ask driver */
    {
        //
        // Ask (Printer UI) driver for default device color profile
        //
        iRetFromCMS = IcmAskDriverForColorProfile(pldc,QCP_DEVICEPROFILE,
                                                  pDevModeW,ProfileNames,pdwColorSpaceFlag);

        //
        // if iRet is greater then 0, driver have paticular color profile to use.
        //
        if (iRetFromCMS > 0)
        {
            if (pvCallBack)
            {
                //
                // Build ICM profile file path.
                //
                BuildIcmProfilePath(ProfileNames,StackTempBuffer,MAX_PATH);

                if (bAnsiCallBack)
                {
                    bToASCII_N(StackTempBufferA,MAX_PATH,
                               StackTempBuffer, wcslen(StackTempBuffer)+1);

                    //
                    // Callback application.
                    //
                    iRet = (*(ICMENUMPROCA)pvCallBack)(StackTempBufferA,lParam);
                }
                else
                {
                    iRet = (*(ICMENUMPROCW)pvCallBack)(StackTempBuffer,lParam);
                }

                if (iRet > 0)
                {
                    //
                    // If iRet is positive value, continue to enumeration.
                    //
                    iRetFromCMS = -1;
                }
            }
            else
            {
                //
                // There is no call back function, just use return value from CMS.
                //
                iRet = iRetFromCMS;
            }
        }
        else
        {
            iRetFromCMS = -1;
        }
    }

    if (iRetFromCMS == -1)
    {
        ENUMTYPEW EnumType;

        //
        // Initialize with zero.
        //
        RtlZeroMemory(&EnumType,sizeof(ENUMTYPEW));

        //
        // Fill up EnumType structure
        //
        EnumType.dwSize = sizeof(ENUMTYPEW);
        EnumType.dwVersion = ENUM_TYPE_VERSION;

        //
        // If device name is given use it, otherwise get it from DEVMODE.
        //
        if (pDeviceName)
        {
            EnumType.dwFields |= ET_DEVICENAME;
            EnumType.pDeviceName = pDeviceName;
        }

        //
        // Set DeviceClass (if hdc is given)
        //
        if (dwDeviceClass)
        {
            EnumType.dwFields |= ET_DEVICECLASS;
            EnumType.dwDeviceClass = dwDeviceClass;
        }

        //
        // Pick up any additional info from devmode (if we have)
        //
        if (pDevModeW)
        {
            //
            // Set MediaType is presented.
            //
            if (pDevModeW->dmFields & DM_MEDIATYPE)
            {
                EnumType.dwFields |= ET_MEDIATYPE;
                EnumType.dwMediaType = pDevModeW->dmMediaType;
            }

            if (pDevModeW->dmFields & DM_DITHERTYPE)
            {
                EnumType.dwFields |= ET_DITHERMODE;
                EnumType.dwDitheringMode = pDevModeW->dmDitherType;
            }

            if ((pDevModeW->dmFields & DM_PRINTQUALITY) &&
                (pDevModeW->dmPrintQuality >= 0))
            {
                EnumType.dwFields |= ET_RESOLUTION;
                EnumType.dwResolution[0] = pDevModeW->dmPrintQuality;

                if (pDevModeW->dmFields & DM_YRESOLUTION)
                {
                    EnumType.dwResolution[1] = pDevModeW->dmYResolution;
                }
                else
                {
                    EnumType.dwResolution[1] = pDevModeW->dmPrintQuality;
                }

                ICMMSG(("Resolution in devmode (%d,%d)\n",
                         EnumType.dwResolution[0],EnumType.dwResolution[1]));
            }
        }

        //
        // Figure out how much memory we need.
        //
        iRetFromCMS = (*fpEnumColorProfilesW)(NULL,&EnumType,NULL,&cjAllocate,NULL);

        //
        // Buffer should be requested ,at least, more then 2 unicode-null.
        //
        if (cjAllocate > (sizeof(UNICODE_NULL) * 2))
        {
            //
            // If the buffer on stack is not enough, allocate it.
            //
            if (cjAllocate > sizeof(StackProfileData))
            {
                //
                // Allocate buffer to recieve data.
                //
                ProfileNames = LOCALALLOC(cjAllocate);

                if (ProfileNames == NULL)
                {
                    GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    goto IcmEnumColorProfile_Cleanup;
                }
            }

            //
            // Enumurate profiles
            //
            iRetFromCMS = (*fpEnumColorProfilesW)(NULL,&EnumType,(PBYTE)ProfileNames,&cjAllocate,NULL);

            if (iRetFromCMS == 0)
            {
                //
                // There is no profile enumulated.
                //
                goto IcmEnumColorProfile_Cleanup;
            }

            if (pvCallBack)
            {
                PWSTR pwstr;

                //
                // Callback for each file.
                //
                pwstr = ProfileNames;

                while(*pwstr)
                {
                    //
                    // Build ICM profile file path.
                    //
                    BuildIcmProfilePath(pwstr,StackTempBuffer,MAX_PATH);

                    if (bAnsiCallBack)
                    {
                        bToASCII_N(StackTempBufferA,MAX_PATH,
                                   StackTempBuffer, wcslen(StackTempBuffer)+1);

                        //
                        // Callback application.
                        //
                        iRet = (*(ICMENUMPROCA)pvCallBack)(StackTempBufferA,lParam);
                    }
                    else
                    {
                        iRet = (*(ICMENUMPROCW)pvCallBack)(StackTempBuffer,lParam);
                    }

                    if (iRet == 0)
                    {
                        //
                        // Stop enumlation.
                        //
                        break;
                    }

                    //
                    // Move pointer to next.
                    //
                    pwstr += (wcslen(pwstr)+1);
                }
            }
            else
            {
                //
                // There is no call back function, just use return value from CMS.
                //
                iRet = iRetFromCMS;
            }
        }

IcmEnumColorProfile_Cleanup:

        if (ProfileNames && (ProfileNames != StackProfileData))
        {
            LOCALFREE(ProfileNames);
        }
    }

    //
    // Free devmode buffer.
    //
    if (pvFree)
    {
        LOCALFREE(pvFree);
    }

    return (iRet);
}

/******************************Public*Routine******************************\
* IcmQueryProfileCallBack()
*
* History:
*
* Write it:
*   19-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

int CALLBACK
IcmQueryProfileCallBack(
    LPWSTR lpFileName,
    LPARAM lAppData
)
{
    PROFILECALLBACK_DATA *ProfileCallBack = (PROFILECALLBACK_DATA *)lAppData;

    if (lpFileName)
    {
        PWSZ FileNameOnly = GetFileNameFromPath(lpFileName);

        if (_wcsicmp(ProfileCallBack->pwszFileName,FileNameOnly) == 0)
        {
            //
            // Yes, found it.
            //
            ProfileCallBack->bFound = TRUE;

            //
            // stop enumuration.
            //
            return (0);
        }
    }

    //
    // Continue to enumuration.
    //
    return (1);
}

/******************************Public*Routine******************************\
* IcmFindProfileCallBack()
*
* History:
*
* Write it:
*   19-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

int CALLBACK
IcmFindProfileCallBack(
    LPWSTR lpFileName,
    LPARAM lAppData
)
{
    //
    // OK, just pick up first enumuration.
    //
    lstrcpyW((PWSZ)lAppData,lpFileName);

    //
    // And then stop enumuration.
    //
    return (0);
}

/******************************Public*Routine******************************\
* GetFileNameFromPath()
*
* History:
*
* Write it:
*   19-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PWSTR
GetFileNameFromPath(
    PWSTR pwszFileName
)
{
    PWSTR FileNameOnly = NULL;

    //
    // Check for: C:\PathName\Profile.icm
    //
    FileNameOnly = wcsrchr(pwszFileName,L'\\');

    if (FileNameOnly != NULL)
    {
        FileNameOnly++;  // Skip '\\'
    }
    else
    {
        //
        // For: C:Profile.icm
        //
        FileNameOnly = wcschr(pwszFileName,L':');

        if (FileNameOnly != NULL)
        {
            FileNameOnly++;  // Skip ':'
        }
        else
        {
            //
            // Otherwise Profile.icm
            //
            FileNameOnly = pwszFileName;
        }
    }

    return (FileNameOnly);
}

/******************************Public*Routine******************************\
* IcmCreateProfileFromLCS()
*
* History:
*
* Write it:
*   19-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmCreateProfileFromLCS(
    LPLOGCOLORSPACEW  lpLogColorSpaceW,
    PVOID            *ppvProfileData,
    PULONG            pulProfileSize
)
{
    BOOL bRet;

    ICMAPI(("gdi32: IcmCreateProfileFromLCS\n"));

    //
    // Call MSCMS.DLL to create Profile from LOGCOLORSPACE
    //
    bRet = (*fpCreateProfileFromLogColorSpaceW)(lpLogColorSpaceW,
                                                (PBYTE *)ppvProfileData);

    if (bRet && *ppvProfileData)
    {
        *pulProfileSize = (ULONG)GlobalSize(*ppvProfileData);
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* BuildIcmProfilePath()
*
* History:
*
* Write it:
*   07-Apr-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PWSZ
BuildIcmProfilePath(
    PWSZ  FileName,         // IN
    PWSZ  FullPathFileName, // OUT
    ULONG BufferSize
)
{
    PWSZ FileNameOnly;

    //
    // BufferSize - need to be used for overrap check sometime later...
    //

    FileNameOnly = GetFileNameFromPath(FileName);

    if (FileName == FileNameOnly)
    {
        // It seems we don't have any specified path, just use color directory.
        
        const UINT c_cBufChars = MAX_PATH;
        
        // Use a temporary because FileName and FullPathFileName can be the same
        // and wcsncpy doesn't like that.
        
        WCHAR awchTemp[MAX_PATH];
        
        int count = c_cBufChars;
        
        // Copy color directory first, then filename
        
        // wcsncpy does not append a NULL if the count is smaller than the
        // string. Do it manually so that wcsncat and wcslen work.
        
        wcsncpy(awchTemp, ColorDirectory, count);
        awchTemp[c_cBufChars-1] = 0;
        
        // Leave space for the NULL terminator. Note, because we append a
        // NULL terminator above, wcslen cannot return a number bigger than
        // BufferSize-1. Therefore the resulting count cannot be negative.
        
        count = c_cBufChars-wcslen(awchTemp)-1;
        ASSERT(count>=0);
        
        wcsncat(awchTemp,L"\\",count);
        
        // leave space for the NULL
        
        count = c_cBufChars-wcslen(awchTemp)-1;
        ASSERT(count>=0);
        
        wcsncat(awchTemp, FileNameOnly, count);
        
        // copy to the final destination and force NULL termination.
        
        wcsncpy(FullPathFileName, awchTemp, BufferSize);
        FullPathFileName[BufferSize-1] = 0;
    }
    else
    {
        //
        // Input path contains path, just use that.
        //
        if (FileName != FullPathFileName)
        {
            //
            // Source and destination buffer is different, need to copy.
            //
            wcsncpy(FullPathFileName,FileName,BufferSize);
            FullPathFileName[BufferSize-1] = 0;
        }
    }

    return (FileNameOnly);
}

/******************************Public*Routine******************************\
* IcmSameColorSpace()
*
* History:
*
* Write it:
*   21-Apr-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmSameColorSpace(
    PCACHED_COLORSPACE pColorSpaceA,
    PCACHED_COLORSPACE pColorSpaceB
)
{
    ICMAPI(("gdi32: IcmSameColorSpace\n"));

    if (pColorSpaceA == pColorSpaceB)
    {
        ICMMSG(("IcmSameColorSpace - Yes\n"));
        return (TRUE);
    }
    else
    {
        ICMMSG(("IcmSameColorSpace - No\n"));
        return (FALSE);
    }
}

/******************************Public*Routine******************************\
* IcmGetColorSpaceByColorSpace()
*
* History:
*
* Write it:
*   21-Apr-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PCACHED_COLORSPACE
IcmGetColorSpaceByColorSpace(
    HGDIOBJ          hObjRequest,
    LPLOGCOLORSPACEW lpLogColorSpace,
    PPROFILE         pColorProfile,
    DWORD            dwColorSpaceFlags
)
{
    PCACHED_COLORSPACE pCandidateColorSpace = NULL;
    PWSZ pProfileName;
    BOOL bNeedMatchHdc = FALSE;

    PLIST_ENTRY p;

    ICMAPI(("gdi32: IcmGetColorSpaceByColorSpace\n"));

    //
    // If this is "on memory" profile which size is larger than
    // maximum size of cachable profile withOUT filename,
    // don't search cache, since we never be able to find from cache.
    //
    if (pColorProfile &&
        (pColorProfile->dwType == PROFILE_MEMBUFFER) &&
        (pColorProfile->cbDataSize > MAX_SIZE_OF_COLORPROFILE_TO_CACHE) &&
        (lpLogColorSpace->lcsFilename[0] == UNICODE_NULL))
    {
        return (NULL);
    }

    //
    // If this is metafile color space, must match hdc.
    //
    if (GET_COLORSPACE_TYPE(dwColorSpaceFlags) == GET_COLORSPACE_TYPE(METAFILE_COLORSPACE))
    {
        bNeedMatchHdc = TRUE;
    }

    pProfileName = lpLogColorSpace->lcsFilename;

    //
    // Search from cache.
    //
    ENTERCRITICALSECTION(&semColorSpaceCache);

    p = ListCachedColorSpace.Flink;

    while(p != &ListCachedColorSpace)
    {
        pCandidateColorSpace = CONTAINING_RECORD(p,CACHED_COLORSPACE,ListEntry);

        //
        // If this colorspace depends on specific gdi object, check it.
        //
        if (/* hdc is match */
            (pCandidateColorSpace->hObj == hObjRequest) ||
            /* candidate is not specific to hdc, and does not need to match hdc */
            ((bNeedMatchHdc == FALSE) && (pCandidateColorSpace->hObj == NULL)))
        {
            LOGCOLORSPACEW *pCandidateLogColorSpace;
            PWSZ            pCandidateProfileName;

            //
            // Get pointer to profile
            //
            pCandidateLogColorSpace = &(pCandidateColorSpace->LogColorSpace);
            pCandidateProfileName = pCandidateColorSpace->LogColorSpace.lcsFilename;

            //
            // Check lcsIntent.
            //
            if (pCandidateLogColorSpace->lcsIntent == lpLogColorSpace->lcsIntent)
            {
                //
                // Check profile name if given
                //
                if (*pProfileName && *pCandidateProfileName)
                {
                    if (_wcsicmp(pProfileName,pCandidateProfileName) == 0)
                    {
                        ICMMSG(("IcmGetColorSpaceByColorSpace():Find in cache (by profile name)\n"));

                        //
                        // Find it ! then Increment ref. counter
                        //
                        pCandidateColorSpace->cRef++;

                        break;
                    }
                }
                else if ((*pProfileName == UNICODE_NULL) && (*pCandidateProfileName == UNICODE_NULL))
                {
                    if (pColorProfile == NULL)
                    {
                        //
                        // Both of color space does not have color profile, check inside LOGCOLORSPACE.
                        //
                        if ((pCandidateLogColorSpace->lcsCSType == lpLogColorSpace->lcsCSType) &&
                            (pCandidateLogColorSpace->lcsGammaRed == lpLogColorSpace->lcsGammaRed) &&
                            (pCandidateLogColorSpace->lcsGammaGreen == lpLogColorSpace->lcsGammaGreen) &&
                            (pCandidateLogColorSpace->lcsGammaBlue == lpLogColorSpace->lcsGammaBlue) &&
                            (RtlCompareMemory(&(pCandidateLogColorSpace->lcsEndpoints),
                                          &(lpLogColorSpace->lcsEndpoints),sizeof(CIEXYZTRIPLE))
                                                                        == sizeof(CIEXYZTRIPLE)))
                        {
                            ICMMSG(("IcmGetColorSpaceByColorSpace():Find in cache (by metrics)\n"));

                            //
                            // Find it ! then Increment ref. counter
                            //
                            pCandidateColorSpace->cRef++;

                            break;
                        }
                    }
                    else if ((pColorProfile->dwType == PROFILE_MEMBUFFER) &&
                             (pCandidateColorSpace->ColorProfile.dwType == PROFILE_MEMBUFFER))
                    {
                        if (pCandidateColorSpace->ColorProfile.cbDataSize == pColorProfile->cbDataSize)
                        {
                            if (RtlCompareMemory(pCandidateColorSpace->ColorProfile.pProfileData,
                                                 pColorProfile->pProfileData,
                                                 pColorProfile->cbDataSize)
                                              == pColorProfile->cbDataSize)
                            {
                                ICMMSG(("IcmGetColorSpaceByColorSpace():Find in cache (by on memory profile)\n"));

                                //
                                // Find it ! then Increment ref. counter
                                //
                                pCandidateColorSpace->cRef++;

                                break;
                            }
                        }
                    }
                }
            }
        }

        p = p->Flink;
        pCandidateColorSpace = NULL;
    }

    LEAVECRITICALSECTION(&semColorSpaceCache);

    return (pCandidateColorSpace);
}

/******************************Public*Routine******************************\
* IcmGetColorSpaceByHandle()
*
* History:
*
* Write it:
*   21-Apr-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PCACHED_COLORSPACE
IcmGetColorSpaceByHandle(
    HGDIOBJ          hObj,
    HCOLORSPACE      hColorSpace,
    LPLOGCOLORSPACEW lpLogColorSpace,
    DWORD            dwFlags
)
{
    ULONG cRet;

    ICMAPI(("gdi32: IcmGetColorSpaceByHandle\n"));

    //
    // Get LOGCOLORSPACE from handle
    //
    cRet = NtGdiExtGetObjectW(hColorSpace,sizeof(LOGCOLORSPACEW),lpLogColorSpace);

    if (cRet >= sizeof(LOGCOLORSPACEW))
    {
        if (lpLogColorSpace->lcsFilename[0] != UNICODE_NULL)
        {
            //
            // Normalize filename
            //
            BuildIcmProfilePath(lpLogColorSpace->lcsFilename,lpLogColorSpace->lcsFilename,MAX_PATH);
        }
        else
        {
            if (lpLogColorSpace->lcsCSType != LCS_CALIBRATED_RGB)
            {
                ULONG ulSize = MAX_PATH;

                //
                // if CSType is not LCS_CALIBRATED_RGB, we should go to MSCMS.DLL
                // to get color profile for corresponding LCSType, then any given
                // profile name from application is IGNORED.
                //
                if ((*fpGetStandardColorSpaceProfileW)(
                       NULL,
                       lpLogColorSpace->lcsCSType,
                       lpLogColorSpace->lcsFilename,
                       &ulSize))
                {
                    ICMMSG(("IcmGetColorSpaceByHandle():CSType %x = %ws\n",
                                          lpLogColorSpace->lcsCSType,
                                          lpLogColorSpace->lcsFilename));
                }
                else
                {
                    ICMWRN(("IcmGetColorSpaceByHandle():Error CSType = %x\n",
                                          lpLogColorSpace->lcsCSType));
                    return (NULL);
                }
            }
        }

        //
        // Find it !
        //
        return (IcmGetColorSpaceByColorSpace(hObj,lpLogColorSpace,NULL,dwFlags));
    }
    else
    {
        ICMWRN(("IcmGetColorSpaceByHandle():Failed on GetObject\n"));
        return (NULL);
    }
}

/******************************Public*Routine******************************\
* IcmGetColorSpaceByName()
*
* History:
*
* Write it:
*   21-Apr-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PCACHED_COLORSPACE
IcmGetColorSpaceByName(
    HGDIOBJ hObj,
    PWSZ    ColorProfileName,
    DWORD   dwIntent,
    DWORD   dwFlags
)
{
    ICMAPI(("gdi32: IcmGetColorSpaceByName (%ws)\n",(ColorProfileName ? ColorProfileName : L"null")));

    if (ColorProfileName)
    {
        LOGCOLORSPACEW LogColorSpace;

        RtlZeroMemory(&LogColorSpace,sizeof(LOGCOLORSPACEW));

        //
        // Put intent in LOGCOLORSPACE
        //
        LogColorSpace.lcsIntent = (LCSGAMUTMATCH) dwIntent;

        //
        // Normalize path name
        //
        BuildIcmProfilePath(ColorProfileName,LogColorSpace.lcsFilename,MAX_PATH);

        //
        // Find it !
        //
        return (IcmGetColorSpaceByColorSpace(hObj,&LogColorSpace,NULL,dwFlags));
    }
    else
    {
        return (NULL);
    }
}

/******************************Public*Routine******************************\
* IcmCreateColorSpaceByName()
*
* History:
*
* Write it:
*   21-Apr-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PCACHED_COLORSPACE
IcmCreateColorSpaceByName(
    HGDIOBJ hObj,
    PWSZ    ColorProfileName,
    DWORD   dwIntent,
    DWORD   dwFlags
)
{
    LOGCOLORSPACEW LogColorSpace;

    ICMAPI(("gdi32: IcmCreateColorSpaceByName\n"));

    RtlZeroMemory(&LogColorSpace,sizeof(LOGCOLORSPACEW));

    //
    // Fill up LOGCOLORSPACE fields.
    //
    LogColorSpace.lcsSignature = LCS_SIGNATURE;
    LogColorSpace.lcsVersion   = 0x400;
    LogColorSpace.lcsSize      = sizeof(LOGCOLORSPACEW);
    LogColorSpace.lcsCSType    = LCS_CALIBRATED_RGB;
    LogColorSpace.lcsIntent    = (LCSGAMUTMATCH) dwIntent;

    //
    // Put profile file name in lcsFilename[]
    //
    lstrcpyW(LogColorSpace.lcsFilename,ColorProfileName);

    //
    // Create colorspace with LOGCOLORSPACE
    //
    return (IcmCreateColorSpaceByColorSpace(hObj,&LogColorSpace,NULL,dwFlags));
}

/******************************Public*Routine******************************\
* IcmCreateColorSpaceByColorSpace()
*
* History:
*
* Write it:
*   21-Apr-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PCACHED_COLORSPACE
IcmCreateColorSpaceByColorSpace(
    HGDIOBJ          hObj,
    LPLOGCOLORSPACEW lpLogColorSpace,
    PPROFILE         pProfileData,
    DWORD            dwFlags
)
{
    PCACHED_COLORSPACE pColorSpace = NULL;

    ICMAPI(("gdi32: IcmCreateColorSpaceByColorSpace\n"));

    if (lpLogColorSpace)
    {
        //
        // If ICMDLL is not loaded, yet, Just Load ICMDLL regardless current ICM mode,
        // since we need it for handle this color profile. And apps can enable ICM
        // later at that time, the opened color profile mighted be used.
        //
        if ((ghICM == NULL) && (!IcmInitialize()))
        {
            ICMWRN(("IcmCreateColorSpace():Fail to load ICM dlls\n"));
            return (NULL);
        }

        //
        // Allocate CACHED_COLORSPACE
        //
        pColorSpace = LOCALALLOC(sizeof(CACHED_COLORSPACE));

        if (pColorSpace)
        {
            //
            // Zero init CACHED_COLORSPACE
            //
            RtlZeroMemory(pColorSpace,sizeof(CACHED_COLORSPACE));

            //
            // Copy LOGCOLORSPACE into CACHED_COLORSPACE
            //
            RtlCopyMemory(&(pColorSpace->LogColorSpace),lpLogColorSpace,sizeof(LOGCOLORSPACEW));

            //
            // Default colorspace is RGB (BGR = 0x00bbggrr same as COLORREF format)
            //
            pColorSpace->ColorFormat = BM_xBGRQUADS;

            //
            // Map intent value for MSCMS from LOGCOLORSPACE.
            //
            switch (lpLogColorSpace->lcsIntent)
            {
            case LCS_GM_BUSINESS:
                pColorSpace->ColorIntent = INTENT_SATURATION;
                break;

            case LCS_GM_GRAPHICS:
                pColorSpace->ColorIntent = INTENT_RELATIVE_COLORIMETRIC;
                break;

            case LCS_GM_IMAGES:
                pColorSpace->ColorIntent = INTENT_PERCEPTUAL;
                break;

            case LCS_GM_ABS_COLORIMETRIC:
                pColorSpace->ColorIntent = INTENT_ABSOLUTE_COLORIMETRIC;
                break;

            default:
                ICMWRN(("IcmCreateColorSpace():Invalid intent value\n"));
                LOCALFREE(pColorSpace);
                return (NULL);
            }

            //
            // Keep flags
            //
            pColorSpace->flInfo = dwFlags;

            //
            // if the color space is specific to some GDI object, keep its handle.
            //
            // for DIBSECTION_COLORSPACE, CreateDIBSection calls us this hdc in hObj,
            // then later overwrite hObj with thier bitmap handle. this prevent from
            // this color space is shared with others.
            //
            if (dwFlags & HGDIOBJ_SPECIFIC_COLORSPACE)
            {
                pColorSpace->hObj = hObj;
            }

            //
            // If this is not LCS_CALIBRATED_RGB, get color profile name.
            //
            if (lpLogColorSpace->lcsCSType != LCS_CALIBRATED_RGB)
            {
                ULONG ulSize = MAX_PATH;

                //
                // if CSType is not LCS_CALIBRATED_RGB, we should go to MSCMS.DLL
                // to get color profile for corresponding LCSType, then any given
                // profile name from application is IGNORED.
                //
                if ((*fpGetStandardColorSpaceProfileW)(
                       NULL, lpLogColorSpace->lcsCSType,
                       pColorSpace->LogColorSpace.lcsFilename, &ulSize))
                {
                    ICMMSG(("IcmCreateColorSpace():CSType %x = %ws\n",
                                          lpLogColorSpace->lcsCSType,
                                          pColorSpace->LogColorSpace.lcsFilename));
                }
                else
                {
                    ICMWRN(("IcmCreateColorSpace():Error CSType = %x\n",
                                          lpLogColorSpace->lcsCSType));

                    LOCALFREE(pColorSpace);
                    return (NULL);
                }
            }

            //
            // Use PROFILE if profile is given
            //
            if ((pProfileData != NULL) &&
                (pProfileData->dwType == PROFILE_MEMBUFFER) &&
                (pProfileData->pProfileData != NULL) &&
                (pProfileData->cbDataSize != 0))
            {
                ICMMSG(("IcmCreateColorSpace():Create ColorSpace cache by memory profile\n"));

                ASSERTGDI(dwFlags & ON_MEMORY_PROFILE,
                          "IcmCreateColorSpace():dwFlags does not have ON_MEMORY_PROFILE");

                if (!(dwFlags & NOT_CACHEABLE_COLORSPACE))
                {
                    //
                    // Try to make a copy, if profile size is small enough,
                    // so that we can cache this profile.
                    //
                    if (pProfileData->cbDataSize <= MAX_SIZE_OF_COLORPROFILE_TO_CACHE)
                    {
                        pColorSpace->ColorProfile.pProfileData = GlobalAlloc(GMEM_FIXED,pProfileData->cbDataSize);

                        if (pColorSpace->ColorProfile.pProfileData)
                        {
                            ICMMSG(("IcmCreateColorSpace():Profile data can be cacheable\n"));

                            pColorSpace->ColorProfile.dwType = PROFILE_MEMBUFFER;
                            pColorSpace->ColorProfile.cbDataSize = pProfileData->cbDataSize;
                            RtlCopyMemory(pColorSpace->ColorProfile.pProfileData,
                                          pProfileData->pProfileData,
                                          pProfileData->cbDataSize);

                            //
                            // Make sure it is cachable...
                            //
                            ASSERTGDI((pColorSpace->flInfo & NOT_CACHEABLE_COLORSPACE) == 0,
                                      "IcmCreateColorSpace():flInfo has NOT_CACHEABLE_COLORSPACE");

                            //
                            // Profile memory need to be freed at deletion.
                            //
                            pColorSpace->flInfo |= NEED_TO_FREE_PROFILE;
                        }
                    }
                }

                //
                // If not able to cache, it the profile data in application.
                //
                if (pColorSpace->ColorProfile.pProfileData == NULL)
                {
                    //
                    // Use PROFILE data if it's given in parameter.
                    //
                    pColorSpace->ColorProfile = *pProfileData;

                    //
                    // We don't make a copy of profile data, so profile data possible to be
                    // free by application, so this color space can not be cached
                    //
                    pColorSpace->flInfo |= NOT_CACHEABLE_COLORSPACE;
                }
            }
            else if (lpLogColorSpace->lcsFilename[0] != UNICODE_NULL)
            {
                PWSZ pszFileNameOnly;

                ICMMSG(("IcmCreateColorSpace():Create ColorSpace cache by file - %ws\n",
                                                                 lpLogColorSpace->lcsFilename));

                //
                // Normalize filename
                //
                pszFileNameOnly = BuildIcmProfilePath(pColorSpace->LogColorSpace.lcsFilename,
                                                      pColorSpace->LogColorSpace.lcsFilename,MAX_PATH);

                //
                // If this is sRGB (= sRGB Color Space Profile.icm) color profile, ...
                //
                if (_wcsicmp(pszFileNameOnly,sRGB_PROFILENAME) == 0)
                {
                    //
                    // Mark device_calibrate_colorspace flag.
                    //
                    pColorSpace->flInfo |= DEVICE_CALIBRATE_COLORSPACE;
                }

                //
                // Fill up PROFILE structure and open it.
                //
                pColorSpace->ColorProfile.dwType = PROFILE_FILENAME;
                pColorSpace->ColorProfile.pProfileData = pColorSpace->LogColorSpace.lcsFilename;
                pColorSpace->ColorProfile.cbDataSize = MAX_PATH * sizeof(WCHAR);
            }
            else // if we only have parameter in LOGCOLORSPACE but not lcsFileName.
            {
                BOOL bRet;

                //
                // Convert LOGCOLORSPACE to ICC Profile.
                //
                ICMMSG(("IcmCreateColorSpace():Create ColorSpace cache by LOGCOLRSPACE\n"));

                //
                // Fill up PROFILE structure.
                //
                pColorSpace->ColorProfile.dwType = PROFILE_MEMBUFFER;
                pColorSpace->ColorProfile.pProfileData = NULL;

                //
                // Call convert function. (LOGCOLORSPACE -> ICC PROFILE)
                //
                bRet = IcmCreateProfileFromLCS(
                               &(pColorSpace->LogColorSpace),             // source logColorSpace
                               &(pColorSpace->ColorProfile.pProfileData), // receive pointer to profile image
                               &(pColorSpace->ColorProfile.cbDataSize));  // receive size of profile image

                if ((bRet == FALSE) ||
                    (pColorSpace->ColorProfile.pProfileData == NULL) ||
                    (pColorSpace->ColorProfile.cbDataSize == 0))
                {
                    ICMWRN(("IcmCreateColorSpaceByColorSpace():IcmCreateProfileFromLCS() failed\n"));

                    LOCALFREE(pColorSpace);
                    return (NULL);
                }

                //
                // Mark pProfileData must be freed at deletion.
                //
                pColorSpace->flInfo |= NEED_TO_FREE_PROFILE;
            }

            //
            // At this point, we don't have color format yet,
            // so call IcmRealizeColorProfile with no color format checking.
            //
            if (IcmRealizeColorProfile(pColorSpace,FALSE))
            {
                //
                // Get profile color format
                //
                pColorSpace->ColorFormat = IcmGetProfileColorFormat(pColorSpace->hProfile);

                //
                // Until create color transform, we don't need realized color space.
                //
                IcmUnrealizeColorProfile(pColorSpace);
            }
            else
            {
                ICMWRN(("IcmCreateColorSpace():Fail to realize color profile\n"));

                if (pColorSpace->flInfo & NEED_TO_FREE_PROFILE)
                {
                    GlobalFree(pColorSpace->ColorProfile.pProfileData);
                }

                LOCALFREE(pColorSpace);
                return (NULL);
            }

            //
            // Initialize ref. counter
            //
            pColorSpace->cRef = 1;

            //
            // Put the created color space into the list
            //
            ENTERCRITICALSECTION(&semColorSpaceCache);

            InsertTailList(&ListCachedColorSpace,&(pColorSpace->ListEntry));
            cCachedColorSpace++;

            LEAVECRITICALSECTION(&semColorSpaceCache);
        }
        else
        {
            WARNING("gdi32:IcmCreateColorSpace():LOCALALLOC failed\n");
        }
    }

    return (pColorSpace);
}

/******************************Public*Routine******************************\
* ColorProfile on demand loading/unloading support functions
*
* History:
*
* Write it:
*   29-Nov-1998 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmRealizeColorProfile(
    PCACHED_COLORSPACE pColorSpace,
    BOOL               bCheckColorFormat
)
{
    ICMAPI(("gdi32: IcmRealizeColorProfile\n"));

    if (pColorSpace)
    {
        if ((pColorSpace->hProfile == NULL) &&
            (pColorSpace->ColorProfile.pProfileData != NULL))
        {
            HPROFILE hProfile = (*fpOpenColorProfileW)(
                                     &(pColorSpace->ColorProfile),
                                     PROFILE_READ,
                                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                                     OPEN_EXISTING);

            if (hProfile)
            {
                //
                // Make sure color format of color profile has not been changed.
                //
                if ((bCheckColorFormat == FALSE) ||
                    (pColorSpace->ColorFormat == IcmGetProfileColorFormat(hProfile)))
                {
                    pColorSpace->hProfile = hProfile;
                }
                else
                {
                    (*fpCloseColorProfile)(hProfile);
                }
            }
        }

        return ((BOOL)!!pColorSpace->hProfile);
    }
    else
    {
        return (TRUE);
    }
}

VOID
IcmUnrealizeColorProfile(
    PCACHED_COLORSPACE pColorSpace
)
{
    ICMAPI(("gdi32: IcmUnrealizeColorProfile\n"));

    if (pColorSpace && pColorSpace->hProfile)
    {
        (*fpCloseColorProfile)(pColorSpace->hProfile);
        pColorSpace->hProfile = NULL;
    }
}

/******************************Public*Routine******************************\
* Metafiling support functions
*
* History:
*
* Write it:
*   23-May-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

VOID
IcmInsertMetafileList(
    PLIST_ENTRY pListHead,
    PWSZ        pName
    )
{
    PMETAFILE_COLORPROFILE pData;

    pData = LOCALALLOC(sizeof(METAFILE_COLORPROFILE));

    if (pData)
    {
        wcscpy(pData->ColorProfile,pName);
        InsertTailList(pListHead,&(pData->ListEntry));
    }
}

BOOL
IcmCheckMetafileList(
    PLIST_ENTRY pListHead,
    PWSZ        pName
    )
{
    PLIST_ENTRY p;
    PMETAFILE_COLORPROFILE pData;

    p = pListHead->Flink;

    while (p != pListHead)
    {
        pData = (PVOID) CONTAINING_RECORD(p,METAFILE_COLORPROFILE,ListEntry);

        if (_wcsicmp(pData->ColorProfile,pName) == 0)
        {
            return TRUE;
        }

        p = p->Flink;
    }

    return FALSE;
}

VOID
IcmFreeMetafileList(
    PLIST_ENTRY pListHead
    )
{
    PLIST_ENTRY p;
    PVOID       pData;

    p = pListHead->Flink;

    while(p != pListHead)
    {
        pData = (PVOID) CONTAINING_RECORD(p,METAFILE_COLORPROFILE,ListEntry);
        //
        // Need to get pointer to next before free memory.
        //
        p = p->Flink;
        //
        // then free memory.
        //
        LOCALFREE(pData);
    }

    InitializeListHead(pListHead);
}

/******************************Public*Routine******************************\
* IcmStretchBlt()
*
* History:
*
* Write it:
*   29-May-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmStretchBlt(HDC hdc, int x, int y, int cx, int cy,
              HDC hdcSrc, int x1, int y1, int cx1, int cy1, DWORD rop,
              PDC_ATTR pdcattr, PDC_ATTR pdcattrSrc)
{
    int     iRet = 0;

    PGDI_ICMINFO pIcmInfo;

    HBITMAP      hbm;
    PVOID        pvBits;
    PBITMAPINFO  pbmi;
    ULONG        cjBits;

    HCOLORSPACE        hSourceColorSpace = NULL,
                       hOldColorSpace = NULL;
    PCACHED_COLORSPACE pSourceColorSpace = NULL;

    POINT ptDevice[2];
    UINT  nNumScan, nNumWidth;
    UINT  nStartScan, nStartWidth;
    BOOL  bNoScaling;

    BYTE dibData[(sizeof(DIBSECTION)+256*sizeof(RGBQUAD))];

    ICMAPI(("gdi32: IcmStretchBlt\n"));

    //
    // Convert Logical coord to Physical coord on source.
    //
    ptDevice[0].x = x1;
    ptDevice[0].y = y1;
    ptDevice[1].x = x1 + cx1;
    ptDevice[1].y = y1 + cy1;

    if (LPtoDP(hdcSrc,ptDevice,2) == FALSE)
    {
        //
        // can't handle, let callee handle this.
        //
        return (FALSE);
    }

    //
    // Compute new origin.
    //
    nStartWidth = ptDevice[0].x; 
    nStartScan  = ptDevice[0].y;
    nNumWidth   = ptDevice[1].x - ptDevice[0].x; 
    nNumScan    = ptDevice[1].y - ptDevice[0].y;

    //
    // Check source bounds.
    //
    if (((INT)nStartWidth < 0) || ((INT)nStartScan < 0) || ((INT)nNumWidth < 0) || ((INT)nNumScan < 0))
    {
        ICMWRN(("IcmStretchBlt: (x1,y1) is out of surface\n"));

        //
        // We can't handle this, let callee handle this.
        //
        return (FALSE);
    }

    //
    // Is there any scaling ?
    //
    bNoScaling = ((cx == (int)nNumWidth) && (cy == (int)nNumScan));

    //
    // Get bitmap handle.
    //
    hbm = (HBITMAP) GetDCObject(hdcSrc, LO_BITMAP_TYPE);

    if (bDIBSectionSelected(pdcattrSrc))
    {
        //
        // Get DIBSECTION currently selected in source DC.
        //
        if (GetObject(hbm, sizeof(DIBSECTION), &dibData) != (int)sizeof(DIBSECTION))
        {
            WARNING("IcmStretchBlt: GetObject(DIBSECTION) failed\n");
            return(FALSE);
        }

        //
        // Load color table and overwrite DIBSECTION structure from right after BITMAPINFOHEADER
        //
        if (((DIBSECTION *)&dibData)->dsBm.bmBitsPixel <= 8)
        {
            GetDIBColorTable(hdcSrc, 0, 256, (RGBQUAD *)&((DIBSECTION *)&dibData)->dsBitfields[0]);
        }

        pbmi = (PBITMAPINFO)&(((DIBSECTION *)&dibData)->dsBmih);

        // if ((nStartScan + nNumScan) > (((DIBSECTION *)&dibData)->dsBm.bmHeight))
        // {
        //    nNumScan = (((DIBSECTION *)&dibData)->dsBm.bmHeight - nStartScan);
        // }

        //
        // Setup color source/destination colorspaces
        //
        if (IS_ICM_INSIDEDC(pdcattrSrc->lIcmMode))
        {
            //
            // if ICM is turned on source DC. we will use source DC's
            // destination color space as destination DC's source
            // color space.
            //
            pIcmInfo = GET_ICMINFO(pdcattrSrc);

            if (pIcmInfo && pIcmInfo->pDestColorSpace)
            {
                hSourceColorSpace = CreateColorSpaceW(&(pIcmInfo->pDestColorSpace->LogColorSpace));
                pSourceColorSpace = pIcmInfo->pDestColorSpace;
            }
        }

        if (hSourceColorSpace == NULL)
        {
            //
            // if no colorspace, use sRGB.
            //
            hSourceColorSpace = GetStockObject(PRIV_STOCK_COLORSPACE);
            pSourceColorSpace = NULL;
        }
    }
    else if (IS_ICM_LAZY_CORRECTION(pdcattrSrc->lIcmMode))
    {
        //
        // Get BITMAP currently selected in source DC.
        //
        if (GetObject(hbm, sizeof(BITMAP), &dibData) != (int)sizeof(BITMAP))
        {
            WARNING("IcmStretchBlt: GetObject(BITMAP) failed\n");
            return(FALSE);
        }

        //
        // Create bitmap info header
        //
        pbmi = (PBITMAPINFO) ((PBYTE)dibData+sizeof(BITMAP));

        pbmi->bmiHeader.biSize        = sizeof(BITMAPINFO);
        pbmi->bmiHeader.biHeight      = ((BITMAP *)&dibData)->bmHeight;
        pbmi->bmiHeader.biWidth       = ((BITMAP *)&dibData)->bmWidth;
        pbmi->bmiHeader.biPlanes      = 1;
        pbmi->bmiHeader.biBitCount    = 24; // 24bpp
        pbmi->bmiHeader.biCompression = BI_RGB;
        pbmi->bmiHeader.biSizeImage     = 0;
        pbmi->bmiHeader.biXPelsPerMeter = 0;
        pbmi->bmiHeader.biYPelsPerMeter = 0;
        pbmi->bmiHeader.biClrUsed       = 0;
        pbmi->bmiHeader.biClrImportant  = 0;

        // if ((nStartScan + nNumScan) > pbmi->bmiHeader.biHeight)
        // {
        //     nNumScan = pbmi->bmiHeader.biHeight - nStartScan;
        // }

        ASSERTGDI(IS_ICM_INSIDEDC(pdcattrSrc->lIcmMode),
                  "IcmStretchBlt():Lazy color correction, but ICM is not enabled\n");

        pIcmInfo = GET_ICMINFO(pdcattrSrc);

        if (pIcmInfo && pIcmInfo->pSourceColorSpace)
        {
            hSourceColorSpace = CreateColorSpaceW(&(pIcmInfo->pSourceColorSpace->LogColorSpace));
            pSourceColorSpace = pIcmInfo->pSourceColorSpace;
        }
        else
        {
            //
            // Otherwise, just use Stcok color space (= sRGB)
            //
            hSourceColorSpace = GetStockObject(PRIV_STOCK_COLORSPACE);
            pSourceColorSpace = NULL;
        }
    }
    else
    {
        //
        // Can't handle here, let callee handle it.
        //
        return (FALSE);
    }

    //
    // Get bitmap size
    //
    cjBits = cjBitmapScanSize(pbmi,nNumScan);

    pvBits = LOCALALLOC(cjBits);

    if (pvBits)
    {
        //
        // Fix up the start scan (bottom-left).
        //
        nStartScan = (pbmi->bmiHeader.biHeight - nStartScan - nNumScan);

        //
        // Call NtGdiGetDIBitsInternal directly, because
        // we don't want to backward color correction to
        // source color space in hdcSrc.
        //
        if (NtGdiGetDIBitsInternal(
                      hdcSrc,hbm,
                      nStartScan,nNumScan,
                      pvBits,pbmi,
                      DIB_RGB_COLORS,
                      cjBits,0) == 0)
        {
            WARNING("IcmStretchBlt(): Failed on GetDIBits()\n");

            LOCALFREE(pvBits);
            pvBits = NULL;
        }

        //
        // Fix up the bitmap height, since pvBits only has nNumScan image.
        //
        pbmi->bmiHeader.biHeight = nNumScan;
    }

    if (pvBits)
    {

        if (hSourceColorSpace)
        {
            hOldColorSpace = IcmSetSourceColorSpace(hdc,hSourceColorSpace,pSourceColorSpace,0);
        }

        //
        // Draw the bitmap.
        //
        //  Target - x,y (upper left).
        //  Source - nStartWidth,0 (upper left).
        //
        if (bNoScaling && (rop == SRCCOPY))
        {
            iRet = SetDIBitsToDevice(hdc,x,y,cx,cy,nStartWidth,0,0,nNumScan,
                                     pvBits,pbmi,DIB_RGB_COLORS);
        }
        else
        {
            iRet = StretchDIBits(hdc,x,y,cx,cy,nStartWidth,0,nNumWidth,nNumScan,
                                 pvBits,pbmi,DIB_RGB_COLORS,rop);
        }

        //
        // Back to original color space, if created
        //
        if (hOldColorSpace)
        {
            IcmSetSourceColorSpace(hdc,hOldColorSpace,NULL,0);
        }

        LOCALFREE(pvBits);
    }

    if (hSourceColorSpace)
    {
        DeleteColorSpace(hSourceColorSpace);
    }

    return (BOOL) !!iRet;
}

/******************************Public*Routine******************************\
* IcmGetColorSpaceforBitmap()
*
* History:
*
* Write it:
*   29-May-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PCACHED_COLORSPACE
IcmGetColorSpaceforBitmap(HBITMAP hbm)
{
    ICMAPI(("gdi32: IcmGetColorSpaceforBitmap\n"));

    FIXUP_HANDLE(hbm);

    return ((PCACHED_COLORSPACE)NtGdiGetColorSpaceforBitmap(hbm));
}

/******************************Public*Routine******************************\
* IcmEnableForCompatibleDC()
*
* History:
*
* Write it:
*   13-Jun-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmEnableForCompatibleDC(
    HDC      hdcCompatible,
    HDC      hdcDevice,
    PDC_ATTR pdcaDevice
    )
{
    PDC_ATTR pdcaCompatible;

    ICMAPI(("gdi32: IcmEnableForCompatibleDC\n"));

    PSHARED_GET_VALIDATE(pdcaCompatible,hdcCompatible,DC_TYPE);

    if (pdcaCompatible)
    {
        PGDI_ICMINFO pIcmInfoCompatible;
        PGDI_ICMINFO pIcmInfoDevice;

        // Initialize ICMINFO
        //
        // for device DC, ICMINFO should be presented.
        //
        if ((pIcmInfoDevice = GET_ICMINFO(pdcaDevice)) == NULL)
        {
            WARNING("gdi32: IcmEnableForCompatibleDC: Can't init icm info\n");
            return (FALSE);
        }

        //
        // for compatible DC, it was just created, ICMINFO is not exist, then create here.
        //
        if ((pIcmInfoCompatible = INIT_ICMINFO(hdcCompatible,pdcaCompatible)) == NULL)
        {
            WARNING("gdi32: IcmEnableForCompatibleDC: Can't init icm info\n");
            return (FALSE);
        }

        //
        // Set Source color space as same as original DC
        //
        // Kernel side...
        //
        if (pdcaDevice->hColorSpace)
        {
            if (pdcaDevice->hColorSpace != GetStockObject(PRIV_STOCK_COLORSPACE))
            {
                //
                // Call directly kernel to set the color space to DC. (don't need client stuff)
                //
                NtGdiSetColorSpace(hdcCompatible,(HCOLORSPACE)pdcaDevice->hColorSpace);
            }

            //
            // Keep it in ICMINFO, so that we can un-select it later.
            //
            pIcmInfoCompatible->hDefaultSrcColorSpace = pdcaDevice->hColorSpace;
        }

        // And client side...
        //
        ENTERCRITICALSECTION(&semColorSpaceCache);

        if (pIcmInfoDevice->pSourceColorSpace)
        {
            pIcmInfoCompatible->pSourceColorSpace = pIcmInfoDevice->pSourceColorSpace;
            pIcmInfoCompatible->pSourceColorSpace->cRef++;
        }

        //
        // Set destination color space as same as original DC
        //
        if (pIcmInfoDevice->pDestColorSpace)
        {
            pIcmInfoCompatible->pDestColorSpace = pIcmInfoDevice->pDestColorSpace;
            pIcmInfoCompatible->pDestColorSpace->cRef++;
        }

        LEAVECRITICALSECTION(&semColorSpaceCache);

        //
        // copy default profile name (if they has)
        //
        if (pIcmInfoDevice->DefaultDstProfile[0] != UNICODE_NULL)
        {
            wcscpy(pIcmInfoCompatible->DefaultDstProfile,pIcmInfoDevice->DefaultDstProfile);
            pIcmInfoCompatible->flInfo |= (ICM_VALID_DEFAULT_PROFILE|
                                           ICM_VALID_CURRENT_PROFILE);
        }

        //
        // Make sure we have valid color space.
        //
        pdcaCompatible->ulDirty_ &= ~DIRTY_COLORSPACE;

        //
        // And we don't have valid color transform.
        //
        pdcaCompatible->ulDirty_ |= DIRTY_COLORTRANSFORM;

        if (IS_ICM_INSIDEDC(pdcaDevice->lIcmMode))
        {
            //
            // For compatible DC, use host ICM anytime...
            //
            ULONG ReqIcmMode = REQ_ICM_HOST;

            //
            // Turn ICM on for this compatible DC.
            //
            if (!NtGdiSetIcmMode(hdcCompatible,ICM_SET_MODE,ReqIcmMode))
            {
                //
                // something wrong... we are fail to enable ICM.
                //
                return (FALSE);
            }

            //
            // Update color transform.
            //
            if (!IcmUpdateDCColorInfo(hdcCompatible,pdcaCompatible))
            {
                //
                // Fail to create new transform
                //
                NtGdiSetIcmMode(hdcCompatible,ICM_SET_MODE,REQ_ICM_OFF);
                return (FALSE);
            }
        }
    }

    return (TRUE);
}

/******************************Public*Routine******************************\
* IcmAskDriverForColorProfile
*
* History:
*   08-Oct-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

int
IcmAskDriverForColorProfile(
    PLDC       pldc,
    ULONG      ulQueryMode,
    PDEVMODEW  pDevMode,
    PWSTR      pProfileName,
    DWORD     *pdwColorSpaceFlag
)
{
    INT   iRet;

    BYTE  TempProfileData[MAX_PATH];

    PVOID pvProfileData = (PVOID) TempProfileData;
    ULONG cjProfileSize = sizeof(TempProfileData);
    FLONG flProfileFlag = 0;

    ICMAPI(("gdi32: IcmAskDriverForColorProfile\n"));

    //
    // Call driver to get device profile data.
    //
    iRet = QueryColorProfileEx(pldc,
                                  pDevMode,
                                  ulQueryMode,
                                  pvProfileData,
                                  &cjProfileSize,
                                  &flProfileFlag);

    if (iRet == -1)
    {
        ICMMSG(("gdi32: IcmAskDriverForColorProfile():Driver does not hook color profile\n"));

        //
        // Driver does not support profile hook.
        //
        return iRet;
    }
    else if ((iRet == 0) &&
             (cjProfileSize > sizeof(TempProfileData)) &&
             (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
    {
        ICMMSG(("gdi32: IcmAskDriverForColorProfile():Allocate larger memory\n"));

        //
        // Buffer is not enough, so allocate it.
        //
        pvProfileData = LOCALALLOC(cjProfileSize);

        if (pvProfileData)
        {
            iRet = QueryColorProfileEx(pldc,
                                          pDevMode,
                                          ulQueryMode,
                                          pvProfileData,
                                          &cjProfileSize,
                                          &flProfileFlag);
        }
    }

    if ((iRet > 0) && (pvProfileData != NULL) && (cjProfileSize != 0))
    {
        if (flProfileFlag == QCP_PROFILEDISK)
        {
            ICMMSG(("gdi32: IcmAskDriverForColorProfile():Profiles - %ws\n",pvProfileData));

            //
            // pvProfileData contains filename in Unicode.
            //
            wcsncpy(pProfileName,(PWSTR)pvProfileData,MAX_PATH);
        }
        else if (flProfileFlag == QCP_PROFILEMEMORY)
        {
            //
            // pvProfileData contains color profile itself.
            //

            //
            // No desired name.
            //
            *pProfileName = UNICODE_NULL;

            //
            // Create temporary color profile.
            //
            if (IcmCreateTemporaryColorProfile(pProfileName,pvProfileData,cjProfileSize))
            {
                ICMMSG(("gdi32: IcmAskDriverForColorProfile():Profiles - %ws\n",pProfileName));

                //
                // Mark this as temporary file, so that when this is not used
                // the file will be deleted.
                //
                *pdwColorSpaceFlag = (DRIVER_COLORSPACE | NEED_TO_DEL_PROFILE);
            }
            else
            {
                ICMMSG(("gdi32: IcmAskDriverForColorProfile():Failed to create temp file\n"));

                //
                // failed to create temporary color profile.
                //
                iRet = 0;
            }
        }
        else
        {
            //
            // Unknown data type.
            //
            iRet = 0;
        }
    }
    else
    {
        iRet = 0;
    }

    if (pvProfileData && (pvProfileData != TempProfileData))
    {
        LOCALFREE(pvProfileData);
    }

    return (iRet);
}

/******************************Public*Routine******************************\
* GdiConvertBitmapV5
*
*  pbBitmapData - pointer to BITMAPV4/V5 data
*  iSizeOfBitmapData - size of buffer
*  uConvertFormat - either of CF_DIB or CF_BITMAP
*
* History:
*   12-Dec-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

HANDLE GdiConvertBitmapV5(
    LPBYTE   pbBitmapData,
    int      iSizeOfBitmapData,
    HPALETTE hPalette,
    UINT     uConvertFormat
)
{
    HANDLE hRet = NULL;

    UNREFERENCED_PARAMETER(hPalette);

    ICMAPI(("gdi32: GdiConvertBitmapV5\n"));

    if (pbBitmapData && iSizeOfBitmapData)
    {
        BITMAPINFO       *pbmi        = (BITMAPINFO *)pbBitmapData;
        BITMAPINFOHEADER *pbmih       = &(pbmi->bmiHeader);
        PVOID            pvBits       = NULL;

        ULONG            ulColorTableSize = (ULONG)-1;
        BOOL             bTransColorTable = FALSE;
        BOOL             bMoveColorMasks  = FALSE;

        //
        // Load external ICM dlls.
        //
        LOAD_ICMDLL(NULL);

        //
        // Find the bitmap bits pointer.
        //
        try
        {
            //
            // Calculate color table size.
            //
            if (pbmih->biCompression == BI_BITFIELDS)
            {
                //
                // Bitfields are a part of BITMAPV4/V5 header.
                //
                ulColorTableSize = 0;
                bMoveColorMasks  = TRUE;
            }
            else if (pbmih->biCompression == BI_RGB)
            {
                if (pbmih->biClrUsed)
                {
                    ulColorTableSize = (pbmih->biClrUsed * sizeof(RGBQUAD));

                    if (pbmih->biBitCount <= 8)
                    {
                        bTransColorTable = TRUE;
                    }
                }
                else if (pbmih->biBitCount <= 8)
                {
                    ulColorTableSize = ((1 << pbmih->biBitCount) * sizeof(RGBQUAD));
                    bTransColorTable = TRUE;
                }
                else
                {
                    ulColorTableSize = 0;
                }
            }
            else if (pbmih->biCompression == BI_RLE4)
            {
                ulColorTableSize = 16 * sizeof(RGBQUAD);
                bTransColorTable = TRUE;
            }
            else if (pbmih->biCompression == BI_RLE8)
            {
                ulColorTableSize = 256 * sizeof(RGBQUAD);
                bTransColorTable = TRUE;
            }
            else
            {
                //
                // BI_JPEG, BI_PNG, and others can not convert
                //
                ICMWRN(("GdiConvertBitmapV5: "
                        "given data is BI_JPEG, BI_PNG, or unkown\n"));
            }

            if (ulColorTableSize != (ULONG)-1)
            {
                //
                // Make sure given data is either BITMAPV4 or V5 header.
                //
                if (pbmih->biSize == sizeof(BITMAPV5HEADER))
                {
                    pvBits = (BYTE *)pbmi
                           + sizeof(BITMAPV5HEADER)
                           + ulColorTableSize
                           + ((LPBITMAPV5HEADER)pbmi)->bV5ProfileSize;
                }
                else if (pbmih->biSize != sizeof(BITMAPV4HEADER))
                {
                    pvBits = (BYTE *)pbmi
                           + sizeof(BITMAPV4HEADER)
                           + ulColorTableSize;
                }
                else
                {
                    ICMWRN(("GdiConvertBitmapV5: given data is not bitmapV4/V5\n"));
                }
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            pvBits = NULL;
        }

        if (pvBits)
        {
            if (uConvertFormat == CF_DIB)
            {
                ULONG cjBitmapBits;

                ICMMSG(("GdiConvertBitmapV5(): CF_DIBV5 -----> CF_DIB\n"));

                //
                // Calculate size of bitmap bits
                //
                try
                {
                    cjBitmapBits = cjBitmapBitsSize(pbmi);
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    cjBitmapBits = 0;
                }

                if (cjBitmapBits)
                {
                    //
                    // Allocate buffer for color translation
                    //
                    hRet = GlobalAlloc(GHND,sizeof(BITMAPINFOHEADER)
                                          + (bMoveColorMasks ? (3 * sizeof(DWORD)) : \
                                                               (ulColorTableSize))
                                          + cjBitmapBits);

                    if (hRet)
                    {
                        PBYTE pjSrc  = (PBYTE)pbmi;
                        PBYTE pjDest = GlobalLock(hRet);
                        BOOL  bTransformError = FALSE;

                        if (pjDest)
                        {
                            PROFILE            sRGBColorProfileData;
                            LOGCOLORSPACEW     LogColorSpaceW;
                            PROFILE            ColorProfile;

                            DWORD              dwFlags = 0;
                            HANDLE             hColorTransform = NULL;
                            HANDLE             hsRGBColorProfile = NULL;
                            HANDLE             hBitmapColorProfile = NULL;
                            PCACHED_COLORSPACE pColorSpace = NULL;

                            try
                            {
                                //
                                // Extract color space from BITMAPV4/V5 header.
                                //
                                bTransformError = !(IcmGetBitmapColorSpace(
                                                        pbmi,
                                                        &LogColorSpaceW,
                                                        &ColorProfile,
                                                        &dwFlags));
                            }
                            except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                bTransformError = TRUE;
                            }

                            if (!bTransformError)
                            {
                                //
                                // Create color space and color transform
                                //
                                if ((LogColorSpaceW.lcsCSType == LCS_sRGB) ||
                                    (LogColorSpaceW.lcsCSType == LCS_WINDOWS_COLOR_SPACE))
                                {
                                    ICMMSG(("GdiConvertBitmapV5(): Original bitmap is sRGB\n"));

                                    //
                                    // No color translarion required.
                                    //
                                    hColorTransform = NULL;
                                }
                                else
                                {
                                    //
                                    // Get source color space (if bitmap has color space)
                                    //

                                    //
                                    // First, find ColorSpace from cache.
                                    //
                                    pColorSpace = IcmGetColorSpaceByColorSpace(
                                                      (HGDIOBJ)NULL,
                                                      &LogColorSpaceW,
                                                      &ColorProfile,
                                                      dwFlags);

                                    if (pColorSpace == NULL)
                                    {
                                        pColorSpace = IcmCreateColorSpaceByColorSpace(
                                                          (HGDIOBJ)NULL,
                                                          &LogColorSpaceW,
                                                          &ColorProfile,
                                                          dwFlags);
                                    }

                                    if (pColorSpace && IcmRealizeColorProfile(pColorSpace,TRUE))
                                    {
                                        hBitmapColorProfile = pColorSpace->hProfile;
                                    }

                                    //
                                    // Open sRGB color space profile as destination color space.
                                    //
                                    sRGBColorProfileData.dwType = PROFILE_FILENAME;
                                    sRGBColorProfileData.pProfileData = (PVOID)sRGB_PROFILENAME;
                                    sRGBColorProfileData.cbDataSize = MAX_PATH * sizeof(WCHAR);

                                    hsRGBColorProfile = (*fpOpenColorProfileW)(
                                                            &sRGBColorProfileData,
                                                            PROFILE_READ,
                                                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                            OPEN_EXISTING);

                                    if (hBitmapColorProfile && hsRGBColorProfile)
                                    {
                                        DWORD    ahIntents[2];
                                        HPROFILE ahProfiles[2];

                                        ahIntents[0]  = INTENT_RELATIVE_COLORIMETRIC;
                                        ahIntents[1]  = pColorSpace->ColorIntent;
                                        ahProfiles[0] = hBitmapColorProfile;
                                        ahProfiles[1] = hsRGBColorProfile;

                                        hColorTransform = (*fpCreateMultiProfileTransform)(
                                                              ahProfiles, 2,
                                                              ahIntents, 2,
                                                              NORMAL_MODE | ENABLE_GAMUT_CHECKING,
                                                              INDEX_DONT_CARE);
                                    }

                                    if (!hColorTransform)
                                    {
                                        bTransformError = TRUE;
                                    }
                                }

                                if (!bTransformError)
                                {
                                    //
                                    // Copy the bitmap to target with proper color space conversion.
                                    //
                                    try
                                    {
                                        BITMAPV5HEADER *pbm5h = (BITMAPV5HEADER *)pbmi;

                                        //
                                        // Copy bitmap header to target.
                                        //
                                        RtlCopyMemory(pjDest,pjSrc,sizeof(BITMAPINFOHEADER));

                                        //
                                        // Adjust bmHeader.biSize
                                        //
                                        ((BITMAPINFOHEADER *)pjDest)->biSize = sizeof(BITMAPINFOHEADER);

                                        //
                                        // Move src and dest pointers
                                        //
                                        pjSrc  += pbmih->biSize;
                                        pjDest += sizeof(BITMAPINFOHEADER);

                                        //
                                        // Copy bit mask or color table.
                                        //
                                        if (bMoveColorMasks)
                                        {
                                            //
                                            // Move color masks. cast it to pointer to BITMAPV5HEADER
                                            // since same offset on BITMAPV4HEADER too.
                                            //

                                            *(DWORD *)pjDest = pbm5h->bV5RedMask;
                                            pjDest += sizeof(DWORD);
                                            *(DWORD *)pjDest = pbm5h->bV5GreenMask;
                                            pjDest += sizeof(DWORD);
                                            *(DWORD *)pjDest = pbm5h->bV5BlueMask;
                                            pjDest += sizeof(DWORD);
                                        }
                                        else
                                        {
                                            if (ulColorTableSize)
                                            {
                                                if (bTransColorTable && hColorTransform)
                                                {
                                                    bTransformError = !(*fpTranslateBitmapBits)(
                                                                           hColorTransform,
                                                                           pjSrc, BM_xRGBQUADS,
                                                                           ulColorTableSize/sizeof(RGBQUAD), 1,
                                                                           0,
                                                                           pjDest, BM_xRGBQUADS,
                                                                           0,NULL,0);
                                                }
                                                else
                                                {
                                                    RtlCopyMemory(pjDest,pjSrc,ulColorTableSize);
                                                }

                                                pjSrc  += ulColorTableSize;
                                                pjDest += ulColorTableSize;
                                            }
                                        }

                                        if (bTransColorTable || (hColorTransform == NULL))
                                        {
                                            //
                                            // All the color information is in the color table. and
                                            // it has been translated, so just copy bitmap bits.
                                            //
                                            RtlCopyMemory(pjDest,pvBits,cjBitmapBits);
                                        }
                                        else
                                        {
                                            //
                                            // Translate bitmap bits.
                                            //
                                            BMFORMAT bmColorType;

                                            //
                                            // Get BMFORMAT based on bitmap format.
                                            //
                                            if (pbmih->biBitCount == 16)
                                            {
                                                if (pbmih->biCompression == BI_RGB)
                                                {
                                                    bmColorType = BM_x555RGB;
                                                }
                                                else if (pbmih->biCompression == BI_BITFIELDS)
                                                {
                                                    if ((pbm5h->bV5RedMask   == 0x007c00) &&
                                                        (pbm5h->bV5GreenMask == 0x0003e0) &&
                                                        (pbm5h->bV5BlueMask  == 0x00001f))
                                                    {
                                                        bmColorType = BM_x555RGB;
                                                    }
                                                    else if ((pbm5h->bV5RedMask   == 0x00f800) &&
                                                             (pbm5h->bV5GreenMask == 0x0007e0) &&
                                                             (pbm5h->bV5BlueMask  == 0x00001f))
                                                    {
                                                        bmColorType = BM_565RGB;
                                                    }
                                                    else
                                                    {
                                                        ICMWRN(("GdiConvertBitmapV5: Bad Bitfields Mask for 16 bpp\n"));
                                                        bTransformError = TRUE;
                                                    }
                                                }
                                                else
                                                {
                                                    ICMWRN(("GdiConvertBitmapV5: Bad biCompression for 16 bpp\n"));
                                                    bTransformError = TRUE;
                                                }
                                            }
                                            else if (pbmih->biBitCount == 24)
                                            {
                                                bmColorType = BM_RGBTRIPLETS;
                                            }
                                            else if (pbmih->biBitCount == 32)
                                            {
                                                if (pbmih->biCompression == BI_RGB)
                                                {
                                                    bmColorType = BM_xRGBQUADS;
                                                }
                                                else if (pbmih->biCompression == BI_BITFIELDS)
                                                {
                                                    if ((pbm5h->bV5RedMask   == 0x0000ff) &&  /* Red */
                                                        (pbm5h->bV5GreenMask == 0x00ff00) &&  /* Green */
                                                        (pbm5h->bV5BlueMask  == 0xff0000))    /* Blue */
                                                    {
                                                        bmColorType = BM_xBGRQUADS;
                                                    }
                                                    else if ((pbm5h->bV5RedMask   == 0xff0000) &&  /* Red */
                                                             (pbm5h->bV5GreenMask == 0x00ff00) &&  /* Green */
                                                             (pbm5h->bV5BlueMask  == 0x0000ff))    /* Blue */
                                                    {
                                                        bmColorType = BM_xRGBQUADS;
                                                    }
                                                    else
                                                    {
                                                        ICMWRN(("GdiConvertBitmapV5: Bad Bitfields Mask for 32 bpp\n"));
                                                        bTransformError = TRUE;
                                                    }
                                                }
                                                else
                                                {
                                                    ICMWRN(("GdiConvertBitmapV5: Bad biCompression for 32 bpp\n"));
                                                    bTransformError = TRUE;
                                                }
                                            }
                                            else
                                            {
                                                ICMWRN(("GdiConvertBitmapV5: Bad biBitCount\n"));
                                                bTransformError = TRUE;
                                            }

                                            if (!bTransformError)
                                            {
                                                bTransformError = !(*fpTranslateBitmapBits)(
                                                                       hColorTransform,
                                                                       pvBits, bmColorType,
                                                                       pbmih->biWidth,
                                                                       ABS(pbmih->biHeight),
                                                                       0,
                                                                       pjDest, bmColorType,
                                                                       0,NULL,0);
                                            }
                                        }
                                    }
                                    except(EXCEPTION_EXECUTE_HANDLER)
                                    {
                                        bTransformError = TRUE;
                                    }
                                }

                                //
                                // Clean up used color transform and color profile handles
                                //
                                if (hColorTransform)
                                {
                                    (*fpDeleteColorTransform)(hColorTransform);
                                }

                                if (hsRGBColorProfile)
                                {
                                    (*fpCloseColorProfile)(hsRGBColorProfile);
                                }

                                if (pColorSpace)
                                {
                                    IcmReleaseColorSpace(NULL,pColorSpace,FALSE);
                                }
                            }
                        }

                        GlobalUnlock(hRet);

                        if (bTransformError)
                        {
                            GlobalFree(hRet);
                            hRet = NULL;
                        }
                    }
                    else
                    {
                        ICMWRN(("GdiConvertBitmapV5: Fail on GlobalAlloc()\n"));
                    }
                }
                else
                {
                    ICMWRN(("GdiConvertBitmapV5: cjBitmapBits is 0\n"));
                }

                return (hRet);
            }
            else if (uConvertFormat == CF_BITMAP)
            {
                HDC     hDC = GetDC(NULL);
                HBITMAP hBitmap = NULL;

                if (hDC)
                {
                    ICMMSG(("GdiConvertBitmapV5(): CF_DIBV5 -----> CF_BITMAP\n"));

                    //
                    // Set destination color space as sRGB, and enable ICM.
                    //
                    if (IcmSetDestinationColorSpace(hDC,sRGB_PROFILENAME,NULL,0) &&
                        SetICMMode(hDC,ICM_ON))
                    {
                        try
                        {
                            //
                            // Create bitmap handle with given bitmap V5 data.
                            //
                            hBitmap = CreateDIBitmap(hDC,
                                                     pbmih,
                                                     CBM_INIT,
                                                     pvBits,
                                                     pbmi,
                                                     DIB_RGB_COLORS);
                        }
                        except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            hBitmap = NULL;
                        }

                        if (!hBitmap)
                        {
                            ICMWRN(("GdiConvertBitmapV5: Fail on CreateDIBitmap()\n"));
                        }
                    }

                    //
                    // Clean up DC
                    //
                    SetICMMode(hDC,ICM_OFF);
                    ReleaseDC(NULL,hDC);
                }

                return ((HANDLE)hBitmap);
            }
            else
            {
                ICMWRN(("GdiConvertBitmapV5(): CF_DIBV5 -----> Unknown\n"));
            }
        }
    }

    return (hRet);
}

/******************************Public*Routine******************************\
* IcmSetTargetColorSpace()
*
* History:
*    8-Jun-1998 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmSetTargetColorSpace(
    HDC                hdc,
    PCACHED_COLORSPACE pTargetColorSpace,
    DWORD              uiAction
    )
{
    BOOL     bRet = FALSE;
    PDC_ATTR pdcattr;
    PGDI_ICMINFO pIcmInfo;

    ICMAPI(("gdi32: IcmSetTargetColorSpace\n"));

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr == NULL)
    {
        return (FALSE);
    }

    if ((pIcmInfo = GET_ICMINFO(pdcattr)) == NULL)
    {
        return (FALSE);
    }

    switch (uiAction)
    {
        case CS_ENABLE:
        {
            //
            // Check validation of given Target color space.
            //
            if (pTargetColorSpace != NULL)
            {
                PCACHED_COLORTRANSFORM pCXform;
                BOOL bDeleteOldCXform = FALSE;

                //
                // Mark we are in proofing mode.
                //
                SET_ICM_PROOFING(pdcattr->lIcmMode);

                if ((pIcmInfo->pProofCXform != NULL) &&
                    IcmSameColorSpace(pTargetColorSpace,pIcmInfo->pTargetColorSpace))
                {
                    ICMMSG(("IcmSetTargetColorSpace():Use Cached Proof Transform\n"));

                    ENTERCRITICALSECTION(&semColorTransformCache);

                    //
                    // the cached proofing transform is still valid.
                    //
                    pCXform = pIcmInfo->pProofCXform;

                    if (pCXform)
                    {
                        //
                        // Increment ref count of it.
                        //
                        pCXform->cRef++;
                    }

                    LEAVECRITICALSECTION(&semColorTransformCache);
                }
                else
                {
                    ICMMSG(("IcmSetTargetColorSpace():Create New Proof Transform\n"));

                    //
                    // We don't have cached color space or it is no longer valid.
                    //

                    //
                    // Check we still have cached color space and it's still valid ?
                    //
                    if (pIcmInfo->pTargetColorSpace &&
                        IcmSameColorSpace(pTargetColorSpace,pIcmInfo->pTargetColorSpace))
                    {
                        //
                        // Cached target color space are still valid, keep as is.
                        //
                    }
                    else
                    {
                        //
                        // Release old target color space.
                        //
                        IcmReleaseColorSpace(NULL,pIcmInfo->pTargetColorSpace,FALSE);

                        //
                        // Increment ref count of it.
                        //
                        IcmReferenceColorSpace(pTargetColorSpace);

                        //
                        // set target destination profile into current DC as target profile
                        //
                        pIcmInfo->pTargetColorSpace = pTargetColorSpace;
                    }

                    //
                    // create new transform
                    //
                    pCXform = IcmCreateColorTransform(hdc,pdcattr,NULL,ICM_FORWARD);

                    //
                    // Marks as need to delete old color transform if we have.
                    //
                    bDeleteOldCXform = pIcmInfo->pProofCXform ? TRUE : FALSE;
                }

                if ((pCXform == IDENT_COLORTRANSFORM) || (pCXform == NULL))
                {
                    //
                    // Invalidate color transform
                    //
                    IcmSelectColorTransform(hdc,pdcattr,NULL,
                                            bDeviceCalibrate(pIcmInfo->pDestColorSpace));

                    //
                    // Delete old color transform.
                    //
                    if (bDeleteOldCXform)
                    {
                        //
                        // Delete cached proofing color transform
                        //
                        IcmDeleteColorTransform(pIcmInfo->pProofCXform,FALSE);
                    }

                    //
                    // Set null color transform to ICMINFO
                    //
                    pIcmInfo->pProofCXform = NULL;

                    if (pCXform == IDENT_COLORTRANSFORM)
                    {
                        ICMMSG(("IcmSetTargetColorSpace():Input & Output colorspace is same\n"));

                        //
                        // Input & Destination & Target color space is same, there is
                        // no color translation needed.
                        //
                        bRet = TRUE;
                    }
                    else
                    {
                        ICMWRN(("IcmSetTargetColorSpace():Fail to create color transform\n"));
                    }

                    //
                    // Translate back to DC color object to original
                    //
                    IcmTranslateColorObjects(hdc,pdcattr,FALSE);
                }
                else
                {
                    //
                    // Select the color transform to DC.
                    //
                    IcmSelectColorTransform(hdc,pdcattr,pCXform,
                                            bDeviceCalibrate(pCXform->DestinationColorSpace));

                    //
                    // Delete old color transform.
                    //
                    if (bDeleteOldCXform)
                    {
                        //
                        // Delete cached proofing color transform
                        //
                        IcmDeleteColorTransform(pIcmInfo->pProofCXform,FALSE);
                    }

                    //
                    // Set new color transform to ICMINFO.
                    //
                    pIcmInfo->pProofCXform = pCXform;

                    //
                    // Initialize color attributes in this DC.
                    //
                    IcmTranslateColorObjects(hdc,pdcattr,TRUE);

                    bRet = TRUE;
                }
            }
            else
            {
                GdiSetLastError(ERROR_INVALID_PARAMETER);
                WARNING("IcmSetTargetColorSpace: target color space is NULL\n");

                //
                // Anyway, just re-initialize without target profile.
                //
                IcmTranslateColorObjects(hdc,pdcattr,TRUE);
            }

            if (!bRet)
            {
                //
                // if failed, mask off as we are not in proofing mode
                //
                CLEAR_ICM_PROOFING(pdcattr->lIcmMode);

                if (pIcmInfo->pTargetColorSpace)
                {
                    //
                    // Release target color space.
                    //
                    IcmReleaseColorSpace(NULL,pIcmInfo->pTargetColorSpace,FALSE);

                    //
                    // Disable target profile.
                    //
                    pIcmInfo->pTargetColorSpace = NULL;
                }
            }

            break;
        }

        case CS_DISABLE:
        case CS_DELETE_TRANSFORM:
        {
            //
            // We are going to be out of proofing mode.
            //
            CLEAR_ICM_PROOFING(pdcattr->lIcmMode);

            if (pdcattr->ulDirty_ & DIRTY_COLORTRANSFORM)
            {
                if (uiAction == CS_DELETE_TRANSFORM)
                {
                    if (pIcmInfo->pTargetColorSpace)
                    {
                        //
                        // Release target color space.
                        //
                        IcmReleaseColorSpace(NULL,pIcmInfo->pTargetColorSpace,FALSE);

                        //
                        // Disable target profile.
                        //
                        pIcmInfo->pTargetColorSpace = NULL;
                    }
                }

                //
                // While DC is in proofing mode, the source or
                // destination color space has been changed by
                // SetColorSpace() or SetICMProfile(). So,
                // we will reset all color transform in this
                // DC.
                //
                if (IcmUpdateDCColorInfo(hdc,pdcattr))
                {
                    bRet = TRUE;
                }
                else
                {
                    GdiSetLastError(ERROR_DELETING_ICM_XFORM);
                }
            }
            else
            {
                //
                // We are leaving proofing mode, Select back the normal colortransform into DC.
                //
                IcmSelectColorTransform(hdc,pdcattr,pIcmInfo->pCXform,
                                        bDeviceCalibrate(pIcmInfo->pDestColorSpace));

                //
                // The color transform cache will effective...
                //
                if (uiAction == CS_DELETE_TRANSFORM)
                {
                    if (pIcmInfo->pTargetColorSpace)
                    {
                        //
                        // Release target color space.
                        //
                        IcmReleaseColorSpace(NULL,pIcmInfo->pTargetColorSpace,FALSE);

                        //
                        // Disable target profile.
                        //
                        pIcmInfo->pTargetColorSpace = NULL;
                    }

                    //
                    // Delete ONLY proofing color transform (if it is)
                    //
                    if (pIcmInfo->pProofCXform)
                    {
                        if (!IcmDeleteColorTransform(pIcmInfo->pProofCXform,FALSE))
                        {
                            GdiSetLastError(ERROR_DELETING_ICM_XFORM);
                            return (FALSE);
                        }

                        //
                        // There is no proofing transform in this ICMINFO.
                        //
                        pIcmInfo->pProofCXform = NULL;
                    }
                }

                bRet = TRUE;
            }

            if (bRet)
            {
                //
                // Initialize color attributes in this DC.
                //
                IcmTranslateColorObjects(hdc,pdcattr,TRUE);
            }

            break;
        }

        default:
        {
            WARNING("IcmSetTargetColorSpace: uiAction is invalid\n");
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* IcmSetDestinationColorSpace()
*
* History:
*   17-Jul-1998 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmSetDestinationColorSpace(
    HDC                hdc,
    LPWSTR             pwszFileName,
    PCACHED_COLORSPACE pColorSpace,
    DWORD              dwFlags
    )
{
    BOOL      bRet = FALSE;
    PDC_ATTR  pdcattr;

    ULONG     FileNameSize;

    if (pColorSpace)
    {
        ICMAPI(("gdi32: IcmSetDestinationColorSpace by ColorSpace (%ws):dwFlags - %d\n",
                           pColorSpace->LogColorSpace.lcsFilename,dwFlags));
    }
    else if (pwszFileName)
    {
        ICMAPI(("gdi32: IcmSetDestinationColorSpace by profile name (%ws):dwFlags - %x\n",
                                                     pwszFileName,dwFlags));

        //
        // Check filename
        //
        if (pwszFileName)
        {
            FileNameSize = lstrlenW(pwszFileName);
        }

        if ((FileNameSize == 0) || (FileNameSize > MAX_PATH))
        {
            ICMWRN(("IcmSetDestinatonColorSpace - no or too long profile name\n"));
            return FALSE;
        }
    }
    else
    {
        ICMAPI(("gdi32: IcmSetDestinationColorSpace - invalid parameter\n"));
        return FALSE;
    }

    FIXUP_HANDLE(hdc);

    //
    // We are going to try to select this color space into thisDC,
    // default is false.
    //
    bRet = FALSE;

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    //
    // Profile filename or pColorSpace should be presented.
    //
    if (pdcattr)
    {
        PGDI_ICMINFO pIcmInfo;

        //
        // Initialize ICMINFO
        //
        if ((pIcmInfo = INIT_ICMINFO(hdc,pdcattr)) == NULL)
        {
            WARNING("gdi32: IcmSetDestinationColorSpace: Can't init icm info\n");
            return(FALSE);
        }

        if (IsColorDeviceContext(hdc))
        {
            PCACHED_COLORSPACE pNewColorSpace = NULL;

            //
            // Load external ICM dlls.
            //
            LOAD_ICMDLL(FALSE);

            if (pColorSpace == NULL)
            {
                //
                // Find colorspace from cache
                //
                pNewColorSpace = IcmGetColorSpaceByName(
                                     (HGDIOBJ)hdc,
                                     pwszFileName,
                                     pIcmInfo->dwDefaultIntent,
                                     dwFlags);

                if (pNewColorSpace == NULL)
                {
                    ICMMSG(("IcmSetDestinationColorSpace():This is new color space, create it\n"));

                    //
                    // Can not find, Create new one
                    //
                    pNewColorSpace = IcmCreateColorSpaceByName(
                                         (HGDIOBJ)hdc,
                                         pwszFileName,
                                         pIcmInfo->dwDefaultIntent,
                                         dwFlags);
                }
            }
            else
            {
                //
                // Increment ref count of given color space
                //
                IcmReferenceColorSpace(pColorSpace);

                //
                // Use pColorSpace from parameter.
                //
                pNewColorSpace = pColorSpace;
            }

            //
            // We are going to select this colorspace onto DC. and free previous profile.
            //
            if (pNewColorSpace)
            {
                PCACHED_COLORSPACE pOldColorSpace = pIcmInfo->pDestColorSpace;

                //
                // Is this same destination color space currently selected in DC ?
                //
                if (IcmSameColorSpace(pNewColorSpace,pIcmInfo->pDestColorSpace))
                {
                    //
                    // Yes, early-out. We don't need new color space.
                    //
                    IcmReleaseColorSpace(NULL,pNewColorSpace,FALSE);
                    return (TRUE);
                }

                //
                // Before change destination color space, we need to flush batched gdi functions.
                //
                CHECK_AND_FLUSH(hdc,pdcattr);

                //
                // Check new color format is accepted by this DC or not.
                //
                if (!NtGdiSetIcmMode(hdc,ICM_CHECK_COLOR_MODE,pNewColorSpace->ColorFormat))
                {
                    ICMWRN(("IcmSetDestinationColorSpace(): DC does not accept this color format\n"));
                    GdiSetLastError(ERROR_INVALID_PROFILE);
                }
                else
                {
                    //
                    // Set new color space into DC.
                    //
                    pIcmInfo->pDestColorSpace = pNewColorSpace;

                    //
                    // Remove dirty transform flag.
                    //
                    pdcattr->ulDirty_ &= ~DIRTY_COLORSPACE;

                    if (IS_ICM_INSIDEDC(pdcattr->lIcmMode) && !IS_ICM_PROOFING(pdcattr->lIcmMode))
                    {
                        PCACHED_COLORTRANSFORM pCXform;

                        //
                        // create new color transform base on new colorspace
                        //
                        pCXform = IcmCreateColorTransform(hdc,pdcattr,NULL,ICM_FORWARD);

                        if (pCXform == IDENT_COLORTRANSFORM)
                        {
                            //
                            // Select null color transform to DC.
                            //
                            IcmSelectColorTransform(hdc,pdcattr,NULL,
                                                    bDeviceCalibrate(pIcmInfo->pDestColorSpace));

                            //
                            // delete old color transform in DC.
                            //
                            IcmDeleteDCColorTransforms(pIcmInfo);

                            //
                            // Select null color transform to ICMINFO.
                            //
                            pIcmInfo->pCXform = NULL;

                            //
                            // back it to original color (non-ICMed color).
                            //
                            IcmTranslateColorObjects(hdc,pdcattr,FALSE);

                            //
                            // And, everything O.K.
                            //
                            bRet = TRUE;
                        }
                        else if (pCXform)
                        {
                            //
                            // Select the colortransform into DC.
                            //
                            if (IcmSelectColorTransform(
                                    hdc,pdcattr,pCXform,
                                    bDeviceCalibrate(pCXform->DestinationColorSpace)))
                            {
                                //
                                // delete old color transform in DC.
                                //
                                IcmDeleteDCColorTransforms(pIcmInfo);

                                //
                                // Select it to ICMINFO.
                                //
                                pIcmInfo->pCXform = pCXform;

                                //
                                // Adjust to new color transform.
                                //
                                IcmTranslateColorObjects(hdc,pdcattr,TRUE);

                                //
                                // And, everything O.K.
                                //
                                bRet = TRUE;
                            }
                            else
                            {
                                //
                                // Failed to select it to the DC in client side.
                                // so delete it and invalidate pCXform.
                                //
                                IcmDeleteColorTransform(pCXform,FALSE);
                                pCXform = NULL;
                            }
                        }

                        if (pCXform == NULL)
                        {
                            //
                            // Failed to create/select color stransform,
                            // so put back previous color space.
                            //
                            pIcmInfo->pDestColorSpace = pOldColorSpace;
                        }
                    }
                    else
                    {
                        //
                        // if ICM is not turned on currently, we just mark
                        // cached color transform is no longer valid.
                        //
                        pdcattr->ulDirty_ |= DIRTY_COLORTRANSFORM;

                        // For ColorMatchToTarget()
                        //
                        // While color matching to the target is enabled by setting
                        // uiAction to CS_ENABLE, application changes to the color
                        // space or gamut matching method are ignored.
                        // Those changes then take effect when color matching to
                        // the target is disabled.
                        //
                        if (IS_ICM_PROOFING(pdcattr->lIcmMode))
                        {
                            ICMMSG(("IcmSetDestinationColorSpace():In Proofing mode, lazy setting...\n"));
                        }

                        bRet = TRUE;
                    }
                }

                if (bRet)
                {
                    //
                    // We are succeeded to select new color space, then
                    // close and free references to old color space.
                    //
                    IcmReleaseColorSpace(NULL,pOldColorSpace,FALSE);
                }
                else
                {
                    //
                    // We will not use this color space as destination color space,
                    // because 1) DC does not accept this color space, 2) Fail to
                    // create color transform based on this color space.
                    //
                    IcmReleaseColorSpace(NULL,pNewColorSpace,FALSE);
                }
            }
            else
            {
                GdiSetLastError(ERROR_PROFILE_NOT_FOUND);
            }
        }
        else
        {
            ICMMSG(("IcmSetDestinationColorSpace(): for Mono-device\n"));

            //
            // Just copy Apps specifyed profile to internal buffer, which will
            // be return to app by GetICMProfile(), but it is NEVER used for
            // non-color device other than that case, since there is no ICM
            // happen.
            //
            wcsncpy(pIcmInfo->DefaultDstProfile,pwszFileName,MAX_PATH);

            //
            // This is not default profile, but current profile.
            //
            pIcmInfo->flInfo &= ~ICM_VALID_DEFAULT_PROFILE;
            pIcmInfo->flInfo |= ICM_VALID_CURRENT_PROFILE;
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* IcmSetSourceColorSpace()
*
* History:
*   17-Jul-1998 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

HCOLORSPACE
IcmSetSourceColorSpace(
    HDC                hdc,
    HCOLORSPACE        hColorSpace,
    PCACHED_COLORSPACE pColorSpace,
    DWORD              dwFlags)
{
    HANDLE hRet = NULL;
    PDC_ATTR pdcattr;

    ICMAPI(("gdi32: IcmSetSourceColorSpace\n"));

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hColorSpace);

    //
    // validate and access hdc
    //
    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        PGDI_ICMINFO pIcmInfo;

        //
        // Initialize ICMINFO
        //
        if ((pIcmInfo = INIT_ICMINFO(hdc,pdcattr)) == NULL)
        {
            WARNING("gdi32: IcmSetSourceColorSpace: Can't init icm info\n");
            return(NULL);
        }

        if (pdcattr->hColorSpace != hColorSpace)
        {
            //
            // Before change source color space, we need to flush batched gdi functions.
            //
            CHECK_AND_FLUSH(hdc,pdcattr);

            //
            // Return Old (currently selected) color space handle.
            //
            hRet = pdcattr->hColorSpace;

            //
            // set new color space, call kernel to keep reference count tracking
            // of colospace object
            //
            if (NtGdiSetColorSpace(hdc,hColorSpace))
            {
                if (IsColorDeviceContext(hdc))
                {
                    PCACHED_COLORSPACE pNewColorSpace;
                    LOGCOLORSPACEW     LogColorSpaceW;

                    RtlZeroMemory(&LogColorSpaceW,sizeof(LOGCOLORSPACEW));

                    //
                    // Load external ICM dlls.
                    //
                    LOAD_ICMDLL(NULL);

                    if (pColorSpace == NULL)
                    {
                        //
                        // Check if there is client-cached colorspace for this or not.
                        //
                        pNewColorSpace = IcmGetColorSpaceByHandle(
                                             (HGDIOBJ)hdc,
                                             hColorSpace,
                                             &LogColorSpaceW,dwFlags);

                        //
                        // If we can not find from cache, but succeeded to obtain
                        // valid logcolorspace from handle, create new one.
                        //
                        if ((pNewColorSpace == NULL) &&
                            (LogColorSpaceW.lcsSignature == LCS_SIGNATURE))
                        {
                            //
                            // Create new one.
                            //
                            pNewColorSpace = IcmCreateColorSpaceByColorSpace(
                                                 (HGDIOBJ)hdc,
                                                 &LogColorSpaceW,
                                                 NULL,
                                                 dwFlags);
                        }
                    }
                    else
                    {
                        //
                        // Increment ref count of given color space
                        //
                        IcmReferenceColorSpace(pColorSpace);

                        //
                        // Use pColorSpace from parameter.
                        //
                        pNewColorSpace = pColorSpace;
                    }

                    //
                    // Update current source color space to new one.
                    //
                    if (pNewColorSpace)
                    {
                        PCACHED_COLORSPACE pOldColorSpace = pIcmInfo->pSourceColorSpace;

                        //
                        // Check the colorspace is same one as currently selected ?
                        //
                        if (IcmSameColorSpace(pNewColorSpace,pIcmInfo->pSourceColorSpace))
                        {
                            //
                            // This is the "actually" same color space, but differrent handle,
                            // don't need to update
                            //
                            IcmReleaseColorSpace(NULL,pNewColorSpace,FALSE);
                            return (hRet);
                        }

                        //
                        // Source color space should be RGB color space.
                        //
                        if (pNewColorSpace->ColorFormat != BM_xBGRQUADS)
                        {
                            ICMWRN(("IcmSetSourceColorSpace():Source color space is not RGB\n"));

                            //
                            // Set back previous color space. (can't fail these calls)
                            //
                            IcmReleaseColorSpace(NULL,pNewColorSpace,FALSE);
                            NtGdiSetColorSpace(hdc,hRet);
                            GdiSetLastError(ERROR_INVALID_COLORSPACE);
                            return (NULL);
                        }

                        //
                        // And set new color space.
                        //
                        pIcmInfo->pSourceColorSpace = pNewColorSpace;

                        //
                        // if ICM is enabled, needs update color transform, right now.
                        //
                        if (IS_ICM_INSIDEDC(pdcattr->lIcmMode) && !IS_ICM_PROOFING(pdcattr->lIcmMode))
                        {
                            PCACHED_COLORTRANSFORM pCXform;

                            //
                            // create new color transform
                            //
                            pCXform = IcmCreateColorTransform(hdc,pdcattr,NULL,ICM_FORWARD);

                            if (pCXform == IDENT_COLORTRANSFORM)
                            {
                                ICMMSG(("IcmSetSourceColorSpace():Input & Output colorspace is same\n"));

                                //
                                // select NULL transform into DC.
                                //
                                IcmSelectColorTransform(hdc,pdcattr,NULL,
                                                        bDeviceCalibrate(pIcmInfo->pDestColorSpace));

                                //
                                // delete old colorspace/transform from ICMINFO.
                                //
                                IcmDeleteDCColorTransforms(pIcmInfo);

                                //
                                // select NULL tranform to ICMINFO.
                                //
                                pIcmInfo->pCXform = NULL;

                                //
                                // Set DC objects color to non-ICMed color.
                                //
                                IcmTranslateColorObjects(hdc,pdcattr,FALSE);
                            }
                            else if (pCXform)
                            {
                                //
                                // Select the color transform to DC.
                                //
                                if (IcmSelectColorTransform(
                                        hdc,pdcattr,pCXform,
                                        bDeviceCalibrate(pCXform->DestinationColorSpace)))
                                {
                                    //
                                    // delete old colorspace/transform from ICMINFO.
                                    //
                                    IcmDeleteDCColorTransforms(pIcmInfo);

                                    //
                                    // select new color transform to ICMINFO.
                                    //
                                    pIcmInfo->pCXform = pCXform;

                                    //
                                    // Succeed to select into DC, Validate DC color objects
                                    //
                                    IcmTranslateColorObjects(hdc,pdcattr,TRUE);
                                }
                                else
                                {
                                    //
                                    // Failed to select it to the DC in client side.
                                    // so delete it and invalidate pCXform.
                                    //
                                    IcmDeleteColorTransform(pCXform,FALSE);
                                    pCXform = NULL;
                                }
                            }

                            if (pCXform == NULL)
                            {
                                ICMMSG(("IcmSetSourceColorSpace():Fail to create/select color transform\n"));

                                //
                                // Set back previous color space. (can't fail these calls)
                                //
                                pIcmInfo->pSourceColorSpace = pOldColorSpace;
                                NtGdiSetColorSpace(hdc,hRet);
                                hRet = NULL;
                            }
                        }
                        else
                        {
                            //
                            // Otherwise, we just mark color transform might be dirty.
                            // Because new color space was selected.
                            //
                            pdcattr->ulDirty_ |= DIRTY_COLORTRANSFORM;

                            // For ColorMatchToTarget()
                            //
                            // While color matching to the target is enabled by setting
                            // uiAction to CS_ENABLE, application changes to the color
                            // space or gamut matching method are ignored.
                            // Those changes then take effect when color matching to
                            // the target is disabled.
                            //
                            if (IS_ICM_PROOFING(pdcattr->lIcmMode))
                            {
                                ICMMSG(("IcmSetSourceColorSpace():In Proofing mode, lazy setting...\n"));
                            }
                        }

                        if (hRet)
                        {
                            //
                            // Succeed to select new color space, then delete old one.
                            //
                            IcmReleaseColorSpace(NULL,pOldColorSpace,FALSE);
                        }
                        else
                        {
                            IcmReleaseColorSpace(NULL,pNewColorSpace,FALSE);
                        }
                    }
                }
                else
                {
                    ICMMSG(("IcmSetSourceColorSpace(): for Mono-device\n"));

                    //
                    // For monochrome device case, just return kernel color space
                    // handle, then just don't create client-side representitive,
                    // since there is no ICM for monochrome device.
                    //
                }
            }
            else
            {
                WARNING("Error: hdc and hColorSpace check out but NtGdi call failed\n");
                hRet = NULL;
            }
        }
        else
        {
            //
            // Same color space was selected, just return current.
            //
            hRet = hColorSpace;
        }
    }

    if (hRet == NULL)
    {
        GdiSetLastError(ERROR_INVALID_COLORSPACE);
    }

    return (hRet);
}

/******************************Public*Routine******************************\
* IcmSaveDC()
*
* History:
*    7-Dec-1998 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmSaveDC(
    HDC hdc,
    PDC_ATTR pdcattr,
    PGDI_ICMINFO pIcmInfo)
{
    BOOL bRet = TRUE;

    ICMAPI(("gdi32: IcmSaveDC\n"));

    if (pdcattr && pIcmInfo)
    {
        //
        // Get currect saved level.
        //
        DWORD dwCurrentSavedDepth;

        if (NtGdiGetDCDword(hdc,DDW_SAVEDEPTH,&dwCurrentSavedDepth))
        {
            PSAVED_ICMINFO pSavedIcmInfo = LOCALALLOC(sizeof(SAVED_ICMINFO));

            if (pSavedIcmInfo)
            {
                PCACHED_COLORSPACE pSourceColorSpace = pIcmInfo->pSourceColorSpace;
                PCACHED_COLORSPACE pDestColorSpace   = pIcmInfo->pDestColorSpace;
                PCACHED_COLORSPACE pTargetColorSpace = pIcmInfo->pTargetColorSpace;
                PCACHED_COLORTRANSFORM pCXform       = pIcmInfo->pCXform;
                PCACHED_COLORTRANSFORM pBackCXform   = pIcmInfo->pBackCXform;
                PCACHED_COLORTRANSFORM pProofCXform  = pIcmInfo->pProofCXform;

                //
                // Increment reference count of color spaces in DC.
                //
                IcmReferenceColorSpace(pSourceColorSpace);
                IcmReferenceColorSpace(pDestColorSpace);
                IcmReferenceColorSpace(pTargetColorSpace);

                //
                // Increment reference count of color transform in DC.
                //
                IcmReferenceColorTransform(pCXform);
                IcmReferenceColorTransform(pBackCXform);
                IcmReferenceColorTransform(pProofCXform);

                //
                // Save color spaces.
                //
                pSavedIcmInfo->pSourceColorSpace = pSourceColorSpace;
                pSavedIcmInfo->pDestColorSpace   = pDestColorSpace;
                pSavedIcmInfo->pTargetColorSpace = pTargetColorSpace;

                //
                // Save color transforms.
                //
                pSavedIcmInfo->pCXform           = pCXform;
                pSavedIcmInfo->pBackCXform       = pBackCXform;
                pSavedIcmInfo->pProofCXform      = pProofCXform;

                //
                // Put current saved level in DC.
                //
                pSavedIcmInfo->dwSavedDepth      = dwCurrentSavedDepth;

                //
                // Insert saved data to list.
                //
                InsertHeadList(&(pIcmInfo->SavedIcmInfo),&(pSavedIcmInfo->ListEntry));

                ICMMSG(("gdi32: IcmSaveDC() - Saved Depth = %d\n",dwCurrentSavedDepth));
            }
            else
            {
                WARNING("IcmSaveDC():Failed on LOCALALLOC()\n");
                bRet = FALSE;
            }
        }
        else
        {
            WARNING("IcmSaveDC():Failed on NtGdiGetDCDword(DDW_SAVEDEPTH)\n");
            bRet = FALSE;
        }
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* IcmRestoreDC()
*
* History:
*    7-Dec-1998 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

VOID
IcmRestoreDC(
    PDC_ATTR pdcattr,
    int iLevel,
    PGDI_ICMINFO pIcmInfo)
{
    ICMAPI(("gdi32: IcmRestoreDC - iLevel = %d\n",iLevel));

    if (pIcmInfo)
    {
        //
        // Still have same ICMINFO.
        //
        PLIST_ENTRY p = pIcmInfo->SavedIcmInfo.Flink;
        BOOL        bContinue = TRUE;

        while (bContinue     &&
               (iLevel != 0) &&
               (p != &(pIcmInfo->SavedIcmInfo)))
        {
            PSAVED_ICMINFO pSavedIcmInfo = CONTAINING_RECORD(p,SAVED_ICMINFO,ListEntry);

            if (iLevel > 0)
            {
                //
                // iLevel is absolute saved depth to restore
                //
                if (iLevel == (int) pSavedIcmInfo->dwSavedDepth)
                {
                    bContinue = FALSE;
                }
            }
            else
            {
                //
                // iLevel is relative saved depth to restore
                //
                if (++iLevel == 0)
                {
                    bContinue = FALSE;
                }
            }

            if (bContinue == FALSE)
            {
                PCACHED_COLORSPACE pSourceColorSpace = pIcmInfo->pSourceColorSpace;
                PCACHED_COLORSPACE pDestColorSpace   = pIcmInfo->pDestColorSpace;
                PCACHED_COLORSPACE pTargetColorSpace = pIcmInfo->pTargetColorSpace;
                PCACHED_COLORTRANSFORM pCXform       = pIcmInfo->pCXform;
                PCACHED_COLORTRANSFORM pBackCXform   = pIcmInfo->pBackCXform;
                PCACHED_COLORTRANSFORM pProofCXform  = pIcmInfo->pProofCXform;

                //
                // Restore this saved data to DC.
                //
                pIcmInfo->pSourceColorSpace = pSavedIcmInfo->pSourceColorSpace;
                pIcmInfo->pDestColorSpace   = pSavedIcmInfo->pDestColorSpace;
                pIcmInfo->pTargetColorSpace = pSavedIcmInfo->pTargetColorSpace;
                pIcmInfo->pCXform           = pSavedIcmInfo->pCXform;
                pIcmInfo->pBackCXform       = pSavedIcmInfo->pBackCXform;
                pIcmInfo->pProofCXform      = pSavedIcmInfo->pProofCXform;

                //
                // Release color space which *WAS* selected in DC.
                //
                IcmReleaseColorSpace(NULL,pSourceColorSpace,FALSE);
                IcmReleaseColorSpace(NULL,pDestColorSpace,FALSE);
                IcmReleaseColorSpace(NULL,pTargetColorSpace,FALSE);

                //
                // Delete color transform which *WAS* selected in DC.
                //
                IcmDeleteColorTransform(pCXform,FALSE);
                IcmDeleteColorTransform(pBackCXform,FALSE);
                IcmDeleteColorTransform(pProofCXform,FALSE);

                if (pdcattr)
                {
                    //
                    // Validate flags.
                    //
                    pdcattr->ulDirty_ &= ~(DIRTY_COLORSPACE | DIRTY_COLORTRANSFORM);
                }
            }
            else
            {
                //
                // Decrement ref count of color space.
                //
                IcmReleaseColorSpace(NULL,pSavedIcmInfo->pSourceColorSpace,FALSE);
                IcmReleaseColorSpace(NULL,pSavedIcmInfo->pDestColorSpace,FALSE);
                IcmReleaseColorSpace(NULL,pSavedIcmInfo->pTargetColorSpace,FALSE);

                //
                // Decrement ref count of color transform.
                //
                IcmDeleteColorTransform(pSavedIcmInfo->pCXform,FALSE);
                IcmDeleteColorTransform(pSavedIcmInfo->pBackCXform,FALSE);
                IcmDeleteColorTransform(pSavedIcmInfo->pProofCXform,FALSE);
            }

            //
            // Get pointer to next.
            //
            p = p->Flink;

            //
            // Remove from list.
            //
            RemoveEntryList(&(pSavedIcmInfo->ListEntry));

            //
            // Free SAVED_ICMINFO.
            //
            LOCALFREE(pSavedIcmInfo);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\linedda.c ===
/******************************Module*Header*******************************\
* Module Name: linedda.c
*
* (Brief description)
*
* Created: 04-Jan-1991 09:23:30
* Author: Eric Kutter [erick]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
* (General description of its use)
*
* Dependencies:
*
*   (#defines)
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

/******************************Public*Routine******************************\
* BOOL WINAPI InnerLineDDA(x1,y1,x2,y2,pfn,pvUserData)
*
*   This routine is basic version of Bressenhams Algorithm for drawing lines.
*   For each point, pfn is called with that point and the user passed in
*   data pointer, pvUserData.  This call is device independant and does no
*   scaling or rotating.  This wouldn't be possible since there is no
*   DC passed in.  It is probably an old artifact of Windows 1.0.  It is
*   strictly a client side function.
*
*   return value is TRUE unless pfn is NULL.
*
* History:
*  07-Jan-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL WINAPI LineDDA(
    int    x1,
    int    y1,
    int    x2,
    int    y2,
    LINEDDAPROC   pfn,
    LPARAM UserData)
{
    int dx;
    int xinc;
    int dy;
    int yinc;
    int iError;
    int cx;

    if (pfn == (LINEDDAPROC)NULL)
        return(FALSE);

    dx   = x2 - x1;
    xinc = 1;

    if (dx <= 0)
    {
        xinc = -xinc;
        dx = -dx;
    }

// prepare for ascending y

    dy   = y2 - y1;
    yinc = 1;
    iError = 0;

// if decending

    if (dy <= 0)
    {
        yinc = -yinc;
        dy = -dy;
        //iError = 0; // in the win3.0 version, this is a 1 but it seems
    }                 // to give wierd results.

// y Major

    if (dy >= dx)
    {
        iError = (iError + dy) / 2;
        cx = dy;

        while (cx--)
        {
            (*pfn)(x1,y1,UserData);
            y1 += yinc;
            iError -= dx;
            if (iError < 0)
            {
                iError += dy;
                x1 += xinc;
            }
        }
    }
    else
    {
// x Major

        iError = (iError + dx) / 2;
        cx = dx;

        while (cx--)
        {
            (*pfn)(x1,y1,UserData);

            x1 += xinc;
            iError -= dy;

            if (iError < 0)
            {
                iError += dx;
                y1 += yinc;
            }
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\local.c ===
/*****************************Module*Header*******************************\
* Module Name: local.c                                                     *
*                                                                          *
* Support routines for client side objects and attribute caching.          *
*                                                                          *
* Created: 30-May-1991 21:55:57                                            *
* Author: Charles Whitmer [chuckwh]                                        *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                            *
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

#include "stdarg.h"

#include "wowgdip.h"

#include "vdm.h"

extern CFONT *pcfDeleteList;

VOID vFreeCFONTCrit(CFONT *pcf);

RTL_CRITICAL_SECTION semLocal;             // Semaphore for handle allocation.

//
// ahStockObjects will contain both the stock objects visible to an
// application, and internal ones such as the private stock bitmap.
//

ULONG_PTR ahStockObjects[PRIV_STOCK_LAST+1];

#if DBG
ULONG   gdi_dbgflags;               // Debug flags - FIREWALL.H.
#endif

#if DBG
INT gbCheckHandleLevel=0;
#endif


/******************************Public*Routine******************************\
* GdiQueryTable()
*
*   private entry point for wow to get the gdi handle table.  This allows
*   WOW to do fix up's on handles since they throw away the high word.
*
* History:
*  24-Jul-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PVOID GdiQueryTable()
{
    VDM_QUERY_VDM_PROCESS_DATA QueryVdmProcessData;
    NTSTATUS Status;

    //
    // Check the Target Process to see if this is a Wx86 process
    //

    QueryVdmProcessData.IsVdmProcess = FALSE;
    QueryVdmProcessData.ProcessHandle = NtCurrentProcess();
    Status = NtVdmControl(VdmQueryVdmProcess, &QueryVdmProcessData);

    if (!NT_SUCCESS(Status) || QueryVdmProcessData.IsVdmProcess == FALSE) {
        return NULL;
    }

    return((PVOID)pGdiSharedHandleTable);
}

/******************************Public*Routine******************************\
*
* History:
*  02-Aug-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PLDC pldcGet(HDC hdc)
{
   PLDC pldc = NULL;
   PDC_ATTR pdca;
   PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

   if (pdca)
        pldc = (PLDC)pdca->pvLDC;

   return(pldc);
}

/******************************Public*Routine******************************\
* pldcCreate()
*
* History:
*  25-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PLDC pldcCreate(
    HDC hdc,
    ULONG ulType)
{
    PLDC pldc;

    pldc = (PLDC)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,sizeof(LDC));

    if (!pldc)
    {
        WARNING("pldcCreate - failed to allocate plinkCreate\n");
    }
    else
    {
        PDC_ATTR pdca;

        pldc->iType = ulType;
        pldc->hdc   = hdc;

    // make sure that all three of these pointer need to be set to zero
    // on print server's dc. ppSubUFIHash certainly has to (tessiew).

        pldc->ppUFIHash = pldc->ppDVUFIHash = pldc->ppSubUFIHash = NULL;

    // initalize postscript data list.

        InitializeListHead(&(pldc->PSDataList));

    // Put pointer to DC_ATTR in LDC.

        PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

        if (pdca)
        {
            pdca->pvLDC = pldc;
        }
    }

    ASSERTGDI((offsetof(LINK,metalink ) == offsetof(METALINK16,metalink ))       &&
              (offsetof(LINK,plinkNext) == offsetof(METALINK16,pmetalink16Next)) &&
              (offsetof(LINK,hobj     ) == offsetof(METALINK16,hobj     ))       &&
              (offsetof(LINK,pv       ) == offsetof(METALINK16,pv       )),
              "pldcCreate - invalid structures\n");

    return(pldc);
}

/******************************Public*Routine******************************\
* VOID vSetPldc()
*
*   This is used if a we already have a pldc and want to set it in this DC.
*   The purpose is ResetDC since we don't know if we still have the same dcattr.
*
* History:
*  03-Aug-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vSetPldc(
    HDC hdc,
    PLDC pldc)
{
    PDC_ATTR pdca;

    PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

    if (pdca)
    {
        pdca->pvLDC = pldc;
    }

    if (pldc)
    {
        pldc->hdc = hdc;
    }
}

/******************************Public*Routine******************************\
* bDeleteLDC()
*
* History:
*  25-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL bDeleteLDC(
    PLDC pldc
    )
{
    if (pldc->pDevMode)
    {
        LOCALFREE(pldc->pDevMode);
    }

    if (pldc->hEMFSpool)
    {
        DeleteEMFSpoolData(pldc);
    }

    if (pldc->dwSizeOfPSDataToRecord)
    {
        PPS_INJECTION_DATA pPSData;
        PLIST_ENTRY        p = pldc->PSDataList.Flink;

        while(p != &(pldc->PSDataList))
        {
            // get pointer to this cell.

            pPSData = CONTAINING_RECORD(p,PS_INJECTION_DATA,ListEntry);

            // get pointer to next cell.

            p = p->Flink;

            // free this cell.

            LOCALFREE(pPSData);
        }
    }

    LocalFree(pldc);
    return(TRUE);
}

/******************************Public*Routine******************************\
* GdiCleanCacheDC (hdcLocal)                                               *
*                                                                          *
* Resets the state of a cached DC, but has no effect on an OWNDC.          *
* Should be called by WOW when the app calls ReleaseDC.                    *
*                                                                          *
* History:                                                                 *
*  Sat 30-Jan-1993 11:49:12 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL GdiCleanCacheDC(HDC hdc)
{
// Validate the call.  It must be a direct display DC.

    if (IS_ALTDC_TYPE(hdc))
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// any other dc doesn't really matter.

    return(TRUE);
}

/******************************Public*Routine******************************\
* GdiConvertAndCheckDC
*
*  Private entry point for USER's drawing routine.  This function differs
*  from GdiConvertDC in that it also does printing specific things for the
*  given dc.  This is for APIs that apps can use for printing.
*
* History:
*  14-Apr-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

HDC GdiConvertAndCheckDC(HDC hdc)
{
    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc,pldc,(HDC)0);

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(FALSE);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    return(hdc);
}

/******************************Public*Routine******************************\
* GdiIsMetaFileDC
*
* History:
* 02-12-92 mikeke  Created
\**************************************************************************/

BOOL GdiIsMetaFileDC(HDC hdc)
{
    BOOL b = FALSE;

    if (IS_ALTDC_TYPE(hdc))
    {
        if (IS_METADC16_TYPE(hdc))
        {
            b = TRUE;
        }
        else
        {
            PLDC pldc;

            DC_PLDC(hdc,pldc,FALSE);

            if (pldc->iType == LO_METADC)
                b = TRUE;
        }
    }
    return(b);
}

/******************************Public*Routine******************************\
*
* GdiIsMetaPrintDC
*
* Tests whether the given DC is a metafile-spooled printer DC
*
* History:
*  Fri Jun 16 12:00:11 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GdiIsMetaPrintDC(HDC hdc)
{
    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc, pldc, FALSE);

        return (pldc->fl & LDC_META_PRINT) != 0;
    }

    return FALSE;
}

/**************************************************************************\
 *
 * WINBUG #82862 2-7-2000 bhouse Possible cleanup of stubs
 *
 * Old Comment:
 *   Client stubs for USER that do things with handles and caching.  They are
 *   now NOP's and should be removed from USER as soon as this stuff is part
 *   of the main build.
 *
\**************************************************************************/

HDC GdiConvertDC(HDC hdc)
{
    FIXUP_HANDLEZ(hdc);
    return(hdc);
}

HFONT GdiConvertFont(HFONT hfnt)
{
    FIXUP_HANDLEZ(hfnt);
    return(hfnt);
}

BOOL GdiValidateHandle(HANDLE hObj)
{
    UINT uiIndex;

    if (hObj == NULL)
        return(TRUE);

    uiIndex = HANDLE_TO_INDEX(hObj);

    if (uiIndex < MAX_HANDLE_COUNT)
    {
        PENTRY pentry = &pGdiSharedHandleTable[uiIndex];

        if ((pentry->FullUnique == (USHORT)((ULONG_PTR)hObj >> 16)) &&
            ((OBJECTOWNER_PID(pentry->ObjectOwner) == gW32PID) ||
             (OBJECTOWNER_PID(pentry->ObjectOwner) == 0))
           )
        {
           return(TRUE);
        }
    }

    WARNING1("GdiValidateHandle: Bad handle\n");

    return(FALSE);
}

HFONT GdiGetLocalFont(HFONT hfntRemote)
{
    return(hfntRemote);
}

HBRUSH GdiGetLocalBrush(HBRUSH hbrushRemote)
{
    return(hbrushRemote);
}

HANDLE META WINAPI SelectBrushLocal(HDC hdc,HANDLE h)
{
    return(h);
}

HANDLE META WINAPI SelectFontLocal(HDC hdc,HANDLE h)
{
    return(h);
}

BOOL GdiSetAttrs(HDC hdc)
{
    hdc;
    return(TRUE);
}

HBITMAP GdiConvertBitmap(HBITMAP hbm)
{
    FIXUP_HANDLEZ(hbm);
    return(hbm);
}

HBRUSH GdiConvertBrush(HBRUSH hbrush)
{
    FIXUP_HANDLEZ(hbrush);
    return (hbrush);
}

HPALETTE GdiConvertPalette(HPALETTE hpal)
{
    FIXUP_HANDLEZ(hpal);
    return(hpal);
}

HRGN GdiConvertRegion(HRGN hrgn)
{
    FIXUP_HANDLEZ(hrgn);
    return(hrgn);
}

void APIENTRY GdiSetServerAttr(HDC hdc, PVOID pattr)
{
    hdc;
    pattr;
}

/******************************Public*Routine******************************\
* plfCreateLOCALFONT (fl)
*
* Allocates a LOCALFONT.  Actually pulls one from a preallocated pool.
* Does simple initialization.
*
* WARNING: This routines assume that the caller has grabbed semLocal
*
*  Sun 10-Jan-1993 01:46:12 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

#define LF_ALLOCCOUNT   10

LOCALFONT *plfFreeListLOCALFONT = (LOCALFONT *) NULL;

LOCALFONT *plfCreateLOCALFONT(FLONG fl)
{
    LOCALFONT *plf;

    // Try to get one off the free list.

    plf = plfFreeListLOCALFONT;
    if (plf != (LOCALFONT *) NULL)
    {
        plfFreeListLOCALFONT = *((LOCALFONT **) plf);
    }

    // Otherwise expand the free list.

    else
    {
        plf = (LOCALFONT *) LOCALALLOC(LF_ALLOCCOUNT * sizeof(LOCALFONT));
        if (plf != (LOCALFONT *) NULL)
        {
            int ii;

            // Link all the new ones into the free list.

            *((LOCALFONT **) plf) = (LOCALFONT *) NULL;
            plf++;

            for (ii=0; ii<LF_ALLOCCOUNT-2; ii++,plf++)
              *((LOCALFONT **) plf) = plf-1;

            plfFreeListLOCALFONT = plf-1;

            // Keep the last one for us!
        }
        else
        {
            GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    if (plf != (LOCALFONT *) NULL)
    {
        plf->fl = fl;
        plf->pcf = (CFONT *) NULL;
    }

     return(plf);
}

/******************************Public*Routine******************************\
* vDeleteLOCALFONT (plf)                                                   *
*                                                                          *
* Frees a LOCALFONT after unreferencing any CFONTs it points to.           *
*                                                                          *
*  Sun 10-Jan-1993 02:27:50 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

VOID vDeleteLOCALFONT(LOCALFONT *plf)
{
    ASSERTGDI(plf != (LOCALFONT *) NULL,"Trying to free NULL LOCALFONT.\n");

    ENTERCRITICALSECTION(&semLocal);
    {
        CFONT *pcf;

        pcf = plf->pcf;

        // Walk the CFONT list and delallocate those CFONTs not in use.
        // put those which are in use back on the global CFONT delete list.

        while( pcf != (CFONT*) NULL )
        {
            ASSERTGDI(!(pcf->fl & CFONT_PUBLIC),"vDeleteLocalFont - public font error\n");

            if( pcf->cRef )
            {
                // this CFONT is in use so we'll put it on the global
                // delete list and free it later.

                CFONT *pcfTmp = pcf->pcfNext;
#if DBG
                DbgPrint("\n\nvDeleteLOCALFONT: CFONT in use putting on delete list, cRef = %ld, hf = %lx.\n",pcf->cRef, pcf->hf);
#endif

                pcf->pcfNext = pcfDeleteList;
                pcfDeleteList = pcf;
                pcf = pcfTmp;
            }
            else
            {
                CFONT *pcfTmp;

                pcfTmp = pcf->pcfNext;
                vFreeCFONTCrit(pcf);
                pcf = pcfTmp;
            }
        }

        *((LOCALFONT **) plf) = plfFreeListLOCALFONT;
        plfFreeListLOCALFONT = plf;
    }
    LEAVECRITICALSECTION(&semLocal);
}


/******************************Public*Routine******************************\
* bLoadSpooler()
*
*   This function loads the spooler and gets the address's of all routines
*   GDI calls in the spooler.  This should be called the first time the
*   spooler is needed.
*
* History:
*  09-Aug-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HINSTANCE           ghSpooler = NULL;
FPSTARTDOCDLGW      fpStartDocDlgW;
FPOPENPRINTERW      fpOpenPrinterW;
FPRESETPRINTERW     fpResetPrinterW;
FPCLOSEPRINTER      fpClosePrinter;
FPGETPRINTERW       fpGetPrinterW;
FPGETPRINTERDRIVERW fpGetPrinterDriverW;
FPENDDOCPRINTER     fpEndDocPrinter;
FPENDPAGEPRINTER    fpEndPagePrinter;
FPREADPRINTER       fpReadPrinter;
FPSPLREADPRINTER    fpSplReadPrinter;
FPSTARTDOCPRINTERW  fpStartDocPrinterW;
FPSTARTPAGEPRINTER  fpStartPagePrinter;
FPABORTPRINTER      fpAbortPrinter;
PFNDOCUMENTEVENT    fpDocumentEvent;
FPQUERYSPOOLMODE    fpQuerySpoolMode;
FPQUERYREMOTEFONTS  fpQueryRemoteFonts;
FPSEEKPRINTER       fpSeekPrinter;
FPQUERYCOLORPROFILE fpQueryColorProfile;
FPSPLDRIVERUNLOADCOMPLETE   fpSplDriverUnloadComplete;
FPGETSPOOLFILEHANDLE        fpGetSpoolFileHandle;
FPCOMMITSPOOLDATA           fpCommitSpoolData;
FPCLOSESPOOLFILEHANDLE      fpCloseSpoolFileHandle;
FPDOCUMENTPROPERTIESW       fpDocumentPropertiesW;
FPLOADSPLWOW64              fpLoadSplWow64;
FPISVALIDDEVMODEW           fpIsValidDevmodeW;

BOOL bLoadSpooler()
{
    if (ghSpooler != NULL)
        WARNING("spooler already loaded\n");

    ENTERCRITICALSECTION(&semLocal);

// make sure someone else didn't sneak in under us and load it.

    if (ghSpooler == NULL)
    {
        HANDLE hSpooler = LoadLibraryW(L"winspool.drv");

        if (hSpooler != NULL)
        {
            #define GETSPOOLERPROC_(type, procname) \
                    fp##procname = (type) GetProcAddress(hSpooler, #procname)

            GETSPOOLERPROC_(FPSTARTDOCDLGW, StartDocDlgW);
            GETSPOOLERPROC_(FPOPENPRINTERW, OpenPrinterW);
            GETSPOOLERPROC_(FPRESETPRINTERW, ResetPrinterW);
            GETSPOOLERPROC_(FPCLOSEPRINTER, ClosePrinter);
            GETSPOOLERPROC_(FPGETPRINTERW, GetPrinterW);
            GETSPOOLERPROC_(FPGETPRINTERDRIVERW, GetPrinterDriverW);
            GETSPOOLERPROC_(FPENDDOCPRINTER, EndDocPrinter);
            GETSPOOLERPROC_(FPENDPAGEPRINTER, EndPagePrinter);
            GETSPOOLERPROC_(FPREADPRINTER, ReadPrinter);
            GETSPOOLERPROC_(FPSTARTDOCPRINTERW, StartDocPrinterW);
            GETSPOOLERPROC_(FPSTARTPAGEPRINTER, StartPagePrinter);
            GETSPOOLERPROC_(FPABORTPRINTER, AbortPrinter);
            GETSPOOLERPROC_(PFNDOCUMENTEVENT, DocumentEvent);
            GETSPOOLERPROC_(FPQUERYSPOOLMODE, QuerySpoolMode);
            GETSPOOLERPROC_(FPQUERYREMOTEFONTS, QueryRemoteFonts);
            GETSPOOLERPROC_(FPSEEKPRINTER, SeekPrinter);
            GETSPOOLERPROC_(FPQUERYCOLORPROFILE, QueryColorProfile);
            GETSPOOLERPROC_(FPSPLDRIVERUNLOADCOMPLETE, SplDriverUnloadComplete);
            GETSPOOLERPROC_(FPDOCUMENTPROPERTIESW, DocumentPropertiesW);
            
            fpLoadSplWow64 = (FPLOADSPLWOW64) GetProcAddress(hSpooler, (LPCSTR) MAKELPARAM(224, 0));
            GETSPOOLERPROC_(FPISVALIDDEVMODEW, IsValidDevmodeW); 

            #ifdef EMULATE_SPOOLFILE_INTERFACE

            fpGetSpoolFileHandle = GetSpoolFileHandle;
            fpCommitSpoolData = CommitSpoolData;
            fpCloseSpoolFileHandle = CloseSpoolFileHandle;

            #else

            GETSPOOLERPROC_(FPGETSPOOLFILEHANDLE, GetSpoolFileHandle);
            GETSPOOLERPROC_(FPCOMMITSPOOLDATA, CommitSpoolData);
            GETSPOOLERPROC_(FPCLOSESPOOLFILEHANDLE, CloseSpoolFileHandle);

            #endif

            fpSplReadPrinter   = (FPSPLREADPRINTER)GetProcAddress(hSpooler, (LPCSTR) MAKELPARAM(205, 0));

            if (! fpStartDocDlgW            ||
                ! fpOpenPrinterW            ||
                ! fpResetPrinterW           ||
                ! fpClosePrinter            ||
                ! fpGetPrinterW             ||
                ! fpGetPrinterDriverW       ||
                ! fpEndDocPrinter           ||
                ! fpEndPagePrinter          ||
                ! fpReadPrinter             ||
                ! fpSplReadPrinter          ||
                ! fpStartDocPrinterW        ||
                ! fpStartPagePrinter        ||
                ! fpAbortPrinter            ||
                ! fpDocumentEvent           ||
                ! fpQuerySpoolMode          ||
                ! fpQueryRemoteFonts        ||
                ! fpSeekPrinter             ||
                ! fpQueryColorProfile       ||
                ! fpSplDriverUnloadComplete ||
                ! fpGetSpoolFileHandle      ||
                ! fpCommitSpoolData         ||
                ! fpCloseSpoolFileHandle    ||
                ! fpDocumentPropertiesW     ||
                ! fpLoadSplWow64            ||
                ! fpIsValidDevmodeW)
            {
                FreeLibrary(hSpooler);
                hSpooler = NULL;
            }

            ghSpooler = hSpooler;
        }
    }

    LEAVECRITICALSECTION(&semLocal);

    if (ghSpooler == NULL)
        GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);

    return(ghSpooler != NULL);
}

/******************************Public*Routine******************************\
* GdiGetLocalDC
*
* Arguments:
*
*   hdc - handle to dc
*
* Return Value:
*
*   same DC or NULL for failure
*
\**************************************************************************/

HDC
GdiGetLocalDC(HDC hdc)
{

    return(hdc);
}
/******************************Public*Routine******************************\
* GdiDeleteLocalDC
*
*   Free client DC_ATTR regardless of reference count
*
* Arguments:
*
*   hdc
*
* Return Value:
*
*   Status
*
* History:
*
*   04-May-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL GdiDeleteLocalDC(HDC hdc)
{
    return(TRUE);
}

/******************************Public*Routine******************************\
* GdiReleaseLocalDC
*
* Routine Description:
*
*   When the reference count of DC_ATTR drops to zero, free it
*
* Arguments:
*
*   hdc - DC handle
*
* Return Value:
*
*   BOOL status
*
* History:
*
*   02-May-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL GdiReleaseLocalDC(HDC hdc)
{

#if DBG
    DbgPrint("Error, call to GdiReleaseLocalDC\n");
    DbgBreakPoint();
#endif

    return(TRUE);
}

/******************************Public*Routine******************************\
* GdiFixUpHandle()
*
*   given a handle with the high word 0'd, return the actual handle
*
* History:
*  16-Feb-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HANDLE GdiFixUpHandle(
    HANDLE h)
{
    HANDLE hNew = NULL;

    if ((((ULONG_PTR)h & FULLUNIQUE_MASK) == 0) && ((ULONG_PTR)h < MAX_HANDLE_COUNT))
    {
        hNew = (HANDLE)MAKE_HMGR_HANDLE((ULONG)(ULONG_PTR)h,pGdiSharedHandleTable[(ULONG_PTR)h].FullUnique);
    }

    return(hNew);
}

/******************************Public*Routine******************************\
* DoRip()
*
*  go to the user mode debugger in checked builds
*
* Effects:
*
* Warnings:
*  Leave this enabled in case efloat.lib needs it.
*  efloat.lib uses gre\engine.h's ASSERTGDI macro.
*
* History:
*  09-Aug-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID DoRip(PSZ psz)
{
    DbgPrint("GDI Assertion Failure: ");
    DbgPrint(psz);
    DbgPrint("\n");
    DbgBreakPoint();
}

/******************************Public*Routine******************************\
* DoIDRip()
*
*  go to the user mode debugger in checked builds
*
* Effects:
*
* Warnings:
*  Leave this enabled in case efloat.lib needs it.
*  efloat.lib uses gre\engine.h's ASSERTGDI macro.
*
* History:
*  31-Aug-2000 -by-  Jason Hartman [jasonha]
* Wrote it.
\**************************************************************************/

VOID DoIDRip(PCSTR ID, PSZ psz)
{
    DbgPrint("GDI Assertion Failure: ");
    if (ID)
    {
        DbgPrint((PCH)ID);
        DbgPrint(": ");
    }
    DbgPrint(psz);
    DbgPrint("\n");
    DbgBreakPoint();
}


DWORD
GetFileMappingAlignment()

/*++

Routine Description:

    Alignment for file mapping starting offset

Arguments:

    NONE

Return Value:

    see above

--*/

{
    static DWORD alignment = 0;

    if (alignment == 0)
    {
        SYSTEM_INFO sysinfo;

        //
        // Set file mapping alignment for EMF spool file to
        // the system memory allocation granularity
        //

        GetSystemInfo(&sysinfo);
        alignment = sysinfo.dwAllocationGranularity;
    }

    return alignment;
}

DWORD
GetSystemPageSize()

/*++

Routine Description:

    Returns the page size for the current system

Arguments:

    NONE

Return Value:

    see above

--*/

{
    static DWORD pagesize = 0;

    if (pagesize == 0)
    {
        SYSTEM_INFO sysinfo;

        GetSystemInfo(&sysinfo);
        pagesize = sysinfo.dwPageSize;
    }

    return pagesize;
}

VOID
CopyMemoryToMemoryMappedFile(
    PVOID Destination,
    CONST VOID *Source,
    DWORD Length
    )

/*++

Routine Description:

    Copy data into memory-mapped file (assuming mostly sequential access pattern)

Arguments:

    Destination - Points to destination buffer
    Source - Points to source buffer
    Length - Number of bytes to be copied

Return Value:

    NONE

--*/

{
    PBYTE dst = (PBYTE) Destination;
    PBYTE src = (PBYTE) Source;
    DWORD alignment = GetFileMappingAlignment();
    DWORD count;

    //
    // Copy the initial portion so that the destination buffer
    // pointer is properly aligned
    //

    count = (DWORD) ((ULONG_PTR) dst % alignment);

    if (count != 0)
    {
        count = min(alignment-count, Length);
        RtlCopyMemory(dst, src, count);

        Length -= count;
        dst += count;
        src += count;
    }

    //
    // Copy the middle portion in 64KB chunks
    //

    count = Length / alignment;
    Length -= count * alignment;

    while (count--)
    {
        RtlCopyMemory(dst, src, alignment);
        VirtualUnlock(dst, alignment);
        dst += alignment;
        src += alignment;
    }

    //
    // Finish up the remaining portion
    //

    if (Length > 0)
        RtlCopyMemory(dst, src, Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\makefile.inc ===
$(DYNLINK_LIB) : $(DYNLINK_LIBP)

$(DYNLINK_LIBP) $(DYNLINK_LIBP:.lib=.exp): $(O)\$(TARGETNAMEP).def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$(DYNLINK_LIBP) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\$(TARGETNAMEP).def
$(LIBRARY_OBJS)
<<NOKEEP

C_DEFINES=$(C_DEFINES) -DPRIVATE= -D_$(ALT_PROJECT)_
$(O)\$(TARGETNAMEP).def: ..\$(TARGETNAME).def
    $(C_PREPROCESSOR) ..\$(TARGETNAME).def > $@


$(UMPDDDILIB) $(UMPDDDILIB:.lib=.exp): $(O)\umpdddip.def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$(UMPDDDILIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\umpdddip.def
$(LIBRARY_OBJS)
<<NOKEEP

C_DEFINES=$(C_DEFINES) -DPRIVATE= -D_$(ALT_PROJECT)_
$(O)\umpdddip.def: ..\umpdddi.def
    $(C_PREPROCESSOR) ..\umpdddi.def > $@

$(WINPPILIB) $(WINPPILIB:.lib=.exp): $(O)\winppi.def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$(WINPPILIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\winppi.def
$(LIBRARY_OBJS)
<<NOKEEP

C_DEFINES=$(C_DEFINES) -DPRIVATE= -D_$(ALT_PROJECT)_
$(O)\winppi.def: ..\winppi.def
    $(C_PREPROCESSOR) ..\winppi.def > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\mem.c ===
/******************************Module*Header*******************************\
* Module Name: mem.c							   
*									   
* Support routines for client side memory management.	                   
*									   
* Created: 30-May-1991 21:55:57 					   
* Author: Charles Whitmer [chuckwh]					   
*									   
* Copyright (c) 1991-1999 Microsoft Corporation                            
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop


PVOID __nw(unsigned int ui)
{
    USE(ui);
    RIP("Bogus __nw call");
    return(NULL);
}

VOID __dl(PVOID pv)
{
    USE(pv);
    RIP("Bogus __dl call");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\local.h ===
/******************************Module*Header*******************************\
* Module Name: local.h                                                     *
*                                                                          *
* Definitions needed for client side objects.                              *
*                                                                          *
* Copyright (c) 1993-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "gdispool.h"
#include "umpd.h"
#include "cliumpd.h"


#define MIRRORED_HDC(hdc)                 (GetLayout(hdc) & LAYOUT_RTL)

//
// Semaphore utilities
//

#define INITIALIZECRITICALSECTION(psem) RtlInitializeCriticalSection(psem)
#define ENTERCRITICALSECTION(hsem)      RtlEnterCriticalSection(hsem)
#define LEAVECRITICALSECTION(hsem)      RtlLeaveCriticalSection(hsem)
#define DELETECRITICALSECTION(psem)     RtlDeleteCriticalSection(psem)

//
// Memory allocation
//

#define LOCALALLOC(size)            RtlAllocateHeap(RtlProcessHeap(),0,size)
#define LOCALFREE(pv)               (void)RtlFreeHeap(RtlProcessHeap(),0,pv)

//
//  check for multiplication overflow (#define's copied from gre/hmgr.h and
//  gre/engine.h, respectively; #include required fro PAGE_SIZE definition.)
//
#include "ntosp.h"
#define MAXIMUM_POOL_ALLOC      (PAGE_SIZE * 10000)
#define BALLOC_OVERFLOW1(c,st)      (c > (MAXIMUM_POOL_ALLOC/sizeof(st)))


extern DWORD GdiBatchLimit;

typedef LPWSTR PWSZ;

extern HBRUSH ghbrDCBrush;
extern HPEN   ghbrDCPen;
extern BOOL   gbWOW64;

#define     WOW64PRINTING(pUMPD)    ((gbWOW64) && (pUMPD) && ((pUMPD)->pp))

void vUMPDWow64Shutdown();

/**************************************************************************\
 *
 * Local handle macros
 *
\**************************************************************************/

// macros to validate the handles passed in and setup some local variables
// for accessing the handle information.

#define DC_PLDC(hdc,pldc,Ret)                                      \
    pldc = GET_PLDC(hdc);                                          \
    if (!pldc || (LO_TYPE(hdc) == LO_METADC16_TYPE))               \
    {                                                              \
        GdiSetLastError(ERROR_INVALID_HANDLE);                     \
        return(Ret);                                               \
    }                                                              \
    ASSERTGDI((pldc->iType == LO_DC) || (pldc->iType == LO_METADC),"DC_PLDC error\n");

#define GET_PLDC(hdc)           pldcGet(hdc)
#define GET_PMDC(hdc)           pmdcGetFromHdc(hdc)

#define GET_PMFRECORDER16(pmf,hdc)          \
{                                           \
    pmf = (PMFRECORDER16)plinkGet(hdc);     \
    if (pmf)                                \
        pmf = ((PLINK)pmf)->pv;             \
}

#define hdcFromIhdc(i)          GdiFixUpHandle((HANDLE)i)
#define pmdcGetFromIhdc(i)      pmdcGetFromHdc(GdiFixUpHandle((HANDLE)i))

// ALTDC_TYPE is not LO_ALTDC_TYPE || LO_METADC16_TYPE

#define IS_ALTDC_TYPE(h)    (LO_TYPE(h) != LO_DC_TYPE)
#define IS_METADC16_TYPE(h) (LO_TYPE(h) == LO_METADC16_TYPE)

// these macros are defined to aid in determining color vs monochrome pages

#define CLEAR_COLOR_PAGE(pldc) pldc->fl &= ~LDC_COLOR_PAGE
#define IS_COLOR_GREY(color) ((BYTE)color == (BYTE)(color >> 8) && (BYTE)color == (BYTE)(color >> 16))
#define IS_GREY_MONO(color) ((BYTE)color == (BYTE)0x0 || (BYTE)color == (BYTE)0xff)
#define IS_COLOR_MONO(color) ((color & 0x00ffffff) == 0 || (color & 0x00ffffff) == 0x00ffffff)

#if 1        // disable debug messages

#define DESIGNATE_COLOR_PAGE(pldc) CLEAR_COLOR_PAGE(pldc);
#define SET_COLOR_PAGE(pldc) pldc->fl |= LDC_COLOR_PAGE;
#define CHECK_COLOR_PAGE(pldc,color)            \
{                                               \
    if (!IS_COLOR_MONO(color))                  \
        pldc->fl |= LDC_COLOR_PAGE;             \
}

#else

#define DESIGNATE_COLOR_PAGE(pldc)              \
{                                               \
    if (pldc->fl & LDC_COLOR_PAGE)              \
    {                                           \
        DbgPrint ("gdi32:Color Page\n");        \
    }                                           \
    else                                        \
    {                                           \
        DbgPrint ("gdi32:Monochrome Page\n");   \
    }                                           \
    CLEAR_COLOR_PAGE(pldc);                     \
}
#define CHECK_COLOR_PAGE(pldc,color)            \
{                                               \
    if (!IS_COLOR_MONO(color))                  \
    {                                           \
        pldc->fl |= LDC_COLOR_PAGE;             \
        DbgPrint ("Set Color Page: %08x %s %d\n",color,__FILE__,__LINE__); \
    }                                           \
}
#define SET_COLOR_PAGE(pldc)            \
{                                       \
    pldc->fl |= LDC_COLOR_PAGE;         \
    DbgPrint ("Set color page %s %d\n",__FILE__,__LINE__); \
}
#endif

/**************************************************************************\
 *
 * LINK stuff
 *
\**************************************************************************/

#define INVALID_INDEX      0xffffffff
#define LINK_HASH_SIZE     128
#define H_INDEX(h)            ((USHORT)(h))
#define LINK_HASH_INDEX(h) (H_INDEX(h) & (LINK_HASH_SIZE-1))

typedef struct tagLINK
{
    DWORD           metalink;
    struct tagLINK *plinkNext;
    HANDLE          hobj;
    PVOID           pv;
} LINK, *PLINK;

extern PLINK aplHash[LINK_HASH_SIZE];

PLINK   plinkGet(HANDLE h);
PLINK   plinkCreate(HANDLE h,ULONG ulSize);
BOOL    bDeleteLink(HANDLE h);

HANDLE  hCreateClientObjLink(PVOID pv,ULONG ulType);
PVOID   pvClientObjGet(HANDLE h, DWORD dwLoType);
BOOL    bDeleteClientObjLink(HANDLE h);

int     iGetServerType(HANDLE hobj);

/****************************************************************************
 *
 * UFI Hash stuff
 *
 ***************************************************************************/

typedef struct _MERGEDVIEW
{
    BYTE *pjMem; // pointer to the merged font's memory image
    ULONG cjMem; // its size
} MERGEDVIEW;

// info needed for subsetting first and subsequent pages

typedef struct _SSINFO
{
    BYTE *pjBits;       // glyph index bitfield, one bit set for every glyph
                        // used on pages up to and including this one
    ULONG cjBits;       // cj of the bitfield above
    ULONG cGlyphsSoFar; // number of bits set in the bitfield above

    ULONG cDeltaGlyphs; // number of glyphs in the delta for this page
    BYTE *pjDelta;      // bitfield for glyphs in the delta for this page
} SSINFO;

typedef union _SSMERGE
{
    MERGEDVIEW mvw;  // only used on the server
    SSINFO     ssi;  // only used on the client
} SSMERGE;

#define UFI_HASH_SIZE   32  // this should be plenty

typedef struct tagUFIHASH
{
    UNIVERSAL_FONT_ID  ufi;
    struct tagUFIHASH *pNext;
    FSHORT             fs1;
    FSHORT             fs2;

// client of server side union

    SSMERGE            u;

} UFIHASH, *PUFIHASH;


#if 0

typedef struct tagUFIHASH
{
    UNIVERSAL_FONT_ID  ufi;
    struct tagUFIHASH *pNext;
    FSHORT             fs1; // server or client, if client delta or not
    FSHORT             fs2; // private or public, dv or not

// this part of the structure is only optionally allocated, only needed
// for subsetting code.

    PBYTE   pjMemory;
    ULONG   ulMemBytes;

// these fields are only used on the client side to do book keeping about
// which glyphs from this font are used in the document

    ULONG   ulDistGlyph;
    ULONG   ulDistDelta;
    PBYTE   pjDelta;
} UFIHASH, *PUFIHASH;

#endif

#define FLUFI_SERVER 1
#define FLUFI_DELTA  2

// Define the local DC object.

#define PRINT_TIMER 0

#if PRINT_TIMER
extern BOOL bPrintTimer;
#endif

/****************************************************************************
 *
 * PostScript Data
 *
 ***************************************************************************/

typedef struct _EMFITEMPSINJECTIONDATA
{
    DWORD      cjSize;
    int        nEscape;
    int        cjInput;
    BYTE       EscapeData[1];
} EMFITEMPSINJECTIONDATA, *PEMFITEMPSINJECTIONDATA;

typedef struct _PS_INJECTION_DATA
{
    LIST_ENTRY              ListEntry;
    EMFITEMPSINJECTIONDATA  EmfData;
} PS_INJECTION_DATA, *PPS_INJECTION_DATA;

/****************************************************************************
 *
 * Local DC
 *
 ***************************************************************************/

typedef struct _LDC
{
    HDC                 hdc;
    ULONG               fl;
    ULONG               iType;

// Metafile information.

    PVOID               pvPMDC; // can't have a PMDC here since it is a class

// Printing information.
// We need to cache the port name from createDC in case it is not specified at StartDoc

    LPWSTR              pwszPort;
    ABORTPROC           pfnAbort;       // Address of application's abort proc.
    ULONG               ulLastCallBack; // Last time we call back to abort proc.
    HANDLE              hSpooler;       // handle to the spooler.
    PUMPD               pUMPD;          // pointer to user-mode printer driver info
    KERNEL_PUMDHPDEV    pUMdhpdev;      // pointer to user-mode pdev info
    PUFIHASH            *ppUFIHash;     // used to keep track of fonts used in doc
    PUFIHASH            *ppDVUFIHash;   // used to keep track of mm instance fonts used in a doc
    PUFIHASH            *ppSubUFIHash;  // used to keep track of subsetted fonts in the doc
    DEVMODEW            *pDevMode;      // used to keep trak of ResetDC's
    UNIVERSAL_FONT_ID   ufi;            // current UFI used for forced mapping
    HANDLE              hEMFSpool;      // information used for recording EMF data
#if PRINT_TIMER
    DWORD               msStartDoc;     // Time of StartDoc in miliseconds.
    DWORD               msStartPage;    // Time of StartPage in miliseconds.
#endif
    DWORD               dwSizeOfPSDataToRecord; // Total size of PostScript Injection data to record EMF
    LIST_ENTRY          PSDataList;     // List to PostScript Injection data
    DEVCAPS             DevCaps;
    HBRUSH              oldSetDCBrushColorBrush; // Holds latest temp DC brush
    HPEN                oldSetDCPenColorPen;     // Holds latest temp DC pen
} LDC,*PLDC;

// Flags for ldc.fl.

#define LDC_SAP_CALLBACK            0x00000020L
#define LDC_DOC_STARTED             0x00000040L
#define LDC_PAGE_STARTED            0x00000080L
#define LDC_CALL_STARTPAGE          0x00000100L
#define LDC_NEXTBAND                0x00000200L
#define LDC_EMPTYBAND               0x00000400L
#define LDC_EMBED_FONTS             0x00001000L
#define LDC_META_ARCDIR_CLOCKWISE   0x00002000L
#define LDC_FONT_SUBSET             0x00004000L
#define LDC_FONT_CHANGE             0x00008000L
#define LDC_DOC_CANCELLED           0x00010000L
#define LDC_META_PRINT              0x00020000L
#define LDC_PRINT_DIRECT            0x00040000L
#define LDC_BANDING                 0x00080000L
#define LDC_DOWNLOAD_FONTS          0x00100000L
#define LDC_RESETDC_CALLED          0x00200000L
#define LDC_FORCE_MAPPING           0x00400000L
#define LDC_LINKED_FONTS            0x00800000L
#define LDC_INFO                    0x01000000L
#define LDC_CACHED_DEVCAPS          0x02000000L
#define LDC_ICM_INFO                0x04000000L
#define LDC_DOWNLOAD_PROFILES       0x08000000L
#define LDC_CALLED_ENDPAGE          0x10000000L
#define LDC_COLOR_PAGE              0x20000000L

// Values for lMsgSAP.

#define MSG_FLUSH       1L  // Created thread should flush its message queue.
#define MSG_CALL_USER   2L  // Created thread should call user.
#define MSG_EXIT        3L  // Created thread should exit.

// TYPE of DC

#define LO_DC           0x01
#define LO_METADC       0x02

extern RTL_CRITICAL_SECTION  semLocal;  // Semaphore for handle management
extern RTL_CRITICAL_SECTION  semBrush;  // semphore for client brush


// ahStockObjects will contain both the stock objects visible to an
// application, and internal ones such as the private stock bitmap.

extern ULONG_PTR ahStockObjects[];

// Declare support functions.

HANDLE GdiFixUpHandle(HANDLE h);

PLDC    pldcGet(HDC hdc);
VOID    vSetPldc(HDC hdc,PLDC pldc);
VOID    GdiSetLastError(ULONG iError);
HBITMAP GdiConvertBitmap(HBITMAP hbm);
HRGN    GdiConvertRegion(HRGN hrgn);
HDC     GdiConvertDC(HDC hdc);
HBRUSH  GdiConvertBrush(HBRUSH hbrush);
VOID    vSAPCallback(PLDC);
BOOL    InternalDeleteDC(HDC hdc,ULONG iType);
int     GetBrushBits(HDC hdc,HBITMAP hbmRemote,UINT iUsage,DWORD cbBmi,
            LPVOID pBits,LPBITMAPINFO pBmi);
VOID    CopyCoreToInfoHeader(LPBITMAPINFOHEADER pbmih,LPBITMAPCOREHEADER pbmch);
HBITMAP GetObjectBitmapHandle(HBRUSH hbr, UINT *piUsage);
BOOL    MonoBitmap(HBITMAP hSrvBitmap);

int     APIENTRY SetBkModeWOW(HDC hdc,int iMode);
int     APIENTRY SetPolyFillModeWOW(HDC hdc,int iMode);
int     APIENTRY SetROP2WOW(HDC hdc,int iMode);
int     APIENTRY SetStretchBltModeWOW(HDC hdc,int iMode);
UINT    APIENTRY SetTextAlignWOW(HDC hdc,UINT iMode);

HMETAFILE    WINAPI   SetMetaFileBitsAlt(HLOCAL);
HENHMETAFILE APIENTRY SetEnhMetaFileBitsAlt(HLOCAL, HANDLE, HANDLE, UINT64);
BOOL    InternalDeleteEnhMetaFile(HENHMETAFILE hemf, BOOL bAllocBuffer);
BOOL    SetFontXform(HDC hdc,FLOAT exScale,FLOAT eyScale);
BOOL    DeleteObjectInternal(HANDLE h);
DWORD   GetServerObjectType(HGDIOBJ h);
BOOL    MakeInfoDC(HDC hdc,BOOL bSet);
BOOL    GetDCPoint(HDC hdc,DWORD i,PPOINT pptOut);

HANDLE  CreateClientObj(ULONG ulType);
BOOL    DeleteClientObj(HANDLE h);
PLDC    pldcCreate(HDC hdc,ULONG ulType);
BOOL    bDeleteLDC(PLDC pldc);

BOOL    bGetANSISetMap();

HANDLE  CreateTempSpoolFile();

// Some convenient defines.

typedef BITMAPINFO   BMI;
typedef PBITMAPINFO  PBMI;
typedef LPBITMAPINFO LPBMI;

typedef BITMAPINFOHEADER   BMIH;
typedef PBITMAPINFOHEADER  PBMIH;
typedef LPBITMAPINFOHEADER LPBMIH;

typedef BITMAPCOREINFO   BMC;
typedef PBITMAPCOREINFO  PBMC;
typedef LPBITMAPCOREINFO LPBMC;

typedef BITMAPCOREHEADER   BMCH;
typedef PBITMAPCOREHEADER  PBMCH;
typedef LPBITMAPCOREHEADER LPBMCH;

#define NEG_INFINITY   0x80000000
#define POS_INFINITY   0x7fffffff

// Check if a source is needed in a 3-way bitblt operation.
// This works on both rop and rop3.  We assume that a rop contains zero
// in the high byte.
//
// This is tested by comparing the rop result bits with source (column A
// below) vs. those without source (column B).  If the two cases are
// identical, then the effect of the rop does not depend on the source
// and we don't need a source device.  Recall the rop construction from
// input (pattern, source, target --> result):
//
//      P S T | R   A B         mask for A = 0CCh
//      ------+--------         mask for B =  33h
//      0 0 0 | x   0 x
//      0 0 1 | x   0 x
//      0 1 0 | x   x 0
//      0 1 1 | x   x 0
//      1 0 0 | x   0 x
//      1 0 1 | x   0 x
//      1 1 0 | x   x 0
//      1 1 1 | x   x 0

#define ISSOURCEINROP3(rop3)    \
        (((rop3) & 0xCCCC0000) != (((rop3) << 2) & 0xCCCC0000))

#define MIN(A,B)    ((A) < (B) ?  (A) : (B))
#define MAX(A,B)    ((A) > (B) ?  (A) : (B))
#define MAX4(a, b, c, d)    max(max(max(a,b),c),d)
#define MIN4(a, b, c, d)    min(min(min(a,b),c),d)

//
// Win31 compatibility stuff.
// see user\client
//

DWORD GetAppCompatFlags(KERNEL_PVOID);
DWORD GetAppCompatFlags2(WORD); // defined in w32\w32inc\usergdi.h

#define ABS(X) (((X) < 0 ) ? -(X) : (X))

#define META

int GetBreakExtra (HDC hdc);
int GetcBreak (HDC hdc);
HANDLE GetDCObject (HDC, int);
DWORD GetDCDWord(HDC hdc,UINT index,INT error );


#if DBG
extern int gerritv;


#define MFD1(X) { if(gerritv) DbgPrint(X); }
#define MFD2(X,Y) { if(gerritv) DbgPrint(X,Y); }
#define MFD3(X,Y,Z) { if(gerritv) DbgPrint(X,Y,Z); }

#else

#define MFD1(X)
#define MFD2(X,Y)
#define MFD3(X,Y,Z)

#endif

BOOL    AssociateEnhMetaFile(HDC);
HENHMETAFILE UnassociateEnhMetaFile(HDC, BOOL);
ULONG   ulToASCII_N(LPSTR psz, DWORD cbAnsi, LPWSTR pwsz, DWORD c);
DWORD   GetAndSetDCDWord( HDC, UINT, UINT, UINT, WORD, UINT );

#ifdef DBCS
#define gbDBCSCodeOn  TRUE
#endif

/**************************************************************************\
 *
 * SPOOLER Linking routines.  We don't want to staticly link to the spooler
 * so that it doesn't need to be brought in until necesary.
 *
 *  09-Aug-1994 -by-  Eric Kutter [erick]
 *
\**************************************************************************/


BOOL bLoadSpooler();

#define BLOADSPOOLER    ((ghSpooler != NULL) || bLoadSpooler())

typedef LPWSTR (FAR WINAPI * FPSTARTDOCDLGW)(HANDLE,CONST DOCINFOW *);
typedef BOOL   (FAR WINAPI * FPOPENPRINTERW)(LPWSTR,LPHANDLE,LPPRINTER_DEFAULTSW);
typedef BOOL   (FAR WINAPI * FPRESETPRINTERW)(HANDLE,LPPRINTER_DEFAULTSW);
typedef BOOL   (FAR WINAPI * FPCLOSEPRINTER)(HANDLE);
typedef BOOL   (FAR WINAPI * FPGETPRINTERW)(HANDLE,DWORD,LPBYTE,DWORD,LPDWORD);
typedef BOOL   (FAR WINAPI * FPGETPRINTERDRIVERW)(HANDLE,LPWSTR,DWORD,LPBYTE,DWORD,LPDWORD);

typedef BOOL   (FAR WINAPI * FPENDDOCPRINTER)(HANDLE);
typedef BOOL   (FAR WINAPI * FPENDPAGEPRINTER)(HANDLE);
typedef BOOL   (FAR WINAPI * FPREADPRINTER)(HANDLE,LPVOID,DWORD,LPDWORD);
typedef BOOL   (FAR WINAPI * FPSPLREADPRINTER)(HANDLE,LPBYTE *,DWORD);
typedef DWORD  (FAR WINAPI * FPSTARTDOCPRINTERW)(HANDLE,DWORD,LPBYTE);
typedef BOOL   (FAR WINAPI * FPSTARTPAGEPRINTER)(HANDLE);
typedef BOOL   (FAR WINAPI * FPWRITERPRINTER)(HANDLE,LPVOID,DWORD,LPDWORD);
typedef BOOL   (FAR WINAPI * FPABORTPRINTER)(HANDLE);
typedef BOOL   (FAR WINAPI * FPQUERYSPOOLMODE)(HANDLE,FLONG*,ULONG*);
typedef INT    (FAR WINAPI * FPQUERYREMOTEFONTS)(HANDLE,PUNIVERSAL_FONT_ID,ULONG);
typedef BOOL   (FAR WINAPI * FPSEEKPRINTER)(HANDLE,LARGE_INTEGER,PLARGE_INTEGER,DWORD,BOOL);
typedef BOOL   (FAR WINAPI * FPQUERYCOLORPROFILE)(HANDLE,PDEVMODEW,ULONG,PVOID,ULONG*,FLONG*);
typedef VOID   (FAR WINAPI * FPSPLDRIVERUNLOADCOMPLETE)(LPWSTR);
typedef HANDLE (FAR WINAPI * FPGETSPOOLFILEHANDLE)(HANDLE);
typedef HANDLE (FAR WINAPI * FPCOMMITSPOOLDATA)(HANDLE, HANDLE, DWORD);
typedef BOOL   (FAR WINAPI * FPCLOSESPOOLFILEHANDLE)(HANDLE, HANDLE);
typedef LONG   (FAR WINAPI * FPDOCUMENTPROPERTIESW)(HWND,HANDLE,LPWSTR,PDEVMODEW,PDEVMODEW,DWORD);
typedef DWORD  (FAR WINAPI * FPLOADSPLWOW64)(HANDLE *hProcess);
typedef BOOL   (FAR WINAPI * FPISVALIDDEVMODEW)(PDEVMODEW pDevmode, SIZE_T size);

extern HINSTANCE           ghSpooler;
extern FPSTARTDOCDLGW      fpStartDocDlgW;
extern FPOPENPRINTERW      fpOpenPrinterW;
extern FPRESETPRINTERW     fpResetPrinterW;
extern FPCLOSEPRINTER      fpClosePrinter;
extern FPGETPRINTERW       fpGetPrinterW;
extern FPGETPRINTERDRIVERW fpGetPrinterDriverW;
extern PFNDOCUMENTEVENT    fpDocumentEvent;
extern FPQUERYCOLORPROFILE fpQueryColorProfile;

extern FPSPLDRIVERUNLOADCOMPLETE fpSplDriverUnloadComplete;

extern FPENDDOCPRINTER     fpEndDocPrinter;
extern FPENDPAGEPRINTER    fpEndPagePrinter;
extern FPSPLREADPRINTER    fpSplReadPrinter;
extern FPREADPRINTER       fpReadPrinter;
extern FPSTARTDOCPRINTERW  fpStartDocPrinterW;
extern FPSTARTPAGEPRINTER  fpStartPagePrinter;
extern FPABORTPRINTER      fpAbortPrinter;
extern FPQUERYSPOOLMODE    fpQuerySpoolMode;
extern FPQUERYREMOTEFONTS  fpQueryRemoteFonts;
extern FPSEEKPRINTER       fpSeekPrinter;

extern FPGETSPOOLFILEHANDLE     fpGetSpoolFileHandle;
extern FPCOMMITSPOOLDATA        fpCommitSpoolData;
extern FPCLOSESPOOLFILEHANDLE   fpCloseSpoolFileHandle;

extern FPDOCUMENTPROPERTIESW    fpDocumentPropertiesW;
extern FPLOADSPLWOW64           fpLoadSplWow64;
extern FPISVALIDDEVMODEW        fpIsValidDevmodeW;

int DocumentEventEx(PUMPD, HANDLE, HDC, INT, ULONG, PVOID, ULONG, PVOID);
DWORD StartDocPrinterWEx(PUMPD, HANDLE, DWORD, LPBYTE);
BOOL  EndDocPrinterEx(PUMPD, HANDLE);
BOOL  StartPagePrinterEx(PUMPD, HANDLE);
BOOL  EndPagePrinterEx(PUMPD, HANDLE);
BOOL  AbortPrinterEx(PLDC, BOOL);
BOOL  ResetPrinterWEx(PLDC, PRINTER_DEFAULTSW *);
BOOL  QueryColorProfileEx(PLDC, PDEVMODEW, ULONG, PVOID, ULONG *, FLONG *);

extern BOOL MFP_StartDocA(HDC hdc, CONST DOCINFOA * pDocInfo, BOOL bBanding );
extern BOOL MFP_StartDocW(HDC hdc, CONST DOCINFOW * pDocInfo, BOOL bBanding );
extern int  MFP_StartPage(HDC hdc );
extern int  MFP_EndPage(HDC hdc );
extern int  MFP_EndFormPage(HDC hdc );
extern int  MFP_EndDoc(HDC hdc);
extern BOOL MFP_ResetBanding( HDC hdc, BOOL bBanding );
extern BOOL MFP_ResetDCW( HDC hdc, DEVMODEW *pdmw );
extern int  DetachPrintMetafile( HDC hdc );
extern HDC  ResetDCWInternal(HDC hdc, CONST DEVMODEW *pdm, BOOL *pbBanding);
extern BOOL PutDCStateInMetafile( HDC hdcMeta );


//font subsetting routines
typedef void *(WINAPIV *CFP_ALLOCPROC) (size_t);
typedef void *(WINAPIV *CFP_REALLOCPROC) (void *, size_t);
typedef void (WINAPIV *CFP_FREEPROC) (void *);

typedef SHORT  (FAR WINAPIV * FPCREATEFONTPACKAGE)(const PUCHAR, const ULONG,
                                                   PUCHAR*, ULONG*, ULONG*, const USHORT,
                                                   const USHORT, const USHORT, const USHORT,
                                                   const USHORT, const USHORT,
                                                   const PUSHORT, const USHORT,
                                                   CFP_ALLOCPROC, CFP_REALLOCPROC, CFP_FREEPROC,
                                                   void*);

typedef SHORT  (FAR WINAPIV * FPMERGEFONTPACKAGE)(const PUCHAR, const ULONG, const PUCHAR, const ULONG, PUCHAR*,
                                                 ULONG*, ULONG*, const USHORT,
                                                 CFP_ALLOCPROC, CFP_REALLOCPROC, CFP_FREEPROC,
                                                 void*);
extern FPCREATEFONTPACKAGE  gfpCreateFontPackage;
extern FPMERGEFONTPACKAGE   gfpMergeFontPackage;

// gulMaxCig is used to decide whether font subset should be used for remote printing
extern ULONG    gulMaxCig;

#if DBG
#define DBGSUBSET 1
#endif

#ifdef  DBGSUBSET
extern FLONG    gflSubset;

#define FL_SS_KEEPLIST      1
#define FL_SS_BUFFSIZE      2
#define FL_SS_SPOOLTIME     4
#define FL_SS_PAGETIME      8
#define FL_SS_SUBSETTIME    16
#endif //  DBGSUBSET

/**************************************************************************\
 *
 * EMF structures.
 *
 *  EMFSPOOLHEADER - first thing in a spool file
 *
 *  EMFITEMHEADER  - defines items (blocks) of a metafile.  This includes
 *                   fonts, pages, new devmode, list of things to do before
 *                   first start page.
 *
 *                   cjSize is the size of the data following the header
 *
 *
\**************************************************************************/

//
// Round up n to the nearest multiple of sizeof(DWORD)
//  (also provide a boolean macro to which returns true of the roundup
//  calculation would overflow)

#define ROUNDUP_DWORDALIGN(n) (((n) + sizeof(DWORD) - 1) & ~(sizeof(DWORD)-1))
#define BROUNDUP_DWORDALIGN_OVERFLOW(n)  (((unsigned)((n)+(sizeof(DWORD)-1)) < (n)) ? 1 : 0)

typedef struct tagEMFSPOOLHEADER {
    DWORD dwVersion;    // version of this EMF spoolfile
    DWORD cjSize;       // size of this structure
    DWORD dpszDocName;  // offset to lpszDocname value of DOCINFO struct
    DWORD dpszOutput;   // offset to lpszOutput value of DOCINFO struct
} EMFSPOOLHEADER;


#define EMRI_METAFILE          0x00000001
#define EMRI_ENGINE_FONT       0x00000002
#define EMRI_DEVMODE           0x00000003
#define EMRI_TYPE1_FONT        0x00000004
#define EMRI_PRESTARTPAGE      0x00000005
#define EMRI_DESIGNVECTOR      0x00000006
#define EMRI_SUBSET_FONT       0x00000007
#define EMRI_DELTA_FONT        0x00000008
#define EMRI_FORM_METAFILE     0x00000009
#define EMRI_BW_METAFILE       0x0000000A
#define EMRI_BW_FORM_METAFILE  0x0000000B
#define EMRI_METAFILE_DATA     0x0000000C
#define EMRI_METAFILE_EXT      0x0000000D
#define EMRI_BW_METAFILE_EXT   0x0000000E
#define EMRI_ENGINE_FONT_EXT   0x0000000F
#define EMRI_TYPE1_FONT_EXT    0x00000010
#define EMRI_DESIGNVECTOR_EXT  0x00000011
#define EMRI_SUBSET_FONT_EXT   0x00000012
#define EMRI_DELTA_FONT_EXT    0x00000013
#define EMRI_PS_JOB_DATA       0x00000014
#define EMRI_EMBED_FONT_EXT    0x00000015

#define EMF_PLAY_COLOR            0x00000001 // Current DC has DMCOLOR_COLOR
#define EMF_PLAY_MONOCHROME       0x00000002 // Changed by Optimization code to MONOCHROME
#define EMF_PLAY_FORCE_MONOCHROME 0x00000003 // Changed to MONOCHROME in the spool file

#define NORMAL_PAGE 1
#define FORM_PAGE   2

typedef struct tagEMFITEMHEADER
{
    DWORD ulID;     // either EMRI_METAFILE or EMRI_FONT
    DWORD cjSize;   // size of item in bytes
} EMFITEMHEADER;

//
// EMF spool file record structure for the following record types:
//  EMRI_METAFILE_EXT
//  EMRI_BW_METAFILE_EXT
//  EMRI_ENGINE_FONT_EXT
//  EMRI_TYPE1_FONT_EXT
//  EMRI_DESIGNVECTOR_EXT
//  EMRI_SUBSET_FONT_EXT
//  EMRI_DELTA_FONT_EXT
//

typedef struct tagEMFITEMHEADER_EXT
{
    EMFITEMHEADER   emfi;
    INT64           offset;
} EMFITEMHEADER_EXT;

typedef struct tagEMFITEMPRESTARTPAGE
{
    ULONG         ulUnused; // originally ulCopyCount
    BOOL          bEPS;
}EMFITEMPRESTARTPAGE, *PEMFITEMPRESTARTPAGE;

typedef struct tagRECORD_INFO_STRUCT
{
    struct tagRECORD_INFO_STRUCT *pNext;
    LONGLONG      RecordOffset;
    ULONG         RecordSize;
    DWORD         RecordID;
} RECORD_INFO_STRUCT, *PRECORD_INFO_STRUCT;

typedef struct tagPAGE_INFO_STRUCT
{
    LONGLONG             EMFOffset;
    LONGLONG             SeekOffset;
    LPDEVMODEW           pDevmode;
    ULONG                EMFSize;
    ULONG                ulID;
    PRECORD_INFO_STRUCT  pRecordInfo;
} PAGE_INFO_STRUCT;

typedef struct tagPAGE_LAYOUT_STRUCT
{
    HENHMETAFILE     hemf;
    DWORD            dwPageNumber;
    XFORM            XFormDC;
    RECT             rectClip;
    RECT             rectDocument;
    RECT             rectBorder;
    BOOL             bAllocBuffer;
} PAGE_LAYOUT_STRUCT;

typedef struct tagEMF_HANDLE
{
    DWORD              tag;
    DWORD              dwPageNumber;
    HENHMETAFILE       hemf;
    BOOL               bAllocBuffer;
    struct tagEMF_HANDLE *pNext;
} EMF_HANDLE, *PEMF_HANDLE;

typedef struct tagEMF_LIST
{
    HENHMETAFILE       hemf;
    BOOL               bAllocBuffer;
    struct tagEMF_LIST *pNext;
} EMF_LIST, *PEMF_LIST;

typedef struct tagSPOOL_FILE_HANDLE
{
    DWORD              tag;
    HDC                hdc;
    HANDLE             hSpooler;
    LPDEVMODEW         pOriginalDevmode;
    LPDEVMODEW         pLastDevmode;
    ULONG              MaxPageProcessed;
    PAGE_INFO_STRUCT   *pPageInfo;
    ULONG              PageInfoBufferSize;
    DWORD              dwNumberOfPagesInCurrSide;
    BOOL               bBanding;
    PAGE_LAYOUT_STRUCT *pPageLayout;
    DWORD              dwNumberOfPagesAllocated;
    PEMF_HANDLE        pEMFHandle;
    DWORD              dwPlayBackStatus;
    BOOL               bUseMemMap;
} SPOOL_FILE_HANDLE;

#define SPOOL_FILE_HANDLE_TAG                   'SPHT'
#define SPOOL_FILE_MAX_NUMBER_OF_PAGES_PER_SIDE 32
#define EMF_HANDLE_TAG                          'EFHT'

/**************************************************************************\
 *
 * stuff from csgdi.h
 *
\**************************************************************************/

//
// Win32ClientInfo[WIN32_CLIENT_INFO_SPIN_COUNT] corresponds to the
// cSpins field of the CLIENTINFO structure.  See ntuser\inc\user.h.
//
#define RESETUSERPOLLCOUNT() ((DWORD)NtCurrentTebShared()->Win32ClientInfo[WIN32_CLIENT_INFO_SPIN_COUNT] = 0)

ULONG cjBitmapSize(CONST BITMAPINFO *pbmi,ULONG iUsage);
ULONG cjBitmapBitsSize(CONST BITMAPINFO *pbmi);
ULONG cjBitmapScanSize(CONST BITMAPINFO *pbmi, int nScans);

BITMAPINFOHEADER * pbmihConvertHeader (BITMAPINFOHEADER *pbmih);

LPBITMAPINFO pbmiConvertInfo(CONST BITMAPINFO *, ULONG, ULONG * ,BOOL);

//
// object.c
//

HANDLE hGetPEBHandle(HANDLECACHETYPE,ULONG);
BOOL bDIBSectionSelected(PDC_ATTR);
PDEVMODEW pdmwGetDefaultDevMode(
    HANDLE          hSpooler,
    PUNICODE_STRING pustrDevice,    // device name
    PVOID          *ppvFree         // *ppvFree must be freed by the caller
    );

/**************************************************************************\
 *  DIB flags.  These flags are merged with the usage field when calling
 *  cjBitmapSize to specify what the size should include.  Any routine that
 *  uses these flags should first use the macro, CHECKDIBFLAGS(iUsage) to
 *  return an error if one of these bits is set.  If the definition of
 *  iUsage changes and one of these flags becomes a valid flag, the interface
 *  will need to be changed slightly.
 *
 *  04-June-1991 -by- Eric Kutter [erick]
\**************************************************************************/

#define DIB_MAXCOLORS   0x80000000
#define DIB_NOCOLORS    0x40000000
#define DIB_LOCALFLAGS  (DIB_MAXCOLORS | DIB_NOCOLORS)

#define CHECKDIBFLAGS(i)  {if (i & DIB_LOCALFLAGS)                    \
                           {RIP("INVALID iUsage"); goto MSGERROR;}}


#define HANDLE_TO_INDEX(h) (DWORD)((ULONG_PTR)h & 0x0000ffff)

/******************************Public*Macro********************************\
*
*  PSHARED_GET_VALIDATE
*
*  Validate all handle information, return user pointer if the handle
*  is valid or NULL otherwise.
*
* Arguments:
*
*   p       - pointer to assign to pUser is successful
*   h       - handle to object
*   iType   - handle type
*
\**************************************************************************/

#pragma warning(4:4821)     // Disable all ptr64->ptr32 truncation warnings for now

#define PSHARED_GET_VALIDATE(p,h,iType)                                 \
{                                                                       \
    UINT uiIndex = HANDLE_TO_INDEX(h);                                  \
    p = NULL;                                                           \
                                                                        \
    if (uiIndex < MAX_HANDLE_COUNT)                                     \
    {                                                                   \
        PENTRY pentry = &pGdiSharedHandleTable[uiIndex];                \
                                                                        \
        if (                                                            \
             (pentry->Objt == iType) &&                                 \
             (pentry->FullUnique == (USHORT)((ULONG_PTR)h >> 16)) &&    \
             (OBJECTOWNER_PID(pentry->ObjectOwner) == gW32PID)          \
           )                                                            \
        {                                                               \
            p = (PVOID)(ULONG_PTR)pentry->pUser;                        \
        }                                                               \
    }                                                                   \
}

#define VALIDATE_HANDLE(bRet, h,iType)                                  \
{                                                                       \
    UINT uiIndex = HANDLE_TO_INDEX(h);                                  \
    bRet = FALSE;                                                       \
                                                                        \
    if (uiIndex < MAX_HANDLE_COUNT)                                     \
    {                                                                   \
        PENTRY pentry = &pGdiSharedHandleTable[uiIndex];                \
                                                                        \
        if (                                                            \
             (pentry->Objt == iType) &&                                 \
             ((pentry->FullUnique&~FULLUNIQUE_STOCK_MASK) ==            \
             (((USHORT)((ULONG_PTR)h >> 16))&~FULLUNIQUE_STOCK_MASK)) &&\
             ((OBJECTOWNER_PID(pentry->ObjectOwner) == gW32PID) ||      \
              (OBJECTOWNER_PID(pentry->ObjectOwner) == 0))              \
           )                                                            \
        {                                                               \
           bRet = TRUE;                                                 \
        }                                                               \
    }                                                                   \
}


#define VALIDATE_HANDLE_AND_STOCK(bRet, h, iType, bStock)               \
{                                                                       \
    UINT uiIndex = HANDLE_TO_INDEX(h);                                  \
    bRet = FALSE;                                                       \
    bStock = FALSE;                                                     \
                                                                        \
    if (uiIndex < MAX_HANDLE_COUNT)                                     \
    {                                                                   \
        PENTRY pentry = &pGdiSharedHandleTable[uiIndex];                \
                                                                        \
        if (                                                            \
             (pentry->Objt == iType) &&                                 \
             ((pentry->FullUnique&~FULLUNIQUE_STOCK_MASK) ==            \
             (((USHORT)((ULONG_PTR)h >> 16))&~FULLUNIQUE_STOCK_MASK)) &&\
             ((OBJECTOWNER_PID(pentry->ObjectOwner) == gW32PID) ||      \
              (OBJECTOWNER_PID(pentry->ObjectOwner) == 0))              \
           )                                                            \
        {                                                               \
           bRet = TRUE;                                                 \
           bStock = (pentry->FullUnique & FULLUNIQUE_STOCK_MASK);       \
        }                                                               \
    }                                                                   \
}
//
//
// DC_ATTR support
//
//
//

extern PGDI_SHARED_MEMORY pGdiSharedMemory;
extern PDEVCAPS           pGdiDevCaps;
extern PENTRY             pGdiSharedHandleTable;
extern W32PID             gW32PID;

#define SHARECOUNT(hbrush)       (pGdiSharedHandleTable[HANDLE_TO_INDEX(h)].ObjectOwner.Share.Count)


/******************************Public*Routine******************************\
*
* FSHARED_DCVALID_RAO - check Valid RAO flag in the handle table entry for
*                       the hdc
*
* Arguments:
*
*   hdc
*
* Return Value:
*
*    BOOL flag value
*
\**************************************************************************/


#define FSHARED_DCVALID_RAO(hdc)                            \
    (pGdiSharedHandleTable[HDC_TO_INDEX(hdc)].Flags &       \
            HMGR_ENTRY_VALID_RAO)

BOOL
DeleteRegion(HRGN);


/******************************Public*Macro********************************\
* ORDER_PRECT makes the rect well ordered
*
* Arguments:
*
*    PRECTL prcl
*
\**************************************************************************/

#define ORDER_PRECTL(prcl)              \
{                                       \
    LONG lt;                            \
                                        \
    if (prcl->left > prcl->right)       \
    {                                   \
        lt          = prcl->left;       \
        prcl->left  = prcl->right;      \
        prcl->right = lt;               \
    }                                   \
                                        \
    if (prcl->top > prcl->bottom)       \
    {                                   \
        lt           = prcl->top;       \
        prcl->top    = prcl->bottom;    \
        prcl->bottom = lt;              \
    }                                   \
}

//
// client region defines and structures
//

#define CONTAINED 1
#define CONTAINS  2
#define DISJOINT  3


#define VALID_SCR(X)    (!((X) & 0xF8000000) || (((X) & 0xF8000000) == 0xF8000000))
#define VALID_SCRPT(P)  ((VALID_SCR((P).x)) && (VALID_SCR((P).y)))
#define VALID_SCRPPT(P) ((VALID_SCR((P)->x)) && (VALID_SCR((P)->y)))
#define VALID_SCRRC(R)  ((VALID_SCR((R).left)) && (VALID_SCR((R).bottom)) && \
                         (VALID_SCR((R).right)) && (VALID_SCR((R).top)))
#define VALID_SCRPRC(R) ((VALID_SCR((R)->left)) && (VALID_SCR((R)->bottom)) && \
                         (VALID_SCR((R)->right)) && (VALID_SCR((R)->top)))

int iRectRelation(PRECTL prcl1, PRECTL prcl2);

int APIENTRY GetRandomRgn(HDC hdc,HRGN hrgn,int iNum);

#define vReferenceCFONTCrit(pcf)   {(pcf)->cRef++;}

DWORD   GetCodePage(HDC hdc);


#define FLOATARG(f)     (*(PULONG)(PFLOAT)&(f))
#define FLOATPTRARG(pf) ((PULONG)(pf))

/******************************Public*Macros******************************\
* FIXUP_HANDLE(h) and FIXUP_HANDLEZ(h)
*
* check to see if the handle has been truncated.
* FIXUP_HANDLEZ() adds an extra check to allow NULL.
*
* Arguments:
*   h - handle to be checked and fix
*
* Return Value:
*
* History:
*
*    25-Jan-1996 -by- Lingyun Wang [lingyunw]
*
\**************************************************************************/

#define HANDLE_FIXUP 0

#if DBG
extern INT gbCheckHandleLevel;
#endif

#define NEEDS_FIXING(h)    (!((ULONG_PTR)h & 0xffff0000))

#if DBG
#define HANDLE_WARNING()                                                 \
{                                                                        \
        if (gbCheckHandleLevel == 1)                                     \
        {                                                                \
            WARNING ("truncated handle\n");                              \
        }                                                                \
        ASSERTGDI (gbCheckHandleLevel != 2, "truncated handle\n");       \
}
#else
#define HANDLE_WARNING()
#endif

#if DBG
#define CHECK_HANDLE_WARNING(h, bZ)                                      \
{                                                                        \
    BOOL bFIX = NEEDS_FIXING(h);                                         \
                                                                         \
    if (bZ) bFIX = h && bFIX;                                            \
                                                                         \
    if (bFIX)                                                            \
    {                                                                    \
        if (gbCheckHandleLevel == 1)                                     \
        {                                                                \
            WARNING ("truncated handle\n");                              \
        }                                                                \
        ASSERTGDI (gbCheckHandleLevel != 2, "truncated handle\n");       \
    }                                                                    \
}
#else
#define CHECK_HANDLE_WARNING(h,bZ)
#endif


#if HANDLE_FIXUP
#define FIXUP_HANDLE(h)                                 \
{                                                       \
    if (NEEDS_FIXING(h))                                \
    {                                                   \
        HANDLE_WARNING();                               \
        h = GdiFixUpHandle(h);                          \
    }                                                   \
}
#else
#define FIXUP_HANDLE(h)                                 \
{                                                       \
    CHECK_HANDLE_WARNING(h,FALSE);                      \
}
#endif

#if HANDLE_FIXUP
#define FIXUP_HANDLEZ(h)                                \
{                                                       \
    if (h && NEEDS_FIXING(h))                           \
    {                                                   \
        HANDLE_WARNING();                               \
        h = GdiFixUpHandle(h);                          \
    }                                                   \
}
#else
#define FIXUP_HANDLEZ(h)                                \
{                                                       \
    CHECK_HANDLE_WARNING(h,TRUE);                       \
}
#endif

#define FIXUP_HANDLE_NOW(h)                             \
{                                                       \
    if (NEEDS_FIXING(h))                                \
    {                                                   \
        HANDLE_WARNING();                               \
        h = GdiFixUpHandle(h);                          \
    }                                                   \
}

/******************************MACRO***************************************\
*  CHECK_AND_FLUSH
*
*   Check if commands in the batch need to be flushed based on matching
*   hdc
*
* Arguments:
*
*   hdc
*
* History:
*
*    14-Feb-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#define CHECK_AND_FLUSH(hdc, pdca)                                       \
{                                                                        \
    if ((NtCurrentTebShared()->GdiTebBatch.HDC == (ULONG_PTR)hdc)        \
         && (pdca->ulDirty_ & BATCHED_DRAWING)                           \
       )                                                                 \
    {                                                                    \
        NtGdiFlush();                                                    \
        pdca->ulDirty_ &= ~BATCHED_DRAWING;                              \
    }                                                                    \
}

#define CHECK_AND_FLUSH_TEXT(hdc, pdca)                                  \
{                                                                        \
    if ((NtCurrentTebShared()->GdiTebBatch.HDC == (ULONG_PTR)hdc)        \
          &&  (pdca->ulDirty_ & BATCHED_TEXT)                            \
       )                                                                 \
    {                                                                    \
        NtGdiFlush();                                                    \
        pdca->ulDirty_ &= ~BATCHED_TEXT;                                 \
        pdca->ulDirty_ &= ~BATCHED_DRAWING;                              \
    }                                                                    \
}

#if defined(_WIN64) || defined(BUILD_WOW6432)

#define KHANDLE_ALIGN(size) ((size + sizeof(KHANDLE) - 1) & ~(sizeof(KHANDLE) - 1))

#else

// no alignment issues on regular 32-bit
#define KHANDLE_ALIGN(size) (size)

#endif

/*********************************MACRO************************************\
* BEGIN_BATCH_HDC
*
*   Attemp to place the command in the TEB batch. This macro is for use
*   with commands requiring an HDC
*
* Arguments:
*
*   hdc     - hdc of command
*   pdca    - PDC_ATTR from hdc
*   cType   - enum bathc command type
*   StrType - specific BATCH structure
*
* Return Value:
*
*   none: will jump to UNBATHCED_COMMAND if command can't be batched
*
* History:
*
*    22-Feb-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#define BEGIN_BATCH_HDC(hdc,pdca,cType,StrType)                               \
{                                                                             \
    PTEBSHARED ptebShared = NtCurrentTebShared();                             \
    StrType *pBatch;                                                          \
    HDC      hdcBatch = hdc;                                                  \
                                                                              \
    if (!(                                                                    \
         (                                                                    \
           (ptebShared->GdiTebBatch.HDC == 0)          ||                     \
           (ptebShared->GdiTebBatch.HDC == (ULONG_PTR)hdc)                    \
         ) &&                                                                 \
         ((ptebShared->GdiTebBatch.Offset + KHANDLE_ALIGN(sizeof(StrType))) <= GDI_BATCH_SIZE) &&  \
         (pdca != NULL) &&                                                    \
         (!(pdca->ulDirty_ & DC_DIBSECTION))                                  \
       ))                                                                     \
    {                                                                         \
        goto UNBATCHED_COMMAND;                                               \
    }                                                                         \
                                                                              \
    pBatch = (StrType *)(                                                     \
                          ((PBYTE)(&ptebShared->GdiTebBatch.Buffer[0])) +     \
                          ptebShared->GdiTebBatch.Offset                      \
                        );                                                    \
                                                                              \
    pBatch->Type              = cType;                                        \
    pBatch->Length            = KHANDLE_ALIGN(sizeof(StrType));               \
                                                                              \
    if (cType < BatchTypeSetBrushOrg)                                         \
    {                                                                         \
        pdca->ulDirty_ |= BATCHED_DRAWING;                                    \
    }                                                                         \
                                                                              \
    if (cType == BatchTypeTextOut)                                            \
    {                                                                         \
        pdca->ulDirty_ |= BATCHED_TEXT;                                       \
    }


/*********************************MACRO************************************\
* BEGIN_BATCH_HDC
*
*   Attemp to place the command in the TEB batch. This macro is for use
*   with commands requiring an HDC
*
* Arguments:
*
*   hdc     - hdc of command
*   pdca    - PDC_ATTR from hdc
*   cType   - enum bathc command type
*   StrType - specific BATCH structure
*
* Return Value:
*
*   none: will jump to UNBATHCED_COMMAND if command can't be batched
*
* History:
*
*    22-Feb-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#define BEGIN_BATCH_HDC_SIZE(hdc,pdca,cType,StrType,Size)                 \
{                                                                         \
    PTEBSHARED ptebShared = NtCurrentTebShared();                         \
    StrType *pBatch;                                                      \
    HDC      hdcBatch = hdc;                                              \
                                                                          \
    if (!(                                                                \
         (                                                                \
           (ptebShared->GdiTebBatch.HDC == 0)          ||                 \
           (ptebShared->GdiTebBatch.HDC == (ULONG_PTR)hdc)                \
         ) &&                                                             \
         ((ptebShared->GdiTebBatch.Offset + KHANDLE_ALIGN(Size)) <= GDI_BATCH_SIZE) &&   \
         (pdca != NULL) &&                                                \
         (!(pdca->ulDirty_ & DC_DIBSECTION))                              \
       ))                                                                 \
    {                                                                     \
        goto UNBATCHED_COMMAND;                                           \
    }                                                                     \
                                                                          \
    pBatch = (StrType *)(                                                 \
                          ((PBYTE)(&ptebShared->GdiTebBatch.Buffer[0])) + \
                          ptebShared->GdiTebBatch.Offset                  \
                        );                                                \
                                                                          \
    pBatch->Type              = cType;                                    \
    pBatch->Length            = KHANDLE_ALIGN(Size);                      \
                                                                          \
    if (cType < BatchTypeSetBrushOrg)                                     \
    {                                                                     \
        pdca->ulDirty_ |= BATCHED_DRAWING;                                \
    }                                                                     \
                                                                          \
    if (cType == BatchTypeTextOut)                                        \
    {                                                                     \
        pdca->ulDirty_ |= BATCHED_TEXT;                                   \
    }


/*********************************MACRO************************************\
* BEGIN_BATCH
*
*   Attemp to place the command in the TEB batch. This macro is for use
*   with commands that don't require an HDC
*
* Arguments:
*
*   cType   - enum bathc command type
*   StrType - specific BATCH structure
*
* Return Value:
*
*   none: will jump to UNBATHCED_COMMAND if command can't be batched
*
* Notes:
*
*   The "Win32ThreadInfo==NULL" check fixes "issue 2" of bug #338052.
*
*   If the thread is not a GUI thread, we can't batch non-HDC operations, 
*   because we can't guarantee that the batch will be flushed before the 
*   thread exits. (GdiThreadCallout isn't called unless the thread is a GUI
*   thread.)
*
* History:
*
*    22-Feb-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#define BEGIN_BATCH(cType,StrType)                                            \
{                                                                             \
    PTEBSHARED ptebShared = NtCurrentTebShared();                             \
    StrType *pBatch;                                                          \
    HDC      hdcBatch = NULL;                                                 \
                                                                              \
    if (ptebShared->Win32ThreadInfo == NULL)                                  \
    {                                                                         \
        goto UNBATCHED_COMMAND;                                               \
    }                                                                         \
                                                                              \
    if (!                                                                     \
         ((ptebShared->GdiTebBatch.Offset + KHANDLE_ALIGN(sizeof(StrType))) <= GDI_BATCH_SIZE) \
       )                                                                      \
    {                                                                         \
        goto UNBATCHED_COMMAND;                                               \
    }                                                                         \
                                                                              \
    pBatch = (StrType *)(                                                     \
                          ((PBYTE)(&ptebShared->GdiTebBatch.Buffer[0])) +     \
                          ptebShared->GdiTebBatch.Offset                      \
                        );                                                    \
                                                                              \
    pBatch->Type              = cType;                                        \
    pBatch->Length            = KHANDLE_ALIGN(sizeof(StrType));               \

/*********************************MACRO************************************\
*  COMPLETE_BATCH_COMMAND
*
*   Complete batched command started with BEGIN_BATCH or BEGIN_BATCH_HDC.
*   The command is not actually batched unless this macro is executed.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   None
*
* History:
*
*    22-Feb-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#define COMPLETE_BATCH_COMMAND()                                           \
    if (hdcBatch)                                                          \
    {                                                                      \
        ptebShared->GdiTebBatch.HDC     = (ULONG_PTR)hdcBatch;             \
    }                                                                      \
    ptebShared->GdiTebBatch.Offset +=                                      \
        (pBatch->Length + sizeof(KHANDLE) - 1) & ~(sizeof(KHANDLE)-1);     \
                                                                           \
    ptebShared->GdiBatchCount++;                                           \
    if (ptebShared->GdiBatchCount >= GdiBatchLimit)                        \
    {                                                                      \
        NtGdiFlush();                                                      \
    }                                                                      \
}


/******************************Public*Routine******************************\
* HBRUSH CacheSelectBrush (HDC hdc, HBRUSH hbrush)
*
*   Client side brush caching
*
* History:
*  04-June-1995 -by-  Lingyun Wang [lingyunW]
* Wrote it.
\**************************************************************************/

#define CACHE_SELECT_BRUSH(pDcAttr,hbrushNew,hbrushOld)                    \
{                                                                          \
    hbrushOld = 0;                                                         \
                                                                           \
    if (pDcAttr)                                                           \
    {                                                                      \
        pDcAttr->ulDirty_ |= DC_BRUSH_DIRTY;                               \
        hbrushOld = pDcAttr->hbrush;                                       \
        pDcAttr->hbrush = hbrushNew;                                       \
    }                                                                      \
}


/******************************Public*Routine******************************\
* CacheSelectPen
*
*   Select a pen into DC_ATTR field of DC and set pen flag
*
* Arguments:
*
*   hdc     - user hdc
*   hpenNew - New Pen to select
*
* Return Value:
*
*   Old Pen or NULL
*
* History:
*
*    25-Jan-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#define CACHE_SELECT_PEN(pdcattr,hpenNew, hpenOld)                         \
{                                                                          \
    hpenOld = 0;                                                           \
                                                                           \
    if (pdcattr)                                                           \
    {                                                                      \
        pdcattr->ulDirty_ |= DC_PEN_DIRTY;                                 \
        hpenOld = pdcattr->hpen;                                           \
        pdcattr->hpen = hpenNew;                                           \
    }                                                                      \
}





/**************************************************************************\
 *
 * far east
 *
\**************************************************************************/

extern UINT   guintAcp;
extern UINT   guintDBCScp;
extern UINT   fFontAssocStatus;
extern WCHAR *gpwcANSICharSet;
extern WCHAR *gpwcDBCSCharSet;
extern BOOL   gbDBCSCodePage;

UINT WINAPI QueryFontAssocStatus( VOID );
DWORD FontAssocHack(DWORD,CHAR*,UINT);

BOOL bComputeTextExtentDBCS(PDC_ATTR,CFONT*,LPCSTR,int,UINT,SIZE*);
BOOL bComputeCharWidthsDBCS(CFONT*, UINT, UINT, ULONG, PVOID);
extern BOOL IsValidDBCSRange( UINT iFirst , UINT iLast );
extern BYTE GetCurrentDefaultChar(HDC hdc);
extern BOOL bSetUpUnicodeStringDBCS(UINT iFirst,UINT iLast,PUCHAR puchTmp,
                                    PWCHAR pwc, UINT uiCodePage,CHAR chDefaultChar);

extern WINAPI NamedEscape(HDC,LPWSTR,int,int,LPCSTR,int,LPSTR);
extern BOOL RemoteRasterizerCompatible(HANDLE hSpooler);

void ConvertDxArray(UINT CP,char *pszDBCS,INT *pDxDBCS,UINT c,INT *pDxU, BOOL bPdy);


#ifdef LANGPACK

/**************************************************************************\
 *
 * language packs
 *
\**************************************************************************/

extern gbLpk;
extern void InitializeLanguagePack();

typedef BOOL   (* FPLPKINITIALIZE)(DWORD);
typedef UINT   (* FPLPKGETCHARACTERPLACEMENT)
                  (HDC,LPCWSTR,int,int,LPGCP_RESULTSW,DWORD,INT);
typedef BOOL   (* FPLPKEXTEXTOUT)
                  (HDC,INT,INT,UINT,CONST RECT*,LPCWSTR,UINT,CONST INT*,INT);

typedef BOOL   (* FPLPKGETTEXTEXTENTEXPOINT)
                  (HDC, LPCWSTR, INT, INT, LPINT, LPINT, LPSIZE, FLONG, INT);
typedef BOOL   (* FPLPKUSEGDIWIDTHCACHE)(HDC,LPCSTR,int,LONG,BOOL);


extern FPLPKGETCHARACTERPLACEMENT fpLpkGetCharacterPlacement;
extern FPLPKEXTEXTOUT fpLpkExtTextOut;
extern FPLPKGETCHARACTERPLACEMENT fpLpkGetCharacterPlacement;
extern FPLPKGETTEXTEXTENTEXPOINT fpLpkGetTextExtentExPoint;
extern FPLPKUSEGDIWIDTHCACHE fpLpkUseGDIWidthCache;

#endif

typedef union _BLENDULONG
{
    BLENDFUNCTION Blend;
    ULONG         ul;
}BLENDULONG,*PBLENDULONG;

BOOL bMergeSubsetFont(HDC, PVOID, ULONG, PVOID*, ULONG*, BOOL, UNIVERSAL_FONT_ID*);
PUFIHASH pufihAddUFIEntry(PUFIHASH*, PUNIVERSAL_FONT_ID, ULONG, FLONG, FLONG);
#define FL_UFI_SUBSET  1


BOOL bDoFontSubset(PUFIHASH, PUCHAR*, ULONG*, ULONG*);
BOOL WriteFontToSpoolFile(PLDC, PUNIVERSAL_FONT_ID, FLONG);
BOOL WriteSubFontToSpoolFile(PLDC, PUCHAR, ULONG, UNIVERSAL_FONT_ID*, BOOL);
BOOL bAddUFIandWriteSpool(HDC,PUNIVERSAL_FONT_ID,BOOL, FLONG);
VOID vFreeUFIHashTable( PUFIHASH *pUFIHashBase, FLONG fl);
BOOL WriteFontDataAsEMFComment(PLDC, DWORD, PVOID, DWORD, PVOID, DWORD);

//
// C helper functions for working with EMFSpoolData object
// (stored in the hEMFSpool field in LDC).
//

BOOL AllocEMFSpoolData(PLDC pldc, BOOL banding);
VOID DeleteEMFSpoolData(PLDC pldc);
BOOL WriteEMFSpoolData(PLDC pldc, PVOID buffer, ULONG size);
BOOL FlushEMFSpoolData(PLDC pldc, DWORD pageType);

#define MMAPCOPY_THRESHOLD  0x100000   // 1MB

VOID CopyMemoryToMemoryMappedFile(PVOID Destination, CONST VOID *Source, DWORD Length);
DWORD GetFileMappingAlignment();
DWORD GetSystemPageSize();

BOOL MirrorRgnDC(HDC hdc, HRGN hrgn, HRGN *phrgn);

#define HORZSIZEP 1
#define VERTSIZEP 2

#if DBG
#define EMFVALFAIL(x) DbgPrint x 
#else
#define EMFVALFAIL(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\metadef.h ===
/*************************************************************************\
* Module Name: metadef.h
*
* This file contains the definitions and constants for metafile.
*
* Created: 12-June-1991 13:46:00
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\*************************************************************************/

// Metafile header sizes for existing valid versions

// Minimum header size
#define META_HDR_SIZE_MIN               META_HDR_SIZE_VERSION_1
// Original header
#define META_HDR_SIZE_VERSION_1         88


// Header with OpenGL extensions
#define META_HDR_SIZE_VERSION_2         100

// Header with sizlMicrometer extensions
#define META_HDR_SIZE_VERSION_3         108


// Maximum header size
#define META_HDR_SIZE_MAX               sizeof(ENHMETAHEADER)

// Metafile version constants

#define META_FORMAT_ENHANCED     0x10000         // Windows NT format
#define META_FORMAT_WINDOWS      0x300           // Windows 3.x format

// Metafile record structure.

typedef struct tagENHMETABOUNDRECORD
{
    DWORD   iType;              // Record type EMR_
    DWORD   nSize;              // Record size in bytes
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   dParm[1];           // Parameters
} ENHMETABOUNDRECORD, *PENHMETABOUNDRECORD;

// Flags for iType field in ENHMETARECORD.
// They are to be used in future to support backward systems only.
// See PlayEnhMetaFileRecord for details.

#define EMR_NOEMBED      0x80000000  // do not include record in embedding
#define EMR_ACCUMBOUNDS  0x40000000  // record has bounds

typedef struct tagMETALINK16
{
    DWORD       metalink;
    struct tagMETALINK16 *pmetalink16Next;
    HANDLE      hobj;
    PVOID       pv;

// WARNING: fields before this must match the LINK structure.

    DWORD       cMetaDC16;
    HDC         ahMetaDC16[1];
} METALINK16, *PMETALINK16;

// Public GdiComment.

typedef struct tagEMRGDICOMMENT_PUBLIC
{
    EMR     emr;
    DWORD   cbData;             // Size of following fields and data
    DWORD   ident;              // GDICOMMENT_IDENTIFIER
    DWORD   iComment;           // Comment type e.g. GDICOMMENT_WINDOWS_METAFILE
} EMRGDICOMMENT_PUBLIC, *PEMRGDICOMMENT_PUBLIC;

// Public GdiComment for embedded Windows metafile.

typedef struct tagEMRGDICOMMENT_WINDOWS_METAFILE
{
    EMR     emr;
    DWORD   cbData;             // Size of following fields and windows metafile
    DWORD   ident;              // GDICOMMENT_IDENTIFIER
    DWORD   iComment;           // GDICOMMENT_WINDOWS_METAFILE
    DWORD   nVersion;           // 0x300 or 0x100
    DWORD   nChecksum;          // Checksum
    DWORD   fFlags;             // Compression etc.  This is currently zero.
    DWORD   cbWinMetaFile;      // Size of windows metafile data in bytes
                                // The windows metafile data follows here
} EMRGDICOMMENT_WINDOWS_METAFILE, *PEMRGDICOMMENT_WINDOWS_METAFILE;

// Public GdiComment for begin group.

typedef struct tagEMRGDICOMMENT_BEGINGROUP
{
    EMR     emr;
    DWORD   cbData;             // Size of following fields and all data
    DWORD   ident;              // GDICOMMENT_IDENTIFIER
    DWORD   iComment;           // GDICOMMENT_BEGINGROUP
    RECTL   rclOutput;          // Output rectangle in logical coords.
    DWORD   nDescription;       // Number of chars in the unicode description
                                // string that follows this field.  This is 0
                                // if there is no description string.
} EMRGDICOMMENT_BEGINGROUP, *PEMRGDICOMMENT_BEGINGROUP;

// Public GdiComment for end group.

typedef EMRGDICOMMENT_PUBLIC  EMRGDICOMMENT_ENDGROUP;
typedef PEMRGDICOMMENT_PUBLIC PEMRGDICOMMENT_ENDGROUP;

// Public GdiComment for multiple formats.

typedef struct tagEMRGDICOMMENT_MULTIFORMATS
{
    EMR     emr;
    DWORD   cbData;             // Size of following fields and all data
    DWORD   ident;              // GDICOMMENT_IDENTIFIER
    DWORD   iComment;           // GDICOMMENT_MULTIFORMATS
    RECTL   rclOutput;          // Output rectangle in logical coords.
    DWORD   nFormats;           // Number of formats contained in the record
    EMRFORMAT aemrformat[1];    // Array of EMRFORMAT structures in order of
                                // preference.  This is followed by the data
                                // for each format.
} EMRGDICOMMENT_MULTIFORMATS, *PEMRGDICOMMENT_MULTIFORMATS;

// iComment flags

#define GDICOMMENT_NOEMBED      0x80000000  // do not include comment in
                                            //   embedding
#define GDICOMMENT_ACCUMBOUNDS  0x40000000  // has logical rectangle bounds
                                            //   that follows the iComment field

// ExtEscape to output encapsulated PostScript file.

typedef struct tagEPSDATA
{
    DWORD    cbData;        // Size of the structure and EPS data in bytes.
    DWORD    nVersion;      // Language level, e.g. 1 for level 1 PostScript.
    POINT    aptl[3];       // Output parallelogram in 28.4 FIX device coords.
                            // This is followed by the EPS data.
} EPSDATA, *PEPSDATA;


/**************************************************************************\
 *
 *                <----------------------------------------------\
 *       hash                                                     \
 *                                                                 \
 *       +-----+                                                   |
 *      0| I16 |       metalink16                                  |
 *      1|     |                                                   |
 *      2|     |       +--------+        +--------+                |
 *      3|     |------>|idc/iobj|     /->|metalink|                |
 *      4|     |       |hobj    |    /   |hobj    |                |
 *      5|     |       |pmlNext |---/    |pmlNext |--/             |
 *       |     |       |16bit mf|        |16bit mf|                |
 *      .|     |       +--------+        +--------+                |
 *      .|     |         |                                         |
 *      .|     |         |                                         |
 *       |     |      /--/                                         |
 *    n-1|     |     /                                             |
 *       +-----+     |                                             |
 *                   |  LDC(idc)          MDC                      |
 *                   |                                             |
 *                   \->+--------+       +--------+    MHE[iobj]   |
 *                      |        |       |        |                |
 *                      |        |    /->|        |   +--------+   |
 *                      |        |   /   |        |   |hobj    |---/
 *                      |pmdc    |--/    |pmhe    |-->|idc/iobj|
 *                      +--------+       |        |   +--------+
 *                                       +--------+
 *
 *
 *
\**************************************************************************/

PMETALINK16 pmetalink16Resize(HANDLE h,int cObj);

#define pmetalink16Get(h)    ((PMETALINK16) plinkGet(h))
#define pmetalink16Create(h) ((PMETALINK16)plinkCreate(h,sizeof(METALINK16)))
#define bDeleteMetalink16(h) bDeleteLink(h)

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\client\metafile.cxx ===
/******************************Module*Header*******************************\
* Module Name: metafile.cxx
*
* Includes enhanced metafile API functions.
*
* Created: 17-July-1991 10:10:36
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#define NO_STRICT

extern "C" {
#if defined(_GDIPLUS_)
#include <gpprefix.h>
#endif

#include <string.h>
#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <windows.h>    // GDI function declarations.
#include <winspool.h>
#include "nlsconv.h"    // UNICODE helpers
#include "firewall.h"
#define __CPLUSPLUS
#include <winspool.h>
#include <w32gdip.h>
#include "ntgdistr.h"
#include "winddi.h"
#include "hmgshare.h"
#include "icm.h"
#include "local.h"      // Local object support.
#include "gdiicm.h"
#include "metadef.h"    // Metafile record type constants.
#include "metarec.h"
#include "mf16.h"
#include "ntgdi.h"
#include "glsup.h"
}

#include "rectl.hxx"
#include "mfdc.hxx"     // Metafile DC declarations.
#include "mfrec.hxx"    // Metafile record class declarations.

WORD   GetWordCheckSum(UINT cbData, PWORD pwData);
DWORD  GetDWordCheckSum(UINT cbData, PDWORD pdwData);
UINT   InternalGetEnhMetaFileDescription(HENHMETAFILE hemf, UINT cchBuffer, LPSTR lpDescription, BOOL bUnicode);

RECTL rclNull = { 0, 0, -1, -1 };
RECTL rclInfinity = {NEG_INFINITY,NEG_INFINITY,POS_INFINITY,POS_INFINITY};
extern XFORM xformIdentity;

typedef UINT (*LPFNCONVERT) (PVOID, PBYTE, UINT, PBYTE, INT, HDC, UINT) ;

extern "C" BOOL SetSizeDevice(HDC hdc, int cxVirtualDevice, int cyVirtualDevice);


/******************************Public*Routine******************************\
* HDC APIENTRY CreateEnhMetaFileA(
*         HDC hDCRef OPTIONAL,
*         LPSTR pszFilename OPTIONAL,
*         LPRECT lpRect OPTIONAL,
*         LPSTR lpDescription OPTIONAL);
*
* The CreateEnhMetaFile function creates an enhanced metafile device context.
*
* Client side stub.  Allocates a client side LDC as well.
*
* Note that it calls the server only after all client side stuff has
* succeeded, we don't want to ask the server to clean up.
*
* The LDC is actually a reference info DC for the metafile.  The pmdc
* in the handle table is a pointer to the metafile DC object.
*
* Parameter   Description
* lpFilename  Points to the filename for the metafile. If NULL, the metafile
*             will be memory based with no backing store.
*
* Return Value
* The return value identifies an enhanced metafile device context if the
* function is successful. Otherwise, it is zero.
*
* Note that it returns a HDC, not a HENHMETAFILE!
*
* History:
*  Wed Jul 17 10:10:36 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" HDC APIENTRY CreateEnhMetaFileA
(
HDC    hDCRef,
LPCSTR pszFilename,
CONST RECT *lpRect,
LPCSTR lpDescription
)
{
    UINT  cch;
    HDC   hdcRet;
    WCHAR awchFilename[MAX_PATH];
    PWCH  pwchFilename    = (PWCH) NULL;
    PWCH  pwchDescription = (PWCH) NULL;

    if (pszFilename != (LPSTR) NULL)
    {
        cch = strlen(pszFilename) + 1;

        if (cch > MAX_PATH)
        {
            ERROR_ASSERT(FALSE, "CreateEnhMetaFileA filename too long");
            GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
            return((HDC) 0);
        }
        vToUnicodeN(pwchFilename = awchFilename, MAX_PATH, pszFilename, cch);
    }

    if (lpDescription != (LPSTR) NULL)
    {
        // Compute the length of the description string including the NULL
        // characters.

        for (cch = 0;
             lpDescription[cch] != (CHAR) 0 || lpDescription[cch+1] != (CHAR) 0;
             cch++)
            ;                   // NULL expression
        cch += 2;

        pwchDescription = (PWCH) LocalAlloc(LMEM_FIXED, cch*sizeof(WCHAR));
        if (pwchDescription == (PWCH) NULL)
        {
            VERIFYGDI(FALSE, "CreateEnhMetaFileA out of memory\n");
            return((HDC) 0);
        }
        vToUnicodeN(pwchDescription, cch, lpDescription, cch);
    }

    hdcRet = CreateEnhMetaFileW(hDCRef, pwchFilename, lpRect, pwchDescription);

    if (pwchDescription)
    {
        if (LocalFree((HANDLE) pwchDescription))
        {
            ASSERTGDI(FALSE, "LocalFree failed");
        }
    }

    return(hdcRet);
}

extern "C" HDC APIENTRY CreateEnhMetaFileW
(
HDC      hDCRef,
LPCWSTR  pwszFilename,
CONST RECT *lpRect,
LPCWSTR  lpDescription
)
{
    HDC   hdcNew = NULL;
    PLDC  pldc   = NULL;
    PMDC  pmdc;

    PUTS("CreateEnhMetaFileW\n");

    // Get the server to create a DC.
    // If hDCRef is supplied then clone it for the reference DC.
    // Otherwise, use the display as the reference info DC for the metafile.

    hdcNew = NtGdiCreateMetafileDC(hDCRef);

    // now create the client version

    if (hdcNew)
    {
        // if this fails, it deletes hdcNew

        pldc = pldcCreate(hdcNew,LO_METADC);
    }

    // Handle errors.

    if (!pldc)
    {
        ERROR_ASSERT(FALSE, "CreateEnhMetaFileW failed");
        return((HDC) 0);
    }

    ASSERTGDI(LO_TYPE(hdcNew) == LO_ALTDC_TYPE,"CreateEnhMetafile - invalid type\n");

// Create the metafile DC object.

    if (!(pmdc = pmdcAllocMDC(hdcNew, pwszFilename, lpDescription, NULL)))
        goto CreateEnhMetaFileW_error;

    pldc->pvPMDC = (PVOID)pmdc;

// Add the Frame Rect if one was specified; if not it will be fixed up
// by CloseEnhMetaFile.

    if (lpRect)
    {
        if (((PERECTL) lpRect)->bEmpty())
        {
            ERROR_ASSERT(FALSE, "CreateEnhMetaFileW invalid frame rect");
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            goto CreateEnhMetaFileW_error;
        }
        else
            pmdc->mrmf.rclFrame = *(PRECTL) lpRect;
    }

// Enable bounds accumlation in the reference DC.

    (void) SetBoundsRectAlt(hdcNew, (LPRECT) NULL,
        (UINT) (DCB_WINDOWMGR | DCB_RESET | DCB_ENABLE));
// Return the result.

    ASSERTGDI(hdcNew != (HDC) NULL, "CreateEnhMetaFileW: bad HDC value");
    return(hdcNew);

// Cleanup for errors.

CreateEnhMetaFileW_error:

    if (pmdc)
    {
        pmdc->fl |= MDC_FATALERROR;
        vFreeMDC(pmdc);
        pldc->pvPMDC = NULL;
    }

    if (!InternalDeleteDC(hdcNew, LO_METADC))
    {
        ASSERTGDI(FALSE, "InternalDeleteDC failed");
    }

    ERROR_ASSERT(FALSE, "CreateEnhMetaFileW failed");
    return((HDC) 0);
}

/******************************Public*Routine******************************\
* AssociateEnhMetaFile()
*
*   Associate an EnhMetaFile with this DC.  This is similar to CreateEnhMetaFile
*   but in this case it just converts the dc.  UnassociateEnhMetaFile must be
*   used on this DC before it can be deleted.  CloseMetaFile can not be use.
*   This is currently only for use by spooled printing using enhanced metafiles.
*
*   This is called at start doc and after each EndPage to set up the next page.
*
* History:
*  19-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

extern "C" BOOL APIENTRY AssociateEnhMetaFile(
    HDC hdc)
{
    ULONG ulSrvDC;
    PMDC  pmdc;
    BOOL  bIcmOn = FALSE;

    PUTS("CreateEnhMetaFileW\n");

// Get the server to create a DC.
// If hDCRef is supplied then clone it for the reference DC.
// Otherwise, use the display as the reference info DC for the metafile.

    PLDC pldc;

    DC_PLDC(hdc,pldc,FALSE);

// Handle errors.

    EMFSpoolData *pEMFSpool = (EMFSpoolData *) pldc->hEMFSpool;

    if (pldc->iType == LO_METADC || pEMFSpool == NULL)
    {
        ERROR_ASSERT(FALSE, "CreateEnhMetaFileW failed");
        return(FALSE);
    }

// Create the metafile DC object.

    if (!(pmdc = pmdcAllocMDC(hdc, NULL, L"Print test\0", (HANDLE) pEMFSpool)))
    {
        ERROR_ASSERT(FALSE, "CreateEnhMetaFileW failed");
        return(FALSE);
    }

// Before, we switch this DC to Metafile DC, turn-off ICM.

    if (SetICMMode(hdc,ICM_QUERY) == ICM_ON)
    {
        SetICMMode(hdc,ICM_OFF);
        bIcmOn = TRUE;
    }

    MakeInfoDC(hdc,TRUE);

    ASSERTGDI(pldc->iType == LO_DC,"AssociateEnhMetaFile not LO_DC\n");

    pldc->pvPMDC  = (PVOID)pmdc;
    pldc->iType = LO_METADC;

    pmdc->mrmf.rclFrame.left   = 0;
    pmdc->mrmf.rclFrame.top    = 0;
    pmdc->mrmf.rclFrame.right  = GetDeviceCaps( hdc, HORZSIZE ) * 100;
    pmdc->mrmf.rclFrame.bottom = GetDeviceCaps( hdc, VERTSIZE ) * 100;

// Enable bounds accumlation in the reference DC.

    SetBoundsRectAlt(hdc, NULL,(UINT) (DCB_WINDOWMGR | DCB_RESET | DCB_ENABLE));

// if ICM is originally turned on, turn on it for LO_METADC.

    if (bIcmOn)
    {
        SetICMMode(hdc,ICM_ON);
    }

// Save state of the DC in the EnhMetaFile

    return (PutDCStateInMetafile( hdc ));
}


/******************************Public*Routine******************************\
* HENHMETAFILE CloseEnhMetaFile(hDC)
* HDC hDC;
*
* The CloseEnhMetaFile function closes the enhanced metafile device context
* and creates an enhanced metafile handle that can be used with other
* enhanced metafile calls.
*
* Parameter  Description
* hDC        Identifies the enhanced metafile device context to be closed.
*
* Return Value
* The return value identifies the enhanced metafile if the function is
* successful.  Otherwise, it is 0.
*
* History:
*  Wed Jul 17 10:10:36 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" HENHMETAFILE APIENTRY CloseEnhMetaFile(HDC hdc)
{
    PMDC            pmdc;
    HENHMETAFILE    hemf = NULL;
    PUTS("CloseEnhMetaFile\n");

// Validate the metafile DC handle.

    PLDC pldc;

    DC_PLDC(hdc,pldc,hemf);

// Handle errors.

    if (pldc->iType != LO_METADC)
        return(hemf);

// Cleanup temp brush or pen created for SetDCBrushColor and SetDCPenColor
    if (pldc->oldSetDCBrushColorBrush)
    {
        DeleteObject(pldc->oldSetDCBrushColorBrush);
        pldc->oldSetDCBrushColorBrush = 0;
    }
    if (pldc->oldSetDCPenColorPen)
    {
        DeleteObject(pldc->oldSetDCPenColorPen);
        pldc->oldSetDCPenColorPen = 0;
    }

    pmdc = (PMDC)pldc->pvPMDC;

    // If the metafile contains GL records, tell OpenGL that things are done
    if (pmdc->mrmf.bOpenGL)
    {
        if (!GlmfCloseMetaFile(hdc))
        {
            WARNING("GlmfCloseMetaFile failed\n");
        }
    }

// Check for fatal errors.

    if (pmdc->bFatalError())
        goto CloseEnhMetaFile_cleanup;

// Make sure that save and restore DCs are balanced.  Always restore back to 1.
// Don't need to check if it fails since not much we can do anyways.  Also,
// we would need to make an extra server call to see if it is already at 1.

    RestoreDC(hdc,1);

// Write out the EOF metafile record.  This would force the previous
// bounds record to be commited.  The EOF metafile record includes the
// metafile palette if logical palettes are used.

    pmdc->mrmf.nPalEntries = pmdc->iPalEntries;

    if (!MF_EOF(hdc,pmdc->iPalEntries,pmdc->pPalEntries))
        goto CloseEnhMetaFile_cleanup;

// Finally flush the bounds to the metafile header.  We cannot flush the
// bounds if we have not committed the previous bounds record yet.
// Therefore, we do this after the last EMREOF record.

    pmdc->vFlushBounds();

// If there was no initial metafile Frame defined in CreateEnhMetaFile then
// the Bounds converted to 0.01 mm will be the Frame.

    if (((PERECTL) &pmdc->mrmf.rclFrame)->bEmpty())
    {
        pmdc->mrmf.rclFrame.left   = MulDiv((int) (100 * pmdc->mrmf.rclBounds.left),
                                            (int) pmdc->mrmf.szlMillimeters.cx,
                                            (int) pmdc->mrmf.szlDevice.cx);
        pmdc->mrmf.rclFrame.right  = MulDiv((int) (100 * pmdc->mrmf.rclBounds.right),
                                            (int) pmdc->mrmf.szlMillimeters.cx,
                                            (int) pmdc->mrmf.szlDevice.cx);
        pmdc->mrmf.rclFrame.top    = MulDiv((int) (100 * pmdc->mrmf.rclBounds.top),
                                            (int) pmdc->mrmf.szlMillimeters.cy,
                                            (int) pmdc->mrmf.szlDevice.cy);
        pmdc->mrmf.rclFrame.bottom = MulDiv((int) (100 * pmdc->mrmf.rclBounds.bottom),
                                            (int) pmdc->mrmf.szlMillimeters.cy,
                                            (int) pmdc->mrmf.szlDevice.cy);
    }

// Flush the buffer and write out the latest header record.

    ASSERTGDI((ULONG) pmdc->mrmf.nHandles <= pmdc->cmhe,
        "CloseEnhMetaFile: Bad nHandles");

    if (pmdc->bIsDiskFile())
    {
        ULONG   nWritten ;

        // Flush the memory buffer.

        if (!pmdc->bFlush())
            goto CloseEnhMetaFile_cleanup;

        // Flush the header record.

        if (SetFilePointer(pmdc->hFile, 0L, (PLONG) NULL, FILE_BEGIN) != 0L)
            goto CloseEnhMetaFile_cleanup;

        if (!WriteFile(pmdc->hFile, &pmdc->mrmf, sizeof(ENHMETAHEADER),
                &nWritten, (LPOVERLAPPED) NULL)
         || nWritten != sizeof(ENHMETAHEADER))
            goto CloseEnhMetaFile_cleanup;

        // Close the file.

        if (!CloseHandle(pmdc->hFile))
        {
            ASSERTGDI(FALSE, "CloseHandle failed");
        }

        pmdc->hFile = INVALID_HANDLE_VALUE;
    }
    else
    {
        // Flush the header record.

        PENHMETAHEADER pmrmf = (PENHMETAHEADER) pmdc->GetPtr(0, sizeof(ENHMETAHEADER));

        if(pmrmf)
        {
            *pmrmf = pmdc->mrmf;

            pmdc->ReleasePtr(pmrmf);
        }
        else
        {
            WARNING("CloseEnhMetaFile() Failed to get ENHMETAHEADER pointer\n");
            goto CloseEnhMetaFile_cleanup;
        }

        // Realloc memory metafile to exact size

        if (!pmdc->ReallocMem(pmdc->iMem))
        {
            ASSERTGDI(FALSE, "ReallocMem failed");
        }
    }

// Fixup the checksum if we are embedding a Windows metafile.
// This is called by SetWinMetaFileBits only.

    if (pmdc->fl & MDC_CHECKSUM)
    {
        DWORD    nChecksum;
        PEMRGDICOMMENT_WINDOWS_METAFILE pemrWinMF;

        ASSERTGDI(!pmdc->bIsDiskFile(),
            "CloseEnhMetaFile: Expects only mem files for Checksum");

        PENHMETAHEADER pmrmf = (PENHMETAHEADER) pmdc->GetPtr(0, pmdc->iMem);

        if(pmrmf)
        {
            nChecksum = GetDWordCheckSum((UINT) pmdc->iMem, (PDWORD) pmrmf);

            pemrWinMF = (PEMRGDICOMMENT_WINDOWS_METAFILE) ((PBYTE) pmrmf + pmrmf->nSize);

            ASSERTGDI(((PMRGDICOMMENT) pemrWinMF)->bIsWindowsMetaFile(),
                "CloseEnhMetaFile: record should be comment");

            pemrWinMF->nChecksum = (DWORD) 0 - nChecksum;

            ASSERTGDI(!GetDWordCheckSum((UINT)pmdc->iMem, (PDWORD) pmrmf),
                "CloseEnhMetaFile Checksum failed");

            pmdc->ReleasePtr(pmrmf);
        }
        else
        {
            WARNING("CloseEnhMetaFile() Failed to get metafile data pointer\n");
            goto CloseEnhMetaFile_cleanup;
        }
    }

// Allocate and initialize a MF.

    if (pmdc->bIsDiskFile())
    {
        hemf = GetEnhMetaFileW(pmdc->wszPathname);
    }
    else
    {
        if (pmdc->bIsEMFSpool())
        {
            // Just in case - we should never get here during EMF spooling

            WARNING("CloseEnhMetaFile: called during EMF spooling\n");

            hemf = pmdc->CompleteEMFData(TRUE);
        }
        else
        {
            PENHMETAHEADER pmrmf = (PENHMETAHEADER) pmdc->GetPtr(0, pmdc->iMem);
            
            if(pmrmf)
            {
                hemf = SetEnhMetaFileBitsAlt((HLOCAL) pmrmf, NULL, NULL, 0);

                pmdc->ReleasePtr(pmrmf);
            }
            else
            {
                WARNING("CloseEnhMetaFile: failed to get emf data\n");
                goto CloseEnhMetaFile_cleanup;
            }
        }

        if (hemf)
            pmdc->hData = NULL; // don't free it below because it has been transfered
    }

CloseEnhMetaFile_cleanup:

// Delete the disk metafile if we had an error.

    if (hemf == (HENHMETAFILE) 0)
        pmdc->fl |= MDC_FATALERROR;

// Delete the MDC and free objects and resources.

    vFreeMDC(pmdc);

// Delete the reference info DC last because we need the local handle in
// vFreeMDC.

    if (!InternalDeleteDC(hdc, LO_METADC))
    {
        ASSERTGDI(FALSE, "InternalDeleteDC failed");
    }

    ERROR_ASSERT(hemf != (HENHMETAFILE) 0, "CloseEnhMetaFile failed");
    return(hemf);
}

/******************************Public*Routine******************************\
* UnassociateEnhMetaFile()
*
*   This should only be called if AssociateEnhMetaFile() is first called on
* this DC.  This is similar to CloseEnhMetaFile in that it returns an
* enhanced metafile, but it does not delete the DC, it just converts it back
* to a direct DC.  This is currently intended only for use with enhanced
* metafile spooling.
*
* History:
*  20-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

extern "C" HENHMETAFILE UnassociateEnhMetaFile(HDC hdc, BOOL bKeepEMF)
{
    PMDC            pmdc;
    HENHMETAFILE    hemf = NULL;
    BOOL            bIcmOn = FALSE;
    PENHMETAHEADER  pmrmf = NULL;

    PUTS("UnassociateEnhMetaFile\n");

// Validate the metafile DC handle.

    PLDC pldc;

    DC_PLDC(hdc,pldc,hemf);

// Handle errors.

    if (pldc->iType != LO_METADC)
    {
    // We need to exit cleanly in this case because we could hit it, if at
    // end page time we suceed in unasociating a metafile but then fail before
    // we can reassociate a new metafile.

        WARNING("UnassociateEnhMetaFileW - not a metafile\n");
        return((HENHMETAFILE)0);
    }

// Cleanup temp brush or pen created for SetDCBrushColor and SetDCPenColor
    if (pldc->oldSetDCBrushColorBrush)
    {
        DeleteObject(pldc->oldSetDCBrushColorBrush);
        pldc->oldSetDCBrushColorBrush = 0;
    }
    if (pldc->oldSetDCPenColorPen)
    {
        DeleteObject(pldc->oldSetDCPenColorPen);
        pldc->oldSetDCPenColorPen = 0;
    }
    pmdc = (PMDC)pldc->pvPMDC;

    // if there is no pmdc, there was a failure during the recording.  Still
    // need to unassociate the meta file but don't want to do any of the other
    // cleanup.
    //

    if (pmdc == NULL || !pmdc->bIsEMFSpool())
    {
        WARNING("UnassociateEnhMetaFile: pmdc is NULL or no EMFSpoolData\n");

        MakeInfoDC(hdc,FALSE);
        return((HENHMETAFILE)0);
    }

    // If the metafile contains GL records, tell OpenGL that things are done
    if (pmdc->mrmf.bOpenGL)
    {
        if (!GlmfCloseMetaFile(hdc))
        {
            WARNING("GlmfCloseMetaFile failed\n");
        }
    }

// Before, we switch this back to original state, turn-off ICM.

    if (SetICMMode(hdc,ICM_QUERY) == ICM_ON)
    {
        SetICMMode(hdc,ICM_OFF);
        bIcmOn = TRUE;
    }

    MakeInfoDC(hdc,FALSE);

// Check for fatal errors.

    if (pmdc->bFatalError())
        goto UnassociateEnhMetaFile_cleanup;

// Write out the EOF metafile record.  This would force the previous
// bounds record to be commited.  The EOF metafile record includes the
// metafile palette if logical palettes are used.

    pmdc->mrmf.nPalEntries = pmdc->iPalEntries;

    if (!MF_EOF(hdc,pmdc->iPalEntries,pmdc->pPalEntries))
        goto UnassociateEnhMetaFile_cleanup;

// Finally flush the bounds to the metafile header.  We cannot flush the
// bounds if we have not committed the previous bounds record yet.
// Therefore, we do this after the last EMREOF record.

    pmdc->vFlushBounds();

// If there was no initial metafile Frame defined in CreateEnhMetaFile then
// the Bounds converted to 0.01 mm will be the Frame.

    if (((PERECTL) &pmdc->mrmf.rclFrame)->bEmpty())
    {
        pmdc->mrmf.rclFrame.left   = MulDiv((int) (100 * pmdc->mrmf.rclBounds.left),
                                            (int) pmdc->mrmf.szlMillimeters.cx,
                                            (int) pmdc->mrmf.szlDevice.cx);
        pmdc->mrmf.rclFrame.right  = MulDiv((int) (100 * pmdc->mrmf.rclBounds.right),
                                            (int) pmdc->mrmf.szlMillimeters.cx,
                                            (int) pmdc->mrmf.szlDevice.cx);
        pmdc->mrmf.rclFrame.top    = MulDiv((int) (100 * pmdc->mrmf.rclBounds.top),
                                            (int) pmdc->mrmf.szlMillimeters.cy,
                                            (int) pmdc->mrmf.szlDevice.cy);
        pmdc->mrmf.rclFrame.bottom = MulDiv((int) (100 * pmdc->mrmf.rclBounds.bottom),
                                            (int) pmdc->mrmf.szlMillimeters.cy,
                                            (int) pmdc->mrmf.szlDevice.cy);
    }

// Flush the buffer and write out the latest header record.

    ASSERTGDI((ULONG) pmdc->mrmf.nHandles <= pmdc->cmhe,
        "UnassociateEnhMetaFile: Bad nHandles");

    // Flush the header record.

    {
        pmrmf = (PENHMETAHEADER) pmdc->GetPtr(0, sizeof(ENHMETAHEADER));
    
        if(pmrmf)
        {
            *pmrmf = pmdc->mrmf;
    
            pmdc->ReleasePtr(pmrmf);
        }
        else
        {
            WARNING("UnassociateEnhMetaFile() failed to get ENHMETAHEADER\n");
            goto UnassociateEnhMetaFile_cleanup;
        }
    }


    // Realloc memory metafile to exact size

    if (!pmdc->ReallocMem(pmdc->iMem))
    {
        ASSERTGDI(FALSE, "ReallocMem failed");
    }

// Fixup the checksum if we are embedding a Windows metafile.
// This is called by SetWinMetaFileBits only.

    if (pmdc->fl & MDC_CHECKSUM)
    {
        DWORD    nChecksum;
        PEMRGDICOMMENT_WINDOWS_METAFILE pemrWinMF;

        ASSERTGDI(!pmdc->bIsDiskFile(),
            "UnassociateMetaFile: Expects only mem files for Checksum");

        pmrmf = (PENHMETAHEADER) pmdc->GetPtr(0, pmdc->iMem);

        if(pmrmf)
        {
            nChecksum = GetDWordCheckSum((UINT) pmdc->iMem, (PDWORD) pmrmf);

            pemrWinMF = (PEMRGDICOMMENT_WINDOWS_METAFILE) ((PBYTE) pmrmf + pmrmf->nSize);

            ASSERTGDI(((PMRGDICOMMENT) pemrWinMF)->bIsWindowsMetaFile(),
                "UnassociatePrintMetaFile: record should be comment");

            pemrWinMF->nChecksum = (DWORD) 0 - nChecksum;

            ASSERTGDI(!GetDWordCheckSum((UINT)pmdc->iMem, (PDWORD) pmrmf),
                "UnassociatePrintMetaFile Checksum failed");

            pmdc->ReleasePtr(pmrmf);
        }
        else
        {
            WARNING("UnassociateMetaFile() failed to get metafile data\n");
            goto UnassociateEnhMetaFile_cleanup;
        }
    }

// Allocate and initialize a MF.

    if (hemf = pmdc->CompleteEMFData(bKeepEMF))
        pmdc->hData = NULL; // don't free it below because it has been transfered

    ASSERTGDI(pldc->iType == LO_METADC,"UnassociateEnhMetaFile not LO_METADC\n");

UnassociateEnhMetaFile_cleanup:

    pldc->iType = LO_DC;

// Delete the disk metafile if we had an error.

    if (hemf == (HENHMETAFILE) 0)
        pmdc->fl |= MDC_FATALERROR;

// Delete the MDC and free objects and resources.

    vFreeMDC(pmdc);

    pldc->pvPMDC = NULL;

// if ICM is originally turned on, turn on it for LO_METADC.

    if (bIcmOn)
    {
        SetICMMode(hdc,ICM_ON);
    }

    return(hemf);
}

/******************************Public*Routine******************************\
* HENHMETAFILE CopyEnhMetaFile(hSrcMetaFile, lpFilename)
* HENHMETAFILE hSrcMetaFile;
* LPSTR lpFilename;
*
* The CopyEnhMetaFile function copies the source metafile. If lpFilename is a
* valid filename, the source is copies to a disk metafile. If lpFilename is
* NULL, the source is copied to a memory metafile.
*
* Parameter     Description
* hSrcMetaFile  Identifies the source metafile.
* lpFilename    Points to a filename of the file that is to receive the
*               metafile. If NULL the source is copied to a memory metafile.
*
* Return Value
* The return value identifies the new enhanced metafile. Zero is returned if
* an error occurred.
*
* History:
*  Tue Sep 03 11:21:14 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" HENHMETAFILE APIENTRY CopyEnhMetaFileA(HENHMETAFILE hemf, LPCSTR psz)
{
    UINT  cch;
    WCHAR awch[MAX_PATH];

    if (psz != (LPSTR) NULL)
    {
        cch = strlen(psz) + 1;

        if (cch > MAX_PATH)
        {
            ERROR_ASSERT(FALSE, "CopyEnhMetaFileA filename too long");
            GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
            return((HENHMETAFILE)0);
        }
        vToUnicodeN(awch, MAX_PATH, psz, cch);

        return(CopyEnhMetaFileW(hemf, awch));
    }
    else
        return(CopyEnhMetaFileW(hemf, (LPWSTR) NULL));
}

extern "C" HENHMETAFILE APIENTRY CopyEnhMetaFileW(HENHMETAFILE hemf, LPCWSTR pwsz)
{
    PMF             pmf;
    HENHMETAFILE    hmf = NULL;

    PUTS("CopyEnhMetaFileW\n");

// Validate the metafile handle.

    if (!(pmf = GET_PMF(hemf)))
        return(hmf);

    PENHMETAHEADER pmrmf = pmf->emfc.GetEMFHeader();

    if(!pmrmf)
    {
        WARNING("CopyEnhMetaFile: unable to get header info\n");
        return(hmf);
    }

    PBYTE pb = (PBYTE) pmf->emfc.ObtainPtr(0, pmrmf->nBytes);

    if(!pb)
    {
        WARNING("CopyEnhMetaFile: unable to get header info\n");
        return(hmf);
    }

    if (pwsz)
    {
        HANDLE hFile    = INVALID_HANDLE_VALUE;
        HANDLE hFileMap = NULL;
        HANDLE hMem     = NULL;

        // It's a disk metafile.
        // Create the disk file.

        if ((hFile = CreateFileW(pwsz,                  // Filename
                                GENERIC_WRITE|GENERIC_READ,   // Write access
                                0L,                     // Non-shared
                                (LPSECURITY_ATTRIBUTES) NULL, // No security
                                CREATE_ALWAYS,          // Always create
                                FILE_ATTRIBUTE_NORMAL,  // normal attributes
                                (HANDLE) 0))            // no template file
            == INVALID_HANDLE_VALUE)
        {
            ERROR_ASSERT(FALSE, "CopyEnhMetaFile: CreateFile failed");
            goto CopyEnhMetaFile_file_cleanup;
        }

        // Map the disk file.

        if (!(hFileMap = CreateFileMappingW(hFile,
                                           (LPSECURITY_ATTRIBUTES) NULL,
                                           PAGE_READWRITE,
                                           0L,
                                           pmrmf->nBytes,
                                           (LPWSTR) NULL)))
        {
            ERROR_ASSERT(FALSE, "CopyEnhMetaFile: CreateFileMapping failed");
            goto CopyEnhMetaFile_file_cleanup;
        }

        if (!(hMem = MapViewOfFile(hFileMap, FILE_MAP_WRITE, 0, 0, 0)))
        {
            ERROR_ASSERT(FALSE, "CopyEnhMetaFile: MapViewOfFile failed");
            goto CopyEnhMetaFile_file_cleanup;
        }

        // Copy the bits.

        RtlCopyMemory((PBYTE) hMem, pb, pmrmf->nBytes);

CopyEnhMetaFile_file_cleanup:

        if (hMem)
        {
            if (!UnmapViewOfFile(hMem))
            {
                ASSERTGDI(FALSE, "UmmapViewOfFile failed");
            }
        }

        if (hFileMap)
        {
            if (!CloseHandle(hFileMap))
            {
                ASSERTGDI(FALSE, "CloseHandle failed");
            }
        }

        if (hFile != INVALID_HANDLE_VALUE)
        {
            if (!CloseHandle(hFile))
            {
                ASSERTGDI(FALSE, "CloseHandle failed");
            }
        }

// Return a hemf if success.

        hmf = (hMem ? GetEnhMetaFileW(pwsz) : (HENHMETAFILE) 0);
    }
    else
    {
        // It's a memory metafile.
        // This is identical to SetEnhMetaFileBits.

        hmf = SetEnhMetaFileBits((UINT)pmrmf->nBytes, pb);
    }

    if(pb)
        pmf->emfc.ReleasePtr(pb);

    return(hmf);
}

/******************************Public*Routine******************************\
* BOOL DeleteEnhMetaFile(hEMF)
* HENHMETAFILE hEMF;
*
* The DeleteEnhMetaFile function invalidates the given metafile handle. If hemf
* refered to a memory metafile, the metafile contents are lost. If hemf refered
* to a disk-based metafile, the metafile contents are retained and access to
* the metafile can be reestablished by retrieving a new handle using the
* GetEnhMetaFile function.
*
* Parameter  Description
* hemf        Identifies the enhanced metafile.
*
* Return Value
* The return value is TRUE if the handle has been invalidated. Otherwise it is
* FALSE.
*
* History:
*  Tue Sep 03 11:21:14 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" BOOL APIENTRY DeleteEnhMetaFile(HENHMETAFILE hemf)
{
    PMF    pmf;

    PUTS("DeleteEnhMetaFile\n");

// Validate the metafile handle.

    if (!(pmf = GET_PMF(hemf)))
        return(FALSE);

// Free the metafile and its handle.

    vFreeMF(pmf);
    return(bDeleteHmf(hemf));
}

BOOL InternalDeleteEnhMetaFile(HENHMETAFILE hemf, BOOL bAllocBuffer)
/*++
Function Description: This is an internal definition of DeleteEnhMetaFile which is
                      used in the printing playback code (object.c). The flag bAllocBuffer
                      if used to indicate if the buffer associated with hemf needs to be
                      freed. This is used while passing read only memory mapped buffers to
                      SetEnhMetaFileBitsAlt.

Parameters:    hemf         --   emf handle to be deleted
               bAllocBuffer --   flag to releasing hemf buffers.

Return Values:  TRUE if successful;
                FALSE otherwise
--*/
{
   PMF    pmf;

   PUTS("DeleteEnhMetaFile\n");

// Validate the metafile handle.

   if (!(pmf = GET_PMF(hemf)))
       return(FALSE);

// Free the metafile and its handle.

   vFreeMFAlt(pmf, bAllocBuffer);
   return(bDeleteHmf(hemf));

}

/******************************Public*Routine******************************\
* HENHMETAFILE GetEnhMetaFile(lpFilename)
* LPSTR lpFilename;
*
* The GetEnhMetaFile function creates a handle for the enhanced metafile
* named by the lpFilename parameter.
*
* Parameter   Description
* lpFilename  Points to the null-terminated character filename that specifies
*             the enhanced metafile. The metafile must already exist.
*
* Return Value
* The return value identifies an enhanced metafile if the function is
* successful.  Otherwise, it is 0.
*
* History:
*  Tue Sep 03 11:21:14 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" HENHMETAFILE  APIENTRY GetEnhMetaFileA(LPCSTR psz)
{
    UINT  cch;
    WCHAR awch[MAX_PATH];

    cch = strlen(psz) + 1;

    if (cch > MAX_PATH)
    {
        ERROR_ASSERT(FALSE, "GetEnhMetaFileA filename too long");
        GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
        return ((HENHMETAFILE)0);
    }

    vToUnicodeN(awch, MAX_PATH, psz, cch);

    return(GetEnhMetaFileW(awch));
}

extern "C" HENHMETAFILE  APIENTRY GetEnhMetaFileW(LPCWSTR pwsz)
{
    PMF     pmf;
    HENHMETAFILE hmf;

    PUTS("GetEnhMetaFileW\n");

// Allocate and initialize a MF.

    if (!(pmf = pmfAllocMF(0, (PDWORD) NULL, pwsz, NULL, 0, 0)))
        return((HENHMETAFILE) 0);

// Allocate a local handle.

    hmf = hmfCreate(pmf);
    if (hmf == NULL)
    {
        vFreeMF(pmf);
    }

// Return the metafile handle.

    return(hmf);
}

/******************************Public*Routine******************************\
* BOOL PlayEnhMetaFile(hDC, hEMF, lpRect)
* HDC hDC;
* HENHMETAFILE hEMF;
* LPRECT lpRect;
*
* The PlayEnhMetaFile function plays the contents of the specified metafile to
* the given device context. The metafile can be played any number of times.
*
* Parameter  Description
* hDC        Identifies the device context of the output device.
* hEMF       Identifies the metafile.
*
* Return Value
* The return value is TRUE if the function is successful. Otherwise, it is
* FALSE.
*
* History:
*  Tue Sep 03 11:21:14 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" BOOL APIENTRY PlayEnhMetaFile(HDC hdc, HENHMETAFILE hemf, CONST RECT *lpRect)
{
    PUTS("PlayEnhMetaFile\n");

// Make sure that hdc is given.  bInternalPlayEMF expects it to be given
// in PlayEnhMetaFile.

    if (hdc == (HDC) 0)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }


    return(bInternalPlayEMF(hdc, hemf, (ENHMFENUMPROC) NULL, (LPVOID) NULL, (PRECTL) lpRect));
}

/******************************Public*Routine******************************\
* BOOL EnumEnhMetaFile(hDC, hemf, lpMetaFunc, lpData, lpRect)
* HDC hDC;
* HENHMETAFILE hemf;
* ENHMFENUMPROC lpMetaFunc;
* LPVOID lpData;
* LPRECT lpRect;
*
* The EnumEnhMetaFile function enumerates the GDI calls within the metafile
* identified by the hemf parameter. The EnumEnhMetaFile function retrieves each
* GDI call within the metafile and passes it to the function pointed to by the
* lpMetaFunc parameter. This callback function, an application-supplied
* function, can process each GDI call as desired. Enumeration continues until
* there are no more GDI calls or the callback function returns FALSE.
*
* Parameter   Description
* hDC         Identifies the device context to be passed to MetaFunc.
* hemf        Identifies the metafile.
* lpMetaFunc  Is the address of the callback function. See the following
*             Comments section for details.
* lpData      Points to the callback-function data.
* lpRect      Points to a %RECT% structure the contains the coordinates of the
*             upper-left and lower-right corners of the bounding rectangle for
*             the output area in logical units.  Points on the edges are
*             included in the output area.  If <hdc> is 0, this is ignored.
*
* Return Value
* The return value is TRUE if the callback function enumerates all the GDI
* calls in a metafile. Otherwise, it returns FALSE.
*
* Comments
* The callback function must be declared as an APIENTRY, so that the correct
* calling conventions will be used.
*
* Callback Function
* BOOL APIENTRY MetaFunc(hDC, lpHTable, lpMFR, nObj, lpData)
* HDC hDC;
* LPHANDLETABLE lpHTable;
* LPENHMETARECORD lpMFR;
* LONG nObj;
* LPVOID lpData;
*
* This function may have any name, MetaFunc is just an example.
*
* Parameter  Description
* hDC        Identifies the device context that was passed to EnumEnhMetaFile.
* lpHTable   Points to a table of handles associated with the objects (pens,
*            brushes, and so on) in the metafile.
* lpMFR      Points to a metafile record contained in the metafile.
* nObj       Specifies the number of objects with associated handles in the
*            handle table.
* lpData     Points to the application-supplied data.
*
* Return Value
* The function can carry out any desired task. It must return TRUE to continue
* enumeration, or FALSE to stop it.
*
* History:
*  Tue Sep 03 11:21:14 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" BOOL APIENTRY EnumEnhMetaFile(HDC hdc, HENHMETAFILE hemf, ENHMFENUMPROC pfn, LPVOID pv, CONST RECT *lpRect)
{
    PUTS("EnumEnhMetaFile\n");

// Make sure that the callback function is given.  bInternalPlayEMF expects
// it to be given in EnumEnhMetaFile.

    if (pfn == (ENHMFENUMPROC) NULL)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    return(bInternalPlayEMF(hdc, hemf, pfn, pv, (PRECTL) lpRect));
}


BOOL bInternalPlayEMF(HDC hdc, HENHMETAFILE hemf, ENHMFENUMPROC pfn, LPVOID pv, CONST RECTL *prcl)
{
    BOOL            bRet = FALSE;
    BOOL            bBailout = TRUE;
    PMF             pmf;
    ULONG           ii, iPos;
    PDC_ATTR        pDcAttr;
    FLONG           flPlayMetaFile;
    PLDC            pldc = (PLDC) NULL;
    PVOID           pvUser;
    DWORD           dwLayout = GDI_ERROR;
    PENHMETARECORD  pemr = NULL;

    //
    // validate hdc, get user mode dc attr pointer
    //

    PSHARED_GET_VALIDATE(pvUser,hdc,DC_TYPE);
    pDcAttr = (PDC_ATTR)pvUser;

    BOOL   bGlmf = FALSE;
    BOOL   bInGlsBlock = FALSE;

    PUTS("bInternalPlayEMF\n");

// Validate the metafile handle.

    if (!(pmf = GET_PMF(hemf)))
        return(bRet);

    PENHMETAHEADER pmrmf = pmf->emfc.GetEMFHeader();

    if(!pmrmf)
    {
        WARNING("bInternalPlayEMF: unable to get header info\n");
        return(FALSE);
    }

// Store hemf in the handle table.

    pmf->pht->objectHandle[0] = hemf;

// Initialize metafile save level to 1.

    pmf->cLevel = 1;

// Initialize the public comment indicator to FALSE.
// This is set by MRMETAFILE::bPlay and cleared by MREOF::bPlay when embedding.

    pmf->bBeginGroup = FALSE;

// Initialize default clipping.

    pmf->erclClipBox = rclInfinity;

    // Load OpenGL if the metafile contains GL records

    DWORD headerSize  = pmrmf->nSize;

    if (pmrmf->offDescription)
    {
        if(!pmf->bValidBoundedSize(pmf,pmrmf->offDescription))
        {
            EMFVALFAIL(("bInternalPlayEMF: offDescription (%08x) validation failed\n", pmrmf->offDescription));
            return(FALSE);
        }

        if(pmrmf->nDescription * sizeof(WCHAR) < pmrmf->nDescription)
        {
            EMFVALFAIL(("bInternalPlayEMF: nDescription (%08x) * sizeof(WCHAR) arithmetic overflow\n", pmrmf->nDescription));
            return(FALSE);
        }

        if(!pmf->bValidBoundedSize(pmf,pmrmf->nDescription * sizeof(WCHAR)))
        {
            EMFVALFAIL(("bInternalPlayEMF: nDescription (%08x) * sizeof(WCHAR) validation failed\n", pmrmf->nDescription));
            return(FALSE);
        }

        headerSize -= pmrmf->nDescription * sizeof(WCHAR);
    }

    if (headerSize >= META_HDR_SIZE_VERSION_2)
    {
        if (pmrmf->offPixelFormat)
        {
            if (!pmf->bValidBoundedSize(pmf,pmrmf->offPixelFormat))
            {
                EMFVALFAIL(("bInternalPlayEMF: offPixelFormat (%08x) validation failed\n", pmrmf->offPixelFormat));
                return(FALSE);
            }
        }
    }

    if (headerSize >= META_HDR_SIZE_VERSION_2 &&
        pmrmf->bOpenGL &&
        !LoadOpenGL())
    {
        return FALSE;
    }

// If DC is not given in EnumEnhMetaFile, we will only enumerate the records.

    if (hdc != (HDC) 0)
    {
        // Make sure that the output rectangle is given.

        if (prcl == (PRECTL) NULL)
        {
            ERROR_ASSERT(FALSE, "bInternalPlayEMF: no output rectangle is given\n");

            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return(bRet);
        }

        // Save DC states before we play.

        if (!SaveDC(hdc))
            return(bRet);

        // find the LDC if we have one

        if (pDcAttr != NULL)
        {
            flPlayMetaFile = pDcAttr->ulDirty_ & DC_PLAYMETAFILE;
            if (flPlayMetaFile)
            {
                PUTS("CommonEnumMetaFile: DC_PLAYMETAFILE bit is set!\n");
            }
            pDcAttr->ulDirty_ |= DC_PLAYMETAFILE;
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }

        //
        // Turn of mirroring if any.
        //
        dwLayout = SetLayout(hdc, 0);

        // The metafile is to be played in the advanced graphics mode only.

        if (!SetGraphicsMode(hdc, GM_ADVANCED))
            goto bInternalPlayEMF_cleanup;

        // Combine the initial destination clipping region into the meta region
        // (hrgnMeta) and reset the destination clipping region before we play.
        // The meta region defines the clipping areas for the metafile picture
        // and is different from those defined in the metafile.
        // The clip region is reset to default in SetMetaRgn.

        if (SetMetaRgn(hdc) == RGN_ERROR)
            goto bInternalPlayEMF_cleanup;

        // Reset DC (without Restore).

        if (!bMetaResetDC(hdc))
            goto bInternalPlayEMF_cleanup;
        // if it use to be mirrored then change the Arc direction default.
        if ((dwLayout != GDI_ERROR) && (dwLayout & LAYOUT_RTL))
            SetArcDirection(hdc, AD_CLOCKWISE);

        // Transform setup.
        //
        // To display the metafile picture in the given output rectangle, we need
        // to scale the picture frame of the metafile to the output rectangle.
        //
        //        picture frame              output rectangle
        //
        //   (a,b)                        (e,f)
        //        +-------+                    +--------------+
        //        | ***** |                    |              |
        //        |   *   |                    |  **********  |
        //        |   *   |                    |      *       |
        //        |   *   |                    |      *       |
        //        +-------+                    |      *       |
        //                (c,d)                |      *       |
        //                                     |      *       |
        //                                     |      *       |
        //                                     |              |
        //                                     +--------------+
        //                                                     (g,h)
        //
        // The base playback transform (M) can be computed as follows:
        //
        //    M = S     . T       .S     . T     . W .P
        //         (m,n)   (-a,-b)  (u,v)   (e,f)   p  p
        //
        //    where
        //
        //      S        scales the metafile picture from source device units to
        //       (m,n)   the picture frame units (.01 mm).
        //
        //      T        translates the picture frame to the origin.
        //       (-a,-b)
        //
        //      S        scales the metafile picture extents to that of the logical
        //       (u,v)   output rectangle where
        //                   u = (g - e) / (c - a), and
        //                   v = (h - f) / (d - b).
        //
        //      T        translates the scaled picture to the logical output
        //       (e,f)   rectangle origin.
        //
        //      W .P     is the world and page transforms of the destination DC that
        //       p  p    determine the final placement and shape of the picture in
        //               in device space.  We assume the combined world and page
        //               transform is given by the XFORM {w x y z s t}.
        //
        // M can be reduced as follows:
        //
        //          [m  0  0]  [ 1  0  0]  [u  0  0]  [1  0  0]  [w  x  0]
        //      M = [0  n  0]. [ 0  1  0]. [0  v  0]. [0  1  0]. [y  z  0]
        //          [0  0  1]  [-a -b  1]  [0  0  1]  [e  f  1]  [s  t  1]
        //
        //          [muw                   mux                   0]
        //        = [nvy                   nvz                   0]
        //          [(-au+e)w+(-bv+f)y+s   (-au+e)x+(-bv+f)z+t   1]
        //

        FLOAT u, v, mu, nv, aue, bvf;
        XFORM xform;
        POINT ptOrg;

        // Verify that the picture frame is valid.

        if (pmrmf->rclFrame.right  < pmrmf->rclFrame.left
         || pmrmf->rclFrame.bottom < pmrmf->rclFrame.top)
        {
            ERROR_ASSERT(FALSE, "bInternalPlayEMF: Picture frame is null\n");
            GdiSetLastError(ERROR_INVALID_DATA);
            goto bInternalPlayEMF_cleanup;
        }

        if (headerSize >= META_HDR_SIZE_VERSION_2 &&
            pmrmf->bOpenGL)
        {
            PBYTE pb = (PBYTE) pmf->emfc.ObtainPtr(0, pmrmf->nBytes);

            if(pb)
            {
                // WINBUG 365038 4-10-2001 pravins Investigate GlmfInitPlayback usage
                // Do we have to send the whole metafile to opengl init?
                bGlmf = GlmfInitPlayback(hdc, (PENHMETAHEADER) pb, (LPRECTL)prcl);

                pmf->emfc.ReleasePtr(pb);

            }

            if(!bGlmf) goto bInternalPlayEMF_cleanup;

        }

        // prcl is incl-incl.

        if (pmrmf->rclFrame.right == pmrmf->rclFrame.left)
            u = (FLOAT) (prcl->right - prcl->left + 1);  // handle special case
        else
            u = (FLOAT) (prcl->right - prcl->left) /
                (FLOAT) (pmrmf->rclFrame.right - pmrmf->rclFrame.left);

        if (pmrmf->rclFrame.bottom == pmrmf->rclFrame.top)
            v = (FLOAT) (prcl->bottom - prcl->top + 1);  // handle special case
        else
            v = (FLOAT) (prcl->bottom - prcl->top) /
                (FLOAT) (pmrmf->rclFrame.bottom - pmrmf->rclFrame.top);

        mu  = (FLOAT) 100.0f * (FLOAT) pmrmf->szlMillimeters.cx /
              (FLOAT) pmrmf->szlDevice.cx * u;
        nv  = (FLOAT) 100.0f * (FLOAT) pmrmf->szlMillimeters.cy /
              (FLOAT) pmrmf->szlDevice.cy * v;

        aue = (FLOAT) prcl->left - (FLOAT) pmrmf->rclFrame.left * u;
        bvf = (FLOAT) prcl->top  - (FLOAT) pmrmf->rclFrame.top  * v;

        if (!GetTransform(hdc, XFORM_WORLD_TO_DEVICE, &xform))
            goto bInternalPlayEMF_cleanup;

        pmf->xformBase.eM11  = mu * xform.eM11;
        pmf->xformBase.eM12  = mu * xform.eM12;
        pmf->xformBase.eM21  = nv * xform.eM21;
        pmf->xformBase.eM22  = nv * xform.eM22;
        pmf->xformBase.eDx   = aue * xform.eM11 + bvf * xform.eM21 + xform.eDx;
        pmf->xformBase.eDy   = aue * xform.eM12 + bvf * xform.eM22 + xform.eDy;

        // Reset mapmode to MM_TEXT.

        if (GetMapMode(hdc) != MM_TEXT)
            if (!SetMapMode(hdc, MM_TEXT))
                goto bInternalPlayEMF_cleanup;

        // Reset window origin.

        if (!GetWindowOrgEx(hdc, &ptOrg))
            goto bInternalPlayEMF_cleanup;

        if (ptOrg.x != 0 || ptOrg.y != 0)
            if (!SetWindowOrgEx(hdc, 0, 0, (LPPOINT) NULL))
                goto bInternalPlayEMF_cleanup;

        // Reset viewport origin.

        if (!GetViewportOrgEx(hdc, &ptOrg))
            goto bInternalPlayEMF_cleanup;
        if (ptOrg.x != 0 || ptOrg.y != 0)
            if (!SetViewportOrgEx(hdc, 0, 0, (LPPOINT) NULL))
                goto bInternalPlayEMF_cleanup;

        // Finally, set the world transform.  Before we set it, check for
        // identity transform since rounding errors can distort the result.

        if (xform.eM12 == 0.0f && xform.eM21 == 0.0f
         && pmf->xformBase.eM12 == 0.0f   && pmf->xformBase.eM21 == 0.0f
         && pmf->xformBase.eM11 >= 0.999f && pmf->xformBase.eM11 <= 1.001f
         && pmf->xformBase.eM22 >= 0.999f && pmf->xformBase.eM22 <= 1.001f
           )
        {
            PUTS("bInternalPlayEMF: Base xform is identity\n");

            pmf->xformBase.eM11 = 1.0f;
            pmf->xformBase.eM22 = 1.0f;
        }

        if (!SetWorldTransform(hdc, &pmf->xformBase))
            goto bInternalPlayEMF_cleanup;

        // Now get the clip box for bound test in the source device units.
        // If the clip region is empty, we can skip playing the metafile.
        // Otherwise, we need to compensate for the tranform errors by
        // expanding the clip box.  We will perform clip test only if the
        // DC is a real DC and not a meta DC.

        if (!pldc || (LO_TYPE(hdc) == LO_DC_TYPE))
        {
            int complexity = GetClipBox(hdc, (LPRECT) &pmf->erclClipBox);

            pmf->erclClipBox.vOrder();

            switch (complexity)
            {
            case NULLREGION:
                bRet = TRUE;            // fall through.

            case RGN_ERROR:
                goto bInternalPlayEMF_cleanup;

            default:
                LONG ldx;               // delta to expand x
                LONG ldy;               // delta to expand y
                FLOAT eppmmDstX, eppmmDstY, eppmmSrcX, eppmmSrcY;
                                    // pixels per millimeter for src and dst devices

                // Initialize the clip box for bound test.

                eppmmDstX = (FLOAT) GetDeviceCaps(hdc, DESKTOPHORZRES) /
                            (FLOAT) GetDeviceCaps(hdc, HORZSIZE);
                eppmmDstY = (FLOAT) GetDeviceCaps(hdc, DESKTOPVERTRES) /
                            (FLOAT) GetDeviceCaps(hdc, VERTSIZE);
                eppmmSrcX = (FLOAT) pmrmf->szlDevice.cx /
                            (FLOAT) pmrmf->szlMillimeters.cx;
                eppmmSrcY = (FLOAT) pmrmf->szlDevice.cy /
                            (FLOAT) pmrmf->szlMillimeters.cy;

                ldx = eppmmDstX >= eppmmSrcX
                        ? 1
                        : (LONG) (eppmmSrcX / eppmmDstX) + 1;

                ldy = eppmmDstY >= eppmmSrcY
                        ? 1
                        : (LONG) (eppmmSrcY / eppmmDstY) + 1;

                pmf->erclClipBox.left   -= ldx;
                pmf->erclClipBox.right  += ldx;
                pmf->erclClipBox.top    -= ldy;
                pmf->erclClipBox.bottom += ldy;
                break;
            }
        }

        // Setup source resolution in the transform DC.

        if (!SetVirtualResolution(pmf->hdcXform,
                                  (int) pmrmf->szlDevice.cx,
                                  (int) pmrmf->szlDevice.cy,
                                  (int) pmrmf->szlMillimeters.cx,
                                  (int) pmrmf->szlMillimeters.cy))
            goto bInternalPlayEMF_cleanup;

        if (pmrmf->nSize >=
           META_HDR_SIZE_VERSION_3 + pmrmf->nDescription * sizeof(WCHAR))
        {
           if (pmrmf->szlMicrometers.cx && pmrmf->szlMicrometers.cy)
           {
              if (!SetSizeDevice(pmf->hdcXform,
                            (DWORD) pmrmf->szlMicrometers.cx,
                            (DWORD) pmrmf->szlMicrometers.cy))
              goto bInternalPlayEMF_cleanup;
           }
        }

        // Initialize the transform in the transform DC.
        // If we use ResetDC for initialization, we need to make sure that the
        // source resolution is not changed!

        if (!SetMapMode(pmf->hdcXform, MM_TEXT)
         || !ModifyWorldTransform(pmf->hdcXform, (LPXFORM) NULL, MWT_IDENTITY)
         || !SetWindowOrgEx(pmf->hdcXform, 0, 0, (LPPOINT) NULL)
         || !SetViewportOrgEx(pmf->hdcXform, 0, 0, (LPPOINT) NULL))
            goto bInternalPlayEMF_cleanup;

        //
        // Restore the layout back.
        //
        if (dwLayout != GDI_ERROR) {
            SetLayout(hdc, dwLayout);
            dwLayout = GDI_ERROR;
        }
    } // if (hdc != (HDC) 0)

// Assume success.

    bRet = TRUE;
    bBailout = FALSE;

    pldc = pldcGet(hdc);

    #if 0
    // EngQueryEMFInfo support junk ... we are dropping support for this entry point

    if (pldc && pldc->pUMPD && (pldc->pUMPD->dwFlags & UMPDFLAG_METAFILE_DRIVER))
    {
        if (pldc->pUMdhpdev)
        {
            ((UMDHPDEV *)(pldc->pUMdhpdev))->pvEMF = (PBYTE)pmf;
        }
    }
    #endif

// Play the records until we encounter the EMR_EOF record.
// We will do the EMR_EOF record after restoring unbalanced DC states.

    iPos = 0;
     
    while(1)
    {
        pemr = pmf->emfc.ObtainRecordPtr(iPos);

        if(!pemr)
        {
            WARNING("bInternalPlayEMF: unable to get emf record\n");
            bRet = FALSE;
            bBailout = TRUE;
            goto bInternalPlayEMF_cleanup;
        }

        if(!pmf->bValidBoundedSize(pemr,pemr->nSize) ||
            (pemr->nSize & 3) ||
            pemr->nSize > pmrmf->nBytes)
        {
            EMFVALFAIL(("bInternalPlayEMF: pemr->nSize > FileSize or EnhMetaHeader->nBytes or not a multiple of 4\n"));
            bRet = FALSE;
            bBailout = TRUE;
            goto bInternalPlayEMF_cleanup;
        }

        if(pemr->iType == EMR_EOF)
            break;

        if( (hdc != 0) && !(pDcAttr->ulDirty_ & DC_PLAYMETAFILE) )
        {
            WARNING("bInternalPlayEMF: CancelDC called\n");
            bRet = FALSE;
            bBailout = TRUE;
            goto bInternalPlayEMF_cleanup;
        }

        // If we're beginning or ending a block of GLS records then we
        // need to notify the OpenGL metafile support
        if (pemr->iType == EMR_GLSRECORD ||
            pemr->iType == EMR_GLSBOUNDEDRECORD)
        {
            if (!bInGlsBlock)
            {
                if (!GlmfBeginGlsBlock(hdc))
                {
                    WARNING("GlmfBeginGlsBlock failed\n");
                    bRet = FALSE;
                }

                bInGlsBlock = TRUE;
            }
        }
        else
        {
            if (bInGlsBlock)
            {
                if (!GlmfEndGlsBlock(hdc))
                {
                    WARNING("GlmfEndGlsBlock failed\n");
                    bRet = FALSE;
                }

                bInGlsBlock = FALSE;
            }
        }

        if (pfn == (ENHMFENUMPROC) NULL)
        {
            // PlayEnhMetaFile
            // If we encountered an error, we will continue playing but
            // return an error.

#if 0
// EngQueryEMFInfo junk
            if (pldc && pldc->pUMPD && (pldc->pUMPD->dwFlags & UMPDFLAG_METAFILE_DRIVER))
            {
                if (pldc->pUMdhpdev)
                {
                    ((UMDHPDEV *)(pldc->pUMdhpdev))->pvCurrentRecord = (PBYTE)pemr;
                }
            }
#endif

            if (!PlayEnhMetaFileRecord
                (
                    hdc,
                    (LPHANDLETABLE) pmf->pht,
                    pemr,
                    (UINT) pmrmf->nHandles
                )
               )
            {
                PUTSX("PlayEnhMetaFileRecord failed: pRecord: 0x%lX\n",
                    (PBYTE) pemr);
                ERROR_ASSERT(FALSE, "\n");
                bRet = FALSE;
            }
        }
        else
        {
            // EnumEnhMetaFile

            if (!(*pfn)
                (
                    hdc,
                    (LPHANDLETABLE) pmf->pht,
                    pemr,
                    (int) pmrmf->nHandles,
                    (LPARAM)pv
                )
               )
            {
                ERROR_ASSERT(FALSE, "EnumProc failed");
                bRet = FALSE;
                bBailout = TRUE;
                goto bInternalPlayEMF_cleanup;
            }
        }

        if ((pmf->fl & MF_FOUNDBAD))
        {
            bRet = FALSE;
            bBailout = TRUE;
            EMFVALFAIL(("bInternalPlayEMF: detected bad Meta records. Skipping all the subsequent records\n"));
            goto bInternalPlayEMF_cleanup;
        }

        // If the metafile is corrupt with a record of size 0, we would loop forever
        // negitive or zero size will be treated as an error

        if (pemr->nSize > 0)
        {
            iPos += pemr->nSize;
        }
        else
        {
            WARNING("bInternalPlayEMF failed on a record with zero/negitive size\n");
            bRet = FALSE;
            bBailout = TRUE;
            goto bInternalPlayEMF_cleanup;
        }

        if (iPos >= pmrmf->nBytes)
        {
            VERIFYGDI(FALSE, "bInternalPlayEMF: No EOF found\n");
            bRet = FALSE;
            bBailout = TRUE;
            goto bInternalPlayEMF_cleanup;
        }

        pmf->emfc.ReleaseRecordPtr(pemr);

    }

    // Cleanup and return.

bInternalPlayEMF_cleanup:

    //
    // Restore the layout back.
    //
    if (dwLayout != GDI_ERROR) {
        SetLayout(hdc, dwLayout);
    }

    // Restore any remaining metafile saved states if necessary.

    if (pmf->cLevel > 1)
    {
        EMRRESTOREDC emrrdc;

        WARNING("bInternalPlayEMF: fixing up unbalanced Save/Restore DCs\n");

        emrrdc.emr.iType = EMR_RESTOREDC;
        emrrdc.emr.nSize = sizeof(EMRRESTOREDC);
        emrrdc.iRelative = 1 - pmf->cLevel;

        // If the app bails out, we still need to restore our states.

            if (pfn == (ENHMFENUMPROC) NULL || bBailout)
        {
                if (!PlayEnhMetaFileRecord(hdc, (LPHANDLETABLE) pmf->pht,
            (CONST ENHMETARECORD *) &emrrdc, (UINT) pmrmf->nHandles))
            bRet = FALSE;
        }
            else
        {
                if (!(*pfn)(hdc, (LPHANDLETABLE) pmf->pht,
            (CONST ENHMETARECORD *) &emrrdc, (int) pmrmf->nHandles,
            (LPARAM)pv))
            bRet = FALSE;
        }
    }

    // Play the EMR_EOF record if the app did not bail out.
    // We play it here to better identify the end of the picture.

    if (!bBailout)
    {
        ASSERTGDI(pemr->iType == EMR_EOF, "bInternalPlayEMF: Bad EMR_EOF record");

        if (pfn != (ENHMFENUMPROC) NULL)
        {
            if (!(*pfn)(hdc, (LPHANDLETABLE) pmf->pht,
                (CONST ENHMETARECORD *) pemr,
                (int) pmrmf->nHandles, (LPARAM)pv))
            {
                bRet = FALSE;
            }
        }

        if (pfn == (ENHMFENUMPROC) NULL || pmf->bBeginGroup)
        {
            // If the enum callback function did not call us on EMR_EOF but
            // called us on EMR_HEADER, we will emit the comment record anyway.

            VERIFYGDI(pfn == (ENHMFENUMPROC) NULL,
            "bInternalPlayEMF: fixing up public group comments\n");

            if (!PlayEnhMetaFileRecord(hdc, (LPHANDLETABLE) pmf->pht,
                (CONST ENHMETARECORD *) pemr, (UINT) pmrmf->nHandles))
            {
                bRet = FALSE;
            }
        }
    }

    // Clean up GL state
    if (bGlmf &&
        !GlmfEndPlayback(hdc))
    {
        ASSERTGDI(FALSE, "GlmfEndPlayback failed");
    }

    // Restore DC states.

    if (hdc != (HDC) 0)
    {
        if (!RestoreDC(hdc, -1))
        {
            ERROR_ASSERT(FALSE, "RestoreDC failed");
        }

        // If PlayEnhMetaFile is called as a result of playback of the multi formats
        // public comment, we have to preserve the DC_PLAYMETAFILE bit.
        // If we hit a CancelDC, then we want to let the caller know.

        ASSERTGDI(!(flPlayMetaFile & ~DC_PLAYMETAFILE),
                  "bInternalPlayEMF: bad flPlayMetaFile\n");

        pDcAttr->ulDirty_ &= ~DC_PLAYMETAFILE;
        pDcAttr->ulDirty_ |= flPlayMetaFile;

    }


    // Delete the objects created by play.  The previous restore would have
    // deselected these objects.  The first entry contain the hemf handle.

    for (ii = 1; ii < (ULONG) pmrmf->nHandles; ii++)
        if (pmf->pht->objectHandle[ii])
        {
            PUTS("Deleting an object in bInternalPlayEMF\n");

            if (!DeleteObject(pmf->pht->objectHandle[ii]))
            {
                VERIFYGDI(FALSE, "bInternalPlayEMF: DeleteObject failed\n");
            }

            pmf->pht->objectHandle[ii] = 0;
        }

    if(pemr)
        pmf->emfc.ReleaseRecordPtr(pemr);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL PlayEnhMetaFileRecord(hDC, lpHandletable, lpEnhMetaRecord, nHandles)
* HDC hDC;
* LPHANDLETABLE lpHandletable;
* CONST ENHMETARECORD *lpMetaRecord;
* UINT nHandles;
*
* The PlayEnhMetaFileRecord function plays a metafile record by executing the GDI
* function call contained within the metafile record.
*
* Parameter      Description
* hDC            Identifies the device context.
* lpHandletable  Points to the object handle table to be used for the metafile
*                playback.
* lpMetaRecord   Points to the metafile record to be played.
* nHandles       Not used
*
* Return Value
* TRUE is returned for success, FALSE for failure.
*
* Comments
* An application typically uses this function in conjunction with the
* EnumEnhMetaFile function to modify and then play a metafile.
*
* The lpHandleTable, nHandles, and lpMetaRecord parameters must be exactly
* those passed to the MetaFunc procedure by EnumEnhMetaFile.
*
* History:
*  Tue Sep 03 11:21:14 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" BOOL APIENTRY PlayEnhMetaFileRecord
(
    HDC hdc,
    LPHANDLETABLE pht,
    CONST ENHMETARECORD *pmr,
    UINT cht
)
{
    PUTS("PlayEnhMetaFileRecord\n");

    if (pmr->iType >= EMR_MIN && pmr->iType <= EMR_MAX)
    {
        return
        (
            (((PMR) pmr)->*afnbMRPlay[((PENHMETARECORD)pmr)->iType - 1])
            (
                hdc,
                (PHANDLETABLE) pht,
                cht
            )
        );
    }

// Allow future metafile records to be embedded.
// Since it is impossible to know in advance the requirements for all new
// records, we will make the assumption that most records can be simply
// embedded with little or no modifications.  If a new record cannot be
// embedded by the following code, it should include a special bit in its
// record type and we will ignore it during embedding.  In this case,
// we assume that the record does not have side effects that distort the
// picture in a major way.  If an embeddable record contains a bounds,
// we need to transform the bounds to the new device coords.
// I estimate the following code to embed 80% of the new records correctly.
//
// NOTE: The future designer should take into account the compatibility
// issue when adding new record types.
//
// Note that although the code is here, it is not a requirement for
// the future metafiles if you think it is insane.  Just add EMR_NOEMBED
// to the metafile types and it will ignore the new records.
// For true compatibility support, see GdiComment for multiple formats.

    ERROR_ASSERT(FALSE, "PlayEnhMetaFileRecord: unknown record");

    if (pmr->iType & EMR_NOEMBED)
        return(TRUE);

// If we are not embedding, we are done with this record.

    PLDC pldc;

    DC_PLDC(hdc,pldc,FALSE);

    if (pldc->iType != LO_METADC)
        return(TRUE);

// Embed this new record