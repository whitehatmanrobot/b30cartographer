csinc (text)) {
        if (*text == ESCH && text[1] == ']')
            memmove(text, text + 1, 1 + _tcslen(text + 1));
        else if (*text == ']')
            break;
    }

    if (!*text)
        makeError(line, SYNTAX_MISSING_END_CHAR, ']');

    *text++ = '\0';                     // null byte over closing bracket
    return(pStart);
}


//  check_syntax_error()  - check if there is a syntax error in expr
//
//  arguments:  type  - type of the current token
//
//  actions:    checks the type of the current token against the type
//              of the previous token.
//
//  ERROR_TABLE :
//                  2nd tok
//
//              alpha     op    unary_op       (        )
//             ------------------------------------------------
//      alpha |   0   |   1   |    0      |     0   |   1     |
//            -------------------------------------------------
//        op  |   1   |   0   |    1      |     1   |   0     |
//            -------------------------------------------------
//   unary_op |   1   |   0   |    0      |     1   |   0     |
//            -------------------------------------------------
//      (     |   1   |   0   |    1      |     1   |   0     |
//            -------------------------------------------------
//        )   |   0   |   1   |    0      |     0   |   1     |
//            -------------------------------------------------
//   1st tok.
//
//    alpha : a primary ( integer, str, prog. invoc. )
//       op : a binary operator
// unary_op : a unary operator ( ~, !, - ). A  ZERO in the slot => error
//
// NOTE: ANY CHANGES TO THE TYPE VALUES WILL AFFECT THIS ROUTINE.

void
check_syntax_error(
    UCHAR newTok
    )
{
    extern UCHAR errTable[5][5];
    extern UCHAR errRow;
    UCHAR errCol;

    if (newTok == LEFT_PAREN)
        errCol = 3;
    else if (newTok == RIGHT_PAREN)
        errCol = 4;
    else if (newTok > LOGICAL_NOT)
        errCol = 0;
    else if (newTok > MULTIPLY)
        errCol = 2;
    else
        errCol = 1;

    if (!errTable[errRow][errCol])
        makeError(line, SYNTAX_INVALID_EXPR);
    errRow = errCol;            // this becomes the first token the next time
}


// type_and_val()
//
// arguments:  type - the type code of the present operator.
//             val  - ptr to a str/or integer
//
// initialises a record with the type code, after checking for any
// syntax errors. The new token is checked against the previous token
// for illegal combinations of tokens.
// initialises the record with the integer value/string ptr.

void
type_and_val(
    UCHAR type,
    INT_PTR val
    )
{
    extern RPNINFO tokRec;              // returned to handleExpr
    extern UCHAR prevTok;               // token last seen

    check_syntax_error(type);
    prevTok = type;
    tokRec.type = type;
    tokRec.valPtr = val;
}


// match()
//
// arguments:  tokPtr - ptr to a token string ( in tokTable )
//
// actions  :  looks for a substring in the expression buffer
//             pointed to by 'text', that matches the given token.
//             if substring found, returns TRUE, else returns FALSE.

UCHAR
match(
    char *tokPtr
    )
{
    extern char *text;
    char *t = text;

    while (*tokPtr && (*t == *tokPtr)) {
        t++;
        tokPtr++;
    }
    if (!*tokPtr) {
        text = t;
        return(TRUE);
    }
    return(FALSE);
}


// getTok()
//
// arguments: none
//
// gets a token from the expression buffer.
// if the current char from the buffer is a space/tab, skip space/tabs
//   until we get a non-space char ( could be NULL char ).
// Check if we are now at the beginning of one of the tokens in the
//   tokenTable. This covers most tokens.
// Check if we have a minus. If a minus and the previous token was an
//   integer, this is a binary minus, else a unary minus.
// If the current char is a double-quote, we are at the start of a
//     string-token.
// If the current char is a '[', we are at the start of a program
//   invocation. In both cases, the escape character is '\\'.
// If current char is a digit, we have a constant ( integer ).
// Else we have defined(ID).
// If none of the above, if current char is NULL, break out, else
//   report error ( illegal character string has been found ).
//
// If we came to the NULL char at the end of the buffer, set global
//    flag 'done' to TRUE, return a RIGHT_PAREN to match the opening
//    LEFT_PAREN.
//
//
// modifies:  text  : ptr to expression buffer.
//           prevTok: thru' calls to type_and_val().
//             done : at end of buffer
//           errRow : index into error table, thru calls to
//                    type_and_val()
// returns : token in tokRec(global, static to the module). The
//             token has the new type/integer/ptr values.

void
getTok()
{
    extern UCHAR prevTok;
    extern BOOL done;
    char c;
    TOKTABREC *p;
    char *ptr;
    long constant;

    c = *text;
    if (c == ' ' || c == '\t') {
        while(_istspace(c))
            c = *++text;                // skip white spaces
    }

    if (IS_OPERATORCHAR(c)) {
        for (p = tokTable; p->op_str && !match(p->op_str); p++)
            ;
    } else {
        // make p point to last entry in table
        p = &tokTable[(sizeof(tokTable) / sizeof(TOKTABREC)) - 1];
    }

    if (p->op_str) {
        type_and_val(p->op, 0);
    } else
    if (c == '-') {         // now check if binary or unary minus to be returned
        text++;
        if (prevTok == INTEGER)
            type_and_val(BINARY_MINUS, 0);
        else
            type_and_val(UNARY_MINUS, 0);
    } else
    if (c == '\"') {
        type_and_val(STR, (INT_PTR) GetEndQuote());
    } else
    if (c == '[') {
        type_and_val(PROG_INVOC_STR, (INT_PTR) GetEndBracket());
    } else {                            // integers and IDs handled here
        if (_istdigit(c)) {
            char *pNumber = text;

            errno = 0;                  // Accept decimal, octal or hex no (richgi)
            constant = strtol(text, &text, 0);
            if (errno == ERANGE) {
                *text = '\0';
                makeError(line, CONST_TOO_BIG, pNumber);
            }

            if (_totupper(*text) == 'L')
                text++;
            type_and_val(INTEGER, constant);
        } else {                        // defined(ID) comes here
            if (c) {
                if (!_tcsnicmp(text, "DEFINED", 7)) {
                    if (!(ptr = _tcschr(text, '(')))
                        makeError(line, SYNTAX_INVALID_EXPR);
                    ptr++;
                    text = ptr + _tcscspn(ptr, ")");
                    *text++ = '\0';
                    type_and_val(INTEGER, handleDefines(ptr));
                }
                else if (!_tcsnicmp(text, "EXIST", 5)) {
                    if (!(ptr = _tcschr(text, '(')))
                        makeError(line, SYNTAX_INVALID_EXPR);
                    ptr++;
                    text = ptr + _tcscspn(ptr, ")");
                    *text++ = '\0';
                    type_and_val(INTEGER, handleExists(ptr));
                }
                else
                    makeError(line, SYNTAX_INVALID_EXPR);
            } else {        // we are now at the end of the string (c is null)
                done = TRUE;
                type_and_val(RIGHT_PAREN, 0);  // this is the last token
            }
        }
    }
}


// chkInvocAndPush()  - check if program invocation required
//
// arguments:  pListPtr - might have a program invocation string
//                         present.
//
// actions  :  if this is a program invocation string, make the
//             program invocation.
//             the return value is got and placed on the stack.
//             the type of the new stack element is now INTEGER.
//             else place list item on stack.
//
//             in either case it moves one item from list to stack.

void
chkInvocAndPush(
    RPNINFO *pListPtr
    )
{
    ++pTop;
    if (pListPtr->type == PROG_INVOC_STR) {
        pTop->valPtr = execLine((char *) pListPtr->valPtr, FALSE, TRUE, FALSE, NULL);
        pTop->type = INTEGER;
    } else {
        *pTop = *pListPtr;
    }
}


// processList()
//
// arguments:  none
//
// actions :   remove an item from the list.
//             if the item is an operand, place it on the operand
//              stack (tempStack).
//             if the operand is a program invocation string, make
//              the invocation, place the return code on stack.
//             if the item is an operator, call the function to
//              do the operation on one/two elements on tempStack.
//
//             finally, check if there is exactly one item on stack.
//             if this item has a value of zero, return FALSE.
//             else return TRUE.
//             if more than one item on stack, abort with error.
//
// modifies:   pTop    - ptr to top of tempStack.
//             pList   - ptr to next position in list.

BOOL
processList()
{
    extern RPNINFO *pList;
    extern RPNINFO *pTop;
    RPNINFO *pTemp;
    BOOL (* func)(UCHAR);

    for (pTemp = rpnList; pTemp < pList; pTemp++) {
        if (pTemp->type > LOGICAL_NOT) {            // operand
            chkInvocAndPush(pTemp);
        } else {
            if (pTemp->type > MULTIPLY)
                func = do_unary_op;
            else
                func = do_binary_op;

            if (!(*func)(pTemp->type))
                makeError(line, BAD_OP_TYPES);
        }
    }

    if ((pTop == tempStack) && (pTop->type == INTEGER))
        if (!pTop->valPtr)
            return(FALSE);
        else
            return(TRUE);
    else
        makeError(line, SYNTAX_INVALID_EXPR);

    return(FALSE);
}


// pushIntoList()
//
// arguments:  none
//
// actions :   pops an item from the tempStack and pushes it onto
//             the list. checks list for overflow ( internal error )
//             and tempStack for underflow ( syntax error in expr ).
//
// modifies:   tempTop    - index of top of tempStack.
//             nextInList - index to next position in list.

void
pushIntoList()
{
    if (pTop < tempStack)
        makeError(line, SYNTAX_INVALID_EXPR);

    if (pList > pListEnd)
        makeError(line, EXPR_TOO_LONG_INTERNAL);

#if !defined(NDEBUG)
    // Keep track of the high water mark on the stack just for grins
    {
        static int  iStackMax = 0;
        if ( pList - rpnList > iStackMax )
            iStackMax = (int) (pList - rpnList);
    }
#endif

    *pList++ = *pTop--;
}


// handleExpr()
//
// arguments:  text - pointer to the buffer that has the expression.
//
// actions  :  calls getTok() to get tokens from the buffer. Places
//             tokens in a tempStack, and moves them into a list in
//             reverse-polish order.
//
//             We need the list so that ALL syntax errors are caught
//             BEFORE processing of the expression begins (especially
//             program invocations that have side effects)
//
//             Once the list is available, an operand stack is used
//             Items are popped and pushed from this stack by the
//             evaluation routines (add, mult, negate etc.)
//
//             we don't really need a separate operand stack. the
//             tempStack has served its purpose when the list is
//             formed and so it may be used for operand processing.

BOOL
handleExpr()
{
    extern RPNINFO tokRec;
    BOOL fRParen;                       // was the token got a right paren?
    extern BOOL done;
    extern RPNINFO *pTop, *pList;
    extern UCHAR errRow;
    extern UCHAR prevTok;

    pTop = tempStack;
    pList = rpnList;
    done = FALSE;
    errRow = 3;                     // row for the first token put in,left paren
    prevTok = LEFT_PAREN;
    type_and_val(LEFT_PAREN, 0);
    *pTop = tokRec;

    while (!done) {                 // while there are more tokens in buffer
        getTok();
        fRParen = FALSE;
        if (tokRec.type != LEFT_PAREN) {
            while (precVector[tokRec.type] <= precVector[pTop->type]) {
                if (!precVector[tokRec.type]) { // if RIGHT_PAREN pop till a
                                                // left paren is seen
                    while (pTop->type != LEFT_PAREN)
                        pushIntoList();
                    fRParen = TRUE;
                    if (pTop < tempStack) {
                        makeError(line, SYNTAX_INVALID_EXPR);
                    } else {
                        pTop--;                 // pop the left paren
                        break;
                    }
                } else {
                    pushIntoList();
                }
            }
        }
        // if token is a left paren, it has to go on the stack
        if (!fRParen) {
            if (pTop == pEnd)
                makeError(line, EXPR_TOO_LONG_INTERNAL);
            else
                *++pTop = tokRec;
        }
    }

    // check the stack here for not empty state
    if (pTop != tempStack - 1)
        makeError(line, SYNTAX_INVALID_EXPR);
    return(processList());
}


// handleDefines()
//
// arguments:  t   pointer to buffer that has the identifier
//
// actions:    Checks if one of 'ID' is present.
//             Aborts with error if more IDs present.
//             Is called for ifdef/ifndef/defined(ID).
//
// returns :   TRUE if ID found in table. FALSE otherwise.

BOOL
handleDefines(
    char *t
    )
{
    char *s;

    s = _tcstok(t, " \t");
    if (_tcstok(NULL, " \t")) {
        makeError(line, SYNTAX_UNEXPECTED_TOKEN, s);
    }

    if (!s) {
        makeError(line, MISSING_ARG_BEFORE_PAREN);
    }

    if (findMacro(s)) {
        return(TRUE);
    }

    return(FALSE);
}


// handleExists()
//
// arguments:  t   pointer to buffer that has the identifier
//
// actions:    Checks if 'name' is a valid file/directory
//             Aborts with error if more names present.
//             Is called for exist(name).
//
// returns :   TRUE if ID found in table. FALSE otherwise.

BOOL
handleExists(
    char *_t
    )
{
    char *s;
    char *szUnQuoted;
    BOOL fResult = FALSE;
    char *szDelim;
    char *t;

    // make local copy, strip blank space before and after string
    char *tSav = t = makeString(_t);
    while (*t && WHITESPACE (*t)) {
        t++;
    }
    s = t + _tcslen(t);
    while (s > t) {
        s = _tcsdec(t, s);
        if (s) {
            if (WHITESPACE (*s)) {
                *s = '\0';
            }
            else {
                break;
            }
        }
    }

    szDelim = ('\"' == *t) ? "\t" : " \t";
    // DS 15360: if id starts with a quote,
    // use "\t" instead of " \t" in _tcstok
    // (handle paths with embedded spaces)
    s = _tcstok(t, szDelim);
    if (_tcstok(NULL, szDelim)) {
        makeError(line, SYNTAX_UNEXPECTED_TOKEN, s);
    }

    if (NULL == s || NULL == (szUnQuoted = unQuote(s))) {   // handle quoted names
        makeError(line, MISSING_ARG_BEFORE_PAREN);
    }

    if (!_access(szUnQuoted, 0x00)) {                       // existence check
        fResult = TRUE;
    }

    FREE(szUnQuoted);
    FREE(tSav);

    return(fResult);
}


// evalExpr()
//
// arguments:    t    pointer to buffer that has the expression
//               kind specifies if it is if/ifdef/ifndef etc.
//
//
//
// returns :     TRUE if expression evaluates to true.
//               FALSE otherwise.

BOOL
evalExpr(
    char *t,
    UCHAR kind
    )
{
    if (!*t) {
        makeError(line, SYNTAX_MISSING_DIRECTIVE);
    }

    switch (kind) {
        case IFDEF_TYPE:
        case ELSE_IFDEF_TYPE:
            return(handleDefines(t));

        case IFNDEF_TYPE:
        case ELSE_IFNDEF_TYPE:
             return((BOOL)!handleDefines(t));

        default:
             text = t;
             return(handleExpr());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\rpn.h ===
// header file with all the necessary structures and tables for
// the expression evaluator.
//
//  Modifications:
//
//  15-Nov-1993 JdR Major speed improvements
//  26-Jul-1988 rj  Removed entry defining "^" as bitwise xor.  Left the
//                  BIT_XOR entries in to avoid bothering with rpn.c.
//                  Then realized it had to go in, so fixed it to handle
//                  IBM and Microsoft versions properly.

typedef struct rpn_info {
    UCHAR type;
    INT_PTR valPtr;   // value or ptr to string
}RPNINFO;

// The precedence vector is also indexed by the operator/operand type
// code to get the precedence for the operator/operand.
// The precedence is used to determine if an item is to stay on the
// temporary stack or is to be moved to the reverse-polish list.

static UCHAR precVector[] = {
    0,      // right paren ')'
    1,      // logical or
    2,      // logical and
    3,      // bit or
    4,      // bit xor
    5,      // bit and
    6,      // equals  '!='
    6,      // equals  '=='
    7,      // relation '>'
    7,      // relation '<'
    7,      // relation '>='
    7,      // relation '<='
    8,      // shift    '>>'
    8,      // shift    '<<'
    9,      // add      '-'
    9,      // add      '+'
    10,     // mult     '%'
    10,     // mult     '/'
    10,     // mult     '*'
    11,     // unary    '-'
    11,     // unary    '~'
    11,     // unary    '!'
    12,     // primary  int
    12,     // primary  str
    12,     // primary  str-sp
    0       // left paren '('
};


// these are the various type codes for the operator/operand tokens

#define RIGHT_PAREN     0
#define LOGICAL_OR      1
#define LOGICAL_AND     2
#define BIT_OR          3
#define BIT_XOR         4
#define BIT_AND         5
#define NOT_EQUAL       6
#define EQUAL           7
#define GREATER_THAN    8
#define LESS_THAN       9
#define GREATER_EQ     10
#define LESS_EQ        11
#define SHFT_RIGHT     12
#define SHFT_LEFT      13
#define BINARY_MINUS   14
#define ADD            15
#define MODULUS        16
#define DIVIDE         17
#define MULTIPLY       18
#define UNARY_MINUS    19
#define COMPLEMENT     20
#define LOGICAL_NOT    21
#define INTEGER        22
#define STR            23
#define PROG_INVOC_STR 24
#define LEFT_PAREN     25


// error table used by the getTok() routines to detect illegal token combinations.
// The table is explained with the routine check_syntax_error()

static UCHAR errTable[5][5] =  {
    { 0, 1, 0, 0, 1 },
    { 1, 0, 1, 1, 0 },
    { 1, 0, 0, 1, 0 },
    { 1, 0, 1, 1, 0 },
    { 0, 1, 0, 0, 1 }
};


// we save space by placing most of the tokens returned to the
// expr-eval parser in a table as shown below. At any time, the
// longest possible token is to be returned, hence the order of
// the strings is very important. eg: '||' is placed BEFORE '|'

typedef struct _tok_tab_rec {
    char *op_str;
    UCHAR op;
} TOKTABREC;

static TOKTABREC tokTable[] = {
    { "(",   LEFT_PAREN   },
    { ")",   RIGHT_PAREN  },
    { "*",   MULTIPLY     },
    { "/",   DIVIDE       },
    { "%",   MODULUS      },
    { "+",   ADD          },
    { "<<",  SHFT_LEFT    },
    { ">>",  SHFT_RIGHT   },
    { "<=",  LESS_EQ      },
    { ">=",  GREATER_EQ   },
    { "<",   LESS_THAN    },
    { ">",   GREATER_THAN },
    { "==",  EQUAL        },
    { "!=",  NOT_EQUAL    },
    { "&&",  LOGICAL_AND  },
    { "||",  LOGICAL_OR   },
    { "&",   BIT_AND      },
    { "|",   BIT_OR       },
    { "^^",  BIT_XOR      },
    { "~",   COMPLEMENT   },
    { "!",   LOGICAL_NOT  },
    { NULL,  0            }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\print.cpp ===
//  PRINT.C -- routines to display info for -p option
//
//  Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  Contains routines that print stuff for -p (and also -z, ifdef'ed)
//
// Revision History:
//  04-Feb-2000 BTF Ported to Win64
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  08-Jun-1992 SS  Port to DOSX32
//  16-May-1991 SB  Move printDate() here from build.c
//  02-Feb-1990 SB  change fopen() to FILEOPEN()
//  22-Nov-1989 SB  Changed free() to FREE()
//  07-Nov-1989 SB  When TMP ended in '\\' then don't add '\\' at end of path
//                  specification for PWB.SHL
//  19-Oct-1989 SB  added searchHandle parameter
//  18-Aug-1989 SB  added fclose() error check
//  05-Jul-1989 SB  Cleaned up -p output to look neater
//  19-Jun-1989 SB  Localized messages with -p option
//  24-Apr-1989 SB  added 1.2 filename support, FILEINFO replaced by void *
//  05-Apr-1989 SB  made all funcs NEAR; Reqd to make all function calls NEAR
//  10-Mar-1989 SB  printReverse() now prints to TMP:PWB.SHL instead of stdout
//   1-Dec-1988 SB  Added printReverseFile() to handle 'z' option
//  17-Aug-1988 RB  Clean up.

#include "precomp.h"
#pragma hdrstop

#include <time.h>
#include "nmtime.h"

// for formatting -p info
#define PAD1        40

size_t   checkLineLength(size_t i, char *s);
void     showDependents(STRINGLIST*, STRINGLIST*);

size_t
checkLineLength(
    size_t i,       // current length
    char *s         // string whose length is to be checked
    )
{
    if ((i += _tcslen(s)) > 40) {
        printf("\n\t\t\t");
        i = 0;
    }
    return(i);
}


void
printDate(
    unsigned spaces,        // spaces to print
    char *name,             // name of file whose date is to be printed
    time_t dateTime         // dateTime of file
    )
{
    if (dateTime == 0) {
        makeMessage(TARGET_DOESNT_EXIST, spaces, "", name);
    } else {
        char *s;

        s = ctime(&dateTime);
        s[24] = '\0';

        makeMessage(TIME_FORMAT, spaces, "", name, PAD1-spaces, s);
    }
}


void
showDependents(
    STRINGLIST *q,          // list of dependents
    STRINGLIST *macros      // macros in the dependents
    )
{
    char *u, *v;
    char *w;
    size_t i;
    struct _finddata_t finddata;
    NMHANDLE searchHandle;

    makeMessage(DEPENDENTS_MESSAGE);
    for (i = 0; q; q = q->next) {
        char *szFilename;

        if (_tcschr(q->text, '$')) {
            u = expandMacros(q->text, &macros);

            for (v = _tcstok(u, " \t"); v; v = _tcstok(NULL, " \t")) {
                if (_tcspbrk(v, "*?")) {
                    if (szFilename = findFirst(v, &finddata, &searchHandle)) {
                        do {
                            w = prependPath(v, szFilename);
                            printf("%s ", w);
                            i = checkLineLength(i, w);
                            FREE(w);
                        }
                        while (szFilename = findNext(&finddata, searchHandle));
                    }
                } else {
                    printf("%s ", v);
                    i = checkLineLength(i, v);
                }
            }

            FREE(u);
        } else if (_tcspbrk(q->text, "*?")) {
            if (szFilename = findFirst(q->text, &finddata, &searchHandle)) {
                do {
                    v = prependPath(q->text, szFilename);
                    printf("%s ", v);
                    i = checkLineLength(i, v);
                    FREE(v);
                }
                while (szFilename = findNext(&finddata, searchHandle));
            }
        } else {
            printf("%s ", q->text);
            i = checkLineLength(i, q->text);
        }
    }
}


void
showMacros(
    void
    )
{
    MACRODEF *p;
    STRINGLIST *q;
    int n = 0;

    makeMessage(MACROS_MESSAGE);

    for (n = 0; n < MAXMACRO; ++n) {
        for (p = macroTable[n]; p; p = p->next) {
            if (p->values && p->values->text) {
                makeMessage(MACRO_DEFINITION, p->name, p->values->text);
                for (q = p->values->next; q; q = q->next) {
                    if (q->text) {
                        printf("\t\t%s\n", q->text);
                    }
                }
            }
        }
    }

    putchar('\n');

    fflush(stdout);
}


void
showRules(
    void
    )
{
    RULELIST *p;
    STRINGLIST *q;
    unsigned n;

    makeMessage(INFERENCE_MESSAGE);

    for (p = rules, n = 1; p; p = p->next, ++n)  {
        printf(p->fBatch? "%s::" : "%s:", p->name);

        makeMessage(COMMANDS_MESSAGE);

        if (q = p->buildCommands) {
            printf("%s\n", q->text);

            while (q = q->next) {
                printf("\t\t\t%s\n", q->text);
            }
        }

        putchar('\n');
    }

    printf("%s: ", suffixes);

    for (q = dotSuffixList; q; q = q->next) {
        printf("%s ", q->text);
    }

    putchar('\n');

    fflush(stdout);
}


void
showTargets(
    void
    )
{
    unsigned bit, i;
    STRINGLIST *q;
    BUILDLIST  *s;
    BUILDBLOCK *r;
    MAKEOBJECT *t;
    unsigned n;
    LOCAL char *flagLetters = "dinsb";

    makeMessage(TARGETS_MESSAGE);
    for (n = 0; n < MAXTARGET; ++n) {
        for (t = targetTable[n]; t; t = t->next, putchar('\n')) {
            printf("%s:%c", t->name,
                   ON(t->buildList->buildBlock->flags, F2_DOUBLECOLON)
                       ? ':' : ' ');
            dollarStar = dollarAt = dollarDollarAt = t->name;
            for (s = t->buildList; s; s = s->next) {
                r = s->buildBlock;
                makeMessage(FLAGS_MESSAGE);
                for (i = 0, bit = F2_DISPLAY_FILE_DATES;
                     bit < F2_FORCE_BUILD;
                     ++i, bit <<= 1)
                     if (ON(r->flags, bit))
                        printf("-%c ", flagLetters[i]);
                showDependents(r->dependents, r->dependentMacros);
                makeMessage(COMMANDS_MESSAGE);
                if (q = r->buildCommands) {
                    if (q->text) printf("%s\n", q->text);
                    while (q = q->next)
                        if (q->text) printf("\t\t\t%s\n", q->text);
                }
                else putchar('\n');
            }
        }
    }
    dollarStar = dollarAt = dollarDollarAt = NULL;
    putchar('\n');
    fflush(stdout);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\proto.h ===
//  PROTO.H -- function prototypes
//
//  Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This include file contains global function prototypes for all modules.
//
// Revision History:
//  04-Feb-2000 BTF Ported to Win64
//  15-Nov-1993 JdR Major speed improvements
//  01-Jun-1993 HV  Change #ifdef KANJI to _MBCS
//  02-Feb-1990 SB  Add open_file() prototype
//  31-Jan-1990 SB  Debug version changes
//  08-Dec-1989 SB  Changed proto of SPRINTF()
//  04-Dec-1989 SB  Changed proto of expandFileNames() to void from void *
//  01-Dec-1989 SB  realloc_memory() added #ifdef DEBUG_MEMORY
//  22-Nov-1989 SB  free_memory() and mem_status() added #ifdef DEBUG_MEMORY
//  19-Oct-1989 SB  added param (searchHandle) to protos of file functions
//  02-Oct-1989 SB  setdrive() proto change
//  18-Aug-1989 SB  heapdump() gets two parameters
//  05-Jun-1989 SB  heapdump() prototype was added
//  22-May-1989 SB  added parameter to freeRules()
//  19-Apr-1989 SB  getFileName(), getDateTime(), putDateTime() added
//                  changed FILEINFO to void * in
//                  findFirst(), findNext(), searchPath(), findRule()
//  05-Apr-1989 SB  made all funcs NEAR; Reqd to make all function calls NEAR
//  22-Mar-1989 SB  rm unlinkTmpFiles(); add delScriptFiles()
//  09-Mar-1989 SB  Changed param from FILEINFO* to FILEINFO** for findRule
//  03-Feb-1989 SB  Changed () to (void) for prototypes
//  02-Feb-1989 SB  Moved freeUnusedRules() prototype from nmake.c to here and
//                  renamed as freeRules()
//  05-Dec-1988 SB  Added CDECL for functions with var params, ecs_strchr() and
//                  ecs_strrchr(); deleted proto for exit() - not reqd
//  23-Oct-1988 SB  Added putEnvStr()
//  07-Jul-1988 rj  Added targetFlag parameter to find and hash
//  06-Jul-1988 rj  Added ecs_system declaration
//  28-Jun-1988 rj  Added doCmd parameter to execLine
//  23-Jun-1988 rj  Added echoCmd parameter to execLine

void        displayBanner(void);
void __cdecl makeError(unsigned, unsigned, ...);
void __cdecl makeMessage(unsigned, ...);
UCHAR       getToken(unsigned, UCHAR);
int         skipWhiteSpace(UCHAR);
int         skipBackSlash(int, UCHAR);
void        parse(void);
void        appendItem(STRINGLIST **, STRINGLIST *);
void        prependItem(STRINGLIST **, STRINGLIST *);
STRINGLIST * removeFirstString(STRINGLIST **);
void      * allocate(size_t);
void      * alloc_stringlist(void);
void      * rallocate(size_t);
char      * makeString(const char *);
char	  * makeQuotedString(const char *);
char      * reallocString(char * pszTarget, const char *szAppend);
BOOL        tagOpen(char *, char *, char *);
void        parseCommandLine(unsigned, char **);
void        getRestOfLine(char **, size_t *);
BOOL        defineMacro(char *, char *, UCHAR);
STRINGLIST * find(char *, unsigned, STRINGLIST **, BOOL);
MACRODEF *  findMacro(char *);
void        insertMacro(STRINGLIST *);
unsigned    hash(char *, unsigned, BOOL);
void        prependList(STRINGLIST **, STRINGLIST **);
BOOL        findMacroValues(char *, STRINGLIST **, STRINGLIST **, char *, unsigned, unsigned, UCHAR);
BOOL        findMacroValuesInRule(RULELIST *, char *, STRINGLIST **);
char      * removeMacros(char *);
void        delScriptFiles(void);
char      * expandMacros(char *, STRINGLIST **);
STRINGLIST * expandWildCards(char *);
void        readCommandFile(char *);
void        setFlags(char, BOOL);
void        showTargets(void);
void        showRules(void);
void        showMacros(void);
char      * findFirst(char*, void *, NMHANDLE*);
char      * findNext(void *, NMHANDLE);

int         processTree(void);
void        expandFileNames(char *, STRINGLIST **, STRINGLIST **);
void        sortRules(void);
BOOL        isRule(char *);
char      * prependPath(const char *, const char *);
char      * searchPath(char *, char *, void *, NMHANDLE*);
BOOL        putMacro(char *, char *, UCHAR);
int         execLine(char *, BOOL, BOOL, BOOL, char **);
RULELIST  * findRule(char *, char *, char *, void *);
int         lgetc(void);
UCHAR       processIncludeFile(char *);
BOOL        evalExpr(char *, UCHAR);
int         doMake(unsigned, char **, char *);
void        freeList(STRINGLIST *);
void        freeStringList(STRINGLIST *);
#ifdef _MBCS
int         GetTxtChr(FILE*);
int         UngetTxtChr (int, FILE *);
#endif
int         putEnvStr(char *, char *);
#define PutEnv(x) _putenv(x)
void        expandExtmake(char *, char *, char*);
BOOL		ZFormat(char *, unsigned, char *, char *);
void        printReverseFile(void);
void        freeRules(RULELIST *, BOOL);
char      * getFileName(void *);
time_t      getDateTime(const _finddata_t *);
void        putDateTime(_finddata_t *, time_t);
char      * getCurDir(void);

void        free_memory(void *);
void        free_stringlist(STRINGLIST *);
void      * realloc_memory(void *, unsigned);

FILE      * open_file(char *, char *);
void        initMacroTable(MACRODEF *table[]);
void        TruncateString(char *, unsigned);
BOOL        IsValidMakefile(FILE *fp);
FILE      * OpenValidateMakefile(char *name,char *mode);

// from util.c
char      * unQuote(char*);
int         strcmpiquote(char *, char*);
char     ** copyEnviron(char **environ);
void        printStats(void);
void        curTime(time_t *);

// from charmap.c
void        initCharmap(void);

// from print.c
void        printDate(unsigned, char*, time_t);

// from build.c
int         invokeBuild(char*, UCHAR, time_t *, char *);
void        DumpList(STRINGLIST *pList);

// from exec.c
extern int  doCommands(char*, STRINGLIST*, STRINGLIST*, UCHAR, char *);
extern int  doCommandsEx(STRINGLIST*, STRINGLIST*, STRINGLIST*, UCHAR, char *);

// from rule.c
extern RULELIST * useRule(MAKEOBJECT*, char*, time_t,
              STRINGLIST**, STRINGLIST**, int*, time_t *,
              char **);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\rule.cpp ===
//  RULE.C -- routines that have to do with inference rules
//
// Copyright (c) 1988-1991, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  Routines that have to do with inference rules
//
// Revision History:
//  04-Feb-2000 BTF Ported to Win64
//  15-Nov-1993 JdR Major speed improvements
//  15-Oct-1993 HV Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  10-May-1993 HV Add include file mbstring.h
//                 Change the str* functions to STR*
//  16-May-1991 SB Created using routines from other modules

#include "precomp.h"
#pragma hdrstop

#define PUBLIC

extern char * QueryFileInfo(char *, void **);

BOOL   removeDuplicateRules(RULELIST*, RULELIST*);
char * skipPathList(char*);

//  findRule -- finds the implicit rule which can be used to build a target
//
// Scope:   Global
//
// Purpose:
//  Given a target findRule() finds if an implicit rule exists to create this
//  target. It does this by scanning the extensions in the list of rules.
//
// Input:
//  name   -- the name of the file corresponding to the rule (see Notes)
//  target -- the target to be built
//  ext    -- the extension of the target
//  dBuf   -- a pointer to the file information about name
//
// Output:
//  Returns a pointer to the applicable rule (NULL if none is found)
//       On return dBuf points to the fileInfo of the file corresponding
//       to the applicable inference rule. (see Notes)
//
// Assumes:
//  It assumes that name points to a buffer of size MAXNAME of allocated memory
//  and dBuf points to an allocated memory area corr to the size of FILEINFO.
//
// Modifies Globals:
//  global  --  how/what
//
// Uses Globals:
//  rules -- the list of implicit rules
//
// Notes:
//  Once NMAKE finds a rule for the extension it looks for the file with the same
//  base name as the target and an extension which is part of the rule. This
//  file is the file corresponding to the rule. Only when this file exists does
//  NMAKE consider the inference rule to be applicable. This file is returned
//  in name and dBuf points to the information about this file.
//   It handles quotes in filenames too.

RULELIST *
findRule(
    char *name,
    char *target,
    char *ext,
    void *dBuf
    )
{
    RULELIST *r;                    // pointer to rule
    char *s,                        // name of rule
     *ptrToExt;                     // extension
    char *endPath, *ptrToTarg, *ptrToName, *temp;
    int n, m;
    MAKEOBJECT *object = NULL;

    for (r = rules; r; r = r->next) {
        s = r->name;
#ifdef DEBUG_ALL
        printf("* findRule: %s,\n", r->name);
        DumpList(r->buildCommands);
        DumpList(r->buildMacros);
#endif
        ptrToExt = _tcsrchr(s, '.');
        // Compare ignoring enclosing quotes
        if (!strcmpiquote(ptrToExt, ext)) {
            *name = '\0';
            for (ptrToTarg = (s+1); *ptrToTarg && *ptrToTarg != '{';ptrToTarg = _tcsinc(ptrToTarg))
                if (*ptrToTarg == ESCH)
                    ptrToTarg++;
                // If Quotes present skip to end-quote
                else if (*ptrToTarg == '"')
                    for (ptrToTarg++; *ptrToTarg != '"'; ptrToTarg++)
                        ;

            if (*ptrToTarg) {
                for (endPath = ptrToTarg; *endPath && *endPath != '}';endPath = _tcsinc(endPath))
                    if (*endPath == ESCH)
                        endPath++;
                n = (int) (endPath - (ptrToTarg + 1));

                // ignore leading quote on target
                temp = target;
                if (*temp == '"')
                    temp++;

                for (ptrToExt = ptrToTarg+1; n; n -= (int) _tclen(ptrToExt),
                    ptrToExt = _tcsinc(ptrToExt),
                    temp = _tcsinc(temp)) { // compare paths
                    if (*ptrToExt == '\\' || *ptrToExt == '/') {
                        if (*temp != '\\' && *temp != '/') {
                            n = -1;
                            break;
                        }
                    } else if (_tcsnicmp(ptrToExt, temp, _tclen(ptrToExt))) {
                        n = -1;
                        break;
                    }
                }

                if (n == -1)
                    continue;           // match failed; do next rule
                ptrToExt = ptrToTarg;
                n = (int) (endPath - (ptrToTarg + 1));

                char *pchLast = _tcsdec(ptrToTarg, endPath);

                ptrToName = target + n + 1;                 // if more path
                if (((temp = _tcschr(ptrToName, '\\'))      // left in target (we
                    || (temp = _tcschr(ptrToName, '/')))    // let separator in
                    && (temp != ptrToName                   // target path in rule,
                    || *pchLast == '\\'                     // e.g. .c.{\x}.obj
                    || *pchLast == '/'))                    // same as .c.{\x\}.obj)
                    continue;                               // use dependent's path,
            }                                               // not target's

            if (*s == '{') {
                for (endPath = ++s; *endPath && *endPath != '}'; endPath = _tcsinc (endPath))
                    if (*endPath == ESCH)
                        endPath++;
                n = (int) (endPath - s);

                if (n) {
                    _tcsncpy(name, s, n);
                    s += n + 1;                 // +1 to go past '}'
                    if (*(s-2) != '\\')
                        *(name+n++) = '\\';
                } else {
                    if (*target == '"')
                        _tcsncpy(name, "\".\\", n = 3);
                    else
                        _tcsncpy(name, ".\\", n = 2);
                    s += 1;
                }

                ptrToName = _tcsrchr(target, '\\');
                temp = _tcsrchr(target, '/');

                if (ptrToName = (temp > ptrToName) ? temp : ptrToName) {
                    _tcscpy(name+n, ptrToName+1);
                    n += (int) (ext - (ptrToName + 1));
                } else {
                    char *szTargNoQuote = *target == '"' ? target + 1 : target;
                    _tcscpy(name+n, szTargNoQuote);
                    n += (int) (ext - szTargNoQuote);
                }
            } else {
                char *t;

                //if rule has path for target then strip off path part
                if (*ptrToTarg) {

                    t = _tcsrchr(target, '.');

                    while (*t != ':' && *t != '\\' && *t != '/' && t > target)
                        t = _tcsdec(target, t);
                    if (t) {
                        if (*t == ':' || *t == '\\' || *t == '/')
                            t++;
                    }
                } else
                    t = target;
                n = (int) (ext - t);

                // preserve the opening quote on target if stripped off path part
                m = 0;
                if ((t != target) && (*target == '"')) {
                    *name = '"';
                    m = 1;
                }
                _tcsncpy(name + m, t, n);
                n += m;
            }

            m = (int) (ptrToExt - s);
            if (n + m > MAXNAME) {
                makeError(0, NAME_TOO_LONG);
            }

            _tcsncpy(name+n, s, m);    // need to be less
            // If quoted add a quote at the end too
            if (*name == '"' && *(name+n+m-1) != '"') {
                *(name+n+m) = '"';
                m++;
            }
            *(name+n+m) = '\0';         // cryptic w/ error

            // Call QueryFileInfo() instead of DosFindFirst() because we need
            // to circumvent the non-FAPI nature of DosFindFirst()

            if ((object = findTarget(name)) || QueryFileInfo(name, (void **)dBuf)) {
                if (object) {
                    putDateTime((_finddata_t*)dBuf, object->dateTime);
                }

                return(r);
            }
        }
    }

    return(NULL);
}


//  freeRules -- free inference rules
//
// Scope:   Global
//
// Purpose: This function clears the list of inference rules presented to it.
//
// Input:
//  r     -- The list of rules to be freed.
//  fWarn -- Warn if rules is not in .SUFFIXES
//
// Assumes:
//  That the list presented to it is a list of rules which are not needed anymore
//
// Uses Globals:
//  gFlags -- The global actions flag, to find if -p option is specified

void
freeRules(
    RULELIST *r,
    BOOL fWarn
    )
{
    RULELIST *q;

    while (q = r) {
        if (fWarn && ON(gFlags, F1_PRINT_INFORMATION))  // if -p option specified
            makeError(0, IGNORING_RULE, r->name);
        FREE(r->name);                  // free name of rule
        freeStringList(r->buildCommands);   // free command list
        freeStringList(r->buildMacros); // free command macros Note: free a Macro List
        r = r->next;
        FREE(q);                        // free rule
    }
}


BOOL
removeDuplicateRules(
    RULELIST *newRule,
    RULELIST *rules
    )
{
    RULELIST *r;
    STRINGLIST *p;

    for (r = rules; r; r = r->next) {
        if (!_tcsicmp(r->name, newRule->name)) {
            FREE(newRule->name);
            while (p = newRule->buildCommands) {
                newRule->buildCommands = p->next;
                FREE(p->text);
                FREE_STRINGLIST(p);
            }
            FREE(newRule);
            return(TRUE);
        }
    }
    return(FALSE);
}


//  skipPathList -- skip any path list in string
//
// Scope:   Local
//
// Purpose:
//  This function skips past any path list in an inference rule. A rule can have
//  optionally a path list enclosed in {} before the extensions. skipPathList()
//  checks if any path list is present and if found skips past it.
//
// Input:   s -- rule under consideration
//
// Output:  Returns pointer to the extension past the path list
//
// Assumes: That the inference rule is syntactically correct & its syntax
//
// Notes:   The syntax of a rule is -- {toPathList}.to{fromPathList}.from

char *
skipPathList(
    char *s
    )
{
    if (*s == '{') {
        while (*s != '}') {
            if (*s == ESCH)
                s++;
            s = _tcsinc(s);
        }
        s = _tcsinc(s);
    }
    return(s);
}


//  sortRules -- sorts the list of inference rules on .SUFFIXES order
//
// Scope:   Global
//
// Purpose:
//  This function sorts the inference rules list into an order depending on the
//  order in which the suffixes are listed in '.SUFFIXES'. The inference rules
//  which have their '.toext' part listed earlier in .SUFFIXES are reordered to
//  be earlier in the inference rules list. The inference rules for suffixes that
//  are not in .SUFFIXES are detected here and are ignored.
//
// Modifies Globals:
//  rules -- the list of rules which gets sorted
//
// Uses Globals:
//  dotSuffixList -- the list of valid suffixes for implicit inference rules.
//
// Notes:
//  The syntax of a rule is -- '{toPath}.toExt{fromPath}.fromExt'. This function
//  sorts the rule list into an order. Suffixes are (as of 1.10.016) checked in a
//  case insensitive manner.

PUBLIC void
sortRules(
    void
    )
{
    STRINGLIST *p,                      // suffix under consideration
               *s,
               *L_macros = NULL;
    RULELIST *oldRules,                 // inference rule list before sort
             *newRules,
             *r;                        // rule under consideration in oldRules
    char *suff, *toExt;
    size_t n;

    oldRules = rules;
    rules = NULL;
    for (p = dotSuffixList; p; p = p->next) {
        n = _tcslen(suff = p->text);
        for (r = oldRules; r;) {
            toExt = skipPathList(r->name);
            if (!_tcsnicmp(suff, toExt, n) &&
                (*(toExt+n) == '.' || *(toExt+n) == '{')
               ) {
                newRules = r;
                if (r->back)
                    r->back->next = r->next;
                else
                    oldRules = r->next;
                if (r->next)
                    r->next->back = r->back;
                r = r->next;
                newRules->next = NULL;
                if (!removeDuplicateRules(newRules, rules)) {
                    for (s = newRules->buildCommands; s; s = s->next) {
                        findMacroValuesInRule(newRules, s->text, &L_macros);
                    }
                    newRules->buildMacros = L_macros;
                    L_macros = NULL;
                    appendItem((STRINGLIST**)&rules, (STRINGLIST*)newRules);
                }
            } else
                r = r->next;
        }
    }
    // forget about rules whose suffixes not in .SUFFIXES
    if (oldRules)
        freeRules(oldRules, TRUE);
}


//  useRule -- applies inference rules for a target (if possible)
//
// Scope:   Local.
//
// Purpose:
//  When no explicit commands are available for a target NMAKE tries to use the
//  available inference rules. useRule() checks if an applicable inference rule
//  is present. If such a rule is found then it attempts a build using this rule
//  and if no applicable rule is present it conveys this to the caller.
//
// Input:
//  object     - object under consideration
//  name       - name of target
//  targetTime - time of target
//  qList      - QuestionList for target
//  sList      - StarStarList for target
//  status     - is dependent available
//  maxDepTime - maximum time of dependent
//  pFirstDep  - first dependent
//
// Output:
//  Returns ... applicable rule

RULELIST *
useRule(
    MAKEOBJECT *object,
    char *name,
    time_t targetTime,
    STRINGLIST **qList,
    STRINGLIST **sList,
    int *status,
    time_t *maxDepTime,
    char **pFirstDep
    )
{
    struct _finddata_t finddata;
    STRINGLIST *temp;
    RULELIST *r;
    time_t tempTime;
    char *t;


    if (!(t = _tcsrchr(object->name, '.')) ||
         (!(r = findRule(name, object->name, t, &finddata)))
       ) {
        return(NULL);                   // there is NO rule applicable
    }
    tempTime = getDateTime(&finddata);
    *pFirstDep = name;
    for (temp = *sList; temp; temp = temp->next) {
        if (!_tcsicmp(temp->text, name)) {
            break;
        }
    }

    if (temp) {
        CLEAR(object->flags2, F2_DISPLAY_FILE_DATES);
    }

    *status += invokeBuild(name, object->flags2, &tempTime, NULL);
   if (ON(object->flags2, F2_FORCE_BUILD) ||
        targetTime < tempTime ||
        (fRebuildOnTie && (targetTime == tempTime))
       ) {
        if (!temp) {
            temp = makeNewStrListElement();
            temp->text = makeString(name);
            appendItem(qList, temp);
            if (!*sList) {              // if this is the only dep found for
                *sList = *qList;        //  the target, $** list is updated
            }
        }

        if (ON(object->flags2, F2_DISPLAY_FILE_DATES) &&
            OFF(object->flags2, F2_FORCE_BUILD)
           ) {
            makeMessage(UPDATE_INFO, name, object->name);
        }
    }

    *maxDepTime = __max(*maxDepTime, tempTime);

    return(r);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\table.h ===
//  TABLE.H -- contains tables used by lexer and parser
//
//  Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This include file contains parser tables and lexer tables.
//
// Revision History:
//  04-Dec-1989 SB Add proper proto's for PFV fn's which actions[] refers to
//  08-Oct-1989 SB Modified nameStates[][] to handle OS/2 1.2 quoted names
//  31-Jul-1989 SB changed entries in nameStates to symbolic BKS (seen Bkslash)
//  20-May-1989 SB changed nameStates[][] to 16x14 to handle at end of the
//        dependency lines
//  13-Jun-1988 rj Modified stringStates to handle \nl as in xmake (v1.5)

// ALL VALUES USED IN THESE TABLES ARE DEFINED IN GRAMMAR.H
// WHEN PRODUCTIONS CHANGE, UPDATE THE FOLLOWING TABLE
//
// The first element in a production line is the number of symbols on
// the right-hand-side of the production arrow.  If the first element
// is 0, the nonterminal to the left of the arrow goes to the null string.
// Table entries beginning w/ "DO" are actions to be carried out at
// that particular point in the production.  All other entries are
// either tokens or non-terminals.

const UCHAR prod0[] = {0};              // MAKEFILE -> prod0 | prod1 | prod2
const UCHAR prod1[] = {2,
               BLANKLINES,
               MAKEFILE};
const UCHAR prod2[] = {5,
               NEWLINE,
               NAME,
               DONAME,
               BODY,
               MAKEFILE};
const UCHAR prod3[] = {5,               // BODY -> prod3 | prod4
               NAMELIST,
               SEPARATOR,
               DOLASTNAME,
               BUILDINFO,
               DOBUILDCMDS};
const UCHAR prod4[] = {3,
               EQUALS,
               VALUE,
               DOMACRO};
const UCHAR prod5[] = {0};              // NAMELIST ->  prod5 | prod6
const UCHAR prod6[] = {3,
               NAME,
               DONAMELIST,
               NAMELIST};
const UCHAR prod7[] = {0};              // COMMANDS -> prod7 | prod8 | prod9
const UCHAR prod8[] = {1,
               MOREBUILDLINES};
const UCHAR prod9[] = {4,
               SEMICOLON,
               STRING,
               DONAMELIST,
               MOREBUILDLINES};
const UCHAR prod10[] = {4,              // MOREBUILDLINES -> prod10 | prod 11
            NEWLINESPACE,               //        | prod12
            STRING,
            DONAMELIST,
            MOREBUILDLINES};
const UCHAR prod11[] = {0};
const UCHAR prod12[] = {2,
            NEWLINE,
            MOREBUILDLINES};

const UCHAR prod13[] = {0};             // BLANKLINES -> prod13 | prod14 |
const UCHAR prod14[] = {2,              //        | prod15
            NEWLINE,
            BLANKLINES};
const UCHAR prod15[] = {2,
            NEWLINESPACE,
            BLANKLINES};
const UCHAR prod16[] = {1,
            DODEPENDS};                 // BUILDINFO -> prod16 | prod17
const UCHAR prod17[] = {3,
            NAMELIST,
            DODEPENDS,
            COMMANDS};
const UCHAR prod18[] = {1, COLON};      // SEPARATOR -> prod18 | prod19
const UCHAR prod19[] = {1, DOUBLECOLON};

const UCHAR * const productions[] = {
    prod0,
    prod1,
    prod2,
    prod3,
    prod4,
    prod5,
    prod6,
    prod7,
    prod8,
    prod9,
    prod10,
    prod11,
    prod12,
    prod13,
    prod14,
    prod15,
    prod16,
    prod17,
    prod18,
    prod19
};


// When either of the high bit (AMBIG_MASK) of something that isn't an ERROR
// condition is set, it means that there are two productions that apply for
// that entry, the one given, and the one given plus one.  The next token
// token must be examined to know which production to use.


// name    newline      newline  semi   colon   double  equals  $
//                      white   colon           colon
//                      space
static const UCHAR table[8][8] = {
    {SEPRTR,1 |AMBIG_MASK,  1,      SYNTAX, NOTARG, NOTARG, MACRO,  0},
    {SYNTAX,13|AMBIG_MASK,  15,     SYNTAX, SYNTAX, SYNTAX, SYNTAX, 13},
    {PARSER,11|AMBIG_MASK,  10,     PARSER, SYNTAX, SYNTAX, SYNTAX, 11},
    {PARSER,7,          8,      9,      SYNTAX, SYNTAX, SYNTAX, 7},
    {3,     SEPEQU,     SEPEQU, SEPRTR, 3,      3,      4,      SEPEQU},
    {6,     5,          5,      5,      5,      5,      NAMES,  5},
    {17,    16,         17,     17,     SYNTAX, SYNTAX, SYNTAX, 16},
    {PARSER,SEPRTR,     SEPRTR, SEPRTR, 18,     19,     SYNTAX, SEPRTR}};


static const UCHAR useAlternate[3][8] = {
    {YES,   NO,         NO,     YES,    YES,    YES,    YES,    NO},
    {NO,    YES,        YES,    NO,     NO,     NO,     NO,     YES},
    {NO,    YES,        YES,    NO,     NO,     NO,     NO,     NO}};

void makeName(void);
void addItemToList(void);
void makeMacro(void);
void assignDependents(void);
void endNameList(void);
void assignBuildCommands(void);

static PFV const actions[] = {
    makeName,
    addItemToList,
    makeMacro,
    assignDependents,
    endNameList,
    assignBuildCommands};


// state tables for lexer's name and string recognizers
// values are defined in grammar.h
//
//   d
//   e
//   f                   m
//   a                   a c      B
//   u |   |    |   |   |   |   |   |   |   |c h|   | @ | F |
//   l | # | =  | \ | : |WS |NL | $ | ( | ) |r a| * | < | D |
//   t |   |    |   |   |   |EOF|   |   |   |o r|   | ? | R |

extern const UCHAR stringStates[13][14] = {
    { 1, 2,  1,  3,  1,  2,  OK, 4,  1,  1,  1,  1,  1,  1},   // 0 in col 0
    { 1, 1,  1,  3,  1,  2,  OK, 4,  1,  1,  1,  1,  1,  1},   // 1 default
    { 1, 1,  1,  3,  1,  2,  OK, 4,  1,  1,  1,  1,  1,  1},   // 2 whitespace
    { 1, 1,  1,  1,  1,  2,  0,  4,  1,  1,  1,  1,  1,  1},   // 3 line cont.
    {CHR,CHR,CHR,CHR,CHR,BAD,BAD,1,  5,  CHR,1,  1,  1,  1},   // 4 macro inv.
    {CHR,CHR,CHR,CHR,CHR,NAM,PAR,CHR,CHR,NAM,6,  11, 8,  6},   // 5 found (
    {CHR,CHR,CHR,CHR,9,  PAR,PAR,CHR,CHR,2,  6,  BAD,BAD,6},   // 6 legal name
    {CHR,CHR,CHR,CHR,9,  PAR,PAR,CHR,CHR,2,  BAD,BAD,BAD,BAD}, // 7 ext sp mac
    {CHR,CHR,CHR,CHR,9,  PAR,PAR,CHR,CHR,2,  BAD,BAD,BAD,7},   // 8 sp ch aft(
    {10, 10, SEQ,10, 10, 10, PAR,10, 10, SEQ,10, 10, 10, 10},  // 9 found a :
    {10, 10, 12, 10, 10, 10, PAR,10, 10, EQU,10, 10, 10, 10},  //10 macro subs
    {CHR,CHR,CHR,CHR,9,  PAR,PAR,CHR,CHR,2,  BAD, 8, BAD,7},   //11 found $(*
    {12, 12, 12, 12, 12, 12, PAR,12, 12, 2,  12, 12, 12, 12}}; //12 look for )


// In the above table, the columns hold the next state to go to
// for the given input symbol and the lines represent the states
// themselves.
//
// WS       stands for whitespace, meaning space or tab
// NL       stands for newline, EOF stands for end of file
// macrochar    is any alphanumeric character or underscore
// *        is used in the special macros $* and $** ($** is the only
//  two-letter macro that doesn't require parentheses, thus
//  we must treat it specially)
// @ < ?    are characters found in special macros (they are not
//  allowed in the names of a user-defined macros)
// BFDR are modifiers to special macros which may be appended
//  to the macro name (but they necessitate the use of
//  parentheses in the macro invocation)
// #        is the comment char.  # is a comment anywhere on a macro
//  definition line, but is only a comment if it appears in
//  column 0 of a build line.  If we're lexing the tools
//  initialization file, then semicolon is also a comment char
//  if it appears in column 0.  (Note that the only way
//  to have a pound sign appear in the makefile and NOT be
//  considered a comment is to define a macro "$A = #" on
//  the commandline that invokes nmake.)
// default  is anything not contained in the above groups and not
//  appearing above a column in the table
//
// OK       means that we accept the string
//  all other mnemonic values are error codes (see end of grammar.h)


//  the states: there is no state to handle comments -- if we see a
//      comment char and we're not ignoring comments, we eat
//      the comment and get another input symbol before consulting
//      the state table
//
//      0   initial state -- for all practical purposes, we can
//          assume that we're in column 0.  If we're getting a
//          macro value, we don't care what column we're in.
//          If we're getting a build line, the only way we won't
//          be in column 0 is if we're getting a command following
//          a semicolon on the target-dependency line.  If the
//          use puts a comment char here, I think it's reasonable
//          to treat it as a comment, since it comes at the beginning
//          of the build command, even though the command itself
//          doesn't start in column 0.
//          We return to the initial state after seeing space-
//          backslash-newline.
//
//      1   on any input symbol that isn't a backslash, comment char,
//          or whitespace, we move here whenever we're not in a
//          comment, or a macro definition
//
//      2   if the input symbol is whitespace, we move here whenever
//          we're not in a comment or a macro definition.
//
//      3   We move here from states 0, 1, or 2 when we've seen a
//          backslash, because if it's followed by a newline, we
//          continue getting the string from the next line of the file.
//          If the next character is a backslash, followed by a newline,
//          there's a kludge in lexer.c that ignores the second back-
//          slash.
//          (The above applies to v. 1.5.  v. 1.0 requires whitespace
//          before a backslash.)
//
//      4   we move here when we see a dollar sign -- this is where
//          all the error checking starts.  We make sure that the
//          macro name is legal, that the substitution sequences
//          are specified correctly (if any is specified at all),
//          and that parens match up.  If our next input is $, a
//          special-macro char, or a legal char in a user-defined-
//          macro name, we go back to state 1.
//
//      5   found an open paren
//
//      6   found a legal macrochar
//
//      7   go here for an extended special macro, and from here we
//          look for a close paren (out of order w/ 8)
//
//      8   we found a special-macro char after the open paren
//          If we find a special-macro modifier
//          after the special macro char following the open paren
//          then we go to 7
//
//      9   found a colon (meaning that the user is going to do
//          some substitution in the macro value)

//      10  any character that isn't newline, right paren, or EOF
//          brings us here,a nd we loop until we see an equals sign.
//          Newline, EOF, or right paren generate error messages.
//
//      11  we move here from state 5 if we see an asterisk, because
//          we have to check for a second asterisk.  A second *
//          takes us to state 8 (because a modifier may follow **).
//          If we find a modifier here (instead of a 2nd *), we go
//          to state 7.
//
//      12  found an equals sign, so we loop, picking up characters
//          for the replacement string, until we find a close paren.
//          Newline, EOF generate error messages.



// The following table is used to recognize names
// It differs from the previous one in that we don't have to deal
// w/ continuations or comments, and we don't allow special macros
// (other than the dynamic dependency macros) to be used as part
// of names.
//
// d
// e
// f                      m
// a                      a c
// u |   |   |   |   |   |   |   |   |   |c h|   |   |   |
// l | # | = | ; | : |WS |NL | $ | ( | ) |r a| { | } | \ | "
// t |   |   |   |   |   |EOF|   |   |   |o r|   |   |   |

extern const UCHAR nameStates[19][15] = {
 {1,  OK, OK, OK, 1,  OK, OK, 2,  1,  1,  1,  8,  1,  BKS,16}, // 0 initial state
 {1,  OK, OK, OK, OK, OK, OK, 2,  1,  1,  1,  8,  1,  BKS,QUO},// 1 do normal name
 {CHR,BAD,CHR,CHR,CHR,BAD,BAD,1,  3,  CHR,1,  CHR,CHR,CHR,CHR},// 2 handle macro
 {CHR,PAR,CHR,CHR,NAM,NAM,PAR,CHR,CHR,NAM,4,  CHR,CHR,CHR,CHR},// 3 do macro name
 {CHR,PAR,CHR,CHR,5,  PAR,PAR,CHR,CHR,1,  4,  CHR,CHR,CHR,CHR},// 4 do mac (name)
 {6,  6,  SEQ,6,  6,  6,  PAR,6,  6,  EQU,6,  6,  6,  6  ,6},  // 5 found : do sub
 {6,  6,  7,  6,  6,  6,  SEQ,6,  6,  SEQ,6,  6,  6,  6  ,6},  // 6 read until =
 {7,  7,  7,  7,  7,  7,  SEQ,7,  7,  1,  7,  7,  7,  7  ,7},  // 7 read until )
 {8,  OK, 8,  8,  8,  8,  OK, 9,  8,  8,  8,  8,  18,  8  ,8}, // 8 do path list
 {CHR,BAD,CHR,CHR,CHR,BAD,BAD,8,  10, CHR,8,  CHR,CHR,CHR,CHR},// 9 do macro in {}
 {CHR,PAR,CHR,CHR,NAM,10, PAR,CHR,CHR,NAM,11, CHR,CHR,CHR,CHR},//10 do macro name
 {CHR,PAR,CHR,CHR,12, PAR,PAR,CHR,CHR,8,  11, CHR,CHR,CHR,CHR},//11 do mac (name)
 {13, 13, SEQ,13, 13, 13, PAR,13, 13, EQU,13, 13, 13, 13 ,13}, //12 found : do sub
 {13, 13, 14, 13, 13, 13, SEQ,13, 13, SEQ,13, 13, 13, 13 ,13}, //13 read until =
 {14, 14, 14, 14, 14, 14, SEQ,14, 14, 8,  14, 14, 14, 14 ,14}, //14 read until )
 {1,  OK, OK, OK, OK, OK, OK, 2,  1,  1,  1,  8,  1,  1  ,1},  //15 \ found so ...
 {16, 16, 16, 16, 16, 16, NOQ,2,  16, 16, 16, 8,  16, BKS,17}, //16 quoted name
 {OK, OK, OK, OK, OK, OK, OK, OK, OK, OK, OK, OK, OK, OK ,OK}, //17 quoted name
 {1,  OK, OK, OK, OK, OK, OK, 2,  1,  1,  1,  8,  1,  BKS,16}};//18 read after {}


// manis :-   changed state[8][7]'s value from 10 to 9
//    changed state[9][10]'s value from 1 to 8.....(25th jan 88)
//
// this is to allow macros inside path portions of rules, e.g.
// {$(abc)}.c{$(def)}.obj: .......
// or   foo : {$a;$(bcd);efg\hijk\}lmn.opq .......

// georgiop: added state 18 to handle quoted names following path lists
// e.g., {whatever}"foo" [DS #4296, 10/30/96]
//		We now enter state 18 as soon as a path list is read. (We used
//		to return to state 1 in that case and generate an error as
//		soon as the quotes were encountered)
//		Also changed state[8][5] from OK to 8 in order to allow paths
//		containing white space. [DS #14575]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\util.cpp ===
//  UTIL.C -- Data structure manipulation functions
//
// Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This module contains routines manipulating the Data Structures of NMAKE. The
//  routines are independent of the Mode of execution (Real/Bound).
//
// Revision History:
//  04-Feb-2000 BTF Ported to Win64
//  01-Feb-1994 HV  Turn off extra info display.
//  17-Jan-1994 HV  Fixed bug #3548: possible bug in findMacroValues because we
//                  are scanning 'string' byte-by-byte instead of char-by-char
//  15-Nov-1993 JdR Major speed improvements
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  03-Jun-1993 HV  Add helper local function TruncateString for findFirst.
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  08-Apr-1993 HV  Rewrite prependPath() to use _splitpath() and _makepath()
//  31-Mar-1993 HV  Rewrite drive(), path(), filename(), and extension() to use
//                  _splitpath() instead of parsing the pathname by itself.
//  08-Jun-1992 SS  Port to DOSX32
//  27-May-1992 RG  Changed open_file to use _fsopen with _SH_DENYWR
//  29-May-1990 SB  ^$ was not becoming same as $$ for command lines ...
//  01-May-1990 SB  Nasty Preprocessor quirk bug in modifySpecialvalue() fixed
//  27-Feb-1990 SB  GP fault for '!if "$(debug"=="y"' fixed (bug t119)
//  08-Feb-1990 SB  GP fault for 'echo $(FOO:" =" ^) fixed
//  06-Feb-1990 SB  Handle $* etc in presence of Quoted names.
//  02-Feb-1990 SB  Add file_open() function
//  31-Jan-1990 SB  Debug changes; testAddr used to track problems at that addr
//  08-Dec-1989 SB  Changed SPRINTF() to avoid C6 warnings with -Oes
//  04-Dec-1989 SB  ZFormat() proto was misspelled as Zformat()
//  01-Dec-1989 SB  realloc_memory() added; allocate() uses _msize() now
//  22-Nov-1989 SB  Add strcmpiquote() and unQuote()
//  22-Nov-1989 SB  add #ifdef DEBUG_MEMORY funcs free_memory() and mem_status()
//  13-Nov-1989 SB  restoreEnv() function unreferenced
//  08-Oct-1989 SB  Added searchBucket(); find() now checks equivalence of quoted
//                  and unquoted versions of a target.
//  06-Sep-1989 SB  $* in in-line files was clobbering Global variable 'buf'
//  18-Aug-1989 SB  heapdump() gets two parameters
//  03-Jul-1989 SB  moved curTime() to utilb.c and utilr.c to handle DOSONLY ver
//  30-Jun-1989 SB  added curTime() to get current Time.
//  28-Jun-1989 SB  changed copyEnviron()
//  05-Jun-1989 SB  makeString("") instead of using "" in DGROUP for null macro
//  21-May-1989 SB  modified find() to understand that targets 'foo.c', '.\foo.c'
//                  and './foo.c' are the same.
//  13-May-1989 SB  Added functions path(), drive(), filename(), extension(),
//                  strbskip(), strbscan() instead of ZTOOLS library
//  12-May-1989 SB  Fixed bug in substitute strings
//  10-May-1989 SB  Added stuff for ESCH handling changes in Quotes;
//  01-May-1989 SB  changed return value of allocate().
//  14-Apr-1989 SB  restoreEnv() created for macroBackInheritance
//  05-Apr-1989 SB  made all funcs NEAR; Reqd to make all function calls NEAR
//  17-Mar-1989 SB  substituteStrings() now has 3 new error checks & avoids GPs
//  13-Mar-1989 SB  ZFormat() was missing the legal case of '%%'
//  22-Feb-1989 SB  ZFormat() has buffer overflow check with extra parameter
//                  and SPRINTF() gives a new error
//  15-Feb-1989 SB  Changed modifySpecialValue(), was not performing correctly
//                  for $(@D) and $(@B) for some cases.
//  13-Feb-1989 SB  Made Prototypes for ZTools Library functions as extern
//   5-Dec-1988 SB  Made SPRINTF() cdecl as NMAKE now uses Pascal calling
//  25-Nov-1988 SB  Added SPRINTF() and ZFormat() and also added prototypes for
//                  functions used from ZTools Library (6 of them)
//  10-Nov-1988 SB  Removed mixed mode functions (bound & real) to utilr.c
//                  & utilb.c; corr globals/debug data also moved
//  10-Oct-1988 SB  Add Comments for hash().
//  18-Sep-1988 RB  Fix bad flag checking for targets in find().
//  15-Sep-1988 RB  Move some def's out to GLOBALS.
//  22-Aug-1988 RB  Don't find undefined macros.
//  17-Aug-1988 RB  Clean up.  Clear memory in allocate().
//   8-Jul-1988 rj  Minor speedup (?) to find().
//   7-Jul-1988 rj  Modified find and hash; less efficient, but case-indep.
//   1-Jul-1988 rj  Fixed line truncation after null special macro.
//  30-Jun-1988 rj  Fixed bug with checkDynamicDependency not handling $$.
//  29-Jun-1988 rj  Fixed bug with extra * after expanding $**.
//                  Fixed abysmal with $$(@?).
//                  Fixed handling of F, B, R modifiers.
//  22-Jun-1988 rj  Added friendly filename truncation (findFirst).
//  22-Jun-1988 rj  Fixed bug #3 (.abc.def.ghi not detected).
//  16-Jun-1988 rj  Modified several routines to look for escape
//                  character when walking through strings.
//  27-May-1988 rb  Fixed space-appending on list-expansion macros.
//                  Don't include trailing path separator in $(@D).

#include "precomp.h"
#pragma hdrstop

// Prototypes of functions local to this module

void   putValue(char**, char**, char**, char**, char*, unsigned*, char *);
void   substituteStrings(char**, char**, char**, char**, char*,
                    unsigned*, char *);
char * isolateMacroName(char*, char*);
char * checkDynamicDependency(char*);
void   increaseBuffer(char**, char**, char**, unsigned*, char *);
void   putSpecial(char**, char**, char**, char**, unsigned*,
                 unsigned, char *);
      char * modifySpecialValue(char, char*, char*);
STRINGLIST * searchBucket(char *, STRINGLIST **, unsigned);
int envVars(char **environ);

// Prototypes of functions used by ZFormat from ZTools Library

      char * strbscan(char *, char *);
char * strbskip(char *, char *);
int    drive(const char *, char *);
int    path(const char *, char *);
int    filenamepart(const char *, char *);
int    extension(const char *, char *);

const char special1[] = "*@<?";
const char special2[] = "DFBR";

// These two variables are needed in order to provide
// more informative error messages in case findMacroValue
// detects an illegal macro in the command block of
// a batch mode rule.
static BOOL fFindingMacroInBatchRule = FALSE;
static char * szBatchRuleName;                // current rule name

#if !defined(NDEBUG)
size_t TotalAlloc;
unsigned long CntAlloc;

void
printStats(
    void
    )
{
#if defined(STATISTICS)
    fprintf(stderr,"\n   Memory Allocation:\n"
                     "       total allocation:\t%12.lu\n"
                     "       individual allocations:\t%12.lu\n"
                     "   Macros:\n"
                     "       searches:\t\t%12.lu\n"
                     "       chain walks:\t\t%12.lu\n"
                     "       insertions:\t\t%12.lu\n"
                   "\n   Targets:\n"
                     "       searches:\t\t%12.lu\n"
                     "       chain walks:\t\t%12.lu\n"
                   "\n   Others:\n"
                     "       stricmp compares:\t%12.lu\n"
                     "       String List frees:\t%12.lu\n"
                     "       String List allocs:\t%12.lu\n",
                    TotalAlloc,
                    CntAlloc,
                    CntfindMacro,
                    CntmacroChains,
                    CntinsertMacro,
                    CntfindTarget,
                    CnttargetChains,
                    CntStriCmp,
                    CntFreeStrList,
                    CntAllocStrList);
#endif
}
#endif
#define ALLOCBLKSIZE 32768
unsigned long AllocFreeCnt;
char * PtrAlloc;
STRINGLIST *PtrFreeStrList;


// rallocate - allocate raw memory (not cleared)
//
// Tries to allocate a chunk of memory, prints error message and exits if
// the requested amount is not available.

void *
rallocate(
    size_t size
    )
{
    void *chunk = malloc(size);

    if (chunk == NULL) {
        makeError(currentLine, OUT_OF_MEMORY);
    }

#if !defined(NDEBUG)
    TotalAlloc += size;
    CntAlloc++;
#endif

    return(chunk);
}


// allocate - allocate memory and clear it
//
// Tries to allocate a chunk of memory, prints error message and exits if
// the requested amount is not available.
// IMPORTANT: we must clear the memory here. Code elsewhere relies on this.

void *
allocate(
    size_t size                        // Number of bytes requested
    )
{
    void *chunk = rallocate(size);

    memset(chunk, 0, size);

    return(chunk);
}


void *
alloc_stringlist(
    void
    )
{
    STRINGLIST *chunk;

#if defined(STATISTICS)
    CntAllocStrList++;
#endif

    if (PtrFreeStrList != NULL) {
        chunk = PtrFreeStrList;
        PtrFreeStrList = chunk->next;
    } else {
        if (AllocFreeCnt < sizeof(STRINGLIST)) {
            PtrAlloc = (char *) rallocate(ALLOCBLKSIZE);
            AllocFreeCnt = ALLOCBLKSIZE;
        }

        chunk = (STRINGLIST *) PtrAlloc;

        PtrAlloc += sizeof(STRINGLIST);
        AllocFreeCnt -= sizeof(STRINGLIST);
    }

    chunk->next = NULL;
    chunk->text = NULL;

    return (void *)chunk;
}


void
free_stringlist(
    STRINGLIST *pMem
    )
{
#if !defined(NDEBUG)
    STRINGLIST *tmp;

    for (tmp = PtrFreeStrList; tmp != NULL; tmp = tmp->next) {
        if (tmp == pMem) {
            fprintf(stderr, "free same pointer twice: %p\n", pMem);
            return;
        }
    }

    pMem->text = NULL;
#endif

    pMem->next = PtrFreeStrList;
    PtrFreeStrList = pMem;

#if defined(STATISTICS)
    CntFreeStrList++;
#endif
}


// allocate space, copies the given string into the newly allocated space, and
// returns ptr.
char *
makeString(
    const char *s
    )
{
    char *t;
    size_t l = _tcslen(s) + 1;
    t = (char *) rallocate(l);
    memcpy(t, s, l);
    return(t);
}

// like makeString, but creates quoted string
char *
makeQuotedString(
    const char *s
    )
{
    char *t;
    size_t l = _tcslen(s);
    t = (char *) rallocate(l + 3);
    t[0] = '"';
    memcpy(t+1, s, l);
    t[l+1] = '"';
    t[l+2] = '\0';
    return(t);
}

// reallocate String sz1 and append sz2
char *
reallocString(
    char * szTarget,
    const char * szAppend
    )
{
    char *szNew;
    size_t cbNew = _tcslen(szTarget) + _tcslen(szAppend) + 1;
    szNew = (char *) REALLOC(szTarget, cbNew);
    if (!szNew) {
        makeError(0, OUT_OF_MEMORY);
        return NULL;
    } else {
        return  _tcscat(szNew, szAppend);
    }
}


// makes element the head of list
void
prependItem(
    STRINGLIST **list,
    STRINGLIST *element
    )
{
    element->next = *list;
    *list = element;
}


// makes element the tail of list
void
appendItem(
    STRINGLIST **list,
    STRINGLIST *element
    )
{
    for (; *list; list = &(*list)->next)
        ;
    *list = element;
}



// hash - returns hash value corresponding to a string
//
// Purpose:
//  This is a hash function. The hash function uses the following Algorithm --
//   Add the characters making up the string (s) to get N (ASCII values)
//      N mod total         ,gives the hash value,
//       where,  total is   MAXMACRO       for macros
//                  MAXTARGET        targets
//  Additionally, for targets it takes Uppercase Values alone, since, targets
//  are generally filenames and DOS/OS2 filenames are case independent.
//
// Input:
//  s           = name for which a hash is required
//  total      = Constant used in the hash function
//  targetFlag = boolean flag; true for targets, false for macros
//
// Output:
//  Returns hash value between 0 and (total-1)

unsigned
hash(
    char *s,
    unsigned total,
    BOOL targetFlag
    )
{
    unsigned n;
    unsigned c;

    if (targetFlag) {
        for (n = 0; c = *s; (n += c), s++)
            if (c == '/') {
                c = '\\';               // slash == backslash in targets
            } else {
                c = _totupper(c);       // lower-case == upper-case in targets
            }
    } else {
        for (n = 0; *s; n += *s++)
            ;
    }

    return(n % total);
}


// find - look up a string in a hash table
//
// Look up a macro or target name in a hash table and return the entry
// or NULL.
// If a macro and undefined, return NULL.
// Targets get matched in a special way because of filename equivalence.

STRINGLIST *
find(
    char *str,
    unsigned limit,
    STRINGLIST *table[],
    BOOL targetFlag
    )
{
    unsigned n;
    char *L_string = str;
    char *quote;
    STRINGLIST *found;
    BOOL fAllocStr = FALSE;

    if (*L_string) {
        n = hash(L_string, limit, targetFlag);

        if (targetFlag) {
#if defined(STATISTICS)
            CntfindTarget++;
#endif

            found = searchBucket(L_string, table, n);

            if (found) {
                return(found);
            }

            //Look for .\string
            if (!_tcsncmp(L_string, ".\\", 2) || !_tcsncmp(L_string, "./", 2)) {
                L_string += 2;
            } else {
                L_string = (char *)rallocate(2 + _tcslen(str) + 1);
                _tcscat(_tcscpy(L_string, ".\\"), str);
                fAllocStr = (BOOL)TRUE;
            }

            n = hash(L_string, limit, targetFlag);
            found = searchBucket(L_string, table, n);

            if (found) {
                if (fAllocStr) {
                    FREE(L_string);
                }

                return(found);
            }

            // Look for ./string
            if (L_string != (str + 2)) {
                L_string[1] = '/';
            }

            n = hash(L_string, limit, targetFlag);
            found = searchBucket(L_string, table, n);

            if (fAllocStr) {
                FREE(L_string);
            }

            if (found) {
                return(found);
            }

            //Look for "foo" or foo
            if (*str == '"') {
                quote = unQuote(str);
            } else {
                size_t len = _tcslen(str) + 2;
                quote = (char *) allocate(len + 1);
                _tcscat(_tcscat(_tcscpy(quote, "\""), str), "\"");
            }

            n = hash(quote, limit, targetFlag);
            found = searchBucket(quote, table, n);

            FREE(quote);

            return found;
        }

        for (found = table[n]; found; found = found->next) {
            if (!_tcscmp(found->text, L_string)) {
                return((((MACRODEF *)found)->flags & M_UNDEFINED) ? NULL : found);
            }
        }

    }

    return(NULL);
}


// FINDMACROVALUES --
// looks up a macro's value in hash table, prepends to list a STRINGLIST
// element holding pointer to macro's text, then recurses on any macro
// invocations in the value
//
// The lexer checks for overrun in names (they must be < 128 chars).
// If a longer, undefined macro is only referred to in the value of
// another macro which is never invoked, the error will not be flagged.
// I think this is reasonable behavior.
//
// MACRO NAMES CAN ONLY CONSIST OF ALPHANUMERIC CHARS AND UNDERSCORE
//
// we pass a null list pointer-pointer if we just want to check for cyclical
// definitions w/o building the list.
//
// the name parameter is what's on the left side of an = when we're just
// checking cyclical definitions.   When we "find" the macros in a target
// block, we have to pass the name of the macro whose text we're recursing
// on in our recursive call to findMacroValues().
//
// Might want to check into how to do this w/o recursion (is it possible?)
//
// This function is RECURSIVE.

// Added a fix to make this function handle expand macros which refer
// to other recursive macros.
//
// levelSeen is the recLevel at which a macroname was first seen so that
// the appropriate expansion can be calculated (even when recursing ...)

BOOL
findMacroValues(
    char *string,                       // string to check
    STRINGLIST **list,                  // list to build
    STRINGLIST **newtail,               // tail of list to update
    char *name,                         // name = string
    unsigned recLevel,                  // recursion level
    unsigned levelSeen,
    UCHAR flags
    )
{
    char macroName[MAXNAME];
    char *s;
    MACRODEF *p;
    STRINGLIST *q, *r, dummy, *tail;
    unsigned i;
    BOOL inQuotes = (BOOL) FALSE;       // flag when inside quote marks

    if (list) {
        if (newtail) {
            tail = *newtail;
        } else {
            tail = *list;
            if (tail) {
                while (tail->next) {
                    tail = tail->next;
                }
            }
        }
    } else {
        tail = NULL;
    }

    for (s = string; *s; ++s) {         // walk the string
        for (; *s && *s != '$'; s = _tcsinc(s)) {  // find next macro
            if (*s == '\"')
                inQuotes = (BOOL) !inQuotes;
            if (!inQuotes && *s == ESCH) {
                ++s;                    // skip past ESCH
                if (*s == '\"')
                    inQuotes = (BOOL) !inQuotes;
            }
        }
        if (!*s)
            break;                      // move past '$'
        if (!s[1])
            if (ON(flags, M_ENVIRONMENT_DEF)) {
                if (newtail)
                    *newtail = tail;
                return(FALSE);
            } else
                makeError(currentLine, SYNTAX_ONE_DOLLAR);
        s = _tcsinc(s);
        if (!inQuotes && *s == ESCH) {
            s = _tcsinc(s);
            if (!MACRO_CHAR(*s))
                if (ON(flags, M_ENVIRONMENT_DEF)) {
                    if (newtail)
                        *newtail = tail;
                    return(FALSE);
                } else
                    makeError(currentLine, SYNTAX_BAD_CHAR, *s);
        }
        if (*s == '$') {                            // $$ = dynamic
            s = checkDynamicDependency(s);          //    dependency
            continue;                               //    or just $$->$
        } else if (*s == '(') {                     // name is longer
            s = isolateMacroName(s+1, macroName);   //    than 1 char
            if (_tcschr(special1, *macroName)) {
                if (fFindingMacroInBatchRule && OFF(gFlags, F1_NO_BATCH)) {
                    // we only allow $< in batch rules
                    // so this is an error
                    char * szBadMacro = (char *) malloc(_tcslen(macroName) + 4);
                    if (szBadMacro) {
                        sprintf(szBadMacro, "$(%s)", macroName);
                        makeError(0, BAD_BATCH_MACRO, szBadMacro, szBatchRuleName);
                    } else {
                        makeError(0, OUT_OF_MEMORY);
                    }
                }
                else
                    continue;
            }
        } else {
            if (_tcschr(special1, *s)){
                if (fFindingMacroInBatchRule && OFF(gFlags, F1_NO_BATCH) && *s != '<') {
                    char szBadMacro[3];
                    szBadMacro[0] = '$';
                    szBadMacro[1] = *s;
                    szBadMacro[2] = '\0';
                    // we only allow $< in batch rules
                    // so this is an error
                    makeError(0, BAD_BATCH_MACRO, szBadMacro, szBatchRuleName);
                }
                else
                    continue;                       // 1-letter macro
            }

            if (!MACRO_CHAR(*s))
                if (ON(flags, M_ENVIRONMENT_DEF)) {
                    if (newtail) *newtail = tail;
                        return(FALSE);
                } else
                    makeError(currentLine, SYNTAX_ONE_DOLLAR);
            macroName[0] = *s;
            macroName[1] = '\0';
        }
        // If list isn't NULL, allocate storage for a new node.  Otherwise
        // this function was called purely to verify the macro name was
        // valid and we can just use the dummy node as a place holder.
        //
        // 2/28/92  BryanT    dummy.text wasn't being initialized each
        //              time.  As a result, if we were to recurse
        //              this function, whatever value was in text
        //              on the last iteration is still there.
        //              In the case where the macroName doesn't exist
        //              in the the call to findMacro(), and the old
        //              dummy->text field contained a '$', the
        //              function would recurse infinitely.
        //              Set to an empty string now
        //
        // q = (list) ? makeNewStrListElement() : &dummy;

        if (list != NULL) {
            q = makeNewStrListElement();
        } else {
            dummy.next = NULL;
            dummy.text = makeString(" ");
            q = &dummy;
        }

        if (p = findMacro(macroName)) {
            // macro names are case sensitive
            if (name && !_tcscmp(name, macroName)) {       // self-refer-
                r = p->values;                              // ential macro
                for (i = recLevel; i != levelSeen && r; --i)
                    r = r->next;                            // (a = $a;b)
                q->text = (r) ? r->text : makeString("");
            }
            else if (ON(p->flags, M_EXPANDING_THIS_ONE)) {  // recursive def
                if (ON(flags, M_ENVIRONMENT_DEF)) {
                    if (newtail) *newtail = tail;
                        return(FALSE);
                } else
                    makeError(currentLine, CYCLE_IN_MACRODEF, macroName);
            }
            else if (ON(p->flags, M_UNDEFINED)) {
                q->text = makeString("");       // if macro undefd [DS 18040]
            }
            else
                q->text = p->values->text;
        }

        if (list) {                             // if blding list
            if (!p || ON(p->flags, M_UNDEFINED))
                q->text = makeString("");       // if macro undefd
            q->next = NULL;                     // use NULL as its value
            if (tail) {
                tail->next = q;
            }else {
                *list = q;
            }
            tail = q;
        }                                       // if found text,

        if (!p || !_tcschr(q->text, '$'))
            continue;                           // and found $ in
        SET(p->flags, M_EXPANDING_THIS_ONE);    // text, recurse
        findMacroValues(q->text,
                        list,
                        &tail,
                        macroName,
                        recLevel+1,
                        (name && _tcscmp(name, macroName)? recLevel : levelSeen),
                        flags);
        CLEAR(p->flags, M_EXPANDING_THIS_ONE);
    }
    if (newtail) *newtail = tail;
        return(TRUE);
}

//
// findMacroValuesInRule --
// This is a wrapper around findMacroValues that generates an
// error if an illegal special macro is referenced (directly
// or indirectly) by the command block of a batch-mode rule
//
BOOL
findMacroValuesInRule(
    RULELIST *pRule,                    // pointer to current rule
    char *string,                       // string to check
    STRINGLIST **list                   // list to build
    )
{
    BOOL retval;
    if (fFindingMacroInBatchRule = pRule->fBatch)
        szBatchRuleName = pRule->name;
    retval = findMacroValues(string, list, NULL, NULL, 0, 0, 0);
    fFindingMacroInBatchRule = FALSE;
    return retval;
}

// isolateMacroName -- returns pointer to name of macro in extended invocation
//
// arguments:   s       pointer to macro invocation
//              macro   pointer to location to store macro's name
//
// returns:    pointer to end of macro's name
//
// isolates name and moves s

char *
isolateMacroName(
    char *s,                            // past closing paren
    char *macro                         // lexer already ckd for bad syntax
    )
{
    char *t;

    for (t = macro; *s && *s != ')' && *s != ':'; t=_tcsinc(t), s=_tcsinc(s)) {
        if (*s == ESCH) {
            s++;
            if (!MACRO_CHAR(*s))
                makeError(currentLine, SYNTAX_BAD_CHAR, *s);
        }
        _tccpy(t, s);
    }
    while (*s != ')') {
        if (*s == ESCH)
            s++;
        if (!*s)
            break;
        s++;
    }
    if (*s != ')')
        makeError(currentLine, SYNTAX_NO_PAREN);

    *t = '\0';
    if (t - macro > MAXNAME)
        makeError(currentLine, NAME_TOO_LONG);
    return(s);
}


// figures out length of the special macro in question, and returns a ptr to
// the char after the last char in the invocation

char *
checkDynamicDependency(
    char *s
    )
{
    char *t;

    t = s + 1;
    if (*t == ESCH)
        return(t);                      // If $^, leave us at the ^
    if (*t == '(') {
        if (*++t == ESCH) {
            return(t);
        } else {
            if (*t == '@') {
                if (*++t == ESCH)
                    makeError(currentLine, SYNTAX_BAD_CHAR, *++t);
                else if (*t == ')')
                    return(t);
                else if (_tcschr(special2, *t)) {
                    if (*++t == ESCH)
                        makeError(currentLine, SYNTAX_BAD_CHAR, *++t);
                    else if (*t == ')')
                        return(t);
                }
            } else {
                t = s + 1;              // invalid spec. mac.
                if (*t == ESCH)
                    return(t);          // evals. to $(
                return(++t);
            }
        }
    }
    return(s);                          // char matched
}


// removes and expands any macros that exist in the string macroStr.
// could return a different string (in case expandMacros needs more
// buffer size for macro expansion. it is the caller's responsibility
// to free the string soon as it is not required....

char *
removeMacros(
    char *macroStr
    )
{
    STRINGLIST *eMacros = NULL;
    STRINGLIST *m;

    if (_tcschr(macroStr, '$')) {
        findMacroValues(macroStr, &eMacros, NULL, NULL, 0, 0, 0);
        m = eMacros;
        macroStr = expandMacros(macroStr, &eMacros);
        while (eMacros = m) {
            m = m->next;
            FREE_STRINGLIST(eMacros);
        }
    }
    return(macroStr);
}


// expandMacros -- expand all macros in a string s
//
// arguments:  s       string to expand
//             macros  list of macros being expanded (for recursive calls)
//
// actions:    allocate room for expanded string
//             look for macros in string (handling ESCH properly (v1.5))
//             parse macro--determine its type
//             use putSpecial to handle special macros
//             recurse on list of macros
//             use putValue to put value of just-found macro in string
//             return expanded string
//
// returns:    string with all macros expanded
//
// CALLER CHECKS TO SEE IF _tcschr(STRING, '$') IN ORER TO CALL THIS.
// this doesn't work for HUGE macros yet.  need to make data far.
//
// we save the original string and the list of ptrs to macro values
// to be substituted.
// the caller has to free the expansion buffer
//
// expandMacros updates the macros pointer and frees the skipped elements

char *
expandMacros(
    char *s,                            // text to expand
    STRINGLIST **macros
    )
{
    STRINGLIST *p;
    char *t, *end;
    char *text, *xresult;
    BOOL inQuotes = (BOOL) FALSE;       // flag when inside quote marks
    char *w;
    BOOL freeFlag = FALSE;
    char resultbuffer[MAXBUF];
    unsigned len = MAXBUF;
    char *result = resultbuffer;

    end = result + MAXBUF;
    for (t = result; *s;) {                         // look for macros
        for (; *s && *s != '$'; *t++ = *s++) {      // as we copy the string
            if (t == end) {
                increaseBuffer(&result, &t, &end, &len, &resultbuffer[0]);
            }
            if (*s == '\"')
                inQuotes = (BOOL) !inQuotes;
            if (!inQuotes && *s == ESCH) {
                *t++ = ESCH;
                if (t == end) {
                    increaseBuffer(&result, &t, &end, &len, &resultbuffer[0]);
                }
                s++;
                if (*s == '\"')
                    inQuotes = (BOOL) !inQuotes;
            }
        }
        if (t == end) {                             //  string
            increaseBuffer(&result, &t, &end, &len, &resultbuffer[0]);
        }
        if (!*s)
            break;                                  // s exhausted
        w = (s+1);   // don't check for ^ here; already did in findMacroValues
        if (*w == '('                               // found a macro
            && _tcschr(special1, *(w+1))) {
            putSpecial(&result, &s, &t, &end, &len, X_SPECIAL_MACRO, &resultbuffer[0]);
            continue;
        } else
        if (*w++ == '$') {                          // double ($$)
            if (*w == ESCH)                         // $$^...
                putSpecial(&result, &s, &t, &end, &len, DOLLAR_MACRO, &resultbuffer[0]);
            else if (*w == '@')                     // $$@
                putSpecial(&result, &s, &t, &end, &len, DYNAMIC_MACRO, &resultbuffer[0]);
            else if ((*w == '(') && (*++w == '@') && (*w == ')'))
                putSpecial(&result, &s, &t, &end, &len, DYNAMIC_MACRO, &resultbuffer[0]);
            else if (((*++w=='F') || (*w=='D') || (*w=='B') || (*w=='R')) && (*++w == ')'))
                putSpecial(&result, &s, &t, &end, &len, X_DYNAMIC_MACRO, &resultbuffer[0]);
            else                                    // $$
                putSpecial(&result, &s, &t, &end, &len, DOLLAR_MACRO, &resultbuffer[0]);
            continue;
        } else
        if (_tcschr(special1, s[1])) {             // $?*<
            putSpecial(&result, &s, &t, &end, &len, SPECIAL_MACRO, &resultbuffer[0]);
            continue;
        }
        if (!*macros)
            makeError(currentLine, MACRO_INTERNAL);

        // skip this element in the macros list

        if (_tcschr((*macros)->text, '$')) {       // recurse
            p = *macros;
            *macros = (*macros)->next;
            text = expandMacros(p->text, macros);
            freeFlag = TRUE;
        } else {
            text = (*macros)->text;
            *macros = (*macros)->next;
        }
        putValue(&result, &s, &t, &end, text, &len, &resultbuffer[0]);
        if (freeFlag) {
            FREE(text);
            freeFlag = FALSE;
        }
    }

    if (t == end) {
        increaseBuffer(&result, &t, &end, &len, &resultbuffer[0]);
    }
    *t++ = '\0';

    // Allocate result buffer
    if (!(xresult = (char *) rallocate((size_t) (t - result)))) {
        makeError(currentLine, MACRO_TOO_LONG);
    }
    memcpy(xresult, result, (size_t) (t - result));
    return(xresult);
}


// increaseBuffer -- increase the size of a string buffer, with error check
//
// arguments:   result  pointer to pointer to start of buffer
//              t       pointer to pointer to end of buffer (before expansion)
//              end     pointer to pointer to end of buffer (after expansion)
//              len     pointer to amount by which to expand buffer
//              first   address of initial stack buffer
//
// actions:    check for out of memory
//        allocate new buffer
//        reset pointers properly
//
// modifies:    t, end to point to previous end and new end of buffer
//
// uses 0 as line number because by the time we hit an error in this routine,
// the line number will be set at the last line of the makefile (because we'll
// have already read and parsed the file)

void
increaseBuffer(
    char **result,
    char **t,
    char **end,
    unsigned *len,
    char *first
    )
{
    unsigned newSize;
    void *pv;

    // determine if result points to the firstbuffer and make a dynamic copy first.

    if (*result == first) {
        char *p = (char *) rallocate(*len);
        memcpy(p, *result, *len);
        *result = p;
    }
    newSize = *len + MAXBUF;
#ifdef DEBUG
    if (fDebug) {
        fprintf(stderr,"\t\tAttempting to reallocate %d bytes to %d\n", *len, newSize);
    }
#endif
    pv = REALLOC(*result, newSize);
    if (!pv) {
        makeError(currentLine, MACRO_TOO_LONG);
    } else {
        *result =(char *)pv;
        *t = *result + *len;                // reset pointers, len
        *len = newSize;
        *end = *result + *len;
    }
}


// putSpecial -- expand value of special macro
//
// arguments:  result  ppointer to start of string being expanded
//             name    ppointer to macro name being expanded
//             dest    ppointer to place to store expanded value
//             end     ppointer to end of dest's buffer
//             length  pointer to amount by which to increase dest's buffer
//             which   ype of special macro
//             first   address of initial stack buffer
//
// actions:    depending on type of macro, set "value" equal to macro's value
//             if macro expands to a list, store whole list in "value" ($?, $*)
//             otherwise, modify value according to F, B, D, R flag
//             use putValue to insert the value in dest
//
// has to detect error if user tries $* etc. when they aren't defined
// fix to handle string substitutions, whitespace around names, etc
// right now list macros are limited to 1024 bytes total

void
putSpecial(
    char **result,
    char **name,
    char **dest,
    char **end,
    unsigned *length,
    unsigned which,
    char *first
    )
{
    char *value = 0;
    STRINGLIST *p;
    BOOL listMacro = FALSE, modifier = FALSE, star = FALSE;
    unsigned i = 1;
    char c, nameBuf[MAXNAME], *temp;

    switch (which) {
        case X_SPECIAL_MACRO:
            i = 2;
            modifier = TRUE;

        case SPECIAL_MACRO:
            switch ((*name)[i]) {
                case '<':
                    value = dollarLessThan;
                    break;

                    case '@':
                        value = dollarAt;
                        break;

                    case '?':
                        value = (char*) dollarQuestion;
                        listMacro = TRUE;
                        break;

                    case '*':
                        if ((*name)[i+1] != '*') {
                            value = dollarStar;
                            star = TRUE;
                            break;
                        }
                        value = (char*) dollarStarStar;
                        listMacro = TRUE;
                        ++i;
                        break;

                    default:
                        break;
            }
            ++i;
            break;

        case X_DYNAMIC_MACRO:
            i = 4;
            modifier = TRUE;

        case DYNAMIC_MACRO:
            value = dollarDollarAt;
            break;

        case DOLLAR_MACRO:
            if (*dest == *end)
                increaseBuffer(result, dest, end, length, first);
            *(*dest)++ = '$';
            *name += 2;
            return;

        default:
            return;                     // can't happen
    }
    if (!value) {
        for (temp = *name; *temp && *temp != ' ' && *temp != '\t'; temp++)
            ;
        c = *temp; *temp = '\0';
        makeError(currentLine, ILLEGAL_SPECIAL_MACRO, *name);
        *temp = c;
        listMacro = FALSE;
        value = makeString("");    // value is freed below, must be on heap [rm]
    }
    if (listMacro) {
        char *pVal, *endVal;
        unsigned lenVal = MAXBUF;
        p = (STRINGLIST*) value;
        pVal = (char *)allocate(MAXBUF);

        endVal = pVal + MAXBUF;
        for (value = pVal; p; p = p->next) {
            temp = p->text;
            if (modifier)
                temp = modifySpecialValue((*name)[i], nameBuf, temp);
            while(*temp) {
                if (value == endVal)
                    increaseBuffer(&pVal, &value, &endVal, &lenVal, NULL);
                *value++ = *temp++;
            }
            if (value == endVal)
                increaseBuffer(&pVal, &value, &endVal, &lenVal, NULL);
            *value = '\0';

            // Append a space if there are more elements in the list.  [RB]

            if (p->next) {
                *value++ = ' ';
                if (value == endVal)
                    increaseBuffer(&pVal, &value, &endVal, &lenVal, NULL);
                *value = '\0';
            }
        }
        value = pVal;
    } else {
        //For some reason 'buf' was being used here clobbering global 'buf
        //  instead of nameBuf
        if (star)
            value = modifySpecialValue('R', nameBuf, value);

        if (modifier)
            value = modifySpecialValue((*name)[i], nameBuf, value);
    }
    putValue(result, name, dest, end, value, length, first);

    if (value != dollarAt &&
        value != dollarDollarAt &&
        value != dollarLessThan &&
        (value < nameBuf || value >= nameBuf + MAXNAME)
       )
        FREE(value);
}


//  modifySpecialValue -- alter path name according to modifier
//
// Scope:   Local.
//
// Purpose:
//  The dynamic macros of NMAKE have modifiers F,B,D & R. This routine does the
//  job of producing a modified special value for a given filename.
//
// Input:
//  c        -- determines the type of modification (modifier is one of F,B,D & R
//  buf      -- location for storing modified value
//  value    -- The path specification to be modified
//
// Output:  Returns a pointer to the modified value
//
// Assumes: That initially buf pointed to previously allocated memory of size MAXNAME.
//
// Notes:
//  Given a path specification of the type "<drive:><path><filename><.ext>", the
//  modifiers F,B,D and R stand for following --
//   F - <filename><.ext>     - actual Filename
//   B - <filename>         - Base filename
//   D - <drive:><path>         - Directory
//   R - <drive:><path><filename> - Real filename (filename without extension)
//  This routine handles OS/2 1.20 filenames as well. The last period in the
//  path specification is the start of the extension. When directory part is null
//  the function returns '.' for current directory.
//
//  This function now handles quoted filenames too

char *
modifySpecialValue(
    char c,
    char *buf,
    char *value
    )
{
    char *lastSlash,                    // last path separator from "\\/"
     *extension;                        // points to the extension
    char *saveBuf;
    BOOL fQuoted;

    lastSlash = extension = NULL;
    saveBuf=buf;
    _tcscpy(buf, value);
    fQuoted = (BOOL) (buf[0] == '"');
    value = buf + _tcslen(buf) - 1;     // start from the end of pathname
    for (;value >= buf; value--) {
        if (PATH_SEPARATOR(*value)) {   // scan upto first path separator
            lastSlash = value;
            break;
        } else
        if (*value == '.' && !extension) //last '.' is extension
            extension = value;
    }

    switch(c) {
        case 'D':
            if (lastSlash) {
                if (buf[1] == ':' && lastSlash == buf + 2)
                    ++lastSlash;        // 'd:\foo.obj' --> 'd:\'
                *lastSlash = '\0';
            } else if (buf[1] == ':')
                buf[2] = '\0';          // 'd:foo.obj'  --> 'd:'
            else
                _tcscpy(buf, ".");      // 'foo.obj'    --> '.'
            break;

        case 'B':
            if (extension)              // for 'B' extension is clobbered
                *extension = '\0';

        case 'F':
            if (lastSlash)
                buf = lastSlash + 1;
            else if (buf[1] == ':')     // 'd:foo.obj'  --> foo     for B
                buf+=2;                 // 'd:foo.obj'  --> foo.obj for F
          break;

        case 'R':
            if (extension)
                *extension = '\0';      // extension clobbered
    }

    if (fQuoted) {                      // [fabriced] make sure we have quotes
        char *pEnd;                     // at both ends
        if(*buf!='"' && buf>saveBuf) { // make sure we can go back one char
            buf--;
            *buf='"';
        }
        pEnd = _tcschr(buf, '\0');
        if(*(pEnd-1)!='"') {
            *pEnd++ =  '"';
            *pEnd = '\0';
        }
    }
    return(buf);
}


// putValue -- store expanded macro's value in dest and advance past it
//
//  arguments:  result    ppointer to start of string being expanded
//              name      ppointer to macro name being expanded
//              dest      ppointer to place to store expanded value
//              end       ppointer to end of dest's buffer
//              source    pointer to text of expanded macro
//              length    pointer to amount by which to increase dest's buffer
//              first     address of initial stack buffer
//
//  actions:    if there is a substitution, call substituteStrings to do it
//              else copy source text into dest
//                advance *name past end of macro's invocation
//
// already did error checking in lexer

void
putValue(
    char **result,
    char **name,
    char **dest,
    char **end,
    char *source,
    unsigned *length,
    char *first
    )
{
    char *s;
    char *t;                            // temporary pointer

    if (*++*name == ESCH)
        ++*name;                        // go past $ & ESCH if any
    s = _tcschr(*name, ':');
    for (t = *name; *t && *t != ')'; t++)   // go find first non-escaped )
        if (*t == ESCH)
            t++;
    if ((**name == '(')                 // substitute only if there is
        && s                            // a : before a non-escaped )
        && (s < t)
       ) {
        substituteStrings(result, &s, dest, end, source, length, first);
        *name = s;
    } else {
        for (; *source; *(*dest)++ = *source++)     // copy source into dest
            if (*dest == *end)
                increaseBuffer(result, dest, end, length, first);

        if (**name == '$')
            ++*name;                    // go past $$
        if (**name == '(')              // advance from ( to )
            while (*++*name != ')');
        else
            if (**name == '*' && *(*name + 1) == '*')
                ++*name;   // skip $**

        ++*name;                        // move all the way past
    }
}


// substituteStrings -- perform macro substitution
//
// arguments:  result  ppointer to start of string being expanded
//             name    ppointer to macro name being expanded
//             dest    ppointer to place to store substituted value
//             end     ppointer to end of dest's buffer
//             source  pointer to text of expanded macro (before sub.)
//             length  pointer to amount by which to increase dest's buffer
//             first   address of initial stack buffer
//
// changes: [SB]
//   old, new now dynamically allocated; saves memory; 3 errors detected
//   for macro syntax in script files.
//
// note: [SB]
//   we could use lexer routines recursively if we get rid of the globals
//   and then these errors needn't be flagged. [?]
//
// actions:    store text to convert from in old
//             store text to convert to in new
//             scan source text
//             when a match is found, copy new text into dest &
//              skip over old text
//             else copy one character from source text into dest
//
// returns:    nothing

void
substituteStrings(
    char **result,
    char **name,
    char **dest,
    char **end,
    char *source,
    unsigned *length,
    char *first
    )
{
    char *oldString, *newString;
    char *pEq, *pPar, *t;
    char *s;
    size_t i;

    ++*name;
    for (pEq = *name; *pEq && *pEq != '='; pEq++)
        if (*pEq == ESCH)
            pEq++;

    if (*pEq != '=')
        makeError(line, SYNTAX_NO_EQUALS);

    if (pEq == *name)
        makeError(line, SYNTAX_NO_SEQUENCE);

    for (pPar = pEq; *pPar && *pPar != ')'; pPar++)
        if (*pPar == ESCH)
            pPar++;

    if (*pPar != ')')
        makeError(line, SYNTAX_NO_PAREN);

    oldString = (char *) allocate((size_t) ((pEq - *name) + 1));
    for (s = oldString, t = *name; *t != '='; *s++ = *t++)
        if (*t == ESCH)
            ++t;

    *s = '\0';
    i = _tcslen(oldString);
    newString = (char *) allocate((size_t) (pPar - pEq));
    for (s = newString, t++; *t != ')'; *s++ = *t++)
        if (*t == ESCH)
            ++t;

    *s = '\0';
    *name = pPar + 1;
    while (*source) {
        if ((*source == *oldString)                     // check for match
            && !_tcsncmp(source, oldString, i)) {       // copy new in for
            for (s = newString; *s; *(*dest)++ = *s++)  //  old string
                if (*dest == *end)
                    increaseBuffer(result, dest, end, length, first);
            source += i;
            continue;
        }
        if (*dest == *end)
            increaseBuffer(result, dest, end, length, first);
        *(*dest)++ = *source++;         // else copy 1 char
    }
    FREE(oldString);
    FREE(newString);
}

//  prependPath -- prepend the path from pszWildcard to pszFilename
//
// Scope:   Global.
//
// Purpose:
//  This function is called to first extract the path (drive & dir parts) from
//  pszWildcard, the prepend that path to pszFilename.  The result string is
//  a reconstruction of the full pathname.  Normally, the pszWildcard parameter
//  is the same as the first parameter supplied to findFirst(), and pszFilename
//  is what returned by findFirst/findNext.
//
// Input:
//  pszWildcard -- Same as the first parameter supplied to findFirst()
//  pszFilename -- Same as the return value of findFirst/FindNext()
//
// Output:
//  Return the reconstructed full pathname.  The user must be responsible to
//  free up the memory allocated by this string.
//
// Assumes:
//  Since pszWildcard, the first parameter to findFirst() must include a filename
//  part; this is what I assume.  If the filename part is missing, then
//  _splitpath will mistaken the directory part of pszWildcard as the filename
//   part and things will be very ugly.
//
// History:
//  08-Apr-1993 HV Rewrite prependPath() to use _splitpath() and _makepath()

char *
prependPath(
    const char *pszWildcard,
    const char *pszFilename
    )
{
    // The following are the components when breaking up pszWildcard
    char  szDrive[_MAX_DRIVE];
    char  szDir[_MAX_DIR];

    // The following are the resulting full pathname.
    char  szPath[_MAX_PATH];
    char *pszResultPath;

    // First break up the pszWildcard, throwing away the filename and the
    // extension parts.
    _splitpath(pszWildcard, szDrive, szDir, NULL, NULL);

    // Then, glue the drive & dir components of pszWildcard to pszFilename
    _makepath(szPath, szDrive, szDir, pszFilename, NULL);

    // Make a copy of the resulting string and return it.
    pszResultPath = makeString(szPath);
    return (pszResultPath);
}


//  isRule -- examines a string to determine whether it's a rule definition
//
// arguments:    s   string to examine for rule-ness
//
// actions:    assume it's not a rule
//       skip past first brace pair (if any)
//       if next character is a period,
//       look for next brace
//       if there are no path separators between second brace pair,
//           and there's just a suffix after them, it's a rule
//       else if there's another period later on, and no path seps
//           after it, then it's a rule.
//
// returns:    TRUE if it's a rule, FALSE otherwise.

BOOL
isRule(
    char *s
    )
{
    char *t = s, *u;
    BOOL result = FALSE;

    if (*t == '{') {                        // 1st char is {, so
        while (*++t && *t != '}')           //  we skip over rest
            if (*t == ESCH)
                ++t;
        if (*t)
            ++t;                            //  of path (no error
    }                                       //  checking)

    if (*t == '.') {
        for (u = t; *u && *u != '{'; ++u)   // find first non-escaped {
            if (*u == ESCH)
                ++u;
        s = t;
        while (t < u) {                     // look for path seps.
            if (PATH_SEPARATOR(*t))
                break;                      // if we find any, it's
            ++t;                            // not a rule (they
        }                                   // can't be in suffix)
        if (*u && (t == u)) {               // if not at end & no path sep
            while (*++u && *u != '}')       // find first non-esc }
                if (*u == ESCH)
                    ++u;
            if (*u) {
                ++u;
                if (*u == '.'                   // if you find it, with . just
                    && !_tcschr(u+1, '/' )      // next to it & no path seps.,
                    && !_tcschr(u+1, '\\'))     // it's a rule
                    if (_tcschr(u+1, '.'))      // too many suffixes
                        makeError(currentLine, TOO_MANY_RULE_NAMES);
                    else
                        result = TRUE;
            }
        } else if (((u = _tcspbrk(s+1, "./\\")) && (*u == '.'))
                 && !_tcschr(u+1, '/')
                 && !_tcschr(u+1, '\\'))
            if (_tcschr(u+1, '.'))             // too many suffixes
                makeError(currentLine, TOO_MANY_RULE_NAMES);
            else
                result = TRUE;
    }
    return(result);
}

// ZFormat - extmake syntax worker routine.
//
// pStr    destination string where formatted result is placed.
// fmt     formatting string. The valid extmake syntax is ...
//           %%        is always %
//           %s        is the first dependent filename
//           %|<dpfe>F    is the appropriate portion out of %s
//              d    drive
//           p    path
//           f    filename
//           e    extension
//           %|F     same as %s
//       One needn't escape a %, unless it is a valid extmake syntax
// pFirstDep    is the dependent filename used for expansion

BOOL
ZFormat(
    char *pStr,
    unsigned limit,
    char *fmt,
    char *pFirstDep
    )
{
    char c;
    char *pEnd = pStr + limit;
    char *s;
    BOOL fError;
    BOOL fDrive;
    BOOL fPath;
    BOOL fFilename;
    BOOL fExtension;
    char L_buf[_MAX_PATH];

    for (; (c = *fmt) && (pStr < pEnd); fmt++) {
        if (c != '%') {
            *pStr++ = c;
        } else {
            switch (*++fmt) {
                case '%':        // '%%' -> '%'
                    *pStr++ = '%';
                    break;

                case 's':
                    for (s = pFirstDep; s && *s && pStr < pEnd; *pStr++ = *s++)
                        ;
                    break;

                case '|':
                    s = fmt-1;
                    fError = fDrive = fPath = fFilename = fExtension = FALSE;
                    *L_buf = '\0';
                    do {
                        switch (*++fmt) {
                            case 'd':
                                fDrive = TRUE;
                                break;

                            case 'p':
                                fPath = TRUE;
                                break;

                            case 'f':
                                fFilename = TRUE;
                                break;

                            case 'e':
                                fExtension = TRUE;
                                break;

                            case 'F':
                                if (fmt[-1] == '|') {
                                    fDrive = TRUE;
                                    fPath = TRUE;
                                    fFilename = TRUE;
                                    fExtension = TRUE;
                                }
                                break;

                            case '\0':
                                // backtrack, so that we don't read past
                                // the end of the string in the for loop
                                // [msdev96 #4057]
                                fmt--;
                                // fall trhough

                            default :
                                fError = TRUE;
                                break;
                        }

                        if (fError) {
                            break;
                        }
                    } while (*fmt != 'F');

                    if (fError) {
                        for (; s <= fmt && pStr < pEnd; *pStr++ = *s++)
                            ;
                        break;
                    }

                    if (!pFirstDep) {
                        makeError(0, EXTMAKE_NO_FILENAME);
                    }

                    if (fDrive) {
                        drive(pFirstDep, L_buf);
                    }

                    if (fPath) {
                        path(pFirstDep, strend(L_buf));
                    }

                    if (fFilename) {
                        filenamepart(pFirstDep, strend(L_buf));
                    }

                    if (fExtension) {
                        extension(pFirstDep, strend(L_buf));
                    }

                    for (s = L_buf; *s && pStr < pEnd; *pStr++ = *s++)
                        ;
                    break;

                case '\0':
                    // backtrack, so that we don't read past
                    // the end of the string in the for loop
                    // [msdev96 #4057]
                    fmt--;
                    // *pStr++ = '%';
                    break;


                default:
                    *pStr++ = '%';
                    if (pStr == pEnd) {
                        return(TRUE);
                    }
                    *pStr++ = *fmt;
                    break;
            }
        }
    }

    if (pStr < pEnd) {
        *pStr = '\0';
        return(FALSE);
    }

    return(TRUE);
}

void
expandExtmake(
    char *buf,
    char *fmt,
    char *pFirstDep
    )
{
    if (ZFormat(buf, MAXCMDLINELENGTH, fmt, pFirstDep))
        makeError(0, COMMAND_TOO_LONG, fmt);
}


//  drive -- copy a drive from source to dest if present
//
// Scope:   Local.
//
// Purpose: copy a drive from source to dest if present, return TRUE if we found one
//
// Input:
//  const char *src -- The full path to extract the drive from.
//  char *dst       -- The buffer to copy the drive to, must be alloc'd before.
//
// Output:  Return TRUE if a drive part is found, else return FALSE.
//
// Assumes:
//  1. src is a legal pathname.
//  2. src does not contain network path (i.e. \\foo\bar)
//  3. The buffer dst is large enough to contain the result.
//  4. src does not contain quote since _splitpath() treat quotes a normal char.
//
// History:
//  31-Mar-1993 HV Rewrite drive(), path(), filenamepart(), and extension() to use
//          _splitpath() instead of parsing the pathname by itself.

int
drive(
    const char *src,
    char *dst
    )
{
    _splitpath(src, dst, NULL, NULL, NULL);
    return (0 != _tcslen(dst));
}


//  extension -- copy a extension from source to dest if present
//
// Scope:   Local.
//
// Purpose: copy a drive from source to dest if present, return TRUE if we found one
//
// Input:
//  const char *src -- The full path to extract the extension from.
//  char *dst       -- The buffer to copy the extension to.
//
// Output:  Return TRUE if a extension part is found, else return FALSE.
//
// Assumes:
//  1. src is a legal pathname.
//  2. src does not contain network path (i.e. \\foo\bar)
//  3. The buffer dst is large enough to contain the result.
//  4. src does not contain quote since _splitpath() treat quotes a normal char.
//
// History:
//  31-Mar-1993 HV Rewrite drive(), path(), filenamepart(), and extension() to use
//          _splitpath() instead of parsing the pathname by itself.

int
extension(
    const char *src,
    char *dst
    )
{
    _splitpath(src, NULL, NULL, NULL, dst);
    return (0 != _tcslen(dst));
}


//  filename -- copy a filename from source to dest if present
//
// Scope:   Local.
//
// Purpose: copy a filename from source to dest if present, return TRUE if we found one
//
// Input:
//  const char *src -- The full path to extract the filename from.
//  char *dst       -- The buffer to copy the filename to.
//
// Output:  Return TRUE if a filename part is found, else return FALSE.
//
// Assumes:
//  1. src is a legal pathname.
//  2. src does not contain network path (i.e. \\foo\bar)
//  3. The buffer dst is large enough to contain the result.
//  4. src does not contain quote since _splitpath() treat quotes a normal char.
//
// Notes:
//  BUGBUG: (posible) when src == '..' --> dst = '.', src == '.', dst = ''
//          This is the way _splitpath works.
//
// History:
//  31-Mar-1993 HV Rewrite drive(), path(), filenamepart(), and extension() to use
//          _splitpath() instead of parsing the pathname by itself.

int
filenamepart(
    const char *src,
    char *dst
    )
{
    _splitpath(src, NULL, NULL, dst, NULL);
    return (0 != _tcslen(dst));
}


//  path -- copy a path from source to dest if present
//
// Scope:   Local.
//
// Purpose: copy a path from source to dest if present, return TRUE if we found one
//
// Input:
//  const char *src -- The full path to extract the path from.
//  char *dst       -- The buffer to copy the path to.
//
// Output:  Return TRUE if a path part is found, else return FALSE.
//
// Assumes:
//  1. src is a legal pathname.
//  2. src does not contain network path (i.e. \\foo\bar)
//  3. The buffer dst is large enough to contain the result.
//  4. src does not contain quote since _splitpath() treat quotes a normal char.
//
// History:
//  31-Mar-1993 HV Rewrite drive(), path(), filenamepart(), and extension() to use
//          _splitpath() instead of parsing the pathname by itself.

int
path(
    const char *src,
    char *dst
    )
{
    _splitpath(src, NULL, dst, NULL, NULL);
    return (0 != _tcslen(dst));
}


STRINGLIST *
searchBucket(
    char *string,
    STRINGLIST *table[],
    unsigned hash
    )
{
    char *s, *t;
    STRINGLIST *p;

    for (p = table[hash]; p; p = p->next) {
#if defined(STATISTICS)
        CnttargetChains++;
#endif
        for (s = string, t = p->text; *s && *t; s++, t++) {
            if (*s == '\\' || *s == '/')            // / == \ in targets
                if (*t == '\\' || *t == '/')
                    continue;
                else
                    break;
            else if (_totupper(*s) == _totupper(*t))    // lc == UC
                continue;
            else
                break;
        }
        if (!*s && !*t)
            return(p);
    }
    return(NULL);
}


int
strcmpiquote(
    char *str1,
    char *str2
    )
{
    int rc;
    char *s1, *s2;
    char *t;

#if defined(STATISTICS)
    CntStriCmp++;
#endif
    s1 = (char *) malloc(_tcslen(str1) + 1);
    if (!s1) {
        makeError(0, OUT_OF_MEMORY);
        return 0;
    } 
    s2 = (char *) malloc(_tcslen(str2) + 1);
    if (!s2) {
        makeError(0, OUT_OF_MEMORY);
        return 0;
    }

    if (*str1 == '"')
        str1++;
    for (t = s1;*str1;*t++=*str1++)
        ;
    if (t[-1] == '"')
        t--;
    *t = '\0';

    if (*str2 == '"')
        str2++;
    for (t = s2;*str2;*t++=*str2++)
        ;
    if (t[-1] == '"')
        t--;
    *t = '\0';

    rc = _tcsicmp(s1, s2);
    free(s1);
    free(s2);
    return(rc);
}


// Remove quotes from a string, if any
// Returns a copy of the string
// Note that there may be quotes at the start, the end or either side.

char *
unQuote(
    char *str
    )
{
    char *s = (char *) rallocate(_tcslen(str) + 1);
    char *t;

#if defined(STATISTICS)
    CntunQuotes++;
#endif

    if (*str == '"') {
        str++;
    }
    for (t = s;*str;*t++=*str++)
        ;
    if (t[-1] == '"') {
        t--;
    }
    *t = '\0';
    return(s);
}


FILE *
open_file(
    char *name,
    char *mode
    )
{
    // If name contains Quotes, remove these before opening the file
    if (*name == '"') {
        *(_tcsrchr(name, '"')) = '\0';
        _tcscpy(name, name+1);
    }

    // Allow sharing between makes running at the same time

    return(_fsopen(name, mode, _SH_DENYWR));
}


//  TruncateString -- Truncate a string to certain size, take care of MBCS
//
// Scope:   GLOBAL.
//
// Purpose:
//  Since an MBCS string can mix double-byte & single-byte characters, simply
//  truncating the string by terminate it with a NULL byte won't work.
//  TruncateString will make sure that the string is cut off at the character
//  boundary.
//
// Input:
//  pszString    -- The string to be truncated.
//  uLen         -- The length to truncate.  The final string's length might be
//                   less than this be cause of double-byte character.
//
// Output:  pszString    -- The truncated string.
//
// History:
//  03-Jun-1993 HV Add helper local function TruncateString for findFirst.

void
TruncateString(
    char *pszString,
    unsigned uLen
    )
{
    char *pEnd = pszString;     // Points to the end of the string
    unsigned cByte;             // Number of bytes to advance depend on lead
                                // byte or not

    // Loop to get to the end of the string, exit only when we have exhausted
    // the string, or when the length limit is reached.
    while(*pEnd) {
        // If the the character is a lead byte, advance 2 bytes,
        // else, just advance 1 byte.
#ifdef _MBCS
    cByte = _ismbblead(*pEnd) ? 2 : 1;
#else
    cByte = 1;
#endif
        // If we hit the limit by advancing, stop now.
        if (pEnd - pszString + cByte > uLen) {
            *pEnd = '\0';    // Truncate it.
            break;
        }

        // Otherwise, advance the pointer to the next character (not byte)
        pEnd += cByte;
    }
}

// IsValidMakefile - Checks if the makefile is in plain ascii text format.
//
// Scope:   GLOBAL.
//
// Purpose:
//  We don't want to open UTF8 or unicode makefiles, only to report an
//  error at some random place in the makefile.
//
// Input:
//  file         -- File pointer.
//
// Output:       -- Returns FALSE if in UTF8 or Unicode format
//
// History:

BOOL IsValidMakefile(FILE *fp)
{
    const char sigUTF8[] = { '\xef', '\xbb', '\xbf' };
    const char sigUnicode[] = { '\xff', '\xfe' };
    char sig[4];
    const unsigned int len = sizeof sig;
    BOOL fResult = fp != NULL;

    if (fp != NULL && fread(sig, len, 1, fp)) {
        fResult = memcmp(sig, sigUTF8, __min(len, sizeof sigUTF8))
               && memcmp(sig, sigUnicode, __min(len, sizeof sigUnicode));
    }

    if (fseek(fp, 0, SEEK_SET) == -1) {
        return FALSE;
    } else {
        return fResult;
    }
}


// OpenValidateMakefile - Open a makefile, only if it's valid.
//
// Scope:   GLOBAL.
//
// Purpose:
//  We don't want to open UTF8 or unicode makefiles, only to report an
//  error at some random place in the makefile.
//
// Input:
//  file         -- File pointer.
//
// Output:       -- Returns FALSE if in UTF8 or Unicode format
//
// History:


FILE *OpenValidateMakefile(char *name,char *mode)
{
    FILE *fp = open_file(name, mode);

    if (fp != NULL && !IsValidMakefile(fp))
    {
        fclose(fp);
        makeError(0, CANT_SUPPORT_UNICODE, 0);
    }

    return fp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ntrelhash\fastfilehash.cpp ===
// (c) 2002 Microsoft Corporation
// [jorgeba] Jorge Peraza

#include "StdAfx.h"
#include "fastfilehash.h"


CFastFileHash::CFastFileHash(void):m_hFile(0),m_iFileSize(0)
{
}

CFastFileHash::~CFastFileHash(void)
{
}

__int32* CFastFileHash::getHash(TCHAR *sFileName)
{
	__int32* iHash = NULL;	

	if(sFileName==NULL)
	{
		return NULL;
	}
	
	if(!openFile(sFileName))
	{
		return NULL;
	}
	
	iHash = calcHash();

	CloseHandle(m_hFile);

	return iHash;
}

int CFastFileHash::openFile(TCHAR *sFileName)
{
	m_hFile = CreateFile(sFileName,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_ALWAYS,0,NULL);
	
	if(m_hFile==INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

__int32* CFastFileHash::calcHash()
{	
	int iFlag = 0;
	int iNdx = 0;
	int iNumOfParts = 0;
	char bFilePart[PART_SIZE];
	__int32* piRes = NULL;


	//Clear common vars
	m_iFileSize = 0;

	//Create the memory for the hash
	piRes = new __int32[5];
	if(piRes==NULL)
	{
		return NULL;
	}
	memset(piRes,0,sizeof(__int32)*5);

	//First, get the size of the file		
	m_iFileSize = GetFileSize(m_hFile,NULL);
	
	iNumOfParts = m_iFileSize / PART_SIZE;

	
	

	//Fill the parts buffer
	for(iNdx=0;iNdx<MAX_PARTS;iNdx++)
	{
		//Clear the buffer
		memset(bFilePart,0,PART_SIZE);
		if(iFlag!=1)
		{
			if(!getPart(bFilePart,iNdx))
			{
				iFlag = 1;				
			}
			else
			{
				doHash(piRes,bFilePart);
			}
		}
	}

	//Fill the last block with m_iFileSize
	memset(bFilePart,0,PART_SIZE);
	memcpy(bFilePart,&m_iFileSize,sizeof(m_iFileSize));	
	doHash(piRes,bFilePart);

	return piRes;
}

int CFastFileHash::getPart(char* pBuffer,int iPart)
{
	int hRes = FALSE;
	DWORD iBytes;

	hRes = ReadFile(m_hFile,pBuffer,PART_SIZE,(LPDWORD) &iBytes,NULL);

	return hRes;
}

void CFastFileHash::doHash(__int32* piHash,char* pBuffer)
{
	for(int iNdx=0;iNdx<5;iNdx++)
	{
		piHash[iNdx] = piHash[iNdx] ^ *((__int32*)pBuffer + iNdx);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\version.h ===
#define rmj             7
#define rmm             0
#define rup             8882
#define szVerName       ""
#define szVerUser       "BryanT2"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ntrelhash\fastfilehash.h ===
#pragma once

const int PART_SIZE = 20;
const int MAX_PARTS = 10;

class IFileHash
{
public:
	virtual __int32* getHash(TCHAR *sFileName) = 0;
};


class CFastFileHash :
	public IFileHash
{
private:
	HANDLE m_hFile;
	__int32 m_iFileSize;
	int openFile(TCHAR *sFileName);
	int getPart(char* pBuffer,int iPart);
	void doHash(__int32* piHash,char* pBuffer);
public:
	CFastFileHash(void);
	~CFastFileHash(void);
	__int32* getHash(TCHAR *sFileName);
	__int32* calcHash();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\win32.cpp ===
#include "precomp.h"
#pragma hdrstop

#include "windows.h"

#ifdef _M_IX86

UCHAR
FIsChicago(void)
{
    DWORD dw;

    dw = GetVersion();

    // Test the "win32s" bit

    if ((dw & 0x80000000) == 0) {
        // If Win32s bit not set, it's Windows NT.

        return 0;
    }

    if (LOBYTE(dw) < 4) {
        // Win32s version 3 is really Win32s. There
        // won't ever be a real Win32s version 4.

        return 0;
    }

    // Yep.  It is really Chicago

    return 1;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\verstamp.h ===
#include "version.h"				   /* SLM maintained version file */

#if defined(_WIN32) || defined(WIN32)
#include <winver.h>
#else	/* !WIN32 */
#include <ver.h>
#endif	/* !WIN32 */

#if 	(rmm < 10)
#define rmmpad "0"
#else
#define rmmpad
#endif

#if 	(rup == 0)

#define VERSION_STR1(a,b,c) 		#a "." rmmpad #b

#else	/* !(rup == 0) */

#define VERSION_STR1(a,b,c) 		#a "." rmmpad #b "." ruppad #c

#if 	(rup < 10)
#define ruppad "000"
#elif	(rup < 100)
#define ruppad "00"
#elif	(rup < 1000)
#define ruppad "0"
#else
#define ruppad
#endif

#endif	/* !(rup == 0) */

#define VERSION_STR2(a,b,c) 		VERSION_STR1(a,b,c)
#define VER_PRODUCTVERSION_STR		VERSION_STR2(rmj,rmm,rup)
#define VER_PRODUCTVERSION			rmj,rmm,0,rup

/*--------------------------------------------------------------*/
/* the following section defines values used in the version 	*/
/* data structure for all files, and which do not change.		*/
/*--------------------------------------------------------------*/

#if defined(_SHIP)
#define VER_DEBUG					0
#else
#define VER_DEBUG					VS_FF_DEBUG
#endif

#if defined(_SHIP)
#define VER_PRIVATEBUILD			0
#else
#define VER_PRIVATEBUILD			VS_FF_PRIVATEBUILD
#endif

#if defined(_SHIP)
#define VER_PRERELEASE				0
#else
#define VER_PRERELEASE				VS_FF_PRERELEASE
#endif

#define VER_FILEFLAGSMASK			VS_FFI_FILEFLAGSMASK
#if defined(_WIN32) || defined(WIN32)
#define VER_FILEOS					VOS__WINDOWS32
#else
#define VER_FILEOS					VOS_DOS_WINDOWS16
#endif
#define VER_FILEFLAGS				(VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR 		"Microsoft Corporation"
#define VER_PRODUCTNAME_STR		"Microsoft (R) Developer Studio"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ntrelhash\ntrelhash.cpp ===
// NtRelHash.cpp : Mini hash for the NT code base builds
// (c) 2002 Microsoft Corporation
// [jorgeba] Jorge Peraza
//

#include "stdafx.h"
#include "fastfilehash.h"

using namespace ::std;

__int32* getReleaseHash(TCHAR *sDir,TCHAR *sFiles, IFileHash* oHashGen);
char* hashManifest(__int32 *piHash);


//Entry point for tge application
int __cdecl main(int argc, char* argv[])
{
	CFastFileHash * oHashGen = new CFastFileHash();
	TCHAR sDir[MAX_PATH];

	//Check for the required arguments
	if(argc<2)
	{
		return 0;
	}

	//Covert the input to Unicode
	if(MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,argv[1],strlen(argv[1])+1,sDir,MAX_PATH-1)==0)
	{
		return 0;
	}
	
	//Generate the hash
	if(oHashGen!=NULL)
	{
		getReleaseHash(sDir,_T("nt*"),(IFileHash*) oHashGen);
		delete oHashGen;
	}	

	return 0;
}

// Generate the release hash,
__int32* getReleaseHash(TCHAR *sDir,TCHAR *sFiles, IFileHash* oHashGen)
{
	//You'll see __int32 a lot, this is required to make this work with thw windows 64 platform
	HANDLE hSearch;
	WIN32_FIND_DATA FindFileData;
	TCHAR sFileName[MAX_PATH];
	TCHAR *sSearchStr = NULL;
	char* pcManifest = NULL;
	int iChars = 0;
	__int32 *piHash;
	__int32 piCombHash[5];

	if((sDir==NULL)||(sFiles==NULL)||(oHashGen==NULL))
	{
		return NULL;
	}

	//Generate the search string
	iChars = _tcslen(sDir);
	iChars += _tcslen(sFiles);

	sSearchStr = new TCHAR[iChars+1];

	if(sSearchStr==NULL)
	{
		return NULL;
	}

	_stprintf(sSearchStr,_T("%s%s"),sDir,sFiles);
	
	
	//Find the first file in the release directory
	hSearch = FindFirstFile(sSearchStr,  &FindFileData );

	delete[] sSearchStr;

	memset(piCombHash,0,sizeof(__int32)*5);
	//Calculate the release hash
	do
	{
		if(!(FindFileData.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY))
		{
			_stprintf(sFileName,_T("%s%s"),sDir,FindFileData.cFileName);					
			piHash = oHashGen->getHash(sFileName);
			if(piHash!=NULL)
			{
				for(int iNdx  = 0;iNdx < 5;iNdx++)
				{
					piCombHash[iNdx] = piCombHash[iNdx] ^ piHash[iNdx];									}					
								
				delete[] piHash;				
			}
			
		}
	}
	while(FindNextFile(hSearch,&FindFileData));

	//Generate the Manifest for the hash (Digital signature)
	pcManifest = hashManifest(piCombHash);
	
	cout << pcManifest;
	
	delete[] pcManifest;
	return NULL;
}

char* hashManifest(__int32 *piHash)
{
	char* pcManifest = NULL;
	char cTemp;

	//Create the Manifest string 
	pcManifest = new char[41];
	if(pcManifest==NULL)
	{
		return NULL;
	}	

	for(int iNdx=0;iNdx<5;iNdx++)
	{
		for(int iNdj=0;iNdj<8;iNdj+=2)
		{
			memcpy(&cTemp,((char*)piHash+(iNdx*4)+(iNdj/2)),1);			 
			pcManifest[(iNdx*8)+iNdj]  =  0x40 | ((cTemp>>4)&0x0f);
			pcManifest[(iNdx*8)+iNdj+1]= 0x40 | (cTemp&0x0f);
		}
	}

	pcManifest[40] = 0;
		
	return pcManifest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nmake\utilp.cpp ===
//  UTILB.C -- Data structure manipulation functions specific to OS/2
//
// Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This file was created from functions in util.c & esetdrv.c which were system
//  dependent. This was done so that the build of the project became simpler and
//  there was a clear flow in the build process.
//
// Method of Creation:
//  1. Identified all functions having mixed mode code.
//  2. Deleted all code blocked out by '#ifndef BOUND' preprocessor directives
//     in these functions
//  3. Deleted all local function & their prototypes not referred by these
//  4. Deleted all global data unreferenced by these, including data blocked
//     of by '#ifdef DEBUG'
//
// Revision History:
//  21-Feb-1994 HV  Get rid of _alloca in findFirst: it confuses the compiler's
//                  backend scheduler (PhilLu).
//  15-Nov-1993 JdR Major speed improvements
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  15-Jun-1993 HV  No longer display warning about filenames being longer than
//                  8.3.  Decision made by EmerickF, see Ikura bug #86 for more
//                  details.
//  03-Jun-1993 HV  Fixed findFirst's pathname truncation (Ikura bug #86)
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  08-Jun-1992 SS  Port to DOSX32
//  10-Apr-1990 SB  removed if _osmode stuff, not needed in protect only version.
//  04-Dec-1989 SB  removed unreferenced local variables in findFirst()
//  01-Dec-1989 SB  changed a remaining free() to FREE(); now FREE()'ing all
//                  allocated stuff from findFirst() on exit
//  22-Nov-1989 SB  Add #ifdef DEBUG_FIND to debug FIND_FIRST, etc.
//  13-Nov-1989 SB  Define INCL_NOPM to exclude <pm.h>
//  19-Oct-1989 SB  findFirst() and findNext() get extra parameter
//  08-Oct-1989 SB  remove quotes around a name before making system call
//  02-Oct-1989 SB  setdrive() proto change
//  04-Sep-1989 SB  Add DOSFINDCLOSE calls is findFirst and QueryFileInfo
//  05-Jul-1989 SB  add curTime() to get current time. (C Runtime function
//                  differs from DOS time and so time() is no good
//  05-Jun-1989 SB  call DosFindClose if DosFindNext returns an error
//  28-May-1989 SB  Add getCurDir() to initialize MAKEDIR macro
//  24-Apr-1989 SB  made FILEINFO a thing of the past. Replace by void *
//                  added OS/2 ver 1.2 support
//  05-Apr-1989 SB  made all funcs NEAR; Reqd to make all function calls NEAR
//  09-Mar-1989 SB  Added function QueryFileInfo() because DosFindFirst has FAPI
//                  restrictions. ResultBuf was being allocated on the heap but
//                  not being freed. This saves about 36 bytes for every call to
//                  findAFile i.e. to findFirst(), findNext() or expandWildCards
//  09-Nov-1988 SB  Created

#include "precomp.h"
#pragma hdrstop

#include <io.h>
#include <direct.h>
#include <time.h>

STRINGLIST *
expandWildCards(
    char *s                             // text to expand
    )
{
    struct _finddata_t finddata;
    NMHANDLE searchHandle;
    STRINGLIST *xlist,                  // list of expanded names
               *p;
    char *namestr;

    if (!(namestr = findFirst(s, &finddata, &searchHandle))) {
        return(NULL);
    }

    xlist = makeNewStrListElement();
    xlist->text = prependPath(s, namestr);

    while (namestr = findNext(&finddata, searchHandle)) {
        p = makeNewStrListElement();
        p->text = prependPath(s, namestr);
        prependItem(&xlist, p);
    }

    return(xlist);
}


//  QueryFileInfo -- it does a DosFindFirst which circumvents FAPI restrictions
//
// Scope:   Global (used by Build.c also)
//
// Purpose:
//  DosFindFirst() has a FAPI restriction in Real mode. You cannot ask it give
//  you a handle to a DTA structure other than the default handle. This function
//  calls C Library Function _dos_findfirst in real mode (which sets the DTA) and
//  does the job. In protect mode it asks OS/2 for a new handle.
//
// Input:
//  file -- the file to be searched for
//  dta  -- the struct containing result of the search
//
// Output:  Returns a pointer to the filename found (if any)
//
// Assumes: That dta points to a structure which has been allocated enough memory
//
// Uses Globals:
//  _osmode --  to determine whether in Real or Bound mode

char *
QueryFileInfo(
    char *file,
    void **dta
    )
{
    NMHANDLE  hDir;
    char *t;

    // Remove Quotes around filename, if existing
    t = file + _tcslen(file) - 1;
    if (*file == '"' && *t == '"') {
        file = unQuote(file);           // file is quoted, so remove quote
    }

#if defined(DEBUG_FIND)
    printf("QueryFileInfo file: %s\n", file);
#endif

    if ((hDir = _findfirst(file, (struct _finddata_t *) dta)) == -1) {
        return(NULL);
    }

    _findclose(hDir);

    return(((struct _finddata_t *) dta)->name);
}


//
// Truncate filename to system limits
//
void
truncateFilename(
    char * s
    )
{
    char szDrive[_MAX_DRIVE];
    char szDir[_MAX_DIR];
    char szName[_MAX_FNAME];
    char szExtension[_MAX_EXT];

    // Ikura bug #86: pathname incorrectly truncated.  Solution: first parse it
    // using _splitpath(), then truncate the filename and extension part.
    // Finally reconstruct the pathname by calling _makepath().

    _splitpath(s, szDrive, szDir, szName, szExtension);
    _makepath(s, szDrive, szDir, szName, szExtension);
}


char *
findFirst(
    char *s,                            // text to expand
    void *dta,
    NMHANDLE *dirHandle
    )
{
    BOOL anyspecial;                   // flag set if s contains special characters.
    char L_buf[_MAX_PATH];               // buffer for removing ESCH

    // Check if name contains any special characters

    anyspecial = (_tcspbrk(s, "\"^*?") != NULL);

    if (anyspecial) {
        char *t;
        char *x;                       // Pointers for truncation, walking for ESCH

        t = s + _tcslen(s) - 1;

        // Copy pathname, skipping ESCHs and quotes
        x = L_buf;
        while( *s ) {
            if (*s == '^' || *s == '"') {
                s++;
            }
			else {
				if (_istlead(*(unsigned char *)s)) 
					*x++ = *s++;
            *x++ = *s++;
			}
        }

        *x = '\0';
        s = L_buf;                       // only elide ESCH the first time!
    }

    truncateFilename(s);

    if ((*dirHandle = _findfirst(s, (struct _finddata_t *) dta)) == -1) {
        // BUGBUG Use GetLastError to get details
        return(NULL);
    }

    // If it had no wildcard then close the search handle

    if (!anyspecial || (!_tcschr(s, '*') && !_tcschr(s, '?'))) {
        _findclose(*dirHandle);
    }

    return(((struct _finddata_t *) dta)->name);
}

char *
findNext(
    void *dta,
    NMHANDLE dirHandle
    )
{
    if (_findnext(dirHandle, (struct _finddata_t *) dta)) {
        _findclose(dirHandle);

        return(NULL);
    }

    return(((struct _finddata_t *) dta)->name);
}


char *
getCurDir(void)
{
	// Convert $ to $$ before returning current dir
	// [DS 14983]. This allows $(MAKEDIR) to work properly in 
	// case the current path contains a $ sign.
	//
    char *pszPath;
    char pbPath[_MAX_DIR+1];
	char *pchSrc = pbPath;
	char *pchDst;
	char ch;

	pszPath = (char *) rallocate(2 * _tcslen(_getcwd(pbPath, _MAX_DIR+1)) + 1);

	pchDst = pszPath;

	// non-MBCS aware implementation ('$' can't be a trailbyte)
	while (ch = *pchSrc) {
		*pchDst++ = *pchSrc++;
		if ('$' == ch)
			*pchDst++ = ch;
	}
	*pchDst = '\0';

    return(pszPath);
}


void
curTime(
    time_t *plTime
    )
{
    time(plTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ntrelhash\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <tchar.h>
#include <string>
#include <iostream>
#include <windows.h>


// TODO: reference additional headers your program requires here
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nvram\nvram.h ===
#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <shellapi.h>

#include <stdio.h>

#define SIZECHARS(x)    (sizeof((x))/sizeof(WCHAR))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ntrelhash\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// NtRelHash.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\objdir\objdir.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    obdir.c

Abstract:

    Utility to obtain a directory of Object Manager Directories for NT.

Author:

    Darryl E. Havens    (DarrylH)   9-Nov-1990

Revision History:


--*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <malloc.h>
#include <ntlsa.h>

#define BUFFERSIZE 1024
#define Error(N,S) {               \
    printf(#N);                    \
    printf(" Error %08lX\n", S);   \
    }

typedef struct _TYPEINFO {
    PWSTR       pszName;
    char * *    AccessRights;
    DWORD       NumberRights;
} TYPEINFO, * PTYPEINFO;


////////////////////////////////////////////////////////
//                                                    //
//          Internal Prototypes                       //
//                                                    //
////////////////////////////////////////////////////////

BOOLEAN
EnableAllPrivileges(
    VOID
    );

VOID
QueryDirectory(
    IN PSTRING DirectoryName
    );

NTSTATUS
OpenObject(
    IN  HANDLE            Root,
    IN  PWCHAR            Type,
    IN  PWCHAR            Name,
    IN  ACCESS_MASK       DesiredAccess,
    OUT PHANDLE           Object
    );

VOID
OpenAndDisplaySacl(
    IN  HANDLE            Root,
    IN  PWCHAR            Type,
    IN  PWCHAR            Name
    );

VOID
QueryAndDisplaySacl(
    IN  HANDLE              Object,
    IN  PWSTR               Type

    );

NTSTATUS
DisplaySacl(
    PSECURITY_DESCRIPTOR SD,
    IN PWSTR Type
    );

VOID
OpenAndDisplayDacl(
    IN  HANDLE            Root,
    IN  PWCHAR            Type,
    IN  PWCHAR            Name
    );

VOID
QueryAndDisplayDacl(
    IN  HANDLE              Object,
    IN  PWSTR               Type
    );

VOID
QueryAndDisplayOwner(
    IN HANDLE Object,
    IN PWSTR Type
    );

NTSTATUS
DisplayDacl(
    PSECURITY_DESCRIPTOR SD,
    IN PWSTR Type
    );

VOID
DumpAce(
    PACE_HEADER     Ace,
    BOOLEAN         AclIsDacl,
    PTYPEINFO       TypeInfo
    );

VOID
DumpStandardAceInfo(
    PACE_HEADER     Ace,
    BOOLEAN         AclIsDacl,
    PTYPEINFO       TypeInfo
    );

VOID
DisplaySid(
    IN  PSID        Sid
    );

VOID
ConnectToLsa( VOID );

VOID
Usage( VOID );


////////////////////////////////////////////////////////
//                                                    //
//          Global Variables                          //
//                                                    //
////////////////////////////////////////////////////////


UCHAR
    Buffer[BUFFERSIZE];


LSA_HANDLE
    LsaHandle;

BOOLEAN
    CompoundLineOutput = FALSE;
    DumpDacl = FALSE;       // May be changed by command parameter
    DumpDaclFull = FALSE;   // May be changed by command parameter
    DumpSacl = FALSE;       // May be changed by command parameter
    DumpSaclFull = FALSE;   // May be changed by command parameter
    DumpOwner = FALSE;      // May be changed by command parameter


char * AccessMask[] = { "Delete", "ReadControl", "WriteDac", "WriteOwner",
                        "Synch", "", "", "",
                        "Sacl", "MaxAllowed", "", "",
                        "GenericAll", "GenericExec", "GenericWrite", "GenericRead"};

char * TokenRights[] = {"AssignPrimary", "Duplicate", "Impersonate", "Query",
                        "QuerySource", "AdjustPriv", "AdjustGroup", "AdjustDef" };

char * KeyRights[] = {  "QueryValue", "SetValue", "CreateSubKey", "EnumSubKey",
                        "Notify", "CreateLink", "", "" };

char * EventRights[] = {"QueryState", "ModifyState" };

char * MutantRights[]={ "QueryState" };

char * SemaphoreRights[] = { "QueryState", "ModifyState" };

char * TimerRights[] = {"QueryState", "ModifyState" };

char * ProfileRights[]={"Control"};

char * ProcessRights[]={"Terminate", "CreateThread", "", "VMOp",
                        "VMRead", "VMWrite", "DupHandle", "CreateProcess",
                        "SetQuota", "SetInfo", "QueryInfo", "SetPort" };

char * ThreadRights[] ={"Terminate", "Suspend", "Alert", "GetContext",
                        "SetContext", "SetInfo", "QueryInfo", "SetToken",
                        "Impersonate", "DirectImpersonate" };

char * SectionRights[]={"Query", "MapWrite", "MapRead", "MapExecute",
                        "Extend"};

char * FileRights[] = { "Read/List", "Write/Add", "Append/SubDir/CreatePipe", "ReadEA",
                        "WriteEA", "Execute/Traverse", "DelChild", "ReadAttr",
                        "WriteAttr"};

char * PortRights[] = { "Connect" };

char * DirRights[]  = { "Query", "Traverse", "Create", "CreateSubdir" };

char * SymLinkRights[]={"Query" };

char * WinstaRights[]={ "EnumDesktops", "ReadAttr", "Clipboard", "CreateDesktop",
                        "WriteAttr", "GlobalAtom", "ExitWindows", "",
                        "Enumerate", "ReadScreen" };

char * DesktopRights[]={"ReadObjects", "CreateWindow", "CreateMenu", "HookControl",
                        "JournalRecord", "JournalPlayback", "Enumerate", "WriteObjects",
                        "SwitchDesktop" };

char * CompletionRights[] = { "Query", "Modify" };

char * ChannelRights[] = { "ReadMessage", "WriteMessage", "Query", "SetInfo" };

char * JobRights[] = { "AssignProcess", "SetAttr", "Query", "Terminate", "SetSecAttr" };


#define TYPE_NONE       0
#define TYPE_EVENT      1
#define TYPE_SECTION    2
#define TYPE_FILE       3
#define TYPE_PORT       4
#define TYPE_DIRECTORY  5
#define TYPE_LINK       6
#define TYPE_MUTANT     7
#define TYPE_WINSTA     8
#define TYPE_SEM        9
#define TYPE_KEY        10
#define TYPE_TOKEN      11
#define TYPE_PROCESS    12
#define TYPE_THREAD     13
#define TYPE_DESKTOP    14
#define TYPE_COMPLETE   15
#define TYPE_CHANNEL    16
#define TYPE_TIMER      17
#define TYPE_JOB        18
#define TYPE_WPORT      19
#define TYPE_MAX        20


TYPEINFO TypeNames[TYPE_MAX] = {
    { L"Unknown", NULL, 0 },
    { L"Event", EventRights, 2 },
    { L"Section", SectionRights, 5 },
    { L"File", FileRights, 9 },
    { L"Port", PortRights, 1 },
    { L"Directory", DirRights, 4 },
    { L"SymbolicLink", SymLinkRights, 1 },
    { L"Mutant", MutantRights, 2 },
    { L"WindowStation", WinstaRights, 10 },
    { L"Semaphore", SemaphoreRights, 2 },
    { L"Key", KeyRights, 6 },
    { L"Token", TokenRights, 8 },
    { L"Process", ProcessRights, 12 },
    { L"Thread", ThreadRights, 10 },
    { L"Desktop", DesktopRights, 10 },
    { L"IoCompletion", CompletionRights, 2 },
    { L"Channel", ChannelRights, 4 },
    { L"Timer", TimerRights, 2 },
    { L"Job", JobRights, 5 },
    { L"WaitablePort", PortRights, 1 }
    };


DWORD
GetObjectTypeIndex(
    PWSTR    TypeName )
{
    DWORD   i;


    for ( i = 1 ; i < TYPE_MAX ; i++ )
    {
        if (_wcsicmp( TypeNames[i].pszName, TypeName ) == 0 )
        {
            return( i );
        }
    }

    return( 0 );
}

VOID 
DisplayFlags(  
    ULONG       Flags,
    ULONG       FlagLimit,
    char        *flagset[],
    ULONG       Indent,
    ULONG       LineBreak,
    ULONG       BufferSize,
    UCHAR *     buffer)
{
   char *         offset;
   char *         limit ;
   char *         linelimit ;
   DWORD          mask, test, i, flagsize ;
   DWORD          scratch;


   if ( LineBreak > BufferSize )
   {
       strncpy( (CHAR *)buffer, "Invalid Parameter", BufferSize);
       
       return;
   }

   mask = 0;
   offset = (CHAR *) buffer;
   test = 1;

   limit = offset + BufferSize ;

   if ( LineBreak )
   {
       linelimit = offset + LineBreak ;
   }
   else
   {

       linelimit = limit ;
   }

   if ( linelimit > limit )
   {
       linelimit = limit ;
       
   }

   memset(offset, ' ', Indent);
   offset += Indent ;

   if (!Flags) {
      strcpy( offset, "None");
      return;
   }

   for ( i = 0 ; i < FlagLimit ; i++ )
   {
       if ( ( Flags & test ) != 0 )
       {
           //
           // Found a flag set in the flag word.  Try to write the text
           // form into the buffer
           //

           flagsize = strlen( flagset[ i ] );

           if ( offset + flagsize + 2 > limit )
           {
               return;
           }

           if ( offset + flagsize + 2 > linelimit )
           {
               //
               // Need to do a linebreak:
               //

               *offset++ = '\r';
               *offset++ = '\n';

               if ( LineBreak )
               {
                   linelimit = offset + LineBreak ;
               }
               else
               {

                   linelimit = limit ;
               }

               if ( linelimit > limit )
               {
                   linelimit = limit ;

               }

               memset(offset, ' ', Indent);
               offset += Indent ;

               if ( offset + flagsize + 2 > linelimit )
               {
                   *offset++ = '\0';
                   return;
                   
               }
           }

           CopyMemory( offset, flagset[ i ], flagsize );

           offset += flagsize ;

           mask |= test;

           if ( ( Flags & (~mask) ) != 0 )
           {
               *offset++ = ' ' ;
               
           }
           
       }

       test <<= 1 ;
       
   }

   *offset = '\0';

}


////////////////////////////////////////////////////////
//                                                    //
//          Routines                                  //
//                                                    //
////////////////////////////////////////////////////////


VOID
__cdecl main(
    int argc,
    char *argv[]
    )
{

    STRING
        String;

    int
        arg;

    char
        *s;

    BOOLEAN
        DirectoryNameArg;




    //
    // process any qualifiers
    //
    // All arguments are considered qualifiers until we reach a backslash ("\").
    // If we reach a backslash, then that argument is accepted as the last argument
    // and it is expected to the the name of the directory to be listed.
    //


    DirectoryNameArg = FALSE;
    arg = 1;
    while (arg < argc) {

        s = argv[arg];

        if (*s == '\\') {
            DirectoryNameArg = TRUE;
            break;  // break out of while loop
        }

        if (*s != '/') {
            Usage();
            return;
        }
        s++;

        if ((*s == 'o') || (*s == 'O')) {

            DumpOwner = TRUE;
            CompoundLineOutput = TRUE;

        } else if (*s == 'd') {

            //
            // Dump DACL qualifier
            //

            if (DumpDaclFull == TRUE) {
                printf("\n\n    Conflicting qualifiers:  /d and /D\n");
                Usage();
                return;
            }
            DumpDacl = TRUE;
            DumpDaclFull = FALSE;
            CompoundLineOutput = TRUE;


        } else if (*s == 'D') {

            //
            // Dump DACL qualifier
            //

            if ((DumpDacl== TRUE) && (DumpDaclFull == FALSE)) {
                printf("\n\n    Conflicting qualifiers:  /d and /D\n");
                Usage();
                return;
            }
            DumpDacl = TRUE;
            DumpDaclFull = TRUE;
            CompoundLineOutput = TRUE;

        } else if (*s == 's') {

            //
            // Dump SACL qualifier
            //

            if (DumpSaclFull == TRUE) {
                printf("\n\n    Conflicting qualifiers:  /s and /S\n");
                Usage();
                return;
            }
            DumpSacl = TRUE;
            DumpSaclFull = FALSE;
            CompoundLineOutput = TRUE;


        } else if (*s == 'S') {

            //
            // Dump SACL qualifier
            //

            if ((DumpSacl== TRUE) && (DumpSaclFull == FALSE)) {
                printf("\n\n    Conflicting qualifiers:  /s and /S\n");
                Usage();
                return;
            }
            DumpSacl = TRUE;
            DumpSaclFull = TRUE;
            CompoundLineOutput = TRUE;


        } else {

            Usage();
            return;
        }

        arg++;
    } // end_while

    if (DumpOwner || DumpDacl || DumpSacl) {
        ConnectToLsa();
    }

    //
    // Set up the name of the directory to list
    //


    if (!DirectoryNameArg) {
        RtlInitString( &String, "\\" );
    } else {
        RtlInitString( &String, argv[arg] );
    }


    if (EnableAllPrivileges()) {
        QueryDirectory( &String );
    }
}


WCHAR LinkTargetBuffer[ 1024 ];

typedef struct _DIR_ENTRY {
    PWSTR Name;
    PWSTR Type;
} DIR_ENTRY, *PDIR_ENTRY;

#define MAX_DIR_ENTRIES 1024
ULONG NumberOfDirEntries;
DIR_ENTRY DirEntries[ MAX_DIR_ENTRIES ];


int
__cdecl
CompareDirEntry(
    void const *p1,
    void const *p2
    )
{
    return _wcsicmp( ((PDIR_ENTRY)p1)->Name, ((PDIR_ENTRY)p2)->Name );
}


VOID
QueryDirectory(
    IN PSTRING DirectoryName
    )
//
// DumpDacl and DumpSacl are expected to be set prior to calling this routine.
//

{
    NTSTATUS Status;
    HANDLE DirectoryHandle, LinkHandle;
    ULONG Context = 0;
    ULONG i, ReturnedLength;
    UNICODE_STRING LinkTarget;

    POBJECT_DIRECTORY_INFORMATION DirInfo;
    POBJECT_NAME_INFORMATION NameInfo;
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING UnicodeString;
    ACCESS_MASK ExtraAccess = 0;
    UNICODE_STRING Match = { 0 };
    UNICODE_STRING Separators = { 0 };
    USHORT Offset ;
    ULONG DisplayedEntries = 0 ;
    BOOLEAN PrefixMatch = FALSE ;
    BOOLEAN SuffixMatch = FALSE ;
    ULONG ObjectNameLength ;
    BOOL PrefixMatched, SuffixMatched ;

    //
    //  Perform initial setup
    //

    RtlZeroMemory( Buffer, BUFFERSIZE );

    if (DumpDacl | DumpOwner) {
        ExtraAccess |= READ_CONTROL;
    }
    if (DumpSacl) {
        ExtraAccess |= ACCESS_SYSTEM_SECURITY;
    }


    //
    //  Open the directory for list directory access
    //

    Status = RtlAnsiStringToUnicodeString( &UnicodeString,
                                           DirectoryName,
                                           TRUE );
    ASSERT( NT_SUCCESS( Status ) );
    InitializeObjectAttributes( &Attributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );
    Status = NtOpenDirectoryObject( &DirectoryHandle,
                                    DIRECTORY_QUERY | ExtraAccess,
                                    &Attributes
                                  );

    if ( ( Status == STATUS_OBJECT_TYPE_MISMATCH ) ||
         ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) ||
         ( Status == STATUS_OBJECT_PATH_NOT_FOUND ) ) {

        RtlInitUnicodeString( &Separators, L"\\" );

        Status = RtlFindCharInUnicodeString(
                    RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END,
                    &UnicodeString,
                    &Separators,
                    &Offset );

        if ( NT_SUCCESS( Status ) )
        {
            UnicodeString.Length = Offset ;
            RtlInitUnicodeString( &Match, UnicodeString.Buffer + ((Offset + 2) / sizeof( WCHAR ) ) );

            if ( Match.Buffer[ 0 ] == L'*' )
            {
                Match.Buffer++ ;
                Match.Length -= sizeof( WCHAR );
                SuffixMatch = TRUE ;
                
            }

            if ( Match.Buffer[ Match.Length / sizeof( WCHAR ) - 1 ] == L'*' )
            {
                Match.Buffer[ Match.Length / sizeof( WCHAR ) - 1 ] = L'\0';
                Match.Length -= sizeof( WCHAR );
                PrefixMatch = TRUE ;
                
            }

            if ( PrefixMatch && SuffixMatch )
            {
                printf("Too complicated a search\n" );
                return;
                
            }
#if DBG
            printf("Searching for %c%ws%c\n",
                (SuffixMatch ? '*' : ' '), Match.Buffer, (PrefixMatch ? '*' : ' ') );
#endif 

            Status = NtOpenDirectoryObject( &DirectoryHandle,
                                            DIRECTORY_QUERY | ExtraAccess,
                                            &Attributes );

        }


    }

    if (!NT_SUCCESS( Status )) {


        if (Status == STATUS_OBJECT_TYPE_MISMATCH) {

            printf( "%Z is not a valid Object Directory Object name\n",
                    DirectoryName );
            }
        else {
            Error( OpenDirectory, Status );
            }

        return;
        }

    //
    // Get the actual name of the object directory object.
    //

    NameInfo = (POBJECT_NAME_INFORMATION) &Buffer[0];
    if (!NT_SUCCESS( Status = NtQueryObject( DirectoryHandle,
                                             ObjectNameInformation,
                                             NameInfo,
                                             BUFFERSIZE,
                                             (PULONG) NULL ) )) {
        printf( "Unexpected error obtaining actual object directory name\n" );
        printf( "Error was:  %X\n", Status );
        return;
    }

    //
    // Output initial informational message
    //

    printf( "Directory of:  %wZ\n", &NameInfo->Name );

    if ( Match.Length == 0 )
    {
        if (DumpOwner) {
            QueryAndDisplayOwner( DirectoryHandle, L"Directory" );
        }
        if (DumpDacl) {
            QueryAndDisplayDacl( DirectoryHandle, L"Directory" );
        }
        if (DumpSacl) {
            QueryAndDisplaySacl( DirectoryHandle, L"Directory" );
        }
        printf( "\n" );
        
    }

    //
    //  Query the entire directory in one sweep
    //

    NumberOfDirEntries = 0;
    for (Status = NtQueryDirectoryObject( DirectoryHandle,
                                          &Buffer,
                                          BUFFERSIZE,
                                          FALSE,
                                          FALSE,
                                          &Context,
                                          &ReturnedLength );
         NT_SUCCESS( Status );
         Status = NtQueryDirectoryObject( DirectoryHandle,
                                          &Buffer,
                                          BUFFERSIZE,
                                          FALSE,
                                          FALSE,
                                          &Context,
                                          &ReturnedLength ) ) {

        //
        //  Check the status of the operation.
        //

        if (!NT_SUCCESS( Status )) {
            if (Status != STATUS_NO_MORE_FILES) {
                Error( Status, Status );
            }
            break;
        }

        //
        //  For every record in the buffer type out the directory information
        //

        //
        //  Point to the first record in the buffer, we are guaranteed to have
        //  one otherwise Status would have been No More Files
        //

        DirInfo = (POBJECT_DIRECTORY_INFORMATION) &Buffer[0];

        while (TRUE) {

            //
            //  Check if there is another record.  If there isn't, then get out
            //  of the loop now
            //

            if (DirInfo->Name.Length == 0) {
                break;
            }

            //
            //  Print out information about the file
            //

            if (NumberOfDirEntries >= MAX_DIR_ENTRIES) {
                printf( "OBJDIR: Too many directory entries.\n" );
                exit( 1 );
                }

            DirEntries[ NumberOfDirEntries ].Name = RtlAllocateHeap( RtlProcessHeap(),
                                                                     HEAP_ZERO_MEMORY,
                                                                     DirInfo->Name.Length +
                                                                         sizeof( UNICODE_NULL )
                                                                   );

            if (DirEntries[ NumberOfDirEntries ].Name == NULL) {
                
                printf( "OBJDIR: Not enough memory to complete the operation.\n" );
                exit( 1 );
            }

            DirEntries[ NumberOfDirEntries ].Type = RtlAllocateHeap( RtlProcessHeap(),
                                                                     HEAP_ZERO_MEMORY,
                                                                     DirInfo->TypeName.Length +
                                                                         sizeof( UNICODE_NULL )
                                                                   );
            if (DirEntries[ NumberOfDirEntries ].Type == NULL) {
                
                printf( "OBJDIR: Not enough memory to complete the operation.\n" );
                exit( 1 );
            }

            memmove( DirEntries[ NumberOfDirEntries ].Name,
                     DirInfo->Name.Buffer,
                     DirInfo->Name.Length
                   );
            memmove( DirEntries[ NumberOfDirEntries ].Type,
                     DirInfo->TypeName.Buffer,
                     DirInfo->TypeName.Length
                   );

            NumberOfDirEntries++;

            //
            //  There is another record so advance DirInfo to the next entry
            //

            DirInfo = (POBJECT_DIRECTORY_INFORMATION) (((PUCHAR) DirInfo) +
                          sizeof( OBJECT_DIRECTORY_INFORMATION ) );

        }

        RtlZeroMemory( Buffer, BUFFERSIZE );

    }


    qsort( DirEntries,
           NumberOfDirEntries,
           sizeof( DIR_ENTRY ),
           CompareDirEntry
         );
    for (i=0; i<NumberOfDirEntries; i++) {

        if ( Match.Length )
        {
            ObjectNameLength = wcslen( DirEntries[ i ].Name );

            if ( PrefixMatch )
            {
                PrefixMatched = _wcsnicmp( DirEntries[ i ].Name,
                                           Match.Buffer,
                                           Match.Length / sizeof( WCHAR ) ) == 0 ;
                
            }

            if ( SuffixMatch )
            {
                if ( ObjectNameLength >= Match.Length / sizeof( WCHAR ) )
                {
                    SuffixMatched = 
                        _wcsnicmp( DirEntries[ i ].Name + ( ObjectNameLength - (Match.Length / sizeof( WCHAR ) )),
                                   Match.Buffer,
                                   Match.Length / sizeof( WCHAR) ) == 0 ;
                    
                }
                else 
                {
                    SuffixMatched = FALSE ;
                }
                
            }

            if ( SuffixMatch && !SuffixMatched )
            {
                continue;
            } 

            if ( PrefixMatch && !PrefixMatched )
            {
                continue;
            }

            if ( (!SuffixMatch) && (!PrefixMatch) &&
                 _wcsicmp( Match.Buffer, DirEntries[ i ].Name ) )
            {
                continue;
                
            }
            
        }

        DisplayedEntries++ ;

        printf( "%-32ws ", DirEntries[ i ].Name);
        if (CompoundLineOutput) {
            printf("\n    ");
        }
        printf( "%ws", DirEntries[ i ].Type );

        if (!wcscmp( DirEntries[ i ].Type, L"SymbolicLink" )) {
            RtlInitUnicodeString( &UnicodeString, DirEntries[ i ].Name );
            InitializeObjectAttributes( &Attributes,
                                        &UnicodeString,
                                        OBJ_CASE_INSENSITIVE,
                                        DirectoryHandle,
                                        NULL );
            Status = NtOpenSymbolicLinkObject( &LinkHandle,
                                               SYMBOLIC_LINK_QUERY,
                                               &Attributes
                                             );
            if (NT_SUCCESS( Status )) {
                LinkTarget.Buffer = LinkTargetBuffer;
                LinkTarget.Length = 0;
                LinkTarget.MaximumLength = sizeof( LinkTargetBuffer );
                Status = NtQuerySymbolicLinkObject( LinkHandle,
                                                    &LinkTarget,
                                                    NULL
                                                  );
                NtClose( LinkHandle );
                }

            if (!NT_SUCCESS( Status )) {
                printf( " - unable to query link target (Status == %09X)\n", Status );
                }
            else {
                printf( " - %wZ\n", &LinkTarget );
                }
            }
        else {
            printf( "\n" );
            }

        if (DumpOwner) {
            QueryAndDisplayOwner( DirectoryHandle, DirEntries[ i ].Type);
        }
        if (DumpDacl) {
            OpenAndDisplayDacl( DirectoryHandle, DirEntries[ i ].Type, DirEntries[ i ].Name);
            }
        if (DumpSacl) {
            OpenAndDisplaySacl( DirectoryHandle, DirEntries[ i ].Type, DirEntries[ i ].Name);
            }
        }

    //
    // Output final messages
    //

    if ( Match.Length != 0 )
    {
        if ( DisplayedEntries == 0 )
        {
            printf("not found\n" );
            
        }
        else if ( DisplayedEntries == 1 )
        {
            printf("\n1 entry\n" );
            
        }
        else 
        {

            printf("\n%ld entries\n", DisplayedEntries );
        }
        
    }
    else 
    {

        if (NumberOfDirEntries == 0) {
            printf( "no entries\n" );
            }
        else
        if (NumberOfDirEntries == 1) {
            printf( "\n1 entry\n" );
            }
        else {
            printf( "\n%ld entries\n", NumberOfDirEntries );
            }


    }


    //
    //  Now close the directory object
    //

    (VOID) NtClose( DirectoryHandle );

    //
    //  And return to our caller
    //

    return;

}


BOOLEAN
EnableAllPrivileges(
    VOID
    )
/*++


Routine Description:

    This routine enables all privileges in the token.

    If we are being asked to dump SACLs then we will check
    to make sure we have SE_SECURITY_PRIVILEGE enabled too.


Arguments:

    None.

Return Value:

    None.

--*/
{
    HANDLE Token;
    ULONG ReturnLength, Index;
    PTOKEN_PRIVILEGES NewState;
    BOOLEAN Result;
    LUID SecurityPrivilege;

    SecurityPrivilege =
        RtlConvertLongToLuid(SE_SECURITY_PRIVILEGE);

    Token = NULL;
    NewState = NULL;

    Result = (OpenProcessToken( GetCurrentProcess(),
                                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                &Token
                              ) ? 1 : 0);
    if (Result) {
        ReturnLength = 4096;
        NewState = malloc( ReturnLength );
        Result = (BOOLEAN)(NewState != NULL);
        if (Result) {
            Result = (GetTokenInformation( Token,            // TokenHandle
                                           TokenPrivileges,  // TokenInformationClass
                                           NewState,         // TokenInformation
                                           ReturnLength,     // TokenInformationLength
                                           &ReturnLength     // ReturnLength
                                         ) ? 1 : 0);

            if (Result) {
                //
                // Set the state settings so that all privileges are enabled...
                //

                if (DumpSacl) {
                    Result = FALSE;
                    }

                if (NewState->PrivilegeCount > 0) {
                    for (Index = 0; Index < NewState->PrivilegeCount; Index++ ) {
                        NewState->Privileges[Index].Attributes = SE_PRIVILEGE_ENABLED;
                        if (RtlEqualLuid(&NewState->Privileges[Index].Luid, &SecurityPrivilege )) {
                            Result = TRUE;
                            }
                        }
                    }
                if (!Result) {
                    // Don't have privilege to dump SACL
                    ASSERT(DumpSacl);

                    printf("\n\n    You do not have sufficient privilege to display SACLs.\n\n");
                    }
                else {
                    Result = (AdjustTokenPrivileges( Token,          // TokenHandle
                                                     FALSE,          // DisableAllPrivileges
                                                     NewState,       // NewState (OPTIONAL)
                                                     ReturnLength,   // BufferLength
                                                     NULL,           // PreviousState (OPTIONAL)
                                                     &ReturnLength   // ReturnLength
                                                   ) ? 1 : 0);
                    if (!Result) {
                        DbgPrint( "AdjustTokenPrivileges( %lx ) failed - %u\n", Token, GetLastError() );
                        }
                    }
                }
            else {
                DbgPrint( "GetTokenInformation( %lx ) failed - %u\n", Token, GetLastError() );
                }
            }
        else {
            DbgPrint( "malloc( %lx ) failed - %u\n", ReturnLength, GetLastError() );
            }
        }
    else {
        DbgPrint( "OpenProcessToken( %lx ) failed - %u\n", GetCurrentProcess(), GetLastError() );
        }

    if (NewState != NULL) {
        free( NewState );
        }

    if (Token != NULL) {
        CloseHandle( Token );
        }

    return( Result );
}


NTSTATUS
OpenObject(
    IN  HANDLE            Root,
    IN  PWCHAR            Type,
    IN  PWCHAR            Name,
    IN  ACCESS_MASK       DesiredAccess,
    OUT PHANDLE           Object
    )

{
    NTSTATUS
        Status;

    UNICODE_STRING
        UnicodeName;

    OBJECT_ATTRIBUTES
        Attributes;

    IO_STATUS_BLOCK
        Iosb;


    RtlInitUnicodeString( &UnicodeName, Name );
    InitializeObjectAttributes( &Attributes, &UnicodeName, OBJ_CASE_INSENSITIVE, Root, NULL );

    //
    // This is effectively a big switch statement of object types
    // that we know how to open...
    //

    if (!wcscmp( Type, L"SymbolicLink" )) {

        Status = NtOpenSymbolicLinkObject( Object, DesiredAccess, &Attributes );

    } else if (!wcscmp( Type, L"Device" )) {

        Status = NtOpenFile( Object, DesiredAccess, &Attributes, &Iosb, 0, 0 );

    } else if (!wcscmp( Type, L"Event" )) {

        Status = NtOpenEvent( Object, DesiredAccess, &Attributes );

    } else if (!wcscmp( Type, L"EventPair" )) {

        Status = NtOpenEventPair( Object, DesiredAccess, &Attributes );

    } else if (!wcscmp( Type, L"Mutant" )) {

        Status = NtOpenMutant( Object, DesiredAccess, &Attributes );

    } else if (!wcscmp( Type, L"Timer" )) {

        Status = NtOpenTimer( Object, DesiredAccess, &Attributes );

    } else if (!wcscmp( Type, L"Semaphore" )) {

        Status = NtOpenSemaphore( Object, DesiredAccess, &Attributes );

    } else if (!wcscmp( Type, L"Section" )) {

        Status = NtOpenSection( Object, DesiredAccess, &Attributes );

    } else if (!wcscmp( Type, L"Directory" )) {

        Status = NtOpenDirectoryObject( Object, DesiredAccess, &Attributes );

    } else if (!wcscmp( Type, L"Process" )) {

        Status = NtOpenProcess( Object, DesiredAccess, &Attributes, NULL );

    } else if (!wcscmp( Type, L"Job" )) {

        Status = NtOpenJobObject( Object, DesiredAccess, &Attributes );

    } else if (!wcscmp( Type, L"WindowStation" )) {

        *Object = OpenWindowStationW( Name, FALSE, DesiredAccess );

        if (*Object)
        {
            Status = STATUS_SUCCESS;
        }
        else
        {
            Status = STATUS_ACCESS_DENIED;
        }

    } else if (!wcscmp( Type, L"Desktop" )) {

        *Object = OpenDesktopW( Name, 0, FALSE, DesiredAccess );

        if (*Object)
        {
            Status = STATUS_SUCCESS;
        }
        else
        {
            Status = STATUS_ACCESS_DENIED;
        }


    } else {

        //
        // this utility doesn't yet support opening this type of object
        //

        Status = STATUS_NOT_SUPPORTED;
    }

    return(Status);
}


VOID
OpenAndDisplaySacl(
    IN  HANDLE            Root,
    IN  PWCHAR            Type,
    IN  PWCHAR            Name
    )

{
    NTSTATUS
        Status,
        IgnoreStatus;

    HANDLE
        Object;


    Status = OpenObject( Root, Type, Name, ACCESS_SYSTEM_SECURITY, &Object);


    if (NT_SUCCESS(Status)) {


        QueryAndDisplaySacl( Object, Type );
        IgnoreStatus = NtClose( Object );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_NOT_SUPPORTED) {
            printf("    Utility doesn't yet query SACLs for this type of object.\n\n");
        } else {
            printf("    Error attempting to query SACL:  0x%lx.\n\n", Status);
        }
    }
    return;
}


VOID
QueryAndDisplaySacl(
    IN HANDLE Object,
    IN PWSTR Type
    )
{
    NTSTATUS
        Status;

    PSECURITY_DESCRIPTOR
        SD = NULL;

    ULONG
        LengthNeeded,
        TypeIndex ;


    Status = NtQuerySecurityObject( Object,
                                    SACL_SECURITY_INFORMATION,
                                    NULL,
                                    0,
                                    &LengthNeeded
                                    );
    ASSERT(!NT_SUCCESS(Status));

    if (Status == STATUS_BUFFER_TOO_SMALL) {

        SD = RtlAllocateHeap( RtlProcessHeap(), 0, LengthNeeded );
        if (SD == NULL) {
            Status = STATUS_NO_MEMORY;
        } else {

            Status = NtQuerySecurityObject( Object,
                                            SACL_SECURITY_INFORMATION,
                                            SD,
                                            LengthNeeded,
                                            &LengthNeeded
                                            );
            if (NT_SUCCESS(Status)) {

                //
                // Display the SACL
                //

                Status = DisplaySacl( SD, Type );
            }
        }
    }
    
    if (SD) {
        RtlFreeHeap( RtlProcessHeap(), 0, SD );
    }

    return;
}



NTSTATUS
DisplaySacl(
    PSECURITY_DESCRIPTOR SD,
    PWSTR Type
    )
/*++

Routine Description:

    This function dumps out a SACL

    If an error status is returned, then the caller is responsible
    for printing a message.



--*/
{
    NTSTATUS
        Status;

    BOOLEAN
        AclPresent,
        AclDefaulted;

    PACL
        Acl;

    ACL_SIZE_INFORMATION
        AclInfo;

    ULONG
        i;

    PACE_HEADER
        Ace;

    ULONG TypeIndex ;


    TypeIndex = GetObjectTypeIndex( Type );

    Status = RtlGetSaclSecurityDescriptor ( SD, &AclPresent, &Acl, &AclDefaulted );

    if (NT_SUCCESS(Status)) {

        printf("    SACL - ");
        if (!AclPresent) {
            printf("No SACL present on object\n");
        } else {

           if (AclDefaulted) {
               printf("SACL Defaulted flag set\n           ");
           }

           if (Acl == NULL) {
               printf("NULL SACL - no auditing performed.\n");
           } else {
               Status = RtlQueryInformationAcl ( Acl,
                                                 &AclInfo,
                                                 sizeof(ACL_SIZE_INFORMATION),
                                                 AclSizeInformation);
               ASSERT(NT_SUCCESS(Status));

               if (AclInfo.AceCount == 0) {
                   printf("No ACEs in ACL, Auditing performed.\n");
               } else {
                   printf("\n");
                   for (i=0; i<AclInfo.AceCount; i++) {

                       Status = RtlGetAce( Acl, i, &Ace );
                       ASSERT(NT_SUCCESS(Status));

                       printf("       Ace[%2d] - ", i);
                       DumpAce( Ace, FALSE, &TypeNames[ TypeIndex ] );
                       printf("\n");
                   }
               }
           }
        }
    }
    printf("\n");

    return(Status);

}


VOID
OpenAndDisplayDacl(
    IN  HANDLE            Root,
    IN  PWCHAR            Type,
    IN  PWCHAR            Name
    )

{
    NTSTATUS
        Status,
        IgnoreStatus;

    HANDLE
        Object;

    ULONG TypeIndex ;


    Status = OpenObject( Root, Type, Name, READ_CONTROL, &Object);

    if (NT_SUCCESS(Status)) {
        QueryAndDisplayDacl( Object, Type );

        IgnoreStatus = NtClose( Object );

        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_ACCESS_DENIED) {
            printf("    Protection on object prevented querying the DACL.\n\n");
        } else if (Status == STATUS_NOT_SUPPORTED) {
            printf("    Utility doesn't yet query DACLs for this type of object.\n\n");
        } else {
            printf("    Error attempting to query DACL:  0x%lx.\n\n", Status);
        }
    }
    return;
}



VOID
QueryAndDisplayDacl(
    IN HANDLE Object,
    IN PWSTR Type
    )
{
    NTSTATUS
        Status;

    PSECURITY_DESCRIPTOR
        SD = NULL;

    ULONG
        LengthNeeded;

    Status = NtQuerySecurityObject( Object,
                                    DACL_SECURITY_INFORMATION,
                                    NULL,
                                    0,
                                    &LengthNeeded
                                    );
    ASSERT(!NT_SUCCESS(Status));

    if (Status == STATUS_BUFFER_TOO_SMALL) {

        SD = RtlAllocateHeap( RtlProcessHeap(), 0, LengthNeeded );
        if (SD == NULL) {
            Status = STATUS_NO_MEMORY;
        } else {

            Status = NtQuerySecurityObject( Object,
                                            DACL_SECURITY_INFORMATION,
                                            SD,
                                            LengthNeeded,
                                            &LengthNeeded
                                            );
            if (NT_SUCCESS(Status)) {

                //
                // Display the DACL
                //

                Status = DisplayDacl( SD, Type );
            }
        }
    }
    
    if (SD) {
        RtlFreeHeap( RtlProcessHeap(), 0, SD );
    }
    return;
}


NTSTATUS
DisplayDacl(
    PSECURITY_DESCRIPTOR SD,
    PWSTR Type
    )
/*++

Routine Description:

    This function dumps out a DACL

    If an error status is returned, then the caller is responsible
    for printing a message.



--*/
{
    NTSTATUS
        Status;

    BOOLEAN
        AclPresent,
        AclDefaulted;

    PACL
        Acl;

    ACL_SIZE_INFORMATION
        AclInfo;

    ULONG
        i;

    PACE_HEADER
        Ace;

    ULONG TypeIndex ;


    TypeIndex = GetObjectTypeIndex( Type );


    Status = RtlGetDaclSecurityDescriptor ( SD, &AclPresent, &Acl, &AclDefaulted );

    if (NT_SUCCESS(Status)) {

        printf("    DACL - ");
        if (!AclPresent) {
            printf("No DACL present on object\n");
        } else {

           if (AclDefaulted) {
               printf("DACL Defaulted flag set\n           ");
           }

           if (Acl == NULL) {
               printf("NULL DACL - grants all access to Everyone\n");
           } else {
               Status = RtlQueryInformationAcl ( Acl,
                                                 &AclInfo,
                                                 sizeof(ACL_SIZE_INFORMATION),
                                                 AclSizeInformation);
               ASSERT(NT_SUCCESS(Status));

               if (AclInfo.AceCount == 0) {
                   printf("No ACEs in ACL, Denies all access to everyone\n");
               } else {
                   printf("\n");
                   for (i=0; i<AclInfo.AceCount; i++) {

                       Status = RtlGetAce( Acl, i, &Ace );
                       ASSERT(NT_SUCCESS(Status));

                       printf("       Ace[%2d] - ", i);
                       DumpAce( Ace, TRUE, &TypeNames[ TypeIndex ] );
                       printf("\n");
                   }
               }
           }
        }
    }
    printf("\n");

    return(Status);

}

VOID
QueryAndDisplayOwner(
    IN HANDLE Object,
    IN PWSTR Type
    )
{
    NTSTATUS
        Status;

    PSECURITY_DESCRIPTOR
        SD = NULL;

    ULONG
        LengthNeeded;

    Status = NtQuerySecurityObject( Object,
                                    OWNER_SECURITY_INFORMATION,
                                    NULL,
                                    0,
                                    &LengthNeeded
                                    );
    ASSERT(!NT_SUCCESS(Status));

    if (Status == STATUS_BUFFER_TOO_SMALL) {

        SD = RtlAllocateHeap( RtlProcessHeap(), 0, LengthNeeded );
        if (SD == NULL) {
            Status = STATUS_NO_MEMORY;
        } else {

            Status = NtQuerySecurityObject( Object,
                                            OWNER_SECURITY_INFORMATION,
                                            SD,
                                            LengthNeeded,
                                            &LengthNeeded
                                            );
            if (NT_SUCCESS(Status)) {

                PSID Owner;
                BOOLEAN OwnerDefaulted;

                Status = RtlGetOwnerSecurityDescriptor ( SD, &Owner, &OwnerDefaulted );

                if (NT_SUCCESS(Status)) {

                    printf("    Owner - ");
                    DisplaySid(Owner);
                }
                
                printf("\n");
            }
        }
    }
    
    if (SD) {
        RtlFreeHeap( RtlProcessHeap(), 0, SD );
    }
    return;
}


VOID
DumpAce(
    PACE_HEADER     Ace,
    BOOLEAN         AclIsDacl,
    PTYPEINFO       TypeInfo
    )
/*++

Routine Description:

    This function displays a single ACE

Arguments:

    Ace - Points to an ACE.

    AclIsDacl - TRUE if acl is a DACL.  False if acl is an SACL.

Return Value:

    None.


--*/
{

    if ((Ace->AceFlags & INHERIT_ONLY_ACE) != 0) {
        printf("Inherit Only - ");
    }

    switch (Ace->AceType) {
    case ACCESS_ALLOWED_ACE_TYPE:

        printf("Grant -");
        DumpStandardAceInfo(Ace, AclIsDacl, TypeInfo);
        break;

    case ACCESS_DENIED_ACE_TYPE:

        printf("Deny -");
        DumpStandardAceInfo(Ace, AclIsDacl, TypeInfo);
        break;


    case SYSTEM_AUDIT_ACE_TYPE:

        printf("Audit ");
        DumpStandardAceInfo(Ace, AclIsDacl, TypeInfo);
        break;


    default:
        printf(" ** Unknown ACE Type **");
    }
    return;
}



VOID
DumpStandardAceInfo(
    PACE_HEADER     Ace,
    BOOLEAN         AclIsDacl,
    PTYPEINFO       TypeInfo
    )
/*++

Routine Description:

    This function dumps out the standard information for a single ACE.



Arguments:

    Ace - Points to an ACE_HEADER.  The ACE must be one of the known types.

    AclIsDacl - TRUE if acl is a DACL.  False if acl is an SACL.

Return Value:

    None.


--*/
{

    PACCESS_ALLOWED_ACE
        Local;

    ACCESS_MASK
        Specific;


    //
    // WARNING -
    //
    // It is assumed that all the known ACE types have their ACCESS_MASK
    // and SID fields in the same location as the ACCESS_ALLOWED_ACE.
    //

    Local = (PACCESS_ALLOWED_ACE)(Ace);


    if (Ace->AceType == SYSTEM_AUDIT_ACE_TYPE) {
        printf("[");
        if (Ace->AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG) {
            printf("S");
            if (Ace->AceFlags & FAILED_ACCESS_ACE_FLAG) {
                printf(",F");
            }
        } else if (Ace->AceFlags & FAILED_ACCESS_ACE_FLAG) {
            printf(" ,F");
        } else {
            printf("Neither Success nor Failure flag set]");
            return;
        }
        printf("] -");
    }

    printf(" 0x%lx - ", Local->Mask );
    DisplaySid( (PSID)(&Local->SidStart) );


    //
    // Everything else is only printed for FULL displays

    if (AclIsDacl && !DumpDaclFull) {
        return;
    }
    if (!AclIsDacl && !DumpSaclFull) {
        return;
    }


    //
    // Print the inheritance
    //

    printf("\n                             Inherit: ");

    if ((Ace->AceFlags & INHERIT_ONLY_ACE) != 0) {
        printf("IO ");
    }

    if ((Ace->AceFlags & OBJECT_INHERIT_ACE) != 0) {
        printf("OI ");
    }

    if ((Ace->AceFlags & CONTAINER_INHERIT_ACE) != 0) {
        printf("CI ");
    }

    if ((Ace->AceFlags & NO_PROPAGATE_INHERIT_ACE) != 0) {
        printf("NPI");
    }



    //
    // Print the accesses
    //

    Specific = (Local->Mask & 0xFFFF);
    printf("\n                             Access: 0x%04lX", Specific);

    if ( TypeInfo->NumberRights )
    {
        DisplayFlags( 
            Specific, 
            TypeInfo->NumberRights, 
            TypeInfo->AccessRights,
            38,
            80,
            sizeof( Buffer ),
            (PUCHAR) Buffer );

        printf("\n%s\n                                ", Buffer);

        
    }
    if (Local->Mask != Specific) {
        printf("  and  (");
    }

    if ((Local->Mask & DELETE) != 0) {
        printf(" D");
    }

    if ((Local->Mask & READ_CONTROL) != 0) {
        printf(" RCtl");
    }

    if ((Local->Mask & WRITE_OWNER) != 0) {
        printf(" WOwn");
    }

    if ((Local->Mask & WRITE_DAC) != 0) {
        printf(" WDacl");
    }
    if ((Local->Mask & SYNCHRONIZE) != 0) {
        printf(" Synch");
    }
    if ((Local->Mask & GENERIC_READ) != 0) {
        printf(" R");
    }

    if ((Local->Mask & GENERIC_WRITE) != 0) {
        printf(" W");
    }

    if ((Local->Mask & GENERIC_EXECUTE) != 0) {
        printf(" E");
    }

    if ((Local->Mask & GENERIC_ALL) != 0) {
        printf(" ALL");
    }

    if ((Local->Mask & ACCESS_SYSTEM_SECURITY) != 0) {
        printf(" ACC_SYS_SEC");
    }
    if ((Local->Mask & MAXIMUM_ALLOWED) != 0) {
        printf(" MAX_ALLOWED");
    }

    if (Local->Mask != Specific) {
        printf(" )");
    }
    printf("\n");


    return;
}



VOID
DisplaySid(
    IN  PSID        Sid
    )

/*++

Routine Description:

    This function calls LSA to lookup a SID and displays the result.

Arguments:

    Sid


Return Value:

    None.


--*/
{
    NTSTATUS
        Status;

    PLSA_REFERENCED_DOMAIN_LIST
        ReferencedDomains;

    PLSA_TRANSLATED_NAME
        SidName;

    ULONG
        DomainIndex;

    UNICODE_STRING
        SidString;


    if (LsaHandle == NULL) {
        printf("Can't call LSA to lookup sid");
        return;
    }

    Status = LsaLookupSids(
                  LsaHandle,
                  1,
                  &Sid,
                  &ReferencedDomains,
                  &SidName
                  );
    if (!NT_SUCCESS(Status)) {
        RtlConvertSidToUnicodeString( &SidString, Sid, TRUE );
        printf("%ws (Unable to translate)", SidString.Buffer );
        RtlFreeUnicodeString( &SidString );
        return;
    }

    DomainIndex = SidName[0].DomainIndex;

    printf("%wZ", &ReferencedDomains->Domains[DomainIndex].Name );
    if (ReferencedDomains->Domains[DomainIndex].Name.Length != 0) {
        printf("\\");
    }
    printf("%wZ", &SidName[0].Name );
    LsaFreeMemory( ReferencedDomains );
    LsaFreeMemory( SidName );
    return;
}


VOID
ConnectToLsa( VOID )
/*++

Routine Description:

    This function connects to LSA in preparation for expected SID
    lookup calls.

--*/
{
    NTSTATUS
        Status;

    OBJECT_ATTRIBUTES
        ObjectAttributes;


    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );

    LsaHandle = NULL;
    Status = LsaOpenPolicy(
                  NULL,                   // SystemName
                  &ObjectAttributes,
                  POLICY_LOOKUP_NAMES,    // DesiredAccess
                  &LsaHandle
                  );

    if (!NT_SUCCESS(Status)) {
        LsaHandle = NULL;
    }

    return;
}


VOID
Usage(VOID)
{
    printf("\n\n"
           "    Usage:\n"
           "                objdir [/o | /O] [/d | /D] [/s | /S] [<dir_name>]\n\n"
           "    Where:\n"
           "                /o or /O - causes the owner to be displayed.\n\n"
           "                /d - causes DACLs to be displayed in short form.\n\n"
           "                /D - causes DACLs to be displayed in long form.\n\n"
           "                /s - causes SACLs to be displayed in short form.\n\n"
           "                /S - causes SACLs to be displayed in long form.\n\n"
           "                <dir_name> - is the name of the directory you\n"
           "                             would like to see displayed.  Default\n"
           "                             is the root directory.\n\n"
           "    Examples:\n"
           "        objdir /d\n"
           "                - displays dacls of objects in root directory\n\n"
           "        objdir \\DosDevices\n"
           "                - displays objects in \\DosDevices\n\n"
           "        objdir /d \\BaseNamedObjects\n"
           "                - displays dacls of objects in \\BaseNamedObjects\n\n"
           "        objdir /s /d \\Windows\n"
           "                - displays sacls and dacls of objects in \\Windows\n\n"
           "        objdir /d \\Windows\\Windowstations\\Service*\n"
           "                - displays dacls of all windowstations beginning with 'service'\n\n"
           "        objdir \\Windows\\w*\n"
           "                - displays objects starting with w in \\Windows\n\n"
           );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nvram\setnvram.c ===
/*++

Copyright (c) 1994-1996 Microsoft Corporation

Module Name:

    setnvram.c

Abstract:

    This program is an example of how you could use a text file to create
    input for nvram.exe.

Author:

    Chuck Lenzmeier (chuckl)

Revision History:

--*/

//
// setnvram.c
//
// This program is an example of

#define _DLL 1
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SEPARATOR "|"

#define MAXLINESIZE 256

#define FALSE 0
#define TRUE 1

char Line[MAXLINESIZE];

char Countdown[MAXLINESIZE];

char LoadIdentifier[MAXLINESIZE];
char SystemPartition[MAXLINESIZE];
char OsLoader[MAXLINESIZE];
char OsLoadPartition[MAXLINESIZE];
char OsLoadFilename[MAXLINESIZE];
char OsLoadOptions[MAXLINESIZE];

char DefaultSystemPartition[MAXLINESIZE];
char DefaultOsLoadPartition[MAXLINESIZE];
char DefaultOsLoadOptions[MAXLINESIZE];

char *
Trim (
    char *String
    )
{
    char *start;
    char *end;

    start = String;
    while ( (*start == ' ') || (*start == '\t') ) {
        start++;
    }

    end = strrchr( start, 0 ) - 1;
    if ( (end > start) && ((*end == ' ') || (*end == '\t')) ) {
        do {
            end--;
        } while ( (*end == ' ') || (*end == '\t') );
        end++;
        *end = 0;
    }

    return start;
}

int
ParsePartition (
    char *String,
    char *Partition
    )
{
    char buffer[MAXLINESIZE];
    char *multi;
    char *scsi;
    char *disk;
    char *part;
    char *dot;

    strcpy( buffer, String );

    if ( _strnicmp(buffer, "scsi.", 5) != 0 ) {
        return FALSE;
    }
    multi = "0";
    scsi = "0";
    disk = &buffer[5];
    dot = strchr( disk, '.' );
    if ( dot == NULL ) {
        return FALSE;
    }
    *dot = 0;
    part = dot + 1;
    dot = strchr( part, '.' );
    if ( dot != NULL ) {
        scsi = disk;
        disk = part;
        *dot = 0;
        part = dot + 1;
        dot = strchr( part, '.' );
        if ( dot != NULL ) {
            multi = scsi;
            scsi = disk;
            disk = part;
            *dot = 0;
            part = dot + 1;
        }
    }

#if !defined(_PPC_)
    strcpy( Partition, "scsi()disk(" );
#else
    strcpy( Partition, "multi(" );
    strcat( Partition, multi );
    strcat( Partition, ")scsi(" );
    strcat( Partition, scsi );
    strcat( Partition, ")disk(" );
#endif
    strcat( Partition, disk );
#if !defined(_PPC_)
    strcat( Partition, ")rdisk()partition(" );
#else
    strcat( Partition, ")rdisk(0)partition(" );
#endif
    strcat( Partition, part );
    strcat( Partition, ")" );

    return TRUE;
}

int
main (
    int argc,
    char *argv[]
    )
{
    FILE *file = stdin;

    char *build;
    int len;
    int linenum;

    char *ident;
    char *token;
    char *sysdir;
    char *osdir;
    char *options;
    char *syspart;
    char *ospart;
    char *loader;

    char options1[MAXLINESIZE];
    char syspart1[MAXLINESIZE];
    char ospart1[MAXLINESIZE];

    if ( argc > 1 ) {
#if 1
      if ( argc > 2 ) {
#endif
        fprintf( stderr, "This program accepts no arguments\n" );
        fprintf( stderr, "Redirect stdin to build data file\n" );
        fprintf( stderr, "Redirect stdout to nvram.exe input file\n" );
        return 1;
#if 1
      } else {
        file = fopen( argv[1], "r" );
        if ( file == NULL ) {
            fprintf( stderr, "Can't open input file %s\n", argv[1] );
            return 1;
        }
      }
#endif
    }

    Countdown[0] = 0;

    LoadIdentifier[0] = 0;
    SystemPartition[0] = 0;
    OsLoader[0] = 0;
    OsLoadPartition[0] = 0;
    OsLoadFilename[0] = 0;
    OsLoadOptions[0] = 0;

    DefaultOsLoadOptions[0] = 0;
    DefaultOsLoadPartition[0] = 0;
    DefaultSystemPartition[0] = 0;

    linenum = 0;

    while ( TRUE ) {

        //
        // Get the next line from the input stream.
        //

        linenum++;

        build = fgets( Line, MAXLINESIZE, file );
        if ( build == NULL ) {
            if ( feof(file) ) break;
            fprintf( stderr, "Error %d reading input at line %d\n", ferror(file), linenum );
            return ferror(file);
        }

        build = Trim( build );
        len = strlen( build );

        //
        // Ignore blank lines and lines that start with //.
        //

        if ( len == 0 ) continue;
        if ( (build[0] == '/') && (build[1] == '/') ) continue;
        if ( build[len-1] != '\n' ) {
            fprintf( stderr, "Line %d is too long; %d characters max\n", linenum, MAXLINESIZE-2 );
            return 1;
        }
        if ( len == 1 ) continue;
        build[len-1] = 0;

        //
        // Check for the special "countdown" line.  If found, save the countdown value.
        //

        if ( strstr(build,"countdown=") == build ) {
            strcpy( Countdown, strchr(build,'=') + 1 );
            continue;
        }

        //
        // Check for the special "default systempartition" line.  If found, save the
        // default string.
        //

        if ( strstr(build,"default systempartition=") == build ) {
            strcpy( DefaultSystemPartition, Trim( strchr(build,'=') + 1 ) );
            continue;
        }

        //
        // Check for the special "default osloadpartition" line.  If found, save the
        // default string.
        //

        if ( strstr(build,"default osloadpartition=") == build ) {
            strcpy( DefaultOsLoadPartition, Trim( strchr(build,'=') + 1 ) );
            continue;
        }

        //
        // Check for the special "default options" line.  If found, save the
        // default string.
        //

        if ( strstr(build,"default options=") == build ) {
            strcpy( DefaultOsLoadOptions, Trim( strchr(build,'=') + 1 ) );
            strcat( DefaultOsLoadOptions, " " );
            continue;
        }

        //
        // OK, we should have an OS load line.  Required format is:
        //
        //   <ident>[|<sys-dir>][|<os-dir>][<dir>][|<options>][|<sys-part>][|<os-part>][|<loader>]
        //
        // Everything after <ident> is optional and may be specified in any order.
        //
        // <sys-dir> defines the directory path to the osloader/hal directory.
        // <os-dir>  defines the directory path to the OS directory.
        // The default value for both of these fields is <ident>.
        // <dir> sets both <sys-dir> and <os-dir>.
        //
        // <sys-part> and <os-part> are optional only if the corresponding defaults
        // have been specified.
        //
        // <loader> is used to override the selection of osloader.exe as the OS loader.
        //
        // <sys-dir>  format is sysdir=<directory path (no leading \)>
        // <os-dir>   format is osdir=<directory path (no leading \)>
        // <dir>      format is dir=<directory path (no leading \)>
        // <options>  format is options=<text of options>
        // <sys-part> format is syspart=<partition specification>
        // <os-part>  format is ospart=<partition specification>
        // <loader>   format is loader=<filename>
        //

        //
        // Get the load-identifier.
        //

        ident = Trim( strtok( build, SEPARATOR ) );

        //
        // Set defaults for optional fields.
        //

        osdir = ident;
        sysdir = ident;
        options = DefaultOsLoadOptions;
        syspart = DefaultSystemPartition;
        ospart = DefaultOsLoadPartition;
        loader = "osloader.exe";

        //
        // Get optional fields.
        //

        while ( (token = strtok( NULL, SEPARATOR )) != NULL ) {

            token = Trim( token );

            if ( strstr(token,"sysdir=") == token ) {

                sysdir = Trim( strchr(token,'=') + 1 );

            } else if ( strstr(token,"osdir=") == token ) {

                osdir = Trim( strchr(token,'=') + 1 );

            } else if ( strstr(token,"dir=") == token ) {

                sysdir = Trim( strchr(token,'=') + 1 );
                osdir = sysdir;

            } else if ( strstr(token,"options=") == token ) {

                //
                // If the options do not start with "nodef", preface the
                // default options (if any) to the specified options.
                //

                options = Trim( strchr(token,'=') + 1 );
                if ( _strnicmp(options,"nodef",5) == 0 ) {
                    options = options+5;
                } else {
                    strcpy( options1, DefaultOsLoadOptions );
                    strcat( options1, options );
                    options = options1;
                }

            } else if ( strstr(token,"syspart=") == token ) {

                syspart = Trim( strchr(token,'=') + 1 );

            } else if ( strstr(token,"ospart=") == token ) {

                ospart = Trim( strchr(token,'=') + 1 );

            } else if ( strstr(token,"loader=") == token ) {

                loader = Trim( strchr(token,'=') + 1 );

            } else {

                //
                // Unrecognized optional field.
                //

                fprintf( stderr, "Unreconized optional field at line %d\n", linenum );
                return 1;

            }

        } // while

        //
        // Verify the validity of the input fields.
        //

        if ( strlen(ident) == 0 ) {
            fprintf( stderr, "Bad <load-identifier> at line %d\n", linenum );
            return 1;
        }
        if ( strlen(sysdir) == 0 ) {
            fprintf( stderr, "Bad <system-directory> at line %d\n", linenum );
            return 1;
        }
        if ( strlen(osdir) == 0 ) {
            fprintf( stderr, "Bad <os-directory> at line %d\n", linenum );
            return 1;
        }
        if ( strlen(syspart) == 0 ) {
            fprintf( stderr, "Missing <system-partition> (no default) at line %d\n", linenum );
            return 1;
        }
        if ( strlen(ospart) == 0 ) {
            fprintf( stderr, "Missing <os-partition> (no default) at line %d\n", linenum );
            return 1;
        }
        if ( !ParsePartition(syspart, syspart1) ) {
            fprintf( stderr, "Bad <system-partition> at line %d\n", linenum );
            return 1;
        }
        if ( !ParsePartition(ospart, ospart1) ) {
            fprintf( stderr, "Bad <os-partition> at line %d\n", linenum );
            return 1;
        }
        if ( strlen(loader) == 0 ) {
            fprintf( stderr, "Bad <loader> at line %d\n", linenum );
            return 1;
        }

        //
        // If this is not the first load line, append ';' to all of the NVRAM strings.
        //

        if ( strlen(LoadIdentifier) != 0 ) {
            strcat( LoadIdentifier, ";" );
            strcat( SystemPartition, ";" );
            strcat( OsLoader, ";" );
            strcat( OsLoadPartition, ";" );
            strcat( OsLoadFilename, ";" );
            strcat( OsLoadOptions, ";" );
        }

        //
        // Append this load line to the NVRAM strings.
        //

        strcat( LoadIdentifier, ident );

        strcat( SystemPartition, syspart1 );

        strcat( OsLoader, syspart1 );
        if ( loader[0] != '\\' ) {
            strcat( OsLoader, "\\" );
            strcat( OsLoader, sysdir );
            strcat( OsLoader, "\\" );
        }
        strcat( OsLoader, loader );

        strcat( OsLoadPartition, ospart1 );

        strcat( OsLoadFilename, "\\" );
        strcat( OsLoadFilename, osdir );

        strcat( OsLoadOptions, options );
        Trim( OsLoadOptions );

    }

    //
    // Write the necessary nvram.exe commands to the output stream.
    //

    if ( Countdown[0] != 0 ) {
        fprintf( stdout, "nvram /set COUNTDOWN = \"%s\"\n", Countdown );
    }
    fprintf( stdout, "nvram /set LOADIDENTIFIER = \"%s\"\n", LoadIdentifier );
    fprintf( stdout, "nvram /set SYSTEMPARTITION = \"%s\"\n", SystemPartition );
    fprintf( stdout, "nvram /set OSLOADER = \"%s\"\n", OsLoader );
    fprintf( stdout, "nvram /set OSLOADPARTITION = \"%s\"\n", OsLoadPartition );
    fprintf( stdout, "nvram /set OSLOADFILENAME = \"%s\"\n", OsLoadFilename );
    fprintf( stdout, "nvram /set OSLOADOPTIONS = \"%s\"\n", OsLoadOptions );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\nvram\nvram.c ===
/*++

Copyright (c) 1993-1996 Microsoft Corporation

Module Name:

    nvram.c

Abstract:

    ARC/NV-RAM manipulation routines for 32-bit winnt setup.
    Also works on boot.ini on i386 machines.

Author:

    Ted Miller (tedm) 19-December-1993

Revision History:

--*/


#include "nvram.h"

typedef enum {
    BootVarSystemPartition,
    BootVarOsLoader,
    BootVarOsLoadPartition,
    BootVarOsLoadFilename,
    BootVarLoadIdentifier,
    BootVarOsLoadOptions,
    BootVarCountdown,
    BootVarMax
} BOOT_VARS;

PWSTR BootVarNames[BootVarMax] = { L"SYSTEMPARTITION",
                                   L"OSLOADER",
                                   L"OSLOADPARTITION",
                                   L"OSLOADFILENAME",
                                   L"LOADIDENTIFIER",
                                   L"OSLOADOPTIONS",
                                   L"COUNTDOWN"
                                 };

PWSTR PaddedBootVarNames[BootVarMax] = { L"SYSTEMPARTITION",
                                         L"       OSLOADER",
                                         L"OSLOADPARTITION",
                                         L" OSLOADFILENAME",
                                         L" LOADIDENTIFIER",
                                         L"  OSLOADOPTIONS",
                                         L"      COUNTDOWN"
                                       };

#ifndef i386

//
// Helper macro to make object attribute initialization a little cleaner.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )



BOOL
DoSetNvRamVar(
    IN PWSTR VarName,
    IN PWSTR VarValue
    )
{
    UNICODE_STRING U1,U2;

    RtlInitUnicodeString(&U1,VarName);
    RtlInitUnicodeString(&U2,VarValue);

    return(NT_SUCCESS(NtSetSystemEnvironmentValue(&U1,&U2)));
}


VOID
PrintNvRamVariable(
    IN PWSTR VariableName,
    IN PWSTR VariableValue
    )
{
    PWSTR pEnd;
    WCHAR c;
    BOOL FirstComponent = TRUE;

    while(*VariableValue) {

        //
        // Find the termination of the current component,
        // which is either a ; or 0.
        //
        pEnd = wcschr(VariableValue,L';');
        if(!pEnd) {
            pEnd = wcschr(VariableValue,0);
        }

        c = *pEnd;
        *pEnd = 0;

        wprintf(
            L"%s%s %s\n",
            FirstComponent ? VariableName : L"               ",
            FirstComponent ? L":" : L" ",
            VariableValue
            );

        *pEnd = c;

        VariableValue = pEnd + (c ? 1 : 0);

        FirstComponent = FALSE;
    }
}

VOID
RotateNvRamVariable(
    IN PWSTR VariableValue
    )
{
    PWSTR pEnd;
    WCHAR Buffer[32768];
    //
    // Find the termination of the current component,
    // which is either a ; or 0.
    //
    pEnd = wcschr(VariableValue,L';');
    if(!pEnd) {
        pEnd = wcschr(VariableValue,0);
    }

    //
    // Copy VariableValue into Buffer starting at second entry
    //
    wcscpy(Buffer, pEnd + (*pEnd ? 1 : 0));

    //
    // Append first entry at the end of Buffer
    //
    if (*pEnd) wcscpy(Buffer + wcslen(Buffer), L";");

    *pEnd = 0;

    wcscpy(Buffer + wcslen(Buffer), VariableValue);

    //
    // Copy whole thing back into VariableValue
    //
    wcscpy(VariableValue, Buffer);

}

int _cdecl main(
    IN int argc,
    IN char *argv[]
    )
{
    DWORD var;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    BOOLEAN OldPriv;
    WCHAR Buffer[32768];
    WCHAR Buffer1[32768];
    WCHAR Buffer2[32768];

    Status = RtlAdjustPrivilege(
                SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
                TRUE,
                FALSE,
                &OldPriv
                );

    if(!NT_SUCCESS(Status)) {
        wprintf(L"Insufficient privilege.\n");
        return(0);
    }

    if(argc == 1) {

        for(var=0; var<BootVarMax; var++) {

            RtlInitUnicodeString(&UnicodeString,BootVarNames[var]);

            Status = NtQuerySystemEnvironmentValue(
                        &UnicodeString,
                        Buffer,
                        SIZECHARS(Buffer),
                        NULL
                        );

            if(NT_SUCCESS(Status)) {
                PrintNvRamVariable(PaddedBootVarNames[var],Buffer);
            } else {
                wprintf(L"%s: <empty>\n",PaddedBootVarNames[var]);
            }

            wprintf(L"\n");
        }
    }

    if((argc == 2) && !lstrcmpiA(argv[1],"rotate")){

        for(var=0; var<BootVarMax; var++) {

            RtlInitUnicodeString(&UnicodeString,BootVarNames[var]);

            Status = NtQuerySystemEnvironmentValue(
                        &UnicodeString,
                        Buffer,
                        SIZECHARS(Buffer),
                        NULL
                        );

            if(NT_SUCCESS(Status)) {
                RotateNvRamVariable(Buffer);
                printf(
                    "Setting variable %ws to %ws [%s]\n",
                    UnicodeString.Buffer,
                    Buffer,
                    DoSetNvRamVar(UnicodeString.Buffer,Buffer) ? "OK" : "Error"
                );
            } else {
                wprintf(L"%s: <empty>\n",PaddedBootVarNames[var]);
            }

            wprintf(L"\n");
        }
    }

    if((argc == 5) && !lstrcmpiA(argv[1]+1,"set") && !lstrcmpA(argv[3],"=")) {

        MultiByteToWideChar(
            CP_OEMCP,
            MB_PRECOMPOSED,
            argv[2],
            -1,
            Buffer1,
            SIZECHARS(Buffer1)
            );

        MultiByteToWideChar(
            CP_OEMCP,
            MB_PRECOMPOSED,
            argv[4],
            -1,
            Buffer2,
            SIZECHARS(Buffer2)
            );

        printf(
            "Setting variable %ws to %ws [%s]\n",
            Buffer1,
            Buffer2,
            DoSetNvRamVar(Buffer1,Buffer2) ? "OK" : "Error"
            );
    }

    return(0);
}

#else

TCHAR LoadID[500];          // load identifier (no quotes)
TCHAR CountDown[100];       // countdown timer
TCHAR OsLoadOptions[500];   // load options
TCHAR OsName[500];          // name of default os

TCHAR OsLine[500];          // complete line of os description and options

#define STR_BOOTINI           TEXT("c:\\boot.ini")
#define STR_BOOTLDR           TEXT("boot loader")
#define STR_TIMEOUT           TEXT("timeout")
#define STR_DEFAULT           TEXT("default")
#define STR_OPERATINGSYS      TEXT("operating systems")
#define STR_NULL              TEXT("")

//
// HandleOption - add option to OsLoadOptions
//

VOID HandleOption( TCHAR* Option )
{
    TCHAR SlashOption[200];
    TCHAR SlashOptionSlash[200];
    //
    // find out if option already exists
    // add blank to end to prevent debug from matching debugport
    //

    wsprintf( SlashOption, TEXT("/%s "), Option );
    wsprintf( SlashOptionSlash, TEXT("/%s/"), Option );

    if( wcsstr( OsLoadOptions, SlashOption )   || 
        wcsstr( OsLoadOptions, SlashOptionSlash ) )
    {
        printf("option already exists: %ws\n",Option);
    }
    else
    {
        //
        // append option without the trailing blank
        //

        printf("added option %ws\n",Option);
        lstrcat( OsLoadOptions, TEXT("/") );
        lstrcat( OsLoadOptions, Option );
    }
}

//
// WriteBootIni - update the boot.ini file with our changes
//

VOID WriteBootIni()
{
    DWORD FileAttr;

    //
    // Get file attributes of boot.ini for later restoration
    //

    FileAttr= GetFileAttributes( STR_BOOTINI );

    //
    // Change file attributes on boot.ini so we can write to it.
    //

    if( !SetFileAttributes( STR_BOOTINI, FILE_ATTRIBUTE_NORMAL ) )
    {
        printf("Failed to turn off read-only on boot.ini  (lasterr= %d)\n",
                GetLastError() );
    }

    //
    // Update boot.ini strings
    //

    if( !WritePrivateProfileString( STR_BOOTLDR, STR_TIMEOUT, 
                                   CountDown, STR_BOOTINI ) )
    {
        printf("failed to write timeout (lasterr= %d)\n",GetLastError());
    }

    //
    // create the osline from its parts
    //
    
    wsprintf(OsLine, TEXT("\"%s\"%s"), LoadID, OsLoadOptions );

    if( !WritePrivateProfileString( STR_OPERATINGSYS, OsName,  
                                    OsLine, STR_BOOTINI ) )
    {
        printf("failed to write OS line (lasterr= %d)\n",GetLastError());
    }

    //
    // Restore boot.ini file attributes
    //

    if( FileAttr != 0xFFFFFFFF )
    {
        SetFileAttributes( STR_BOOTINI, FileAttr );
    }

}

//
// Usage - print out usage information
//

VOID Usage()
{
        printf("\nUsage:\n");
        printf("    no parameters:  prints current settings.\n");
        printf("   /set parameter = value  : sets value in boot.ini\n");
        printf("   rotate : rotates default build through boot options\n");
        printf("\n");
        printf("Example:  nvram /set osloadoptions = debug\n");
        printf("   This will set the debug option on\n\n");
        printf("Available options:\n");
        printf("    loadidentifier, osloadoptions, countdown\n");
}


int _cdecl main(
    IN int argc,
    IN char *argv[]
    )
{
    DWORD dwStatus;
    LPWSTR* pArgs;

    // parse command line in unicode

    pArgs= CommandLineToArgvW( GetCommandLine(), &argc );

    //
    // Get the boot information from boot.ini
    //

    // timeout

    dwStatus= GetPrivateProfileString(
                 STR_BOOTLDR, 
                 STR_TIMEOUT,
                 STR_NULL,
                 CountDown,
                 SIZECHARS(CountDown),
                 STR_BOOTINI );
    if( !dwStatus )
    {
        printf("Failed to get timeout value\n");
        return(-1);
    }

    // default os description and options

    dwStatus= GetPrivateProfileString(
                  STR_BOOTLDR,
                  STR_DEFAULT,
                  STR_NULL,
                  OsName,
                  SIZECHARS(OsName),
                  STR_BOOTINI );
    if( !dwStatus )
    {
        printf("Failed to get default OS name\n");
        return(-1);
    }

    dwStatus= GetPrivateProfileString(
                  STR_OPERATINGSYS,
                  OsName,
                  STR_NULL,
                  OsLine,
                  SIZECHARS(OsLine),
                  STR_BOOTINI );
    if( !dwStatus )
    {
        printf("Failed to get default os description\n");
        return(-1);
    }
                 
    //
    // Now parse the line into description and options.
    // If it starts with a quote, it may have options.
    // If it doesn't start with a quote, it won't.
    //

    *LoadID= *OsLoadOptions= TEXT('\0');

    if( *OsLine == TEXT('"') )
    {
        INT i;

        for( i=1; OsLine[i]; i++ )
        {
            LoadID[i-1]= OsLine[i];
            if( OsLine[i] == TEXT('"') )
               break;
        }

        if( OsLine[i] )
        {
            LoadID[i-1]= TEXT('\0');   // don't copy final quote
            lstrcpy( OsLoadOptions, &OsLine[i+1] );
            lstrcat( OsLoadOptions, TEXT(" ") ); // all options end with blank
        }
    }
    else
    {
        lstrcpy( LoadID, OsLine );
        lstrcpy( OsLoadOptions, TEXT("") );
    }

    // no parameters prints out values

    if( argc == 1 )
    {
        printf("%ws: %ws\n",PaddedBootVarNames[BootVarLoadIdentifier], LoadID);
        printf("%ws: %ws\n",PaddedBootVarNames[BootVarOsLoadOptions], OsLoadOptions);
        printf("%ws: %ws\n",PaddedBootVarNames[BootVarCountdown], CountDown);
    }
    
    // -set parameter = value
    // sets parameter to some value

    if( (argc == 2) &&
       !lstrcmpiW(pArgs[1],L"rotate") )
    {
        INT i;
        DWORD FileAttr;

        //
        // Read in all boot options
        //

        dwStatus= GetPrivateProfileString(
                      STR_OPERATINGSYS,
                      NULL,
                      STR_NULL,
                      OsLine,
                      SIZECHARS(OsLine),
                      STR_BOOTINI );
        if( !dwStatus )
        {
            printf("Failed to get os section\n");
            return(-1);
        }

        //
        // read through boot options until we find default entry
        //

        i = 0;

        while( lstrcmpiW( OsName, &(OsLine[i]) ) ){

            i = i + wcslen(&OsLine[i]) + 1;
        }

        //
        // increment one more entry
        //

        i = i + wcslen(&OsLine[i]) + 1;

        //
        // if we've gone off the end then start over
        //

        if (!lstrcmpiW( &(OsLine[i]), L"\0\0" ) ){
            i = 0;
        }

        //
        // Get file attributes of boot.ini for later restoration
        //

        FileAttr= GetFileAttributes( STR_BOOTINI );

        //
        // Change file attributes on boot.ini so we can write to it.
        //

        if( !SetFileAttributes( STR_BOOTINI, FILE_ATTRIBUTE_NORMAL ) )
        {
            printf("Failed to turn off read-only on boot.ini  (lasterr= %d)\n",
                    GetLastError() );
        }

        if( !WritePrivateProfileString( STR_BOOTLDR, STR_DEFAULT,
                                       &(OsLine[i]), STR_BOOTINI ) )
        {
            printf("failed to write default (lasterr= %d)\n",GetLastError());
        }

        //
        // Restore boot.ini file attributes
        //

        if( FileAttr != 0xFFFFFFFF )
        {
            SetFileAttributes( STR_BOOTINI, FileAttr );
        }

    }
    if( (argc == 5) && 
       !lstrcmpiW(pArgs[1]+1,L"set") && 
       !lstrcmpW(pArgs[3],L"=") )
    {
        INT i;

        // see if we understand parameter

        for( i=0; i<BootVarMax; i++ )
        {
            if( lstrcmpiW( pArgs[2], BootVarNames[i] ) == 0 )
                break;
        }

        // handle the ones we can

        switch( i )
        {
            default:
                printf("Not valid parameter name to set: %ws\n",pArgs[2]);
                Usage();
                return(-1);
                break;

            case BootVarLoadIdentifier:
                lstrcpyW( LoadID, pArgs[4] );
                break;

            case BootVarOsLoadOptions:
                HandleOption( pArgs[4] );
                break;

            case BootVarCountdown:
                lstrcpyW( CountDown, pArgs[4] );
                break;
        }

        WriteBootIni();
    }

    // -?     
    // usage message

    if( argc == 2 && !lstrcmpW(pArgs[1]+1, L"?") )
    {
        Usage();
    }

    return(0);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\opprec\mat.c ===
#include <stdio.h>
#include <malloc.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "opprec.h"

void	ReadMat(FILE *fh, int *pMat, char **pStr, int cEnt)
{
	register int	i, j;
	int ind = 0;
	char str[200];
	char *p, *q;

	for (i = 0 ; i < cEnt ; ++i) {
		if ((pStr[i] = malloc(8)) == NULL) {
			printf("insufficient memory\n");
			exit(2);
		}
		if ((p = SkipBlank (fh, str, 200)) == NULL) {
			printf ("EOF reached\n");
			exit (1);
		}
		while (isspace (*p))
			p++;
		if ((q = strpbrk (p, " \t")) == NULL) {
			printf ("Bad format (%s)\n", str);
			exit (1);
		}
		*q = 0;
		strcpy (pStr[i], p);
		p = q + 1;
		for (j = 0; j < cEnt; j++, ind++) {
			// read group and matrix values
			while (isspace (*p))
				p++;
			if ((*p == 0) || ((*p != '0') && (*p != '1'))) {
				printf ("Bad format (%s)\n", str);
				exit (1);
			}
			pMat[ind] = *p++ - '0';
		}
	}
}

void	DumpMat(int *pMat, int cEnt)
{
	register int	i;
	register int	j;

	for (i=0 ; i<cEnt ; ++i)
	{
		for (j=0 ; j<cEnt ; ++j)
			printf("%d ", pMat[i * cEnt + j]);

		printf("\n");
	}
}



void AddClosure(int *pMat, int cEnt)
{
				int	d;
				int	e, f;
				int	i;
	register int	j;
	register	int	k;
				int	n;
				int	*pMatTmp;

	pMatTmp = malloc(cEnt * cEnt * sizeof(int));
    if (!pMatTmp) {
        return;
    }

	for (n = 0; n < cEnt; ++n) {
		for (i = 0; i < cEnt; ++i) {
			for (j = 0; j < cEnt; ++j) {
				d = pMat[i * cEnt + j];

				for (k = 0; k < cEnt; ++k) {
					e = pMat[i * cEnt + k];
					f = pMat[k * cEnt + j];

					if ((e != 0) && (f != 0))
						if (e + f > d)
							d = e + f;
				}

				pMatTmp[i * cEnt + j] = d;
			}
		}
		memcpy (pMat, pMatTmp, cEnt * cEnt * sizeof (int));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\opprec\opprec.c ===
/**	opprec.c - compute operator predecence function values
 *	R. A. Garmoe	89/05/09
 */

/*	This program accepts a directed graph (in matrix form) and calculates
 *	the operator precedence function values f(op) and g(op).  For more
 *	information see Compilers: Principles, Techniques and Tools, by Aho,
 *	Sethi and Ullman [Addison-Wesley], Section 4.6.  A value of 1 in the
 *	matrix indicates an edge; a value of 0 indicates no edge.  Note
 *	also that the entries fx -> fy and gx -> gy are only present as
 *	placeholders (to make the matrix easier to read in); these values
 *	should always be zero.
 *
 *	To use this program, first generate the directed graph file expr2.z and
 *	run it through the C preprocessor to remove comments:
 *
 *		cl -P expr2.z
 *
 *	This will produce the file expr2.i, which can then be run through
 *	opprec.exe:
 *
 *		graph {option} expr2.i > expr2.out
 *
 *	The output file expr2.out then contains the precedence function
 *	values in either assembler or C format.
 */



/*	Call
 *
 *	opprec vca file
 *
 *	where
 *		v	include operator values in output as comments
 *		c	generate C compilable output
 *		a	generate MASM assemblable output
 *		file	input file stripped of comments
 */





#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "opprec.h"

struct token {
	struct token *next;
	char   precstr[17];
	char   type[17];
	char   tclass[17];
	char   bind[17];
	char   eval[17];
};
struct token *tokhead = NULL;
struct token *toktail = NULL;
int	asmout = FALSE; 	//output assembler form if true
int	verbose = FALSE;	//output operator group data if true

void cdecl main(int argc, char **argv)
{
	int 	i;
	int 	j;
	int 	d;
	int    *pMat;
	int    *pPrec;
	char  **pStr;
	int 	cEnt;
	FILE   *fh;
	char   *p, *q;
	int 	len, f, g;
	struct	token *pt;
	int 	ntoken = 0;
	char	str[200];

	// check arguments

	if (argc != 3) {
		printf ("Usage: graph -vca file\n");
		exit (1);
	}

	for (i = 0; argv[1][i] != 0; i++) {
		switch (argv[1][i]) {
			case 'a':
				asmout = TRUE;
				break;

			case 'c':
				asmout = FALSE;
				break;

			case 'v':
				verbose = TRUE;
				break;

			default:
				printf ("Unknown argument %c\n", argv[1][i]);
				exit (1);
		}
	}
	if ((fh = fopen (argv[2], "r")) == NULL) {
		printf ("Unable to open '%s'\n", argv[1]);
		exit (1);
	}

	// read and print token class definitions

	for (;;) {
		if ((p = SkipBlank (fh, str, 200)) == NULL) {
			printf ("EOF reached\n");
			exit (1);
		}
		while (isspace (*p)) {
			p++;
		}
		q = strpbrk (p, " \t");
		if ( q )
			*q = 0;
		if (strcmp (p, "END") == 0) {
			break;
		}
		if (asmout) {
			printf ("OPCDAT %s\n", p);
		}
		else {
			printf ("OPCDAT (%s)\n", p);
		}
	}
	printf ("\n");

	// read token definitions

	for (;;) {
		if ((p = SkipBlank (fh, str, 200)) == NULL) {
			printf ("EOF reached\n");
			exit (1);
		}
		while (isspace (*p)) {
			p++;
		}
		if (strcmp (p, "END") == 0) {
			break;
		}
		if ((q = strpbrk (p, " \t")) == NULL) {
			printf ("Bad format (%s)\n", str);
			exit (1);
		}
		*q = 0;
		ntoken++;
		if ((pt = (struct token *)malloc (sizeof (struct token))) == NULL) {
			printf ("insufficient memory\n");
			exit (2);
		}
		pt->next = NULL;
		strcpy (pt->precstr, p);
		p = q + 1;
		while (isspace (*p)) {
			p++;
		}
		if ((q = strpbrk (p, " \t")) == NULL) {
			printf ("Bad format (%s)\n", str);
			exit (1);
		}
		*q = 0;
		strcpy (pt->type, p);
		p = q + 1;
		while (isspace (*p)) {
			p++;
		}
		if ((q = strpbrk (p, " \t")) != NULL) {
			*q = 0;
		}
		strcpy (pt->tclass, p);
		p = q + 1;
		while (isspace (*p)) {
			p++;
		}
		if ((q = strpbrk (p, " \t")) != NULL) {
			*q = 0;
		}
		strcpy (pt->bind, p);
		p = q + 1;
		while (isspace (*p)) {
			p++;
		}
		if ((q = strpbrk (p, " \t")) != NULL) {
			*q = 0;
		}
		strcpy (pt->eval, p);




		if (tokhead == NULL) {
			tokhead = pt;
			toktail = pt;
		}
		else {
			toktail->next = pt;
			toktail = pt;
		}
	}
	if (asmout) {
		printf ("OPCNT COPS_EXPR,\t%d\n\n", ntoken);
	}
	else {
		printf ("OPCNT (COPS_EXPR,\t%d\t)\n\n", ntoken);
	}

	// read dimension of matrix.	note that the upper left and lower right
	// quadrants of the matrix must be zero.

	if (SkipBlank (fh, str, 200) == NULL) {
		printf ("EOF reached\n");
		exit (1);
	}
	cEnt = atoi (str);

	// allocate space for the matrix and the description strings

	pMat = (int *)malloc (cEnt * cEnt * sizeof(int));
	pStr = malloc (cEnt * sizeof (char *));
	pPrec = (int *)malloc (cEnt * sizeof (int));
	if ((pMat == NULL) || (pStr == NULL) || (pPrec == NULL)) {
		printf ("insufficient memory\n");
		exit (2);
	}

	ReadMat (fh, pMat, pStr, cEnt);

	AddClosure (pMat, cEnt);

	// check for acyclic graph

	for (i = 0; i < cEnt; ++i) {
		if (pMat[i * cEnt + i] != 0) {
			printf ("Graph is cyclic for %s!!!\n", pStr[i]);
			exit(3);
		}
	}

	// print precedence function values

	for (i = 0; i < cEnt; ++i) {
		d = 0;
		for (j = 0; j < cEnt; ++j) {
			if (pMat[i * cEnt + j] > d) {
				d = pMat[i * cEnt + j];
			}
		}
		pPrec[i] = d;
		if (verbose) {
			if (asmout) {
				printf (";%-4s : %3d\n", pStr[i], d);
			}
			else {
				printf ("/*%-4s : %3d*/\n", pStr[i], d);
			}
		}
	}

	// print token definitions

	for (pt = tokhead; pt != NULL; pt = pt->next) {
		len = strlen (pt->precstr);

		// search for F string in list of precedence groupings

		for (i = 0; i < cEnt; i++) {
			if ((p = strstr(pStr[i], pt->precstr)) &&
			  ((*(p + len) == 0) || (*(p + len) == 'G'))) {
				break;
			}
		}
		if (i == cEnt) {
			printf ("F precedence string \"%s\" not found\n", pt->precstr);
			exit (4);
		}
		else {
			f = pPrec[i];
		}

		// search for G string in list of precedence groupings

		*pt->precstr = 'G';
		for (i = 0; i < cEnt; i++) {
			// search for string in list of precedence groupings
			if ((p = strstr(pStr[i], pt->precstr)) && (*(p + len) == 0)) {
				break;
			}
		}
		if (i == cEnt) {
			printf ("G precedence string \"%s\" not found\n", pt->precstr);
			exit (4);
		}
		else {
			g = pPrec[i];
		}
		if (asmout) {
			printf ("OPDAT %-16s,%4d,%4d,\t%-16s\n", pt->type, f, g,pt->tclass);
		}
		else {
			printf ("OPDAT (%-16s,%4d,%4d,\t%-16s,%-16s,%-16s\t)\n",
			  pt->type, f, g,pt->tclass, pt->bind, pt->eval);
		}
	}
	fclose (fh);
}




char *SkipBlank (FILE *fh, char *pStr, int cnt)
{
	int	len;

	for (;;) {
		if (fgets (pStr, cnt, fh) == NULL) {
			return (NULL);
		}
		len = strlen (pStr);
		if ((len == 1) || (*pStr == '#')) {
			continue;
		}
		*(pStr + len - 1) = 0;
		return (pStr);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\opprec\opprec.h ===
extern void   cdecl main(int, char **);
extern void     ReadMat(FILE *, int *, char **, int);
extern void     DumpMat(int *, int);
extern void     CopyMat(int *, int *, int);
extern void     AddClosure(int *, int);
extern char *   SkipBlank (FILE *, char *, int);


#define FALSE 0
#define TRUE ~FALSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\parcomp\makefile.inc ===
$(O)\parcomp.res: parcomp.rc

$(O)\parsync.res: parsync.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pageheap\makefile.inc ===
!IF "$(BUILD_ALT_DIR)" == "d"
PAGEHEAP_COPY_BIN_DIR=binD
!ELSE
PAGEHEAP_COPY_BIN_DIR=bin
!ENDIF

copyexe:
    if exist $(_OBJ_DIR)\i386\*.exe copy $(_OBJ_DIR)\i386\*.exe ..\$(PAGEHEAP_COPY_BIN_DIR)\i386
    if exist $(_OBJ_DIR)\i386\*.dll copy $(_OBJ_DIR)\i386\*.exe ..\$(PAGEHEAP_COPY_BIN_DIR)\i386
    if exist $(_OBJ_DIR)\Alpha\*.exe copy $(_OBJ_DIR)\Alpha\*.exe ..\$(PAGEHEAP_COPY_BIN_DIR)\alpha
    if exist $(_OBJ_DIR)\Alpha\*.dll copy $(_OBJ_DIR)\Alpha\*.exe ..\$(PAGEHEAP_COPY_BIN_DIR)\alpha
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\paranoia\paranoia.c ===
//#define NOSIGNAL	1
#define NOPAUSE         1

#include <stdio.h>
#include <stdlib.h>
#ifndef NOSIGNAL
#include <signal.h>
#endif
#include <setjmp.h>

#include <math.h>//extern double fabs(), floor(), log(), pow(), sqrt();
#include <float.h> //for rounding mode

#ifdef Single
#define FLOAT float
#define FABS(x) (float)fabs((double)(x))
#define FLOOR(x) (float)floor((double)(x))
#define LOG(x) (float)log((double)(x))
#define POW(x,y) (float)pow((double)(x),(double)(y))
#define SQRT(x) (float)sqrt((double)(x))
#else
#define FLOAT double
#define FABS(x) fabs(x)
#define FLOOR(x) floor(x)
#define LOG(x) log(x)
#define POW(x,y) pow(x,y)
#define SQRT(x) sqrt(x)
#endif

jmp_buf ovfl_buf;
typedef void (__cdecl *Sig_type)(int);
Sig_type sigsave;

#define KEYBOARD 0

FLOAT Radix, BInvrse, RadixD2, BMinusU2;
FLOAT Sign(), Random();

/*Small floating point constants.*/
FLOAT Zero = 0.0;
FLOAT Half = 0.5;
FLOAT One = 1.0;
FLOAT Two = 2.0;
FLOAT Three = 3.0;
FLOAT Four = 4.0;
FLOAT Five = 5.0;
FLOAT Eight = 8.0;
FLOAT Nine = 9.0;
FLOAT TwentySeven = 27.0;
FLOAT ThirtyTwo = 32.0;
FLOAT TwoForty = 240.0;
FLOAT MinusOne = -1.0;
FLOAT OneAndHalf = 1.5;
/*Integer constants*/
int NoTrials = 20; /*Number of tests for commutativity. */
#define False 0
#define True 1

/* Definitions for declared types
        Guard == (Yes, No);
        Rounding == (Chopped, Rounded, Other);
        Message == packed array [1..40] of char;
        Class == (Flaw, Defect, Serious, Failure);
          */
#define Yes 1
#define No  0
#define Chopped 2
#define Rounded 1
#define Other   0
#define Flaw    3
#define Defect  2
#define Serious 1
#define Failure 0
typedef int Guard, Rounding, Class;
typedef char Message;

/* Declarations of Variables */
int Indx;
char ch[8];
FLOAT AInvrse, A1;
FLOAT C, CInvrse;
FLOAT D, FourD;
FLOAT E0, E1, Exp2, E3, MinSqEr;
FLOAT SqEr, MaxSqEr, E9;
FLOAT Third;
FLOAT F6, F9;
FLOAT H, HInvrse;
int I;
FLOAT StickyBit, J;
FLOAT MyZero;
FLOAT Precision;
FLOAT Q, Q9;
FLOAT R, Random9;
FLOAT T, Underflow, S;
FLOAT OneUlp, UfThold, U1, U2;
FLOAT V, V0, V9;
FLOAT W;
FLOAT X, X1, X2, X8, Random1;
FLOAT Y, Y1, Y2, Random2;
FLOAT Z, PseudoZero, Z1, Z2, Z9;
int ErrCnt[4];
int fpecount;
int Milestone;
int PageNo;
int M, N, N1;
Guard GMult, GDiv, GAddSub;
Rounding RMult, RDiv, RAddSub, RSqrt;
int Break, Done, NotMonot, Monot, Anomaly, IEEE,
                SqRWrng, UfNGrad;
/* Computed constants. */
/*U1  gap below 1.0, i.e, 1.0-U1 is next number below 1.0 */
/*U2  gap above 1.0, i.e, 1.0+U2 is next number above 1.0 */

void Instructions(void);
void Pause(void);
void Heading(void);
void Characteristics(void);
void History(void);
void notify(char *s);
void TstPtUf(void);
void PrintIfNPositive(void);
void SR3980(void);
void IsYeqX(void);
void SR3750(void);
void NewD(void);
void SqXMinX (int ErrKind);
FLOAT Random(void);
void BadCond(int K, char *T);
void TstCond (int K, int Valid, char *T);
FLOAT Sign (FLOAT X);

/* floating point exception receiver */
 void
__cdecl
sigfpe(int x)
{
        x;
        fpecount++;
        printf("\n* * * FLOATING-POINT ERROR * * *\n");
        fflush(stdout);
        if (sigsave) {
#ifndef NOSIGNAL
                signal(SIGFPE, sigsave);
#endif
                sigsave = 0;
                longjmp(ovfl_buf, 1);
                }
        abort();
}

int __cdecl
main()
{
	_controlfp(_PC_53, _MCW_PC);
	/* First two assignments use integer right-hand sides. */
        Zero = 0;
        One = 1;
        Two = One + One;
        Three = Two + One;
        Four = Three + One;
        Five = Four + One;
        Eight = Four + Four;
        Nine = Three * Three;
        TwentySeven = Nine * Three;
        ThirtyTwo = Four * Eight;
        TwoForty = Four * Five * Three * Four;
        MinusOne = -One;
        Half = One / Two;
        OneAndHalf = One + Half;
        ErrCnt[Failure] = 0;
        ErrCnt[Serious] = 0;
        ErrCnt[Defect] = 0;
        ErrCnt[Flaw] = 0;
        PageNo = 1;
        /*=============================================*/
        Milestone = 0;
        /*=============================================*/
//#ifndef NOSIGNAL
//	 signal(SIGFPE, sigfpe);
//#endif
        Instructions();
        Pause();
        Heading();
        Pause();
        Characteristics();
        Pause();
        History();
        Pause();
        /*=============================================*/
        Milestone = 7;
        /*=============================================*/
        printf("Program is now RUNNING tests on small integers:\n");

        TstCond (Failure, (Zero + Zero == Zero) && (One - One == Zero)
                   && (One > Zero) && (One + One == Two),
                        "0+0 != 0, 1-1 != 0, 1 <= 0, or 1+1 != 2");
        Z = - Zero;
        if (Z != 0.0) {
                ErrCnt[Failure] = ErrCnt[Failure] + 1;
                printf("Comparison alleges that -0.0 is Non-zero!\n");
                U1 = 0.001;
                Radix = 1;
                TstPtUf();
                }
        TstCond (Failure, (Three == Two + One) && (Four == Three + One)
                   && (Four + Two * (- Two) == Zero)
                   && (Four - Three - One == Zero),
                   "3 != 2+1, 4 != 3+1, 4+2*(-2) != 0, or 4-3-1 != 0");
        TstCond (Failure, (MinusOne == (0 - One))
                   && (MinusOne + One == Zero ) && (One + MinusOne == Zero)
                   && (MinusOne + FABS(One) == Zero)
                   && (MinusOne + MinusOne * MinusOne == Zero),
                   "-1+1 != 0, (-1)+abs(1) != 0, or -1+(-1)*(-1) != 0");
        TstCond (Failure, Half + MinusOne + Half == Zero,
                  "1/2 + (-1) + 1/2 != 0");
        /*=============================================*/
        /*SPLIT
        part2();
        part3();
        part4();
        part5();
        part6();
        part7();
        part8();
        }
#include "paranoia.h"
part2(){
*/
        Milestone = 10;
        /*=============================================*/
        TstCond (Failure, (Nine == Three * Three)
                   && (TwentySeven == Nine * Three) && (Eight == Four + Four)
                   && (ThirtyTwo == Eight * Four)
                   && (ThirtyTwo - TwentySeven - Four - One == Zero),
                   "9 != 3*3, 27 != 9*3, 32 != 8*4, or 32-27-4-1 != 0");
        TstCond (Failure, (Five == Four + One) &&
                        (TwoForty == Four * Five * Three * Four)
                   && (TwoForty / Three - Four * Four * Five == Zero)
                   && ( TwoForty / Four - Five * Three * Four == Zero)
                   && ( TwoForty / Five - Four * Three * Four == Zero),
                  "5 != 4+1, 240/3 != 80, 240/4 != 60, or 240/5 != 48");
        if (ErrCnt[Failure] == 0) {
                printf("-1, 0, 1/2, 1, 2, 3, 4, 5, 9, 27, 32 & 240 are O.K.\n");
                printf("\n");
                }
        printf("Searching for Radix and Precision.\n");
        W = One;
        do  {
                W = W + W;
                Y = W + One;
                Z = Y - W;
                Y = Z - One;
                } while (MinusOne + FABS(Y) < Zero);
        /*.. now W is just big enough that |((W+1)-W)-1| >= 1 ...*/
        Precision = Zero;
        Y = One;
        do  {
                Radix = W + Y;
                Y = Y + Y;
                Radix = Radix - W;
                } while ( Radix == Zero);
        if (Radix < Two) Radix = One;
        printf("Radix = %f .\n", Radix);
        if (Radix != 1) {
                W = One;
                do  {
                        Precision = Precision + One;
                        W = W * Radix;
                        Y = W + One;
                        } while ((Y - W) == One);
                }
        /*... now W == Radix^Precision is barely too big to satisfy (W+1)-W == 1
                                                      ...*/
        U1 = One / W;
        U2 = Radix * U1;
        printf("Closest relative separation found is U1 = %.7e .\n\n", U1);
        printf("Recalculating radix and precision\n ");

        /*save old values*/
        E0 = Radix;
        E1 = U1;
        E9 = U2;
        E3 = Precision;

        X = Four / Three;
        Third = X - One;
        F6 = Half - Third;
        X = F6 + F6;
        X = FABS(X - Third);
        if (X < U2) X = U2;

        /*... now X = (unknown no.) ulps of 1+...*/
        do  {
                U2 = X;
                Y = Half * U2 + ThirtyTwo * U2 * U2;
                Y = One + Y;
                X = Y - One;
                } while ( ! ((U2 <= X) || (X <= Zero)));

        /*... now U2 == 1 ulp of 1 + ... */
        X = Two / Three;
        F6 = X - Half;
        Third = F6 + F6;
        X = Third - Half;
        X = FABS(X + F6);
        if (X < U1) X = U1;

        /*... now  X == (unknown no.) ulps of 1 -... */
        do  {
                U1 = X;
                Y = Half * U1 + ThirtyTwo * U1 * U1;
                Y = Half - Y;
                X = Half + Y;
                Y = Half - X;
                X = Half + Y;
                } while ( ! ((U1 <= X) || (X <= Zero)));
        /*... now U1 == 1 ulp of 1 - ... */
        if (U1 == E1) printf("confirms closest relative separation U1 .\n");
        else printf("gets better closest relative separation U1 = %.7e .\n", U1);
        W = One / U1;
        F9 = (Half - U1) + Half;
        Radix = FLOOR(0.01 + U2 / U1);
        if (Radix == E0) printf("Radix confirmed.\n");
        else printf("MYSTERY: recalculated Radix = %.7e .\n", Radix);
        TstCond (Defect, Radix <= Eight + Eight,
                   "Radix is too big: roundoff problems");
        TstCond (Flaw, (Radix == Two) || (Radix == 10)
                   || (Radix == One), "Radix is not as good as 2 or 10");
        /*=============================================*/
        Milestone = 20;
        /*=============================================*/
        TstCond (Failure, F9 - Half < Half,
                   "(1-U1)-1/2 < 1/2 is FALSE, prog. fails?");
        X = F9;
        I = 1;
        Y = X - Half;
        Z = Y - Half;
        TstCond (Failure, (X != One)
                   || (Z == Zero), "Comparison is fuzzy,X=1 but X-1/2-1/2 != 0");
        X = One + U2;
        I = 0;
        /*=============================================*/
        Milestone = 25;
        /*=============================================*/
        /*... BMinusU2 = nextafter(Radix, 0) */
        BMinusU2 = Radix - One;
        BMinusU2 = (BMinusU2 - U2) + One;
        /* Purify Integers */
        if (Radix != One)  {
                X = - TwoForty * LOG(U1) / LOG(Radix);
                Y = FLOOR(Half + X);
                if (FABS(X - Y) * Four < One) X = Y;
                Precision = X / TwoForty;
                Y = FLOOR(Half + Precision);
                if (FABS(Precision - Y) * TwoForty < Half) Precision = Y;
                }
        if ((Precision != FLOOR(Precision)) || (Radix == One)) {
                printf("Precision cannot be characterized by an Integer number\n");
                printf("of significant digits but, by itself, this is a minor flaw.\n");
                }
        if (Radix == One)
                printf("logarithmic encoding has precision characterized solely by U1.\n");
        else printf("The number of significant digits of the Radix is %f .\n",
                        Precision);
        TstCond (Serious, U2 * Nine * Nine * TwoForty < One,
                   "Precision worse than 5 decimal figures  ");
        /*=============================================*/
        Milestone = 30;
        /*=============================================*/
        /* Test for extra-precise subepressions */
        X = FABS(((Four / Three - One) - One / Four) * Three - One / Four);
        do  {
                Z2 = X;
                X = (One + (Half * Z2 + ThirtyTwo * Z2 * Z2)) - One;
                } while ( ! ((Z2 <= X) || (X <= Zero)));
        X = Y = Z = FABS((Three / Four - Two / Three) * Three - One / Four);
        do  {
                Z1 = Z;
                Z = (One / Two - ((One / Two - (Half * Z1 + ThirtyTwo * Z1 * Z1))
                        + One / Two)) + One / Two;
                } while ( ! ((Z1 <= Z) || (Z <= Zero)));
        do  {
                do  {
                        Y1 = Y;
                        Y = (Half - ((Half - (Half * Y1 + ThirtyTwo * Y1 * Y1)) + Half
                                )) + Half;
                        } while ( ! ((Y1 <= Y) || (Y <= Zero)));
                X1 = X;
                X = ((Half * X1 + ThirtyTwo * X1 * X1) - F9) + F9;
                } while ( ! ((X1 <= X) || (X <= Zero)));
        if ((X1 != Y1) || (X1 != Z1)) {
                BadCond(Serious, "Disagreements among the values X1, Y1, Z1,\n");
                printf("respectively  %.7e,  %.7e,  %.7e,\n", X1, Y1, Z1);
                printf("are symptoms of inconsistencies introduced\n");
                printf("by extra-precise evaluation of arithmetic subexpressions.\n");
                notify("Possibly some part of this");
                if ((X1 == U1) || (Y1 == U1) || (Z1 == U1))  printf(
                        "That feature is not tested further by this program.\n") ;
                }
        else  {
                if ((Z1 != U1) || (Z2 != U2)) {
                        if ((Z1 >= U1) || (Z2 >= U2)) {
                                BadCond(Failure, "");
                                notify("Precision");
                                printf("\tU1 = %.7e, Z1 - U1 = %.7e\n",U1,Z1-U1);
                                printf("\tU2 = %.7e, Z2 - U2 = %.7e\n",U2,Z2-U2);
                                }
                        else {
                                if ((Z1 <= Zero) || (Z2 <= Zero)) {
                                        printf("Because of unusual Radix = %f", Radix);
                                        printf(", or exact rational arithmetic a result\n");
                                        printf("Z1 = %.7e, or Z2 = %.7e ", Z1, Z2);
                                        notify("of an\nextra-precision");
                                        }
                                if (Z1 != Z2 || Z1 > Zero) {
                                        X = Z1 / U1;
                                        Y = Z2 / U2;
                                        if (Y > X) X = Y;
                                        Q = - LOG(X);
                                        printf("Some subexpressions appear to be calculated extra\n");
                                        printf("precisely with about %g extra B-digits, i.e.\n",
                                                (Q / LOG(Radix)));
                                        printf("roughly %g extra significant decimals.\n",
                                                Q / LOG(10.));
                                        }
                                printf("That feature is not tested further by this program.\n");
                                }
                        }
                }
        Pause();
        /*=============================================*/
        /*SPLIT
        }
#include "paranoia.h"
part3(){
*/
        Milestone = 35;
        /*=============================================*/
        if (Radix >= Two) {
                X = W / (Radix * Radix);
                Y = X + One;
                Z = Y - X;
                T = Z + U2;
                X = T - Z;
                TstCond (Failure, X == U2,
                        "Subtraction is not normalized X=Y,X+Z != Y+Z!");
                if (X == U2) printf(
                        "Subtraction appears to be normalized, as it should be.");
                }
        printf("\nChecking for guard digit in *, /, and -.\n");
        Y = F9 * One;
        Z = One * F9;
        X = F9 - Half;
        Y = (Y - Half) - X;
        Z = (Z - Half) - X;
        X = One + U2;
        T = X * Radix;
        R = Radix * X;
        X = T - Radix;
        X = X - Radix * U2;
        T = R - Radix;
        T = T - Radix * U2;
        X = X * (Radix - One);
        T = T * (Radix - One);
        if ((X == Zero) && (Y == Zero) && (Z == Zero) && (T == Zero)) GMult = Yes;
        else {
                GMult = No;
                TstCond (Serious, False,
                        "* lacks a Guard Digit, so 1*X != X");
                }
        Z = Radix * U2;
        X = One + Z;
        Y = FABS((X + Z) - X * X) - U2;
        X = One - U2;
        Z = FABS((X - U2) - X * X) - U1;
        TstCond (Failure, (Y <= Zero)
                   && (Z <= Zero), "* gets too many final digits wrong.\n");
        Y = One - U2;
        X = One + U2;
        Z = One / Y;
        Y = Z - X;
        X = One / Three;
        Z = Three / Nine;
        X = X - Z;
        T = Nine / TwentySeven;
        Z = Z - T;
        TstCond(Defect, X == Zero && Y == Zero && Z == Zero,
                "Division lacks a Guard Digit, so error can exceed 1 ulp\n\
or  1/3  and  3/9  and  9/27 may disagree");
        Y = F9 / One;
        X = F9 - Half;
        Y = (Y - Half) - X;
        X = One + U2;
        T = X / One;
        X = T - X;
        if ((X == Zero) && (Y == Zero) && (Z == Zero)) GDiv = Yes;
        else {
                GDiv = No;
                TstCond (Serious, False,
                        "Division lacks a Guard Digit, so X/1 != X");
                }
        X = One / (One + U2);
        Y = X - Half - Half;
        TstCond (Serious, Y < Zero,
                   "Computed value of 1/1.000..1 >= 1");
        X = One - U2;
        Y = One + Radix * U2;
        Z = X * Radix;
        T = Y * Radix;
        R = Z / Radix;
        StickyBit = T / Radix;
        X = R - X;
        Y = StickyBit - Y;
        TstCond (Failure, X == Zero && Y == Zero,
                        "* and/or / gets too many last digits wrong");
        Y = One - U1;
        X = One - F9;
        Y = One - Y;
        T = Radix - U2;
        Z = Radix - BMinusU2;
        T = Radix - T;
        if ((X == U1) && (Y == U1) && (Z == U2) && (T == U2)) GAddSub = Yes;
        else {
                GAddSub = No;
                TstCond (Serious, False,
                        "- lacks Guard Digit, so cancellation is obscured");
                }
        if (F9 != One && F9 - One >= Zero) {
                BadCond(Serious, "comparison alleges  (1-U1) < 1  although\n");
                printf("  subtraction yields  (1-U1) - 1 = 0 , thereby vitiating\n");
                printf("  such precautions against division by zero as\n");
                printf("  ...  if (X == 1.0) {.....} else {.../(X-1.0)...}\n");
                }
        if (GMult == Yes && GDiv == Yes && GAddSub == Yes) printf(
                "     *, /, and - appear to have guard digits, as they should.\n");
        /*=============================================*/
        Milestone = 40;
        /*=============================================*/
        Pause();
        printf("Checking rounding on multiply, divide and add/subtract.\n");
        RMult = Other;
        RDiv = Other;
        RAddSub = Other;
        RadixD2 = Radix / Two;
        A1 = Two;
        Done = False;
        do  {
                AInvrse = Radix;
                do  {
                        X = AInvrse;
                        AInvrse = AInvrse / A1;
                        } while ( ! (FLOOR(AInvrse) != AInvrse));
                Done = (X == One) || (A1 > Three);
                if (! Done) A1 = Nine + One;
                } while ( ! (Done));
        if (X == One) A1 = Radix;
        AInvrse = One / A1;
        X = A1;
        Y = AInvrse;
        Done = False;
        do  {
                Z = X * Y - Half;
                TstCond (Failure, Z == Half,
                        "X * (1/X) differs from 1");
                Done = X == Radix;
                X = Radix;
                Y = One / X;
                } while ( ! (Done));
        Y2 = One + U2;
        Y1 = One - U2;
        X = OneAndHalf - U2;
        Y = OneAndHalf + U2;
        Z = (X - U2) * Y2;
        T = Y * Y1;
        Z = Z - X;
        T = T - X;
        X = X * Y2;
        Y = (Y + U2) * Y1;
        X = X - OneAndHalf;
        Y = Y - OneAndHalf;
        if ((X == Zero) && (Y == Zero) && (Z == Zero) && (T <= Zero)) {
                X = (OneAndHalf + U2) * Y2;
                Y = OneAndHalf - U2 - U2;
                Z = OneAndHalf + U2 + U2;
                T = (OneAndHalf - U2) * Y1;
                X = X - (Z + U2);
                StickyBit = Y * Y1;
                S = Z * Y2;
                T = T - Y;
                Y = (U2 - Y) + StickyBit;
                Z = S - (Z + U2 + U2);
                StickyBit = (Y2 + U2) * Y1;
                Y1 = Y2 * Y1;
                StickyBit = StickyBit - Y2;
                Y1 = Y1 - Half;
                if ((X == Zero) && (Y == Zero) && (Z == Zero) && (T == Zero)
                        && ( StickyBit == Zero) && (Y1 == Half)) {
                        RMult = Rounded;
                        printf("Multiplication appears to round correctly.\n");
                        }
                else    if ((X + U2 == Zero) && (Y < Zero) && (Z + U2 == Zero)
                                && (T < Zero) && (StickyBit + U2 == Zero)
                                && (Y1 < Half)) {
                                RMult = Chopped;
                                printf("Multiplication appears to chop.\n");
                                }
                        else printf("* is neither chopped nor correctly rounded.\n");
                if ((RMult == Rounded) && (GMult == No)) notify("Multiplication");
                }
        else printf("* is neither chopped nor correctly rounded.\n");
        /*=============================================*/
        Milestone = 45;
        /*=============================================*/
        Y2 = One + U2;
        Y1 = One - U2;
        Z = OneAndHalf + U2 + U2;
        X = Z / Y2;
        T = OneAndHalf - U2 - U2;
        Y = (T - U2) / Y1;
        Z = (Z + U2) / Y2;
        X = X - OneAndHalf;
        Y = Y - T;
        T = T / Y1;
        Z = Z - (OneAndHalf + U2);
        T = (U2 - OneAndHalf) + T;
        if (! ((X > Zero) || (Y > Zero) || (Z > Zero) || (T > Zero))) {
                X = OneAndHalf / Y2;
                Y = OneAndHalf - U2;
                Z = OneAndHalf + U2;
                X = X - Y;
                T = OneAndHalf / Y1;
                Y = Y / Y1;
                T = T - (Z + U2);
                Y = Y - Z;
                Z = Z / Y2;
                Y1 = (Y2 + U2) / Y2;
                Z = Z - OneAndHalf;
                Y2 = Y1 - Y2;
                Y1 = (F9 - U1) / F9;
                if ((X == Zero) && (Y == Zero) && (Z == Zero) && (T == Zero)
                        && (Y2 == Zero) && (Y2 == Zero)
                        && (Y1 - Half == F9 - Half )) {
                        RDiv = Rounded;
                        printf("Division appears to round correctly.\n");
                        if (GDiv == No) notify("Division");
                        }
                else if ((X < Zero) && (Y < Zero) && (Z < Zero) && (T < Zero)
                        && (Y2 < Zero) && (Y1 - Half < F9 - Half)) {
                        RDiv = Chopped;
                        printf("Division appears to chop.\n");
                        }
                }
        if (RDiv == Other) printf("/ is neither chopped nor correctly rounded.\n");
        BInvrse = One / Radix;
        TstCond (Failure, (BInvrse * Radix - Half == Half),
                   "Radix * ( 1 / Radix ) differs from 1");
        /*=============================================*/
        /*SPLIT
        }
#include "paranoia.h"
part4(){
*/
        Milestone = 50;
        /*=============================================*/
        TstCond (Failure, ((F9 + U1) - Half == Half)
                   && ((BMinusU2 + U2 ) - One == Radix - One),
                   "Incomplete carry-propagation in Addition");
        X = One - U1 * U1;
        Y = One + U2 * (One - U2);
        Z = F9 - Half;
        X = (X - Half) - Z;
        Y = Y - One;
        if ((X == Zero) && (Y == Zero)) {
                RAddSub = Chopped;
                printf("Add/Subtract appears to be chopped.\n");
                }
        if (GAddSub == Yes) {
                X = (Half + U2) * U2;
                Y = (Half - U2) * U2;
                X = One + X;
                Y = One + Y;
                X = (One + U2) - X;
                Y = One - Y;
                if ((X == Zero) && (Y == Zero)) {
                        X = (Half + U2) * U1;
                        Y = (Half - U2) * U1;
                        X = One - X;
                        Y = One - Y;
                        X = F9 - X;
                        Y = One - Y;
                        if ((X == Zero) && (Y == Zero)) {
                                RAddSub = Rounded;
                                printf("Addition/Subtraction appears to round correctly.\n");
                                if (GAddSub == No) notify("Add/Subtract");
                                }
                        else printf("Addition/Subtraction neither rounds nor chops.\n");
                        }
                else printf("Addition/Subtraction neither rounds nor chops.\n");
                }
        else printf("Addition/Subtraction neither rounds nor chops.\n");
        S = One;
        X = One + Half * (One + Half);
        Y = (One + U2) * Half;
        Z = X - Y;
        T = Y - X;
        StickyBit = Z + T;
        if (StickyBit != Zero) {
                S = Zero;
                BadCond(Flaw, "(X - Y) + (Y - X) is non zero!\n");
                }
        StickyBit = Zero;
        if ((GMult == Yes) && (GDiv == Yes) && (GAddSub == Yes)
                && (RMult == Rounded) && (RDiv == Rounded)
                && (RAddSub == Rounded) && (FLOOR(RadixD2) == RadixD2)) {
                printf("Checking for sticky bit.\n");
                X = (Half + U1) * U2;
                Y = Half * U2;
                Z = One + Y;
                T = One + X;
                if ((Z - One <= Zero) && (T - One >= U2)) {
                        Z = T + Y;
                        Y = Z - X;
                        if ((Z - T >= U2) && (Y - T == Zero)) {
                                X = (Half + U1) * U1;
                                Y = Half * U1;
                                Z = One - Y;
                                T = One - X;
                                if ((Z - One == Zero) && (T - F9 == Zero)) {
                                        Z = (Half - U1) * U1;
                                        T = F9 - Z;
                                        Q = F9 - Y;
                                        if ((T - F9 == Zero) && (F9 - U1 - Q == Zero)) {
                                                Z = (One + U2) * OneAndHalf;
                                                T = (OneAndHalf + U2) - Z + U2;
                                                X = One + Half / Radix;
                                                Y = One + Radix * U2;
                                                Z = X * Y;
                                                if (T == Zero && X + Radix * U2 - Z == Zero) {
                                                        if (Radix != Two) {
                                                                X = Two + U2;
                                                                Y = X / Two;
                                                                if ((Y - One == Zero)) StickyBit = S;
                                                                }
                                                        else StickyBit = S;
                                                        }
                                                }
                                        }
                                }
                        }
                }
        if (StickyBit == One) printf("Sticky bit apparently used correctly.\n");
        else printf("Sticky bit used incorrectly or not at all.\n");
        TstCond (Flaw, !(GMult == No || GDiv == No || GAddSub == No ||
                        RMult == Other || RDiv == Other || RAddSub == Other),
                "lack(s) of guard digits or failure(s) to correctly round or chop\n\
(noted above) count as one flaw in the final tally below");
        /*=============================================*/
        Milestone = 60;
        /*=============================================*/
        printf("\n");
        printf("Does Multiplication commute?  ");
        printf("Testing on %d random pairs.\n", NoTrials);
        Random9 = SQRT(3.0);
        Random1 = Third;
        I = 1;
        do  {
                X = Random();
                Y = Random();
                Z9 = Y * X;
                Z = X * Y;
                Z9 = Z - Z9;
                I = I + 1;
                } while ( ! ((I > NoTrials) || (Z9 != Zero)));
        if (I == NoTrials) {
                Random1 = One + Half / Three;
                Random2 = (U2 + U1) + One;
                Z = Random1 * Random2;
                Y = Random2 * Random1;
                Z9 = (One + Half / Three) * ((U2 + U1) + One) - (One + Half /
                        Three) * ((U2 + U1) + One);
                }
        if (! ((I == NoTrials) || (Z9 == Zero)))
                BadCond(Defect, "X * Y == Y * X trial fails.\n");
        else printf("     No failures found in %d integer pairs.\n", NoTrials);
        /*=============================================*/
        Milestone = 70;
        /*=============================================*/
        printf("\nRunning test of square root(x).\n");
        TstCond (Failure, (Zero == SQRT(Zero))
                   && (- Zero == SQRT(- Zero))
                   && (One == SQRT(One)), "Square root of 0.0, -0.0 or 1.0 wrong");
        MinSqEr = Zero;
        MaxSqEr = Zero;
        J = Zero;
        X = Radix;
        OneUlp = U2;
        SqXMinX (Serious);
        X = BInvrse;
        OneUlp = BInvrse * U1;
        SqXMinX (Serious);
        X = U1;
        OneUlp = U1 * U1;
        SqXMinX (Serious);
        if (J != Zero) Pause();
        printf("Testing if sqrt(X * X) == X for %d Integers X.\n", NoTrials);
        J = Zero;
        X = Two;
        Y = Radix;
        if ((Radix != One)) do  {
                X = Y;
                Y = Radix * Y;
                } while ( ! ((Y - X >= NoTrials)));
        OneUlp = X * U2;
        I = 1;
        while (I <= NoTrials) {
                X = X + One;
                SqXMinX (Defect);
                if (J > Zero) break;
                I = I + 1;
                }
        printf("Test for sqrt monotonicity.\n");
        I = - 1;
        X = BMinusU2;
        Y = Radix;
        Z = Radix + Radix * U2;
        NotMonot = False;
        Monot = False;
        while ( ! (NotMonot || Monot)) {
                I = I + 1;
                X = SQRT(X);
                Q = SQRT(Y);
                Z = SQRT(Z);
                if ((X > Q) || (Q > Z)) NotMonot = True;
                else {
                        Q = FLOOR(Q + Half);
                        if ((I > 0) || (Radix == Q * Q)) Monot = True;
                        else if (I > 0) {
                        if (I > 1) Monot = True;
                        else {
                                Y = Y * BInvrse;
                                X = Y - U1;
                                Z = Y + U1;
                                }
                        }
                        else {
                                Y = Q;
                                X = Y - U2;
                                Z = Y + U2;
                                }
                        }
                }
        if (Monot) printf("sqrt has passed a test for Monotonicity.\n");
        else {
                BadCond(Defect, "");
                printf("sqrt(X) is non-monotonic for X near %.7e .\n", Y);
                }
        /*=============================================*/
        /*SPLIT
        }
#include "paranoia.h"
part5(){
*/
        Milestone = 80;
        /*=============================================*/
        MinSqEr = MinSqEr + Half;
        MaxSqEr = MaxSqEr - Half;
        Y = (SQRT(One + U2) - One) / U2;
        SqEr = (Y - One) + U2 / Eight;
        if (SqEr > MaxSqEr) MaxSqEr = SqEr;
        SqEr = Y + U2 / Eight;
        if (SqEr < MinSqEr) MinSqEr = SqEr;
        Y = ((SQRT(F9) - U2) - (One - U2)) / U1;
        SqEr = Y + U1 / Eight;
        if (SqEr > MaxSqEr) MaxSqEr = SqEr;
        SqEr = (Y + One) + U1 / Eight;
        if (SqEr < MinSqEr) MinSqEr = SqEr;
        OneUlp = U2;
        X = OneUlp;
        for( Indx = 1; Indx <= 3; ++Indx) {
                Y = SQRT((X + U1 + X) + F9);
                Y = ((Y - U2) - ((One - U2) + X)) / OneUlp;
                Z = ((U1 - X) + F9) * Half * X * X / OneUlp;
                SqEr = (Y + Half) + Z;
                if (SqEr < MinSqEr) MinSqEr = SqEr;
                SqEr = (Y - Half) + Z;
                if (SqEr > MaxSqEr) MaxSqEr = SqEr;
                if (((Indx == 1) || (Indx == 3)))
                        X = OneUlp * Sign (X) * FLOOR(Eight / (Nine * SQRT(OneUlp)));
                else {
                        OneUlp = U1;
                        X = - OneUlp;
                        }
                }
        /*=============================================*/
        Milestone = 85;
        /*=============================================*/
        SqRWrng = False;
        Anomaly = False;
        RSqrt = Other; /* ~dgh */
        if (Radix != One) {
                printf("Testing whether sqrt is rounded or chopped.\n");
                D = FLOOR(Half + POW(Radix, One + Precision - FLOOR(Precision)));
        /* ... == Radix^(1 + fract) if (Precision == Integer + fract. */
                X = D / Radix;
                Y = D / A1;
                if ((X != FLOOR(X)) || (Y != FLOOR(Y))) {
                        Anomaly = True;
                        }
                else {
                        X = Zero;
                        Z2 = X;
                        Y = One;
                        Y2 = Y;
                        Z1 = Radix - One;
                        FourD = Four * D;
                        do  {
                                if (Y2 > Z2) {
                                        Q = Radix;
                                        Y1 = Y;
                                        do  {
                                                X1 = FABS(Q + FLOOR(Half - Q / Y1) * Y1);
                                                Q = Y1;
                                                Y1 = X1;
                                                } while ( ! (X1 <= Zero));
                                        if (Q <= One) {
                                                Z2 = Y2;
                                                Z = Y;
                                                }
                                        }
                                Y = Y + Two;
                                X = X + Eight;
                                Y2 = Y2 + X;
                                if (Y2 >= FourD) Y2 = Y2 - FourD;
                                } while ( ! (Y >= D));
                        X8 = FourD - Z2;
                        Q = (X8 + Z * Z) / FourD;
                        X8 = X8 / Eight;
                        if (Q != FLOOR(Q)) Anomaly = True;
                        else {
                                Break = False;
                                do  {
                                        X = Z1 * Z;
                                        X = X - FLOOR(X / Radix) * Radix;
                                        if (X == One)
                                                Break = True;
                                        else
                                                Z1 = Z1 - One;
                                        } while ( ! (Break || (Z1 <= Zero)));
                                if ((Z1 <= Zero) && (! Break)) Anomaly = True;
                                else {
                                        if (Z1 > RadixD2) Z1 = Z1 - Radix;
                                        do  {
                                                NewD();
                                                } while ( ! (U2 * D >= F9));
                                        if (D * Radix - D != W - D) Anomaly = True;
                                        else {
                                                Z2 = D;
                                                I = 0;
                                                Y = D + (One + Z) * Half;
                                                X = D + Z + Q;
                                                SR3750();
                                                Y = D + (One - Z) * Half + D;
                                                X = D - Z + D;
                                                X = X + Q + X;
                                                SR3750();
                                                NewD();
                                                if (D - Z2 != W - Z2) Anomaly = True;
                                                else {
                                                        Y = (D - Z2) + (Z2 + (One - Z) * Half);
                                                        X = (D - Z2) + (Z2 - Z + Q);
                                                        SR3750();
                                                        Y = (One + Z) * Half;
                                                        X = Q;
                                                        SR3750();
                                                        if (I == 0) Anomaly = True;
                                                        }
                                                }
                                        }
                                }
                        }
                if ((I == 0) || Anomaly) {
                        BadCond(Failure, "Anomalous arithmetic with Integer < ");
                        printf("Radix^Precision = %.7e\n", W);
                        printf(" fails test whether sqrt rounds or chops.\n");
                        SqRWrng = True;
                        }
                }
        if (! Anomaly) {
                if (! ((MinSqEr < Zero) || (MaxSqEr > Zero))) {
                        RSqrt = Rounded;
                        printf("Square root appears to be correctly rounded.\n");
                        }
                else  {
                        if ((MaxSqEr + U2 > U2 - Half) || (MinSqEr > Half)
                                || (MinSqEr + Radix < Half)) SqRWrng = True;
                        else {
                                RSqrt = Chopped;
                                printf("Square root appears to be chopped.\n");
                                }
                        }
                }
        if (SqRWrng) {
                printf("Square root is neither chopped nor correctly rounded.\n");
                printf("Observed errors run from %.7e ", MinSqEr - Half);
                printf("to %.7e ulps.\n", Half + MaxSqEr);
                TstCond (Serious, MaxSqEr - MinSqEr < Radix * Radix,
                        "sqrt gets too many last digits wrong");
                }
        /*=============================================*/
        Milestone = 90;
        /*=============================================*/
        Pause();
        printf("Testing powers Z^i for small Integers Z and i.\n");
        N = 0;
        /* ... test powers of zero. */
        I = 0;
        Z = -Zero;
        Break = False;
        do  {
                X = One;
                SR3980();
                if (I <= 10) {
                        I = 1023;
                        SR3980();
                        }
                if (Z == MinusOne) Break = True;
                else {
                        Z = MinusOne;
                        PrintIfNPositive();
                        N = 0;
                        /* .. if(-1)^N is invalid, replace MinusOne by One. */
                        I = - 4;
                        }
                } while ( ! Break);
        PrintIfNPositive();
        N1 = N;
        N = 0;
        Z = A1;
        Break = False;
        do  {
                X = Z;
                I = 1;
                SR3980();
                if (Z == AInvrse) Break = True;
                else Z = AInvrse;
                } while ( ! (Break));
        /*=============================================*/
                Milestone = 100;
        /*=============================================*/
        /*  Powers of Radix have been tested, */
        /*         next try a few primes     */
        M = NoTrials;
        Z = Three;
        do  {
                X = Z;
                I = 1;
                SR3980();
                do  {
                        Z = Z + Two;
                        } while ( Three * FLOOR(Z / Three) == Z );
                } while ( Z < Eight * Three );
        if (N > 0) {
                printf("Errors like this may invalidate financial calculations\n");
                printf("\tinvolving interest rates.\n");
                }
        PrintIfNPositive();
        N += N1;
        if (N == 0) printf("... no discrepancis found.\n");
        if (N > 0) Pause();
        else printf("\n");
        /*=============================================*/
        /*SPLIT
        }
#include "paranoia.h"
part6(){
*/
        Milestone = 110;
        /*=============================================*/
        printf("Seeking Underflow thresholds UfThold and E0.\n");
        D = U1;
        if (Precision != FLOOR(Precision)) {
                D = BInvrse;
                X = Precision;
                do  {
                        D = D * BInvrse;
                        X = X - One;
                        } while ( X > Zero);
                }
        Y = One;
        Z = D;
        /* ... D is power of 1/Radix < 1. */
        do  {
                C = Y;
                Y = Z;
                Z = Y * Y;
                } while ((Y > Z) && (Z + Z > Z));
        Y = C;
        Z = Y * D;
        do  {
                C = Y;
                Y = Z;
                Z = Y * D;
                } while ((Y > Z) && (Z + Z > Z));
        if (Radix < Two) HInvrse = Two;
        else HInvrse = Radix;
        H = One / HInvrse;
        /* ... 1/HInvrse == H == Min(1/Radix, 1/2) */
        CInvrse = One / C;
        E0 = C;
        Z = E0 * H;
        /* ...1/Radix^(BIG Integer) << 1 << CInvrse == 1/C */
        do  {
                Y = E0;
                E0 = Z;
                Z = E0 * H;
                } while ((E0 > Z) && (Z + Z > Z));
        UfThold = E0;
        E1 = Zero;
        Q = Zero;
        E9 = U2;
        S = One + E9;
        D = C * S;
        if (D <= C) {
                E9 = Radix * U2;
                S = One + E9;
                D = C * S;
                if (D <= C) {
                        BadCond(Failure, "multiplication gets too many last digits wrong.\n");
                        Underflow = E0;
                        Y1 = Zero;
                        PseudoZero = Z;
                        Pause();
                        }
                }
        else {
                Underflow = D;
                PseudoZero = Underflow * H;
                UfThold = Zero;
                do  {
                        Y1 = Underflow;
                        Underflow = PseudoZero;
                        if (E1 + E1 <= E1) {
                                Y2 = Underflow * HInvrse;
                                E1 = FABS(Y1 - Y2);
                                Q = Y1;
                                if ((UfThold == Zero) && (Y1 != Y2)) UfThold = Y1;
                                }
                        PseudoZero = PseudoZero * H;
                        } while ((Underflow > PseudoZero)
                                && (PseudoZero + PseudoZero > PseudoZero));
                }
        /* Comment line 4530 .. 4560 */
        if (PseudoZero != Zero) {
                printf("\n");
                Z = PseudoZero;
        /* ... Test PseudoZero for "phoney- zero" violates */
        /* ... PseudoZero < Underflow or PseudoZero < PseudoZero + PseudoZero
                   ... */
                if (PseudoZero <= Zero) {
                        BadCond(Failure, "Positive expressions can underflow to an\n");
                        printf("allegedly negative value\n");
                        printf("PseudoZero that prints out as: %g .\n", PseudoZero);
                        X = - PseudoZero;
                        if (X <= Zero) {
                                printf("But -PseudoZero, which should be\n");
                                printf("positive, isn't; it prints out as  %g .\n", X);
                                }
                        }
                else {
                        BadCond(Flaw, "Underflow can stick at an allegedly positive\n");
                        printf("value PseudoZero that prints out as %g .\n", PseudoZero);
                        }
                TstPtUf();
                }
        /*=============================================*/
        Milestone = 120;
        /*=============================================*/
        if (CInvrse * Y > CInvrse * Y1) {
                S = H * S;
                E0 = Underflow;
                }
        if (! ((E1 == Zero) || (E1 == E0))) {
                BadCond(Defect, "");
                if (E1 < E0) {
                        printf("Products underflow at a higher");
                        printf(" threshold than differences.\n");
                        if (PseudoZero == Zero)
                        E0 = E1;
                        }
                else {
                        printf("Difference underflows at a higher");
                        printf(" threshold than products.\n");
                        }
                }
        printf("Smallest strictly positive number found is E0 = %g .\n", E0);
        Z = E0;
        TstPtUf();
        Underflow = E0;
        if (N == 1) Underflow = Y;
        I = 4;
        if (E1 == Zero) I = 3;
        if (UfThold == Zero) I = I - 2;
        UfNGrad = True;
        switch (I)  {
                case    1:
                UfThold = Underflow;
                if ((CInvrse * Q) != ((CInvrse * Y) * S)) {
                        UfThold = Y;
                        BadCond(Failure, "Either accuracy deteriorates as numbers\n");
                        printf("approach a threshold = %.17e\n", UfThold);;
                        printf(" coming down from %.17e\n", C);
                        printf(" or else multiplication gets too many last digits wrong.\n");
                        }
                Pause();
                break;

                case    2:
                BadCond(Failure, "Underflow confuses Comparison, which alleges that\n");
                printf("Q == Y while denying that |Q - Y| == 0; these values\n");
                printf("print out as Q = %.17e, Y = %.17e .\n", Q, Y2);
                printf ("|Q - Y| = %.17e .\n" , FABS(Q - Y2));
                UfThold = Q;
                break;

                case    3:
                X = X;
                break;

                case    4:
                if ((Q == UfThold) && (E1 == E0)
                        && (FABS( UfThold - E1 / E9) <= E1)) {
                        UfNGrad = False;
                        printf("Underflow is gradual; it incurs Absolute Error =\n");
                        printf("(roundoff in UfThold) < E0.\n");
                        Y = E0 * CInvrse;
                        Y = Y * (OneAndHalf + U2);
                        X = CInvrse * (One + U2);
                        Y = Y / X;
                        IEEE = (Y == E0);
                        }
                }
        if (UfNGrad) {
                printf("\n");
                sigsave = sigfpe;
                if (setjmp(ovfl_buf)) {
                        printf("Underflow / UfThold failed!\n");
                        R = H + H;
                        }
                else R = SQRT(Underflow / UfThold);
                printf("### %.17e %.17e %.17e %.17e\n", Underflow, UfThold, R, H);
                sigsave = 0;
                if (R <= H) {
                        Z = R * UfThold;
                        X = Z * (One + R * H * (One + H));
                        }
                else {
                        Z = UfThold;
                        X = Z * (One + H * H * (One + H));
                        }
                printf("### %.17e %.17e %.17e %.17e %.17e %.17e\n", Underflow, UfThold, R, H, X, Z);
                if (! ((X == Z) || (X - Z != Zero))) {
                        BadCond(Flaw, "");
                        printf("X = %.17e\n\tis not equal to Z = %.17e .\n", X, Z);
                        Z9 = X - Z;
                        printf("yet X - Z yields %.17e .\n", Z9);
                        printf("    Should this NOT signal Underflow, ");
                        printf("this is a SERIOUS DEFECT\nthat causes ");
                        printf("confusion when innocent statements like\n");;
                        printf("    if (X == Z)  ...  else");
                        printf("  ... (f(X) - f(Z)) / (X - Z) ...\n");
                        printf("encounter Division by Zero although actually\n");
                        sigsave = sigfpe;
                        if (setjmp(ovfl_buf)) printf("X / Z fails!\n");
                        else printf("X / Z = 1 + %g .\n", (X / Z - Half) - Half);
                        sigsave = 0;
                        }
                }
        printf("The Underflow threshold is %.17e, %s\n", UfThold,
                   " below which");
        printf("calculation may suffer larger Relative error than ");
        printf("merely roundoff.\n");
        Y2 = U1 * U1;
        Y = Y2 * Y2;
        Y2 = Y * U1;
        if (Y2 <= UfThold) {
                if (Y > E0) {
                        BadCond(Defect, "");
                        I = 5;
                        }
                else {
                        BadCond(Serious, "");
                        I = 4;
                        }
                printf("Range is too narrow; U1^%d Underflows.\n", I);
                }
        /*=============================================*/
        /*SPLIT
        }
#include "paranoia.h"
part7(){
*/
        Milestone = 130;
        /*=============================================*/
        Y = - FLOOR(Half - TwoForty * LOG(UfThold) / LOG(HInvrse)) / TwoForty;
        Y2 = Y + Y;
        printf("Since underflow occurs below the threshold\n");
        printf("UfThold = (%.17e) ^ (%.17e)\nonly underflow ", HInvrse, Y);
        printf("should afflict the expression\n\t(%.17e) ^ (%.17e);\n", HInvrse, Y);
        V9 = POW(HInvrse, Y2);
        printf("actually calculating yields: %.17e .\n", V9);
        if (! ((V9 >= Zero) && (V9 <= (Radix + Radix + E9) * UfThold))) {
                BadCond(Serious, "this is not between 0 and underflow\n");
                printf("   threshold = %.17e .\n", UfThold);
                }
        else if (! (V9 > UfThold * (One + E9)))
                printf("This computed value is O.K.\n");
        else {
                BadCond(Defect, "this is not between 0 and underflow\n");
                printf("   threshold = %.17e .\n", UfThold);
                }
        /*=============================================*/
        Milestone = 140;
        /*=============================================*/
        printf("\n");
        /* ...calculate Exp2 == exp(2) == 7.389056099... */
        X = Zero;
        I = 2;
        Y = Two * Three;
        Q = Zero;
        N = 0;
        do  {
                Z = X;
                I = I + 1;
                Y = Y / (I + I);
                R = Y + Q;
                X = Z + R;
                Q = (Z - X) + R;
                } while(X > Z);
        Z = (OneAndHalf + One / Eight) + X / (OneAndHalf * ThirtyTwo);
        X = Z * Z;
        Exp2 = X * X;
        X = F9;
        Y = X - U1;
        printf("Testing X^((X + 1) / (X - 1)) vs. exp(2) = %.17e as X -> 1.\n",
                Exp2);
        for(I = 1;;) {
                Z = X - BInvrse;
                Z = (X + One) / (Z - (One - BInvrse));
                Q = POW(X, Z) - Exp2;
                if (FABS(Q) > TwoForty * U2) {
                        N = 1;
                        V9 = (X - BInvrse) - (One - BInvrse);
                        BadCond(Defect, "Calculated");
                        printf(" %.17e for\n", POW(X,Z));
                        printf("\t(1 + (%.17e) ^ (%.17e);\n", V9, Z);
                        printf("\tdiffers from correct value by %.17e .\n", Q);
                        printf("\tThis much error may spoil financial\n");
                        printf("\tcalculations involving tiny interest rates.\n");
                        break;
                        }
                else {
                        Z = (Y - X) * Two + Y;
                        X = Y;
                        Y = Z;
                        Z = One + (X - F9)*(X - F9);
                        if (Z > One && I < NoTrials) I++;
                        else  {
                                if (X > One) {
                                        if (N == 0)
                                           printf("Accuracy seems adequate.\n");
                                        break;
                                        }
                                else {
                                        X = One + U2;
                                        Y = U2 + U2;
                                        Y += X;
                                        I = 1;
                                        }
                                }
                        }
                }
        /*=============================================*/
        Milestone = 150;
        /*=============================================*/
        printf("Testing powers Z^Q at four nearly extreme values.\n");
        N = 0;
        Z = A1;
        Q = FLOOR(Half - LOG(C) / LOG(A1));
        Break = False;
        do  {
                X = CInvrse;
                Y = POW(Z, Q);
                IsYeqX();
                Q = - Q;
                X = C;
                Y = POW(Z, Q);
                IsYeqX();
                if (Z < One) Break = True;
                else Z = AInvrse;
                } while ( ! (Break));
        PrintIfNPositive();
        if (N == 0) printf(" ... no discrepancies found.\n");
        printf("\n");

        /*=============================================*/
        Milestone = 160;
        /*=============================================*/
        Pause();
        printf("Searching for Overflow threshold:\n");
        printf("This may generate an error.\n");
        Y = - CInvrse;
        V9 = HInvrse * Y;
        sigsave = sigfpe;
        if (setjmp(ovfl_buf)) { I = 0; V9 = Y; goto overflow; }
        do {
                V = Y;
                Y = V9;
                V9 = HInvrse * Y;
                } while(V9 < Y);
        I = 1;
overflow:
        sigsave = 0;
        Z = V9;
        printf("Can `Z = -Y' overflow?\n");
        printf("Trying it on Y = %.17e .\n", Y);
        V9 = - Y;
        V0 = V9;
        if (V - Y == V + V0) printf("Seems O.K.\n");
        else {
                printf("finds a ");
                BadCond(Flaw, "-(-Y) differs from Y.\n");
                }
        if (Z != Y) {
                BadCond(Serious, "");
                printf("overflow past %.17e\n\tshrinks to %.17e .\n", Y, Z);
                }
        if (I) {
                Y = V * (HInvrse * U2 - HInvrse);
                Z = Y + ((One - HInvrse) * U2) * V;
                if (Z < V0) Y = Z;
                if (Y < V0) V = Y;
                if (V0 - V < V0) V = V0;
                }
        else {
                V = Y * (HInvrse * U2 - HInvrse);
                V = V + ((One - HInvrse) * U2) * Y;
                }
        printf("Overflow threshold is V  = %.17e .\n", V);
        if (I) printf("Overflow saturates at V0 = %.17e .\n", V0);
        else printf("There is no saturation value because \
the system traps on overflow.\n");
        V9 = V * One;
        printf("No Overflow should be signaled for V * 1 = %.17e\n", V9);
        V9 = V / One;
        printf("                           nor for V / 1 = %.17e .\n", V9);
        printf("Any overflow signal separating this * from the one\n");
        printf("above is a DEFECT.\n");
        /*=============================================*/
        Milestone = 170;
        /*=============================================*/
        if (!(-V < V && -V0 < V0 && -UfThold < V && UfThold < V)) {
                BadCond(Failure, "Comparisons involving ");
                printf("+-%g, +-%g\nand +-%g are confused by Overflow.",
                        V, V0, UfThold);
                }
        /*=============================================*/
        Milestone = 175;
        /*=============================================*/
        printf("\n");
        for(Indx = 1; Indx <= 3; ++Indx) {
                switch (Indx)  {
                        case 1: Z = UfThold; break;
                        case 2: Z = E0; break;
                        case 3: Z = PseudoZero; break;
                        }
                if (Z != Zero) {
                        V9 = SQRT(Z);
                        Y = V9 * V9;
                        if (Y / (One - Radix * E9) < Z
                           || Y > (One + Radix * E9) * Z) { /* dgh: + E9 --> * E9 */
                                if (V9 > U1) BadCond(Serious, "");
                                else BadCond(Defect, "");
                                printf("Comparison alleges that what prints as Z = %.17e\n", Z);
                                printf(" is too far from sqrt(Z) ^ 2 = %.17e .\n", Y);
                                }
                        }
                }
        /*=============================================*/
        Milestone = 180;
        /*=============================================*/
        for(Indx = 1; Indx <= 2; ++Indx) {
                if (Indx == 1) Z = V;
                else Z = V0;
                V9 = SQRT(Z);
                X = (One - Radix * E9) * V9;
                V9 = V9 * X;
                if (((V9 < (One - Two * Radix * E9) * Z) || (V9 > Z))) {
                        Y = V9;
                        if (X < W) BadCond(Serious, "");
                        else BadCond(Defect, "");
                        printf("Comparison alleges that Z = %17e\n", Z);
                        printf(" is too far from sqrt(Z) ^ 2 (%.17e) .\n", Y);
                        }
                }
        /*=============================================*/
        /*SPLIT
        }
#include "paranoia.h"
part8(){
*/
        Milestone = 190;
        /*=============================================*/
        Pause();
        X = UfThold * V;
        Y = Radix * Radix;
        if (X*Y < One || X > Y) {
                if (X * Y < U1 || X > Y/U1) BadCond(Defect, "Badly");
                else BadCond(Flaw, "");

                printf(" unbalanced range; UfThold * V = %.17e\n\t%s\n",
                        X, "is too far from 1.\n");
                }
        /*=============================================*/
        Milestone = 200;
        /*=============================================*/
        for (Indx = 1; Indx <= 5; ++Indx)  {
                X = F9;
                switch (Indx)  {
                        case 2: X = One + U2; break;
                        case 3: X = V; break;
                        case 4: X = UfThold; break;
                        case 5: X = Radix;
                        }
                Y = X;
                sigsave = sigfpe;
                if (setjmp(ovfl_buf))
                        printf("  X / X  traps when X = %g\n", X);
                else {
                        V9 = (Y / X - Half) - Half;
                        if (V9 == Zero) continue;
                        if (V9 == - U1 && Indx < 5) BadCond(Flaw, "");
                        else BadCond(Serious, "");
                        printf("  X / X differs from 1 when X = %.17e\n", X);
                        printf("  instead, X / X - 1/2 - 1/2 = %.17e .\n", V9);
                        }
                sigsave = 0;
                }
        /*=============================================*/
        Milestone = 210;
        /*=============================================*/
        MyZero = Zero;
        printf("\n");
        printf("What message and/or values does Division by Zero produce?\n") ;
#ifndef NOPAUSE
        printf("This can interupt your program.  You can ");
        printf("skip this part if you wish.\n");
        printf("Do you wish to compute 1 / 0? ");
        fflush(stdout);
        read (KEYBOARD, ch, 8);
        if ((ch[0] == 'Y') || (ch[0] == 'y')) {
#endif
                sigsave = sigfpe;
                printf("    Trying to compute 1 / 0 produces ...");
                if (!setjmp(ovfl_buf)) printf("  %.7e .\n", One / MyZero);
                sigsave = 0;
#ifndef NOPAUSE
                }
        else printf("O.K.\n");
        printf("\nDo you wish to compute 0 / 0? ");
        fflush(stdout);
        read (KEYBOARD, ch, 80);
        if ((ch[0] == 'Y') || (ch[0] == 'y')) {
#endif
                sigsave = sigfpe;
                printf("\n    Trying to compute 0 / 0 produces ...");
                if (!setjmp(ovfl_buf)) printf("  %.7e .\n", Zero / MyZero);
                sigsave = 0;
#ifndef NOPAUSE
                }
        else printf("O.K.\n");
#endif
        /*=============================================*/
        Milestone = 220;
        /*=============================================*/
        Pause();
        printf("\n");
        {
                static char *msg[] = {
                        "FAILUREs  encountered =",
                        "SERIOUS DEFECTs  discovered =",
                        "DEFECTs  discovered =",
                        "FLAWs  discovered =" };
                int i;
                for(i = 0; i < 4; i++) if (ErrCnt[i])
                        printf("The number of  %-29s %d.\n",
                                msg[i], ErrCnt[i]);
                }
        printf("\n");
        if ((ErrCnt[Failure] + ErrCnt[Serious] + ErrCnt[Defect]
                        + ErrCnt[Flaw]) > 0) {
                if ((ErrCnt[Failure] + ErrCnt[Serious] + ErrCnt[
                        Defect] == 0) && (ErrCnt[Flaw] > 0)) {
                        printf("The arithmetic diagnosed seems ");
                        printf("Satisfactory though flawed.\n");
                        }
                if ((ErrCnt[Failure] + ErrCnt[Serious] == 0)
                        && ( ErrCnt[Defect] > 0)) {
                        printf("The arithmetic diagnosed may be Acceptable\n");
                        printf("despite inconvenient Defects.\n");
                        }
                if ((ErrCnt[Failure] + ErrCnt[Serious]) > 0) {
                        printf("The arithmetic diagnosed has ");
                        printf("unacceptable Serious Defects.\n");
                        }
                if (ErrCnt[Failure] > 0) {
                        printf("Potentially fatal FAILURE may have spoiled this");
                        printf(" program's subsequent diagnoses.\n");
                        }
                }
        else {
                printf("No failures, defects nor flaws have been discovered.\n");
                if (! ((RMult == Rounded) && (RDiv == Rounded)
                        && (RAddSub == Rounded) && (RSqrt == Rounded)))
                        printf("The arithmetic diagnosed seems Satisfactory.\n");
                else {
                        if (StickyBit >= One &&
                                (Radix - Two) * (Radix - Nine - One) == Zero) {
                                printf("Rounding appears to conform to ");
                                printf("the proposed IEEE standard P");
                                if ((Radix == Two) &&
                                         ((Precision - Four * Three * Two) *
                                          ( Precision - TwentySeven -
                                           TwentySeven + One) == Zero))
                                        printf("754");
                                else printf("854");
                                if (IEEE) printf(".\n");
                                else {
                                        printf(",\nexcept for possibly Double Rounding");
                                        printf(" during Gradual Underflow.\n");
                                        }
                                }
                        printf("The arithmetic diagnosed appears to be Excellent!\n");
                        }
                }
        if (fpecount)
                printf("\nA total of %d floating point exceptions were registered.\n",
                        fpecount);
	printf("END OF TEST.\n");

/***  Begin NON_PARANOIA modification  ***/
	return( 0 );
/***  End NON_PARANOIA modification  ***/
	}

/*SPLIT subs.c
#include "paranoia.h"
*/

/* Sign */

FLOAT Sign (X)
FLOAT X;
{ return X >= 0. ? 1.0 : -1.0; }

/* Pause */

void Pause(void)
{
#ifndef NOPAUSE
        char ch[8];

        printf("\nTo continue, press RETURN");
        fflush(stdout);
        read(KEYBOARD, ch, 8);
#endif
        printf("\nDiagnosis resumes after milestone Number %d", Milestone);
        printf("          Page: %d\n\n", PageNo);
        ++Milestone;
        ++PageNo;
        }

 /* TstCond */

void TstCond (int K, int Valid, char *T)
{ if (! Valid) { BadCond(K,T); printf(".\n"); } }

void BadCond(int K, char *T)
{
        static char *msg[] = { "FAILURE", "SERIOUS DEFECT", "DEFECT", "FLAW" };

        ErrCnt [K] = ErrCnt [K] + 1;
        printf("%s:  %s", msg[K], T);
        }

/* Random */
/*  Random computes
     X = (Random1 + Random9)^5
     Random1 = X - FLOOR(X) + 0.000005 * X;
   and returns the new value of Random1
*/

FLOAT Random()
{
        FLOAT X, Y;

        X = Random1 + Random9;
        Y = X * X;
        Y = Y * Y;
        X = X * Y;
        Y = X - FLOOR(X);
        Random1 = Y + X * 0.000005;
        return(Random1);
        }

/* SqXMinX */

void SqXMinX (int ErrKind)
{
        FLOAT XA, XB;

        XB = X * BInvrse;
        XA = X - XB;
        SqEr = ((SQRT(X * X) - XB) - XA) / OneUlp;
        if (SqEr != Zero) {
                if (SqEr < MinSqEr) MinSqEr = SqEr;
                if (SqEr > MaxSqEr) MaxSqEr = SqEr;
                J = J + 1.0;
                BadCond(ErrKind, "\n");
                printf("sqrt( %.17e) - %.17e  = %.17e\n", X * X, X, OneUlp * SqEr);
                printf("\tinstead of correct value 0 .\n");
                }
        }

/* NewD */

void NewD(void)
{
        X = Z1 * Q;
        X = FLOOR(Half - X / Radix) * Radix + X;
        Q = (Q - X * Z) / Radix + X * X * (D / Radix);
        Z = Z - Two * X * D;
        if (Z <= Zero) {
                Z = - Z;
                Z1 = - Z1;
                }
        D = Radix * D;
        }

/* SR3750 */

void SR3750(void)
{
        if (! ((X - Radix < Z2 - Radix) || (X - Z2 > W - Z2))) {
                I = I + 1;
                X2 = SQRT(X * D);
                Y2 = (X2 - Z2) - (Y - Z2);
                X2 = X8 / (Y - Half);
                X2 = X2 - Half * X2 * X2;
                SqEr = (Y2 + Half) + (Half - X2);
                if (SqEr < MinSqEr) MinSqEr = SqEr;
                SqEr = Y2 - X2;
                if (SqEr > MaxSqEr) MaxSqEr = SqEr;
                }
        }

/* IsYeqX */

void IsYeqX(void)
{
        if (Y != X) {
                if (N <= 0) {
                        if (Z == Zero && Q <= Zero)
                                printf("WARNING:  computing\n");
                        else BadCond(Defect, "computing\n");
                        printf("\t(%.17e) ^ (%.17e)\n", Z, Q);
                        printf("\tyielded %.17e;\n", Y);
                        printf("\twhich compared unequal to correct %.17e ;\n",
                                X);
                        printf("\t\tthey differ by %.17e .\n", Y - X);
                        }
                N = N + 1; /* ... count discrepancies. */
                }
        }

/* SR3980 */

void SR3980(void)
{
        do {
                Q = (FLOAT) I;
                Y = POW(Z, Q);
                IsYeqX();
                if (++I > M) break;
                X = Z * X;
                } while ( X < W );
        }

/* PrintIfNPositive */

void PrintIfNPositive(void)
{
        if (N > 0) printf("Similar discrepancies have occurred %d times.\n", N);
        }

/* TstPtUf */

void TstPtUf(void)
{
        N = 0;
        if (Z != Zero) {
                printf("Since comparison denies Z = 0, evaluating ");
                printf("(Z + Z) / Z should be safe.\n");
                sigsave = sigfpe;
                if (setjmp(ovfl_buf)) goto very_serious;
                Q9 = (Z + Z) / Z;
                printf("What the machine gets for (Z + Z) / Z is  %.17e .\n",
                        Q9);
                if (FABS(Q9 - Two) < Radix * U2) {
                        printf("This is O.K., provided Over/Underflow");
                        printf(" has NOT just been signaled.\n");
                        }
                else {
                        if ((Q9 < One) || (Q9 > Two)) {
very_serious:
                                N = 1;
                                ErrCnt [Serious] = ErrCnt [Serious] + 1;
                                printf("This is a VERY SERIOUS DEFECT!\n");
                                }
                        else {
                                N = 1;
                                ErrCnt [Defect] = ErrCnt [Defect] + 1;
                                printf("This is a DEFECT!\n");
                                }
                        }
                sigsave = 0;
                V9 = Z * One;
                Random1 = V9;
                V9 = One * Z;
                Random2 = V9;
                V9 = Z / One;
                if ((Z == Random1) && (Z == Random2) && (Z == V9)) {
                        if (N > 0) Pause();
                        }
                else {
                        N = 1;
                        BadCond(Defect, "What prints as Z = ");
                        printf("%.17e\n\tcompares different from  ", Z);
                        if (Z != Random1) printf("Z * 1 = %.17e ", Random1);
                        if (! ((Z == Random2)
                                || (Random2 == Random1)))
                                printf("1 * Z == %g\n", Random2);
                        if (! (Z == V9)) printf("Z / 1 = %.17e\n", V9);
                        if (Random2 != Random1) {
                                ErrCnt [Defect] = ErrCnt [Defect] + 1;
                                BadCond(Defect, "Multiplication does not commute!\n");
                                printf("\tComparison alleges that 1 * Z = %.17e\n",
                                        Random2);
                                printf("\tdiffers from Z * 1 = %.17e\n", Random1);
                                }
                        Pause();
                        }
                }
        }

void notify(char *s)
{
        printf("%s test appears to be inconsistent...\n", s);
        printf("   PLEASE NOTIFY KARPINKSI!\n");
        }

/*SPLIT msgs.c */

/* Instructions */

void msglist(char **s)
{ while(*s) printf("%s\n", *s++); }

void Instructions(void)
{
  static char *instr[] = {
        "Lest this program stop prematurely, i.e. before displaying\n",
        "    `END OF TEST',\n",
        "try to persuade the computer NOT to terminate execution when an",
        "error like Over/Underflow or Division by Zero occurs, but rather",
        "to persevere with a surrogate value after, perhaps, displaying some",
        "warning.  If persuasion avails naught, don't despair but run this",
        "program anyway to see how many milestones it passes, and then",
        "amend it to make further progress.\n",
        "Answer questions with Y, y, N or n (unless otherwise indicated).\n",
        0};

        msglist(instr);
        }

/* Heading */

void Heading(void)
{
  static char *head[] = {
        "Users are invited to help debug and augment this program so it will",
        "cope with unanticipated and newly uncovered arithmetic pathologies.\n",
        "Please send suggestions and interesting results to",
        "\tRichard Karpinski",
        "\tComputer Center U-76",
        "\tUniversity of California",
        "\tSan Francisco, CA 94143-0704, USA\n",
        "In doing so, please include the following information:",
#ifdef Single
        "\tPrecision:\tsingle;",
#else
        "\tPrecision:\tdouble;",
#endif
        "\tVersion:\t10 February 1989;",
        "\tComputer:\n",
        "\tCompiler:\n",
        "\tOptimization level:\n",
        "\tOther relevant compiler options:",
        0};

        msglist(head);
        }

/* Characteristics */

void Characteristics(void)
{
        static char *chars[] = {
         "Running this program should reveal these characteristics:",
        "     Radix = 1, 2, 4, 8, 10, 16, 100, 256 ...",
        "     Precision = number of significant digits carried.",
        "     U2 = Radix/Radix^Precision = One Ulp",
        "\t(OneUlpnit in the Last Place) of 1.000xxx .",
        "     U1 = 1/Radix^Precision = One Ulp of numbers a little less than 1.0 .",
        "     Adequacy of guard digits for Mult., Div. and Subt.",
        "     Whether arithmetic is chopped, correctly rounded, or something else",
        "\tfor Mult., Div., Add/Subt. and Sqrt.",
        "     Whether a Sticky Bit used correctly for rounding.",
        "     UnderflowThreshold = an underflow threshold.",
        "     E0 and PseudoZero tell whether underflow is abrupt, gradual, or fuzzy.",
        "     V = an overflow threshold, roughly.",
        "     V0  tells, roughly, whether  Infinity  is represented.",
        "     Comparisions are checked for consistency with subtraction",
        "\tand for contamination with pseudo-zeros.",
        "     Sqrt is tested.  Y^X is not tested.",
        "     Extra-precise subexpressions are revealed but NOT YET tested.",
        "     Decimal-Binary conversion is NOT YET tested for accuracy.",
        0};

        msglist(chars);
        }

/* History */

void History(void)
{
 /* Converted from Brian Wichmann's Pascal version to C by Thos Sumner,
        with further massaging by David M. Gay. */

  static char *hist[] = {
        "The program attempts to discriminate among",
        "   FLAWs, like lack of a sticky bit,",
        "   Serious DEFECTs, like lack of a guard digit, and",
        "   FAILUREs, like 2+2 == 5 .",
        "Failures may confound subsequent diagnoses.\n",
        "The diagnostic capabilities of this program go beyond an earlier",
        "program called `MACHAR', which can be found at the end of the",
        "book  `Software Manual for the Elementary Functions' (1980) by",
        "W. J. Cody and W. Waite. Although both programs try to discover",
        "the Radix, Precision and range (over/underflow thresholds)",
        "of the arithmetic, this program tries to cope with a wider variety",
        "of pathologies, and to say how well the arithmetic is implemented.",
        "\nThe program is based upon a conventional radix representation for",
        "floating-point numbers, but also allows logarithmic encoding",
        "as used by certain early WANG machines.\n",
        "BASIC version of this program (C) 1983 by Prof. W. M. Kahan;",
        "see source comments for more history.",
        0};

        msglist(hist);
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\order\order.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    order.c

Abstract:

    This module contains the order tool which reads a call graph output
    by the linker and the performance data from the kernel profile and
    produces a .prf file subsequent input to the linker.

Author:

    David N. Cutler (davec) 24-Feb-1995

Environment:

    Kernel mode only.

Revision History:

--*/

#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

//
// Define maximum values for table sizes.
//

#define MAXIMUM_CALLED 75               // maximum number of called functions
#define MAXIMUM_FUNCTION 5000           // maximum number of program functions
#define MAXIMUM_TOKEN 100               // maximum character in input token
#define MAXIMUM_SECTION 20              // maximum number of allocation sections
#define MAXIMUM_SYNONYM 10              // maximum number of synonym symbols

//
// Define file numbers.
//

#define CALLTREE_FILE 0                 // call tree file produced by linker
#define PROFILE_FILE 1                  // profile file produced by kernprof
#define ORDER_FILE 2                    // order file produced by this program

//
// Define back edge node sttucture.
//
// Back edge nodes are used to represent back edges in the call graph and
// are constructed after the function list has been defined.
//
//

typedef struct _BACK_EDGE_NODE {
    LIST_ENTRY Entry;
    struct _FUNCTION_NODE *Node;
} BACK_EDGE_NODE, *PBACK_EDGE_NODE;

//
// Define called node structure.
//
// Called nodes are used to represent forward edges in the call graph and
// are constructed when the function list is being defined.
//

#define REFERENCE_NODE 0                // called entry is reference to node
#define REFERENCE_NAME 1                // called entry is reference to name

struct _FUNCTION_NODE;

typedef struct _CALLED_NODE {
    union {
        struct _FUNCTION_NODE *Node;
        PCHAR Name;
    } u;

    ULONG Type;
} CALLED_NODE, *PCALLED_NODE;

//
// Define section node structure.
//
// Section nodes collect allocation information and contain the list of
// function nodes in the section.
//

typedef struct _SECTION_NODE {
    LIST_ENTRY SectionListHead;
    LIST_ENTRY OrderListHead;
    PCHAR Name;
    ULONG Base;
    ULONG Size;
    ULONG Offset;
    ULONG Number;
    ULONG Threshold;
} SECTION_NODE, *PSECTION_NODE;

//
// Define symbol node structure.
//
// Symbol nodes are associated with function nodes and store synonym names
// for the functions and their type of allocation.
//

typedef struct _SYMBOL_NODE {
    PCHAR Name;
    LONG Type;
} SYMBOL_NODE, *PSYMBOL_NODE;

//
// Define function node structure.
//
// Function nodes contain information about a paritcular function and its
// edges in the call graph.
//

typedef struct _FUNCTION_NODE {
    SYMBOL_NODE SynonymList[MAXIMUM_SYNONYM];
    CALLED_NODE CalledList[MAXIMUM_CALLED];
    LIST_ENTRY CallerListHead;
    LIST_ENTRY OrderListEntry;
    LIST_ENTRY SectionListEntry;
    PSECTION_NODE SectionNode;
    ULONG NumberSynonyms;
    ULONG NumberCalled;
    ULONG Rva;
    ULONG Size;
    ULONG HitCount;
    ULONG HitDensity;
    ULONG Offset;
    ULONG Placed;
    ULONG Ordered;
} FUNCTION_NODE, *PFUNCTION_NODE;

//
// Define forward referenced functions.
//

VOID
CheckForConflict (
    PFUNCTION_NODE FunctionNode,
    PFUNCTION_NODE ConflictNode,
    ULONG Depth
    );

VOID
DumpInternalTables (
    VOID
    );

PFUNCTION_NODE
FindHighestDensityFunction (
    PFUNCTION_NODE CallerNode
    );

LONG
GetNextToken (
    IN FILE *InputFile,
    OUT PCHAR TokenBuffer
    );

PFUNCTION_NODE
LookupFunctionNode (
    IN PCHAR Name,
    IN ULONG Rva,
    IN ULONG Size,
    IN LONG Type
    );

PSECTION_NODE
LookupSectionNode (
    IN PCHAR Name
    );

VOID
OrderFunctionList (
    VOID
    );

ULONG
ParseCallTreeFile (
    IN FILE *InputFile
    );

ULONG
ParseProfileFile (
    IN FILE *InputFile
    );

VOID
PlaceCallerList (
    IN PFUNCTION_NODE FunctionNode,
    IN ULONG Depth
    );

VOID
SortFunctionList (
    VOID
    );

VOID
WriteOrderFile (
    IN FILE *OutputFile
    );

//
// Define function list data.
//

ULONG NumberFunctions = 0;
PFUNCTION_NODE FunctionList[MAXIMUM_FUNCTION];

//
// Define section list data.
//

ULONG NumberSections = 0;
PSECTION_NODE SectionList[MAXIMUM_SECTION];

//
// Define input and output file name defaults.
//

PCHAR FileName[3] = {"calltree.out", "profile.out", "order.prf"};

//
// Define dump flags.
//

ULONG DumpBackEdges = 0;
ULONG DumpFunctionList = 0;
ULONG DumpGoodnessValue = 0;
ULONG DumpSectionList = 0;
ULONG TraceAllocation = 0;

//
// Define primary cache mask parameter.
//

ULONG CacheMask = 8192 - 1;
ULONG CacheSize = 8192;

VOID
__cdecl
main (
    int argc,
    char *argv[]
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{

    FILE *InputFile;
    ULONG Index;
    FILE *OutputFile;
    ULONG Shift;
    ULONG Status;
    PCHAR Switch;

    //
    // Parse the command parameters.
    //

    for (Index = 1; Index < (ULONG)argc; Index += 1) {
        Switch = argv[Index];
        if (*Switch++ == '-') {
            if (*Switch == 'b') {
                DumpBackEdges = 1;

            } else if (*Switch == 'c') {
                Switch += 1;
                if (sscanf(Switch, "%d", &Shift) != 1) {
                    fprintf(stderr, "ORDER: Conversion of the shift failed\n");
                    exit(1);
                }

                CacheMask = (1024 << Shift) - 1;
                CacheSize = (1024 << Shift);

            } else if (*Switch == 'f') {
                DumpFunctionList = 1;

            } else if (*Switch == 'g') {
                Switch += 1;
                FileName[CALLTREE_FILE] = Switch;

            } else if (*Switch == 'k') {
                Switch += 1;
                FileName[PROFILE_FILE] = Switch;

            } else if (*Switch == 's') {
                DumpSectionList = 1;

            } else if (*Switch == 't') {
                TraceAllocation = 1;

            } else if (*Switch == 'v') {
                DumpGoodnessValue = 1;

            } else {
                if (*Switch != '?') {
                    fprintf(stderr, "ORDER: Invalid switch %s\n", argv[Index]);
                }

                fprintf(stderr, "ORDER: Usage order [switch] [output-file]\n");
                fprintf(stderr, "       -b = print graph backedges\n");
                fprintf(stderr, "       -cn = primary cache size 1024*2**n\n");
                fprintf(stderr, "       -f = print function list\n");
                fprintf(stderr, "       -gfile = specify graph input file, default calltree.out\n");
                fprintf(stderr, "       -kfile = specify profile input file, default profile.out\n");
                fprintf(stderr, "       -s = print section list\n");
                fprintf(stderr, "       -t = trace allocation\n");
                fprintf(stderr, "       -v = print graph placement value\n");
                fprintf(stderr, "       -? - print usage\n");
                exit(1);
            }

        } else {
            FileName[ORDER_FILE] = argv[Index];
        }
    }

    //
    // Open and parse the call tree file.
    //

    InputFile = fopen(FileName[CALLTREE_FILE], "r");
    if (InputFile == NULL) {
        fprintf(stderr,
                "ORDER: Open of call tree file %s failed\n",
                FileName[CALLTREE_FILE]);

        exit(1);
    }

    Status = ParseCallTreeFile(InputFile);
    fclose(InputFile);
    if (Status != 0) {
        exit(1);
    }

    //
    // Open and parse the profile file.
    //

    InputFile = fopen(FileName[PROFILE_FILE], "r");
    if (InputFile == NULL) {
        fprintf(stderr,
                "ORDER: Open of profile file %s failed\n",
                FileName[PROFILE_FILE]);

        exit(1);
    }

    Status = ParseProfileFile(InputFile);
    fclose(InputFile);
    if (Status != 0) {
        exit(1);
    }

    //
    // Sort the function list and create the section lists.
    //

    SortFunctionList();

    //
    // Order function list.
    //

    OrderFunctionList();

    //
    // Open the output file and write the ordered function list.
    //

    OutputFile = fopen(FileName[ORDER_FILE], "w");
    if (OutputFile == NULL) {
        fprintf(stderr,
                "ORDER: Open of order file %s failed\n",
                FileName[ORDER_FILE]);

        exit(1);
    }

    WriteOrderFile(OutputFile);
    fclose(OutputFile);
    if (Status != 0) {
        exit(1);
    }

    //
    // Dump internal tables as appropriate.
    //

    DumpInternalTables();
    return;
}

VOID
CheckForConflict (
    PFUNCTION_NODE FunctionNode,
    PFUNCTION_NODE ConflictNode,
    ULONG Depth
    )

/*++

Routine Description:

    This function checks for an allocation conflict .

Arguments:

    FunctionNode - Supplies a pointer to a function node that has been
        placed.

    ConflictNode - Supplies a pointer to a function node that has not
        been placed.

    Depth - Supplies the current allocation depth.

Return Value:

    None.

--*/

{

    ULONG Base;
    ULONG Bound;
    ULONG Index;
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    ULONG Offset;
    PFUNCTION_NODE PadNode;
    PSECTION_NODE SectionNode;
    ULONG Wrap;

    //
    // Compute the cache size truncated offset and bound of the placed
    // function.
    //

    Offset = FunctionNode->Offset & CacheMask;
    Bound = Offset + FunctionNode->Size;
    SectionNode = FunctionNode->SectionNode;

    //
    // If the section offset conflicts with the placed function,
    // then attempt to allocate a function from the end of the
    // section list that will pad the memory allocation so the
    // conflict function does not overlap with the placed function.
    //

    Base = SectionNode->Offset & CacheMask;
    Wrap = (Base + ConflictNode->Size) & CacheMask;
    while (((Base >= Offset) && (Base < Bound)) ||
           ((Base < Offset) && (Wrap >= Bound)) ||
           ((Wrap >= Offset) && (Wrap < Base))) {
        ListHead = &SectionNode->SectionListHead;
        ListEntry = ListHead->Blink;
        while (ListEntry != ListHead) {
            PadNode = CONTAINING_RECORD(ListEntry,
                                        FUNCTION_NODE,
                                        SectionListEntry);

            if ((PadNode->Ordered == 0) &&
                (PadNode->SynonymList[0].Type == 'C')) {
                PadNode->Ordered = 1;
                PadNode->Placed = 1;
                InsertTailList(&SectionNode->OrderListHead,
                               &PadNode->OrderListEntry);

                PadNode->Offset = SectionNode->Offset;
                SectionNode->Offset += PadNode->Size;

                //
                // If allocation is being trace, then output the
                // allocation and depth information.
                //

                if (TraceAllocation != 0) {
                    fprintf(stdout,
                            "pp %6lx %4lx %-8s",
                            PadNode->Offset,
                            PadNode->Size,
                            SectionNode->Name);

                    for (Index = 0; Index < Depth; Index += 1) {
                        fprintf(stdout, " ");
                    }

                    fprintf(stdout, "%s\n",
                            PadNode->SynonymList[0].Name);
                }

                Base = SectionNode->Offset & CacheMask;
                Wrap = (Base + ConflictNode->Size) & CacheMask;
                break;
            }

            ListEntry = ListEntry->Blink;
        }

        if (ListEntry == ListHead) {
            break;
        }
    }

    return;
}

VOID
DumpInternalTables (
    VOID
    )

/*++

Routine Description:

    This function dumps various internal tables.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG Base;
    ULONG Bound;
    PFUNCTION_NODE CalledNode;
    PFUNCTION_NODE CallerNode;
    PFUNCTION_NODE FunctionNode;
    ULONG Index;
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    ULONG Loop;
    PCHAR Name;
    ULONG Number;
    ULONG Offset;
    PSECTION_NODE SectionNode;
    ULONG Sum;
    ULONG Total;
    ULONG Wrap;

    //
    // Scan the function list and dump each function entry.
    //

    if (DumpFunctionList != 0) {
        fprintf(stdout, "Dump of function list with attributes\n\n");
        for (Index = 0; Index < NumberFunctions; Index += 1) {

            //
            // Dump the function node.
            //

            FunctionNode = FunctionList[Index];
            fprintf(stdout,
                    "%7d %-36s %c %-8s %6lx %4lx %7d\n",
                    FunctionNode->HitDensity,
                    FunctionNode->SynonymList[0].Name,
                    FunctionNode->SynonymList[0].Type,
                    FunctionNode->SectionNode->Name,
                    FunctionNode->Rva,
                    FunctionNode->Size,
                    FunctionNode->HitCount);

            //
            // Dump the synonym names.
            //

            for (Loop = 1; Loop < FunctionNode->NumberSynonyms; Loop += 1) {
                fprintf(stdout,
                        "       syno: %-34s %c\n",
                        FunctionNode->SynonymList[Loop].Name,
                        FunctionNode->SynonymList[Loop].Type);
            }

            //
            // Dump the called references.
            //

            for (Loop = 0; Loop < FunctionNode->NumberCalled; Loop += 1) {
                CalledNode = FunctionNode->CalledList[Loop].u.Node;
                Name = CalledNode->SynonymList[0].Name;
                fprintf(stdout,"       calls: %-s\n", Name);
            }
        }

        fprintf(stdout, "\n\n");
    }

    //
    // Scan the function list and dump the back edges of each function
    // entry.
    //

    if (DumpBackEdges != 0) {
        fprintf(stdout, "Dump of function list back edges\n\n");
        for (Index = 0; Index < NumberFunctions; Index += 1) {
            FunctionNode = FunctionList[Index];
            fprintf(stdout, "%s\n", FunctionNode->SynonymList[0].Name);
            ListHead = &FunctionNode->CallerListHead;
            ListEntry = ListHead->Flink;
            while (ListEntry != ListHead) {
                CallerNode = CONTAINING_RECORD(ListEntry, BACK_EDGE_NODE, Entry)->Node;
                fprintf(stdout, "  %s\n", CallerNode->SynonymList[0].Name);
                ListEntry = ListEntry->Flink;
            }
        }

        fprintf(stdout, "\n\n");
    }

    //
    // Scan the section list and dump each entry.
    //

    if (DumpSectionList != 0) {
        fprintf(stdout, "Dump of section list\n\n");
        for (Index = 0; Index < NumberSections; Index += 1) {
            SectionNode = SectionList[Index];
            fprintf(stdout,
                    "%-8s %6lx, %6lx, %6lx, %4d %7d\n",
                    SectionNode->Name,
                    SectionNode->Base,
                    SectionNode->Size,
                    SectionNode->Offset,
                    SectionNode->Number,
                    SectionNode->Threshold);
        }

        fprintf(stdout, "\n\n");
    }

    //
    // Compute the graph goodness value as the summation of the hit
    // count of all functions whose allocation does not conflict with
    // the functions that call it and whose hit density is great than
    // the section threshold.
    //

    if (DumpGoodnessValue != 0) {
        Number = 0;
        Sum = 0;
        Total = 0;
        for (Index = 0; Index < NumberFunctions; Index += 1) {
            FunctionNode = FunctionList[Index];
            SectionNode = FunctionNode->SectionNode;
            Total += FunctionNode->Size;
            if ((FunctionNode->HitDensity > SectionNode->Threshold) &&
                (FunctionNode->SynonymList[0].Type == 'C')) {
                Offset = FunctionNode->Offset & CacheMask;
                Bound = (Offset + FunctionNode->Size) & CacheMask;
                Sum += FunctionNode->Size;
                ListHead = &FunctionNode->CallerListHead;
                ListEntry = ListHead->Flink;
                while (ListEntry != ListHead) {
                    CallerNode = CONTAINING_RECORD(ListEntry, BACK_EDGE_NODE, Entry)->Node;
                    Base = CallerNode->Offset & CacheMask;
                    Wrap = (Base + CallerNode->Size) & CacheMask;
                    if ((((Base >= Offset) && (Base < Bound)) ||
                        ((Base < Offset) && (Wrap >= Bound)) ||
                        ((Wrap >= Offset) && (Wrap < Base))) &&
                        (CallerNode != FunctionNode) &&
                        (CallerNode->HitDensity > SectionNode->Threshold)) {
                        Number += 1;
                        fprintf(stdout,
                                "%-36s   %6lx %4lx conflicts with\n  %-36s %6lx %4lx\n",
                                FunctionNode->SynonymList[0].Name,
                                FunctionNode->Offset,
                                FunctionNode->Size,
                                CallerNode->SynonymList[0].Name,
                                CallerNode->Offset,
                                CallerNode->Size);

                    } else {
                        Sum += CallerNode->Size;
                    }

                    ListEntry = ListEntry->Flink;
                }
            }
        }

        Sum = Sum * 100 / Total;
        fprintf(stdout, "Graph goodness value is %d\n", Sum);
        fprintf(stdout, "%d conflicts out of %d functions\n", Number, NumberFunctions);
    }
}

PFUNCTION_NODE
FindHighestDensityFunction (
    PFUNCTION_NODE CallerNode
    )

/*++

Routine Description:

    This function finds the function node that has the highest hit density
    of all the functions called by the caller node.

Arguments:

    CallerNode - Supplies a pointer to a function node whose highest
        hit density called function is to be found.

Return Value:

    The address of the function node for the highest hit density called
    function is returned as the function value.

--*/

{

    PFUNCTION_NODE CheckNode;
    PFUNCTION_NODE FoundNode;
    ULONG Index;

    //
    // Scan all the functions called by the specified function and
    // compute the address of the highest hit density called function.
    //

    FoundNode = NULL;
    for (Index = 0; Index < CallerNode->NumberCalled; Index += 1) {
        if (CallerNode->CalledList[Index].Type == REFERENCE_NODE) {
            CheckNode = CallerNode->CalledList[Index].u.Node;
            if ((FoundNode == NULL) ||
                (CheckNode->HitDensity > FoundNode->HitDensity)) {
                FoundNode = CheckNode;
            }
        }
    }

    return FoundNode;
}

LONG
GetNextToken (
    IN FILE *InputFile,
    OUT PCHAR TokenBuffer
    )

/*++

Routine Description:

    This function reads the next token from the specified input file,
    copies it to the token buffer, zero terminates the token, and
    returns the delimiter character.

Arguments:

    InputFile - Supplies a pointer to the input file descripor.

    TokenBuffer - Supplies a pointer to the output token buffer.

Return Value:

    The token delimiter character is returned as the function value.

--*/

{

    CHAR Character;

    //
    // Read characters from the input stream and copy them to the token
    // buffer until an EOF or token delimiter is encountered. Terminate
    // the token will a null and return the token delimiter character.
    //

    do {
        Character = (CHAR)fgetc(InputFile);
        if ((Character != ' ') &&
            (Character != '\t')) {
            break;
        }

    } while(TRUE);

    do {
        if ((Character == EOF) ||
            (Character == ' ') ||
            (Character == '\n') ||
            (Character == '\t')) {
            break;
        }

        *TokenBuffer++ = Character;
        Character = (CHAR)fgetc(InputFile);
    } while(TRUE);

    *TokenBuffer = '\0';
    return Character;
}

PFUNCTION_NODE
LookupFunctionNode (
    IN PCHAR Name,
    IN ULONG Rva,
    IN ULONG Size,
    IN LONG Type
    )

/*++

Routine Description:

    This function searches the function list for a matching entry.

Arguments:

    Name - Supplies a pointer to the name of the function.

    Rva - Supplies the revlative virtual address of the function.

    Size - Supplies the size of the function.

    Type - specified the type of the function (0, N, or C).

Return Value:

    If a matching entry is found, then the function node address is
    returned as the function value. Otherwise, NULL is returned.

--*/

{

    ULONG Index;
    ULONG Loop;
    PFUNCTION_NODE Node;
    ULONG Number;

    //
    // Search the function list for a matching function.
    //

    for (Index = 0; Index < NumberFunctions; Index += 1) {
        Node = FunctionList[Index];

        //
        // Search the synonym list for the specified function name.
        //

        for (Loop = 0; Loop < Node->NumberSynonyms; Loop += 1) {
            if (strcmp(Name, Node->SynonymList[Loop].Name) == 0) {
                if (Type != 0) {
                    fprintf(stderr,
                            "ORDER: Warning - duplicate function name %s\n",
                            Name);
                }

                return Node;
            }
        }

        //
        // If the type is nonzero, then a function definition is being
        // looked up and the RVA/size must be checked for a synonym. If
        // the RVA and size of the entry are equal to the RVA and size
        // of the reference, then the function name is added to the node
        // as a synonym.
        //

        if (Type != 0) {
            if ((Node->Rva == Rva) && (Node->Size == Size)) {
                Number = Node->NumberSynonyms;
                if (Number >= MAXIMUM_SYNONYM) {
                    fprintf(stderr,
                            "ORDER: Warning - Too many synonyms %s\n",
                            Name);

                } else {
                    if (Type == 'C') {
                        Node->SynonymList[Number].Name = Node->SynonymList[0].Name;
                        Node->SynonymList[Number].Type = Node->SynonymList[0].Type;
                        Number = 0;
                    }

                    Node->SynonymList[Number].Name = Name;
                    Node->SynonymList[Number].Type = Type;
                    Node->NumberSynonyms += 1;
                }

                return Node;
            }
        }

    }

    return NULL;
}

PSECTION_NODE
LookupSectionNode (
    IN PCHAR Name
    )

/*++

Routine Description:

    This function searches the section list for a matching entry.

Arguments:

    Name - Supplies a pointer to the name of the section.

Return Value:

    If a matching entry is found, then the section node address is
    returned as the function value. Otherwise, NULL is returned.

--*/

{

    ULONG Index;
    PSECTION_NODE SectionNode;

    //
    // Search the function list for a matching function.
    //

    for (Index = 0; Index < NumberSections; Index += 1) {
        SectionNode = SectionList[Index];
        if (strcmp(Name, SectionNode->Name) == 0) {
            return SectionNode;
        }
    }

    return NULL;
}

VOID
PlaceCallerList (
    IN PFUNCTION_NODE FunctionNode,
    ULONG Depth
    )

/*++

Routine Description:

    This function recursively places all the functions in the caller list
    for the specified function.

Arguments:

    FunctionNode - Supplies a pointer to a function node.

    Depth - Supplies the depth of the function in the caller tree.

Return Value:

    None.

--*/

{

    PFUNCTION_NODE CallerNode;
    ULONG Index;
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    PFUNCTION_NODE PadNode;
    PSECTION_NODE SectionNode;

    //
    // Scan the caller list and process each function that has not been
    // placed.
    //
    //

    Depth += 1;
    SectionNode = FunctionNode->SectionNode;
    ListHead = &FunctionNode->CallerListHead;
    ListEntry = ListHead->Flink;
    while (ListHead != ListEntry) {
        CallerNode = CONTAINING_RECORD(ListEntry, BACK_EDGE_NODE, Entry)->Node;

        //
        // If the caller is in the same section, has not been placed, is
        // placeable, has a hit density above the section threshold, has
        // not been placed, and the current function is the highest density
        // called function of the caller, then insert the function in the
        // section order list and compute it's offset and bound.
        //

        if ((SectionNode == CallerNode->SectionNode) &&
            (CallerNode->Placed == 0) &&
            (CallerNode->Ordered == 0) &&
            (CallerNode->SynonymList[0].Type == 'C') &&
            (CallerNode->HitDensity > SectionNode->Threshold) &&
            (FindHighestDensityFunction(CallerNode) == FunctionNode)) {
            CallerNode->Placed = 1;
            CallerNode->Ordered = 1;

            //
            // Resolve any allocation conflict, insert function in the
            // section order list, and place the fucntion.
            //

            CheckForConflict(FunctionNode, CallerNode, Depth);
            InsertTailList(&SectionNode->OrderListHead,
                           &CallerNode->OrderListEntry);

            CallerNode->Offset = SectionNode->Offset;
            SectionNode->Offset += CallerNode->Size;

            //
            // If allocation is being trace, then output the allocation and
            // depth information.
            //

            if (TraceAllocation != 0) {
                fprintf(stdout,
                        "%2d %6lx %4lx %-8s",
                        Depth,
                        CallerNode->Offset,
                        CallerNode->Size,
                        SectionNode->Name);

                for (Index = 0; Index < Depth; Index += 1) {
                    fprintf(stdout, " ");
                }

                fprintf(stdout, "%s\n",
                        CallerNode->SynonymList[0].Name);
            }

            PlaceCallerList(CallerNode, Depth);
        }

        ListEntry = ListEntry->Flink;
    }

    return;
}

VOID
OrderFunctionList (
    VOID
    )

/*++

Routine Description:

    This function computes the link order for based on the information
    in the function list.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG Base;
    ULONG Bound;
    PFUNCTION_NODE CallerNode;
    FUNCTION_NODE DummyNode;
    PFUNCTION_NODE FunctionNode;
    ULONG High;
    ULONG Index;
    ULONG Limit;
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    ULONG Low;
    ULONG Offset;
    PFUNCTION_NODE PadNode;
    PSECTION_NODE SectionNode;
    ULONG Span;

    //
    // Scan forward through the function list and compute the link order.
    //

    for (Index = 0; Index < NumberFunctions; Index += 1) {
        FunctionNode = FunctionList[Index];

        //
        // If the function has not been placed, then place the function.
        //

        if ((FunctionNode->Placed == 0) &&
            (FunctionNode->SynonymList[0].Type == 'C')) {
            FunctionNode->Ordered = 1;
            FunctionNode->Placed = 1;
            SectionNode = FunctionNode->SectionNode;

            //
            // Attempt to find the highest hit density caller than has
            // already been placed and compute the total bounds for all
            // placed caller functions.
            //

            Bound = 0;
            Offset = CacheMask;
            ListHead = &FunctionNode->CallerListHead;
            ListEntry = ListHead->Flink;
            while (ListEntry != ListHead) {
                CallerNode = CONTAINING_RECORD(ListEntry, BACK_EDGE_NODE, Entry)->Node;
                if ((SectionNode == CallerNode->SectionNode) &&
                    (CallerNode->Placed != 0) &&
                    (CallerNode->Ordered != 0) &&
                    (CallerNode->SynonymList[0].Type == 'C') &&
                    (CallerNode->HitDensity > SectionNode->Threshold)) {
                    Base = CallerNode->Offset & CacheMask;
                    Limit = Base + CallerNode->Size;
                    Low = min(Offset, Base);
                    High = max(Bound, Limit);
                    Span = High - Low;
                    if ((Span < CacheSize) &&
                        ((CacheSize - Span) > FunctionNode->Size)) {
                        Offset = Low;
                        Bound = High;
                    }
                }

                ListEntry = ListEntry->Flink;
            }

            //
            // If a caller has already been placed and the hit density is
            // above the section threshold, then resolve any allocation
            // conflict before inserting the function in the section order
            // list and placing it in memory.
            //

            if (Bound != 0) {
                Span = Bound - Offset;
                if ((Span < CacheSize) &&
                    ((CacheSize - Span) > FunctionNode->Size)) {
                    DummyNode.SectionNode = SectionNode;
                    DummyNode.Offset = Offset;
                    DummyNode.Size = Span;
                    CheckForConflict(&DummyNode, FunctionNode, 1);
                }
            }

            InsertTailList(&SectionNode->OrderListHead,
                           &FunctionNode->OrderListEntry);

            FunctionNode->Offset = SectionNode->Offset;
            SectionNode->Offset += FunctionNode->Size;

            //
            // If allocation is being trace, then output the allocation and
            // depth information.
            //

            if (TraceAllocation != 0) {
                fprintf(stdout,
                        "%2d %6lx %4lx %-8s %s\n",
                        1,
                        FunctionNode->Offset,
                        FunctionNode->Size,
                        SectionNode->Name,
                        FunctionNode->SynonymList[0].Name);
            }

            PlaceCallerList(FunctionNode, 1);
        }
    }

    return;
}

ULONG
ParseCallTreeFile (
    IN FILE *InputFile
    )

/*++

Routine Description:

    This function reads the call tree data and produces the initial call
    graph.

Arguments:

    InputFile - Supplies a pointer to the input file stream.

Return Value:

    A value of zero is returned if the call tree is successfully parsed.
    Otherwise, a nonzero value is returned.

--*/

{

    PCHAR Buffer;
    PFUNCTION_NODE CalledNode;
    PBACK_EDGE_NODE CallerNode;
    LONG Delimiter;
    ULONG HitCount;
    ULONG Index;
    ULONG Loop;
    PCHAR Name;
    PFUNCTION_NODE Node;
    ULONG Number;
    ULONG Rva;
    PSECTION_NODE SectionNode;
    ULONG Size;
    CHAR TokenBuffer[MAXIMUM_TOKEN];
    LONG Type;

    //
    // Process the call tree file.
    //

    Buffer = &TokenBuffer[0];
    do {

        //
        // Get the relative virtual address of the next function.
        //

        Delimiter = GetNextToken(InputFile, Buffer);
        if (Delimiter == EOF) {
            break;
        }

        if (sscanf(Buffer, "%lx", &Rva) != 1) {
            fprintf(stderr, "ORDER: Conversion of the RVA failed\n");
            return 1;
        }

        //
        // Get the function type.
        //

        Delimiter = GetNextToken(InputFile, Buffer);
        if (Delimiter == EOF) {
            fprintf(stderr, "ORDER: Premature end of file at function type\n");
            return 1;
        }

        Type = *Buffer;

        //
        // Get the section name.
        //

        Delimiter = GetNextToken(InputFile, Buffer);
        if (Delimiter == EOF) {
            fprintf(stderr, "ORDER: Premature end of file at section name\n");
            return 1;
        }

        //
        // If the specfied section is not already in the section list, then
        // allocate and initialize a new section list entry.
        //

        SectionNode = LookupSectionNode(Buffer);
        if (SectionNode == NULL) {

            //
            // Allocate a section node and zero.
            //

            if (NumberSections >= MAXIMUM_SECTION) {
                fprintf(stderr, "ORDER: Maximum number of sections exceeded\n");
                return 1;
            }

            SectionNode = (PSECTION_NODE)malloc(sizeof(SECTION_NODE));
            if (SectionNode == NULL) {
                fprintf(stderr, "ORDER: Failed to allocate section node\n");
                return 1;
            }

            memset((PCHAR)SectionNode, 0, sizeof(SECTION_NODE));
            SectionList[NumberSections] = SectionNode;
            NumberSections += 1;

            //
            // Initialize section node.
            //

            InitializeListHead(&SectionNode->OrderListHead);
            InitializeListHead(&SectionNode->SectionListHead);
            Name = (PCHAR)malloc(strlen(Buffer) + 1);
            if (Name == NULL) {
                fprintf(stderr, "ORDER: Failed to allocate section name\n");
                return 1;
            }

            strcpy(Name, Buffer);
            SectionNode->Name = Name;
        }

        //
        // Get the function size.
        //

        Delimiter = GetNextToken(InputFile, Buffer);
        if (Delimiter == EOF) {
            fprintf(stderr, "ORDER: Premature end of file at function size\n");
            return 1;
        }

        if (sscanf(Buffer, "%lx", &Size) != 1) {
            fprintf(stderr, "ORDER: Conversion of the function size failed\n");
            return 1;
        }

        //
        // Get the function name.
        //

        Delimiter = GetNextToken(InputFile, Buffer);
        if (Delimiter == EOF) {
            fprintf(stderr, "ORDER: Premature end of file at function name\n");
            return 1;
        }

        Name = (PCHAR)malloc(strlen(Buffer) + 1);
        if (Name == NULL) {
            fprintf(stderr, "ORDER: Failed to allocate function name\n");
            return 1;
        }

        strcpy(Name, Buffer);

        //
        // If the specified function is not already in the function list,
        // then allocate and initialize a new function list entry.
        //

        Node = LookupFunctionNode(Name, Rva, Size, Type);
        if (Node == NULL) {

            //
            // Allocate a function node and zero.
            //

            if (NumberFunctions >= MAXIMUM_FUNCTION) {
                fprintf(stderr, "ORDER: Maximum number of functions exceeded\n");
                return 1;
            }

            Node = (PFUNCTION_NODE)malloc(sizeof(FUNCTION_NODE));
            if (Node == NULL) {
                fprintf(stderr, "ORDER: Failed to allocate function node\n");
                return 1;
            }

            memset((PCHAR)Node, 0, sizeof(FUNCTION_NODE));
            FunctionList[NumberFunctions] = Node;
            NumberFunctions += 1;

            //
            // Initialize function node.
            //

            InitializeListHead(&Node->CallerListHead);
            Node->SynonymList[0].Name = Name;
            Node->SynonymList[0].Type = Type;
            Node->NumberSynonyms = 1;
            Node->SectionNode = SectionNode;

            //
            // Initialize relative virtual address and function size.
            //

            Node->Rva = Rva;
            if (Size == 0) {
                Size = 4;
            }

            Node->Size = Size;
        }

        //
        // Parse the called forward edges and add them to the current node.
        //

        if (Delimiter != '\n') {
            do {

                //
                // Get next function reference.
                //

                Delimiter = GetNextToken(InputFile, Buffer);
                if (Delimiter == EOF) {
                    fprintf(stderr, "ORDER: Premature end of file called scan\n");
                    return 1;
                }

                Number = Node->NumberCalled;
                if (Number >= MAXIMUM_CALLED) {
                    fprintf(stderr,
                            "ORDER: Too many called references %s\n",
                            Buffer);

                    return 1;
                }

                //
                // Lookup the specified function in the function list. If the
                // specified function is found, then store the address of the
                // function node in the called list. Otherwise, allocate a name
                // buffer, copy the function name to the buffer, and store the
                // address of the name buffer in the called list.
                //

                CalledNode = LookupFunctionNode(Buffer, 0, 0, 0);
                if (CalledNode == NULL) {
                    Name = (PCHAR)malloc(strlen(Buffer) + 1);
                    if (Name == NULL) {
                        fprintf(stderr, "ORDER: Failed to allocate reference name\n");
                        return 1;
                    }

                    strcpy(Name, Buffer);
                    Node->CalledList[Number].u.Name = Name;
                    Node->CalledList[Number].Type = REFERENCE_NAME;

                } else {
                    Node->CalledList[Number].u.Node = CalledNode;
                    Node->CalledList[Number].Type = REFERENCE_NODE;
                }

                Node->NumberCalled += 1;
            } while (Delimiter != '\n');
        }

    } while(TRUE);

    //
    // Scan the function table and do the final resolution for all called
    // functions names that were unresolved when the individual functions
    // were defined.
    //

    for (Index = 0; Index < NumberFunctions; Index += 1) {
        Node = FunctionList[Index];
        for (Loop = 0; Loop < Node->NumberCalled; Loop += 1) {
            if (Node->CalledList[Loop].Type == REFERENCE_NAME) {
                CalledNode =
                        LookupFunctionNode(Node->CalledList[Loop].u.Name,
                                           0,
                                           0,
                                           0);

                if (CalledNode == NULL) {
                    fprintf(stderr,
                            "ORDER: Unresolved reference name %s\n",
                            Node->CalledList[Loop].u.Name);

                    return 1;

                } else {
                    Node->CalledList[Loop].Type = REFERENCE_NODE;
                    Node->CalledList[Loop].u.Node = CalledNode;
                }

            } else {
                CalledNode = Node->CalledList[Loop].u.Node;
            }

            //
            // Allocate a back edge node and place the node in the caller
            // list of called function.
            //

            CallerNode = (PBACK_EDGE_NODE)malloc(sizeof(BACK_EDGE_NODE));
            if (CallerNode == NULL) {
                fprintf(stderr, "ORDER: Failed to allocate caller node\n");
                return 1;
            }

            CallerNode->Node = Node;
            InsertTailList(&CalledNode->CallerListHead, &CallerNode->Entry);
        }
    }

    return 0;
}

ULONG
ParseProfileFile (
    IN FILE *InputFile
    )

/*++

Routine Description:

    This function reads the profile data and computes the hit density
    for each funtion.

Arguments:

    InputFile - Supplies a pointer to the input file stream.

Return Value:

    A value of zero is returned if the call tree is successfully parsed.
    Otherwise, a nonzero value is returned.

--*/

{

    PCHAR Buffer;
    ULONG HitCount;
    LONG Delimiter;
    PFUNCTION_NODE FunctionNode;
    CHAR TokenBuffer[MAXIMUM_TOKEN];

    //
    // Process the profile file.
    //

    Buffer = &TokenBuffer[0];
    do {

        //
        // Get the bucket hit count.
        //

        Delimiter = GetNextToken(InputFile, Buffer);
        if (Delimiter == EOF) {
            break;
        }

        if (sscanf(Buffer, "%d", &HitCount) != 1) {
            fprintf(stderr, "ORDER: Conversion of bucket hit failed\n");
            return 1;
        }

        //
        // Get the function name.
        //

        Delimiter = GetNextToken(InputFile, Buffer);
        if (Delimiter == EOF) {
            fprintf(stderr, "ORDER: Premature end of file at profile name\n");
            return 1;
        }

        //
        // Lookup the function name in the function table and update the
        // hit count.
        //

        FunctionNode = LookupFunctionNode(Buffer, 0, 0, 0);
        if (FunctionNode == NULL) {
            fprintf(stderr, "ORDER: Warning function name %s undefined\n", Buffer);

        } else {
            FunctionNode->HitCount += HitCount;
//          FunctionNode->HitDensity = FunctionNode->HitCount;
            FunctionNode->HitDensity =
                            (FunctionNode->HitCount * 100) / FunctionNode->Size;
        }

    } while (TRUE);

    return 0;
}

VOID
SortFunctionList (
    VOID
    )

/*++

Routine Description:

    This function sorts the function list by hit density and creates
    the section list ordered by hit density.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PFUNCTION_NODE CallerList[MAXIMUM_FUNCTION];
    PFUNCTION_NODE CallerNode;
    PFUNCTION_NODE FunctionNode;
    LONG i;
    LONG j;
    LONG k;
    PSECTION_NODE InitNode;
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    ULONG NumberCallers;
    PSECTION_NODE SectionNode;

    //
    // All functions that are in the INIT section or cannot be placed are
    // forced to have a hit density of zero.
    //

    InitNode = LookupSectionNode("INIT");
    if (InitNode == NULL) {
        fprintf(stderr, "ORDER: Warning - unable to find INIT section\n");
    }

    for (i = 0; i < (LONG)NumberFunctions; i += 1) {
        FunctionNode = FunctionList[i];
        SectionNode = FunctionNode->SectionNode;
        if ((SectionNode == InitNode) ||
            (FunctionNode->SynonymList[0].Type != 'C')) {
            FunctionNode->HitDensity = 0;
        }
    }

    //
    // Perform a bubble sort on the function list hit density.
    //

    if (NumberFunctions > 1) {
        i = 0;
        do {
            for (j = i; j >= 0; j -= 1) {
                if (FunctionList[j]->HitDensity >= FunctionList[j + 1]->HitDensity) {
                    if (FunctionList[j]->HitDensity > FunctionList[j + 1]->HitDensity) {
                        break;

                    } else if (FunctionList[j]->Size >= FunctionList[j + 1]->Size) {
                        break;
                    }
                }

                FunctionNode = FunctionList[j];
                FunctionList[j] = FunctionList[j + 1];
                FunctionList[j + 1] = FunctionNode;
            }

            i += 1;
        } while (i < (LONG)(NumberFunctions - 1));
    }

    //
    // Perform a bubble sort on the caller list of each function.
    //

    for (k = 0; k < (LONG)NumberFunctions; k += 1) {
        FunctionNode = FunctionList[i];
        ListHead = &FunctionNode->CallerListHead;
        ListEntry = ListHead->Flink;
        i = 0;
        while (ListEntry != ListHead) {
            CallerList[i] = CONTAINING_RECORD(ListEntry, BACK_EDGE_NODE, Entry)->Node;
            i += 1;
            ListEntry = ListEntry->Flink;
        }

        if (i > 1) {
            NumberCallers = i;
            i = 0;
            do {
                for (j = i; j >= 0; j -= 1) {
                    if (CallerList[j]->HitDensity >= CallerList[j + 1]->HitDensity) {
                        if (CallerList[j]->HitDensity > CallerList[j + 1]->HitDensity) {
                            break;

                        } else if (CallerList[j]->Size >= CallerList[j + 1]->Size) {
                            break;
                        }
                    }

                    CallerNode = CallerList[j];
                    CallerList[j] = CallerList[j + 1];
                    CallerList[j + 1] = CallerNode;
                }

                i += 1;
            } while (i < (LONG)(NumberCallers - 1));

            ListEntry = FunctionNode->CallerListHead.Flink;
            for (i = 0; i < (LONG)NumberCallers; i += 1) {
                CONTAINING_RECORD(ListEntry, BACK_EDGE_NODE, Entry)->Node = CallerList[i];
                ListEntry = ListEntry->Flink;
            }
        }
    }

    //
    // Compute the size of each section and create the section lists ordered
    // by hit density.
    //

    for (i = 0; i < (LONG)NumberFunctions; i += 1) {
        FunctionNode = FunctionList[i];
        SectionNode = FunctionNode->SectionNode;
        SectionNode->Size += FunctionNode->Size;
        SectionNode->Number += 1;
        InsertTailList(&SectionNode->SectionListHead,
                       &FunctionNode->SectionListEntry);
    }

    //
    // Set the hit density threshold to zero.
    //


    for (i = 0; i < (LONG)NumberSections; i += 1) {
        SectionList[i]->Threshold = 0;
    }
}

VOID
WriteOrderFile (
    IN FILE *OutputFile
    )

/*++

Routine Description:

    This function scans the section list and writes the link order file.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG Index;
    PFUNCTION_NODE FunctionNode;
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    PSECTION_NODE SectionNode;

    //
    // Scan the section list and write the link order list.
    //

    for (Index = 0; Index < NumberSections; Index += 1) {
        SectionNode = SectionList[Index];
        ListHead = &SectionNode->OrderListHead;
        ListEntry = ListHead->Flink;
        while (ListHead != ListEntry) {
            FunctionNode = CONTAINING_RECORD(ListEntry,
                                             FUNCTION_NODE,
                                             OrderListEntry);

            fprintf(OutputFile, "%s\n", FunctionNode->SynonymList[0].Name);
            ListEntry = ListEntry->Flink;
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pageheap\pageheap.cxx ===
//
// Page heap command line manipulator
// Copyright (c) Microsoft Corporation, 1999
//
// -- History --
//
// 3.04  Whistler: protect page heap meta data option
// 3.03  Whistler: more granular fault injection option
// 3.02  Whistler: leaks detection
// 3.01  Whistler: fault injection
// 3.00  Whistler/W2000 SP1
//

//
// module: pageheap.cxx
// author: silviuc
// created: Tue Feb 02 10:43:04 1999
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <malloc.h>
#include <tchar.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <common.ver>

//
// Definitions copied from \nt\base\ntos\inc\heappage.h
//

#define PAGE_HEAP_ENABLE_PAGE_HEAP          0x0001
#define PAGE_HEAP_COLLECT_STACK_TRACES      0x0002
#define PAGE_HEAP_RESERVED_04               0x0004
#define PAGE_HEAP_RESERVED_08               0x0008
#define PAGE_HEAP_CATCH_BACKWARD_OVERRUNS   0x0010
#define PAGE_HEAP_UNALIGNED_ALLOCATIONS     0x0020
#define PAGE_HEAP_SMART_MEMORY_USAGE        0x0040
#define PAGE_HEAP_USE_SIZE_RANGE            0x0080
#define PAGE_HEAP_USE_DLL_RANGE             0x0100
#define PAGE_HEAP_USE_RANDOM_DECISION       0x0200
#define PAGE_HEAP_USE_DLL_NAMES             0x0400
#define PAGE_HEAP_USE_FAULT_INJECTION       0x0800
#define PAGE_HEAP_PROTECT_META_DATA         0x1000
#define PAGE_HEAP_CHECK_NO_SERIALIZE_ACCESS 0x2000
#define PAGE_HEAP_NO_LOCK_CHECKS            0x4000


VOID
PrintFlags (
    DWORD Flags,
    BOOL ShutdownFlagsDefined = FALSE
    )
{
    if ((Flags & PAGE_HEAP_ENABLE_PAGE_HEAP)) {
        printf("full ");
    }
    if ((Flags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {
        printf("backwards ");
    }
    if ((Flags & PAGE_HEAP_UNALIGNED_ALLOCATIONS)) {
        printf("unaligned ");
    }
    if ((Flags & PAGE_HEAP_SMART_MEMORY_USAGE)) {
        printf("decommit ");
    }
    if ((Flags & PAGE_HEAP_USE_SIZE_RANGE)) {
        printf("size ");
    }
    if ((Flags & PAGE_HEAP_USE_DLL_RANGE)) {
        printf("address ");
    }
    if ((Flags & PAGE_HEAP_USE_RANDOM_DECISION)) {
        printf("random ");
    }
    if ((Flags & PAGE_HEAP_USE_DLL_NAMES)) {
        printf("dlls ");
    }
    if ((Flags & PAGE_HEAP_USE_FAULT_INJECTION)) {
        printf("fault ");
    }
    if ((Flags & PAGE_HEAP_COLLECT_STACK_TRACES)) {
        printf("traces ");
    }
    if ((Flags & PAGE_HEAP_PROTECT_META_DATA)) {
        printf("protect ");
    }
    if ((Flags & PAGE_HEAP_CHECK_NO_SERIALIZE_ACCESS)) {
        printf("no_sync ");
    }
    if ((Flags & PAGE_HEAP_NO_LOCK_CHECKS)) {
        printf("no_lock_checks ");
    }

    if (ShutdownFlagsDefined) {
        printf("leaks ");
    }
}

BOOL
EnablePageHeap (
    LPCTSTR Name,
    LPTSTR HeapFlags,
    LPTSTR DebugString,
    char * * Args);

BOOL
DisablePageHeap (
    LPCTSTR Name);

BOOL
IsPageHeapEnabled (
    LPCTSTR Name);

BOOL
IsPageHeapFlagsValueDefined (
    LPCTSTR Name,
    PDWORD Value);

BOOL
ReadGlobalFlagValue (
    HKEY Key,
    LPTSTR Buffer,
    ULONG Length);

BOOL
WriteGlobalFlagValue (
    HKEY Key,
    LPTSTR Buffer,
    ULONG Length);

BOOL
ReadHeapFlagValue (
    HKEY Key,
    LPTSTR Buffer,
    ULONG Length);

BOOL
WriteHeapFlagValue (
    HKEY Key,
    LPTSTR Buffer,
    ULONG Length);

BOOL
DeleteHeapFlagValue (
    HKEY Key);

BOOL
WriteDebuggerValue (
    HKEY Key,
    LPTSTR Buffer,
    ULONG Length);

BOOL
DeleteDebuggerValue (
    HKEY Key);

HKEY
OpenImageKey (
    LPCTSTR Name,
    BOOL ShouldExist);

VOID
CloseImageKey (
    HKEY Key);

VOID
CreateImageName (
    LPCTSTR Source,
    LPTSTR Name,
    ULONG Length);

VOID
PrintPageheapEnabledApplications (
    );

VOID
Help (
    );

__declspec(noreturn)
VOID
__cdecl
Error (
    LPCTSTR Format,
    ...);

BOOL 
IsWow64Active (
    );

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

char * * 
SearchOption (
    char * Args[],
    char * Option
    )
{
    while (*Args) {
        if (_stricmp(*Args, Option) == 0) {
            return Args;
        }

        Args++;
    }

    return NULL;
}

#pragma warning(disable:4706)

void _cdecl
#if defined (_PART_OF_GFLAGS_)
PageHeapMain (int argc, char *argv[])
#else
main (int argc, char *argv[])
#endif
{
    TCHAR ImageName [MAX_PATH + 1];
    char * * Option;

    if (IsWow64Active()) {
        _tprintf (TEXT ("Warning: pageheap.exe is running inside WOW64. \n"
                        "This scenario can be used to test x86 binaries (running inside WOW64) \n"
                        "but not native (IA64) binaries. \n\n"));
    }
    
    if (argc == 2 && strstr (argv[1], TEXT("?")) != NULL) {

        Help ();
    }
    else if ((Option = SearchOption(argv + 1, "/enable"))) {

        PCHAR DebugString = NULL;

        if (SearchOption (argv + 1, "/debug") != NULL) {
            DebugString = "ntsd -g -G -x";
        }

        if (SearchOption (argv + 1, "/kdebug") != NULL) {
            DebugString = "ntsd -g -G -d -x";
        }

        if (Option[1] && Option[1][0] != '/') {
            CreateImageName (Option[1], ImageName, MAX_PATH + 1);
            EnablePageHeap (ImageName, NULL, DebugString, argv);
        }
        else {
            Help();
        }
    }
    else if ((Option = SearchOption(argv + 1, "/disable"))) {
        
        if (Option[1]) {
            CreateImageName (Option[1], ImageName, MAX_PATH + 1);
            DisablePageHeap (ImageName);
        }
        else {
            Help();
        }
    }
    else if (argc == 2) {

        CreateImageName (argv[1], ImageName, MAX_PATH + 1);
        if (IsPageHeapEnabled (ImageName) == FALSE) {
            _tprintf (TEXT("Page heap is not enabled for %s\n"), argv[1]);
        }
        else {

            DWORD Value;

            if (IsPageHeapFlagsValueDefined (ImageName, &Value)) {
                
                _tprintf (TEXT("Page heap is enabled for %s with flags ("), argv[1]);
                PrintFlags (Value);
                _tprintf (TEXT(")\n"));
            }
            else {

                _tprintf (TEXT("Page heap is enabled for %s with flags ("), argv[1]);
                PrintFlags (0);
                _tprintf (TEXT(")\n"));
            }
        }
    }
    else {

        PrintPageheapEnabledApplications ();
    }
}


VOID
Help (

    )
{
    _tprintf (
        TEXT("pageheap - Page heap utility, v 3.04                                 \n")
        VER_LEGALCOPYRIGHT_STR TEXT("\n")
        TEXT("                                                                     \n")
        TEXT("pageheap [OPTION [OPTION ...]]                                       \n")
        TEXT("                                                                     \n")
        TEXT("    /enable PROGRAM         Enable page heap with default settings.  \n")
        TEXT("    /disable PROGRAM        Disable page heap.                       \n")
        TEXT("    /full                   Page heap for all allocations.           \n")
        TEXT("    /size START END         Page heap allocations for size range.    \n")
        TEXT("    /address START END      Page heap allocations for address range. \n")
        TEXT("    /dlls DLL ...           Page heap allocations for target dlls.   \n")
        TEXT("    /random PROBABILITY     Page heap allocations with PROBABILITY.  \n")
        TEXT("    /debug                  Launch under debugger `ntsd -g -G -x'.   \n")
        TEXT("    /kdebug                 Launch under debugger `ntsd -g -G -d -x'.\n")
        TEXT("    /backwards              Catch backwards overruns.                \n")
        TEXT("    /unaligned              No alignment for allocations.            \n")
        TEXT("    /decommit               Decommit guard pages (lower memory use). \n")
        TEXT("    /notraces               Do not collect stack traces.             \n")
        TEXT("    /fault RATE TIMEOUT     Probability (1..10000) for heap calls failures \n")
        TEXT("                            and time during process initialization (in seconds)\n")
        TEXT("                            when faults are not allowed.             \n")
        TEXT("    /leaks                  Check for heap leaks when process shuts down. \n")
        TEXT("    /protect                Protect heap internal structures. Can be  \n")
        TEXT("                            used to detect random corruptions but    \n")
        TEXT("                            execution is slower.                     \n")
        TEXT("    /no_sync                Check for unsynchronized access. Do not  \n")
        TEXT("                            use this flag for an MPheap process.     \n")
        TEXT("    /no_lock_checks         Disable critical section verifier.       \n")
        TEXT("                                                                     \n")
        TEXT("                                                                     \n")
        TEXT("PROGRAM      Name of the binary with extension (.exe or something else).\n")
        TEXT("DLL          Name of the binary with extension (.dll or something else).\n")
        TEXT("PROBABILITY  Decimal integer in range [0..100] representing probability.\n")
        TEXT("             to make page heap allocation vs. a normal heap allocation. \n")
        TEXT("START..END   For /size option these are decimal integers.            \n")
        TEXT("             For /address option these are hexadecimal integers.     \n")
        TEXT("                                                                     \n")
        TEXT("If no option specified the program will print all page heap enabled  \n")
        TEXT("applications and their specific options.                             \n")
        TEXT("                                                                     \n")
        TEXT("The `/leaks' option is effective only when normal page heap is enabled \n")
        TEXT("(i.e. not full page heap) therefore all flags that will force full   \n")
        TEXT("page heap will be disabled if /leaks is specified.                   \n")
        TEXT("                                                                     \n")
        TEXT("Note. Enabling page heap does not affect currently running           \n")
        TEXT("processes. If you need to use page heap for processes that are       \n")
        TEXT("already running and cannot be restarted (csrss.exe, winlogon.exe),   \n")
        TEXT("a reboot is needed after the page heap has been enabled for          \n")
        TEXT("that process.                                                        \n")
        TEXT("                                                                     \n")
        TEXT("                                                                     \n"));

    exit(1);
}

__declspec(noreturn)
VOID
__cdecl
Error (

    LPCTSTR Format,
    ...)
{
    va_list Params;

    va_start (Params, Format);
    _tprintf (TEXT("Error: "));
    _vtprintf (Format, Params);
    _tprintf ( TEXT("\n "));
    exit (1);
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

#define PAGE_HEAP_BIT 0x02000000

BOOL
IsPageHeapEnabled (

    LPCTSTR Name)
{
    HKEY Key;
    TCHAR Buffer [128];
    DWORD Flags;
    BOOL Success;

    if ((Key = OpenImageKey (Name, TRUE)) == NULL) {

        return FALSE;
    }

    Success = ReadGlobalFlagValue (Key, Buffer, sizeof Buffer);

    CloseImageKey (Key);

    if (Success == FALSE) {

        return FALSE;
    }

    if (_stscanf (Buffer, TEXT("%x"), &Flags) != 1) {

        return FALSE;
    }

    return (Flags & PAGE_HEAP_BIT) ? TRUE : FALSE;
}


BOOL
IsPageHeapFlagsValueDefined (
    LPCTSTR Name,
    PDWORD Value)
{
    HKEY Key;
    TCHAR Buffer [128];
    BOOL Success;

    if ((Key = OpenImageKey (Name, TRUE)) == NULL) {

        return FALSE;
    }

    Success = ReadHeapFlagValue (Key, Buffer, sizeof Buffer);

    CloseImageKey (Key);

    if (Success == FALSE) {

        return FALSE;
    }

    if (_stscanf (Buffer, TEXT("%x"), Value) != 1) {
        
        return FALSE;
    }

    return TRUE;
}


BOOL
EnablePageHeap (
    LPCTSTR Name,
    LPTSTR HeapFlagsString,
    LPTSTR DebugString,
    char * * Args
    )
{
    HKEY Key;
    TCHAR Buffer [128];
    DWORD Flags;
    DWORD HeapFlags;
    char * * Option;
    LONG Result;
    BOOL LeakDetectionEnabled = FALSE;
    DWORD Scanned;

    if ((Key = OpenImageKey (Name, FALSE)) == NULL) {

        Error (TEXT("Cannot open image registry key for %s"), Name);
    }

    if (ReadGlobalFlagValue (Key, Buffer, sizeof Buffer) == FALSE) {

        Flags = 0;
    }
    else {

        Scanned = _stscanf (Buffer, TEXT("%x"), &Flags);

        if (Scanned != 1) {
            Error (TEXT("Failed to read global flags"));
        }
    }

    Flags |= PAGE_HEAP_BIT;
    _stprintf (Buffer, TEXT("0x%08X"), Flags);

    if (WriteGlobalFlagValue (Key, Buffer, (ULONG)_tcslen(Buffer)) == FALSE) {

        return FALSE;
    }

    //
    // Figure out if we have some page heap flags specified.
    //

    HeapFlags = 0;

    if (HeapFlagsString != NULL) {

        Scanned = _stscanf (HeapFlagsString, "%x", &HeapFlags);

        if (Scanned != 1) {
            Error (TEXT("Failed to read heap flags"));
        }
    }

    //
    // Write `Debugger' value if needed.
    //

    if (DebugString != NULL) {

        if (WriteDebuggerValue (Key, DebugString, (ULONG)_tcslen(DebugString)) == FALSE) {

            return FALSE;
        }
    }

    //
    // Check for /leaks option. This requires a normal page heap to be
    // fully effective. Therefore any flag that will enable full page
    // heap will be disabled.
    //

    if ((Option = SearchOption (Args, "/leaks")) != NULL) {

        DWORD ShutdownFlags = 0x03;

        Result = RegSetValueEx (
            Key, TEXT ("ShutdownFlags"), 0, REG_DWORD,
            (LPBYTE)(&ShutdownFlags), sizeof ShutdownFlags);

        if (Result) {
            Error (TEXT("Failed to write ShutdownFlags value: error %u"), Result);
        }

        LeakDetectionEnabled = TRUE;
    }

    //
    // Check for full, backward, decommit, unaligned, protect options.
    //

    HeapFlags |= PAGE_HEAP_COLLECT_STACK_TRACES;

    if ((Option = SearchOption (Args, "/notraces")) != NULL) {
        HeapFlags &= ~PAGE_HEAP_COLLECT_STACK_TRACES;
    }

    if ((Option = SearchOption (Args, "/full")) != NULL) {
        if (! LeakDetectionEnabled) {
            HeapFlags |= PAGE_HEAP_ENABLE_PAGE_HEAP;
        }
        else {
            printf("/full option disabled because /leaks is present. \n");
        }
    }

    if ((Option = SearchOption (Args, "/backwards")) != NULL) {
        if (! LeakDetectionEnabled) {
            HeapFlags |= PAGE_HEAP_ENABLE_PAGE_HEAP;
            HeapFlags |= PAGE_HEAP_CATCH_BACKWARD_OVERRUNS;
        }
        else {
            printf("/backwards option disabled because /leaks is present. \n");
        }
    }

    if ((Option = SearchOption (Args, "/decommit")) != NULL) {
        if (! LeakDetectionEnabled) {
            HeapFlags |= PAGE_HEAP_ENABLE_PAGE_HEAP;
            HeapFlags |= PAGE_HEAP_SMART_MEMORY_USAGE;
        }
        else {
            printf("/decommit option disabled because /leaks is present. \n");
        }
    }

    if ((Option = SearchOption (Args, "/unaligned")) != NULL) {
        if (! LeakDetectionEnabled) {
            HeapFlags |= PAGE_HEAP_ENABLE_PAGE_HEAP;
            HeapFlags |= PAGE_HEAP_UNALIGNED_ALLOCATIONS;
        }
        else {
            printf("/unaligned option disabled because /leaks is present. \n");
        }
    }

    if ((Option = SearchOption (Args, "/protect")) != NULL) {
        if (! LeakDetectionEnabled) {
            HeapFlags |= PAGE_HEAP_ENABLE_PAGE_HEAP;
            HeapFlags |= PAGE_HEAP_PROTECT_META_DATA;
        }
        else {
            printf("/protect option disabled because /leaks is present. \n");
        }
    }

    if ((Option = SearchOption (Args, "/no_sync")) != NULL) {
        HeapFlags |= PAGE_HEAP_CHECK_NO_SERIALIZE_ACCESS;
    }
    
    if ((Option = SearchOption (Args, "/no_lock_checks")) != NULL) {
        HeapFlags |= PAGE_HEAP_NO_LOCK_CHECKS;
    }
    
    //
    // Check /size option
    //

    Option = SearchOption (Args, "/size");

    if (Option != NULL) {

        if (!LeakDetectionEnabled && Option[1] && Option[2]) {

            DWORD RangeStart;
            DWORD RangeEnd;

            HeapFlags |= PAGE_HEAP_ENABLE_PAGE_HEAP;
            HeapFlags |= PAGE_HEAP_USE_SIZE_RANGE;

            Scanned = sscanf (Option[1], "%u", &RangeStart);

            if (Scanned != 1) {
                Error (TEXT("Failed to read start range value."));
            }

            Scanned = sscanf (Option[2], "%u", &RangeEnd);

            if (Scanned != 1) {
                Error (TEXT("Failed to read end range value."));
            }

            Result = RegSetValueEx (
                Key, TEXT ("PageHeapSizeRangeStart"), 0, REG_DWORD,
                (LPBYTE)(&RangeStart), sizeof RangeStart);

            if (Result) {
                Error (TEXT("Failed to write SizeRangeStart value: error %u"), Result);
            }

            Result = RegSetValueEx (
                Key, TEXT ("PageHeapSizeRangeEnd"), 0, REG_DWORD,
                (LPBYTE)(&RangeEnd), sizeof RangeEnd);

            if (Result) {
                Error (TEXT("Failed to write SizeRangeEnd value: error %u"), Result);
            }
        }

        if (LeakDetectionEnabled) {
            printf("/size option disabled because /leaks is present. \n");
        }

    }

    //
    // Check /address option
    //

    Option = SearchOption (Args, "/address");

    if (Option != NULL) {

        if (!LeakDetectionEnabled && Option[1] && Option[2]) {

            DWORD RangeStart;
            DWORD RangeEnd;

            HeapFlags |= PAGE_HEAP_ENABLE_PAGE_HEAP;
            HeapFlags |= PAGE_HEAP_USE_DLL_RANGE;

            Scanned = sscanf (Option[1], "%x", &RangeStart);

            if (Scanned != 1) {
                Error (TEXT("Failed to read start range value."));
            }

            Scanned = sscanf (Option[2], "%x", &RangeEnd);

            if (Scanned != 1) {
                Error (TEXT("Failed to read end range value."));
            }

            Result = RegSetValueEx (
                Key, TEXT ("PageHeapDllRangeStart"), 0, REG_DWORD,
                (LPBYTE)(&RangeStart), sizeof RangeStart);

            if (Result) {
                Error (TEXT("Failed to write DllRangeStart value: error %u"), Result);
            }

            Result = RegSetValueEx (
                Key, TEXT ("PageHeapDllRangeEnd"), 0, REG_DWORD,
                (LPBYTE)(&RangeEnd), sizeof RangeEnd);

            if (Result) {
                Error (TEXT("Failed to write DllRangeStart value: error %u"), Result);
            }
        }

        if (LeakDetectionEnabled) {
            printf("/address option disabled because /leaks is present. \n");
        }
    }

    //
    // Check /random option
    //

    Option = SearchOption (Args, "/random");

    if (!LeakDetectionEnabled && Option != NULL) {

        if (Option[1]) {

            DWORD Probability;

            HeapFlags |= PAGE_HEAP_ENABLE_PAGE_HEAP;
            HeapFlags |= PAGE_HEAP_USE_RANDOM_DECISION;

            Scanned = sscanf (Option[1], "%u", &Probability);

            if (Scanned != 1) {
                Error (TEXT("Failed to read probability value."));
            }

            Result = RegSetValueEx (
                Key, TEXT ("PageHeapRandomProbability"), 0, REG_DWORD,
                (LPBYTE)(&Probability), sizeof Probability);

            if (Result) {
                Error (TEXT("Failed to write RandomProbability value: error %u"), Result);
            }
        }
    }

    if (Option && LeakDetectionEnabled) {
        printf("/random option disabled because /leaks is present. \n");
    }

    //
    // Check /fault option
    //

    Option = SearchOption (Args, "/fault");

    if (Option != NULL) {

        if (Option[1]) { // FAULT-RATE

            DWORD Probability;

            HeapFlags |= PAGE_HEAP_USE_FAULT_INJECTION;

            Scanned = sscanf (Option[1], "%u", &Probability);

            if (Scanned != 1) {
                Error (TEXT("Failed to read probability value."));
            }

            Result = RegSetValueEx (
                Key, TEXT ("PageHeapFaultProbability"), 0, REG_DWORD,
                (LPBYTE)(&Probability), sizeof Probability);

            if (Result) {
                Error (TEXT("Failed to write FaultProbability value: error %u"), Result);
            }

            if (Option[2]) { // TIME-OUT

                DWORD TimeOut;

                Scanned = sscanf (Option[2], "%u", &TimeOut);

                if (Scanned != 1) {
                    Error (TEXT("Failed to read timeout value."));
                }

                Result = RegSetValueEx (
                    Key, TEXT ("PageHeapFaultTimeOut"), 0, REG_DWORD,
                    (LPBYTE)(&TimeOut), sizeof TimeOut);

                if (Result) {
                    Error (TEXT("Failed to write FaultTimeOut value: error %u"), Result);
                }
            }
        }
    }

    //
    // Check /dlls option
    //

    Option = SearchOption (Args, "/dlls");

    if (!LeakDetectionEnabled && Option != NULL) {

        TCHAR Dlls[512];
        ULONG Index;

        if (Option[1]) {

            HeapFlags |= PAGE_HEAP_ENABLE_PAGE_HEAP;
            HeapFlags |= PAGE_HEAP_USE_DLL_NAMES;

            for (Index = 1, Dlls[0] = '\0';
                Option[Index] && Option[Index][0] != '/';
                Index++) {

                _tcscat (Dlls, Option[Index]);
                _tcscat (Dlls, " ");

                //
                // We do not allow more than 200 characters because this
                // will cause an overflow in \nt\base\ntdll\ldrinit.c in the
                // function that reads registry options.
                //

                if (_tcslen (Dlls) > 200) {
                    break;
                }
            }

            //
            // SilviuC: the call to _tcslen below is not correct if we
            // ever will want to make this program Unicode.
            //

            Result = RegSetValueEx (
                Key, TEXT ("PageHeapTargetDlls"), 0, REG_SZ,
                (LPBYTE)(Dlls), (ULONG)_tcslen(Dlls) + 1);

            if (Result) {
                Error (TEXT("Failed to write RandomProbability value: error %u"), Result);
            }
        }
    }

    if (Option && LeakDetectionEnabled) {
        printf("/dlls option disabled because /leaks is present. \n");
    }

    //
    // Finally write the page heap flags value.
    //

    {
        TCHAR ValueBuffer [32];

        sprintf (ValueBuffer, "0x%x", HeapFlags);

        if (WriteHeapFlagValue (Key, ValueBuffer, (ULONG)_tcslen(ValueBuffer)) == FALSE) {

            Error (TEXT("Failed to write PageHeapFlags value."));
        }
    }

    CloseImageKey (Key);
    return TRUE;
}

BOOL
DisablePageHeap (

    LPCTSTR Name)
{
    HKEY Key;
    TCHAR Buffer [128];
    DWORD Flags;

    if ((Key = OpenImageKey (Name, TRUE)) == NULL) {

        //
        // There is no key therefore nothing to disable.
        //

        return TRUE;
    }

    if (ReadGlobalFlagValue (Key, Buffer, sizeof Buffer) == FALSE) {

        Flags = 0;
    }
    else {

        if (_stscanf (Buffer, TEXT("%x"), &Flags) != 1) {

            Flags = 0;
        }
    }

    Flags &= ~PAGE_HEAP_BIT;
    _stprintf (Buffer, TEXT("0x%08X"), Flags);

    //
    // If by wiping the page heap bit from `GlobalFlags' we get a zero
    // value we will wipe out the value altogether. This is important
    // when we run the app under debugger. In this case it makes a 
    // difference if the value is not there or is all zeroes.
    //

    if (Flags != 0) {
        
        if (WriteGlobalFlagValue (Key, Buffer, (ULONG)_tcslen(Buffer)) == FALSE) {

            return FALSE;
        }
    }
    else {

        RegDeleteValue (Key, TEXT ("GlobalFlag"));
    }

    RegDeleteValue (Key, TEXT ("PageHeapFlags"));
    RegDeleteValue (Key, TEXT ("Debugger"));
    RegDeleteValue (Key, TEXT ("ShutdownFlags"));
    RegDeleteValue (Key, TEXT ("PageHeapSizeRangeStart"));
    RegDeleteValue (Key, TEXT ("PageHeapSizeRangeEnd"));
    RegDeleteValue (Key, TEXT ("PageHeapDllRangeStart"));
    RegDeleteValue (Key, TEXT ("PageHeapDllRangeEnd"));
    RegDeleteValue (Key, TEXT ("PageHeapTargetDlls"));
    RegDeleteValue (Key, TEXT ("PageHeapRandomProbability"));
    RegDeleteValue (Key, TEXT ("PageHeapFaultProbability"));
    RegDeleteValue (Key, TEXT ("PageHeapFaultTimeOut"));

    CloseImageKey (Key);
    return TRUE;
}


BOOL
ReadGlobalFlagValue (

    HKEY Key,
    LPTSTR Buffer,
    ULONG Length)
{
    LONG Result;
    DWORD Type;
    DWORD ReadLength = Length;

    Result = RegQueryValueEx (

        Key,
        TEXT ("GlobalFlag"),
        0,
        &Type,
        (LPBYTE)Buffer,
        &ReadLength);

    if (Result != ERROR_SUCCESS || Type != REG_SZ) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}

BOOL
ReadHeapFlagValue (

    HKEY Key,
    LPTSTR Buffer,
    ULONG Length)
{
    LONG Result;
    DWORD Type;
    DWORD ReadLength = Length;

    Result = RegQueryValueEx (

        Key,
        TEXT ("PageHeapFlags"),
        0,
        &Type,
        (LPBYTE)Buffer,
        &ReadLength);

    if (Result != ERROR_SUCCESS || Type != REG_SZ) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}

BOOL
WriteGlobalFlagValue (

    HKEY Key,
    LPTSTR Buffer,
    ULONG Length)
{
    LONG Result;

    Result = RegSetValueEx (

        Key,
        TEXT ("GlobalFlag"),
        0,
        REG_SZ,
        (LPBYTE)Buffer,
        Length);

    if (Result != ERROR_SUCCESS) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}

BOOL
WriteHeapFlagValue (

    HKEY Key,
    LPTSTR Buffer,
    ULONG Length)
{
    LONG Result;

    Result = RegSetValueEx (

        Key,
        TEXT ("PageHeapFlags"),
        0,
        REG_SZ,
        (LPBYTE)Buffer,
        Length);

    if (Result != ERROR_SUCCESS) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}


BOOL
WriteDebuggerValue (

    HKEY Key,
    LPTSTR Buffer,
    ULONG Length)
{
    LONG Result;

    Result = RegSetValueEx (

        Key,
        TEXT ("Debugger"),
        0,
        REG_SZ,
        (LPBYTE)Buffer,
        Length);

    if (Result != ERROR_SUCCESS) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}


BOOL
IsShutdownFlagsValueDefined (
    LPCTSTR KeyName
    )
{
    HKEY Key;
    LONG Result;
    DWORD Value;
    DWORD Type;
    DWORD ReadLength = sizeof (DWORD);

    if ((Key = OpenImageKey (KeyName, TRUE)) == NULL) {
        return FALSE;
    }
    
    Result = RegQueryValueEx (
        Key,
        TEXT ("ShutdownFlags"),
        0,
        &Type,
        (LPBYTE)(&Value),
        &ReadLength);

    CloseImageKey (Key);

    if (Result == ERROR_SUCCESS && (Value & 0x03) == 0x03) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

HKEY
OpenImageKey (

    LPCTSTR Name,
    BOOL ShouldExist)
{
    HKEY Key;
    LONG Result;
    TCHAR Buffer [MAX_PATH];

    _stprintf (
        Buffer,
        TEXT ("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\%s"),
        Name);

    if (ShouldExist) {

        Result = RegOpenKeyEx (

            HKEY_LOCAL_MACHINE,
            Buffer,
            0,
            KEY_ALL_ACCESS,
            &Key);
    }
    else {

        Result = RegCreateKeyEx (

            HKEY_LOCAL_MACHINE,
            Buffer,
            0,
            0,
            0,
            KEY_ALL_ACCESS,
            NULL,
            &Key,
            NULL);
    }

    if (Result != ERROR_SUCCESS) {

        return NULL;
    }
    else {

        return Key;
    }

}


VOID
CloseImageKey (

    HKEY Key)
{
    RegCloseKey (Key);
}


VOID
CreateImageName (

    LPCTSTR Source,
    LPTSTR Name,
    ULONG Length)
{
    //
    // Length is MAX_PATH + 1 so that it can accomodate MAX_PATH 
    // characters and a null termination character.
    //

    _tcsncpy (Name, Source, Length - 1);
    Name[Length - 1] = L'\0';

    _tcslwr (Name);
}


VOID
PrintPageheapEnabledApplications (

    )
{
    LPCTSTR ImageFileExecutionOptionsKeyName =
        TEXT ("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options");

    HKEY OptionsKey;
    LONG Result;
    TCHAR KeyName [MAX_PATH];
    ULONG KeySize;
    BOOL FoundOne = FALSE;
    ULONG Index;
    FILETIME FileTime;

    Result = RegOpenKeyEx (

        HKEY_LOCAL_MACHINE,
        ImageFileExecutionOptionsKeyName,
        0,
        KEY_ALL_ACCESS,
        &OptionsKey);

    if (Result != ERROR_SUCCESS) {

        Error (TEXT("Cannot open registry key %s: error %u"),
               ImageFileExecutionOptionsKeyName,
               Result);
    }

    for (Index = 0; ; Index += 1) {

        KeySize = MAX_PATH;

        Result = RegEnumKeyEx (

            OptionsKey,
            Index,
            KeyName,
            &KeySize,
            NULL,
            NULL,
            NULL,
            &FileTime);

        if (Result == ERROR_NO_MORE_ITEMS) {

            break;
        }

        if (Result != ERROR_SUCCESS) {

            Error (TEXT("Cannot enumerate registry key %s: error %u"),
               ImageFileExecutionOptionsKeyName,
               Result);
        }

        if (IsPageHeapEnabled (KeyName)) {

            DWORD Value;

            FoundOne = TRUE;
            
            if (IsPageHeapFlagsValueDefined (KeyName, &Value)) {
                _tprintf (TEXT("%s: page heap enabled with flags ("), KeyName);
                PrintFlags (Value, IsShutdownFlagsValueDefined(KeyName));
                _tprintf (TEXT(")\n"));
            }
            else {
                _tprintf (TEXT("%s: page heap enabled with flags ("), KeyName);
                PrintFlags (0, IsShutdownFlagsValueDefined(KeyName));
                _tprintf (TEXT(")\n"));
            }
        }
    }

    if (FoundOne == FALSE) {

        _tprintf (TEXT("No application has page heap enabled.\n"));
    }
}


BOOL 
IsWow64Active (
    )                 
{

    ULONG_PTR       ul;
    NTSTATUS        st;

    //
    // If this call succeeds then we are on Windows 2000 or later.
    //

    st = NtQueryInformationProcess(NtCurrentProcess(), 
                                   ProcessWow64Information,
                                   &ul, 
                                   sizeof(ul), 
                                   NULL);

    if (NT_SUCCESS(st) && (0 != ul)) {
        // 32-bit code running on Win64
        return TRUE;
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\parcomp\parcomp.c ===
#include <nt.h>
#include <ntddft.h>
#include <ntdddisk.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <string.h>


#define SECTOR_SIZE 512
#define COMPARE_BUFFER_SIZE 0x4000

BYTE PrimaryBuffer[COMPARE_BUFFER_SIZE];
BYTE SecondaryBuffer[COMPARE_BUFFER_SIZE];
BYTE OutputBuffer[1024];

void
DumpMiscompare(
    IN PBYTE PrimarySector,
    IN PBYTE SecondarySector
    )
{
    BYTE ch;
    int i, j, offset;

    i = 0;

    while( i < SECTOR_SIZE && PrimarySector[i] == SecondarySector[i] ) {

        i++;
    }

    offset = i & ~7;

    while( offset < SECTOR_SIZE ) {

        printf( "%03X: ", offset );

        // display primary as hex.

        for( j = offset; j < offset + 8; j++ ) {

            if( j < i ) {

                printf( "   " );

            } else {

                printf( " %02X", PrimarySector[j] );
            }
        }

        printf( "  " );

        // display primary as character.

        for( j = offset; j < offset + 8; j++ ) {

            if( j < i ) {

                printf( " " );

            } else {

                ch = PrimarySector[j];
                if( !isprint(ch) ) {

                    ch = '.';
                }

                printf( "%c", ch );
            }
        }

        printf( " -- " );

        // Display secondary as hex.

        for( j = offset; j < offset + 8; j++ ) {

            if( j < i ) {

                printf( "   " );

            } else {

                printf( " %02X", SecondarySector[j] );
            }
        }

        printf( "  " );

        // display primary as character.

        for( j = offset; j < offset + 8; j++ ) {

            if( j < i ) {

                printf( " " );

            } else {

                ch = SecondarySector[j];
                if( !isprint(ch) ) {

                    ch = '.';
                }

                printf( "%c", ch );
            }
        }

        printf( "\n" );
        offset += 8;
    }

    // Add a blank line.
    //
    printf( "\n" );
}

BOOL
ReadSectors(
    IN HANDLE   VolumeHandle,
    IN ULONG    SectorNumber,
    IN ULONG    NumberOfSectors,
    IN PBYTE    Buffer,
    IN BOOL     Secondary
    )
{
    FT_SPECIAL_READ SpecialReadBuffer;
    ULONG BytesRead;

    SpecialReadBuffer.ByteOffset = RtlEnlargedIntegerMultiply( SectorNumber, SECTOR_SIZE );
    SpecialReadBuffer.Length = NumberOfSectors * SECTOR_SIZE;

    // Issue the IOCTL
    //
    return( DeviceIoControl( VolumeHandle,
                             Secondary ? FT_SECONDARY_READ : FT_PRIMARY_READ,
                             &SpecialReadBuffer,
                             sizeof( SpecialReadBuffer ),
                             Buffer,
                             NumberOfSectors * SECTOR_SIZE,
                             &BytesRead,
                             NULL ) &&
            BytesRead == NumberOfSectors * SECTOR_SIZE );
}

VOID
ShowUsage()
{
        printf( "usage: parcomp DosDriveName: [-d] [-b:StartingSector] [-e:EndingSector]\n" );
        exit(4);
}

int __cdecl
main( int argc, char **argv )
{
    PARTITION_INFORMATION PartitionInfo;
    BYTE DriveNameBuffer[32];
    HANDLE VolumeHandle;
    LARGE_INTEGER BigSectorsOnVolume;
    ULONG SectorsOnVolume, SectorOffset, SectorsToRead, i, Errors;
    LONG k;
    BOOL PrimaryRead, SecondaryRead, DumpErrors = FALSE;
    ULONG BytesTransferred;
    ULONG StartSector = 0, EndSector = 0;


    if( argc < 2 ) {

        ShowUsage();
    }

    memset( DriveNameBuffer, 0, sizeof( DriveNameBuffer ) );
    strcat( DriveNameBuffer, "\\\\.\\" );
    strcat( DriveNameBuffer, argv[1] );

    for( k = 2;
         k < argc;
         k++ ) {

        if( argv[k][0] == '-' ||
            argv[k][0] == '/' ) {

            switch (argv[k][1]) {

            case 'd':

                //
                // Display miscompares.
                //
                DumpErrors = TRUE;
                break;

            case 'b':

                //
                // Specify beginning sector number.
                //
                if (sscanf( argv[k]+2, ":%x", &StartSector ) != 1)
                    ShowUsage();
                break;

            case 'e':

                //
                // Specify beginning sector number.
                //
                if (sscanf( argv[k]+2, ":%x", &EndSector ) != 1)
                    ShowUsage();
                break;

            default:

                ShowUsage();
                break;
            }
        } else {

            ShowUsage();
        }
    }

    // Open the volume with the DOS name.
    //
    VolumeHandle = CreateFile( DriveNameBuffer,
                               GENERIC_READ,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               0 );

    if( VolumeHandle == INVALID_HANDLE_VALUE ) {

        printf( "Unable to open %s [Error %d]\n", argv[1], GetLastError() );
        exit(4);
    }

    // GetFile information.
    //
    if( !DeviceIoControl( VolumeHandle,
                          IOCTL_DISK_GET_PARTITION_INFO,
                          NULL,
                          0,
                          &PartitionInfo,
                          sizeof( PartitionInfo ),
                          &BytesTransferred,
                          NULL ) ) {

        printf( "Unable to get volume size [Error %d].\n", GetLastError() );
        CloseHandle( VolumeHandle );
        exit(4);
    }

    if( !(PartitionInfo.PartitionType & VALID_NTFT) ) {

        printf( "%s is not a Fault-Tolerant volume.\n", argv[1] );
        exit(4);
    }

    BigSectorsOnVolume = RtlExtendedLargeIntegerDivide( PartitionInfo.PartitionLength, SECTOR_SIZE, NULL );
    SectorsOnVolume = BigSectorsOnVolume.LowPart;

    if( EndSector == 0 ) {

        EndSector = SectorsOnVolume;
    }

    sprintf( OutputBuffer, "Sectors on volume = %x\n", SectorsOnVolume );
    printf( OutputBuffer );
    OutputDebugString( OutputBuffer );

    sprintf( OutputBuffer, "Starting Sector = %x\n", StartSector );
    printf( OutputBuffer );
    OutputDebugString( OutputBuffer );

    sprintf( OutputBuffer, "Ending Sector = %x\n", EndSector );
    printf( OutputBuffer );
    OutputDebugString( OutputBuffer );

    SectorsToRead = 0;
    Errors = 0;

    printf( "Sectors read %8x\b\b\b\b\b\b\b\b", StartSector );

    for( SectorOffset = StartSector;
         SectorOffset < EndSector;
         SectorOffset += SectorsToRead ) {

        SectorsToRead = __min( COMPARE_BUFFER_SIZE / SECTOR_SIZE,
                               EndSector - SectorOffset );

        // zero out the buffers.
        //
        memset( PrimaryBuffer, 0, COMPARE_BUFFER_SIZE );
        memset( SecondaryBuffer, 0, COMPARE_BUFFER_SIZE );

        // Read the primary:
        //
        PrimaryRead = ReadSectors( VolumeHandle,
                                   SectorOffset,
                                   SectorsToRead,
                                   PrimaryBuffer,
                                   FALSE );

        // Read the secondary:
        //
        SecondaryRead = ReadSectors( VolumeHandle,
                                     SectorOffset,
                                     SectorsToRead,
                                     SecondaryBuffer,
                                     TRUE );

        if( PrimaryRead && SecondaryRead ) {

            for( i = 0; i < SectorsToRead; i++ ) {

                if( memcmp( PrimaryBuffer + SECTOR_SIZE * i,
                    SecondaryBuffer + SECTOR_SIZE * i,
                    SECTOR_SIZE ) ) {

                    sprintf( OutputBuffer, "\rPrimary and Secondary miscompare at sector %x\n", SectorOffset + i );
                    printf( OutputBuffer );
                    OutputDebugString( OutputBuffer );

                    if( DumpErrors ) {

                      DumpMiscompare( PrimaryBuffer + SECTOR_SIZE * i,
                                      SecondaryBuffer + SECTOR_SIZE * i );
                    }

                    printf( "Sectors read %8x\b\b\b\b\b\b\b\b", SectorOffset );
                    Errors++;
                }
            }

        } else if( PrimaryRead ) {

            sprintf( OutputBuffer, "\rSecondary read failed at sector %x, length %x (Error %d)\n", SectorOffset, SectorsToRead, GetLastError() );
            printf( OutputBuffer );
            OutputDebugString( OutputBuffer );
            printf( "Sectors read %8x\b\b\b\b\b\b\b\b", SectorOffset );

        } else if( SecondaryRead ) {

            sprintf( OutputBuffer, "\rPrimary read failed at sector %x, length %x (Error %d)\n", SectorOffset, SectorsToRead, GetLastError() );
            printf( OutputBuffer );
            OutputDebugString( OutputBuffer );
            printf( "Sectors read %8x\b\b\b\b\b\b\b\b", SectorOffset );

        } else {

            sprintf( OutputBuffer, "\rPrimary and Secondary reads failed at sector %x, length %x (Error %d)\n", SectorOffset, SectorsToRead, GetLastError() );
            printf( OutputBuffer );
            OutputDebugString( OutputBuffer );
            printf( "Sectors read %8x\b\b\b\b\b\b\b\b", SectorOffset );
        }
        printf( "%8x\b\b\b\b\b\b\b\b", SectorOffset );
    }

    printf( "%8x\b\b\b\b\b\b\b\b", SectorOffset );
    printf( "\n%x Errors\n", Errors );
    CloseHandle( VolumeHandle );
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\parcomp\parsync.c ===
#include <nt.h>
#include <ntddft.h>
#include <ntdddisk.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <string.h>

int __cdecl
main( int argc, char **argv )
{
    PARTITION_INFORMATION PartitionInfo;
    FT_SYNC_INFORMATION SyncInfo;
    BYTE DriveNameBuffer[32];
    HANDLE VolumeHandle;
    ULONG BytesTransferred;

    if( argc < 2 ) {

        printf( "usage: %s DosDriveName: [-b:StartingSector] [-e:EndingSector]\n", argv[0] );
        exit(4);
    }

    memset( DriveNameBuffer, 0, sizeof( DriveNameBuffer ) );
    strcat( DriveNameBuffer, "\\\\.\\" );
    strcat( DriveNameBuffer, argv[1] );

    // Open the volume with the DOS name.
    //
    VolumeHandle = CreateFile( DriveNameBuffer,
                               GENERIC_READ,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               0 );

    if( VolumeHandle == INVALID_HANDLE_VALUE ) {

        printf( "Unable to open %s [Error %d]\n", argv[1], GetLastError() );
        exit(4);
    }

    // GetFile information.
    //
    if( !DeviceIoControl( VolumeHandle,
                          IOCTL_DISK_GET_PARTITION_INFO,
                          NULL,
                          0,
                          &PartitionInfo,
                          sizeof( PartitionInfo ),
                          &BytesTransferred,
                          NULL ) ) {

        printf( "Unable to get volume size [Error %d].\n", GetLastError() );
        CloseHandle( VolumeHandle );
        exit(4);
    }


    // Synchronize the parity information for the entire volume:
    //
    SyncInfo.ByteOffset.QuadPart = 0;
    SyncInfo.ByteCount =  PartitionInfo.PartitionLength;

    // Issue the IOCTL
    //
    if( !DeviceIoControl( VolumeHandle,
                          FT_SYNC_REDUNDANT_COPY,
                          &SyncInfo,
                          sizeof( SyncInfo ),
                          NULL,
                          0,
                          &BytesTransferred,
                          NULL ) ) {

        printf( "Synchronization failed (Error %d).\n", GetLastError() );

    } else {

        printf( "Synchronization complete.\n" );
    }

    CloseHandle( VolumeHandle );
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pcmcmd\pcmcmd.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    pcmcmd.h

Abstract:

    This file provides definitions for the pcmcmd utility

Author:

    Neil Sandlin

Environment:

    User process.

Notes:

Revision History:
   
--*/


typedef struct _HOST_INFO {
    struct _HOST_INFO *Next;
    ULONG DeviceIndex;
    PUCHAR InstanceID;
    ULONG ControllerType;
    ULONG SocketNumber;
} HOST_INFO, *PHOST_INFO;


extern
CHAR
getopt (ULONG argc, PUCHAR *argv, PCHAR opts);


VOID
DumpCIS(
    PHOST_INFO HostInfo
    );

VOID
DumpIrqScanInfo(
    VOID
    );

HANDLE
GetHandleForIoctl(
    IN PHOST_INFO hostInfo
    );

//
// Constants
//

#define PCMCIA_DEVICE_NAME "\\DosDevices\\Pcmcia"

#define BUFFER_SIZE 4096
#define CISTPL_END  0xFF


typedef struct _StringTable {
   PUCHAR  CommandName;
   UCHAR   CommandCode;
} StringTable, *PStringTable;


typedef struct _OLD_PCCARD_DEVICE_DATA {
    ULONG DeviceId;
    ULONG LegacyBaseAddress;
    UCHAR IRQMap[16];
} OLD_PCCARD_DEVICE_DATA, *POLD_PCCARD_DEVICE_DATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\passprop\passprop.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1992
//
// File:        passprop.cxx
//
// Contents:    utility program to set domain password properties
//
//
// History:     3-May-96       Created         MikeSw
//
//------------------------------------------------------------------------


extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <lmcons.h>
#include <lmaccess.h>
#include "passp.h"
}

void _cdecl
main(int argc, char *argv[])
{
    NTSTATUS Status;
    PDOMAIN_PASSWORD_INFORMATION PasswordInfo =  NULL;
    SAM_HANDLE ServerHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    SAM_HANDLE UserHandle = NULL;
    LSA_HANDLE PolicyHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo = NULL;
    PULONG UserId = NULL;
    PSID_NAME_USE NameUse = NULL;
    ULONG TurnOffFlags = 0;
    ULONG TurnOnFlags = 0;
    int Index;
    CHAR MessageBuff[1000];
    CHAR ComplexArg[20];
    CHAR SimpleArg[20];
    CHAR AdminArg[20];
    CHAR NoAdminArg[20];

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0,
        NULL,
        NULL
        );

    FormatMessageA(
        FORMAT_MESSAGE_FROM_HMODULE,
        NULL,
        MSG_PASSPROP_SWITCH_COMPLEX,
        0,
        ComplexArg,
        20,
        NULL
        );

    FormatMessageA(
        FORMAT_MESSAGE_FROM_HMODULE,
        NULL,
        MSG_PASSPROP_SWITCH_SIMPLE,
        0,
        SimpleArg,
        20,
        NULL
        );

    FormatMessageA(
        FORMAT_MESSAGE_FROM_HMODULE,
        NULL,
        MSG_PASSPROP_SWITCH_ADMIN_LOCKOUT,
        0,
        AdminArg,
        20,
        NULL
        );

    FormatMessageA(
        FORMAT_MESSAGE_FROM_HMODULE,
        NULL,
        MSG_PASSPROP_SWITCH_NO_ADMIN_LOCKOUT,
        0,
        NoAdminArg,
        20,
        NULL
        );


    for (Index = 1; Index < argc  ; Index++)
    {
        if (_stricmp(argv[Index],ComplexArg) == 0)
        {
            TurnOnFlags |= DOMAIN_PASSWORD_COMPLEX;
        } else if (_stricmp(argv[Index],SimpleArg) == 0)
        {
            TurnOffFlags |= DOMAIN_PASSWORD_COMPLEX;
        } else if (_stricmp(argv[Index],AdminArg) == 0)
        {
            TurnOnFlags |= DOMAIN_LOCKOUT_ADMINS;
        } else if (_stricmp(argv[Index],NoAdminArg) == 0)
        {
            TurnOffFlags |= DOMAIN_LOCKOUT_ADMINS;
        } else
        {
            goto Usage;
        }
    }

    //
    // The InitializeObjectAttributes call doesn't initialize the
    // quality of serivce, so do that separately.
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;



    Status = LsaOpenPolicy(
                NULL,
                &ObjectAttributes,
                POLICY_VIEW_LOCAL_INFORMATION,
                &PolicyHandle
                );

    if (!NT_SUCCESS(Status)) {
        printf("Failed to open local policy: 0x%x\n",Status);
        return;
    }

    Status = LsaQueryInformationPolicy(
                PolicyHandle,
                PolicyAccountDomainInformation,
                (PVOID *) &AccountDomainInfo
                );

    LsaClose(PolicyHandle);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to query info policy: 0x%x\n",Status);
        return;
    }

    Status = SamConnect(
                NULL,
                &ServerHandle,
                SAM_SERVER_LOOKUP_DOMAIN,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(Status)) {
        printf("Failed to sam connect: 0x%x\n",Status);
        return;
    }

    Status = SamOpenDomain(
                ServerHandle,
                MAXIMUM_ALLOWED,
                AccountDomainInfo->DomainSid,
                &DomainHandle
                );
    if (!NT_SUCCESS(Status)) {
        printf("Failed to open domain: 0x%x\n",Status);
        SamCloseHandle(ServerHandle);
        return;
    }

    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainPasswordInformation,
                (PVOID *) &PasswordInfo
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to query domain pasword info: 0x%x\n",Status);
        SamCloseHandle(ServerHandle);
        SamCloseHandle(DomainHandle);
        return;

    }
    PasswordInfo->PasswordProperties = (PasswordInfo->PasswordProperties | TurnOnFlags) & (~TurnOffFlags);

    if ((TurnOnFlags != 0) || (TurnOffFlags != 0))
    {
        Status = SamSetInformationDomain(
                    DomainHandle,
                    DomainPasswordInformation,
                    PasswordInfo
                    );
        if (!NT_SUCCESS(Status))
        {
            printf("Failed to query domain pasword info: 0x%x\n",Status);
            return;
        }
    }

    if ((PasswordInfo->PasswordProperties & DOMAIN_PASSWORD_COMPLEX) != 0)
    {
        FormatMessageA(
            FORMAT_MESSAGE_FROM_HMODULE,
            NULL,
            MSG_PASSPROP_COMPLEX,
            0,
            MessageBuff,
            1000,
            NULL
            );
    }
    else
    {
        FormatMessageA(
            FORMAT_MESSAGE_FROM_HMODULE,
            NULL,
            MSG_PASSPROP_SIMPLE,
            0,
            MessageBuff,
            1000,
            NULL
            );
    }
    printf("%s",MessageBuff);
    if ((PasswordInfo->PasswordProperties & DOMAIN_LOCKOUT_ADMINS) != 0)
    {
        FormatMessageA(
            FORMAT_MESSAGE_FROM_HMODULE,
            NULL,
            MSG_PASSPROP_ADMIN_LOCKOUT,
            0,
            MessageBuff,
            1000,
            NULL
            );
    }
    else
    {
        FormatMessageA(
            FORMAT_MESSAGE_FROM_HMODULE,
            NULL,
            MSG_PASSPROP_NO_ADMIN_LOCKOUT,
            0,
            MessageBuff,
            1000,
            NULL
            );
    }
    printf("%s",MessageBuff);

    SamCloseHandle(ServerHandle);
    SamCloseHandle(DomainHandle);
    SamFreeMemory(PasswordInfo);
    return;

Usage:
    FormatMessageA(
            FORMAT_MESSAGE_FROM_HMODULE,
            NULL,
            MSG_PASSPROP_USAGE,
            0,
            MessageBuff,
            1000,
            NULL
            );

    printf("%s",MessageBuff);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pcmcmd\getopt.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    getopt.c

Abstract:

    Utility function to parse command line options.
    Inspired by UNIX getopt - but coded from scratch.
    Not thread-safe currently (don't call this from
    multiple threads simultaneously)
   
Author:

    Ravisankar Pudipeddi (ravisp) 27 June 1997

Environment:

    User

Notes:

Revision History:

--*/

#include <pch.h>

PUCHAR optarg;
ULONG  optind=1;
static ULONG optcharind;
static ULONG hyphen=0;

CHAR
getopt (ULONG Argc, PUCHAR *Argv, PCHAR Opts)

/*++

Routine Description:

    Parses command line arguments.
    This function should be repeatedly called
    to parse all the supplied command line options.
    A command line argument prefixed with a hyphen/slash
    ('-' or '/') is treated as a command line option(s).
    The set of options the caller is interested in
    is passed via the Opts argument.

    The format of this desired options list is:

    "<option-letter1>[:]<option-letter2>[:]......."

    Examples: "ds:g",  "x:o:r" etc. 
    Each letter in this string is an option the
    caller is interested in.
    If there is a colon (':') after the option letter,
    then the caller expects an argument with this option
    letter. 
    On each call, successive options are processed and
    the next matching option in the list of desired options
    is returned. If the option requires an argument, then
    the option argument is in the global 'optarg'.
    If all the options have been processed then the value
    EOF is returned at which point caller should desist
    calling this function again for the lifetime of the process.

    A single hyphen/slash ('-' or '/) unaccompanied by any option 
    letter in the command line indicates  getopt to stop processing
    command line options and treat the rest of the arguments
    as regular command line arguments.
    
    After all the options have been processed (i.e. getopt
    returned EOF), the global 'optind' contains the index
    to the start of the non-option arguments which may be
    processed by the caller.

    Note: This function *does not* return an error code if 
    an non-desired option is encountered in the command line.
    
Arguments:
    
    Argc  -  number of command line arguments
    Argv  -  pointer to array of command line arguments 
             (Argv[0] is skipped in processing the options,
              treated as the base filename of the executable)

    Opts  -  String containing the desired options

Return Value:
    
    EOF   - No more options. Don't call this function again.
            The global 'optind' points to index of the first argument
            following the options on the command line
    
    0     - Error in specifying command line options 
           
    Any other character -  Next option on the command line.
                           The value 'optarg' points to the command line
                           argument string following this option, if 
                           the option was indicated as requiring an argument
                           (i.e. preceding a colon in the Opts string)

--*/
{
    CHAR  ch;
    PCHAR indx;

    do {
        if (optind >= Argc) {
            return EOF;
        }
    
        ch = Argv[optind][optcharind++];
        if (ch == '\0') {
            optind++; optcharind=0;
            hyphen = 0;
            continue;
        }
        
        if ( hyphen || (ch == '-') || (ch == '/')) {
            if (!hyphen) {
                ch = Argv[optind][optcharind++];
                if (ch == '\0') {
                    //
                    // just a '-' (or '/')  without any other
                    // char after it indicates to stop
                    // processing options, the rest are
                    // regular command line arguments
                    // optind points to the arguments after
                    // this lone hyphen
                    //
                    optind++;
                    return EOF;
                }
            } else if (ch == '\0') {
                //
                // End of options on this arg.
                // continue to next...
                optind++; 
                optcharind = 0;
                continue;
            }
            indx = strchr(Opts, ch);
            if (indx == NULL) {
                //
                // Non-desired option encountered
                // We just ignore it
                //
                continue;
            }
            if (*(indx+1) == ':') {
                if (Argv[optind][optcharind] != '\0'){
                    optarg = &Argv[optind][optcharind];
                } else {
                    if ((optind + 1) >= Argc ||
                        (Argv[optind+1][0] == '-' ||
                         Argv[optind+1][0] == '/' )) {
                        //
                        // This is a case when one of the following error
                        // condition exists: 
                        //  1. The user didn't supply an argument to an option
                        //     which requires one (ie, this option was the last
                        //     command line argument on the line)
                        //  2. The  supplied another option as an argument to this
                        //     option. Currently we treat this as an error
                        //
                        return 0;
                    }
                    optarg = Argv[++optind];
                }
                optind++;
                hyphen = optcharind = 0;
                return ch;
            }
            //
            // Argument not required for this option
            // So any other characters in the same
            // argument would be other valid options
            //
            hyphen = 1;
            return ch;
        } else {
            //
            // Non option encountered.
            // No more options present..
            //
            return EOF;
        }
    } while (1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pcmcmd\pch.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include <string.h>
#include <ntconfig.h>
#include <windows.h>
#include <setupapi.h>

#include <ntddpcm.h>
#include <tuple.h>
#include <pcmcmd.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pcmcmd\pcmcmd.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

     pcmcmd.c

Abstract:

     This program converses with the PCMCIA support driver to display
     tuple and other information.

Author:

     Bob Rinne

Environment:

     User process.

Notes:

Revision History:
    
     Ravisankar Pudipeddi (ravisp) June 27 1997
          - command line options & support for multiple controllers
     Neil Sandlin (neilsa) Sept 20, 1998
          - more commands      
     Neil Sandlin (neilsa) Apr 15, 2002
          - rewrote it to use setupapi

--*/

#include <pch.h>


BOOL
ProcessCommands(
    HDEVINFO hDevInfo,
    PHOST_INFO HostInfo
    );
    
BOOL
EnumerateHostControllers(
    HDEVINFO hInfoList
    );

    
VOID
DumpSocketInfo(
    PHOST_INFO HostInfo
    );
    
VOID
HideDevice(
    PHOST_INFO HostInfo
    );

VOID
RevealDevice(
    PHOST_INFO HostInfo
    );

VOID
PrintHelp(
    VOID
    );



PHOST_INFO hostInfoList = NULL;
PHOST_INFO hostInfoListTail = NULL;
ULONG   Commands = 0;
PUCHAR specifiedInstanceID = NULL;
LONG specifiedDeviceNumber = -1;
LONG specifiedSlotNumber = -1;

#define CMD_DUMP_TUPLES           0x00000001
#define CMD_DUMP_CONFIGURATION  0x00000002
#define CMD_DUMP_REGISTERS    0x00000004 
#define CMD_DUMP_SOCKET_INFO      0x00000008
#define CMD_DUMP_IRQ_SCAN_INFO  0x00000010
#define CMD_HIDE_DEVICE           0x00000020
#define CMD_REVEAL_DEVICE         0x00000040

//
// Procedures
//


int __cdecl
main(
    int     argc,
    char *argv[]
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG   deviceNumber = 0;
    ULONG   slotNumber = 0;
    NTSTATUS status;
    CHAR      c;
    extern  PUCHAR optarg;
    PHOST_INFO hostInfo;
    HDEVINFO hDevInfo;
    BOOL bRet;
    ULONG requiredSize = 0;
    GUID classGuid;

    //
    // Scan command line
    //

    while ((c = getopt(argc, argv, "d:s:p:hrti?")) != EOF) {

        switch (c) {

        case 'd':
            specifiedDeviceNumber = atoi(optarg);
            break;


        case 's':
            specifiedSlotNumber = atoi(optarg);
            break;
            
        case 'p':
            specifiedInstanceID = optarg;
            break;            


        case 't':
            Commands |= CMD_DUMP_TUPLES;
            break;
           

        case 'i':
            Commands |= CMD_DUMP_IRQ_SCAN_INFO;
            break;


        case 'h':
            Commands |= CMD_HIDE_DEVICE;
            break;


        case 'r':
            Commands |= CMD_REVEAL_DEVICE;
            break;


        default:
            PrintHelp();
            return(1);
        }
    }


    //
    // Dump IRQscan info from registry, if requested
    //
    
    if (Commands & CMD_DUMP_IRQ_SCAN_INFO) {
        DumpIrqScanInfo();
        
        //
        // if there were no other commands, then exit
        //
        if (!(Commands & ~CMD_DUMP_IRQ_SCAN_INFO)) {
            return(0);
        }
        Commands &= ~CMD_DUMP_IRQ_SCAN_INFO;
    }


    //
    // Build a list of devices from the class GUID for pcmcia
    //

    
    bRet = SetupDiClassGuidsFromName("PCMCIA", &classGuid, 1, &requiredSize);
    
    if (!bRet || (requiredSize == 0)) {
        printf("error: couldn't find class GUID for PCMCIA\n");
        return;
    }

    hDevInfo = SetupDiGetClassDevs(&classGuid, NULL, NULL, DIGCF_PRESENT | DIGCF_PROFILE);
    
    if (hDevInfo == INVALID_HANDLE_VALUE) {
        printf("error(%d): couldn't create info list\n", GetLastError());
        return;
    }

    try{
        BOOL bProcessedAtLeastOne = FALSE;
        //
        // Build the list of pcmcia controllers
        //

        if (!EnumerateHostControllers(hDevInfo)) {
            leave;
        }

        //
        // Loop through the list of controllers
        //
        
        for (hostInfo = hostInfoList; hostInfo != NULL; hostInfo = hostInfo->Next) {
       
            if (ProcessCommands(hDevInfo, hostInfo)) {
                bProcessedAtLeastOne = TRUE;
            }
       
        }

        if (!bProcessedAtLeastOne) {
            printf("controller not found\n");
        }

    } finally {
    
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }        

    return (0);
}


BOOL
GetDeviceRegistryDword(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA devInfoData,
    PUCHAR ValueName,
    ULONG KeyType,
    PULONG pData
    )
{
    HKEY hDeviceKey;
    LONG status;
    ULONG sizeOfUlong = sizeof(ULONG);

    hDeviceKey = SetupDiOpenDevRegKey(hDevInfo,
                                      devInfoData,
                                      DICS_FLAG_GLOBAL,
                                      0,
                                      KeyType,
                                      KEY_READ);
                                      
    if (hDeviceKey == INVALID_HANDLE_VALUE) {
        printf("error: unable to open DevRegKey\n");
        return FALSE;
    }
    
    status = RegQueryValueEx(hDeviceKey,
                             ValueName,
                             NULL,
                             NULL,
                             (PUCHAR) pData,
                             &sizeOfUlong);
                             

    RegCloseKey(hDeviceKey);

    return (status == ERROR_SUCCESS);
}    


BOOL
EnumerateHostControllers(
    HDEVINFO hDevInfo
    )
/*++

Routine Description:

    Build a linked list of HOST_INFO data structures, one for each PCMCIA controller

Arguments:

Return Value:

--*/
{
    BOOL bRet;
    ULONG requiredSize = 0;
    GUID classGuid;
    ULONG index = 0;
    SP_DEVINFO_DATA devInfoData;
    PHOST_INFO hostInfo;

    devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    
    //
    // Loop through all instances of pcmcia host controllers
    //
    
    while(1) {
        bRet = SetupDiEnumDeviceInfo(hDevInfo, index, &devInfoData);
        
        if (!bRet) {
            if (index == 0) {
                printf("error(%d): no pcmcia host controllers found\n", GetLastError());
                return FALSE;
            }
            break;
        }

        //
        // Found a controller. Create a host info structure and chain it to the global list
        //
        
        hostInfo = malloc(sizeof(HOST_INFO));
        if (hostInfo == NULL) {
            printf("malloc error - out of memory\n");
            return FALSE;
        }

        memset(hostInfo, 0, sizeof(HOST_INFO));
        hostInfo->DeviceIndex = index;
        
        if (hostInfoListTail == NULL) {
            hostInfoListTail = hostInfo;        
            hostInfoList = hostInfo;
        } else {
            hostInfoListTail->Next = hostInfo;        
        }            

        //
        // get the device instance string for our host_info structure
        //            
        
        requiredSize = 0;            
        bRet = SetupDiGetDeviceInstanceId(hDevInfo,
                                          &devInfoData,
                                          NULL,
                                          0,
                                          &requiredSize);

        if (!requiredSize) {
            printf("error: found DeviceInfo with no instance ID\n");
            return FALSE;
        }
        
        hostInfo->InstanceID = malloc(requiredSize);
        
        if (hostInfo->InstanceID == NULL) {
            printf("malloc error - out of memory\n");
            return FALSE;
        }
        
        bRet = SetupDiGetDeviceInstanceId(hDevInfo,
                                          &devInfoData,
                                          hostInfo->InstanceID,
                                          requiredSize,
                                          &requiredSize);

        if (!bRet) {
            printf("error: couldn't retrieve instance ID\n");
            return FALSE;
        }
        
        //
        // Get the "CompatibleControllerType", so we know how many sockets there are
        //
        
        bRet = GetDeviceRegistryDword(hDevInfo,
                                      &devInfoData,
                                      "CompatibleControllerType",                                     
                                      DIREG_DRV,
                                      &hostInfo->ControllerType);
        
        if (!bRet) {
            hostInfo->ControllerType = 0xFFFFFFFF;
        }
        
        index++;
    }
    return TRUE;
}


BOOL
ProcessCommands(
    HDEVINFO hDevInfo,
    PHOST_INFO hostInfo
    )
{
    NTSTATUS status;

    ULONG   slotNumber;
    ULONG numberOfSlots = 1;


    if (specifiedInstanceID && strcmp(specifiedInstanceID, hostInfo->InstanceID)) {
        return FALSE;
    }
    
    if ((specifiedDeviceNumber != -1) && (specifiedDeviceNumber != hostInfo->DeviceIndex)) {
        return FALSE;
    }
    
    // NEED TO IMPLEMENT: there are more types of controllers with 2 slots
    if (hostInfo->ControllerType == 0) {
        numberOfSlots = 2;
    }
    
    printf("\n**---- PC-CARD host controller %d ----**\n\n", hostInfo->DeviceIndex);
    printf("    %s\n", hostInfo->InstanceID);
    
    for (slotNumber = 0; slotNumber < numberOfSlots; slotNumber++) {
        
        if ((specifiedSlotNumber != -1) && (specifiedSlotNumber != slotNumber)) {
            continue;
        }
        
        hostInfo->SocketNumber = slotNumber;    

        if (Commands & CMD_DUMP_TUPLES) {
            DumpCIS(hostInfo);
        }
        if (Commands & CMD_HIDE_DEVICE) {
            HideDevice(hostInfo);
        }
        if (Commands & CMD_REVEAL_DEVICE) {
            RevealDevice(hostInfo);
        }
        if (!Commands || (Commands & CMD_DUMP_SOCKET_INFO)) {
            DumpSocketInfo(hostInfo); 
        }
        
    }        
    return TRUE;
}



HANDLE
GetHandleForIoctl(
    IN PHOST_INFO hostInfo
    )

/*++

Routine Description:

     This routine will open the device.

Arguments:

     DeviceName - ASCI string of device path to open.
     HandlePtr - A pointer to a location for the handle returned on a
                     successful open.

Return Value:

     NTSTATUS

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    STRING              NtFtName;
    IO_STATUS_BLOCK status_block;
    UNICODE_STRING  unicodeDeviceName;
    NTSTATUS            status;
    UCHAR   deviceName[128];
    HANDLE handle;

    sprintf(deviceName, "%s%d", PCMCIA_DEVICE_NAME, hostInfo->DeviceIndex);

    RtlInitString(&NtFtName, deviceName);

    (VOID)RtlAnsiStringToUnicodeString(&unicodeDeviceName,
                                       &NtFtName,
                                       TRUE);

    memset(&objectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));

    InitializeObjectAttributes(&objectAttributes,
                               &unicodeDeviceName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);


    status = NtOpenFile(&handle,
                        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                        &objectAttributes,
                        &status_block,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT );

    RtlFreeUnicodeString(&unicodeDeviceName);

    if (!NT_SUCCESS(status)) {
        printf("error: Unable to OpenFile on %s\n", deviceName);
        handle = INVALID_HANDLE_VALUE;
    }
    
    return handle;

} // OpenDevice

PUCHAR Controllers[] = {
    "PcmciaIntelCompatible",  
    "PcmciaCardBusCompatible",
    "PcmciaElcController",    
    "PcmciaDatabook",         
    "PcmciaPciPcmciaBridge",  
    "PcmciaCirrusLogic",         
    "PcmciaTI",           
    "PcmciaTopic",          
    "PcmciaRicoh",          
    "PcmciaDatabookCB",          
    "PcmciaOpti",       
    "PcmciaTrid",       
    "PcmciaO2Micro",          
    "PcmciaNEC",            
    "PcmciaNEC_98",            
};



VOID
DumpSocketInfo(
    IN PHOST_INFO hostInfo
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS                 status;
    IO_STATUS_BLOCK      statusBlock;
    PCMCIA_SOCKET_INFORMATION commandBlock;
    ULONG ctlClass, ctlModel, ctlRev;
    HANDLE  handle;

    handle = GetHandleForIoctl(hostInfo);

    if (handle == INVALID_HANDLE_VALUE) {
        return;
    }

    memset(&commandBlock, 0, sizeof(commandBlock));
    commandBlock.Socket = (USHORT) hostInfo->SocketNumber;

    status = NtDeviceIoControlFile(handle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   IOCTL_SOCKET_INFORMATION,
                                   &commandBlock,
                                   sizeof(commandBlock),
                                   &commandBlock,
                                   sizeof(commandBlock));

    if (!NT_SUCCESS(status)) {
        printf("    error: %08x on DumpSocketInfo ioctl\n", status);
        NtClose(handle);
        return;
    }        
    
    printf("    Basic Information for Socket %d:\n", hostInfo->SocketNumber);

    printf("        Manufacturer = %s\n", commandBlock.Manufacturer);
    printf("        Identifier   = %s\n", commandBlock.Identifier);
    printf("        TupleCRC     = %x\n", commandBlock.TupleCrc);
    printf("        DriverName   = %s\n", commandBlock.DriverName);
    printf("        Function ID = %d\n", commandBlock.DeviceFunctionId);

    ctlClass = PcmciaClassFromControllerType(commandBlock.ControllerType);
    if (ctlClass >= sizeof(Controllers)/sizeof(PUCHAR)) {
        printf("        ControllerType = Unknown (%x)\n", commandBlock.ControllerType);
    } else {
        printf("        ControllerType(%x) = %s", commandBlock.ControllerType,
                                                         Controllers[ctlClass]);
        ctlModel = PcmciaModelFromControllerType(commandBlock.ControllerType);
        ctlRev  = PcmciaRevisionFromControllerType(commandBlock.ControllerType);

        if (ctlModel) {
            printf("%d", ctlModel);
        }
        if (ctlRev) {
            printf(", rev(%d)", ctlRev);
        }                
                    
        printf("\n");
    }
    if (commandBlock.CardInSocket) {
        printf("        Card In Socket\n");
    }
    if (commandBlock.CardEnabled) {
        printf("        Card Enabled\n");
    }
    
    NtClose(handle);
}



VOID
HideDevice(
    IN PHOST_INFO hostInfo
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS                 status;
    IO_STATUS_BLOCK      statusBlock;
    PCMCIA_SOCKET_REQUEST commandBlock;
    HANDLE  handle;
    
    handle = GetHandleForIoctl(hostInfo);

    if (handle == INVALID_HANDLE_VALUE) {
        return;
    }

    memset(&commandBlock, 0, sizeof(commandBlock));
    commandBlock.Socket = (USHORT) hostInfo->SocketNumber;

    status = NtDeviceIoControlFile(handle, NULL, NULL, NULL,
                                   &statusBlock,
                                   IOCTL_PCMCIA_HIDE_DEVICE,
                                   &commandBlock, sizeof(commandBlock),
                                   NULL, 0);

    if (NT_SUCCESS(status)) {
         printf("OK\n");
    } else {
         printf("Failed - %x\n", status);
    }
    NtClose(handle);
}



VOID
RevealDevice(
    IN PHOST_INFO hostInfo
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS                 status;
    IO_STATUS_BLOCK      statusBlock;
    PCMCIA_SOCKET_REQUEST commandBlock;
    HANDLE  handle;
    
    handle = GetHandleForIoctl(hostInfo);

    if (handle == INVALID_HANDLE_VALUE) {
        return;
    }

    memset(&commandBlock, 0, sizeof(commandBlock));
    commandBlock.Socket = (USHORT) hostInfo->SocketNumber;

    status = NtDeviceIoControlFile(handle, NULL, NULL, NULL,
                                   &statusBlock,
                                   IOCTL_PCMCIA_REVEAL_DEVICE,
                                   &commandBlock, sizeof(commandBlock),
                                   NULL, 0);

    if (NT_SUCCESS(status)) {
         printf("OK\n");
    } else {
         printf("Failed - %x\n", status);
    }
    NtClose(handle);
}


VOID
PrintHelp(
    VOID
    )
{   
    printf("pcmcmd.exe - Command line interface to the PCCARD (pcmcia, cardbus) bus driver\n");
    printf("\n");
    printf("Usage: PCMCMD [-d <arg>] [-s <arg>] [-p <arg>] [-t] [-i]\n");
    printf("\n");
    printf("  -p \"PnP instance ID\"        specifies PCMCIA host by PnP instance ID\n");
    printf("  -d ControllerNumber         specifies PCMCIA host by number (zero-based)\n");
    printf("  -s SocketNumber             specifies PCMCIA socket number (zero-based)\n");
    printf("                              Note: cardbus hosts have only one socket\n");
    printf("  -t                          Dumps the CIS tuples of the PC-Card\n");
    printf("  -i                          Dumps irq detection info\n");
    printf("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pcmcmd\registry.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

     registry.c

Abstract:

     This module contains the code that dumps pccard info from the registry

Author:

     Neil Sandlin (neilsa) 11 Feb 1999

Environment:

     User mode

Revision History :


--*/

#include "pch.h"

#define PCMCIA_REGISTRY_CONTROLLER_TYPE  "OtherController"



VOID
DumpIrqMap(
    PUCHAR IRQMap
    )
{

    ULONG i;
    ULONG usable = 0, crossed = 0;
    
    for (i = 1; i < 16; i++) {
        if (IRQMap[i] == i) {
            usable++;
        } else if (IRQMap[i] != 0) {
            crossed++;
        }
    }
    
    if (usable == 0) {
        printf("NO usable IRQs found!\n");
    } else {
        if (usable == 1) {
            printf("1 usable IRQ found: ");
        } else {
            printf("%d usable IRQs found: ", usable);
        }
        
    
        for (i = 1; (i < 16) && usable; i++) {
            if (IRQMap[i] == i) {
                printf("%X", i);
                if (--usable != 0) {
                    printf(",");
                }
            }

        }                    
        printf("\n");
    }
    
    if (crossed) {
        printf("Crosswired IRQs found!\n");
    
        for (i = 1; (i < 16) && crossed; i++) {
            if (IRQMap[i] && (IRQMap[i] != i)) {
                printf("          %X ==> %X\n", i, IRQMap[i]);
                crossed--;
            }
        }                    
    }
    printf("\n");
}    


VOID
DumpDetectedIrqMaskData(
    PVOID pArgData,
    ULONG DataSize
    )
{
    static PUCHAR ErrorStrings[] = {
          "Unknown",
          "Scan Disabled",
          "Map Zero",
          "No Timer (PNP0100)",
          "No Pic (PNP0000)",
          "No Legacy Base",
          "Dup Legacy Base",
          "No Controllers"
          };
#define MAX_ERROR_CODE 7


    if (DataSize == sizeof(CM_PCCARD_DEVICE_DATA)) {
    
        PCM_PCCARD_DEVICE_DATA pData = (PCM_PCCARD_DEVICE_DATA) pArgData;
        printf("Version 1.0 Data\n");

        if (pData->Flags & PCCARD_DEVICE_PCI) {
             printf("Device is PCI enumerated\n");
        }
        if (pData->DeviceId) {
             printf("DeviceId = %X\n", pData->DeviceId);
        }
        if (pData->BusData) {            
             printf("BusData = %06X\n", pData->BusData);
        }
        if (pData->LegacyBaseAddress) {
             printf("LegacyBase = %X\n", pData->LegacyBaseAddress);
        }             
        if (pData->Flags & PCCARD_MAP_ERROR) {
             UCHAR ec = pData->ErrorCode;
             
             if (ec > MAX_ERROR_CODE) {
                  ec = 0;
             }
             printf("\n*** Detection error! *** ==> %s\n\n", ErrorStrings[ec]);
        } else {
        
        }
        
        DumpIrqMap(pData->IRQMap);
        
    } else if (DataSize == sizeof(OLD_PCCARD_DEVICE_DATA)) { 
        POLD_PCCARD_DEVICE_DATA pData = (POLD_PCCARD_DEVICE_DATA) pArgData;
        printf("Version 0.9 Data\n");
        printf("DeviceId = %X\n", pData->DeviceId);
        printf("LegacyBase = %X\n", pData->LegacyBaseAddress);
        DumpIrqMap(pData->IRQMap);

    } else {
        printf("Error: unrecognized data size\n");
    }        
}
                                    


VOID
DumpPcCardKey(
    HKEY handlePcCard
    )
/*++

Routine Description:

    This routine looks through the OtherController key for pccard entries
    created by NTDETECT. For each entry, the IRQ scan data is read in and
    saved for later.
    

Arguments:

    handlePcCard - open handle to "OtherController" key in registry at
                        HARDWARE\Description\System\MultifunctionAdapter\<ISA>

Return value:

    status

--*/
{
#define VALUE2_BUFFER_SIZE sizeof(CM_PCCARD_DEVICE_DATA) + sizeof(CM_FULL_RESOURCE_DESCRIPTOR)
    UCHAR valueInfo[VALUE2_BUFFER_SIZE];
    ULONG valueInfoSize;
    ULONG DataType;

    LONG     status;
    LPTSTR subKeyInfo;
    HKEY     handleSubKey = NULL;
    ULONG  subKeyInfoSize;
    ULONG  index;
    ULONG  resultLength;
    DWORD SubKeys;
    BOOLEAN FoundPcCard = FALSE;
    
    status = RegQueryInfoKey(handlePcCard,
                                     NULL, NULL, 0,
                                     &SubKeys,
                                     &subKeyInfoSize,
                                     NULL, NULL, NULL, NULL, NULL, NULL);
                                     
    if ((status != ERROR_SUCCESS) &&
         (status != ERROR_MORE_DATA) &&
         (status != ERROR_INSUFFICIENT_BUFFER)) {
        printf("Error: unable to query info on PcCardKey\n");   
        goto cleanup;
    }
    
    subKeyInfo = malloc(subKeyInfoSize+1);
    
    if (!subKeyInfo) {
        printf("Error: unable to malloc subKeyInfo (%d)\n", subKeyInfoSize+1);   
        goto cleanup;
    }

    for (index=0; index < SubKeys; index++) {   
    
        //
        // Loop through the children of the PcCardController key
        //
        status = RegEnumKey(handlePcCard,
                                  index,
                                  subKeyInfo,
                                  subKeyInfoSize+1);

        if (status != NO_ERROR) {
            if (!FoundPcCard) {
                printf("\nError: unable to find pccard detection key\n\n");
            }
            goto cleanup;
        }
    
        if (handleSubKey) {
            // close handle from previous iteration
            RegCloseKey(handleSubKey);
            handleSubKey = NULL;
        }

        status = RegOpenKeyEx(handlePcCard,
                                     subKeyInfo,
                                     0,
                                     KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                                     &handleSubKey);

        if (status != NO_ERROR) {
            printf("Error: unable to open enumerated key %s (%d)\n", subKeyInfo, status);
            goto cleanup;
        }
        
        //
        // Get the value of "Identifier"
        //

        valueInfoSize = VALUE2_BUFFER_SIZE;
        status = RegQueryValueEx(handleSubKey,
                                         "Identifier",
                                         0,
                                         &DataType,
                                         valueInfo,
                                         &valueInfoSize
                                         );

        if (status == NO_ERROR) {
        
            if ((valueInfoSize == 17) &&
                (valueInfo[0] == 'P') &&
                (valueInfo[1] == 'c') &&
                (valueInfo[2] == 'C') &&
                (valueInfo[3] == 'a') &&
                (valueInfo[4] == 'r') &&
                (valueInfo[5] == 'd')) {

                FoundPcCard = TRUE;              
                //
                // Get the IRQ detection data
                //
                valueInfoSize = VALUE2_BUFFER_SIZE;
                status = RegQueryValueEx(handleSubKey,
                                                 "Configuration Data",
                                                 0,
                                                 &DataType,
                                                 valueInfo,
                                                 &valueInfoSize
                                                 );
              
                if (status == NO_ERROR) {
                    PCM_FULL_RESOURCE_DESCRIPTOR pFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) valueInfo;
                    PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartialDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) pFullDesc->PartialResourceList.PartialDescriptors;

                    
                    if (pPartialDesc->Type == CmResourceTypeDeviceSpecific) {
                        printf("\n*** PcCard Irq Detection Data:%s ***\n\n", subKeyInfo);

                        DumpDetectedIrqMaskData((PVOID)((ULONG_PTR)&pPartialDesc->u.DeviceSpecificData + 3*sizeof(ULONG)),
                                                        pPartialDesc->u.DeviceSpecificData.DataSize);
                    }
                }
            }
        }
 
    }
cleanup:
    if (handleSubKey) {
        RegCloseKey(handleSubKey);
    }
    
    if (subKeyInfo) {
        free(subKeyInfo);
    }
    return;      
}



VOID
DumpIrqScanInfo(
    VOID
    )
/*++

Routine Description:

    This routine finds the "OtherController" entry in
    HARDWARE\Description\System\MultifunctionAdapter\<ISA>. This is
    where NTDETECT stores irq scan results.
    
Arguments:

Return value:

    status

--*/
{

#define VALUE_BUFFER_SIZE 4

    UCHAR valueInfo[VALUE_BUFFER_SIZE];
    ULONG valueInfoSize;
    
    HKEY     handleRoot = NULL;
    HKEY     handleSubKey = NULL;
    HKEY     handlePcCard = NULL;
    LPTSTR subKeyInfo = NULL;
    ULONG  subKeyInfoSize;
    LONG     status;
    ULONG  resultLength;
    ULONG  index;
    ULONG  DataType;
    DWORD  SubKeys;
    BOOLEAN FoundIsa = FALSE;
    
    //
    // Get a handle to the MultifunctionAdapter key
    //


    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 "HARDWARE\\DESCRIPTION\\System\\MultiFunctionAdapter",
                                 0,
                                 KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                                 &handleRoot);

    if (status != NO_ERROR) {
        printf("Error: unable to open MultiFunctionAdapter key (%d)\n", status);   
        goto cleanup;
    }    

    status = RegQueryInfoKey(handleRoot,
                                     NULL, NULL, 0,
                                     &SubKeys,
                                     &subKeyInfoSize,
                                     NULL, NULL, NULL, NULL, NULL, NULL);
                                     
     if ((status != ERROR_SUCCESS) &&
          (status != ERROR_MORE_DATA) &&
          (status != ERROR_INSUFFICIENT_BUFFER)) {
        printf("Error: unable to query info on MultiFunctionAdapter key (%d)\n", status);   
        goto cleanup;
     }

    subKeyInfo = malloc(subKeyInfoSize+1);
    
    if (!subKeyInfo) {
        printf("Error: unable to malloc subKeyInfo (%d)\n", subKeyInfoSize+1);   
        goto cleanup;
    }
    
    for (index=0; index < SubKeys; index++) {
    
        //
        // Loop through the children of "MultifunctionAdapter"
        //
        status = RegEnumKey(handleRoot,
                                  index,
                                  subKeyInfo,
                                  subKeyInfoSize+1);   

        if (status != NO_ERROR) {
            if (!FoundIsa) {
                printf("Error: ISA key not found (%d)\n", status);
            }                
            goto cleanup;
        }

    
        if (handleSubKey) {
            // close handle from previous iteration
            RegCloseKey(handleSubKey);
            handleSubKey = NULL;
        }
        
        status = RegOpenKeyEx(handleRoot,
                                     subKeyInfo,
                                     0,
                                     KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                                     &handleSubKey);
    
        if (status != NO_ERROR) {
            printf("Error: unable to open enumerated key %s (%d)\n", subKeyInfo, status);
            goto cleanup;
        }



        //
        // Get the value of "Identifier"
        //
        valueInfoSize = VALUE_BUFFER_SIZE;
        status = RegQueryValueEx(handleSubKey,
                                         "Identifier",
                                         0,
                                         &DataType,
                                         valueInfo,
                                         &valueInfoSize
                                         );
        
        if (status == NO_ERROR) {
            
            if ((valueInfoSize == 4) &&
                (valueInfo[0] == 'I') &&
                (valueInfo[1] == 'S') &&
                (valueInfo[2] == 'A') &&
                (valueInfo[3] == 0)) {

                FoundIsa = TRUE;
                status = RegOpenKeyEx(handleSubKey,
                                             PCMCIA_REGISTRY_CONTROLLER_TYPE,
                                             0,
                                             KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                                             &handlePcCard);
                
                if (status == NO_ERROR) {
                
                    DumpPcCardKey(handlePcCard);
                    RegCloseKey(handlePcCard);
                } else {
                    printf("\nError: unable to find pccard detection data\n\n");
                } 
            }
        }
    }
    
cleanup:
    if (handleRoot) {
        RegCloseKey(handleRoot);
    }

    if (handleSubKey) {
        RegCloseKey(handleSubKey);
    }
    
    if (subKeyInfo) {
        free(subKeyInfo);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pcmcmd\tuples.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

     tuples.c

Abstract:

     This program converses with the PCMCIA support driver to display
     tuple and other information.

Author:

     Bob Rinne

Environment:

     User process.

Notes:

Revision History:
    
     Ravisankar Pudipeddi (ravisp) June 27 1997
          - command line options & support for multiple controllers
     Neil Sandlin (neilsa) Sept 20, 1998
          - more commands        

--*/

#include <pch.h>

//
// Tuple output strings
//


StringTable CommandCodes[] = {

    "CISTPL_NULL",           CISTPL_NULL,
    "CISTPL_DEVICE",         CISTPL_DEVICE,
    "CISTPL_LONGLINK_MFC",   CISTPL_LONGLINK_MFC,   
    "CISTPL_CHECKSUM",       CISTPL_CHECKSUM,
    "CISTPL_LONGLINK_A",     CISTPL_LONGLINK_A,
    "CISTPL_LONGLINK_C",     CISTPL_LONGLINK_C,
    "CISTPL_LINKTARGET",     CISTPL_LINKTARGET,
    "CISTPL_NO_LINK",        CISTPL_NO_LINK,
    "CISTPL_VERS_1",         CISTPL_VERS_1,
    "CISTPL_ALTSTR",         CISTPL_ALTSTR,
    "CISTPL_DEVICE_A",       CISTPL_DEVICE_A,
    "CISTPL_JEDEC_C",        CISTPL_JEDEC_C,
    "CISTPL_JEDEC_A",        CISTPL_JEDEC_A,
    "CISTPL_CONFIG",         CISTPL_CONFIG,
    "CISTPL_CFTABLE_ENTRY",  CISTPL_CFTABLE_ENTRY,
    "CISTPL_DEVICE_OC",      CISTPL_DEVICE_OC,
    "CISTPL_DEVICE_OA",      CISTPL_DEVICE_OA,
    "CISTPL_GEODEVICE",      CISTPL_GEODEVICE,
    "CISTPL_GEODEVICE_A",    CISTPL_GEODEVICE_A,
    "CISTPL_MANFID",         CISTPL_MANFID,
    "CISTPL_FUNCID",         CISTPL_FUNCID,
    "CISTPL_FUNCE",          CISTPL_FUNCE,
    "CISTPL_VERS_2",         CISTPL_VERS_2,
    "CISTPL_FORMAT",         CISTPL_FORMAT,
    "CISTPL_GEOMETRY",       CISTPL_GEOMETRY,
    "CISTPL_BYTEORDER",      CISTPL_BYTEORDER,
    "CISTPL_DATE",           CISTPL_DATE,
    "CISTPL_BATTERY",        CISTPL_BATTERY,
    "CISTPL_ORG",            CISTPL_ORG,

    //
    // CISTPL_END must be the last one in the table.
    //

    "CISTPL_END",            CISTPL_END

};


//
// Procedures
//


NTSTATUS
ReadTuple(
            IN HANDLE Handle,
            IN LONG  SlotNumber,
            IN PUCHAR Buffer,
            IN LONG  BufferSize
            )

/*++

Routine Description:

     Perform the NT function to get the tuple data from the
     pcmcia support driver.

Arguments:

     Handle - an open handle to the driver.
     SlotNumber - The socket offset
     Buffer - return buffer for the data.
     BufferSize - the size of the return buffer area.

Return Value:

     The results of the NT call.

--*/

{
    NTSTATUS         status;
    IO_STATUS_BLOCK statusBlock;
    TUPLE_REQUEST    commandBlock;

    commandBlock.Socket = (USHORT) SlotNumber;

    status = NtDeviceIoControlFile(Handle,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &statusBlock,
                                             IOCTL_GET_TUPLE_DATA,
                                             &commandBlock,
                                             sizeof(commandBlock),
                                             Buffer,
                                             BufferSize);
    return status;
}


PUCHAR
FindTupleCodeName(
                      UCHAR TupleCode
                      )

/*++

Routine Description:

     Return an ascii string that describes the tuple code provided.

Arguments:

     TupleCode - what code to look up.

Return Value:

     A string pointer - always.

--*/

{
    ULONG index;

    for (index = 0; CommandCodes[index].CommandCode != CISTPL_END; index++) {
        if (CommandCodes[index].CommandCode == TupleCode) {
            return CommandCodes[index].CommandName;
        }
    }

    return "Command Unknown";
}


PUCHAR DeviceTypeString[] = {
    "DTYPE_NULL",
    "DTYPE_ROM",
    "DTYPE_OTPROM",
    "DTYPE_EPROM",
    "DTYPE_EEPROM",
    "DTYPE_FLASH",
    "DTYPE_SRAM",
    "DTYPE_DRAM",
    "Reserved8",
    "Reserved9",
    "Reserveda",
    "Reservedb",
    "Reservedc",
    "DTYPE_FUNCSPEC",
    "DTYPE_EXTEND"
    "Reservedf",
};

PUCHAR DeviceSpeedString[] = {
    "DSPEED_NULL",
    "DSPEED_250NS",
    "DSPEED_200NS",
    "DSPEED_150NS",
    "DSPEED_100NS",
    "DSPEED_RES1",
    "DSPEED_RES2",
    "DSPEED_EXT"
};

VOID
DisplayDeviceTuple(
                        PUCHAR TupleBuffer,
                        UCHAR  TupleSize
                        )

/*++

Routine Description:

     Display the data at the given pointer as a CISTPL_DEVICE structure.

Arguments:

     TupleBuffer - the CISTPL_DEVICE to display.
     TupleSize   - the link value for the tuple.

Return Value:

     None

--*/

{
    UCHAR  mantissa = MANTISSA_RES1;
    UCHAR  exponent;
    UCHAR  deviceTypeCode;
    UCHAR  wps;
    UCHAR  deviceSpeed;
    UCHAR  temp;

    temp = *TupleBuffer;
    deviceTypeCode = DeviceTypeCode(temp);
    wps = DeviceWPS(temp);
    deviceSpeed = DeviceSpeedField(temp);

    temp = *(TupleBuffer + 1);

    if (deviceSpeed == DSPEED_EXT) {
        exponent = SpeedExponent(temp);
        mantissa = SpeedMantissa(temp);
    }

    printf("DeviceType: %s DeviceSpeed: ", DeviceTypeString[deviceTypeCode]);
    if (mantissa != MANTISSA_RES1) {
        printf("Mantissa %.2x, Exponent %.2x\n", mantissa, exponent);
    } else {
        printf("%s\n", DeviceSpeedString[deviceSpeed]);
    }
}


VOID
DisplayVers1(
                PUCHAR TupleBuffer,
                UCHAR  TupleSize,
                USHORT Crc
                )

/*++

Routine Description:

     Display the data as a Version tuple

Arguments:

     TupleBuffer - the CISTPL_DEVICE to display.
     TupleSize   - the link value for the tuple.

Return Value:

     None

--*/

{
    PUCHAR string;
    PUCHAR cp;

    //
    // Step around the MAJOR and MINOR codes of 4/1 at
    // the beginning of the tuple to get to the strings.
    //

    string = TupleBuffer;
    string++;
    string++;

    printf("Manufacturer:\t%s\n", string);
    while (*string++) {
    }

    printf("Product Name:\t%s\n", string);
    printf("CRC:         \t%.4x\n", Crc);
    while (*string++) {
    }

    printf("Product Info:\t");
    if (isprint(*string)) {
        printf("%s", string);
    } else {
        while (*string) {
            printf("%.2x ", *string);
            string++;
        }
    }
    printf("\n");
}


VOID
DisplayConfigTuple(
                        PUCHAR TupleBuffer,
                        UCHAR  TupleSize
                        )

/*++

Routine Description:

     Display the data at the given pointer as a CISTPL_CONFIG tuple.

Arguments:

     TupleBuffer - the CISTPL_DEVICE to display.
     TupleSize   - the link value for the tuple.

Return Value:

     None

--*/

{
    UCHAR  sizeField;
    UCHAR  tpccRfsz;
    UCHAR  tpccRmsz;
    UCHAR  tpccRasz;
    UCHAR  last;
    ULONG  baseAddress;
    PUCHAR ptr;

    sizeField = *TupleBuffer;
    last = *(TupleBuffer + 1);
    tpccRfsz = TpccRfsz(sizeField);
    tpccRmsz = TpccRmsz(sizeField);
    tpccRasz = TpccRasz(sizeField);

    printf("TPCC_SZ %.2x (%.2x/%.2x/%.2x) - Last %.2x\n",
             sizeField,
             tpccRasz,
             tpccRmsz,
             tpccRfsz,
             last);

    baseAddress = 0;
    ptr = TupleBuffer + 2;
    switch (tpccRasz) {
    case 3:
        baseAddress = *(ptr + 3) << 24;
    case 2:
        baseAddress |= *(ptr + 2) << 16;
    case 1:
        baseAddress |= *(ptr + 1) << 8;
    default:
        baseAddress |= *ptr;
    }
    printf("Base Address: %8x - ", baseAddress);
    ptr += tpccRasz + 1;

    baseAddress = 0;
    switch (tpccRmsz) {
    case 3:
        baseAddress = *(ptr + 3) << 24;
    case 2:
        baseAddress |= *(ptr + 2) << 16;
    case 1:
        baseAddress |= *(ptr + 1) << 8;
    default:
        baseAddress |= *ptr;
    }
    printf("Register Presence Mask: %8x\n", baseAddress);
}


PUCHAR
ProcessMemSpace(
                    PUCHAR Buffer,
                    UCHAR  MemSpace
                    )

/*++

Routine Description:

     Display and process memspace information

Arguments:

     Buffer - start of memspace information
     MemSpace - the memspace value from the feature byte.

Return Value:

     location of byte after all memory space information

--*/

{
    PUCHAR ptr = Buffer;
    UCHAR  item = *ptr++;
    UCHAR  lengthSize;
    UCHAR  addrSize;
    UCHAR  number;
    UCHAR  hasHostAddress;
    ULONG  cardAddress;
    ULONG  length;
    ULONG  hostAddress;

    if (MemSpace == 3) {

        lengthSize = (item & 0x18) >> 3;
        addrSize = (item & 0x60) >> 5;
        number = (item & 0x07) + 1;
        hasHostAddress = item & 0x80;
        printf("(0x%.2x) %s - %d entries - LengthSize %d - AddrSize %d\n",
                 item,
                 hasHostAddress ? "Host address" : "no host",
                 number,
                 lengthSize,
                 addrSize);
        while (number) {
            cardAddress = length = hostAddress = 0;
            switch (lengthSize) {
            case 3:
                length |= (*(ptr + 2)) << 16;
            case 2:
                length |= (*(ptr + 1)) << 8;
            case 1:
                length |= *ptr;
            }
            ptr += lengthSize;
            switch (addrSize) {
            case 3:
                cardAddress |= (*(ptr + 2)) << 16;
            case 2:
                cardAddress |= (*(ptr + 1)) << 8;
            case 1:
                cardAddress |= *ptr;
            }
            ptr += addrSize;
            if (hasHostAddress) {
                switch (addrSize) {
                case 3:
                    hostAddress |= (*(ptr + 2)) << 16;
                case 2:
                    hostAddress |= (*(ptr + 1)) << 8;
                case 1:
                    hostAddress |= *ptr;
                }
                printf("\tHost 0x%.8x ", hostAddress * 256);
                ptr += addrSize;
            } else {
                printf("\t");
            }
            printf("Card 0x%.8x Size 0x%.8x\n",
                     cardAddress * 256,
                     length * 256);
            number--;
        }
    }
    return ptr;
}

USHORT VoltageConversionTable[16] = {
    10, 12, 13, 14, 20, 25, 30, 35,
    40, 45, 50, 55, 60, 70, 80, 90
};

UCHAR
ConvertVoltage(
                  UCHAR MantissaExponentByte,
                  UCHAR ExtensionByte
                  )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    USHORT power;
    USHORT value;

    value = VoltageConversionTable[(MantissaExponentByte >> 3) & 0x0f];
    power = 1;

    if ((MantissaExponentByte & EXTENSION_BYTE_FOLLOWS) &&
         (ExtensionByte < 100)) {
        value = (100 * value + (ExtensionByte & 0x7f));
        power += 2;
    }

    power = (MantissaExponentByte & 0x07) - 4 - power;

    while (power > 0) {
        value *= 10;
        power--;
    }

    while (power < 0) {
        value /= 10;
        power++;
    }

    return (UCHAR) value;
}

PUCHAR PowerTypeTable[] = {
    "Nominal",
    "Minimum",
    "Maximum",
    "Static",
    "Average",
    "Peak",
    "PwrDown"
};

PUCHAR VoltagePinTable[] = {
    "Vcc",
    "Vpp1",
    "Vpp2"
};

PUCHAR
ProcessPower(
                PUCHAR Buffer,
                UCHAR  FeatureByte
                )

/*++

Routine Description:

     Display and process power information

Arguments:

     Power - start of power information

Return Value:

     location of byte after all power information

--*/

{
    UCHAR  powerSelect;
    UCHAR  bit;
    UCHAR  item;
    UCHAR  entries;
    PUCHAR ptr = Buffer;
    UCHAR  count = FeatureByte;

    powerSelect = *ptr;
    printf("Parameter Selection Byte = 0x%.2x\n", powerSelect);

    entries = 0;
    while (entries < count) {
        powerSelect = *ptr++;
        printf("\t%s \"%d%d%d%d%d%d%d%d\"\n",
                 VoltagePinTable[entries],
                 powerSelect & 0x80 ? 1 : 0,
                 powerSelect & 0x40 ? 1 : 0,
                 powerSelect & 0x20 ? 1 : 0,
                 powerSelect & 0x10 ? 1 : 0,
                 powerSelect & 0x08 ? 1 : 0,
                 powerSelect & 0x04 ? 1 : 0,
                 powerSelect & 0x02 ? 1 : 0,
                 powerSelect & 0x01 ? 1 : 0);
        for (bit = 0; bit < 7; bit++) {
            if (powerSelect & (1 << bit)) {

                if (!bit) {

                    //
                    // Convert nominal power for output.
                    //

                    item = ConvertVoltage(*ptr,
                                                 (UCHAR) (*ptr & EXTENSION_BYTE_FOLLOWS ?
                                                             *(ptr + 1) :
                                                             (UCHAR) 0));
                }
                printf("\t\t%s power =\t%d/10 volts\n", PowerTypeTable[bit], item);
                while (*ptr++ & EXTENSION_BYTE_FOLLOWS) {
                }
            }
        }
        entries++;
    }
    return ptr;
}

PUCHAR
ProcessTiming(
                 PUCHAR Buffer
                 )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PUCHAR ptr = Buffer;
    UCHAR  item = *ptr++;
    UCHAR  reservedScale = (item & 0xe0) >> 5;
    UCHAR  readyBusyScale = (item & 0x1c) >> 2;
    UCHAR  waitScale = (item & 0x03);

    printf("Timing (0x%.2x): reservedScale 0x%.2x, readyBusyScale 0x%.2x, waitScale 0x%.2x\n",
             item,
             reservedScale,
             readyBusyScale,
             waitScale);

    if (waitScale != 3) {
        printf("\tWaitSpeed 0x%.2x\n", *ptr);
        ptr++;
        while (*ptr & EXTENSION_BYTE_FOLLOWS) {
            ptr++;
        }
    }

    if (readyBusyScale != 7) {
        printf("\tReadyBusySpeed 0x%.2x\n", *ptr);
        ptr++;
        while (*ptr & EXTENSION_BYTE_FOLLOWS) {
            ptr++;
        }
    }

    if (reservedScale != 7) {
        printf("\tReservedSpeed 0x%.2x\n", *ptr);
        ptr++;
        while (*ptr & EXTENSION_BYTE_FOLLOWS) {
            ptr++;
        }
    }
    return ptr;
}

PUCHAR
ProcessIoSpace(
                  PUCHAR Buffer
                  )

/*++

Routine Description:

     Display and process iospace information

Arguments:

     Buffer - start of IoSpace information

Return Value:

     location of byte after all power information

--*/

{
    UCHAR  item;
    UCHAR  ioAddrLines;
    UCHAR  bus8;
    UCHAR  bus16;
    UCHAR  ranges;
    UCHAR  lengthSize;
    UCHAR  addressSize;
    ULONG  address;
    PUCHAR ptr = Buffer;

    item = *ptr++;
    ioAddrLines = item & IO_ADDRESS_LINES_MASK;
    bus8 = Is8BitAccess(item);
    bus16 = Is16BitAccess(item);
    ranges = HasRanges(item);

    printf("IoSpace (%.2x): IoAddressLines %.2d - %s/%s\n",
             item,
             ioAddrLines,
             bus8 ? "8bit" : "",
             bus16 ? "16bit" : "");

    //
    // This is what it looks like the IBM token ring card
    // does.  It is unclear in the specification if this
    // is correct or not.
    //

    if ((!ranges) && (!ioAddrLines)) {
        ranges = 0xFF;
    }

    if (ranges) {

        if (ranges == 0xff) {

            //
            // This is based on the tuple data as given by
            // the IBM token ring card.  This is not the
            // way I would interpret the specification.
            //

            addressSize = 2;
            lengthSize = 1;
            ranges = 1;
        } else {
            item = *ptr++;
            ranges = item & 0x0f;
            ranges++;
            addressSize = GetAddressSize(item);
            lengthSize = GetLengthSize(item);
        }

        while (ranges) {
            address = 0;
            switch (addressSize) {
            case 4:
                address |= (*(ptr + 3)) << 24;
            case 3:
                address |= (*(ptr + 2)) << 16;
            case 2:
                address |= (*(ptr + 1)) << 8;
            case 1:
                address |= *ptr;
            }
            ptr += addressSize;
            printf("\tStart %.8x - Length ", address);

            address = 0;
            switch (lengthSize) {
            case 4:
                address |= (*(ptr + 3)) << 24;
            case 3:
                address |= (*(ptr + 2)) << 16;
            case 2:
                address |= (*(ptr + 1)) << 8;
            case 1:
                address |= *ptr;
            }
            ptr += lengthSize;
            printf("%.8x\n", address);

            ranges--;
        }
    } else {
        printf("\tResponds to all ranges.\n");
    }
    return ptr;
}
PUCHAR
ProcessIrq(
             PUCHAR Buffer
             )

/*++

Routine Description:

     Display and process irq information

Arguments:

     Buffer - start of irq information

Return Value:

     location of byte after all irq information

--*/

{
    PUCHAR ptr = Buffer;
    UCHAR  level;
    USHORT mask;
    ULONG  irqNumber;

    level = *ptr++;
    if (!level) {

        //
        // NOTE: It looks like Future Domain messed up on this
        // and puts an extra zero byte into the structure.
        // skip it for now.
        //

        level = *ptr++;
    }
    if (level & 0x80) {
        printf("Share ");
    }
    if (level & 0x40) {
        printf("Pulse ");
    }
    if (level & 0x20) {
        printf("Level ");
    }
    if (level & 0x10) {
        mask = *ptr | (*(ptr + 1) << 8);
        ptr += 2;
        printf("mask = %.4x - ", mask);
        for (irqNumber = 0; mask; irqNumber++, mask = mask >> 1) {
            if (mask & 0x0001) {
                printf("IRQ%d ", irqNumber);
            }
        }
        printf("- ");

        if (level & 0x08) {
            printf("Vend ");
        }
        if (level & 0x04) {
            printf("Berr ");
        }
        if (level & 0x02) {
            printf("IOCK ");
        }
        if (level & 0x01) {
            printf("NMI");
        }
        printf("\n");
    } else {
        printf("irq = %d\n", level & 0x0f);
    }

    return ptr;
}


PUCHAR InterfaceTypeStrings[] = {
    "Memory",
    "I/O",
    "Reserved 2",
    "Reserved 3",
    "Custom 0",
    "Custom 1",
    "Custom 2",
    "Custom 3",
    "Reserved 8",
    "Reserved 9",
    "Reserved a",
    "Reserved b",
    "Reserved c",
    "Reserved d",
    "Reserved e",
    "Reserved f",
};

VOID
DisplayCftableEntryTuple(
                                PUCHAR TupleBuffer,
                                UCHAR  TupleSize
                                )

/*++

Routine Description:

     Display the data at the given pointer as a CISTPL_CFTABLE_ENTRY tuple.

Arguments:

     TupleBuffer - the CISTPL_DEVICE to display.
     TupleSize   - the link value for the tuple.

Return Value:

     None

--*/

{
    UCHAR  temp;
    UCHAR  item;
    UCHAR  defaultbit;
    UCHAR  memSpace;
    UCHAR  power;
    PUCHAR ptr;

    temp = *TupleBuffer;
    item = IntFace(temp);
    defaultbit = Default(temp);
    temp = ConfigEntryNumber(temp);

    printf("ConfigurationEntryNumber %.2x (%s/%s)\n",
             temp,
             item ? "intface" : "",
             defaultbit ? "default" : "");

    ptr = TupleBuffer + 1;
    if (item) {
        temp = *ptr++;
        item = temp & 0x0F;
        printf("InterfaceDescription (%.2x) %s (%s/%s/%s/%s)\n",
                 temp,
                 InterfaceTypeStrings[item],
                 temp & 0x80 ? "WaitReq" : "",
                 temp & 0x40 ? "RdyBsy" : "",
                 temp & 0x20 ? "WP" : "",
                 temp & 0x10 ? "BVD" : "");
    }
    item = *ptr++;

    memSpace = MemSpaceInformation(item);
    power = PowerInformation(item);
    printf("The following structures are present:\n");
    switch (power) {
    case 3:
        printf("Vcc, Vpp1, Vpp2; ");
        break;
    case 2:
        printf("Vcc and Vpp; ");
        break;
    case 1:
        printf("Vcc; ");
        break;
    case 0:
        break;
    }
    if (power) {
        ptr = ProcessPower(ptr, power);
    }
    if (TimingInformation(item)) {
        ptr = ProcessTiming(ptr);
    }
    if (IoSpaceInformation(item)) {
        ptr = ProcessIoSpace(ptr);
    }
    if (IRQInformation(item)) {
        printf("IRQ: ");
        ptr = ProcessIrq(ptr);
    }
    switch (memSpace) {
    case 3:
        printf("Memory selection: ");
        break;
    case 2:
        printf("Length and Card Address: ");
        break;
    case 1:
        printf("2-byte length: ");
        break;
    case 0:
        break;
    }
    if (memSpace) {
        ptr = ProcessMemSpace(ptr, memSpace);
    }

    if (MiscInformation(item)) {
        printf("Misc fields present");
    }
    printf("\n");
}


UCHAR TplList[] = {
    CISTPL_DEVICE,
    CISTPL_VERS_1,
    CISTPL_CONFIG,
    CISTPL_CFTABLE_ENTRY,
    CISTPL_MANFID,
    CISTPL_END
};

static unsigned short crc16a[] = {
    0000000,  0140301,  0140601,    0000500,
    0141401,  0001700,  0001200,    0141101,
    0143001,  0003300,  0003600,    0143501,
    0002400,  0142701,  0142201,    0002100,
};
static unsigned short crc16b[] = {
    0000000,  0146001,  0154001,    0012000,
    0170001,  0036000,  0024000,    0162001,
    0120001,  0066000,  0074000,    0132001,
    0050000,  0116001,  0104001,    0043000,
};
USHORT
GetCRC(
        PUCHAR TupleBuffer
        )

/*++

Routine Description:

     Using the same algorithm as Windows 95, calculate the CRC value
     to be appended with the manufacturer name and device name to
     obtain the unique identifier for the PCCARD.

Arguments:

     TupleBuffer - the tuple data

Return Value:

     A USHORT CRC value.

--*/

{
    USHORT  crc = 0;
    USHORT  index;
    USHORT  length;
    PUCHAR  tupleData;
    PUCHAR  cp;
    PUCHAR  tplBuffer;
    UCHAR   tupleCode;
    UCHAR   linkValue;
    UCHAR   tmp;

    //
    // Calculate CRC
    //

    tplBuffer = TupleBuffer;
    printf("Calculating CRC ");
    while (1) {
        tupleData = tplBuffer + 2;
        tupleCode = *tplBuffer++;

        if (tupleCode == CISTPL_END) {
            break;
        }

        linkValue = (tupleCode) ? *tplBuffer++ : 0;
        length = linkValue;

        printf("%x", tupleCode);
        for (index = 0; TplList[index] != CISTPL_END; index++) {

            if (tupleCode == TplList[index]) {


                //
                // This one is included in the CRC calculation
                //

                printf("*", tupleCode);
                if (tupleCode == CISTPL_VERS_1) {
                    cp = tupleData + 2;

                    //
                    // Include all of the manufacturer name.
                    //

                    while (*cp) {
                        cp++;
                    }

                    //
                    // Include the product string
                    //

                    cp++;
                    while (*cp) {
                        cp++;
                    }
                    cp++;

                    length = (USHORT)(cp - tupleData);
                }

                for (cp = tupleData; length; length--, cp++) {

                    tmp = *cp ^ (UCHAR)crc;
                    crc = (crc >> 8) ^ crc16a[tmp & 0x0f] ^ crc16b[tmp >> 4];
                }
                break;
            }
        }
        printf(" ");
        tplBuffer = tplBuffer + linkValue;
    }
    printf("++\n");
    return crc;
}


VOID
DumpTuple(
            PUCHAR Buffer
            )

/*++

Routine Description:

     Control routine to process the tuple data.

Arguments:

     Buffer - the tuple data.

Return Value:

     None

--*/

{
    PUCHAR tupleBuffer = Buffer;
    PUCHAR tupleCodeName;
    USHORT crc;
    UCHAR  index;
    UCHAR  tupleCode;
    UCHAR  linkValue;

    crc = GetCRC(tupleBuffer);
    while (1) {
        tupleCode = *tupleBuffer++;
        linkValue = (tupleCode) ? *tupleBuffer : 0;

        if (tupleCode == CISTPL_END) {
            break;
        }

        tupleCodeName = FindTupleCodeName(tupleCode);

        printf("Tuple Code\t%s\t%.2x - Link %.2x:", tupleCodeName, tupleCode, linkValue);

        if (linkValue) {
            for (index = 0; index < linkValue; index++) {
                if ((index & 0x0F) == 0) {
                    printf("\n");
                }
                printf(" %.2x", *(tupleBuffer + index + 1));
            }
        }
        printf("\n");

        tupleBuffer++;
        switch (tupleCode) {
        case CISTPL_DEVICE:
            DisplayDeviceTuple(tupleBuffer, linkValue);
            break;
        case CISTPL_VERS_1:
            DisplayVers1(tupleBuffer, linkValue, crc);
            break;
        case CISTPL_CONFIG:
            DisplayConfigTuple(tupleBuffer, linkValue);
            break;
        case CISTPL_CFTABLE_ENTRY:
            DisplayCftableEntryTuple(tupleBuffer, linkValue);
            break;
        case CISTPL_LONGLINK_MFC:
        case CISTPL_LONGLINK_A:
        case CISTPL_LONGLINK_C:
        case CISTPL_LINKTARGET:
        case CISTPL_NO_LINK:
        default:
            break;
        }

        tupleBuffer = tupleBuffer + linkValue;
        printf("\n");
    }
}



VOID
DumpCIS(
    IN PHOST_INFO hostInfo
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS status;
    PUCHAR  currentBufferPointer;
    UCHAR   hexBuffer[260];
    UCHAR   ascii[100];
    ULONG    i;
    UCHAR   c;
    PUCHAR buffer;
    HANDLE  handle;
    
    handle = GetHandleForIoctl(hostInfo);

    if (handle == INVALID_HANDLE_VALUE) {
        return;
    }

    buffer = malloc(BUFFER_SIZE);
    if (!buffer) {
        printf("Unable to malloc\n");
        NtClose(handle);
        return;
    }
    
    memset(buffer, 0, BUFFER_SIZE);
    
    status = ReadTuple(handle, hostInfo->SocketNumber, buffer, BUFFER_SIZE);

    //
    // Don't bother dumping tuples for cards that aren't there.
    //

    if (!NT_SUCCESS(status)) {
        NtClose(handle);
        return;
    }

    printf("\nCIS Tuples for Socket Number %d:\n\n", hostInfo->SocketNumber);

    hexBuffer[0] = '\0';
    ascii[0] = '\0';
    currentBufferPointer = buffer;
    for (i = 0; i < 512; i++) {
        c = *currentBufferPointer;
        sprintf(hexBuffer, "%s %.2x", hexBuffer, c);
        c = isprint(c) ? c : '.';
        sprintf(ascii, "%s%c", ascii, c);
        currentBufferPointer++;

        //
        // Display the line every 16 bytes.
        //

        if ((i & 0x0f) == 0x0f) {
            printf("%s", hexBuffer);
            printf(" *%s*\n", ascii);
            hexBuffer[0] = '\0';
            ascii[0] = '\0';
        }
    }
    printf("%s", hexBuffer);
    printf("\t\t*%s*\n\n", ascii);
    DumpTuple(buffer);

    NtClose(handle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\inc\pdhidef.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    pdhidef.h

Abstract:

    function definitions used internally by the performance data helper
    functions

--*/

#ifndef _PDHI_DEFS_H_
#define _PDHI_DEFS_H_

#pragma warning ( disable : 4115 )

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _DEBUG_MUTEXES
#define _DEBUG_MUTEXES 0    // for debugging
#endif


#include <locale.h>
#include "pdhitype.h"

#if DBG
VOID
__cdecl
PdhDebugPrint(
    ULONG   DebugPrintLevel,
    char  * DebugMessage,
    ...
);

#define DebugPrint(x)   PdhDebugPrint x
#else
#define DebugPrint(x)
#endif

#define STATIC_PDH_FUNCTION PDH_STATUS __stdcall
#define STATIC_BOOL         BOOL __stdcall
#define STATIC_DWORD        DWORD __stdcall
#define PDH_PLA_MUTEX       L"__PDH_PLA_MUTEX__"

// global variable declarations
extern HANDLE   ThisDLLHandle;
extern WCHAR    szStaticLocalMachineName[];
extern HANDLE   hPdhDataMutex;
extern HANDLE   hPdhContextMutex;
extern HANDLE   hPdhPlaMutex;
extern HANDLE   hPdhHeap;
extern HANDLE   hEventLog;

extern LONGLONG  llRemoteRetryTime;
extern BOOL      bEnableRemotePdhAccess;
extern DWORD     dwPdhiLocalDefaultDataSource;
extern LONG      dwCurrentRealTimeDataSource;
extern ULONGLONG ulPdhCollectTimeout;
extern BOOL      bProcessIsDetaching;

//    (assumes dword is 4 bytes)
#define ALIGN_ON_DWORD(x) ((VOID *) (((DWORD_PTR) (x) & 3) ? (((DWORD_PTR) (x) & ~3) + 4 ) : ((DWORD_PTR)(x))))
#define DWORD_MULTIPLE(x) ((((x) + sizeof(DWORD) - 1) / sizeof(DWORD)) * sizeof(DWORD))
#define CLEAR_FIRST_FOUR_BYTES(x)  * (DWORD *)(x) = 0L

//    (assumes QuadWORD is 8 bytes)
#define ALIGN_ON_QWORD(x) ((VOID *)(((DWORD_PTR)(x) & 7) ? (((DWORD_PTR)(x) & ~7) + 8) : ((DWORD_PTR)(x))))
#define QWORD_MULTIPLE(x) ((((x) + sizeof(LONGLONG) - 1) / sizeof(LONGLONG)) * sizeof(LONGLONG))
#define CLEAR_FIRST_EIGHT_BYTES(x) * (LONGLONG *)(x) = 0L

#if _DEBUG_MUTEXES
__inline
DWORD
PdhiLocalWaitForMutex(
    LPCSTR  szSourceFileName,
    DWORD   dwLineNo,
    HANDLE  hMutex
)
{
    DWORD   dwReturnValue = PDH_INVALID_PARAMETER;
    if (hMutex != NULL) {
        FILETIME    ft;
        GetSystemTimeAsFileTime(& ft);
        dwReturnValue = WaitForSingleObject(hMutex, 60000);
        DebugPrint((4, "\n[%8.8x] Mutex [%8.8x] %s by (%d) at: %s (%d)",
                        ft.dwLowDateTime,
                        (DWORD) hMutex,
                        (dwReturnValue == 0 ? "Locked" : "Lock Failed"),
                        GetCurrentThreadId(),
                        szSourceFileName,
                        dwLineNo));
    }
    else {
        DebugPrint((4, "\nLock of NULL Mutex attmpted at: %s (%d)", szSourceFileName, dwLineNo));
        dwReturnValue = PDH_INVALID_PARAMETER;
    }
    return dwReturnValue;
}

#define WAIT_FOR_AND_LOCK_MUTEX(h) PdhiLocalWaitForMutex (__FILE__, __LINE__, h);

__inline
void
PdhiLocalReleaseMutex(
    LPCSTR  szSourceFileName,
    DWORD   dwLineNo,
    HANDLE  hMutex
)
{
    BOOL      bSuccess;
    LONG      lPrevCount = 0;
    FILETIME  ft;

    if (hMutex != NULL) {
        GetSystemTimeAsFileTime(& ft);
        bSuccess = ReleaseMutex(hMutex);
        DebugPrint((4, "\n[%8.8x] Mutex [%8.8x] %s by (%d) at: %s (%d)",
                        ft.dwLowDateTime,
                        (DWORD) hMutex,
                        (bSuccess ? "Released" : "Release Failed"),
                        GetCurrentThreadId(),
                        szSourceFileName,
                        dwLineNo));
    }
    else {
        DebugPrint((4, "\nRelease of NULL Mutex attempted at: %s (%d)", szSourceFileName, dwLineNo));
    }
}

#define RELEASE_MUTEX(h)  PdhiLocalReleaseMutex (__FILE__, __LINE__, h);
#else
#define WAIT_FOR_AND_LOCK_MUTEX(h) (h != NULL ? WaitForSingleObject(h, 60000) : WAIT_TIMEOUT)
#define RELEASE_MUTEX(h)  (h != NULL ? ReleaseMutex(h) : FALSE)
#endif

#define LODWORD(ll) ((DWORD)((LONGLONG)ll & 0x00000000FFFFFFFF))
#define HIDWORD(ll) ((DWORD)(((LONGLONG)ll >> 32) & 0x00000000FFFFFFFF))
#define MAKELONGLONG(low, high) \
        ((LONGLONG) (((DWORD) (low)) | ((LONGLONG) ((DWORD) (high))) << 32))

#define MAX_BTREE_DEPTH        40
#define PDH_SQL_STRING_SIZE  1024
#define SMALL_BUFFER_SIZE    4096
#define MEDIUM_BUFFER_SIZE  16384
#define LARGE_BUFFER_SIZE   65536

// set this to 1 to report code errors (i.e. debugging information)
// to the event log.
#define PDHI_REPORT_CODE_ERRORS 0

// set this to 1 to report user errors (i.e. things the normal user
// would care about) to the event log.
#define PDHI_REPORT_USER_ERRORS 1

// USER category errors are typically configuration, schema or access
// access errors, errors the user can usually do something about
#define PDH_EVENT_CATEGORY_USER     100

// COUNTER category errors are errors returned do to valid data returning
// invalid results. These are a special subset of USER Category errors.
#define PDH_EVENT_CATEGORY_COUNTER  110

// DEBUG category errors are of interest only to PDH developers as they
// indicate problems that can normally only be fixed by modifying the
// program code.
#define PDH_EVENT_CATEGORY_DEBUG    200

#define REPORT_EVENT(t,c,id)    ReportEvent (hEventLog, t, c, id, NULL, 0, 0, NULL, NULL)

__inline
BOOL
CounterIsOkToUse(void * pCounterArg)
{
    BOOL          bReturn  = FALSE;
    PPDHI_COUNTER pCounter = (PPDHI_COUNTER) pCounterArg;
    if (pCounter != NULL) {
        if (! (pCounter->dwFlags & PDHIC_COUNTER_UNUSABLE)) {
            bReturn = TRUE;
        }
    }
    return bReturn;
}

DWORD
DataSourceTypeH(
    PDH_HLOG hDataSource
);

DWORD
DataSourceTypeW(
    LPCWSTR szDataSource
);

DWORD
DataSourceTypeA(
    LPCSTR szDataSource
);

LPWSTR
GetStringResource(
    DWORD   dwResId
);
//
//  Log file entries
//
extern LPCSTR       szTsvLogFileHeader;
extern LPCSTR       szCsvLogFileHeader;
extern LPCSTR       szBinLogFileHeader;
extern LPCSTR       szTsvType;
extern LPCSTR       szCsvType;
extern LPCSTR       szBinaryType;
extern const DWORD  dwFileHeaderLength;
extern const DWORD  dwTypeLoc;
extern const DWORD  dwVersionLoc;
extern const DWORD  dwFieldLength;

DWORD
UnmapReadonlyMappedFile(
    LPVOID   pMemoryBase,
    BOOL   * bNeedToCloseHandles
);

PDH_FUNCTION
PdhiGetLogCounterInfo(
    PDH_HLOG      hLog,
    PPDHI_COUNTER pCounter
);

PDH_FUNCTION
PdhiEnumLoggedMachines(
    PDH_HLOG hDataSource,
    LPVOID   mszMachineList,
    LPDWORD  pcchBufferSize,
    BOOL     bUnicode
);

PDH_FUNCTION
PdhiEnumLoggedObjects(
    PDH_HLOG hDataSource,
    LPCWSTR  szMachineName,
    LPVOID   mszObjectList,
    LPDWORD  pcchBufferSize,
    DWORD    dwDetailLevel,
    BOOL     bRefresh,
    BOOL     bUnicode
);

PDH_FUNCTION
PdhiEnumLoggedObjectItems(
    PDH_HLOG hDataSource,
    LPCWSTR  szMachineName,
    LPCWSTR  szObjectName,
    LPVOID   mszCounterList,
    LPDWORD  pdwCounterListLength,
    LPVOID   mszInstanceList,
    LPDWORD  pdwInstanceListLength,
    DWORD    dwDetailLevel,
    DWORD    dwFlags,
    BOOL     bUnicode
);

BOOL
PdhiDataSourceHasDetailLevelsH(
    PDH_HLOG hDataSource
);

BOOL
PdhiDataSourceHasDetailLevels(
    LPWSTR  szDataSource
);

PDH_FUNCTION
PdhiGetMatchingLogRecord(
    PDH_HLOG   hLog,
    LONGLONG * pStartTime,
    LPDWORD    pdwIndex
);

PDH_FUNCTION
PdhiGetCounterValueFromLogFile(
    PDH_HLOG       hLog,
    DWORD          dwIndex,
    PDHI_COUNTER * pCounter
);

STATIC_PDH_FUNCTION
PdhiGetCounterInfo(
    HCOUNTER             hCounter,
    BOOLEAN              bRetrieveExplainText,
    LPDWORD              pdwBufferSize,
    PPDH_COUNTER_INFO_W  lpBuffer,
    BOOL                 bUnicode
);

// log.c
BOOL
PdhiCloseAllLoggers();

ULONG HashCounter(
    LPWSTR szCounterName
);

void
PdhiInitCounterHashTable(
    PDHI_COUNTER_TABLE pTable
);

void
PdhiResetInstanceCount(
    PDHI_COUNTER_TABLE pTable
);

PDH_FUNCTION
PdhiFindCounterInstList(
    PDHI_COUNTER_TABLE pHeadList,
    LPWSTR             szCounter,
    PPDHI_INST_LIST  * pInstList
);

PDH_FUNCTION
PdhiFindInstance(
    PLIST_ENTRY      pHeadInst,
    LPWSTR           szInstance,
    BOOLEAN          bUpdateCount,
    PPDHI_INSTANCE * pInstance
);

DWORD
AddStringToMultiSz(
    LPVOID  mszDest,
    LPWSTR  szSource,
    BOOL    bUnicodeDest
);

// query.c
PDH_FUNCTION
PdhiCollectQueryData(
    PPDHI_QUERY pQuery,
    LONGLONG    *pllTimeStamp
);

BOOL
PdhiQueryCleanup(
);

PDH_FUNCTION
PdhiConvertUnicodeToAnsi(
    UINT     uCodePage,
    LPWSTR   wszSrc,
    LPSTR    aszDest,
    LPDWORD  pdwSize
);

// qutils.c

DWORD
WINAPI
PdhiAsyncTimerThreadProc(
    LPVOID  pArg
);

BOOL
IsValidQuery(
    HQUERY  hQuery
);

BOOL
IsValidCounter(
    HCOUNTER  hCounter
);

BOOL
InitCounter(
    PPDHI_COUNTER pCounter
);

BOOL
ParseFullPathNameW(
    LPCWSTR szFullCounterPath,
    PDWORD  pdwBufferLength,
    PPDHI_COUNTER_PATH  pCounter,
    BOOL    bWbemSyntax
);

BOOL
ParseInstanceName(
    LPCWSTR szInstanceString,
    LPWSTR  szInstanceName,
    LPWSTR  szParentName,
    DWORD   dwName,
    LPDWORD lpIndex
);

BOOL
FreeCounter(
    PPDHI_COUNTER   pThisCounter
);

BOOL
InitPerflibCounterInfo(
    PPDHI_COUNTER   pCounter
);

BOOL
AddMachineToQueryLists(
    PPERF_MACHINE   pMachine,
    PPDHI_COUNTER   pNewCounter
);

BOOL
UpdateRealTimeCounterValue(
    PPDHI_COUNTER   pCounter
);

BOOL
UpdateRealTimeMultiInstanceCounterValue(
    PPDHI_COUNTER   pCounter
);

BOOL
UpdateCounterValue(
    PPDHI_COUNTER    pCounter,
    PPERF_DATA_BLOCK pPerfData
);

BOOL
UpdateMultiInstanceCounterValue(
    PPDHI_COUNTER    pCounter,
    PPERF_DATA_BLOCK pPerfData,
    LONGLONG         TimeStamp
);

BOOL
UpdateCounterObject(
    PPDHI_COUNTER pCounter
);

#define GPCDP_GET_BASE_DATA 0x00000001
PVOID
GetPerfCounterDataPtr(
    PPERF_DATA_BLOCK    pPerfData,
    PPDHI_COUNTER_PATH  pPath,
    PPERFLIB_COUNTER    pplCtr,
    DWORD               dwFlags,
    PPERF_OBJECT_TYPE   *pPerfObject,
    PDWORD              pStatus
);

LONG
GetQueryPerfData(
    PPDHI_QUERY   pQuery,
    LONGLONG    * pTimeStamp
);

BOOL
GetInstanceByNameMatch(
    PPERF_MACHINE   pMachine,
    PPDHI_COUNTER   pCounter
);

PDH_FUNCTION
PdhiResetLogBuffers(
    PDH_HLOG  hLog
);

PDH_FUNCTION
AddUniqueWideStringToMultiSz(
    LPVOID  mszDest,
    LPWSTR  szSource,
    DWORD   dwSizeLeft,
    LPDWORD pdwSize,
    BOOL    bUnicodeDest
);

BOOL
PdhiBrowseDataSource(
    HWND    hWndParent,
    LPVOID  szFileName,
    LPDWORD pcchFileNameSize,
    BOOL    bUnicodeString
);

LPWSTR
PdhiGetExplainText(
    LPCWSTR szMachineName,
    LPCWSTR szObjectName,
    LPCWSTR szCounterName
);

LONG
GetCurrentServiceState(
    SC_HANDLE   hService,
    BOOL      * bStopped,
    BOOL      * bPaused
);

// wbem.cpp

BOOL
IsWbemDataSource(
    LPCWSTR  szDataSource
);

PDH_FUNCTION
PdhiFreeAllWbemServers(
);

PDH_FUNCTION
PdhiGetWbemExplainText(
    LPCWSTR  szMachineName,
    LPCWSTR  szObjectName,
    LPCWSTR  szCounterName,
    LPWSTR   szExplain,
    LPDWORD  pdwExplain
);

PDH_FUNCTION
PdhiEnumWbemMachines(
    LPVOID   pMachineList,
    LPDWORD  pcchBufferSize,
    BOOL     bUnicode
);

PDH_FUNCTION
PdhiEnumWbemObjects(
    LPCWSTR szWideMachineName,
    LPVOID  mszObjectList,
    LPDWORD pcchBufferSize,
    DWORD   dwDetailLevel,
    BOOL    bRefresh,
    BOOL    bUnicode
);

PDH_FUNCTION
PdhiGetDefaultWbemObject(
    LPCWSTR szMachineName,
    LPVOID  szDefaultObjectName,
    LPDWORD pcchBufferSize,
    BOOL    bUnicode
);

PDH_FUNCTION
PdhiEnumWbemObjectItems(
    LPCWSTR  szWideMachineName,
    LPCWSTR  szWideObjectName,
    LPVOID   mszCounterList,
    LPDWORD  pcchCounterListLength,
    LPVOID   mszInstanceList,
    LPDWORD  pcchInstanceListLength,
    DWORD    dwDetailLevel,
    DWORD    dwFlags,
    BOOL     bUnicode
);

PDH_FUNCTION
PdhiGetDefaultWbemProperty(
    LPCWSTR  szMachineName,
    LPCWSTR  szObjectName,
    LPVOID   szDefaultCounterName,
    LPDWORD  pcchBufferSize,
    BOOL     bUnicode
);

PDH_FUNCTION
PdhiEncodeWbemPathW(
    PPDH_COUNTER_PATH_ELEMENTS_W pCounterPathElements,
    LPWSTR                       szFullPathBuffer,
    LPDWORD                      pcchBufferSize,
    LANGID                       LangId,
    DWORD                        dwFlags
);

PDH_FUNCTION
PdhiDecodeWbemPathA(
    LPCSTR                       szFullPathBuffer,
    PPDH_COUNTER_PATH_ELEMENTS_A pCounterPathElements,
    LPDWORD                       pcchBufferSize,
    LANGID                        LangId,
    DWORD                         dwFlags
);

PDH_FUNCTION
PdhiDecodeWbemPathW(
    LPCWSTR                      szFullPathBuffer,
    PPDH_COUNTER_PATH_ELEMENTS_W pCounterPathElements,
    LPDWORD                      pcchBufferSize,
    LANGID                       LangId,
    DWORD                        dwFlags
);

PDH_FUNCTION
PdhiEncodeWbemPathA(
    PPDH_COUNTER_PATH_ELEMENTS_A pCounterPathElements,
    LPSTR                        szFullPathBuffer,
    LPDWORD                      pcchBufferSize,
    LANGID                       LangId,
    DWORD                        dwFlags
);

BOOL
WbemInitCounter(
    PPDHI_COUNTER pCounter
);

LONG
GetQueryWbemData(
    PPDHI_QUERY   pQuery,
    LONGLONG    * pllTimeStamp
);

PDH_FUNCTION
PdhiCloseWbemCounter(
    PPDHI_COUNTER pCounter
);

PDH_FUNCTION
PdhiFreeWbemQuery(
    PPDHI_QUERY  pThisQuery
);

// routinues for cached machine/Object/Counter/Instance structure for counter logs.
int
PdhiCompareLogCounterInstance(
    PPDHI_LOG_COUNTER   pCounter,
    LPWSTR              szCounter,
    LPWSTR              szInstance,
    DWORD               dwInstance,
    LPWSTR              szParent
);

void
PdhiFreeLogMachineTable(
    PPDHI_LOG_MACHINE * MachineTable
);

PPDHI_LOG_MACHINE
PdhiFindLogMachine(
    PPDHI_LOG_MACHINE * MachineTable,
    LPWSTR              szMachine,
    BOOL                bInsert
);

PPDHI_LOG_OBJECT
PdhiFindLogObject(
    PPDHI_LOG_MACHINE   pMachine,
    PPDHI_LOG_OBJECT  * ObjectTable,
    LPWSTR              szObject,
    BOOL                bInsert
);

PPDHI_LOG_COUNTER
PdhiFindLogCounter(
    PPDHI_LOG           pLog,
    PPDHI_LOG_MACHINE * MachineTable,
    LPWSTR              szMachine,
    LPWSTR              szObject,
    LPWSTR              szCounter,
    DWORD               dwCounterType,
    DWORD               dwDefaultScale,
    LPWSTR              szInstance,
    DWORD               dwInstance,
    LPWSTR              szParent,
    DWORD               dwParent,
    LPDWORD             pdwIndex,
    BOOL                bInsert
);

PPDHI_LOG_COUNTER
PdhiFindObjectCounter(
    PPDHI_LOG           pLog,
    PPDHI_LOG_OBJECT    pObject,
    LPWSTR              szCounter,
    DWORD               dwCounterType,
    DWORD               dwDefaultScale,
    LPWSTR              szInstance,
    DWORD               dwInstance,
    LPWSTR              szParent,
    DWORD               dwParent,
    LPDWORD             pdwIndex,
    BOOL                bInsert
);

PDH_FUNCTION
PdhiEnumCachedMachines(
    PPDHI_LOG_MACHINE MachineList,
    LPVOID            pBuffer,
    LPDWORD           lpdwBufferSize,
    BOOL              bUnicodeDest
);

PDH_FUNCTION
PdhiEnumCachedObjects(
    PPDHI_LOG_MACHINE MachineList,
    LPCWSTR           szMachineName,
    LPVOID            pBuffer,
    LPDWORD           pcchBufferSize,
    DWORD             dwDetailLevel,
    BOOL              bUnicodeDest
);

PDH_FUNCTION
PdhiEnumCachedObjectItems(
    PPDHI_LOG_MACHINE  MachineList,
    LPCWSTR            szMachineName,
    LPCWSTR            szObjectName,
    PDHI_COUNTER_TABLE CounterTable,
    DWORD              dwDetailLevel,
    DWORD              dwFlags
);

// Debug event tracing facility
//
#define PDH_DBG_TRACE_NONE    0       // no trace
#define PDH_DBG_TRACE_FATAL   1       // Print fatal error traces only
#define PDH_DBG_TRACE_ERROR   2       // All errors
#define PDH_DBG_TRACE_WARNING 3       // Warnings as well
#define PDH_DBG_TRACE_INFO    4       // Informational traces as well
#define PDH_DBG_TRACE_ALL     255     // All traces

#define ARG_TYPE_ULONG        0
#define ARG_TYPE_WSTR         1
#define ARG_TYPE_STR          2
#define ARG_TYPE_ULONG64      3
#define ARG_TYPE_ULONGX       4
#define ARG_TYPE_ULONG64X     5

#ifdef _WIN64
#define ARG_TYPE_PTR          ARG_TYPE_ULONG64X
#else
#define ARG_TYPE_PTR          ARG_TYPE_ULONGX
#endif

#define PDH_CALCFUNS         10
#define PDH_STATFUNS         11
#define PDH_COUNTER          20
#define PDH_CUTILS           21
#define PDH_DLLINIT          22
#define PDH_PERFDATA         23
#define PDH_PERFNAME         24
#define PDH_PERFUTIL         25
#define PDH_QUERY            26
#define PDH_QUTILS           27
#define PDH_STRINGS          28
#define PDH_VBFUNCS          29
#define PDH_LOG              40
#define PDH_LOGBIN           41
#define PDH_LOGCTRL          42
#define PDH_LOGPM            43
#define PDH_LOGSQL           44
#define PDH_LOGTEXT          45
#define PDH_LOGWMI           46
#define PDH_RELOG            47
#define PDH_PLOGMAN          50
#define PDH_REGUTIL          51
#define PDH_WMIUTIL          52
#define PDH_BROWSDLG         60
#define PDH_BROWSER          61
#define PDH_DATASRC          62
#define PDH_EXPLDLG          63
#define PDH_WILDCARD         64
#define PDH_WBEM             70
#define PDH_GALLOC           80
#define PDH_GREALLOC         81
#define PDH_GFREE            82

// n must be 1 through 8. x is the one of above types
#define ARG_DEF(x, n)         (x << ((n-1) * 4))

#define TRACE_WSTR(str)          str, (sizeof(WCHAR) * (lstrlenW(str) + 1))
#define TRACE_STR(str)           str, (sizeof(CHAR) * (lstrlenA(str) + 1))
#define TRACE_DWORD(dwValue)     & dwValue, sizeof(LONG)
#define TRACE_LONG64(llValue)    & llValue, sizeof(LONGLONG)

#ifdef _WIN64
#define TRACE_PTR(ptr)           TRACE_LONG64(ptr)
#else
#define TRACE_PTR(ptr)           TRACE_DWORD(ptr)
#endif

#ifdef _INIT_PDH_DEBUGTRACE
DWORD g_dwDebugTraceLevel = PDH_DBG_TRACE_NONE;
#else
extern DWORD g_dwDebugTraceLevel;
#endif

PDH_FUNCTION
PdhDebugStartTrace();

VOID
PdhDbgTrace(
    ULONG  LineNumber,
    ULONG  ModuleNumber,
    ULONG  OptArgs,
    ULONG  Status,
    ...
);

#define TRACE(L, X) if (g_dwDebugTraceLevel >= L) PdhDbgTrace X

#define _SHOW_PDH_MEM_ALLOCS        1
//#define _VALIDATE_PDH_MEM_ALLOCS    1

#ifndef _SHOW_PDH_MEM_ALLOCS
#define G_ALLOC(s)      HeapAlloc(hPdhHeap, (HEAP_ZERO_MEMORY), s)
#define G_REALLOC(h,s)  HeapReAlloc(hPdhHeap, (HEAP_ZERO_MEMORY), h, s)
#define G_FREE(h)       if (h != NULL) HeapFree(hPdhHeap, 0, h)
#define G_SIZE(h)       (h != NULL ? HeapSize(hPdhHeap, 0, h) : 0)
#else

#ifdef _VALIDATE_PDH_MEM_ALLOCS

__inline
LPVOID
PdhiHeapAlloc(DWORD s)
{
    LPVOID  lpRetVal;
    HeapValidate(hPdhHeap, 0, NULL);
    lpRetVal = HeapAlloc (hPdhHeap, HEAP_ZERO_MEMORY, s);
    return lpRetVal;
}

__inline
LPVOID
PdhiHeapReAlloc(LPVOID h, DWORD s)
{
    LPVOID  lpRetVal;
    HeapValidate(hPdhHeap, 0, NULL);
    lpRetVal = HeapReAlloc (hPdhHeap, HEAP_ZERO_MEMORY, h, s);
    return lpRetVal;
}

__inline
BOOL
PdhiHeapFree(LPVOID h)
{
    BOOL bRetVal;
    if (h == NULL) return TRUE;
    HeapValidate(hPdhHeap, 0, NULL);
    bRetVal = HeapFree (hPdhHeap, 0, h);
    return bRetVal;
}

#define G_ALLOC(s)     PdhiHeapAlloc(s)
#define G_REALLOC(h,s) PdhiHeapReAlloc(h, s)
#define G_FREE(h)      PdhiHeapFree(h)
#define G_SIZE(h)      (h != NULL ? HeapSize(hPdhHeap, 0, h) : 0)

#else

__inline
LPVOID
PdhiHeapAlloc(LPSTR szSourceFileName, DWORD dwLineNo, SIZE_T s)
{
    LPVOID   lpRetVal = NULL;
    LONGLONG dwSize   = (LONGLONG) s;

    if (hPdhHeap != NULL) {
        lpRetVal = HeapAlloc(hPdhHeap, HEAP_ZERO_MEMORY, s);
        TRACE((PDH_DBG_TRACE_INFO),
              (dwLineNo,
               PDH_GALLOC,
               ARG_DEF(ARG_TYPE_PTR, 1) | ARG_DEF(ARG_TYPE_STR, 2) | ARG_DEF(ARG_TYPE_ULONG64, 3),
               ERROR_SUCCESS,
               TRACE_PTR(lpRetVal),
               TRACE_STR(szSourceFileName),
               TRACE_LONG64(dwSize),
               NULL));
    }
    return lpRetVal;
}

__inline
LPVOID
PdhiHeapReAlloc(LPSTR szSourceFileName, DWORD dwLineNo, LPVOID h, SIZE_T s)
{
    LPVOID   lpRetVal      = NULL;
    SIZE_T   dwBeforeSize;
    LONGLONG lBeforeSize;
    LONGLONG lAfterSize;

    if (hPdhHeap != NULL) {
        dwBeforeSize = HeapSize(hPdhHeap, 0, h);
        lpRetVal     = HeapReAlloc(hPdhHeap, HEAP_ZERO_MEMORY, h, s);
        lBeforeSize  = (LONGLONG) dwBeforeSize;
        lAfterSize   = (LONGLONG) s;
        TRACE((PDH_DBG_TRACE_INFO),
              (dwLineNo,
               PDH_GREALLOC,
               ARG_DEF(ARG_TYPE_PTR, 1) | ARG_DEF(ARG_TYPE_PTR, 2) | ARG_DEF(ARG_TYPE_STR, 3)
                                        | ARG_DEF(ARG_TYPE_ULONG64, 4) | ARG_DEF(ARG_TYPE_ULONG64, 5),
               ERROR_SUCCESS,
               TRACE_PTR(lpRetVal),
               TRACE_PTR(h),
               TRACE_STR(szSourceFileName),
               TRACE_LONG64(lAfterSize),
               TRACE_LONG64(lBeforeSize),
               NULL));
    }
    return lpRetVal;
}

__inline
BOOL
PdhiHeapFree(LPSTR szSourceFileName, DWORD dwLineNo, LPVOID h)
{
    BOOL     bRetVal      = TRUE;
    SIZE_T   dwBlockSize;
    LONGLONG lBlockSize;

    if (h != NULL) {
        dwBlockSize = HeapSize(hPdhHeap, 0, h);
        lBlockSize  = (LONGLONG) dwBlockSize;
        TRACE((PDH_DBG_TRACE_INFO),
              (dwLineNo,
               PDH_GFREE,
               ARG_DEF(ARG_TYPE_PTR, 1) | ARG_DEF(ARG_TYPE_STR, 2) | ARG_DEF(ARG_TYPE_ULONG64, 3),
               ERROR_SUCCESS,
               TRACE_PTR(h),
               TRACE_STR(szSourceFileName),
               TRACE_LONG64(lBlockSize),
               NULL));

        bRetVal = HeapFree(hPdhHeap, 0, h);
    }
    return bRetVal;
}

#define G_ALLOC(s)      PdhiHeapAlloc(__FILE__, __LINE__, s)
#define G_REALLOC(h,s)  PdhiHeapReAlloc(__FILE__, __LINE__, h, s)
#define G_FREE(h)       PdhiHeapFree(__FILE__, __LINE__, h)
#define G_SIZE(h)       (h != NULL ? HeapSize(hPdhHeap, 0, h) : 0)

#endif
#endif

LPSTR
PdhiWideCharToMultiByte(
    UINT   CodePage,
    LPWSTR wszString
);

LPWSTR
PdhiMultiByteToWideChar(
    UINT   CodePage,
    LPSTR  aszString
);

//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//
#define InitializeListHead(ListHead)   ((ListHead)->Flink = (ListHead)->Blink = (ListHead))
#define IsListEmpty(ListHead)          ((ListHead)->Flink == (ListHead))
#define RemoveHeadList(ListHead)       (ListHead)->Flink; \
                                       { RemoveEntryList((ListHead)->Flink) }
#define RemoveTailList(ListHead)       (ListHead)->Blink; \
                                       { RemoveEntryList((ListHead)->Blink) }
#define RemoveEntryList(Entry)         { PLIST_ENTRY _EX_Blink; \
                                         PLIST_ENTRY _EX_Flink; \
                                         _EX_Flink        = (Entry)->Flink; \
                                         _EX_Blink        = (Entry)->Blink; \
                                         _EX_Blink->Flink = _EX_Flink; \
                                         _EX_Flink->Blink = _EX_Blink; \
                                       }
#define InsertTailList(ListHead,Entry) { PLIST_ENTRY _EX_Blink; \
                                         PLIST_ENTRY _EX_ListHead; \
                                         _EX_ListHead        = (ListHead); \
                                         _EX_Blink           = _EX_ListHead->Blink; \
                                         (Entry)->Flink      = _EX_ListHead; \
                                         (Entry)->Blink      = _EX_Blink; \
                                         _EX_Blink->Flink    = (Entry); \
                                         _EX_ListHead->Blink = (Entry); \
                                       }
#define InsertHeadList(ListHead,Entry) { PLIST_ENTRY _EX_Flink; \
                                         PLIST_ENTRY _EX_ListHead; \
                                         _EX_ListHead        = (ListHead); \
                                         _EX_Flink           = _EX_ListHead->Flink; \
                                         (Entry)->Flink      = _EX_Flink; \
                                         (Entry)->Blink      = _EX_ListHead; \
                                         _EX_Flink->Blink    = (Entry); \
                                         _EX_ListHead->Flink = (Entry); \
                                       }
#define PopEntryList(ListHead)         (ListHead)->Next; \
                                       { PSINGLE_LIST_ENTRY FirstEntry; \
                                         FirstEntry = (ListHead)->Next;\
                                         if (FirstEntry != NULL) { \
                                             (ListHead)->Next = FirstEntry->Next; \
                                         } \
                                       }
#define PushEntryList(ListHead,Entry)  (Entry)->Next    = (ListHead)->Next; \
                                       (ListHead)->Next = (Entry)
#ifdef __cplusplus
}
#endif

#endif // _PDHI_DEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pcopy\pcopy.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <malloc.h>

// #include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#include "metadata.h"

BOOL fCheckDebugData;

int
objcomp(
        void *pFile1,
        DWORD dwSize1,
        void *pFile2,
        DWORD dwSize2,
        BOOL  fIgnoreRsrcDifferences
       );

// Generic routine to write a blob out.
void
SaveTemp(
         PVOID pFile,
         PCHAR szFile,
         DWORD FileSize
         )
{
    DWORD dwBytesWritten;
    HANDLE hFile;
    hFile = CreateFile(
                szFile,
                GENERIC_WRITE,
                (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE),
                NULL,
                CREATE_ALWAYS,
                0,
                NULL
                );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        printf("Unable to open %s\n", szFile);
        return;
    }

    if (!WriteFile(hFile, pFile, FileSize, &dwBytesWritten, FALSE)) {
        printf("Unable to write date to %s\n", szFile);
    }

    CloseHandle(hFile);
    return;
}

// Zero out the timestamps in a PE library.
BOOL
ZeroLibTimeStamps(
    PCHAR pFile,
    DWORD dwSize
    )
{
    PIMAGE_ARCHIVE_MEMBER_HEADER pHeader;
    DWORD dwOffset;
    CHAR MemberSize[sizeof(pHeader->Size) + 1];
    PIMAGE_FILE_HEADER pObjHeader;

    ZeroMemory(MemberSize, sizeof(MemberSize));

    __try {

        dwOffset = IMAGE_ARCHIVE_START_SIZE;
        while (dwOffset < dwSize) {
            pHeader = (PIMAGE_ARCHIVE_MEMBER_HEADER)(pFile+dwOffset);
            ZeroMemory(pHeader->Date, sizeof(pHeader->Date));
            ZeroMemory(pHeader->Mode, sizeof(pHeader->Mode));        // Mode isn't interesting (it indicates whether the member was readonly or r/w)

            dwOffset += IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR;
            memcpy(MemberSize, pHeader->Size, sizeof(pHeader->Size));

            // If it's not one of the special members, it must be an object/file, zero it's timestamp also.
            if (memcmp(pHeader->Name, IMAGE_ARCHIVE_LINKER_MEMBER, sizeof(pHeader->Name)) &&
                memcmp(pHeader->Name, IMAGE_ARCHIVE_LONGNAMES_MEMBER, sizeof(pHeader->Name)))
            {
                IMAGE_FILE_HEADER UNALIGNED *pFileHeader = (PIMAGE_FILE_HEADER)(pFile+dwOffset);
                if ((pFileHeader->Machine == IMAGE_FILE_MACHINE_UNKNOWN) &&
                    (pFileHeader->NumberOfSections == IMPORT_OBJECT_HDR_SIG2))
                {
                    // VC6 import descriptor OR ANON object header. Eitherway,
                    // casting to IMPORT_OBJECT_HEADER will do the trick.
                    ((IMPORT_OBJECT_HEADER UNALIGNED *)pFileHeader)->TimeDateStamp = 0;
                } else {
                    pFileHeader->TimeDateStamp = 0;
                }
            }
            dwOffset += strtoul(MemberSize, NULL, 10);
            dwOffset = (dwOffset + 1) & ~1;   // align to word
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    return TRUE;
}

PBYTE RvaToVa(PIMAGE_NT_HEADERS pNtHeaders,
              PBYTE             pbBase,
              DWORD             dwRva)
{
    PIMAGE_SECTION_HEADER   pNtSection = NULL;
    DWORD                   i;

    pNtSection = IMAGE_FIRST_SECTION(pNtHeaders);
    for (i = 0; i < pNtHeaders->FileHeader.NumberOfSections; i++) {
        if (dwRva >= pNtSection->VirtualAddress &&
            dwRva < pNtSection->VirtualAddress + pNtSection->SizeOfRawData)
            break;
        pNtSection++;
    }

    if (i < pNtHeaders->FileHeader.NumberOfSections)
        return pbBase +
            (dwRva - pNtSection->VirtualAddress) +
            pNtSection->PointerToRawData;
    else
        return NULL;
}

// Follow a resource tree rooted under the version resource and clear all data
// blocks.
void ScrubResDir(PIMAGE_NT_HEADERS           pNtHeaders,
                 PBYTE                       pbBase,
                 PBYTE                       pbResBase,
                 PIMAGE_RESOURCE_DIRECTORY   pResDir)
{
    PIMAGE_RESOURCE_DIRECTORY       pSubResDir;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResEntry;
    PIMAGE_RESOURCE_DATA_ENTRY      pDataEntry;
    WORD                            i;
    PBYTE                           pbData;
    DWORD                           cbData;

    pResEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResDir + 1);

    for (i = 0; i < (pResDir->NumberOfNamedEntries + pResDir->NumberOfIdEntries); i++, pResEntry++) {
        if (pResEntry->DataIsDirectory) {
            // Another sub-directory, recurse into it.
            pSubResDir = (PIMAGE_RESOURCE_DIRECTORY)(pbResBase + pResEntry->OffsetToDirectory);
            ScrubResDir(pNtHeaders, pbBase, pbResBase, pSubResDir);
        } else {
            // Found a data block, zap it.
            pDataEntry = (PIMAGE_RESOURCE_DATA_ENTRY)(pbResBase + pResEntry->OffsetToData);
            pbData = RvaToVa(pNtHeaders, pbBase, pDataEntry->OffsetToData);
            cbData = pDataEntry->Size;
            if (pbData)
                ZeroMemory(pbData, cbData);
        }
    }
}

typedef union {
    PIMAGE_OPTIONAL_HEADER32 hdr32;
    PIMAGE_OPTIONAL_HEADER64 hdr64;
} PIMAGE_OPTIONAL_HEADER_BOTH;

void 
WhackVersionResource(
                     PIMAGE_NT_HEADERS pNtHeaders,
                     PBYTE  pFile
                     )
{
    PIMAGE_DATA_DIRECTORY       pResDataDir;
    PIMAGE_RESOURCE_DIRECTORY   pResDir;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResEntry;
    DWORD i;

    pResDataDir = 
       pNtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
       &((PIMAGE_OPTIONAL_HEADER32) pNtHeaders)->DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE] :
       &((PIMAGE_OPTIONAL_HEADER64) pNtHeaders)->DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE];

    pResDir = (PIMAGE_RESOURCE_DIRECTORY)RvaToVa(pNtHeaders, pFile, pResDataDir->VirtualAddress);

    if (pResDir) {
        pResDir->TimeDateStamp = 0;

        // Search for a top level resource ID of 0x0010. This should be the root
        // of the version info. If we find it, clear all data blocks below this
        // root.
        pResEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResDir + 1 + pResDir->NumberOfNamedEntries);
        for (i = 0; i < pResDir->NumberOfIdEntries; i++, pResEntry++) {
            if (pResEntry->Id != 0x0010)
                continue;
            ScrubResDir(pNtHeaders, pFile, (PBYTE)pResDir, pResDir);
            break;
        }
    }
}

IMAGE_FILE_HEADER UNALIGNED *
GetNextLibMember(
    DWORD *pdwOffset,
    void  *pFile,
    DWORD  dwSize,
    DWORD *dwMemberSize
    )
{
    PIMAGE_ARCHIVE_MEMBER_HEADER pHeader;
    CHAR MemberSize[sizeof(pHeader->Size) + 1];

    ZeroMemory(MemberSize, sizeof(MemberSize));

    __try {

        while (*pdwOffset < dwSize) {
            pHeader = (PIMAGE_ARCHIVE_MEMBER_HEADER)((PCHAR)pFile+*pdwOffset);

            *pdwOffset += IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR;
            memcpy(MemberSize, pHeader->Size, sizeof(pHeader->Size));

            // If it's not one of the special members, it must be an object/file, zero it's timestamp also.
            if (memcmp(pHeader->Name, IMAGE_ARCHIVE_LINKER_MEMBER, sizeof(pHeader->Name)) &&
                memcmp(pHeader->Name, IMAGE_ARCHIVE_LONGNAMES_MEMBER, sizeof(pHeader->Name)))
            {
                PIMAGE_FILE_HEADER pFileHeader = (PIMAGE_FILE_HEADER)((PCHAR)pFile+*pdwOffset);
                *dwMemberSize = strtoul(MemberSize, NULL, 10);
                *pdwOffset += *dwMemberSize;
                *pdwOffset = (*pdwOffset + 1) & ~1;   // align to word
                return pFileHeader;
            }
            *pdwOffset += strtoul(MemberSize, NULL, 10);
            *pdwOffset = (*pdwOffset + 1) & ~1;   // align to word
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    return NULL;
}

BOOL
CompareLibMembers(
    void *pFile1,
    DWORD dwSize1,
    void *pFile2,
    DWORD dwSize2
    )
{
    DWORD dwOffset1, dwOffset2, dwMemberSize1, dwMemberSize2;
    IMAGE_FILE_HEADER UNALIGNED *pObjHeader1;
    IMAGE_FILE_HEADER UNALIGNED *pObjHeader2;

    __try {

        dwOffset1 = dwOffset2 = IMAGE_ARCHIVE_START_SIZE;
        pObjHeader1 = GetNextLibMember(&dwOffset1, pFile1, dwSize1, &dwMemberSize1);
        pObjHeader2 = GetNextLibMember(&dwOffset2, pFile2, dwSize2, &dwMemberSize2);

        while (pObjHeader1 && pObjHeader2) {

            if ((pObjHeader1->Machine != pObjHeader2->Machine) ||
                (pObjHeader1->NumberOfSections != pObjHeader2->NumberOfSections))
            {
                return TRUE;        // Machine and/or Section count doesn't match - files differ.
            }

            if ((pObjHeader1->Machine == IMAGE_FILE_MACHINE_UNKNOWN) &&
                (pObjHeader1->NumberOfSections == IMPORT_OBJECT_HDR_SIG2))
            {
                // VC6 import descriptor OR ANON object header.  Check the Version.
                if (((IMPORT_OBJECT_HEADER UNALIGNED *)pObjHeader1)->Version !=
                    ((IMPORT_OBJECT_HEADER UNALIGNED *)pObjHeader2)->Version)
                {
                    // Versions don't match, these aren't same members.  files differ
                    return TRUE;
                }
                if (((IMPORT_OBJECT_HEADER UNALIGNED *)pObjHeader1)->Version) {
                    // non-zero version indicates ANON_OBJECT_HEADER
                    if (memcmp(pObjHeader1, pObjHeader2, sizeof(ANON_OBJECT_HEADER) + ((ANON_OBJECT_HEADER UNALIGNED *)pObjHeader1)->SizeOfData)) {
                        // members don't match, files differ.
                        return TRUE;
                    }
                } else {
                    // zero version indicates IMPORT_OBJECT_HEADER
                    if (memcmp(pObjHeader1, pObjHeader2, sizeof(IMPORT_OBJECT_HEADER) + ((IMPORT_OBJECT_HEADER UNALIGNED *)pObjHeader1)->SizeOfData)) {
                        // members don't match, files differ.
                        return TRUE;
                    }
                }
            } else {
                // It's a real object - compare the non-debug data in the objects to see if they match
                // ignore resource data - you can't extract it from a lib anyway.
                if (objcomp(pObjHeader1, dwMemberSize1, pObjHeader2, dwMemberSize2, TRUE)) {
                    return TRUE;
                }
            }

            pObjHeader1 = GetNextLibMember(&dwOffset1, pFile1, dwSize1, &dwMemberSize1);
            pObjHeader2 = GetNextLibMember(&dwOffset2, pFile2, dwSize2, &dwMemberSize2);

        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }

    if (pObjHeader1 != pObjHeader2) {
        // Both s/b null.  If they're not, one lib has more members and they differ
        return TRUE;
    } else {
        return FALSE;
    }
}

//
// Compare two libraries ignoring info that isn't relevant
//  (timestamps for now, debug info later).
//
int
libcomp(
    void *pFile1,
    DWORD dwSize1,
    void *pFile2,
    DWORD dwSize2
    )
{
    // Normalize the two files and compare the results.

    ZeroLibTimeStamps(pFile1, dwSize1);
    ZeroLibTimeStamps(pFile2, dwSize2);

    if (dwSize1 == dwSize2) {
        if (!memcmp(pFile1, pFile2, dwSize1)) {
            // Files match, don't copy
            return FALSE;
        }
    }

    // OK.  Zeroing out timestamps didn't work.  Compare the members in each lib.
    // If they match, the libs match.

    return CompareLibMembers(pFile1, dwSize1, pFile2, dwSize2);
}

//
// Compare two headers.  For now, just use memcmp.  Later, we'll need to
// handle MIDL generated timestamp differences and check for comment only changes.
//

int
hdrcomp(
       void *pFile1,
       DWORD dwSize1,
       void *pFile2,
       DWORD dwSize2
      )
{
    if (dwSize1 != dwSize2) {
        return 1;
    }

    return memcmp(pFile1, pFile2, dwSize1);
}

//
// Compare two typelibs.  Initially just memcmp.  Use DougF's typelib code later.
//

int
tlbcomp(
        void *pFile1,
        DWORD dwSize1,
        void *pFile2,
        DWORD dwSize2
       )
{
    PIMAGE_NT_HEADERS pNtHeader1, pNtHeader2;

    if (dwSize1 != dwSize2) {
        return 1;
    }

    pNtHeader1 = RtlpImageNtHeader(pFile1);
    pNtHeader2 = RtlpImageNtHeader(pFile2);

    if (!pNtHeader1 || !pNtHeader2) {
        // Not both PE images - just do a memcmp
        return memcmp(pFile1, pFile2, dwSize1);
    }

    pNtHeader1->FileHeader.TimeDateStamp = 0;
    pNtHeader2->FileHeader.TimeDateStamp = 0;

    // Eliminate the version resource from the mix

    WhackVersionResource(pNtHeader1, pFile1);
    WhackVersionResource(pNtHeader2, pFile2);

    return memcmp(pFile1, pFile2, dwSize1);
}

int
objcomp(
        void *pFile1,
        DWORD dwSize1,
        void *pFile2,
        DWORD dwSize2,
        BOOL  fIgnoreRsrcDifferences
       )
{
    IMAGE_FILE_HEADER UNALIGNED *pFileHeader1 = (PIMAGE_FILE_HEADER)(pFile1);
    IMAGE_FILE_HEADER UNALIGNED *pFileHeader2 = (PIMAGE_FILE_HEADER)(pFile2);
    IMAGE_SECTION_HEADER UNALIGNED *pSecHeader1;
    IMAGE_SECTION_HEADER UNALIGNED *pSecHeader2;

    if (pFileHeader1->Machine != pFileHeader2->Machine) {
        // Machines don't match, files differ
        return TRUE;
    }

    if (dwSize1 == dwSize2) {
        // See if this is a simple test - same size files, zero out timestamps and compare
        pFileHeader1->TimeDateStamp = 0;
        pFileHeader2->TimeDateStamp = 0;
        if (!memcmp(pFile1, pFile2, dwSize1)) {
            // Files match, don't copy
            return FALSE;
        } else {
            if (fCheckDebugData) {
                // Sizes match, contents don't (must be debug data) - do the copy
                return TRUE;
            }
        }
    }

    if (fCheckDebugData) {
        // Sizes don't match (must be debug data differences) - do a copy
        return TRUE;
    }

    // Harder.  Ignore the debug data in each and compare what's left.

    if (pFileHeader1->NumberOfSections != pFileHeader2->NumberOfSections) {
        // Different number of sections - files differ
        return TRUE;
    }

    pSecHeader1 = (PIMAGE_SECTION_HEADER)((PCHAR)pFile1+sizeof(IMAGE_FILE_HEADER) + pFileHeader1->SizeOfOptionalHeader);
    pSecHeader2 = (PIMAGE_SECTION_HEADER)((PCHAR)pFile2+sizeof(IMAGE_FILE_HEADER) + pFileHeader2->SizeOfOptionalHeader);

    while (pFileHeader1->NumberOfSections--) {

        if (memcmp(pSecHeader1->Name, pSecHeader2->Name, IMAGE_SIZEOF_SHORT_NAME)) {
            // Section names don't match, can't compare - files differ
            return TRUE;
        }

        if (memcmp(pSecHeader1->Name, ".debug$", 7) &&
            memcmp(pSecHeader1->Name, ".drectve", 8) &&
            !(!memcmp(pSecHeader1->Name, ".rsrc$", 6) && fIgnoreRsrcDifferences) )
        {
            // Not a debug section and not a linker directive, compare for match.
            if (pSecHeader1->SizeOfRawData != pSecHeader2->SizeOfRawData) {
                // Section sizes don't match - files differ.
                return TRUE;
            }

            if (pSecHeader1->PointerToRawData || pSecHeader2->PointerToRawData) {
                if (memcmp((PCHAR)pFile1+pSecHeader1->PointerToRawData, (PCHAR)pFile2+pSecHeader2->PointerToRawData, pSecHeader1->SizeOfRawData)) {
                    // Raw data doesn't match - files differ
                    return TRUE;
                }
            }
        }
        pSecHeader1++;
        pSecHeader2++;
    }

    // Compared the sections and they match - files don't differ.
    return FALSE;
}


int
IsValidMachineType(USHORT usMachine)
{
    if ((usMachine == IMAGE_FILE_MACHINE_I386) ||
        (usMachine == IMAGE_FILE_MACHINE_AMD64) ||
        (usMachine == IMAGE_FILE_MACHINE_IA64) ||
        (usMachine == IMAGE_FILE_MACHINE_ALPHA64) ||
        (usMachine == IMAGE_FILE_MACHINE_ALPHA))
    {
        return TRUE;
    } else {
        return FALSE;
    }
}


// Internal metadata header.
typedef struct
{
    ULONG       lSignature;             // "Magic" signature.
    USHORT      iMajorVer;              // Major file version.
    USHORT      iMinorVer;              // Minor file version.
    ULONG       iExtraData;             // Offset to next structure of information
    ULONG       iVersionString;         // Length of version string
    BYTE        pVersion[0];            // Version string
}  MD_STORAGESIGNATURE, *PMD_STORAGESIGNATURE;

int
normalizeasm(
             PBYTE  pFile,
             DWORD  dwSize,
             PBYTE *ppbMetadata,
             DWORD *pcbMetadata
            )
{
    PIMAGE_NT_HEADERS           pNtHeaders;
    BOOL                        f32Bit;
    PIMAGE_OPTIONAL_HEADER_BOTH pOptHeader;
    PIMAGE_DATA_DIRECTORY       pCorDataDir;
    PIMAGE_DATA_DIRECTORY       pDebugDataDir;
    PIMAGE_DEBUG_DIRECTORY      pDebugDir;
    PBYTE                       pbDebugData;
    DWORD                       cbDebugData;
    PIMAGE_DATA_DIRECTORY       pExportDataDir;
    PIMAGE_EXPORT_DIRECTORY     pExportDir;
    PIMAGE_COR20_HEADER         pCorDir;
    PMD_STORAGESIGNATURE        pMetadata;
    DWORD                       i;
    PBYTE                       pbStrongNameSig;
    DWORD                       cbStrongNameSig;

    // Check that this is a standard PE.
    pNtHeaders = RtlpImageNtHeader(pFile);
    if (pNtHeaders == NULL)
        return FALSE;

    // Managed assemblies still burn in a machine type (though they should be portable).
    if (!IsValidMachineType(pNtHeaders->FileHeader.Machine))
        return FALSE;

    // Clear the file timestamp.
    pNtHeaders->FileHeader.TimeDateStamp = 0;

    // Determine whether we're dealing with a 32 or 64 bit PE.
    if (pNtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
        f32Bit = TRUE;
    else if (pNtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
        f32Bit = FALSE;
    else
        return FALSE;

    pOptHeader.hdr32 = (PVOID)&pNtHeaders->OptionalHeader;

    // Clear the checksum.
    if (f32Bit)
        pOptHeader.hdr32->CheckSum = 0;
    else
        pOptHeader.hdr64->CheckSum = 0;

    pCorDataDir = f32Bit ?
        &pOptHeader.hdr32->DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR] :
        &pOptHeader.hdr64->DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR];

    if (pCorDataDir->VirtualAddress == 0)
        return FALSE;

    // Zero any debug data.
    pDebugDataDir = f32Bit ?
        &pOptHeader.hdr32->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG] :
        &pOptHeader.hdr64->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
    if (pDebugDataDir->VirtualAddress) {
        pDebugDir = (PIMAGE_DEBUG_DIRECTORY)RvaToVa(pNtHeaders, pFile, pDebugDataDir->VirtualAddress);
        if (pDebugDir) {
            pDebugDir->TimeDateStamp = 0;
            pbDebugData = pFile + pDebugDir->PointerToRawData;
            cbDebugData = pDebugDir->SizeOfData;
            ZeroMemory(pbDebugData, cbDebugData);
        }
    }

    // Zero export data timestamp.
    pExportDataDir = f32Bit ?
        &pOptHeader.hdr32->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT] :
        &pOptHeader.hdr64->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
    if (pExportDataDir->VirtualAddress) {
        pExportDir = (PIMAGE_EXPORT_DIRECTORY)RvaToVa(pNtHeaders, pFile, pExportDataDir->VirtualAddress);
        if (pExportDir)
            pExportDir->TimeDateStamp = 0;
    }

    // Locate metadata blob in image and return the results for comparison.
    pCorDir = (PIMAGE_COR20_HEADER)RvaToVa(pNtHeaders, pFile, pCorDataDir->VirtualAddress);
    if (pCorDir) {
        *ppbMetadata = RvaToVa(pNtHeaders, pFile, pCorDir->MetaData.VirtualAddress);
        *pcbMetadata = pCorDir->MetaData.Size;

        // Remove metadata version string (contains a build number).
        pMetadata = (PMD_STORAGESIGNATURE)*ppbMetadata;
        if (pMetadata->lSignature != 0x424A5342)
            return FALSE;
        for (i = 0; i < pMetadata->iVersionString; i++)
            pMetadata->pVersion[i] = 0;
    
        // Clear any strong name signature.
        pbStrongNameSig = RvaToVa(pNtHeaders, pFile, pCorDir->StrongNameSignature.VirtualAddress);
        cbStrongNameSig = pCorDir->StrongNameSignature.Size;
        ZeroMemory(pbStrongNameSig, cbStrongNameSig);
    }

    WhackVersionResource(pNtHeaders, pFile);

    return TRUE;
}

//
// Open metadata scope on memory -- return MVID and zero any file hashes.
//

int
scanmetadata(
             IMetaDataDispenser *pDispenser,
             PBYTE pbMetadata,
             DWORD cbMetadata,
             GUID *pGUID
            )
{
    IMetaDataImport            *pImport;
    IMetaDataAssemblyImport    *pAsmImport;
    HCORENUM                    hEnum = 0;
    DWORD                       dwFiles;
    mdFile                     *pFileTokens;
    DWORD                       i;
    PBYTE                       pbHash;
    DWORD                       cbHash;

    // Ask the metadata engine to look at the in-memory metadata blob.
    if (FAILED(pDispenser->lpVtbl->OpenScopeOnMemory(pDispenser,
                                                     pbMetadata,
                                                     cbMetadata,
                                                     0x80,
                                                     &IID_IMetaDataImport,
                                                     (IUnknown **)&pImport)))
        return FALSE;

    // Retrieve the MVID value.
    if (FAILED(pImport->lpVtbl->GetScopeProps(pImport,
                                              NULL,
                                              0,
                                              NULL,
                                              pGUID)))
        return FALSE;

    // Get an assembly importer interface as well as the straight module importer.
    if (FAILED(pImport->lpVtbl->QueryInterface(pImport, &IID_IMetaDataAssemblyImport, (void**)&pAsmImport)))
        return FALSE;

    // Enumerate the file (external module) entries.
    if (FAILED(pAsmImport->lpVtbl->EnumFiles(pAsmImport, &hEnum, NULL, 0, NULL)))
        return FALSE;

    if (FAILED(pImport->lpVtbl->CountEnum(pImport, hEnum, &dwFiles)))
        return FALSE;

    pFileTokens = (mdFile*)malloc(dwFiles * sizeof(mdFile));

    if (!pFileTokens)
        return FALSE;

    if (FAILED(pAsmImport->lpVtbl->EnumFiles(pAsmImport,
                                             &hEnum,
                                             pFileTokens,
                                             dwFiles,
                                             &dwFiles)))
    {
        free(pFileTokens);
        return FALSE;
    }

    // Look at each file reference in turn. Metadata actually gives us back the
    // real address of the hash blob so we can zero it directly.
    for (i = 0; i < dwFiles; i++) {
        if (FAILED(pAsmImport->lpVtbl->GetFileProps(pAsmImport,
                                                    pFileTokens[i],
                                                    NULL,
                                                    0,
                                                    NULL,
                                                    (const void*)&pbHash,
                                                    &cbHash,
                                                    NULL)))
        {
            free(pFileTokens);
            return FALSE;
        }
        ZeroMemory(pbHash, cbHash);
    }

    pAsmImport->lpVtbl->Release(pAsmImport);
    pImport->lpVtbl->Release(pImport);

    free(pFileTokens);
    return TRUE;
}

//
// Compare two managed assemblies.
//

int
asmcomp(
        void *pFile1,
        DWORD dwSize1,
        void *pFile2,
        DWORD dwSize2
       )
{
    PBYTE               pbMetadata1;
    DWORD               cbMetadata1;
    PBYTE               pbMetadata2;
    DWORD               cbMetadata2;
    IMetaDataDispenser *pDispenser = NULL;
    BYTE                mvid1[16];
    BYTE                mvid2[16];
    DWORD               i, j;

    if (!normalizeasm(pFile1, dwSize1, &pbMetadata1, &cbMetadata1))
        return TRUE;

    if (!normalizeasm(pFile2, dwSize2, &pbMetadata2, &cbMetadata2))
        return TRUE;

    if (cbMetadata1 != cbMetadata2)
        return TRUE;

    // It's hard to normalize metadata blobs. They contain two major types of
    // per-build churn: a module MVID (GUID) and zero or more file hashes for
    // included modules. These are hard to locate, they're not part of a
    // simplistic file format, but are stored in a fully fledged relational
    // database with non-trivial schema. 
    // Instead, we use the metadata engine itself to give us the file hashes (it
    // actually gives us the addresses of these in memory so we can zero them
    // directly) and the MVID (can't use the same trick here, but we can use the
    // MVID value to decide whether to discount metadata deltas).

    // We need COM.
    if (FAILED(CoInitialize(NULL)))
        return TRUE;

    // And the root interface into the runtime metadata engine.
    if (FAILED(CoCreateInstance(&CLSID_CorMetaDataDispenser,
                                NULL,
                                CLSCTX_INPROC_SERVER, 
                                &IID_IMetaDataDispenser,
                                (void **)&pDispenser)))
        return TRUE;

    if (!scanmetadata(pDispenser,
                      pbMetadata1,
                      cbMetadata1,
                      (GUID*)mvid1))
        return TRUE;

    if (!scanmetadata(pDispenser,
                      pbMetadata2,
                      cbMetadata2,
                      (GUID*)mvid2))
        return TRUE;

    // Locate mvids in the metadata blobs (they should be at the same offset).
    for (i = 0; i < cbMetadata1; i++)
        if (pbMetadata1[i] == mvid1[0]) {
            for (j = 0; j < 16; j++)
                if (pbMetadata1[i + j] != mvid1[j] ||
                    pbMetadata2[i + j] != mvid2[j])
                    break;
            if (j == 16) {
                // Found the MVIDs in both assemblies, zero them.
                ZeroMemory(&pbMetadata1[i], 16);
                ZeroMemory(&pbMetadata2[i], 16);
                printf("Zapped MVID\n");
            }
        }

    return memcmp(pFile1, pFile2, dwSize1);
}


#define FILETYPE_ARCHIVE  0x01
#define FILETYPE_TYPELIB  0x02
#define FILETYPE_HEADER   0x03
#define FILETYPE_PE_OBJECT   0x04
#define FILETYPE_MANAGED  0x05
#define FILETYPE_UNKNOWN  0xff

//
// Given a file, attempt to determine what it is.  Initial pass will just use file
//  extensions except for libs that we can search for the <arch>\n start.
//

int
DetermineFileType(
                  void *pFile,
                  DWORD dwSize,
                  CHAR *szFileName
                 )
{
    char szExt[_MAX_EXT];

    // Let's see if it's a library first:

    if ((dwSize >= IMAGE_ARCHIVE_START_SIZE) &&
        !memcmp(pFile, IMAGE_ARCHIVE_START, IMAGE_ARCHIVE_START_SIZE))
    {
        return FILETYPE_ARCHIVE;
    }

    // For now, guess about the headers/tlb based on the extension.

    _splitpath(szFileName, NULL, NULL, NULL, szExt);

    if (!_stricmp(szExt, ".h") ||
        !_stricmp(szExt, ".hxx") ||
        !_stricmp(szExt, ".hpp") ||
        !_stricmp(szExt, ".w") ||
        !_stricmp(szExt, ".inc"))
    {
        return FILETYPE_HEADER;
    }

    if (!_stricmp(szExt, ".tlb"))
    {
        return FILETYPE_TYPELIB;
    }

    if ((!_stricmp(szExt, ".obj") ||
         !_stricmp(szExt, ".lib"))
        &&
        IsValidMachineType(((PIMAGE_FILE_HEADER)pFile)->Machine))
    {
        return FILETYPE_PE_OBJECT;
    }

    if (!_stricmp(szExt, ".dll"))
    {
        return FILETYPE_MANAGED;
    }

    return FILETYPE_UNKNOWN;
}

//
// Determine if two files are materially different.
//

BOOL
CheckIfCopyNecessary(
                     char *szSourceFile,
                     char *szDestFile,
                     BOOL *fTimeStampsDiffer
                     )
{
    PVOID pFile1 = NULL, pFile2 = NULL;
    DWORD File1Size, File2Size, dwBytesRead, dwErrorCode = ERROR_SUCCESS;
    HANDLE hFile1 = INVALID_HANDLE_VALUE;
    HANDLE hFile2 = INVALID_HANDLE_VALUE;
    BOOL fCopy = FALSE;
    int File1Type, File2Type;
    FILETIME FileTime1, FileTime2;

    hFile1 = CreateFile(
                szDestFile,
                GENERIC_READ,
                (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE),
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if ( hFile1 == INVALID_HANDLE_VALUE ) {
        fCopy = TRUE;           // Dest file doesn't exist.  Always do the copy.
        goto Exit;
    }

    // Now get the second file.

    hFile2 = CreateFile(
                szSourceFile,
                GENERIC_READ,
                (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE),
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if ( hFile2 == INVALID_HANDLE_VALUE ) {
        // If the source is missing, always skip the copy (don't want to delete the dest file).
        dwErrorCode = ERROR_FILE_NOT_FOUND;
        goto Exit;
    }

    // Get the file times and sizes.

    if (!GetFileTime(hFile1, NULL, NULL, &FileTime1)) {
        dwErrorCode = GetLastError();
        goto Exit;
    }

    if (!GetFileTime(hFile2, NULL, NULL, &FileTime2)) {
        dwErrorCode = GetLastError();
        goto Exit;
    }

    if (!memcmp(&FileTime1, &FileTime2, sizeof(FILETIME))) {
        *fTimeStampsDiffer = FALSE;
        goto Exit;
    }

    *fTimeStampsDiffer = TRUE;

    // Read file 1 in.

    File1Size = GetFileSize(hFile1, NULL);
    pFile1 = malloc(File1Size);

    if (!pFile1) {
        dwErrorCode = ERROR_OUTOFMEMORY;
        goto Exit;              // Can't compare - don't copy.
    }

    SetFilePointer(hFile1, 0, 0, FILE_BEGIN);
    if (!ReadFile(hFile1, pFile1, File1Size, &dwBytesRead, FALSE)) {
        dwErrorCode = GetLastError();
        goto Exit;              // Can't compare - don't copy
    }

    // Read file 2 in.

    File2Size = GetFileSize(hFile2, NULL);

    pFile2 = malloc(File2Size);

    if (!pFile2) {
        dwErrorCode = ERROR_OUTOFMEMORY;
        goto Exit;              // Can't compare - don't copy.
    }

    SetFilePointer(hFile2, 0, 0, FILE_BEGIN);
    if (!ReadFile(hFile2, pFile2, File2Size, &dwBytesRead, FALSE)) {
        dwErrorCode = GetLastError();
        goto Exit;              // Can't compare - don't copy
    }

    // Let's see what we've got.

    File1Type = DetermineFileType(pFile1, File1Size, szSourceFile);
    File2Type = DetermineFileType(pFile2, File2Size, szDestFile);

    if (File1Type == File2Type) {
        switch (File1Type) {
            case FILETYPE_ARCHIVE:
                fCopy = libcomp(pFile1, File1Size, pFile2, File2Size);
                break;

            case FILETYPE_HEADER:
                fCopy = hdrcomp(pFile1, File1Size, pFile2, File2Size);
                break;

            case FILETYPE_TYPELIB:
                fCopy = tlbcomp(pFile1, File1Size, pFile2, File2Size);
                break;

            case FILETYPE_PE_OBJECT:
                fCopy = objcomp(pFile1, File1Size, pFile2, File2Size, FALSE);
                break;

            case FILETYPE_MANAGED:
                fCopy = asmcomp(pFile1, File1Size, pFile2, File2Size);
                break;

            case FILETYPE_UNKNOWN:
            default:
                if (File1Size == File2Size) {
                    fCopy = memcmp(pFile1, pFile2, File1Size);
                } else {
                    fCopy = TRUE;
                }
        }
    } else {
        // They don't match according to file extensions - just memcmp them.
        if (File1Size == File2Size) {
            fCopy = memcmp(pFile1, pFile2, File1Size);
        } else {
            fCopy = TRUE;
        }
    }

Exit:
    if (pFile1)
        free(pFile1);

    if (pFile2)
        free(pFile2);

    if (hFile1 != INVALID_HANDLE_VALUE)
        CloseHandle(hFile1);

    if (hFile2 != INVALID_HANDLE_VALUE)
        CloseHandle(hFile2);

    SetLastError(dwErrorCode);

    return fCopy;
}

BOOL
UpdateDestTimeStamp(
                     char *szSourceFile,
                     char *szDestFile
                     )
{
    HANDLE hFile;
    FILETIME LastWriteTime;
    DWORD dwAttributes;
    BOOL fTweakAttributes;

    hFile = CreateFile(
                szSourceFile,
                GENERIC_READ,
                (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE),
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        return FALSE;
    }

    if (!GetFileTime(hFile, NULL, NULL, &LastWriteTime)) {
        CloseHandle(hFile);
        return FALSE;
    }

    CloseHandle(hFile);

    dwAttributes = GetFileAttributes(szDestFile);

    if ((dwAttributes != (DWORD) -1) && (dwAttributes & FILE_ATTRIBUTE_READONLY))
    {
        // Make sure it's not readonly
        SetFileAttributes(szDestFile, dwAttributes & ~FILE_ATTRIBUTE_READONLY);
        fTweakAttributes = TRUE;
    } else {
        fTweakAttributes = FALSE;
    }

    hFile = CreateFile(
                szDestFile,
                GENERIC_WRITE,
                (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE),
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        return FALSE;
    }

    SetFileTime(hFile, NULL, NULL, &LastWriteTime);
    CloseHandle(hFile);

    if (fTweakAttributes) {
        // Put the readonly attribute back on.
        if (!SetFileAttributes(szDestFile, dwAttributes)) {
            printf("PCOPY: SetFileAttributes(%s, %X) failed - error code: %d\n", szDestFile, dwAttributes, GetLastError());
        }
    }
    return TRUE;
}

//
// Log routine to find out what files were actually copied and why.
//

void
LogCopyFile(
            char * szSource,
            char * szDest,
            BOOL fCopy,
            DWORD dwReturnCode
            )
{
    if (getenv("LOG_PCOPY")) {
        FILE *FileHandle = fopen("\\pcopy.log", "a");

        if (FileHandle) {
             time_t Time;
             UCHAR const *szTime = "";
             Time = time(NULL);
             szTime = ctime(&Time);
             fprintf(FileHandle, "%s: %.*s, %s, %s, %d\n", fCopy ? (dwReturnCode ? "ERROR" : "DONE") : "SKIP", strlen(szTime)-1, szTime, szSource, szDest, dwReturnCode);
             fclose(FileHandle);
        }
    }
}

BOOL
MyMakeSureDirectoryPathExists(
    char * DirPath
    )
{
    LPSTR p;
    DWORD dw;

    char szDir[_MAX_DIR];
    char szMakeDir[_MAX_DIR];

    _splitpath(DirPath, szMakeDir, szDir, NULL, NULL);
    strcat(szMakeDir, szDir);

    p = szMakeDir;

    dw = GetFileAttributes(szMakeDir);
    if ( (dw != (DWORD) -1) && (dw & FILE_ATTRIBUTE_DIRECTORY) ) {
        // Directory already exists.
        return TRUE;
    }

    //  If the second character in the path is "\", then this is a UNC
    //  path, and we should skip forward until we reach the 2nd \ in the path.

    if ((*p == '\\') && (*(p+1) == '\\')) {
        p++;            // Skip over the first \ in the name.
        p++;            // Skip over the second \ in the name.

        //  Skip until we hit the first "\" (\\Server\).

        while (*p && *p != '\\') {
            p = p++;
        }

        // Advance over it.

        if (*p) {
            p++;
        }

        //  Skip until we hit the second "\" (\\Server\Share\).

        while (*p && *p != '\\') {
            p = p++;
        }

        // Advance over it also.

        if (*p) {
            p++;
        }

    } else
    // Not a UNC.  See if it's <drive>:
    if (*(p+1) == ':' ) {

        p++;
        p++;

        // If it exists, skip over the root specifier

        if (*p && (*p == '\\')) {
            p++;
        }
    }

    while( *p ) {
        if ( *p == '\\' ) {
            *p = '\0';
            dw = GetFileAttributes(szMakeDir);
            // Nothing exists with this name.  Try to make the directory name and error if unable to.
            if ( dw == 0xffffffff ) {
                if (strlen(szMakeDir)) {        // Don't try to md <empty string>
                    if ( !CreateDirectory(szMakeDir,NULL) ) {
                        if( GetLastError() != ERROR_ALREADY_EXISTS ) {
                            return FALSE;
                        }
                    }
                }
            } else {
                if ( (dw & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY ) {
                    // Something exists with this name, but it's not a directory... Error
                    return FALSE;
                }
            }

            *p = '\\';
        }
        p = p++;
    }

    return TRUE;
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    char *szSourceFile, *szDestFile, *szAlternateSourceFile;
    BOOL fCopyFile = 0, fDoCopy, fTimeStampsDiffer;
    int CopyErrorCode;

    if (argc < 3) {
        puts("pcopy <-d> <source file> <dest file>\n"
             "     -d switch: compare debug data\n"
             "        (by default, debug differences are ignored)\n"
             "Returns: -1 if no copy necessary (no material change to the files)\n"
             "          0 if a successful copy was made\n"
             "          otherwise the error code for why the copy was unsuccessful\n");
        return ((int)ERROR_INVALID_COMMAND_LINE);
    }

    if (argv[1][0] == '-' && argv[1][1] == 'd') {
        fCheckDebugData = TRUE;
        szSourceFile = argv[2];
        szDestFile = argv[3];
    } else {
        szSourceFile = argv[1];
        szDestFile = argv[2];
    }

    if (getenv("PCOPY_COMPARE_DEBUG")) {
        fCheckDebugData = TRUE;
    }

    szAlternateSourceFile = strstr(szSourceFile, "::");
    if (szAlternateSourceFile) {
        *szAlternateSourceFile = '\0';    // Null terminte szSourceFile
        szAlternateSourceFile+=2;           // Advance past the ::
    }

    fDoCopy = CheckIfCopyNecessary(szSourceFile, szDestFile, &fTimeStampsDiffer);

    if (fDoCopy) {
        DWORD dwAttributes;

CopyAlternate:

        dwAttributes = GetFileAttributes(szDestFile);

        if (dwAttributes != (DWORD) -1) {
            // Make sure it's not readonly
            SetFileAttributes(szDestFile, dwAttributes & ~FILE_ATTRIBUTE_READONLY);
        }

        // Make sure destination directory exists.
        MyMakeSureDirectoryPathExists(szDestFile);

        fCopyFile = CopyFileA(szSourceFile, szDestFile, FALSE);
        if (!fCopyFile) {
            CopyErrorCode = (int) GetLastError();
        } else {
            dwAttributes = GetFileAttributes(szDestFile);

            if (dwAttributes != (DWORD) -1) {
                // Make sure the dest is read/write
                SetFileAttributes(szDestFile, dwAttributes & ~FILE_ATTRIBUTE_READONLY);
            }

            CopyErrorCode = 0;
        }
        if (!CopyErrorCode && szAlternateSourceFile) {
            CHAR Drive[_MAX_DRIVE];
            CHAR Dir[_MAX_DIR];
            CHAR FileName[_MAX_FNAME];
            CHAR Ext[_MAX_EXT];
            CHAR NewDest[_MAX_PATH];

            _splitpath(szDestFile, Drive, Dir, NULL, NULL);
            _splitpath(szAlternateSourceFile, NULL, NULL, FileName, Ext);
            _makepath(NewDest, Drive, Dir, FileName, Ext);
            szSourceFile = szAlternateSourceFile;
            szAlternateSourceFile=NULL;
            szDestFile=NewDest;
            goto CopyAlternate;
        }
    } else {
        CopyErrorCode = GetLastError();
        if (!CopyErrorCode && fTimeStampsDiffer) {
            // No copy necessary.  Touch the timestamp on the dest to match the source.
            UpdateDestTimeStamp(szSourceFile, szDestFile);
        }
    }

    LogCopyFile(szSourceFile, szDestFile, fDoCopy, CopyErrorCode);

    if (fDoCopy) {
        return CopyErrorCode;
    } else {
        return CopyErrorCode ? CopyErrorCode : -1;      // No copy necessary.
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\inc\pdhitype.h ===
/*++
Copyright (C) 1995-1999 Microsoft Corporation

Module Name:
    pdhitype.h

Abstract:
    data types used internally by the Data Provider Helper functions.
--*/

#ifndef _PDHI_TYPE_H_
#define _PDHI_TYPE_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <stdio.h>
#include "wbemdef.h"
#include "perftype.h"
#include "pdhicalc.h"

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4201 )

#define PDH_LOG_TYPE_RETIRED_BIN    3
#define PDH_INVALID_POINTER         ((LPVOID) -1)

typedef double  DOUBLE;

typedef struct _PDHI_LOG_MACHINE_NODE  PDHI_LOG_MACHINE,  * PPDHI_LOG_MACHINE;
typedef struct _PDHI_LOG_OBJECT_NODE   PDHI_LOG_OBJECT,   * PPDHI_LOG_OBJECT;
typedef struct _PDHI_LOG_COUNTER_NODE  PDHI_LOG_COUNTER,  * PPDHI_LOG_COUNTER;

struct _PDHI_LOG_MACHINE_NODE {
    PPDHI_LOG_MACHINE  next;
    PPDHI_LOG_OBJECT   ObjTable;
    PPDHI_LOG_OBJECT   ObjList;
    LPWSTR             szMachine;
    PPERF_DATA_BLOCK   pBlock;
    DWORD              dwIndex;
};

struct _PDHI_LOG_OBJECT_NODE {
    PPDHI_LOG_COUNTER  CtrTable;
    PPDHI_LOG_COUNTER  CtrList;
    PPDHI_LOG_COUNTER  InstTable;
    PPDHI_LOG_COUNTER  InstList;
    PPDHI_LOG_OBJECT   left;
    PPDHI_LOG_OBJECT   right;
    PPDHI_LOG_OBJECT   next;
    LPWSTR             szObject;
    PPERF_OBJECT_TYPE  pObjData;
    DWORD              dwObject;
    DWORD              dwIndex;
    BOOL               bIsRed;
    BOOL               bNeedExpand;
};

struct _PDHI_LOG_COUNTER_NODE {
    PPDHI_LOG_COUNTER  left;
    PPDHI_LOG_COUNTER  right;
    PPDHI_LOG_COUNTER  next;
    ULONGLONG          TimeStamp;
    LONGLONG           TimeBase;
    LPWSTR             szCounter;
    LPWSTR             szInstance;
    LPWSTR             szParent;
    LPDWORD            pCtrData;
    DWORD              dwCounterID;
    DWORD              dwCounterType;
    DWORD              dwDefaultScale;
    DWORD              dwInstance;
    DWORD              dwParent;
    BOOL               bIsRed;
    BOOL               bMultiInstance;
};

typedef struct _PDHI_MAPPED_LOG_FILE {
    struct _PDHI_MAPPED_LOG_FILE  * pNext;
    LPWSTR                          szLogFileName;
    HANDLE                          hFileHandle;
    HANDLE                          hMappedFile;
    LPVOID                          pData;
    DWORD                           dwRefCount;
    LONGLONG                        llFileSize;
} PDHI_MAPPED_LOG_FILE, * PPDHI_MAPPED_LOG_FILE;

// make signature into DWORDs to make this a little faster

#define SigQuery    ((DWORD)0x51484450)    // L"PDHQ"
#define SigCounter  ((DWORD)0x43484450)    // L"PDHC"
#define SigLog      ((DWORD)0x4C484450)    // L"PDHL"

typedef struct _PDHI_QUERY_MACHINE {
    PPERF_MACHINE                pMachine;     // pointer to the machine structure
    LPWSTR                       szObjectList; // list of objects to query on that machine
    PERF_DATA_BLOCK            * pPerfData;    // query's perf data block
    LONG                         lQueryStatus; // status of last perf query
    LONGLONG                     llQueryTime;  // timestamp from last query attempt
    struct _PDHI_QUERY_MACHINE * pNext;        // next machine in list
} PDHI_QUERY_MACHINE, * PPDHI_QUERY_MACHINE;

typedef struct _PDHI_COUNTER_PATH {
    LPWSTR  szMachineName;      // null = the local machine
    LPWSTR  szObjectName;
    LPWSTR  szInstanceName;     // NULL if no inst.
    LPWSTR  szParentName;       // points to name if instance has a parent
    DWORD   dwIndex;            // index (to support dup. names.) 0 = 1st inst.
    LPWSTR  szCounterName;
    BYTE    pBuffer[1];         // beginning of string buffer space
} PDHI_COUNTER_PATH, * PPDHI_COUNTER_PATH;

typedef struct _PDHI_RAW_COUNTER_ITEM {
    DWORD       szName;
    DWORD       MultiCount;
    LONGLONG    FirstValue;
    LONGLONG    SecondValue;
} PDHI_RAW_COUNTER_ITEM, * PPDHI_RAW_COUNTER_ITEM;

typedef struct _PDHI_RAW_COUNTER_ITEM_BLOCK {
    DWORD                   dwLength;
    DWORD                   dwItemCount;
    DWORD                   dwReserved;
    LONG                    CStatus;
    FILETIME                TimeStamp;
    PDHI_RAW_COUNTER_ITEM   pItemArray[1];
} PDHI_RAW_COUNTER_ITEM_BLOCK, * PPDHI_RAW_COUNTER_ITEM_BLOCK;

#define HASH_TABLE_SIZE 257

typedef struct _PDHI_INSTANCE {
    LIST_ENTRY Entry;
    FILETIME   TimeStamp;
    DWORD      dwTotal;
    DWORD      dwCount;
    LPWSTR     szInstance;
} PDHI_INSTANCE, * PPDHI_INSTANCE;

typedef struct _PDHI_INST_LIST {
    struct _PDHI_INST_LIST * pNext;
    LIST_ENTRY               InstList;
    LPWSTR                   szCounter;
} PDHI_INST_LIST, * PPDHI_INST_LIST;

typedef PPDHI_INST_LIST PDHI_COUNTER_TABLE[HASH_TABLE_SIZE];

typedef struct  _PDHI_QUERY_LIST {
    struct _PDHI_QUERY   * flink;
    struct _PDHI_QUERY   * blink;
} PDHI_QUERY_LIST, * PPDHI_QUERY_LIST;

typedef struct  _PDHI_COUNTER_LIST {
    struct _PDHI_COUNTER * flink;
    struct _PDHI_COUNTER * blink;
} PDHI_COUNTER_LIST, * PPDHI_COUNTER_LIST;

typedef struct  _PDHI_LOG_LIST {
    struct _PDHI_LOG     * flink;
    struct _PDHI_LOG     * blink;
} PDHI_LOG_LIST, * PPDHI_LOG_LIST;

typedef struct _PDHI_COUNTER {
    CHAR                           signature[4];     // should be "PDHC" for counters
    DWORD                          dwLength;         // length of this structure
    struct _PDHI_QUERY           * pOwner;           // pointer to owning query
    LPWSTR                         szFullName;       // full counter path string
    PDHI_COUNTER_LIST              next;             // list links
    DWORD                          dwUserData;       // user defined DWORD
    LONG                           lScale;           // integer scale exponent
    DWORD                          CVersion;         // system perfdata version
    DWORD                          dwFlags;          // flags
    PPDHI_QUERY_MACHINE            pQMachine;        // pointer to the machine structure
    PPDHI_COUNTER_PATH             pCounterPath;     // parsed counter path
    PDH_RAW_COUNTER                ThisValue;        // most recent value
    PDH_RAW_COUNTER                LastValue;        // previous value
    LPWSTR                         szExplainText;    // pointer to the explain text buffer
    LPCOUNTERCALC                  CalcFunc;         // pointer to the calc function
    LPCOUNTERSTAT                  StatFunc;         // pointer to the statistics function
    PPDHI_RAW_COUNTER_ITEM_BLOCK   pThisRawItemList; // pointer to current data set
    PPDHI_RAW_COUNTER_ITEM_BLOCK   pLastRawItemList; // pointer to previous data set
    PPERF_DATA_BLOCK               pThisObject;
    PPERF_DATA_BLOCK               pLastObject;
    DWORD                          dwIndex;
    LONGLONG                       TimeBase;         // freq. of timer used by this counter
    PERFLIB_COUNTER                plCounterInfo;    // perflib specific counter data
    IWbemClassObject             * pWbemObject;      // refreshable Object pointer
    LONG                           lWbemRefreshId;   // reffrshable ID
    IWbemObjectAccess            * pWbemAccess;      // data access Object pointer
    IWbemHiPerfEnum              * pWbemEnum;        // interface for wildcard instance queries
    LONG                           lNameHandle;      // handle for name property
    LONG                           lWbemEnumId;      // id for wbem enumerator
    LONG                           lNumItemHandle;   // handle of Numerator Property
    LONG                           lNumItemType;     // WBEM Data type of numerator value
    LONG                           lDenItemHandle;   // handle of Denominator Property
    LONG                           lDenItemType;     // WBEM Data type of Denominator value
    LONG                           lFreqItemHandle;  // handle of Timebase Freq Property
    LONG                           lFreqItemType;    // WBEM Data type of Timebase Freqvalue
    PVOID                        pBTreeNode;
} PDHI_COUNTER, * PPDHI_COUNTER;

// flags for the PDHI_COUNTER data structure.
#define  PDHIC_MULTI_INSTANCE       ((DWORD) 0x00000001)
#define  PDHIC_ASYNC_TIMER          ((DWORD) 0x00000002)
#define  PDHIC_WBEM_COUNTER         ((DWORD) 0x00000004)
#define  PDHIC_COUNTER_BLOCK        ((DWORD) 0x00000008)
#define  PDHIC_COUNTER_OBJECT       ((DWORD) 0x00000010)
#define  PDHIC_COUNTER_NOT_INIT     ((DWORD) 0x80000000)
#define  PDHIC_COUNTER_INVALID      ((DWORD) 0x40000000)
#define  PDHIC_COUNTER_UNUSABLE     ((DWORD) 0xC0000000)

typedef struct  _PDHI_QUERY {
    CHAR                              signature[4];     // should be "PDHQ" for queries
    PDHI_QUERY_LIST                   next;             // pointer to next query in list
    PPDHI_COUNTER                     pCounterListHead; // pointer to first counter in list
    DWORD                             dwLength;         // length of this structure
    DWORD_PTR                         dwUserData;
    DWORD                             dwInterval;       // interval in seconds
    DWORD                             dwFlags;          // notification flags
    PDH_TIME_INFO                     TimeRange;        // query time range
    HLOG                              hLog;             // handle to log file (for data source)
    HLOG                              hOutLog;          // Log handle for output logfile (to write query result)
    DWORD                             dwReleaseLog;
    DWORD                             dwLastLogIndex;   // the last log record returned to a Get Value call
    HANDLE                            hMutex;           // mutex to sync changes to data.
    HANDLE                            hNewDataEvent;    // handle to event that is sent when data is collected
    HANDLE                            hAsyncThread;     // thread handle for async collection
    HANDLE                            hExitEvent;       // event to set for thread to terminate
    union {
        struct {
            PPDHI_QUERY_MACHINE       pFirstQMachine;   // pointer to first machine in list
        };
        struct {
            IWbemRefresher          * pRefresher;       // WBEM Refresher interface ptr
            IWbemConfigureRefresher * pRefresherCfg;    // WBEM Ref. Config interface ptr.
            LANGID                    LangID;           // Language code for strings
        };
    };
} PDHI_QUERY, * PPDHI_QUERY;

#define  PDHIQ_WBEM_QUERY  ((DWORD) 0x00000004)

typedef struct _PDHI_LOG {
    CHAR               signature[4];         // should be "PDHL" for log entries
    PDHI_LOG_LIST      next;                 // links to next and previous entries
    struct _PDHI_LOG * NextLog;              // next log entry for multiple WMI logfile open
    HANDLE             hLogMutex;            // sync mutex to serialize modifications to the structure
    DWORD              dwLength;             // the size of this structure
    LPWSTR             szLogFileName;        // full file name for this log file
    HANDLE             hLogFileHandle;       // handle to open log file
    HANDLE             hMappedLogFile;       // handle for memory mapped files
    LPVOID             lpMappedFileBase;     // starting address for mapped log file
    FILE             * StreamFile;           // stream pointer for text files
    LONGLONG           llFileSize;           // file size (used only for reading)
    DWORD              dwRecord1Size;        // size of ID record in BLG files, not used by text files
    DWORD              dwLastRecordRead;     // index of last record read from the file
    LPVOID             pLastRecordRead;      // pointer to buffer containing the last record
    LPWSTR             szCatFileName;        // catalog file name
    HANDLE             hCatFileHandle;       // handle to the open catalog file
    PPDHI_QUERY        pQuery;               // pointer to the query associated with the log
    LONGLONG           llMaxSize;            // max size of a circular log file
    DWORD              dwLogFormat;          // log type and access flags
    DWORD              dwMaxRecordSize;      // size of longest record in log
    PVOID              pPerfmonInfo;         // used when reading perfmon logs
    LARGE_INTEGER      liLastRecordOffset;   // offset to last record read
    GUID               guidSQL;              // GUID associated with the dataset
    int                iRunidSQL;            // Integer RunID associated with the dataset
    void             * henvSQL;              // HENV environment handle for to SQL
    void             * hdbcSQL;              // HDBC odbc connection handle for SQL
    LPWSTR             szDSN;                // pointer to Data Source Name within LogFileName (separators replaced with 0's)
    LPWSTR             szCommentSQL;          // pointer to the Comment string that defines the name of the data set within the SQL database
    DWORD              dwNextRecordIdToWrite; // next record number to write
} PDHI_LOG, * PPDHI_LOG;

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning ( default : 4201 )
#endif


#ifdef __cplusplus
}
#endif
#endif // _PDH_TYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pcopy\metadata.h ===
extern const GUID __declspec(selectany) CLSID_CorMetaDataDispenser = 
{ 0xe5cb7a31, 0x7512, 0x11d2, { 0x89, 0xce, 0x0, 0x80, 0xc7, 0x92, 0xe5, 0xd8 } };

extern const GUID __declspec(selectany) IID_IMetaDataDispenser =
{ 0x809c652e, 0x7396, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };

extern const GUID __declspec(selectany) IID_IMetaDataImport = 
{ 0x7dac8207, 0xd3ae, 0x4c75, { 0x9b, 0x67, 0x92, 0x80, 0x1a, 0x49, 0x7d, 0x44 } };

extern const GUID __declspec(selectany) IID_IMetaDataAssemblyImport = 
{ 0xee62470b, 0xe94b, 0x424e, { 0x9b, 0x7c, 0x2f, 0x0, 0xc9, 0x24, 0x9f, 0x93 } };

typedef PVOID HCORENUM;
typedef DWORD mdAssembly;
typedef DWORD mdAssemblyRef;
typedef DWORD mdFile;
typedef DWORD mdExportedType;
typedef DWORD mdToken;
typedef DWORD mdTypeDef;
typedef DWORD mdManifestResource;
typedef DWORD mdInterfaceImpl;
typedef DWORD mdTypeRef;

#undef  INTERFACE   
#define INTERFACE IMetaDataAssemblyImport
DECLARE_INTERFACE_(IMetaDataAssemblyImport, IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_
                               REFIID riid,
                               LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(GetAssemblyProps)(            // S_OK or error.
        THIS_
        mdAssembly  mda,                    // [IN] The Assembly for which to get the properties.
        const void  **ppbPublicKey,         // [OUT] Pointer to the public key.
        ULONG       *pcbPublicKey,          // [OUT] Count of bytes in the public key.
        ULONG       *pulHashAlgId,          // [OUT] Hash Algorithm.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        void        *pMetaData,        // [OUT] Assembly MetaData.
        DWORD       *pdwAssemblyFlags) PURE;    // [OUT] Flags.

    STDMETHOD(GetAssemblyRefProps)(         // S_OK or error.
        THIS_
        mdAssemblyRef mdar,                 // [IN] The AssemblyRef for which to get the properties.
        const void  **ppbPublicKeyOrToken,  // [OUT] Pointer to the public key or token.
        ULONG       *pcbPublicKeyOrToken,   // [OUT] Count of bytes in the public key or token.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        void        *pMetaData,        // [OUT] Assembly MetaData.
        const void  **ppbHashValue,         // [OUT] Hash blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the hash blob.
        DWORD       *pdwAssemblyRefFlags) PURE; // [OUT] Flags.

    STDMETHOD(GetFileProps)(                // S_OK or error.
        THIS_
        mdFile      mdf,                    // [IN] The File for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        const void  **ppbHashValue,         // [OUT] Pointer to the Hash Value Blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the Hash Value Blob.
        DWORD       *pdwFileFlags) PURE;    // [OUT] Flags.

    STDMETHOD(GetExportedTypeProps)(             // S_OK or error.
        THIS_
        mdExportedType   mdct,                   // [IN] The ExportedType for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef or mdExportedType.
        mdTypeDef   *ptkTypeDef,            // [OUT] TypeDef token within the file.
        DWORD       *pdwExportedTypeFlags) PURE; // [OUT] Flags.

    STDMETHOD(GetManifestResourceProps)(    // S_OK or error.
        THIS_
        mdManifestResource  mdmr,           // [IN] The ManifestResource for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ManifestResource.
        DWORD       *pdwOffset,             // [OUT] Offset to the beginning of the resource within the file.
        DWORD       *pdwResourceFlags) PURE;// [OUT] Flags.

    STDMETHOD(EnumAssemblyRefs)(            // S_OK or error
        THIS_
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdAssemblyRef rAssemblyRefs[],      // [OUT] Put AssemblyRefs here.
        ULONG       cMax,                   // [IN] Max AssemblyRefs to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumFiles)(                   // S_OK or error
        THIS_
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdFile      rFiles[],               // [OUT] Put Files here.
        ULONG       cMax,                   // [IN] Max Files to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.
};

#undef  INTERFACE   
#define INTERFACE IMetaDataImport
DECLARE_INTERFACE_(IMetaDataImport, IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_
                               REFIID riid,
                               LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD_(void, CloseEnum)(THIS_ HCORENUM hEnum) PURE;
    STDMETHOD(CountEnum)(THIS_ HCORENUM hEnum, ULONG *pulCount) PURE;
    STDMETHOD(ResetEnum)(THIS_ HCORENUM hEnum, ULONG ulPos) PURE;
    STDMETHOD(EnumTypeDefs)(THIS_ HCORENUM *phEnum, mdTypeDef rTypeDefs[],
                            ULONG cMax, ULONG *pcTypeDefs) PURE;
    STDMETHOD(EnumInterfaceImpls)(THIS_ HCORENUM *phEnum, mdTypeDef td,
                            mdInterfaceImpl rImpls[], ULONG cMax,
                            ULONG* pcImpls) PURE;
    STDMETHOD(EnumTypeRefs)(THIS_ HCORENUM *phEnum, mdTypeRef rTypeRefs[],
                            ULONG cMax, ULONG* pcTypeRefs) PURE;

    STDMETHOD(FindTypeDefByName)(           // S_OK or error.
        THIS_
        LPCWSTR     szTypeDef,              // [IN] Name of the Type.
        mdToken     tkEnclosingClass,       // [IN] TypeDef/TypeRef for Enclosing class.
        mdTypeDef   *ptd) PURE;             // [OUT] Put the TypeDef token here.

    STDMETHOD(GetScopeProps)(               // S_OK or error.
        THIS_
        LPWSTR      szName,                 // [OUT] Put the name here.
        ULONG       cchName,                // [IN] Size of name buffer in wide chars.
        ULONG       *pchName,               // [OUT] Put size of name (wide chars) here.
        GUID        *pmvid) PURE;           // [OUT, OPTIONAL] Put MVID here.
};

#undef  INTERFACE
#define INTERFACE IMetaDataDispenser
DECLARE_INTERFACE_(IMetaDataDispenser, IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_
                               REFIID riid,
                               LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(DefineScope)(                 // Return code.
        THIS_
        REFCLSID    rclsid,                 // [in] What version to create.
        DWORD       dwCreateFlags,          // [in] Flags on the create.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.

    STDMETHOD(OpenScope)(                   // Return code.
        THIS_
        LPCWSTR     szScope,                // [in] The scope to open.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.

    STDMETHOD(OpenScopeOnMemory)(           // Return code.
        THIS_
        LPCVOID     pData,                  // [in] Location of scope data.
        ULONG       cbData,                 // [in] Size of the data pointed to by pData.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\inc\pdh.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PDH.H

Abstract:

    Header file for the Performance Data Helper (PDH) DLL functions.

--*/
#ifndef _PDH_H_
#define _PDH_H_

#if _MSC_VER > 1000
#pragma once
#endif

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4201)

// system include files required for datatype and constant definitions
#include <windows.h>    // necessary for data types used in this file
#include <winperf.h>    // necessary for the Detail Level definitions

#ifdef __cplusplus
extern "C" {
#endif

typedef LONG            PDH_STATUS;

#define PDH_FUNCTION    PDH_STATUS __stdcall

// version info
#define PDH_CVERSION_WIN40  ((DWORD)(0x0400))
#define PDH_CVERSION_WIN50  ((DWORD)(0x0500))
// v1.1 revision of PDH -- basic log functions
// v1.2 of the PDH -- adds variable instance counters
// v1.3 of the PDH -- adds log service control & stubs for NT5/PDH v2 fn's
// v2.0 of the PDH -- is the NT v 5.0 B2 version
#define PDH_VERSION         ((DWORD)((PDH_CVERSION_WIN50) + 0x0003))

// define severity masks
#define IsSuccessSeverity(ErrorCode)       ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0x00000000L) ? TRUE : FALSE)
#define IsInformationalSeverity(ErrorCode) ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0x40000000L) ? TRUE : FALSE)
#define IsWarningSeverity(ErrorCode)       ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0x80000000L) ? TRUE : FALSE)
#define IsErrorSeverity(ErrorCode)         ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0xC0000000L) ? TRUE : FALSE)

#define MAX_COUNTER_PATH       256  // Maximum counter path length. This is an obsolute constance.

#define PDH_MAX_COUNTER_NAME    1024  // Maximum counter name length.
#define PDH_MAX_INSTANCE_NAME   1024  // Maximum counter instance name length.
#define PDH_MAX_COUNTER_PATH    2048  // Maximum full counter path length.
#define PDH_MAX_DATASOURCE_PATH 1024  // MAximum full counter log name length.

// data type definitions

typedef HANDLE       PDH_HCOUNTER;
typedef HANDLE       PDH_HQUERY;
typedef HANDLE       PDH_HLOG;

typedef PDH_HCOUNTER HCOUNTER;
typedef PDH_HQUERY   HQUERY;
#ifndef _LMHLOGDEFINED_
typedef PDH_HLOG     HLOG;
#endif

#ifdef INVALID_HANDLE_VALUE
#undef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE  ((HANDLE)((LONG_PTR)-1))
#endif

#define H_REALTIME_DATASOURCE NULL
#define H_WBEM_DATASOURCE     INVALID_HANDLE_VALUE

typedef struct _PDH_RAW_COUNTER {
    DWORD       CStatus;
    FILETIME    TimeStamp;
    LONGLONG    FirstValue;
    LONGLONG    SecondValue;
    DWORD       MultiCount;
} PDH_RAW_COUNTER, * PPDH_RAW_COUNTER;

typedef struct _PDH_RAW_COUNTER_ITEM_A {
    LPSTR           szName;
    PDH_RAW_COUNTER RawValue;
} PDH_RAW_COUNTER_ITEM_A, * PPDH_RAW_COUNTER_ITEM_A;

typedef struct _PDH_RAW_COUNTER_ITEM_W {
    LPWSTR          szName;
    PDH_RAW_COUNTER RawValue;
} PDH_RAW_COUNTER_ITEM_W, * PPDH_RAW_COUNTER_ITEM_W;

typedef struct _PDH_FMT_COUNTERVALUE {
    DWORD    CStatus;
    union {
        LONG        longValue;
        double      doubleValue;
        LONGLONG    largeValue;
        LPCSTR      AnsiStringValue;
        LPCWSTR     WideStringValue;
    };
} PDH_FMT_COUNTERVALUE, * PPDH_FMT_COUNTERVALUE;

typedef struct _PDH_FMT_COUNTERVALUE_ITEM_A {
    LPSTR                   szName;
    PDH_FMT_COUNTERVALUE    FmtValue;
} PDH_FMT_COUNTERVALUE_ITEM_A, * PPDH_FMT_COUNTERVALUE_ITEM_A;

typedef struct _PDH_FMT_COUNTERVALUE_ITEM_W {
    LPWSTR                  szName;
    PDH_FMT_COUNTERVALUE    FmtValue;
} PDH_FMT_COUNTERVALUE_ITEM_W, * PPDH_FMT_COUNTERVALUE_ITEM_W;

typedef struct _PDH_STATISTICS {
    DWORD                   dwFormat;
    DWORD                   count;
    PDH_FMT_COUNTERVALUE    min;
    PDH_FMT_COUNTERVALUE    max;
    PDH_FMT_COUNTERVALUE    mean;
} PDH_STATISTICS, * PPDH_STATISTICS;

typedef struct _PDH_COUNTER_PATH_ELEMENTS_A {
    LPSTR   szMachineName;
    LPSTR   szObjectName;
    LPSTR   szInstanceName;
    LPSTR   szParentInstance;
    DWORD   dwInstanceIndex;
    LPSTR   szCounterName;
} PDH_COUNTER_PATH_ELEMENTS_A, * PPDH_COUNTER_PATH_ELEMENTS_A;

typedef struct _PDH_COUNTER_PATH_ELEMENTS_W {
    LPWSTR  szMachineName;
    LPWSTR  szObjectName;
    LPWSTR  szInstanceName;
    LPWSTR  szParentInstance;
    DWORD   dwInstanceIndex;
    LPWSTR  szCounterName;
} PDH_COUNTER_PATH_ELEMENTS_W, * PPDH_COUNTER_PATH_ELEMENTS_W;

typedef struct _PDH_DATA_ITEM_PATH_ELEMENTS_A {
    LPSTR   szMachineName;
    GUID    ObjectGUID;
    DWORD   dwItemId;
    LPSTR   szInstanceName;
} PDH_DATA_ITEM_PATH_ELEMENTS_A, * PPDH_DATA_ITEM_PATH_ELEMENTS_A;

typedef struct _PDH_DATA_ITEM_PATH_ELEMENTS_W {
    LPWSTR  szMachineName;
    GUID    ObjectGUID;
    DWORD   dwItemId;
    LPWSTR  szInstanceName;
} PDH_DATA_ITEM_PATH_ELEMENTS_W, * PPDH_DATA_ITEM_PATH_ELEMENTS_W;

typedef struct _PDH_COUNTER_INFO_A {
    DWORD   dwLength;
    DWORD   dwType;
    DWORD   CVersion;
    DWORD   CStatus;
    LONG    lScale;
    LONG    lDefaultScale;
    DWORD_PTR   dwUserData;
    DWORD_PTR   dwQueryUserData;
    LPSTR   szFullPath;
    union   {
        PDH_DATA_ITEM_PATH_ELEMENTS_A DataItemPath;
        PDH_COUNTER_PATH_ELEMENTS_A CounterPath;
        struct {
            LPSTR   szMachineName;
            LPSTR   szObjectName;
            LPSTR   szInstanceName;
            LPSTR   szParentInstance;
            DWORD   dwInstanceIndex;
            LPSTR   szCounterName;
        };
    };
    LPSTR   szExplainText;
    DWORD   DataBuffer[1];
} PDH_COUNTER_INFO_A, * PPDH_COUNTER_INFO_A;

typedef struct _PDH_COUNTER_INFO_W {
    DWORD   dwLength;
    DWORD   dwType;
    DWORD   CVersion;
    DWORD   CStatus;
    LONG    lScale;
    LONG    lDefaultScale;
    DWORD_PTR   dwUserData;
    DWORD_PTR   dwQueryUserData;
    LPWSTR  szFullPath;
    union   {
        PDH_DATA_ITEM_PATH_ELEMENTS_W DataItemPath;
        PDH_COUNTER_PATH_ELEMENTS_W CounterPath;
        struct {
            LPWSTR   szMachineName;
            LPWSTR   szObjectName;
            LPWSTR   szInstanceName;
            LPWSTR   szParentInstance;
            DWORD    dwInstanceIndex;
            LPWSTR   szCounterName;
        };
    };
    LPWSTR  szExplainText;
    DWORD   DataBuffer[1];
} PDH_COUNTER_INFO_W, * PPDH_COUNTER_INFO_W;

typedef struct _PDH_TIME_INFO {
    LONGLONG    StartTime;
    LONGLONG    EndTime;
    DWORD       SampleCount;
} PDH_TIME_INFO, * PPDH_TIME_INFO;

typedef struct _PDH_RAW_LOG_RECORD {
    DWORD       dwStructureSize;
    DWORD       dwRecordType;
    DWORD       dwItems;
    UCHAR       RawBytes[1];
} PDH_RAW_LOG_RECORD, * PPDH_RAW_LOG_RECORD;

typedef struct _PDH_LOG_SERVICE_QUERY_INFO_A {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwLogQuota;
    LPSTR   szLogFileCaption;
    LPSTR   szDefaultDir;
    LPSTR   szBaseFileName;
    DWORD   dwFileType;
    DWORD   dwReserved;
    union {
        struct {
            DWORD   PdlAutoNameInterval;
            DWORD   PdlAutoNameUnits;
            LPSTR   PdlCommandFilename;
            LPSTR   PdlCounterList;
            DWORD   PdlAutoNameFormat;
            DWORD   PdlSampleInterval;
            FILETIME    PdlLogStartTime;
            FILETIME    PdlLogEndTime;
        };
        struct {
            DWORD   TlNumberOfBuffers;
            DWORD   TlMinimumBuffers;
            DWORD   TlMaximumBuffers;
            DWORD   TlFreeBuffers;
            DWORD   TlBufferSize;
            DWORD   TlEventsLost;
            DWORD   TlLoggerThreadId;
            DWORD   TlBuffersWritten;
            DWORD   TlLogHandle;
            LPSTR   TlLogFileName;
        };
    };
} PDH_LOG_SERVICE_QUERY_INFO_A, * PPDH_LOG_SERVICE_QUERY_INFO_A;

typedef struct _PDH_LOG_SERVICE_QUERY_INFO_W {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwLogQuota;
    LPWSTR  szLogFileCaption;
    LPWSTR  szDefaultDir;
    LPWSTR  szBaseFileName;
    DWORD   dwFileType;
    DWORD   dwReserved;
    union {
        struct {
            DWORD   PdlAutoNameInterval;
            DWORD   PdlAutoNameUnits;
            LPWSTR  PdlCommandFilename;
            LPWSTR  PdlCounterList;
            DWORD   PdlAutoNameFormat;
            DWORD   PdlSampleInterval;
            FILETIME    PdlLogStartTime;
            FILETIME    PdlLogEndTime;
        };
        struct {
            DWORD   TlNumberOfBuffers;
            DWORD   TlMinimumBuffers;
            DWORD   TlMaximumBuffers;
            DWORD   TlFreeBuffers;
            DWORD   TlBufferSize;
            DWORD   TlEventsLost;
            DWORD   TlLoggerThreadId;
            DWORD   TlBuffersWritten;
            DWORD   TlLogHandle;
            LPWSTR  TlLogFileName;
        };
    };
} PDH_LOG_SERVICE_QUERY_INFO_W, * PPDH_LOG_SERVICE_QUERY_INFO_W;

//
//  Time value constants
//
#define MAX_TIME_VALUE ((LONGLONG) 0x7FFFFFFFFFFFFFFF)
#define MIN_TIME_VALUE ((LONGLONG) 0)

// function definitions

PDH_FUNCTION
PdhGetDllVersion(
    IN  LPDWORD lpdwVersion
);

//
//  Query Functions
//

PDH_FUNCTION
PdhOpenQueryW(
    IN  LPCWSTR      szDataSource,
    IN  DWORD_PTR    dwUserData,
    IN  PDH_HQUERY * phQuery
);

PDH_FUNCTION
PdhOpenQueryA(
    IN  LPCSTR       szDataSource,
    IN  DWORD_PTR    dwUserData,
    IN  PDH_HQUERY * phQuery
);

PDH_FUNCTION
PdhAddCounterW(
    IN  PDH_HQUERY     hQuery,
    IN  LPCWSTR        szFullCounterPath,
    IN  DWORD_PTR      dwUserData,
    IN  PDH_HCOUNTER * phCounter
);

PDH_FUNCTION
PdhAddCounterA(
    IN  PDH_HQUERY     hQuery,
    IN  LPCSTR         szFullCounterPath,
    IN  DWORD_PTR      dwUserData,
    IN  PDH_HCOUNTER * phCounter
);

PDH_FUNCTION
PdhRemoveCounter(
    IN  PDH_HCOUNTER hCounter
);

PDH_FUNCTION
PdhCollectQueryData(
    IN  PDH_HQUERY hQuery
);

PDH_FUNCTION
PdhCloseQuery(
    IN  PDH_HQUERY hQuery
);

//
//  Counter Functions
//

PDH_FUNCTION
PdhGetFormattedCounterValue(
    IN  PDH_HCOUNTER          hCounter,
    IN  DWORD                 dwFormat,
    IN  LPDWORD               lpdwType,
    IN  PPDH_FMT_COUNTERVALUE pValue
);

PDH_FUNCTION
PdhGetFormattedCounterArrayA(
    IN  PDH_HCOUNTER                 hCounter,
    IN  DWORD                        dwFormat,
    IN  LPDWORD                      lpdwBufferSize,
    IN  LPDWORD                      lpdwItemCount,
    IN  PPDH_FMT_COUNTERVALUE_ITEM_A ItemBuffer
);

PDH_FUNCTION
PdhGetFormattedCounterArrayW(
    IN  PDH_HCOUNTER                 hCounter,
    IN  DWORD                        dwFormat,
    IN  LPDWORD                      lpdwBufferSize,
    IN  LPDWORD                      lpdwItemCount,
    IN  PPDH_FMT_COUNTERVALUE_ITEM_W ItemBuffer
);

// dwFormat flag values
//
#define PDH_FMT_RAW          ((DWORD) 0x00000010)
#define PDH_FMT_ANSI         ((DWORD) 0x00000020)
#define PDH_FMT_UNICODE      ((DWORD) 0x00000040)
#define PDH_FMT_LONG         ((DWORD) 0x00000100)
#define PDH_FMT_DOUBLE       ((DWORD) 0x00000200)
#define PDH_FMT_LARGE        ((DWORD) 0x00000400)
#define PDH_FMT_NOSCALE      ((DWORD) 0x00001000)
#define PDH_FMT_1000         ((DWORD) 0x00002000)
#define PDH_FMT_NODATA       ((DWORD) 0x00004000)
#define PDH_FMT_NOCAP100     ((DWORD) 0x00008000)
#define PERF_DETAIL_COSTLY   ((DWORD) 0x00010000)
#define PERF_DETAIL_STANDARD ((DWORD) 0x0000FFFF)

PDH_FUNCTION
PdhGetRawCounterValue(
    IN  PDH_HCOUNTER      hCounter,
    IN  LPDWORD           lpdwType,
    IN  PPDH_RAW_COUNTER  pValue
);

PDH_FUNCTION
PdhGetRawCounterArrayA(
    IN  PDH_HCOUNTER            hCounter,
    IN  LPDWORD                 lpdwBufferSize,
    IN  LPDWORD                 lpdwItemCount,
    IN  PPDH_RAW_COUNTER_ITEM_A ItemBuffer
);

PDH_FUNCTION
PdhGetRawCounterArrayW(
    IN  PDH_HCOUNTER            hCounter,
    IN  LPDWORD                 lpdwBufferSize,
    IN  LPDWORD                 lpdwItemCount,
    IN  PPDH_RAW_COUNTER_ITEM_W ItemBuffer
);

PDH_FUNCTION
PdhCalculateCounterFromRawValue(
    IN  PDH_HCOUNTER          hCounter,
    IN  DWORD                 dwFormat,
    IN  PPDH_RAW_COUNTER      rawValue1,
    IN  PPDH_RAW_COUNTER      rawValue2,
    IN  PPDH_FMT_COUNTERVALUE fmtValue
);

PDH_FUNCTION
PdhComputeCounterStatistics(
    IN  PDH_HCOUNTER     hCounter,
    IN  DWORD            dwFormat,
    IN  DWORD            dwFirstEntry,
    IN  DWORD            dwNumEntries,
    IN  PPDH_RAW_COUNTER lpRawValueArray,
    IN  PPDH_STATISTICS  data
);

PDH_FUNCTION
PdhGetCounterInfoW(
    IN  PDH_HCOUNTER        hCounter,
    IN  BOOLEAN             bRetrieveExplainText,
    IN  LPDWORD             pdwBufferSize,
    IN  PPDH_COUNTER_INFO_W lpBuffer
);

PDH_FUNCTION
PdhGetCounterInfoA(
    IN  PDH_HCOUNTER        hCounter,
    IN  BOOLEAN             bRetrieveExplainText,
    IN  LPDWORD             pdwBufferSize,
    IN  PPDH_COUNTER_INFO_A lpBuffer
);

#define PDH_MAX_SCALE  (7L)
#define PDH_MIN_SCALE (-7L)

PDH_FUNCTION
PdhSetCounterScaleFactor(
    IN  PDH_HCOUNTER hCounter,
    IN  LONG         lFactor
);
//
//   Browsing and enumeration functions
//
PDH_FUNCTION
PdhConnectMachineW(
    IN  LPCWSTR szMachineName
);

PDH_FUNCTION
PdhConnectMachineA(
    IN  LPCSTR szMachineName
);

PDH_FUNCTION
PdhEnumMachinesW(
    IN  LPCWSTR szDataSource,
    IN  LPWSTR  mszMachineList,
    IN  LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhEnumMachinesA(
    IN  LPCSTR  szDataSource,
    IN  LPSTR   mszMachineList,
    IN  LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhEnumObjectsW(
    IN  LPCWSTR szDataSource,
    IN  LPCWSTR szMachineName,
    IN  LPWSTR  mszObjectList,
    IN  LPDWORD pcchBufferSize,
    IN  DWORD   dwDetailLevel,
    IN  BOOL    bRefresh
);

PDH_FUNCTION
PdhEnumObjectsA(
    IN  LPCSTR  szDataSource,
    IN  LPCSTR  szMachineName,
    IN  LPSTR   mszObjectList,
    IN  LPDWORD pcchBufferSize,
    IN  DWORD   dwDetailLevel,
    IN  BOOL    bRefresh
);

PDH_FUNCTION
PdhEnumObjectItemsW(
    IN  LPCWSTR szDataSource,
    IN  LPCWSTR szMachineName,
    IN  LPCWSTR szObjectName,
    IN  LPWSTR  mszCounterList,
    IN  LPDWORD pcchCounterListLength,
    IN  LPWSTR  mszInstanceList,
    IN  LPDWORD pcchInstanceListLength,
    IN  DWORD   dwDetailLevel,
    IN  DWORD   dwFlags
);

PDH_FUNCTION
PdhEnumObjectItemsA(
    IN  LPCSTR  szDataSource,
    IN  LPCSTR  szMachineName,
    IN  LPCSTR  szObjectName,
    IN  LPSTR   mszCounterList,
    IN  LPDWORD pcchCounterListLength,
    IN  LPSTR   mszInstanceList,
    IN  LPDWORD pcchInstanceListLength,
    IN  DWORD   dwDetailLevel,
    IN  DWORD   dwFlags
);

#define PDH_OBJECT_HAS_INSTANCES    ((DWORD) 0x00000001)

PDH_FUNCTION
PdhMakeCounterPathW(
    IN  PPDH_COUNTER_PATH_ELEMENTS_W pCounterPathElements,
    IN  LPWSTR                       szFullPathBuffer,
    IN  LPDWORD                      pcchBufferSize,
    IN  DWORD                        dwFlags
);

PDH_FUNCTION
PdhMakeCounterPathA(
    IN  PPDH_COUNTER_PATH_ELEMENTS_A pCounterPathElements,
    IN  LPSTR                        szFullPathBuffer,
    IN  LPDWORD                      pcchBufferSize,
    IN  DWORD                        dwFlags
);

PDH_FUNCTION
PdhParseCounterPathW(
    IN  LPCWSTR                      szFullPathBuffer,
    IN  PPDH_COUNTER_PATH_ELEMENTS_W pCounterPathElements,
    IN  LPDWORD                      pdwBufferSize,
    IN  DWORD                        dwFlags
);

PDH_FUNCTION
PdhParseCounterPathA(
    IN  LPCSTR                       szFullPathBuffer,
    IN  PPDH_COUNTER_PATH_ELEMENTS_A pCounterPathElements,
    IN  LPDWORD                      pdwBufferSize,
    IN  DWORD                        dwFlags
);

#define PDH_PATH_WBEM_RESULT ((DWORD) 0x00000001)
#define PDH_PATH_WBEM_INPUT  ((DWORD) 0x00000002)

#define PDH_PATH_LANG_FLAGS(LangId, Flags)  ((DWORD)(((LangId & 0x0000FFFF) << 16) | (Flags & 0x0000FFFF)))

PDH_FUNCTION
PdhParseInstanceNameW(
    IN  LPCWSTR szInstanceString,
    IN  LPWSTR  szInstanceName,
    IN  LPDWORD pcchInstanceNameLength,
    IN  LPWSTR  szParentName,
    IN  LPDWORD pcchParentNameLength,
    IN  LPDWORD lpIndex
);

PDH_FUNCTION
PdhParseInstanceNameA(
    IN  LPCSTR  szInstanceString,
    IN  LPSTR   szInstanceName,
    IN  LPDWORD pcchInstanceNameLength,
    IN  LPSTR   szParentName,
    IN  LPDWORD pcchParentNameLength,
    IN  LPDWORD lpIndex
);

PDH_FUNCTION
PdhValidatePathW(
    IN  LPCWSTR szFullPathBuffer
);

PDH_FUNCTION
PdhValidatePathA(
    IN  LPCSTR szFullPathBuffer
);

PDH_FUNCTION
PdhGetDefaultPerfObjectW(
    IN  LPCWSTR szDataSource,
    IN  LPCWSTR szMachineName,
    IN  LPWSTR  szDefaultObjectName,
    IN  LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfObjectA(
    IN  LPCSTR  szDataSource,
    IN  LPCSTR  szMachineName,
    IN  LPSTR   szDefaultObjectName,
    IN  LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterW(
    IN  LPCWSTR szDataSource,
    IN  LPCWSTR szMachineName,
    IN  LPCWSTR szObjectName,
    IN  LPWSTR  szDefaultCounterName,
    IN  LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterA(
    IN  LPCSTR  szDataSource,
    IN  LPCSTR  szMachineName,
    IN  LPCSTR  szObjectName,
    IN  LPSTR   szDefaultCounterName,
    IN  LPDWORD pcchBufferSize
);

typedef PDH_STATUS (__stdcall * CounterPathCallBack)(DWORD_PTR);

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4214 )  // Disable warning messages
typedef struct _BrowseDlgConfig_HW {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bShowObjectBrowser:1,
            bReserved:22;

    HWND                hWndOwner;
    PDH_HLOG            hDataSource;
    LPWSTR              szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPWSTR              szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_HW, * PPDH_BROWSE_DLG_CONFIG_HW;

typedef struct _BrowseDlgConfig_HA {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bShowObjectBrowser:1,
            bReserved:22;

    HWND                hWndOwner;
    PDH_HLOG            hDataSource;
    LPSTR               szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPSTR               szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_HA, * PPDH_BROWSE_DLG_CONFIG_HA;

typedef struct _BrowseDlgConfig_W {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bShowObjectBrowser:1,
            bReserved:22;

    HWND                hWndOwner;
    LPWSTR              szDataSource;
    LPWSTR              szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPWSTR              szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_W, * PPDH_BROWSE_DLG_CONFIG_W;

typedef struct _BrowseDlgConfig_A {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bShowObjectBrowser:1,
            bReserved:22;

    HWND                hWndOwner;
    LPSTR               szDataSource;
    LPSTR               szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPSTR               szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_A, * PPDH_BROWSE_DLG_CONFIG_A;
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning ( default : 4214 )
#endif

PDH_FUNCTION
PdhBrowseCountersW(
    IN  PPDH_BROWSE_DLG_CONFIG_W pBrowseDlgData
);

PDH_FUNCTION
PdhBrowseCountersA(
    IN  PPDH_BROWSE_DLG_CONFIG_A pBrowseDlgData
);

PDH_FUNCTION
PdhExpandCounterPathW(
    IN  LPCWSTR szWildCardPath,
    IN  LPWSTR  mszExpandedPathList,
    IN  LPDWORD pcchPathListLength
);

PDH_FUNCTION
PdhExpandCounterPathA(
    IN  LPCSTR  szWildCardPath,
    IN  LPSTR   mszExpandedPathList,
    IN  LPDWORD pcchPathListLength
);

//
//  v2.0 functions
//
PDH_FUNCTION
PdhLookupPerfNameByIndexW(
    IN  LPCWSTR szMachineName,
    IN  DWORD   dwNameIndex,
    IN  LPWSTR  szNameBuffer,
    IN  LPDWORD pcchNameBufferSize
);

PDH_FUNCTION
PdhLookupPerfNameByIndexA(
    IN  LPCSTR  szMachineName,
    IN  DWORD   dwNameIndex,
    IN  LPSTR   szNameBuffer,
    IN  LPDWORD pcchNameBufferSize
);

PDH_FUNCTION
PdhLookupPerfIndexByNameW(
    IN  LPCWSTR szMachineName,
    IN  LPCWSTR szNameBuffer,
    IN  LPDWORD pdwIndex
);

PDH_FUNCTION
PdhLookupPerfIndexByNameA(
    IN  LPCSTR  szMachineName,
    IN  LPCSTR  szNameBuffer,
    IN  LPDWORD pdwIndex
);

#define PDH_NOEXPANDCOUNTERS    1
#define PDH_NOEXPANDINSTANCES   2
#define PDH_REFRESHCOUNTERS     4

PDH_FUNCTION
PdhExpandWildCardPathA(
    IN  LPCSTR  szDataSource,
    IN  LPCSTR  szWildCardPath,
    IN  LPSTR   mszExpandedPathList,
    IN  LPDWORD pcchPathListLength,
    IN  DWORD   dwFlags
);

PDH_FUNCTION
PdhExpandWildCardPathW(
    IN  LPCWSTR szDataSource,
    IN  LPCWSTR szWildCardPath,
    IN  LPWSTR  mszExpandedPathList,
    IN  LPDWORD pcchPathListLength,
    IN  DWORD   dwFlags
);

//
//   Logging Functions
//

#define PDH_LOG_READ_ACCESS      ((DWORD) 0x00010000)
#define PDH_LOG_WRITE_ACCESS     ((DWORD) 0x00020000)
#define PDH_LOG_UPDATE_ACCESS    ((DWORD) 0x00040000)
#define PDH_LOG_ACCESS_MASK      ((DWORD) 0x000F0000)

#define PDH_LOG_CREATE_NEW       ((DWORD) 0x00000001)
#define PDH_LOG_CREATE_ALWAYS    ((DWORD) 0x00000002)
#define PDH_LOG_OPEN_ALWAYS      ((DWORD) 0x00000003)
#define PDH_LOG_OPEN_EXISTING    ((DWORD) 0x00000004)
#define PDH_LOG_CREATE_MASK      ((DWORD) 0x0000000F)

#define PDH_LOG_OPT_USER_STRING  ((DWORD) 0x01000000)
#define PDH_LOG_OPT_CIRCULAR     ((DWORD) 0x02000000)
#define PDH_LOG_OPT_MAX_IS_BYTES ((DWORD) 0x04000000)
#define PDH_LOG_OPT_APPEND       ((DWORD) 0x08000000)
#define PDH_LOG_OPT_MASK         ((DWORD) 0x0F000000)

#define PDH_LOG_TYPE_UNDEFINED      0
#define PDH_LOG_TYPE_CSV            1
#define PDH_LOG_TYPE_TSV            2
//#define PDH_LOG_TYPE_BINARY         3 // this is the retired binary format
#define PDH_LOG_TYPE_TRACE_KERNEL   4
#define PDH_LOG_TYPE_TRACE_GENERIC  5
#define PDH_LOG_TYPE_PERFMON        6
#define PDH_LOG_TYPE_SQL            7
#define PDH_LOG_TYPE_BINARY         8

PDH_FUNCTION
PdhOpenLogW(
    IN  LPCWSTR     szLogFileName,
    IN  DWORD       dwAccessFlags,
    IN  LPDWORD     lpdwLogType,
    IN  PDH_HQUERY  hQuery,
    IN  DWORD       dwMaxSize,
    IN  LPCWSTR     szUserCaption,
    IN  PDH_HLOG  * phLog
);

PDH_FUNCTION
PdhOpenLogA(
    IN  LPCSTR       szLogFileName,
    IN  DWORD        dwAccessFlags,
    IN  LPDWORD      lpdwLogType,
    IN  PDH_HQUERY   hQuery,
    IN  DWORD        dwMaxSize,
    IN  LPCSTR       szUserCaption,
    IN  PDH_HLOG   * phLog
);

PDH_FUNCTION
PdhUpdateLogW(
    IN  PDH_HLOG hLog,
    IN  LPCWSTR  szUserString
);

PDH_FUNCTION
PdhUpdateLogA(
    IN  PDH_HLOG hLog,
    IN  LPCSTR   szUserString
);

PDH_FUNCTION
PdhUpdateLogFileCatalog(
    IN  PDH_HLOG hLog
);

PDH_FUNCTION
PdhGetLogFileSize(
    IN  PDH_HLOG   hLog,
    IN  LONGLONG * llSize
);

PDH_FUNCTION
PdhCloseLog(
    IN  PDH_HLOG hLog,
    IN  DWORD    dwFlags
);

#define PDH_FLAGS_CLOSE_QUERY   ((DWORD) 0x00000001)
//
//  Data source selection dialog
//
#define PDH_FLAGS_FILE_BROWSER_ONLY ((DWORD) 0x00000001)

PDH_FUNCTION
PdhSelectDataSourceW(
    IN  HWND    hWndOwner,
    IN  DWORD   dwFlags,
    IN  LPWSTR  szDataSource,
    IN  LPDWORD pcchBufferLength
);

PDH_FUNCTION
PdhSelectDataSourceA(
    IN  HWND    hWndOwner,
    IN  DWORD   dwFlags,
    IN  LPSTR   szDataSource,
    IN  LPDWORD pcchBufferLength
);

BOOL
PdhIsRealTimeQuery(
    IN  PDH_HQUERY hQuery
);

PDH_FUNCTION
PdhSetQueryTimeRange(
    IN  PDH_HQUERY     hQuery,
    IN  PPDH_TIME_INFO pInfo
);

PDH_FUNCTION
PdhGetDataSourceTimeRangeW(
    IN  LPCWSTR        szDataSource,
    IN  LPDWORD        pdwNumEntries,
    IN  PPDH_TIME_INFO pInfo,
    IN  LPDWORD        pdwBufferSize
);

PDH_FUNCTION
PdhGetDataSourceTimeRangeA(
    IN  LPCSTR         szDataSource,
    IN  LPDWORD        pdwNumEntries,
    IN  PPDH_TIME_INFO pInfo,
    IN  LPDWORD        dwBufferSize
);

PDH_FUNCTION
PdhCollectQueryDataEx(
    IN  PDH_HQUERY hQuery,
    IN  DWORD      dwIntervalTime,
    IN  HANDLE     hNewDataEvent
);

PDH_FUNCTION
PdhFormatFromRawValue(
    IN  DWORD                   dwCounterType,
    IN  DWORD                   dwFormat,
    IN  LONGLONG              * pTimeBase,
    IN  PPDH_RAW_COUNTER        pRawValue1,
    IN  PPDH_RAW_COUNTER        pRawValue2,
    IN  PPDH_FMT_COUNTERVALUE   pFmtValue
);

PDH_FUNCTION
PdhGetCounterTimeBase(
    IN  PDH_HCOUNTER   hCounter,
    IN  LONGLONG     * pTimeBase
);

PDH_FUNCTION
PdhReadRawLogRecord(
    IN  PDH_HLOG            hLog,
    IN  FILETIME            ftRecord,
    IN  PPDH_RAW_LOG_RECORD pRawLogRecord,
    IN  LPDWORD             pdwBufferLength
);


#define DATA_SOURCE_REGISTRY ((DWORD) 0x00000001)
#define DATA_SOURCE_LOGFILE  ((DWORD) 0x00000002)
#define DATA_SOURCE_WBEM     ((DWORD) 0x00000004)

PDH_FUNCTION
PdhSetDefaultRealTimeDataSource(
    IN  DWORD dwDataSourceId
);

// Extended API for WMI event trace logfile format
//
PDH_FUNCTION
PdhBindInputDataSourceW(
    IN  PDH_HLOG * phDataSource,
    IN  LPCWSTR    LogFileNameList
);

PDH_FUNCTION
PdhBindInputDataSourceA(
    IN  PDH_HLOG * phDataSource,
    IN  LPCSTR     LogFileNameList
);

PDH_FUNCTION
PdhOpenQueryH(
    IN  PDH_HLOG     hDataSource,
    IN  DWORD_PTR    dwUserData,
    IN  PDH_HQUERY * phQuery
);

PDH_FUNCTION
PdhEnumMachinesHW(
    IN  PDH_HLOG hDataSource,
    IN  LPWSTR   mszMachineList,
    IN  LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhEnumMachinesHA(
    IN  PDH_HLOG hDataSource,
    IN  LPSTR    mszMachineList,
    IN  LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhEnumObjectsHW(
    IN  PDH_HLOG hDataSource,
    IN  LPCWSTR  szMachineName,
    IN  LPWSTR   mszObjectList,
    IN  LPDWORD  pcchBufferSize,
    IN  DWORD    dwDetailLevel,
    IN  BOOL     bRefresh
) ;

PDH_FUNCTION
PdhEnumObjectsHA(
    IN  PDH_HLOG hDataSource,
    IN  LPCSTR   szMachineName,
    IN  LPSTR    mszObjectList,
    IN  LPDWORD  pcchBufferSize,
    IN  DWORD    dwDetailLevel,
    IN  BOOL     bRefresh
);

PDH_FUNCTION
PdhEnumObjectItemsHW(
    IN  PDH_HLOG hDataSource,
    IN  LPCWSTR  szMachineName,
    IN  LPCWSTR  szObjectName,
    IN  LPWSTR   mszCounterList,
    IN  LPDWORD  pcchCounterListLength,
    IN  LPWSTR   mszInstanceList,
    IN  LPDWORD  pcchInstanceListLength,
    IN  DWORD    dwDetailLevel,
    IN  DWORD    dwFlags
);

PDH_FUNCTION
PdhEnumObjectItemsHA(
    IN  PDH_HLOG hDataSource,
    IN  LPCSTR   szMachineName,
    IN  LPCSTR   szObjectName,
    IN  LPSTR    mszCounterList,
    IN  LPDWORD  pcchCounterListLength,
    IN  LPSTR    mszInstanceList,
    IN  LPDWORD  pcchInstanceListLength,
    IN  DWORD    dwDetailLevel,
    IN  DWORD    dwFlags
);

PDH_FUNCTION
PdhExpandWildCardPathHW(
    IN  PDH_HLOG hDataSource,
    IN  LPCWSTR  szWildCardPath,
    IN  LPWSTR   mszExpandedPathList,
    IN  LPDWORD  pcchPathListLength,
    IN  DWORD    dwFlags
);

PDH_FUNCTION
PdhExpandWildCardPathHA(
    IN  PDH_HLOG hDataSource,
    IN  LPCSTR   szWildCardPath,
    IN  LPSTR    mszExpandedPathList,
    IN  LPDWORD  pcchPathListLength,
    IN  DWORD    dwFlags
);

PDH_FUNCTION
PdhGetDataSourceTimeRangeH(
    IN  PDH_HLOG       hDataSource,
    IN  LPDWORD        pdwNumEntries,
    IN  PPDH_TIME_INFO pInfo,
    IN  LPDWORD        pdwBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfObjectHW(
    IN  PDH_HLOG hDataSource,
    IN  LPCWSTR  szMachineName,
    IN  LPWSTR   szDefaultObjectName,
    IN  LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfObjectHA(
    IN  PDH_HLOG hDataSource,
    IN  LPCSTR   szMachineName,
    IN  LPSTR    szDefaultObjectName,
    IN  LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterHW(
    IN  PDH_HLOG hDataSource,
    IN  LPCWSTR  szMachineName,
    IN  LPCWSTR  szObjectName,
    IN  LPWSTR   szDefaultCounterName,
    IN  LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterHA(
    IN  PDH_HLOG hDataSource,
    IN  LPCSTR   szMachineName,
    IN  LPCSTR   szObjectName,
    IN  LPSTR    szDefaultCounterName,
    IN  LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhBrowseCountersHW(
    IN  PPDH_BROWSE_DLG_CONFIG_HW pBrowseDlgData
);

PDH_FUNCTION
PdhBrowseCountersHA(
    IN  PPDH_BROWSE_DLG_CONFIG_HA pBrowseDlgData
);

//Check that a DSN points to a database that contains the correct Perfmon tables.
PDH_FUNCTION
PdhVerifySQLDBW(
    IN  LPCWSTR szDataSource
);

PDH_FUNCTION
PdhVerifySQLDBA(
    IN  LPCSTR szDataSource
);


//Create the correct perfmon tables in the database pointed to by a DSN.
PDH_FUNCTION
PdhCreateSQLTablesW(
    IN  LPCWSTR szDataSource
);  

PDH_FUNCTION
PdhCreateSQLTablesA(
    IN  LPCSTR szDataSource
);     

//Return the list of Log set names in the database pointed to by the DSN.
PDH_FUNCTION
PdhEnumLogSetNamesW(
    IN  LPCWSTR szDataSource,
    IN  LPWSTR  mszDataSetNameList,
    IN  LPDWORD pcchBufferLength
);

PDH_FUNCTION
PdhEnumLogSetNamesA(
    IN  LPCSTR  szDataSource,
    IN  LPSTR   mszDataSetNameList,
    IN  LPDWORD pcchBufferLength
);

//Retrieve the GUID for an open Log Set
PDH_FUNCTION
PdhGetLogSetGUID(
    IN  PDH_HLOG   hLog,             
    IN  GUID     * pGuid,
    IN  int      * pRunId
);

//Set the RunID for an open Log Set
PDH_FUNCTION
PdhSetLogSetRunID(
    IN  PDH_HLOG hLog,             
    IN  int      RunId
);

//
//   Unicode/ANSI compatibility section
//
#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE
#endif
#endif

#ifdef UNICODE
// start of UNICODE definitions
#define PdhOpenQuery                PdhOpenQueryW
#define PdhAddCounter               PdhAddCounterW
#define PdhGetCounterInfo           PdhGetCounterInfoW
#define PDH_COUNTER_INFO            PDH_COUNTER_INFO_W
#define PPDH_COUNTER_INFO           PPDH_COUNTER_INFO_W
#define PdhConnectMachine           PdhConnectMachineW
#define PdhEnumMachines             PdhEnumMachinesW
#define PdhEnumObjects              PdhEnumObjectsW
#define PdhEnumObjectItems          PdhEnumObjectItemsW
#define PdhMakeCounterPath          PdhMakeCounterPathW
#define PDH_COUNTER_PATH_ELEMENTS   PDH_COUNTER_PATH_ELEMENTS_W
#define PPDH_COUNTER_PATH_ELEMENTS  PPDH_COUNTER_PATH_ELEMENTS_W
#define PdhParseCounterPath         PdhParseCounterPathW
#define PdhParseInstanceName        PdhParseInstanceNameW
#define PdhValidatePath             PdhValidatePathW
#define PdhGetDefaultPerfObject     PdhGetDefaultPerfObjectW
#define PdhGetDefaultPerfCounter    PdhGetDefaultPerfCounterW
#define PdhBrowseCounters           PdhBrowseCountersW
#define PdhBrowseCountersH          PdhBrowseCountersHW
#define PDH_BROWSE_DLG_CONFIG       PDH_BROWSE_DLG_CONFIG_W
#define PPDH_BROWSE_DLG_CONFIG      PPDH_BROWSE_DLG_CONFIG_W
#define PDH_BROWSE_DLG_CONFIG_H     PDH_BROWSE_DLG_CONFIG_HW
#define PPDH_BROWSE_DLG_CONFIG_H    PPDH_BROWSE_DLG_CONFIG_HW
#define PdhExpandCounterPath        PdhExpandCounterPathW
// v2.0 functions
#define PDH_FMT_COUNTERVALUE_ITEM   PDH_FMT_COUNTERVALUE_ITEM_W
#define PPDH_FMT_COUNTERVALUE_ITEM  PPDH_FMT_COUNTERVALUE_ITEM_W
#define PDH_RAW_COUNTER_ITEM        PDH_RAW_COUNTER_ITEM_W
#define PPDH_RAW_COUNTER_ITEM       PPDH_RAW_COUNTER_ITEM_W
#define PdhGetFormattedCounterArray PdhGetFormattedCounterArrayW
#define PdhGetRawCounterArray       PdhGetRawCounterArrayW
#define PdhLookupPerfNameByIndex    PdhLookupPerfNameByIndexW
#define PdhLookupPerfIndexByName    PdhLookupPerfIndexByNameW
#define PdhOpenLog                  PdhOpenLogW
#define PdhUpdateLog                PdhUpdateLogW
#define PdhSelectDataSource         PdhSelectDataSourceW
#define PdhGetDataSourceTimeRange   PdhGetDataSourceTimeRangeW
#define PDH_LOG_SERVICE_QUERY_INFO  PDH_LOG_SERVICE_QUERY_INFO_W
#define PPDH_LOG_SERVICE_QUERY_INFO PPDH_LOG_SERVICE_QUERY_INFO_W
#define PdhLogServiceControl        PdhLogServiceControlW
#define PdhLogServiceQuery          PdhLogServiceQueryW
#define PdhExpandWildCardPath       PdhExpandWildCardPathW
#define PdhBindInputDataSource      PdhBindInputDataSourceW
#define PdhEnumMachinesH            PdhEnumMachinesHW
#define PdhEnumObjectsH             PdhEnumObjectsHW
#define PdhEnumObjectItemsH         PdhEnumObjectItemsHW
#define PdhExpandWildCardPathH      PdhExpandWildCardPathHW
#define PdhGetDefaultPerfObjectH    PdhGetDefaultPerfObjectHW
#define PdhGetDefaultPerfCounterH   PdhGetDefaultPerfCounterHW
#define PdhEnumLogSetNames          PdhEnumLogSetNamesW
#define PdhCreateSQLTables          PdhCreateSQLTablesW
#define PdhVerifySQLDB              PdhVerifySQLDBW

// end of UNICODE definitions
#else
// start of ANSI definitions
#define PdhOpenQuery                PdhOpenQueryA
#define PdhAddCounter               PdhAddCounterA
#define PdhGetCounterInfo           PdhGetCounterInfoA
#define PDH_COUNTER_INFO            PDH_COUNTER_INFO_A
#define PPDH_COUNTER_INFO           PPDH_COUNTER_INFO_A
#define PdhConnectMachine           PdhConnectMachineA
#define PdhEnumMachines             PdhEnumMachinesA
#define PdhEnumObjects              PdhEnumObjectsA
#define PdhEnumObjectItems          PdhEnumObjectItemsA
#define PdhMakeCounterPath          PdhMakeCounterPathA
#define PDH_COUNTER_PATH_ELEMENTS   PDH_COUNTER_PATH_ELEMENTS_A
#define PPDH_COUNTER_PATH_ELEMENTS  PPDH_COUNTER_PATH_ELEMENTS_A
#define PdhParseCounterPath         PdhParseCounterPathA
#define PdhParseInstanceName        PdhParseInstanceNameA
#define PdhValidatePath             PdhValidatePathA
#define PdhGetDefaultPerfObject     PdhGetDefaultPerfObjectA
#define PdhGetDefaultPerfCounter    PdhGetDefaultPerfCounterA
#define PdhBrowseCounters           PdhBrowseCountersA
#define PdhBrowseCountersH          PdhBrowseCountersHA
#define PDH_BROWSE_DLG_CONFIG       PDH_BROWSE_DLG_CONFIG_A
#define PPDH_BROWSE_DLG_CONFIG      PPDH_BROWSE_DLG_CONFIG_A
#define PDH_BROWSE_DLG_CONFIG_H     PDH_BROWSE_DLG_CONFIG_HA
#define PPDH_BROWSE_DLG_CONFIG_H    PPDH_BROWSE_DLG_CONFIG_HA
#define PdhExpandCounterPath        PdhExpandCounterPathA
// v2.0 functions
#define PDH_FMT_COUNTERVALUE_ITEM   PDH_FMT_COUNTERVALUE_ITEM_A
#define PPDH_FMT_COUNTERVALUE_ITEM  PPDH_FMT_COUNTERVALUE_ITEM_A
#define PDH_RAW_COUNTER_ITEM        PDH_RAW_COUNTER_ITEM_A
#define PPDH_RAW_COUNTER_ITEM       PPDH_RAW_COUNTER_ITEM_A
#define PdhGetFormattedCounterArray PdhGetFormattedCounterArrayA
#define PdhGetRawCounterArray       PdhGetRawCounterArrayA
#define PdhLookupPerfNameByIndex    PdhLookupPerfNameByIndexA
#define PdhLookupPerfIndexByName    PdhLookupPerfIndexByNameA
#define PdhOpenLog                  PdhOpenLogA
#define PdhUpdateLog                PdhUpdateLogA
#define PdhSelectDataSource         PdhSelectDataSourceA
#define PdhGetDataSourceTimeRange   PdhGetDataSourceTimeRangeA
#define PDH_LOG_SERVICE_QUERY_INFO  PDH_LOG_SERVICE_QUERY_INFO_A
#define PPDH_LOG_SERVICE_QUERY_INFO PPDH_LOG_SERVICE_QUERY_INFO_A
#define PdhLogServiceControl        PdhLogServiceControlA
#define PdhLogServiceQuery          PdhLogServiceQueryA
#define PdhExpandWildCardPath       PdhExpandWildCardPathA
#define PdhBindInputDataSource      PdhBindInputDataSourceA
#define PdhEnumMachinesH            PdhEnumMachinesHA
#define PdhEnumObjectsH             PdhEnumObjectsHA
#define PdhEnumObjectItemsH         PdhEnumObjectItemsHA
#define PdhExpandWildCardPathH      PdhExpandWildCardPathHA
#define PdhGetDefaultPerfObjectH    PdhGetDefaultPerfObjectHA
#define PdhGetDefaultPerfCounterH   PdhGetDefaultPerfCounterHA
#define PdhEnumLogSetNames          PdhEnumLogSetNamesA
#define PdhCreateSQLTables          PdhCreateSQLTablesA
#define PdhVerifySQLDB              PdhVerifySQLDBA

// end of ANSI definitions
#endif  // UNICODE

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning ( default : 4201 )
#endif


#ifdef __cplusplus
}
#endif

#endif //_PDH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\inc\pdhp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pdhp.h

Abstract:

    PDH private APIs. Converts WMI event trace data to perf counters

Author:

    Melur Raghuraman (mraghu) 03-Oct-1997

Environment:

Revision History:


--*/

#ifndef __PDHP__
#define __PDHP__

#include <wchar.h>
#include <pdh.h>

#ifdef __cplusplus
extern "C" {
#endif

/*****************************************************************************\
    Private Pdh Section
\*****************************************************************************/

#define PDH_RELOG_STATUS_PROCESSING       1

typedef struct _PDH_RELOG_INFO_A {
    LPSTR           strLog;
    DWORD           dwFileFormat;
    DWORD           dwFlags;
    PDH_TIME_INFO   TimeInfo;
    FILETIME        ftInterval;
    void            (*StatusFunction)(int, double);
    ULONG           Reserved1;
    ULONG           Reserved2;
} PDH_RELOG_INFO_A, *PPDH_RELOG_INFO_A;

typedef struct _PDH_RELOG_INFO_W {
    LPWSTR          strLog;
    DWORD           dwFileFormat;
    DWORD           dwFlags;
    PDH_TIME_INFO   TimeInfo;
    FILETIME        ftInterval;
    void            (*StatusFunction)(int, double);
    ULONG           Reserved1;
    ULONG           Reserved2;
} PDH_RELOG_INFO_W, *PPDH_RELOG_INFO_W;

PDH_FUNCTION
PdhRelogA( 
    HLOG    hLogIn,
    PPDH_RELOG_INFO_A  pRelogInfo
);

PDH_FUNCTION
PdhRelogW( 
    HLOG    hLogIn,
    PPDH_RELOG_INFO_W pRelogInfo
);

#ifdef UNICODE
#define PdhRelog            PdhRelogW
#define PDH_RELOG_INFO      PDH_RELOG_INFO_W
#define PPDH_RELOG_INFO     PPDH_RELOG_INFO_W
#else
#define PdhRelog            PdhRelogA
#define PDH_RELOG_INFO      PDH_RELOG_INFO_A
#define PPDH_RELOG_INFO     PPDH_RELOG_INFO_A
#endif

/*****************************************************************************\
    Performance Logs and Alerts Section
\*****************************************************************************/


#ifdef UNICODE
#define PdhPlaStart                PdhPlaStartW
#define PdhPlaStop                 PdhPlaStopW
#define PdhPlaSchedule             PdhPlaScheduleW
#define PdhPlaCreate               PdhPlaCreateW
#define PdhPlaDelete               PdhPlaDeleteW
#define PdhPlaAddItem              PdhPlaAddItemW
#define PdhPlaSetItemList          PdhPlaSetItemListW
#define PdhPlaRemoveAllItems       PdhPlaRemoveAllItemsW
#define PdhPlaGetInfo              PdhPlaGetInfoW
#define PdhPlaSetInfo              PdhPlaSetInfoW
#define PdhPlaSetRunAs             PdhPlaSetRunAsW
#define PdhPlaEnumCollections      PdhPlaEnumCollectionsW
#define PdhPlaValidateInfo         PdhPlaValidateInfoW
#define PDH_PLA_INFO               PDH_PLA_INFO_W
#define PPDH_PLA_INFO              PPDH_PLA_INFO_W
#define PDH_PLA_ITEM               PDH_PLA_ITEM_W
#define PPDH_PLA_ITEM              PPDH_PLA_ITEM_W
#define PdhTranslate009Counter     PdhTranslate009CounterW
#define PdhTranslateLocaleCounter  PdhTranslateLocaleCounterW
#define PdhAdd009Counter           PdhAdd009CounterW
#define PdhGetLogFileType          PdhGetLogFileTypeW
#define PdhPlaGetLogFileName       PdhPlaGetLogFileNameW
#define PdhPlaGetSchedule          PdhPlaGetScheduleW
#define PdhiPlaFormatBlanks        PdhiPlaFormatBlanksW
#else
#define PdhPlaStart                PdhPlaStartA
#define PdhPlaStop                 PdhPlaStopA
#define PdhPlaSchedule             PdhPlaScheduleW
#define PdhPlaCreate               PdhPlaCreateA
#define PdhPlaDelete               PdhPlaDeleteA
#define PdhPlaAddItem              PdhPlaAddItemA
#define PdhPlaSetItemList          PdhPlaSetItemListA
#define PdhPlaRemoveAllItems       PdhPlaRemoveAllItemA
#define PdhPlaGetInfo              PdhPlaGetInfoA
#define PdhPlaSetInfo              PdhPlaSetInfoA
#define PdhPlaSetRunAs             PdhPlaSetRunAsA
#define PdhPlaEnumCollections      PdhPlaEnumCollectionsA
#define PdhPlaValidateInfo         PdhPlaValidateInfoA
#define PDH_PLA_INFO               PDH_PLA_INFO_A
#define PPDH_PLA_INFO              PPDH_PLA_INFO_A
#define PDH_PLA_ITEM               PDH_PLA_ITEM_A
#define PPDH_PLA_ITEM              PPDH_PLA_ITEM_A
#define PdhTranslate009Counter     PdhTranslate009CounterA
#define PdhTranslateLocaleCounter  PdhTranslateLocaleCounterA
#define PdhAdd009Counter           PdhAdd009CounterA
#define PdhGetLogFileType          PdhGetLogFileTypeA
#define PdhPlaGetLogFileName       PdhPlaGetLogFileNameA
#define PdhPlaGetSchedule          PdhPlaGetScheduleA
#define PdhiPlaFormatBlanks        PdhiPlaFormatBlanksA
#endif

// wDataType values
#define PLA_TT_DTYPE_DATETIME   ((WORD)0x0001)
#define PLA_TT_DTYPE_UNITS      ((WORD)0x0002)

// dwMode values
#define PLA_AUTO_MODE_NONE      ((DWORD)0x00000000)       // Manual
#define PLA_AUTO_MODE_SIZE      ((DWORD)0x00000001)       // Size
#define PLA_AUTO_MODE_AT        ((DWORD)0x00000002)       // Time
#define PLA_AUTO_MODE_AFTER     ((DWORD)0x00000003)       // Value & unit type
#define PLA_AUTO_MODE_CALENDAR  ((DWORD)0x00000004)       // Schedule Calender

// wTimeType values
#define PLA_TT_TTYPE_START              ((WORD)0x0001)
#define PLA_TT_TTYPE_STOP               ((WORD)0x0002)
#define PLA_TT_TTYPE_RESTART            ((WORD)0x0003)
#define PLA_TT_TTYPE_SAMPLE             ((WORD)0x0004)
#define PLA_TT_TTYPE_LAST_MODIFIED      ((WORD)0x0005)
#define PLA_TT_TTYPE_CREATENEWFILE      ((WORD)0x0006)
#define PLA_TT_TTYPE_REPEAT_SCHEDULE    ((WORD)0x0007)

// dwUnitType values
#define PLA_TT_UTYPE_SECONDS        ((DWORD)0x00000001)    
#define PLA_TT_UTYPE_MINUTES        ((DWORD)0x00000002)   
#define PLA_TT_UTYPE_HOURS          ((DWORD)0x00000003)   
#define PLA_TT_UTYPE_DAYS           ((DWORD)0x00000004)   
#define PLA_TT_UTYPE_DAYSOFWEEK     ((DWORD)0x00000005)   

#pragma warning ( disable : 4201 )

typedef struct _PLA_TIME_INFO {
    WORD    wDataType;
    WORD    wTimeType;
    DWORD   dwAutoMode;
    union {
        LONGLONG    llDateTime; // filetime stored as a LONGLONG
        struct {
            DWORD   dwValue;
            DWORD   dwUnitType;
        };
    };
} PLA_TIME_INFO, *PPLA_TIME_INFO;

typedef struct _PDH_PLA_ITEM_W {
    DWORD dwType;
    union {
        LPWSTR strCounters;
        struct {
            LPWSTR strProviders;
            LPWSTR strFlags;
            LPWSTR strLevels;
        };
    };
} PDH_PLA_ITEM_W, *PPDH_PLA_ITEM_W;

typedef struct _PDH_PLA_ITEM_A {
    DWORD dwType;
    union {
        LPSTR strCounters;
        struct {
            LPSTR strProviders;
            LPSTR strFlags;
            LPSTR strLevels;
        };
    };
} PDH_PLA_ITEM_A, *PPDH_PLA_ITEM_A;

// Generic Fields
#define PLA_INFO_FLAG_USER        0x00000001
#define PLA_INFO_FLAG_FORMAT      0x00000002
#define PLA_INFO_FLAG_MAXLOGSIZE  0x00000004
#define PLA_INFO_FLAG_RUNCOMMAND  0x00000008
#define PLA_INFO_FLAG_FILENAME    0x00000010
#define PLA_INFO_FLAG_AUTOFORMAT  0x00000020
#define PLA_INFO_FLAG_DATASTORE   0x00000040
#define PLA_INFO_FLAG_REPEAT      0x00000080
#define PLA_INFO_FLAG_STATUS      0x00000100
#define PLA_INFO_FLAG_TYPE        0x00000200
#define PLA_INFO_FLAG_BEGIN       0x00000400
#define PLA_INFO_FLAG_END         0x00000800
#define PLA_INFO_FLAG_CRTNEWFILE  0x00001000
#define PLA_INFO_FLAG_DEFAULTDIR  0x00002000
#define PLA_INFO_FLAG_SRLNUMBER   0x00004000
#define PLA_INFO_FLAG_SQLNAME     0x00008000
#define PLA_INFO_FLAG_ALL         0xFFFFFFFF

// Trace Fields
#define PLA_INFO_FLAG_BUFFERSIZE  0x00010000
#define PLA_INFO_FLAG_LOGGERNAME  0x00020000
#define PLA_INFO_FLAG_MODE        0x00040000
#define PLA_INFO_FLAG_MINBUFFERS  0x00080000
#define PLA_INFO_FLAG_MAXBUFFERS  0x00100000
#define PLA_INFO_FLAG_FLUSHTIMER  0x00200000
#define PLA_INFO_FLAG_PROVIDERS   0x00400000
#define PLA_INFO_FLAG_TRACE       0x00FFFFFF

// Performance Fields
#define PLA_INFO_FLAG_INTERVAL    0x01000000
#define PLA_INFO_FLAG_COUNTERS    0x02000000
#define PLA_INFO_FLAG_PERF        0xFF00FFFF

#define PLA_INFO_CREATE_FILENAME    \
    (PLA_INFO_FLAG_FORMAT|          \
    PLA_INFO_FLAG_FILENAME|         \
    PLA_INFO_FLAG_AUTOFORMAT|       \
    PLA_INFO_FLAG_TYPE|             \
    PLA_INFO_FLAG_CRTNEWFILE|       \
    PLA_INFO_FLAG_DEFAULTDIR|       \
    PLA_INFO_FLAG_SRLNUMBER|        \
    PLA_INFO_FLAG_SQLNAME|          \
    PLA_INFO_FLAG_STATUS )          \


typedef struct _PDH_PLA_INFO_W {
    DWORD       dwMask;
    LPWSTR      strUser;
    LPWSTR      strPassword;
    DWORD       dwType;
    DWORD       dwMaxLogSize;
    DWORD       dwFlags;
    DWORD       dwLogQuota;
    LPWSTR      strLogFileCaption;
    LPWSTR      strDefaultDir;
    LPWSTR      strBaseFileName;
    LPWSTR      strSqlName;
    DWORD       dwFileFormat;
    DWORD       dwAutoNameFormat;
    DWORD       dwLogFileSerialNumber;
    LPWSTR      strCommandFileName;
    DWORD       dwDatastoreAttributes;
    PLA_TIME_INFO    ptLogBeginTime;
    PLA_TIME_INFO    ptLogEndTime;
    PLA_TIME_INFO    ptCreateNewFile;
    PLA_TIME_INFO    ptRepeat;
    DWORD       dwStatus;
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    union {
        struct {
            PDH_PLA_ITEM_W  piCounterList;
            DWORD           dwAutoNameInterval;
            DWORD           dwAutoNameUnits;
            PLA_TIME_INFO   ptSampleInterval;
        } Perf;
        struct {
            PDH_PLA_ITEM_W  piProviderList;
            LPWSTR  strLoggerName;
            DWORD   dwMode;
            DWORD   dwNumberOfBuffers;
            DWORD   dwMaximumBuffers;
            DWORD   dwMinimumBuffers;
            DWORD   dwBufferSize;
            DWORD   dwFlushTimer;
        } Trace;
    };
} PDH_PLA_INFO_W, *PPDH_PLA_INFO_W;

typedef struct _PDH_PLA_INFO_A {
    DWORD       dwMask;
    // NOT YET IMPLEMENTED
} PDH_PLA_INFO_A, *PPDH_PLA_INFO_A;

#pragma warning ( default : 4201 )

typedef struct _PLA_VERSION_ {
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuild;
    DWORD dwSubBuild;
} PLA_VERSION, *PPLA_VERSION;

HRESULT
PdhiPlaFormatBlanksA( 
    LPSTR strComputer, 
    LPSTR strFormat 
);

HRESULT
PdhiPlaFormatBlanksW( 
    LPWSTR strComputer, 
    LPWSTR strFormat 
);

PDH_FUNCTION
PdhPlaGetScheduleA(
    LPSTR strName, 
    LPSTR strComputer,
    LPDWORD pdwTypeStart,
    LPDWORD pdwTypeStop,
    PPDH_TIME_INFO pInfo
);

PDH_FUNCTION
PdhPlaGetScheduleW(
    LPWSTR strName, 
    LPWSTR strComputer,
    LPDWORD pdwTypeStart,
    LPDWORD pdwTypeStop,
    PPDH_TIME_INFO pInfo
);


PDH_FUNCTION
PlaTimeInfoToMilliSeconds(
    PLA_TIME_INFO* pTimeInfo,
    LONGLONG* pllmsecs
);

PDH_FUNCTION
PdhPlaValidateInfoA(
    LPSTR strName,
    LPSTR strComputer,
    PPDH_PLA_INFO_A pInfo
);

PDH_FUNCTION
PdhPlaValidateInfoW(
    LPWSTR strName,
    LPWSTR strComputer,
    PPDH_PLA_INFO_W pInfo
);

PDH_FUNCTION
PdhPlaSetRunAsA(
    LPSTR strName,
    LPSTR strComputer,
    LPSTR strUser,
    LPSTR strPassword
);

PDH_FUNCTION
PdhPlaSetRunAsW(
    LPWSTR strName,
    LPWSTR strComputer,
    LPWSTR strUser,
    LPWSTR strPassword
);

PDH_FUNCTION 
PdhPlaScheduleA( 
    LPSTR strName, 
    LPSTR strComputer,
    DWORD fType,
    PPDH_TIME_INFO pInfo
);

PDH_FUNCTION 
PdhPlaScheduleW( 
    LPWSTR strName, 
    LPWSTR strComputer,
    DWORD fType,
    PPDH_TIME_INFO pInfo
);

PDH_FUNCTION 
PdhPlaStartA( 
    LPSTR strName, 
    LPSTR strComputer
);

PDH_FUNCTION 
PdhPlaStartW( 
    LPWSTR strName, 
    LPWSTR strComputer
);

PDH_FUNCTION 
PdhPlaStopA( 
    LPSTR strName, 
    LPSTR strComputer  
);

PDH_FUNCTION 
PdhPlaStopW( 
    LPWSTR strName, 
    LPWSTR strComputer  
);

PDH_FUNCTION 
PdhPlaCreateA( 
    LPSTR strName, 
    LPSTR strComputer,
    PPDH_PLA_INFO_A pInfo
);

PDH_FUNCTION 
PdhPlaCreateW( 
    LPWSTR strName, 
    LPWSTR strComputer,
    PPDH_PLA_INFO_W pInfo
);

PDH_FUNCTION 
PdhPlaDeleteA( 
    LPSTR strName, 
    LPSTR strComputer
);

PDH_FUNCTION 
PdhPlaDeleteW( 
    LPWSTR strName, 
    LPWSTR strComputer
);

PDH_FUNCTION
PdhPlaAddItemA(
    LPSTR  strName,
    LPSTR  strComputer,
    PPDH_PLA_ITEM_A  pItem
);

PDH_FUNCTION 
PdhPlaAddItemW(
    LPWSTR  strName,
    LPWSTR  strComputer,
    PPDH_PLA_ITEM_W pItem
);

PDH_FUNCTION 
PdhPlaSetItemListA(
    LPSTR  strName,
    LPSTR  strComputer,
    PPDH_PLA_ITEM_A pItems
);

PDH_FUNCTION 
PdhPlaSetItemListW(
    LPWSTR  strName,
    LPWSTR  strComputer,
    PPDH_PLA_ITEM_W pItems
);

PDH_FUNCTION 
PdhPlaRemoveAllItemsA(
    LPSTR strName,
    LPSTR strComputer
);

PDH_FUNCTION 
PdhPlaRemoveAllItemsW(
    LPWSTR strName,
    LPWSTR strComputer
);

PDH_FUNCTION
PdhPlaGetInfoA(
    LPSTR strName,
    LPSTR strComputer,
    LPDWORD pdwBufferSize,
    PPDH_PLA_INFO_A pInfo
);

PDH_FUNCTION
PdhPlaGetInfoW(
    LPWSTR strName,
    LPWSTR strComputer,
    LPDWORD pdwBufferSize,
    PPDH_PLA_INFO_W pInfo
);

PDH_FUNCTION
PdhPlaSetInfoA(
    LPSTR strName,
    LPSTR strComputer,
    PPDH_PLA_INFO_A pInfo
);

PDH_FUNCTION
PdhPlaSetInfoW(
    LPWSTR strName,
    LPWSTR strComputer,
    PPDH_PLA_INFO_W pInfo
);

PDH_FUNCTION
PdhPlaSetRunAsA(
    LPSTR strName,
    LPSTR strComputer,
    LPSTR strUser,
    LPSTR strPassword
);

PDH_FUNCTION
PdhPlaSetRunAsW(
    LPWSTR strName,
    LPWSTR strComputer,
    LPWSTR strUser,
    LPWSTR strPassword
);

PDH_FUNCTION
PdhiPlaSetRunAs(
    LPWSTR strName,
    LPWSTR strComputer,
    LPWSTR strUser,
    LPWSTR strPassword
);

PDH_FUNCTION
PdhiPlaRunAs( 
    LPWSTR strName,
    LPWSTR strComputer,
    HANDLE* hToken
);

PDH_FUNCTION
PdhiPlaGetVersion(
    LPCWSTR strComputer,
    PPLA_VERSION pVersion 
);


PDH_FUNCTION
PdhPlaEnumCollectionsA( 
    LPSTR strComputer,
    LPDWORD pdwBufferSize,
    LPSTR mszCollections
);

PDH_FUNCTION
PdhPlaEnumCollectionsW( 
    LPWSTR strComputer,
    LPDWORD pcchBufferSize,
    LPWSTR mszCollections
);

PDH_FUNCTION
PdhPlaGetLogFileNameA(
    LPWSTR strName,
    LPWSTR strComputer,
    PPDH_PLA_INFO_A pInfo,
    DWORD dwFlags,
    LPDWORD pcchBufferSize,
    LPWSTR strFileName
);

PDH_FUNCTION
PdhPlaGetLogFileNameW(
    LPWSTR strName,
    LPWSTR strComputer,
    PPDH_PLA_INFO_W pInfo,
    DWORD dwFlags,
    LPDWORD pcchBufferSize,
    LPWSTR strFileName
);

PDH_FUNCTION
PdhTranslate009CounterW(
    IN  LPWSTR      szLocalePath,
    IN  LPWSTR      pszFullPathName,
    IN  LPDWORD     pcchPathLength);

PDH_FUNCTION
PdhTranslate009CounterA(
    IN  LPSTR       szLocalePath,
    IN  LPSTR       pszFullPathName,
    IN  LPDWORD     pcchPathLength);

PDH_FUNCTION
PdhTranslateLocaleCounterW(
    IN  LPWSTR      sz009Path,
    IN  LPWSTR      pszFullPathName,
    IN  LPDWORD     pcchPathLength);

PDH_FUNCTION
PdhTranslateLocaleCounterA(
    IN  LPSTR       sz009Path,
    IN  LPSTR       pszFullPathName,
    IN  LPDWORD     pcchPathLength);

PDH_FUNCTION
PdhAdd009CounterW(
    IN  HQUERY      hQuery,
    IN  LPWSTR      szFullPath,
    IN  DWORD_PTR   dwUserData,
    OUT HCOUNTER  * phCounter);

PDH_FUNCTION
PdhAdd009CounterA(
    IN  HQUERY      hQuery,
    IN  LPSTR       szFullPath,
    IN  DWORD_PTR   dwUserData,
    OUT HCOUNTER  * phCounter);

PDH_FUNCTION
PdhGetLogFileTypeW(
    IN LPCWSTR LogFileName,
    IN LPDWORD LogFileType);

PDH_FUNCTION
PdhGetLogFileTypeA(
    IN LPCSTR  LogFileName,
    IN LPDWORD LogFileType);

PDH_FUNCTION
PdhListLogFileHeaderW (
    IN  LPCWSTR     szFileName,
    IN  LPWSTR      mszHeaderList,
    IN  LPDWORD     pcchHeaderListSize
);

PDH_FUNCTION
PdhListLogFileHeaderA (
    IN  LPCSTR     szFileName,
    IN  LPSTR      mszHeaderList,
    IN  LPDWORD     pcchHeaderListSize
);

#define PLA_SECONDS_IN_DAY      86400
#define PLA_SECONDS_IN_HOUR      3600
#define PLA_SECONDS_IN_MINUTE      60
#define _PLA_CONFIG_DLL_NAME_W_     L"SmLogCfg.dll"
#define _PLA_SERVICE_EXE_NAME_W_    L"SmLogSvc.exe"   

// Communication between smlogcfg and smlogsvc

#define PLA_MAX_AUTO_NAME_LEN   ((DWORD)0x0000000B)
#define PLA_MAX_COLLECTION_NAME   ((DWORD)(_MAX_FNAME - PLA_MAX_AUTO_NAME_LEN - 1))

#define PLA_FILENAME_USE_SUBEXT     0x00000001
#define PLA_FILENAME_GET_SUBFMT     0x00000002
#define PLA_FILENAME_GET_SUBXXX     0x00000004
#define PLA_FILENAME_CREATEONLY     0x00000008
#define PLA_FILENAME_CURRENTLOG     0x00000010
#define PLA_FILENAME_NOEXPANDEV     0x00000020

#define PLA_SERVICE_CONTROL_SYNCHRONIZE 128
#define PLA_QUERY_STOPPED       ((DWORD)0x00000000)              
#define PLA_QUERY_RUNNING       ((DWORD)0x00000001)
#define PLA_QUERY_START_PENDING ((DWORD)0x00000002)

#define PLA_NEW_LOG         ((DWORD)0xFFFFFFFF)
#define PLA_FIRST_LOG_TYPE  ((DWORD)0x00000000)
#define PLA_COUNTER_LOG     ((DWORD)0x00000000)
#define PLA_TRACE_LOG       ((DWORD)0x00000001)
#define PLA_ALERT           ((DWORD)0x00000002)
#define PLA_LAST_LOG_TYPE   ((DWORD)0x00000002)
#define PLA_NUM_LOG_TYPES   ((DWORD)0x00000003)

// Sysmon log output file configuration definitions

#define PLA_DATASTORE_APPEND_MASK       ((DWORD)0x000000F)     
#define PLA_DATASTORE_OVERWRITE         ((DWORD)0x0000001)     
#define PLA_DATASTORE_APPEND            ((DWORD)0x0000002)     

#define PLA_DATASTORE_SIZE_MASK         ((DWORD)0x00000F0)     
#define PLA_DATASTORE_SIZE_ONE_RECORD   ((DWORD)0x0000010)     
#define PLA_DATASTORE_SIZE_KB           ((DWORD)0x0000020)     
#define PLA_DATASTORE_SIZE_MB           ((DWORD)0x0000040)     

#define PLA_FIRST_FILE_TYPE ((DWORD)0x00000000)
#define PLA_CSV_FILE        ((DWORD)0x00000000)
#define PLA_TSV_FILE        ((DWORD)0x00000001)
#define PLA_BIN_FILE        ((DWORD)0x00000002)
#define PLA_BIN_CIRC_FILE   ((DWORD)0x00000003)
#define PLA_CIRC_TRACE_FILE ((DWORD)0x00000004)
#define PLA_SEQ_TRACE_FILE  ((DWORD)0x00000005)
#define PLA_SQL_LOG         ((DWORD)0x00000006)
#define PLA_NUM_FILE_TYPES  ((DWORD)0x00000007)

#define PLA_SLF_NAME_NONE           ((DWORD)0xFFFFFFFF)
#define PLA_SLF_NAME_FIRST_AUTO     ((DWORD)0x00000000)
#define PLA_SLF_NAME_MMDDHH         ((DWORD)0x00000000)
#define PLA_SLF_NAME_NNNNNN         ((DWORD)0x00000001)
#define PLA_SLF_NAME_YYYYDDD        ((DWORD)0x00000002)
#define PLA_SLF_NAME_YYYYMM         ((DWORD)0x00000003)
#define PLA_SLF_NAME_YYYYMMDD       ((DWORD)0x00000004)
#define PLA_SLF_NAME_YYYYMMDDHH     ((DWORD)0x00000005)
#define PLA_SLF_NAME_MMDDHHMM       ((DWORD)0x00000006)
#define PLA_SLF_NUM_AUTO_NAME_TYPES ((DWORD)0x00000007)

// Sysmon log query types and constants

// Constants
#define PLA_DISK_MAX_SIZE   ((DWORD)-1)

#define PLA_LOG_SIZE_UNIT_MB                (1024*1024)
#define PLA_LOG_SIZE_UNIT_KB                1024

#define PLA_TLI_ENABLE_BUFFER_FLUSH         ((DWORD)0x00000001)
#define PLA_TLI_ENABLE_KERNEL_TRACE         ((DWORD)0x00000002)
#define PLA_TLI_ENABLE_MEMMAN_TRACE         ((DWORD)0x00000004)
#define PLA_TLI_ENABLE_FILEIO_TRACE         ((DWORD)0x00000008)
#define PLA_TLI_ENABLE_PROCESS_TRACE        ((DWORD)0x00000010)
#define PLA_TLI_ENABLE_THREAD_TRACE         ((DWORD)0x00000020)
#define PLA_TLI_ENABLE_DISKIO_TRACE         ((DWORD)0x00000040)
#define PLA_TLI_ENABLE_NETWORK_TCPIP_TRACE  ((DWORD)0x00000080)

#define PLA_TLI_ENABLE_MASK                 ((DWORD)0x000000FF)
#define PLA_TLI_ENABLE_KERNEL_MASK          ((DWORD)0x000000FE)

// alert action flags
#define PLA_ALRT_ACTION_LOG_EVENT   ((DWORD)0x00000001)
#define PLA_ALRT_ACTION_SEND_MSG    ((DWORD)0x00000002)
#define PLA_ALRT_ACTION_EXEC_CMD    ((DWORD)0x00000004)
#define PLA_ALRT_ACTION_START_LOG   ((DWORD)0x00000008)
#define PLA_ALRT_ACTION_MASK        ((DWORD)0x0000000F)

#define PLA_ALRT_CMD_LINE_SINGLE    ((DWORD)0x00000100)
#define PLA_ALRT_CMD_LINE_A_NAME    ((DWORD)0x00000200)
#define PLA_ALRT_CMD_LINE_C_NAME    ((DWORD)0x00000400)
#define PLA_ALRT_CMD_LINE_D_TIME    ((DWORD)0x00000800)
#define PLA_ALRT_CMD_LINE_L_VAL     ((DWORD)0x00001000)
#define PLA_ALRT_CMD_LINE_M_VAL     ((DWORD)0x00002000)
#define PLA_ALRT_CMD_LINE_U_TEXT    ((DWORD)0x00004000)
#define PLA_ALRT_CMD_LINE_MASK      ((DWORD)0x00007F00)

#define PLA_ALRT_DEFAULT_ACTION     ((DWORD)0x00000001) // log event is default

#define PLA_AIBF_UNDER  0L
#define PLA_AIBF_OVER   ((DWORD)0x00000001) // true when "over" limit is selected
#define PLA_AIBF_SEEN   ((DWORD)0x00000002) // set when the user has seen this value
#define PLA_AIBF_SAVED  ((DWORD)0x00000004) // true when user has saved this entry in an edit box
 
typedef struct _PLA_ALERT_INFO_BLOCK {
    DWORD   dwSize;
    LPTSTR  szCounterPath;
    DWORD   dwFlags;
    double  dLimit;
} PLA_ALERT_INFO_BLOCK, *PPLA_ALERT_INFO_BLOCK;

#ifdef __cplusplus
}
#endif

#endif // __PDHP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\inc\perftype.h ===
/*++
Copyright (C) 1996-1999 Microsoft Corporation

Module Name:
    perftype.h

Abstract:
    Datatype definitions used by performance api utilities
--*/
#ifndef _PERFTYPE_H_
#define _PERFTYPE_H_

#include <windows.h>
#include <winperf.h>

#ifndef _DEBUG_MUTEXES
#define _DEBUG_MUTEXES 0    // for debugging
#endif

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define STR_COUNTER 0
#define STR_HELP    1

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

// default retry interval is no more often than every 120 seconds (2 min)
#define RETRY_TIME_INTERVAL ((LONGLONG)(1200000000))

typedef struct _LOCAL_PERF_NAME_INFO {
    HKEY    hKeyPerflib;
    HANDLE  hNameFile;
    HANDLE  hHelpFile;
    HANDLE  hNameFileObject;
    HANDLE  hHelpFileObject;
    LPVOID  pNameFileBaseAddr;
    LPVOID  pHelpFileBaseAddr;
} LOCAL_PERF_NAME_INFO, * PLOCAL_PERF_NAME_INFO;

#define OS_VER_SIZE 8
typedef struct _PERF_MACHINE {
    HKEY                    hKeyPerformanceData;
    LPWSTR                  szName;
    PERF_DATA_BLOCK       * pSystemPerfData;
    LPWSTR                * szPerfStrings;
    LPWSTR                * sz009PerfStrings;
    BYTE                  * typePerfStrings;
    FILETIME                LastStringUpdateTime;
    DWORD                   dwLastPerfString;
    DWORD                   dwRefCount;
    LPWSTR                  szQueryObjects;
    DWORD                   dwStatus;
    LONGLONG                llRetryTime;
    HANDLE                  hMutex;
    DWORD                   dwRetryFlags;
    DWORD                   dwMachineFlags;
    PLOCAL_PERF_NAME_INFO   pLocalNameInfo;
    WCHAR                   szOsVer[OS_VER_SIZE];
    struct  _PERF_MACHINE * pNext;
    struct  _PERF_MACHINE * pPrev;
    DWORD                   dwThreadId;
    DWORD                   dwObjectId;
} PERF_MACHINE, *PPERF_MACHINE;

#define PDHIPM_FLAGS_HAVE_COSTLY    ((DWORD)0x00000001)
#define PDHIPM_FLAGS_USING_RPDH     ((DWORD)0x00000002)
#define PDHIPM_FLAGS_TRY_RPDH_FIRST ((DWORD)0x00000004)

typedef struct _PERFLIB_COUNTER {
    DWORD   dwObjectId;
    LONG    lInstanceId;
    LPWSTR  szInstanceName;
    DWORD   dwParentObjectId;
    LPWSTR  szParentInstanceName;
    DWORD   dwCounterId;
    DWORD   dwCounterType;
    DWORD   dwCounterSize;
    LONG    lDefaultScale;
    DWORD	dwSQLCounterId;
} PERFLIB_COUNTER, *PPERFLIB_COUNTER;

//
//  function definitions
//
// perfutil.c

extern PPERF_MACHINE   pFirstMachine;

PDH_STATUS
ConnectMachine(
    PPERF_MACHINE   pThisMachine
);

PDH_STATUS
ValidateMachineConnection(
    PPERF_MACHINE   pMachine
);


PPERF_MACHINE
GetMachine(
    LPWSTR  szMachineName,
    DWORD   dwIndex,
    DWORD   dwFlags
);

// GetMachine Flags...
#define PDH_GM_UPDATE_NAME          ((DWORD) 0x00000001)
#define PDH_GM_UPDATE_PERFDATA      ((DWORD) 0x00000002)
#define PDH_GM_READ_COSTLY_DATA     ((DWORD) 0x00000004)
#define PDH_GM_UPDATE_PERFNAME_ONLY ((DWORD) 0x00000008)

BOOL
FreeMachine(
    PPERF_MACHINE   pMachine,
    BOOL            bForceRelease,
    BOOL            bProcessExit
);

BOOL
FreeAllMachines(
    BOOL bProcessExit
);

DWORD
GetObjectId(
    PPERF_MACHINE   pMachine,
    LPWSTR          szObjectName,
    BOOL          * bInstances
);

DWORD
GetCounterId(
    PPERF_MACHINE pMachine,
    DWORD         dwObjectId,
    LPWSTR        szCounterName
);

BOOL
AppendObjectToValueList(
    DWORD   dwObjectId,
    PWSTR   pwszValueList,
    DWORD   dwValueList
);

BOOL
GetObjectPerfInfo(
    PPERF_DATA_BLOCK  pPerfData,
    DWORD           dwObjectId,
    LONGLONG        *pPerfTime,
    LONGLONG        *pPerfFreq
);

// internal PerfName.C functions

LPCWSTR
PdhiLookupPerfNameByIndex(
    PPERF_MACHINE  pMachine,
    DWORD   dwNameIndex
);

DWORD
PdhiLookupPerfIndexByName(
    PPERF_MACHINE  pMachine,
    LPCWSTR        szNameBuffer
);

#endif // _PERFTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\inc\resource.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Resource symbols used by pdh.rc

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pdh.rc
//
#define IDS_ERR_UNABLE_TO_CONNECT       10005
#define IDS_BRWS_NO_OBJECTS             10006
#define IDS_BRWS_NO_COUNTERS            10007
#define IDS_BRWS_NO_INSTANCES           10008
#define IDS_BRWS_ADD                    10009
#define IDS_BRWS_CLOSE                  10010
#define IDS_BRWS_OK                     10011
#define IDS_BRWS_CANCEL                 10012
#define IDS_ERR_MACHINE_NOT_IN_LOGFILE  10013
#define IDS_ERR_NO_HELP                 10014
#define IDS_DSRC_SELECT                 10015

#define IDS_LOGTYPE_PDH_LOGS            10016
#define IDS_LOGTYPE_BIN_LOGS            10017
#define IDS_LOGTYPE_CSV_LOGS            10018
#define IDS_LOGTYPE_TSV_LOGS            10019
#define IDS_LOGTYPE_PM_LOGS             10020
#define IDS_LOGTYPE_ALL_LOGS            10021
#define IDS_LOGTYPE_ALL_FILES           10022
#define IDS_PERFFILE_FRIENDLYNAME       10023

#define IDS_COLLECT_TIMEOUT             10024

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        10024
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         4003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhcalc\pdhicalc.h ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    pdhicalc.h

Abstract:

    calculation functions for the Data Provider Helper.

--*/

#ifndef _PDHICALC_H_
#define _PDHICALC_H_

#include <pdh.h>        // for public PDH data types
#include <winperf.h>    // for perf counter type constants

#if defined(__cplusplus)
#define LINK_SPEC extern "C"
#else
#define LINK_SPEC
#endif

// special perf counter type used by text log files
// value is stored as a double precision floating point value
#define PERF_DOUBLE_RAW  (PERF_SIZE_DWORD | 0x00002000 | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL)

typedef double (APIENTRY   COUNTERCALC)   (PPDH_RAW_COUNTER, PPDH_RAW_COUNTER, LONGLONG *, LPDWORD);
typedef double (APIENTRY * LPCOUNTERCALC) (PPDH_RAW_COUNTER, PPDH_RAW_COUNTER, LONGLONG *, LPDWORD);

typedef PDH_STATUS (APIENTRY   COUNTERSTAT)   (LPVOID, DWORD, DWORD, DWORD, PPDH_RAW_COUNTER, PPDH_STATISTICS);
typedef PDH_STATUS (APIENTRY * LPCOUNTERSTAT) (LPVOID, DWORD, DWORD, DWORD, PPDH_RAW_COUNTER, PPDH_STATISTICS);

// calc functions
extern COUNTERCALC PdhiCalcDouble;
extern COUNTERCALC PdhiCalcAverage;
extern COUNTERCALC PdhiCalcElapsedTime;
extern COUNTERCALC PdhiCalcRawFraction;
extern COUNTERCALC PdhiCalcCounter;
extern COUNTERCALC PdhiCalcTimer;
extern COUNTERCALC PdhiCalcInverseTimer;
extern COUNTERCALC PdhiCalcRawCounter;
extern COUNTERCALC PdhiCalcNoData;
extern COUNTERCALC PdhiCalcDelta;

// status functions
extern COUNTERSTAT PdhiComputeFirstLastStats;
extern COUNTERSTAT PdhiComputeRawCountStats;
extern COUNTERSTAT PdhiComputeNoDataStats;

LINK_SPEC
PDH_STATUS 
PdhiComputeFormattedValue(
    IN      LPCOUNTERCALC           pCalcFunc,
    IN      DWORD                   dwCounterType,
    IN      LONG                    lScale,
    IN      DWORD                   dwFormat,
    IN      PPDH_RAW_COUNTER        pRawValue1,
    IN      PPDH_RAW_COUNTER        pRawValue2,
    IN      PLONGLONG               pTimeBase,
    IN      DWORD                   dwReserved,
    IN  OUT PPDH_FMT_COUNTERVALUE   fmtValue
);

LINK_SPEC
BOOL
AssignCalcFunction(
    IN  DWORD           dwCounterType,
    IN  LPCOUNTERCALC * pCalcFunc,
    IN  LPCOUNTERSTAT * pStatFunc
);

#endif // _PDHICALC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\inc\wbemdef.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    wbemdef.h

Abstract:

    data types and other declarations used internally by the 
    Data Provider Helper functions for interface with WBEM data 
    providers

--*/

#ifndef _PDHI_WBEM_DEF_H_
#define _PDHI_WBEM_DEF_H_

#include <windows.h>
#include <wbemcli.h>
#include <wbemprov.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _PDHI_WBEM_OBJECT_DEF {
    struct _PDHI_WBEM_OBJECT_DEF * pNext;
    LPWSTR                  szObject;
    LPWSTR                  szDisplay; 
    BOOL                    bDefault;
    IWbemClassObject      * pClass;
} PDHI_WBEM_OBJECT_DEF, * PPDHI_WBEM_OBJECT_DEF;
    
typedef struct _PDHI_WBEM_SERVER_DEF {
    struct _PDHI_WBEM_SERVER_DEF * pNext;
    LPWSTR                  szMachine;  // includes namespace
    DWORD                   dwCache;
    IWbemServices         * pSvc;
    LONG                    lRefCount;
    PPDHI_WBEM_OBJECT_DEF   pObjList;
} PDHI_WBEM_SERVER_DEF, * PPDHI_WBEM_SERVER_DEF;

extern PPDHI_WBEM_SERVER_DEF pFirstWbemServer;

#ifdef __cplusplus
}
#endif

#endif //_PDHI_WBEM_DEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\inc\perfdata.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    perfdata.h

Abstract:

    <abstract>

--*/

#ifndef _PERFDATA_H_
#define _PERFDATA_H_

typedef LPVOID  LPMEMORY;
typedef HGLOBAL HMEMORY;

#ifndef UNICODE_NULL
// then the unicode string struct is probably not defined either
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt
#endif

LPWSTR *
BuildNameTable(
    LPWSTR  szComputerName, // computer to query names from 
    LANGID    LangId,       // language ID
    PPERF_MACHINE pMachine  // to update member fields
);

__inline
PPERF_OBJECT_TYPE
FirstObject(
    PPERF_DATA_BLOCK pPerfData
)
{
    PPERF_OBJECT_TYPE pObject = NULL;

    if (pPerfData != NULL && pPerfData->TotalByteLength > pPerfData->HeaderLength) {
        pObject = (PPERF_OBJECT_TYPE) (((LPBYTE) pPerfData) + pPerfData->HeaderLength);
        if (pPerfData->TotalByteLength < pPerfData->HeaderLength + pObject->TotalByteLength) {
            pObject = NULL;
        }
    }
    return pObject;
}

__inline
PPERF_OBJECT_TYPE
NextObject(
    PPERF_DATA_BLOCK  pPerfData,
    PPERF_OBJECT_TYPE pThisObject
)
{
    PPERF_OBJECT_TYPE pObject = NULL;

    if (pPerfData != NULL && pThisObject != NULL) {
        if (pThisObject->TotalByteLength != 0) {
            PPERF_OBJECT_TYPE pEndObject  = (PPERF_OBJECT_TYPE) (((PCHAR) pPerfData) + pPerfData->TotalByteLength);
            PPERF_OBJECT_TYPE pNextObject = (PPERF_OBJECT_TYPE) (((PCHAR) pThisObject) + pThisObject->TotalByteLength);

            if (pNextObject < pEndObject) {
                pObject = pNextObject;
            }
        }
    }
    return pObject;
}

PPERF_OBJECT_TYPE
GetObjectDefByTitleIndex(
    PPERF_DATA_BLOCK pDataBlock,
    DWORD            ObjectTypeTitleIndex
);

PPERF_OBJECT_TYPE
GetObjectDefByName(
    PPERF_DATA_BLOCK   pDataBlock,
    DWORD              dwLastNameIndex,
    LPCWSTR          * NameArray,
    LPCWSTR            szObjectName
);

__inline
PPERF_INSTANCE_DEFINITION
FirstInstance(
    PPERF_OBJECT_TYPE pObject
)
{
    PPERF_INSTANCE_DEFINITION pInstDef = NULL;

    if (pObject != NULL && pObject->TotalByteLength > pObject->DefinitionLength
                        && pObject->DefinitionLength > pObject->HeaderLength) {
        pInstDef = (PPERF_INSTANCE_DEFINITION) (((LPBYTE) pObject) + pObject->DefinitionLength);
        if (pObject->TotalByteLength < pObject->DefinitionLength + pInstDef->ByteLength) {
            pInstDef = NULL;
        }
    }
    return pInstDef;
}


__inline
PPERF_INSTANCE_DEFINITION
NextInstance(
    PPERF_OBJECT_TYPE         pObject,
    PPERF_INSTANCE_DEFINITION pInstDef
)
{
    PPERF_INSTANCE_DEFINITION pNextInst = NULL;

    if (pObject != NULL && pInstDef != NULL) {
        PPERF_OBJECT_TYPE   pEndObject    = (PPERF_OBJECT_TYPE) (((PCHAR) pObject) + pObject->TotalByteLength);
        PPERF_COUNTER_BLOCK pCounterBlock = (PPERF_COUNTER_BLOCK) (((PCHAR) pInstDef) + pInstDef->ByteLength);

        if ((LPVOID) pCounterBlock < (LPVOID) pEndObject) {
            pNextInst = (PPERF_INSTANCE_DEFINITION) (((PCHAR) pCounterBlock) + pCounterBlock->ByteLength);
            if ((LPVOID) pNextInst >= (LPVOID) pEndObject) {
                pNextInst = NULL;
            }
        }
    }
    return pNextInst;
}

PPERF_INSTANCE_DEFINITION
GetInstance(
    PERF_OBJECT_TYPE *pObjectDef,
    LONG InstanceNumber
);

PPERF_INSTANCE_DEFINITION
GetInstanceByUniqueId(
    PERF_OBJECT_TYPE *pObjectDef,
    LONG InstanceUniqueId
);

DWORD
GetInstanceNameStr(
    PPERF_INSTANCE_DEFINITION   pInstance,
    LPWSTR                    * lpszInstance,
    DWORD                       dwCodePage
);

DWORD
GetFullInstanceNameStr(
    PPERF_DATA_BLOCK           pPerfData,
    PPERF_OBJECT_TYPE          pObjectDef,
    PPERF_INSTANCE_DEFINITION  pInstanceDef,
    LPWSTR                     szInstanceName,
    DWORD                      dwInstanceName
);

BOOL IsMatchingInstance(
    PPERF_INSTANCE_DEFINITION pInstanceDef, 
    DWORD                     dwCodePage,
    LPWSTR                    szInstanceNameToMatch,
    DWORD                     dwInstanceNameLength
);


__inline
PPERF_COUNTER_DEFINITION
FirstCounter(
    PPERF_OBJECT_TYPE pObject
)
{
    PPERF_COUNTER_DEFINITION pCounter = NULL;

    if (pObject != NULL && pObject->TotalByteLength >= pObject->DefinitionLength
                        && pObject->DefinitionLength > pObject->HeaderLength) {
        pCounter = (PPERF_COUNTER_DEFINITION) (((LPBYTE) pObject) + pObject->HeaderLength);
        if (pObject->DefinitionLength < pObject->HeaderLength + pCounter->ByteLength) {
            pCounter = NULL;
        }
    }
    return pCounter;
}

__inline
PPERF_COUNTER_DEFINITION
NextCounter(
    PPERF_OBJECT_TYPE        pObject,
    PPERF_COUNTER_DEFINITION pCounterDef
)
{
    PPERF_COUNTER_DEFINITION pCounter = NULL;

    if (pObject != NULL && pCounterDef != NULL) {
        PPERF_COUNTER_DEFINITION pEndCounter =
                        (PPERF_COUNTER_DEFINITION) (((PCHAR) pObject) + pObject->DefinitionLength);
        if (pCounterDef < pEndCounter && pCounterDef->ByteLength > 0) {
            pCounter = (PPERF_COUNTER_DEFINITION) (((PCHAR) pCounterDef) + pCounterDef->ByteLength);
            if (pCounter >= pEndCounter) {
                pCounter = NULL;
            }
        }
    }

    return pCounter;
}

PPERF_COUNTER_DEFINITION
GetCounterDefByName(
    PPERF_OBJECT_TYPE   pObject,
    DWORD               dwLastNameIndex,
    LPWSTR            * NameArray,
    LPWSTR              szCounterName
);

PPERF_COUNTER_DEFINITION
GetCounterDefByTitleIndex(
    PPERF_OBJECT_TYPE pObjectDef,
    BOOL              bBaseCounterDef,
    DWORD             CounterTitleIndex
);

LONG
GetSystemPerfData(
    HKEY               hKeySystem,
    PPERF_DATA_BLOCK * pPerfData,
    LPWSTR             szObjectList,
    BOOL               bCollectCostlyData
);

PPERF_INSTANCE_DEFINITION
GetInstanceByName(
    PPERF_DATA_BLOCK  pDataBlock,
    PPERF_OBJECT_TYPE pObjectDef,
    LPWSTR            pInstanceName,
    LPWSTR            pParentName,
    DWORD             dwIndex
);

__inline
LPWSTR GetInstanceName(
    PPERF_INSTANCE_DEFINITION  pInstDef
)
{
    LPWSTR szInstance = NULL;

    if (pInstDef != NULL && (pInstDef->ByteLength >= pInstDef->NameOffset + pInstDef->NameLength)) {
        szInstance = (LPWSTR) (((ULONG_PTR) pInstDef) + pInstDef->NameOffset);
    }
    return szInstance;
}



__inline
PVOID
GetCounterDataPtr(
    PPERF_OBJECT_TYPE        pObjectDef,
    PPERF_COUNTER_DEFINITION pCounterDef
)
{

    PPERF_COUNTER_BLOCK pCtrBlock;

    pCtrBlock = (PPERF_COUNTER_BLOCK) ((PCHAR)pObjectDef + pObjectDef->DefinitionLength);
    return (pCtrBlock->ByteLength >= pCounterDef->CounterOffset + pCounterDef->CounterSize)
            ? (PVOID) ((PCHAR) pCtrBlock + pCounterDef->CounterOffset)
            : NULL;
}

__inline
PVOID
GetInstanceCounterDataPtr(
    PPERF_OBJECT_TYPE         pObjectDef,
    PPERF_INSTANCE_DEFINITION pInstanceDef,
    PPERF_COUNTER_DEFINITION  pCounterDef
)
{
    PPERF_COUNTER_BLOCK pCtrBlock;

    UNREFERENCED_PARAMETER(pObjectDef);
    pCtrBlock = (PPERF_COUNTER_BLOCK) ((PCHAR)pInstanceDef + pInstanceDef->ByteLength);
    return (pCtrBlock->ByteLength >= pCounterDef->CounterOffset + pCounterDef->CounterSize)
            ? (PVOID) ((PCHAR) pCtrBlock + pCounterDef->CounterOffset)
            : NULL;
}

#endif //_PERFDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\inc\strings.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    strings.h

Abstract:

    String constants used by the functions in the PDH.DLL library

--*/

#ifndef _PDH_STRINGS_H_
#define _PDH_STRINGS_H_

#ifdef __cplusplus
extern "C" {
#endif

#define POUNDSIGN_L     ((WCHAR)L'#')
#define SPLAT_L         ((WCHAR)L'*')
#define SLASH_L         ((WCHAR)L'/')
#define BACKSLASH_L     ((WCHAR)L'\\')
#define LEFTPAREN_L     ((WCHAR)L'(')
#define RIGHTPAREN_L    ((WCHAR)L')')
#define SPACE_L         ((WCHAR)L' ')
#define COLON_L         ((WCHAR)L':')
#define ATSIGN_L        ((WCHAR)L'@')

#define POUNDSIGN_A     ((UCHAR)'#')
#define BACKSLASH_A     ((UCHAR)'\\')
#define DOUBLEQUOTE_A   ((UCHAR)'\"')
#define COLON_A         ((UCHAR)':')

extern LPCWSTR    cszAppShortName;

// registry path, key and value strings
extern LPCWSTR    cszNamesKey;

extern LPCWSTR    cszDefaultLangId;
extern LPCWSTR    cszCounters;
extern LPCWSTR    cszHelp;
extern LPCWSTR    cszLastHelp;
extern LPCWSTR    cszLastCounter;
extern LPCWSTR    cszVersionName;
extern LPCWSTR    cszCounterName;
extern LPCWSTR    cszHelpName;
extern LPCWSTR    cszGlobal;
extern LPCWSTR    cszCostly;
extern LPCWSTR    cszLogQueries;
extern LPCWSTR    cszLogFileType;
extern LPCWSTR    cszAutoNameInterval;
extern LPCWSTR    cszLogFileName;
extern LPCWSTR    cszLogDefaultDir;
extern LPCWSTR    cszBaseFileName;
extern LPCWSTR    cszLogFileAutoFormat;
extern LPCWSTR    cszAutoRenameUnits;
extern LPCWSTR    cszCommandFile;
extern LPCWSTR    cszCounterList;
extern LPCSTR     caszCounterList;
extern LPCWSTR    cszPerfDataLog;
extern LPCWSTR    cszDefault;
extern LPCSTR     caszDefaultLogCaption;
extern LPCWSTR    cszPerfNamePathPrefix;
extern LPCWSTR    cszDat;
extern LPCWSTR    cszWBEM;
extern LPCWSTR    cszWMI;
extern LPCWSTR    cszSQL;
extern LPCSTR     caszWBEM;
extern LPCSTR     caszWMI;
extern LPCWSTR    cszWbemDefaultPerfRoot;
extern LPCWSTR    cszSingletonInstance;
extern LPCWSTR    cszNameParam;
extern LPCWSTR    cszCountertype;
extern LPCWSTR    cszDisplayname;
extern LPCWSTR    cszExplainText;
extern LPCWSTR    cszSingleton;
extern LPCWSTR    cszPerfdetail;
extern LPCWSTR    cszPerfdefault;
extern LPCWSTR    cszDefaultscale;
extern LPCWSTR    cszClass;
extern LPCWSTR    cszPerfRawData;
extern LPCWSTR    cszNotFound;
extern LPCWSTR    cszName;
extern LPCWSTR    cszBaseSuffix;
extern LPCWSTR    cszTimestampPerfTime;
extern LPCWSTR    cszFrequencyPerfTime;
extern LPCWSTR    cszTimestampSys100Ns;
extern LPCWSTR    cszFrequencySys100Ns;
extern LPCWSTR    cszTimestampObject;
extern LPCWSTR    cszFrequencyObject;
extern LPCWSTR    cszPerfmonLogSig;

extern LPCWSTR    cszRemoteMachineRetryTime;
extern LPCWSTR    cszEnableRemotePdhAccess;
extern LPCWSTR    cszPdhKey;
extern LPCWSTR    cszDefaultNullDataSource;
extern LPCWSTR    cszCollectTimeout;
extern LPCWSTR    cszLogSectionName;
extern LPCWSTR    cszCurrentVersionKey;
extern LPCWSTR    cszCurrentVersionValueName;

extern LPCWSTR    fmtDecimal;
extern LPCWSTR    fmtSpaceDecimal;
extern LPCWSTR    fmtLangId;

// single character strings
extern LPCWSTR    cszEmptyString;
extern LPCWSTR    cszPoundSign;
extern LPCWSTR    cszSplat;
extern LPCWSTR    cszSlash;
extern LPCWSTR    cszBackSlash;
extern LPCWSTR    cszLeftParen;
extern LPCWSTR    cszRightParen;
extern LPCWSTR    cszC;
extern LPCWSTR    cszH;
extern LPCWSTR    cszColon;
extern LPCWSTR    cszDoubleQuote;

extern LPCSTR     caszPoundSign;
extern LPCSTR     caszSplat;
extern LPCSTR     caszSlash;
extern LPCSTR     caszBackSlash;
extern LPCSTR     caszDoubleBackSlash;
extern LPCSTR     caszLeftParen;
extern LPCSTR     caszRightParen;
extern LPCSTR     caszSpace;

extern LPCWSTR    cszDoubleBackSlash;
extern LPCWSTR    cszDoubleBackSlashDot;
extern LPCWSTR    cszRightParenBackSlash;

// other general strings
extern LPCWSTR    cszSpacer;
extern LPCWSTR    cszBlg;

// strings only used in DEBUG builds
#ifdef _DEBUG
extern LPCWSTR    cszNameDontMatch;
extern LPCWSTR    cszNotice;
#endif

#ifdef __cplusplus
}
#endif

#endif //_PDH_STRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhdll\makefile.inc ===
PRIVLIB= $(O)\pdhp.lib
$(O)\pdh.lib : $(PRIVLIB)


$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\pdhp.def $(LIBRARY_OBJS)
   -lib -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\pdhp.def
$(LIBRARY_OBJS)
<<NOKEEP

$(O)\pdhp.def: pdh.def
    $(C_PREPROCESSOR) $** -DPRIVATE= > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhdll\counter.c ===
/*++
Copyright (C) 1996-1999 Microsoft Corporation

Module Name:
    counter.c

Abstract:
    counter processing functions exposed in pdh.dll
--*/

#include <windows.h>
#include <stdlib.h>
#include <math.h>
#include <mbctype.h>
#include "strsafe.h"
#include <pdh.h>
#include "pdhitype.h"
#include "pdhidef.h"
#include "pdhmsg.h"
#include "strings.h"

__inline
DWORD
PdhiGetStringLength(
    LPWSTR szString,
    BOOL   bUnicode
)
{
    DWORD dwReturn = 0;

    if (bUnicode) {
        dwReturn = lstrlenW(szString);
    }
    else {
        dwReturn = WideCharToMultiByte(_getmbcp(), 0, szString, lstrlenW(szString), NULL, 0, NULL, NULL);
    }
    return dwReturn;
}

STATIC_PDH_FUNCTION
PdhiGetFormattedCounterArray(
    PPDHI_COUNTER   pCounter,
    DWORD           dwFormat,
    LPDWORD         lpdwBufferSize,
    LPDWORD         lpdwItemCount,
    LPVOID          ItemBuffer,
    BOOL            bWideArgs
)
{
    PDH_STATUS                   PdhStatus      = ERROR_SUCCESS;
    PDH_STATUS                   PdhFnStatus    = ERROR_SUCCESS;
    DWORD                        dwRequiredSize = 0;
    WCHAR                        wszInstanceName[32];
    PPDHI_RAW_COUNTER_ITEM       pThisItem      = NULL;
    PPDHI_RAW_COUNTER_ITEM       pLastItem      = NULL;
    PDH_RAW_COUNTER              ThisRawCounter;
    PDH_RAW_COUNTER              LastRawCounter;
    LPWSTR                       szThisItem;
    LPWSTR                       szLastItem;
    PPDH_RAW_COUNTER             pThisRawCounter;
    PPDH_RAW_COUNTER             pLastRawCounter;
    PPDH_FMT_COUNTERVALUE_ITEM_W pThisFmtItem;
    DWORD                        dwThisItemIndex;
    LPWSTR                       wszNextString;
    DWORD                        dwNameLength;
    DWORD                        dwRetItemCount = 0;

    PdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pCounter->pOwner->hMutex);
    if (PdhStatus != ERROR_SUCCESS) {
        return PdhStatus;
    }

    // compute required buffer size
    if (pCounter->dwFlags & PDHIC_MULTI_INSTANCE) {
        if (ItemBuffer != NULL) {
            pThisFmtItem = (PPDH_FMT_COUNTERVALUE_ITEM_W) ItemBuffer;
            if( pCounter->pThisRawItemList == NULL) {
                PdhStatus = PDH_CSTATUS_ITEM_NOT_VALIDATED;
                goto Cleanup;
            }
            wszNextString = (LPWSTR)((LPBYTE) ItemBuffer + (sizeof (PDH_FMT_COUNTERVALUE_ITEM_W) *
                                                            pCounter->pThisRawItemList->dwItemCount));
            // verify 8 byte alignment
        }
        else {
            pThisFmtItem  = NULL;
            wszNextString = NULL;
        }

        // for multi structs, the buffer required
        dwThisItemIndex = 0;
        dwRequiredSize += (DWORD)(pCounter->pThisRawItemList->dwItemCount) *
                            (bWideArgs ? sizeof (PDH_FMT_COUNTERVALUE_ITEM_W) : sizeof (PDH_FMT_COUNTERVALUE_ITEM_A));
        for (pThisItem = & (pCounter->pThisRawItemList->pItemArray[0]);
                        dwThisItemIndex < pCounter->pThisRawItemList->dwItemCount;
                        dwThisItemIndex ++, pThisItem ++, pLastItem ++) {
            szThisItem = (LPWSTR) (((LPBYTE) pCounter->pThisRawItemList) + pThisItem->szName);
            if (bWideArgs) {
                dwNameLength    = lstrlenW(szThisItem) + 1;
                dwRequiredSize += dwNameLength * sizeof(WCHAR);
                if ((dwRequiredSize <= * lpdwBufferSize) && (wszNextString != NULL)) {
                    // this is the only field that is type dependent  (i.e.
                    // wide vs ansi chars.
                    pThisFmtItem->szName = wszNextString;
                    StringCchCopyW(wszNextString, dwNameLength, szThisItem);
                    wszNextString       += dwNameLength;
                    PdhStatus            = ERROR_SUCCESS;
                }
                else {
                    PdhStatus = PDH_MORE_DATA;
                }
            }
            else {
                DWORD dwSize = (* lpdwBufferSize < dwRequiredSize) ? (0) : (* lpdwBufferSize - dwRequiredSize);
                PdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(), szThisItem, (LPSTR) wszNextString, & dwSize);
                if (wszNextString && PdhStatus == ERROR_SUCCESS) {
                    pThisFmtItem->szName = wszNextString;
                    wszNextString        = (LPWSTR) ((LPSTR) wszNextString + dwSize);
                }
                dwRequiredSize += (dwSize * sizeof(CHAR));
            }

            if (PdhStatus == ERROR_SUCCESS) {
                //
                // COMPUTE FORMATTED VALUE HERE!!!
                //
                if (pCounter->pThisRawItemList != NULL) {
                    ThisRawCounter.CStatus     = pCounter->pThisRawItemList->CStatus;
                    ThisRawCounter.TimeStamp   = pCounter->pThisRawItemList->TimeStamp;
                    ThisRawCounter.FirstValue  = pThisItem->FirstValue;
                    ThisRawCounter.SecondValue = pThisItem->SecondValue;
                    ThisRawCounter.MultiCount  = pThisItem->MultiCount;
                    pThisRawCounter            = & ThisRawCounter;
                }
                else {
                    ZeroMemory(& ThisRawCounter, sizeof(ThisRawCounter));
                    pThisRawCounter = NULL;
                }

                if (pCounter->pLastRawItemList != NULL) {
                    // test to see if "This" buffer has more entries than "last" buffer
                    if (dwThisItemIndex < pCounter->pLastRawItemList->dwItemCount) {
                        pLastItem  = &(pCounter->pLastRawItemList->pItemArray[dwThisItemIndex]);
                        szLastItem = (LPWSTR) (((LPBYTE) pCounter->pLastRawItemList) + pLastItem->szName);
                        if (lstrcmpiW(szThisItem, szLastItem) == 0) {
                            // the names match so we'll assume this is the correct instance
                            LastRawCounter.CStatus     = pCounter->pLastRawItemList->CStatus;
                            LastRawCounter.TimeStamp   = pCounter->pLastRawItemList->TimeStamp;
                            LastRawCounter.FirstValue  = pLastItem->FirstValue;
                            LastRawCounter.SecondValue = pLastItem->SecondValue;
                            LastRawCounter.MultiCount  = pLastItem->MultiCount;
                            pLastRawCounter            = & LastRawCounter;
                        }
                        else {
                            // the names DON'T match so we'll try the calc on just
                            // one value. This will work for some (e.g. instantaneous)
                            // counters, but not all
                            ZeroMemory(& LastRawCounter, sizeof(LastRawCounter));
                            pLastRawCounter = NULL;
                        }
                    }
                    else {
                        // the new buffer is larger than the old one so 
                        // we'll try the calc function on just
                        // one value. This will work for some (e.g. instantaneous)
                        // counters, but not all
                        ZeroMemory(& LastRawCounter, sizeof(LastRawCounter));
                        pLastRawCounter = NULL;
                    }
                }
                else {
                    // there is no "previous" counter entry for this counter
                    ZeroMemory(& LastRawCounter, sizeof(LastRawCounter));
                    pLastRawCounter = NULL;
                }
                PdhFnStatus = PdhiComputeFormattedValue(pCounter->CalcFunc,
                                                        pCounter->plCounterInfo.dwCounterType,
                                                        pCounter->lScale,
                                                        dwFormat,
                                                        pThisRawCounter,
                                                        pLastRawCounter,
                                                        & pCounter->TimeBase,
                                                        0L,
                                                        & pThisFmtItem->FmtValue);
                if (PdhFnStatus != ERROR_SUCCESS) {
                    // save the last error encountered for return to the caller
                    PdhStatus = PdhFnStatus;

                    // error in calculation so set the status for this
                    // counter item
                    pThisFmtItem->FmtValue.CStatus = PDH_CSTATUS_INVALID_DATA;
                    // clear the value
                    pThisFmtItem->FmtValue.largeValue = 0;
                }

                // update pointers
                pThisFmtItem ++;
            }
        }

        dwRetItemCount = dwThisItemIndex;
    }
    else {
        if (ItemBuffer != NULL) {
            pThisFmtItem = (PPDH_FMT_COUNTERVALUE_ITEM_W) ItemBuffer;
            wszNextString = (LPWSTR)((LPBYTE)ItemBuffer +
                            (bWideArgs ? sizeof (PDH_FMT_COUNTERVALUE_ITEM_W) : sizeof (PDH_FMT_COUNTERVALUE_ITEM_A)));
            // verify 8 byte alignment
        }
        else {
            pThisFmtItem  = NULL;
            wszNextString = NULL;
        }
        // this is a single instance counter so the size required is:
        //      the size of the instance name +
        //      the size of the parent name +
        //      the size of any index parameter +
        //      the size of the value buffer
        //
        if (pCounter->pCounterPath->szInstanceName != NULL) {
            dwRequiredSize += PdhiGetStringLength(pCounter->pCounterPath->szInstanceName, bWideArgs);
            if (pCounter->pCounterPath->szParentName != NULL) {
                dwRequiredSize += 1 + PdhiGetStringLength(pCounter->pCounterPath->szParentName, bWideArgs);
            }
            if (pCounter->pCounterPath->dwIndex > 0) {
                double dIndex, dLen;
                dIndex          = (double) pCounter->pCounterPath->dwIndex; // cast to float
                dLen            = floor(log10(dIndex));                     // get integer log
                dwRequiredSize  = (DWORD) dLen;                             // cast to integer
                dwRequiredSize += 2;                                        // increment for brackets
            }
            // add in length of null character
            dwRequiredSize += 1;
        }
        // adjust size of required buffer by size of text character
        dwRequiredSize *= ((bWideArgs) ? (sizeof(WCHAR)) : (sizeof(CHAR)));

        // add in length of data structure
        dwRequiredSize += (bWideArgs ? sizeof(PDH_FMT_COUNTERVALUE_ITEM_W) : sizeof(PDH_FMT_COUNTERVALUE_ITEM_A));
        if ((dwRequiredSize <= * lpdwBufferSize)  & (wszNextString != NULL)) {
            pThisFmtItem->szName = wszNextString;
            if (pCounter->pCounterPath->szInstanceName != NULL) {
                if (bWideArgs) {
                    dwNameLength = dwRequiredSize - sizeof(PDH_FMT_COUNTERVALUE_ITEM_W);
                    if (pCounter->pCounterPath->szParentName != NULL) {
                        StringCbPrintfW(wszNextString, dwNameLength, L"%ws%ws%ws",
                                        pCounter->pCounterPath->szParentName,
                                        cszSlash,
                                        pCounter->pCounterPath->szInstanceName);
                    }
                    else {
                        StringCbCopyW(wszNextString, dwNameLength, pCounter->pCounterPath->szInstanceName);
                    }

                    if (pCounter->pCounterPath->dwIndex > 0) {
                        _ltow(pCounter->pCounterPath->dwIndex, wszInstanceName, 10);
                        StringCbCatW(wszNextString, dwNameLength, cszPoundSign);
                        StringCbCatW(wszNextString, dwNameLength, wszInstanceName);
                    }
                    // update pointers
                    wszNextString += lstrlenW(wszNextString) + 1;
                }
                else {
                    if (pCounter->pCounterPath->szParentName != NULL) {
                        dwNameLength  = lstrlenW(pCounter->pCounterPath->szParentName) + 1;
                        WideCharToMultiByte(_getmbcp(),
                                            0,
                                            pCounter->pCounterPath->szParentName,
                                            -1,
                                            (LPSTR) wszNextString,
                                            dwNameLength,
                                            NULL,
                                            NULL);
                        wszNextString  = (LPWSTR) ((LPSTR) wszNextString + lstrlenA((LPSTR) wszNextString));

                        dwNameLength   = lstrlenW(cszSlash) + 1;
                        WideCharToMultiByte(_getmbcp(),
                                            0,
                                            cszSlash,
                                            -1,
                                            (LPSTR) wszNextString,
                                            dwNameLength,
                                            NULL,
                                            NULL);
                        wszNextString  = (LPWSTR) ((LPSTR) wszNextString + lstrlenA((LPSTR) wszNextString));
                    }

                    dwNameLength  = lstrlenW(pCounter->pCounterPath->szInstanceName) + 1;
                    WideCharToMultiByte(_getmbcp(),
                                        0,
                                        pCounter->pCounterPath->szInstanceName,
                                        -1,
                                        (LPSTR) wszNextString,
                                        dwNameLength,
                                        NULL,
                                        NULL);
                    wszNextString  = (LPWSTR) ((LPSTR) wszNextString + lstrlenA((LPSTR) wszNextString));
                    if (pCounter->pCounterPath->dwIndex > 0) {
                        dwNameLength = dwRequiredSize - sizeof(PDH_FMT_COUNTERVALUE_ITEM_A);
                        _ltoa(pCounter->pCounterPath->dwIndex, (LPSTR) wszInstanceName, 10);
                        StringCbCatA((LPSTR) pThisFmtItem->szName, dwNameLength, caszPoundSign);
                        StringCbCatA((LPSTR) pThisFmtItem->szName, dwNameLength, (LPSTR) wszInstanceName);
                    }
                    // null terminate the string
                    * ((LPSTR) wszNextString) = '\0';
                    wszNextString = (LPWSTR) ((LPBYTE) wszNextString + 1);
                    // insure alignment on the appropriate boundry
                }
            }
            else if (bWideArgs) {
                * wszNextString = L'\0';
            }
            else {
                * ((LPSTR) wszNextString) = '\0';
            }

            PdhFnStatus = PdhiComputeFormattedValue(pCounter->CalcFunc,
                                                    pCounter->plCounterInfo.dwCounterType,
                                                    pCounter->lScale,
                                                    dwFormat,
                                                    & pCounter->ThisValue,
                                                    & pCounter->LastValue,
                                                    & pCounter->TimeBase,
                                                    0L,
                                                    & pThisFmtItem->FmtValue);
            if (PdhFnStatus != ERROR_SUCCESS) {
                PdhStatus = PdhFnStatus;
                // error in calculation so set the status for this
                // counter item
                pThisFmtItem->FmtValue.CStatus    = PDH_CSTATUS_INVALID_DATA;
                // clear the value
                pThisFmtItem->FmtValue.largeValue = 0;
                // and return the status to the caller
            }
        }
        else {
            // then this was a real data request so return
            PdhStatus = PDH_MORE_DATA;
        }
        dwRetItemCount = 1;
    }

Cleanup:
    RELEASE_MUTEX(pCounter->pOwner->hMutex);
    if (PdhStatus == ERROR_SUCCESS || PdhStatus == PDH_MORE_DATA) {
        // update buffer size and item count buffers
        * lpdwBufferSize = dwRequiredSize;
        * lpdwItemCount  = dwRetItemCount;
    }

    return PdhStatus;
}

PDH_FUNCTION
PdhGetFormattedCounterArrayA(
    IN  PDH_HCOUNTER                 hCounter,
    IN  DWORD                        dwFormat,
    IN  LPDWORD                      lpdwBufferSize,
    IN  LPDWORD                      lpdwItemCount,
    IN  PPDH_FMT_COUNTERVALUE_ITEM_A ItemBuffer
)
{
    PDH_STATUS  PdhStatus = ERROR_SUCCESS;
    DWORD       dwBufferSize;
    DWORD       dwItemCount;
    DWORD       dwTest;
    LPBYTE      pByte;

    if (lpdwBufferSize == NULL || lpdwItemCount == NULL) {
        PdhStatus = PDH_INVALID_ARGUMENT;
    }
    else if (! IsValidCounter(hCounter)) {
        PdhStatus = PDH_INVALID_HANDLE;
    }
    else if (! CounterIsOkToUse (hCounter)) {
        PdhStatus = PDH_CSTATUS_ITEM_NOT_VALIDATED;
    }
    else {
        // validate arguments
        __try {
            // test argument for Read and Write access
            dwBufferSize = * lpdwBufferSize;
            // test argument for Read and Write access
            dwItemCount  = * lpdwItemCount;

            if (dwBufferSize > 0) {
                // then the buffer must be valid
                if (ItemBuffer != NULL) {
                    // NULL is a valid value for this parameter
                    // test both ends of the buffer passed in
                    pByte                  = (LPBYTE) ItemBuffer;
                    dwTest                 = (DWORD) pByte[0];
                    pByte[0]               = 0;
                    pByte[0]               = (BYTE) (dwTest & 0x000000FF);
                    dwTest                 = (DWORD) pByte[dwBufferSize -1];
                    pByte[dwBufferSize -1] = 0;
                    pByte[dwBufferSize -1] = (BYTE) (dwTest & 0x000000FF);
                }
                else {
                    PdhStatus = PDH_INVALID_ARGUMENT;
                }
            } 
            // check for disallowed format options
            if ((dwFormat & PDH_FMT_RAW) || (dwFormat & PDH_FMT_ANSI) ||
                                            (dwFormat & PDH_FMT_UNICODE) || (dwFormat & PDH_FMT_NODATA)) {
                PdhStatus = PDH_INVALID_ARGUMENT;
            }

        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (PdhStatus == ERROR_SUCCESS) {
        PdhStatus = PdhiGetFormattedCounterArray((PPDHI_COUNTER) hCounter,
                                                 dwFormat,
                                                 & dwBufferSize,
                                                 & dwItemCount,
                                                 (LPVOID) ItemBuffer,
                                                 FALSE);
    }
    if (PdhStatus == ERROR_SUCCESS || PdhStatus == PDH_MORE_DATA) {
        __try {
            * lpdwBufferSize = dwBufferSize;
            * lpdwItemCount  = dwItemCount;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    return PdhStatus;
}

PDH_FUNCTION
PdhGetFormattedCounterArrayW(
    IN  PDH_HCOUNTER                 hCounter,
    IN  DWORD                        dwFormat,
    IN  LPDWORD                      lpdwBufferSize,
    IN  LPDWORD                      lpdwItemCount,
    IN  PPDH_FMT_COUNTERVALUE_ITEM_W ItemBuffer
)
{
    PDH_STATUS  PdhStatus = ERROR_SUCCESS;
    DWORD       dwBufferSize;
    DWORD       dwItemCount;
    DWORD       dwTest;
    LPBYTE      pByte;

    if (lpdwBufferSize == NULL || lpdwItemCount == NULL) {
        PdhStatus = PDH_INVALID_ARGUMENT;
    }
    else if (! IsValidCounter(hCounter)) {
        PdhStatus = PDH_INVALID_HANDLE;
    }
    else if (! CounterIsOkToUse (hCounter)) {
        PdhStatus = PDH_CSTATUS_ITEM_NOT_VALIDATED;
    }
    else {
        // validate arguments
        __try {
            // test argument for Read and Write access
            dwBufferSize = * lpdwBufferSize;
            // test argument for Read and Write access
            dwItemCount  = * lpdwItemCount;

            if (dwBufferSize > 0) {
                // then the buffer must be valid
                if (ItemBuffer != NULL) {
                    // NULL is a valid value for this parameter
                    // test both ends of the buffer passed in
                    pByte                  = (LPBYTE) ItemBuffer;
                    dwTest                 = (DWORD) pByte[0];
                    pByte[0]               = 0;
                    pByte[0]               = (BYTE) (dwTest & 0x000000FF);
                    dwTest                 = (DWORD) pByte[dwBufferSize -1];
                    pByte[dwBufferSize -1] = 0;
                    pByte[dwBufferSize -1] = (BYTE) (dwTest & 0x000000FF);
                }
                else {
                    PdhStatus = PDH_INVALID_ARGUMENT;
                }
            } 
            // check for disallowed format options
            if ((dwFormat & PDH_FMT_RAW) || (dwFormat & PDH_FMT_ANSI) ||
                                            (dwFormat & PDH_FMT_UNICODE) || (dwFormat & PDH_FMT_NODATA)) {
                PdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (PdhStatus == ERROR_SUCCESS) {
        PdhStatus = PdhiGetFormattedCounterArray((PPDHI_COUNTER) hCounter,
                                                 dwFormat,
                                                 & dwBufferSize,
                                                 & dwItemCount,
                                                 (LPVOID) ItemBuffer,
                                                 TRUE);
    }
    if (PdhStatus == ERROR_SUCCESS || PdhStatus == PDH_MORE_DATA) {
        __try {
            * lpdwBufferSize = dwBufferSize;
            * lpdwItemCount  = dwItemCount;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    return PdhStatus;
}

STATIC_PDH_FUNCTION
PdhiGetRawCounterArray(
    PPDHI_COUNTER pCounter,
    LPDWORD       lpdwBufferSize,
    LPDWORD       lpdwItemCount,
    LPVOID        ItemBuffer,
    BOOL          bWideArgs
)
{
    PDH_STATUS              PdhStatus      = ERROR_SUCCESS;
    DWORD                   dwRequiredSize = 0;
    WCHAR                   wszInstanceName[32];
    PPDHI_RAW_COUNTER_ITEM  pThisItem;
    LPWSTR                  szThisItem;
    PPDH_RAW_COUNTER_ITEM_W pThisRawItem;
    DWORD                   dwThisItemIndex;
    LPWSTR                  wszNextString;
    DWORD                   dwNameLength;
    DWORD                   dwRetItemCount = 0;

    PdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pCounter->pOwner->hMutex);
    if (PdhStatus != ERROR_SUCCESS) {
        return PdhStatus;
    }

    // compute required buffer size
    if (pCounter->dwFlags & PDHIC_MULTI_INSTANCE) {
        if (ItemBuffer != NULL) {
            pThisRawItem  = (PPDH_RAW_COUNTER_ITEM_W) ItemBuffer;
            wszNextString = (LPWSTR)((LPBYTE)ItemBuffer + (sizeof(PDH_RAW_COUNTER_ITEM_W) *
                                                           pCounter->pThisRawItemList->dwItemCount));
            // verify 8 byte alignment
        }
        else {
            pThisRawItem  = NULL;
            wszNextString = NULL;
        }

        // for multi structs, the buffer required
        dwThisItemIndex = 0;
        dwRequiredSize += pCounter->pThisRawItemList->dwItemCount *
                            (bWideArgs ? sizeof (PDH_RAW_COUNTER_ITEM_W) : sizeof (PDH_RAW_COUNTER_ITEM_A));
        for (pThisItem = &(pCounter->pThisRawItemList->pItemArray[0]);
                        dwThisItemIndex < pCounter->pThisRawItemList->dwItemCount;
                        dwThisItemIndex ++, pThisItem ++) {
            szThisItem = (LPWSTR) (((LPBYTE) pCounter->pThisRawItemList) + pThisItem->szName);
            if (pThisRawItem != NULL) {
                pThisRawItem->szName = wszNextString;
            }
            else {
                PdhStatus = PDH_MORE_DATA;
            }
            if (bWideArgs) {
                dwNameLength    = lstrlenW(szThisItem) + 1;
                dwRequiredSize += dwNameLength * sizeof(WCHAR);
                if ((dwRequiredSize <= * lpdwBufferSize) && (wszNextString != NULL)) {
                    StringCchCopyW(wszNextString, dwNameLength, szThisItem);
                    wszNextString += dwNameLength;
                }
                else {
                    PdhStatus = PDH_MORE_DATA;
                    if (pThisRawItem != NULL) pThisRawItem->szName = NULL;
                }
            }
            else {
                dwNameLength = (dwRequiredSize <= * lpdwBufferSize) ? (* lpdwBufferSize - dwRequiredSize) : (0);
                PdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(), szThisItem, (LPSTR) wszNextString, & dwNameLength);
                if (PdhStatus == ERROR_SUCCESS) {
                    wszNextString = (LPWSTR) (((LPSTR) wszNextString) + dwNameLength);
                }
                else if (pThisRawItem != NULL) {
                    pThisRawItem->szName = NULL;
                }
                dwRequiredSize += (dwNameLength * sizeof(CHAR));
            }

            if (PdhStatus == ERROR_SUCCESS) {
                pThisRawItem->RawValue.CStatus     = pCounter->pThisRawItemList->CStatus;
                pThisRawItem->RawValue.TimeStamp   = pCounter->pThisRawItemList->TimeStamp;
                pThisRawItem->RawValue.FirstValue  = pThisItem->FirstValue;
                pThisRawItem->RawValue.SecondValue = pThisItem->SecondValue;
                pThisRawItem->RawValue.MultiCount  = pThisItem->MultiCount;
                // update pointers
                pThisRawItem ++;
            }
        }
        dwRetItemCount = dwThisItemIndex;
    }
    else {
        if (ItemBuffer != NULL) {
            pThisRawItem = (PPDH_RAW_COUNTER_ITEM_W)ItemBuffer;
            wszNextString = (LPWSTR)((LPBYTE)ItemBuffer +
                            (bWideArgs ? sizeof (PDH_RAW_COUNTER_ITEM_W) : sizeof (PDH_RAW_COUNTER_ITEM_A)));
            // verify 8 byte alignment
        }
        else {
            pThisRawItem  = NULL;
            wszNextString = NULL;
        }
        // this is a single instance counter so the size required is:
        //      the size of the instance name +
        //      the size of the parent name +
        //      the size of any index parameter +
        //      the size of the value buffer
        //
        if (pCounter->pCounterPath->szInstanceName != NULL) {
            dwRequiredSize += PdhiGetStringLength(pCounter->pCounterPath->szInstanceName, bWideArgs);
            if (pCounter->pCounterPath->szParentName != NULL) {
                dwRequiredSize += 1 + PdhiGetStringLength(pCounter->pCounterPath->szParentName, bWideArgs);
            }
            if (pCounter->pCounterPath->dwIndex > 0) {
                double dIndex, dLen;
                dIndex          = (double)pCounter->pCounterPath->dwIndex; // cast to float
                dLen            = floor(log10(dIndex));                    // get integer log
                dwRequiredSize  = (DWORD)dLen;                             // cast to integer
                dwRequiredSize += 1;                                       // increment for pound sign
            }
            // add in length of two null characters
            // this still has to look like an MSZ even if there is
            // is only one string in the buffer
            dwRequiredSize += 1;
        }
        // adjust size of required buffer by size of text character
        dwRequiredSize *= ((bWideArgs) ? (sizeof(WCHAR)) : (sizeof(CHAR)));

        // add in length of data structure
        dwRequiredSize += (bWideArgs ? sizeof (PDH_RAW_COUNTER_ITEM_W) : sizeof (PDH_RAW_COUNTER_ITEM_A));

        if ((dwRequiredSize <= * lpdwBufferSize)  && (wszNextString != NULL)) {
            pThisRawItem->szName = wszNextString;
            if (pCounter->pCounterPath->szInstanceName != NULL) {
                if (bWideArgs) {
                    dwNameLength = dwRequiredSize - sizeof(PDH_RAW_COUNTER_ITEM_W);
                    if (pCounter->pCounterPath->szParentName != NULL) {
                        StringCbPrintfW(wszNextString, dwNameLength, L"%ws%ws%ws",
                                        pCounter->pCounterPath->szParentName,
                                        cszSlash,
                                        pCounter->pCounterPath->szInstanceName);
                    }
                    else {
                        StringCbCopyW(wszNextString, dwNameLength, pCounter->pCounterPath->szInstanceName);
                    }
                    if (pCounter->pCounterPath->dwIndex > 0) {
                        _ltow (pCounter->pCounterPath->dwIndex, wszInstanceName, 10);
                        StringCbCatW(wszNextString, dwNameLength, cszPoundSign);
                        StringCbCatW(wszNextString, dwNameLength, wszInstanceName);
                    }
                    dwNameLength   = lstrlenW(pThisRawItem->szName) + 1;
                    wszNextString += dwNameLength;
                }
                else {
                    if (pCounter->pCounterPath->szParentName != NULL) {
                        dwNameLength  = lstrlenW(pCounter->pCounterPath->szParentName) + 1;
                        WideCharToMultiByte(_getmbcp(),
                                            0,
                                            pCounter->pCounterPath->szParentName,
                                            -1,
                                            (LPSTR) wszNextString,
                                            dwNameLength,
                                            NULL,
                                            NULL);
                        wszNextString = (LPWSTR) ((LPSTR) wszNextString + lstrlenA((LPSTR) wszNextString));
                        dwNameLength  = lstrlenW(cszSlash) + 1;
                        WideCharToMultiByte(_getmbcp(),
                                            0,
                                            cszSlash,
                                            -1,
                                            (LPSTR) wszNextString,
                                            dwNameLength,
                                            NULL,
                                            NULL);
                        wszNextString = (LPWSTR) ((LPSTR) wszNextString + lstrlenA((LPSTR) wszNextString));
                    }
                    dwNameLength  = lstrlenW(pCounter->pCounterPath->szInstanceName) + 1;
                    WideCharToMultiByte(_getmbcp(),
                                        0,
                                        pCounter->pCounterPath->szInstanceName,
                                        -1,
                                        (LPSTR) wszNextString,
                                        dwNameLength,
                                        NULL,
                                        NULL);
                    wszNextString = (LPWSTR) ((LPSTR) wszNextString + lstrlenA((LPSTR) wszNextString));
                    if (pCounter->pCounterPath->dwIndex > 0) {
                        dwNameLength = dwRequiredSize - sizeof(PDH_FMT_COUNTERVALUE_ITEM_A);
                        _ltoa (pCounter->pCounterPath->dwIndex, (LPSTR)wszInstanceName, 10);
                        StringCbCatA((LPSTR) wszNextString, dwNameLength, caszPoundSign);
                        StringCbCatA((LPSTR) wszNextString, dwNameLength, (LPSTR) wszInstanceName);
                        dwNameLength  = lstrlenA((LPSTR) wszNextString) + 1;
                        wszNextString = (LPWSTR)((LPSTR) wszNextString + dwNameLength);
                    }
                    // null terminate the string
                    * ((LPSTR) wszNextString) = '\0';
                    wszNextString = (LPWSTR) ((LPBYTE) wszNextString + 1);
                }
            }
            else if (bWideArgs) {
                * wszNextString = L'\0';
            }
            else {
                * ((LPSTR) wszNextString) = '\0';
            }
            pThisRawItem->RawValue = pCounter->ThisValue;
        }
        else {
            // then this was a real data request so return
            PdhStatus = PDH_MORE_DATA;
        }
        dwRetItemCount = 1;
    }

    RELEASE_MUTEX(pCounter->pOwner->hMutex);
    if (PdhStatus == ERROR_SUCCESS || PdhStatus == PDH_MORE_DATA) {
        // update buffer size and item count buffers
        * lpdwBufferSize = dwRequiredSize;
        * lpdwItemCount = dwRetItemCount;
    }

    return PdhStatus;
}

PDH_FUNCTION
PdhGetRawCounterArrayA(
    IN  PDH_HCOUNTER            hCounter,
    IN  LPDWORD                 lpdwBufferSize,
    IN  LPDWORD                 lpdwItemCount,
    IN  PPDH_RAW_COUNTER_ITEM_A ItemBuffer
)
{
    PDH_STATUS  PdhStatus = ERROR_SUCCESS;
    DWORD       dwBufferSize;
    DWORD       dwItemCount;
    DWORD       dwTest;
    LPBYTE      pByte;

    if (lpdwBufferSize == NULL || lpdwItemCount == NULL) {
        PdhStatus = PDH_INVALID_ARGUMENT;
    }
    else if (! IsValidCounter(hCounter)) {
        PdhStatus = PDH_INVALID_HANDLE;
    }
    else if (! CounterIsOkToUse (hCounter)) {
        PdhStatus = PDH_CSTATUS_ITEM_NOT_VALIDATED;
    } else {
        // validate arguments
        __try {
            // test argument for Read and Write access
            dwBufferSize = * lpdwBufferSize;
            // test argument for Read and Write access
            dwItemCount  = * lpdwItemCount;

            if (dwBufferSize > 0) {
                if (ItemBuffer != NULL) {
                    // NULL is a valid value for this parameter
                    // test both ends of the buffer passed in
                    pByte                  = (LPBYTE) ItemBuffer;
                    dwTest                 = (DWORD) pByte[0];
                    pByte[0]               = 0;
                    pByte[0]               = (BYTE) (dwTest & 0x000000FF);
                    dwTest                 = (DWORD) pByte[dwBufferSize -1];
                    pByte[dwBufferSize -1] = 0;
                    pByte[dwBufferSize -1] = (BYTE) (dwTest & 0x000000FF);
                }
                else {
                    // if the buffer size is > 0, then a pointer
                    // must be non-null & valid
                    PdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (PdhStatus == ERROR_SUCCESS) {
        PdhStatus = PdhiGetRawCounterArray((PPDHI_COUNTER) hCounter,
                                           & dwBufferSize,
                                           & dwItemCount,
                                           (LPVOID) ItemBuffer,
                                           FALSE);
    }
    if (PdhStatus == ERROR_SUCCESS || PdhStatus == PDH_MORE_DATA) {
        __try {
            * lpdwBufferSize = dwBufferSize;
            * lpdwItemCount  = dwItemCount;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    return PdhStatus;
}

PDH_FUNCTION
PdhGetRawCounterArrayW(
    IN  PDH_HCOUNTER            hCounter,
    IN  LPDWORD                 lpdwBufferSize,
    IN  LPDWORD                 lpdwItemCount,
    IN  PPDH_RAW_COUNTER_ITEM_W ItemBuffer
)
{
    PDH_STATUS  PdhStatus = ERROR_SUCCESS;
    DWORD       dwBufferSize;
    DWORD       dwItemCount;
    DWORD       dwTest;
    LPBYTE      pByte;

    // TODO: Post W2K1 Capture lpdw* to local variables. Capture ItemBuffer

    if (lpdwBufferSize == NULL || lpdwItemCount == NULL) {
        PdhStatus = PDH_INVALID_ARGUMENT;
    }
    else if (! IsValidCounter(hCounter)) {
        PdhStatus = PDH_INVALID_HANDLE;
    }
    else if (! CounterIsOkToUse (hCounter)) {
        PdhStatus = PDH_CSTATUS_ITEM_NOT_VALIDATED;
    }
    else {
        // validate arguments
        __try {
            // test argument for Read and Write access
            dwBufferSize = * lpdwBufferSize;
            // test argument for Read and Write access
            dwItemCount  = * lpdwItemCount;

            if (dwBufferSize > 0) {
                if (ItemBuffer != NULL) {
                    // NULL is a valid value for this parameter
                    // test both ends of the buffer passed in
                    pByte                  = (LPBYTE) ItemBuffer;
                    dwTest                 = (DWORD) pByte[0];
                    pByte[0]               = 0;
                    pByte[0]               = (BYTE) (dwTest & 0x000000FF);
                    dwTest                 = (DWORD) pByte[dwBufferSize -1];
                    pByte[dwBufferSize -1] = 0;
                    pByte[dwBufferSize -1] = (BYTE) (dwTest & 0x000000FF);
                }
                else {
                    // if the buffer size is > 0, then a pointer
                    // must be non-null & valid
                    PdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (PdhStatus == ERROR_SUCCESS) {
        PdhStatus = PdhiGetRawCounterArray((PPDHI_COUNTER) hCounter,
                                           & dwBufferSize,
                                           & dwItemCount,
                                           (LPVOID) ItemBuffer,
                                           TRUE);
    }
    if (PdhStatus == ERROR_SUCCESS || PdhStatus == PDH_MORE_DATA) {
        __try {
            * lpdwBufferSize = dwBufferSize;
            * lpdwItemCount  = dwItemCount;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    return PdhStatus;
}

PDH_FUNCTION
PdhGetFormattedCounterValue(
    IN  PDH_HCOUNTER          hCounter,
    IN  DWORD                 dwFormat,
    IN  LPDWORD               lpdwType,
    IN  PPDH_FMT_COUNTERVALUE pValue
)
/*++
Routine Description:
    Function to retrieve, computer and format the specified counter's
        current value. The values used are those currently in the counter
        buffer. (The data is not collected by this routine.)

Arguments:
    IN      HCOUNTER    hCounter
        the handle to the counter whose value should be returned
    IN      DWORD       dwFormat
        the format flags that define how the counter value should be
        formatted prior for return. These flags are defined in the
        PDH.H header file.
    IN      LPDWORD     lpdwType
        an optional buffer in which the counter type value can be returned.
        For the prototype, the flag values are defined in WINPERF.H
    IN      PPDH_FMT_COUNTERVALUE      pValue
        the pointer to the data buffer passed by the caller to receive
        the data requested.

Return Value:
    The WIN32 Error status of the function's operation. Common values
        returned are:
            ERROR_SUCCESS   when all requested data is returned
            PDH_INVALID_HANDLE    if the handle is not recognized as valid
            PDH_INVALID_ARGUMENT  if an argument is not correct or is
                incorrectly formatted.
            PDH_INVALID_DATA if the counter does not contain valid data
                or a successful status code
--*/
{
    PPDHI_COUNTER        pCounter;
    PDH_STATUS           lStatus = ERROR_SUCCESS;
    PDH_FMT_COUNTERVALUE LocalCounterValue;
    DWORD                dwTypeMask;

    // TODO: Why bother with testing for NON-NULL stuff in mutex?
    // Check for obvious lpdwType != NULL & pValue != NULL before mutex.

    if (pValue == NULL) {
        lStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            pValue->CStatus   = (DWORD) -1;
            pValue->longValue = (LONGLONG) 0;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            lStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (lStatus == ERROR_SUCCESS) {
        lStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);
        if (lStatus == ERROR_SUCCESS) {
            if (! IsValidCounter(hCounter)) {
                lStatus = PDH_INVALID_HANDLE;
            }
            else if (! CounterIsOkToUse(hCounter)) {
                lStatus = PDH_CSTATUS_ITEM_NOT_VALIDATED;
            }
            else {
                // validate format flags:
                //      only one of the following can be set at a time
                dwTypeMask = dwFormat & (PDH_FMT_LONG | PDH_FMT_DOUBLE | PDH_FMT_LARGE);
                if (! ((dwTypeMask == PDH_FMT_LONG) || (dwTypeMask == PDH_FMT_DOUBLE) ||
                                                       (dwTypeMask == PDH_FMT_LARGE))) {
                    lStatus = PDH_INVALID_ARGUMENT;
                }
            }
            if (lStatus == ERROR_SUCCESS) {
                // get counter pointer
                pCounter = (PPDHI_COUNTER) hCounter;
                // lock query while reading the data
                lStatus  = WAIT_FOR_AND_LOCK_MUTEX(pCounter->pOwner->hMutex);
                if (lStatus == ERROR_SUCCESS) {
                    // compute and format current value
                    lStatus = PdhiComputeFormattedValue(pCounter->CalcFunc,
                                                        pCounter->plCounterInfo.dwCounterType,
                                                        pCounter->lScale,
                                                        dwFormat,
                                                        & pCounter->ThisValue,
                                                        & pCounter->LastValue,
                                                        & pCounter->TimeBase,
                                                        0L,
                                                        & LocalCounterValue);
                    RELEASE_MUTEX(pCounter->pOwner->hMutex);
                    __try {
                        if (lpdwType != NULL) {
                            * lpdwType = pCounter->plCounterInfo.dwCounterType;
                        } // NULL is OK, the counter type will not be returned, though
                        * pValue = LocalCounterValue;
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        lStatus = PDH_INVALID_ARGUMENT;
                    }            
                }
            }
            RELEASE_MUTEX (hPdhDataMutex);
        }
    }
    return lStatus;
}

PDH_FUNCTION
PdhGetRawCounterValue(
    IN  PDH_HCOUNTER     hCounter,
    IN  LPDWORD          lpdwType,
    IN  PPDH_RAW_COUNTER pValue
)
/*++
Routine Description:
    Function to retrieve the specified counter's current raw value.
        The values used are those currently in the counter
        buffer. (The data is not collected by this routine.)

Arguments:
    IN      HCOUNTER    hCounter
        the handle to the counter whose value should be returned
    IN      LPDWORD     lpdwType
        an optional buffer in which the counter type value can be returned.
        This value must be NULL if this info is not desired.
        For the prototype, the flag values are defined in WINPERF.H
    IN      PPDH_RAW_COUNTER      pValue
        the pointer to the data buffer passed by the caller to receive
        the data requested.

Return Value:
    The WIN32 Error status of the function's operation. Common values
        returned are:
            ERROR_SUCCESS   when all requested data is returned
            PDH_INVALID_HANDLE    if the handle is not recognized as valid
            PDH_INVALID_ARGUMENT  if an argument is formatted incorrectly
--*/
{
    PDH_STATUS    Status = ERROR_SUCCESS;
    PPDHI_COUNTER pCounter;

    if (pValue == NULL) {
        Status = PDH_INVALID_ARGUMENT;
    }
    else {
        Status = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);
        if (Status == ERROR_SUCCESS) {
            // validate arguments before retrieving the data
            if (! IsValidCounter(hCounter)) {
                Status = PDH_INVALID_HANDLE;
            }
            else if (! CounterIsOkToUse(hCounter)) {
                Status = PDH_CSTATUS_ITEM_NOT_VALIDATED;
            }
            else {
                // the handle is good so try the rest of the args
                pCounter = (PPDHI_COUNTER) hCounter;
                Status   = WAIT_FOR_AND_LOCK_MUTEX(pCounter->pOwner->hMutex);
                if (Status == ERROR_SUCCESS) {
                    __try {
                        // try to write to the arguments passed in
                        * pValue = pCounter->ThisValue;
                        if (lpdwType != NULL) {
                            * lpdwType = pCounter->plCounterInfo.dwCounterType;
                        } // NULL is OK
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        Status = PDH_INVALID_ARGUMENT;
                    }
                    RELEASE_MUTEX(pCounter->pOwner->hMutex);
                }
            }
            RELEASE_MUTEX(hPdhDataMutex);
        }
    }
    return Status;
}

PDH_FUNCTION
PdhCalculateCounterFromRawValue(
    IN  PDH_HCOUNTER          hCounter,
    IN  DWORD                 dwFormat,
    IN  PPDH_RAW_COUNTER      rawValue1,
    IN  PPDH_RAW_COUNTER      rawValue2,
    IN  PPDH_FMT_COUNTERVALUE fmtValue
)
/*++
Routine Description:
    Calculates the formatted counter value using the data in the RawValue
        buffer in the format requested by the format field using the
        calculation functions of the counter type defined by the dwType
        field.

Arguments:
    IN      HCOUNTER    hCounter
        The handle of the counter to use in order to determine the
        calculation functions for interpretation of the raw value buffer
    IN      DWORD       dwFormat
        Format in which the requested data should be returned. The
        values for this field are described in the PDH.H header
        file.
    IN      PPDH_RAW_COUNTER    rawValue1
        pointer to the buffer that contains the first raw value structure
    IN      PPDH_RAW_COUNTER    rawValue2
        pointer to the buffer that contains the second raw value structure.
        This argument may be null if only one value is required for the
        computation.
    IN      PPDH_FMT_COUNTERVALUE   fmtValue
        the pointer to the data buffer passed by the caller to receive
        the data requested. If the counter requires 2 values, (as in the
        case of a rate counter), rawValue1 is assumed to be the most
        recent value and rawValue2, the older value.

Return Value:
    The WIN32 Error status of the function's operation. Common values
        returned are:
            ERROR_SUCCESS   when all requested data is returned
            PDH_INVALID_HANDLE if the counter handle is incorrect
            PDH_INVALID_ARGUMENT if an argument is incorrect
--*/
{
    PDH_STATUS           lStatus = ERROR_SUCCESS;
    PPDHI_COUNTER        pCounter;
    DWORD                dwTypeMask;
    PDH_FMT_COUNTERVALUE pdhLocalCounterValue;

    if (fmtValue == NULL) {
        lStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        lStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);
    }
    if (lStatus == ERROR_SUCCESS) {
        // validate arguments
        if (! IsValidCounter(hCounter)) {
            lStatus = PDH_INVALID_HANDLE;
        }
        else if (! CounterIsOkToUse(hCounter)) {
            lStatus = PDH_CSTATUS_ITEM_NOT_VALIDATED;
        }
        else {
            // the handle is valid so check the rest of the arguments
            // validate format flags:
            dwTypeMask = dwFormat & (PDH_FMT_LONG | PDH_FMT_DOUBLE | PDH_FMT_LARGE);
            //      only one of the following can be set at a time
            if (! ((dwTypeMask == PDH_FMT_LONG) || (dwTypeMask == PDH_FMT_DOUBLE) || (dwTypeMask == PDH_FMT_LARGE))) {
                lStatus = PDH_INVALID_ARGUMENT;
            }
        }
        if (lStatus == ERROR_SUCCESS) {
            pCounter = (PPDHI_COUNTER) hCounter;
            lStatus  = WAIT_FOR_AND_LOCK_MUTEX(pCounter->pOwner->hMutex);
            if (lStatus == ERROR_SUCCESS) {
                __try {
                    lStatus = PdhiComputeFormattedValue((((PPDHI_COUNTER) hCounter)->CalcFunc),
                                                        (((PPDHI_COUNTER) hCounter)->plCounterInfo.dwCounterType),
                                                        (((PPDHI_COUNTER) hCounter)->lScale),
                                                        dwFormat,
                                                        rawValue1,
                                                        rawValue2,
                                                        &((PPDHI_COUNTER)hCounter)->TimeBase,
                                                        0L,
                                                        &pdhLocalCounterValue);
                    * fmtValue = pdhLocalCounterValue;
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    lStatus = PDH_INVALID_ARGUMENT;
                }
                RELEASE_MUTEX(pCounter->pOwner->hMutex);
            }
        }
        RELEASE_MUTEX(hPdhDataMutex);
    }
    return lStatus;
}

PDH_FUNCTION
PdhComputeCounterStatistics(
    IN  HCOUNTER         hCounter,
    IN  DWORD            dwFormat,
    IN  DWORD            dwFirstEntry,
    IN  DWORD            dwNumEntries,
    IN  PPDH_RAW_COUNTER lpRawValueArray,
    IN  PPDH_STATISTICS  data
)
/*++
Routine Description:
    Reads an array of raw value structures of the counter type specified in
        the dwType field, computes the counter values of each and formats
        and returns a statistics structure that contains the following
        statistical data from the counter information:

            Minimum     The smallest value of the computed counter values
            Maximum     The largest value of the computed counter values
            Mean        The arithmetic mean (average) of the computed values
            Median      The median value of the computed counter values

Arguments:
    IN      HCOUNTER    hCounter
        The handle of the counter to use in order to determine the
        calculation functions for interpretation of the raw value buffer
    IN      DWORD       dwFormat
        Format in which the requested data should be returned. The
        values for this field are described in the PDH.H header
        file.
    IN      DWORD       dwNumEntries
        the number of raw value entries for the specified counter type
    IN      PPDH_RAW_COUNTER      lpRawValueArray
        pointer to the array of raw value entries to be evaluated
    IN      PPDH_STATISTICS data
        the pointer to the data buffer passed by the caller to receive
        the data requested.

Return Value:
    The WIN32 Error status of the function's operation. Note that the
        function can return successfully even though no data was calc-
        ulated. The  status value in the statistics data buffer must be
        tested to insure the data is valid before it's used by an
        application.  Common values returned are:
            ERROR_SUCCESS   when all requested data is returned
            PDH_INVALID_HANDLE if the counter handle is incorrect
            PDH_INVALID_ARGUMENT if an argument is incorrect
--*/
{
    PPDHI_COUNTER pCounter;
    PDH_STATUS    Status = ERROR_SUCCESS;
    DWORD         dwTypeMask;

    if (lpRawValueArray == NULL || data == NULL) {
        Status = PDH_INVALID_ARGUMENT;
    }
    else {
        Status = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);
    }
    if (Status == ERROR_SUCCESS) {
        if (! IsValidCounter(hCounter)) {
            Status = PDH_INVALID_HANDLE;
        }
        else if (! CounterIsOkToUse(hCounter)) {
            Status = PDH_CSTATUS_ITEM_NOT_VALIDATED;
        }
        else {
            // counter handle is valid so test the rest of the
            // arguments
            // validate format flags:
            //      only one of the following can be set at a time
            dwTypeMask = dwFormat & (PDH_FMT_LONG | PDH_FMT_DOUBLE | PDH_FMT_LARGE);
            if (! ((dwTypeMask == PDH_FMT_LONG) || (dwTypeMask == PDH_FMT_DOUBLE) || (dwTypeMask == PDH_FMT_LARGE))) {
                Status = PDH_INVALID_ARGUMENT;
            }
        }

        if (Status == ERROR_SUCCESS) {
            pCounter = (PPDHI_COUNTER) hCounter;
            Status   = WAIT_FOR_AND_LOCK_MUTEX(pCounter->pOwner->hMutex);
            if (Status == ERROR_SUCCESS) {
                __try {
                    // we should have read access to the Raw Data
                    DWORD   dwTest = * ((DWORD volatile *) & lpRawValueArray->CStatus);

                    if (dwFirstEntry >= dwNumEntries) {
                        Status = PDH_INVALID_ARGUMENT;
                    }
                    else {
                        // call satistical function for this counter
                        Status = (* pCounter->StatFunc)
                                 (pCounter, dwFormat, dwFirstEntry, dwNumEntries, lpRawValueArray, data);
                    }
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    Status = PDH_INVALID_ARGUMENT;
                }
                RELEASE_MUTEX(pCounter->pOwner->hMutex);
            }
        }
        RELEASE_MUTEX(hPdhDataMutex);
    }
    return Status;
}

STATIC_PDH_FUNCTION
PdhiGetCounterInfo(
    PDH_HCOUNTER        hCounter,
    BOOLEAN             bRetrieveExplainText,
    LPDWORD             pdwBufferSize,
    PPDH_COUNTER_INFO_W lpBuffer,
    BOOL                bUnicode
)
/*++
Routine Description:
    Examines the specified counter and returns the configuration and
        status information of the counter.

Arguments:
    IN      HCOUNTER    hCounter
        Handle to the desired counter.
    IN      BOOLEAN     bRetrieveExplainText
        TRUE will fill in the explain text structure
        FALSE will return a null pointer in the explain text
    IN      LPDWORD     pcchBufferSize
        The address of the buffer that contains the size of the data buffer
        passed by the caller. On entry, the value in the buffer is the
        size of the data buffer in bytes. On return, this value is the size
        of the buffer returned. If the buffer is not large enough, then
        this value is the size that the buffer needs to be in order to
        hold the requested data.
    IN      LPPDH_COUNTER_INFO_W  lpBuffer
        the pointer to the data buffer passed by the caller to receive
        the data requested.
    IN      BOOL        bUnicode
        TRUE if wide character strings should be returned
        FALSE if ANSI strings should be returned

Return Value:
    The WIN32 Error status of the function's operation. Common values
        returned are:
            ERROR_SUCCESS   when all requested data is returned
            PDH_MORE_DATA when the buffer passed by the caller is too small
            PDH_INVALID_HANDLE    if the handle is not recognized as valid
            PDH_INVALID_ARGUMENT  if an argument is invalid or incorrect
--*/
{
    PDH_STATUS      Status         = ERROR_SUCCESS;
    DWORD           dwSizeRequired = 0;
    DWORD           dwPathLength;
    DWORD           dwMachineLength;
    DWORD           dwObjectLength;
    DWORD           dwInstanceLength;
    DWORD           dwParentLength;
    DWORD           dwNameLength   = 0;
    DWORD           dwHelpLength   = 0;
    PPDHI_COUNTER   pCounter;
    DWORD           dwBufferSize   = 0;

    Status = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);
    if (Status == ERROR_SUCCESS) {
        if (! IsValidCounter(hCounter)) {
            Status = PDH_INVALID_HANDLE;
        }
        else if (! CounterIsOkToUse(hCounter)) {
            Status = PDH_CSTATUS_ITEM_NOT_VALIDATED;
        }
        else {
            // the counter is valid so test the remaining arguments
            __try {
                if (pdwBufferSize != NULL) {
                    // test read & write access
                    dwBufferSize = * pdwBufferSize;
                }
                else {
                    // this cannot be NULL
                    Status = PDH_INVALID_ARGUMENT;
                }
                if (Status == ERROR_SUCCESS) {
                    // test return buffer for write access at
                    // both ends of the buffer
                    if (lpBuffer != NULL && dwBufferSize > 0) {
                        * (LPBYTE) lpBuffer                   = 0;
                        ((LPBYTE) lpBuffer)[dwBufferSize - 1] = 0;
                    }
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                Status = PDH_INVALID_ARGUMENT;
            }
        }

        if (Status == ERROR_SUCCESS) {
            pCounter = (PPDHI_COUNTER) hCounter;
            Status   = WAIT_FOR_AND_LOCK_MUTEX(pCounter->pOwner->hMutex);
            if (Status == ERROR_SUCCESS) {
                // check for a "no string" request
                if (lpBuffer != NULL && dwBufferSize == sizeof(PDH_COUNTER_INFO_W)) {
                    // then return all but the strings
                    // room for the basic structure so load it
                    lpBuffer->dwLength         = dwSizeRequired; // this will be updated later
                    lpBuffer->dwType           = pCounter->plCounterInfo.dwCounterType;
                    lpBuffer->CVersion         = pCounter->CVersion;
                    lpBuffer->CStatus          = pCounter->ThisValue.CStatus;
                    lpBuffer->lScale           = pCounter->lScale;
                    lpBuffer->lDefaultScale    = pCounter->plCounterInfo.lDefaultScale;
                    lpBuffer->dwUserData       = pCounter->dwUserData;
                    lpBuffer->dwQueryUserData  = pCounter->pOwner->dwUserData;
                    lpBuffer->szFullPath       = NULL;
                    lpBuffer->szMachineName    = NULL;
                    lpBuffer->szObjectName     = NULL;
                    lpBuffer->szInstanceName   = NULL;
                    lpBuffer->szParentInstance = NULL;
                    lpBuffer->dwInstanceIndex  = 0L;
                    lpBuffer->szCounterName    = NULL;
                    lpBuffer->szExplainText    = NULL;
                    lpBuffer->DataBuffer[0]    = 0;
                    // the size value is ok to leave as is
                }
                else {
                    // this is a size/full request so continue

                    // compute size of data to return
                    dwSizeRequired = sizeof (PDH_COUNTER_INFO_W) - sizeof(DWORD);   // size of struct
                    // this should already end on a DWORD boundry

                    dwPathLength     = 1 + PdhiGetStringLength(pCounter->szFullName, bUnicode);
                    dwPathLength    *= (bUnicode ? sizeof(WCHAR) : sizeof(CHAR));
                    dwPathLength     = DWORD_MULTIPLE(dwPathLength);
                    dwSizeRequired  += dwPathLength;

                    dwMachineLength  = 1 + PdhiGetStringLength(pCounter->pCounterPath->szMachineName, bUnicode);
                    dwMachineLength *= (bUnicode ? sizeof(WCHAR) : sizeof(CHAR));
                    dwMachineLength  = DWORD_MULTIPLE(dwMachineLength);
                    dwSizeRequired  += dwMachineLength;

                    dwObjectLength   = 1 + PdhiGetStringLength(pCounter->pCounterPath->szObjectName, bUnicode);
                    dwObjectLength  *= (bUnicode ? sizeof(WCHAR) : sizeof(CHAR));
                    dwObjectLength   = DWORD_MULTIPLE(dwObjectLength);
                    dwSizeRequired  += dwObjectLength;

                    if (pCounter->pCounterPath->szInstanceName != NULL) {
                        dwInstanceLength   = 1 + PdhiGetStringLength(pCounter->pCounterPath->szInstanceName, bUnicode);
                        dwInstanceLength  *= (bUnicode ? sizeof(WCHAR) : sizeof(CHAR));
                        dwInstanceLength   = DWORD_MULTIPLE(dwInstanceLength);
                        dwSizeRequired  += dwInstanceLength;
                    }
                    else {
                        dwInstanceLength = 0;
                    }

                    if (pCounter->pCounterPath->szParentName != NULL) {
                        dwParentLength   = 1 + PdhiGetStringLength(pCounter->pCounterPath->szParentName, bUnicode);
                        dwParentLength  *= (bUnicode ? sizeof(WCHAR) : sizeof(CHAR));
                        dwParentLength   = DWORD_MULTIPLE(dwParentLength);
                        dwSizeRequired  += dwParentLength;
                    }
                    else {
                        dwParentLength = 0;
                    }

                    dwNameLength    = 1 + PdhiGetStringLength(pCounter->pCounterPath->szCounterName, bUnicode);
                    dwNameLength   *= (bUnicode ? sizeof(WCHAR) : sizeof(CHAR));
                    dwNameLength    = DWORD_MULTIPLE(dwNameLength);
                    dwSizeRequired += dwNameLength;

                    if (bRetrieveExplainText) {
                        if (pCounter->szExplainText != NULL) {
                            dwHelpLength    = 1 + PdhiGetStringLength(pCounter->szExplainText, bUnicode);
                            dwHelpLength   *= (bUnicode ? sizeof(WCHAR) : sizeof(CHAR));
                            dwHelpLength    = DWORD_MULTIPLE(dwHelpLength);
                            dwSizeRequired  += dwHelpLength;
                        }
                        else {
                            dwHelpLength = 0;
                        }
                    }

                    if (lpBuffer != NULL && dwSizeRequired <= dwBufferSize) {
                        // should be enough room in the buffer, so continue
                        lpBuffer->dwLength        = dwSizeRequired;
                        lpBuffer->dwType          = pCounter->plCounterInfo.dwCounterType;
                        lpBuffer->CVersion        = pCounter->CVersion;
                        lpBuffer->CStatus         = pCounter->ThisValue.CStatus;
                        lpBuffer->lScale          = pCounter->lScale;
                        lpBuffer->lDefaultScale   = pCounter->plCounterInfo.lDefaultScale;
                        lpBuffer->dwUserData      = pCounter->dwUserData;
                        lpBuffer->dwQueryUserData = pCounter->pOwner->dwUserData;

                        // do string data now
                        lpBuffer->szFullPath = (LPWSTR)& lpBuffer->DataBuffer[0];
                        if (bUnicode) {
                            StringCbCopyW(lpBuffer->szFullPath,
                                          dwPathLength,
                                          pCounter->szFullName);
                        }
                        else {
                            WideCharToMultiByte(_getmbcp(),
                                                0,
                                                pCounter->szFullName,
                                                -1,
                                                (LPSTR) lpBuffer->szFullPath,
                                                dwPathLength,
                                                NULL,
                                                NULL);
                        }

                        lpBuffer->szMachineName = (LPWSTR)((LPBYTE) lpBuffer->szFullPath + dwPathLength);
                        if (bUnicode) {
                            StringCbCopyW(lpBuffer->szMachineName,
                                          dwMachineLength,
                                          pCounter->pCounterPath->szMachineName);
                        }
                        else {
                            WideCharToMultiByte(_getmbcp(),
                                                0,
                                                pCounter->pCounterPath->szMachineName,
                                                -1,
                                                (LPSTR) lpBuffer->szMachineName,
                                                dwMachineLength,
                                                NULL,
                                                NULL);
                        }

                        lpBuffer->szObjectName = (LPWSTR)((LPBYTE) lpBuffer->szMachineName + dwMachineLength);
                        if (bUnicode){
                            StringCbCopyW(lpBuffer->szObjectName,
                                          dwObjectLength,
                                          pCounter->pCounterPath->szObjectName);
                        }
                        else {
                            WideCharToMultiByte(_getmbcp(),
                                                0,
                                                pCounter->pCounterPath->szObjectName,
                                                -1,
                                                (LPSTR) lpBuffer->szObjectName,
                                                dwObjectLength,
                                                NULL,
                                                NULL);
                        }

                        lpBuffer->szInstanceName = (LPWSTR)((LPBYTE) lpBuffer->szObjectName + dwObjectLength);
                        if (dwInstanceLength > 0) {
                            if (bUnicode) {
                                StringCbCopyW(lpBuffer->szInstanceName,
                                              dwInstanceLength,
                                              pCounter->pCounterPath->szInstanceName);
                            }
                            else {
                                WideCharToMultiByte(_getmbcp(),
                                                    0,
                                                    pCounter->pCounterPath->szInstanceName,
                                                    -1,
                                                    (LPSTR) lpBuffer->szInstanceName,
                                                    dwInstanceLength,
                                                    NULL,
                                                    NULL);
                            }
                            lpBuffer->szParentInstance = (LPWSTR)((LPBYTE)lpBuffer->szInstanceName + dwInstanceLength);
                        }
                        else {
                            lpBuffer->szParentInstance = lpBuffer->szInstanceName;
                            lpBuffer->szInstanceName   = NULL;
                        }

                        if (dwParentLength > 0) {
                            if (bUnicode) {
                                StringCbCopyW(lpBuffer->szParentInstance,
                                              dwParentLength,
                                              pCounter->pCounterPath->szParentName);
                            }
                            else {
                                WideCharToMultiByte(_getmbcp(),
                                                    0,
                                                    pCounter->pCounterPath->szParentName,
                                                    -1,
                                                    (LPSTR) lpBuffer->szParentInstance,
                                                    dwParentLength,
                                                    NULL,
                                                    NULL);
                            }
                            lpBuffer->szCounterName = (LPWSTR)((LPBYTE) lpBuffer->szParentInstance + dwParentLength);
                        }
                        else {
                            lpBuffer->szCounterName    = lpBuffer->szParentInstance;
                            lpBuffer->szParentInstance = NULL;
                        }

                        lpBuffer->dwInstanceIndex = pCounter->pCounterPath->dwIndex;

                        if (bUnicode) {
                            StringCbCopyW(lpBuffer->szCounterName,
                                          dwNameLength,
                                          pCounter->pCounterPath->szCounterName);
                        }
                        else {
                            WideCharToMultiByte(_getmbcp(),
                                                0,
                                                pCounter->pCounterPath->szCounterName,
                                                -1,
                                                (LPSTR) lpBuffer->szCounterName,
                                                dwNameLength,
                                                NULL,
                                                NULL);
                        }

                        if ((pCounter->szExplainText != NULL) && bRetrieveExplainText) {
                            // copy explain text
                            lpBuffer->szExplainText = (LPWSTR)((LPBYTE) lpBuffer->szCounterName + dwNameLength);
                            if (bUnicode) {
                                StringCbCopyW(lpBuffer->szExplainText, dwHelpLength, pCounter->szExplainText);
                            }
                            else {
                                WideCharToMultiByte(_getmbcp(),
                                                    0,
                                                    pCounter->szExplainText,
                                                    -1,
                                                    (LPSTR) lpBuffer->szExplainText,
                                                    dwHelpLength,
                                                    NULL,
                                                    NULL);
                            }
                        }
                        else {
                            lpBuffer->szExplainText = NULL;
                        }
                    }
                    else {
                        // either way, no data will be transferred
                        Status = PDH_MORE_DATA;
                    }
                    __try {
                        * pdwBufferSize = dwSizeRequired;
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        Status = PDH_INVALID_ARGUMENT;
                    }
                }
                RELEASE_MUTEX(pCounter->pOwner->hMutex);
            }
        }
        RELEASE_MUTEX(hPdhDataMutex);
    }
    return Status;
}

PDH_FUNCTION
PdhGetCounterInfoW(
    IN  PDH_HCOUNTER        hCounter,
    IN  BOOLEAN             bRetrieveExplainText,
    IN  LPDWORD             pdwBufferSize,
    IN  PPDH_COUNTER_INFO_W lpBuffer
)
/*++
Routine Description:

    Examines the specified counter and returns the configuration and
        status information of the counter.
Arguments:
    IN      HCOUNTER    hCounter
        Handle to the desired counter.
    IN      BOOLEAN     bRetrieveExplainText
        TRUE will fill in the explain text structure
        FALSE will return a null pointer in the explain text
    IN      LPDWORD     pcchBufferSize
        The address of the buffer that contains the size of the data buffer
        passed by the caller. On entry, the value in the buffer is the
        size of the data buffer in bytes. On return, this value is the size
        of the buffer returned. If the buffer is not large enough, then
        this value is the size that the buffer needs to be in order to
        hold the requested data.
    IN      LPPDH_COUNTER_INFO_W  lpBuffer
        the pointer to the data buffer passed by the caller to receive
        the data requested.

Return Value:
    The WIN32 Error status of the function's operation. Common values
        returned are:
            ERROR_SUCCESS   when all requested data is returned
            PDH_MORE_DATA when the buffer passed by the caller is too small
            PDH_INVALID_HANDLE    if the handle is not recognized as valid
            PDH_INVALID_ARGUMENT  if an argument is invalid or incorrect
--*/
{
    return PdhiGetCounterInfo(hCounter, bRetrieveExplainText, pdwBufferSize, lpBuffer, TRUE);
}

PDH_FUNCTION
PdhGetCounterInfoA(
    IN  PDH_HCOUNTER        hCounter,
    IN  BOOLEAN             bRetrieveExplainText,
    IN  LPDWORD             pdwBufferSize,
    IN  PPDH_COUNTER_INFO_A lpBuffer
)
/*++
Routine Description:
    Examines the specified counter and returns the configuration and
        status information of the counter.

Arguments:
    IN      HCOUNTER    hCounter
        Handle to the desired counter.
    IN      BOOLEAN     bRetrieveExplainText
        TRUE will fill in the explain text structure
        FALSE will return a null pointer in the explain text
    IN      LPDWORD     pcchBufferSize
        The address of the buffer that contains the size of the data buffer
        passed by the caller. On entry, the value in the buffer is the
        size of the data buffer in bytes. On return, this value is the size
        of the buffer returned. If the buffer is not large enough, then
        this value is the size that the buffer needs to be in order to
        hold the requested data.
    IN      LPPDH_COUNTER_INFO_A  lpBuffer
        the pointer to the data buffer passed by the caller to receive
        the data requested.

Return Value:
    The WIN32 Error status of the function's operation. Common values
        returned are:
            ERROR_SUCCESS   when all requested data is returned
            PDH_MORE_DATA when the buffer passed by the caller is too small
            PDH_INVALID_HANDLE    if the handle is not recognized as valid
            PDH_INVALID_ARGUMENT  if an argument is invalid or incorrect
--*/
{
    return PdhiGetCounterInfo(hCounter, bRetrieveExplainText, pdwBufferSize, (PPDH_COUNTER_INFO_W) lpBuffer, FALSE);
}

PDH_FUNCTION
PdhSetCounterScaleFactor(
    IN  PDH_HCOUNTER hCounter,
    IN  LONG         lFactor
)
/*++
Routine Description:
    sets the counter multiplication scale factor used in computing formatted
        counter values. The legal range of values is -7 to +7 which equates
        to a factor of .0000007 to 10,000,000.

Arguments:
    IN      HCOUNTER    hCounter
        handle of the counter to update
    IN      LONG        lFactor
        integer value of the exponent of the factor (i.e. the multiplier is
        10 ** lFactor.)

Return Value:
    The WIN32 Error status of the function's operation. Common values
        returned are:
            ERROR_SUCCESS   when all requested data is returned
            PDH_INVALID_ARGUMENT  if the scale value is out of range
            PDH_INVALID_HANDLE    if the handle is not recognized as valid
--*/
{
    PPDHI_COUNTER pCounter;
    PDH_STATUS    retStatus = ERROR_SUCCESS;

    retStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);

    if (retStatus == ERROR_SUCCESS) {
        if (! IsValidCounter(hCounter)) {
            // not a valid counter
            retStatus = PDH_INVALID_HANDLE;
        }
        else if (lFactor > PDH_MAX_SCALE || lFactor < PDH_MIN_SCALE) {
            retStatus = PDH_INVALID_ARGUMENT;
        }
        else if (! CounterIsOkToUse(hCounter)) {
            retStatus = PDH_CSTATUS_ITEM_NOT_VALIDATED;
        }
        else {
            pCounter  = (PPDHI_COUNTER) hCounter;
            retStatus = WAIT_FOR_AND_LOCK_MUTEX(pCounter->pOwner->hMutex);
            if (retStatus == ERROR_SUCCESS) {
                __try {
                    pCounter->lScale = lFactor;
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    retStatus = PDH_INVALID_ARGUMENT;
                }
                RELEASE_MUTEX(pCounter->pOwner->hMutex);
                retStatus = ERROR_SUCCESS;
            }
        }
        RELEASE_MUTEX (hPdhDataMutex);
    }
    return retStatus;
}

#pragma optimize ("", off)
PDH_FUNCTION
PdhGetCounterTimeBase(
    IN  PDH_HCOUNTER   hCounter,
    IN  LONGLONG     * pTimeBase
)
/*++
Routine Description:
    retrieves the value of the timebase used in the computation
        of the formatted version of this counter.

Arguments:
    IN      HCOUNTER    hCounter
        handle of the counter to query

    IN      LONGLONG    pTimeBase
        pointer to the longlong value that will receive the value of the
        timebase used by the counter. The Timebase is the frequency of the
        timer used to measure the specified.

Return Value:
    The WIN32 Error status of the function's operation. Common values
        returned are:
            ERROR_SUCCESS   when all requested data is returned
            PDH_INVALID_ARGUMENT  if the scale value is out of range
            PDH_INVALID_HANDLE    if the handle is not recognized as valid
--*/
{

    PPDHI_COUNTER   pCounter;
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;

    if (pTimeBase != NULL) {
        if (IsValidCounter(hCounter)) {
            if (! CounterIsOkToUse(hCounter)) {
                pdhStatus = PDH_CSTATUS_ITEM_NOT_VALIDATED;
            }
            else {
                pCounter = (PPDHI_COUNTER) hCounter;
                __try {
                    * pTimeBase = pCounter->TimeBase;
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
        }
        else {
            pdhStatus = PDH_INVALID_HANDLE;
        }
    }
    else {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    return pdhStatus;
}
#pragma optimize ("", on)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhcalc\calcfuns.c ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    calcfuns.c

Abstract:

    Counter calculation functions
    WMICOOKER.DLL depends on this file also. \nt\admin\wmi\wbem\winmgmt\wmicooker

--*/

#include <windows.h>
#include <math.h>
#include "strsafe.h"
#include <pdh.h>
#include "pdhitype.h"
#include "pdhidef.h"
#include "pdhicalc.h"
#include "pdhmsg.h"

BOOL
AssignCalcFunction(
    DWORD           dwCounterType,
    LPCOUNTERCALC * pCalcFunc,
    LPCOUNTERSTAT * pStatFunc
)
{
    BOOL bReturn = TRUE;

    // reset the last error value
    SetLastError(ERROR_SUCCESS);

    if (pCalcFunc == NULL || pStatFunc == NULL) {
        SetLastError(PDH_INVALID_ARGUMENT);
        bReturn = FALSE;
    }
    else {
        __try {
            * pCalcFunc = PdhiCalcNoData;
            * pStatFunc = PdhiComputeNoDataStats;
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            bReturn = FALSE;
        }
    }
    if (bReturn) {
        switch (dwCounterType) {
        case PERF_DOUBLE_RAW:
            * pCalcFunc = PdhiCalcDouble;
            * pStatFunc = PdhiComputeRawCountStats;
            break;

        case PERF_AVERAGE_TIMER:
            * pCalcFunc = PdhiCalcAverage;
            * pStatFunc = PdhiComputeFirstLastStats;
            break;

        case PERF_ELAPSED_TIME:
            * pCalcFunc = PdhiCalcElapsedTime;
            * pStatFunc = PdhiComputeRawCountStats;
            break;

        case PERF_RAW_FRACTION:
        case PERF_LARGE_RAW_FRACTION:
            * pCalcFunc = PdhiCalcRawFraction;
            * pStatFunc = PdhiComputeRawCountStats;
            break;

        case PERF_COUNTER_COUNTER:
        case PERF_COUNTER_BULK_COUNT:
        case PERF_SAMPLE_COUNTER:
            * pCalcFunc = PdhiCalcCounter;
            * pStatFunc = PdhiComputeFirstLastStats;
            break;

        case PERF_AVERAGE_BULK:
        case PERF_COUNTER_TIMER:
        case PERF_100NSEC_TIMER:
        case PERF_OBJ_TIME_TIMER:
        case PERF_COUNTER_QUEUELEN_TYPE:
        case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
        case PERF_COUNTER_100NS_QUEUELEN_TYPE:
        case PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
        case PERF_SAMPLE_FRACTION:
        case PERF_COUNTER_MULTI_TIMER:
        case PERF_100NSEC_MULTI_TIMER:
        case PERF_PRECISION_SYSTEM_TIMER:
        case PERF_PRECISION_100NS_TIMER:
        case PERF_PRECISION_OBJECT_TIMER:
            * pCalcFunc = PdhiCalcTimer;
            * pStatFunc = PdhiComputeFirstLastStats;
            break;

        case PERF_COUNTER_TIMER_INV:
        case PERF_100NSEC_TIMER_INV:
        case PERF_COUNTER_MULTI_TIMER_INV:
        case PERF_100NSEC_MULTI_TIMER_INV:
            * pCalcFunc = PdhiCalcInverseTimer;
            * pStatFunc = PdhiComputeFirstLastStats;
            break;

        case PERF_COUNTER_RAWCOUNT:
        case PERF_COUNTER_LARGE_RAWCOUNT:
        case PERF_COUNTER_RAWCOUNT_HEX:
        case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
            * pCalcFunc = PdhiCalcRawCounter;
            * pStatFunc = PdhiComputeRawCountStats;
            break;

        case PERF_COUNTER_DELTA:
        case PERF_COUNTER_LARGE_DELTA:
            * pCalcFunc = PdhiCalcDelta;
            * pStatFunc = PdhiComputeRawCountStats;
            break;

        case PERF_COUNTER_TEXT:
        case PERF_SAMPLE_BASE:
        case PERF_AVERAGE_BASE:
        case PERF_COUNTER_MULTI_BASE:
        case PERF_RAW_BASE:
        //case PERF_LARGE_RAW_BASE:
        case PERF_COUNTER_HISTOGRAM_TYPE:
        case PERF_COUNTER_NODATA:
        case PERF_PRECISION_TIMESTAMP:
            * pCalcFunc = PdhiCalcNoData;
            * pStatFunc = PdhiComputeNoDataStats;
            break;

        default:
            // an unrecognized counter type. Define the function, but
            // return false.
            * pCalcFunc = PdhiCalcNoData;
            * pStatFunc = PdhiComputeNoDataStats;
            SetLastError(PDH_FUNCTION_NOT_FOUND);
            bReturn = FALSE;
            break;
        }
    }
    return bReturn;
}

BOOL
PdhiCounterNeedLastValue(
    DWORD  dwCounterType
)
{
    BOOL bReturn = TRUE;
    switch (dwCounterType) {
    case PERF_DOUBLE_RAW:
    case PERF_ELAPSED_TIME:
    case PERF_RAW_FRACTION:
    case PERF_LARGE_RAW_FRACTION:
    case PERF_COUNTER_RAWCOUNT:
    case PERF_COUNTER_LARGE_RAWCOUNT:
    case PERF_COUNTER_RAWCOUNT_HEX:
    case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
    case PERF_COUNTER_TEXT:
    case PERF_SAMPLE_BASE:
    case PERF_AVERAGE_BASE:
    case PERF_COUNTER_MULTI_BASE:
    case PERF_RAW_BASE:
    //case PERF_LARGE_RAW_BASE:
    case PERF_COUNTER_HISTOGRAM_TYPE:
    case PERF_COUNTER_NODATA:
    case PERF_PRECISION_TIMESTAMP:
        bReturn = FALSE;
        break;

    case PERF_AVERAGE_TIMER:
    case PERF_COUNTER_COUNTER:
    case PERF_COUNTER_BULK_COUNT:
    case PERF_SAMPLE_COUNTER:
    case PERF_AVERAGE_BULK:
    case PERF_COUNTER_TIMER:
    case PERF_100NSEC_TIMER:
    case PERF_OBJ_TIME_TIMER:
    case PERF_COUNTER_QUEUELEN_TYPE:
    case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
    case PERF_COUNTER_100NS_QUEUELEN_TYPE:
    case PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
    case PERF_SAMPLE_FRACTION:
    case PERF_COUNTER_MULTI_TIMER:
    case PERF_100NSEC_MULTI_TIMER:
    case PERF_PRECISION_SYSTEM_TIMER:
    case PERF_PRECISION_100NS_TIMER:
    case PERF_PRECISION_OBJECT_TIMER:
    case PERF_COUNTER_TIMER_INV:
    case PERF_100NSEC_TIMER_INV:
    case PERF_COUNTER_MULTI_TIMER_INV:
    case PERF_100NSEC_MULTI_TIMER_INV:
    case PERF_COUNTER_DELTA:
    case PERF_COUNTER_LARGE_DELTA:

    default:
        bReturn = TRUE;
        break;
    }

    return bReturn;
}

double
APIENTRY
PdhiCalcDouble(
    PPDH_RAW_COUNTER   pThisValue,
    PPDH_RAW_COUNTER   pLastValue,
    LONGLONG         * pllTimeBase,
    LPDWORD            pdwStatus
)
{
    double  dReturn;
    DWORD   dwStatus;

    UNREFERENCED_PARAMETER(pLastValue);
    UNREFERENCED_PARAMETER(pllTimeBase);

    dReturn = * (DOUBLE *) & pThisValue->FirstValue;

    if (dReturn < 0) {
        dReturn  = 0.0f;
        dwStatus = PDH_CSTATUS_INVALID_DATA;
    }
    else {
        dwStatus = pThisValue->CStatus;
    }
    if (pdwStatus != NULL) {
        * pdwStatus = dwStatus;
    }
    return dReturn;
}

double
APIENTRY
PdhiCalcAverage(
    PPDH_RAW_COUNTER   pThisValue,
    PPDH_RAW_COUNTER   pLastValue,
    LONGLONG         * pllTimeBase,
    LPDWORD            pdwStatus
)
{
    LONGLONG llNumDiff;
    LONGLONG llDenDiff = 0;
    double   dNum;
    double   dDen;
    double   dReturn   = 0.0f;
    DWORD    dwStatus  = PDH_CSTATUS_VALID_DATA;

    // test access to the required second parameter (lastValue)
    __try {
        if (pLastValue != NULL) {
            if (IsSuccessSeverity(pLastValue->CStatus)) {
                llDenDiff = pThisValue->SecondValue - pLastValue->SecondValue;
            }
            else {
                dwStatus = pLastValue->CStatus;
            }
        }
        else {
            dwStatus = PDH_CSTATUS_INVALID_DATA;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = PDH_INVALID_ARGUMENT;
    }

    if (dwStatus == PDH_CSTATUS_VALID_DATA) {
        if ((llDenDiff > 0) && (* pllTimeBase > 0)) {
            llNumDiff = pThisValue->FirstValue - pLastValue->FirstValue;
            if (llNumDiff < 0) {
                llNumDiff += MAXDWORD;
            }
            if (llNumDiff > 0) {
                dNum    = (double) llNumDiff;
                dNum   /= (double) * pllTimeBase;
                dDen    = (double) llDenDiff;
                dReturn = (dNum / dDen);
            }
            else if (llNumDiff < 0) {
                dwStatus = PDH_CALC_NEGATIVE_VALUE;
            }
        }
        else {
            if (llDenDiff < 0) {
                dwStatus = PDH_CALC_NEGATIVE_DENOMINATOR;
            }
            else if (* pllTimeBase < 0) {
                dwStatus = PDH_CALC_NEGATIVE_TIMEBASE;
            }
        }
    }
    if (pdwStatus != NULL) {
        * pdwStatus = dwStatus;
    }
    return dReturn;
}

double
APIENTRY
PdhiCalcElapsedTime(
    PPDH_RAW_COUNTER   pThisValue,
    PPDH_RAW_COUNTER   pLastValue,
    LONGLONG         * pllTimeBase,
    LPDWORD            pdwStatus
)
{
    LONGLONG llDiff;
    double   dReturn  = 0.0f;
    DWORD    dwStatus = PDH_CSTATUS_VALID_DATA;

    UNREFERENCED_PARAMETER(pLastValue);
    // test access to the required second parameter (lastValue)
    __try {
        if (IsSuccessSeverity(pThisValue->CStatus)) {
            llDiff = pThisValue->SecondValue - pThisValue->FirstValue;
        }
        else {
            dwStatus = pThisValue->CStatus;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = PDH_INVALID_ARGUMENT;
    }

    if (dwStatus == PDH_CSTATUS_VALID_DATA) {
        if (* pllTimeBase > 0) {
            llDiff = pThisValue->SecondValue - pThisValue->FirstValue;
            if (llDiff > 0) {
                dReturn  = (double) llDiff;
                dReturn /= (double) * pllTimeBase;
            }
            else {
                if (llDiff < 0) {
                    dwStatus = PDH_CALC_NEGATIVE_DENOMINATOR;
                }
            }
        }
        else {
            if (* pllTimeBase < 0) {
                dwStatus = PDH_CALC_NEGATIVE_TIMEBASE;
            }
        }
    }
    if (pdwStatus != NULL) {
        * pdwStatus = dwStatus;
    }
    return dReturn;
}

double
APIENTRY
PdhiCalcRawFraction(
    PPDH_RAW_COUNTER   pThisValue,
    PPDH_RAW_COUNTER   pLastValue,
    LONGLONG         * pllTimeBase,
    LPDWORD            pdwStatus
)
{
    LONGLONG llDen;
    double   dReturn  = 0.0f;
    DWORD    dwStatus = PDH_CSTATUS_VALID_DATA;

    UNREFERENCED_PARAMETER(pLastValue);
    UNREFERENCED_PARAMETER(pllTimeBase);

    if ((llDen = pThisValue->SecondValue) > 0) {
        dReturn  = (double)(pThisValue->FirstValue);
        dReturn /= (double)llDen;
    }
    else {
        if (llDen < 0) {
            dwStatus = PDH_CALC_NEGATIVE_DENOMINATOR;
        }
        dReturn = (double)0.0;
    }
    if (pdwStatus != NULL) {
        * pdwStatus = dwStatus;
    }
    return dReturn;
}

double
APIENTRY
PdhiCalcCounter(
    PPDH_RAW_COUNTER   pThisValue,
    PPDH_RAW_COUNTER   pLastValue,
    LONGLONG         * pllTimeBase,
    LPDWORD            pdwStatus
)
{
    LONGLONG llNumDiff;
    LONGLONG llDenDiff = 0;
    double   dNum;
    double   dDen;
    double   dReturn   = 0.0f;
    double   dMulti;
    DWORD    dwStatus  = PDH_CSTATUS_VALID_DATA;

    // test access to the required second parameter (lastValue)
    __try {
        if (pLastValue != NULL) {
            if (IsSuccessSeverity(pLastValue->CStatus)) {
                llDenDiff = pThisValue->SecondValue - pLastValue->SecondValue;
            }
            else {
                dwStatus = pLastValue->CStatus;
            }
        }
        else {
            dwStatus = PDH_CSTATUS_INVALID_DATA;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = PDH_INVALID_ARGUMENT;
    }

    if (dwStatus == PDH_CSTATUS_VALID_DATA) {
        if ((llDenDiff > 0) && (* pllTimeBase)) {
            llNumDiff = pThisValue->FirstValue - pLastValue->FirstValue;
            if (llNumDiff < 0) {
                llNumDiff += MAXDWORD;
            }
            if (llNumDiff > 0) {
                dNum    = (double) llNumDiff;
                dDen    = (double) llDenDiff;
                dDen   /= (double) * pllTimeBase;
                dReturn = (dNum / dDen);
                if (pThisValue->MultiCount > 1) {
                    // don't do this if the count is <= 1
                    dMulti   = (double) pThisValue->FirstValue;
                    dReturn /= dMulti;
                }
            }
            else if (llNumDiff < 0) {
                dwStatus = PDH_CALC_NEGATIVE_VALUE;
            }
        }
        else {
            if (llDenDiff < 0) {
                dwStatus = PDH_CALC_NEGATIVE_DENOMINATOR;
            }
            else if (* pllTimeBase < 0) {
                dwStatus = PDH_CALC_NEGATIVE_TIMEBASE;
            }
        }
    }
    if (pdwStatus != NULL) {
        * pdwStatus = dwStatus;
    }
    return dReturn;
}

double
APIENTRY
PdhiCalcTimer(
    PPDH_RAW_COUNTER   pThisValue,
    PPDH_RAW_COUNTER   pLastValue,
    LONGLONG         * pllTimeBase,
    LPDWORD            pdwStatus
)
{
    LONGLONG llNumDiff;
    LONGLONG llDenDiff = 0;
    double   dReturn   = 0.0f;
    DWORD    dwStatus  = PDH_CSTATUS_VALID_DATA;

    UNREFERENCED_PARAMETER(pllTimeBase);

    // test access to the required second parameter (lastValue)
    __try {
        if (pLastValue != NULL) {
            if (IsSuccessSeverity(pLastValue->CStatus)) {
                llDenDiff = pThisValue->SecondValue - pLastValue->SecondValue;
            }
            else {
                dwStatus = pLastValue->CStatus;
            }
        }
        else {
            // the last value wasn't passed in
            dwStatus = PDH_CSTATUS_INVALID_DATA;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = PDH_INVALID_ARGUMENT;
    }

    if (dwStatus == PDH_CSTATUS_VALID_DATA) {
        if (llDenDiff > 0) {
            llNumDiff = pThisValue->FirstValue - pLastValue->FirstValue;
            if (llNumDiff < 0) {
                llNumDiff += MAXDWORD;
            }
            if (llNumDiff > 0) {
                dReturn  = (double) llNumDiff;
                dReturn /= (double) llDenDiff;
                if (pThisValue->MultiCount > 1) {
                    // don't do this if the count is <= 1
                    dReturn /= (double)pThisValue->MultiCount;
                }
            }
            else if (llNumDiff < 0) {
                dwStatus = PDH_CALC_NEGATIVE_VALUE;
            }
        }
        else {
            if (llDenDiff < 0) {
                dwStatus = PDH_CALC_NEGATIVE_DENOMINATOR;
            }
        }
    }
    if (pdwStatus != NULL) {
        * pdwStatus = dwStatus;
    }
    return dReturn;
}

double
APIENTRY
PdhiCalcInverseTimer(
    PPDH_RAW_COUNTER   pThisValue,
    PPDH_RAW_COUNTER   pLastValue,
    LONGLONG         * pllTimeBase,
    LPDWORD            pdwStatus
)
{
    LONGLONG llNumDiff;
    LONGLONG llDenDiff = 0;
    double   dReturn   = 0.0f;
    double   dNumDiff, dDenDiff;
    double   dRatio;
    DWORD    dwStatus  = PDH_CSTATUS_VALID_DATA;

    UNREFERENCED_PARAMETER(pllTimeBase);
    // test access to the required second parameter (lastValue)
    __try {
        if (pLastValue != NULL) {
            if (IsSuccessSeverity(pLastValue->CStatus)) {
                llDenDiff = pThisValue->SecondValue - pLastValue->SecondValue;
            }
            else {
                dwStatus = pLastValue->CStatus;
            }
        }
        else {
            dwStatus = PDH_CSTATUS_INVALID_DATA;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = PDH_INVALID_ARGUMENT;
    }
    if (dwStatus == PDH_CSTATUS_VALID_DATA) {
        if (llDenDiff > 0) {
            llNumDiff = pThisValue->FirstValue - pLastValue->FirstValue;
            if (llNumDiff < 0) {
                llNumDiff += MAXDWORD;
            }
            if (llNumDiff >= 0) {
                dNumDiff  = (double)llNumDiff;
                dDenDiff  = (double)llDenDiff;
                dRatio    = dNumDiff;
                dRatio   /= dDenDiff;
                if (pThisValue->MultiCount <= 1) {
                    dReturn = (double) 1.0;
                }
                else {
                    dReturn = (double) pThisValue->MultiCount;
                }
                // subtract the result from the multi count to get the
                // "inverse" time
                dReturn -= dRatio;

                if (dReturn < (double) 0.0) {
                    // allow a "fudge" factor before reporting errors
                    if (dReturn < (double) (-0.1)) {
                        dwStatus = PDH_CALC_NEGATIVE_DENOMINATOR;
                    }
                    dReturn = (double) 0.0;
                }
            }
            else if (llNumDiff < 0) {
                dwStatus = PDH_CALC_NEGATIVE_VALUE;
            }
        }
        else {
            if (llDenDiff < 0) {
                dwStatus = PDH_CALC_NEGATIVE_DENOMINATOR;
            }
            dReturn = (double) 0.0;
        }
    }
    if (pdwStatus != NULL) {
        * pdwStatus = dwStatus;
    }
    return dReturn;
}

double
APIENTRY
PdhiCalcRawCounter(
    PPDH_RAW_COUNTER   pThisValue,
    PPDH_RAW_COUNTER   pLastValue,
    LONGLONG         * pllTimeBase,
    LPDWORD            pdwStatus
)
{
    UNREFERENCED_PARAMETER(pLastValue);
    UNREFERENCED_PARAMETER(pllTimeBase);
    if (pdwStatus != NULL) {
        * pdwStatus = pThisValue->CStatus;
    }
    return (double) pThisValue->FirstValue;
}

double
APIENTRY
PdhiCalcNoData(
    PPDH_RAW_COUNTER   pThisValue,
    PPDH_RAW_COUNTER   pLastValue,
    LONGLONG         * pllTimeBase,
    LPDWORD            pdwStatus
)
{
    UNREFERENCED_PARAMETER(pThisValue);
    UNREFERENCED_PARAMETER(pLastValue);
    UNREFERENCED_PARAMETER(pllTimeBase);
    if (pdwStatus != NULL) {
        * pdwStatus = PDH_NO_DATA;
    }
    return (double) 0.0;
}

double
APIENTRY
PdhiCalcDelta(
    PPDH_RAW_COUNTER   pThisValue,
    PPDH_RAW_COUNTER   pLastValue,
    LONGLONG         * pllTimeBase,
    LPDWORD            pdwStatus
)
{
    LONGLONG llNumDiff = 0;
    double   dReturn   = 0.0f;
    DWORD    dwStatus  = PDH_CSTATUS_VALID_DATA;

    UNREFERENCED_PARAMETER(pllTimeBase);
    // test access to the required second parameter (lastValue)
    __try {
        if (pLastValue != NULL) {
            if (IsSuccessSeverity(pLastValue->CStatus)) {
                llNumDiff = pThisValue->FirstValue - pLastValue->FirstValue;
            }
            else {
                dwStatus = pLastValue->CStatus;
            }
        }
        else {
            dwStatus = PDH_CSTATUS_INVALID_DATA;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = PDH_INVALID_ARGUMENT;
    }

    if (dwStatus == PDH_CSTATUS_VALID_DATA) {
        if (llNumDiff < 0) {
            llNumDiff += MAXDWORD;
        }
        if (llNumDiff < 0) {
            dwStatus = PDH_CALC_NEGATIVE_VALUE;
            dReturn  = (double) 0.0;
        }
        else {
            dReturn = (double)llNumDiff;
        }
    }
    if (pdwStatus != NULL) {
        * pdwStatus = dwStatus;
    }
    return dReturn;
}

PDH_STATUS
PdhiComputeFormattedValue(
    LPCOUNTERCALC         pCalcFunc,
    DWORD                 dwCounterType,
    LONG                  lScale,
    DWORD                 dwFormat,
    PPDH_RAW_COUNTER      pRawValue1,
    PPDH_RAW_COUNTER      pRawValue2,
    PLONGLONG             pTimeBase,
    DWORD                 dwReserved,
    PPDH_FMT_COUNTERVALUE pValue
)
{
    double     dResult = (double)0.0;
    double     dScale;
    PDH_STATUS lStatus = ERROR_SUCCESS;
    DWORD      dwValueStatus = PDH_CSTATUS_VALID_DATA;

    UNREFERENCED_PARAMETER(dwReserved);

    __try {
        // make sure the counter values are valid before continuing
        if (pRawValue1 != NULL) {
            if ((pRawValue1->CStatus != PDH_CSTATUS_NEW_DATA) &&
                            (pRawValue1->CStatus != PDH_CSTATUS_VALID_DATA)) {
                dwValueStatus = pRawValue1->CStatus;
                lStatus       = PDH_INVALID_DATA;
            }
        }
        else {
            // this is a required parameter
            dwValueStatus = PDH_CSTATUS_INVALID_DATA;
            lStatus       = PDH_INVALID_ARGUMENT;
        }

        if ((lStatus == ERROR_SUCCESS) && (pRawValue2 != NULL)) {
            if (PdhiCounterNeedLastValue(dwCounterType) == TRUE) {
                // this is an optional parameter, but if present, it must be valid
                if ((pRawValue2->CStatus != PDH_CSTATUS_NEW_DATA) &&
                                (pRawValue2->CStatus != PDH_CSTATUS_VALID_DATA)) {
                    dwValueStatus = pRawValue2->CStatus;
                    lStatus       = PDH_INVALID_DATA;
                }
            }
        }

        if (((dwFormat & PDH_FMT_LONG) != 0) && ((dwFormat & PDH_FMT_LARGE) != 0)) {
            dwValueStatus = PDH_CSTATUS_INVALID_DATA;
            lStatus       = PDH_INVALID_ARGUMENT;
        }
        else if (((dwFormat & PDH_FMT_LONG) != 0) || ((dwFormat & PDH_FMT_LARGE) != 0)) {
            if (dwFormat & PDH_FMT_DOUBLE) {
                dwValueStatus = PDH_CSTATUS_INVALID_DATA;
                lStatus       = PDH_INVALID_ARGUMENT;
            }
        }

        if (lScale > PDH_MAX_SCALE || lScale < PDH_MIN_SCALE) {
            dwValueStatus = PDH_CSTATUS_INVALID_DATA;
            lStatus       = PDH_INVALID_ARGUMENT;
        }
        if (pTimeBase == NULL) {
            dwValueStatus = PDH_CSTATUS_INVALID_DATA;
            lStatus       = PDH_INVALID_ARGUMENT;
        }
        else {
            LONGLONG tmpTimeBase = * pTimeBase;
            * pTimeBase = tmpTimeBase;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        dwValueStatus = PDH_CSTATUS_INVALID_DATA;
        lStatus       = PDH_INVALID_ARGUMENT;
    }
    if (lStatus == ERROR_SUCCESS) {
        // call the counter's calculation function if the raw value is valid
        if (IsSuccessSeverity(pRawValue1->CStatus)) {
            __try {
                dResult = (* pCalcFunc)(pRawValue1, pRawValue2, pTimeBase, & dwValueStatus);
                // format returned value

                if ((dwCounterType & 0xF0000000) == PERF_DISPLAY_PERCENT) {
                    // scale to show percent
                    dResult *= (double) 100.0;
                    // this should probably be controlled by a registry
                    // value as is the case with PERFMON
                    if (! (dwFormat & PDH_FMT_NOCAP100)) {
                        if (dResult > (double) 100.0) dResult = (double) 100.0;
                    }
                }
                if (!(dwFormat & PDH_FMT_NOSCALE)) {
                    //now scale
                    dScale   = pow(10.0, (double)lScale);
                    dResult *= dScale;
                }

                if (dwFormat & PDH_FMT_1000) {
                    //now scale
                    dResult *= (double) 1000.0;
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                // something failed
                dResult       = (double) 0.0;
                dwValueStatus = PDH_INVALID_ARGUMENT;
            }
        }
        else {
            dwValueStatus = pRawValue1->CStatus;
        }
        if (!IsSuccessSeverity(dwValueStatus)) {
            // an error occured so pass that on to the caller
            lStatus = dwValueStatus;
        }
    } //end if valid counter data

    // now format
    __try {
        if (dwFormat & PDH_FMT_LONG) {
            pValue->longValue = (LONG) dResult;
        }
        else if (dwFormat & PDH_FMT_LARGE) {
            pValue->largeValue = (LONGLONG) dResult;
        }
        else {
            // double is the default
            pValue->doubleValue = dResult;
        }
        pValue->CStatus = dwValueStatus;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = PDH_INVALID_ARGUMENT;
    }
    return lStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhdll\dllinit.c ===
/*++
Copyright (c) 1995-1999  Microsoft Corporation

Module Name:
    dllinit.c

Abstract:
    This module contians the DLL attach/detach event entry point for
    the pdh.dll

Author:
    Bob Watson (a-robw) Jul 95

Revision History:
--*/

#include <windows.h>
#include <wmistr.h>
#include <objbase.h>
#include <initguid.h>
#include <evntrace.h>
#include <wmiguid.h>
#include <wmium.h>
#include "strsafe.h"
#include "pdh.h"
#include "pdhp.h"
#include "pdhitype.h"
#define _INIT_PDH_DEBUGTRACE
#include "pdhidef.h"
#include "pdhmsg.h"
#include "strings.h"

#define  PDH_DEFAULT_COLLECT_TIMEOUT 300 // 5 minutes

HANDLE    ThisDLLHandle    = NULL;
WCHAR     szStaticLocalMachineName[MAX_COMPUTERNAME_LENGTH + 3] = {0};
HANDLE    hPdhDataMutex    = NULL;
HANDLE    hPdhContextMutex = NULL;
HANDLE    hPdhHeap         = NULL;
HANDLE    hEventLog        = NULL;

LONGLONG  llRemoteRetryTime            = RETRY_TIME_INTERVAL;
BOOL      bEnableRemotePdhAccess       = TRUE;
DWORD     dwPdhiLocalDefaultDataSource = DATA_SOURCE_REGISTRY;
LONG      dwCurrentRealTimeDataSource  = 0;
ULONGLONG ulPdhCollectTimeout          = PDH_DEFAULT_COLLECT_TIMEOUT;
BOOL      bProcessIsDetaching          = FALSE;

LPWSTR
GetStringResource(
    DWORD   dwResId
)
{
    LPWSTR  szReturnString = NULL;
    LPWSTR  szTmpString    = NULL;
    DWORD   dwStrLen       = (2048 * sizeof(WCHAR));

    szReturnString = (LPWSTR) G_ALLOC(dwStrLen);
    if (szReturnString != NULL) {
        dwStrLen /= sizeof(WCHAR);
        dwStrLen = LoadStringW(ThisDLLHandle, (UINT) dwResId,  szReturnString,  dwStrLen);
        if (dwStrLen > 0) {
            // then realloc down to the size used
            dwStrLen ++; // to include the NULL
            dwStrLen      *= sizeof(WCHAR);
            szTmpString    = szReturnString;
            szReturnString = G_REALLOC(szTmpString, dwStrLen);
            if (szReturnString == NULL) {
                G_FREE(szTmpString);
                szTmpString = NULL;
            }
        }
        else {
            // free the memory since the look up failed
            G_FREE(szReturnString);
            szReturnString = NULL;
        }
    } //else  allocation failed

    return szReturnString;
}

STATIC_BOOL
PdhiOpenEventLog(
    HANDLE  * phEventLogHandle
)
{
    HANDLE  hReturn;
    BOOL    bReturn = FALSE;

    if ((hReturn = RegisterEventSourceW(NULL, cszAppShortName)) != NULL) {
        * phEventLogHandle = hReturn;
        bReturn            = TRUE;
    }
    return bReturn;
}

STATIC_BOOL
PdhiGetRegistryDefaults()
{
    DWORD dwStatus;
    DWORD dwType, dwSize, dwValue;

    HKEY    hKeyPDH;

    ulPdhCollectTimeout = ((ULONGLONG) PDH_DEFAULT_COLLECT_TIMEOUT) * ((ULONGLONG) 10000000);   
    // the local data source is not initialized so use it
    dwStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE, cszPdhKey, 0L, KEY_READ, & hKeyPDH);
    if (dwStatus == ERROR_SUCCESS) {
        // get the default null data source
        //
        dwValue  = 0;
        dwType   = 0;
        dwSize   = sizeof (dwValue);
        dwStatus = RegQueryValueExW(hKeyPDH, cszDefaultNullDataSource, NULL, & dwType, (LPBYTE) & dwValue, & dwSize);
        if (dwStatus != ERROR_SUCCESS || dwType != REG_DWORD) {
            dwValue = DATA_SOURCE_REGISTRY;
        }
        else {
            // check the value for validity
            switch (dwValue) {
            case DATA_SOURCE_WBEM:
            case DATA_SOURCE_REGISTRY:
                // this is OK
                break;

            case DATA_SOURCE_LOGFILE:
            default:
                // these are not OK so insert default
                dwValue = DATA_SOURCE_REGISTRY;
                break;
            }
        }
        dwPdhiLocalDefaultDataSource = dwValue;

        //
        //  get the retry timeout
        //
        dwValue  = 0;
        dwType   = 0;
        dwSize   = sizeof (dwValue);
        dwStatus = RegQueryValueExW(hKeyPDH, cszRemoteMachineRetryTime, NULL, & dwType, (LPBYTE) & dwValue, & dwSize);
        if (dwStatus != ERROR_SUCCESS || dwType != REG_DWORD) {
            dwValue = 0;
        }
        else {
            // check the value for validity
            // must be 30 seconds or more yet no more than an hour
            if ((dwValue <= 30) || (dwValue > 3600)) {
                dwValue = 0;
            }
        }
        if (dwValue != 0) {
            // convert to 100NS units
            llRemoteRetryTime = dwValue * 10000000;   
        }
        else {
            // use default
            llRemoteRetryTime = RETRY_TIME_INTERVAL;
        }

        //  get the remote access mode
        //
        dwValue = 0;
        dwType = 0;
        dwSize = sizeof (dwValue);
        dwStatus = RegQueryValueExW(hKeyPDH, cszEnableRemotePdhAccess, NULL, & dwType, (LPBYTE) & dwValue, & dwSize);
        if (dwStatus != ERROR_SUCCESS || dwType != REG_DWORD) {
            dwValue = TRUE;
        }
        else {
            // check the value for validity
            if (dwValue != 0) {
                dwValue = TRUE;
            }            
        }
        bEnableRemotePdhAccess = (BOOL) dwValue;

        // get RegQueryValueEx(HKEY_PERFORMANCE_DATA) elapsed time maximum
        //
        dwValue  = 0;
        dwType   = 0;
        dwSize   = sizeof(dwValue);
        dwStatus = RegQueryValueExW(hKeyPDH, cszCollectTimeout, NULL, & dwType, (LPBYTE) & dwValue, & dwSize);
        if (dwStatus != ERROR_SUCCESS || dwType != REG_DWORD) {
            dwValue = PDH_DEFAULT_COLLECT_TIMEOUT;
        }
        else if (dwValue < 30 || dwValue > 3600) {
            // must between 30 seconds and 1 hour
            //
            dwValue = PDH_DEFAULT_COLLECT_TIMEOUT;
        }
        ulPdhCollectTimeout = ((ULONGLONG) dwValue) * ((ULONGLONG) 10000000);   

        // close the registry key
        RegCloseKey(hKeyPDH);
    }
    return TRUE;
}

STATIC_BOOL
PdhiCloseEventLog(
    HANDLE  * phEventLogHandle
)
{
    BOOL    bReturn = TRUE;

    if (* phEventLogHandle != NULL) {
        bReturn            = DeregisterEventSource(* phEventLogHandle);
        * phEventLogHandle = NULL;
    }
    return bReturn;
}

HRESULT
PdhiPlaInitMutex()
{
    HRESULT hr = ERROR_SUCCESS;
    BOOL bResult = TRUE;

    PSECURITY_DESCRIPTOR  SD = NULL;
    SECURITY_ATTRIBUTES sa;
    PSID AuthenticatedUsers    = NULL;
    PSID BuiltInAdministrators = NULL;
    PSID NetworkService        = NULL;
    PSID LoggingUsers          = NULL;
    DWORD dwAclSize;
    ACL  *Acl;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    bResult = AllocateAndInitializeSid(
                        &NtAuthority,
                        2,
                        SECURITY_BUILTIN_DOMAIN_RID,
                        DOMAIN_ALIAS_RID_ADMINS,
                        0,0,0,0,0,0,
                        &BuiltInAdministrators);
    if( !bResult ){goto cleanup;}

    bResult = AllocateAndInitializeSid(
                        &NtAuthority,
                        1,
                        SECURITY_AUTHENTICATED_USER_RID,
                        0,0,0,0,0,0,0,
                        &AuthenticatedUsers);
    if( !bResult ){goto cleanup;}

    bResult = AllocateAndInitializeSid(
                        &NtAuthority,
                        1,
                        SECURITY_NETWORK_SERVICE_RID,
                        0,0,0,0,0,0,0,
                        &NetworkService);
    if( !bResult ){goto cleanup;}

    bResult = AllocateAndInitializeSid(
                        &NtAuthority,
                        1,
                        DOMAIN_ALIAS_RID_LOGGING_USERS,
                        0,0,0,0,0,0,0,
                        &LoggingUsers);
    if( !bResult ){goto cleanup;}


    dwAclSize = sizeof (ACL) +
                (4 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
                GetLengthSid(AuthenticatedUsers) +
                GetLengthSid(BuiltInAdministrators) +
                GetLengthSid(NetworkService) +
                GetLengthSid(LoggingUsers);

    SD = (PSECURITY_DESCRIPTOR)G_ALLOC(SECURITY_DESCRIPTOR_MIN_LENGTH + dwAclSize);
    if( NULL == SD ){ goto cleanup; }

    ZeroMemory( SD, sizeof(SD) );
    
    Acl = (ACL *)((BYTE *)SD + SECURITY_DESCRIPTOR_MIN_LENGTH);

    bResult = InitializeAcl( Acl, dwAclSize, ACL_REVISION);
    if( !bResult ){goto cleanup;}

    bResult = AddAccessAllowedAce(Acl, ACL_REVISION, MUTEX_ALL_ACCESS, AuthenticatedUsers );
    if( !bResult ){goto cleanup;}

    bResult = AddAccessAllowedAce(Acl, ACL_REVISION, MUTEX_ALL_ACCESS , NetworkService );
    if( !bResult ){goto cleanup;}

    bResult = AddAccessAllowedAce(Acl, ACL_REVISION, MUTEX_ALL_ACCESS , LoggingUsers );
    if( !bResult ){goto cleanup;}
    
    bResult = AddAccessAllowedAce(Acl, ACL_REVISION, GENERIC_ALL, BuiltInAdministrators );
    if( !bResult ){goto cleanup;}

    bResult = InitializeSecurityDescriptor(SD, SECURITY_DESCRIPTOR_REVISION);
    if( !bResult ){goto cleanup;}

    bResult = SetSecurityDescriptorDacl(SD, TRUE, Acl,  FALSE);
    if( !bResult ){goto cleanup;}
    
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = SD;
    sa.bInheritHandle = FALSE;

    hPdhPlaMutex = CreateMutexW( &sa, FALSE, PDH_PLA_MUTEX );

cleanup:
    if( hPdhPlaMutex == NULL || !bResult ){
        hr = GetLastError();
    }
    if( NULL != AuthenticatedUsers ){
        FreeSid(AuthenticatedUsers);
    }
    if( NULL != BuiltInAdministrators){
        FreeSid(BuiltInAdministrators);
    }
    if( NULL != NetworkService){
        FreeSid(NetworkService);
    }
    if( NULL != LoggingUsers){
        FreeSid(LoggingUsers);
    }
    G_FREE(SD);

    return hr;
}

const LPCWSTR cszTraceLevel           = L"DebugTraceLevel";
const LPCWSTR cszTraceFileValue       = L"DebugTraceFile";
const LPCWSTR cszTraceLogName         = L"PDH Debug Logger";
const LPCWSTR cszDefaultTraceFile     = L"PdhDbg.Etl";
const LPCWSTR cszDefaultTraceFileName = L"C:\\PdhDbg.Etl";

TRACEHANDLE   g_hTraceHandle      = 0;
LONG          g_lDbgStarted       = 0;

DEFINE_GUID( /* 51af3adf-28b1-4ba5-b59a-3aeec16deb3c */
    PdhDebugGuid,
    0x51af3adf,
    0x28b1,
    0x4ba5,
    0xb5, 0x9a, 0x3a, 0xee, 0xc1, 0x6d, 0xeb, 0x3c
);

PDH_FUNCTION
PdhDebugStartTrace()
{
    DWORD       status          = ERROR_SUCCESS;
    DWORD       dwType          = 0;
    DWORD       dwSize          = 0;
    DWORD       dwTraceLevel    = PDH_DBG_TRACE_NONE;
    HKEY        hKey            = NULL;
    TRACEHANDLE TraceHandle     = 0;
    LPWSTR      szTraceFileName = NULL;
    CHAR        Buffer[SMALL_BUFFER_SIZE];
    PCHAR       ptr;
    ULONG       lFileNameSize = 0;

    PEVENT_TRACE_PROPERTIES Properties;

    if (InterlockedCompareExchange(& g_lDbgStarted, 1, 0) != 0) {
        return ERROR_SUCCESS;
    }

    status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                           L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\PDH",
                           0L,
                           KEY_READ,
                           & hKey);
    if (status == ERROR_SUCCESS) {
        dwSize = sizeof(DWORD);
        dwType = 0;
        status = RegQueryValueExW(hKey, cszTraceLevel, NULL, & dwType, (LPBYTE) & dwTraceLevel, & dwSize);
        if ((status != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
            dwTraceLevel = PDH_DBG_TRACE_NONE;
        }
    }

    if (dwTraceLevel == PDH_DBG_TRACE_NONE) goto Cleanup;

    dwType = 0;
    dwSize = 0;
    status = RegQueryValueExW(hKey, cszTraceFileValue, NULL, & dwType, (LPBYTE) szTraceFileName, & dwSize);
    while (status == ERROR_MORE_DATA) {
        if (szTraceFileName != NULL) HeapFree(GetProcessHeap(), 0, szTraceFileName);
        szTraceFileName = (LPWSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize);
        status = RegQueryValueExW(hKey, cszTraceFileValue, NULL, & dwType, (LPBYTE) szTraceFileName, & dwSize);
    }
    if (status != ERROR_SUCCESS || dwType != REG_SZ) {
        DWORD dwFileSize = MAX_PATH + lstrlenW(cszDefaultTraceFile) + 2;

        if (szTraceFileName != NULL) HeapFree(GetProcessHeap(), 0, szTraceFileName);
        szTraceFileName = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(WCHAR) * dwFileSize);
        if (szTraceFileName == NULL) {
            goto Cleanup;
        }

        if (GetSystemWindowsDirectoryW(szTraceFileName, MAX_PATH) > 0) {
            StringCchCatW(szTraceFileName, dwFileSize, L"\\");
            StringCchCatW(szTraceFileName, dwFileSize, cszDefaultTraceFile);
        }
        else {
            StringCchCopyW(szTraceFileName, MAX_PATH, cszDefaultTraceFileName);
        }
    }
    lFileNameSize = sizeof(WCHAR) * (lstrlenW(szTraceFileName) + 1);

    Properties = (PEVENT_TRACE_PROPERTIES) Buffer;

    ZeroMemory(Buffer, SMALL_BUFFER_SIZE);
    Properties->Wnode.BufferSize  = SMALL_BUFFER_SIZE;
    Properties->Wnode.Flags       = WNODE_FLAG_TRACED_GUID;
    Properties->LoggerNameOffset  = sizeof(EVENT_TRACE_PROPERTIES);
    Properties->LogFileNameOffset = Properties->LoggerNameOffset + sizeof(cszTraceLogName);
    ptr = (PCHAR) (((PCHAR) Buffer) + Properties->LoggerNameOffset);
    RtlCopyMemory(ptr, cszTraceLogName, sizeof(cszTraceLogName));
    ptr = (PCHAR) (((PCHAR) Buffer) + Properties->LogFileNameOffset);
    RtlCopyMemory(ptr, szTraceFileName, lFileNameSize);
    status = QueryTraceW(0, cszTraceLogName, Properties);
    if (status == ERROR_SUCCESS) {
        TraceHandle = (TRACEHANDLE) Properties->Wnode.HistoricalContext;
        goto Cleanup;
    }

    // Reinitialize structure again for StartTrace()
    //
    ZeroMemory(Buffer, SMALL_BUFFER_SIZE);
    Properties->Wnode.BufferSize  = SMALL_BUFFER_SIZE;
    Properties->Wnode.Flags       = WNODE_FLAG_TRACED_GUID;
    Properties->BufferSize        = 64;
    Properties->LogFileMode       = EVENT_TRACE_FILE_MODE_SEQUENTIAL
                                  | EVENT_TRACE_USE_PAGED_MEMORY
                                  | EVENT_TRACE_FILE_MODE_APPEND;
    Properties->LoggerNameOffset  = sizeof(EVENT_TRACE_PROPERTIES);
    Properties->LogFileNameOffset = Properties->LoggerNameOffset + sizeof(cszTraceLogName);
    ptr = (PCHAR) (((PCHAR) Buffer) + Properties->LoggerNameOffset);
    RtlCopyMemory(ptr, cszTraceLogName, sizeof(cszTraceLogName));
    ptr = (PCHAR) (((PCHAR) Buffer) + Properties->LogFileNameOffset);
    RtlCopyMemory(ptr, szTraceFileName, lFileNameSize);

    status = StartTraceW(& TraceHandle, cszTraceLogName, Properties);
    if (status == ERROR_SUCCESS) {
        g_hTraceHandle = TraceHandle;
    }
    else {
        dwTraceLevel = PDH_DBG_TRACE_NONE;
        TraceHandle  = (TRACEHANDLE) 0;
    }

Cleanup:
    if (hKey != NULL && hKey != INVALID_HANDLE_VALUE) RegCloseKey(hKey);
    if (szTraceFileName != NULL) HeapFree(GetProcessHeap(), 0, szTraceFileName);
    g_dwDebugTraceLevel = dwTraceLevel;
    g_hTraceHandle      = TraceHandle;
    return status;
}

VOID
PdhDbgTrace(
    ULONG   LineNumber,
    ULONG   ModuleNumber,
    ULONG   OptArgs,
    ULONG   Status,
    ...
)
{
    ULONG ErrorCode;
    struct _MY_EVENT {
        EVENT_TRACE_HEADER Header;
        MOF_FIELD MofField[MAX_MOF_FIELDS];
    } MyEvent;
    ULONG i;
    va_list ArgList;
    PVOID source;
    SIZE_T len;
    DWORD  dwLastError;

    dwLastError = GetLastError();
    RtlZeroMemory(& MyEvent, sizeof(EVENT_TRACE_HEADER));

    va_start(ArgList, Status);
    for (i = 3; i < MAX_MOF_FIELDS; i ++) {
        source = va_arg(ArgList, PVOID);
        if (source == NULL) break;
        len = va_arg(ArgList, SIZE_T);
        if (len == 0) break;
        MyEvent.MofField[i].DataPtr = (ULONGLONG) source;
        MyEvent.MofField[i].Length  = (ULONG) len;
    }
    va_end(ArgList);

    MyEvent.Header.Class.Type   = (UCHAR) ModuleNumber;
    MyEvent.Header.Size         = (USHORT) (  sizeof(EVENT_TRACE_HEADER)
                                            + (i * sizeof(MOF_FIELD)));
    MyEvent.Header.Flags        = WNODE_FLAG_TRACED_GUID |
                                  WNODE_FLAG_USE_MOF_PTR |
                                  WNODE_FLAG_USE_GUID_PTR;
    MyEvent.Header.GuidPtr      = (ULONGLONG) & PdhDebugGuid;
    MyEvent.MofField[0].DataPtr = (ULONGLONG) & LineNumber;
    MyEvent.MofField[0].Length  = sizeof(LineNumber);
    MyEvent.MofField[1].DataPtr = (ULONGLONG) & Status;
    MyEvent.MofField[1].Length  = sizeof(Status);
    MyEvent.MofField[2].DataPtr = (ULONGLONG) & OptArgs;
    MyEvent.MofField[2].Length  = sizeof(OptArgs);

    __try {
        ErrorCode = TraceEvent(g_hTraceHandle, (PEVENT_TRACE_HEADER) & MyEvent);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = GetLastError();
    }

    if (ErrorCode != ERROR_SUCCESS) {
        DebugPrint((1, "ErrorCode = %d Module = %d Line = %d Status = 0X%08X\n",
                ErrorCode, ModuleNumber, LineNumber, Status));
    }

    SetLastError(dwLastError);
}

BOOL
_stdcall
PdhDllInitRoutine(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
)
{
    BOOL    bStatus;
    BOOL    bReturn = TRUE;
    OSVERSIONINFOW   os;
    ReservedAndUnused;

    switch(Reason) {
        case DLL_PROCESS_ATTACH:
            bProcessIsDetaching = FALSE;
            {
                DWORD   dwBufferLength = 0;

                ThisDLLHandle = DLLHandle;

                // make sure this is the correct operating system
                ZeroMemory(& os, sizeof(OSVERSIONINFOW));
                os.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
                bReturn = GetVersionExW(& os);
                if (bReturn) {
                    // check for windows NT v4.0
                    if (os.dwPlatformId != VER_PLATFORM_WIN32_NT) {
                        // not WINDOWS NT
                        bReturn = FALSE;
                    }
                    else if (os.dwMajorVersion < 4) {
                        // it's windows NT, but an old one
                        bReturn = FALSE;
                    }
                }
                else {
                    // unable to read version so give up
                }

                if (bReturn) {
                    // disable thread init calls
                    DisableThreadLibraryCalls(DLLHandle);

                    // initialize the event log so events can be reported
                    PdhDebugStartTrace();
                    bStatus = PdhiOpenEventLog(& hEventLog);
                    bStatus = PdhiGetRegistryDefaults();

                    // initialize the local computer name buffer
                    if (szStaticLocalMachineName[0] == 0) {
                        // initialize the computer name for this computer
                        szStaticLocalMachineName[0] = BACKSLASH_L;
                        szStaticLocalMachineName[1] = BACKSLASH_L;
                        dwBufferLength              = MAX_COMPUTERNAME_LENGTH + 1;
                        GetComputerNameW(& szStaticLocalMachineName[2], & dwBufferLength);
                    }
                    hPdhDataMutex    = CreateMutexW(NULL, FALSE, NULL);
                    hPdhContextMutex = CreateMutexW(NULL, FALSE, NULL);
                    hPdhHeap         = HeapCreate(0, 0, 0);
                    if (hPdhHeap == NULL) {
                        // unable to create our own heap, so use the
                        // process heap
                        hPdhHeap = GetProcessHeap();
                    }
                    PdhiPlaInitMutex();
                }
            }
            break;

        case DLL_PROCESS_DETACH:

            // close all pending loggers
            //
            bProcessIsDetaching = (ReservedAndUnused != NULL) ? (TRUE) : (FALSE);
            PdhiCloseAllLoggers();

            // walk down query list and close (at least disconnect) queries.
            PdhiQueryCleanup ();
            FreeAllMachines(bProcessIsDetaching);
            PdhiFreeAllWbemServers();
            if (hPdhDataMutex != NULL) {
                bStatus = CloseHandle(hPdhDataMutex);
                hPdhDataMutex = NULL;
            }
            if (hPdhContextMutex != NULL) {
                bStatus = CloseHandle(hPdhContextMutex);
                hPdhContextMutex = NULL;
            }

            if (hPdhHeap != GetProcessHeap()) {
                HeapDestroy(hPdhHeap);
                hPdhHeap = NULL;
            }

            // lastly close the event log interface
            bStatus = PdhiCloseEventLog(& hEventLog);
            bReturn = TRUE;
            break ;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            bReturn = TRUE;
            break;
    }

    return (bReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhcalc\statfuns.c ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    statfuns.c

Abstract:

    Statistical calculation functions

--*/

#include <windows.h>
#include <math.h>
#include "strsafe.h"
#include <pdh.h> 
#include "pdhitype.h"
#include "pdhidef.h"
#include "pdhicalc.h"
#include "pdhmsg.h"

#define PDHI_FMT_FILTER     (PDH_FMT_LONG | PDH_FMT_DOUBLE | PDH_FMT_LARGE)

PDH_STATUS
APIENTRY
PdhiComputeFirstLastStats(
    PPDHI_COUNTER    pCounter,
    DWORD            dwFormat,
    DWORD            dwFirstEntry,
    DWORD            dwNumEntries,
    PPDH_RAW_COUNTER lpRawValueArray,
    PPDH_STATISTICS  data
)
{
    PDH_STATUS           Status           = ERROR_SUCCESS;
    DOUBLE               dThisValue       = (double) 0.0;
    DOUBLE               dMin             = (double) +10E8;    // these are just "big" seed numbers
    DOUBLE               dMax             = (double) -10E8;    
    DOUBLE               dMean            = (double) 0.0;
    DOUBLE               dTotal           = (double) 0.0;
    BOOLEAN              bFirstItem       = TRUE;
    DWORD                dwItem;
    DWORD                dwValidItemCount = 0;
    DWORD                dwFirstValidItem = 0;
    DWORD                dwLastValidItem  = 0;
    DWORD                dwComputeFormat;
    PPDH_RAW_COUNTER     pNewCounter;
    PPDH_RAW_COUNTER     pOldCounter;
    PDH_FMT_COUNTERVALUE fmtValue;
    DWORD                cStatusReturn;

    __try {
        // initialize th user's data buffer
        data->dwFormat        = 0;
        data->count           = 0;
        data->min.CStatus     = PDH_CSTATUS_INVALID_DATA;
        data->min.largeValue  = 0;
        data->max.CStatus     = PDH_CSTATUS_INVALID_DATA;
        data->max.largeValue  = 0;
        data->mean.CStatus    = PDH_CSTATUS_INVALID_DATA;
        data->mean.largeValue = 0;

        // find first valid counter in array
        dwItem      = dwFirstEntry;
        pNewCounter = NULL;
        pOldCounter = & lpRawValueArray[dwItem];
        do {
            // get value of this instance if next counter is valid
            if ((pOldCounter->CStatus == PDH_CSTATUS_VALID_DATA) ||
                            (pOldCounter->CStatus == PDH_CSTATUS_NEW_DATA)) {
                pNewCounter      = pOldCounter;
                dwFirstValidItem = dwItem;
                break;
            }
            else {
                dwItem      = ++ dwItem % dwNumEntries;
                pOldCounter = & lpRawValueArray[dwItem];
            }
        }
        while (dwItem != dwFirstEntry);
        
        // do calculations in Floating point format
        dwComputeFormat  = dwFormat;
        dwComputeFormat &= ~ PDHI_FMT_FILTER;
        dwComputeFormat |= PDH_FMT_DOUBLE | PDH_FMT_NOCAP100;

        // go to next entry to begin processing
        dwItem      = ++ dwItem % dwNumEntries;
        pNewCounter = & lpRawValueArray[dwItem];

        // these counters need 2 or more entrys to compute values from
        if ((dwItem != dwFirstEntry) && (dwNumEntries > 1)) {
            // start record found so initialize and continue
            dwLastValidItem = dwItem;

            // step through the remaining entries
            while (dwItem != dwFirstEntry) {
                // get value of this instance if next counter is valid
                if ((pNewCounter->CStatus == PDH_CSTATUS_VALID_DATA) ||
                                (pNewCounter->CStatus == PDH_CSTATUS_NEW_DATA)) {
                    // record this as a valid counter
                    dwLastValidItem = dwItem;
                    // get current value
                    cStatusReturn = PdhiComputeFormattedValue(
                                    pCounter->CalcFunc,
                                    pCounter->plCounterInfo.dwCounterType,
                                    pCounter->lScale,
                                    dwComputeFormat,
                                    pNewCounter,
                                    pOldCounter,
                                    & pCounter->TimeBase,
                                    0L,
                                    & fmtValue);
                    if (cStatusReturn == ERROR_SUCCESS) {
                        dThisValue = fmtValue.doubleValue;
                        // update min & max
                        if (bFirstItem) {
                            dMax = dMin = dThisValue;
                            bFirstItem = FALSE;
                        }
                        else {
                            if (dThisValue > dMax) dMax = dThisValue;
                            if (dThisValue < dMin) dMin = dThisValue;
                        }
                        dTotal += dThisValue;
                        dwValidItemCount++;
                    }
                }
                pOldCounter = pNewCounter;
                dwItem      = ++ dwItem % dwNumEntries;
                pNewCounter = & lpRawValueArray[dwItem];
            }
            // compute average
            if (dwValidItemCount > 0) {
                pOldCounter = & lpRawValueArray[dwFirstValidItem];
                pNewCounter = & lpRawValueArray[dwLastValidItem];

                cStatusReturn = PdhiComputeFormattedValue(
                                pCounter->CalcFunc,
                                pCounter->plCounterInfo.dwCounterType,
                                pCounter->lScale,
                                dwComputeFormat,
                                pNewCounter,
                                pOldCounter,
                                & pCounter->TimeBase,
                                0L,
                                & fmtValue);
                if (cStatusReturn == ERROR_SUCCESS) {
                    dMean         = fmtValue.doubleValue;
                    cStatusReturn = PDH_CSTATUS_VALID_DATA;
                }
                else {
                    dMean         = dTotal / dwValidItemCount;
                    cStatusReturn = PDH_CSTATUS_VALID_DATA;
                }
            }
            else {
                dMean         = 0.0;
                dMax          = 0.0;
                dMin          = 0.0;
                cStatusReturn = PDH_CSTATUS_INVALID_DATA;
            }
        }
        else {
            // array does not contain a valid counter so exit
            dMean         = 0.0;
            dMax          = 0.0;
            dMin          = 0.0;
            cStatusReturn = PDH_CSTATUS_INVALID_DATA;
        }

        // update user's buffer with new data
        data->dwFormat     = dwFormat;
        data->count        = dwValidItemCount;
        data->min.CStatus  = cStatusReturn;
        data->max.CStatus  = cStatusReturn;
        data->mean.CStatus = cStatusReturn;
        switch ((dwFormat & PDHI_FMT_FILTER)) {
            case PDH_FMT_LONG:
                if (dMin > (DOUBLE) MAXLONG) {
                    data->min.longValue = MAXLONG;
                    data->min.CStatus   = PDH_CSTATUS_INVALID_DATA;
                }
                else {
                    data->min.longValue = (long) dMin;
                }
                if (dMax > (DOUBLE) MAXLONG) {
                    data->max.longValue = MAXLONG;
                    data->max.CStatus   = PDH_CSTATUS_INVALID_DATA;
                }
                else {
                    data->max.longValue = (long) dMax;
                }
                if (dMean > (DOUBLE) MAXLONG) {
                    data->mean.longValue = MAXLONG;
                    data->mean.CStatus   = PDH_CSTATUS_INVALID_DATA;
                }
                else {
                    data->mean.longValue = (long) dMean;
                }
                break;

            case PDH_FMT_DOUBLE:
                data->min.doubleValue  = dMin;
                data->max.doubleValue  = dMax;
                data->mean.doubleValue = dMean;
                break;

            case PDH_FMT_LARGE:
            default:
                if (dMin > (DOUBLE) MAXLONGLONG) {
                    data->min.largeValue = MAXLONGLONG;
                    data->min.CStatus    = PDH_CSTATUS_INVALID_DATA;
                }
                else {
                    data->min.largeValue = (LONGLONG) dMin;
                }
                if (dMax > (DOUBLE) MAXLONGLONG) {
                    data->max.largeValue = MAXLONGLONG;
                    data->max.CStatus    = PDH_CSTATUS_INVALID_DATA;
                }
                else {
                    data->max.largeValue = (LONGLONG) dMax;
                }
                if (dMean > (DOUBLE) MAXLONGLONG) {
                    data->mean.largeValue = MAXLONGLONG;
                    data->mean.CStatus    = PDH_CSTATUS_INVALID_DATA;
                }
                else {
                    data->mean.largeValue = (LONGLONG) dMean;
                }
                break;
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = PDH_INVALID_ARGUMENT;
    } 
    return Status;
}

PDH_STATUS
APIENTRY
PdhiComputeRawCountStats(
    PPDHI_COUNTER    pCounter,
    DWORD            dwFormat,
    DWORD            dwFirstEntry,
    DWORD            dwNumEntries,
    PPDH_RAW_COUNTER lpRawValueArray,
    PPDH_STATISTICS  data
)
{
    PDH_STATUS           Status           = ERROR_SUCCESS;
    DOUBLE               dThisValue       = (double) 0.0;
    DOUBLE               dMin             = (double) +10E8;    // these are just "big" seed numbers
    DOUBLE               dMax             = (double) -10E8;    
    DOUBLE               dMean            = (double) 0.0;
    BOOLEAN              bFirstItem       = TRUE;
    DOUBLE               dScale;
    DWORD                dwItem;
    DWORD                dwValidItemCount = 0;
    DWORD                dwFirstValidItem = 0;
    DWORD                dwLastValidItem  = 0;
    DWORD                dwComputeFormat;
    PPDH_RAW_COUNTER     pNewCounter;
    PPDH_RAW_COUNTER     pOldCounter      = NULL;
    PDH_FMT_COUNTERVALUE fmtValue;
    DWORD                cStatusReturn;

    UNREFERENCED_PARAMETER(dwFirstEntry);
    __try {
        // initialize the user's data buffer
        data->dwFormat        = 0;
        data->count           = 0;
        data->min.CStatus     = PDH_CSTATUS_INVALID_DATA;
        data->min.largeValue  = 0;
        data->max.CStatus     = PDH_CSTATUS_INVALID_DATA;
        data->max.largeValue  = 0;
        data->mean.CStatus    = PDH_CSTATUS_INVALID_DATA;
        data->mean.largeValue = 0;

        // find first valid counter in array
        dwItem      = 0;
        pNewCounter = lpRawValueArray;
        while (dwItem < dwNumEntries) {
            // get value of this instance if next counter is valid
            if ((pNewCounter->CStatus == PDH_CSTATUS_VALID_DATA) ||
                            (pNewCounter->CStatus == PDH_CSTATUS_NEW_DATA)) {
                break;
            }
            else {
                pOldCounter = pNewCounter;
                pNewCounter ++;
                dwItem ++;
            }
        }
        
        // do calculations in Floating point format
        dwComputeFormat  = dwFormat;
        dwComputeFormat &= ~ PDHI_FMT_FILTER;
        dwComputeFormat |= PDH_FMT_DOUBLE | PDH_FMT_NOCAP100;
        if ((dwItem != dwNumEntries) && (dwNumEntries > 0)) {
            // start record found so continue
            dwFirstValidItem = dwItem;

            // step through the remaining entries
            while (dwItem < dwNumEntries) {
                // get value of this instance if next counter is valid
                if ((pNewCounter->CStatus == PDH_CSTATUS_VALID_DATA) ||
                                (pNewCounter->CStatus == PDH_CSTATUS_NEW_DATA)) {
                    dwLastValidItem = dwItem;
                    cStatusReturn = PdhiComputeFormattedValue(
                                    pCounter->CalcFunc,
                                    pCounter->plCounterInfo.dwCounterType,
                                    pCounter->lScale,
                                    dwComputeFormat,
                                    pNewCounter,
                                    pOldCounter,
                                    & pCounter->TimeBase,
                                    0L,
                                    & fmtValue);
                    if (cStatusReturn == ERROR_SUCCESS) {
                        dThisValue = fmtValue.doubleValue;
                        if (bFirstItem) {
                            dMin = dMax = dThisValue;
                            bFirstItem = FALSE;
                        }
                        else {
                            if (dThisValue > dMax) dMax = dThisValue;
                            if (dThisValue < dMin) dMin = dThisValue;
                        }
                        dMean += dThisValue;
                        dwValidItemCount ++;
                    }
                }
                pOldCounter = pNewCounter;
                pNewCounter ++;
                dwItem ++;
            }
            // compute average
            if (dwValidItemCount > 0) {
                dMean /= (double) dwValidItemCount;

                if (!(dwFormat & PDH_FMT_NOSCALE)) {
                    //now scale
                    dScale  = pow (10.0, (double)pCounter->lScale);
                    dMean  *= dScale;
                    dMin   *= dScale;
                    dMax   *= dScale;
                }
                cStatusReturn = PDH_CSTATUS_VALID_DATA;
            }
            else {
                dMean         = 0.0;
                dMax          = 0.0;
                dMin          = 0.0;
                cStatusReturn = PDH_CSTATUS_INVALID_DATA;
            }
        }
        else {
            // array does not contain a valid counter so exit
            dMean         = 0.0;
            dMax          = 0.0;
            dMin          = 0.0;
            cStatusReturn = PDH_CSTATUS_INVALID_DATA;
        }

        // update user's buffer with new data
        data->dwFormat     = dwFormat;
        data->count        = dwValidItemCount;
        data->min.CStatus  = cStatusReturn;
        data->max.CStatus  = cStatusReturn;
        data->mean.CStatus = cStatusReturn;
        switch ((dwFormat & PDHI_FMT_FILTER)) {
        case PDH_FMT_LONG:
            if (dMin > (DOUBLE) MAXLONG) {
                data->min.longValue = MAXLONG;
                data->min.CStatus   = PDH_CSTATUS_INVALID_DATA;
            }
            else {
                data->min.longValue = (long) dMin;
            }
            if (dMax > (DOUBLE) MAXLONG) {
                data->max.longValue = MAXLONG;
                data->max.CStatus   = PDH_CSTATUS_INVALID_DATA;
            }
            else {
                data->max.longValue = (long) dMax;
            }
            if (dMean > (DOUBLE) MAXLONG) {
                data->mean.longValue = MAXLONG;
                data->mean.CStatus   = PDH_CSTATUS_INVALID_DATA;
            }
            else {
                data->mean.longValue = (long) dMean;
            }
            break;

        case PDH_FMT_DOUBLE:
            data->min.doubleValue  = dMin;
            data->max.doubleValue  = dMax;
            data->mean.doubleValue = dMean;
            break;

        case PDH_FMT_LARGE:
        default:
            if (dMin > (DOUBLE) MAXLONGLONG) {
                data->min.largeValue = MAXLONGLONG;
                data->min.CStatus    = PDH_CSTATUS_INVALID_DATA;
            }
            else {
                data->min.largeValue = (LONGLONG) dMin;
            }
            if (dMax > (DOUBLE) MAXLONGLONG) {
                data->max.largeValue = MAXLONGLONG;
                data->max.CStatus    = PDH_CSTATUS_INVALID_DATA;
            }
            else {
                data->max.largeValue = (LONGLONG) dMax;
            }
            if (dMean > (DOUBLE) MAXLONGLONG) {
                data->mean.largeValue = MAXLONGLONG;
                data->mean.CStatus    = PDH_CSTATUS_INVALID_DATA;
            }
            else {
                data->mean.largeValue = (LONGLONG) dMean;
            }
            break;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = PDH_INVALID_ARGUMENT;
    } 
    return Status;
}

PDH_STATUS
APIENTRY
PdhiComputeNoDataStats(
    PPDHI_COUNTER    pCounter,
    DWORD            dwFormat,
    DWORD            dwFirstEntry,
    DWORD            dwNumEntries,
    PPDH_RAW_COUNTER lpRawValueArray,
    PPDH_STATISTICS  data
)
{
    PDH_STATUS Status = ERROR_SUCCESS;

    UNREFERENCED_PARAMETER(pCounter);
    UNREFERENCED_PARAMETER(dwFirstEntry);
    UNREFERENCED_PARAMETER(dwNumEntries);
    UNREFERENCED_PARAMETER(lpRawValueArray);
    __try {
        data->dwFormat     = dwFormat;
        data->count        = 0;
        data->min.CStatus  = PDH_CSTATUS_INVALID_DATA;
        data->max.CStatus  = PDH_CSTATUS_INVALID_DATA;
        data->mean.CStatus = PDH_CSTATUS_INVALID_DATA;

        switch ((dwFormat & PDHI_FMT_FILTER)) {
        case PDH_FMT_LONG:
            data->min.doubleValue = 0;
            data->max.longValue   = 0;
            data->mean.longValue  = 0;
            break;

        case PDH_FMT_DOUBLE:
            data->min.doubleValue  = (double) 0;
            data->max.doubleValue  = (double) 0;
            data->mean.doubleValue = (double) 0.0;
            break;

        case PDH_FMT_LARGE:
        default:
            data->min.largeValue  = 0;
            data->max.largeValue  = 0;
            data->mean.largeValue = 0;
            break;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = PDH_INVALID_ARGUMENT;
    } 
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhdll\cutils.c ===
/*++
Copyright (C) 1995-1999 Microsoft Corporation

Module Name:
    cutils.c

Abstract:
    Counter management utility functions
--*/

#include <windows.h>
#include <math.h>
#include "strsafe.h"
#include <pdh.h>
#include "pdhitype.h"
#include "pdhidef.h"
#include "perftype.h"
#include "perfdata.h"
#include "pdhmsg.h"
#include "strings.h"

BOOL
IsValidCounter(
    HCOUNTER  hCounter
)
/*++
Routine Description:
    examines the counter handle to verify it is a valid counter. For now
        the test amounts to:
            the Handle is NOT NULL
            the memory is accessible (i.e. it doesn't AV)
            the signature array is valid
            the size field is correct

        if any tests fail, the handle is presumed to be invalid

Arguments:
    IN  HCOUNTER  hCounter
        the handle of the counter to test

Return Value:
    TRUE    the handle passes all the tests
    FALSE   one of the test's failed and the handle is not a valid counter
--*/
{
    BOOL          bReturn = FALSE;    // assume it's not a valid query
    PPDHI_COUNTER pCounter;
    LONG          lStatus = ERROR_SUCCESS;

    __try {
        if (hCounter != NULL) {
            // see if a valid signature
            pCounter = (PPDHI_COUNTER) hCounter;
            if ((* (DWORD *) & pCounter->signature[0] == SigCounter) &&
                            (pCounter->dwLength == sizeof (PDHI_COUNTER))) {
                bReturn = TRUE;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        // something failed miserably so we can assume this is invalid
        lStatus = GetExceptionCode();
    }
    return bReturn;
}

BOOL
InitCounter(
    PPDHI_COUNTER pCounter
)
/*++
Routine Description:
    Initialized the counter data structure by:
        Allocating the memory block to contain the counter structure
            and all the associated data fields. If this allocation
            is successful, then the fields are initialized by
            verifying the counter is valid.

Arguments:
    IN      PPDHI_COUNTER pCounter
        pointer of the counter to initialize using the system data

Return Value:
    TRUE if the counter was successfully initialized
    FALSE if a problem was encountered

    In either case, the CStatus field of the structure is updated to
    indicate the status of the operation.
--*/
{
    PPERF_MACHINE   pMachine          = NULL;
    DWORD           dwBufferSize      = MEDIUM_BUFFER_SIZE;
    DWORD           dwOldSize;
    BOOL            bInstances        = FALSE;
    LPVOID          pLocalCounterPath = NULL;
    BOOL            bReturn           = TRUE;
    LONG            lOffset;

    // reset the last error value
    pCounter->ThisValue.CStatus = ERROR_SUCCESS;
    SetLastError(ERROR_SUCCESS);

    if (pCounter->szFullName != NULL) {
        // allocate counter path buffer
        if (pCounter->pCounterPath != NULL) {
            __try {
                G_FREE(pCounter->pCounterPath);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                // no need to do anything
            }
            pCounter->pCounterPath = NULL;
        }
        pLocalCounterPath = G_ALLOC(dwBufferSize);
        if (pLocalCounterPath == NULL) {
            // could not allocate string buffer
            pCounter->ThisValue.CStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            bReturn = FALSE;
        }
        else {
            dwOldSize = dwBufferSize;
            if (ParseFullPathNameW(pCounter->szFullName, & dwBufferSize, pLocalCounterPath, FALSE)) {
                // resize to only the space required
                if (dwOldSize < dwBufferSize) {
                    pCounter->pCounterPath = G_REALLOC(pLocalCounterPath, dwBufferSize);
                }
                else {
                    pCounter->pCounterPath = pLocalCounterPath;
                }

                if (pCounter->pCounterPath != NULL) {
                    if (pLocalCounterPath != pCounter->pCounterPath) { // ???
                        // the memory block moved so
                        // correct addresses inside structure
                        lOffset = (LONG) ((ULONG_PTR) pCounter->pCounterPath - (ULONG_PTR) pLocalCounterPath);
                        if (lOffset != 0 && pCounter->pCounterPath->szMachineName != NULL) {
                            pCounter->pCounterPath->szMachineName = (LPWSTR) (
                                (LPBYTE)pCounter->pCounterPath->szMachineName + lOffset);
                        }
                        if (lOffset != 0 && pCounter->pCounterPath->szObjectName != NULL) {
                            pCounter->pCounterPath->szObjectName = (LPWSTR) (
                                (LPBYTE)pCounter->pCounterPath->szObjectName + lOffset);
                        }
                        if (lOffset != 0 && pCounter->pCounterPath->szInstanceName != NULL) {
                            pCounter->pCounterPath->szInstanceName = (LPWSTR) (
                                (LPBYTE)pCounter->pCounterPath->szInstanceName + lOffset);
                        }
                        if (lOffset != 0 && pCounter->pCounterPath->szParentName != NULL) {
                            pCounter->pCounterPath->szParentName = (LPWSTR) (
                                (LPBYTE)pCounter->pCounterPath->szParentName + lOffset);
                        }
                        if (lOffset != 0 && pCounter->pCounterPath->szCounterName != NULL) {
                            pCounter->pCounterPath->szCounterName = (LPWSTR) (
                                (LPBYTE)pCounter->pCounterPath->szCounterName + lOffset);
                        }
                    }

                    if (pCounter->pOwner->hLog == NULL) {
                        // validate realtime counter
                        // try to connect to machine and get machine pointer
                        pMachine = GetMachine(pCounter->pCounterPath->szMachineName, 0, PDH_GM_UPDATE_PERFNAME_ONLY);
                        if (pMachine == NULL) {
                            // unable to find machine
                            pCounter->ThisValue.CStatus = PDH_CSTATUS_NO_MACHINE;
                            pCounter->dwFlags          |= PDHIC_COUNTER_INVALID;
                            bReturn                     = FALSE;
                        }
                        else if (pMachine->szPerfStrings == NULL || pMachine->typePerfStrings == NULL) {
                            // a machine entry was found, but the machine is not available
                            pMachine->dwRefCount --;
                            RELEASE_MUTEX(pMachine->hMutex);
                            pCounter->ThisValue.CStatus = pMachine->dwStatus;
                            if (pMachine->dwStatus == PDH_ACCESS_DENIED) {
                                // then don't add this counter since the machine
                                // won't let us in
                                bReturn = FALSE;
                            }
                        }
                        else {
                            // init raw counter value
                            ZeroMemory(& pCounter->ThisValue, sizeof(PDH_RAW_COUNTER));
                            ZeroMemory(& pCounter->LastValue, sizeof(PDH_RAW_COUNTER));

                            // look up object name
                            pCounter->plCounterInfo.dwObjectId = GetObjectId(pMachine,
                                                                             pCounter->pCounterPath->szObjectName,
                                                                             & bInstances);
                            if (pCounter->plCounterInfo.dwObjectId == (DWORD) -1) {
                                // unable to lookup object on this machine
                                pCounter->plCounterInfo.dwObjectId   = (DWORD) -1;
                                pCounter->ThisValue.CStatus          = PDH_CSTATUS_NO_OBJECT;
                                pCounter->dwFlags                   |= PDHIC_COUNTER_INVALID;
                                bReturn                              = FALSE;
                            }
                            else {
                                // update instanceName look up instances if necessary
                                if (bInstances) {
                                    if (pCounter->pCounterPath->szInstanceName != NULL) {
                                        if (* pCounter->pCounterPath->szInstanceName != SPLAT_L) {
                                            if (! GetInstanceByNameMatch(pMachine, pCounter)) {
                                                // unable to lookup instance
                                                pCounter->ThisValue.CStatus = PDH_CSTATUS_NO_INSTANCE;
                                                // keep the counter since the instance may return
                                            }
                                        }
                                        else {
                                            // this is a wild card query so don't look
                                            // for any instances yet
                                            pCounter->dwFlags |= PDHIC_MULTI_INSTANCE;
                                        }
                                    }
                                    else {
                                        // the path for this object should include an instance name
                                        // and doesn't so return an error
                                        // this is an unrecoverable error so indicate that it's finished
                                        //
                                        pCounter->ThisValue.CStatus = PDH_CSTATUS_BAD_COUNTERNAME;
                                        pCounter->dwFlags          &= ~PDHIC_COUNTER_NOT_INIT;
                                        pCounter->dwFlags          |= PDHIC_COUNTER_INVALID;
                                        bReturn                     = FALSE;
                                    }
                                }
                                pCounter->dwFlags &= ~PDHIC_COUNTER_NOT_INIT;
                            }
                            pMachine->dwRefCount --;
                            RELEASE_MUTEX(pMachine->hMutex);

                            if (bReturn) {
                                // look up counter
                                if (*pCounter->pCounterPath->szCounterName != SPLAT_L) {
                                    pCounter->plCounterInfo.dwCounterId = GetCounterId(
                                                            pMachine,
                                                            pCounter->plCounterInfo.dwObjectId,
                                                            pCounter->pCounterPath->szCounterName);
                                    if (pCounter->plCounterInfo.dwCounterId != (DWORD) -1) {
                                        // load and initialize remaining counter values
                                        if (AddMachineToQueryLists(pMachine, pCounter)) {
                                            if (InitPerflibCounterInfo(pCounter)) {
                                                // assign the appropriate calculation function
                                                bReturn =  AssignCalcFunction(
                                                                pCounter->plCounterInfo.dwCounterType,
                                                                & pCounter->CalcFunc,
                                                                & pCounter->StatFunc);
                                                TRACE((PDH_DBG_TRACE_INFO),
                                                      (__LINE__,
                                                       PDH_CUTILS,
                                                       ARG_DEF(ARG_TYPE_WSTR, 1),
                                                       ERROR_SUCCESS,
                                                       TRACE_WSTR(pCounter->szFullName),
                                                       TRACE_DWORD(pCounter->plCounterInfo.dwCounterType),
                                                       NULL));
                                                if (! bReturn) {
                                                    pCounter->dwFlags |= PDHIC_COUNTER_INVALID;
                                                }
                                            }
                                            else {
                                                // unable to initialize this counter
                                                pCounter->dwFlags |= PDHIC_COUNTER_INVALID;
                                                bReturn            = FALSE;
                                            }
                                        }
                                        else {
                                            // machine could not be added, error is already
                                            // in "LastError" so free string buffer and leave
                                            pCounter->dwFlags |= PDHIC_COUNTER_INVALID;
                                            bReturn            = FALSE;
                                        }
                                    }
                                    else {
                                        // unable to lookup counter
                                        pCounter->ThisValue.CStatus = PDH_CSTATUS_NO_COUNTER;
                                        pCounter->dwFlags          |= PDHIC_COUNTER_INVALID;
                                        bReturn                     = FALSE;
                                    }
                                }
                                else {
                                    if (AddMachineToQueryLists(pMachine, pCounter)) {
                                        pCounter->dwFlags    |= PDHIC_COUNTER_OBJECT;
                                        pCounter->pThisObject = NULL;
                                        pCounter->pLastObject = NULL;
                                    }
                                    else {
                                        // machine could not be added, error is already
                                        // in "LastError" so free string buffer and leave
                                        pCounter->dwFlags |= PDHIC_COUNTER_INVALID;
                                        bReturn            = FALSE;
                                    }
                                }
                            }
                        }
                    }
                    else {
                        PDH_STATUS pdhStatus;
                        // validate counter from log file
                        pdhStatus = PdhiGetLogCounterInfo(pCounter->pOwner->hLog, pCounter);
                        if (pdhStatus == ERROR_SUCCESS) {
                            // finish initializing the counter
                            //
                            pCounter->ThisValue.TimeStamp.dwLowDateTime  = 0;
                            pCounter->ThisValue.TimeStamp.dwHighDateTime = 0;
                            pCounter->ThisValue.MultiCount               = 1;
                            pCounter->ThisValue.FirstValue               = 0;
                            pCounter->ThisValue.SecondValue              = 0;
                            //
                            pCounter->LastValue.TimeStamp.dwLowDateTime  = 0;
                            pCounter->LastValue.TimeStamp.dwHighDateTime = 0;
                            pCounter->LastValue.MultiCount               = 1;
                            pCounter->LastValue.FirstValue               = 0;
                            pCounter->LastValue.SecondValue              = 0;
                            //
                            //  lastly update status
                            //
                            pCounter->ThisValue.CStatus                  = PDH_CSTATUS_VALID_DATA;
                            pCounter->LastValue.CStatus                  = PDH_CSTATUS_VALID_DATA;
                            // assign the appropriate calculation function
                            bReturn = AssignCalcFunction(pCounter->plCounterInfo.dwCounterType,
                                                         & pCounter->CalcFunc,
                                                         & pCounter->StatFunc);
                            TRACE((PDH_DBG_TRACE_INFO),
                                  (__LINE__,
                                   PDH_CUTILS,
                                   ARG_DEF(ARG_TYPE_WSTR, 1),
                                   ERROR_SUCCESS,
                                   TRACE_WSTR(pCounter->szFullName),
                                   TRACE_DWORD(pCounter->plCounterInfo.dwCounterType),
                                   NULL));
                        }
                        else {
                            // set the counter status to the error returned
                            pCounter->ThisValue.CStatus = pdhStatus;
                            pCounter->dwFlags          |= PDHIC_COUNTER_INVALID;
                            bReturn                     = FALSE;
                        }
                        pCounter->dwFlags &= ~PDHIC_COUNTER_NOT_INIT;
                    }
                    if (! bReturn) {
                        //free string buffer
                        G_FREE(pCounter->pCounterPath);
                        pCounter->pCounterPath = NULL;
                    }
                }
                else {
                    G_FREE(pLocalCounterPath);
                    // unable to realloc
                    pCounter->ThisValue.CStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    bReturn                     = FALSE;
                }
            }
            else {
                // unable to parse counter name
                pCounter->ThisValue.CStatus  = PDH_CSTATUS_BAD_COUNTERNAME;
                pCounter->dwFlags           &= ~PDHIC_COUNTER_NOT_INIT;
                pCounter->dwFlags           |= PDHIC_COUNTER_INVALID;
                G_FREE(pLocalCounterPath);
                bReturn                      = FALSE;
            }
        }
    }
    else {
        // no counter name
        pCounter->ThisValue.CStatus  = PDH_CSTATUS_NO_COUNTERNAME;
        pCounter->dwFlags           &= ~PDHIC_COUNTER_NOT_INIT;
        pCounter->dwFlags           |= PDHIC_COUNTER_INVALID;
        bReturn                      = FALSE;
    }

    if (! bReturn && pCounter->ThisValue.CStatus != ERROR_SUCCESS) {
        SetLastError(pCounter->ThisValue.CStatus);
    }

    return bReturn;
}

BOOL
ParseInstanceName(
    LPCWSTR szInstanceString,
    LPWSTR  szInstanceName,
    LPWSTR  szParentName,
    DWORD   dwName,
    LPDWORD lpIndex
)
/*
    parses the instance name formatted as follows

        [parent/]instance[#index]

    parent is optional and if present, is delimited by a forward slash
    index is optional and if present, is delimited by a colon

    parent and instance may be any legal file name character except a
    delimeter character "/#\()" Index must be a string composed of
    decimal digit characters (0-9), less than 10 characters in length, and
    equate to a value between 0 and 2**32-1 (inclusive).

    This function assumes that the instance name and parent name buffers
    are of sufficient size.

    NOTE: szInstanceName and szInstanceString can be the same buffer
*/
{
    LPWSTR  szSrcChar     = (LPWSTR) szInstanceString;
    LPWSTR  szDestChar    = (LPWSTR) szInstanceName;
    LPWSTR  szLastPound   = NULL;
    BOOL    bReturn       = FALSE;
    DWORD   dwIndex       = 0;
    DWORD   dwInstCount   = 0;

    szDestChar = (LPWSTR) szInstanceName;
    szSrcChar  = (LPWSTR) szInstanceString;

    __try {
        do {
            * szDestChar = * szSrcChar;
            if (* szDestChar == POUNDSIGN_L) szLastPound = szDestChar;
            szDestChar  ++;
            szSrcChar   ++;
            dwInstCount ++;
        }
        while (dwInstCount <= dwName && (* szSrcChar != L'\0') && (* szSrcChar != SLASH_L));

        if (dwInstCount <= dwName) {
            // see if that was really the parent or not
            if (* szSrcChar == SLASH_L) {
                // terminate destination after test in case they are the same buffer
                * szDestChar = L'\0';
                szSrcChar ++;    // and move source pointer past delimter
                // it was the parent name so copy it to the parent
                StringCchCopyW(szParentName, dwName, szInstanceName);
                // and copy the rest of the string after the "/" to the
                //  instance name field
                szDestChar  = szInstanceName;
                dwInstCount = 0;
                do {
                    * szDestChar = * szSrcChar;
                    if (* szDestChar == POUNDSIGN_L) szLastPound = szDestChar;
                    szDestChar  ++;
                    szSrcChar   ++;
                    dwInstCount ++;
                }
                while (dwInstCount <= dwName && (* szSrcChar != L'\0'));
            }
            else {
                // that was the only element so load an empty string for the parent
                * szParentName = L'\0';
            }
            if (dwInstCount <= dwName) {
                //  if szLastPound is NOT null and is inside the instance string, then
                //  see if it points to a decimal number. If it does, then it's an index
                //  otherwise it's part of the instance name
                * szDestChar = L'\0';    // terminate the destination string
                dwIndex      = 0;
                if (szLastPound != NULL) {
                    if (szLastPound > szInstanceName) {
                        // there's a pound sign in the instance name
                        // see if it's preceded by a non-space char
                        szLastPound --;
                        if (* szLastPound > SPACE_L) {
                            szLastPound ++;
                            // see if it's followed by a digit
                            szLastPound ++;
                            if ((* szLastPound >= L'0') && (*szLastPound <= L'9')) {
                                dwIndex       = wcstoul(szLastPound, NULL, 10);
                                szLastPound  --;
                                * szLastPound = L'\0';   // terminate the name at the pound sign
                            }
                        }
                    }
                }
                * lpIndex = dwIndex;
                bReturn = TRUE;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        // unable to move strings
        bReturn = FALSE;
    }
    return bReturn;
}

BOOL
ParseFullPathNameW(
    LPCWSTR             szFullCounterPath,
    PDWORD              pdwBufferSize,
    PPDHI_COUNTER_PATH  pCounter,
    BOOL                bWbemSyntax
)
/*
    interprets counter path string as either a

        \\machine\object(instance)\counter

    or if bWbemSyntax == TRUE

        \\machine\namespace:ClassName(InstanceName)\CounterName

    and returns the component in the counter path structure

    \\machine or \\machine\namespace may be omitted on the local machine
    (instance) may be omitted on counters with no instance structures
    if object or counter is missing, then FALSE is returned, otherwise
    TRUE is returned if the parsing was successful
*/
{
    LPWSTR szWorkMachine        = NULL;
    LPWSTR szWorkObject         = NULL;
    LPWSTR szWorkInstance       = NULL;
    LPWSTR szWorkParent         = NULL;
    LPWSTR szWorkCounter        = NULL;
    DWORD  dwBufferSize         = lstrlenW(szFullCounterPath) + 1;
    BOOL   bReturn              = FALSE;
    LPWSTR szSrcChar, szDestChar;
    DWORD  dwBufferLength       = 0;
    DWORD  dwWorkMachineLength  = 0;
    DWORD  dwWorkObjectLength   = 0;
    DWORD  dwWorkInstanceLength = 0;
    DWORD  dwWorkParentLength   = 0;
    DWORD  dwWorkCounterLength  = 0;
    DWORD  dwWorkIndex          = 0;
    DWORD  dwParenDepth         = 0;
    WCHAR  wDelimiter           = 0;
    LPWSTR pszBsDelim[2]        = {0,0};
    LPWSTR szThisChar;
    DWORD  dwParenCount         = 0;
    LPWSTR szLastParen          = NULL;

    if (dwBufferSize < MAX_PATH) dwBufferSize = MAX_PATH;

    szWorkMachine  = G_ALLOC(dwBufferSize * sizeof(WCHAR));
    szWorkObject   = G_ALLOC(dwBufferSize * sizeof(WCHAR));
    szWorkInstance = G_ALLOC(dwBufferSize * sizeof(WCHAR));
    szWorkParent   = G_ALLOC(dwBufferSize * sizeof(WCHAR));
    szWorkCounter  = G_ALLOC(dwBufferSize * sizeof(WCHAR));

    if (szWorkMachine != NULL && szWorkObject   != NULL && szWorkInstance != NULL
                              && szWorkParent   != NULL && szWorkCounter  != NULL) {
        // get machine name from counter path
        szSrcChar = (LPWSTR) szFullCounterPath;

        //define the delimiter char between the machine and the object
        // or in WBEM parlance, the server & namespace and the Class name
        if (bWbemSyntax) {
            wDelimiter = COLON_L;
        }
        else {
            wDelimiter = BACKSLASH_L;
            // if this is  backslash delimited string, then find the
            // backslash the denotes the end of the machine and start of the
            // object by walking down the string and finding the 2nd to the last
            // backslash.
            // this is necessary since a WBEM machine\namespace path can have
            // multiple backslashes in it while there will ALWAYS be two at
            // the end, one at the start of the object name and one at the start
            // of the counter name
            dwParenDepth = 0;
            for (szThisChar = szSrcChar; * szThisChar != L'\0'; szThisChar++) {
                if (* szThisChar == LEFTPAREN_L) {
                    if (dwParenDepth == 0) dwParenCount ++;
                    dwParenDepth ++;
                }
                else if (* szThisChar == RIGHTPAREN_L) {
                    if (dwParenDepth > 0) dwParenDepth --;
                }
                else {
                    if (dwParenDepth == 0) {
                       // ignore delimiters inside parenthesis
                       if (* szThisChar == wDelimiter) {
                           pszBsDelim[0] = pszBsDelim[1];
                           pszBsDelim[1] = szThisChar;
                       }
                       // ignore it and go to the next character
                    }
                }
            }
            if ((dwParenCount > 0) && (pszBsDelim[0] != NULL) && (pszBsDelim[1] != NULL)) {
                dwParenDepth = 0;
                for (szThisChar = pszBsDelim[0]; ((* szThisChar != L'\0') && (szThisChar < pszBsDelim[1])); szThisChar ++) {
                    if (* szThisChar == LEFTPAREN_L) {
                        if (dwParenDepth == 0) {
                            // see if the preceeding char is whitespace
                            -- szThisChar;
                            if (* szThisChar > SPACE_L) {
                                // then this could be an instance delim
                                szLastParen = ++ szThisChar;
                            }
                            else {
                               // else it's probably part of the instance name
                               ++ szThisChar;
                            }
                        }
                        dwParenDepth ++;
                    }
                    else if (* szThisChar == RIGHTPAREN_L) {
                        if (dwParenDepth > 0) dwParenDepth --;
                    }
                }
            }
        }

        // see if this is really a machine name by looking for leading "\\"
        if ((szSrcChar[0] == BACKSLASH_L) && (szSrcChar[1] == BACKSLASH_L)) {
            szDestChar          = szWorkMachine;
            * szDestChar ++     = * szSrcChar ++;
            * szDestChar ++     = * szSrcChar ++;
            dwWorkMachineLength = 2;
            // must be a machine name so find the object delimiter and zero terminate
            // it there
            while (* szSrcChar != L'\0') {
                if (pszBsDelim[0] != NULL) {
                    // then go to this pointer
                    if (szSrcChar == pszBsDelim[0]) break;
                }
                else {
                    // go to the next delimiter
                    if (* szSrcChar != wDelimiter) break;
                }
                * szDestChar ++ = * szSrcChar ++;
                dwWorkMachineLength ++;
            }
            if (* szSrcChar == L'\0') {
                // no other required fields
                goto Cleanup;
            }
            else {
                // null terminate and continue
                * szDestChar ++ = L'\0';
            }
        }
        else {
            // no machine name, so they must have skipped that field
            // which is OK. We'll insert the local machine name here
            StringCchCopyW(szWorkMachine, dwBufferSize, szStaticLocalMachineName);
            dwWorkMachineLength = lstrlenW(szWorkMachine);
        }
        // szSrcChar should be pointing to the backslash preceeding the
        // object name now.
        if (szSrcChar[0] == wDelimiter) {
            szSrcChar ++;    // to move past backslash
            szDestChar = szWorkObject;
            // copy until:
            //  a) the end of the source string is reached
            //  b) the instance delimiter is found "("
            //  c) the counter delimiter is found "\"
            //  d) a non-printable, non-space char is found
            while ((* szSrcChar != L'\0') && (szSrcChar != szLastParen)
                                          && (* szSrcChar != BACKSLASH_L) && (* szSrcChar >= SPACE_L)) {
                dwWorkObjectLength ++;
                * szDestChar ++ = * szSrcChar ++;
            }
            // see why it ended:
            if (* szSrcChar < SPACE_L) {
                // ran     of source string
                goto Cleanup;
            }
            else if (szSrcChar == szLastParen) {
                dwParenDepth = 1;
                // there's an instance so copy that to the instance field
                * szDestChar = L'\0'; // terminate destination string
                szDestChar   = szWorkInstance;
                // skip past open paren
                ++ szSrcChar;
                // copy until:
                //  a) the end of the source string is reached
                //  b) the instance delimiter is found "("
                while ((* szSrcChar != L'\0') && (dwParenDepth > 0)) {
                    if (* szSrcChar == RIGHTPAREN_L) {
                        dwParenDepth --;
                    }
                    else if (* szSrcChar == LEFTPAREN_L) {
                        dwParenDepth ++;
                    }
                    if (dwParenDepth > 0) {
                        // copy all parenthesis except the last one
                        dwWorkInstanceLength ++;
                        * szDestChar ++ = * szSrcChar ++;
                    }
                }
                // see why it ended:
                if (* szSrcChar == L'\0') {
                    // ran     of source string
                    goto Cleanup;
                }
                else {
                    // move source to object delimiter
                    if (* ++ szSrcChar != BACKSLASH_L) {
                        // bad format
                        goto Cleanup;
                    }
                    else {
                        * szDestChar = L'\0';
                        // check instance string for a parent
                        if (ParseInstanceName(
                                szWorkInstance, szWorkInstance, szWorkParent, dwBufferSize, & dwWorkIndex)) {
                            dwWorkInstanceLength = lstrlenW(szWorkInstance);
                            dwWorkParentLength   = lstrlenW(szWorkParent);
                        }
                        else {
                            // instance string not formatted correctly
                            goto Cleanup;
                        }
                    }
                }
            }
            else {
                // terminate the destination string
                * szDestChar = L'\0';
            }
            // finally copy the counter name
            szSrcChar ++;    // to move past backslash
            szDestChar = szWorkCounter;
            // copy until:
            //  a) the end of the source string is reached
            while (* szSrcChar != L'\0') {
                dwWorkCounterLength ++;
                * szDestChar ++ = * szSrcChar ++;
            }
            * szDestChar = L'\0';
            // now to see if all this will fit in the users's buffer
            dwBufferLength = sizeof(PDHI_COUNTER_PATH) - sizeof(BYTE);
            dwBufferLength += DWORD_MULTIPLE((dwWorkMachineLength + 1) * sizeof(WCHAR));
            dwBufferLength += DWORD_MULTIPLE((dwWorkObjectLength + 1) * sizeof(WCHAR));
            if (dwWorkInstanceLength > 0) {
                dwBufferLength += DWORD_MULTIPLE((dwWorkInstanceLength + 1) * sizeof(WCHAR));
            }
            if (dwWorkParentLength > 0) {
                dwBufferLength += DWORD_MULTIPLE((dwWorkParentLength + 1) * sizeof(WCHAR));
            }
            dwBufferLength += DWORD_MULTIPLE((dwWorkCounterLength + 1) * sizeof(WCHAR));

            TRACE((PDH_DBG_TRACE_INFO),
                  (__LINE__,
                   PDH_CUTILS,
                   ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2)
                                             | ARG_DEF(ARG_TYPE_WSTR, 3)
                                             | ARG_DEF(ARG_TYPE_WSTR, 4)
                                             | ARG_DEF(ARG_TYPE_WSTR, 5)
                                             | ARG_DEF(ARG_TYPE_WSTR, 6),
                   ERROR_SUCCESS,
                   TRACE_WSTR(szFullCounterPath),
                   TRACE_WSTR(szWorkMachine),
                   TRACE_WSTR(szWorkObject),
                   TRACE_WSTR(szWorkCounter),
                   TRACE_WSTR(szWorkInstance),
                   TRACE_WSTR(szWorkParent),
                   TRACE_DWORD(dwWorkIndex),
                   TRACE_DWORD(dwBufferLength),
                   NULL));

            if (dwBufferLength < * pdwBufferSize) {
                // it looks like it'll fit so start filling things in
                szDestChar = (LPWSTR) & pCounter->pBuffer[0];

                if (dwWorkMachineLength != 0) {
                    pCounter->szMachineName = szDestChar;
                    StringCchCopyW(szDestChar, dwWorkMachineLength + 1, szWorkMachine);
                    szDestChar += dwWorkMachineLength + 1;
                    szDestChar  = ALIGN_ON_DWORD(szDestChar);
                }
                else {
                    pCounter->szMachineName = NULL;
                }
                pCounter->szObjectName = szDestChar;
                StringCchCopyW(szDestChar, dwWorkObjectLength + 1, szWorkObject);
                szDestChar += dwWorkObjectLength + 1;
                szDestChar  = ALIGN_ON_DWORD(szDestChar);

                if (dwWorkInstanceLength != 0) {
                    pCounter->szInstanceName = szDestChar;
                    StringCchCopyW(szDestChar, dwWorkInstanceLength + 1, szWorkInstance);
                    szDestChar += dwWorkInstanceLength + 1;
                    szDestChar  = ALIGN_ON_DWORD(szDestChar);
                }
                else {
                    pCounter->szInstanceName = NULL;
                }

                if (dwWorkParentLength != 0) {
                    pCounter->szParentName = szDestChar;
                    StringCchCopyW(szDestChar, dwWorkParentLength + 1, szWorkParent);
                    szDestChar += dwWorkParentLength + 1;
                    szDestChar  = ALIGN_ON_DWORD(szDestChar);
                }
                else {
                    pCounter->szParentName = NULL;
                }
                pCounter->dwIndex = dwWorkIndex;

                pCounter->szCounterName = szDestChar;
                StringCchCopyW(szDestChar, dwWorkCounterLength + 1, szWorkCounter);

                szDestChar += dwWorkCounterLength + 1;
                szDestChar  = ALIGN_ON_DWORD(szDestChar);

                * pdwBufferSize = dwBufferLength;
                bReturn = TRUE;
            }
            else {
                //insufficient buffer
            }
        }
        else {
            // no object found so return
        }
    }
    else {
        // incoming string is too long
    }

Cleanup:
    G_FREE(szWorkMachine);
    G_FREE(szWorkObject);
    G_FREE(szWorkInstance);
    G_FREE(szWorkParent);
    G_FREE(szWorkCounter);
    return bReturn;
}

BOOL
FreeCounter(
    PPDHI_COUNTER pThisCounter
)
{
    // NOTE:
    //  This function assumes the query containing
    //  this counter has already been locked by the calling
    //  function.

    PPDHI_COUNTER pPrevCounter;
    PPDHI_COUNTER pNextCounter;
    PPDHI_QUERY   pParentQuery;

    // define pointers
    pPrevCounter = pThisCounter->next.blink;
    pNextCounter = pThisCounter->next.flink;
    pParentQuery = pThisCounter->pOwner;

    // decrement machine reference counter if a machine has been assigned
    if (pThisCounter->pQMachine != NULL) {
        if (pThisCounter->pQMachine->pMachine != NULL) {
            if (--pThisCounter->pQMachine->pMachine->dwRefCount == 0) {
                // then this is the last counter so remove machine
    //            freeing the machine in this call causes all kinds of 
    //            multi-threading problems so we'll keep it around until
    //            the DLL unloads.
    //            FreeMachine (pThisCounter->pQMachine->pMachine, FALSE);
                pThisCounter->pQMachine->pMachine = NULL;
            }
            else {
                // the ref count is non-zero so leave the pointer alone
            }
        }
        else {
            // the pointer has already been cleared
        }
    }
    else {
        // there's no machine
    }

    // free allocated memory in the counter
    G_FREE(pThisCounter->pCounterPath);
    pThisCounter->pCounterPath = NULL;

    G_FREE(pThisCounter->szFullName);
    pThisCounter->szFullName = NULL;

    if (pParentQuery != NULL) {
        if (pParentQuery->hLog == NULL) {
            G_FREE(pThisCounter->pThisObject);
            pThisCounter->pThisObject = NULL;
            G_FREE(pThisCounter->pLastObject);
            pThisCounter->pLastObject = NULL;
            G_FREE(pThisCounter->pThisRawItemList);
            pThisCounter->pThisRawItemList = NULL;
            G_FREE(pThisCounter->pLastRawItemList);
            pThisCounter->pLastRawItemList = NULL;
        }
    }

    // check for WBEM items

    if ((pThisCounter->dwFlags & PDHIC_WBEM_COUNTER) && (pThisCounter->pOwner != NULL)) {
        PdhiCloseWbemCounter(pThisCounter);
    }

    // update pointers if they've been assigned
    if ((pPrevCounter != NULL) && (pNextCounter != NULL)) {
        if ((pPrevCounter != pThisCounter) && (pNextCounter != pThisCounter)) {
            // update query list pointers
            pPrevCounter->next.flink = pNextCounter;
            pNextCounter->next.blink = pPrevCounter;
        }
        else {
            // this is the only counter entry in the list
            // so the caller must deal with updating the head pointer
        }
    }
    // delete this counter
    G_FREE(pThisCounter);

    return TRUE;
}

BOOL
UpdateCounterValue(
    PPDHI_COUNTER    pCounter,
    PPERF_DATA_BLOCK pPerfData
)
{
    DWORD                LocalCStatus = 0;
    DWORD                LocalCType   = 0;
    LPVOID               pData        = NULL;
    PDWORD               pdwData;
    UNALIGNED LONGLONG * pllData;
    PPERF_OBJECT_TYPE    pPerfObject  = NULL;
    BOOL                 bReturn      = FALSE;

    pData = GetPerfCounterDataPtr(pPerfData,
                                  pCounter->pCounterPath,
                                  & pCounter->plCounterInfo,
                                  0,
                                  & pPerfObject,
                                  & LocalCStatus);
    pCounter->ThisValue.CStatus = LocalCStatus;
    if (IsSuccessSeverity(LocalCStatus)) {
        // assume success
        bReturn = TRUE;
        // load counter value based on counter type
        LocalCType = pCounter->plCounterInfo.dwCounterType;
        switch (LocalCType) {
        //
        // these counter types are loaded as:
        //      Numerator = Counter data from perf data block
        //      Denominator = Perf Time from perf data block
        //      (the time base is the PerfFreq)
        //
        case PERF_COUNTER_COUNTER:
        case PERF_COUNTER_QUEUELEN_TYPE:
        case PERF_SAMPLE_COUNTER:
            pCounter->ThisValue.FirstValue  = (LONGLONG) (* (DWORD *) pData);
            pCounter->ThisValue.SecondValue = pPerfData->PerfTime.QuadPart;
            break;

        case PERF_OBJ_TIME_TIMER:
            pCounter->ThisValue.FirstValue = (LONGLONG) (* (DWORD *) pData);
            pCounter->ThisValue.SecondValue = pPerfObject->PerfTime.QuadPart;
            break;

        case PERF_COUNTER_100NS_QUEUELEN_TYPE:
            pllData                         = (UNALIGNED LONGLONG *) pData;
            pCounter->ThisValue.FirstValue  = * pllData;
            pCounter->ThisValue.SecondValue = pPerfData->PerfTime100nSec.QuadPart;
            break;

        case PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
            pllData                         = (UNALIGNED LONGLONG *) pData;
            pCounter->ThisValue.FirstValue  = * pllData;
            pCounter->ThisValue.SecondValue = pPerfObject->PerfTime.QuadPart;
            break;

        case PERF_COUNTER_TIMER:
        case PERF_COUNTER_TIMER_INV:
        case PERF_COUNTER_BULK_COUNT:
        case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
            pllData                         = (UNALIGNED LONGLONG *) pData;
            pCounter->ThisValue.FirstValue  = * pllData;
            pCounter->ThisValue.SecondValue = pPerfData->PerfTime.QuadPart;
            if ((LocalCType & PERF_MULTI_COUNTER) == PERF_MULTI_COUNTER) {
                pCounter->ThisValue.MultiCount = (DWORD) * ++ pllData;
            }
            break;
        //
        //  this is a hack to make the PDH work like PERFMON for
        //  this counter type
        //
        case PERF_COUNTER_MULTI_TIMER:
        case PERF_COUNTER_MULTI_TIMER_INV:
            pllData                         = (UNALIGNED LONGLONG *) pData;
            pCounter->ThisValue.FirstValue  = * pllData;
            // begin hack code
            pCounter->ThisValue.FirstValue *=  (DWORD) pPerfData->PerfFreq.QuadPart;
            // end hack code
            pCounter->ThisValue.SecondValue = pPerfData->PerfTime.QuadPart;
            if ((LocalCType & PERF_MULTI_COUNTER) == PERF_MULTI_COUNTER) {
                pCounter->ThisValue.MultiCount = (DWORD) * ++ pllData;
            }
            break;
        //
        //  These counters do not use any time reference
        //
        case PERF_COUNTER_RAWCOUNT:
        case PERF_COUNTER_RAWCOUNT_HEX:
        case PERF_COUNTER_DELTA:
            pCounter->ThisValue.FirstValue  = (LONGLONG) (* (DWORD *) pData);
            pCounter->ThisValue.SecondValue = 0;
            break;

        case PERF_COUNTER_LARGE_RAWCOUNT:
        case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
        case PERF_COUNTER_LARGE_DELTA:
            pCounter->ThisValue.FirstValue  = * (LONGLONG *) pData;
            pCounter->ThisValue.SecondValue = 0;
            break;
        //
        //  These counters use the 100 Ns time base in thier calculation
        //
        case PERF_100NSEC_TIMER:
        case PERF_100NSEC_TIMER_INV:
        case PERF_100NSEC_MULTI_TIMER:
        case PERF_100NSEC_MULTI_TIMER_INV:
            pllData = (UNALIGNED LONGLONG *)pData;
            pCounter->ThisValue.FirstValue  = * pllData;
            pCounter->ThisValue.SecondValue = pPerfData->PerfTime100nSec.QuadPart;
            if ((LocalCType & PERF_MULTI_COUNTER) == PERF_MULTI_COUNTER) {
                ++ pllData;
                pCounter->ThisValue.MultiCount = * (DWORD *) pllData;
            }
            break;
        //
        //  These counters use two data points, the one pointed to by
        //  pData and the one immediately after
        //
        case PERF_SAMPLE_FRACTION:
        case PERF_RAW_FRACTION:
            pdwData                        = (DWORD *) pData;
            pCounter->ThisValue.FirstValue = (LONGLONG) (* pdwData);
            // find the pointer to the base value in the structure
            pData = GetPerfCounterDataPtr(pPerfData,
                                          pCounter->pCounterPath,
                                          & pCounter->plCounterInfo,
                                          GPCDP_GET_BASE_DATA,
                                          NULL,
                                          & LocalCStatus);
            if (IsSuccessSeverity(LocalCStatus)) {
                pdwData                         = (DWORD *) pData;
                pCounter->ThisValue.SecondValue = (LONGLONG) (* pdwData);
            }
            else {
                // unable to locate base value
                pCounter->ThisValue.SecondValue = 0;
                pCounter->ThisValue.CStatus     = LocalCStatus;
                bReturn = FALSE;
            }
            break;

        case PERF_LARGE_RAW_FRACTION:
            pllData                        = (UNALIGNED LONGLONG *) pData;
            pCounter->ThisValue.FirstValue = * pllData;
            pData = GetPerfCounterDataPtr(pPerfData,
                                          pCounter->pCounterPath,
                                          & pCounter->plCounterInfo,
                                          GPCDP_GET_BASE_DATA,
                                          NULL,
                                          & LocalCStatus);
            if (IsSuccessSeverity(LocalCStatus)) {
                pllData = (LONGLONG *) pData;
                pCounter->ThisValue.SecondValue = * pllData;
            }
            else {
                pCounter->ThisValue.SecondValue = 0;
                pCounter->ThisValue.CStatus     = LocalCStatus;
                bReturn = FALSE;
            }
            break;

        case PERF_PRECISION_SYSTEM_TIMER:
        case PERF_PRECISION_100NS_TIMER:
        case PERF_PRECISION_OBJECT_TIMER:
            pllData                        = (LONGLONG *) pData;
            pCounter->ThisValue.FirstValue = * pllData;
            // find the pointer to the base value in the structure
            pData = GetPerfCounterDataPtr(pPerfData,
                                          pCounter->pCounterPath,
                                          & pCounter->plCounterInfo,
                                          GPCDP_GET_BASE_DATA,
                                          NULL,
                                          & LocalCStatus);
            if (IsSuccessSeverity(LocalCStatus)) {
                pllData                         = (LONGLONG *) pData;
                pCounter->ThisValue.SecondValue = * pllData;
            }
            else {
                // unable to locate base value
                pCounter->ThisValue.SecondValue = 0;
                pCounter->ThisValue.CStatus     = LocalCStatus;
                bReturn = FALSE;
            }
            break;

        case PERF_AVERAGE_TIMER:
        case PERF_AVERAGE_BULK:
            // counter (numerator) is a LONGLONG, while the
            // denominator is just a DWORD
            pllData                        = (UNALIGNED LONGLONG *) pData;
            pCounter->ThisValue.FirstValue = * pllData;
            pData = GetPerfCounterDataPtr(pPerfData,
                                          pCounter->pCounterPath,
                                          & pCounter->plCounterInfo,
                                          GPCDP_GET_BASE_DATA,
                                          NULL,
                                          & LocalCStatus);
            if (IsSuccessSeverity(LocalCStatus)) {
                pdwData                         = (DWORD *) pData;
                pCounter->ThisValue.SecondValue = * pdwData;
            } else {
                // unable to locate base value
                pCounter->ThisValue.SecondValue = 0;
                pCounter->ThisValue.CStatus     = LocalCStatus;
                bReturn = FALSE;
            }
            break;
        //
        //  These counters are used as the part of another counter
        //  and as such should not be used, but in case they are
        //  they'll be handled here.
        //
        case PERF_SAMPLE_BASE:
        case PERF_AVERAGE_BASE:
        case PERF_COUNTER_MULTI_BASE:
        case PERF_RAW_BASE:
        case PERF_LARGE_RAW_BASE:
            pCounter->ThisValue.FirstValue  = 0;
            pCounter->ThisValue.SecondValue = 0;
            break;

        case PERF_ELAPSED_TIME:
            // this counter type needs the object perf data as well
            if (GetObjectPerfInfo(pPerfData,
                                  pCounter->plCounterInfo.dwObjectId,
                                  & pCounter->ThisValue.SecondValue,
                                  & pCounter->TimeBase)) {
                pllData                        = (UNALIGNED LONGLONG *) pData;
                pCounter->ThisValue.FirstValue = * pllData;
            }
            else {
                pCounter->ThisValue.FirstValue  = 0;
                pCounter->ThisValue.SecondValue = 0;
            }
            break;
        //
        //  These counters are not supported by this function (yet)
        //
        case PERF_COUNTER_TEXT:
        case PERF_COUNTER_NODATA:
        case PERF_COUNTER_HISTOGRAM_TYPE:
            pCounter->ThisValue.FirstValue  = 0;
            pCounter->ThisValue.SecondValue = 0;
            break;

        default:
            // an unidentified counter was returned so
            pCounter->ThisValue.FirstValue  = 0;
            pCounter->ThisValue.SecondValue = 0;
            bReturn                         = FALSE;
            break;
        }
    }
    else {
        // else this counter is not valid so this value == 0
        pCounter->ThisValue.FirstValue  = pCounter->LastValue.FirstValue;
        pCounter->ThisValue.SecondValue = pCounter->LastValue.SecondValue;
        pCounter->ThisValue.CStatus     = LocalCStatus;
        bReturn                         = FALSE;
    }
        
    return bReturn;
}

BOOL
UpdateRealTimeCounterValue(
    PPDHI_COUNTER pCounter
)
{
    BOOL     bResult      = FALSE;
    DWORD    LocalCStatus = 0;
    FILETIME GmtFileTime;

    // move current value to last value buffer
    pCounter->LastValue             = pCounter->ThisValue;
    // and clear the old value
    pCounter->ThisValue.MultiCount  = 1;
    pCounter->ThisValue.FirstValue  = 0;
    pCounter->ThisValue.SecondValue = 0;

    // don't process if the counter has not been initialized
    if (!(pCounter->dwFlags & PDHIC_COUNTER_UNUSABLE)) {
        // get the counter's machine status first. There's no point in
        // contuning if the machine is offline
        LocalCStatus = pCounter->pQMachine->lQueryStatus;
        if (IsSuccessSeverity(LocalCStatus) && pCounter->pQMachine->pPerfData != NULL) {
            // update timestamp
            SystemTimeToFileTime(& pCounter->pQMachine->pPerfData->SystemTime, & GmtFileTime);
            FileTimeToLocalFileTime(& GmtFileTime, & pCounter->ThisValue.TimeStamp);
            bResult = UpdateCounterValue(pCounter, pCounter->pQMachine->pPerfData);
        }
        else {
            // unable to read data from this counter's machine so use the
            // query's timestamp
            //
            pCounter->ThisValue.TimeStamp.dwLowDateTime  = LODWORD(pCounter->pQMachine->llQueryTime);
            pCounter->ThisValue.TimeStamp.dwHighDateTime = HIDWORD(pCounter->pQMachine->llQueryTime);
            // all other data fields remain un-changed
            pCounter->ThisValue.CStatus                  = LocalCStatus;   // save counter status
        }
    }
    else {
        if (pCounter->dwFlags & PDHIC_COUNTER_NOT_INIT) {
            // try to init it
            InitCounter (pCounter);
        }
    }
    return bResult;
}

BOOL
UpdateMultiInstanceCounterValue(
    PPDHI_COUNTER    pCounter,
    PPERF_DATA_BLOCK pPerfData,
    LONGLONG         TimeStamp
)
{
    PPERF_OBJECT_TYPE           pPerfObject         = NULL;
    PPERF_INSTANCE_DEFINITION   pPerfInstance       = NULL;
    PPERF_OBJECT_TYPE           pParentObject       = NULL;
    PPERF_INSTANCE_DEFINITION   pThisParentInstance = NULL;
    PPERF_COUNTER_DEFINITION    pNumPerfCounter     = NULL;
    PPERF_COUNTER_DEFINITION    pDenPerfCounter     = NULL;
    DWORD                       LocalCStatus        = 0;
    DWORD                       LocalCType          = 0;
    LPVOID                      pData               = NULL;
    PDWORD                      pdwData;
    UNALIGNED LONGLONG        * pllData;
    FILETIME                    GmtFileTime;
    DWORD                       dwSize;
    DWORD                       dwFinalSize;
    LONG                        nThisInstanceIndex;
    LONG                        nParentInstanceIndex;
    LPWSTR                      szNextNameString;
    DWORD                       dwStrSize;
    PPDHI_RAW_COUNTER_ITEM      pThisItem;
    BOOL                        bReturn  = FALSE;

    pPerfObject = GetObjectDefByTitleIndex(pPerfData, pCounter->plCounterInfo.dwObjectId);

    if (pPerfObject != NULL) {
        // this should be caught during the AddCounter operation
        //
        // allocate a new buffer for the current data
        // this should be large enough to handle the header,
        // all instances and thier name strings
        //
        dwSize    = sizeof(PDHI_RAW_COUNTER_ITEM_BLOCK) - sizeof(PDHI_RAW_COUNTER_ITEM);
        dwStrSize = 0;

        pPerfInstance = FirstInstance(pPerfObject);
        // make sure pointer is still within the same instance

        for (nThisInstanceIndex = 0;
                        pPerfInstance != NULL && nThisInstanceIndex < pPerfObject->NumInstances;
                        nThisInstanceIndex ++) {
            // this should only fail in dire cases
            if (pPerfInstance == NULL) break;
            // for this instance add the size of the data item
            dwSize += sizeof(PDHI_RAW_COUNTER_ITEM);
            // and the size of the name string
            dwSize    += pPerfInstance->NameLength + sizeof(WCHAR);
            dwStrSize += pPerfInstance->NameLength / sizeof(WCHAR) + 1;
            // to the required buffer size

            // if this instance has a parent, see how long it's string
            // is

            // first see if we've already got the pointer to the parent

            if (pPerfInstance->ParentObjectTitleIndex != 0) {
                // then include the parent instance name
                if (pParentObject == NULL) {
                    // get parent object
                    pParentObject = GetObjectDefByTitleIndex(pPerfData, pPerfInstance->ParentObjectTitleIndex);
                }
                else {
                    if (pParentObject->ObjectNameTitleIndex != pPerfInstance->ParentObjectTitleIndex) {
                        pParentObject = GetObjectDefByTitleIndex(pPerfData, pPerfInstance->ParentObjectTitleIndex);
                    }
                }
                if (pParentObject == NULL) break;

                // now go to the corresponding instance entry
                pThisParentInstance = FirstInstance(pParentObject);
                // make sure pointer is still within the same instance

                if (pThisParentInstance != NULL) {
                    if (pPerfInstance->ParentObjectInstance < (DWORD) pParentObject->NumInstances) {
                        for (nParentInstanceIndex = 0;
                                        (DWORD) nParentInstanceIndex != pPerfInstance->ParentObjectInstance;
                                        nParentInstanceIndex ++) {
                            pThisParentInstance = NextInstance(pParentObject, pThisParentInstance);                               
                            if (pThisParentInstance == NULL) break;
                        }

                        if (pThisParentInstance != NULL) {
                            // found it so add in it's string length
                            dwSize += pThisParentInstance->NameLength + sizeof(WCHAR);
                            dwStrSize += pThisParentInstance->NameLength / sizeof(WCHAR) + 1;
                        }
                    }
                    else {
                        // the index is not in the parent
                        pThisParentInstance = NULL;
                        // so don't change the size required field
                    }
                }
            }
            // round up to the next DWORD address
            dwSize = DWORD_MULTIPLE(dwSize);
            // and go to the next instance
            pPerfInstance = NextInstance(pPerfObject, pPerfInstance);
        }
        //
        //
        pCounter->pThisRawItemList = G_ALLOC(dwSize);
        if (pCounter->pThisRawItemList != NULL) {
            pCounter->pThisRawItemList->dwLength = dwSize;
            pNumPerfCounter = GetCounterDefByTitleIndex(pPerfObject, 0, pCounter->plCounterInfo.dwCounterId);

            // just in case we need it later
            pDenPerfCounter = pNumPerfCounter + 1;
            // fill in the counter data
            pCounter->pThisRawItemList->dwItemCount = pPerfObject->NumInstances;
            pCounter->pThisRawItemList->CStatus     = LocalCStatus;

            // update timestamp
            SystemTimeToFileTime(& pPerfData->SystemTime, & GmtFileTime);
            FileTimeToLocalFileTime(& GmtFileTime, & pCounter->pThisRawItemList->TimeStamp);
            pThisItem = & pCounter->pThisRawItemList->pItemArray[0];
            szNextNameString = (LPWSTR) & (pCounter->pThisRawItemList->pItemArray[pPerfObject->NumInstances]);
            pPerfInstance = FirstInstance(pPerfObject);
            if (pPerfInstance != NULL) {
                // make sure pointer is still within the same instance
                // for each instance log the raw data values for this counter
                for (nThisInstanceIndex = 0;
                        pPerfInstance != NULL && nThisInstanceIndex < pPerfObject->NumInstances;
                        nThisInstanceIndex ++) {
                    // make sure pointe is still within the same instance
                    // make a new instance entry

                    // get the name of this instance
                    pThisItem->szName = (DWORD) (((LPBYTE) szNextNameString) - ((LPBYTE) pCounter->pThisRawItemList));
                    if (dwStrSize == 0) {
                        SetLastError(ERROR_OUTOFMEMORY);
                        bReturn = FALSE;
                        break;
                    }
                    dwSize = GetFullInstanceNameStr(pPerfData, pPerfObject, pPerfInstance, szNextNameString, dwStrSize);
                    if (dwSize == 0) {
                        // unable to read instance name
                        // so make one up (and assert in DBG builds)
                        _ltow(nThisInstanceIndex, szNextNameString, 10);
                        dwSize = lstrlenW(szNextNameString);
                    }

                    if (dwSize + 1 > dwStrSize) {
                        SetLastError(ERROR_OUTOFMEMORY);
                        bReturn = FALSE;
                        break;
                    }
                    szNextNameString += dwSize + 1;
                    dwStrSize        -= (dwSize + 1);

                    // get the pointer to the counter data
                    pData = GetPerfCounterDataPtr(pPerfData,
                                                  pCounter->pCounterPath,
                                                  & pCounter->plCounterInfo,
                                                  0,
                                                  NULL,
                                                  & LocalCStatus);
                    if (pNumPerfCounter != NULL) {
                        pData = GetInstanceCounterDataPtr(pPerfObject, pPerfInstance, pNumPerfCounter);
                    }
                    if (pData == NULL) {
                        SetLastError(PDH_CSTATUS_NO_INSTANCE);
                        bReturn = FALSE;
                        break;
                    }
                    bReturn = TRUE; // assume success
                    // load counter value based on counter type
                    LocalCType = pCounter->plCounterInfo.dwCounterType;
                    switch (LocalCType) {
                    //
                    // these counter types are loaded as:
                    //      Numerator = Counter data from perf data block
                    //      Denominator = Perf Time from perf data block
                    //      (the time base is the PerfFreq)
                    //
                    case PERF_COUNTER_COUNTER:
                    case PERF_COUNTER_QUEUELEN_TYPE:
                    case PERF_SAMPLE_COUNTER:
                        pThisItem->FirstValue  = (LONGLONG) (* (DWORD *) pData);
                        pThisItem->SecondValue = pPerfData->PerfTime.QuadPart;
                        break;

                    case PERF_OBJ_TIME_TIMER:
                        pThisItem->FirstValue  = (LONGLONG) (* (DWORD *) pData);
                        pThisItem->SecondValue = pPerfObject->PerfTime.QuadPart;
                        break;

                    case PERF_COUNTER_100NS_QUEUELEN_TYPE:
                        pllData                = (UNALIGNED LONGLONG *) pData;
                        pThisItem->FirstValue  = * pllData;
                        pThisItem->SecondValue = pPerfData->PerfTime100nSec.QuadPart;
                        break;

                    case PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
                        pllData                = (UNALIGNED LONGLONG *) pData;
                        pThisItem->FirstValue  = * pllData;
                        pThisItem->SecondValue = pPerfObject->PerfTime.QuadPart;
                        break;

                    case PERF_COUNTER_TIMER:
                    case PERF_COUNTER_TIMER_INV:
                    case PERF_COUNTER_BULK_COUNT:
                    case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
                        pllData                = (UNALIGNED LONGLONG *) pData;
                        pThisItem->FirstValue  = * pllData;
                        pThisItem->SecondValue = pPerfData->PerfTime.QuadPart;
                        if ((LocalCType & PERF_MULTI_COUNTER) == PERF_MULTI_COUNTER) {
                            pThisItem->MultiCount = (DWORD) * ++pllData;
                        }
                        break;

                    case PERF_COUNTER_MULTI_TIMER:
                    case PERF_COUNTER_MULTI_TIMER_INV:
                        pllData                = (UNALIGNED LONGLONG *) pData;
                        pThisItem->FirstValue  = * pllData;
                        // begin hack code
                        pThisItem->FirstValue *= (DWORD) pPerfData->PerfFreq.QuadPart;
                        // end hack code
                        pThisItem->SecondValue = pPerfData->PerfTime.QuadPart;
                        if ((LocalCType & PERF_MULTI_COUNTER) == PERF_MULTI_COUNTER) {
                            pThisItem->MultiCount = (DWORD) * ++ pllData;
                        }
                        break;
                    //
                    //  These counters do not use any time reference
                    //
                    case PERF_COUNTER_RAWCOUNT:
                    case PERF_COUNTER_RAWCOUNT_HEX:
                    case PERF_COUNTER_DELTA:
                        pThisItem->FirstValue  = (LONGLONG) (* (DWORD *) pData);
                        pThisItem->SecondValue = 0;
                        break;

                    case PERF_COUNTER_LARGE_RAWCOUNT:
                    case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
                    case PERF_COUNTER_LARGE_DELTA:
                        pThisItem->FirstValue  = * (LONGLONG *) pData;
                        pThisItem->SecondValue = 0;
                        break;
                    //
                    //  These counters use the 100 Ns time base in thier calculation
                    //
                    case PERF_100NSEC_TIMER:
                    case PERF_100NSEC_TIMER_INV:
                    case PERF_100NSEC_MULTI_TIMER:
                    case PERF_100NSEC_MULTI_TIMER_INV:
                        pllData                = (UNALIGNED LONGLONG *) pData;
                        pThisItem->FirstValue  = * pllData;
                        pThisItem->SecondValue = pPerfData->PerfTime100nSec.QuadPart;
                        if ((LocalCType & PERF_MULTI_COUNTER) == PERF_MULTI_COUNTER) {
                            ++ pllData;
                            pThisItem->MultiCount = * (DWORD *) pllData;
                        }
                        break;
                    //
                    //  These counters use two data points, the one pointed to by
                    //  pData and the one pointed by the definition following
                    //  immediately after
                    //
                    case PERF_SAMPLE_FRACTION:
                    case PERF_RAW_FRACTION:
                        pdwData                = (DWORD *) pData;
                        pThisItem->FirstValue  = (LONGLONG)(* pdwData);
                        pData                  = GetInstanceCounterDataPtr(pPerfObject, pPerfInstance, pDenPerfCounter);
                        pdwData                = (DWORD *) pData;
                        pThisItem->SecondValue = (LONGLONG) (* pdwData);
                        break;

                    case PERF_LARGE_RAW_FRACTION:
                        pllData                        = (UNALIGNED LONGLONG *) pData;
                        pCounter->ThisValue.FirstValue = * pllData;
                        pData = GetInstanceCounterDataPtr(pPerfObject, pPerfInstance, pDenPerfCounter);
                        if (pData) {
                            pllData                         = (LONGLONG *) pData;
                            pCounter->ThisValue.SecondValue = * pllData;
                        }
                        else {
                            pCounter->ThisValue.SecondValue = 0;
                            bReturn = FALSE;
                        }
                        break;

                    case PERF_PRECISION_SYSTEM_TIMER:
                    case PERF_PRECISION_100NS_TIMER:
                    case PERF_PRECISION_OBJECT_TIMER:
                        pllData                = (UNALIGNED LONGLONG *) pData;
                        pThisItem->FirstValue  = * pllData;
                        // find the pointer to the base value in the structure
                        pData = GetInstanceCounterDataPtr(pPerfObject, pPerfInstance, pDenPerfCounter);
                        pllData                = (LONGLONG *) pData;
                        pThisItem->SecondValue = * pllData;
                        break;

                    case PERF_AVERAGE_TIMER:
                    case PERF_AVERAGE_BULK:
                        // counter (numerator) is a LONGLONG, while the
                        // denominator is just a DWORD
                        pllData                = (UNALIGNED LONGLONG *) pData;
                        pThisItem->FirstValue  = * pllData;
                        pData = GetInstanceCounterDataPtr(pPerfObject, pPerfInstance, pDenPerfCounter);
                        pdwData                = (DWORD *) pData;
                        pThisItem->SecondValue = (LONGLONG) * pdwData;
                        break;
                    //
                    //  These counters are used as the part of another counter
                    //  and as such should not be used, but in case they are
                    //  they'll be handled here.
                    //
                    case PERF_SAMPLE_BASE:
                    case PERF_AVERAGE_BASE:
                    case PERF_COUNTER_MULTI_BASE:
                    case PERF_RAW_BASE:
                    case PERF_LARGE_RAW_BASE:
                        pThisItem->FirstValue  = 0;
                        pThisItem->SecondValue = 0;
                        break;

                    case PERF_ELAPSED_TIME:
                        // this counter type needs the object perf data as well
                        if (GetObjectPerfInfo(pPerfData,
                                              pCounter->plCounterInfo.dwObjectId,
                                              & pThisItem->SecondValue,
                                              & pCounter->TimeBase)) {
                            pllData               = (UNALIGNED LONGLONG *) pData;
                            pThisItem->FirstValue = * pllData;
                        }
                        else {
                            pThisItem->FirstValue  = 0;
                            pThisItem->SecondValue = 0;
                        }
                        break;
                    //
                    //  These counters are not supported by this function (yet)
                    //
                    case PERF_COUNTER_TEXT:
                    case PERF_COUNTER_NODATA:
                    case PERF_COUNTER_HISTOGRAM_TYPE:
                        pThisItem->FirstValue  = 0;
                        pThisItem->SecondValue = 0;
                        break;

                    default:
                        // an unrecognized counter type was returned
                        pThisItem->FirstValue  = 0;
                        pThisItem->SecondValue = 0;
                        bReturn = FALSE;
                        break;
                    }
                    pThisItem ++;    // go to the next entry

                    // go to the next instance data block
                    pPerfInstance = NextInstance(pPerfObject, pPerfInstance);
                } // end for each instance
            }
            else {
                // no instance found so ignore
            }
            // measure the memory block used
            dwFinalSize = (DWORD)((LPBYTE)szNextNameString - (LPBYTE) pCounter->pThisRawItemList);
        }
        else {
            // unable to allocate a new buffer so return error
            SetLastError(ERROR_OUTOFMEMORY);
            bReturn = FALSE;
        }
    }
    else {
        pCounter->pThisRawItemList = G_ALLOC(sizeof(PDHI_RAW_COUNTER_ITEM_BLOCK));
        if (pCounter->pThisRawItemList != NULL) {
            pCounter->pThisRawItemList->dwLength                 = sizeof(PDHI_RAW_COUNTER_ITEM_BLOCK);
            pCounter->pThisRawItemList->dwItemCount              = 0;
            pCounter->pThisRawItemList->CStatus                  = LocalCStatus;
            pCounter->pThisRawItemList->TimeStamp.dwLowDateTime  = LODWORD(TimeStamp);
            pCounter->pThisRawItemList->TimeStamp.dwHighDateTime = HIDWORD(TimeStamp);
        }
        else {
            SetLastError(ERROR_OUTOFMEMORY);
            bReturn = FALSE;
        }
    }
    return bReturn;
}

BOOL
UpdateRealTimeMultiInstanceCounterValue(
    PPDHI_COUNTER pCounter
)
{
    BOOL   bResult      = TRUE;
    DWORD  LocalCStatus = 0;

    if (pCounter->pThisRawItemList != NULL) {
        // free old counter buffer list
        if (pCounter->pLastRawItemList && pCounter->pLastRawItemList != pCounter->pThisRawItemList) {
            G_FREE(pCounter->pLastRawItemList);
        }
        pCounter->pLastRawItemList = pCounter->pThisRawItemList;
        pCounter->pThisRawItemList = NULL;
    }

    // don't process if the counter has not been initialized
    if (!(pCounter->dwFlags & PDHIC_COUNTER_UNUSABLE)) {

        // get the counter's machine status first. There's no point in
        // contuning if the machine is offline

        LocalCStatus = pCounter->pQMachine->lQueryStatus;
        if (IsSuccessSeverity(LocalCStatus)) {
            bResult = UpdateMultiInstanceCounterValue(pCounter,
                                                      pCounter->pQMachine->pPerfData,
                                                      pCounter->pQMachine->llQueryTime);
        }
        else {
            // unable to read data from this counter's machine so use the
            // query's timestamp
            pCounter->pThisRawItemList = G_ALLOC(sizeof(PDHI_RAW_COUNTER_ITEM_BLOCK));
            if (pCounter->pThisRawItemList != NULL) {
                pCounter->pThisRawItemList->dwLength                 = sizeof(PDHI_RAW_COUNTER_ITEM_BLOCK);
                pCounter->pThisRawItemList->dwItemCount              = 0;
                pCounter->pThisRawItemList->CStatus                  = LocalCStatus;
                pCounter->pThisRawItemList->TimeStamp.dwLowDateTime  = LODWORD(pCounter->pQMachine->llQueryTime);
                pCounter->pThisRawItemList->TimeStamp.dwHighDateTime = HIDWORD(pCounter->pQMachine->llQueryTime);
            }
            else {
                SetLastError(ERROR_OUTOFMEMORY);
                bResult = FALSE;
            }
        }
    }
    else {
        if (pCounter->dwFlags & PDHIC_COUNTER_NOT_INIT) {
            // try to init is
            InitCounter(pCounter);
        }
    }
    return bResult;
}

BOOL
UpdateCounterObject(
    PPDHI_COUNTER pCounter
)
{
    BOOL              bReturn      = TRUE;
    PPERF_OBJECT_TYPE pPerfObject  = NULL;
    PPERF_OBJECT_TYPE pLogPerfObj;
    DWORD             dwBufferSize = sizeof(PERF_DATA_BLOCK);
    FILETIME          ftGmtTime;
    FILETIME          ftLocTime;

    if (pCounter == NULL) {
        SetLastError(PDH_INVALID_ARGUMENT);
        bReturn = FALSE;
    }
    else {
        if (pCounter->pThisObject != NULL) {
            if (pCounter->pLastObject && pCounter->pThisObject != pCounter->pLastObject) {
                G_FREE(pCounter->pLastObject);
            }
            pCounter->pLastObject = pCounter->pThisObject;
            pCounter->pThisObject = NULL;
        }

        // don't process if the counter has not been initialized
        if (!(pCounter->dwFlags & PDHIC_COUNTER_UNUSABLE)) { 
            if (IsSuccessSeverity(pCounter->pQMachine->lQueryStatus)) {
                pPerfObject = GetObjectDefByTitleIndex(pCounter->pQMachine->pPerfData,
                                                       pCounter->plCounterInfo.dwObjectId);
                dwBufferSize  = pCounter->pQMachine->pPerfData->HeaderLength;
                dwBufferSize += ((pPerfObject == NULL) ? sizeof(PERF_OBJECT_TYPE) : pPerfObject->TotalByteLength);
                pCounter->pThisObject = G_ALLOC(dwBufferSize);
                if (pCounter->pThisObject != NULL) {
                    RtlCopyMemory(pCounter->pThisObject,
                                  pCounter->pQMachine->pPerfData,
                                  pCounter->pQMachine->pPerfData->HeaderLength);
                    pCounter->pThisObject->TotalByteLength = dwBufferSize;
                    pCounter->pThisObject->NumObjectTypes  = 1;

                    SystemTimeToFileTime(& pCounter->pThisObject->SystemTime, & ftGmtTime);
                    FileTimeToLocalFileTime(& ftGmtTime, & ftLocTime);
                    FileTimeToSystemTime(& ftLocTime, & pCounter->pThisObject->SystemTime);
                    pLogPerfObj = (PPERF_OBJECT_TYPE)
                            ((LPBYTE) pCounter->pThisObject + pCounter->pQMachine->pPerfData->HeaderLength);
                    if (pPerfObject != NULL) {
                        RtlCopyMemory(pLogPerfObj, pPerfObject, pPerfObject->TotalByteLength);
                    }
                    else {
                        ZeroMemory(pLogPerfObj, sizeof(PERF_OBJECT_TYPE));
                        pLogPerfObj->TotalByteLength      = sizeof(PERF_OBJECT_TYPE);
                        pLogPerfObj->DefinitionLength     = sizeof(PERF_OBJECT_TYPE);
                        pLogPerfObj->HeaderLength         = sizeof(PERF_OBJECT_TYPE);
                        pLogPerfObj->ObjectNameTitleIndex = pCounter->plCounterInfo.dwObjectId;
                        pLogPerfObj->ObjectHelpTitleIndex = pCounter->plCounterInfo.dwObjectId + 1;
                    }
                }
                else {
                    SetLastError(ERROR_OUTOFMEMORY);
                    bReturn = FALSE;
                }
            }
            else {
                pCounter->pThisObject = G_ALLOC(sizeof(PERF_DATA_BLOCK));
                if (pCounter->pThisObject == NULL) {
                    pCounter->pThisObject = pCounter->pLastObject;
                }
                else {
                    pCounter->pThisObject->Signature[0]              = L'P';
                    pCounter->pThisObject->Signature[1]              = L'E';
                    pCounter->pThisObject->Signature[2]              = L'R';
                    pCounter->pThisObject->Signature[3]              = L'F';
                    pCounter->pThisObject->LittleEndian              = TRUE;
                    pCounter->pThisObject->Version                   = PERF_DATA_VERSION;
                    pCounter->pThisObject->Revision                  = PERF_DATA_REVISION;
                    pCounter->pThisObject->TotalByteLength           = sizeof(PERF_DATA_BLOCK);
                    pCounter->pThisObject->NumObjectTypes            = 1;
                    pCounter->pThisObject->DefaultObject             = pCounter->plCounterInfo.dwObjectId;
                    pCounter->pThisObject->SystemNameLength          = 0;
                    pCounter->pThisObject->SystemNameOffset          = 0;
                    pCounter->pThisObject->HeaderLength              = sizeof(PERF_DATA_BLOCK);
                    pCounter->pThisObject->PerfTime.QuadPart         = 0;
                    pCounter->pThisObject->PerfFreq.QuadPart         = 0;
                    pCounter->pThisObject->PerfTime100nSec.QuadPart  = 0;
                    GetLocalTime(& pCounter->pThisObject->SystemTime);
                }
                SetLastError(PDH_CSTATUS_INVALID_DATA);
                bReturn = FALSE;
            }
        }
        else {
            if (pCounter->dwFlags & PDHIC_COUNTER_NOT_INIT) {
                InitCounter(pCounter);
            }
            pCounter->pThisObject = pCounter->pLastObject;
            SetLastError(PDH_CSTATUS_INVALID_DATA);
            bReturn = FALSE;
        }
    }
    return bReturn;
}

PVOID
GetPerfCounterDataPtr(
    PPERF_DATA_BLOCK    pPerfData,
    PPDHI_COUNTER_PATH  pPath,
    PPERFLIB_COUNTER    pplCtr ,
    DWORD               dwFlags,
    PPERF_OBJECT_TYPE   *pPerfObjectArg,
    PDWORD              pStatus
)
{
    PPERF_OBJECT_TYPE           pPerfObject   = NULL;
    PPERF_INSTANCE_DEFINITION   pPerfInstance = NULL;
    PPERF_COUNTER_DEFINITION    pPerfCounter  = NULL;
    DWORD                       dwTestValue   = 0;
    PVOID                       pData         = NULL;
    DWORD                       dwCStatus     = PDH_CSTATUS_INVALID_DATA;

    pPerfObject = GetObjectDefByTitleIndex(pPerfData, pplCtr->dwObjectId);

    if (pPerfObject != NULL) {
        if (pPerfObjectArg != NULL) * pPerfObjectArg = pPerfObject;
        if (pPerfObject->NumInstances == PERF_NO_INSTANCES) {
            // then just look up the counter
            pPerfCounter = GetCounterDefByTitleIndex(pPerfObject,
                                                     ((dwFlags & GPCDP_GET_BASE_DATA) ? TRUE : FALSE),
                                                     pplCtr->dwCounterId);
            if (pPerfCounter != NULL) {
                // get data and return it
                pData = GetCounterDataPtr(pPerfObject, pPerfCounter);
                if (pData != NULL) {
                    // test the pointer to see if it fails
                    __try {
                        dwTestValue = * (DWORD *) pData;
                        dwCStatus   = PDH_CSTATUS_VALID_DATA;
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        pData     = NULL;
                        dwCStatus = PDH_CSTATUS_INVALID_DATA;
                    }
                }
                else {
                    dwCStatus = PDH_CSTATUS_INVALID_DATA;
                }
            }
            else {
                // unable to find counter
                dwCStatus = PDH_CSTATUS_NO_COUNTER;
            }
        }
        else {
            // find instance
            if (pplCtr->lInstanceId == PERF_NO_UNIQUE_ID && pPath->szInstanceName != NULL) {
                pPerfInstance = GetInstanceByName(pPerfData,
                                                  pPerfObject,
                                                  pPath->szInstanceName,
                                                  pPath->szParentName,
                                                  pPath->dwIndex);
                if (pPerfInstance == NULL && pPath->szInstanceName[0] >= L'0' && pPath->szInstanceName[0] <= L'9') {
                    LONG lInstanceId = (LONG) _wtoi(pPath->szInstanceName);
                    pPerfInstance = GetInstanceByUniqueId(pPerfObject, lInstanceId);
                }
            }
            else {
                pPerfInstance = GetInstanceByUniqueId(pPerfObject, pplCtr->lInstanceId);
            }
            if (pPerfInstance != NULL) {
                // instance found so find pointer to counter data
                pPerfCounter = GetCounterDefByTitleIndex(pPerfObject,
                                                         ((dwFlags & GPCDP_GET_BASE_DATA) ? TRUE : FALSE),
                                                         pplCtr->dwCounterId);
                if (pPerfCounter != NULL) {
                    // counter found so get data pointer
                    pData = GetInstanceCounterDataPtr(pPerfObject, pPerfInstance, pPerfCounter);
                    if (pData != NULL) {
                        // test the pointer to see if it's valid
                        __try {
                            dwTestValue = * (DWORD *) pData;
                            dwCStatus   = PDH_CSTATUS_VALID_DATA;
                        }
                        __except (EXCEPTION_EXECUTE_HANDLER) {
                            pData     = NULL;
                            dwCStatus = PDH_CSTATUS_INVALID_DATA;
                        }
                    }
                    else {
                        dwCStatus = PDH_CSTATUS_INVALID_DATA;
                    }
                }
                else {
                    // counter not found
                    dwCStatus = PDH_CSTATUS_NO_COUNTER;
                }
            }
            else {
                // instance not found
                dwCStatus = PDH_CSTATUS_NO_INSTANCE;
            }
        }
    }
    else {
        // unable to find object
        dwCStatus = PDH_CSTATUS_NO_OBJECT;
    }
    if (pStatus != NULL) {
        __try {
            * pStatus = dwCStatus;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            // ?
        }
    }
    return pData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhdll\perfname.c ===
/*++
Copyright (C) 1996-1999 Microsoft Corporation

Module Name:
    perfname.c

Abstract:
    <abstract>
--*/

#include <windows.h>
#include <winperf.h>
#include <mbctype.h>
#include "strsafe.h"
#include <pdh.h>
#include "pdhitype.h"
#include "pdhidef.h"
#include "pdhmsg.h"
#include "strings.h"

LPSTR
PdhiWideCharToMultiByte(
    UINT   CodePage,
    LPWSTR wszString
)
{
    LPSTR aszString = NULL;
    int   dwValue   = WideCharToMultiByte(CodePage, 0, wszString, -1, NULL, 0, NULL, NULL);
    if (dwValue != 0) {
        aszString = G_ALLOC((dwValue + 1) * sizeof(CHAR));
        if (aszString != NULL) {
            WideCharToMultiByte(CodePage, 0, wszString, -1, aszString, dwValue + 1, NULL, NULL);
        }
    }
    return aszString;
}

LPWSTR
PdhiMultiByteToWideChar(
    UINT   CodePage,
    LPSTR  aszString
)
{
    LPWSTR wszString = NULL;
    int    dwValue   = MultiByteToWideChar(CodePage, 0, aszString, -1, NULL, 0);
    if (dwValue != 0) {
        wszString = G_ALLOC((dwValue + 1) * sizeof(WCHAR));
        if (wszString != NULL) {
            MultiByteToWideChar(CodePage, 0, aszString, -1, wszString, dwValue + 1);
        }
    }
    return wszString;
}

LPCWSTR
PdhiLookupPerfNameByIndex(
    PPERF_MACHINE  pMachine,
    DWORD          dwNameIndex
)
{
    LPWSTR  szReturn = NULL;
    LONG    lStatus  = ERROR_SUCCESS;

    SetLastError(lStatus);
    if (pMachine != NULL) {
        if (pMachine->dwStatus == ERROR_SUCCESS) {
            if (dwNameIndex <= pMachine->dwLastPerfString) {
                szReturn = pMachine->szPerfStrings[dwNameIndex];
            }
            else {
                lStatus = PDH_INVALID_ARGUMENT;
            }
        }
        else {
            lStatus = pMachine->dwStatus ;
        }
    }
    else {
        lStatus = PDH_CSTATUS_NO_MACHINE;
    }
    SetLastError(lStatus);
    return (LPCWSTR) szReturn;
}

DWORD
PdhiLookupPerfIndexByName(
    PPERF_MACHINE  pMachine,
    LPCWSTR        szNameBuffer
)
{
    DWORD   dwCurrentIndex = 2;
    BOOL    bDone          = FALSE;
    LPWSTR  szThisPerfString;

    SetLastError(ERROR_SUCCESS);

    while (! bDone) {
        // test even indices first
        for (; dwCurrentIndex <= pMachine->dwLastPerfString; dwCurrentIndex += 2) {
            szThisPerfString = pMachine->szPerfStrings[dwCurrentIndex];
            if (szThisPerfString != NULL) {
                if (lstrcmpiW(szNameBuffer, szThisPerfString) == 0) {
                    // match found
                    bDone = TRUE;
                    break;
                }
            }
        }
        if (! bDone) {
            // if doing an odd # & not done then exit because we've
            // looked at them all and not found anything
            if (dwCurrentIndex & 0x00000001) break;
            dwCurrentIndex = 3;
        } // else just go to the loop exit
    }

    if (! bDone) {
        SetLastError(PDH_STRING_NOT_FOUND);
        dwCurrentIndex = 0;
    }
    return dwCurrentIndex;
}

PDH_FUNCTION
PdhLookupPerfNameByIndexW(
    LPCWSTR szMachineName,
    DWORD   dwNameIndex,
    LPWSTR  szNameBuffer,
    LPDWORD pcchNameBufferSize
)
{
    PPERF_MACHINE   pMachine;
    PDH_STATUS      pdhStatus          = ERROR_SUCCESS;
    LPWSTR          szLocalMachineName = NULL;
    LPWSTR          szLocalName;
    DWORD           dwNameLen;
    DWORD           dwLocalNameSize    = 0;

    if (pcchNameBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        // test access to all the parameteres passed in before continuing
        __try {
            dwLocalNameSize = * pcchNameBufferSize;

            if (szMachineName == NULL) {
                szLocalMachineName = (LPWSTR) szStaticLocalMachineName;
            }
            else if (* szMachineName == L'\0' || lstrlenW(szMachineName) > PDH_MAX_COUNTER_NAME) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else {
                szLocalMachineName = (LPWSTR) szMachineName;
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if (szNameBuffer != NULL && dwLocalNameSize > 0) {
                    WCHAR wszTmp;
                    wszTmp                            = szNameBuffer[0];
                    szNameBuffer[0]                   = L'\0';
                    szNameBuffer[0]                   = wszTmp;
                    wszTmp                            = szNameBuffer[dwLocalNameSize - 1];
                    szNameBuffer[dwLocalNameSize - 1] = L'\0';
                    szNameBuffer[dwLocalNameSize - 1] = wszTmp;
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pMachine = GetMachine(szLocalMachineName, 0, PDH_GM_UPDATE_PERFNAME_ONLY);
        if (pMachine != NULL) {
            if (pMachine->dwStatus == ERROR_SUCCESS) {
                szLocalName = (LPWSTR) PdhiLookupPerfNameByIndex(pMachine, dwNameIndex);
                if (szLocalName != NULL) {
                    dwNameLen = lstrlenW(szLocalName) + 1;
                    if (szNameBuffer != NULL && dwNameLen <= dwLocalNameSize) {
                        StringCchCopyW(szNameBuffer, dwLocalNameSize, szLocalName);
                    }
                    else {
                        pdhStatus = PDH_MORE_DATA;
                    }
                    dwLocalNameSize = dwNameLen;
                }
                else {
                    pdhStatus = GetLastError();
                }
            }
            else {
                pdhStatus = pMachine->dwStatus;
            }
            pMachine->dwRefCount--;
            RELEASE_MUTEX(pMachine->hMutex);
        }
        else {
            pdhStatus = GetLastError();
        }
    }

    if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
        __try {
            * pcchNameBufferSize = dwLocalNameSize;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhLookupPerfNameByIndexA(
    LPCSTR  szMachineName,
    DWORD   dwNameIndex,
    LPSTR   szNameBuffer,
    LPDWORD pcchNameBufferSize
)
{
    PPERF_MACHINE   pMachine;
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    LPWSTR          szLocalMachineName = NULL;
    LPWSTR          szLocalName;
    DWORD           dwLocalNameSize = 0;

    if (pcchNameBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        // test access to all the parameteres passed in before continuing
        __try {
            dwLocalNameSize = * pcchNameBufferSize;

            if (szMachineName == NULL) {
                // use local machine name
                szLocalMachineName = & szStaticLocalMachineName[0];
            }
            else if (* szMachineName == '\0' || lstrlenA(szMachineName) > PDH_MAX_COUNTER_NAME) {
                // NULL machine name
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else {
                // then allocate a new buffer and convert the LPSTR to a LPWSTR
                szLocalMachineName = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szMachineName);
                if (szLocalMachineName == NULL) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            }

            if (pdhStatus == ERROR_SUCCESS) {
                if (szNameBuffer != NULL && dwLocalNameSize > 0) {
                    CHAR aszTmp;
                    aszTmp                            = szNameBuffer[0];
                    szNameBuffer[0]                   = '\0';
                    szNameBuffer[0]                   = aszTmp;
                    aszTmp                            = szNameBuffer[dwLocalNameSize - 1];
                    szNameBuffer[dwLocalNameSize - 1] = '\0';
                    szNameBuffer[dwLocalNameSize - 1] = aszTmp;
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pMachine = GetMachine(szLocalMachineName, 0, PDH_GM_UPDATE_PERFNAME_ONLY);
        if (pMachine != NULL) {
            if (pMachine->dwStatus == ERROR_SUCCESS) {
                szLocalName = (LPWSTR)PdhiLookupPerfNameByIndex(pMachine, dwNameIndex);
                if (szLocalName != NULL) {
                    pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                                         szLocalName,
                                                         szNameBuffer,
                                                         & dwLocalNameSize);
                }
                else {
                    pdhStatus = GetLastError();
                }
            }
            else {
                pdhStatus = pMachine->dwStatus;
            }
            pMachine->dwRefCount --;
            RELEASE_MUTEX (pMachine->hMutex);
        }
        else {
            pdhStatus = GetLastError();
        }
    }

    if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
        __try {
            * pcchNameBufferSize = dwLocalNameSize;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (szLocalMachineName != NULL && szLocalMachineName != (LPWSTR) szStaticLocalMachineName) {
            G_FREE (szLocalMachineName);
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhLookupPerfIndexByNameW(
    LPCWSTR szMachineName,
    LPCWSTR szNameBuffer,
    LPDWORD pdwIndex
)
{
    PPERF_MACHINE   pMachine;
    PDH_STATUS      pdhStatus          = ERROR_SUCCESS;
    LPWSTR          szLocalMachineName = NULL;
    DWORD           dwIndexFound;

    if ((szNameBuffer == NULL) || (pdwIndex == NULL)) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        // test access to all the parameteres passed in before continuing
        __try {
            if (szMachineName == NULL) {
                // use local machine name
                szLocalMachineName = szStaticLocalMachineName;
            }
            else {
                if (* szMachineName == L'\0') {
                    // NULL machine name
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
                else if (lstrlenW(szMachineName) > PDH_MAX_COUNTER_NAME) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
                else {
                    szLocalMachineName = (LPWSTR) szMachineName;
                }
            }

            // test read access to name
            if (* szNameBuffer == L'\0' || lstrlenW(szNameBuffer) > PDH_MAX_COUNTER_NAME)  {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            if (pdhStatus == ERROR_SUCCESS)  {
                // test write access
                * pdwIndex = 0;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pMachine = GetMachine(szLocalMachineName, 0, PDH_GM_UPDATE_PERFNAME_ONLY);
        if (pMachine != NULL) {
            if (pMachine->dwStatus == ERROR_SUCCESS) {
                dwIndexFound = PdhiLookupPerfIndexByName(pMachine, szNameBuffer);
                if (dwIndexFound == 0) {
                    // match not found
                    pdhStatus = GetLastError();
                }
                else {
                    __try {
                       // write value found
                        * pdwIndex = dwIndexFound;
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
            }
            else {
                pdhStatus = pMachine->dwStatus;
            }
            pMachine->dwRefCount--;
            RELEASE_MUTEX(pMachine->hMutex);
        }
        else {
            pdhStatus = GetLastError();
        }
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhLookupPerfIndexByNameA(
    LPCSTR  szMachineName,
    LPCSTR  szNameBuffer,
    LPDWORD pdwIndex
)
{
    PPERF_MACHINE   pMachine;
    PDH_STATUS      pdhStatus          = ERROR_SUCCESS;
    LPWSTR          szLocalMachineName =  NULL;
    DWORD           dwIndexFound;
    LPWSTR          szWideName;

    if ((szNameBuffer == NULL) || (pdwIndex == NULL)) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        // test access to all the parameteres passed in before continuing
        __try {
            if (szMachineName == NULL) {
                // use local machine name
                szLocalMachineName = (LPWSTR) szStaticLocalMachineName;
            }
            else {
                if (* szMachineName == '\0') {
                    // NULL machine name
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
                else if (lstrlenA(szMachineName) > PDH_MAX_COUNTER_NAME) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
                else {
                    // then allocate a new buffer and convert the LPSTR to a LPWSTR
                    szLocalMachineName = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szMachineName);
                    if (szLocalMachineName == NULL) {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                }
            }

            // test read access to name
            if (pdhStatus == ERROR_SUCCESS) {
                if (* szNameBuffer == '\0' || lstrlenA(szNameBuffer) > PDH_MAX_COUNTER_NAME)  {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

            if (pdhStatus == ERROR_SUCCESS) {
                // test write access
                * pdwIndex = 0;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pMachine = GetMachine(szLocalMachineName, 0, PDH_GM_UPDATE_PERFNAME_ONLY);
        if (pMachine != NULL) {
            if (pMachine->dwStatus == ERROR_SUCCESS) {
                // convert name string to wide characters for comparison
                szWideName = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szNameBuffer);
                if (szWideName != NULL) {
                    dwIndexFound = PdhiLookupPerfIndexByName(pMachine, szWideName);
                    if (dwIndexFound == 0) {
                        // match not found
                        pdhStatus = GetLastError();
                    }
                    else {
                        __try {
                           // write value found
                            * pdwIndex = dwIndexFound;
                        }
                        __except (EXCEPTION_EXECUTE_HANDLER) {
                            pdhStatus = PDH_INVALID_ARGUMENT;
                        }
                    }
                    G_FREE(szWideName);
                }
                else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            }
            else {
                pdhStatus = pMachine->dwStatus;
            }
            pMachine->dwRefCount--;
            RELEASE_MUTEX (pMachine->hMutex);
        }
        else {
            pdhStatus = GetLastError();
        }
    }

    if (szLocalMachineName != NULL && szLocalMachineName != szStaticLocalMachineName) {
        G_FREE(szLocalMachineName);
    }

    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhdll\perfdata.c ===
/*++
Copyright (C) 1996-1999 Microsoft Corporation

Module Name:
    perfdata.c

Abstract:
    <abstract>
--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include "strsafe.h"
#include <mbctype.h>
#include "pdh.h"
#include "pdhitype.h"
#include "pdhidef.h"
#include "perfdata.h"
#include "pdhmsg.h"
#include "strings.h"

// the following strings are for getting texts from perflib
#define OLD_VERSION 0x010000
#define tohexdigit(x) ((CHAR) (((x) < 10) ? ((x) + L'0') : ((x) + L'a' - 10)))

#define INITIAL_SIZE        ((DWORD) 0x00020000)
#define RESERVED            0L

DWORD
PdhiMakePerfPrimaryLangId(
    LANGID  lID,
    LPWSTR  szBuffer
)
{
    WCHAR    LangId;
    WCHAR    nDigit;

    LangId      = (WCHAR) PRIMARYLANGID(lID);
    nDigit      = (WCHAR) (LangId >> 8);
    szBuffer[0] = tohexdigit(nDigit);
    nDigit      = (WCHAR) (LangId & 0XF0) >> 4;
    szBuffer[1] = tohexdigit(nDigit);
    nDigit      = (WCHAR) (LangId & 0xF);
    szBuffer[2] = tohexdigit(nDigit);
    szBuffer[3] = L'\0';

    return ERROR_SUCCESS;
}

BOOL
IsMatchingInstance(
    PPERF_INSTANCE_DEFINITION pInstanceDef,
    DWORD                     dwCodePage,
    LPWSTR                    szInstanceNameToMatch,
    DWORD                     dwInstanceNameLength
)
// compares pInstanceName to the name in the instance
{
    BOOL    bMatch                   = FALSE;
    DWORD   dwThisInstanceNameLength;
    LPWSTR  szThisInstanceName       = NULL;
    LPWSTR  szBufferForANSINames     = NULL;

    if (szInstanceNameToMatch != NULL) {
        if (dwInstanceNameLength == 0) {
            // get the length to compare
            dwInstanceNameLength = lstrlenW(szInstanceNameToMatch);
        }
        if (dwCodePage == 0) {
            // try to take a shortcut here if it's a unicode string
            // compare to the length of the shortest string
            // get the pointer to this string
            szThisInstanceName = GetInstanceName(pInstanceDef);
            if (szThisInstanceName != NULL) {
                // convert instance Name from bytes to chars
                dwThisInstanceNameLength = pInstanceDef->NameLength / sizeof(WCHAR);

                // see if this length includes the term. null. If so shorten it
                if (szThisInstanceName[dwThisInstanceNameLength - 1] == L'\0') {
                    dwThisInstanceNameLength --;
                }
            }
            else {
                dwThisInstanceNameLength = 0;
            }
        }
        else {
            // go the long way and read/translate/convert the string
            dwThisInstanceNameLength =GetInstanceNameStr(pInstanceDef, & szBufferForANSINames, dwCodePage);
            if (dwThisInstanceNameLength > 0) {
                szThisInstanceName = & szBufferForANSINames[0];
            }
        }

        // if the lengths are not equal then the names can't be either
        if (dwInstanceNameLength == dwThisInstanceNameLength) {
            if (szThisInstanceName != NULL) {
                if (lstrcmpiW(szInstanceNameToMatch, szThisInstanceName) == 0) {
                    // this is a match
                    bMatch = TRUE;
                }
            }
        }
        G_FREE(szBufferForANSINames);
    }
    return bMatch;
}

LPWSTR *
BuildNameTable(
    LPWSTR        szComputerName, // computer to query names from
    LANGID        LangId,         // language ID
    PPERF_MACHINE pMachine        // update member fields
)
/*++

BuildNameTable

Arguments:

    hKeyRegistry
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.

    lpszLangId
            The unicode id of the language to look up. (default is 409)

Return Value:

    pointer to an allocated table. (the caller must free it when finished!)
    the table is an array of pointers to zero terminated strings. NULL is
    returned if an error occured.

--*/
{
    LPWSTR  * lpCounterId;
    LPWSTR    lpCounterNames;
    LPWSTR    lpHelpText;
    LPWSTR    lpThisName;
    LONG      lWin32Status         = ERROR_SUCCESS;
    DWORD     dwLastError;
    DWORD     dwValueType;
    DWORD     dwArraySize;
    DWORD     dwBufferSize;
    DWORD     dwCounterSize        = 0;
    DWORD     dwHelpSize           = 0;
    DWORD     dw009CounterSize     = 0;
    DWORD     dw009HelpSize        = 0;
    DWORD     dwThisCounter;
    DWORD     dwLastCounter;
    DWORD     dwSystemVersion;
    DWORD     dwLastId;
    DWORD     dwLastHelpId;
    HKEY      hKeyRegistry         = NULL;
    HKEY      hKeyValue            = NULL;
    HKEY      hKeyNames            = NULL;
    HKEY      hKey009Names         = NULL;
    LPWSTR    lpValueNameString    = NULL;
    LPWSTR    lp009ValueNameString = NULL;
    LPWSTR    CounterNameBuffer    = NULL;
    LPWSTR    HelpNameBuffer       = NULL;
    LPWSTR    Counter009NameBuffer = NULL;
    LPWSTR    Help009NameBuffer    = NULL;
    LPWSTR    lpszLangId           = NULL;
    BOOL      bUse009Locale        = FALSE;
    BOOL      bUsePerfTextKey      = TRUE;
    LPWSTR  * lpReturn             = NULL;

    if (pMachine == NULL) {
        lWin32Status = PDH_INVALID_ARGUMENT;
        goto BNT_BAILOUT;
    }
    pMachine->szPerfStrings        = NULL;
    pMachine->sz009PerfStrings     = NULL;
    pMachine->typePerfStrings      = NULL;

    if (szComputerName == NULL) {
        // use local machine
        hKeyRegistry = HKEY_LOCAL_MACHINE;
    }
    else {
        lWin32Status = RegConnectRegistryW(szComputerName, HKEY_LOCAL_MACHINE, & hKeyRegistry);
        if (lWin32Status != ERROR_SUCCESS) {
            // unable to connect to registry
            goto BNT_BAILOUT;
        }
    }
    CounterNameBuffer = G_ALLOC(5 * MAX_PATH * sizeof(WCHAR));
    if (CounterNameBuffer == NULL) {
        lWin32Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto BNT_BAILOUT;
    }
    HelpNameBuffer       = CounterNameBuffer    + MAX_PATH;
    Counter009NameBuffer = HelpNameBuffer       + MAX_PATH;
    Help009NameBuffer    = Counter009NameBuffer + MAX_PATH;
    lpszLangId           = Help009NameBuffer    + MAX_PATH;

    // check for null arguments and insert defaults if necessary

    if ((LangId == MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)) || (PRIMARYLANGID(LangId) == LANG_ENGLISH)) {
        bUse009Locale = TRUE;
    }
    PdhiMakePerfPrimaryLangId(LangId, lpszLangId);

    // open registry to get number of items for computing array size

    lWin32Status = RegOpenKeyExW(hKeyRegistry, cszNamesKey, RESERVED, KEY_READ, & hKeyValue);
    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }

    // get last update time of registry key

    lWin32Status = RegQueryInfoKey(
            hKeyValue, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, & pMachine->LastStringUpdateTime);

    // get number of Counter Help items
    dwBufferSize = sizeof (dwLastHelpId);
    lWin32Status = RegQueryValueExW(hKeyValue,
                                    cszLastHelp,
                                    RESERVED,
                                    & dwValueType,
                                    (LPBYTE) & dwLastHelpId,
                                    & dwBufferSize);
    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        goto BNT_BAILOUT;
    }

    // get number of Counter Name items
    dwBufferSize = sizeof (dwLastId);
    lWin32Status = RegQueryValueExW(hKeyValue,
                                    cszLastCounter,
                                    RESERVED,
                                    & dwValueType,
                                    (LPBYTE) & dwLastId,
                                    & dwBufferSize);
    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        goto BNT_BAILOUT;
    }

    if (dwLastId < dwLastHelpId) dwLastId = dwLastHelpId;
    dwArraySize = (dwLastId + 1) * sizeof(LPWSTR);

    // get Perflib system version
    dwBufferSize = sizeof(dwSystemVersion);
    lWin32Status = RegQueryValueExW(hKeyValue,
                                    cszVersionName,
                                    RESERVED,
                                    & dwValueType,
                                    (LPBYTE) & dwSystemVersion,
                                    & dwBufferSize);
    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        dwSystemVersion = OLD_VERSION;
    }

    if (dwSystemVersion == OLD_VERSION) {
        // get names from registry
        dwBufferSize = lstrlenW(cszNamesKey) + lstrlenW(cszBackSlash) + lstrlenW(lpszLangId) + 1;
        lpValueNameString = G_ALLOC(dwBufferSize * sizeof(WCHAR));
        if (lpValueNameString == NULL) {
            lWin32Status = PDH_MEMORY_ALLOCATION_FAILURE;
            goto BNT_BAILOUT;
        }

        StringCchPrintfW(lpValueNameString, dwBufferSize, L"%ws%ws%ws",
                         cszNamesKey, cszBackSlash, lpszLangId);
        lWin32Status = RegOpenKeyExW(hKeyRegistry, lpValueNameString, RESERVED, KEY_READ, & hKeyNames);
        if (! bUse009Locale && lWin32Status == ERROR_SUCCESS) {
            dwBufferSize = lstrlenW(cszNamesKey) + lstrlenW(cszBackSlash) + lstrlenW(cszDefaultLangId) + 1;
            lp009ValueNameString = G_ALLOC(dwBufferSize * sizeof(WCHAR));
            if (lp009ValueNameString == NULL) {
                lWin32Status = PDH_MEMORY_ALLOCATION_FAILURE;
                goto BNT_BAILOUT;
            }
            StringCchPrintfW(lp009ValueNameString, dwBufferSize, L"%ws%ws%ws",
                             cszNamesKey, cszBackSlash, cszDefaultLangId);
            lWin32Status = RegOpenKeyExW(hKeyRegistry, lp009ValueNameString, RESERVED, KEY_READ, & hKey009Names);
        }
    }
    else {
        __try {
            if (bUse009Locale == FALSE) {
                lWin32Status = RegConnectRegistryW(szComputerName, HKEY_PERFORMANCE_NLSTEXT, & hKeyNames);
                if (lWin32Status == ERROR_SUCCESS) {
                    lWin32Status = RegConnectRegistryW(szComputerName, HKEY_PERFORMANCE_TEXT, & hKey009Names);
                    if (lWin32Status != ERROR_SUCCESS) {
                        bUsePerfTextKey = FALSE;
                        if (hKeyNames != HKEY_PERFORMANCE_NLSTEXT) RegCloseKey(hKeyNames);
                    }
                }
                else {
                    bUsePerfTextKey = FALSE;
                }
            }
            else {
                lWin32Status = RegConnectRegistryW(szComputerName, HKEY_PERFORMANCE_TEXT, & hKeyNames);
                if (lWin32Status != ERROR_SUCCESS) {
                    bUsePerfTextKey = FALSE;
                }
                else {
                    hKey009Names = hKeyNames;
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            bUsePerfTextKey = FALSE;
        }
    }
    lWin32Status = ERROR_SUCCESS;

    if (! bUsePerfTextKey) {
        StringCchPrintfW(CounterNameBuffer,    MAX_PATH, L"%ws%ws", cszCounterName, lpszLangId);
        StringCchPrintfW(HelpNameBuffer,       MAX_PATH, L"%ws%ws", cszHelpName,    lpszLangId);
        StringCchPrintfW(Counter009NameBuffer, MAX_PATH, L"%ws%ws", cszCounterName, cszDefaultLangId);
        StringCchPrintfW(Help009NameBuffer,    MAX_PATH, L"%ws%ws", cszHelpName,    cszDefaultLangId);

        // cannot open HKEY_PERFORMANCE_TEXT, try the old way
        //
        if (szComputerName == NULL) {
            hKeyNames = HKEY_PERFORMANCE_DATA;
        }
        else {
            lWin32Status = RegConnectRegistryW(szComputerName, HKEY_PERFORMANCE_DATA, & hKeyNames);
            if (lWin32Status != ERROR_SUCCESS) {
                goto BNT_BAILOUT;
            }
        }
        hKey009Names = hKeyNames;        
    }
    else {
        StringCchCopyW(CounterNameBuffer,    MAX_PATH, cszCounters);
        StringCchCopyW(HelpNameBuffer,       MAX_PATH, cszHelp);
        StringCchCopyW(Counter009NameBuffer, MAX_PATH, cszCounters);
        StringCchCopyW(Help009NameBuffer,    MAX_PATH, cszHelp);
    }

    // get size of counter names and add that to the arrays
    dwBufferSize = 0;
    lWin32Status = RegQueryValueExW(hKeyNames,
                                    CounterNameBuffer,
                                    RESERVED,
                                    & dwValueType,
                                    NULL,
                                    & dwBufferSize);
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;
    dwCounterSize = dwBufferSize;

    if (! bUse009Locale) {
        dwBufferSize = 0;
        lWin32Status = RegQueryValueExW(hKey009Names,
                                        Counter009NameBuffer,
                                        RESERVED,
                                        & dwValueType,
                                        NULL,
                                        & dwBufferSize);
        if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;
        dw009CounterSize = dwBufferSize;
    }
    else {
        dw009CounterSize = dwCounterSize;
    }

    // get size of counter names and add that to the arrays
    dwBufferSize = 0;
    lWin32Status = RegQueryValueExW(hKeyNames,
                                    HelpNameBuffer,
                                    RESERVED,
                                    & dwValueType,
                                    NULL,
                                    & dwBufferSize);
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;
    dwHelpSize = dwBufferSize;

    if (! bUse009Locale) {
        dwBufferSize = 0;
        lWin32Status = RegQueryValueExW(hKey009Names,
                                        Help009NameBuffer,
                                        RESERVED,
                                        & dwValueType,
                                        NULL,
                                        & dwBufferSize);
        if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;
        dw009HelpSize = dwBufferSize;
    }
    else {
        dw009HelpSize = dwHelpSize;
    }

    pMachine->szPerfStrings = G_ALLOC(dwArraySize + dwCounterSize + dwHelpSize);
    if (pMachine->szPerfStrings == NULL) {
        lWin32Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto BNT_BAILOUT;
    }

    if (bUse009Locale) {
        pMachine->sz009PerfStrings = pMachine->szPerfStrings;
    }
    else {
        pMachine->sz009PerfStrings = G_ALLOC(dwArraySize + dw009CounterSize + dw009HelpSize);
        if (pMachine->sz009PerfStrings == NULL) {
            lWin32Status = PDH_MEMORY_ALLOCATION_FAILURE;
            goto BNT_BAILOUT;
        }
    }

    pMachine->typePerfStrings = G_ALLOC(dwLastId + 1);
    if (pMachine->typePerfStrings == NULL) {
        lWin32Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto BNT_BAILOUT;
    }

    // initialize pointers into buffer

    lpCounterId    = pMachine->szPerfStrings;
    lpCounterNames = (LPWSTR)((LPBYTE)lpCounterId + dwArraySize);
    lpHelpText     = (LPWSTR)((LPBYTE)lpCounterNames + dwCounterSize);

    // read counters into memory

    dwBufferSize = dwCounterSize;
    lWin32Status = RegQueryValueExW(hKeyNames,
                                    CounterNameBuffer,
                                    RESERVED,
                                    & dwValueType,
                                    (LPVOID) lpCounterNames,
                                    & dwBufferSize);
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = dwHelpSize;
    lWin32Status = RegQueryValueExW(hKeyNames,
                                    HelpNameBuffer,
                                    RESERVED,
                                    & dwValueType,
                                    (LPVOID)lpHelpText,
                                    & dwBufferSize);
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    // load counter array items

    dwLastCounter = 0;
    for (lpThisName = lpCounterNames; * lpThisName != L'\0'; lpThisName += (lstrlenW(lpThisName) + 1)) {
        // first string should be an integer (in decimal unicode digits)
        dwThisCounter = wcstoul(lpThisName, NULL, 10);

        // and load array element;
        if ((dwThisCounter > 0) && (dwThisCounter <= dwLastId)) {
            // point to corresponding counter name
            lpThisName                              += (lstrlenW(lpThisName) + 1);
            lpCounterId[dwThisCounter]               = lpThisName;
            pMachine->typePerfStrings[dwThisCounter] = STR_COUNTER;
            dwLastCounter                            = dwThisCounter;
        }
    }

    dwLastCounter = 0;
    for (lpThisName = lpHelpText; * lpThisName != L'\0'; lpThisName += (lstrlenW(lpThisName) + 1)) {
        // first string should be an integer (in decimal unicode digits)
        dwThisCounter = wcstoul(lpThisName, NULL, 10);

        // and load array element;
        if ((dwThisCounter > 0) && (dwThisCounter <= dwLastId)) {
            // point to corresponding counter name
            lpThisName                              += (lstrlenW(lpThisName) + 1);
            lpCounterId[dwThisCounter]               = lpThisName;
            pMachine->typePerfStrings[dwThisCounter] = STR_HELP;
            dwLastCounter                            = dwThisCounter;
        }
    }

    lpCounterId    = pMachine->sz009PerfStrings;
    lpCounterNames = (LPWSTR) ((LPBYTE) lpCounterId + dwArraySize);
    lpHelpText     = (LPWSTR) ((LPBYTE) lpCounterNames + dw009CounterSize);

    // read counters into memory
    dwBufferSize = dw009CounterSize;
    lWin32Status = RegQueryValueExW(hKey009Names,
                                    Counter009NameBuffer,
                                    RESERVED,
                                    & dwValueType,
                                    (LPVOID) lpCounterNames,
                                    & dwBufferSize);
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = dw009HelpSize;
    lWin32Status = RegQueryValueExW(hKey009Names,
                                    Help009NameBuffer,
                                    RESERVED,
                                    & dwValueType,
                                    (LPVOID) lpHelpText,
                                    & dwBufferSize);
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    for (lpThisName = lpCounterNames; * lpThisName != L'\0'; lpThisName += (lstrlenW(lpThisName) + 1)) {
        dwThisCounter = wcstoul(lpThisName, NULL, 10);
        if ((dwThisCounter > 0) && (dwThisCounter <= dwLastId)) {
            lpThisName                += (lstrlenW(lpThisName) + 1);
            lpCounterId[dwThisCounter] = lpThisName;
        }
    }

    for (lpThisName = lpHelpText; * lpThisName != L'\0'; lpThisName += (lstrlenW(lpThisName) + 1)) {
        dwThisCounter = wcstoul(lpThisName, NULL, 10);
        if ((dwThisCounter > 0) && (dwThisCounter <= dwLastId)) {
            lpThisName                += (lstrlenW(lpThisName) + 1);
            lpCounterId[dwThisCounter] = lpThisName;
        }
    }

    pMachine->dwLastPerfString = dwLastId;
    lpReturn                   = pMachine->szPerfStrings;

BNT_BAILOUT:
    G_FREE(CounterNameBuffer);
    G_FREE(lpValueNameString);
    G_FREE(lp009ValueNameString);

    if (hKeyValue != NULL && hKeyValue != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKeyValue);
    }
    if (hKey009Names != NULL && hKey009Names != INVALID_HANDLE_VALUE  && hKey009Names != hKeyNames
                             && hKey009Names != HKEY_PERFORMANCE_DATA && hKey009Names != HKEY_PERFORMANCE_TEXT) {
       RegCloseKey(hKey009Names);
    }
    if (hKeyNames != NULL && hKeyNames != INVALID_HANDLE_VALUE     && hKeyNames != HKEY_PERFORMANCE_DATA
                          && hKeyNames != HKEY_PERFORMANCE_NLSTEXT && hKeyNames != HKEY_PERFORMANCE_TEXT) {
        RegCloseKey(hKeyNames);
    }
    if (hKeyRegistry != NULL && hKeyRegistry != INVALID_HANDLE_VALUE && hKeyRegistry != HKEY_LOCAL_MACHINE) {
        RegCloseKey(hKeyRegistry);
    }

    if (lWin32Status != ERROR_SUCCESS && pMachine != NULL) {
        if (pMachine->sz009PerfStrings && pMachine->sz009PerfStrings != pMachine->szPerfStrings) {
            G_FREE(pMachine->sz009PerfStrings);
        }
        G_FREE(pMachine->szPerfStrings);
        pMachine->sz009PerfStrings = NULL;
        pMachine->szPerfStrings    = NULL;
        G_FREE(pMachine->typePerfStrings);
        pMachine->typePerfStrings = NULL;
        dwLastError = GetLastError();
    }
    return lpReturn;
}

#pragma warning ( disable : 4127 )
PPERF_OBJECT_TYPE
GetObjectDefByTitleIndex(
    PPERF_DATA_BLOCK pDataBlock,
    DWORD            ObjectTypeTitleIndex
)
{
    DWORD             NumTypeDef;
    PPERF_OBJECT_TYPE pObjectDef;
    PPERF_OBJECT_TYPE pReturnObject = NULL;
    BOOL              bContinue;

    __try {
        pObjectDef   = FirstObject(pDataBlock);
        NumTypeDef   = 0;
        bContinue    = (pObjectDef != NULL) ? TRUE : FALSE;

        while (bContinue) {
            if (pObjectDef->ObjectNameTitleIndex == ObjectTypeTitleIndex) {
                pReturnObject = pObjectDef;
                bContinue     = FALSE;
            }
            else {
                NumTypeDef ++;
                if (NumTypeDef < pDataBlock->NumObjectTypes) {
                    pObjectDef = NextObject(pDataBlock, pObjectDef);
                    //make sure next object is legit
                    if (pObjectDef == NULL) {
                        // looks like we ran off the end of the data buffer
                        bContinue = FALSE;
                    }
                    else if (pObjectDef->TotalByteLength == 0) {
                        // 0-length object buffer returned
                        bContinue = FALSE;
                    }
                }
                else {
                    // no more data objects in this data block
                    bContinue = FALSE;
                }
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pReturnObject = NULL;
    }
    return pReturnObject;
}

PPERF_OBJECT_TYPE
GetObjectDefByName(
    PPERF_DATA_BLOCK   pDataBlock,
    DWORD              dwLastNameIndex,
    LPCWSTR          * NameArray,
    LPCWSTR            szObjectName
)
{
    DWORD             NumTypeDef;
    PPERF_OBJECT_TYPE pReturnObject = NULL;
    PPERF_OBJECT_TYPE pObjectDef;
    BOOL              bContinue;

    __try {
        pObjectDef   = FirstObject(pDataBlock);
        NumTypeDef   = 0;
        bContinue    = (pObjectDef != NULL) ? TRUE : FALSE;
        while (bContinue) {
            if (pObjectDef->ObjectNameTitleIndex < dwLastNameIndex) {
                // look up name of object & compare
                if (lstrcmpiW(NameArray[pObjectDef->ObjectNameTitleIndex], szObjectName) == 0) {
                    pReturnObject = pObjectDef;
                    bContinue     = FALSE;
                }
            }
            if (bContinue) {
                NumTypeDef ++;
                if (NumTypeDef < pDataBlock->NumObjectTypes) {
                    pObjectDef = NextObject(pDataBlock, pObjectDef); // get next
                    //make sure next object is legit
                    if (pObjectDef == NULL) {
                        // looks like we ran off the end of the data buffer
                        bContinue = FALSE;
                    }
                    else if (pObjectDef->TotalByteLength == 0) {
                        // 0-length object buffer returned
                        bContinue = FALSE;
                    }
                }
                else {
                    // end of data block
                    bContinue = FALSE;
                }
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pReturnObject = NULL;
    }
    return pReturnObject;
}
#pragma warning ( default : 4127 )

PPERF_INSTANCE_DEFINITION
GetInstance(
    PPERF_OBJECT_TYPE pObjectDef,
    LONG              InstanceNumber
)
{
    PPERF_INSTANCE_DEFINITION pInstanceDef;
    PPERF_INSTANCE_DEFINITION pRtnInstance = NULL;
    LONG                      NumInstance;

    if (pObjectDef != NULL) {
        pInstanceDef = FirstInstance(pObjectDef);
        for (NumInstance = 0;
                pInstanceDef != NULL && pRtnInstance == NULL && NumInstance < pObjectDef->NumInstances;
                NumInstance ++) {
            if (InstanceNumber == NumInstance) {
                pRtnInstance = pInstanceDef;
            }
            else {
                pInstanceDef = NextInstance(pObjectDef, pInstanceDef);
            }
        }
    }
    return pRtnInstance;
}

PPERF_INSTANCE_DEFINITION
GetInstanceByUniqueId(
    PPERF_OBJECT_TYPE pObjectDef,
    LONG              InstanceUniqueId
)
{
    PPERF_INSTANCE_DEFINITION pInstanceDef = NULL;
    PPERF_INSTANCE_DEFINITION pRtnInstance = NULL;
    LONG                      NumInstance;

    if (pObjectDef != NULL) {
        pInstanceDef = FirstInstance(pObjectDef);
        for (NumInstance = 0;
                pInstanceDef != NULL && pRtnInstance == NULL && NumInstance < pObjectDef->NumInstances;
                NumInstance ++) {
            if (InstanceUniqueId == pInstanceDef->UniqueID) {
                pRtnInstance = pInstanceDef;
            }
            else {
                pInstanceDef = NextInstance(pObjectDef, pInstanceDef);
            }
        }
    }
    return pRtnInstance;
}

DWORD
GetAnsiInstanceName(
    PPERF_INSTANCE_DEFINITION   pInstance,
    LPWSTR                    * lpszInstance,
    DWORD                       dwCodePage
)
{
    LPSTR  szDest    = NULL;
    DWORD  dwLength  = 0;
    LPWSTR szSource  = (LPWSTR) GetInstanceName(pInstance);

    // the locale should be set here
    DBG_UNREFERENCED_PARAMETER(dwCodePage);

    if (szSource != NULL) {
        // pInstance->NameLength == the number of bytes (chars) in the string
        szDest = PdhiWideCharToMultiByte(_getmbcp(), szSource);
        if (szDest != NULL) {
            dwLength       = lstrlenA(szDest);
            * lpszInstance = (LPWSTR) szDest;
        }
    }
    return dwLength;
}

DWORD
GetUnicodeInstanceName(
    PPERF_INSTANCE_DEFINITION   pInstance,
    LPWSTR                    * lpszInstance
)
{
    LPWSTR   wszSource   = GetInstanceName(pInstance);
    DWORD    dwStrLength = 0;
    DWORD    dwLength    = 0;

    if (wszSource != NULL) {
        // pInstance->NameLength == length of string in BYTES so adjust to
        // number of wide characters here
        //
        if (lpszInstance != NULL) {
            * lpszInstance = NULL;
            dwLength = pInstance->NameLength;
            if (dwLength != 0) {
                dwStrLength = lstrlenW(wszSource) + 1;
                if (dwLength > dwStrLength * sizeof(WCHAR)) {
                    dwLength = dwStrLength * sizeof(WCHAR);
                    pInstance->NameLength = dwLength;
                }
                * lpszInstance = G_ALLOC(dwLength);
                if (* lpszInstance != NULL) {
                    StringCbCopyW(* lpszInstance, dwLength, wszSource);
                    dwLength = lstrlenW(wszSource);
                }
                else {
                    dwLength = 0;
                }
            }
        }
    }

    return dwLength; // just incase there's null's in the string
}

DWORD
GetInstanceNameStr(
    PPERF_INSTANCE_DEFINITION   pInstance,
    LPWSTR                    * lpszInstance,
    DWORD                       dwCodePage
)
{
    DWORD  dwCharSize;
    DWORD  dwLength = 0;

    if (pInstance != NULL) {
        if (lpszInstance != NULL) {
            * lpszInstance = NULL;
            if (dwCodePage > 0) {
                dwCharSize = sizeof(CHAR);
                dwLength   = GetAnsiInstanceName(pInstance, lpszInstance, dwCodePage);
            }
            else { // it's a UNICODE name
                dwCharSize = sizeof(WCHAR);
                dwLength   = GetUnicodeInstanceName(pInstance, lpszInstance);
            }
            // sanity check here...
            // the returned string length (in characters) plus the terminating NULL
            // should be the same as the specified length in bytes divided by the
            // character size. If not then the codepage and instance data type
            // don't line up so test that here
            if ((dwLength + 1) != (pInstance->NameLength / dwCharSize)) {
                // something isn't quite right so try the "other" type of string type
                G_FREE(* lpszInstance);
                * lpszInstance = NULL;
                if (dwCharSize == sizeof(CHAR)) {
                    // then we tried to read it as an ASCII string and that didn't work
                    // so try it as a UNICODE (if that doesn't work give up and return
                    // it any way.
                    dwLength = GetUnicodeInstanceName(pInstance, lpszInstance);
                }
                else if (dwCharSize == sizeof(WCHAR)) {
                    // then we tried to read it as a UNICODE string and that didn't work
                    // so try it as an ASCII string (if that doesn't work give up and return
                    // it any way.
                    dwLength = GetAnsiInstanceName (pInstance, lpszInstance, dwCodePage);
                }
            }
        } // else return buffer is null
    }
    else {
        // no instance def object is specified so return an empty string
        * lpszInstance = G_ALLOC(1 * sizeof(WCHAR));
    }
    return dwLength;
}

PPERF_INSTANCE_DEFINITION
GetInstanceByNameUsingParentTitleIndex(
    PPERF_DATA_BLOCK  pDataBlock,
    PPERF_OBJECT_TYPE pObjectDef,
    LPWSTR            pInstanceName,
    LPWSTR            pParentName,
    DWORD             dwIndex
)
{
    PPERF_OBJECT_TYPE          pParentObj;
    PPERF_INSTANCE_DEFINITION  pParentInst;
    PPERF_INSTANCE_DEFINITION  pInstanceDef;
    PPERF_INSTANCE_DEFINITION  pRtnInstance = NULL;
    LONG                       NumInstance;
    DWORD                      dwLocalIndex;
    DWORD                      dwInstanceNameLength;

    pInstanceDef = FirstInstance(pObjectDef);
    if (pInstanceDef != NULL) {
        dwLocalIndex         = dwIndex;
        dwInstanceNameLength = lstrlenW(pInstanceName);
        for (NumInstance = 0;
                        pRtnInstance == NULL && pInstanceDef != NULL && NumInstance < pObjectDef->NumInstances;
                        NumInstance ++) {
            if (IsMatchingInstance(pInstanceDef, pObjectDef->CodePage, pInstanceName, dwInstanceNameLength)) {
                // Instance name matches
                if (pParentName == NULL) {
                    // No parent, we're done if this is the right "copy"
                    if (dwLocalIndex == 0) {
                        pRtnInstance = pInstanceDef;
                    }
                    else {
                        -- dwLocalIndex;
                    }
                }
                else {
                    // Must match parent as well
                    pParentObj = GetObjectDefByTitleIndex(pDataBlock, pInstanceDef->ParentObjectTitleIndex);
                    if (pParentObj == NULL) {
                        // can't locate the parent, forget it
                        break;
                    }
                    else {
                        // Object type of parent found; now find parent
                        // instance
                        pParentInst = GetInstance(pParentObj, pInstanceDef->ParentObjectInstance);
                        if (pParentInst == NULL) {
                            // can't locate the parent instance, forget it
                            break;
                        }
                        else {
                            if (IsMatchingInstance (pParentInst, pParentObj->CodePage, pParentName, 0)) {
                                // Parent Instance Name matches that passed in
                                if (dwLocalIndex == 0) {
                                    pRtnInstance = pInstanceDef;
                                }
                                else {
                                    -- dwLocalIndex;
                                }
                            }
                        }
                    }
                }
            }
            if (pRtnInstance == NULL) {
                pInstanceDef = NextInstance(pObjectDef, pInstanceDef);
            }
        }
    }
    return pRtnInstance;
}

PPERF_INSTANCE_DEFINITION
GetInstanceByName(
    PPERF_DATA_BLOCK  pDataBlock,
    PPERF_OBJECT_TYPE pObjectDef,
    LPWSTR            pInstanceName,
    LPWSTR            pParentName,
    DWORD             dwIndex
)
{
    PPERF_OBJECT_TYPE         pParentObj;
    PPERF_INSTANCE_DEFINITION pParentInst;
    PPERF_INSTANCE_DEFINITION pInstanceDef;
    PPERF_INSTANCE_DEFINITION pRtnInstance = NULL;
    LONG                      NumInstance;
    DWORD                     dwLocalIndex;
    DWORD                     dwInstanceNameLength;

    pInstanceDef = FirstInstance(pObjectDef);
    if (pInstanceDef != NULL) {
        dwLocalIndex         = dwIndex;
        dwInstanceNameLength = lstrlenW(pInstanceName);
        for (NumInstance = 0;
                        pRtnInstance == NULL && pInstanceDef != NULL && NumInstance < pObjectDef->NumInstances;
                        NumInstance ++) {
            if (IsMatchingInstance (pInstanceDef, pObjectDef->CodePage, pInstanceName, dwInstanceNameLength)) {
                // Instance name matches
                if ((! pInstanceDef->ParentObjectTitleIndex ) || (pParentName == NULL)) {
                    // No parent, we're done
                    if (dwLocalIndex == 0) {
                        pRtnInstance = pInstanceDef;
                    }
                    else {
                        -- dwLocalIndex;
                    }
                }
                else {
                    // Must match parent as well
                    pParentObj = GetObjectDefByTitleIndex(pDataBlock, pInstanceDef->ParentObjectTitleIndex);
                    if (pParentObj == NULL) {
                        // if parent object is not found, 
                        // then exit and return NULL
                        break;
                    }
                    else {
                        // Object type of parent found; now find parent
                        // instance
                        pParentInst = GetInstance(pParentObj, pInstanceDef->ParentObjectInstance);
                        if (pParentInst != NULL) {
                            if (IsMatchingInstance (pParentInst, pParentObj->CodePage, pParentName, 0)) {
                                // Parent Instance Name matches that passed in
                                if (dwLocalIndex == 0) {
                                    pRtnInstance = pInstanceDef;
                                }
                                else {
                                    --dwLocalIndex;
                                }
                            }
                        }
                    }
                }
            }
            if (pRtnInstance == NULL) {
                pInstanceDef = NextInstance(pObjectDef, pInstanceDef);
            }
        }
    }
    return pRtnInstance;
}  // GetInstanceByName

PPERF_COUNTER_DEFINITION
GetCounterDefByName(
    PPERF_OBJECT_TYPE   pObject,
    DWORD               dwLastNameIndex,
    LPWSTR            * NameArray,
    LPWSTR              szCounterName
)
{
    DWORD                    NumTypeDef;
    PPERF_COUNTER_DEFINITION pThisCounter;
    PPERF_COUNTER_DEFINITION pRtnCounter = NULL;

    pThisCounter = FirstCounter(pObject);
    if (pThisCounter != NULL) {
        for (NumTypeDef = 0;
                        pRtnCounter == NULL && pThisCounter != NULL && NumTypeDef < pObject->NumCounters;
                        NumTypeDef ++) {
            if (pThisCounter->CounterNameTitleIndex > 0 && pThisCounter->CounterNameTitleIndex < dwLastNameIndex) {
                // look up name of counter & compare
                if (lstrcmpiW(NameArray[pThisCounter->CounterNameTitleIndex], szCounterName) == 0) {
                    pRtnCounter = pThisCounter;
                }
            }
            if (pRtnCounter == NULL) {
                pThisCounter = NextCounter(pObject, pThisCounter); // get next
            }
        }
    }
    return pRtnCounter;
}

PPERF_COUNTER_DEFINITION
GetCounterDefByTitleIndex(
    PPERF_OBJECT_TYPE pObjectDef,
    BOOL              bBaseCounterDef,
    DWORD             CounterTitleIndex
)
{
    DWORD                    NumCounters;
    PPERF_COUNTER_DEFINITION pCounterDef;
    PPERF_COUNTER_DEFINITION pRtnCounter = NULL;

    pCounterDef = FirstCounter(pObjectDef);
    if (pCounterDef != NULL) {
        for (NumCounters = 0;
                       pRtnCounter == NULL && pCounterDef != NULL && NumCounters < pObjectDef->NumCounters;
                       NumCounters ++) {
            if (pCounterDef->CounterNameTitleIndex == CounterTitleIndex) {
                if (bBaseCounterDef) {
                    // get next definition block
                    if (++ NumCounters < pObjectDef->NumCounters) {
                        // then it should be in there
                        pCounterDef = NextCounter(pObjectDef, pCounterDef);
                        if (pCounterDef) {
                            // make sure this is really a base counter
                            if (! (pCounterDef->CounterType & PERF_COUNTER_BASE)) {
                                // it's not and it should be so return NULL
                                pCounterDef = NULL;
                            }
                        }
                    }
                }
                pRtnCounter = pCounterDef;
            }
            if (pRtnCounter == NULL && pCounterDef != NULL) {
                pCounterDef = NextCounter(pObjectDef, pCounterDef);
            }
        }
    }
    return pRtnCounter;
}

#pragma warning ( disable : 4127 )
LONG
GetSystemPerfData(
    HKEY               hKeySystem,
    PPERF_DATA_BLOCK * ppPerfData,
    LPWSTR             szObjectList,
    BOOL               bCollectCostlyData
)
{  // GetSystemPerfData
    LONG             lError       = ERROR_SUCCESS;
    DWORD            Size;
    DWORD            Type         = 0;
    PPERF_DATA_BLOCK pCostlyPerfData;
    DWORD            CostlySize;
    LPDWORD          pdwSrc, pdwDest, pdwLast;
    FILETIME         ftStart, ftEnd;
    LONGLONG         ElapsedTime = 0;

    if (* ppPerfData == NULL) {
        * ppPerfData = G_ALLOC(INITIAL_SIZE);
        if (* ppPerfData == NULL) return PDH_MEMORY_ALLOCATION_FAILURE;
    }
    __try {
        while (TRUE) {
            Size   = (DWORD) G_SIZE(* ppPerfData);
            GetSystemTimeAsFileTime(& ftStart);
            lError = RegQueryValueExW(hKeySystem, szObjectList, RESERVED, & Type, (LPBYTE) * ppPerfData, & Size);
            GetSystemTimeAsFileTime(& ftEnd);
            ElapsedTime += (MAKELONGLONG(ftEnd.dwLowDateTime, ftEnd.dwHighDateTime)
                         -  MAKELONGLONG(ftStart.dwLowDateTime, ftStart.dwHighDateTime));
            if ((!lError) && (Size > 0) &&
                            ((* ppPerfData)->Signature[0] == (WCHAR) 'P') &&
                            ((* ppPerfData)->Signature[1] == (WCHAR) 'E') &&
                            ((* ppPerfData)->Signature[2] == (WCHAR) 'R') &&
                            ((* ppPerfData)->Signature[3] == (WCHAR) 'F')) {
                if (bCollectCostlyData) {
                    // collect the costly counters now
                    // the size available is that not used by the above call
                    CostlySize      = (DWORD) G_SIZE(* ppPerfData) - Size;
                    pCostlyPerfData = (PPERF_DATA_BLOCK) ((LPBYTE) (* ppPerfData) + Size);
                    lError = RegQueryValueExW(hKeySystem,
                                              cszCostly,
                                              RESERVED,
                                              & Type,
                                              (LPBYTE) pCostlyPerfData,
                                              & CostlySize);
                    if ((!lError) && (CostlySize > 0) &&
                                    (pCostlyPerfData->Signature[0] == (WCHAR) 'P') &&
                                    (pCostlyPerfData->Signature[1] == (WCHAR) 'E') &&
                                    (pCostlyPerfData->Signature[2] == (WCHAR) 'R') &&
                                    (pCostlyPerfData->Signature[3] == (WCHAR) 'F')) {
                        // update the header block
                        (* ppPerfData)->TotalByteLength += pCostlyPerfData->TotalByteLength
                                                         - pCostlyPerfData->HeaderLength;
                        (* ppPerfData)->NumObjectTypes  += pCostlyPerfData->NumObjectTypes;

                        // move the costly data to the end of the global data

                        pdwSrc  = (LPDWORD) ((LPBYTE) pCostlyPerfData + pCostlyPerfData->HeaderLength);
                        pdwDest = (LPDWORD) pCostlyPerfData ;
                        pdwLast = (LPDWORD) ((LPBYTE) pCostlyPerfData + pCostlyPerfData->TotalByteLength -
                                                                        pCostlyPerfData->HeaderLength);
                        while (pdwSrc < pdwLast) {* pdwDest ++ = * pdwSrc ++; }
                        lError = ERROR_SUCCESS;
                        break;
                    }
                }
                else {
                    lError = ERROR_SUCCESS;
                    break;
                }
            }

            if (lError == ERROR_MORE_DATA) {
                if (ElapsedTime > ((LONGLONG) ulPdhCollectTimeout)) {
                    lError = PDH_QUERY_PERF_DATA_TIMEOUT;
                    break;
                }
                else {
                    DWORD dwTmpSize = Size;
                    Size            = (DWORD) G_SIZE(* ppPerfData);
                    G_FREE (* ppPerfData);
                    * ppPerfData    = NULL;
                    Size           *= 2;
                    if (Size <= dwTmpSize) {
                        // Already overflow DWORD, no way for
                        // RegQueryValueEx() to succeed with size larger
                        // than DWORD. Abort.
                        lError = PDH_MEMORY_ALLOCATION_FAILURE;
                        break;
                    }
                    else {
                        * ppPerfData = G_ALLOC(Size);
                        if (* ppPerfData == NULL) {
                            lError = PDH_MEMORY_ALLOCATION_FAILURE;
                            break;
                        }
                    }
                }
            }
            else {
                break;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        lError = GetExceptionCode();
    }
    return lError;
}  // GetSystemPerfData
#pragma warning ( default : 4127 )

DWORD
GetFullInstanceNameStr(
    PPERF_DATA_BLOCK          pPerfData,
    PPERF_OBJECT_TYPE         pObjectDef,
    PPERF_INSTANCE_DEFINITION pInstanceDef,
    LPWSTR                    szInstanceName,
    DWORD                     dwInstanceName
)
{
    LPWSTR                    szInstanceNameString = NULL; 
    LPWSTR                    szParentNameString   = NULL;
    LPWSTR                    szFullInstance       = NULL;
    // compile instance name.
    // the instance name can either be just
    // the instance name itself or it can be
    // the concatenation of the parent instance,
    // a delimiting char (backslash) followed by
    // the instance name
    DWORD                     dwLength             = 0;
    PPERF_OBJECT_TYPE         pParentObjectDef;
    PPERF_INSTANCE_DEFINITION pParentInstanceDef;

    if (pInstanceDef->UniqueID == PERF_NO_UNIQUE_ID) {
        dwLength = GetInstanceNameStr(pInstanceDef, & szInstanceNameString, pObjectDef->CodePage);
    }
    else {
        // make a string out of the unique ID
        szInstanceNameString = G_ALLOC(MAX_PATH * sizeof(WCHAR));
        if (szInstanceNameString != NULL) {
            _ltow(pInstanceDef->UniqueID, szInstanceNameString, 10);
            dwLength = lstrlenW(szInstanceNameString);
        }
        else {
            dwLength = 0;
        }
    }
    if (dwLength > 0) {
        if (pInstanceDef->ParentObjectTitleIndex > 0) {
            // then add in parent instance name
            pParentObjectDef = GetObjectDefByTitleIndex(pPerfData, pInstanceDef->ParentObjectTitleIndex);
            if (pParentObjectDef != NULL) {
                pParentInstanceDef = GetInstance(pParentObjectDef, pInstanceDef->ParentObjectInstance);
                if (pParentInstanceDef != NULL) {
                    if (pParentInstanceDef->UniqueID == PERF_NO_UNIQUE_ID) {
                        dwLength += GetInstanceNameStr(pParentInstanceDef,
                                                       & szParentNameString,
                                                       pParentObjectDef->CodePage);
                    }
                    else {
                        szParentNameString = G_ALLOC(MAX_PATH * sizeof(WCHAR));
                        if (szParentNameString != NULL) {
                            // make a string out of the unique ID
                            _ltow(pParentInstanceDef->UniqueID, szParentNameString, 10);
                            dwLength += lstrlenW(szParentNameString);
                        }
                    }
                    StringCchPrintfW(szInstanceName, dwInstanceName, L"%ws%ws%ws",
                                    szParentNameString, cszSlash, szInstanceNameString);
                    dwLength += 1; // cszSlash
                }
                else {
                    StringCchCopyW(szInstanceName, dwInstanceName, szInstanceNameString);
                }
            }
            else {
                StringCchCopyW(szInstanceName, dwInstanceName, szInstanceNameString);
            }
        }
        else {
            StringCchCopyW(szInstanceName, dwInstanceName, szInstanceNameString);
        }
    }
    G_FREE(szParentNameString);
    G_FREE(szInstanceNameString);
    return dwLength;
}

#if DBG
#define DEBUG_BUFFER_LENGTH 1024
UCHAR   PdhDebugBuffer[DEBUG_BUFFER_LENGTH];
// debug level:
//  5 = memory allocs  (if _VALIDATE_PDH_MEM_ALLOCS defined) and all 4's
//  4 = function entry and exits (w/ status codes) and all 3's
//  3 = Not impl
//  2 = Not impl
//  1 = Not impl
//  0 = No messages

ULONG   pdhDebugLevel = 0;

VOID
__cdecl
PdhDebugPrint(
    ULONG DebugPrintLevel,
    char * DebugMessage,
    ...
    )
{
    va_list ap;

    if ((DebugPrintLevel <= (pdhDebugLevel & 0x0000ffff)) || ((1 << (DebugPrintLevel + 15)) & pdhDebugLevel)) {
        DbgPrint("PDH(%05d,%05d)::", GetCurrentProcessId(), GetCurrentThreadId());
    }
    else return;

    va_start(ap, DebugMessage);
    StringCchVPrintfA((PCHAR) PdhDebugBuffer, DEBUG_BUFFER_LENGTH, DebugMessage, ap);
    DbgPrint((PCHAR) PdhDebugBuffer);
    va_end(ap);

}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhdll\perfutil.c ===
/*++
Copyright (C) 1996-1999 Microsoft Corporation

Module Name:
    perfutil.c

Abstract:
    Performance registry interface functions
--*/

#include <windows.h>
#include "strsafe.h"
#include <pdh.h>
#include "pdhitype.h"
#include "pdhidef.h"
#include "perfdata.h"
#include "pdhmsg.h"
#include "strings.h"

DWORD
PdhiMakePerfLangId(
    LANGID  lID,
    LPWSTR  szBuffer
);

PPERF_MACHINE
PdhiAddNewMachine(
    PPERF_MACHINE   pLastMachine,
    LPWSTR          szMachineName
);

PPERF_MACHINE pFirstMachine = NULL;

PDH_STATUS
ConnectMachine(
    PPERF_MACHINE pThisMachine
)
{
    PDH_STATUS  pdhStatus       = ERROR_SUCCESS;
    LONG        lStatus         = ERROR_SUCCESS;
    FILETIME    CurrentFileTime;
    LONGLONG    llCurrentTime;
    WCHAR       szOsVer[OS_VER_SIZE];
    HKEY        hKeyRemMachine;
    HKEY        hKeyRemCurrentVersion;
    DWORD       dwBufSize;
    DWORD       dwType;
    BOOL        bUpdateRetryTime = FALSE;
    DWORD       dwReconnecting;

    if (pThisMachine == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    } else {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pThisMachine->hMutex);
    }

    if (pdhStatus == ERROR_SUCCESS) {
    // connect to system's performance registry
        if (lstrcmpiW(pThisMachine->szName, szStaticLocalMachineName) == 0) {
            // only one thread at a time can try to connect to a machine.

            pThisMachine->dwRefCount++;

            // assign default OS version
            // assume NT4 unless found otherwise
            StringCchCopyW(pThisMachine->szOsVer, OS_VER_SIZE, (LPCWSTR) L"4.0");   
            // this is the local machine so use the local reg key
            pThisMachine->hKeyPerformanceData = HKEY_PERFORMANCE_DATA;

            // look up the OS version and save it
            lStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE, cszCurrentVersionKey, 0L, KEY_READ, & hKeyRemCurrentVersion);
            if (lStatus == ERROR_SUCCESS) {
                dwType=0;
                dwBufSize = OS_VER_SIZE * sizeof(WCHAR);
                lStatus = RegQueryValueExW(hKeyRemCurrentVersion,
                                           cszCurrentVersionValueName,
                                           0L,
                                           & dwType,
                                           (LPBYTE) szOsVer,
                                           & dwBufSize);
                if ((lStatus == ERROR_SUCCESS) && (dwType == REG_SZ)) {
                    StringCchCopyW(pThisMachine->szOsVer, OS_VER_SIZE, szOsVer);
                }
                RegCloseKey(hKeyRemCurrentVersion);
            }
        }
        else {
            // now try to connect if the retry timeout has elapzed
            GetSystemTimeAsFileTime(& CurrentFileTime);
            llCurrentTime  = MAKELONGLONG(CurrentFileTime.dwLowDateTime, CurrentFileTime.dwHighDateTime);
            dwReconnecting = (DWORD)InterlockedCompareExchange((PLONG) & pThisMachine->dwRetryFlags, TRUE, FALSE);

            if (! dwReconnecting) {
               if ((pThisMachine->llRetryTime == 0) || (pThisMachine->llRetryTime <= llCurrentTime)) {
                    // only one thread at a time can try to connect to a machine.

                    pThisMachine->dwRefCount ++;
                    bUpdateRetryTime = TRUE; // only update after an attempt has been made

                    __try {
                        // close any open keys
                        if (pThisMachine->hKeyPerformanceData != NULL) {
                            RegCloseKey(pThisMachine->hKeyPerformanceData);
                            pThisMachine->hKeyPerformanceData = NULL;
                        }
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        lStatus = GetExceptionCode();
                    }

                    if (lStatus != ERROR_SUCCESS) {
                        pThisMachine->hKeyPerformanceData = NULL;
                    }
                    else {
                        // get OS version of remote machine
                        lStatus = RegConnectRegistryW(pThisMachine->szName,
                                                      HKEY_LOCAL_MACHINE,
                                                      & hKeyRemMachine);
                        if (lStatus == ERROR_SUCCESS) {
                            // look up the OS version and save it
                            lStatus = RegOpenKeyExW(hKeyRemMachine,
                                                    cszCurrentVersionKey,
                                                    0L,
                                                    KEY_READ,
                                                    & hKeyRemCurrentVersion);
                            if (lStatus == ERROR_SUCCESS) {
                                dwType=0;
                                dwBufSize = OS_VER_SIZE * sizeof(WCHAR);
                                lStatus = RegQueryValueExW(hKeyRemCurrentVersion,
                                                           cszCurrentVersionValueName,
                                                           0L,
                                                           & dwType,
                                                           (LPBYTE) szOsVer,
                                                           & dwBufSize);
                                if ((lStatus == ERROR_SUCCESS) && (dwType == REG_SZ)) {
                                    StringCchCopyW(pThisMachine->szOsVer, OS_VER_SIZE, szOsVer);
                                }
                                RegCloseKey(hKeyRemCurrentVersion);
                            }
                            RegCloseKey(hKeyRemMachine);
                        }
                    }

                    if (lStatus == ERROR_SUCCESS) {
                        __try {
                            // Connect to remote registry
                            lStatus = RegConnectRegistryW(pThisMachine->szName,
                                                          HKEY_PERFORMANCE_DATA,
                                                          & pThisMachine->hKeyPerformanceData);
                        }
                        __except (EXCEPTION_EXECUTE_HANDLER) {
                            lStatus = GetExceptionCode();
                        }
                    } // else pass error through
                }
                else {
                   // not time to reconnect yet so save the old status and 
                   // clear the registry key
                    pThisMachine->hKeyPerformanceData = NULL;
                    lStatus                           = pThisMachine->dwStatus;
                }
                 // clear the reconnecting flag
                InterlockedExchange((LONG *) & pThisMachine->dwRetryFlags, FALSE);
            }
            else {
                // some other thread is trying to connect
                pdhStatus = PDH_CANNOT_CONNECT_MACHINE;
                goto Cleanup;
            }
        }

        if ((pThisMachine->hKeyPerformanceData != NULL) && (pThisMachine->dwRetryFlags == 0)) {
            // successfully connected to computer's registry, so
            // get the performance names from that computer and cache them
    /*
            the shortcut of mapping local strings cannot be used reliably until
            more synchronization of the mapped file is implemented. Just Mapping
            to the file and not locking it or checking for updates leaves it
            vulnerable to the mapped file being changed by an external program 
            and invalidating the pointer table built by the BuildLocalNameTable
            function.

            Until this synchronization and locking is implemented, the 
            BuildLocalNameTable function should not be used.
    */
            if (pThisMachine->hKeyPerformanceData != HKEY_PERFORMANCE_DATA) {
                if (pThisMachine->szPerfStrings != NULL) {
                    // reload the perf strings, incase new ones have been
                    // installed
                    if (pThisMachine->sz009PerfStrings != NULL
                                    && pThisMachine->sz009PerfStrings != pThisMachine->szPerfStrings) {
                        G_FREE(pThisMachine->sz009PerfStrings);
                    }
                    G_FREE(pThisMachine->typePerfStrings);
                    G_FREE(pThisMachine->szPerfStrings);
                    pThisMachine->sz009PerfStrings = NULL;
                    pThisMachine->typePerfStrings  = NULL;
                    pThisMachine->szPerfStrings    = NULL;
                }
                BuildNameTable(pThisMachine->szName, GetUserDefaultUILanguage(), pThisMachine);
                if (pThisMachine->szPerfStrings == NULL) {
                    BuildNameTable(pThisMachine->szName, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), pThisMachine);
                }
            }
            else {
                if (pThisMachine->szPerfStrings != NULL) {
                    // reload the perf strings, incase new ones have been
                    // installed
                    if (pThisMachine->sz009PerfStrings != NULL
                                    && pThisMachine->sz009PerfStrings != pThisMachine->szPerfStrings) {
                        G_FREE(pThisMachine->sz009PerfStrings);
                    }
                    G_FREE(pThisMachine->typePerfStrings);
                    G_FREE(pThisMachine->szPerfStrings);
                    pThisMachine->sz009PerfStrings = NULL;
                    pThisMachine->typePerfStrings  = NULL;
                    pThisMachine->szPerfStrings    = NULL;
                }
                BuildNameTable(NULL, GetUserDefaultUILanguage(), pThisMachine);
                if (pThisMachine->szPerfStrings == NULL) {
                    BuildNameTable(NULL, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), pThisMachine);
                }
                pThisMachine->pLocalNameInfo = NULL;
            }

            if (pThisMachine->szPerfStrings != NULL) {
                pdhStatus              = ERROR_SUCCESS;
                pThisMachine->dwStatus = ERROR_SUCCESS;
            }
            else {
                // unable to read system counter name strings
                pdhStatus                      = PDH_CANNOT_READ_NAME_STRINGS;
                ZeroMemory(& pThisMachine->LastStringUpdateTime, sizeof(pThisMachine->LastStringUpdateTime));
                pThisMachine->dwLastPerfString = 0;
                pThisMachine->dwStatus         = PDH_CSTATUS_NO_MACHINE;
            }
        }
        else {
            // unable to connect to the specified machine
            pdhStatus = PDH_CANNOT_CONNECT_MACHINE;
            // Set error to either 
            //  "PDH_CSTATUS_NO_MACHINE" if no connection could be made
            // or 
            //  PDH_ACCESS_DENIED if ERROR_ACCESS_DENIED status is returned
            // since if ERROR_ACCESS_DENIED is returned, then reconnection will
            // probably be futile.
            if ((lStatus == ERROR_ACCESS_DENIED) || (lStatus == PDH_ACCESS_DENIED)) {
                pThisMachine->dwStatus = PDH_ACCESS_DENIED;
            }
            else {
                pThisMachine->dwStatus = PDH_CSTATUS_NO_MACHINE;
            }
        }

        if (pdhStatus != ERROR_SUCCESS) {
            if (bUpdateRetryTime) {
                // this attempt didn't work so reset retry counter  to
                // wait some more for the machine to come back up.
                GetSystemTimeAsFileTime(& CurrentFileTime);
                llCurrentTime  = MAKELONGLONG(CurrentFileTime.dwLowDateTime, CurrentFileTime.dwHighDateTime);
                pThisMachine->llRetryTime = llCurrentTime;
                if (pThisMachine->dwStatus != PDH_ACCESS_DENIED) {
                    pThisMachine->llRetryTime += llRemoteRetryTime;
                }
            }
        }
        else {
            // clear the retry counter to allow function calls
            pThisMachine->llRetryTime = 0;
        }
        pThisMachine->dwRefCount --;
        RELEASE_MUTEX(pThisMachine->hMutex);
    }

Cleanup:
    return pdhStatus;
}

PPERF_MACHINE
PdhiAddNewMachine(
    PPERF_MACHINE pLastMachine,
    LPWSTR        szMachineName
)
{
    PPERF_MACHINE   pNewMachine   = NULL;
    LPWSTR          szNameBuffer  = NULL;
    LPWSTR          szIdList      = NULL;
    DWORD           dwNameSize    = 0;
    BOOL            bUseLocalName = TRUE;

    // reset the last error value
    SetLastError(ERROR_SUCCESS);

    if (szMachineName != NULL) {
        if (* szMachineName != L'\0') {
            bUseLocalName = FALSE;
        }
    }

    if (bUseLocalName) {
        dwNameSize = lstrlenW(szStaticLocalMachineName) + 1;
    } else {
        dwNameSize = lstrlenW(szMachineName) + 1;
    }
    pNewMachine = (PPERF_MACHINE) G_ALLOC(sizeof(PERF_MACHINE) + SMALL_BUFFER_SIZE + (sizeof(WCHAR) * dwNameSize));
    if  (pNewMachine != NULL) {
        szIdList     = (LPWSTR) ((LPBYTE) pNewMachine + sizeof(PERF_MACHINE));
        szNameBuffer = (LPWSTR) ((LPBYTE) szIdList + SMALL_BUFFER_SIZE);

        // initialize the new buffer
        pNewMachine->hKeyPerformanceData = NULL;
        pNewMachine->pLocalNameInfo      = NULL;
        pNewMachine->szName              = szNameBuffer;
        if (bUseLocalName) {
            StringCchCopyW(pNewMachine->szName, dwNameSize, szStaticLocalMachineName);
        }
        else {
            StringCchCopyW(pNewMachine->szName, dwNameSize, szMachineName);
        }

        pNewMachine->pSystemPerfData  = NULL;
        pNewMachine->szPerfStrings    = NULL;
        pNewMachine->sz009PerfStrings = NULL;
        pNewMachine->typePerfStrings  = NULL;
        pNewMachine->dwLastPerfString = 0;
        pNewMachine->dwRefCount       = 0;
        pNewMachine->szQueryObjects   = szIdList;
        pNewMachine->dwStatus         = PDH_CSTATUS_NO_MACHINE; // not connected yet
        pNewMachine->llRetryTime      = 1;   // retry connection immediately
        pNewMachine->dwRetryFlags     = 0;   // Not attempting a connection.
        pNewMachine->dwMachineFlags   = 0;
        pNewMachine->hMutex           = CreateMutex(NULL, FALSE, NULL);

        // everything went OK so far so add this entry to the list
        if (pLastMachine != NULL) {
            pNewMachine->pNext        = pLastMachine->pNext;
            pLastMachine->pNext       = pNewMachine;
            pNewMachine->pPrev        = pLastMachine;
            pNewMachine->pNext->pPrev = pNewMachine;
        }
        else {
            // this is the first item in the list so it
            // points to itself
            pNewMachine->pNext = pNewMachine;
            pNewMachine->pPrev = pNewMachine;
        }
    }
    else {
        // unable to allocate machine data memory
        SetLastError(PDH_MEMORY_ALLOCATION_FAILURE);
    }

    return pNewMachine;
}

PPERF_MACHINE
GetMachine(
    LPWSTR  szMachineName,
    DWORD   dwIndex,
    DWORD   dwFlags
)
{
    PPERF_MACHINE   pThisMachine  = NULL;
    PPERF_MACHINE   pLastMachine;
    BOOL            bFound        = FALSE;
    LPWSTR          szFnMachineName;
    BOOL            bNew          = FALSE; // true if this is a new machine to the list
    BOOL            bUseLocalName = TRUE;
    DWORD           dwLocalStatus = ERROR_SUCCESS;
    WCHAR           wszObject[MAX_PATH];

    // reset the last error value
    SetLastError(ERROR_SUCCESS);

    if (WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex) == ERROR_SUCCESS) {
        if (szMachineName != NULL) {
            if (* szMachineName != L'\0') {
                bUseLocalName = FALSE;
            }
        }
        if (bUseLocalName) {
            szFnMachineName = szStaticLocalMachineName;
        }
        else {
            szFnMachineName = szMachineName;
        }

        // walk down list to find this machine

        pThisMachine = pFirstMachine;
        pLastMachine = NULL;

        // walk around entire list
        if (pThisMachine != NULL) {
            do {
                // walk down the list and look for a match
                if (lstrcmpiW(szFnMachineName, pThisMachine->szName) != 0) {
                    pLastMachine = pThisMachine;
                    pThisMachine = pThisMachine->pNext;
                }
                else {
                    bFound = TRUE;
                    break;
                }
            }
            while (pThisMachine != pFirstMachine);
        }
        // if thismachine == the first machine, then we couldn't find a match in
        // the list, if this machine is NULL, then there is no list
        if (! bFound) {
            // then this machine was not found so add it.
            pThisMachine = PdhiAddNewMachine(pLastMachine, szFnMachineName);
            if (pThisMachine != NULL) {
                bNew = TRUE;
                if (pFirstMachine == NULL) {
                    // then update the first pointer
                    pFirstMachine = pThisMachine;
                }
            }
            else {
                dwLocalStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }

        if (dwLocalStatus == ERROR_SUCCESS) {
            dwLocalStatus = WAIT_FOR_AND_LOCK_MUTEX(pThisMachine->hMutex);
        }
        if (dwLocalStatus == ERROR_SUCCESS) {
            if (! (dwFlags & PDH_GM_UPDATE_PERFNAME_ONLY)) {
                if (dwFlags & PDH_GM_UPDATE_PERFDATA) {
                    pThisMachine->dwObjectId = dwIndex;
                    pThisMachine->dwThreadId = GetCurrentThreadId();
                }
                else if (pThisMachine->dwThreadId != GetCurrentThreadId()) {
                    dwFlags                 |= PDH_GM_UPDATE_PERFDATA;
                    pThisMachine->dwThreadId = GetCurrentThreadId();
                    pThisMachine->dwObjectId = dwIndex;
                }
                else if (pThisMachine->pSystemPerfData == NULL) {
                    dwFlags                 |= PDH_GM_UPDATE_PERFDATA;
                    pThisMachine->dwObjectId = dwIndex;
                }
                else if (pThisMachine->dwObjectId != 0 && pThisMachine->dwObjectId != dwIndex) {
                    dwFlags                 |= PDH_GM_UPDATE_PERFDATA;
                    pThisMachine->dwObjectId = dwIndex;
                }
            }

            if ((! bFound) || (dwFlags & PDH_GM_UPDATE_PERFDATA) || (dwFlags & PDH_GM_UPDATE_NAME)
                           || (pThisMachine->dwStatus != ERROR_SUCCESS)) {
                // then this is a new machine or the caller wants the data refreshed or the machine
                // has an entry, but is not yet on line first try to connect to the machine
                // the call to ConnectMachine updates the machine status so there's no need to keep it here.

                BOOL bUpdateName     = TRUE;

                if (! (dwFlags & PDH_GM_UPDATE_NAME)) {
                    if (pThisMachine->szPerfStrings != NULL && pThisMachine->typePerfStrings != NULL) {
                        // No need to update performance name/explain strings, assume that they are OK.
                        //
                        bUpdateName = FALSE;
                    }
                }
                if (bUpdateName || pThisMachine->dwStatus != ERROR_SUCCESS) {
                    G_FREE(pThisMachine->pSystemPerfData);
                    pThisMachine->pSystemPerfData = NULL;
                    dwLocalStatus = ConnectMachine(pThisMachine);
                }
                if (dwLocalStatus != ERROR_SUCCESS) {
                    dwLocalStatus = pThisMachine->dwStatus;
                }
                else if (! (dwFlags & PDH_GM_UPDATE_PERFNAME_ONLY)) {
                    // connected to the machine so
                    // then lock access to it
                    // the caller of this function must release the mutex

                    if (dwFlags & PDH_GM_UPDATE_PERFDATA) {
                        // get the current system counter info
                        ZeroMemory(wszObject, MAX_PATH * sizeof(WCHAR));
                        if (pThisMachine->dwObjectId == 0) {
                            StringCchCopyW(wszObject, MAX_PATH, (LPWSTR) cszGlobal);
                        }
                        else {
                            StringCchPrintfW(wszObject, MAX_PATH, L"%d", pThisMachine->dwObjectId);
                        }
                        pThisMachine->dwStatus = GetSystemPerfData(
                                        pThisMachine->hKeyPerformanceData,
                                        & pThisMachine->pSystemPerfData,
                                        wszObject,
                                        (BOOL) (dwFlags & PDH_GM_READ_COSTLY_DATA)
                            );
                        if ((dwFlags & PDH_GM_READ_COSTLY_DATA) && (pThisMachine->dwStatus == ERROR_SUCCESS)) {
                            pThisMachine->dwMachineFlags |= PDHIPM_FLAGS_HAVE_COSTLY;
                        }
                        else {
                            pThisMachine->dwMachineFlags &= ~PDHIPM_FLAGS_HAVE_COSTLY;
                        }
                        dwLocalStatus = pThisMachine->dwStatus;
                    }
                }
            }
        }
        else {
            pThisMachine  = NULL;
            dwLocalStatus = WAIT_TIMEOUT;
        }

        if (pThisMachine != NULL) {
            // machine found so bump the ref count
            // NOTE!!! the caller must release this!!!
            pThisMachine->dwRefCount ++;
        }

        // at this point if pThisMachine is NULL then it was not found, nor
        // could it be added otherwise it is pointing to the matching machine
        // structure

        RELEASE_MUTEX(hPdhDataMutex);
    }
    else {
        dwLocalStatus = WAIT_TIMEOUT;
    }

    if (dwLocalStatus != ERROR_SUCCESS) {
        SetLastError(dwLocalStatus);
    }
    return pThisMachine;
}

BOOL
FreeMachine(
    PPERF_MACHINE pMachine,
    BOOL          bForceRelease,
    BOOL          bProcessExit
)
{
    PPERF_MACHINE pPrev;
    PPERF_MACHINE pNext;
    HANDLE        hMutex;

    // unlink if this isn't the only one in the list

    if ((!bForceRelease) && (pMachine->dwRefCount)) return FALSE;

    hMutex = pMachine->hMutex;
    if (WAIT_FOR_AND_LOCK_MUTEX (hMutex) != ERROR_SUCCESS) {
        SetLastError(WAIT_TIMEOUT);
        return FALSE;
    }

    pPrev = pMachine->pPrev;
    pNext = pMachine->pNext;

    if ((pPrev != pMachine) && (pNext != pMachine)) {
        // this is not the only entry in the list
        pPrev->pNext = pNext;
        pNext->pPrev = pPrev;
        if (pMachine == pFirstMachine) {
            // then we are deleting the first one in the list so
            // update the list head to point to the next one in line
            pFirstMachine = pNext;
        }
    }
    else {
        // this is the only entry so clear the head pointer
        pFirstMachine = NULL;
    }

    // now free all allocated memory

    G_FREE(pMachine->pSystemPerfData);
    G_FREE(pMachine->typePerfStrings);
    if (pMachine->sz009PerfStrings != NULL && pMachine->sz009PerfStrings != pMachine->szPerfStrings) {
        G_FREE(pMachine->sz009PerfStrings);
    }
    G_FREE(pMachine->szPerfStrings);

    // close key
    if (pMachine->hKeyPerformanceData != NULL) {
        if ((! bProcessExit) || pMachine->hKeyPerformanceData != HKEY_PERFORMANCE_DATA) {
            RegCloseKey(pMachine->hKeyPerformanceData);
        }
        pMachine->hKeyPerformanceData = NULL;
    }

    // free memory block
    G_FREE(pMachine);

    // release and close mutex

    RELEASE_MUTEX(hMutex);

    if (hMutex != NULL) {
        CloseHandle(hMutex);
    }

    return TRUE;
}

BOOL
FreeAllMachines (
    BOOL bProcessExit
)
{
    PPERF_MACHINE pThisMachine;

    // free any machines in the machine list
    if (pFirstMachine != NULL) {
        if (WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex) == ERROR_SUCCESS) {
            pThisMachine = pFirstMachine;
            while (pFirstMachine != pFirstMachine->pNext) {
                // delete from list
                // the deletion routine updates the prev pointer as it
                // removes the specified entry.
                FreeMachine(pThisMachine->pPrev, TRUE, bProcessExit);
                if (pFirstMachine == NULL) break;
            }
            // remove last query
            if (pFirstMachine) {
                FreeMachine(pFirstMachine, TRUE, bProcessExit);
            }
            pFirstMachine = NULL;
            RELEASE_MUTEX (hPdhDataMutex);
        }
        else {
            SetLastError (WAIT_TIMEOUT);
            return FALSE;
        }
    }
    return TRUE;

}

DWORD
GetObjectId(
    PPERF_MACHINE   pMachine,
    LPWSTR          szObjectName,
    BOOL          * bInstances
)
{
    PPERF_OBJECT_TYPE pObject    = NULL;
    DWORD             dwIndex    = 2;
    DWORD             dwRtnIndex = (DWORD) -1;
    LPWSTR            szName;
    WCHAR             szIndex[MAX_PATH];
    BOOL              bName      = TRUE;
    BOOL              bCheck;

    if (pMachine->szPerfStrings == NULL || dwIndex > pMachine->dwLastPerfString) return dwRtnIndex;

    while (dwRtnIndex == (DWORD) -1) {
        bCheck = TRUE;
        if (bName) {
            szName = pMachine->szPerfStrings[dwIndex];
            bCheck = (szName != NULL) ? TRUE : FALSE;
            if (bCheck) bCheck = (lstrcmpiW(szName, (LPWSTR) szObjectName) == 0) ? TRUE : FALSE;
        }

        if (bCheck) {
            if (pMachine->dwStatus != ERROR_SUCCESS) {
                bCheck = TRUE;
            }
            else if (pMachine->dwThreadId != GetCurrentThreadId()) {
                bCheck = TRUE;
            }
            else if (pMachine->pSystemPerfData == NULL) {
                bCheck = TRUE;
            }
            else if (pMachine->dwObjectId != 0 && pMachine->dwObjectId != dwIndex) {
                bCheck = TRUE;
            }
            else {
                bCheck = FALSE;
            }

            if (bCheck) {
                ZeroMemory(szIndex, MAX_PATH * sizeof(WCHAR));
                StringCchPrintfW(szIndex, MAX_PATH, L"%d", dwIndex);
                pMachine->dwStatus = GetSystemPerfData(
                                pMachine->hKeyPerformanceData, & pMachine->pSystemPerfData, szIndex, FALSE);
                pMachine->dwThreadId = GetCurrentThreadId();
                pMachine->dwObjectId = dwIndex;
            }
            if (pMachine->dwStatus == ERROR_SUCCESS) {
                pObject = GetObjectDefByTitleIndex(pMachine->pSystemPerfData, dwIndex);
                if (pObject != NULL) {
                    LPCWSTR szTmpObjectName = PdhiLookupPerfNameByIndex(pMachine, pObject->ObjectNameTitleIndex);
                    TRACE((PDH_DBG_TRACE_INFO),
                          (__LINE__,
                           PDH_PERFUTIL,
                           ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                           ERROR_SUCCESS,
                           TRACE_WSTR(szObjectName),
                           TRACE_WSTR(szTmpObjectName),
                           TRACE_DWORD(pObject->ObjectNameTitleIndex),
                           TRACE_DWORD(pObject->ObjectHelpTitleIndex),
                           TRACE_DWORD(pObject->NumCounters),
                           TRACE_DWORD(pObject->DefaultCounter),
                           TRACE_DWORD(pObject->NumInstances),
                           NULL));
                    if (bInstances != NULL) {
                        * bInstances = (pObject->NumInstances != PERF_NO_INSTANCES ? TRUE : FALSE);
                    }
                    dwRtnIndex           = dwIndex;
                    break;
                }
            }
        }

        if (! bName) {
            break;
        }
        else if (dwIndex >= pMachine->dwLastPerfString) {
            dwIndex = wcstoul(szObjectName, NULL, 10);
            bName   = FALSE;
            if (dwIndex == 0) break;
        }
        else {
            dwIndex += 2;
            if (dwIndex > pMachine->dwLastPerfString) {
                dwIndex = wcstoul(szObjectName, NULL, 10);
                bName   = FALSE;
                if (dwIndex == 0) break;
            }
        }
    }

    return dwRtnIndex;
}

DWORD
GetCounterId (
    PPERF_MACHINE pMachine,
    DWORD         dwObjectId,
    LPWSTR        szCounterName
)
{
    PPERF_OBJECT_TYPE        pObject;
    PPERF_COUNTER_DEFINITION pCounter;
    DWORD                    dwCounterTitle = (DWORD) -1;

    pObject = GetObjectDefByTitleIndex(pMachine->pSystemPerfData, dwObjectId);
    if (pObject != NULL) {
        pCounter = GetCounterDefByName(pObject, pMachine->dwLastPerfString, pMachine->szPerfStrings, szCounterName);
        if (pCounter != NULL) {
            // update counter name string
            LPCWSTR szTmpCounterName = PdhiLookupPerfNameByIndex(pMachine, pCounter->CounterNameTitleIndex);
            TRACE((PDH_DBG_TRACE_INFO),
                  (__LINE__,
                   PDH_PERFUTIL,
                   ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2)
                                             | ARG_DEF(ARG_TYPE_ULONGX, 6),
                   ERROR_SUCCESS,
                   TRACE_WSTR(szCounterName),
                   TRACE_WSTR(szTmpCounterName),
                   TRACE_DWORD(dwObjectId),
                   TRACE_DWORD(pCounter->CounterNameTitleIndex),
                   TRACE_DWORD(pCounter->CounterHelpTitleIndex),
                   TRACE_DWORD(pCounter->CounterType),
                   TRACE_DWORD(pCounter->CounterSize),
                   TRACE_DWORD(pCounter->CounterOffset),
                   NULL));
            dwCounterTitle = pCounter->CounterNameTitleIndex;
        }
        else {
            dwCounterTitle = wcstoul(szCounterName, NULL, 10);
            if (dwCounterTitle == 0) dwCounterTitle = (DWORD) -1;
        }
    }
    return dwCounterTitle;
}

BOOL
InitPerflibCounterInfo(
    PPDHI_COUNTER   pCounter
)
/*++
Routine Description:
    Initializes the perflib related fields of the counter structure

Arguments:
    IN      PPDHI_COUNTER   pCounter
        pointer to the counter structure to initialize

Return Value:
    TRUE
--*/
{
    PPERF_OBJECT_TYPE        pPerfObject    = NULL;
    PPERF_COUNTER_DEFINITION pPerfCounter   = NULL;

    if (pCounter->pQMachine->pMachine == NULL) {
        pCounter->ThisValue.CStatus = PDH_CSTATUS_NO_MACHINE;
        return FALSE;
    } else if (pCounter->pQMachine->pMachine->dwStatus != ERROR_SUCCESS) {
        // machine not initialized
        return FALSE;
    }

    // get perf object definition from system data structure
    pPerfObject = GetObjectDefByTitleIndex (
        pCounter->pQMachine->pMachine->pSystemPerfData,
        pCounter->plCounterInfo.dwObjectId);

    if (pPerfObject != NULL) {
        // object was found now look up counter definition
        pPerfCounter = GetCounterDefByTitleIndex (pPerfObject, 0,
            pCounter->plCounterInfo.dwCounterId);
        if (pPerfCounter != NULL) {
            // get system perf data info
            // (pack into a DWORD)
            pCounter->CVersion = pCounter->pQMachine->pMachine->pSystemPerfData->Version;
            pCounter->CVersion &= 0x0000FFFF;
            pCounter->CVersion <<= 16;
            pCounter->CVersion &= 0xFFFF0000;
            pCounter->CVersion |= (pCounter->pQMachine->pMachine->pSystemPerfData->Revision & 0x0000FFFF);

            // get the counter's time base
            if (pPerfCounter->CounterType & PERF_TIMER_100NS) {
                pCounter->TimeBase = (LONGLONG)10000000;
            } else if (pPerfCounter->CounterType & PERF_OBJECT_TIMER) {
                // then get the time base freq from the object
                pCounter->TimeBase = pPerfObject->PerfFreq.QuadPart;
            } else { // if (pPerfCounter->CounterType & PERF_TIMER_TICK or other)
                pCounter->TimeBase = pCounter->pQMachine->pMachine->pSystemPerfData->PerfFreq.QuadPart;
            }

            // look up info from counter definition
            pCounter->plCounterInfo.dwCounterType =
                pPerfCounter->CounterType;
            pCounter->plCounterInfo.dwCounterSize =
                pPerfCounter->CounterSize;

            pCounter->plCounterInfo.lDefaultScale =
                pPerfCounter->DefaultScale;

            //
            //  get explain text pointer
            pCounter->szExplainText =
                (LPWSTR)PdhiLookupPerfNameByIndex (
                    pCounter->pQMachine->pMachine,
                    pPerfCounter->CounterHelpTitleIndex);

            //
            //  now clear/initialize the raw counter info
            //
            pCounter->ThisValue.TimeStamp.dwLowDateTime = 0;
            pCounter->ThisValue.TimeStamp.dwHighDateTime = 0;
            pCounter->ThisValue.MultiCount = 1;
            pCounter->ThisValue.FirstValue = 0;
            pCounter->ThisValue.SecondValue = 0;
            //
            pCounter->LastValue.TimeStamp.dwLowDateTime = 0;
            pCounter->LastValue.TimeStamp.dwHighDateTime = 0;
            pCounter->LastValue.MultiCount = 1;
            pCounter->LastValue.FirstValue = 0;
            pCounter->LastValue.SecondValue = 0;
            //
            //  clear data array pointers
            //
            pCounter->pThisRawItemList = NULL;
            pCounter->pLastRawItemList = NULL;
            //
            //  lastly update status
            //
            if (pCounter->ThisValue.CStatus == 0)  {
                // don't overwrite any other status values
                pCounter->ThisValue.CStatus = PDH_CSTATUS_VALID_DATA;
            }
            return TRUE;
        } else {
            // unable to find counter
            pCounter->ThisValue.CStatus = PDH_CSTATUS_NO_COUNTER;
            return FALSE;
        }
    } else {
        // unable to find object
        pCounter->ThisValue.CStatus = PDH_CSTATUS_NO_OBJECT;
        return FALSE;
    }
}

#pragma warning ( disable : 4127 )
STATIC_BOOL
IsNumberInUnicodeList(
    DWORD   dwNumber,
    LPWSTR  lpwszUnicodeList
)
/*++
IsNumberInUnicodeList

Arguments:
    IN dwNumber
        DWORD number to find in list
    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:
    TRUE:
            dwNumber was found in the list of unicode number strings
    FALSE:
            dwNumber was not found in the list.
--*/
{
    DWORD   dwThisNumber;
    LPWSTR  pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    BOOL    bReturn = FALSE;
    BOOL    bDone   = FALSE;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar  = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter  = SPACE_L;
    bValidNumber = FALSE;
    bNewItem     = TRUE;

    while (! bDone) {
        switch (EvalThisChar(* pwcThisChar, wcDelimiter)) {
        case DIGIT:
            // if this is the first digit after a delimiter, then
            // set flags to start computing the new number
            if (bNewItem) {
                bNewItem     = FALSE;
                bValidNumber = TRUE;
            }
            if (bValidNumber) {
                dwThisNumber *= 10;
                dwThisNumber += (* pwcThisChar - (WCHAR) '0');
            }
            break;

        case DELIMITER:
            // a delimter is either the delimiter character or the
            // end of the string ('\0') if when the delimiter has been
            // reached a valid number was found, then compare it to the
            // number from the argument list. if this is the end of the
            // string and no match was found, then return.
            //
            if (bValidNumber) {
                if (dwThisNumber == dwNumber) {
                    bDone   = TRUE;
                    bReturn = TRUE;
                }
                else {
                    bValidNumber = FALSE;
                }
            }
            if (! bDone) {
                if (* pwcThisChar == L'\0') {
                    bDone   = TRUE;
                    bReturn = FALSE;
                }
                else {
                    bNewItem     = TRUE;
                    dwThisNumber = 0;
                }
            }
            break;

        case INVALID:
            // if an invalid character was encountered, ignore all
            // characters up to the next delimiter and then start fresh.
            // the invalid number is not compared.
            bValidNumber = FALSE;
            break;

        default:
            break;
        }
        pwcThisChar ++;
    }

    return bReturn;
}   // IsNumberInUnicodeList
#pragma warning ( default : 4127 )

BOOL
AppendObjectToValueList(
    DWORD   dwObjectId,
    PWSTR   pwszValueList,
    DWORD   dwValueList
)
/*++
AppendObjectToValueList

Arguments:
    IN dwNumber
        DWORD number to insert in list
    IN PWSTR
        pointer to wide char string that contains buffer that is
        Null terminated, Space delimited list of decimal numbers that
        may have this number appended to.

Return Value:
    TRUE:
            dwNumber was added to list
    FALSE:
            dwNumber was not added. (because it's already there or
                an error occured)
--*/
{
    WCHAR   tempString[16];
    BOOL    bReturn = FALSE;
    LPWSTR  szFormatString;

    if (!pwszValueList) {
        bReturn = FALSE;
    }
    else if (IsNumberInUnicodeList(dwObjectId, pwszValueList)) {
        bReturn = FALSE;   // object already in list
    }
    else {
        __try {
            if (* pwszValueList == 0) {
                // then this is the first string so no delimiter
                szFormatString = (LPWSTR) fmtDecimal;
            }
            else {
                // this is being added to the end so include the delimiter
                szFormatString = (LPWSTR) fmtSpaceDecimal;
            }
            // format number and append the new object id the  value list
            StringCchPrintfW(tempString, 16, szFormatString, dwObjectId);
            StringCchCatW(pwszValueList, dwValueList, tempString);
            bReturn = TRUE;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            bReturn = FALSE;
        }
    }
    return bReturn;
}

BOOL
GetInstanceByNameMatch(
    PPERF_MACHINE pMachine,
    PPDHI_COUNTER pCounter
)
{
    PPERF_INSTANCE_DEFINITION pInstanceDef;
    PPERF_OBJECT_TYPE         pObjectDef;
    LONG                      lInstanceId = PERF_NO_UNIQUE_ID;
    BOOL                      bReturn     = FALSE;

    // get the instances object

    pObjectDef = GetObjectDefByTitleIndex(pMachine->pSystemPerfData, pCounter->plCounterInfo.dwObjectId);
    if (pObjectDef != NULL) {
        pInstanceDef = FirstInstance(pObjectDef);
        if (pInstanceDef != NULL) {
            if (pInstanceDef->UniqueID == PERF_NO_UNIQUE_ID) {
                // get instance in that object by comparing names
                // if there is no parent specified, then just look it up by name
                pInstanceDef = GetInstanceByName(pMachine->pSystemPerfData,
                                                 pObjectDef,
                                                 pCounter->pCounterPath->szInstanceName,
                                                 pCounter->pCounterPath->szParentName,
                                                 pCounter->pCounterPath->dwIndex);
            }
            else {
                // get numeric equivalent of Instance ID
                if (pCounter->pCounterPath->szInstanceName != NULL) {
                    lInstanceId = wcstol(pCounter->pCounterPath->szInstanceName, NULL, 10);
                }
                pInstanceDef = GetInstanceByUniqueId(pObjectDef, lInstanceId);
            }

            // update counter fields
            pCounter->plCounterInfo.lInstanceId = lInstanceId;
            if (lInstanceId == -1) {
                // use instance NAME
                pCounter->plCounterInfo.szInstanceName       = pCounter->pCounterPath->szInstanceName;
                pCounter->plCounterInfo.szParentInstanceName = pCounter->pCounterPath->szParentName;
            }
            else {
                // use instance ID number
                pCounter->plCounterInfo.szInstanceName       = NULL;
                pCounter->plCounterInfo.szParentInstanceName = NULL;
            }
        }
        if (pInstanceDef != NULL) {
            // instance found
            bReturn = TRUE;
        }
    }
    return bReturn;
}

BOOL
GetObjectPerfInfo(
    PPERF_DATA_BLOCK   pPerfData,
    DWORD              dwObjectId,
    LONGLONG         * pPerfTime,
    LONGLONG         * pPerfFreq
)
{
    PPERF_OBJECT_TYPE pObject;
    BOOL              bReturn = FALSE;

    pObject = GetObjectDefByTitleIndex(pPerfData, dwObjectId);
    if (pObject != NULL) {
        __try {
            * pPerfTime = pObject->PerfTime.QuadPart;
            * pPerfFreq = pObject->PerfFreq.QuadPart;
            bReturn     = TRUE;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            bReturn = FALSE;
        }
    }
    return bReturn;
}

PDH_STATUS
ValidateMachineConnection(
    PPERF_MACHINE   pMachine
)
{
    PDH_STATUS  pdhStatus     = ERROR_SUCCESS;
    HANDLE      hThread;
    DWORD       ThreadId;
    DWORD       dwWaitStatus;
    DWORD       dwReconnecting;
    LONGLONG    llCurrentTime;
    FILETIME    CurrentFileTime;

    // if a connection or request has failed, this will be
    // set to an error status
    if (pMachine != NULL) {
        if (pMachine->dwStatus != ERROR_SUCCESS) {
            // get the current time
            GetSystemTimeAsFileTime(& CurrentFileTime);
            llCurrentTime  = MAKELONGLONG(CurrentFileTime.dwLowDateTime, CurrentFileTime.dwHighDateTime);
            if (pMachine->llRetryTime <= llCurrentTime) {
                if (pMachine->llRetryTime != 0) {
                    // see what's up by trying to reconnect
                    dwReconnecting = pMachine->dwRetryFlags;
                    if (!dwReconnecting) {
                        pdhStatus = ConnectMachine(pMachine);
                    }
                    else {
                        // a connection attempt is in process so do nothing here
                        pdhStatus = PDH_CANNOT_CONNECT_MACHINE;
                    }
                }
            }
            else {
                // it's not retry time, yet so machine is off line still
                pdhStatus = PDH_CSTATUS_NO_MACHINE;
            }
        }
    }
    else {
        pdhStatus = PDH_CSTATUS_NO_MACHINE;
    }
    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhdll\strings.c ===
/*++
Copyright (C) 1996-1999 Microsoft Corporation

Module Name:
    strings.c

Abstract:
    String constants used by the functions in the PDH.DLL library
--*/

#include <windows.h>
#include "strings.h"

LPCWSTR cszAppShortName            = (LPCWSTR) L"PDH";

// registry path, key and value strings
LPCWSTR cszNamesKey                = (LPCWSTR) L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
LPCWSTR cszDefaultLangId           = (LPCWSTR) L"009";
LPCWSTR cszCounters                = (LPCWSTR) L"Counters";
LPCWSTR cszHelp                    = (LPCWSTR) L"Help";
LPCWSTR cszLastHelp                = (LPCWSTR) L"Last Help";
LPCWSTR cszLastCounter             = (LPCWSTR) L"Last Counter";
LPCWSTR cszVersionName             = (LPCWSTR) L"Version";
LPCWSTR cszCounterName             = (LPCWSTR) L"Counter ";
LPCWSTR cszHelpName                = (LPCWSTR) L"Explain ";
LPCWSTR cszGlobal                  = (LPCWSTR) L"Global";
LPCWSTR cszCostly                  = (LPCWSTR) L"Costly";
LPCWSTR cszLogQueries              = (LPCWSTR) L"SYSTEM\\CurrentControlSet\\Services\\PerfDataLog\\Log Queries";
LPCWSTR cszLogFileType             = (LPCWSTR) L"Log File Type";
LPCWSTR cszAutoNameInterval        = (LPCWSTR) L"Auto Name Interval";
LPCWSTR cszLogFileName             = (LPCWSTR) L"Log Filename";
LPCWSTR cszLogDefaultDir           = (LPCWSTR) L"Log Default Directory";
LPCWSTR cszBaseFileName            = (LPCWSTR) L"Base Filename";
LPCWSTR cszLogFileAutoFormat       = (LPCWSTR) L"Log File Auto Format";
LPCWSTR cszAutoRenameUnits         = (LPCWSTR) L"Auto Rename Units";
LPCWSTR cszCommandFile             = (LPCWSTR) L"Command File";
LPCWSTR cszCounterList             = (LPCWSTR) L"Counter List";
LPCSTR  caszCounterList            = "Counter List";
LPCWSTR cszPerfDataLog             = (LPCWSTR) L"PerfDataLog";
LPCWSTR cszDefault                 = (LPCWSTR) L"Default";
LPCSTR  caszDefaultLogCaption      = "User Data";
LPCWSTR cszPerfNamePathPrefix      = (LPCWSTR) L"%systemroot%\\system32\\perf";
LPCWSTR cszDat                     = (LPCWSTR) L".dat";
LPCWSTR cszWBEM                    = (LPCWSTR) L"WBEM:";
LPCWSTR cszWMI                     = (LPCWSTR) L"WMI:";
LPCWSTR cszSQL                     = (LPCWSTR) L"SQL:";
LPCSTR  caszWBEM                   = "WBEM:";
LPCSTR  caszWMI                    = "WMI:";
LPCWSTR cszWbemDefaultPerfRoot     = (LPCWSTR) L"\\root\\cimv2";
LPCWSTR cszSingletonInstance       = (LPCWSTR) L"=@";
LPCWSTR cszNameParam               = (LPCWSTR) L".Name=\"";
LPCWSTR cszCountertype             = (LPCWSTR) L"countertype";
LPCWSTR cszDisplayname             = (LPCWSTR) L"displayname";
LPCWSTR cszExplainText             = (LPCWSTR) L"Description";
LPCWSTR cszDefaultscale            = (LPCWSTR) L"defaultscale";
LPCWSTR cszSingleton               = (LPCWSTR) L"singleton";
LPCWSTR cszPerfdetail              = (LPCWSTR) L"perfdetail";
LPCWSTR cszPerfdefault             = (LPCWSTR) L"perfdefault";
LPCWSTR cszClass                   = (LPCWSTR) L"__CLASS";
LPCWSTR cszPerfRawData             = (LPCWSTR) L"Win32_PerfRawData";
LPCWSTR cszNotFound                = (LPCWSTR) L"Not Found";
LPCWSTR cszName                    = (LPCWSTR) L"Name";
LPCWSTR cszBaseSuffix              = (LPCWSTR) L"_Base";
LPCWSTR cszTimestampPerfTime       = (LPCWSTR) L"Timestamp_PerfTime";
LPCWSTR cszFrequencyPerfTime       = (LPCWSTR) L"Frequency_PerfTime";
LPCWSTR cszTimestampSys100Ns       = (LPCWSTR) L"Timestamp_Sys100NS";
LPCWSTR cszFrequencySys100Ns       = (LPCWSTR) L"Frequency_Sys100NS";
LPCWSTR cszTimestampObject         = (LPCWSTR) L"Timestamp_Object";
LPCWSTR cszFrequencyObject         = (LPCWSTR) L"Frequency_Object";
LPCWSTR cszPerfmonLogSig           = (LPCWSTR) L"Loges";
LPCWSTR cszRemoteMachineRetryTime  = (LPCWSTR) L"Remote Reconnection Retry Time";
LPCWSTR cszEnableRemotePdhAccess   = (LPCWSTR) L"Enable Remote PDH Access";
LPCWSTR cszPdhKey                  = (LPCWSTR) L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\PDH";
LPCWSTR cszDefaultNullDataSource   = (LPCWSTR) L"DefaultNullDataSource";
LPCWSTR cszCollectTimeout          = (LPCWSTR) L"CollectTimeout";
LPCWSTR cszLogSectionName          = (LPCWSTR) L"SYSMON_LOG_READONLY_";
LPCWSTR cszCurrentVersionKey       = (LPCWSTR) L"Software\\Microsoft\\Windows NT\\CurrentVersion";
LPCWSTR cszCurrentVersionValueName = (LPCWSTR) L"CurrentVersion";
LPCWSTR fmtDecimal                 = (LPCWSTR) L"%d";
LPCWSTR fmtSpaceDecimal            = (LPCWSTR) L" %d";
LPCWSTR fmtLangId                  = (LPCWSTR) L"%3.3x";

// single character strings
LPCWSTR cszEmptyString             = (LPCWSTR) L"";
LPCWSTR cszPoundSign               = (LPCWSTR) L"#";
LPCWSTR cszSplat                   = (LPCWSTR) L"*";
LPCWSTR cszSlash                   = (LPCWSTR) L"/";
LPCWSTR cszBackSlash               = (LPCWSTR) L"\\";
LPCWSTR cszLeftParen               = (LPCWSTR) L"(";
LPCWSTR cszRightParen              = (LPCWSTR) L")";
LPCWSTR cszC                       = (LPCWSTR) L"C";
LPCWSTR cszH                       = (LPCWSTR) L"H";
LPCWSTR cszColon                   = (LPCWSTR) L":";
LPCWSTR cszDoubleQuote             = (LPCWSTR) L"\"";
LPCSTR  caszPoundSign              = "#";
LPCSTR  caszSplat                  = "*";
LPCSTR  caszSlash                  = "/";
LPCSTR  caszBackSlash              = "\\";
LPCSTR  caszDoubleBackSlash        = "\\\\";
LPCSTR  caszLeftParen              = "(";
LPCSTR  caszRightParen             = ")";
LPCSTR  caszSpace                  = " ";
LPCWSTR cszDoubleBackSlash         = (LPCWSTR) L"\\\\";
LPCWSTR cszDoubleBackSlashDot      = (LPCWSTR) L"\\\\.";
LPCWSTR cszRightParenBackSlash     = (LPCWSTR) L")\\";

// other general strings
LPCWSTR cszSpacer                  = (LPCWSTR) L" - ";
LPCWSTR cszBlg                     = (LPCWSTR) L"blg";

// strings only used in DEBUG builds
#ifdef _DEBUG
LPCWSTR cszNameDontMatch           = (LPCWSTR) L"Last Machine Name does not match the current selection";
LPCWSTR cszNotice                  = (LPCWSTR) L"Notice!";
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhdll\qutils.c ===
/*++
Copyright (C) 1995-1999 Microsoft Corporation

Module Name:
    qutils.c

Abstract:
    Query management utility functions
--*/

#include <windows.h>
#include "strsafe.h"
#include <pdh.h>
#include "pdhitype.h"
#include "pdhidef.h"
#include "pdhmsg.h"
#include "strings.h"
#include "log_bin.h"
#include "log_wmi.h"
#include "perfdata.h"

BOOL
IsValidQuery(
    PDH_HQUERY hQuery
)
{
    BOOL        bReturn = FALSE;    // assume it's not a valid query
    PPDHI_QUERY pQuery;

    __try {
        if (hQuery != NULL) {
            // see if a valid signature
            pQuery = (PPDHI_QUERY) hQuery;
            if ((* (DWORD *) & pQuery->signature[0] == SigQuery) && (pQuery->dwLength == sizeof(PDHI_QUERY))) {
                bReturn = TRUE;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        // something failed miserably so we can assume this is invalid
    }
    return bReturn;
}

BOOL
AddMachineToQueryLists(
    PPERF_MACHINE pMachine,
    PPDHI_COUNTER pNewCounter
)
{
    BOOL                bReturn = FALSE; // assume failure
    PPDHI_QUERY         pQuery;
    PPDHI_QUERY_MACHINE pQMachine;
    PPDHI_QUERY_MACHINE pLastQMachine;

    pQuery = pNewCounter->pOwner;

    if (IsValidQuery(pQuery)) {
        if (pQuery->pFirstQMachine != NULL) {
            // look for machine in list
            pLastQMachine = pQMachine = pQuery->pFirstQMachine;
            while (pQMachine != NULL) {
                if (pQMachine->pMachine == pMachine) {
                    // found the machine already in the list so continue
                    bReturn = TRUE;
                    break;
                }
                else {
                    pLastQMachine = pQMachine;
                    pQMachine     = pQMachine->pNext;
                }
            }
            if (pQMachine == NULL) {
                // add this machine to the end of the list
                pQMachine = G_ALLOC((sizeof(PDHI_QUERY_MACHINE) + (sizeof(WCHAR) * MAX_PATH)));
                if (pQMachine != NULL) {
                    pQMachine->pMachine     = pMachine;
                    pQMachine->szObjectList = (LPWSTR) ( & pQMachine[1]);
                    pQMachine->pNext        = NULL;
                    pQMachine->lQueryStatus = pMachine->dwStatus;
                    pQMachine->llQueryTime  = 0;
                    bReturn                 = TRUE;

                    // the pPerfData pointer will be tested prior to usage
                    pQMachine->pPerfData    = G_ALLOC(MEDIUM_BUFFER_SIZE);
                    if (pQMachine->pPerfData == NULL) {
                        G_FREE(pQMachine);
                        pQMachine = NULL;
                        bReturn   = FALSE;
                        SetLastError(PDH_MEMORY_ALLOCATION_FAILURE);
                    }
                    else {
                        pLastQMachine->pNext = pQMachine;
                    }
                }
                else {
                    // unable to alloc memory block so machine cannot
                    // be added
                    SetLastError(PDH_MEMORY_ALLOCATION_FAILURE);
                }
            }
        }
        else {
            // add this as the first machine
            pQMachine = G_ALLOC ((sizeof(PDHI_QUERY_MACHINE) + (sizeof(WCHAR) * PDH_MAX_COUNTER_PATH)));
            if (pQMachine != NULL) {
                pQMachine->pMachine     = pMachine;
                pQMachine->szObjectList = (LPWSTR) (& pQMachine[1]);
                pQMachine->pNext        = NULL;
                pQMachine->lQueryStatus = pMachine->dwStatus;
                pQMachine->llQueryTime  = 0;
                bReturn                 = TRUE;

                // the pPerfData pointer will be tested prior to usage
                pQMachine->pPerfData = G_ALLOC(MEDIUM_BUFFER_SIZE);
                if (pQMachine->pPerfData == NULL) {
                    G_FREE(pQMachine);
                    pQMachine = NULL;
                    bReturn   = FALSE;
                    SetLastError(PDH_MEMORY_ALLOCATION_FAILURE);
                }
                else {
                    pQuery->pFirstQMachine = pQMachine;
                }
            }
            else {
                // unable to alloc memory block so machine cannot
                // be added
               SetLastError(PDH_MEMORY_ALLOCATION_FAILURE);
            }
        }
        // here pQMachine should be the pointer to the correct machine
        // entry or NULL if unable to create
        if (pQMachine != NULL) {
            // save the new pointer
            pNewCounter->pQMachine = pQMachine;

            // increment reference count for this machine
            pMachine->dwRefCount ++;

            // update query perf. object list
            AppendObjectToValueList(
                    pNewCounter->plCounterInfo.dwObjectId, pQMachine->szObjectList, PDH_MAX_COUNTER_PATH);
        }
    }
    else {
        SetLastError(PDH_INVALID_HANDLE);
        bReturn = FALSE;
    }

    return bReturn;
}

extern PDH_FUNCTION
PdhiGetBinaryLogCounterInfo(
    PPDHI_LOG       pLog,
    PPDHI_COUNTER   pCounter
);

extern PPERF_DATA_BLOCK
PdhWmiMergeObjectBlock(
    PPDHI_LOG                       pLog,
    LPWSTR                          szMachine,
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisMasterRecord,
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisSubRecord
);

PDH_FUNCTION
PdhiGetCounterFromDataBlock(
    PPDHI_LOG          pLog,
    PVOID              pDataBuffer,
    PPDHI_COUNTER      pCounter
)
{
    PDH_STATUS        pdhStatus           = ERROR_SUCCESS;
    PERFLIB_COUNTER * pPerfCounter        = & pCounter->plCounterInfo;
    PPDH_RAW_COUNTER  pRawValue           = & pCounter->ThisValue;
    LPWSTR            szCompositeInstance = NULL;
    DWORD             dwDataItemIndex;
    LPWSTR            szThisInstanceName;

    PPDHI_BINARY_LOG_RECORD_HEADER  pThisMasterRecord;
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisSubRecord;

    PPDHI_RAW_COUNTER_ITEM_BLOCK    pDataBlock;
    PPDHI_RAW_COUNTER_ITEM          pDataItem;
    PPDH_RAW_COUNTER                pRawItem;

    PPERF_DATA_BLOCK                pPerfData;
    PPERF_DATA_BLOCK                pTmpBlock;
    FILETIME                        ftDataBlock;
    FILETIME                        ftGmtDataBlock;
    LONGLONG                        TimeStamp;

    ZeroMemory(& ftDataBlock, sizeof(FILETIME));
    ZeroMemory(& ftGmtDataBlock, sizeof(FILETIME));
    ZeroMemory(pRawValue, sizeof(PDH_RAW_COUNTER));
    pThisMasterRecord = (PPDHI_BINARY_LOG_RECORD_HEADER) pDataBuffer;
    pThisSubRecord = PdhiGetSubRecord(pThisMasterRecord, pCounter->dwIndex);

    if (pThisSubRecord != NULL) {
        if (pThisSubRecord->dwType == BINLOG_TYPE_DATA_PSEUDO) {
            PDH_STATUS Status     = ERROR_SUCCESS;
            DWORD      dwOriginal = pCounter->dwIndex;
            DWORD      dwPrevious;

            while (Status == ERROR_SUCCESS && pThisSubRecord) {
                if (pThisSubRecord->dwType != BINLOG_TYPE_DATA_PSEUDO) {
                    break;
                }
                dwPrevious = pCounter->dwIndex;
                Status     = PdhiGetBinaryLogCounterInfo(pLog, pCounter);
                if (   Status == ERROR_SUCCESS
                    && dwPrevious != pCounter->dwIndex) {
                    pThisSubRecord = PdhiGetSubRecord(pThisMasterRecord, pCounter->dwIndex);
                }
            }
            if (pThisSubRecord == NULL || Status == PDH_ENTRY_NOT_IN_LOG_FILE) {
                pCounter->dwIndex = 0;
                do {
                    dwPrevious = pCounter->dwIndex;
                    Status     = PdhiGetBinaryLogCounterInfo(pLog, pCounter);
                    if (Status == ERROR_SUCCESS && dwPrevious != pCounter->dwIndex) {
                        pThisSubRecord = PdhiGetSubRecord(pThisMasterRecord, pCounter->dwIndex);
                    }
                    if (pThisSubRecord->dwType != BINLOG_TYPE_DATA_PSEUDO) {
                        break;
                    }
                }
                while (Status == ERROR_SUCCESS && pCounter->dwIndex < dwOriginal && pThisSubRecord);

                if (pThisSubRecord == NULL || pCounter->dwIndex >= dwOriginal) {
                    Status = PDH_ENTRY_NOT_IN_LOG_FILE;
                }
            }
            if (Status == PDH_ENTRY_NOT_IN_LOG_FILE) {
                    pCounter->dwIndex = dwOriginal;
                    pThisSubRecord = PdhiGetSubRecord(pThisMasterRecord, pCounter->dwIndex);
            }
        }
    }
    if (pLog->pLastRecordRead != pDataBuffer) {
        pLog->pLastRecordRead = pDataBuffer;
    }

    if (pThisSubRecord != NULL) {
        switch (pThisSubRecord->dwType) {
        case BINLOG_TYPE_DATA_LOC_OBJECT:
            pTmpBlock = (PPERF_DATA_BLOCK) ((LPBYTE)pThisSubRecord + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
            pPerfData = PdhWmiMergeObjectBlock(
                            pLog, pCounter->pCounterPath->szMachineName, pThisMasterRecord, pThisSubRecord);
            SystemTimeToFileTime(& pPerfData->SystemTime, & ftDataBlock);
            TimeStamp = MAKELONGLONG(ftDataBlock.dwLowDateTime, ftDataBlock.dwHighDateTime);
            if (pCounter->dwFlags & PDHIC_MULTI_INSTANCE) {
                UpdateMultiInstanceCounterValue(pCounter, pPerfData, TimeStamp);
            }
            else {
                UpdateCounterValue(pCounter, pPerfData);
                pCounter->ThisValue.TimeStamp = ftDataBlock;
            }
            break;

        case BINLOG_TYPE_DATA_PSEUDO:
        case BINLOG_TYPE_DATA_SINGLE:
            pRawItem = (PPDH_RAW_COUNTER) ((LPBYTE)pThisSubRecord + sizeof (PDHI_BINARY_LOG_RECORD_HEADER));
            RtlCopyMemory(pRawValue, pRawItem, sizeof (PDH_RAW_COUNTER));
            pdhStatus = ERROR_SUCCESS;
            break;

        case BINLOG_TYPE_DATA_MULTI:
            if (pCounter->dwFlags & PDHIC_MULTI_INSTANCE) {
                // this is a wild card query
                //
                ULONG i;
                ULONG CopySize = pThisSubRecord->dwLength - sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
                PPDHI_RAW_COUNTER_ITEM_BLOCK pNewBlock = G_ALLOC(CopySize);

                if (pNewBlock == NULL) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                else if (pCounter->pThisRawItemList != NULL) {
                    G_FREE(pCounter->pLastRawItemList);
                    pCounter->pLastRawItemList = pCounter->pThisRawItemList;
                }
                pCounter->pThisRawItemList = pNewBlock;
                RtlCopyMemory(pNewBlock,
                              (((LPBYTE) pThisSubRecord) + sizeof(PDHI_BINARY_LOG_RECORD_HEADER)),
                              CopySize);
            }
            else if (pPerfCounter->szInstanceName != NULL) {
                DWORD dwInstanceId   = pCounter->pCounterPath->dwIndex;
                DWORD dwInstanceSize = lstrlenW(pPerfCounter->szInstanceName) + 1;

                if (pPerfCounter->szParentInstanceName != NULL) {
                    dwInstanceSize += lstrlenW(pPerfCounter->szParentInstanceName) + 1;
                }
                szCompositeInstance = G_ALLOC(sizeof(WCHAR) * dwInstanceSize);
                if (szCompositeInstance != NULL) {
                    if (pPerfCounter->szParentInstanceName != NULL) {
                        StringCchPrintfW(szCompositeInstance, dwInstanceSize,
                                         L"%ws/%ws",
                                         pPerfCounter->szParentInstanceName,
                                         pPerfCounter->szInstanceName);
                    }
                    else {
                        StringCchCopyW(szCompositeInstance, dwInstanceSize, pPerfCounter->szInstanceName);
                    }
                }
                else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    break;
                }

                pDataBlock = (PPDHI_RAW_COUNTER_ITEM_BLOCK)
                             ((LPBYTE) pThisSubRecord + sizeof (PDHI_BINARY_LOG_RECORD_HEADER));
                pdhStatus          = PDH_ENTRY_NOT_IN_LOG_FILE;
                pRawValue->CStatus = PDH_CSTATUS_NO_INSTANCE;

                for (dwDataItemIndex = 0; dwDataItemIndex < pDataBlock->dwItemCount; dwDataItemIndex++) {
                    pDataItem = &pDataBlock->pItemArray[dwDataItemIndex];
                    szThisInstanceName = (LPWSTR) ((LPBYTE) pDataBlock + (DWORD_PTR) pDataItem->szName);
                    if (lstrcmpiW(szThisInstanceName, szCompositeInstance) == 0) {
                        if (dwInstanceId == 0) {
                            pdhStatus              = ERROR_SUCCESS;
                            pRawValue->CStatus     = pDataBlock->CStatus;
                            pRawValue->TimeStamp   = pDataBlock->TimeStamp;
                            pRawValue->FirstValue  = pDataItem->FirstValue;
                            pRawValue->SecondValue = pDataItem->SecondValue;
                            pRawValue->MultiCount  = pDataItem->MultiCount;
                            break;
                        }
                        else {
                            dwInstanceId --;
                        }
                    }
                }
            }
            else {
                pdhStatus          = PDH_ENTRY_NOT_IN_LOG_FILE;
                pRawValue->CStatus = PDH_CSTATUS_INVALID_DATA;
            }
            break;

        default:
            pdhStatus          = PDH_LOG_TYPE_NOT_FOUND;
            pRawValue->CStatus = PDH_CSTATUS_INVALID_DATA;
            break;
        }
    }
    else {
        pdhStatus          = PDH_ENTRY_NOT_IN_LOG_FILE;
        pRawValue->CStatus = PDH_CSTATUS_INVALID_DATA;
    }

    G_FREE(szCompositeInstance);
    return pdhStatus;
}

LONG
GetQueryPerfData(
    PPDHI_QUERY   pQuery,
    LONGLONG    * pTimeStamp
)
{
    LONG                lStatus           = PDH_INVALID_DATA;
    PPDHI_COUNTER       pCounter;
    PPDHI_QUERY_MACHINE pQMachine;
    LONGLONG            llCurrentTime;
    LONGLONG            llTimeStamp       = 0;
    BOOLEAN             bCounterCollected = FALSE;
    BOOL                bLastLogEntry;

    if (pQuery->hLog == H_REALTIME_DATASOURCE) {
        FILETIME GmtFileTime;
        FILETIME LocFileTime;

        // this is a real-time query so
        // get the current data from each of the machines in the query
        //  (after this "sequential" approach is perfected, then the
        //  "parallel" approach of multiple threads can be developed
        //
        // get time stamp now so each machine will have the same time
        GetSystemTimeAsFileTime(& GmtFileTime);
        FileTimeToLocalFileTime(& GmtFileTime, & LocFileTime);
        llTimeStamp = MAKELONGLONG(LocFileTime.dwLowDateTime, LocFileTime.dwHighDateTime);

        pQMachine = pQuery->pFirstQMachine;
        while (pQMachine != NULL) {
            pQMachine->llQueryTime = llTimeStamp;
            lStatus = ValidateMachineConnection(pQMachine->pMachine);
            if (lStatus == ERROR_SUCCESS) {
                // machine is connected so get data
                lStatus = GetSystemPerfData(
                                pQMachine->pMachine->hKeyPerformanceData,
                                & pQMachine->pPerfData,
                                pQMachine->szObjectList,
                                FALSE); // never query the costly data objects as a group
                // save the machine's last status

                pQMachine->pMachine->dwStatus = lStatus;
                // if there was an error in the data collection,
                // set the retry counter and wait to try again.
                if (lStatus != ERROR_SUCCESS) {
                    GetSystemTimeAsFileTime(& LocFileTime);
                    llCurrentTime = MAKELONGLONG(LocFileTime.dwLowDateTime, LocFileTime.dwHighDateTime);
                    pQMachine->pMachine->llRetryTime = llCurrentTime + RETRY_TIME_INTERVAL;
                }

            }
            pQMachine->lQueryStatus = lStatus;
            // get next machine in query
            pQMachine = pQMachine->pNext;
        }
        // now update the counters using this new data
        if ((pCounter = pQuery->pCounterListHead) != NULL) {
            DWORD dwCollected = 0;
            do {
                if (pCounter->dwFlags & PDHIC_COUNTER_OBJECT) {
                    if (UpdateCounterObject(pCounter)) {
                        dwCollected ++;
                    }
                }
                else if (pCounter->dwFlags & PDHIC_MULTI_INSTANCE) {
                    if (UpdateRealTimeMultiInstanceCounterValue (pCounter)) {
                        dwCollected ++;
                    }
                }
                else {
                    // update single instance counter values
                    if (UpdateRealTimeCounterValue(pCounter)) {
                        dwCollected ++;
                    }
                }
                pCounter = pCounter->next.flink;
            }
            while (pCounter != NULL && pCounter != pQuery->pCounterListHead);
            lStatus = (dwCollected > 0) ? ERROR_SUCCESS : PDH_NO_DATA;
        }
        else {
            // no counters in the query  (?!)
            lStatus = PDH_NO_DATA;
        }
    }
    else {
        // read data from log file
        // get the next log record entry and update the
        // corresponding counter entries

        PPDHI_LOG pLog      = NULL;
        DWORD     dwLogType = 0;

        __try {
            pLog      = (PPDHI_LOG) (pQuery->hLog);
            dwLogType = LOWORD(pLog->dwLogFormat);
            lStatus   = ERROR_SUCCESS;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pQuery->dwLastLogIndex = (ULONG) -1;
            lStatus                = PDH_INVALID_HANDLE;
        }

        if (lStatus == ERROR_SUCCESS) {
            if (dwLogType == PDH_LOG_TYPE_BINARY) {
                if (pQuery->dwLastLogIndex == 0) {
                    lStatus = PdhiReadTimeWmiRecord(
                                    pLog,
                                    * (ULONGLONG *) & pQuery->TimeRange.StartTime,
                                    NULL,
                                    0);
                    pQuery->dwLastLogIndex = BINLOG_FIRST_DATA_RECORD;
                }
                else {
                    lStatus = PdhiReadNextWmiRecord(pLog, NULL, 0, TRUE);
                }
                if (lStatus != ERROR_SUCCESS && lStatus != PDH_MORE_DATA) {
                    pQuery->dwLastLogIndex = (DWORD) -1;
                }
                else {
                    pQuery->dwLastLogIndex --;
                }
            }
            else if (pQuery->dwLastLogIndex == 0) {
                // then the first matching entry needs to be
                // located in the log file
                lStatus = PdhiGetMatchingLogRecord(
                                pQuery->hLog,
                                (LONGLONG *) & pQuery->TimeRange.StartTime,
                                & pQuery->dwLastLogIndex);
                if (lStatus != ERROR_SUCCESS) {
                    // the matching time entry wasn't found in the log
                    pQuery->dwLastLogIndex = (DWORD) -1;
                }
                else {
                    // decrement the index so it can be incremented
                    // below. 0 is not a valid entry so there's no
                    // worry about -1 being attempted accidently.
                    pQuery->dwLastLogIndex--;
                }
            }

            if (pQuery->dwLastLogIndex != (DWORD) -1) {
                bLastLogEntry = FALSE;
                pQuery->dwLastLogIndex ++;   // go to next entry
                if ((pCounter = pQuery->pCounterListHead) != NULL) {
                    DWORD dwCounter = 0;
                    do {
                        if (dwLogType == PDH_LOG_TYPE_BINARY) {
                            // save current value as last value since we are getting
                            // a new one, hopefully.
                            pCounter->LastValue = pCounter->ThisValue;
                            lStatus = PdhiGetCounterFromDataBlock(
                                            pLog,
                                            pLog->pLastRecordRead,
                                            pCounter);
                        }
                        else {
                            lStatus = PdhiGetCounterValueFromLogFile(
                                            pQuery->hLog,
                                            pQuery->dwLastLogIndex,
                                            pCounter);
                        }
                        if (lStatus != ERROR_SUCCESS) {
                            // see if this is because there's no more entries
                            if (lStatus == PDH_NO_MORE_DATA) {
                                bLastLogEntry = TRUE;
                                break;
                            }
                        }
                        else if (dwLogType == PDH_LOG_TYPE_BINARY) {
                            if (pCounter->ThisValue.CStatus == PDH_CSTATUS_VALID_DATA) {
                                llTimeStamp = pLog->llFileSize;
                                if (pLog->llFileSize > pQuery->TimeRange.EndTime) {
                                    lStatus = PDH_NO_MORE_DATA;
                                    bLastLogEntry = TRUE;
                                    break;
                                }
                                dwCounter ++;
                            }
                        }
                        else {
                            // single entry or multiple entries
                            //
                            if (pCounter->ThisValue.CStatus == PDH_CSTATUS_VALID_DATA) {
                                llTimeStamp = MAKELONGLONG(pCounter->ThisValue.TimeStamp.dwLowDateTime,
                                                           pCounter->ThisValue.TimeStamp.dwHighDateTime);
                                if (llTimeStamp > pQuery->TimeRange.EndTime) {
                                    lStatus = PDH_NO_MORE_DATA;
                                    bLastLogEntry = TRUE;
                                    break;
                                }
                                dwCounter ++;
                            }
                            bCounterCollected = TRUE;
                        }
                        // go to next counter in list
                        pCounter = pCounter->next.flink;
                    }
                    while (pCounter != NULL && pCounter != pQuery->pCounterListHead);

                    if (bLastLogEntry) {
                        lStatus = PDH_NO_MORE_DATA;
                    }
                    else if (dwCounter == 0) {
                        lStatus = PDH_NO_DATA;
                    }
                    else if (bCounterCollected) {
                        lStatus = ERROR_SUCCESS;
                    }
                }
                else {
                    // no counters in the query  (?!)
                    lStatus = PDH_NO_DATA;
                }
            }
            else {
                // all samples in the requested time frame have
                // been returned.
                lStatus = PDH_NO_MORE_DATA;
            }
        }
    }
    * pTimeStamp = llTimeStamp;
    return lStatus;
}

DWORD
WINAPI
PdhiAsyncTimerThreadProc(
    LPVOID  pArg
)
{
    PPDHI_QUERY pQuery;
    DWORD       dwMsWaitTime;
    PDH_STATUS  Status;
    FILETIME    ftStart;
    FILETIME    ftStop;
    LONGLONG    llAdjustment;
    DWORD       dwInterval;
    LONG        lStatus = ERROR_SUCCESS;
    LONGLONG    llTimeStamp;

    pQuery     = (PPDHI_QUERY) pArg;
    dwInterval = dwMsWaitTime = pQuery->dwInterval * 1000; // convert sec. to mS.

    // wait for timeout or exit event, then update the specified query
    while ((lStatus = WaitForSingleObject(pQuery->hExitEvent, dwMsWaitTime)) != WAIT_OBJECT_0) {
        // time out elapsed so get new sample.
        GetSystemTimeAsFileTime(& ftStart);
        lStatus = WAIT_FOR_AND_LOCK_MUTEX(pQuery->hMutex);
        if (lStatus == ERROR_SUCCESS) {
            if (pQuery->dwFlags & PDHIQ_WBEM_QUERY) {
                Status = GetQueryWbemData(pQuery, & llTimeStamp);
            } else {
                Status = GetQueryPerfData(pQuery, & llTimeStamp);
            }
            SetEvent (pQuery->hNewDataEvent);
            RELEASE_MUTEX(pQuery->hMutex);
            GetSystemTimeAsFileTime(& ftStop);
            llAdjustment  = * (LONGLONG *) & ftStop;
            llAdjustment -= * (LONGLONG *) & ftStart;
            llAdjustment += 5000;   // for rounding
            llAdjustment /= 10000;  // convert 100ns Units to ms

            if (dwInterval > llAdjustment) {
                dwMsWaitTime = dwInterval - (DWORD) (llAdjustment & 0x00000000FFFFFFFF);
            }
            else {
                dwMsWaitTime = 0; // overdue so do it now.
            }
        }
    }
    return lStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhdll\vbfuncs.c ===
/*++
Copyright (C) 1995-1999 Microsoft Corporation

Module Name:
    vbfuncs.c

Abstract:
    Visual Basic interface functions exposed in pdh.dll
--*/
#include <windows.h>
#include "strsafe.h"
#include <winperf.h>
#include <pdh.h>
#include "pdhidef.h"
#include "pdhmsg.h"
#include "strings.h"

#define INITIAL_VB_LIST_SIZE (4096 * 4)
#define EXTEND_VB_LIST_SIZE  (4096 * 2)

typedef struct _VB_STRING_LIST {
    LPSTR   mszList;          // pointer to buffer containing strings
    LPSTR   szTermChar;       // pointer to "next" char to use
    DWORD   dwNumEntries;     // number of strings
    DWORD   dwSize;           // max size (in chars) of buffer
    DWORD   dwRemaining;      // # of chars left
    DWORD   dwLastEntryRead;  // index of last string read indicating index of....
    DWORD   dwLastItemLength; // length of last item read
    LPSTR   szLastItemRead;   // pointer to START of last item read
} VB_STRING_LIST, FAR * LPVB_STRING_LIST;

VB_STRING_LIST PdhivbList = { NULL, NULL, 0, 0, 0};

BOOL
PdhiAddStringToVbList(
    LPSTR szString
)
{
    DWORD             dwSize1, dwSize2;
    VB_STRING_LIST  * pVbList;
    BOOL              bReturn = FALSE;

    if (WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex) == ERROR_SUCCESS) {
        dwSize1 = lstrlenA(szString) + 1;
        pVbList = & PdhivbList;
        if (dwSize1 > pVbList->dwRemaining) {
            LPSTR lpTmp = pVbList->mszList;

            dwSize2          = (DWORD) (pVbList->szTermChar - pVbList->mszList);
            pVbList->dwSize += EXTEND_VB_LIST_SIZE;
            pVbList->mszList = G_REALLOC(lpTmp, pVbList->dwSize);
            if (pVbList->mszList == NULL) {
                G_FREE(lpTmp);
                ZeroMemory(pVbList, sizeof(VB_STRING_LIST));
                RELEASE_MUTEX(hPdhDataMutex);
                goto Cleanup;
            }
            else {
                // update values
                pVbList->szLastItemRead = pVbList->mszList;
                pVbList->szTermChar     = pVbList->mszList + dwSize2;
                pVbList->dwRemaining   += EXTEND_VB_LIST_SIZE;
            }
        }
        // copy new string
        StringCchCopyA(pVbList->szTermChar, pVbList->dwSize, szString);
        pVbList->dwNumEntries ++;
        pVbList->szTermChar  += dwSize1;
        pVbList->dwRemaining -= dwSize1;
        RELEASE_MUTEX(hPdhDataMutex);
        bReturn = TRUE;
    }
Cleanup:
    return bReturn;
}

void
PdhiDialogCallBack(
    DWORD_PTR dwArg
)
{
    // add strings in buffer to list boxpfdh
    LPTSTR         NewCounterName;
    LPTSTR         NewCounterName2;
    LPTSTR         szExpandedPath;
    DWORD          dwSize1, dwSize2;
    PDH_STATUS    pdhStatus = ERROR_SUCCESS;
    PPDH_BROWSE_DLG_CONFIG    pDlgConfig;

    pDlgConfig = (PPDH_BROWSE_DLG_CONFIG)dwArg;

    if (pDlgConfig->CallBackStatus == PDH_MORE_DATA) {
        // transfer buffer is too small for selection so extend it and
        // try again.
        if (pDlgConfig->szReturnPathBuffer != NULL) {
            G_FREE (pDlgConfig->szReturnPathBuffer);
        }
        pDlgConfig->cchReturnPathLength += EXTEND_VB_LIST_SIZE;
        pDlgConfig->szReturnPathBuffer =
            G_ALLOC ((pDlgConfig->cchReturnPathLength * sizeof (CHAR)));

        if (pDlgConfig->szReturnPathBuffer != NULL) {
            pdhStatus = PDH_RETRY;
        } else {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    } else {
        for (NewCounterName = pDlgConfig->szReturnPathBuffer;
            (*NewCounterName != 0) && (pdhStatus == ERROR_SUCCESS);
            NewCounterName += (lstrlen(NewCounterName) + 1)) {
            if (strstr (NewCounterName, caszSplat) == NULL) {
                // this is a regular path entry so add it to the VB List
                if (!PdhiAddStringToVbList (NewCounterName)) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            } else {
                szExpandedPath = G_ALLOC (INITIAL_VB_LIST_SIZE);
                if (szExpandedPath != NULL) {
                    // there's a wild card path character so expand it then enter them
                    // clear the list buffer
                    *(LPDWORD)szExpandedPath = 0;
                    dwSize1 = dwSize2 = INITIAL_VB_LIST_SIZE;
                    PdhExpandCounterPath (NewCounterName, szExpandedPath, &dwSize2);
                    if (dwSize2 < dwSize1) {
                        // then the returned buffer fit
                        for (NewCounterName2 = szExpandedPath;
                            *NewCounterName2 != 0;
                            NewCounterName2 += (lstrlen(NewCounterName2) + 1)) {

                            if (!PdhiAddStringToVbList (NewCounterName2)) {
                                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                                break; //out of loop
                            }
                        }
                    } else {
                        pdhStatus = PDH_INSUFFICIENT_BUFFER;
                    }
                    G_FREE (szExpandedPath);
                } else {
                    SetLastError (PDH_MEMORY_ALLOCATION_FAILURE);
                }
            }
        }
        // clear buffer
        ZeroMemory(pDlgConfig->szReturnPathBuffer,
                   (pDlgConfig->cchReturnPathLength * sizeof(CHAR)));
    }
    pDlgConfig->CallBackStatus = pdhStatus;
    return;
}

double
PdhVbGetDoubleCounterValue(
    IN  PDH_HCOUNTER hCounter,
    IN  LPDWORD      pdwCounterStatus
)
/*++
Routine Description:
    retrieves the current value of the specified counter and returns the
        formatted version to the caller.

Arguments:
    IN  HCOUNTER hCounter
        pointer to the counter to get the data for
    IN LPDWORD  pdwCounterStatus
        status value of this counter. This value should be checked to
        insure the data is valid. If the status is not successful, then
        the data returned cannot be trusted and should not be used

Return Value:
    a double precesion floating point value of the current counter value
        formatted and computed as required by the counter type.
--*/
{
    PDH_STATUS  pdhStatus;
    PDH_FMT_COUNTERVALUE    pdhValue;
    DWORD       dwCounterType;
    double    dReturn;

    pdhStatus = PdhGetFormattedCounterValue (
        hCounter, PDH_FMT_DOUBLE | PDH_FMT_NOCAP100, &dwCounterType, &pdhValue);

    if (pdhStatus == ERROR_SUCCESS) {
        // the function was successful so return the counter status
        // and the returned value
        pdhStatus = pdhValue.CStatus;
        dReturn = pdhValue.doubleValue;
    } else {
        // the function returned an error so return the
        // error in the status field & 0.0 for a value
        dReturn = 0.0f;
    }

    if (pdwCounterStatus != NULL) {
        __try {
            *pdwCounterStatus = pdhStatus;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            // unable to write to status variable
            // don't worry about it, since it's optional and there's not much
            // we can do here anyway.
        }
    }
    return dReturn;
}

DWORD
PdhVbGetOneCounterPath(
    IN  LPSTR  szPathBuffer,
    IN  DWORD  cchBufferLength,
    IN  DWORD  dwDetailLevel,
    IN  LPCSTR szCaption
)
/*++
Routine Description:
    Retrieves one path string from the buffer of stored counter paths
        assembled by the most recent call to PdhVbCreateCounterPathList

Arguments:
    LPSTR   szPathBuffer
        string buffer to return selected counter path in
    DWORD   cchBufferLength
        size of string buffer in characters
    DWORD   dwDetailLevel
        detail level to filter the counters by
    LPCSTR  szCaption
        string to display in the caption bar

Return Value:
    returns the length of the path string in characters returned
        to the caller.
--*/
{
    PDH_BROWSE_DLG_CONFIG_A BrowseConfig;
    PDH_STATUS              PdhStatus = ERROR_SUCCESS;
    DWORD                   dwReturn = 0;

    // test access to caller supplied buffer
    __try {
        CHAR cChar;
        if ((cchBufferLength > 0) && (szPathBuffer != NULL)) {
            cChar                             = szPathBuffer[0];
            szPathBuffer[0]                   = '\0';
            szPathBuffer[0]                   = cChar;
            cChar                             = szPathBuffer[cchBufferLength - 1];
            szPathBuffer[cchBufferLength - 1] = '\0';
            szPathBuffer[cchBufferLength - 1] = cChar;
        }
        else {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }

        if (szCaption != NULL) {
            cChar = * ((CHAR volatile *) szCaption);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        PdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (PdhStatus == ERROR_SUCCESS) {
        ZeroMemory(& BrowseConfig, sizeof(PDH_BROWSE_DLG_CONFIG_A));
        BrowseConfig.bIncludeInstanceIndex    = FALSE;
        BrowseConfig.bSingleCounterPerAdd     = TRUE;
        BrowseConfig.bSingleCounterPerDialog  = TRUE;
        BrowseConfig.bLocalCountersOnly       = FALSE;
        BrowseConfig.bWildCardInstances       = FALSE;
        BrowseConfig.bDisableMachineSelection = FALSE;
        BrowseConfig.bHideDetailBox           = (dwDetailLevel > 0 ? TRUE : FALSE);
        BrowseConfig.hWndOwner                = NULL;  // there should be some way to get this
        BrowseConfig.szReturnPathBuffer       = szPathBuffer;
        BrowseConfig.cchReturnPathLength      = cchBufferLength;
        BrowseConfig.pCallBack                = NULL;
        BrowseConfig.dwCallBackArg            = 0;
        // default is to show ALL counters
        BrowseConfig.dwDefaultDetailLevel     = (dwDetailLevel > 0 ? dwDetailLevel : PERF_DETAIL_WIZARD);
        BrowseConfig.szDialogBoxCaption       = (LPSTR) szCaption;

        PdhStatus = PdhBrowseCountersA(& BrowseConfig);
    }

    if (PdhStatus == ERROR_SUCCESS) {
        dwReturn = lstrlenA(szPathBuffer);
    }
    else {
        dwReturn = 0;
    }
    return dwReturn;
}

DWORD
PdhVbCreateCounterPathList(
    IN  DWORD  dwDetailLevel,
    IN  LPCSTR szCaption
)
/*++
Routine Description:
    Displays the counter browsing dialog box and allows the user to select
        multiple counter paths. As the paths are selected, they are stored
        in an internal buffer for later retrieval by the caller.

    NOTE, that calling this function will clear any previous selections.

Arguments:
    DWORD   dwDetailLevel
        detail level to filter the counters by
    LPCSTR  szCaption
        string to display in the caption bar

Return Value:
    returns the number of path strings selected by the user that must
        be retrieved by the caller.
--*/
{
    PDH_STATUS              PdhStatus = ERROR_SUCCESS;
    PDH_BROWSE_DLG_CONFIG_A BrowseConfig;
    DWORD                   dwReturn = 0;

    // test access to caller supplied buffer
    __try {
        CHAR cChar;
        if (szCaption != NULL) {
            cChar = * ((CHAR volatile *) szCaption);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        PdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (PdhStatus == ERROR_SUCCESS) {
        PdhStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);
        if (PdhStatus == ERROR_SUCCESS) {
            if (PdhivbList.mszList != NULL) {
                G_FREE(PdhivbList.mszList);
                ZeroMemory((LPVOID) & PdhivbList, sizeof(VB_STRING_LIST));
            }
            PdhivbList.mszList = G_ALLOC(INITIAL_VB_LIST_SIZE);
            if (PdhivbList.mszList != NULL) {
                PdhivbList.szLastItemRead   = PdhivbList.mszList;
                PdhivbList.szTermChar       = PdhivbList.mszList;
                PdhivbList.dwRemaining      = INITIAL_VB_LIST_SIZE;
                PdhivbList.dwSize           = INITIAL_VB_LIST_SIZE;
                PdhivbList.dwLastEntryRead  = 0;
                PdhivbList.dwLastItemLength = 0;
            }
            else {
                PdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
            RELEASE_MUTEX(hPdhDataMutex);
        }
    }

    if (PdhStatus == ERROR_SUCCESS) {
        ZeroMemory(& BrowseConfig, sizeof(PDH_BROWSE_DLG_CONFIG_A));
        BrowseConfig.bIncludeInstanceIndex    = FALSE;
        BrowseConfig.bSingleCounterPerAdd     = FALSE;
        BrowseConfig.bSingleCounterPerDialog  = FALSE;
        BrowseConfig.bLocalCountersOnly       = FALSE;
        BrowseConfig.bWildCardInstances       = FALSE;
        BrowseConfig.bDisableMachineSelection = FALSE;
        BrowseConfig.bHideDetailBox           = (dwDetailLevel > 0 ? TRUE : FALSE);
        BrowseConfig.hWndOwner                = NULL;  // there should be some way to get this
        BrowseConfig.szReturnPathBuffer       = G_ALLOC (INITIAL_VB_LIST_SIZE);
        if (BrowseConfig.szReturnPathBuffer != NULL) {
            BrowseConfig.cchReturnPathLength  = (BrowseConfig.szReturnPathBuffer != NULL ? INITIAL_VB_LIST_SIZE : 0);
            BrowseConfig.pCallBack            = (CounterPathCallBack) PdhiDialogCallBack;
            BrowseConfig.dwCallBackArg        = (DWORD_PTR) & BrowseConfig;
            // default is to show ALL counters
            BrowseConfig.dwDefaultDetailLevel = (dwDetailLevel > 0 ? dwDetailLevel : PERF_DETAIL_WIZARD);
            BrowseConfig.szDialogBoxCaption   = (LPSTR)szCaption;

            PdhStatus = PdhBrowseCountersA(& BrowseConfig);
            if (BrowseConfig.szReturnPathBuffer != NULL) {
                G_FREE(BrowseConfig.szReturnPathBuffer);
            }
            dwReturn = PdhivbList.dwNumEntries;
        }
        else {
            SetLastError(PDH_MEMORY_ALLOCATION_FAILURE);
            dwReturn = 0;
        }
    }
    return dwReturn;
}

DWORD
PdhVbGetCounterPathFromList(
    IN  DWORD dwIndex,     // starting at 1 for VB types
    IN  LPSTR szBuffer,    // return buffer
    IN  DWORD dwBufferSize // size in chars of buffer
)
/*++
Routine Description:
    Displays the counter browsing dialog box and allows the user to select
        multiple counter paths. As the paths are selected, they are stored
        in an internal buffer for later retrieval by the caller.

    NOTE, that calling this function will clear any previous selections.

Arguments:
    DWORD       dwIndex
        The "1-based" index of the counter path to retrieve from
        the list of selected counter paths generated by the previous
        call to PdhVbCreateCounterPathList.
    LPSTR       szBuffer
        string buffer to return the selected string in
    DWORD       dwBufferSize
        size of the szBuffer in characters

Return Value:
    Returns the number of characters copied to the calling function
--*/
{
    DWORD dwBuffIndex;    // 0-based index for "c"
    DWORD dwThisIndex;
    DWORD dwCharsCopied;  // size of string not counting term NULL
    BOOL  bContinue = TRUE;

    dwBuffIndex   = dwIndex - 1;
    dwCharsCopied = 0;

    // validate the arguments
    __try {
        if (dwBufferSize > 0) {
            // try writing to ouput buffer
            szBuffer[0]                = '\0';
            szBuffer[dwBufferSize - 1] = '\0';
        }
        else {
            bContinue = FALSE;
        }
        if (dwBuffIndex >= PdhivbList.dwNumEntries) {
            bContinue = FALSE;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        bContinue = FALSE;
    }

    if (WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex) == ERROR_SUCCESS) {
        if (bContinue) {
            if (PdhivbList.szLastItemRead == NULL) {
                PdhivbList.szLastItemRead   = PdhivbList.mszList;
                PdhivbList.dwLastEntryRead  = 0;
                PdhivbList.dwLastItemLength = 0;
            }
            if (PdhivbList.szLastItemRead != NULL) {
                if (PdhivbList.dwLastItemLength == 0) {
                    PdhivbList.dwLastItemLength = lstrlen(PdhivbList.szLastItemRead) + 1;
                }
            }
            else {
                bContinue = FALSE;
            }
        }

        if (bContinue) {
            // see if this is the next entry
            if (dwBuffIndex == (PdhivbList.dwLastEntryRead + 1)) {
                PdhivbList.szLastItemRead  += PdhivbList.dwLastItemLength;
                PdhivbList.dwLastItemLength = lstrlen(PdhivbList.szLastItemRead) + 1;
                PdhivbList.dwLastEntryRead ++;
                if (PdhivbList.dwLastItemLength < dwBufferSize) {
                    StringCchCopyA(szBuffer, dwBufferSize, PdhivbList.szLastItemRead);
                    dwCharsCopied = PdhivbList.dwLastItemLength - 1;
                }
            }
            else if (dwBuffIndex == PdhivbList.dwLastEntryRead) {
                // it's this one (again)
                if (PdhivbList.dwLastItemLength < dwBufferSize) {
                    StringCchCopyA(szBuffer, dwBufferSize, PdhivbList.szLastItemRead);
                    dwCharsCopied = PdhivbList.dwLastItemLength - 1;
                }
            }
            else {
                // walk the list to the desired entry (ugh!)
                PdhivbList.szLastItemRead = PdhivbList.mszList;
                for (dwThisIndex = 0; dwThisIndex < dwBuffIndex; dwThisIndex++) {
                    PdhivbList.szLastItemRead += lstrlen(PdhivbList.szLastItemRead) + 1;
                }
                PdhivbList.dwLastItemLength = lstrlen(PdhivbList.szLastItemRead) + 1;
                PdhivbList.dwLastEntryRead  = dwThisIndex;
                if (PdhivbList.dwLastItemLength < dwBufferSize) {
                    StringCchCopyA(szBuffer, dwBufferSize, PdhivbList.szLastItemRead);
                    dwCharsCopied = PdhivbList.dwLastItemLength - 1;
                }
            }
        }
        RELEASE_MUTEX(hPdhDataMutex);
    }
    return dwCharsCopied;
}

DWORD
PdhVbGetCounterPathElements(
    IN  LPCSTR szPathString,
    IN  LPSTR  szMachineName,
    IN  LPSTR  szObjectName,
    IN  LPSTR  szInstanceName,
    IN  LPSTR  szParentInstance,
    IN  LPSTR  szCounterName,
    IN  DWORD  dwBufferSize
)
/*++
Routine Description:
    breaks the counter path provided in the szPathString argument and
        returns the components in the buffers provided by the caller.
        The buffers must be at least "dwBufferSize" in length.

Arguments:
    LPCSTR  szPathString
        pointer to the full counter path that is to be parsed into
        component strings
    LPSTR   szMachineName
        caller supplied buffer that is to receive the machine name.
        The buffer must be at least dwBufferSize in length.
    LPSTR   szObjectName
        caller supplied buffer that is to receive the object name.
        The buffer must be at least dwBufferSize in length.
    LPSTR   szInstanceName
        caller supplied buffer that is to receive the Instance name.
        The buffer must be at least dwBufferSize in length.
    LPSTR   szParentInstance
        caller supplied buffer that is to receive the parent instance name.
        The buffer must be at least dwBufferSize in length.
    LPSTR   szCounterName
        caller supplied buffer that is to receive the counter name.
        The buffer must be at least dwBufferSize in length.
    DWORD   dwBufferSize
        The buffer size of the caller supplied string buffers in characters

Return Value:
    ERROR_SUCCESS if the counter string is successfully parsed, otherwise
        a PDH error if not.
    PDH_INVALID_ARGUMENT if one or more of the string buffers is not
        the correct size
    PDH_INSUFFICIENT_BUFFER if one or more of the counter path elements
        is too large for the return buffer length.
    PDH_MEMORY_ALLOCATION_FAILURE if a temporary memory buffer could not
        be allocated.
--*/
{
    PPDH_COUNTER_PATH_ELEMENTS_A pInfo;
    PDH_STATUS                   pdhStatus = ERROR_SUCCESS;
    DWORD                        dwSize;

    // validate the return arguments
    __try {
        CHAR    cChar;
        if (szPathString != NULL) {
            cChar = * ((CHAR volatile *) szPathString);
            if (cChar == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
        else {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        if (pdhStatus == ERROR_SUCCESS){
            if (szMachineName != NULL) {
                szMachineName[0]                = '\0';
                szMachineName[dwBufferSize - 1] = '\0';
            }
            else {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }

        if (pdhStatus == ERROR_SUCCESS){
            if (szObjectName != NULL) {
                szObjectName[0]                = '\0';
                szObjectName[dwBufferSize - 1] = '\0';
            }
            else {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }

        if (pdhStatus == ERROR_SUCCESS){
            if (szInstanceName != NULL) {
                szInstanceName[0]                = '\0';
                szInstanceName[dwBufferSize - 1] = '\0';
            }
            else {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }

        if (pdhStatus == ERROR_SUCCESS){
            if (szParentInstance != NULL) {
                szParentInstance[0]                = '\0';
                szParentInstance[dwBufferSize - 1] = '\0';
            }
            else {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }


        if (pdhStatus == ERROR_SUCCESS){
            if (szCounterName != NULL) {
                szCounterName[0]                = '\0';
                szCounterName[dwBufferSize - 1] = '\0';
            } else {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // allocate temp buffer for component strings
        dwSize = (5 * dwBufferSize) + sizeof(PDH_COUNTER_INFO_A);
        pInfo = G_ALLOC (dwSize);
        if (pInfo != NULL) {
            pdhStatus = PdhParseCounterPathA(szPathString, pInfo, & dwSize, 0);
            if (pdhStatus == ERROR_SUCCESS) {
                // move from local structure to user args if the strings will fit
                if (pInfo->szMachineName != NULL) {
                    if (FAILED(StringCchCopyA(szMachineName, dwBufferSize, pInfo->szMachineName))) {
                        pdhStatus = PDH_INSUFFICIENT_BUFFER;
                    }
                }

                if (pInfo->szObjectName != NULL) {
                    if (FAILED(StringCchCopyA(szObjectName, dwBufferSize, pInfo->szObjectName))) {
                        pdhStatus = PDH_INSUFFICIENT_BUFFER;
                    }
                }

                if (pInfo->szInstanceName != NULL) {
                    if (FAILED(StringCchCopyA(szInstanceName, dwBufferSize, pInfo->szInstanceName))) {
                        pdhStatus = PDH_INSUFFICIENT_BUFFER;
                    }
                }

                if (pInfo->szParentInstance != NULL) {
                    if (FAILED(StringCchCopyA(szParentInstance, dwBufferSize, pInfo->szParentInstance))) {
                        pdhStatus = PDH_INSUFFICIENT_BUFFER;
                    }
                }

                if (pInfo->szCounterName != NULL) {
                    if (FAILED(StringCchCopyA(szCounterName, dwBufferSize, pInfo->szCounterName))) {
                        pdhStatus = PDH_INSUFFICIENT_BUFFER;
                    }
                }
            } // else pass error to caller
            G_FREE (pInfo);
        }
        else {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    } // else pass error to caller

    return pdhStatus;
}

DWORD
PdhVbAddCounter(
    IN  PDH_HQUERY     hQuery,
    IN  LPCSTR         szFullCounterPath,
    IN  PDH_HCOUNTER * hCounter
)
/*++
Routine Description:
    Creates and initializes a counter structure and attaches it to the
        specified query by calling the C function.

Arguments:
    IN  HQUERY  hQuery
        handle of the query to attach this counter to once the counter
        entry has been successfully created.
    IN  LPCSTR szFullCounterPath
        pointer to the path string that describes the counter to add to
        the query referenced above. This string must specify a single
        counter. Wildcard path strings are not permitted.
    IN  HCOUNTER *phCounter
        pointer to the buffer that will get the handle value of the
        successfully created counter entry.

Return Value:
    Returns ERROR_SUCCESS if a new query was created and initialized,
        and a PDH_ error value if not.
    PDH_INVALID_ARGUMENT is returned when one or more of the arguements
        is invalid or incorrect.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a memory buffer could
        not be allocated.
    PDH_INVALID_HANDLE is returned if the query handle is not valid.
    PDH_CSTATUS_NO_COUNTER is returned if the specified counter was
        not found
    PDH_CSTATUS_NO_OBJECT is returned if the specified object could
        not be found
    PDH_CSTATUS_NO_MACHINE is returned if a machine entry could not
        be created.
    PDH_CSTATUS_BAD_COUNTERNAME is returned if the counter name path
        string could not be parsed or interpreted
    PDH_CSTATUS_NO_COUNTERNAME is returned if an empty counter name
        path string is passed in
    PDH_FUNCTION_NOT_FOUND is returned if the calculation function
        for this counter could not be determined.
--*/
{
    DWORD        dwReturn      = ERROR_SUCCESS;
    PDH_HCOUNTER hLocalCounter = NULL;

    if ((hCounter == NULL) || (szFullCounterPath == NULL)) {
        dwReturn = PDH_INVALID_ARGUMENT;
    }
    else {
        dwReturn = PdhAddCounterA(hQuery, szFullCounterPath, 0, & hLocalCounter);
    }

    if (dwReturn == ERROR_SUCCESS) {
        __try {
            * hCounter = hLocalCounter;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwReturn = PDH_INVALID_ARGUMENT;
        }
    }
    return dwReturn;
}

DWORD
PdhVbOpenQuery(
    IN  PDH_HQUERY * phQuery
)
/*++
Routine Description:
    allocates a new query structure for a VB app by calling the "C"
    function with the rest of the arguments supplied

Arguments:
    IN  HQUERY  *phQuery
        pointer to the buffer that will receive the query handle opened.

Return Value:
    Returns ERROR_SUCCESS if a new query was created and initialized,
        and a PDH_ error value if not.
    PDH_INVALID_ARGUMENT is returned when one or more of the arguements
        is invalid or incorrect.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a memory buffer could
        not be allocated.
--*/
{
    DWORD      dwReturn    = ERROR_SUCCESS;
    PDH_HQUERY hLocalQuery = NULL;

    if (phQuery == NULL) {
        dwReturn = PDH_INVALID_ARGUMENT;
    }
    else {
        dwReturn = PdhOpenQuery(NULL, 0, & hLocalQuery);
    }

    if (dwReturn == ERROR_SUCCESS) {
        __try {
            * phQuery = hLocalQuery;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            dwReturn = PDH_INVALID_ARGUMENT;
        }
    }
    return dwReturn;
}

DWORD
PdhVbIsGoodStatus(
    IN  LONG lStatus
)
/*++
Routine Description:
    Checks the status severity of the PDH status value
    passed into the function as a binary Good (TRUE)/Bad (FALSE)
    value.

Arguments:
    IN  LONG lStatus
        Status code to test

Return Value:
    TRUE  if the status code is Success or Informational severity
    FALSE if the status code is Error or Warning severity
--*/
{
    BOOL   bReturn;

    if (lStatus == ERROR_SUCCESS) {
        bReturn = TRUE;
    }
    else if (IsSuccessSeverity(lStatus)) {
        bReturn = TRUE;
    }
    else if (IsInformationalSeverity(lStatus)) {
        bReturn = TRUE;
    }
    else {
        bReturn = FALSE;
    }

    return (DWORD) bReturn;
}

DWORD
PdhVbOpenLog(
    IN  LPCSTR     szLogFileName,
    IN  DWORD      dwAccessFlags,
    IN  LPDWORD    lpdwLogType,
    IN  HQUERY     hQuery,
    IN  DWORD      dwMaxSize,
    IN  LPCSTR     szUserCaption,
    IN  PDH_HLOG * phLog
)
/*++
Routine Description:

Arguments:
    IN      LPCSTR  szLogFileName,
    IN      DWORD   dwAccessFlags,
    IN      LPDWORD lpdwLogType,
    IN      HQUERY  hQuery,
    IN      DWORD   dwMaxSize,
    IN      LPCSTR  szUserCaption,
    IN      HLOG    * phLog

Return Value:
    TRUE  if the status code is Success or Informational severity
    FALSE if the status code is Error or Warning severity
--*/
{
    return PdhOpenLogA(szLogFileName, dwAccessFlags, lpdwLogType, hQuery, dwMaxSize, szUserCaption, phLog);
}

DWORD
PdhVbUpdateLog(
    IN  PDH_HLOG hLog,
    IN  LPCSTR   szUserString
)
/*++
Routine Description:

Arguments:
    IN      HLOG    hLog,
    IN      LPCWSTR szUserString

Return Value:
    TRUE  if the status code is Success or Informational severity
    FALSE if the status code is Error or Warning severity
--*/
{
    return PdhUpdateLogA(hLog, szUserString);
}

DWORD 
PdhVbGetLogFileSize(
    IN  PDH_HLOG   hLog,
    IN  LONG     * lSize      
)
/*++
Routine Description:

Arguments:
    IN      HLOG       hLog,
    IN      LONGLONG * llSize     

Return Value:
    TRUE  if the status code is Success or Informational severity
    FALSE if the status code is Error or Warning severity
--*/
{
    PDH_STATUS  pdhStatus;
    LONGLONG    llTemp;

    pdhStatus = PdhGetLogFileSize(hLog, & llTemp);
    if (pdhStatus == ERROR_SUCCESS) {
        if (llTemp > 0x0000000080000000) {
            // file size is larger than a long value
            pdhStatus = PDH_INSUFFICIENT_BUFFER;
        }
        else {
            __try {
                * lSize = (LONG) (llTemp & 0x000000007FFFFFFF);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
    }
    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhdll\query.c ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    query.c

Abstract:

    Query management functions exposed in pdh.dll

--*/

#include <windows.h>
#include <winperf.h>
#include <math.h>
#include "mbctype.h"
#include "strsafe.h"
#include <pdh.h>
#include "pdhitype.h"
#include "pdhidef.h"
#include "pdhmsg.h"
#include "strings.h"

STATIC_BOOL  IsValidLogHandle(IN HLOG hLog);
PDH_FUNCTION PdhiRewindWmiLog(IN PPDHI_LOG pLog);

// query link list head pointer
PPDHI_QUERY PdhiDllHeadQueryPtr = NULL;

STATIC_BOOL
PdhiFreeQuery(
    PPDHI_QUERY pThisQuery
)
/*++

Routine Description:

    removes the query from the list of queries and updates the list
        linkages

Arguments:

    IN  PPDHI_QUERY pThisQuery
        pointer to the query to remove. No testing is performed on
        this pointer so it's assumed to be a valid query pointer.
        The pointer is invalid when this function returns.

Return Value:

    TRUE

--*/
{
    PPDHI_QUERY         pPrevQuery;
    PPDHI_QUERY         pNextQuery;
    PPDHI_COUNTER       pThisCounter;
    PPDHI_QUERY_MACHINE pQMachine;
    PPDHI_QUERY_MACHINE pNextQMachine;
    LONG                lStatus;
    BOOL                bStatus;
    HANDLE              hQueryMutex;

    if (WAIT_FOR_AND_LOCK_MUTEX(pThisQuery->hMutex) != ERROR_SUCCESS)
        return WAIT_TIMEOUT;

    TRACE((PDH_DBG_TRACE_INFO),
          (__LINE__,
           PDH_QUERY,
           ARG_DEF(ARG_TYPE_PTR, 1) | ARG_DEF(ARG_TYPE_ULONGX, 2),
           ERROR_SUCCESS,
           TRACE_PTR(pThisQuery),
           TRACE_DWORD(pThisQuery->dwFlags),
           NULL));
    hQueryMutex = pThisQuery->hMutex;

    // close any async data collection threads

    if (pThisQuery->hExitEvent != NULL) {
        RELEASE_MUTEX(pThisQuery->hMutex);
        // stop current thread first
        SetEvent(pThisQuery->hExitEvent);
        // wait 1 second for the thread to stop
        lStatus = WaitForSingleObject(pThisQuery->hAsyncThread, 10000L);
        if (lStatus == WAIT_TIMEOUT) {
            TRACE((PDH_DBG_TRACE_ERROR), (__LINE__, PDH_QUERY, 0, lStatus, NULL));
        }

        if (WAIT_FOR_AND_LOCK_MUTEX(pThisQuery->hMutex) != ERROR_SUCCESS)
            return WAIT_TIMEOUT;

        bStatus = CloseHandle(pThisQuery->hExitEvent);
        pThisQuery->hExitEvent = NULL;
    }

    // define pointers
    pPrevQuery = pThisQuery->next.blink;
    pNextQuery = pThisQuery->next.flink;

    // free any counters in counter list
    if ((pThisCounter = pThisQuery->pCounterListHead) != NULL) {
        while (pThisCounter->next.blink != pThisCounter->next.flink) {
            // delete from list
            // the deletion routine updates the blink pointer as it
            // removes the specified entry.
            FreeCounter(pThisCounter->next.blink);
        }
        // remove last counter
        FreeCounter(pThisCounter);
        pThisQuery->pCounterListHead = NULL;
    }

    if (!(pThisQuery->dwFlags & PDHIQ_WBEM_QUERY)) {
        // free allocated memory in the query
        if ((pQMachine = pThisQuery->pFirstQMachine) != NULL) {
            //  Free list of machine pointers
            do {
                pNextQMachine = pQMachine->pNext;
                if (pQMachine->pPerfData != NULL) {
                    G_FREE(pQMachine->pPerfData);
                }
                G_FREE(pQMachine);
                pQMachine = pNextQMachine;
            }
            while (pQMachine != NULL);
            pThisQuery->pFirstQMachine = NULL;
        }
    }

    if (pThisQuery->dwFlags & PDHIQ_WBEM_QUERY) {
        lStatus = PdhiFreeWbemQuery(pThisQuery);
    }

    if (pThisQuery->dwReleaseLog != FALSE && pThisQuery->hLog != H_REALTIME_DATASOURCE
                                          && pThisQuery->hLog != H_WBEM_DATASOURCE) {
        PdhCloseLog(pThisQuery->hLog, 0);
        pThisQuery->hLog = H_REALTIME_DATASOURCE;
    }
    if (pThisQuery->hOutLog != NULL && IsValidLogHandle(pThisQuery->hOutLog)) {
        PPDHI_LOG pOutLog = (PPDHI_LOG) pThisQuery->hOutLog;
        pOutLog->pQuery = NULL;
    }

    // update pointers
    if (pPrevQuery == pThisQuery && pNextQuery == pThisQuery) {
        // then this query is the only (i.e. last) one in the list
        PdhiDllHeadQueryPtr = NULL;
    }
    else {
        // update query list pointers
        pPrevQuery->next.flink = pNextQuery;
        pNextQuery->next.blink = pPrevQuery;
        if (PdhiDllHeadQueryPtr == pThisQuery) {
            // then this is the first entry in the list so point to the
            // next one in line
            PdhiDllHeadQueryPtr = pNextQuery;
        }
    }

    if (pThisQuery->hMutex != NULL) {        
        pThisQuery->hMutex = NULL;
    }

    // delete this query
    G_FREE(pThisQuery);

    // release and free the query mutex
    RELEASE_MUTEX(hQueryMutex);
    CloseHandle(hQueryMutex);

    return TRUE;
}

PDH_FUNCTION
PdhOpenQueryH(
    IN  PDH_HLOG     hDataSource,
    IN  DWORD_PTR    dwUserData,
    IN  PDH_HQUERY * phQuery
)
{
    PPDHI_QUERY pNewQuery;
    PPDHI_QUERY pLastQuery;
    PDH_STATUS  ReturnStatus = ERROR_SUCCESS;
    BOOL        bWbemData    = FALSE;
    PPDHI_LOG   pDataSource  = NULL;
    DWORD       dwDataSource;
    DWORD_PTR   dwLocalData;

    __try {
        dwLocalData  = dwUserData;
        dwDataSource = DataSourceTypeH(hDataSource);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        ReturnStatus = PDH_INVALID_ARGUMENT;
        goto Cleanup;
    }
 
    if (phQuery == NULL) {
        ReturnStatus = PDH_INVALID_ARGUMENT;
        goto Cleanup;
    }

    if (dwDataSource == DATA_SOURCE_WBEM) {
        hDataSource = H_WBEM_DATASOURCE;
        bWbemData   = TRUE;
    }

    if (dwDataSource == DATA_SOURCE_WBEM || dwDataSource == DATA_SOURCE_REGISTRY) {
        pDataSource = NULL;
    }
    else if (IsValidLogHandle(hDataSource)) {
        pDataSource = (PPDHI_LOG) hDataSource;
    }
    else {
        ReturnStatus = PDH_INVALID_ARGUMENT;
        goto Cleanup;
    }

    ReturnStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);
    
    if (ReturnStatus == ERROR_SUCCESS) {
        pNewQuery = G_ALLOC(sizeof (PDHI_QUERY));
        if (pNewQuery == NULL) {
            ReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }

        if (ReturnStatus == ERROR_SUCCESS) {
            pNewQuery->hMutex = CreateMutexW(NULL, TRUE, NULL);
            * (DWORD *)(& pNewQuery->signature[0]) = SigQuery;
            if (PdhiDllHeadQueryPtr == NULL) {
                PdhiDllHeadQueryPtr = pNewQuery->next.flink = pNewQuery->next.blink = pNewQuery;
            }
            else {
                pLastQuery                      = PdhiDllHeadQueryPtr->next.blink;
                pNewQuery->next.flink           = PdhiDllHeadQueryPtr;
                pNewQuery->next.blink           = pLastQuery;
                PdhiDllHeadQueryPtr->next.blink = pNewQuery;
                pLastQuery->next.flink          = pNewQuery;
            }

            pNewQuery->pCounterListHead = NULL;
            pNewQuery->pFirstQMachine   = NULL;
            pNewQuery->dwLength         = sizeof(PDHI_QUERY);
            pNewQuery->dwUserData       = dwLocalData;
            pNewQuery->dwFlags          = 0;
            pNewQuery->dwFlags         |= (bWbemData ? PDHIQ_WBEM_QUERY : 0);
            pNewQuery->hLog             = hDataSource;
            pNewQuery->dwReleaseLog     = FALSE;
            if (pDataSource != NULL && LOWORD(pDataSource->dwLogFormat) == PDH_LOG_TYPE_BINARY) {
                ReturnStatus = PdhiRewindWmiLog(pDataSource);
                if (ReturnStatus != ERROR_SUCCESS) {
                    RELEASE_MUTEX(pNewQuery->hMutex);
                    RELEASE_MUTEX(hPdhDataMutex);
                    goto Cleanup;
                }
            }
            pNewQuery->hOutLog          = NULL;

            * (LONGLONG *)(& pNewQuery->TimeRange.StartTime) = MIN_TIME_VALUE;
            * (LONGLONG *)(& pNewQuery->TimeRange.EndTime)   = MAX_TIME_VALUE;
            pNewQuery->TimeRange.SampleCount                 = 0;
            pNewQuery->dwLastLogIndex                        = 0;
            pNewQuery->dwInterval                            = 0;
            pNewQuery->hAsyncThread                          = NULL;
            pNewQuery->hExitEvent                            = NULL;
            pNewQuery->hNewDataEvent                         = NULL;

            pNewQuery->pRefresher    = NULL;
            pNewQuery->pRefresherCfg = NULL;
            pNewQuery->LangID        = GetUserDefaultUILanguage();

            RELEASE_MUTEX(pNewQuery->hMutex);

            __try {
                * phQuery    = (HQUERY) pNewQuery;
                if(pDataSource != NULL) {
                    pDataSource->pQuery = (HQUERY) pNewQuery;
                }
                ReturnStatus = ERROR_SUCCESS;
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                if (pNewQuery != NULL) {
                    PdhiFreeQuery(pNewQuery);
                }
                ReturnStatus = PDH_INVALID_ARGUMENT;
            }
        }
        RELEASE_MUTEX(hPdhDataMutex);
    } 

Cleanup:
    if (ReturnStatus == ERROR_SUCCESS) {
        if (hDataSource == H_REALTIME_DATASOURCE || hDataSource == H_WBEM_DATASOURCE) {
            dwCurrentRealTimeDataSource ++;
        }
    }

    TRACE((PDH_DBG_TRACE_INFO),
          (__LINE__,
           PDH_QUERY,
           ARG_DEF(ARG_TYPE_PTR, 1) | ARG_DEF(ARG_TYPE_PTR, 2)
                                    | ARG_DEF(ARG_TYPE_PTR, 3),
           ReturnStatus,
           TRACE_PTR(hDataSource),
           TRACE_PTR(phQuery),
           TRACE_PTR(pNewQuery),
           TRACE_DWORD(dwDataSource),
           TRACE_DWORD(dwCurrentRealTimeDataSource),
           NULL));

    return ReturnStatus;
}

PDH_FUNCTION
PdhOpenQueryW(
    IN  LPCWSTR      szDataSource,
    IN  DWORD_PTR    dwUserData,
    IN  PDH_HQUERY * phQuery
)
/*++
Routine Description:
    allocates a new query structure and inserts it at the end of the
    query list.

Arguments:
    IN      LPCWSTR szDataSource
        the name of the data (log) file to read from or NULL if the
        current activity is desired.
    IN      DWORD   dwUserData
        the user defined data field for this query,

Return Value:
    Returns ERROR_SUCCESS if a new query was created and initialized,
        and a PDH_ error value if not.
    PDH_INVALID_ARGUMENT is returned when one or more of the arguements
        is invalid or incorrect.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a memory buffer could
        not be allocated.
--*/
{
    PPDHI_QUERY pNewQuery;
    PPDHI_QUERY pLastQuery;
    PDH_STATUS  ReturnStatus = ERROR_SUCCESS;
    HLOG        hLogLocal    = NULL;
    DWORD       dwLogType    = 0;
    BOOL        bWbemData    = FALSE;
    DWORD       dwDataSource = 0;
    DWORD_PTR   dwLocalData;

    // try writing to return pointer
    if (phQuery == NULL) {
       ReturnStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            if (szDataSource != NULL) {
                dwLocalData = lstrlenW(szDataSource);

                if (dwLocalData == 0 || dwLocalData > PDH_MAX_DATASOURCE_PATH) {
                    ReturnStatus = PDH_INVALID_ARGUMENT;
                }
                else if (* szDataSource == L'\0') {
                    // test for read access to the name
                    ReturnStatus = PDH_INVALID_ARGUMENT;
                }
            } // else NULL is a valid arg
            if (ReturnStatus == ERROR_SUCCESS) {
                dwLocalData  = dwUserData;
                dwDataSource = DataSourceTypeW(szDataSource);
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            ReturnStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (ReturnStatus == ERROR_SUCCESS) {
        // validate the data source
        switch (dwDataSource) {
        case DATA_SOURCE_LOGFILE:
            // then they are planning to read from a log file so
            // try to open it
            ReturnStatus = PdhOpenLogW(szDataSource,
                                       PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                                       &dwLogType,
                                       NULL,
                                       0,
                                       NULL,
                                       & hLogLocal);
            break;

        case DATA_SOURCE_WBEM:
            bWbemData = TRUE;
            // they want real-time data, so just keep going
            hLogLocal = NULL;
            break;

        case DATA_SOURCE_REGISTRY:
            // they want real-time data, so just keep going
            hLogLocal = NULL;
            break;

        default:
            break;
        }
    }
    if (ReturnStatus != ERROR_SUCCESS) goto Cleanup;

    ReturnStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);
    
    if (ReturnStatus == ERROR_SUCCESS) {
        // allocate new memory
        pNewQuery = G_ALLOC(sizeof(PDHI_QUERY));

        if (pNewQuery == NULL) {
            ReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        if (ReturnStatus == ERROR_SUCCESS) {
            // create and capture the mutex for this query.
            pNewQuery->hMutex = CreateMutexW(NULL, TRUE, NULL);

            //initialize structures & list pointers
            // assign signature
            * (DWORD *) (& pNewQuery->signature[0]) = SigQuery;

            // update list pointers
            // test to see if this is the first query in the list
            if (PdhiDllHeadQueryPtr == NULL) {
                // then this is the first so fill in the static link pointers
                PdhiDllHeadQueryPtr = pNewQuery->next.flink = pNewQuery->next.blink = pNewQuery;
            }
            else {
                // get pointer to "last" entry in list
                pLastQuery                      = PdhiDllHeadQueryPtr->next.blink;
                // update new query pointers
                pNewQuery->next.flink           = PdhiDllHeadQueryPtr;
                pNewQuery->next.blink           = pLastQuery;
                // update existing pointers
                PdhiDllHeadQueryPtr->next.blink = pNewQuery;
                pLastQuery->next.flink          = pNewQuery;
            }

            // initialize the counter linked list pointer
            pNewQuery->pCounterListHead = NULL;
            // initialize the machine list pointer
            pNewQuery->pFirstQMachine   = NULL;
            // set length & user data
            pNewQuery->dwLength         = sizeof(PDHI_QUERY);
            pNewQuery->dwUserData       = dwLocalData;
            // initialize remaining data fields
            pNewQuery->dwFlags          = 0;
            pNewQuery->dwFlags         |= (bWbemData ? PDHIQ_WBEM_QUERY : 0);
            pNewQuery->hLog             = hLogLocal;
            pNewQuery->hOutLog          = NULL;
            pNewQuery->dwReleaseLog     = TRUE;

            // initialize time range to include entire range
            * (LONGLONG *) (& pNewQuery->TimeRange.StartTime) = MIN_TIME_VALUE;
            * (LONGLONG *) (& pNewQuery->TimeRange.EndTime)   = MAX_TIME_VALUE;
            pNewQuery->TimeRange.SampleCount = 0;
            pNewQuery->dwLastLogIndex        = 0;
            pNewQuery->dwInterval            = 0;       // no auto interval
            pNewQuery->hAsyncThread          = NULL;    // timing thread;
            pNewQuery->hExitEvent            = NULL;    // async timing thread exit
            pNewQuery->hNewDataEvent         = NULL;    // no event
            // initialize WBEM Data fields
            pNewQuery->pRefresher            = NULL;
            pNewQuery->pRefresherCfg         = NULL;
            pNewQuery->LangID                = GetUserDefaultUILanguage();

            // release the mutex for this query
            RELEASE_MUTEX(pNewQuery->hMutex);

            __try {
                // return new query pointer as a handle.
                * phQuery    = (HQUERY) pNewQuery;
                ReturnStatus = ERROR_SUCCESS;
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                if (pNewQuery != NULL) {
                    // PdhiFreeQuery expects the data to be locked
                    PdhiFreeQuery(pNewQuery);
                }
                ReturnStatus = PDH_INVALID_ARGUMENT;
            }
        }
        // release the data mutex
        RELEASE_MUTEX (hPdhDataMutex);
    } 

    // if this query was added and it's a real-time query then disable
    // future calls to change the data source.
    if (ReturnStatus == ERROR_SUCCESS) {
        if (hLogLocal == NULL) {
            dwCurrentRealTimeDataSource ++;
        }
        else {
            PPDHI_LOG pLog = (PPDHI_LOG) hLogLocal;
            pLog->pQuery   = pNewQuery;
        }
    }

Cleanup:
    TRACE((PDH_DBG_TRACE_INFO),
          (__LINE__,
           PDH_QUERY,
           ARG_DEF(ARG_TYPE_PTR, 1) | ARG_DEF(ARG_TYPE_PTR, 2),
           ReturnStatus,
           TRACE_PTR(phQuery),
           TRACE_PTR(pNewQuery),
           TRACE_DWORD(dwDataSource),
           TRACE_DWORD(dwCurrentRealTimeDataSource),
           NULL));
    return ReturnStatus;
}

PDH_FUNCTION
PdhOpenQueryA(
    IN  LPCSTR       szDataSource,
    IN  DWORD_PTR    dwUserData,
    IN  PDH_HQUERY * phQuery
)
/*++
Routine Description:
    allocates a new query structure and inserts it at the end of the
    query list.

Arguments:
    IN      LPCSTR szDataSource
        the name of the data (log) file to read from or NULL if the
        current activity is desired.
    IN      DWORD   dwUserData
        the user defined data field for this query,

Return Value:
    Returns a valid query handle if successful or INVALID_HANDLE_VALUE
        if not. WIN32 Error status is retrieved using GetLastError()
--*/
{
    LPWSTR     szWideArg    = NULL;
    PDH_STATUS ReturnStatus = ERROR_SUCCESS;
    DWORD_PTR  dwLocalData;

    if (phQuery == NULL) {
       ReturnStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            if (szDataSource != NULL) {
                DWORD dwLength = lstrlenA(szDataSource);
                if (dwLength == 0 || dwLength > PDH_MAX_DATASOURCE_PATH) {
                    ReturnStatus = PDH_INVALID_ARGUMENT;
                }
                else {
                    szWideArg = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szDataSource);
                    if (szWideArg == NULL) {
                        // then a name was passed in but not converted to a wide
                        // character string so a memory allocation failure occurred
                        ReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                }
            }
            if (ReturnStatus == ERROR_SUCCESS) {
                * phQuery   = NULL;
                dwLocalData = dwUserData;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            ReturnStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (ReturnStatus == ERROR_SUCCESS) {
        // call wide char version of function
        ReturnStatus = PdhOpenQueryW(szWideArg, dwLocalData, phQuery);
    }
    G_FREE (szWideArg);
    // and return handle
    return ReturnStatus;
}

PDH_FUNCTION
PdhiAddCounter(
    PDH_HQUERY     hQuery,
    LPCWSTR        szFullName,
    DWORD_PTR      dwUserData,
    PDH_HCOUNTER * phCounter,
    PPDHI_COUNTER  pNewCounter
)
/*  Internal function called by PdhAddCounterW, PdhAddCounterA.
    Assumes that szFullName and pNewCounter are properly allocated,
    and initialized, i.e.  szFullName has the counter path, and
    pNewCounter zeroed.
*/
{
    PPDHI_COUNTER  pLastCounter = NULL;
    PPDHI_QUERY    pQuery       = NULL;
    PDH_STATUS     ReturnStatus = ERROR_SUCCESS;
    BOOL           bStatus      = TRUE;

    // we're changing the contents of PDH data so lock it

    * phCounter  = NULL;
    ReturnStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);

    if (ReturnStatus == ERROR_SUCCESS) {
        if (! IsValidQuery(hQuery)) {
            // invalid query handle
            ReturnStatus = PDH_INVALID_HANDLE;
        }
        else {
            // assign signature & length values
            * (DWORD *)(& pNewCounter->signature[0]) = SigCounter;
            pNewCounter->dwLength                    = sizeof(PDHI_COUNTER);
            pQuery       = (PPDHI_QUERY) hQuery;
            ReturnStatus = WAIT_FOR_AND_LOCK_MUTEX(pQuery->hMutex);
            if (ReturnStatus == ERROR_SUCCESS) {
                // link to owning query
                pNewCounter->pOwner     = pQuery;
                // set user data fields
                pNewCounter->dwUserData = (DWORD) dwUserData;
                // counter is not init'd yet
                pNewCounter->dwFlags    = PDHIC_COUNTER_NOT_INIT;
                // initialize scale to 1X and let the caller make any changes
                pNewCounter->lScale     = 0;
                pNewCounter->szFullName = (LPWSTR) szFullName;

                if (pQuery->dwFlags & PDHIQ_WBEM_QUERY) {
                    pNewCounter->dwFlags |= PDHIC_WBEM_COUNTER;
                    // then this is a WBEM query so use WBEM
                    // functions to initialize it
                    bStatus = WbemInitCounter(pNewCounter);
                }
                else {
                    bStatus = InitCounter(pNewCounter);
                }
                // load counter data using data retrieved from system

                if (bStatus) {
                    // update list pointers
                    // test to see if this is the first query in the list
                    if (pQuery->pCounterListHead == NULL) {
                        // then this is the 1st so fill in the
                        // static link pointers
                        pQuery->pCounterListHead = pNewCounter->next.flink = pNewCounter->next.blink = pNewCounter;
                    }
                    else {
                        pLastCounter                         = pQuery->pCounterListHead->next.blink;
                        pNewCounter->next.flink              = pQuery->pCounterListHead;
                        pNewCounter->next.blink              = pLastCounter;
                        pLastCounter->next.flink             = pNewCounter;
                        pQuery->pCounterListHead->next.blink = pNewCounter;
                    }
                    * phCounter  = (HCOUNTER) pNewCounter;
                    ReturnStatus = ERROR_SUCCESS;
                }
                else {
                    // get the error value
                    ReturnStatus = GetLastError();
                }
                RELEASE_MUTEX (pQuery->hMutex);
            }
        }
        RELEASE_MUTEX(hPdhDataMutex);
    }
    TRACE((PDH_DBG_TRACE_INFO),
          (__LINE__,
           PDH_QUERY,
           ARG_DEF(ARG_TYPE_PTR, 1) | ARG_DEF(ARG_TYPE_PTR, 2)
                                    | ARG_DEF(ARG_TYPE_WSTR, 3),
           ReturnStatus,
           TRACE_PTR(pQuery),
           TRACE_PTR(pNewCounter),
           TRACE_WSTR(szFullName),
           TRACE_DWORD(pNewCounter->dwUserData),
           NULL));
    return ReturnStatus;
}

PDH_FUNCTION
PdhAddCounterW(
    IN  PDH_HQUERY     hQuery,
    IN  LPCWSTR        szFullCounterPath,
    IN  DWORD_PTR      dwUserData,
    IN  PDH_HCOUNTER * phCounter
)
/*++
Routine Description:
    Creates and initializes a counter structure and attaches it to the
        specified query.

Arguments:
    IN  HQUERY  hQuery
        handle of the query to attach this counter to once the counter
        entry has been successfully created.
    IN  LPCWSTR szFullCounterPath
        pointer to the path string that describes the counter to add to
        the query referenced above. This string must specify a single
        counter. Wildcard path strings are not permitted.
    IN  DWORD   dwUserData
        the user defined data field for this query.
    IN  HCOUNTER *phCounter
        pointer to the buffer that will get the handle value of the
        successfully created counter entry.

Return Value:
    Returns ERROR_SUCCESS if a new query was created and initialized,
        and a PDH_ error value if not.
    PDH_INVALID_ARGUMENT is returned when one or more of the arguements
        is invalid or incorrect.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a memory buffer could
        not be allocated.
    PDH_INVALID_HANDLE is returned if the query handle is not valid.
    PDH_CSTATUS_NO_COUNTER is returned if the specified counter was
        not found
    PDH_CSTATUS_NO_OBJECT is returned if the specified object could
        not be found
    PDH_CSTATUS_NO_MACHINE is returned if a machine entry could not
        be created.
    PDH_CSTATUS_BAD_COUNTERNAME is returned if the counter name path
        string could not be parsed or interpreted
    PDH_CSTATUS_NO_COUNTERNAME is returned if an empty counter name
        path string is passed in
    PDH_FUNCTION_NOT_FOUND is returned if the calculation function
        for this counter could not be determined.
--*/
{
    PPDHI_COUNTER pNewCounter   = NULL;
    PDH_STATUS    ReturnStatus  = ERROR_SUCCESS;
    SIZE_T        nPathLen      = 0;
    LPWSTR        szFullName    = NULL;
    PDH_HCOUNTER  hLocalCounter = NULL;
    PDH_HQUERY    hLocalQuery;
    DWORD_PTR     dwLocalData;

    if (szFullCounterPath == NULL || phCounter == NULL) {
        return PDH_INVALID_ARGUMENT;
    }
    __try {
        hLocalQuery = hQuery;
        dwLocalData = dwUserData;
        * phCounter = NULL; // init to null

        nPathLen = lstrlenW(szFullCounterPath);
        if (nPathLen == 0 || nPathLen > PDH_MAX_COUNTER_PATH) {
            ReturnStatus = PDH_INVALID_ARGUMENT;
        }
        else {
            szFullName = G_ALLOC((nPathLen + 1) * sizeof(WCHAR));
            if (szFullName) {
                StringCchCopyW(szFullName, nPathLen + 1, szFullCounterPath);
            }
            else {
                ReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        ReturnStatus = PDH_INVALID_ARGUMENT;
    }
    if (ReturnStatus == ERROR_SUCCESS) {
        pNewCounter = G_ALLOC(sizeof(PDHI_COUNTER));
        if (pNewCounter == NULL) {
            ReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    }

    // query handle is tested by PdhiAddCounter

    if (ReturnStatus == ERROR_SUCCESS) {
        ReturnStatus = PdhiAddCounter(hLocalQuery, szFullName, dwLocalData, & hLocalCounter, pNewCounter);
        if (ReturnStatus == ERROR_SUCCESS && hLocalCounter != NULL) {
            __try {
                * phCounter = hLocalCounter;
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                ReturnStatus = PDH_INVALID_ARGUMENT;
            }
        }
    }
    if (ReturnStatus != ERROR_SUCCESS) {
        if (pNewCounter != NULL) {
            if (pNewCounter->szFullName == NULL) {
                G_FREE(szFullName);
            }
            if (! FreeCounter(pNewCounter)) {
                if (pNewCounter->szFullName != NULL) {
                    G_FREE(pNewCounter->szFullName);
                }
                G_FREE(pNewCounter);
            }
        }
        else if (szFullName != NULL) {    // allocated this, but not pNewCounter
            G_FREE(szFullName);
        }
    }
    return ReturnStatus;
}

PDH_FUNCTION
PdhAddCounterA(
    IN  PDH_HQUERY     hQuery,
    IN  LPCSTR         szFullCounterPath,
    IN  DWORD_PTR      dwUserData,
    IN  PDH_HCOUNTER * phCounter
)
/*++
Routine Description:
    Creates and initializes a counter structure and attaches it to the
        specified query.

Arguments:
    IN  HQUERY  hQuery
        handle of the query to attach this counter to once the counter
        entry has been successfully created.
    IN  LPCSTR szFullCounterPath
        pointer to the path string that describes the counter to add to
        the query referenced above. This string must specify a single
        counter. Wildcard path strings are not permitted.
    IN  DWORD   dwUserData
        the user defined data field for this query.
    IN  HCOUNTER *phCounter
        pointer to the buffer that will get the handle value of the
        successfully created counter entry.

Return Value:
    Returns ERROR_SUCCESS if a new query was created and initialized,
        and a PDH_ error value if not.
    PDH_INVALID_ARGUMENT is returned when one or more of the arguements
        is invalid or incorrect.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a memory buffer could
        not be allocated.
    PDH_INVALID_HANDLE is returned if the query handle is not valid.
    PDH_CSTATUS_NO_COUNTER is returned if the specified counter was
        not found
    PDH_CSTATUS_NO_OBJECT is returned if the specified object could
        not be found
    PDH_CSTATUS_NO_MACHINE is returned if a machine entry could not
        be created.
    PDH_CSTATUS_BAD_COUNTERNAME is returned if the counter name path
        string could not be parsed or interpreted
    PDH_CSTATUS_NO_COUNTERNAME is returned if an empty counter name
        path string is passed in
    PDH_FUNCTION_NOT_FOUND is returned if the calculation function
        for this counter could not be determined.
--*/
{
    LPWSTR        szFullName    = NULL;
    PDH_STATUS    ReturnStatus  = ERROR_SUCCESS;
    PDH_HCOUNTER  hLocalCounter = NULL;
    PDH_HQUERY    hLocalQuery;
    DWORD_PTR     dwLocalData;
    PPDHI_COUNTER pNewCounter   = NULL;

    if (phCounter == NULL || szFullCounterPath == NULL) {
        return PDH_INVALID_ARGUMENT;
    }

    __try {
        DWORD dwLength = lstrlenA(szFullCounterPath);

         // try writing to return pointer
        hLocalQuery = hQuery;
        dwLocalData = dwUserData;
        * phCounter = NULL;

        if (dwLength == 0 || dwLength > PDH_MAX_COUNTER_PATH) {
            ReturnStatus = PDH_INVALID_ARGUMENT;
        }
        else {
            szFullName = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szFullCounterPath);
            if (szFullName == NULL) {
                ReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        ReturnStatus = PDH_INVALID_ARGUMENT;
    }
    if (ReturnStatus == ERROR_SUCCESS) {
        pNewCounter = G_ALLOC(sizeof (PDHI_COUNTER));
        if (pNewCounter == NULL) {
            ReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    }
    // query handle is tested by PdhiAddCounter
    if (ReturnStatus == ERROR_SUCCESS) {
        ReturnStatus = PdhiAddCounter( hLocalQuery, szFullName, dwLocalData, & hLocalCounter, pNewCounter);
        if (ReturnStatus == ERROR_SUCCESS && hLocalCounter != NULL) {
            __try {
                * phCounter = hLocalCounter;
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                ReturnStatus = PDH_INVALID_ARGUMENT;
            }
        }
    }
    if (ReturnStatus != ERROR_SUCCESS) {
        if (pNewCounter != NULL) {
            if (pNewCounter->szFullName == NULL) {
                G_FREE(szFullName);
            }
            if (! FreeCounter(pNewCounter)) {
                if (pNewCounter->szFullName != NULL) {
                    G_FREE(pNewCounter->szFullName);
                }
                G_FREE(pNewCounter);
            }
        }
        else if (szFullName != NULL) {    // allocated this, but not pNewCounter
            G_FREE(szFullName);
        }
    }
    return ReturnStatus;
}

PDH_FUNCTION
PdhRemoveCounter(
    IN  PDH_HCOUNTER  hCounter
)
/*++
Routine Description:
    Removes the specified counter from the query it is attached to and
        closes any handles and frees any memory associated with this
        counter

Arguments:
    IN  HCOUNTER  hCounter
        handle of the counter to remove from the query.

Return Value:
    Returns ERROR_SUCCESS if a new query was created and initialized,
        and a PDH_ error value if not.

    PDH_INVALID_HANDLE is returned if the counter handle is not valid.
--*/
{
    PPDHI_COUNTER       pThisCounter;
    PPDHI_QUERY         pThisQuery;
    PPDHI_COUNTER       pNextCounter;
    PPDHI_QUERY_MACHINE pQMachine;
    PPDHI_QUERY_MACHINE pNextQMachine;
    PDH_STATUS          pdhStatus = ERROR_SUCCESS;

    // we're changing the contents PDH data so lock it
    if (WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex) != ERROR_SUCCESS) return WAIT_TIMEOUT;

    if (IsValidCounter(hCounter)) {
         // it's ok to cast it to a pointer now.
        pThisCounter = (PPDHI_COUNTER) hCounter;
        pThisQuery   = pThisCounter->pOwner;

        if (! IsValidQuery(pThisQuery)) {
            pdhStatus = PDH_INVALID_HANDLE;
            goto Cleanup;
        }

        if (WAIT_FOR_AND_LOCK_MUTEX(pThisQuery->hMutex) != ERROR_SUCCESS) {
            pdhStatus = WAIT_TIMEOUT;
            goto Cleanup;
        }

        if (pThisCounter == pThisQuery->pCounterListHead) {
            if (pThisCounter->next.flink == pThisCounter){
                // then this is the only counter in the query
                FreeCounter(pThisCounter);
                pThisQuery->pCounterListHead = NULL;

                if (!(pThisQuery->dwFlags & PDHIQ_WBEM_QUERY)) {
                    // remove the QMachine list since there are now no more
                    // counters to query
                        if ((pQMachine = pThisQuery->pFirstQMachine) != NULL) {
                        //  Free list of machine pointers
                        do {
                            pNextQMachine = pQMachine->pNext;
                            if (pQMachine->pPerfData != NULL) {
                                G_FREE(pQMachine->pPerfData);
                            }
                            G_FREE(pQMachine);
                            pQMachine = pNextQMachine;
                        }
                        while (pQMachine != NULL);
                        pThisQuery->pFirstQMachine = NULL;
                    }
                }
            }
            else {
                // they are deleting the first counter from the list
                // so update the list pointer
                // Free Counter takes care of the list links, we just
                // need to manage the list head pointer
                pNextCounter = pThisCounter->next.flink;
                FreeCounter(pThisCounter);
                pThisQuery->pCounterListHead = pNextCounter;
            }
        }
        else {
            // remove this from the list
            FreeCounter(pThisCounter);
        }
        RELEASE_MUTEX(pThisQuery->hMutex);
    }
    else {
        pdhStatus = PDH_INVALID_HANDLE;
    }

Cleanup:
    RELEASE_MUTEX(hPdhDataMutex);
    return pdhStatus;
}

PDH_FUNCTION
PdhSetQueryTimeRange(
    IN  PDH_HQUERY      hQuery,
    IN  PPDH_TIME_INFO  pInfo
)
{
    PPDHI_QUERY  pQuery;
    PDH_STATUS   pdhStatus = ERROR_SUCCESS;

    if (pInfo == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        if (IsValidQuery(hQuery)) {           
            pQuery = (PPDHI_QUERY) hQuery;
            pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pQuery->hMutex);
            if (pdhStatus == ERROR_SUCCESS) {
                if (IsValidQuery(hQuery)) {           
                    if (pQuery->hLog == NULL) {
                        pdhStatus = ERROR_SUCCESS;
                    }
                    else {
                        __try {
                            if (* (LONGLONG *) (& pInfo->EndTime) > * (LONGLONG *) (& pInfo->StartTime)) {
                                // reset log file pointers to beginning so next query
                                // will read from the start of the time range
                                pdhStatus = PdhiResetLogBuffers(pQuery->hLog);
                                // ok so now load new time range
                                if (pdhStatus == ERROR_SUCCESS) {
                                    pQuery->TimeRange      = * pInfo;
                                    pQuery->dwLastLogIndex = 0;
                                }
                            }
                            else {
                                // end time is smaller (earlier) than start time
                                pdhStatus = PDH_INVALID_ARGUMENT;
                            }
                        }
                        __except (EXCEPTION_EXECUTE_HANDLER) {
                            pdhStatus = PDH_INVALID_ARGUMENT;
                        }
                    }
                }
                else {
                    // the query disappeared while we were waiting for it
                    pdhStatus = PDH_INVALID_HANDLE;
                }
                RELEASE_MUTEX(pQuery->hMutex);
            } // else couldn't lock query
        }
        else {
            pdhStatus = PDH_INVALID_HANDLE;
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiCollectQueryData(
    PPDHI_QUERY   pQuery,
    LONGLONG    * pllTimeStamp
)
{
    PDH_STATUS  Status;

    if (WAIT_FOR_AND_LOCK_MUTEX(pQuery->hMutex) != ERROR_SUCCESS) return WAIT_TIMEOUT;

    if (pQuery->dwFlags & PDHIQ_WBEM_QUERY) {
        Status = GetQueryWbemData(pQuery, pllTimeStamp);
    }
    else {
        Status = GetQueryPerfData(pQuery, pllTimeStamp);
    }
    RELEASE_MUTEX(pQuery->hMutex);
    return Status;
}

PDH_FUNCTION
PdhCollectQueryData(
    IN  PDH_HQUERY hQuery
)
/*++
Routine Description:
    Retrieves the current value of each counter attached to the specified
        query.
    For this version, each machine associated with this query is polled
    sequentially. This is simple and safe, but potentially slow so a
    multi-threaded approach will be reviewed for the next version.

    Note that while the call may succeed, no data may be available. The
    status of each counter MUST be checked before its data is used.

Arguments:
    IN  HQUERY  hQuery
        handle of the query to update.

Return Value:
    Returns ERROR_SUCCESS if a new query was created and initialized,
        and a PDH_ error value if not.
    PDH_INVALID_HANDLE is returned if the query handle is not valid.
    PDH_NO_DATA is returned if the query does not have any counters defined
        yet.
--*/
{
    PDH_STATUS  Status;
    PPDHI_QUERY pQuery;
    LONGLONG    llTimeStamp;

    if (WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex) != ERROR_SUCCESS) return WAIT_TIMEOUT;

    if (IsValidQuery(hQuery)) {
        pQuery = (PPDHI_QUERY) hQuery;
        Status = PdhiCollectQueryData(pQuery, & llTimeStamp);
    }
    else {
        Status = PDH_INVALID_HANDLE;
    }
    RELEASE_MUTEX(hPdhDataMutex);
    return Status;
}

PDH_FUNCTION
PdhCollectQueryDataEx(
    IN  HQUERY  hQuery,
    IN  DWORD   dwIntervalTime,
    IN  HANDLE  hNewDataEvent
)
/*++
Routine Description:
    Retrieves the current value of each counter attached to the specified
        query periodically based on the interval time specified.

    For this version, each machine associated with this query is polled
    sequentially.

    Note that while the call may succeed, no data may be available. The
    status of each counter MUST be checked before its data is used.

Arguments:
    IN  HQUERY  hQuery
        handle of the query to update.
    IN      DWORD       dwIntervalTime
        Interval to poll for new data in seconds
        this value must be > 0. A value of 0 will terminate any current
        data collection threads.
    IN      HANDLE      hNewDataEvent
        Handle to an Event that should be signaled when new data is
        available. This can be NULL if no notification is desired.

Return Value:
    Returns ERROR_SUCCESS if a new query was created and initialized,
        and a PDH_ error value if not.
    PDH_INVALID_HANDLE is returned if the query handle is not valid.
--*/
{
    PDH_STATUS  lStatus = ERROR_SUCCESS;
    PPDHI_QUERY pQuery;
    DWORD       dwThreadId;
    BOOL        bStatus;

    if (WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex) != ERROR_SUCCESS) return WAIT_TIMEOUT;

    if (IsValidQuery(hQuery)) {
        // set the query structure's interval to the caller specified
        // value then start the timing thread.
        pQuery = (PPDHI_QUERY) hQuery;

        if (WAIT_FOR_AND_LOCK_MUTEX(pQuery->hMutex) != ERROR_SUCCESS) {
            lStatus = WAIT_TIMEOUT;
            goto Cleanup;
        }

        if (pQuery->hExitEvent != NULL) {
            RELEASE_MUTEX(pQuery->hMutex);
            // stop current thread first
            SetEvent(pQuery->hExitEvent);
            // wait 1 second for the thread to stop
            lStatus = WaitForSingleObject(pQuery->hAsyncThread, 10000L);
            if (lStatus == WAIT_TIMEOUT) {
                TRACE((PDH_DBG_TRACE_ERROR), (__LINE__, PDH_QUERY, 0, lStatus, NULL));
            }
            lStatus = WAIT_FOR_AND_LOCK_MUTEX(pQuery->hMutex);
            if (lStatus == ERROR_SUCCESS) {
                bStatus              = CloseHandle(pQuery->hExitEvent);
                pQuery->hExitEvent   = NULL;
                bStatus              = CloseHandle(pQuery->hAsyncThread);
                pQuery->hAsyncThread = NULL;
            }
        }

        if (lStatus == ERROR_SUCCESS) {
            // query mutex is still locked at this point
            if (dwIntervalTime > 0) {
                // start a new interval
                // initialize new values
                __try {
                    pQuery->dwInterval    = dwIntervalTime;
                    pQuery->hNewDataEvent = hNewDataEvent;
                }
                __except(EXCEPTION_EXECUTE_HANDLER) {
                    lStatus = PDH_INVALID_ARGUMENT;
                }
                if (lStatus == ERROR_SUCCESS) {
                    pQuery->hExitEvent    = CreateEventW(NULL, TRUE, FALSE, NULL);
                    pQuery->hAsyncThread  = CreateThread(NULL,
                                                         0,
                                                         PdhiAsyncTimerThreadProc,
                                                         (LPVOID) pQuery,
                                                         0,
                                                         & dwThreadId);
                }
                RELEASE_MUTEX(pQuery->hMutex);
                if (pQuery->hAsyncThread == NULL) {
                    lStatus = WAIT_FOR_AND_LOCK_MUTEX(pQuery->hMutex);
                    if (lStatus == ERROR_SUCCESS) {
                        pQuery->dwInterval    = 0;
                        pQuery->hNewDataEvent = NULL;
                        bStatus               = CloseHandle(pQuery->hExitEvent);
                        pQuery->hExitEvent    = NULL;
                        RELEASE_MUTEX(pQuery->hMutex);
                        lStatus               = GetLastError();
                    } 
                }
            }
            else {
                // they just wanted to stop so clean up Query struct
                pQuery->dwInterval    = 0;
                pQuery->hNewDataEvent = NULL;
                RELEASE_MUTEX(pQuery->hMutex);
                // lstatus = ERROR_SUCCESS from above
            }
        }
    }
    else {
        lStatus = PDH_INVALID_HANDLE;
    }

Cleanup:
    RELEASE_MUTEX (hPdhDataMutex);
    return lStatus;
}

PDH_FUNCTION
PdhCloseQuery(
    IN  PDH_HQUERY hQuery
)
/*++
Routine Description:
    closes the query, all counters, connections and other resources
        related to this query are freed as well.

Arguments:
    IN  HQUERY  hQuery
        the handle of the query to free.

Return Value:
    Returns ERROR_SUCCESS if a new query was created and initialized,
        and a PDH_ error value if not.
    PDH_INVALID_HANDLE is returned if the query handle is not valid.
--*/
{
    PDH_STATUS  dwReturn;
    // lock system data
    if (WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex) != ERROR_SUCCESS) return WAIT_TIMEOUT;

    if (IsValidQuery(hQuery)) {
        // dispose of query
        PPDHI_QUERY pQuery = (PPDHI_QUERY) hQuery;
        if (pQuery->hLog == H_REALTIME_DATASOURCE || pQuery->hLog == H_WBEM_DATASOURCE) {
            dwCurrentRealTimeDataSource --;
            if (dwCurrentRealTimeDataSource < 0) {
                dwCurrentRealTimeDataSource = 0;
            }
        }
        PdhiFreeQuery(pQuery);
        // release data lock
        dwReturn = ERROR_SUCCESS;
    }
    else {
        dwReturn = PDH_INVALID_HANDLE;
    }
    RELEASE_MUTEX(hPdhDataMutex);
    return dwReturn;
}

BOOL
PdhiQueryCleanup(
)
{
    PPDHI_QUERY pThisQuery;
    BOOL        bReturn = FALSE;

    if (WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex) == ERROR_SUCCESS) {
        // free any queries in the query list
        pThisQuery = PdhiDllHeadQueryPtr;
        if (pThisQuery != NULL) {
            while (pThisQuery->next.blink != pThisQuery->next.flink) {
                // delete from list
                // the deletion routine updates the blink pointer as it
                // removes the specified entry.
                PdhiFreeQuery(pThisQuery->next.blink);
            }
            // remove last query
            PdhiFreeQuery(pThisQuery);
            PdhiDllHeadQueryPtr         = NULL;
            dwCurrentRealTimeDataSource = 0;
        }
        RELEASE_MUTEX(hPdhDataMutex);
        bReturn = TRUE;
    }
    return bReturn;
}

PDH_FUNCTION
PdhGetDllVersion(
    IN  LPDWORD lpdwVersion
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    __try {
        * lpdwVersion = PDH_VERSION;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    return pdhStatus;
}

BOOL
PdhIsRealTimeQuery(
    IN  PDH_HQUERY hQuery
)
{
    PPDHI_QUERY  pQuery;
    BOOL         bReturn = FALSE;
    
    SetLastError (ERROR_SUCCESS);
    if (IsValidQuery(hQuery)) {
        __try {
            pQuery = (PPDHI_QUERY) hQuery;
            if (pQuery->hLog == NULL) {
                bReturn = TRUE;
            }
            else {
                bReturn = FALSE;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            SetLastError(GetExceptionCode());
        }
    }
    else {
        bReturn = FALSE;
    }
    return bReturn;
}

PDH_FUNCTION
PdhFormatFromRawValue(
    IN  DWORD                   dwCounterType,
    IN  DWORD                   dwFormat,
    IN  LONGLONG              * pTimeBase,
    IN  PPDH_RAW_COUNTER        pRawValue1,
    IN  PPDH_RAW_COUNTER        pRawValue2,
    IN  PPDH_FMT_COUNTERVALUE   pFmtValue
)
/*++
Routine Description:
    Calculates the formatted counter value using the data in the RawValue
        buffer in the format requested by the format field using the
        calculation functions of the counter type specified by the
        dwCounterType field.

Arguments:
    IN      DWORD   dwCounterType
        The type of the counter to use in order to determine the
        calculation functions for interpretation of the raw value buffers
    IN      DWORD       dwFormat
        Format in which the requested data should be returned. The
        values for this field are described in the PDH.H header
        file.
    IN      LONGLONG            *pTimeBase
        pointer to the _int64 value containing the timebase (i.e. counter
        unit frequency) used by this counter. This can be NULL if it's not
        required by the counter type
    IN      PPDH_RAW_COUNTER    rawValue1
        pointer to the buffer that contains the first raw value structure
    IN      PPDH_RAW_COUNTER    rawValue2
        pointer to the buffer that contains the second raw value structure.
        This argument may be null if only one value is required for the
        computation.
    IN      PPDH_FMT_COUNTERVALUE   fmtValue
        the pointer to the data buffer passed by the caller to receive
        the data requested. If the counter requires 2 values, (as in the
        case of a rate counter), rawValue1 is assumed to be the most
        recent value and rawValue2, the older value.

Return Value:
    The WIN32 Error status of the function's operation. Common values
        returned are:
            ERROR_SUCCESS   when all requested data is returned
            PDH_INVALID_HANDLE if the counter handle is incorrect
            PDH_INVALID_ARGUMENT if an argument is incorrect
--*/
{
    PDH_STATUS      lStatus = ERROR_SUCCESS;
    LPCOUNTERCALC   pCalcFunc;
    LPCOUNTERSTAT   pStatFunc;
    LONGLONG        llTimeBase;
    BOOL            bReturn;

    // TODO: Need to check for pRawValue1
    //      bad arguments are caught in the PdhiComputeFormattedValue function
    // NOTE: postW2k pTimeBase really do not need to be a pointer, since it is
    // not returned
    if (pTimeBase != NULL) {
        __try {
            DWORD   dwTempStatus;
            DWORD   dwTypeMask;

            // read access to the timebase
            llTimeBase = * pTimeBase;

            // we should have read access to the rawValues
            dwTempStatus = * ((DWORD volatile *) & pRawValue1->CStatus);

            // this one could be NULL
            if (pRawValue2 != NULL) {
                dwTempStatus = * ((DWORD volatile *) & pRawValue2->CStatus);
            }

            // and write access to the fmtValue
            pFmtValue->CStatus = 0;

            // validate format flags:
            //      only one of the following can be set at a time
            dwTypeMask = dwFormat & (PDH_FMT_LONG | PDH_FMT_DOUBLE | PDH_FMT_LARGE);
            if (! ((dwTypeMask == PDH_FMT_LONG) || (dwTypeMask == PDH_FMT_DOUBLE) ||
                            (dwTypeMask == PDH_FMT_LARGE))) {
                lStatus = PDH_INVALID_ARGUMENT;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            lStatus = PDH_INVALID_ARGUMENT;
        }
    }
    else {
        llTimeBase = 0;
    }

    if (lStatus == ERROR_SUCCESS) {
        // get calc func for counter type this will also test the
        // validity of the counter type argument

        bReturn = AssignCalcFunction(dwCounterType, & pCalcFunc, & pStatFunc);
        if (!bReturn) {
            lStatus = GetLastError();
        }
        else {
            lStatus = PdhiComputeFormattedValue(pCalcFunc,
                                                dwCounterType,
                                                0L,
                                                dwFormat,
                                                pRawValue1,
                                                pRawValue2,
                                                & llTimeBase,
                                                0L,
                                                pFmtValue);
        }
    }
    return lStatus;
}

LPWSTR
PdhiMatchObjectNameInList(
    LPWSTR   szObjectName,
    LPWSTR * szSrcPerfStrings,
    LPWSTR * szDestPerfStrings,
    DWORD    dwLastString
)
{
    LPWSTR szRtnName = NULL;
    DWORD  i;

    for (i = 0; i <= dwLastString; i ++) {
        if (szSrcPerfStrings[i] && szSrcPerfStrings[i] != L'\0'
                                && lstrcmpiW(szObjectName, szSrcPerfStrings[i]) == 0) {
            szRtnName = szDestPerfStrings[i];
            break;
        }
    }
    return szRtnName;
}

PDH_FUNCTION
PdhiBuildFullCounterPath(
    BOOL               bMachine,
    PPDHI_COUNTER_PATH pCounterPath,
    LPWSTR             szObjectName,
    LPWSTR             szCounterName,
    LPWSTR             szFullPath,
    DWORD              dwFullPath
)
{
    PDH_STATUS Status = ERROR_SUCCESS;

    // Internal routine,
    // Build full counter path name from counter path structure, assume
    // passed-in string buffer is large enough to hold.

    if (bMachine) {
        StringCchCopyW(szFullPath, dwFullPath, pCounterPath->szMachineName);
        StringCchCatW(szFullPath, dwFullPath, cszBackSlash);
    }
    else {
        StringCchCopyW(szFullPath, dwFullPath, cszBackSlash);
    }
    StringCchCatW(szFullPath, dwFullPath, szObjectName);
    if (pCounterPath->szInstanceName != NULL && pCounterPath->szInstanceName[0] != L'\0') {
        StringCchCatW(szFullPath, dwFullPath, cszLeftParen);
        if (pCounterPath->szParentName != NULL && pCounterPath->szParentName[0] != L'\0') {
            StringCchCatW(szFullPath, dwFullPath, pCounterPath->szParentName);
            StringCchCatW(szFullPath, dwFullPath, cszSlash);

            TRACE((PDH_DBG_TRACE_INFO),
                  (__LINE__,
                   PDH_QUERY,
                   ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2)
                                             | ARG_DEF(ARG_TYPE_WSTR, 3)
                                             | ARG_DEF(ARG_TYPE_WSTR, 4)
                                             | ARG_DEF(ARG_TYPE_WSTR, 5),
                   ERROR_SUCCESS,
                   TRACE_WSTR(pCounterPath->szMachineName),
                   TRACE_WSTR(szObjectName),
                   TRACE_WSTR(szCounterName),
                   TRACE_WSTR(pCounterPath->szParentName),
                   TRACE_WSTR(pCounterPath->szInstanceName),
                   TRACE_DWORD(pCounterPath->dwIndex),
                   NULL));
        }
        else {
            TRACE((PDH_DBG_TRACE_INFO),
                  (__LINE__,
                   PDH_QUERY,
                   ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2)
                                             | ARG_DEF(ARG_TYPE_WSTR, 3)
                                             | ARG_DEF(ARG_TYPE_WSTR, 4),
                   ERROR_SUCCESS,
                   TRACE_WSTR(pCounterPath->szMachineName),
                   TRACE_WSTR(szObjectName),
                   TRACE_WSTR(szCounterName),
                   TRACE_WSTR(pCounterPath->szInstanceName),
                   TRACE_DWORD(pCounterPath->dwIndex),
                   NULL));
        }
        StringCchCatW(szFullPath, dwFullPath, pCounterPath->szInstanceName);
        if (pCounterPath->dwIndex != ((DWORD) -1) && pCounterPath->dwIndex != 0) {
            WCHAR szDigits[16];

            ZeroMemory(szDigits, 16 * sizeof(WCHAR));
            StringCchCatW(szFullPath, dwFullPath, cszPoundSign);
            _ltow((long) pCounterPath->dwIndex, szDigits, 10);
            StringCchCatW(szFullPath, dwFullPath, szDigits);
        }
        StringCchCatW(szFullPath, dwFullPath, cszRightParen);
    }
    else {
        TRACE((PDH_DBG_TRACE_INFO),
              (__LINE__,
               PDH_QUERY,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2)
                                         | ARG_DEF(ARG_TYPE_WSTR, 3),
               ERROR_SUCCESS,
               TRACE_WSTR(pCounterPath->szMachineName),
               TRACE_WSTR(szObjectName),
               TRACE_WSTR(szCounterName),
               TRACE_DWORD(pCounterPath->dwIndex),
               NULL));
    }
    StringCchCatW(szFullPath, dwFullPath, cszBackSlash);
    StringCchCatW(szFullPath, dwFullPath, szCounterName);
    return Status;
}

PDH_FUNCTION
PdhiTranslateCounter(
    LPWSTR  szSourcePath,
    LPVOID  pFullPathName,
    LPDWORD pcchPathLength,
    BOOL    bLocaleTo009,
    BOOL    bUnicode
)
{
    PDH_STATUS         Status         = ERROR_SUCCESS;
    PPERF_MACHINE      pMachine       = NULL;
    PPDHI_COUNTER_PATH pCounterPath   = NULL;
    LPWSTR             szRtnPath      = NULL;
    DWORD              dwPathSize;
    DWORD              dwRtnPathSize;
    DWORD              dwSize;
    BOOL               bMachineThere  = FALSE;

    bMachineThere =  (lstrlenW(szSourcePath) >= 2) && (szSourcePath[0] == BACKSLASH_L)
                                                   && (szSourcePath[1] == BACKSLASH_L);
    dwPathSize = sizeof(WCHAR) * (lstrlenW(szStaticLocalMachineName) + lstrlenW(szSourcePath) + 2);
    dwSize     = sizeof(PDHI_COUNTER_PATH) + 2 * dwPathSize;
    pCounterPath = G_ALLOC(dwSize);
    if (pCounterPath == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    if (ParseFullPathNameW(szSourcePath, & dwSize, pCounterPath, FALSE)) {
        pMachine = GetMachine(pCounterPath->szMachineName, 0, PDH_GM_UPDATE_PERFNAME_ONLY);
        if (pMachine == NULL) {
            Status = PDH_CSTATUS_NO_MACHINE;
        }
        else if (pMachine->dwStatus != ERROR_SUCCESS) {
            pMachine->dwRefCount --;
            RELEASE_MUTEX(pMachine->hMutex);
            Status = PDH_CSTATUS_NO_MACHINE;
        }
        else {
            LPWSTR  szObjectName  = NULL;
            LPWSTR  szCounterName = NULL;
            BOOLEAN bInstance     = TRUE;

            if (bLocaleTo009) {
                szObjectName  = PdhiMatchObjectNameInList(pCounterPath->szObjectName,
                                                          pMachine->szPerfStrings,
                                                          pMachine->sz009PerfStrings,
                                                          pMachine->dwLastPerfString);
                szCounterName = PdhiMatchObjectNameInList(pCounterPath->szCounterName,
                                                          pMachine->szPerfStrings,
                                                          pMachine->sz009PerfStrings,
                                                          pMachine->dwLastPerfString);
            }
            else {
                szObjectName  = PdhiMatchObjectNameInList(pCounterPath->szObjectName,
                                                          pMachine->sz009PerfStrings,
                                                          pMachine->szPerfStrings,
                                                          pMachine->dwLastPerfString);
                szCounterName = PdhiMatchObjectNameInList(pCounterPath->szCounterName,
                                                          pMachine->sz009PerfStrings,
                                                          pMachine->szPerfStrings,
                                                          pMachine->dwLastPerfString);
            }
            if (szObjectName == NULL) {
                DWORD dwObjectTitle = wcstoul(pCounterPath->szObjectName, NULL, 10);
                if (dwObjectTitle != 0) {
                    szObjectName = pCounterPath->szObjectName;
                }
            }
            if (szCounterName == NULL) {
                DWORD dwCounterTitle = wcstoul(pCounterPath->szCounterName, NULL, 10);
                if (dwCounterTitle != 0) {
                    szCounterName = pCounterPath->szCounterName;
                }
            }
            if ((szObjectName == NULL) && (* pCounterPath->szObjectName == SPLAT_L)) {
                szObjectName = pCounterPath->szObjectName;
            }
            if ((szCounterName == NULL) && (* pCounterPath->szCounterName == SPLAT_L)) {
                szCounterName = pCounterPath->szCounterName;
            }

            if (szObjectName == NULL || szCounterName == NULL) {
                Status = PDH_INVALID_ARGUMENT;
            }
            else {
                if (pCounterPath->szInstanceName != NULL
                            && pCounterPath->szInstanceName[0] != L'\0') {
                    dwRtnPathSize = sizeof(WCHAR) * (  lstrlenW(pCounterPath->szMachineName)
                                                     + lstrlenW(szObjectName)
                                                     + lstrlenW(pCounterPath->szInstanceName)
                                                     + lstrlenW(szCounterName) + 5);
                    if (pCounterPath->szParentName != NULL && pCounterPath->szParentName[0] != L'\0') {
                        dwRtnPathSize += (sizeof(WCHAR) * (lstrlenW(pCounterPath->szParentName) + 1));
                    }
                    if (pCounterPath->dwIndex != ((DWORD) -1) && pCounterPath->dwIndex != 0) {
                        dwRtnPathSize += (sizeof(WCHAR) * 16);
                    }
                }
                else {
                    dwRtnPathSize = sizeof(WCHAR) * (lstrlenW(pCounterPath->szMachineName)
                                                     + lstrlenW(szObjectName) + lstrlenW(szCounterName) + 3);
                    bInstance = FALSE;
                }
                szRtnPath = G_ALLOC(dwRtnPathSize);
                if (szRtnPath == NULL) {
                    Status = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                else {
                    PdhiBuildFullCounterPath(
                            bMachineThere, pCounterPath, szObjectName, szCounterName, szRtnPath, dwRtnPathSize);
                    __try {
                        if (bUnicode) {
                            if ((pFullPathName != NULL) && ((* pcchPathLength) >= (DWORD) (lstrlenW(szRtnPath) + 1))) {
                                StringCchCopyW(pFullPathName, * pcchPathLength, szRtnPath);
                            }
                            else {
                                Status = PDH_MORE_DATA;
                            }
                            * pcchPathLength = lstrlenW(szRtnPath) + 1;
                        }
                        else {
                            dwRtnPathSize = * pcchPathLength;
                            if (bLocaleTo009) {
                                Status = PdhiConvertUnicodeToAnsi(
                                                CP_ACP, szRtnPath, pFullPathName, & dwRtnPathSize);
                            }
                            else {
                                Status = PdhiConvertUnicodeToAnsi(
                                                _getmbcp(), szRtnPath, pFullPathName, & dwRtnPathSize);
                            }
                            * pcchPathLength = dwRtnPathSize;
                        }
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER) {
                        Status = PDH_INVALID_ARGUMENT;
                    }
                }
            }
            pMachine->dwRefCount --;
            RELEASE_MUTEX(pMachine->hMutex);
        }
    }
    else {
        Status = PDH_CSTATUS_BAD_COUNTERNAME;
    }

Cleanup:
    G_FREE(szRtnPath);
    G_FREE(pCounterPath);
    return Status;
}

PDH_FUNCTION
PdhTranslate009CounterW(
    IN  LPWSTR  szLocalePath,
    IN  LPWSTR  pszFullPathName,
    IN  LPDWORD pcchPathLength
)
{
    PDH_STATUS Status       = ERROR_SUCCESS;

    if (szLocalePath == NULL || pcchPathLength == NULL) {
        Status = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            DWORD dwPathLength = * pcchPathLength;

            if (* szLocalePath == L'\0' || lstrlenW(szLocalePath) > PDH_MAX_COUNTER_PATH) {
                Status = PDH_INVALID_ARGUMENT;
            }
            else if (dwPathLength > 0) {
                if (pszFullPathName == NULL) {
                    Status = PDH_INVALID_ARGUMENT;
                }
                else {
                    * pszFullPathName = L'\0';
                    * (LPWSTR) (pszFullPathName + (dwPathLength - 1)) = L'\0';
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            Status = PDH_INVALID_ARGUMENT;
        }
    }
    if (Status == ERROR_SUCCESS) {
        Status = PdhiTranslateCounter(szLocalePath, pszFullPathName, pcchPathLength, TRUE, TRUE);
    }
    return Status;
}

PDH_FUNCTION
PdhTranslate009CounterA(
    IN  LPSTR   szLocalePath,
    IN  LPSTR   pszFullPathName,
    IN  LPDWORD pcchPathLength
)
{
    PDH_STATUS Status     = ERROR_SUCCESS;
    LPWSTR     szTmpPath  = NULL;

    if (szLocalePath == NULL || pcchPathLength == NULL) {
        Status = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            DWORD dwPathLength = * pcchPathLength;

            if (* szLocalePath == '\0' || lstrlenA(szLocalePath) > PDH_MAX_COUNTER_PATH) {
                Status = PDH_INVALID_ARGUMENT;
            }
            else {
                szTmpPath = PdhiMultiByteToWideChar(_getmbcp(), szLocalePath);
                if (szTmpPath == NULL) {
                    Status = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            }
            if (Status == ERROR_SUCCESS) {
                if (dwPathLength > 0) {
                    if (pszFullPathName == NULL) {
                        Status = PDH_INVALID_ARGUMENT;
                    }
                    else {
                        * pszFullPathName = '\0';
                        * (LPWSTR) (pszFullPathName + (dwPathLength - 1)) = '\0';
                    }
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            Status = PDH_INVALID_ARGUMENT;
        }
    }
    if (Status == ERROR_SUCCESS) {
        Status = PdhiTranslateCounter(szTmpPath, pszFullPathName, pcchPathLength, TRUE, FALSE);
    }
    G_FREE(szTmpPath);
    return Status;
}

PDH_FUNCTION
PdhTranslateLocaleCounterW(
    IN  LPWSTR  sz009Path,
    IN  LPWSTR  pszFullPathName,
    IN  LPDWORD pcchPathLength
)
{
    PDH_STATUS Status = ERROR_SUCCESS;

    if (sz009Path == NULL || pcchPathLength == NULL) {
        Status = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            DWORD dwPathLength = * pcchPathLength;

            if (* sz009Path == L'\0' || lstrlenW(sz009Path) > PDH_MAX_COUNTER_PATH) {
                Status = PDH_INVALID_ARGUMENT;
            }
            else if (dwPathLength > 0) {
                if (pszFullPathName == NULL) {
                    Status = PDH_INVALID_ARGUMENT;
                }
                else {
                    * pszFullPathName = L'\0';
                    * (LPWSTR) (pszFullPathName + (dwPathLength - 1)) = L'\0';
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            Status = PDH_INVALID_ARGUMENT;
        }
    }
    if (Status == ERROR_SUCCESS) {
        Status = PdhiTranslateCounter(sz009Path, pszFullPathName, pcchPathLength, FALSE, TRUE);
    }
    return Status;
}

PDH_FUNCTION
PdhTranslateLocaleCounterA(
    IN  LPSTR   sz009Path,
    IN  LPSTR   pszFullPathName,
    IN  LPDWORD pcchPathLength
)
{
    PDH_STATUS Status     = ERROR_SUCCESS;
    LPWSTR     szTmpPath  = NULL;
    DWORD      dwPathSize;

    if (sz009Path == NULL || pcchPathLength == NULL) {
        Status = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            DWORD dwPathLength = * pcchPathLength;

            if (* sz009Path == '\0' || lstrlenA(sz009Path) > PDH_MAX_COUNTER_PATH) {
                Status = PDH_INVALID_ARGUMENT;
            }
            else {
                szTmpPath = PdhiMultiByteToWideChar(CP_ACP, sz009Path);
                if (szTmpPath == NULL) {
                    Status = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            }
            if (Status == ERROR_SUCCESS) {
                if (dwPathLength > 0) {
                    if (pszFullPathName == NULL) {
                        Status = PDH_INVALID_ARGUMENT;
                    }
                    else {
                        * pszFullPathName = '\0';
                        * (LPWSTR) (pszFullPathName + (dwPathLength - 1)) = '\0';
                    }
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            Status = PDH_INVALID_ARGUMENT;
        }
    }
    if (Status == ERROR_SUCCESS) {
        Status = PdhiTranslateCounter(szTmpPath, pszFullPathName, pcchPathLength, FALSE, FALSE);
    }
    G_FREE(szTmpPath);
    return Status;
}

PDH_FUNCTION
PdhAdd009CounterW(
    IN  PDH_HQUERY     hQuery,
    IN  LPWSTR         szFullPath,
    IN  DWORD_PTR      dwUserData,
    OUT PDH_HCOUNTER * phCounter
)
{
    PDH_STATUS  Status       = ERROR_SUCCESS;
    LPWSTR      szLocalePath = NULL;
    DWORD       dwPathLength;

    if (szFullPath == NULL || phCounter == NULL) {
        Status = PDH_INVALID_ARGUMENT;
    }
    else if (IsValidQuery(hQuery)) {
        __try {
            DWORD_PTR dwLocalData = dwUserData;

            * phCounter  = NULL;
            dwPathLength = lstrlenW(szFullPath);
            if (dwPathLength > PDH_MAX_COUNTER_PATH) {
                Status = PDH_INVALID_ARGUMENT;
            }
            else {
                dwPathLength ++;
                szLocalePath = G_ALLOC(sizeof(WCHAR) * dwPathLength);
                if (szLocalePath != NULL) {
                    Status = PdhTranslateLocaleCounterW(szFullPath, szLocalePath, & dwPathLength);
                    while (Status == PDH_MORE_DATA) {
                        G_FREE(szLocalePath);
                        szLocalePath = G_ALLOC(sizeof(WCHAR) * dwPathLength);
                        if (szLocalePath == NULL) {
                            Status = PDH_MEMORY_ALLOCATION_FAILURE;
                        }
                        else {
                            Status = PdhTranslateLocaleCounterW(szFullPath, szLocalePath, & dwPathLength);
                        }
                    }
                }
                else {
                    Status = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            Status = PDH_INVALID_ARGUMENT;
        }
    }
    else {
        Status = PDH_INVALID_ARGUMENT;
    }
    if (Status == ERROR_SUCCESS) {
        Status = PdhAddCounterW(hQuery, szLocalePath, dwUserData, phCounter);
    }
    G_FREE(szLocalePath);
    return Status;
}

PDH_FUNCTION
PdhAdd009CounterA(
    IN  PDH_HQUERY     hQuery,
    IN  LPSTR          szFullPath,
    IN  DWORD_PTR      dwUserData,
    OUT PDH_HCOUNTER * phCounter
)
{
    PDH_STATUS  Status       = ERROR_SUCCESS;
    LPSTR       szLocalePath = NULL;
    DWORD       dwPathLength;

    if (szFullPath == NULL || phCounter == NULL) {
        Status = PDH_INVALID_ARGUMENT;
    }
    else if (IsValidQuery(hQuery)) {
        __try {
            DWORD_PTR dwLocalData = dwUserData;

            * phCounter  = NULL;
            dwPathLength = lstrlenA(szFullPath) + 1;
            if (dwPathLength > PDH_MAX_COUNTER_PATH) {
                Status = PDH_INVALID_ARGUMENT;
            }
            else {
                dwPathLength ++;
                szLocalePath = G_ALLOC(sizeof(CHAR) * dwPathLength);
                if (szLocalePath != NULL) {
                    Status = PdhTranslateLocaleCounterA(szFullPath, szLocalePath, & dwPathLength);
                    while (Status == PDH_MORE_DATA) {
                        G_FREE(szLocalePath);
                        szLocalePath = G_ALLOC(sizeof(CHAR) * dwPathLength);
                        if (szLocalePath == NULL) {
                            Status = PDH_MEMORY_ALLOCATION_FAILURE;
                        }
                        else {
                            Status = PdhTranslateLocaleCounterA(szFullPath, szLocalePath, & dwPathLength);
                        }
                    }
                }
                else {
                    Status = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            Status = PDH_INVALID_ARGUMENT;
       }
    }
    else {
        Status = PDH_INVALID_ARGUMENT;
    }
    if (Status == ERROR_SUCCESS) {
        Status = PdhAddCounterA(hQuery, szLocalePath, dwUserData, phCounter);
    }
    G_FREE(szLocalePath);
    return Status;
}

PDH_FUNCTION
PdhiConvertUnicodeToAnsi(
    UINT     uCodePage,
    LPWSTR   wszSrc,
    LPSTR    aszDest,
    LPDWORD  pdwSize
)
{
    PDH_STATUS Status  = ERROR_SUCCESS;
    DWORD      dwDest;
    DWORD      dwSrc   = 0;
    DWORD      dwSize  = * pdwSize;

    if (wszSrc == NULL || pdwSize == NULL) {
        Status = PDH_INVALID_ARGUMENT;
    }
    else if (* wszSrc == L'\0') {
        Status = PDH_INVALID_ARGUMENT;
    }
    else {
        dwSrc  = lstrlenW(wszSrc);
        dwDest = WideCharToMultiByte(uCodePage, 0, wszSrc, dwSrc, NULL, 0, NULL, NULL);
        if (aszDest != NULL && (dwDest + 1) <= dwSize) {
            ZeroMemory(aszDest, dwSize * sizeof(CHAR));
            WideCharToMultiByte(_getmbcp(), 0, wszSrc, dwSrc, aszDest, * pdwSize, NULL, NULL);
            TRACE((PDH_DBG_TRACE_INFO),
                  (__LINE__,
                   PDH_QUERY,
                   ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                   ERROR_SUCCESS,
                   TRACE_WSTR(wszSrc),
                   TRACE_STR(aszDest),
                   TRACE_DWORD(dwSrc),
                   TRACE_DWORD(dwDest),
                   TRACE_DWORD(dwSize),
                   NULL));
        }
        else {
            Status = PDH_MORE_DATA;
            TRACE((PDH_DBG_TRACE_WARNING),
                  (__LINE__,
                   PDH_QUERY,
                   ARG_DEF(ARG_TYPE_WSTR, 1),
                   PDH_MORE_DATA,
                   TRACE_WSTR(wszSrc),
                   TRACE_DWORD(dwSrc),
                   TRACE_DWORD(dwDest),
                   TRACE_DWORD(dwSize),
                   NULL));
        }

        * pdwSize = dwDest + 1;
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhlog\log.c ===
/*++
Copyright (C) 1995-1999 Microsoft Corporation

Module Name:
    log.c

Abstract:
    Log file interface functions exposed in pdh.dll
--*/

#include <windows.h>
#ifndef _PRSHT_H_   // to eliminate W4 errors in commdlg.h
#define _PRSHT_H_ 
#endif      
#include <commdlg.h>
#include <mbctype.h>
#include <strsafe.h>
#include <pdh.h>
#include "pdhidef.h"
#include "strings.h"
#include "log_text.h"
#include "log_bin.h"
#include "log_sql.h"
#include "log_pm.h"
#include "log_wmi.h"
#include "resource.h"
#include "pdhmsg.h"

#pragma warning (disable : 4213)

// note that when the log file headers are written
// they will be prefixed with a double quote character
LPCSTR      szTsvLogFileHeader  = "(PDH-TSV 4.0)";
LPCSTR      szCsvLogFileHeader  = "(PDH-CSV 4.0)";
LPCSTR      szBinLogFileHeader  = "(PDH-BIN 4.0)";
LPCSTR      szTsvType           = "PDH-TSV";
LPCSTR      szCsvType           = "PDH-CSV";
LPCSTR      szBinaryType        = "PDH-BIN";
const DWORD dwFileHeaderLength  = 13;
const DWORD dwTypeLoc           = 2;
const DWORD dwVersionLoc        = 10;
const DWORD dwFieldLength       = 7;
const DWORD dwPerfmonTypeLength = 5;    //size in chars

// max mapping size of headers for binary log files
#define PDH_LOG_HEADER_MAP_SIZE 8192
#define VALUE_BUFFER_SIZE         32

typedef struct  _FILE_FILTER_INFO {
    UINT    nDisplayTextResourceId;
    LPWSTR  szFilterText;
    DWORD   dwFilterTextSize;
} FILE_FILTER_INFO;
//
//  global variables
//
PPDHI_LOG             PdhiFirstLogEntry = NULL;
PPDHI_MAPPED_LOG_FILE PdhipFirstLogFile = NULL;

FILE_FILTER_INFO    ffiLogFilterInfo[] = {
    {IDS_LOGTYPE_PDH_LOGS,  (LPWSTR) L"*.blg;*.csv;*.tsv",       17},
    {IDS_LOGTYPE_BIN_LOGS,  (LPWSTR) L"*.blg",                    5},
    {IDS_LOGTYPE_CSV_LOGS,  (LPWSTR) L"*.csv",                    5},
    {IDS_LOGTYPE_TSV_LOGS,  (LPWSTR) L"*.tsv",                    5},
    {IDS_LOGTYPE_PM_LOGS,   (LPWSTR) L"*.log",                    5},
    {IDS_LOGTYPE_ALL_LOGS,  (LPWSTR) L"*.blg;*.csv;*.tsv;*.log", 23},
    {IDS_LOGTYPE_ALL_FILES, (LPWSTR) L"*.*",                      4},
    {0, NULL, 0}
};

STATIC_DWORD
MakeLogFilterInfoString(
    LPWSTR  szLogFilter,
    DWORD   cchLogFilterSize
)
{
    FILE_FILTER_INFO * pFFI      = & ffiLogFilterInfo[0];
    WCHAR              szThisEntry[MAX_PATH];
    DWORD              dwStatus  = ERROR_SUCCESS;
    LPWSTR             szDestPtr = szLogFilter;
    LPWSTR             szEndPtr  = szDestPtr + cchLogFilterSize;
    DWORD              dwUsed    = 0;
    DWORD              dwThisStringLen;

    ZeroMemory(szLogFilter, cchLogFilterSize * sizeof(WCHAR));
    while (szEndPtr > szDestPtr && pFFI->szFilterText != NULL) {
        dwThisStringLen = LoadStringW(ThisDLLHandle, pFFI->nDisplayTextResourceId, szThisEntry, MAX_PATH);
        if (dwThisStringLen > 0) {
            if (dwUsed + dwThisStringLen + 1 <= cchLogFilterSize) {
                // add in this string
                StringCchCopyW(szDestPtr, cchLogFilterSize - dwUsed, szThisEntry);
                dwUsed    += dwThisStringLen + 1;
                szDestPtr += dwThisStringLen + 1;
            }
        }
        dwThisStringLen = pFFI->dwFilterTextSize;
        if (dwUsed + dwThisStringLen + 1 <= cchLogFilterSize) {
            // add in this string
            StringCchCopyW(szDestPtr, cchLogFilterSize - dwUsed, pFFI->szFilterText);
            dwUsed    += dwThisStringLen + 1;
            szDestPtr += dwThisStringLen + 1;
        }
        pFFI ++;
    }
    if (dwUsed > 0 && dwUsed < cchLogFilterSize) {
        // add MSZ NULL
        * szDestPtr = L'\0';
    }
    else {
        dwStatus = ERROR_INSUFFICIENT_BUFFER;
    }   
    return dwStatus;
}

//
//  Internal  Logging utility functions
//
STATIC_DWORD
OpenReadonlyMappedFile(
    PPDHI_LOG               pLog,
    LPCWSTR                 szFileName,
    PPDHI_MAPPED_LOG_FILE * pFileEntry,
    DWORD                   dwLogType
)
{
    PDH_STATUS             pdhStatus     = ERROR_SUCCESS;
    DWORD                  dwSize;
    PPDHI_MAPPED_LOG_FILE  pOpenedFile   = NULL;
    LPWSTR                 szSectionName = NULL;
    LPWSTR                 szThisChar;
    DWORD                  dwLoSize, dwHiSize;

    pdhStatus = WaitForSingleObject(hPdhContextMutex, 10000);
    if (pdhStatus == WAIT_TIMEOUT) {
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
    }
    else {
        if (PdhipFirstLogFile == NULL) {
            // then there are no mapped files so create a new entry and 
            // fill it with this file
            pOpenedFile = NULL;
        }
        else {
            for (pOpenedFile = PdhipFirstLogFile; pOpenedFile != NULL; pOpenedFile = pOpenedFile->pNext) {
                if (lstrcmpiW(szFileName, pOpenedFile->szLogFileName) == 0) break;
            }
            // here pOpenedFile will either be NULL or a ponter
        }
        if (pOpenedFile == NULL) {
            DWORD dwPID     = GetCurrentProcessId();
            DWORD dwSection = lstrlenW(cszLogSectionName) + lstrlenW(szFileName) + 16;
            szSectionName   = (LPWSTR) G_ALLOC(dwSection * sizeof(WCHAR));

            // create a new entry
            dwSize      = sizeof(PDHI_MAPPED_LOG_FILE) + QWORD_MULTIPLE((lstrlenW(szFileName) + 1) * sizeof(WCHAR));
            pOpenedFile = (PPDHI_MAPPED_LOG_FILE) G_ALLOC(dwSize);
            if (pOpenedFile != NULL && szSectionName != NULL) {
                // initialize the pointers
                pOpenedFile->szLogFileName = (LPWSTR) & pOpenedFile[1];
                StringCchCopyW(pOpenedFile->szLogFileName, lstrlenW(szFileName) + 1, szFileName);
                pOpenedFile->hFileHandle = CreateFileW(pOpenedFile->szLogFileName,
                                                       GENERIC_READ,                       // Read Access for input
                                                       FILE_SHARE_READ | FILE_SHARE_WRITE, // allow read sharing
                                                       NULL,                               // default security
                                                       OPEN_EXISTING,
                                                       FILE_ATTRIBUTE_NORMAL,              // ignored
                                                       NULL);                              // no template file
                if (pOpenedFile->hFileHandle != INVALID_HANDLE_VALUE) {
                    StringCchPrintfW(szSectionName, dwSection, L"%s_%8.8x_%s", 
                                                    cszLogSectionName, dwPID, pOpenedFile->szLogFileName);
                    // remove filename type characters 
                    for (szThisChar = szSectionName; * szThisChar != L'\0'; szThisChar ++) {
                        switch (*szThisChar) {
                        case L'\\':
                        case L':':
                        case L'.':
                            * szThisChar = L'_';
                            break;

                        default:
                            break;
                        }
                    }
                    dwLoSize                  = GetFileSize(pOpenedFile->hFileHandle, & dwHiSize);
                    pOpenedFile->llFileSize   = dwHiSize;
                    pOpenedFile->llFileSize <<= 32;
                    pOpenedFile->llFileSize  &= 0xFFFFFFFF00000000;
                    pOpenedFile->llFileSize  += dwLoSize;

                    // just map the header for starters

                    if (pOpenedFile->llFileSize > 0) {
                        pLog->iRunidSQL = 0;
                        if (dwLogType == PDH_LOG_TYPE_RETIRED_BIN) {
                            pOpenedFile->hMappedFile = CreateFileMappingW(pOpenedFile->hFileHandle,
                                                                          NULL,
                                                                          PAGE_READONLY,
                                                                          dwHiSize,
                                                                          dwLoSize,
                                                                          szSectionName);
                            if (pOpenedFile->hMappedFile == NULL) {
                                dwHiSize = 0;
                                dwLoSize = PDH_LOG_HEADER_MAP_SIZE;
                            }
                            else {
                                pOpenedFile->pData = MapViewOfFile(pOpenedFile->hMappedFile,
                                                                   FILE_MAP_READ,
                                                                   0,
                                                                   0,
                                                                   dwLoSize);
                                if (pOpenedFile->pData == NULL) {
                                    dwHiSize = 0;
                                    dwLoSize = PDH_LOG_HEADER_MAP_SIZE;
                                }
                                else {
                                    pLog->iRunidSQL = 1;
                                }
                            }
                        }

                        if (pLog->iRunidSQL == 0) {
                            pOpenedFile->hMappedFile = CreateFileMappingW(pOpenedFile->hFileHandle,
                                                                          NULL,
                                                                          PAGE_READONLY,
                                            dwHiSize, dwLoSize, szSectionName);
                            if (pOpenedFile->hMappedFile != NULL) {
                                pOpenedFile->pData = MapViewOfFile(pOpenedFile->hMappedFile,
                                                                   FILE_MAP_READ,
                                                                   0,
                                                                   0,
                                                                   dwLoSize);
                                if (pOpenedFile->pData == NULL) {
                                    pdhStatus = GetLastError();
                                }
                            }
                            else {
                                pdhStatus = GetLastError();
                            }
                        }
                    } else {
                        // 0-length file
                        pdhStatus = ERROR_FILE_INVALID;
                    }
                }
                else {
                    pdhStatus = GetLastError();
                }
    
                if (pdhStatus == ERROR_SUCCESS) {
                    // then add this to the list and return the answer
                    pOpenedFile->pNext      = PdhipFirstLogFile;
                    PdhipFirstLogFile       = pOpenedFile;
                    // init ref count
                    pOpenedFile->dwRefCount = 1;
                    * pFileEntry            = pOpenedFile;
                }
                else {
                    // delete it from the list and return NULL
                    if (pOpenedFile->pData       != NULL) UnmapViewOfFile(pOpenedFile->pData);
                    if (pOpenedFile->hMappedFile != NULL) CloseHandle(pOpenedFile->hMappedFile);
                    if (pOpenedFile->hFileHandle != NULL) CloseHandle(pOpenedFile->hFileHandle);
                    * pFileEntry = NULL;
                }
            }
            else {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
        else {
            * pFileEntry = pOpenedFile;
            pOpenedFile->dwRefCount ++;
        }
        RELEASE_MUTEX(hPdhContextMutex);
    }

    if (pdhStatus != ERROR_SUCCESS) G_FREE(pOpenedFile);
    G_FREE(szSectionName);
    return pdhStatus;
}


DWORD
UnmapReadonlyMappedFile(
    LPVOID   pMemoryBase,
    BOOL   * bNeedToCloseHandles
)
{
    PDH_STATUS              pdhStatus = ERROR_SUCCESS;
    PPDHI_MAPPED_LOG_FILE   pOpenedFile;
    PPDHI_MAPPED_LOG_FILE   pPrevFile = NULL;

    pdhStatus = WaitForSingleObject(hPdhContextMutex, 10000);
    if (pdhStatus  == WAIT_TIMEOUT) {
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
    }
    else {
        // find file to close
        for (pOpenedFile = PdhipFirstLogFile; pOpenedFile != NULL; pOpenedFile = pOpenedFile->pNext) {
            if (pOpenedFile->pData == pMemoryBase) {
                break;
            }
            else {
                pPrevFile = pOpenedFile;
            }
        }
        // here pOpenedFile will either be NULL or a ponter
        if (pOpenedFile != NULL) {
            -- pOpenedFile->dwRefCount;
            if (pOpenedFile->dwRefCount == 0) {
                // found so remove from list and close
                if (pOpenedFile == PdhipFirstLogFile) {
                    PdhipFirstLogFile = pOpenedFile->pNext;
                }
                else {
#pragma warning( disable: 4701 ) // pPrevFile will only be used if the opened log is not the first log
                    pPrevFile->pNext = pOpenedFile->pNext;
#pragma warning (default : 4701 )
                }
                // close open resources
                if (pOpenedFile->pData       != NULL) UnmapViewOfFile(pOpenedFile->pData);
                if (pOpenedFile->hMappedFile != NULL) CloseHandle(pOpenedFile->hMappedFile);
                if (pOpenedFile->hFileHandle != NULL) CloseHandle(pOpenedFile->hFileHandle);
                G_FREE(pOpenedFile);
            }
            * bNeedToCloseHandles = FALSE;
        }
        else {
            // then this must be a normal mapped file
            if (! UnmapViewOfFile(pMemoryBase)) {
                pdhStatus = GetLastError();
            }
            * bNeedToCloseHandles = TRUE;
        }
        RELEASE_MUTEX (hPdhContextMutex);
    }
    return pdhStatus;
}

STATIC_BOOL
IsValidLogHandle(
    PDH_HLOG  hLog
)
/*++
Routine Description:
    examines the log handle to verify it is a valid log entry. For now
        the test amounts to:
            the Handle is NOT NULL
            the memory is accessible (i.e. it doesn't AV)
            the signature array is valid
            the size field is correct

        if any tests fail, the handle is presumed to be invalid

Arguments:
    IN  HLOG    hLog
        the handle of the log entry  to test

Return Value:
    TRUE    the handle passes all the tests
    FALSE   one of the test's failed and the handle is not a valid counter
--*/
{
    BOOL      bReturn = FALSE;    // assume it's not a valid query
    PPDHI_LOG pLog;
    
    __try {
        if (hLog != NULL) {
            // see if a valid signature
            pLog = (PPDHI_LOG) hLog;
            if ((* (DWORD *) & pLog->signature[0] == SigLog) && (pLog->dwLength == sizeof(PDHI_LOG))) {
                bReturn = TRUE;
            }
            else {
                // this is not a valid log entry because the sig is bad
                // or the structure is the wrong size
            }
        }
        else {
            // this is not a valid counter because the handle is NULL
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        // something failed miserably so we can assume this is invalid
    }
    return bReturn;
}

STATIC_DWORD
GetLogFileType(
    HANDLE  hLogFile
)
{
    CHAR         cBuffer[MAX_PATH];
    LPSTR        aszString;
    LPWSTR       wszString;
    CHAR         aszChar;
    WCHAR        wszChar;
    BOOL         bStatus;
    DWORD        dwResult            = PDH_LOG_TYPE_UNDEFINED;
    DWORD        dwBytesRead;

    ZeroMemory(cBuffer, MAX_PATH * sizeof(CHAR));

    // read first log file record
    SetFilePointer(hLogFile, 0, NULL, FILE_BEGIN);
    bStatus = ReadFile(hLogFile, (LPVOID) cBuffer, dwFileHeaderLength, & dwBytesRead, NULL);
    if (bStatus) {
        // read header record to get type
        aszString = (cBuffer + dwTypeLoc);
        aszChar   = * (aszString + dwFieldLength);
        * (aszString + dwFieldLength) = '\0';
        if (lstrcmpiA(aszString, szTsvType) == 0) {
            dwResult = PDH_LOG_TYPE_TSV;
        }
        else if (lstrcmpiA(aszString, szCsvType) == 0) {
            dwResult = PDH_LOG_TYPE_CSV;
        }
        else if (lstrcmpiA(aszString, szBinaryType) == 0) {
            dwResult = PDH_LOG_TYPE_RETIRED_BIN;
        }
        else {
            * (aszString + dwFieldLength) = aszChar;
            wszString = (LPWSTR) cBuffer;
            wszChar   = * (wszString + dwPerfmonTypeLength);
            * (wszString + dwPerfmonTypeLength) = L'\0';
            // perfmon log file type string is in a different
            // location than sysmon logs and used wide chars.
            if (lstrcmpiW(wszString, cszPerfmonLogSig) == 0) {
                dwResult = PDH_LOG_TYPE_PERFMON;
            }
        } 
    }
    return dwResult;
}

STATIC_PDH_FUNCTION
CreateNewLogEntry(
    LPCWSTR      szLogFileName,
    PDH_HQUERY   hQuery,
    DWORD        dwMaxSize,
    PPDHI_LOG  * pLog
)
/*++
    creates a new log entry and inserts it in the list of open log files
--*/
{
    PPDHI_LOG   pNewLog;
    PPDHI_LOG   pFirstLog;
    PPDHI_LOG   pLastLog;
    DWORD       dwSize;
    PDH_STATUS  pdhStatus         = ERROR_SUCCESS;
    DWORD       dwLogFileNameSize = lstrlenW(szLogFileName) + 1;

    dwSize  = sizeof(PDHI_LOG) + DWORD_MULTIPLE(2 * dwLogFileNameSize * sizeof(WCHAR));
    pNewLog = G_ALLOC(dwSize);   // allocate new structure

    if (pNewLog == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        * pLog = NULL;
    }
    else {
        // initialize the elements in the structure
        * ((LPDWORD) (& pNewLog->signature[0])) = SigLog;
        // create and acquire a data mutex for this
        pNewLog->hLogMutex = CreateMutexW(NULL, TRUE, NULL);

        // insert this item at the end of the list
        if (PdhiFirstLogEntry == NULL) {
             // then this is the first entry
            PdhiFirstLogEntry   = pNewLog;
            pNewLog->next.flink =
            pNewLog->next.blink = pNewLog;
        }
        else {
            // go to the first entry and insert this one just before it
            pFirstLog             = PdhiFirstLogEntry;
            pLastLog              = pFirstLog->next.blink;
            pNewLog->next.flink   = pLastLog->next.flink;
            pLastLog->next.flink  = pNewLog;
            pNewLog->next.blink   = pFirstLog->next.blink;
            pFirstLog->next.blink = pNewLog;
        }
        // set length field (this is used more for validation
        // than anything else
        pNewLog->dwLength = sizeof(PDHI_LOG);
        // append filename strings immediately after this block
        pNewLog->szLogFileName = (LPWSTR) (& pNewLog[1]);
        StringCchCopyW(pNewLog->szLogFileName, dwLogFileNameSize, szLogFileName);
        // locate catalog name immediately after log file name
        pNewLog->szCatFileName = pNewLog->szLogFileName + dwLogFileNameSize;
        // 
        // NOTE: Catalog should be in the logfile itself, so no need for
        // yet another file extension
        StringCchCopyW(pNewLog->szCatFileName, dwLogFileNameSize, szLogFileName);
        // initialize the file handles
        pNewLog->hLogFileHandle = INVALID_HANDLE_VALUE;
        pNewLog->hCatFileHandle = INVALID_HANDLE_VALUE;

        // initialize the Record Length size
        pNewLog->llMaxSize     = (LONGLONG) ((ULONGLONG) dwMaxSize);
        pNewLog->dwRecord1Size = 0;

        // assign the query
        pNewLog->pQuery        = (PPDHI_QUERY) hQuery;
        pNewLog->dwLogFormat   = 0; // for now
        pNewLog->pPerfmonInfo  = NULL;
        * pLog                 = pNewLog;
    }
    return pdhStatus;
}

OpenSQLLog(
    PPDHI_LOG pLog,
    DWORD     dwAccessFlags,
    LPDWORD   lpdwLogType
)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    pLog->dwLogFormat  = PDH_LOG_TYPE_SQL;
    pLog->dwLogFormat |= dwAccessFlags & (PDH_LOG_ACCESS_MASK | PDH_LOG_OPT_MASK);
    if ((dwAccessFlags & PDH_LOG_WRITE_ACCESS) == PDH_LOG_WRITE_ACCESS) {
        pdhStatus = PdhiOpenOutputSQLLog(pLog);
    }
    else {
        pdhStatus = PdhiOpenInputSQLLog(pLog);
    }

    if (pdhStatus == ERROR_SUCCESS) {
        *lpdwLogType = (DWORD) (LOWORD(pLog->dwLogFormat));
    }
    return pdhStatus;
}

STATIC_PDH_FUNCTION
OpenInputLogFile(
    PPDHI_LOG   pLog,
    DWORD       dwAccessFlags,
    LPDWORD     lpdwLogType
)
{
    LONG                  Win32Error;
    PDH_STATUS            pdhStatus       = ERROR_SUCCESS;
    DWORD                 dwFileCreate    = 0;
    PPDHI_MAPPED_LOG_FILE pMappedFileInfo = NULL;

    // for input, the query handle is NULL
    pLog->pQuery = NULL;

////////////////
// SQL goes here 
///////////////

    // First test whether logfile is WMI Event Trace format.
    // If all logfiles are WMI Event Trace format, return immediately;
    // otherwise try other formats.
    //
    pdhStatus = PdhiOpenInputWmiLog(pLog);
    if (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_BINARY_LOG_CORRUPT || pdhStatus == PDH_LOG_SAMPLE_TOO_SMALL) {
        pLog->dwLogFormat  = PDH_LOG_TYPE_BINARY;
        pLog->dwLogFormat |= dwAccessFlags & (PDH_LOG_ACCESS_MASK | PDH_LOG_OPT_MASK);
        * lpdwLogType = PDH_LOG_TYPE_BINARY;
        return pdhStatus;
    }

    pdhStatus = ERROR_SUCCESS;

    // open file for input based on the specified access flags
    switch (dwAccessFlags & PDH_LOG_CREATE_MASK) {
    case PDH_LOG_OPEN_EXISTING:
        dwFileCreate = OPEN_EXISTING;
        break;

    case PDH_LOG_CREATE_NEW:
    case PDH_LOG_CREATE_ALWAYS:
    case PDH_LOG_OPEN_ALWAYS:
        // a log file to be read from must not be empty or non-existent
    default:
        // unrecognized value
        pdhStatus = PDH_INVALID_ARGUMENT;
        break;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pLog->hLogFileHandle = CreateFileW(pLog->szLogFileName,
                                           GENERIC_READ,                       // Read Access for input
                                           FILE_SHARE_READ | FILE_SHARE_WRITE, // allow read sharing
                                           NULL,                               // default security
                                           dwFileCreate,
                                           FILE_ATTRIBUTE_NORMAL,              // ignored
                                           NULL);                              // no template file
        if (pLog->hLogFileHandle == INVALID_HANDLE_VALUE) {
            Win32Error = GetLastError();
            // translate to PDH_ERROR
            switch (Win32Error) {
            case ERROR_FILE_NOT_FOUND:
                pdhStatus = PDH_FILE_NOT_FOUND;
                break;

            case ERROR_ALREADY_EXISTS:
                pdhStatus = PDH_FILE_ALREADY_EXISTS;
                break;

            default:
                switch (dwAccessFlags & PDH_LOG_CREATE_MASK) {
                case PDH_LOG_CREATE_NEW:
                case PDH_LOG_CREATE_ALWAYS:
                    pdhStatus = PDH_LOG_FILE_CREATE_ERROR;
                    break;

                case PDH_LOG_OPEN_EXISTING:
                case PDH_LOG_OPEN_ALWAYS:
                default:
                    pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
                    break;
                }
                break;
            }
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        // read the log header and determine the log file type
        pLog->dwLogFormat = GetLogFileType(pLog->hLogFileHandle);
        if (pLog->dwLogFormat != 0) {
            pLog->dwLogFormat |= dwAccessFlags & (PDH_LOG_ACCESS_MASK | PDH_LOG_OPT_MASK);
        }
        else {
            pdhStatus = PDH_LOG_TYPE_NOT_FOUND;
        }

        switch (LOWORD(pLog->dwLogFormat)) {
        case PDH_LOG_TYPE_RETIRED_BIN:
        case PDH_LOG_TYPE_PERFMON:  
            // close file opened above
            CloseHandle(pLog->hLogFileHandle);
            pLog->iRunidSQL = 0;
            pdhStatus = OpenReadonlyMappedFile(pLog,
                                               pLog->szLogFileName,
                                               & pMappedFileInfo,
                                               (DWORD) LOWORD(pLog->dwLogFormat));
            if (pdhStatus == ERROR_SUCCESS) {
                // then update log fields
                pLog->hLogFileHandle   = pMappedFileInfo->hFileHandle;
                pLog->hMappedLogFile   = pMappedFileInfo->hMappedFile;
                pLog->lpMappedFileBase = pMappedFileInfo->pData;
                pLog->llFileSize       = pMappedFileInfo->llFileSize;
            }
            break;

        case PDH_LOG_TYPE_CSV:
        case PDH_LOG_TYPE_TSV:
        default:
            break;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        // call any type-specific open functions
        switch (LOWORD(pLog->dwLogFormat)) {
        case PDH_LOG_TYPE_CSV:
        case PDH_LOG_TYPE_TSV:
            pdhStatus = PdhiOpenInputTextLog(pLog);
            break;

        case PDH_LOG_TYPE_RETIRED_BIN:
            pdhStatus = PdhiOpenInputBinaryLog(pLog);
            break;

        case PDH_LOG_TYPE_PERFMON:
            pdhStatus = PdhiOpenInputPerfmonLog(pLog);
            break;

        default:
            pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
            break;
        }
        * lpdwLogType = (DWORD) (LOWORD(pLog->dwLogFormat));
    }
    return pdhStatus;
}

STATIC_PDH_FUNCTION
OpenUpdateLogFile(
    PPDHI_LOG pLog,
    DWORD     dwAccessFlags,
    LPDWORD   lpdwLogType
)
{
    LONG        Win32Error;
    PDH_STATUS  pdhStatus    = ERROR_SUCCESS;
    DWORD       dwFileCreate = 0;

    // for input, the query handle is NULL
    pLog->pQuery = NULL;

    // open file for input based on the specified access flags

    switch (dwAccessFlags & PDH_LOG_CREATE_MASK) {
    case PDH_LOG_OPEN_EXISTING:
        dwFileCreate = OPEN_EXISTING;
        break;

    case PDH_LOG_CREATE_NEW:
    case PDH_LOG_CREATE_ALWAYS:
    case PDH_LOG_OPEN_ALWAYS:
        // a log file to be updated must not be empty or non-existent
    default:
        // unrecognized value
        pdhStatus = PDH_INVALID_ARGUMENT;
        break;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pLog->hLogFileHandle = CreateFileW(pLog->szLogFileName,
                                           GENERIC_READ | GENERIC_WRITE, // Read & Write Access for input
                                           FILE_SHARE_READ,              // allow read sharing
                                           NULL,                         // default security
                                           dwFileCreate,
                                           FILE_ATTRIBUTE_NORMAL,        // ignored
                                           NULL);                        // no template file
        if (pLog->hLogFileHandle == INVALID_HANDLE_VALUE) {
            Win32Error = GetLastError();
            // translate to PDH_ERROR
            switch (Win32Error) {
            case ERROR_FILE_NOT_FOUND:
                pdhStatus = PDH_FILE_NOT_FOUND;
                break;

            case ERROR_ALREADY_EXISTS:
                pdhStatus = PDH_FILE_ALREADY_EXISTS;
                break;

            default:
                switch (dwAccessFlags & PDH_LOG_CREATE_MASK) {
                case PDH_LOG_CREATE_NEW:
                case PDH_LOG_CREATE_ALWAYS:
                    pdhStatus = PDH_LOG_FILE_CREATE_ERROR;
                    break;

                case PDH_LOG_OPEN_EXISTING:
                case PDH_LOG_OPEN_ALWAYS:
                default:
                    pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
                    break;
                }
                break;
            }
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        // read the log header and determine the log file type
        pLog->dwLogFormat = GetLogFileType(pLog->hLogFileHandle);
        if (pLog->dwLogFormat != 0) {
            pLog->dwLogFormat |= dwAccessFlags & (PDH_LOG_ACCESS_MASK | PDH_LOG_OPT_MASK);
        }
        else {
            pdhStatus = PDH_LOG_TYPE_NOT_FOUND;
        }

        // call any type-specific open functions
        switch (LOWORD(pLog->dwLogFormat)) {
        case PDH_LOG_TYPE_CSV:
        case PDH_LOG_TYPE_TSV:
        case PDH_LOG_TYPE_BINARY:
            // this will be added later
            // updating a text file will be limited to appending, but that
            // has it's own problems (e.g. insuring the counter list
            // is the same in the new query as the one stored in the log file
            pdhStatus = PDH_NOT_IMPLEMENTED;
            break;

        case PDH_LOG_TYPE_RETIRED_BIN:
        case PDH_LOG_TYPE_PERFMON:
            pdhStatus = PDH_NOT_IMPLEMENTED;
            break;

        default:
            pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
            break;
        }
        * lpdwLogType = (DWORD) (LOWORD(pLog->dwLogFormat));
    }
    return pdhStatus;
}

STATIC_PDH_FUNCTION
OpenOutputLogFile(
    PPDHI_LOG pLog,
    DWORD     dwAccessFlags,
    LPDWORD   lpdwLogType
)
{
    LONG        Win32Error;
    PDH_STATUS  pdhStatus    = ERROR_SUCCESS;
    DWORD       dwFileCreate = 0;

    // for output, the query handle must be valid

    if (!IsValidQuery((PDH_HQUERY) pLog->pQuery)) {
        pdhStatus = PDH_INVALID_HANDLE;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // special handling PDH_LOG_TYPE_BINARY
        //
        if (* lpdwLogType == PDH_LOG_TYPE_BINARY) {
            * lpdwLogType = PDH_LOG_TYPE_BINARY;
            pLog->dwLogFormat  = dwAccessFlags & (PDH_LOG_ACCESS_MASK | PDH_LOG_OPT_MASK);
            pLog->dwLogFormat |= *lpdwLogType & ~(PDH_LOG_ACCESS_MASK | PDH_LOG_OPT_MASK);
            return (PdhiOpenOutputWmiLog(pLog));
        }
    }

    // open file for output based on the specified access flags
    if (pdhStatus == ERROR_SUCCESS) {
        switch (dwAccessFlags & PDH_LOG_CREATE_MASK) {
        case PDH_LOG_CREATE_NEW:
            dwFileCreate = CREATE_NEW;
            break;

        case PDH_LOG_CREATE_ALWAYS:
        dwFileCreate = CREATE_ALWAYS;
            break;

        case PDH_LOG_OPEN_EXISTING:
            dwFileCreate = OPEN_EXISTING;
            break;

        case PDH_LOG_OPEN_ALWAYS:
            dwFileCreate = OPEN_ALWAYS;
            break;

        default:
            // unrecognized value
            pdhStatus = PDH_INVALID_ARGUMENT;
            break;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pLog->hLogFileHandle = CreateFileW(pLog->szLogFileName,
                                           GENERIC_WRITE | GENERIC_READ, // write access for output
                                           FILE_SHARE_READ,              // allow read sharing
                                           NULL,                         // default security
                                           dwFileCreate,
                                           FILE_ATTRIBUTE_NORMAL,
                                           NULL);                        // no template file
        if (pLog->hLogFileHandle == INVALID_HANDLE_VALUE) {
            Win32Error = GetLastError();
            // translate to PDH_ERROR
            switch (Win32Error) {
            case ERROR_FILE_NOT_FOUND:
                pdhStatus = PDH_FILE_NOT_FOUND;
                break;

            case ERROR_ALREADY_EXISTS:
                pdhStatus = PDH_FILE_ALREADY_EXISTS;
                break;

            default:
                switch (dwAccessFlags & PDH_LOG_CREATE_MASK) {
                case PDH_LOG_CREATE_NEW:
                case PDH_LOG_CREATE_ALWAYS:
                    pdhStatus = PDH_LOG_FILE_CREATE_ERROR;
                    break;

                case PDH_LOG_OPEN_EXISTING:
                case PDH_LOG_OPEN_ALWAYS:
                default:
                    pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
                    break;
                }
                break;
            }
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        // the file opened successfully so update the data structure
        // this assumes the access flags are in the HIWORD and the...
        pLog->dwLogFormat  = dwAccessFlags & (PDH_LOG_ACCESS_MASK | PDH_LOG_OPT_MASK);
        // the type id is in the LOWORD
        pLog->dwLogFormat |= *lpdwLogType & ~(PDH_LOG_ACCESS_MASK | PDH_LOG_OPT_MASK);

        // call any type-specific open functions
        switch (LOWORD(pLog->dwLogFormat)) {
        case PDH_LOG_TYPE_CSV:
        case PDH_LOG_TYPE_TSV:
            pdhStatus = PdhiOpenOutputTextLog(pLog);
            break;

        case PDH_LOG_TYPE_RETIRED_BIN:
        case PDH_LOG_TYPE_PERFMON:
            // cannot create counter logfile with PERFMON4 LOG format or WIN2K BLG format.
            pdhStatus = PDH_NOT_IMPLEMENTED;
            break;

        case PDH_LOG_TYPE_SQL:
            // SQL data soruce should be handled in PdhOpenLogW() before
            // it calls OpenOutputLogFile(). If it goes here, this is
            // an incorrect SQL datasoruce format.
            //
            pdhStatus = PDH_INVALID_SQL_LOG_FORMAT;
            break;

        default:
            pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
            break;
        }
    }
    return pdhStatus;
}

STATIC_PDH_FUNCTION
WriteLogHeader(
    PPDHI_LOG pLog,
    LPCWSTR   szUserCaption
)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    switch (LOWORD(pLog->dwLogFormat)) {
    case PDH_LOG_TYPE_CSV:
    case PDH_LOG_TYPE_TSV:
        pdhStatus = PdhiWriteTextLogHeader(pLog, szUserCaption);
        break;

    case PDH_LOG_TYPE_RETIRED_BIN:
    case PDH_LOG_TYPE_PERFMON:
        pdhStatus = PDH_NOT_IMPLEMENTED;
        break;

    case PDH_LOG_TYPE_BINARY:
        break;

    case PDH_LOG_TYPE_SQL:
        pdhStatus = PdhiWriteSQLLogHeader(pLog, szUserCaption);
        break;

    default:
        pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
        break;
    }
    return pdhStatus;

}

STATIC_PDH_FUNCTION
DeleteLogEntry(
    PPDHI_LOG pLog
)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    PPDHI_LOG  pLogNext;

    // assumes structure is locked
    if (IsValidLogHandle ((PDH_HLOG) pLog)) {
        if (PdhiFirstLogEntry == pLog) {
            // then this is the first entry in the list so the
            // the "first" entry will be the next forward entry
            if (pLog->next.flink == pLog->next.blink && pLog->next.flink == pLog) {
                // then this is the only entry in the list so clear the first
                // log entry
                PdhiFirstLogEntry = NULL;
            }
            else {
                // remove this entry from the list
                (pLog->next.flink)->next.blink = pLog->next.blink;
                (pLog->next.blink)->next.flink = pLog->next.flink;
                PdhiFirstLogEntry              = pLog->next.flink;
            }
        }
        else {
            // it's not the first one, so
            // just remove it from the list
            (pLog->next.flink)->next.blink = pLog->next.blink;
            (pLog->next.blink)->next.flink = pLog->next.flink;
        }
        // and release the memory block;
        if (pLog->hLogMutex != NULL) {
            while (WAIT_FOR_AND_LOCK_MUTEX(pLog->hLogMutex) == WAIT_TIMEOUT);
            RELEASE_MUTEX(pLog->hLogMutex);
            CloseHandle(pLog->hLogMutex);
        }

        while (pLog) {
            pLogNext = pLog->NextLog;
            G_FREE(pLog);
            pLog     = pLogNext;
        }
        pdhStatus = ERROR_SUCCESS;
    }
    else {
        pdhStatus = PDH_INVALID_HANDLE;
    }
    return pdhStatus;
}


STATIC_PDH_FUNCTION
CloseAndDeleteLogEntry(
    PPDHI_LOG pLog,
    DWORD     dwFlags,
    BOOLEAN   bForceDelete
)
{
    PDH_STATUS  pdhStatus           = ERROR_SUCCESS;
    BOOL        bStatus;
    BOOL        bNeedToCloseHandles = TRUE; 

    // call any type-specific open functions
    switch (LOWORD(pLog->dwLogFormat)) {
    case PDH_LOG_TYPE_CSV:
    case PDH_LOG_TYPE_TSV:
        pdhStatus = PdhiCloseTextLog(pLog, dwFlags);
        break;

    case PDH_LOG_TYPE_RETIRED_BIN:
        pdhStatus = PdhiCloseBinaryLog(pLog, dwFlags);
        break;

    case PDH_LOG_TYPE_PERFMON:
        pdhStatus = PdhiClosePerfmonLog(pLog, dwFlags);
        break;

    case PDH_LOG_TYPE_BINARY:
        pdhStatus = PdhiCloseWmiLog(pLog, dwFlags);
        break;

    case PDH_LOG_TYPE_SQL:
        pdhStatus = PdhiCloseSQLLog(pLog, dwFlags);
        break;

    default:
        pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
        break;
    }
    if (bForceDelete || pdhStatus == ERROR_SUCCESS) {
        if (pLog->lpMappedFileBase != NULL) {
            UnmapReadonlyMappedFile(pLog->lpMappedFileBase, & bNeedToCloseHandles);
        }
        else {
            // if this wasn't a mapped file, then delete
            // the "current record" buffer
            if (pLog->pLastRecordRead != NULL) {
                G_FREE(pLog->pLastRecordRead);
                pLog->pLastRecordRead = NULL;
            }
        }
        if (bNeedToCloseHandles) {
            if (pLog->hMappedLogFile != NULL) {
                bStatus = CloseHandle(pLog->hMappedLogFile);
                pLog->hMappedLogFile  = NULL;
            }

            if (pLog->hLogFileHandle != INVALID_HANDLE_VALUE) {
                bStatus = CloseHandle(pLog->hLogFileHandle);
                pLog->hLogFileHandle = INVALID_HANDLE_VALUE;
            }
        }
        else {
            // the handles have already been closed so just
            // clear their values
            pLog->lpMappedFileBase = NULL;
            pLog->hMappedLogFile   = NULL;
            pLog->hLogFileHandle   = INVALID_HANDLE_VALUE;
        }

        if (pLog->pPerfmonInfo != NULL) {
            G_FREE (pLog->pPerfmonInfo);
            pLog->pPerfmonInfo = NULL;
        }

        pLog->dwLastRecordRead = 0;

        if (pLog->hCatFileHandle != INVALID_HANDLE_VALUE) {
            bStatus = CloseHandle(pLog->hCatFileHandle);
            pLog->hCatFileHandle = INVALID_HANDLE_VALUE;
        }

        if ((dwFlags & PDH_FLAGS_CLOSE_QUERY) == PDH_FLAGS_CLOSE_QUERY) {
            pdhStatus = PdhCloseQuery((HQUERY)pLog->pQuery);
        }

        pdhStatus = DeleteLogEntry(pLog);
    }
    return pdhStatus;
}

//
//  Local utility functions
//
PDH_FUNCTION
PdhiGetLogCounterInfo(
    PDH_HLOG      hLog,
    PPDHI_COUNTER pCounter
)
// validates the counter is in the log file and initializes the data fields
{
    PPDHI_LOG   pLog;
    PDH_STATUS  pdhStatus;

    if (IsValidLogHandle(hLog)) {
        pLog = (PPDHI_LOG)hLog;
        switch (LOWORD(pLog->dwLogFormat)) {
        case PDH_LOG_TYPE_CSV:
        case PDH_LOG_TYPE_TSV:
            pdhStatus = PdhiGetTextLogCounterInfo(pLog, pCounter);
            break;

        case PDH_LOG_TYPE_BINARY:
        case PDH_LOG_TYPE_RETIRED_BIN:
            pdhStatus = PdhiGetBinaryLogCounterInfo(pLog, pCounter);
            break;

        case PDH_LOG_TYPE_PERFMON:
            pdhStatus = PdhiGetPerfmonLogCounterInfo(pLog, pCounter);
            break;

       case PDH_LOG_TYPE_SQL:
            pdhStatus = PdhiGetSQLLogCounterInfo(pLog, pCounter);
            break;

        default:
            pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
            break;
        }
    }
    else {
        pdhStatus = PDH_INVALID_HANDLE;
    }
    return pdhStatus;
}

PDH_FUNCTION
AddUniqueWideStringToMultiSz(
    LPVOID  mszDest,
    LPWSTR  szSource,
    DWORD   dwSizeLeft,
    LPDWORD pdwSize,
    BOOL    bUnicodeDest
)
/*++
Routine Description:
    searches the Multi-SZ list, mszDest for szSource and appends it
        to mszDest if it wasn't found

Arguments:
    OUT LPVOID  mszDest     Multi-SZ list to get new string
    IN  LPWSTR  szSource    string to add if it's not already in list

ReturnValue:
    The new length of the destination string including both
    trailing NULL characters if the string was added, or 0 if the
    string is already in the list.
--*/
{
    PDH_STATUS Status         = ERROR_SUCCESS;
    LPVOID     szDestElem;
    DWORD      dwReturnLength = 0;
    LPSTR      aszSource = NULL;
    DWORD      dwLength;

    // check arguments

    if (mszDest == NULL || szSource == NULL || pdwSize == NULL) {
        Status = PDH_INVALID_ARGUMENT; // invalid buffers
        goto AddString_Bailout;
    }
    else if (* szSource == L'\0') {
        goto AddString_Bailout; // no source string to add
    }

    // if not a unicode list, make an ansi copy of the source string to
    // compare
    // and ultimately copy if it's not already in the list

    if (! bUnicodeDest) {
        aszSource = PdhiWideCharToMultiByte(_getmbcp(), szSource);
        if (aszSource != NULL) {
            dwReturnLength = lstrlenA(aszSource);
        }
        else {
            // unable to allocate memory for the temp string
            dwReturnLength = 0;
            Status         = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    }
    else {
        // just use the ANSI version of the source file name
        dwReturnLength = 1;
    }

    if (dwReturnLength > 0) {
        // go to end of dest string
        //
        for (szDestElem = mszDest;
                (bUnicodeDest ? (* (LPWSTR) szDestElem != L'\0') : (* (LPSTR)  szDestElem != '\0'));) {
            if (bUnicodeDest) {
                // bail out if string already in list
                if (lstrcmpiW((LPCWSTR) szDestElem, szSource) == 0) {
                    dwReturnLength = 0;
                    goto AddString_Bailout;
                }
                else {
                    // goto the next item
                    szDestElem = (LPVOID) ((LPWSTR) szDestElem + (lstrlenW((LPCWSTR) szDestElem) + 1));
                }
            }
            else {
                // bail out if string already in list
                if (lstrcmpiA((LPSTR) szDestElem, aszSource) == 0) {
                    dwReturnLength = 0;
                    goto AddString_Bailout;
                }
                else {
                    // goto the next item
                    szDestElem = (LPVOID) ((LPSTR) szDestElem + (lstrlenA((LPCSTR) szDestElem) + 1));
                }
            }
        }

        // if here, then add string
        // szDestElem is at end of list

        if (bUnicodeDest) {
            if ((DWORD) (lstrlenW(szSource) + 2) <= dwSizeLeft) {
                StringCchCopyW((LPWSTR) szDestElem, dwSizeLeft, szSource);
                szDestElem = (LPVOID)((LPWSTR)szDestElem + lstrlenW((LPWSTR) szDestElem) + 1);
                * ((LPWSTR) szDestElem) = L'\0';
                dwReturnLength = (DWORD) ((LPWSTR) szDestElem - (LPWSTR) mszDest);
            }
            else {
                dwReturnLength = lstrlenW(szSource) + 2;
                Status         = PDH_MORE_DATA;
            }
        }
        else {
            if ((DWORD) (lstrlenA(aszSource) + 2) <= dwSizeLeft) {
                StringCchCopyA((LPSTR)szDestElem, dwSizeLeft, aszSource);
                szDestElem = (LPVOID)((LPSTR)szDestElem + lstrlenA((LPSTR) szDestElem) + 1);
                * ((LPSTR) szDestElem) = '\0'; // add second NULL
                dwReturnLength = (DWORD) ((LPSTR) szDestElem - (LPSTR) mszDest);
            }
            else {
                dwReturnLength = lstrlenA(aszSource) + 2;
                Status         = PDH_MORE_DATA;
            }
        }
    }

AddString_Bailout:
    G_FREE(aszSource);
    if (pdwSize != NULL) * pdwSize = dwReturnLength;
    return Status;
}

//
//   Exported Logging Functions
//
PDH_FUNCTION
PdhOpenLogW(
    IN  LPCWSTR      szLogFileName,
    IN  DWORD        dwAccessFlags,
    IN  LPDWORD      lpdwLogType,
    IN  PDH_HQUERY   hQuery,
    IN  DWORD        dwMaxSize,
    IN  LPCWSTR      szUserCaption,
    IN  PDH_HLOG   * phLog
)
{
    PDH_STATUS  pdhStatus      = ERROR_SUCCESS;
    DWORD       dwLocalLogType = 0;
    PPDHI_LOG   pLog;

    if (szLogFileName == NULL || lpdwLogType == NULL || phLog == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            dwLocalLogType = *lpdwLogType;
            * lpdwLogType  = dwLocalLogType;

            if (* szLogFileName == L'\0' || lstrlenW(szLogFileName) > PDH_MAX_DATASOURCE_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            if (szUserCaption != NULL) {
                // if not NULL, it must be valid
                if (* szUserCaption == L'\0' || lstrlenW(szUserCaption) > PDH_MAX_COUNTER_PATH) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            // something failed so give up here
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            // create a log entry
            // if successful, this also acquires the lock for this structure
            pdhStatus = CreateNewLogEntry((LPCWSTR) szLogFileName, hQuery, dwMaxSize, & pLog);
            // Here we must check for SQL: in the file name, and branch off to do SQL
            // Processing /end SJM/
            // open the file
            if (pdhStatus == ERROR_SUCCESS) {
                // find out if SQL file type
                if (lstrlenW(szLogFileName) > 4 && (szLogFileName[0] == L'S' || szLogFileName[0] == L's') &&
                                                   (szLogFileName[1] == L'Q' || szLogFileName[1] == L'q') &&
                                                   (szLogFileName[2] == L'L' || szLogFileName[2] == L'l') &&
                                                   szLogFileName[3] == L':') {
                    dwLocalLogType  = PDH_LOG_TYPE_SQL;
                    pLog->llMaxSize = (LONGLONG) ((ULONGLONG) dwMaxSize);
                    pdhStatus       = OpenSQLLog(pLog, dwAccessFlags, & dwLocalLogType);
                    if ((dwAccessFlags & PDH_LOG_WRITE_ACCESS) == PDH_LOG_WRITE_ACCESS) {
                        if (pLog->pQuery != NULL) {
                            pLog->pQuery->hOutLog = (HLOG) pLog;
                        }
                        if (pdhStatus == ERROR_SUCCESS) {   
                            pdhStatus = WriteLogHeader(pLog, (LPCWSTR)szUserCaption);
                        }
                    }
                // dispatch based on read/write attribute
                }
                else if ((dwAccessFlags & PDH_LOG_READ_ACCESS) == PDH_LOG_READ_ACCESS) {
                    pdhStatus = OpenInputLogFile(pLog, dwAccessFlags, & dwLocalLogType);
                }
                else if ((dwAccessFlags & PDH_LOG_WRITE_ACCESS) == PDH_LOG_WRITE_ACCESS) {
                    pdhStatus = OpenOutputLogFile(pLog, dwAccessFlags, & dwLocalLogType);
                    if (pdhStatus == ERROR_SUCCESS) {
                        pLog->pQuery->hOutLog = (HLOG) pLog;
                        pdhStatus = WriteLogHeader(pLog, (LPCWSTR) szUserCaption);
                    }
                }
                else if ((dwAccessFlags & PDH_LOG_UPDATE_ACCESS) == PDH_LOG_UPDATE_ACCESS) {
                    pdhStatus = OpenUpdateLogFile(pLog, dwAccessFlags, & dwLocalLogType);
                }
                else {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
                if (pdhStatus == ERROR_SUCCESS) {
                    __try {
                        // return handle to caller
                        * phLog       = (HLOG) pLog;
                        * lpdwLogType = dwLocalLogType;
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        // something failed so give up here
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                } 

                // release the lock for the next thread

                if (pdhStatus != ERROR_SUCCESS) {
                    // unable to complete this operation so toss this entry
                    // since it isn't really a valid log entry.
                    // NOTE: DeleteLogEntry will release the mutex
                    DeleteLogEntry(pLog);
                }
                else {
                    RELEASE_MUTEX (pLog->hLogMutex);
                }
            }
            RELEASE_MUTEX(hPdhDataMutex);
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhOpenLogA(
    IN  LPCSTR       szLogFileName,
    IN  DWORD        dwAccessFlags,
    IN  LPDWORD      lpdwLogType,
    IN  PDH_HQUERY   hQuery,
    IN  DWORD        dwMaxRecords,
    IN  LPCSTR       szUserCaption,
    IN  PDH_HLOG   * phLog
)
{
    LPWSTR      wszLogName     = NULL;
    LPWSTR      wszUserCaption = NULL;
    DWORD       dwLocalLogType;
    PDH_STATUS  pdhStatus      = ERROR_SUCCESS;

    if (szLogFileName == NULL || lpdwLogType == NULL || phLog == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            if (* szLogFileName == L'\0' || lstrlenA(szLogFileName) > PDH_MAX_DATASOURCE_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else {
                dwLocalLogType = *lpdwLogType;  // test read
                wszLogName     = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szLogFileName);
                if (wszLogName == NULL) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                else if (szUserCaption != NULL) {
                    // if not NULL, it must be valid
                    if (* szUserCaption == L'\0' || lstrlenA(szUserCaption) > PDH_MAX_COUNTER_PATH) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                    else {
                        wszUserCaption = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szUserCaption);
                        if (wszUserCaption == NULL) {
                            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        }
                    }
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            // assume a bad parameter caused the exception
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhOpenLogW(
                        wszLogName, dwAccessFlags, & dwLocalLogType, hQuery, dwMaxRecords, wszUserCaption, phLog);
    }
    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            // return handle to caller
            * lpdwLogType = dwLocalLogType;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            // something failed so give up here
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    G_FREE(wszLogName);
    G_FREE(wszUserCaption);
    return pdhStatus;
}

PDH_FUNCTION
PdhUpdateLogW(
    IN  PDH_HLOG hLog,
    IN  LPCWSTR  szUserString
)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    SYSTEMTIME st;
    FILETIME   ft;
    PPDHI_LOG  pLog;

    if (szUserString != NULL) {
        __try {
            if (* szUserString == L'\0' || lstrlenW(szUserString) > PDH_MAX_COUNTER_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        if (IsValidLogHandle(hLog)) {
            pLog      = (PPDHI_LOG) hLog;
            pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pLog->hLogMutex);
            if (pdhStatus == ERROR_SUCCESS) {
                // make sure it's still valid as it could have 
                //  been deleted while we were waiting
                if (IsValidLogHandle(hLog)) {
                    if (pLog->pQuery == NULL) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                    else {
                        // get the timestamp and update the log's query,
                        // then write the data to the log file in the
                        // appropriate format

                        // update data samples
                        pdhStatus = PdhiCollectQueryData((HQUERY) pLog->pQuery, (LONGLONG *) & ft);
                        if (pdhStatus == ERROR_SUCCESS) {
                            FileTimeToSystemTime(& ft, & st);
                        }
                        else {
                            GetLocalTime(& st);
                        }

                        // test for end of log file in case the caller is
                        // reading from a log file. If this value is returned,
                        // then don't update the output log file any more.
                        if (pdhStatus != PDH_NO_MORE_DATA) {
                            switch (LOWORD(pLog->dwLogFormat)) {
                            case PDH_LOG_TYPE_CSV:
                            case PDH_LOG_TYPE_TSV:
                                pdhStatus =PdhiWriteTextLogRecord(pLog, & st, (LPCWSTR) szUserString);
                                break;

                            case PDH_LOG_TYPE_RETIRED_BIN:
                            case PDH_LOG_TYPE_PERFMON:
                                pdhStatus = PDH_NOT_IMPLEMENTED;
                                break;

                            case PDH_LOG_TYPE_BINARY:
                                pdhStatus = PdhiWriteWmiLogRecord(pLog, & st, (LPCWSTR) szUserString);
                                break;
                            // add case for SQL
                            case PDH_LOG_TYPE_SQL:
                                pdhStatus =PdhiWriteSQLLogRecord(pLog, & st, (LPCWSTR) szUserString);
                                break;

                            default:
                                pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                                break;
                            }
                        }
                        else {
                            // return the NO_MORE_DATA error to the caller
                            // so they know not to call this function any more
                        }
                    }
                }
                else {
                    pdhStatus = PDH_INVALID_HANDLE;
                }
                RELEASE_MUTEX(pLog->hLogMutex);
            } // else couldn't lock the log
        }
        else {
            pdhStatus = PDH_INVALID_HANDLE;
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhUpdateLogA(
    IN  PDH_HLOG hLog,
    IN  LPCSTR   szUserString
)
{
    PDH_STATUS pdhStatus          = ERROR_SUCCESS;
    LPWSTR     wszLocalUserString = NULL;
    DWORD      dwUserStringLen;

    __try {
        if (szUserString != NULL) {
            if (* szUserString == L'\0' || lstrlenA(szUserString) > PDH_MAX_COUNTER_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else {
                wszLocalUserString = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szUserString);
                if (wszLocalUserString == NULL) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhUpdateLogW(hLog, wszLocalUserString);
    }

    G_FREE(wszLocalUserString);
    return pdhStatus;
}

PDH_FUNCTION
PdhUpdateLogFileCatalog(
    IN  PDH_HLOG hLog
)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    PPDHI_LOG  pLog;

    if (IsValidLogHandle(hLog)) {
        pLog      = (PPDHI_LOG) hLog;
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pLog->hLogMutex);
        // make sure it's still valid as it could have 
        //  been deleted while we were waiting
        if (pdhStatus == ERROR_SUCCESS) {
            if (IsValidLogHandle(hLog)) {
                pLog = (PPDHI_LOG) hLog;
                switch (LOWORD(pLog->dwLogFormat)) {
                case PDH_LOG_TYPE_CSV:
                case PDH_LOG_TYPE_TSV:
                case PDH_LOG_TYPE_BINARY:
                case PDH_LOG_TYPE_SQL:
                case PDH_LOG_TYPE_RETIRED_BIN:
                case PDH_LOG_TYPE_PERFMON:
                    pdhStatus = PDH_NOT_IMPLEMENTED;
                    break;

                default:
                    pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                    break;
                }
            }
            else {
                pdhStatus = PDH_INVALID_HANDLE;
            }
            RELEASE_MUTEX (pLog->hLogMutex);
        }
    }
    else {
        pdhStatus = PDH_INVALID_HANDLE;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhCloseLog(
    IN  PDH_HLOG hLog,
    IN  DWORD    dwFlags
)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    PPDHI_LOG  pLog;

    if (hLog != H_REALTIME_DATASOURCE && hLog != H_WBEM_DATASOURCE) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            if (IsValidLogHandle(hLog)) {
                pLog = (PPDHI_LOG) hLog;
                // make sure it's still valid as it could have 
                //  been deleted while we were waiting
                if (IsValidLogHandle(hLog)) {
                    // this will release and delete the mutex
                    pdhStatus = CloseAndDeleteLogEntry(pLog, dwFlags, FALSE);
                }
                else {
                    pdhStatus = PDH_INVALID_HANDLE;
                }
            }
            else {
                pdhStatus = PDH_INVALID_HANDLE;
            }
            RELEASE_MUTEX(hPdhDataMutex);
        }
    }
    return pdhStatus;
}

BOOL
PdhiBrowseDataSource(
    HWND    hWndParent,
    LPVOID  szFileName,
    LPDWORD pcchFileNameSize,
    BOOL    bUnicodeString
)
{
    OPENFILENAMEW ofn;
    LPWSTR        szTempString      = NULL;
    LPWSTR        szDirString       = NULL;
    LPWSTR        szTempFileName    = NULL;
    BOOL          bReturn;
    DWORD         dwSize;
    LPWSTR        szMsg             = NULL;
    LPWSTR        szLogFilterString = NULL;
    LPWSTR        szLogFilter;

    if (szFileName == NULL) {
        SetLastError(PDH_INVALID_ARGUMENT);
        bReturn = FALSE;
    }
    else {
        // clear last error
        SetLastError (ERROR_SUCCESS);

        dwSize = * pcchFileNameSize * 2;
        if (dwSize < (DWORD) (lstrlenW(szFileName) + 1)) dwSize = (DWORD) (lstrlenW(szFileName) + 1);
        if (dwSize < SMALL_BUFFER_SIZE) dwSize = SMALL_BUFFER_SIZE;
        szLogFilterString = G_ALLOC(3 * dwSize * sizeof(WCHAR));
        if (szLogFilterString == NULL) {
            SetLastError(PDH_MEMORY_ALLOCATION_FAILURE);
            bReturn = FALSE;
        }
        else {
            szTempString = szLogFilterString + dwSize;
            szDirString  = szTempString + dwSize;
            // continue
            // get the current filename
            if (bUnicodeString) {
                StringCchCopyW(szTempString, dwSize, (LPWSTR) szFileName);
            }
            else {
                MultiByteToWideChar(_getmbcp(), 0, (LPSTR) szFileName, -1, (LPWSTR) szTempString, dwSize);
            }

            // set the path up for the initial  dir display
            if (szTempString[0] != L'\0') {
                if (SearchPathW(NULL, szTempString, NULL, dwSize, szDirString, & szTempFileName) > 0) {
                    // then update the buffers to show file and dir path
                    if (szTempFileName > szDirString) {
                        // then we have a path with a file name so
                        // truncate the path at the last backslash and
                        // then copy the filename to the original buffer
                        * (szTempFileName - 1) = L'\0'; // should be L'\\' originally.
                        StringCchCopyW(szTempString, dwSize, szTempFileName);
                    }
                }
            }

            // get the log filter string
            if (MakeLogFilterInfoString(szLogFilterString, dwSize) == ERROR_SUCCESS) {
                szLogFilter = szLogFilterString;
            }
            else {
                // then use default filter string
                szLogFilter = NULL;
            }

            // display file open dialog to browse for log files.

            szMsg                 = GetStringResource(IDS_DSRC_SELECT);
            ofn.lStructSize       = sizeof(ofn);
            ofn.hwndOwner         = hWndParent;
            ofn.hInstance         = ThisDLLHandle;
            ofn.lpstrFilter       = szLogFilter;
            ofn.lpstrCustomFilter =  NULL;
            ofn.nMaxCustFilter    = 0;
            ofn.nFilterIndex      = 1;
            ofn.lpstrFile         = szTempString;
            ofn.nMaxFile          = SMALL_BUFFER_SIZE - 1;
            ofn.lpstrFileTitle    = NULL;
            ofn.nMaxFileTitle     = 0;
            ofn.lpstrInitialDir   = szDirString;
            ofn.lpstrTitle        = szMsg;
            ofn.Flags             = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
            ofn.nFileOffset       = 0;
            ofn.nFileExtension    = 0;
            ofn.lpstrDefExt       = cszBlg;
            ofn.lCustData         = 0;
            ofn.lpfnHook          = NULL;
            ofn.lpTemplateName    = NULL;

            if (GetOpenFileNameW(& ofn)) {
                // then update the return string
                if (bUnicodeString) {
                    StringCchCopyW((LPWSTR) szFileName, *pcchFileNameSize, szTempString);
                    * pcchFileNameSize = lstrlenW(szTempString) + 1;
                }
                else {
                    PdhiConvertUnicodeToAnsi(_getmbcp(), szTempString, (LPSTR) szFileName, pcchFileNameSize);
                }
                bReturn = TRUE;
            }
            else {
                bReturn = FALSE;
            }
            G_FREE(szMsg);
            G_FREE(szLogFilterString);
        }
    }
    return bReturn;
}

PDH_FUNCTION
PdhGetDataSourceTimeRangeH(
    IN  PDH_HLOG        hDataSource,
    IN  LPDWORD         pdwNumEntries,
    IN  PPDH_TIME_INFO  pInfo,
    IN  LPDWORD         pdwBufferSize
)
{
    PDH_STATUS    pdhStatus         = ERROR_SUCCESS;
    DWORD         dwLocalBufferSize = 0;
    DWORD         dwLocalNumEntries = 0;
    PDH_TIME_INFO LocalInfo;
    PPDHI_LOG     pLog;

    if (hDataSource == H_REALTIME_DATASOURCE || hDataSource == H_WBEM_DATASOURCE) {
        pdhStatus = PDH_DATA_SOURCE_IS_REAL_TIME;
    }
    else if (pdwNumEntries == NULL || pInfo == NULL || pdwBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        // test caller's buffers before trying to use them
        __try {
            dwLocalNumEntries   = * pdwNumEntries;
            dwLocalBufferSize   = * pdwBufferSize;
            LocalInfo.StartTime = pInfo->StartTime;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        if (IsValidLogHandle(hDataSource)) {
            pLog = (PPDHI_LOG) hDataSource;
            pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pLog->hLogMutex);
            if (pdhStatus == ERROR_SUCCESS) {
                if (IsValidLogHandle(hDataSource)) {
                    // enum machines based on log type
                    //
                    ZeroMemory(& LocalInfo, sizeof(PDH_TIME_INFO));
                    switch (LOWORD(pLog->dwLogFormat)) {
                    case PDH_LOG_TYPE_CSV:
                    case PDH_LOG_TYPE_TSV:
                        pdhStatus = PdhiGetTimeRangeFromTextLog(
                                        pLog, & dwLocalNumEntries, & LocalInfo, & dwLocalBufferSize);
                        break;

                    case PDH_LOG_TYPE_BINARY:
                        pdhStatus = PdhiGetTimeRangeFromWmiLog(
                                        pLog, & dwLocalNumEntries, & LocalInfo, & dwLocalBufferSize);
                        break;

                    case PDH_LOG_TYPE_RETIRED_BIN:
                        pdhStatus = PdhiGetTimeRangeFromBinaryLog(
                                        pLog, & dwLocalNumEntries, & LocalInfo, & dwLocalBufferSize);
                        break;

                    case PDH_LOG_TYPE_SQL:
                        pdhStatus = PdhiGetTimeRangeFromSQLLog(
                                        pLog, & dwLocalNumEntries, & LocalInfo, & dwLocalBufferSize);
                        break;
                                        
                    case PDH_LOG_TYPE_PERFMON:
                        pdhStatus = PdhiGetTimeRangeFromPerfmonLog(
                                        pLog, & dwLocalNumEntries, & LocalInfo, & dwLocalBufferSize);
                        break;

                    default:
                        pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                        break;
                    }
                    __try {
                        * pdwBufferSize    = dwLocalBufferSize;
                        * pdwNumEntries    = dwLocalNumEntries;
                        pInfo->StartTime   = LocalInfo.StartTime;
                        pInfo->EndTime     = LocalInfo.EndTime;
                        pInfo->SampleCount = LocalInfo.SampleCount;
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        pdhStatus = PDH_INVALID_ARGUMENT;   
                    }
                }
                else {
                    pdhStatus = PDH_INVALID_HANDLE;
                }
                RELEASE_MUTEX (pLog->hLogMutex);
            }
        }
        else {
            pdhStatus = PDH_INVALID_HANDLE;
        }
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhGetDataSourceTimeRangeW(
    IN  LPCWSTR         szDataSource,
    IN  LPDWORD         pdwNumEntries,
    IN  PPDH_TIME_INFO  pInfo,
    IN  LPDWORD         pdwBufferSize
)
{
    PDH_STATUS PdhStatus   = PDH_DATA_SOURCE_IS_REAL_TIME; 
    PDH_HLOG   hDataSource = NULL;
    DWORD      dwLogType   = -1;

    if (szDataSource != NULL) {
        // open log file
        //
        PdhStatus = PdhOpenLogW(szDataSource,
                                PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                                & dwLogType,
                                NULL,
                                0,
                                NULL,
                                & hDataSource);
        if (PdhStatus == ERROR_SUCCESS) {
            PdhStatus = PdhGetDataSourceTimeRangeH(hDataSource, pdwNumEntries, pInfo, pdwBufferSize);
            PdhCloseLog(hDataSource, 0);
        }
    }

    return PdhStatus;
}

PDH_FUNCTION
PdhGetDataSourceTimeRangeA(
    IN  LPCSTR          szDataSource,
    IN  LPDWORD         pdwNumEntries,
    IN  PPDH_TIME_INFO  pInfo,
    IN  LPDWORD         pdwBufferSize
)
{
    LPWSTR      wszDataSource     = NULL;
    PDH_STATUS  pdhStatus         = ERROR_SUCCESS;
    DWORD       dwLocalBufferSize = 0;
    DWORD       dwLocalNumEntries = 0;

    if (szDataSource == NULL) {
        // null data source == the current activity so return
        pdhStatus = PDH_DATA_SOURCE_IS_REAL_TIME;
    }
    else if (pdwNumEntries == NULL ||  pInfo == NULL ||  pdwBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            dwLocalBufferSize = * pdwBufferSize;
            dwLocalNumEntries = * pdwNumEntries;

            if (* szDataSource == '\0' || lstrlenA(szDataSource) > PDH_MAX_DATASOURCE_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else {
                wszDataSource = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szDataSource);
                if (wszDataSource == NULL) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            // assume a bad parameter caused the exception
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhGetDataSourceTimeRangeW(wszDataSource, & dwLocalNumEntries, pInfo, & dwLocalBufferSize);
    }
    if (pdhStatus == ERROR_SUCCESS) {
        // copy returned values regardless of status
        __try {
            * pdwBufferSize = dwLocalBufferSize;
            * pdwNumEntries = dwLocalNumEntries;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;   
        }
    }

    G_FREE(wszDataSource);

    return pdhStatus;
}


PDH_FUNCTION
PdhGetLogFileSize(
    IN  PDH_HLOG   hLog,
    IN  LONGLONG * llSize
)
{
    PDH_STATUS pdhStatus      = ERROR_SUCCESS;
    PPDHI_LOG  pLog;
    UINT       nErrorMode;
    DWORD      dwFileSizeLow  = 0;
    DWORD      dwFileSizeHigh = 0;
    LONGLONG   llFileLength;
    DWORD      dwError;

    if (llSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else if (IsValidLogHandle (hLog)) {
        pLog = (PPDHI_LOG) hLog;
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pLog->hLogMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            if (IsValidLogHandle(hLog)) {
                if (LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_SQL) {
                    __try {
                       * llSize = pLog->dwNextRecordIdToWrite - 1;
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                       pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
                else if (LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_BINARY) {
                    pdhStatus = PdhiGetWmiLogFileSize(pLog, llSize);
                }
                else {
                    // disable windows error message popup
                    nErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);
                    if (pLog->hLogFileHandle != INVALID_HANDLE_VALUE) {
                        dwFileSizeLow = GetFileSize(pLog->hLogFileHandle, &dwFileSizeHigh);
                        // test for error
                        if ((dwFileSizeLow == 0xFFFFFFFF) && ((dwError = GetLastError()) != NO_ERROR)) {
                            // then we couldn't get the file size
                            pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
                        }
                        else {
                            if (dwFileSizeHigh > 0) {
                                llFileLength = ((LONGLONG) dwFileSizeHigh) << (sizeof(DWORD) * 8);
                            }
                            else {
                                llFileLength = 0;
                            }
                            llFileLength += dwFileSizeLow;
                            // write to the caller' buffer
                            __try {
                                * llSize = llFileLength;
                            }
                            __except (EXCEPTION_EXECUTE_HANDLER) {
                                pdhStatus = PDH_INVALID_ARGUMENT;
                            }
                        }
                    }
                    else {
                        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
                    }
                    SetErrorMode(nErrorMode);  // restore old error mode
                }
            }
            else {
                pdhStatus = PDH_INVALID_HANDLE;
            }
            RELEASE_MUTEX (pLog->hLogMutex);
        }
    }
    else {
        pdhStatus = PDH_INVALID_HANDLE;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhReadRawLogRecord(
    IN  PDH_HLOG            hLog,
    IN  FILETIME            ftRecord,
    IN  PPDH_RAW_LOG_RECORD pBuffer,
    IN  LPDWORD             pdwBufferLength
)
{
    PPDHI_LOG   pLog;
    PDH_STATUS  pdhStatus           = ERROR_SUCCESS;
    DWORD       dwLocalBufferLength = 0;

    if (pdwBufferLength == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            CHAR    TestChar;
            // test read & write access to the user's buffer.
            dwLocalBufferLength = * pdwBufferLength;

            if (dwLocalBufferLength > 0) {
                // test beginnging and end of the buffer passed in
                TestChar = ((CHAR *) pBuffer)[0];
                ((CHAR *) pBuffer)[0] = '\0';
                ((CHAR *) pBuffer)[0] = TestChar;

                TestChar = ((CHAR *) pBuffer)[dwLocalBufferLength - 1];
                ((CHAR *) pBuffer)[dwLocalBufferLength - 1] = '\0';
                ((CHAR *) pBuffer)[dwLocalBufferLength - 1] = TestChar;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (! IsValidLogHandle(hLog)) {
            pdhStatus = PDH_INVALID_HANDLE;
        }
        else {
            pLog = (PPDHI_LOG)hLog;
            // see if the log is open, first?
            pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pLog->hLogMutex);
            if (pdhStatus == ERROR_SUCCESS) {
                // make sure it's still valid
                if (IsValidLogHandle(hLog)) {
                switch (LOWORD(pLog->dwLogFormat)) {
                    case PDH_LOG_TYPE_CSV:
                    case PDH_LOG_TYPE_TSV:
                        pdhStatus = PdhiReadRawTextLogRecord(hLog, & ftRecord, pBuffer, & dwLocalBufferLength);
                        break;

                    case PDH_LOG_TYPE_BINARY:
                    case PDH_LOG_TYPE_RETIRED_BIN:
                        pdhStatus = PdhiReadRawBinaryLogRecord(hLog, & ftRecord, pBuffer, & dwLocalBufferLength);
                        break;

                    case PDH_LOG_TYPE_SQL:
                        //note this is only supported with a null buffer
                        // as we don't actually read the record, and
                        // positioning the file at the record doesn't
                        // mean anything for SQL
                        pdhStatus = PdhiReadRawSQLLogRecord(hLog, & ftRecord, pBuffer, & dwLocalBufferLength);
                        break;

                    case PDH_LOG_TYPE_PERFMON:
                        pdhStatus = PdhiReadRawPerfmonLogRecord(hLog, & ftRecord, pBuffer, & dwLocalBufferLength);
                        break;

                    default:
                        pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                        break;
                    }
                }
                __try {
                    * pdwBufferLength = dwLocalBufferLength;
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
            else {
                pdhStatus = PDH_INVALID_HANDLE;
            }
            RELEASE_MUTEX (pLog->hLogMutex);
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumLoggedMachines(
    PDH_HLOG hDataSource,
    LPVOID   mszMachineList,
    LPDWORD  pcchBufferSize,
    BOOL     bUnicode
)
{
    PDH_STATUS  pdhStatus = PDH_INVALID_HANDLE;
    PPDHI_LOG   pDataSource;
    DWORD       dwLogType;

    // enum machines based on log type
    //
    if (IsValidLogHandle(hDataSource)) {
        pDataSource = (PPDHI_LOG) hDataSource;
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pDataSource->hLogMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            if (IsValidLogHandle(hDataSource)) {
                dwLogType = pDataSource->dwLogFormat;
                switch (LOWORD(dwLogType)) {
                case PDH_LOG_TYPE_CSV:
                case PDH_LOG_TYPE_TSV:
                    pdhStatus = PdhiEnumMachinesFromTextLog(
                                    (PPDHI_LOG) hDataSource, mszMachineList, pcchBufferSize, bUnicode);
                    break;

                case PDH_LOG_TYPE_BINARY:
                    pdhStatus = PdhiEnumMachinesFromWmiLog(
                                    (PPDHI_LOG) hDataSource, mszMachineList, pcchBufferSize, bUnicode);
                    break;

                case PDH_LOG_TYPE_RETIRED_BIN:
                    pdhStatus = PdhiEnumMachinesFromBinaryLog(
                                    (PPDHI_LOG) hDataSource, mszMachineList, pcchBufferSize, bUnicode);
                    break;

                case PDH_LOG_TYPE_SQL:
                    pdhStatus = PdhiEnumMachinesFromSQLLog(
                                    (PPDHI_LOG) hDataSource, mszMachineList, pcchBufferSize, bUnicode);
                    break;

                case PDH_LOG_TYPE_PERFMON:
                    pdhStatus = PdhiEnumMachinesFromPerfmonLog(
                                    (PPDHI_LOG) hDataSource, mszMachineList, pcchBufferSize, bUnicode);
                    break;

                default:
                    pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                    break;
                }
            }
            else {
               pdhStatus = PDH_INVALID_HANDLE;
            }
            RELEASE_MUTEX (pDataSource->hLogMutex);
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumLoggedObjects(
    PDH_HLOG hDataSource,
    LPCWSTR  szMachineName,
    LPVOID   mszObjectList,
    LPDWORD  pcchBufferSize,
    DWORD    dwDetailLevel,
    BOOL     bRefresh,
    BOOL     bUnicode
)
{
    PDH_STATUS  pdhStatus = PDH_INVALID_HANDLE;
    PPDHI_LOG   pDataSource;
    DWORD       dwLogType;

    UNREFERENCED_PARAMETER(bRefresh);
    if (IsValidLogHandle(hDataSource)) {
        pDataSource = (PPDHI_LOG) hDataSource;
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pDataSource->hLogMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            if (IsValidLogHandle(hDataSource)) {
                dwLogType = pDataSource->dwLogFormat;
                // enum objects based on log type & machine name
                switch (LOWORD(dwLogType)) {
                case PDH_LOG_TYPE_CSV:
                case PDH_LOG_TYPE_TSV:
                    pdhStatus = PdhiEnumObjectsFromTextLog((PPDHI_LOG) hDataSource,
                                    szMachineName, mszObjectList, pcchBufferSize, dwDetailLevel, bUnicode);
                    break;

                case PDH_LOG_TYPE_BINARY:
                    pdhStatus = PdhiEnumObjectsFromWmiLog((PPDHI_LOG) hDataSource,
                                    szMachineName, mszObjectList, pcchBufferSize, dwDetailLevel, bUnicode);
                    break;

                case PDH_LOG_TYPE_RETIRED_BIN:
                    pdhStatus = PdhiEnumObjectsFromBinaryLog((PPDHI_LOG) hDataSource,
                                    szMachineName, mszObjectList, pcchBufferSize, dwDetailLevel, bUnicode);
                    break;

                case PDH_LOG_TYPE_SQL:
                    pdhStatus = PdhiEnumObjectsFromSQLLog((PPDHI_LOG) hDataSource,
                                    szMachineName, mszObjectList, pcchBufferSize, dwDetailLevel, bUnicode);
                    break;

                case PDH_LOG_TYPE_PERFMON:
                    pdhStatus = PdhiEnumObjectsFromPerfmonLog((PPDHI_LOG) hDataSource,
                                    szMachineName, mszObjectList, pcchBufferSize, dwDetailLevel, bUnicode);
                    break;

                default:
                    pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                    break;
                }
            }
            else {
                pdhStatus = PDH_INVALID_HANDLE;
            }
            RELEASE_MUTEX(pDataSource->hLogMutex);
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumLoggedObjectItems(
    PDH_HLOG hDataSource,
    LPCWSTR  szMachineName,
    LPCWSTR  szObjectName,
    LPVOID   mszCounterList,
    LPDWORD  pdwCounterListLength,
    LPVOID   mszInstanceList,
    LPDWORD  pdwInstanceListLength,
    DWORD    dwDetailLevel,
    DWORD    dwFlags,
    BOOL     bUnicode
)
{
    PDH_STATUS         pdhStatus         = PDH_INVALID_HANDLE;
    PPDHI_LOG          pDataSource;
    DWORD              dwLogType;
    PDHI_COUNTER_TABLE CounterTable;
    DWORD              dwIndex;
    LIST_ENTRY         InstanceList;
    PLIST_ENTRY        pHeadInst;
    PLIST_ENTRY        pNextInst;
    PPDHI_INSTANCE     pInstance;
    PPDHI_INST_LIST    pInstList;
    LPVOID             TempBuffer        = NULL;
    DWORD              dwNewBuffer       = 0;
    LPVOID             LocalCounter      = NULL;
    DWORD              LocalCounterSize  = 0;
    LPVOID             LocalInstance     = NULL;
    DWORD              LocalInstanceSize = 0;
    DWORD              dwCntrBufferUsed  = 0;
    DWORD              dwInstBufferUsed  = 0;

    PdhiInitCounterHashTable(CounterTable);
    InitializeListHead(& InstanceList);
    LocalCounter  = G_ALLOC(MEDIUM_BUFFER_SIZE);
    LocalInstance = G_ALLOC(MEDIUM_BUFFER_SIZE);
    if (LocalCounter == NULL || LocalInstance == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }
    LocalCounterSize = LocalInstanceSize = MEDIUM_BUFFER_SIZE;
    if (mszCounterList != NULL) {
        ZeroMemory(mszCounterList, (* pdwCounterListLength) * (bUnicode ? sizeof(WCHAR) : sizeof(CHAR)));
    }
    if (mszInstanceList != NULL) {
        ZeroMemory(mszInstanceList, (* pdwInstanceListLength) * (bUnicode ? sizeof(WCHAR) : sizeof(CHAR)));
    }

    if (IsValidLogHandle(hDataSource)) {
        pDataSource = (PPDHI_LOG) hDataSource;
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pDataSource->hLogMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            if (IsValidLogHandle(hDataSource)) {
                dwLogType = pDataSource->dwLogFormat;

                // enum objects based on log type & machine name
                switch (LOWORD(dwLogType)) {
                case PDH_LOG_TYPE_CSV:
                case PDH_LOG_TYPE_TSV:
                    pdhStatus = PdhiEnumObjectItemsFromTextLog((PPDHI_LOG) hDataSource,
                                    szMachineName, szObjectName, CounterTable, dwDetailLevel, dwFlags);
                    break;

                case PDH_LOG_TYPE_BINARY:
                    pdhStatus = PdhiEnumObjectItemsFromWmiLog((PPDHI_LOG) hDataSource,
                                    szMachineName, szObjectName, CounterTable, dwDetailLevel, dwFlags);
                    break;

                case PDH_LOG_TYPE_RETIRED_BIN:
                    pdhStatus = PdhiEnumObjectItemsFromBinaryLog((PPDHI_LOG) hDataSource,
                                    szMachineName, szObjectName, CounterTable, dwDetailLevel, dwFlags);
                    break;

                case PDH_LOG_TYPE_SQL:
                    pdhStatus = PdhiEnumObjectItemsFromSQLLog((PPDHI_LOG) hDataSource,
                                    szMachineName, szObjectName, CounterTable, dwDetailLevel, dwFlags);
                    break;

                case PDH_LOG_TYPE_PERFMON:
                    pdhStatus = PdhiEnumObjectItemsFromPerfmonLog((PPDHI_LOG) hDataSource,
                                    szMachineName, szObjectName, CounterTable, dwDetailLevel, dwFlags);
                    break;

                default:
                    pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                    break;
                }
            }
            else {
                pdhStatus = PDH_INVALID_HANDLE;
            }
            RELEASE_MUTEX (pDataSource->hLogMutex);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        dwCntrBufferUsed = 0;
        for (dwIndex = 0; dwIndex < HASH_TABLE_SIZE; dwIndex ++) {
            PPDHI_INSTANCE pNewInst;
            pInstList = CounterTable[dwIndex];
            while (pInstList != NULL) {
                if (! IsListEmpty(& pInstList->InstList)) {
                    pHeadInst = & pInstList->InstList;
                    pNextInst = pHeadInst->Flink;
                    while (pNextInst != pHeadInst) {
                        pInstance = CONTAINING_RECORD(pNextInst, PDHI_INSTANCE, Entry);
                        pdhStatus = PdhiFindInstance(& InstanceList, pInstance->szInstance, FALSE, & pNewInst);
                        if (pNewInst->dwTotal < pInstance->dwTotal) {
                            pNewInst->dwTotal = pInstance->dwTotal;
                        }
                        pNextInst = pNextInst->Flink;
                    }
                }

                dwNewBuffer = (lstrlenW(pInstList->szCounter) + 1) * sizeof(WCHAR);
                while (LocalCounterSize < (dwCntrBufferUsed + dwNewBuffer)) {
                    TempBuffer = LocalCounter;
                    LocalCounter = G_REALLOC(TempBuffer, LocalCounterSize + MEDIUM_BUFFER_SIZE);
                    if (LocalCounter == NULL) {
                        G_FREE(TempBuffer);
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        goto Cleanup;
                    }
                    LocalCounterSize += MEDIUM_BUFFER_SIZE;
                }

                dwNewBuffer = AddStringToMultiSz((LPVOID) LocalCounter, pInstList->szCounter, bUnicode);
                if (dwNewBuffer > 0) {
                    dwCntrBufferUsed = dwNewBuffer * (bUnicode ? sizeof(WCHAR) : sizeof(CHAR));
                }
                pInstList = pInstList->pNext;
            }
        }

        dwInstBufferUsed = 0;
        if (! IsListEmpty(& InstanceList)) {
            pHeadInst = & InstanceList;
            pNextInst = pHeadInst->Flink;
            while (pNextInst != pHeadInst) {
                pInstance   = CONTAINING_RECORD(pNextInst, PDHI_INSTANCE, Entry);
                dwNewBuffer = (lstrlenW(pInstance->szInstance) + 1) * sizeof(WCHAR) * pInstance->dwTotal;
                while (LocalInstanceSize < (dwInstBufferUsed + dwNewBuffer)) {
                    TempBuffer    = LocalInstance;
                    LocalInstance = G_REALLOC(TempBuffer, LocalInstanceSize + MEDIUM_BUFFER_SIZE);
                    if (LocalInstance == NULL) {
                        G_FREE(TempBuffer);
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        goto Cleanup;
                    }
                    LocalInstanceSize += MEDIUM_BUFFER_SIZE;
                }

                for (dwIndex = 0; dwIndex < pInstance->dwTotal; dwIndex ++) {
                        dwNewBuffer = AddStringToMultiSz((LPVOID) LocalInstance, pInstance->szInstance, bUnicode);
                }
                if (dwNewBuffer > 0) {
                    dwInstBufferUsed = dwNewBuffer * (bUnicode ? sizeof(WCHAR) : sizeof(CHAR));
                }
                pNextInst = pNextInst->Flink;
            }
        }

        if (mszCounterList != NULL && dwCntrBufferUsed <= * pdwCounterListLength) {
            RtlCopyMemory(mszCounterList, LocalCounter, dwCntrBufferUsed);
        }
        else {
            if (mszCounterList != NULL)
                RtlCopyMemory(mszCounterList, LocalCounter, * pdwCounterListLength);
            dwCntrBufferUsed += (bUnicode) ? sizeof(WCHAR) : sizeof(CHAR);
            pdhStatus = PDH_MORE_DATA;
        }
        * pdwCounterListLength = dwCntrBufferUsed;

        if (dwInstBufferUsed > 0) {
            if (mszInstanceList != NULL && dwInstBufferUsed <= * pdwInstanceListLength) {
                RtlCopyMemory(mszInstanceList, LocalInstance, dwInstBufferUsed);
            }
            else {
                if (mszInstanceList != NULL)
                    RtlCopyMemory(mszInstanceList, LocalInstance, * pdwInstanceListLength);
                dwInstBufferUsed += (bUnicode) ? sizeof(WCHAR) : sizeof(CHAR);
                pdhStatus = PDH_MORE_DATA;
            }
        }
        * pdwInstanceListLength = dwInstBufferUsed;
    }

Cleanup:
    if (! IsListEmpty(& InstanceList)) {
        pHeadInst = & InstanceList;
        pNextInst = pHeadInst->Flink;
        while (pNextInst != pHeadInst) {
            pInstance = CONTAINING_RECORD(pNextInst, PDHI_INSTANCE, Entry);
            pNextInst = pNextInst->Flink;
            RemoveEntryList(& pInstance->Entry);
            G_FREE(pInstance);
        }
    }
    for (dwIndex = 0; dwIndex < HASH_TABLE_SIZE; dwIndex ++) {
        PPDHI_INST_LIST pCurrent;
        pInstList = CounterTable[dwIndex];
        while (pInstList != NULL) {
            if (! IsListEmpty(& pInstList->InstList)) {
                pHeadInst = & pInstList->InstList;
                pNextInst = pHeadInst->Flink;
                while (pNextInst != pHeadInst) {
                    pInstance = CONTAINING_RECORD(pNextInst, PDHI_INSTANCE, Entry);
                    pNextInst = pNextInst->Flink;
                    RemoveEntryList(& pInstance->Entry);
                    G_FREE(pInstance);
                }
            }
            pCurrent  = pInstList;
            pInstList = pInstList->pNext;
            G_FREE(pCurrent);
        }
    }
    G_FREE(LocalCounter);
    G_FREE(LocalInstance);

    return pdhStatus;
}

BOOL
PdhiDataSourceHasDetailLevelsH(
    PDH_HLOG hDataSource
)
{
    return (hDataSource == H_REALTIME_DATASOURCE);
}

PDH_FUNCTION
PdhiGetMatchingLogRecord(
    PDH_HLOG   hLog,
    LONGLONG * pStartTime,
    LPDWORD    pdwIndex
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    PPDHI_LOG   pLog;
    DWORD       dwTempIndex;

    __try {
        dwTempIndex = *pdwIndex;
        * pdwIndex  = 0;
        * pdwIndex  = dwTempIndex;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (pdhStatus == ERROR_SUCCESS) {
        if (IsValidLogHandle(hLog)) {
            pLog = (PPDHI_LOG) hLog;
            pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pLog->hLogMutex);
            if (pdhStatus == ERROR_SUCCESS) {
                if (IsValidLogHandle(hLog)) {
                    // call any type-specific open functions
                    switch (LOWORD(pLog->dwLogFormat)) {
                    case PDH_LOG_TYPE_CSV:
                    case PDH_LOG_TYPE_TSV:
                        pdhStatus = PdhiGetMatchingTextLogRecord(pLog, pStartTime, pdwIndex);
                        break;

                    case PDH_LOG_TYPE_RETIRED_BIN:
                        pdhStatus = PdhiGetMatchingBinaryLogRecord(pLog, pStartTime, pdwIndex);
                        break;

                    case PDH_LOG_TYPE_SQL:
                        pdhStatus = PdhiGetMatchingSQLLogRecord(pLog, pStartTime, pdwIndex);
                        break;

                    case PDH_LOG_TYPE_PERFMON:
                        pdhStatus = PdhiGetMatchingPerfmonLogRecord(pLog, pStartTime, pdwIndex);
                        break;

                    case PDH_LOG_TYPE_BINARY:
                    default:
                        pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                        break;
                    }
                }
                else {
                    pdhStatus = PDH_INVALID_HANDLE;
                }
                RELEASE_MUTEX (pLog->hLogMutex);
            }
        }
        else {
            pdhStatus = PDH_INVALID_HANDLE;
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetCounterValueFromLogFile(
    PDH_HLOG      hLog,
    DWORD         dwIndex,
    PPDHI_COUNTER pCounter
)
{
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    PPDHI_LOG       pLog = NULL;
    PDH_RAW_COUNTER pValue;

    ZeroMemory(& pValue, sizeof(PDH_RAW_COUNTER));
    pCounter->LastValue = pCounter->ThisValue;
    if (pdhStatus == ERROR_SUCCESS) {
        if (IsValidLogHandle (hLog)) {
            pLog = (PPDHI_LOG) hLog;
            pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pLog->hLogMutex);
            if (pdhStatus == ERROR_SUCCESS) {
                if (IsValidLogHandle (hLog)) {
                    // call any type-specific open functions
                    switch (LOWORD(pLog->dwLogFormat)) {
                    case PDH_LOG_TYPE_CSV:
                    case PDH_LOG_TYPE_TSV:
                        pdhStatus = PdhiGetCounterValueFromTextLog(pLog, dwIndex, & pCounter->plCounterInfo, & pValue);
                        break;

                    case PDH_LOG_TYPE_RETIRED_BIN:
                        pdhStatus = PdhiGetCounterValueFromBinaryLog(pLog, dwIndex, pCounter);
                        break;

                    case PDH_LOG_TYPE_SQL:
                        pdhStatus = PdhiGetCounterValueFromSQLLog(pLog, dwIndex, pCounter, & pValue);
                        break;

                    case PDH_LOG_TYPE_PERFMON:
                        pdhStatus = PdhiGetCounterValueFromPerfmonLog(pLog, dwIndex, pCounter, & pValue);
                        break;

                    case PDH_LOG_TYPE_BINARY:
                    default:
                        pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                        break;
                    }
                }
                else {
                    pdhStatus = PDH_INVALID_HANDLE;
                }
                RELEASE_MUTEX (pLog->hLogMutex);
            }
        }
        else {
            pdhStatus = PDH_INVALID_HANDLE;
        }
    }
    if (pdhStatus == ERROR_SUCCESS && LOWORD(pLog->dwLogFormat) != PDH_LOG_TYPE_RETIRED_BIN
                                   && LOWORD(pLog->dwLogFormat) != PDH_LOG_TYPE_BINARY) {
        if (pdhStatus != ERROR_SUCCESS) {
            // See if this is because there's no more entries.
            // If not, clear the counter value & return error
            //
            if (pdhStatus != PDH_NO_MORE_DATA) {
                ZeroMemory(& pCounter->ThisValue, sizeof(PDH_RAW_COUNTER));
                pCounter->ThisValue.CStatus = pdhStatus;
            }
        }
        else {
            pCounter->ThisValue = pValue;
        }
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiResetLogBuffers(
    PDH_HLOG hLog
)
{
    PDH_STATUS pdhStatus;
    PPDHI_LOG  pLog;

    if (IsValidLogHandle(hLog)) {
        pLog      = (PPDHI_LOG) hLog;
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pLog->hLogMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            if (IsValidLogHandle(hLog)) {
                if (LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_BINARY) {
                    pdhStatus = PdhiRewindWmiLog(pLog);
                }
                else {
                    pLog->dwLastRecordRead = 0;

                    if (pLog->lpMappedFileBase != NULL) {
                        // for mapped files we use a pointer into the buffer
                        // so reset it
                        pLog->pLastRecordRead = pLog->lpMappedFileBase;
                    }
                    else {
                        // for other files we have a separate buffer
                        if (pLog->pLastRecordRead != NULL) {
                            G_FREE(pLog->pLastRecordRead);
                            pLog->pLastRecordRead = NULL;
                        }
                    }
                    pdhStatus = ERROR_SUCCESS;
                }
            }
            else {
                pdhStatus = PDH_INVALID_HANDLE;
            }
            RELEASE_MUTEX (pLog->hLogMutex);
        }
    }
    else {
        pdhStatus = PDH_INVALID_HANDLE;
    }
    return pdhStatus;
}


PDH_FUNCTION
PdhListLogFileHeaderW(
    IN  LPCWSTR szFileName,
    IN  LPWSTR  mszHeaderList,
    IN  LPDWORD pcchHeaderListSize
)
{
    HLOG        hDataSource = NULL;
    PDH_STATUS  pdhStatus;
    DWORD       dwLogType   = -1;
    PPDHI_LOG   pDataSource;

    if (szFileName == NULL || pcchHeaderListSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        // open log file
        pdhStatus = PdhOpenLogW(szFileName,
                                PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                                & dwLogType,
                                NULL,
                                0,
                                NULL,
                                & hDataSource);
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pDataSource = (PPDHI_LOG) hDataSource;
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pDataSource->hLogMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            if (IsValidLogHandle(hDataSource)) {
                __try {
                    // enum objects based on log type & machine name
                    switch (LOWORD(dwLogType)) {
                    case PDH_LOG_TYPE_CSV:
                    case PDH_LOG_TYPE_TSV:
                        pdhStatus = PdhiListHeaderFromTextLog((PPDHI_LOG) hDataSource,
                                                              (LPVOID) mszHeaderList,
                                                              pcchHeaderListSize,
                                                              TRUE);
                        break;

                    case PDH_LOG_TYPE_BINARY:
                    case PDH_LOG_TYPE_RETIRED_BIN:
                        pdhStatus = PdhiListHeaderFromBinaryLog((PPDHI_LOG) hDataSource,
                                                                (LPVOID) mszHeaderList,
                                                                pcchHeaderListSize,
                                                                TRUE);
                        break;

                    case PDH_LOG_TYPE_SQL:
                        pdhStatus = PdhiListHeaderFromSQLLog((PPDHI_LOG) hDataSource,
                                                             (LPVOID) mszHeaderList,
                                                             pcchHeaderListSize,
                                                             TRUE);
                        break;

                    case PDH_LOG_TYPE_PERFMON:
                        pdhStatus = PDH_NOT_IMPLEMENTED;
                        break;

                    default:
                        pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                        break;
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
            else {
                pdhStatus = PDH_INVALID_HANDLE;
            }
            RELEASE_MUTEX(pDataSource->hLogMutex);
        }
        PdhCloseLog(hDataSource, 0);
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhListLogFileHeaderA(
    IN  LPCSTR  szFileName,
    IN  LPSTR   mszHeaderList,
    IN  LPDWORD pcchHeaderListSize
)
{
    HLOG        hDataSource = NULL;
    PDH_STATUS  pdhStatus;
    DWORD       dwLogType   = -1;
    PPDHI_LOG   pDataSource;

    if (szFileName == NULL || pcchHeaderListSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        // open log file
        pdhStatus = PdhOpenLogA(szFileName,
                                PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                                & dwLogType,
                                NULL,
                                0,
                                NULL,
                                & hDataSource);
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pDataSource = (PPDHI_LOG) hDataSource;
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pDataSource->hLogMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            if (IsValidLogHandle(hDataSource)) {
                __try {
                    // enum objects based on log type & machine name
                    switch (LOWORD(dwLogType)) {
                    case PDH_LOG_TYPE_CSV:
                    case PDH_LOG_TYPE_TSV:
                        pdhStatus = PdhiListHeaderFromTextLog((PPDHI_LOG) hDataSource,
                                                              (LPVOID)mszHeaderList,
                                                              pcchHeaderListSize,
                                                              FALSE);
                        break;

                    case PDH_LOG_TYPE_BINARY:
                    case PDH_LOG_TYPE_RETIRED_BIN:
                        pdhStatus = PdhiListHeaderFromBinaryLog((PPDHI_LOG) hDataSource,
                                                                (LPVOID) mszHeaderList,
                                                                pcchHeaderListSize,
                                                                FALSE);
                        break;

                    case PDH_LOG_TYPE_SQL:
                        pdhStatus = PdhiListHeaderFromSQLLog((PPDHI_LOG) hDataSource,
                                                             (LPVOID) mszHeaderList,
                                                             pcchHeaderListSize,
                                                             FALSE);
                        break;

                    case PDH_LOG_TYPE_PERFMON:
                        pdhStatus = PDH_NOT_IMPLEMENTED;
                        break;

                    default:
                        pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                        break;
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
            else {
                pdhStatus = PDH_INVALID_HANDLE;
            }
            RELEASE_MUTEX (pDataSource->hLogMutex);
        }
        PdhCloseLog(hDataSource, 0);
    }

    return pdhStatus;
}

extern DWORD DataSourceTypeW(IN LPCWSTR szDataSource);

PDH_FUNCTION
PdhBindInputDataSourceW(
    IN  PDH_HLOG * phDataSource,
    IN  LPCWSTR    LogFileNameList
)
{
    PDH_STATUS PdhStatus    = ERROR_SUCCESS;
    DWORD      dwDataSource = DataSourceTypeW(LogFileNameList);
    LPWSTR     NextLogFile  = (LPWSTR) LogFileNameList;
    ULONG      LogFileCount = 0;
    ULONG      LogFileSize;
    PPDHI_LOG  pLogHead     = NULL;
    PPDHI_LOG  pLogNew      = NULL;
    DWORD      dwLogType;
    PDH_HLOG   hLogLocal    = H_REALTIME_DATASOURCE;

    __try {
        dwDataSource = DataSourceTypeW(LogFileNameList);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        PdhStatus = PDH_INVALID_ARGUMENT;
    }
    if (PdhStatus == ERROR_SUCCESS) {
        switch (dwDataSource) {
        case DATA_SOURCE_WBEM:
            hLogLocal = H_WBEM_DATASOURCE;
            break;

        case DATA_SOURCE_REGISTRY:
            hLogLocal = H_REALTIME_DATASOURCE;
            break;

        case DATA_SOURCE_LOGFILE:
            if (LogFileNameList == NULL) {
                PdhStatus = PDH_INVALID_ARGUMENT;
            }
            else {
                if (lstrlenW(LogFileNameList) > 4 && (LogFileNameList[0] == L'S' || LogFileNameList[0] == L's') &&
                                                     (LogFileNameList[1] == L'Q' || LogFileNameList[1] == L'q') &&
                                                     (LogFileNameList[2] == L'L' || LogFileNameList[2] == L'l') &&
                                                     LogFileNameList[3] == L':') {
                    // special handling for SQL datasource
                    //
                    dwLogType = PDH_LOG_TYPE_SQL;
                    PdhStatus = PdhOpenLogW(LogFileNameList,
                                            PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                                            & dwLogType,
                                            NULL,
                                            0,
                                            NULL,
                                            & hLogLocal);
                    break;
                }

                __try {
                    while (* NextLogFile != L'\0') {
                        if (lstrlenW(NextLogFile) <= PDH_MAX_DATASOURCE_PATH) {
                            LogFileSize  = sizeof(WCHAR) * (lstrlenW(NextLogFile) + 1);
                            LogFileSize  = DWORD_MULTIPLE(LogFileSize);
                            //LogFileSize += sizeof(PDHI_LOG);

                            pLogNew = G_ALLOC(LogFileSize + sizeof(PDHI_LOG));
                            if (pLogNew == NULL) {
                                PdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                                break;
                            }
                            * ((LPDWORD)(& pLogNew->signature[0])) = SigLog;
                            pLogNew->dwLength      = sizeof(PDHI_LOG);
                            pLogNew->szLogFileName = (LPWSTR) (((PUCHAR) pLogNew) + sizeof(PDHI_LOG));
                            StringCbCopyW(pLogNew->szLogFileName, LogFileSize, NextLogFile);
                            pLogNew->NextLog       = pLogHead;
                            pLogHead               = pLogNew;
                            LogFileCount ++;
                        }
                        // skip counter log with datasource name longer than PDH_MAX_DATASOURCE_PATH
                        NextLogFile += (lstrlenW(NextLogFile) + 1);
                    }

                    if (pLogHead == NULL) {
                        PdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    PdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

            if (PdhStatus == ERROR_SUCCESS) {
                pLogHead->hLogMutex = CreateMutexW(NULL, TRUE, NULL);
                pLogHead->hLogFileHandle = INVALID_HANDLE_VALUE;
                pLogHead->hCatFileHandle = INVALID_HANDLE_VALUE;
                if (PdhiFirstLogEntry == NULL) {
                    PdhiFirstLogEntry    = pLogHead;
                    pLogHead->next.flink =
                    pLogHead->next.blink = pLogHead;
                }
                else {
                    PPDHI_LOG pFirstLog   = PdhiFirstLogEntry;
                    PPDHI_LOG pLastLog    = pFirstLog->next.blink;
                    pLogHead->next.flink  = pLastLog->next.flink;
                    pLastLog->next.flink  = pLogHead;
                    pLogHead->next.blink  = pFirstLog->next.blink;
                    pFirstLog->next.blink = pLogHead;
                }
                PdhStatus = OpenInputLogFile(pLogHead, PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING, & dwDataSource);
                if (PdhStatus == ERROR_SUCCESS && (dwDataSource == PDH_LOG_TYPE_BINARY || LogFileCount == 1)) {
                    hLogLocal = (PDH_HLOG) pLogHead;
                }
                else {
                    if (PdhStatus == ERROR_SUCCESS) {
                        PdhStatus = PDH_INVALID_ARGUMENT;
                        PdhCloseLog(pLogHead, 0);
                    }
                    DeleteLogEntry(pLogHead);
                }
            }
            else {
                while (pLogHead != NULL) {
                    pLogNew  = pLogHead;
                    pLogHead = pLogNew->NextLog;
                    G_FREE(pLogNew);
                }
            }
            break;

        default:
            PdhStatus = PDH_INVALID_ARGUMENT;
            break;
        }
    }
    if (PdhStatus == ERROR_SUCCESS) {
        __try {
            * phDataSource = hLogLocal;
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            PdhStatus = PDH_INVALID_ARGUMENT;
            PdhCloseLog(hLogLocal, 0);
        }
    }
    return PdhStatus;
}

PDH_FUNCTION
PdhBindInputDataSourceA(
    IN  PDH_HLOG * phDataSource,
    IN  LPCSTR     LogFileNameList
)
{
    LPWSTR     wLogFileNameList = NULL;
    LPWSTR     wNextFileName;
    LPSTR      aNextFileName;
    ULONG      LogFileListSize  = 1;
    PDH_STATUS PdhStatus        = ERROR_SUCCESS;

    if (LogFileNameList == NULL) {
        wLogFileNameList = NULL;
    }
    else {
        __try {
            while (LogFileNameList[LogFileListSize - 1] != '\0' || LogFileNameList[LogFileListSize] != '\0') {
                LogFileListSize ++;
            }
            LogFileListSize = (LogFileListSize + 1) * sizeof(WCHAR);

            wLogFileNameList = (LPWSTR) G_ALLOC(LogFileListSize);
            if (wLogFileNameList == NULL) {
                PdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
            else {
                aNextFileName = (LPSTR) LogFileNameList;
                wNextFileName = wLogFileNameList;

                while (* aNextFileName != '\0') {
                    LogFileListSize = lstrlenA(aNextFileName) + 1;
                    if (LogFileListSize <= PDH_MAX_DATASOURCE_PATH) {
                        MultiByteToWideChar(_getmbcp(), 0, aNextFileName, -1, (LPWSTR) wNextFileName, LogFileListSize);
                        wNextFileName += LogFileListSize;
                    }
                    // skip counter log with datasource name longer than PDH_MAX_DATASOURCE_PATH
                    aNextFileName += LogFileListSize;
                }
                * wNextFileName = L'\0';
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (PdhStatus == ERROR_SUCCESS) {
        PdhStatus = PdhBindInputDataSourceW(phDataSource, wLogFileNameList);
    }
    G_FREE(wLogFileNameList);
    return PdhStatus;
}

BOOL
PdhiCloseAllLoggers(
)
{
    BOOL bReturn = FALSE;
    if (WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex) == ERROR_SUCCESS) {
        while (PdhiFirstLogEntry != NULL) {
            PPDHI_LOG pLog = PdhiFirstLogEntry;
            CloseAndDeleteLogEntry(pLog, 0, TRUE);
        }
        RELEASE_MUTEX(hPdhDataMutex);
        bReturn = TRUE;
    }

    return bReturn;
}

PDH_FUNCTION PdhiCheckWmiLogFileType(IN LPCWSTR LogFileName, IN LPDWORD LogFileType);

PDH_FUNCTION
PdhGetLogFileTypeW(
    IN  LPCWSTR LogFileName,
    IN  LPDWORD LogFileType
)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HANDLE     hFile;
    DWORD      dwLogFormat;

    if (LogFileName == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            dwLogFormat   = * LogFileType;
            * LogFileType = dwLogFormat;
            if (* LogFileName == L'\0' || lstrlenW(LogFileName) > PDH_MAX_DATASOURCE_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        hFile = CreateFileW(LogFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
        if (hFile == NULL || hFile == INVALID_HANDLE_VALUE) {
            pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        dwLogFormat = GetLogFileType(hFile);
        CloseHandle(hFile);
        if (dwLogFormat == PDH_LOG_TYPE_UNDEFINED) {
            pdhStatus = PdhiCheckWmiLogFileType(LogFileName, & dwLogFormat);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        * LogFileType = dwLogFormat;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhGetLogFileTypeA(
    IN  LPCSTR  LogFileName,
    IN  LPDWORD LogFileType
)
{
    PDH_STATUS pdhStatus      = ERROR_SUCCESS;
    LPWSTR     wszLogFileName = NULL;
    DWORD      dwLogFileName  = 0;

    if (LogFileName == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            if (* LogFileName == '\0' || lstrlenA(LogFileName) > PDH_MAX_DATASOURCE_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            else {
                wszLogFileName = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) LogFileName);
                if (wszLogFileName == NULL) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhGetLogFileTypeW(wszLogFileName, LogFileType);
    }
    G_FREE(wszLogFileName);
    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhlog\log_bin.c ===
/*++
Copyright (C) 1996-1999 Microsoft Corporation

Module Name:
    log_bin.c

Abstract:
    <abstract>
--*/

#include <windows.h>
#include <strsafe.h>
#include <pdh.h>
#include "pdhidef.h"
#include "log_bin.h"
#include "log_wmi.h"
#include "strings.h"
#include "pdhmsg.h"

typedef struct _LOG_BIN_CAT_RECORD {
    PDHI_BINARY_LOG_RECORD_HEADER RecHeader;
    PDHI_LOG_CAT_ENTRY            CatEntry;
    DWORD                         dwEntryRecBuff[1];
} LOG_BIN_CAT_RECORD, * PLOG_BIN_CAT_RECORD;

typedef struct _LOG_BIN_CAT_ENTRY {
    DWORD              dwEntrySize;
    DWORD              dwOffsetToNextInstance;
    DWORD              dwEntryOffset;
    LOG_BIN_CAT_RECORD bcRec;
} LOG_BIN_CAT_ENTRY, * PLOG_BIN_CAT_ENTRY;

#define RECORD_AT(p,lo) ((PPDHI_BINARY_LOG_RECORD_HEADER) ((LPBYTE) (p->lpMappedFileBase) + lo))

LPCSTR  PdhiszRecordTerminator       = "\r\n";
DWORD   PdhidwRecordTerminatorLength = 2;

#define MAX_BINLOG_FILE_SIZE ((LONGLONG) 0x0000000040000000)

// dwFlags values
#define WBLR_WRITE_DATA_RECORD      0
#define WBLR_WRITE_LOG_HEADER       1
#define WBLR_WRITE_COUNTER_HEADER   2

DWORD
PdhiComputeDwordChecksum(
    LPVOID pBuffer,
    DWORD  dwBufferSize    // in bytes
)
{
    LPDWORD pDwVal;
    LPBYTE  pByteVal;
    DWORD   dwDwCount;
    DWORD   dwByteCount;
    DWORD   dwThisByte;
    DWORD   dwCheckSum = 0;
    DWORD   dwByteVal  = 0;

    if (dwBufferSize > 0) {
        dwDwCount   = dwBufferSize / sizeof(DWORD);
        dwByteCount = dwBufferSize % sizeof(DWORD);

        pDwVal = (LPDWORD) pBuffer;
        while (dwDwCount != 0) {
            dwCheckSum += * pDwVal ++;
            dwDwCount --;
        }

        pByteVal = (LPBYTE) pDwVal;
        dwThisByte = 0;
        while (dwThisByte < dwByteCount) {
            dwByteVal |= ((* pByteVal & 0x000000FF) << (dwThisByte * 8));
            dwThisByte ++;
        }
        dwCheckSum += dwByteVal;
    }
    return dwCheckSum;
}

PPDHI_BINARY_LOG_RECORD_HEADER
PdhiGetSubRecord(
    PPDHI_BINARY_LOG_RECORD_HEADER  pRecord,
    DWORD                           dwRecordId
)
// locates the specified sub record in the pRecord Buffer
// the return pointer is between pRecord and pRecord + pRecord->dwLength;
// NULL is returned if the specified record could not be found
// ID values start at 1 for the first sub record in buffer
{
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisRecord;
    DWORD                           dwRecordType;
    DWORD                           dwRecordLength;
    DWORD                           dwBytesProcessed;
    DWORD                           dwThisSubRecordId;

    dwRecordType     = ((PPDHI_BINARY_LOG_RECORD_HEADER) pRecord)->dwType;
    dwRecordLength   = ((PPDHI_BINARY_LOG_RECORD_HEADER) pRecord)->dwLength;
    pThisRecord      = (PPDHI_BINARY_LOG_RECORD_HEADER)((LPBYTE) pRecord + sizeof (PDHI_BINARY_LOG_RECORD_HEADER));
    dwBytesProcessed = sizeof(PDHI_BINARY_LOG_RECORD_HEADER);

    if (dwBytesProcessed < dwRecordLength) {
        dwThisSubRecordId = 1;
        while (dwThisSubRecordId < dwRecordId) {
            if ((WORD) (pThisRecord->dwType & 0x0000FFFF) == BINLOG_START_WORD) {
                // go to next sub record
                dwBytesProcessed += pThisRecord->dwLength;
                pThisRecord = (PPDHI_BINARY_LOG_RECORD_HEADER) (((LPBYTE) pThisRecord) + pThisRecord->dwLength);
                if (dwBytesProcessed >= dwRecordLength) {
                    // out of sub-records so exit
                    break;
                }
                else {
                    dwThisSubRecordId ++;
                }
            }
            else {
                // we're lost so bail
                break;
            }
        }
    }
    else {
        dwThisSubRecordId = 0;
    }

    if (dwThisSubRecordId == dwRecordId) {
        // then validate this is really a record and it's within the
        // master record.
        if ((WORD)(pThisRecord->dwType & 0x0000FFFF) != BINLOG_START_WORD) {
            // bogus record so return a NULL pointer
            pThisRecord = NULL;
        }
        else {
            // this is OK so return pointer
        }
    }
    else {
        // record not found so return a NULL pointer
        pThisRecord = NULL;
    }
    return pThisRecord;
}

STATIC_PDH_FUNCTION
PdhiReadBinaryMappedRecord(
    PPDHI_LOG pLog,
    DWORD     dwRecordId,
    LPVOID    pRecord,
    DWORD     dwMaxSize
)
{
    PDH_STATUS                     pdhStatus= ERROR_SUCCESS;
    LPVOID                         pEndOfFile;
    LPVOID                         pLastRecord;
    DWORD                          dwLastRecordIndex;
    PPDHI_BINARY_LOG_HEADER_RECORD pHeader;
    PPDHI_BINARY_LOG_RECORD_HEADER pRecHeader;
    LPVOID                         pLastRecordInLog;
    DWORD                          dwBytesToRead;
    DWORD                          dwBytesRead;
    BOOL                           bStatus;

    if (dwRecordId == 0) return PDH_ENTRY_NOT_IN_LOG_FILE;    // record numbers start at 1

    // see if the file has been mapped
    if (pLog->hMappedLogFile == NULL) {
        // then it's not mapped so read it using the file system
        if ((pLog->dwLastRecordRead == 0) || (dwRecordId < pLog->dwLastRecordRead)) {
            // then we know no record has been read yet so assign
            // pointer just to be sure
            SetFilePointer(pLog->hLogFileHandle, 0, NULL, FILE_BEGIN);
            
            // allocate a new buffer
            if (pLog->dwMaxRecordSize < 0x10000) pLog->dwMaxRecordSize = 0x10000;
            dwBytesToRead = pLog->dwMaxRecordSize;

            // allocate a fresh buffer
            if (pLog->pLastRecordRead != NULL) {
                G_FREE(pLog->pLastRecordRead);
                pLog->pLastRecordRead = NULL;
            }
            pLog->pLastRecordRead = G_ALLOC(pLog->dwMaxRecordSize);

            if (pLog->pLastRecordRead == NULL) {
                pdhStatus =  PDH_MEMORY_ALLOCATION_FAILURE;
            }
            else {
                // initialize the first record header
                dwBytesToRead = pLog->dwRecord1Size;
                dwBytesRead = 0;
                bStatus = ReadFile(pLog->hLogFileHandle, pLog->pLastRecordRead, dwBytesToRead, & dwBytesRead, NULL);
                if (bStatus && (dwBytesRead == pLog->dwRecord1Size)) {
                    // make sure the buffer is big enough
                    pLog->dwLastRecordRead = 1;
                    pdhStatus = ERROR_SUCCESS;
                }
                else {
                    // unable to read the first record
                    pdhStatus = PDH_UNABLE_READ_LOG_HEADER;
                }
            }
        }
        else {
            // assume everything is already set up and OK
        }

        // "seek" to the desired record file pointer should either be pointed 
        // to the start of a new record or at the end of the file
        while ((dwRecordId != pLog->dwLastRecordRead) && (pdhStatus == ERROR_SUCCESS)) {
            // clear the buffer
            ZeroMemory(pLog->pLastRecordRead, pLog->dwMaxRecordSize);
            // read record header field
            dwBytesToRead = sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
            dwBytesRead   = 0;
            bStatus       = ReadFile(pLog->hLogFileHandle, pLog->pLastRecordRead, dwBytesToRead, & dwBytesRead, NULL);
            if (bStatus && (dwBytesRead == dwBytesToRead)) {
               // make sure the rest of the record will fit in the buffer
                pRecHeader = (PPDHI_BINARY_LOG_RECORD_HEADER) pLog->pLastRecordRead;
                // make sure this is a valid record
                if (*(WORD *)&(pRecHeader->dwType) == BINLOG_START_WORD) {
                    if (pRecHeader->dwLength > pLog->dwMaxRecordSize) {
                        LPVOID pTmp = pLog->pLastRecordRead;

                        // realloc the buffer
                        pLog->dwMaxRecordSize = pRecHeader->dwLength;
                        pLog->pLastRecordRead = G_REALLOC(pTmp, pLog->dwMaxRecordSize);
                        if (pLog->pLastRecordRead == NULL) {
                            G_FREE(pTmp);
                        }
                    }

                    if (pLog->pLastRecordRead != NULL) {
                        dwBytesToRead = pRecHeader->dwLength - sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
                        dwBytesRead = 0;
                        pLastRecord = (LPVOID)((LPBYTE)(pLog->pLastRecordRead) + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
                        bStatus = ReadFile(pLog->hLogFileHandle, pLastRecord, dwBytesToRead, & dwBytesRead, NULL);
                        if (bStatus) {
                            pLog->dwLastRecordRead ++;
                        }
                        else {
                            pdhStatus = PDH_END_OF_LOG_FILE;
                        }
                    }
                    else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                }
                else {
                    // file is corrupt
                    pdhStatus = PDH_INVALID_DATA;
                }
            }
            else {
                pdhStatus = PDH_END_OF_LOG_FILE;
            }
        }
        // here the result will be success when the specified file has been read or
        // a PDH error if not
    }
    else {
        // the file has been memory mapped so use that interface
        if (pLog->dwLastRecordRead == 0) {
            // then we know no record has been read yet so assign
            // pointer just to be sure
            pLog->pLastRecordRead = pLog->lpMappedFileBase;
            pLog->dwLastRecordRead = 1;
        }

        pHeader = (PPDHI_BINARY_LOG_HEADER_RECORD) RECORD_AT(pLog, pLog->dwRecord1Size);

        // "seek" to the desired record
        if (dwRecordId < pLog->dwLastRecordRead) {
            if (dwRecordId >= BINLOG_FIRST_DATA_RECORD) {
                // rewind the file
                pLog->pLastRecordRead  = (LPVOID)((LPBYTE) pLog->lpMappedFileBase + pHeader->Info.FirstRecordOffset);
                pLog->dwLastRecordRead = BINLOG_FIRST_DATA_RECORD;
            }
            else {
                // rewind the file
                pLog->pLastRecordRead  = pLog->lpMappedFileBase;
                pLog->dwLastRecordRead = 1;
            }
        }

        // then use the point specified as the end of the file
        // if the log file contians a specified Wrap offset, then use that
        // if not, then if the file length is specified, use that
        // if not, the use the reported file length
        pEndOfFile = (LPVOID) ((LPBYTE) pLog->lpMappedFileBase);
        if (pHeader->Info.WrapOffset > 0) {
            pEndOfFile = (LPVOID)((LPBYTE)pEndOfFile + pHeader->Info.WrapOffset);
        }
        else if (pHeader->Info.FileLength > 0) {
            pEndOfFile = (LPVOID)((LPBYTE)pEndOfFile + pHeader->Info.FileLength);
        }
        else {
            pEndOfFile = (LPVOID)((LPBYTE)pEndOfFile + pLog->llFileSize);
        }
        pLastRecord = pLog->pLastRecordRead;
        dwLastRecordIndex = pLog->dwLastRecordRead;

        __try {
            // walk around the file until an access violation occurs or
            // the record is found. If an access violation occurs,
            // we can assume we went off the end of the file and out
            // of the mapped section
            // make sure the record has a valid header
            if (pLog->dwLastRecordRead !=  BINLOG_TYPE_ID_RECORD ?
                    (* (WORD *) pLog->pLastRecordRead == BINLOG_START_WORD) : TRUE) {
                // then it looks OK so continue
                while (pLog->dwLastRecordRead != dwRecordId) {
                    // go to next record
                    pLastRecord = pLog->pLastRecordRead;
                    if (pLog->dwLastRecordRead != BINLOG_TYPE_ID_RECORD) {
                        if (pLog->dwLastRecordRead == BINLOG_HEADER_RECORD) {                   
                            // if the last record was the header, then the next record
                            // is the "first" data , not the first after the header
                            pLog->pLastRecordRead = (LPVOID)((LPBYTE) pLog->lpMappedFileBase +
                                                             pHeader->Info.FirstRecordOffset);
                        }
                        else {
                            // if the current record is any record other than the header
                            // ...then
                            if (((PPDHI_BINARY_LOG_RECORD_HEADER)pLog->pLastRecordRead)->dwLength > 0) {
                                // go to the next record in the file
                                pLog->pLastRecordRead = (LPVOID) ((LPBYTE) pLog->pLastRecordRead +
                                        ((PPDHI_BINARY_LOG_RECORD_HEADER) pLog->pLastRecordRead)->dwLength);
                                // test for exceptions here
                                if (pLog->pLastRecordRead >= pEndOfFile) {
                                    // find out if this is a circular log or not
                                    if (pLog->dwLogFormat & PDH_LOG_OPT_CIRCULAR) {
                                        // test to see if the file has wrapped
                                        if (pHeader->Info.WrapOffset != 0) {
                                            // then wrap to the beginning of the file
                                            pLog->pLastRecordRead = (LPVOID)((LPBYTE)pLog->lpMappedFileBase +
                                                    pHeader->Info.FirstDataRecordOffset);
                                        }
                                        else {
                                            // the file is still linear so this is the end
                                            pdhStatus = PDH_END_OF_LOG_FILE;
                                        }
                                    }
                                    else {
                                        // this is the end of the file
                                        // so reset to the previous pointer
                                        pdhStatus = PDH_END_OF_LOG_FILE;
                                    }
                                }
                                else {
                                    // not at the physical end of the file, but if this is a circular
                                    // log, it could be the logical end of the records so test that
                                    // here
                                    if (pLog->dwLogFormat & PDH_LOG_OPT_CIRCULAR) {
                                        pLastRecordInLog = (LPVOID)((LPBYTE)pLog->lpMappedFileBase +
                                                pHeader->Info.LastRecordOffset);
                                        pLastRecordInLog = (LPVOID)((LPBYTE)pLastRecordInLog +
                                                ((PPDHI_BINARY_LOG_RECORD_HEADER)pLastRecordInLog)->dwLength);
                                        if (pLog->pLastRecordRead == pLastRecordInLog) {
                                            // then this is the last record in the log
                                            pdhStatus = PDH_END_OF_LOG_FILE;
                                        }
                                    }
                                    else {
                                        // nothing to do since this is a normal case
                                    }
                                } // end if / if not end of log file
                            }
                            else {
                                // length is 0 so we've probably run off the end of the log somehow
                                pdhStatus = PDH_END_OF_LOG_FILE;
                            }
                        } // end if /if not header record
                    }
                    else {
                        pLog->pLastRecordRead = (LPBYTE) pLog->pLastRecordRead + pLog->dwRecord1Size;
                    }
                    if (pdhStatus == ERROR_SUCCESS) {
                        // update pointers & indices
                        pLog->dwLastRecordRead ++;
                        dwLastRecordIndex = pLog->dwLastRecordRead;
                    }
                    else {
                        pLog->pLastRecordRead = pLastRecord;
                        break; // out of the while loop
                    }
                }
            }
            else {
                pdhStatus = PDH_END_OF_LOG_FILE;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pLog->pLastRecordRead = pLastRecord;
            pLog->dwLastRecordRead = dwLastRecordIndex;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // see if we ended up at the right place
        if (pLog->dwLastRecordRead == dwRecordId) {
            if (pRecord != NULL) {
                // then try to copy it
                // if the record ID is 1 then it's the header record so this is
                // a special case record that is actually a CR/LF terminated record
                if (dwRecordId != BINLOG_TYPE_ID_RECORD) {
                    if (((PPDHI_BINARY_LOG_RECORD_HEADER)pLog->pLastRecordRead)->dwLength <= dwMaxSize) {
                        // then it'll fit so copy it
                        memcpy(pRecord, pLog->pLastRecordRead,
                            ((PPDHI_BINARY_LOG_RECORD_HEADER)pLog->pLastRecordRead)->dwLength);
                        pdhStatus = ERROR_SUCCESS;
                    }
                    else {
                        // then copy as much as will fit
                        memcpy(pRecord, pLog->pLastRecordRead, dwMaxSize);
                        pdhStatus = PDH_MORE_DATA;
                    }
                }
                else {
                    // copy the first record and zero terminate it
                    if (pLog->dwRecord1Size <= dwMaxSize) {
                        memcpy(pRecord, pLog->pLastRecordRead, pLog->dwRecord1Size);
                        // null terminate after string
                        ((LPBYTE) pRecord)[pLog->dwRecord1Size - PdhidwRecordTerminatorLength + 1] = 0;
                    }
                    else {
                        memcpy(pRecord, pLog->pLastRecordRead, dwMaxSize);
                        pdhStatus = PDH_MORE_DATA;
                    }
                }
            }
            else {
                // just return success
                // no buffer was passed, but the record pointer has been
                // positioned
                pdhStatus = ERROR_SUCCESS;
            }
        }
        else {
            pdhStatus = PDH_END_OF_LOG_FILE;
        }
    }

    return pdhStatus;
}

STATIC_PDH_FUNCTION
PdhiReadOneBinLogRecord(
    PPDHI_LOG pLog,
    DWORD     dwRecordId,
    LPVOID    pRecord,
    DWORD     dwMaxSize
)
{
    PDH_STATUS  pdhStatus= ERROR_SUCCESS;
    LPVOID      pEndOfFile;
    LPVOID      pLastRecord;
    DWORD       dwLastRecordIndex = 0;
    PPDHI_BINARY_LOG_HEADER_RECORD pHeader = NULL;
    BOOL        bCircular = FALSE;
    DWORD       dwRecordSize;
    DWORD       dwRecordReadSize;
    LONGLONG    llLastFileOffset;
    LPVOID      pTmpBuffer;

    if ((LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_BINARY) && (dwRecordId == BINLOG_HEADER_RECORD)) {
        // special handling for WMI event trace logfile format
        //
        return PdhiReadWmiHeaderRecord(pLog, pRecord, dwMaxSize);
    }

    if (pLog->iRunidSQL != 0) {
        return PdhiReadBinaryMappedRecord(pLog, dwRecordId, pRecord, dwMaxSize);
    }

    if (pLog->dwLastRecordRead == 0) {
        // then we know no record has been read yet so assign
        // pointer just to be sure
        pLog->pLastRecordRead = NULL;
        pLog->liLastRecordOffset.QuadPart = 0;
        SetFilePointer(pLog->hLogFileHandle,
                       pLog->liLastRecordOffset.LowPart,
                       & pLog->liLastRecordOffset.HighPart, FILE_BEGIN);
        if (pLog->liLastRecordOffset.LowPart == INVALID_SET_FILE_POINTER) {
            pdhStatus = GetLastError();
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {

        // map header to local structure (the header data should be mapped into memory
        pHeader = (PPDHI_BINARY_LOG_HEADER_RECORD)RECORD_AT(pLog, pLog->dwRecord1Size);

        if (pHeader->Info.WrapOffset > 0) {
            bCircular = TRUE;
        }

        // "seek" to the desired record 
        if ((dwRecordId < pLog->dwLastRecordRead) || (pLog->dwLastRecordRead == 0)) {
            // rewind if not initialized or the desired record is before this one
            if (dwRecordId >= BINLOG_FIRST_DATA_RECORD) {
                // rewind the file to the first regular record
                pLog->liLastRecordOffset.QuadPart = pHeader->Info.FirstRecordOffset;
                pLog->dwLastRecordRead            = BINLOG_FIRST_DATA_RECORD;
            }
            else {
                // rewind the file to the very start of the file
                pLog->liLastRecordOffset.QuadPart = 0;
                pLog->dwLastRecordRead            = 1;
            }
            pLog->liLastRecordOffset.LowPart = SetFilePointer(pLog->hLogFileHandle,
                                                              pLog->liLastRecordOffset.LowPart,
                                                              & pLog->liLastRecordOffset.HighPart,
                                                              FILE_BEGIN);
            if (pLog->liLastRecordOffset.LowPart == INVALID_SET_FILE_POINTER) {
                pdhStatus = GetLastError();
            }
            else {
                if (pLog->pLastRecordRead != NULL) {
                    G_FREE(pLog->pLastRecordRead);
                    pLog->pLastRecordRead = NULL;
                }

                if (pLog->dwLastRecordRead == 1) {
                    // the this is the text ID field
                    dwRecordSize = pLog->dwRecord1Size;
                }
                else {
                    dwRecordSize = sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
                }

                pLog->pLastRecordRead = G_ALLOC(dwRecordSize);
                if (pLog->pLastRecordRead != NULL) {
                    // read in the header (or entire record if the 1st record
                    // otherwise it's a data record
                    if (ReadFile(pLog->hLogFileHandle, pLog->pLastRecordRead, dwRecordSize, & dwRecordReadSize, NULL)) {
                        // then we have the record header or type record so 
                        // complete the operation and read the rest of the record
                        if (pLog->dwLastRecordRead != BINLOG_TYPE_ID_RECORD) {
                            // the Type ID record is of fixed length and has not header record
                            dwRecordSize = ((PPDHI_BINARY_LOG_RECORD_HEADER)pLog->pLastRecordRead)->dwLength;
                            pTmpBuffer   = pLog->pLastRecordRead;
                            pLog->pLastRecordRead = G_REALLOC(pTmpBuffer, dwRecordSize);
                            if (pLog->pLastRecordRead != NULL) {
                                // read in the rest of the record and append it to the header data already read in
                                // otherwise it's a data record
                                pLastRecord = (LPVOID) & ((LPBYTE) pLog->pLastRecordRead)[sizeof(PDHI_BINARY_LOG_RECORD_HEADER)];
                                if (ReadFile(pLog->hLogFileHandle,
                                             pLastRecord,
                                             dwRecordSize - sizeof(PDHI_BINARY_LOG_RECORD_HEADER),
                                             & dwRecordReadSize,
                                             NULL)) {
                                    // then we have the record header or type record
                                    pdhStatus = ERROR_SUCCESS;
                                }
                                else {
                                    pdhStatus = GetLastError();
                                }
                            }
                            else {
                                G_FREE(pTmpBuffer);
                                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                            }
                        }
                        pdhStatus = ERROR_SUCCESS;
                    }
                    else {
                        pdhStatus = GetLastError();
                    }
                }
                else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            }
        }

        // then use the point specified as the end of the file
        // if the log file contians a specified Wrap offset, then use that
        // if not, then if the file length is specified, use that
        // if not, the use the reported file length
        pEndOfFile = (LPVOID)((LPBYTE) pLog->lpMappedFileBase);

        if (pHeader->Info.WrapOffset > 0) {
            pEndOfFile = (LPVOID)((LPBYTE) pEndOfFile + pHeader->Info.WrapOffset);
        }
        else if (pHeader->Info.FileLength > 0) {
            pEndOfFile = (LPVOID)((LPBYTE) pEndOfFile + pHeader->Info.FileLength);
        }
        else {
            pEndOfFile = (LPVOID)((LPBYTE) pEndOfFile + pLog->llFileSize);
        }

        dwLastRecordIndex = pLog->dwLastRecordRead;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            // walk around the file until an access violation occurs or
            // the record is found. If an access violation occurs,
            // we can assume we went off the end of the file and out
            // of the mapped section

                // make sure the record has a valid header
            if (pLog->dwLastRecordRead !=  BINLOG_TYPE_ID_RECORD ?
                            (* (WORD *) pLog->pLastRecordRead == BINLOG_START_WORD) : TRUE) {
                // then it looks OK so continue
                while (pLog->dwLastRecordRead != dwRecordId) {
                    // go to next record
                    if (pLog->dwLastRecordRead != BINLOG_TYPE_ID_RECORD) {
                        llLastFileOffset = pLog->liLastRecordOffset.QuadPart;
                        if (pLog->dwLastRecordRead == BINLOG_HEADER_RECORD) {                   
                            // if the last record was the header, then the next record
                            // is the "first" data , not the first after the header
                            // the function returns the new offset
                            pLog->liLastRecordOffset.QuadPart = pHeader->Info.FirstRecordOffset;
                            pLog->liLastRecordOffset.LowPart  = SetFilePointer(pLog->hLogFileHandle,
                                                                               pLog->liLastRecordOffset.LowPart,
                                                                               & pLog->liLastRecordOffset.HighPart,
                                                                               FILE_BEGIN);
                        }
                        else {
                            // if the current record is any record other than the header
                            // ...then
                            if (((PPDHI_BINARY_LOG_RECORD_HEADER)pLog->pLastRecordRead)->dwLength > 0) {
                                // go to the next record in the file
                                pLog->liLastRecordOffset.QuadPart += ((PPDHI_BINARY_LOG_RECORD_HEADER)
                                                                      pLog->pLastRecordRead)->dwLength;
                                // test for exceptions here
                                if (pLog->liLastRecordOffset.QuadPart >= pLog->llFileSize) {
                                    // find out if this is a circular log or not
                                    if (pLog->dwLogFormat & PDH_LOG_OPT_CIRCULAR) {
                                        // test to see if the file has wrapped
                                        if (pHeader->Info.WrapOffset != 0) {
                                            // then wrap to the beginning of the file
                                            pLog->liLastRecordOffset.QuadPart = pHeader->Info.FirstDataRecordOffset;
                                        }
                                        else {
                                            // the file is still linear so this is the end
                                            pdhStatus = PDH_END_OF_LOG_FILE;
                                        }
                                    }
                                    else {
                                        // this is the end of the file
                                        // so reset to the previous pointer
                                        pdhStatus = PDH_END_OF_LOG_FILE;
                                    }
                                }
                                else {
                                    // not at the physical end of the file, but if this is a circular
                                    // log, it could be the logical end of the records so test that
                                    // here
                                    if (pLog->dwLogFormat & PDH_LOG_OPT_CIRCULAR) {
                                        if (llLastFileOffset == pHeader->Info.LastRecordOffset) {
                                            // then this is the last record in the log
                                            pdhStatus = PDH_END_OF_LOG_FILE;
                                        }
                                    }
                                    else {
                                        // nothing to do since this is a normal case
                                    }
                                } // end if / if not end of log file
                            }
                            else {
                                // length is 0 so we've probably run off the end of the log somehow
                                pdhStatus = PDH_END_OF_LOG_FILE;
                            }
                            // now go to that record
                            if (pdhStatus == ERROR_SUCCESS) {
                                pLog->liLastRecordOffset.LowPart = SetFilePointer(pLog->hLogFileHandle,
                                                                                  pLog->liLastRecordOffset.LowPart,
                                                                                  & pLog->liLastRecordOffset.HighPart,
                                                                                  FILE_BEGIN);
                            }
                        } // end if /if not header record
                    }
                    else {
                        pLog->liLastRecordOffset.QuadPart = pLog->dwRecord1Size;
                        pLog->liLastRecordOffset.LowPart  = SetFilePointer(pLog->hLogFileHandle,
                                                                           pLog->liLastRecordOffset.LowPart,
                                                                           & pLog->liLastRecordOffset.HighPart,
                                                                           FILE_BEGIN);
                    }
                    if (pdhStatus == ERROR_SUCCESS) {
                        // the last record buffer should not be NULL and it should
                        // be large enough to hold the header
                        if (pLog->pLastRecordRead != NULL) {
                            // read in the header (or entire record if the 1st record
                            // otherwise it's a data record
                            dwRecordSize = sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
                            if (ReadFile(pLog->hLogFileHandle,
                                         pLog->pLastRecordRead,
                                         dwRecordSize,
                                         & dwRecordReadSize,
                                         NULL)) {
                                // then we have the record header or type record
                                // update pointers & indices
                                pLog->dwLastRecordRead ++;
                                pdhStatus = ERROR_SUCCESS;
                            }
                            else {
                                pdhStatus = GetLastError();
                            }
            
                        }
                        else {
                            DebugBreak();
                        }
                    }
                    else {
                        break; // out of the while loop
                    }
                }
            }
            else {
                pdhStatus = PDH_END_OF_LOG_FILE;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pLog->dwLastRecordRead = dwLastRecordIndex;
        }
    }

    // see if we ended up at the right place
    if ((pdhStatus == ERROR_SUCCESS) && (pLog->dwLastRecordRead == dwRecordId)) {
        if (dwLastRecordIndex != pLog->dwLastRecordRead) {
            // then we've move the file pointer so read the entire data record
            dwRecordSize = ((PPDHI_BINARY_LOG_RECORD_HEADER)pLog->pLastRecordRead)->dwLength;
            pTmpBuffer   = pLog->pLastRecordRead;
            pLog->pLastRecordRead = G_REALLOC(pTmpBuffer, dwRecordSize);

            if (pLog->pLastRecordRead != NULL) {
                // read in the rest of the record and append it to the header data already read in
                // otherwise it's a data record
                pLastRecord = (LPVOID)&((LPBYTE)pLog->pLastRecordRead)[sizeof(PDHI_BINARY_LOG_RECORD_HEADER)];
                if (ReadFile(pLog->hLogFileHandle,
                             pLastRecord,
                             dwRecordSize - sizeof(PDHI_BINARY_LOG_RECORD_HEADER),
                             & dwRecordReadSize,
                             NULL)) {
                    // then we have the record header or type record
                    pdhStatus = ERROR_SUCCESS;
                }
                else {
                    pdhStatus = GetLastError();
                }
            }
            else {
                G_FREE(pTmpBuffer);
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }

        if ((pdhStatus == ERROR_SUCCESS) && (pRecord != NULL)) {
            // then try to copy it
            // if the record ID is 1 then it's the header record so this is
            // a special case record that is actually a CR/LF terminated record
            if (dwRecordId != BINLOG_TYPE_ID_RECORD) {
                if (((PPDHI_BINARY_LOG_RECORD_HEADER)pLog->pLastRecordRead)->dwLength <= dwMaxSize) {
                    // then it'll fit so copy it
                    RtlCopyMemory(pRecord, pLog->pLastRecordRead,
                                  ((PPDHI_BINARY_LOG_RECORD_HEADER)pLog->pLastRecordRead)->dwLength);
                    pdhStatus = ERROR_SUCCESS;
                }
                else {
                    // then copy as much as will fit
                    RtlCopyMemory(pRecord, pLog->pLastRecordRead, dwMaxSize);
                    pdhStatus = PDH_MORE_DATA;
                }
            }
            else {
                // copy the first record and zero terminate it
                if (pLog->dwRecord1Size <= dwMaxSize) {
                    RtlCopyMemory(pRecord, pLog->pLastRecordRead, pLog->dwRecord1Size);
                    // null terminate after string
                    ((LPBYTE) pRecord)[pLog->dwRecord1Size - PdhidwRecordTerminatorLength + 1] = 0;
                }
                else {
                    RtlCopyMemory(pRecord, pLog->pLastRecordRead, dwMaxSize);
                    pdhStatus = PDH_MORE_DATA;
                }
            }
        }
        else {
            // just return current status value
            // no buffer was passed, but the record pointer has been
            // positioned
        }
    }
    else {
        // if successful so far, then return EOF
        if (pdhStatus == ERROR_SUCCESS) pdhStatus = PDH_END_OF_LOG_FILE;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiGetBinaryLogCounterInfo(
    PPDHI_LOG     pLog,
    PPDHI_COUNTER pCounter
)
{
    PDH_STATUS                      pdhStatus;
    DWORD                           dwIndex;
    DWORD                           dwPrevious      = pCounter->dwIndex;
    PPDHI_COUNTER_PATH              pTempPath       = NULL;
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisMasterRecord;
    PPDHI_LOG_COUNTER_PATH          pPath;
    DWORD                           dwBufferSize;
    DWORD                           dwRecordLength;
    DWORD                           dwBytesProcessed;
    DWORD                           dwTmpIndex;
    LPBYTE                          pFirstChar;
    LPWSTR                          szThisMachineName;
    LPWSTR                          szThisObjectName;
    LPWSTR                          szThisCounterName;
    LPWSTR                          szThisInstanceName;
    LPWSTR                          szThisParentName;
    BOOL                            bCheckThisObject = FALSE;

    // crack the path in to components

    pTempPath = G_ALLOC(LARGE_BUFFER_SIZE);

    if (pTempPath == NULL) {
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }

    dwBufferSize = (DWORD) G_SIZE(pTempPath);

    if (ParseFullPathNameW(pCounter->szFullName, &dwBufferSize, pTempPath, FALSE)) {
        // read the header record to find the matching entry

        pdhStatus = PdhiReadOneBinLogRecord(pLog, BINLOG_HEADER_RECORD, NULL, 0);
        if (pdhStatus == ERROR_SUCCESS) {
            pThisMasterRecord = (PPDHI_BINARY_LOG_RECORD_HEADER) pLog->pLastRecordRead;
            dwRecordLength    = ((PPDHI_BINARY_LOG_RECORD_HEADER) pThisMasterRecord)->dwLength;
            pPath = (PPDHI_LOG_COUNTER_PATH) ((LPBYTE) pThisMasterRecord + sizeof (PDHI_BINARY_LOG_HEADER_RECORD));
            dwBytesProcessed  = sizeof(PDHI_BINARY_LOG_HEADER_RECORD);
            dwIndex           = 0;
            pdhStatus         = PDH_ENTRY_NOT_IN_LOG_FILE;
            dwTmpIndex        = 0;

            while (dwBytesProcessed < dwRecordLength) {
                // go through catalog to find a match
                dwIndex ++;

                pFirstChar = (LPBYTE) & pPath->Buffer[0];
                if (dwPrevious != 0 && dwPrevious >= dwIndex) {
                    bCheckThisObject = FALSE;
                }
                else if (pPath->lMachineNameOffset >= 0L) {
                    // then there's a machine name in this record so get
                    // it's size
                    szThisMachineName = (LPWSTR)((LPBYTE) pFirstChar + pPath->lMachineNameOffset);

                    // if this is for the desired machine, then select the object

                    if (lstrcmpiW(szThisMachineName, pTempPath->szMachineName) == 0) {
                        szThisObjectName = (LPWSTR)((LPBYTE) pFirstChar + pPath->lObjectNameOffset);
                        if (lstrcmpiW(szThisObjectName, pTempPath->szObjectName) == 0) {
                            // then this is the object to look up
                            bCheckThisObject = TRUE;
                        }
                        else {
                            // not this object
                            szThisObjectName = NULL;
                        }
                    }
                    else {
                        // this machine isn't selected
                    }
                }
                else {
                    // there's no machine specified so for this counter so list it by default
                    if (pPath->lObjectNameOffset >= 0) {
                        szThisObjectName = (LPWSTR) ((LPBYTE) pFirstChar + pPath->lObjectNameOffset);
                        if (lstrcmpiW(szThisObjectName,pTempPath->szObjectName) == 0) {
                            // then this is the object to look up
                            bCheckThisObject = TRUE;
                        }
                        else {
                            // not this object
                            szThisObjectName = NULL;
                        }
                    }
                    else {
                        // no object to copy
                        szThisObjectName = NULL;
                    }
                }

                if (bCheckThisObject) {
                    szThisCounterName = (LPWSTR) ((LPBYTE) pFirstChar + pPath->lCounterOffset);
                    if (* szThisCounterName == SPLAT_L) {
                        pdhStatus = PdhiGetWmiLogCounterInfo(pLog, pCounter);
                        pCounter->dwIndex = dwIndex;
                        break;
                    }
                    else if (lstrcmpiW(szThisCounterName, pTempPath->szCounterName) == 0) {
                        // check instance name
                        // get the instance name from this counter and add it to the list
                        if (pPath->lInstanceOffset >= 0) {
                            szThisInstanceName = (LPWSTR)((LPBYTE) pFirstChar + pPath->lInstanceOffset);

                            if (*szThisInstanceName != SPLAT_L) {
                                if (pPath->lParentOffset >= 0) {
                                    szThisParentName = (LPWSTR)((LPBYTE) pFirstChar + pPath->lParentOffset);
                                    if (lstrcmpiW(szThisParentName, pTempPath->szParentName) != 0) {
                                        // wrong parent
                                        bCheckThisObject = FALSE;
                                    }
                                }
                                if (lstrcmpiW(szThisInstanceName, pTempPath->szInstanceName) != 0) {
                                    // wrong instance
                                    bCheckThisObject = FALSE;
                                }
                                if (pTempPath->dwIndex > 0) {
                                    if (pPath->dwIndex == pTempPath->dwIndex) {
                                        bCheckThisObject = TRUE;
                                    }
                                    else if (pPath->dwIndex == 0) {
                                        if (dwTmpIndex == pTempPath->dwIndex) {
                                            bCheckThisObject = TRUE;
                                        }
                                        else {
                                            dwTmpIndex ++;
                                            bCheckThisObject = FALSE;
                                        }
                                    }
                                    else if (LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_RETIRED_BIN) {
                                        if (dwTmpIndex == pTempPath->dwIndex) {
                                            bCheckThisObject = TRUE;
                                        }
                                        else {
                                            dwTmpIndex ++;
                                            bCheckThisObject = FALSE;
                                        }
                                    }
                                    else {
                                        // wrong index
                                        bCheckThisObject = FALSE;
                                    }
                                }
                                else if (pPath->dwIndex != 0 && LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_BINARY) {
                                    bCheckThisObject = FALSE;
                                }
                            }
                            else {
                                // this is a wild card spec
                                // so assume it's valid since that's
                                // faster than reading the file each time.
                                // if the instance DOESN't exist in this
                                // file then the appropriate status will
                                // be returned in each query.
                            }
                        }
                        else {
                            // there is no instance name to compare
                            // so assume it's OK
                        }
                        if (bCheckThisObject) {
                            // fill in the data and return
                            // this data is NOT used by the log file reader
                            pCounter->plCounterInfo.dwObjectId  = 0;
                            pCounter->plCounterInfo.lInstanceId = 0;
                            if (pPath->lInstanceOffset >= 0) {
                                pCounter->plCounterInfo.szInstanceName       = pCounter->pCounterPath->szInstanceName;
                                pCounter->plCounterInfo.dwParentObjectId     = 0;
                                pCounter->plCounterInfo.szParentInstanceName = pCounter->pCounterPath->szParentName;
                            }
                            else {
                                pCounter->plCounterInfo.szInstanceName       = NULL;
                                pCounter->plCounterInfo.dwParentObjectId     = 0;
                                pCounter->plCounterInfo.szParentInstanceName = NULL;
                            }
                            //define as multi instance if necessary
                            // if the user is passing in a "*" character
                            if (pCounter->plCounterInfo.szInstanceName != NULL) {
                                if (*pCounter->plCounterInfo.szInstanceName == SPLAT_L) {
                                    pCounter->dwFlags |= PDHIC_MULTI_INSTANCE;
                                }
                            }
                            // this data is used by the log file readers
                            pCounter->plCounterInfo.dwCounterId   = dwIndex; // entry in log
                            pCounter->plCounterInfo.dwCounterType = pPath->dwCounterType;
                            pCounter->plCounterInfo.dwCounterSize = pPath->dwCounterType & PERF_SIZE_LARGE ?
                                                                    sizeof (LONGLONG) : sizeof(DWORD);
                            pCounter->plCounterInfo.lDefaultScale = pPath->lDefaultScale;
                            pCounter->TimeBase                    = pPath->llTimeBase;
                            pCounter->dwIndex                     = dwIndex;
                            pdhStatus                             = ERROR_SUCCESS;

                            break;
                        }
                    }
                }
                else {
                    // we aren't interested in this so just ignore it
                }

                // get next path entry from log file record
                dwBytesProcessed += pPath->dwLength;
                pPath             = (PPDHI_LOG_COUNTER_PATH) ((LPBYTE) pPath + pPath->dwLength);
            } // end while searching the catalog entries
        }
        else {
            // unable to find desired record so return status
        }
    }
    else {
        // unable to read the path
        pdhStatus = PDH_INVALID_PATH;
    }
    G_FREE(pTempPath);
    return pdhStatus;
}

PDH_FUNCTION
PdhiOpenInputBinaryLog(
    PPDHI_LOG pLog
)
{
    PDH_STATUS                     pdhStatus = ERROR_SUCCESS;
    PPDHI_BINARY_LOG_HEADER_RECORD pHeader;

    pLog->StreamFile = (FILE *) ((DWORD_PTR) (-1));

    // map file header as a memory array for reading

    if ((pLog->hMappedLogFile != NULL) && (pLog->lpMappedFileBase != NULL)) {
        // save size of binary log record header
        pLog->dwRecord1Size = dwFileHeaderLength +          // ID characters
                              2 +                           // quotations
                              PdhidwRecordTerminatorLength; // CR/LF terminator
        pLog->dwRecord1Size = QWORD_MULTIPLE(pLog->dwRecord1Size);

        // read the header and get the option flags
        pHeader = (PPDHI_BINARY_LOG_HEADER_RECORD) ((LPBYTE) (pLog->lpMappedFileBase) + pLog->dwRecord1Size);
        pLog->dwLogFormat |= pHeader->Info.dwFlags;
    }
    else {
        // return PDH Error
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiCloseBinaryLog(
    PPDHI_LOG pLog,
    DWORD     dwFlags
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    BOOL        bStatus;
    LONGLONG    llEndOfFile = 0;
    PPDHI_BINARY_LOG_HEADER_RECORD pHeader;
    BOOL        bNeedToCloseHandles = FALSE;

    UNREFERENCED_PARAMETER (dwFlags);

    // if open for reading, then the file is also mapped as a memory section
    if (pLog->lpMappedFileBase != NULL) {
        // if open for output, get "logical" end of file so it
        // can be truncated to to the amount of file used in order to
        // save disk space
        if ((pLog->dwLogFormat & PDH_LOG_ACCESS_MASK) == PDH_LOG_WRITE_ACCESS) {
            pHeader     = (PPDHI_BINARY_LOG_HEADER_RECORD) ((LPBYTE) (pLog->lpMappedFileBase) + pLog->dwRecord1Size);
            llEndOfFile = pHeader->Info.WrapOffset;
            if (llEndOfFile < pHeader->Info.NextRecordOffset) {
                llEndOfFile = pHeader->Info.NextRecordOffset;
            }
        }

        pdhStatus = UnmapReadonlyMappedFile(pLog->lpMappedFileBase, &bNeedToCloseHandles);
        pLog->lpMappedFileBase = NULL;
        // for mapped files, this is a pointer into the file/memory section
        // so once the view is unmapped, it's no longer valid
        pLog->pLastRecordRead = NULL;
    }
    if (bNeedToCloseHandles) {
        if (pLog->hMappedLogFile != NULL) {
            bStatus               = CloseHandle(pLog->hMappedLogFile);
            pLog->hMappedLogFile  = NULL;
        }
        if (pdhStatus == ERROR_SUCCESS) {
            if (! (FlushFileBuffers(pLog->hLogFileHandle))) {
                pdhStatus = GetLastError();
            }
        }
        else {
            // close them anyway, but save the status from the prev. call
            FlushFileBuffers(pLog->hLogFileHandle);
        }

        // see if we can truncate the file
        if (llEndOfFile > 0) {
            DWORD   dwLoPos, dwHighPos;
            // truncate at the last byte used
            dwLoPos   = LODWORD(llEndOfFile);
            dwHighPos = HIDWORD(llEndOfFile);
            dwLoPos   = SetFilePointer (pLog->hLogFileHandle, dwLoPos, (LONG *) & dwHighPos, FILE_BEGIN);
            if (dwLoPos == 0xFFFFFFFF) {
                pdhStatus = GetLastError ();
            }
            if (pdhStatus == ERROR_SUCCESS) {
                if (! SetEndOfFile(pLog->hLogFileHandle)) {
                    pdhStatus = GetLastError();
                }
            }
        } // else don't know where the end is so continue

        if (pLog->hLogFileHandle != INVALID_HANDLE_VALUE) {
            bStatus              = CloseHandle(pLog->hLogFileHandle);
            pLog->hLogFileHandle = INVALID_HANDLE_VALUE;
        }
    }
    else {
        // the handles have already been closed so just
        // clear their values
        pLog->lpMappedFileBase = NULL;
        pLog->hMappedLogFile   = NULL;
        pLog->hLogFileHandle   = INVALID_HANDLE_VALUE;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumMachinesFromBinaryLog(
    PPDHI_LOG pLog,
    LPVOID    pBuffer,
    LPDWORD   pcchBufferSize,
    BOOL      bUnicodeDest
)
{
    LPVOID  pTempBuffer = NULL;
    LPVOID  pOldBuffer;
    DWORD   dwTempBufferSize;
    LPVOID  LocalBuffer = NULL;
    DWORD   dwLocalBufferSize;

    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    // read the header record and enum the machine name from the entries

    if (pLog->dwMaxRecordSize == 0) {
        // no size is defined so start with 64K
        pLog->dwMaxRecordSize = 0x010000;
    }

    dwTempBufferSize = pLog->dwMaxRecordSize;
    pTempBuffer = G_ALLOC(dwTempBufferSize);
    if (pTempBuffer == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }
    dwLocalBufferSize = MEDIUM_BUFFER_SIZE;
    LocalBuffer       = G_ALLOC(dwLocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
    if (LocalBuffer == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    // read in the catalog record

    while ((pdhStatus = PdhiReadOneBinLogRecord(
                    pLog, BINLOG_HEADER_RECORD, pTempBuffer, dwTempBufferSize)) != ERROR_SUCCESS) {
        if (pdhStatus == PDH_MORE_DATA) {
            // read the 1st WORD to see if this is a valid record
            if (* (WORD *) pTempBuffer == BINLOG_START_WORD) {
                // it's a valid record so read the 2nd DWORD to get the
                // record size;
                dwTempBufferSize = ((DWORD *) pTempBuffer)[1];
                if (dwTempBufferSize < pLog->dwMaxRecordSize) {
                    // then something is bogus so return an error
                    pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
                    break; // out of while loop
                }
                else {
                    pLog->dwMaxRecordSize = dwTempBufferSize;
                }
            }
            else {
                // we're lost in this file
                pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
                break; // out of while loop
            }
            // realloc a new buffer
            pOldBuffer = pTempBuffer;
            pTempBuffer = G_REALLOC(pOldBuffer, dwTempBufferSize);
            if (pTempBuffer == NULL) {
                // return memory error
                G_FREE(pOldBuffer);
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                break;
            }
        }
        else {
            // some other error was returned so
            // return error from read function
            break;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        PPDHI_LOG_COUNTER_PATH  pPath;
        DWORD                   dwBytesProcessed;
        LONG                    nItemCount   = 0;
        LPBYTE                  pFirstChar;
        LPWSTR                  szMachineName;
        DWORD                   dwRecordLength;
        DWORD                   dwBufferUsed = 0;
        DWORD                   dwNewBuffer  = 0;

        // we can assume the record was read successfully so read in the
        // machine names
        dwRecordLength   = ((PPDHI_BINARY_LOG_RECORD_HEADER) pTempBuffer)->dwLength;
        pPath            = (PPDHI_LOG_COUNTER_PATH) ((LPBYTE) pTempBuffer + sizeof(PDHI_BINARY_LOG_HEADER_RECORD));
        dwBytesProcessed = sizeof(PDHI_BINARY_LOG_HEADER_RECORD);

        while (dwBytesProcessed < dwRecordLength) {
            if (pPath->lMachineNameOffset >= 0L) {
                // then there's a machine name in this record so get
                // it's size
                pFirstChar    = (LPBYTE) & pPath->Buffer[0];
                szMachineName = (LPWSTR)((LPBYTE) pFirstChar + pPath->lMachineNameOffset);
                dwNewBuffer   = (lstrlenW (szMachineName) + 1);
                while (dwNewBuffer + dwBufferUsed > dwLocalBufferSize) {
                    pOldBuffer         = LocalBuffer;
                    dwLocalBufferSize += MEDIUM_BUFFER_SIZE;
                    LocalBuffer        = G_REALLOC(pOldBuffer,
                                            dwLocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
                    if (LocalBuffer == NULL) {
                        if (pOldBuffer != NULL) G_FREE(pOldBuffer);
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        goto Cleanup;
                    }
                }
                pdhStatus = AddUniqueWideStringToMultiSz((LPVOID) LocalBuffer,
                                                         szMachineName,
                                                         dwLocalBufferSize - dwBufferUsed,
                                                         & dwNewBuffer,
                                                         bUnicodeDest);
                if (pdhStatus == ERROR_SUCCESS) {
                    if (dwNewBuffer > 0) {
                        dwBufferUsed = dwNewBuffer;
                        nItemCount ++;
                    }
                }
                else {
                    if (pdhStatus == PDH_MORE_DATA) pdhStatus = PDH_INVALID_DATA;
                    goto Cleanup;
                }
            }
            // get next path entry from log file record
            dwBytesProcessed += pPath->dwLength;
            pPath             = (PPDHI_LOG_COUNTER_PATH) ((LPBYTE) pPath + pPath->dwLength);
        }

        if (nItemCount > 0 && pdhStatus != PDH_MORE_DATA) {
            // then the routine was successful. Errors that occurred
            // while scanning will be ignored as long as at least
            // one entry was successfully read
            pdhStatus = ERROR_SUCCESS;
        }

        if (nItemCount > 0) {
            dwBufferUsed ++;
        }
        if (pBuffer && dwBufferUsed <= * pcchBufferSize) {
            RtlCopyMemory(pBuffer, LocalBuffer, dwBufferUsed * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
        }
        else {
            if (pBuffer) {
                RtlCopyMemory(pBuffer,
                              LocalBuffer,
                              (* pcchBufferSize) * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
            }
            pdhStatus = PDH_MORE_DATA;
        }
        * pcchBufferSize = dwBufferUsed;
   }

Cleanup:
   G_FREE(LocalBuffer);
   G_FREE(pTempBuffer);
   return pdhStatus;
}

PDH_FUNCTION
PdhiEnumObjectsFromBinaryLog(
    PPDHI_LOG pLog,
    LPCWSTR   szMachineName,
    LPVOID    pBuffer,
    LPDWORD   pcchBufferSize,
    DWORD     dwDetailLevel,
    BOOL      bUnicodeDest
)
{
    LPVOID      pTempBuffer    = NULL;
    LPVOID      pOldBuffer;
    DWORD       dwTempBufferSize;
    LPVOID      LocalBuffer    = NULL;
    DWORD       dwLocalBufferSize;
    LPCWSTR     szLocalMachine = szMachineName;
    PDH_STATUS  pdhStatus      = ERROR_SUCCESS;
    // read the header record and enum the machine name from the entries

    UNREFERENCED_PARAMETER(dwDetailLevel);

    if (pLog->dwMaxRecordSize == 0) {
        // no size is defined so start with 64K
        pLog->dwMaxRecordSize = 0x010000;
    }

    if (szLocalMachine == NULL)          szLocalMachine = szStaticLocalMachineName;
    else if (szLocalMachine[0] == L'\0') szLocalMachine = szStaticLocalMachineName;

    dwTempBufferSize = pLog->dwMaxRecordSize;
    pTempBuffer = G_ALLOC(dwTempBufferSize);
    if (pTempBuffer == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    dwLocalBufferSize = MEDIUM_BUFFER_SIZE;
    LocalBuffer       = G_ALLOC(dwLocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
    if (LocalBuffer == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    // read in the catalog record

    while ((pdhStatus = PdhiReadOneBinLogRecord(pLog, BINLOG_HEADER_RECORD,
                    pTempBuffer, dwTempBufferSize)) != ERROR_SUCCESS) {
        if (pdhStatus == PDH_MORE_DATA) {
            // read the 1st WORD to see if this is a valid record
            if (* (WORD *) pTempBuffer == BINLOG_START_WORD) {
                // it's a valid record so read the 2nd DWORD to get the
                // record size;
                dwTempBufferSize = ((DWORD *) pTempBuffer)[1];
                if (dwTempBufferSize < pLog->dwMaxRecordSize) {
                    // then something is bogus so return an error
                    pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
                    break; // out of while loop
                }
                else {
                    pLog->dwMaxRecordSize = dwTempBufferSize;
                }
            }
            else {
                // we're lost in this file
                pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
                break; // out of while loop
            }
            // realloc a new buffer
            pOldBuffer  = pTempBuffer;
            pTempBuffer = G_REALLOC(pOldBuffer, dwTempBufferSize);
            if (pTempBuffer == NULL) {
                // return memory error
                G_FREE(pOldBuffer);
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                break;
            }
        }
        else {
            // some other error was returned so
            // return error from read function
            break;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        PPDHI_LOG_COUNTER_PATH  pPath;
        DWORD                   dwBytesProcessed;
        LONG                    nItemCount   = 0;
        LPBYTE                  pFirstChar;
        LPWSTR                  szThisMachineName;
        LPWSTR                  szThisObjectName;
        DWORD                   dwRecordLength;
        DWORD                   dwBufferUsed = 0;
        DWORD                   dwNewBuffer  = 0;
        BOOL                    bCopyThisObject;

        // we can assume the record was read successfully so read in the
        // objects that match the machine name and detail level criteria
        dwRecordLength = ((PPDHI_BINARY_LOG_RECORD_HEADER)pTempBuffer)->dwLength;

        pPath            = (PPDHI_LOG_COUNTER_PATH) ((LPBYTE) pTempBuffer + sizeof(PDHI_BINARY_LOG_HEADER_RECORD));
        dwBytesProcessed = sizeof(PDHI_BINARY_LOG_HEADER_RECORD);

        while (dwBytesProcessed < dwRecordLength) {
            bCopyThisObject  = FALSE;
            szThisObjectName = NULL;
            pFirstChar       = (LPBYTE) & pPath->Buffer[0];

            if (pPath->lMachineNameOffset >= 0L) {
                // then there's a machine name in this record so get
                // it's size
                szThisMachineName = (LPWSTR)((LPBYTE) pFirstChar + pPath->lMachineNameOffset);

                // if this is for the desired machine, then copy this object

                if (lstrcmpiW(szThisMachineName, szLocalMachine) == 0) {
                    if (szThisObjectName >= 0) {
                        szThisObjectName = (LPWSTR)((LPBYTE) pFirstChar + pPath->lObjectNameOffset);
                        bCopyThisObject  = TRUE;
                    }
                    else {
                        // no object to copy
                    }
                }
                else {
                    // this machine isn't selected
                }
            }
            else {
                // there's no machine specified so for this counter so list it by default
                if (szThisObjectName >= 0) {
                    szThisObjectName = (LPWSTR)((LPBYTE) pFirstChar + pPath->lObjectNameOffset);
                    bCopyThisObject  = TRUE;
                }
                else {
                    // no object to copy
                }
            }

            if (bCopyThisObject && szThisObjectName != NULL) {
                // get the size of this object's name
                dwNewBuffer = (lstrlenW(szThisObjectName) + 1);

                while (dwNewBuffer + dwBufferUsed > dwLocalBufferSize) {
                    pOldBuffer         = LocalBuffer;
                    dwLocalBufferSize += MEDIUM_BUFFER_SIZE;
                    LocalBuffer        = G_REALLOC(pOldBuffer,
                                                   dwLocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
                    if (LocalBuffer == NULL) {
                        if (pOldBuffer != NULL) G_FREE(pOldBuffer);
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        goto Cleanup;
                    }
                }
                pdhStatus = AddUniqueWideStringToMultiSz((LPVOID) LocalBuffer,
                                                         szThisObjectName,
                                                         dwLocalBufferSize - dwBufferUsed,
                                                         & dwNewBuffer,
                                                         bUnicodeDest);
                if (pdhStatus == ERROR_SUCCESS) {
                    if (dwNewBuffer > 0) {
                        dwBufferUsed = dwNewBuffer;
                        nItemCount ++;
                    }
                }
                else {
                    if (pdhStatus == PDH_MORE_DATA) pdhStatus = PDH_INVALID_DATA;
                    goto Cleanup;
                }
            }

            // get next path entry from log file record
            dwBytesProcessed += pPath->dwLength;
            pPath = (PPDHI_LOG_COUNTER_PATH) ((LPBYTE)pPath + pPath->dwLength);
        }

        if (nItemCount > 0 && pdhStatus != PDH_MORE_DATA) {
            // then the routine was successful. Errors that occurred
            // while scanning will be ignored as long as at least
            // one entry was successfully read
            pdhStatus = ERROR_SUCCESS;
        }

        if (nItemCount > 0) {
            dwBufferUsed ++;
        }
        if (pBuffer && dwBufferUsed <= * pcchBufferSize) {
            RtlCopyMemory(pBuffer, LocalBuffer, dwBufferUsed * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
        }
        else {
            if (pBuffer) {
                RtlCopyMemory(pBuffer,
                              LocalBuffer,
                              (* pcchBufferSize) * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
            }
            pdhStatus = PDH_MORE_DATA;
        }

        * pcchBufferSize = dwBufferUsed;
   }

Cleanup:
   G_FREE(LocalBuffer);
   G_FREE(pTempBuffer);
   return pdhStatus;
}

PDH_FUNCTION
PdhiEnumObjectItemsFromBinaryLog(
    PPDHI_LOG          pLog,
    LPCWSTR            szMachineName,
    LPCWSTR            szObjectName,
    PDHI_COUNTER_TABLE CounterTable,
    DWORD              dwDetailLevel,
    DWORD              dwFlags
)
{
    LPVOID          pTempBuffer       = NULL;
    LPVOID          pOldBuffer;
    DWORD           dwTempBufferSize;
    PDH_STATUS      pdhStatus         = ERROR_SUCCESS;
    PPDHI_INST_LIST pInstList;
    PPDHI_INSTANCE  pInstance;
    BOOL            bProcessInstance  = FALSE;

    UNREFERENCED_PARAMETER(dwDetailLevel);
    UNREFERENCED_PARAMETER(dwFlags);

    // read the header record and enum the machine name from the entries

    if (pLog->dwMaxRecordSize == 0) {
        // no size is defined so start with 64K
        pLog->dwMaxRecordSize = 0x010000;
    }

    dwTempBufferSize = pLog->dwMaxRecordSize;
    pTempBuffer = G_ALLOC (dwTempBufferSize);
    if (pTempBuffer == NULL) {
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }

    // read in the catalog record

    while ((pdhStatus = PdhiReadOneBinLogRecord(
                        pLog, BINLOG_HEADER_RECORD, pTempBuffer, dwTempBufferSize)) != ERROR_SUCCESS) {
        if (pdhStatus == PDH_MORE_DATA) {
            // read the 1st WORD to see if this is a valid record
            if (* (WORD *) pTempBuffer == BINLOG_START_WORD) {
                // it's a valid record so read the 2nd DWORD to get the
                // record size;
                dwTempBufferSize = ((DWORD *) pTempBuffer)[1];
                if (dwTempBufferSize < pLog->dwMaxRecordSize) {
                    // then something is bogus so return an error
                    pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
                    break; // out of while loop
                }
                else {
                    pLog->dwMaxRecordSize = dwTempBufferSize;
                }
            }
            else {
                // we're lost in this file
                pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
                break; // out of while loop
            }
            // realloc a new buffer
            pOldBuffer  = pTempBuffer;
            pTempBuffer = G_REALLOC(pOldBuffer, dwTempBufferSize);
            if (pTempBuffer == NULL) {
                // return memory error
                G_FREE(pOldBuffer);
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                break;
            }
        }
        else {
            // some other error was returned so
            // return error from read function
            break;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        PPDHI_BINARY_LOG_HEADER_RECORD  pHeader;
        PPDHI_LOG_COUNTER_PATH          pPath;
        PPDHI_BINARY_LOG_RECORD_HEADER  pThisMasterRecord;
        PPDHI_BINARY_LOG_RECORD_HEADER  pThisSubRecord;
        PPDHI_RAW_COUNTER_ITEM_BLOCK    pDataBlock;
        PPDHI_RAW_COUNTER_ITEM          pDataItem;
        DWORD                           dwBytesProcessed;
        LONG                            nItemCount = 0;
        LPBYTE                          pFirstChar;
        LPWSTR                          szThisMachineName;
        LPWSTR                          szThisObjectName;
        LPWSTR                          szThisCounterName = NULL;
        LPWSTR                          szThisInstanceName;
        LPWSTR                          szThisParentName;
        WCHAR                           szCompositeInstance[SMALL_BUFFER_SIZE];
        DWORD                           dwRecordLength;
        BOOL                            bCopyThisObject;
        DWORD                           dwIndex;
        DWORD                           dwThisRecordIndex;
        DWORD                           dwDataItemIndex;
        PLOG_BIN_CAT_RECORD             pCatRec;
        LPWSTR                          szWideInstanceName;

        pHeader =  (PPDHI_BINARY_LOG_HEADER_RECORD) pTempBuffer;

        // we can assume the record was read successfully so read in the
        // objects that match the machine name and detail level criteria
        dwRecordLength = ((PPDHI_BINARY_LOG_RECORD_HEADER) pTempBuffer)->dwLength;

        pPath = (PPDHI_LOG_COUNTER_PATH) ((LPBYTE) pTempBuffer + sizeof(PDHI_BINARY_LOG_HEADER_RECORD));
        dwBytesProcessed = sizeof(PDHI_BINARY_LOG_HEADER_RECORD);
        dwIndex = 0;

        while (dwBytesProcessed < dwRecordLength) {
            bCopyThisObject  = FALSE;
            szThisObjectName = NULL;
            dwIndex ++;
            pFirstChar       = (LPBYTE) & pPath->Buffer[0];

            if (pPath->lMachineNameOffset >= 0L) {
                // then there's a machine name in this record so get
                // it's size
                szThisMachineName = (LPWSTR)((LPBYTE) pFirstChar + pPath->lMachineNameOffset);

                // if this is for the desired machine, then select the object

                if (lstrcmpiW(szThisMachineName,szMachineName) == 0) {
                    if (szThisObjectName >= 0) {
                        szThisObjectName = (LPWSTR)((LPBYTE) pFirstChar + pPath->lObjectNameOffset);
                        if (lstrcmpiW(szThisObjectName,szObjectName) == 0) {
                            // then this is the object to look up
                            bCopyThisObject = TRUE;
                        }
                        else {
                            // not this object
                        }
                    }
                    else {
                        // no object to copy
                    }
                }
                else {
                    // this machine isn't selected
                }
            }
            else {
                // there's no machine specified so for this counter so list it by default
                if (pPath->lObjectNameOffset >= 0) {
                    szThisObjectName = (LPWSTR)((LPBYTE) pFirstChar + pPath->lObjectNameOffset);
                    if (lstrcmpiW(szThisObjectName,szObjectName) == 0) {
                        // then this is the object to look up
                        bCopyThisObject = TRUE;
                    }
                    else {
                        // not this object
                    }
                }
                else {
                    // no object to copy
                }
            }

            if (bCopyThisObject) {
                // if here, then there should be a name
                // get the counter name from this counter and add it to the list
                if (pPath->lCounterOffset > 0) {
                    szThisCounterName = (LPWSTR)((LPBYTE) pFirstChar + pPath->lCounterOffset);
                }
                else {
                    szThisCounterName = NULL;
                    bCopyThisObject = FALSE;
                }
            }

            if (bCopyThisObject) {
                pdhStatus = PdhiFindCounterInstList(CounterTable, szThisCounterName, & pInstList);
                if (pdhStatus != ERROR_SUCCESS || pInstList == NULL) {
                    continue;
                }

                // check instance now
                // get the instance name from this counter and add it to the list
                if (pPath->lInstanceOffset >= 0) {
                    szThisInstanceName = (LPWSTR)((LPBYTE) pFirstChar + pPath->lInstanceOffset);
                    if (* szThisInstanceName != SPLAT_L) {
                        if (pPath->lParentOffset >= 0) {
                            szThisParentName = (LPWSTR)((LPBYTE) pFirstChar + pPath->lParentOffset);
                            StringCchPrintfW(szCompositeInstance, SMALL_BUFFER_SIZE, L"%ws%ws%ws",
                                    szThisParentName, cszSlash, szThisInstanceName);
                        }
                        else {
                            StringCchCopyW(szCompositeInstance, SMALL_BUFFER_SIZE, szThisInstanceName);
                        }

                        //if (pPath->dwIndex > 0) {
                        //    _ltow (pPath->dwIndex, (LPWSTR)
                        //        (szCompositeInstance + lstrlenW(szCompositeInstance)),
                        //        10L);
                        //}

                        pdhStatus = PdhiFindInstance(& pInstList->InstList, szCompositeInstance, TRUE, & pInstance);

                        if (pdhStatus == ERROR_SUCCESS) {
                            nItemCount ++;
                        }
                    }
                    else {
                        // only use the catalog if it's up to date and present
                        if ((pHeader->Info.CatalogOffset > 0) &&
                                        (pHeader->Info.LastUpdateTime <= pHeader->Info.CatalogDate)){
                            // find catalog record
                            pCatRec = (PLOG_BIN_CAT_RECORD)
                                            // base of mapped log file
                                            ((LPBYTE) pLog->lpMappedFileBase +
                                            // + offset to catalog records
                                             pHeader->Info.CatalogOffset +
                                            // + offset to the instance entry for this item
                                             * (LPDWORD) & pPath->Buffer[0]);
                            for (szWideInstanceName = (LPWSTR)((LPBYTE) & pCatRec->CatEntry + pCatRec->CatEntry.dwInstanceStringOffset);
                                     * szWideInstanceName != 0;
                                     szWideInstanceName += lstrlenW(szWideInstanceName) + 1) {
                                 pdhStatus = PdhiFindInstance(
                                                 & pInstList->InstList, szWideInstanceName, TRUE, & pInstance);
                            }
                        }
                        else if (! bProcessInstance) {
                            // look up individual instances in log...
                            // read records from file and store instances

                            dwThisRecordIndex = BINLOG_FIRST_DATA_RECORD;

                            // this call just moved the record pointer
                            pdhStatus = PdhiReadOneBinLogRecord (pLog, dwThisRecordIndex, NULL, 0);
                            while (pdhStatus == ERROR_SUCCESS) {
                                PdhiResetInstanceCount(CounterTable);
                                pThisMasterRecord = (PPDHI_BINARY_LOG_RECORD_HEADER) pLog->pLastRecordRead;
                                // make sure we haven't left the file

                                pThisSubRecord = PdhiGetSubRecord(pThisMasterRecord, dwIndex);
                                if (pThisSubRecord == NULL) {
                                    // bail on a null record
                                    pdhStatus = PDH_END_OF_LOG_FILE;
                                    break;
                                }

                                pDataBlock = (PPDHI_RAW_COUNTER_ITEM_BLOCK) ((LPBYTE) pThisSubRecord +
                                                                             sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
                                // walk down list of entries and add them to the
                                // list of instances (these should already
                                // be assembled in parent/instance format)

                                if (pDataBlock->dwLength > 0) {
                                    for (dwDataItemIndex = 0;
                                                    dwDataItemIndex < pDataBlock->dwItemCount;
                                                    dwDataItemIndex++) {
                                        pDataItem = & pDataBlock->pItemArray[dwDataItemIndex];
                                        szThisInstanceName = (LPWSTR) (((LPBYTE) pDataBlock) + pDataItem->szName);
                                        pdhStatus = PdhiFindInstance(
                                                        & pInstList->InstList, szThisInstanceName, TRUE, & pInstance);
                                    }
                                }
                                else {
                                    // no data in this record
                                }

                                if (pdhStatus != ERROR_SUCCESS) {
                                    // then exit loop, otherwise
                                    break;
                                }
                                else {
                                    // go to next record in log
                                    pdhStatus = PdhiReadOneBinLogRecord(pLog, ++ dwThisRecordIndex, NULL, 0);
                                }
                            }
                            if (pdhStatus == PDH_END_OF_LOG_FILE) {
                                pdhStatus = ERROR_SUCCESS;
                            }
                            if (pdhStatus == ERROR_SUCCESS) {
                                bProcessInstance = TRUE;
                            }
                        }
                    }
                }
                memset(szCompositeInstance, 0, (sizeof(szCompositeInstance)));
            }

            // get next path entry from log file record
            dwBytesProcessed += pPath->dwLength;
            pPath             = (PPDHI_LOG_COUNTER_PATH) ((LPBYTE) pPath + pPath->dwLength);

        }

        if (nItemCount > 0 && pdhStatus != PDH_MORE_DATA) {
            // then the routine was successful. Errors that occurred
            // while scanning will be ignored as long as at least
            // one entry was successfully read
            pdhStatus = ERROR_SUCCESS;
        }
   }
   G_FREE(pTempBuffer);
   return pdhStatus;
}

PDH_FUNCTION
PdhiGetMatchingBinaryLogRecord(
    PPDHI_LOG   pLog,
    LONGLONG  * pStartTime,
    LPDWORD     pdwIndex
)
{
    PDH_STATUS                      pdhStatus     = ERROR_SUCCESS;
    DWORD                           dwRecordId;
    LONGLONG                        RecordTimeValue;
    LONGLONG                        LastTimeValue = 0;
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisMasterRecord;
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisSubRecord;
    PPDHI_RAW_COUNTER_ITEM_BLOCK    pDataBlock;
    PPDH_RAW_COUNTER                pRawItem;

    // read the first data record in the log file
    // note that the record read is not copied to the local buffer
    // rather the internal buffer is used in "read-only" mode

    // if the high dword of the time value is 0xFFFFFFFF, then the
    // low dword is the record id to read

    if ((* pStartTime & 0xFFFFFFFF00000000) == 0xFFFFFFFF00000000) {
        dwRecordId    = (DWORD) (* pStartTime & 0x00000000FFFFFFFF);
        LastTimeValue = *pStartTime;
        if (dwRecordId == 0) return PDH_ENTRY_NOT_IN_LOG_FILE;
    }
    else {
        dwRecordId = BINLOG_FIRST_DATA_RECORD;
    }

    pdhStatus = PdhiReadOneBinLogRecord(pLog, dwRecordId, NULL, 0); // to prevent copying the record

    while ((pdhStatus == ERROR_SUCCESS) && (dwRecordId >= BINLOG_FIRST_DATA_RECORD)) {
        // define pointer to the current record
        pThisMasterRecord = (PPDHI_BINARY_LOG_RECORD_HEADER) pLog->pLastRecordRead;

        // get timestamp of this record by looking at the first entry in the
        // record.
        pThisSubRecord = (PPDHI_BINARY_LOG_RECORD_HEADER)((LPBYTE) pThisMasterRecord +
                                                          sizeof(PDHI_BINARY_LOG_RECORD_HEADER));

        switch (pThisSubRecord->dwType) {
        case BINLOG_TYPE_DATA_SINGLE:
            pRawItem        = (PPDH_RAW_COUNTER)((LPBYTE) pThisSubRecord + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
            RecordTimeValue = MAKELONGLONG(pRawItem->TimeStamp.dwLowDateTime, pRawItem->TimeStamp.dwHighDateTime);
            break;

        case BINLOG_TYPE_DATA_MULTI:
            pDataBlock = (PPDHI_RAW_COUNTER_ITEM_BLOCK)((LPBYTE) pThisSubRecord +
                                                        sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
            RecordTimeValue = * (LONGLONG *) & pDataBlock->TimeStamp;
            break;

        default:
            // unknown record type
            RecordTimeValue = 0;
            break;
        }

        if (RecordTimeValue != 0) {
            if ((*pStartTime == RecordTimeValue) || (*pStartTime == 0)) {
                // found the match so bail here
                LastTimeValue = RecordTimeValue;
                break;

            }
            else if (RecordTimeValue > * pStartTime) {
                // then this is the first record > than the desired time
                // so the desired value is the one before this one
                // unless it's the first data record of the log
                if (dwRecordId > BINLOG_FIRST_DATA_RECORD) {
                    dwRecordId--;
                }
                else {
                    // this hasnt' been initialized yet.
                    LastTimeValue = RecordTimeValue;
                }
                break;
            }
            else {
                // save value for next trip through loop
                LastTimeValue = RecordTimeValue;
                // advance record counter and try the next entry
                dwRecordId ++;
            }
        }
        else {
            // no timestamp field so ignore this record.
            dwRecordId ++;
        }

        // read the next record in the file
        pdhStatus = PdhiReadOneBinLogRecord(pLog, dwRecordId, NULL, 1); // to prevent copying the record
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // then dwRecordId is the desired entry
        * pdwIndex   = dwRecordId;
        * pStartTime = LastTimeValue;
        pdhStatus    = ERROR_SUCCESS;
    }
    else if (dwRecordId < BINLOG_FIRST_DATA_RECORD) {
        // handle special cases for log type field and header record
        * pdwIndex   = dwRecordId;
        * pStartTime = LastTimeValue;
        pdhStatus    = ERROR_SUCCESS;
    }
    else {
        pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiGetCounterFromDataBlock(
    PPDHI_LOG     pLog,
    PVOID         pDataBuffer,
    PPDHI_COUNTER pCounter
);

PDH_FUNCTION
PdhiGetCounterValueFromBinaryLog(
    PPDHI_LOG     pLog,
    DWORD         dwIndex,
    PPDHI_COUNTER pCounter
)
{
    PDH_STATUS       pdhStatus;
    PPDH_RAW_COUNTER pValue = & pCounter->ThisValue;

    // read the first data record in the log file
    // note that the record read is not copied to the local buffer
    // rather the internal buffer is used in "read-only" mode

    pdhStatus = PdhiReadOneBinLogRecord(pLog, dwIndex, NULL, 0);

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiGetCounterFromDataBlock(pLog, pLog->pLastRecordRead, pCounter);
    } else {
        // no more records in log file
        pdhStatus           = PDH_NO_MORE_DATA;
        // unable to find entry in the log file
        pValue->CStatus     = PDH_CSTATUS_INVALID_DATA;
        pValue->TimeStamp.dwLowDateTime = pValue->TimeStamp.dwHighDateTime = 0;
        pValue->FirstValue  = 0;
        pValue->SecondValue = 0;
        pValue->MultiCount  = 1;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiGetTimeRangeFromBinaryLog(
    PPDHI_LOG       pLog,
    LPDWORD         pdwNumEntries,
    PPDH_TIME_INFO  pInfo,
    LPDWORD         pdwBufferSize
)
/*++
    the first entry in the buffer returned is the total time range covered
    in the file, if there are multiple time blocks in the log file, then
    subsequent entries will identify each segment in the file.
--*/
{
    PDH_STATUS                      pdhStatus;
    LONGLONG                        llStartTime    = MAX_TIME_VALUE;
    LONGLONG                        llEndTime      = MIN_TIME_VALUE;
    LONGLONG                        llThisTime     = (LONGLONG) 0;
    DWORD                           dwThisRecord   = BINLOG_FIRST_DATA_RECORD;
    DWORD                           dwValidEntries = 0;
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisMasterRecord;
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisSubRecord;
    PPDHI_RAW_COUNTER_ITEM_BLOCK    pDataBlock;
    PPDH_RAW_COUNTER                pRawItem;

    // read the first data record in the log file
    // note that the record read is not copied to the local buffer
    // rather the internal buffer is used in "read-only" mode

    pdhStatus = PdhiReadOneBinLogRecord(pLog, dwThisRecord, NULL, 0); // to prevent copying the record

    while (pdhStatus == ERROR_SUCCESS) {
        // define pointer to the current record
        pThisMasterRecord = (PPDHI_BINARY_LOG_RECORD_HEADER) pLog->pLastRecordRead;

        // get timestamp of this record by looking at the first entry in the
        // record.
        if ((pThisMasterRecord->dwType & BINLOG_TYPE_DATA) == BINLOG_TYPE_DATA) {
            // only evaluate data records
            pThisSubRecord = (PPDHI_BINARY_LOG_RECORD_HEADER) ((LPBYTE) pThisMasterRecord +
                                                               sizeof(PDHI_BINARY_LOG_RECORD_HEADER));

            switch (pThisSubRecord->dwType) {
            case BINLOG_TYPE_DATA_SINGLE:
                pRawItem   = (PPDH_RAW_COUNTER)((LPBYTE) pThisSubRecord + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
                llThisTime = MAKELONGLONG(pRawItem->TimeStamp.dwLowDateTime, pRawItem->TimeStamp.dwHighDateTime);
                break;

            case BINLOG_TYPE_DATA_MULTI:
                pDataBlock = (PPDHI_RAW_COUNTER_ITEM_BLOCK)((LPBYTE) pThisSubRecord +
                                                             sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
                llThisTime = MAKELONGLONG(pDataBlock->TimeStamp.dwLowDateTime, pDataBlock->TimeStamp.dwHighDateTime);
                break;

            default:
                // unknown record type
                llThisTime = 0;
                break;
            }
        }
        else {
            llThisTime = 0;
        }

        if (llThisTime > 0) {
            if (llThisTime < llStartTime) {
                llStartTime = llThisTime;
            }
            if (llThisTime > llEndTime) {
                llEndTime = llThisTime;
            }

            dwValidEntries ++;
        }
        else {
            // no timestamp field so ignore this record.
        }

        // read the next record in the file
        pdhStatus = PdhiReadOneBinLogRecord(pLog, ++ dwThisRecord, NULL, 0); // to prevent copying the record
    }

    if (pdhStatus == PDH_END_OF_LOG_FILE) {
        // clear out any temp values
        if (llStartTime == MAX_TIME_VALUE) llStartTime = 0;
        if (llEndTime == MIN_TIME_VALUE)   llEndTime   = 0;
        // then the whole file was read so update the args.
        if (* pdwBufferSize >=  sizeof(PDH_TIME_INFO)) {
            * (LONGLONG *) (& pInfo->StartTime) = llStartTime;
            * (LONGLONG *) (& pInfo->EndTime)   = llEndTime;
            pInfo->SampleCount                  = dwValidEntries;
            * pdwBufferSize                     = sizeof(PDH_TIME_INFO);
            * pdwNumEntries                     = 1;
        }
        else {
            pdhStatus = PDH_MORE_DATA;
        }
        pdhStatus = ERROR_SUCCESS;
    }
    else {
        pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiReadRawBinaryLogRecord(
    PPDHI_LOG             pLog,
    FILETIME            * ftRecord,
    PPDH_RAW_LOG_RECORD   pBuffer,
    LPDWORD               pdwBufferLength
)
{
    PDH_STATUS                     pdhStatus = ERROR_SUCCESS;
    LONGLONG                       llStartTime;
    DWORD                          dwIndex   = 0;
    DWORD                          dwSizeRequired;
    DWORD                          dwLocalRecordLength; // including terminating NULL
    PPDHI_BINARY_LOG_RECORD_HEADER pThisMasterRecord;

    llStartTime = * (LONGLONG *) ftRecord;

    pdhStatus = PdhiGetMatchingBinaryLogRecord(pLog, & llStartTime, & dwIndex);

    // copy results from internal log buffer if it'll fit.

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwIndex != BINLOG_TYPE_ID_RECORD) {
            // then record is a Binary log type
            pThisMasterRecord   = (PPDHI_BINARY_LOG_RECORD_HEADER) pLog->pLastRecordRead;
            dwLocalRecordLength = pThisMasterRecord ? pThisMasterRecord->dwLength : 0;

        }
        else {
            // this is a fixed size
            dwLocalRecordLength = pLog->dwRecord1Size;
        }

        dwSizeRequired = sizeof(PDH_RAW_LOG_RECORD) - sizeof (UCHAR) + dwLocalRecordLength;
        if (* pdwBufferLength >= dwSizeRequired) {
            pBuffer->dwRecordType = (DWORD)(LOWORD(pLog->dwLogFormat));
            pBuffer->dwItems = dwLocalRecordLength;
            // copy it
            if (pLog->pLastRecordRead != NULL && dwLocalRecordLength > 0) {
                RtlCopyMemory(& pBuffer->RawBytes[0], pLog->pLastRecordRead, dwLocalRecordLength);
            }
            pBuffer->dwStructureSize = dwSizeRequired;
        }
        else {
            pdhStatus = PDH_MORE_DATA;
        }
        * pdwBufferLength = dwSizeRequired;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiListHeaderFromBinaryLog(
    PPDHI_LOG pLogFile,
    LPVOID    pBufferArg,
    LPDWORD   pcchBufferSize,
    BOOL      bUnicodeDest
)
{
    LPVOID      pTempBuffer = NULL;
    LPVOID      pOldBuffer;
    DWORD       dwTempBufferSize;
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    // read the header record and enum the machine name from the entries

    if (pLogFile->dwMaxRecordSize == 0) {
        // no size is defined so start with 64K
        pLogFile->dwMaxRecordSize = 0x010000;
    }

    dwTempBufferSize = pLogFile->dwMaxRecordSize;
    pTempBuffer = G_ALLOC(dwTempBufferSize);
    if (pTempBuffer == NULL) {
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }

    // read in the catalog record

    while ((pdhStatus = PdhiReadOneBinLogRecord(
                    pLogFile, BINLOG_HEADER_RECORD, pTempBuffer, dwTempBufferSize)) != ERROR_SUCCESS) {
        if (pdhStatus == PDH_MORE_DATA) {
            // read the 1st WORD to see if this is a valid record
            if (* (WORD *) pTempBuffer == BINLOG_START_WORD) {
                // it's a valid record so read the 2nd DWORD to get the
                // record size;
                dwTempBufferSize = ((DWORD *) pTempBuffer)[1];
                if (dwTempBufferSize < pLogFile->dwMaxRecordSize) {
                    // then something is bogus so return an error
                    pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
                    break; // out of while loop
                }
                else {
                    pLogFile->dwMaxRecordSize = dwTempBufferSize;
                }
            }
            else {
                // we're lost in this file
                pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
                break; // out of while loop
            }
            // realloc a new buffer
            pOldBuffer  = pTempBuffer;
            pTempBuffer = G_REALLOC(pOldBuffer, dwTempBufferSize);
            if (pTempBuffer == NULL) {
                // return memory error
                G_FREE(pOldBuffer);
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                break;
            }
        }
        else {
            // some other error was returned so
            // return error from read function
            break;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // walk down list and copy strings to msz buffer
        PPDHI_LOG_COUNTER_PATH          pPath;
        DWORD                           dwBytesProcessed;
        LONG                            nItemCount   = 0;
        LPBYTE                          pFirstChar;
        PDH_COUNTER_PATH_ELEMENTS_W     pdhPathElem;
        WCHAR                           szPathString[1024];
        DWORD                           dwRecordLength;
        DWORD                           dwBufferUsed = 0;
        DWORD                           dwNewBuffer  = 0;

        // we can assume the record was read successfully so read in the
        // machine names
        dwRecordLength = ((PPDHI_BINARY_LOG_RECORD_HEADER)pTempBuffer)->dwLength;

        pPath = (PPDHI_LOG_COUNTER_PATH) ((LPBYTE) pTempBuffer + sizeof(PDHI_BINARY_LOG_HEADER_RECORD));
        dwBytesProcessed = sizeof(PDHI_BINARY_LOG_HEADER_RECORD);

        while (dwBytesProcessed < dwRecordLength) {
            if (pPath->lMachineNameOffset >= 0L) {
                // then there's a machine name in this record so get
                // it's size
                memset(& pdhPathElem, 0, sizeof(pdhPathElem));
                pFirstChar = (LPBYTE) & pPath->Buffer[0];

                if (pPath->lMachineNameOffset >= 0) {
                    pdhPathElem.szMachineName = (LPWSTR) ((LPBYTE) pFirstChar + pPath->lMachineNameOffset);
                }
                if (pPath->lObjectNameOffset >= 0) {
                    pdhPathElem.szObjectName = (LPWSTR) ((LPBYTE) pFirstChar + pPath->lObjectNameOffset);
                }
                if (pPath->lInstanceOffset >= 0) {
                    pdhPathElem.szInstanceName = (LPWSTR) ((LPBYTE) pFirstChar + pPath->lInstanceOffset);
                }
                if (pPath->lParentOffset >= 0) {
                    pdhPathElem.szParentInstance = (LPWSTR) ((LPBYTE) pFirstChar + pPath->lParentOffset);
                }
                if (pPath->dwIndex == 0) {
                    // don't display #0 in path
                    pdhPathElem.dwInstanceIndex = (DWORD) -1;
                }
                else {
                    pdhPathElem.dwInstanceIndex = pPath->dwIndex;
                }
                if (pPath->lCounterOffset >= 0) {
                    pdhPathElem.szCounterName = (LPWSTR) ((LPBYTE) pFirstChar + pPath->lCounterOffset);
                }

                dwNewBuffer = sizeof (szPathString) / sizeof(szPathString[0]);

                pdhStatus = PdhMakeCounterPathW(& pdhPathElem, szPathString, & dwNewBuffer, 0);
                if (pdhStatus == ERROR_SUCCESS) {
                    if (pBufferArg != NULL && (dwBufferUsed + dwNewBuffer + 1) < * pcchBufferSize) {
                        pdhStatus = AddUniqueWideStringToMultiSz((LPVOID) pBufferArg,
                                                                 szPathString,
                                                                 * pcchBufferSize - dwBufferUsed,
                                                                 & dwNewBuffer,
                                                                 bUnicodeDest);
                        if (pdhStatus == ERROR_SUCCESS) {
                            if (dwNewBuffer > 0) {
                                // string was added so update size used.
                                dwBufferUsed = dwNewBuffer;
                                nItemCount ++;
                            }
                        }
                        else if (pdhStatus == PDH_MORE_DATA) {
                            dwBufferUsed += dwNewBuffer;
                            nItemCount ++;
                        }
                    }
                    else {
                        // this one won't fit, so set the status
                        pdhStatus = PDH_MORE_DATA;
                        // and update the size required to return
                        // add size of this string and delimiter to the size required.
                        dwBufferUsed += (dwNewBuffer + 1);
                        nItemCount ++;
                    }
                } // else ignore this entry
            }
            // get next path entry from log file record
            dwBytesProcessed += pPath->dwLength;
            pPath             = (PPDHI_LOG_COUNTER_PATH) ((LPBYTE) pPath + pPath->dwLength);
        }

        if (nItemCount > 0 && pdhStatus != PDH_MORE_DATA) {
            // then the routine was successful. Errors that occurred
            // while scanning will be ignored as long as at least
            // one entry was successfully read
            pdhStatus = ERROR_SUCCESS;
        }

        if (pBufferArg == NULL) {
            // add in size of MSZ null;
            // (AddUnique... already includes this in the return value
            dwBufferUsed ++;
        }

        // update the buffer used or required.
        * pcchBufferSize = dwBufferUsed;

   }

   G_FREE(pTempBuffer);
   return pdhStatus;
}

PDH_FUNCTION
PdhiGetCounterArrayFromBinaryLog(
    PPDHI_LOG                      pLog,
    DWORD                          dwIndex,
    PPDHI_COUNTER                  pCounter,
    PPDHI_RAW_COUNTER_ITEM_BLOCK * ppValue
)
{
    PDH_STATUS                      pdhStatus;
    DWORD                           dwDataItemIndex;
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisMasterRecord;
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisSubRecord;
    PPDHI_RAW_COUNTER_ITEM_BLOCK    pDataBlock;
    PPDHI_RAW_COUNTER_ITEM_BLOCK    pNewArrayHeader;

    // allocate a new array for
    // update counter's Current counter array contents

    // read the first data record in the log file
    // note that the record read is not copied to the local buffer
    // rather the internal buffer is used in "read-only" mode

    pdhStatus = PdhiReadOneBinLogRecord(pLog, dwIndex, NULL, 0); // to prevent copying the record

    if (pdhStatus == ERROR_SUCCESS) {
        // define pointer to the current record
        pThisMasterRecord = (PPDHI_BINARY_LOG_RECORD_HEADER) pLog->pLastRecordRead;

        // get timestamp of this record by looking at the first entry in the
        // record.
        if (pThisMasterRecord->dwType != BINLOG_TYPE_DATA) return PDH_NO_MORE_DATA;

        pThisSubRecord = PdhiGetSubRecord(pThisMasterRecord, pCounter->plCounterInfo.dwCounterId);

        if (pThisSubRecord != NULL) {
            switch (pThisSubRecord->dwType) {
            case BINLOG_TYPE_DATA_SINGLE:
                // return data as one instance
                // for now this isn't supported as it won't be hit.
                //
                break;

            case BINLOG_TYPE_DATA_MULTI:
                // cast pointer to this part of the data record
                pDataBlock = (PPDHI_RAW_COUNTER_ITEM_BLOCK) ((LPBYTE) pThisSubRecord +
                                                             sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
                // allocate a new buffer for the data
                pNewArrayHeader = (PPDHI_RAW_COUNTER_ITEM_BLOCK) G_ALLOC(pDataBlock->dwLength);

                if (pNewArrayHeader != NULL) {
                    // copy the log record to the local buffer
                    RtlCopyMemory(pNewArrayHeader, pDataBlock, pDataBlock->dwLength);
                    // convert offsets to pointers
                    for (dwDataItemIndex = 0;  dwDataItemIndex < pNewArrayHeader->dwItemCount; dwDataItemIndex ++) {
                        // add in the address of the base of the structure
                        // to the offset stored in the field
                        pNewArrayHeader->pItemArray[dwDataItemIndex].szName =
                                        pNewArrayHeader->pItemArray[dwDataItemIndex].szName;
                    }
                    // clear any old buffers
                    if (pCounter->pThisRawItemList != NULL) {
                        G_FREE(pCounter->pThisRawItemList);
                        pCounter->pThisRawItemList = NULL;
                    }
                    pCounter->pThisRawItemList = pNewArrayHeader;
                    * ppValue                  = pNewArrayHeader;
                }
                else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                break;

            default:
                pdhStatus = PDH_LOG_TYPE_NOT_FOUND;
                break;
            }
        }
        else {
            // entry not found in record
            pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
        }
    }
    else {
        // no more records in log file
        pdhStatus = PDH_NO_MORE_DATA;
    }
    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhlog\log_sql.c ===
/*++
Copyright (C) 1996-1999 Microsoft Corporation

Module Name:
    log_SQL.c

Abstract:
    <abstract>
--*/

#include <windows.h>
//#include <stdio.h>
//#include <stdlib.h>
#include <mbctype.h>
#include <strsafe.h>
#include <pdh.h>
#include "strings.h"
#include <pdhmsg.h>
#include "pdhidef.h"

#include <sql.h>
#include <odbcss.h>
// pragma to supress /W4 errors
#pragma warning ( disable : 4201 )
#include <sqlext.h>
#pragma warning ( default : 4201 )

#include "log_SQL.h"
#include "log_bin.h" // to get the binary log file record formatting

#pragma warning ( disable : 4213)

#define TIME_FIELD_BUFF_SIZE           24
#define TIMEZONE_BUFF_SIZE             32
#define PDH_SQL_BULK_COPY_REC        2048
#define SQL_COUNTER_ID_SIZE            12
#define SQLSTMTSIZE                  4096
#define INITIAL_MSZ_SIZE             1024
#define MSZ_SIZE_ADDON               1024
#define MULTI_COUNT_DOUBLE_RAW 0xFFFFFFFF

#define ALLOC_CHECK(pB)       if (NULL == pB) { return PDH_MEMORY_ALLOCATION_FAILURE; }
#define ALLOC_CHECK_HSTMT(pB) if (NULL == pB) { SQLFreeStmt(hstmt, SQL_DROP); return PDH_MEMORY_ALLOCATION_FAILURE; }
#define SQLSUCCEEDED(rc) (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO || rc == SQL_NO_DATA)

#define ReportSQLError(pLog, SQL_ERROR, NULL, Status) PdhiReportSQLError(pLog, SQL_ERROR, NULL, Status, __LINE__)

typedef struct _PDH_SQL_BULK_COPY {
    GUID   dbGuid;
    INT    dbCounterId;
    INT    dbRecordIndex;
    CHAR   dbDateTime[TIME_FIELD_BUFF_SIZE];
    double dbCounterValue;
    INT    dbFirstValueA;
    INT    dbFirstValueB;
    INT    dbSecondValueA;
    INT    dbSecondValueB;
    INT    dbMultiCount;
    DWORD  dwRecordCount;
} PDH_SQL_BULK_COPY, * PPDH_SQL_BULK_COPY;

typedef struct _PDHI_SQL_LOG_DATA PDHI_SQL_LOG_DATA, * PPDHI_SQL_LOG_DATA;
struct _PDHI_SQL_LOG_DATA {
    PDH_RAW_COUNTER    RawData;
    DOUBLE             dFormattedValue;
    DWORD              dwRunId;
};

typedef struct _PDHI_SQL_LOG_INFO {
    PPDHI_LOG_MACHINE    MachineList;
    PPDHI_SQL_LOG_DATA * LogData;
    FILETIME             RecordTime;
    DWORD                dwRunId;
    DWORD                dwMaxCounter;
    DWORD                dwMinCounter;
} PDHI_SQL_LOG_INFO, * PPDHI_SQL_LOG_INFO;


/* external functions */
BOOL __stdcall
IsValidLogHandle(
    HLOG hLog
);

/* forward declares */
PDH_FUNCTION
PdhpGetSQLLogHeader(
    PPDHI_LOG pLog
);

PDH_FUNCTION
PdhpWriteSQLCounters(
    PPDHI_LOG   pLog
);

BOOL __stdcall
PdhpConvertFileTimeToSQLString(
    FILETIME * pFileTime,
    LPWSTR     szStartDate,
    DWORD      dwStartDate
)
{
    //1998-01-02 12:00:00.000
    SYSTEMTIME  st;
    BOOL        bReturn = FALSE;

    if (FileTimeToSystemTime(pFileTime, & st)) {
        StringCchPrintfW(szStartDate, dwStartDate, L"%04d-%02d-%02d %02d:%02d:%02d.%03d",
                        st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
        bReturn = TRUE;
    }
    return bReturn;
}

BOOL __stdcall
PdhpConvertSQLStringToFileTime(
    LPWSTR      szStartDate,
    FILETIME  * pFileTime
)   //           1111111111222
{   // 01234567890123456789012
    // 1998-01-02 12:00:00.000

    SYSTEMTIME   st;
    WCHAR        buffer[TIME_FIELD_BUFF_SIZE];
    WCHAR      * pwchar;

    ZeroMemory(buffer, sizeof(WCHAR) * TIME_FIELD_BUFF_SIZE);
    StringCchCopyW(buffer, TIME_FIELD_BUFF_SIZE, szStartDate);
    buffer[4]        = L'\0';
    st.wYear         = (WORD) _wtoi(buffer);
    pwchar           = & (buffer[5]);
    buffer[7]        = L'\0';
    st.wMonth        = (WORD) _wtoi(pwchar);
    pwchar           = & (buffer[8]);
    buffer[10]       = L'\0';
    st.wDay          = (WORD) _wtoi(pwchar);
    pwchar           = & (buffer[11]);
    buffer[13]       = L'\0';
    st.wHour         = (WORD) _wtoi(pwchar);
    pwchar           = & (buffer[14]);
    buffer[16]       = L'\0';
    st.wMinute       = (WORD) _wtoi(pwchar);
    pwchar           = & (buffer[17]);
    buffer[19]       = L'\0';
    st.wSecond       = (WORD) _wtoi(pwchar);
    pwchar           = & (buffer[20]);
    st.wMilliseconds = (WORD) _wtoi(pwchar);
    st.wDayOfWeek    = 0;

    return SystemTimeToFileTime(& st, pFileTime);
}

LPWSTR __stdcall
PdhpGetNextMultisz(
    LPWSTR mszSource
)
{
    // get the next string in a multisz
    LPVOID  szDestElem;

    szDestElem = mszSource;
    szDestElem = (LPVOID) ((LPWSTR) szDestElem + (lstrlenW((LPCWSTR) szDestElem) + 1));
    return ((LPWSTR) szDestElem);
}

PPDH_SQL_BULK_COPY
PdhiBindBulkCopyStructure(
    PPDHI_LOG   pLog
)
{
    PDH_STATUS         Status = ERROR_SUCCESS;
    PPDH_SQL_BULK_COPY pBulk  = (PPDH_SQL_BULK_COPY) pLog->lpMappedFileBase;
    RETCODE            rc;

    if (pBulk != NULL) return pBulk;

    pBulk = G_ALLOC(sizeof(PDH_SQL_BULK_COPY));
    if (pBulk != NULL) {
        pLog->lpMappedFileBase = pBulk;
        pBulk->dbGuid          = pLog->guidSQL;
        pBulk->dwRecordCount   = 0;

        rc = bcp_initW(pLog->hdbcSQL, L"CounterData", NULL, NULL, DB_IN);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }
        rc = bcp_bind(pLog->hdbcSQL, (LPCBYTE) & (pBulk->dbGuid), 0, sizeof(GUID), NULL, 0, SQLUNIQUEID, 1);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }
        rc = bcp_bind(pLog->hdbcSQL, (LPCBYTE) & (pBulk->dbCounterId), 0, sizeof(INT), NULL, 0, SQLINT4, 2);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }
        rc = bcp_bind(pLog->hdbcSQL, (LPCBYTE) & (pBulk->dbRecordIndex), 0, sizeof(INT), NULL, 0, SQLINT4, 3);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }
        rc = bcp_bind(pLog->hdbcSQL, (LPCBYTE) (pBulk->dbDateTime), 0, 24, NULL, 0, SQLCHARACTER, 4);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }
        rc = bcp_bind(pLog->hdbcSQL, (LPCBYTE) & (pBulk->dbCounterValue), 0, sizeof(double), NULL, 0, SQLFLT8, 5);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }
        rc = bcp_bind(pLog->hdbcSQL, (LPCBYTE) & (pBulk->dbFirstValueA), 0, sizeof(INT), NULL, 0, SQLINT4, 6);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }
        rc = bcp_bind(pLog->hdbcSQL, (LPCBYTE) & (pBulk->dbFirstValueB), 0, sizeof(INT), NULL, 0, SQLINT4, 7);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }
        rc = bcp_bind(pLog->hdbcSQL, (LPCBYTE) & (pBulk->dbSecondValueA), 0, sizeof(INT), NULL, 0, SQLINT4, 8);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }
        rc = bcp_bind(pLog->hdbcSQL, (LPCBYTE) & (pBulk->dbSecondValueB), 0, sizeof(INT), NULL, 0, SQLINT4, 9);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }
        rc = bcp_bind(pLog->hdbcSQL, (LPCBYTE) & (pBulk->dbMultiCount), 0, sizeof(INT), NULL, 0, SQLINT4, 10);
        if (rc == FAIL) {
            Status = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }
    }
    else {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
    }

Cleanup:
    if (Status != ERROR_SUCCESS) {
        G_FREE(pBulk);
        pBulk  = pLog->lpMappedFileBase = NULL;
        Status = ReportSQLError(pLog, SQL_ERROR, NULL, Status);
        SetLastError(Status);
    }
    return pBulk;
}

PDH_FUNCTION
PdhiSqlUpdateCounterDetails(
    PPDHI_LOG         pLog,
    BOOL              bBeforeSendRow,
    PPDHI_LOG_MACHINE pMachine,
    PPDHI_LOG_OBJECT  pObject,
    PPDHI_LOG_COUNTER pCounter,
    LONGLONG          TimeBase,
    LPWSTR            szMachine,
    LPWSTR            szObject,
    LPWSTR            szCounter,
    DWORD             dwCounterType,
    DWORD             dwDefaultScale,
    LPWSTR            szInstance,
    DWORD             dwInstance,
    LPWSTR            szParent,
    DWORD             dwParent
)
{
    PDH_STATUS         Status    = ERROR_SUCCESS;
    HSTMT              hstmt     = NULL;
    RETCODE            rc;
    LPWSTR             szSQLStmt = NULL;
    DWORD              dwSQLStmt = 0;
    DWORD              dwCounterId;
    SQLLEN             dwCounterIdLen;
    SQLLEN             dwRowCount;
    PPDH_SQL_BULK_COPY pBulk     = (PPDH_SQL_BULK_COPY) pLog->lpMappedFileBase;

    if (! bBeforeSendRow) {
        if (pBulk != NULL && pBulk->dwRecordCount > 0) {
            DBINT rcBCP = bcp_batch(pLog->hdbcSQL);
            if (rcBCP < 0) {
                TRACE((PDH_DBG_TRACE_ERROR),
                      (__LINE__,
                       PDH_LOGSQL,
                       0,
                       PDH_SQL_EXEC_DIRECT_FAILED,
                       TRACE_DWORD(rcBCP),
                       TRACE_DWORD(pBulk->dwRecordCount),
                       NULL));
                ReportSQLError(pLog, SQL_ERROR, NULL, PDH_SQL_EXEC_DIRECT_FAILED);
            }
            pBulk->dwRecordCount = 0;
        }
    }

    dwSQLStmt = MAX_PATH + lstrlenW(szMachine) + lstrlenW(szObject) + lstrlenW(szCounter);
    if (szInstance != NULL) dwSQLStmt += lstrlenW(szInstance);
    if (szParent != NULL)   dwSQLStmt += lstrlenW(szParent);

    if (dwSQLStmt < SQLSTMTSIZE) dwSQLStmt  = SQLSTMTSIZE;

    szSQLStmt = G_ALLOC(dwSQLStmt * sizeof(WCHAR));
    if (szSQLStmt == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }
    rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }

    // need to cover the following cases where 0 = NULL, 1 = present,
    // can't have an Instance Index without an Instance Name
    //
    // Instance Name
    //  Instance Index
    //   Parent Name
    //    Parent Object ID
    // 0000
    // 1000  pos 4 & 5 are countertype,defscale
    // 0010
    // 0001
    // 1100
    // 1010
    // 1001
    // 0011
    // 1110
    // 1101
    // 1011
    // 1111
    //
    if ((szInstance == NULL || szInstance[0] == L'\0') && dwInstance == 0
                    && (szParent == NULL || szParent[0] == L'\0') && dwParent == 0) {
        StringCchPrintfW(szSQLStmt, dwSQLStmt, // 0000
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws',%d,%d,NULL,NULL,NULL,NULL,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale,
                LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else if ((szInstance != NULL && szInstance[0] != '\0') && dwInstance == 0
                    && (szParent == NULL || szParent[0] == '\0') && dwParent == 0) {
        StringCchPrintfW(szSQLStmt, dwSQLStmt, // 1000
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws',%d,%d,'%ws',NULL,NULL,NULL,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale, szInstance,
                LODWORD(TimeBase), HIDWORD(TimeBase));

    }
    else if ((szInstance == NULL || szInstance[0] == '\0') && dwInstance == 0
                    && (szParent != NULL && szParent[0] != '\0') && dwParent == 0) {
        StringCchPrintfW(szSQLStmt, dwSQLStmt, // 0010
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws',%d,%d,NULL,NULL,'%ws',NULL,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale, szParent,
                LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else if ((szInstance == NULL || szInstance[0] == '\0') && dwInstance == 0
                    && (szParent == NULL || szParent[0] == '\0') && dwParent != 0) {
        StringCchPrintfW(szSQLStmt, dwSQLStmt, // 0001
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws',%d,%d,NULL,NULL,NULL,%d,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale, dwParent,
                LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else if ((szInstance != NULL && szInstance[0] != '\0') && dwInstance != 0
                    && (szParent == NULL || szParent[0] == '\0') && dwParent == 0) {
        StringCchPrintfW(szSQLStmt, dwSQLStmt, // 1100
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws',%d,%d,'%ws',%d,NULL,NULL,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale, szInstance, dwInstance,
                LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else if ((szInstance != NULL && szInstance[0] != '\0') && dwInstance == 0
                    && (szParent != NULL && szParent[0] != '\0') && dwParent == 0) {
        StringCchPrintfW(szSQLStmt, dwSQLStmt, // 1010
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws',%d,%d,'%ws',NULL,'%ws',NULL,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale, szInstance, szParent,
                LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else if ((szInstance != NULL && szInstance[0] != '\0') && dwInstance == 0
                    && (szParent == NULL || szParent[0] == '\0') && dwParent != 0) {
        StringCchPrintfW(szSQLStmt, dwSQLStmt, // 1001
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws',%d,%d,'%ws',NULL,NULL,%d,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale, szInstance, dwParent,
                LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else if ((szInstance == NULL || szInstance[0] == '\0') && dwInstance == 0
                    && (szParent != NULL && szParent[0] != '\0') && dwParent != 0) {
        StringCchPrintfW(szSQLStmt, dwSQLStmt, // 0011
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws',%d,%d,NULL,NULL,'%ws',%d,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale, szParent, dwParent,
                LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else if ((szInstance != NULL && szInstance[0] != '\0') && dwInstance != 0
                    && (szParent != NULL && szParent[0] != '\0') && dwParent == 0) {
        StringCchPrintfW(szSQLStmt, dwSQLStmt, // 1110
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws',%d,%d,'%ws',%d,'%ws',NULL,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale, szInstance, dwInstance, szParent,
                LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else if ((szInstance != NULL && szInstance[0] != '\0') && dwInstance != 0
                    && (szParent == NULL || szParent[0] == '\0') && dwParent != 0) {
        StringCchPrintfW(szSQLStmt, dwSQLStmt, //1101
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws',%d,%d,'%ws',%d,NULL,%d,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale, szInstance, dwInstance, dwParent,
                LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else if ((szInstance != NULL && szInstance[0] != '\0') && dwInstance == 0
                    && (szParent != NULL && szParent[0] != '\0') && dwParent != 0) {
        StringCchPrintfW(szSQLStmt, dwSQLStmt, // 1011
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws',%d,%d,'%ws',NULL,'%ws',%d,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale, szInstance, szParent, dwParent,
                LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else if ((szInstance != NULL && szInstance[0] != '\0') && dwInstance != 0
                    && (szParent != NULL && szParent[0] != '\0') && dwParent != 0) {
        StringCchPrintfW(szSQLStmt, dwSQLStmt, // 1111
            L"begin transaction AddCounterDetails insert into CounterDetails values ('%ws','%ws','%ws',%d,%d,'%ws',%d,'%ws',%d,%d,%d) Select @@Identity commit transaction AddCounterDetails",
                szMachine, szObject, szCounter, dwCounterType, dwDefaultScale,
                szInstance, dwInstance, szParent, dwParent,
                LODWORD(TimeBase), HIDWORD(TimeBase));
    }
    else {
        Status = PDH_INVALID_ARGUMENT;
        goto Cleanup;
    }

    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
        goto Cleanup;
    }
    rc = SQLRowCount(hstmt, & dwRowCount);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ROWCOUNT_FAILED);
        goto Cleanup;
    }
    rc = SQLMoreResults(hstmt);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_MORE_RESULTS_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 1, SQL_C_SLONG, & dwCounterId, 0, & dwCounterIdLen);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLFetch(hstmt);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_FETCH_FAILED);
        goto Cleanup;
    }
    if (SQL_NO_DATA == rc) {
        Status = PDH_NO_DATA;
        goto Cleanup;
    }
    if (pCounter != NULL) {
        pCounter->dwCounterID = dwCounterId;
    }

Cleanup:
    if (hstmt != NULL) SQLFreeStmt(hstmt, SQL_DROP);
    G_FREE(szSQLStmt);
    return Status;
}

PPDHI_LOG_COUNTER
PdhiSqlFindCounter(
    PPDHI_LOG           pLog,
    PPDHI_LOG_MACHINE * MachineTable,
    LPWSTR              szMachine,
    LPWSTR              szObject,
    LPWSTR              szCounter,
    DWORD               dwCounterType,
    DWORD               dwDefaultScale,
    LPWSTR              szInstance,
    DWORD               dwInstance,
    LPWSTR              szParent,
    DWORD               dwParent,
    LONGLONG            TimeBase,
    BOOL                bBeforeSendRow,
    BOOL                bInsert
)
{
    PPDHI_LOG_MACHINE   pMachine = NULL;
    PPDHI_LOG_OBJECT    pObject  = NULL;
    PPDHI_LOG_COUNTER   pCounter = NULL;
    PPDHI_LOG_COUNTER   pNode    = NULL;
    PPDHI_LOG_COUNTER * pStack[MAX_BTREE_DEPTH];
    PPDHI_LOG_COUNTER * pLink;
    int                 dwStack = 0;
    PPDHI_LOG_COUNTER   pParent;
    PPDHI_LOG_COUNTER   pSibling;
    PPDHI_LOG_COUNTER   pChild;
    int                 iCompare;
    BOOL                bUpdateCounterDetail = FALSE;
    WCHAR               szTmp[PDH_SQL_STRING_SIZE];

    ZeroMemory(szTmp, PDH_SQL_STRING_SIZE * sizeof(WCHAR));
    StringCchCopyW(szTmp, PDH_SQL_STRING_SIZE, szMachine);
    for (pMachine = (* MachineTable);
                     (pMachine != NULL) && lstrcmpiW(pMachine->szMachine, szTmp) != 0;
                     pMachine = pMachine->next);
    if (pMachine == NULL) {
        pMachine = G_ALLOC(sizeof(PDHI_LOG_MACHINE) + (PDH_SQL_STRING_SIZE + 1) * sizeof(WCHAR));
        if (pMachine == NULL) goto Cleanup;

        pMachine->szMachine = (LPWSTR) (((PCHAR) pMachine) + sizeof(PDHI_LOG_MACHINE));
        StringCchCopyW(pMachine->szMachine, PDH_SQL_STRING_SIZE, szMachine);
        pMachine->ObjTable  = NULL;
        pMachine->next      = (* MachineTable);
        * MachineTable      = pMachine;
    }

    pObject = PdhiFindLogObject(pMachine, & (pMachine->ObjTable), szObject, TRUE);
    if (pObject == NULL) goto Cleanup;

    pStack[dwStack ++] = & (pObject->CtrTable);
    pCounter = pObject->CtrTable;
    while (pCounter != NULL) {
        iCompare = PdhiCompareLogCounterInstance(pCounter, szCounter, szInstance, dwInstance, szParent);
        if (iCompare == 0) {
            if (dwCounterType < pCounter->dwCounterType) {
                iCompare = -1;
            }
            else if (dwCounterType > pCounter->dwCounterType) {
                iCompare = 1;
            }
            else {
                iCompare = 0;
            }
        }
        if (iCompare < 0) {
            pStack[dwStack ++] = & (pCounter->left);
            pCounter = pCounter->left;
        }
        else if (iCompare > 0) {
            pStack[dwStack ++] = & (pCounter->right);
            pCounter = pCounter->right;
        }
        else {
            break;
        }
    }

    if (pCounter == NULL) {
        pCounter = G_ALLOC(sizeof(PDHI_LOG_COUNTER) + 3 * sizeof(WCHAR) * (PDH_SQL_STRING_SIZE + 1));
        if (pCounter == NULL) goto Cleanup;

        pCounter->next           = pObject->CtrList;
        pObject->CtrList         = pCounter;
        pCounter->bIsRed         = TRUE;
        pCounter->left           = NULL;
        pCounter->right          = NULL;
        pCounter->dwCounterType  = dwCounterType;
        pCounter->dwDefaultScale = dwDefaultScale;
        pCounter->dwInstance     = dwInstance;
        pCounter->dwParent       = dwParent;
        pCounter->TimeStamp      = 0;
        pCounter->TimeBase       = TimeBase;
        pCounter->szCounter      = (LPWSTR) (((PCHAR) pCounter) + sizeof(PDHI_LOG_COUNTER));
        StringCchCopyW(pCounter->szCounter, PDH_SQL_STRING_SIZE, szCounter);
        if (szInstance == NULL || szInstance[0] == L'\0') {
            pCounter->szInstance = NULL;
        }
        else {
            pCounter->szInstance = (LPWSTR) (((PCHAR) pCounter) + sizeof(PDHI_LOG_COUNTER)
                                 + sizeof(WCHAR) * (PDH_SQL_STRING_SIZE + 1));
            StringCchCopyW(pCounter->szInstance, PDH_SQL_STRING_SIZE, szInstance);
        }
        if (szParent == NULL || szParent[0] == L'\0') {
            pCounter->szParent = NULL;
        }
        else {
            pCounter->szParent = (LPWSTR) (((PCHAR) pCounter) + sizeof(PDHI_LOG_COUNTER)
                                   + 2 * sizeof(WCHAR) * (PDH_SQL_STRING_SIZE + 1));
            StringCchCopyW(pCounter->szParent, PDH_SQL_STRING_SIZE, szParent);
        }

        if (bInsert) {
            bUpdateCounterDetail = TRUE;
        }

        pLink   = pStack[-- dwStack];
        * pLink = pCounter;
        pChild  = NULL;
        pNode   = pCounter;
        while (dwStack > 0) {
            pLink   = pStack[-- dwStack];
            pParent = * pLink;
            if (! pParent->bIsRed) {
                pSibling = (pParent->left == pNode)
                         ? pParent->right : pParent->left;
                if (pSibling && pSibling->bIsRed) {
                    pNode->bIsRed    = FALSE;
                    pSibling->bIsRed = FALSE;
                    pParent->bIsRed  = TRUE;
                }
                else {
                    if (pChild && pChild->bIsRed) {
                        if (pChild == pNode->left) {
                            if (pNode == pParent->left) {
                                pParent->bIsRed  = TRUE;
                                pParent->left    = pNode->right;
                                pNode->right     = pParent;
                                pNode->bIsRed    = FALSE;
                                * pLink          = pNode;
                            }
                            else {
                                pParent->bIsRed  = TRUE;
                                pParent->right   = pChild->left;
                                pChild->left     = pParent;
                                pNode->left      = pChild->right;
                                pChild->right    = pNode;
                                pChild->bIsRed   = FALSE;
                                * pLink          = pChild;
                            }
                        }
                        else {
                            if (pNode == pParent->right) {
                                pParent->bIsRed  = TRUE;
                                pParent->right   = pNode->left;
                                pNode->left      = pParent;
                                pNode->bIsRed    = FALSE;
                                * pLink          = pNode;
                            }
                            else {
                                pParent->bIsRed  = TRUE;
                                pParent->left    = pChild->right;
                                pChild->right    = pParent;
                                pNode->right     = pChild->left;
                                pChild->left     = pNode;
                                pChild->bIsRed   = FALSE;
                                * pLink          = pChild;
                            }
                        }
                    }
                    break;
                }
            }
            pChild = pNode;
            pNode  = pParent;
        }
        pObject->CtrTable->bIsRed = FALSE;
    }

    if (bUpdateCounterDetail && pCounter) {
        PdhiSqlUpdateCounterDetails(pLog,
                                    bBeforeSendRow,
                                    pMachine,
                                    pObject,
                                    pCounter,
                                    pCounter->TimeBase,
                                    pMachine->szMachine,
                                    pObject->szObject,
                                    pCounter->szCounter,
                                    dwCounterType,
                                    dwDefaultScale,
                                    pCounter->szInstance,
                                    dwInstance,
                                    pCounter->szParent,
                                    dwParent);
    }

Cleanup:
    return pCounter;
}

PDH_FUNCTION
PdhiSqlBuildCounterObjectNode(
    PPDHI_LOG          pLog,
    LPWSTR             szMachine,
    LPWSTR             szObject
)
{
    PDH_STATUS        Status           = ERROR_SUCCESS;
    RETCODE           rc               = SQL_SUCCESS;
    HSTMT             hstmt            = NULL;
    DWORD             CounterID        = 0;
    SQLLEN            dwCounterID      = 0;
    LPWSTR            CounterName      = NULL;
    SQLLEN            dwCounterName    = 0;
    DWORD             CounterType      = 0;
    SQLLEN            dwCounterType    = 0;
    DWORD             DefaultScale     = 0;
    SQLLEN            dwDefaultScale   = 0;
    LPWSTR            InstanceName     = NULL;
    SQLLEN            dwInstanceName   = 0;
    DWORD             InstanceIndex    = 0;
    SQLLEN            dwInstanceIndex  = 0;
    LPWSTR            ParentName       = NULL;
    SQLLEN            dwParentName     = 0;
    DWORD             ParentObjectID   = 0;
    SQLLEN            dwParentObjectID = 0;
    LARGE_INTEGER     lTimeBase;
    SQLLEN            dwTimeBaseA      = 0;
    SQLLEN            dwTimeBaseB      = 0;
    LPWSTR            SQLStmt          = NULL;
    DWORD             dwSQLStmt        = 0;
    BOOL              bFind            = FALSE;
    PPDHI_LOG_OBJECT  pObject          = NULL;
    PPDHI_LOG_MACHINE pMachine;
    PPDHI_LOG_COUNTER pCounter;

    CounterName = (LPWSTR) G_ALLOC(3 * PDH_SQL_STRING_SIZE * sizeof(WCHAR));
    if (CounterName == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }
    InstanceName = CounterName  + PDH_SQL_STRING_SIZE;
    ParentName   = InstanceName + PDH_SQL_STRING_SIZE;

    for (pMachine  = ((PPDHI_LOG_MACHINE) (pLog->pPerfmonInfo));
         pMachine != NULL && lstrcmpiW(pMachine->szMachine, szMachine) != 0;
         pMachine  = pMachine->next);

    if (pMachine != NULL) {
        pObject = pMachine->ObjTable;
        while (pObject != NULL) {
            int iCompare = lstrcmpiW(szObject, pObject->szObject);
            if (iCompare < 0)      pObject = pObject->left;
            else if (iCompare > 0) pObject = pObject->right;
            else break;
        }
    }
    if (pObject != NULL) goto Cleanup;

    dwSQLStmt = MAX_PATH + lstrlenW(szMachine) + lstrlenW(szObject);
    if (dwSQLStmt < SQLSTMTSIZE) dwSQLStmt = SQLSTMTSIZE;
    SQLStmt = G_ALLOC(dwSQLStmt * sizeof(WCHAR));
    if (SQLStmt == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    StringCchPrintfW(SQLStmt, dwSQLStmt,
              L"select CounterID, CounterName, CounterType, DefaultScale, InstanceName, InstanceIndex, ParentName, ParentObjectID, TimeBaseA, TimeBaseB from CounterDetails where MachineName = '%ws' and ObjectName = '%ws'",
              szMachine, szObject);

    rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 1, SQL_C_LONG, & CounterID, 0, & dwCounterID);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 2, SQL_C_WCHAR, CounterName, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwCounterName);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 3, SQL_C_LONG, & CounterType, 0, & dwCounterType);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 4, SQL_C_LONG, & DefaultScale, 0, & dwDefaultScale);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 5, SQL_C_WCHAR, InstanceName, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwInstanceName);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 6, SQL_C_LONG, & InstanceIndex, 0, & dwInstanceIndex);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 7, SQL_C_WCHAR, ParentName, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwParentName);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 8, SQL_C_LONG, & ParentObjectID, 0, & dwParentObjectID);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 9, SQL_C_LONG, & lTimeBase.LowPart, 0, & dwTimeBaseA);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 10, SQL_C_LONG, & lTimeBase.HighPart, 0, & dwTimeBaseB);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    rc = SQLExecDirectW(hstmt, SQLStmt, SQL_NTS);
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
        goto Cleanup;
    }

    CounterType = DefaultScale = InstanceIndex = ParentObjectID = 0;
    rc = SQLFetch(hstmt);
    while (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO) {
        pCounter = PdhiSqlFindCounter(pLog,
                                      (PPDHI_LOG_MACHINE *) (& (pLog->pPerfmonInfo)),
                                      szMachine,
                                      szObject,
                                      CounterName,
                                      CounterType,
                                      DefaultScale,
                                      InstanceName,
                                      InstanceIndex,
                                      ParentName,
                                      ParentObjectID,
                                      0,
                                      TRUE,
                                      FALSE);
        if (pCounter != NULL) {
            pCounter->dwCounterID = CounterID;
            if (dwTimeBaseA != SQL_NULL_DATA && dwTimeBaseB != SQL_NULL_DATA) {
                pCounter->TimeBase = lTimeBase.QuadPart;
            }
            else {
                pCounter->TimeBase      = 0;
                pCounter->dwCounterType = PERF_DOUBLE_RAW;
            }
        }
        ZeroMemory(CounterName,  PDH_SQL_STRING_SIZE * sizeof(WCHAR));
        ZeroMemory(InstanceName, PDH_SQL_STRING_SIZE * sizeof(WCHAR));
        ZeroMemory(ParentName,   PDH_SQL_STRING_SIZE * sizeof(WCHAR));
        CounterType = DefaultScale = InstanceIndex = ParentObjectID = 0;
        rc = SQLFetch(hstmt);
    }
    if (! SQLSUCCEEDED(rc)) {
        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_FETCH_FAILED);
        goto Cleanup;
    }

Cleanup:
    if (hstmt != NULL) SQLFreeStmt(hstmt, SQL_DROP);
    G_FREE(SQLStmt);
    G_FREE(CounterName);
    return Status;
}

PDH_FUNCTION
PdhiSqlGetCounterArray(
    PPDHI_COUNTER  pCounter,
    LPDWORD        lpdwBufferSize,
    LPDWORD        lpdwItemCount,
    LPVOID         ItemBuffer
)
{
    PDH_STATUS                    Status          = ERROR_SUCCESS;
    PDH_STATUS                    PdhFnStatus     = ERROR_SUCCESS;
    DWORD                         dwRequiredSize  = 0;
    PPDHI_RAW_COUNTER_ITEM        pThisItem       = NULL;
    PPDHI_RAW_COUNTER_ITEM        pLastItem       = NULL;
    LPWSTR                        szThisItem      = NULL;
    LPWSTR                        szLastItem      = NULL;
    PPDH_RAW_COUNTER              pThisRawCounter = NULL;
    PPDH_RAW_COUNTER              pLastRawCounter = NULL;
    PPDH_FMT_COUNTERVALUE_ITEM_W  pThisFmtItem    = NULL;
    DWORD                         dwThisItemIndex;
    LPWSTR                        wszNextString;
    DWORD                         dwRetItemCount  = 0;
    LIST_ENTRY                    InstList;
    PPDHI_INSTANCE                pInstance;
    WCHAR                         szPound[16];

    InitializeListHead(& InstList);
    Status = WAIT_FOR_AND_LOCK_MUTEX(pCounter->pOwner->hMutex);
    if (Status != ERROR_SUCCESS) {
        return Status;
    }
    if(pCounter->pThisRawItemList == NULL) {
        Status = PDH_CSTATUS_ITEM_NOT_VALIDATED;
        goto Cleanup;
    }

    dwRetItemCount  = pCounter->pThisRawItemList->dwItemCount;
    dwThisItemIndex = 0;
    if (ItemBuffer != NULL) {
        pThisRawCounter = (PPDH_RAW_COUNTER) ItemBuffer;
    }
    else {
        pThisRawCounter = NULL;
    }
    dwRequiredSize  = (DWORD) (dwRetItemCount * sizeof(PDH_RAW_COUNTER));
    if ((ItemBuffer != NULL) && (dwRequiredSize <= * lpdwBufferSize)) {
        pThisFmtItem = (PPDH_FMT_COUNTERVALUE_ITEM_W) (((LPBYTE) ItemBuffer) + dwRequiredSize);
    }
    else {
        pThisFmtItem = NULL;
    }
    dwRequiredSize += (DWORD) (dwRetItemCount * sizeof(PDH_FMT_COUNTERVALUE_ITEM_W));
    if ((ItemBuffer != NULL) && (dwRequiredSize <= * lpdwBufferSize)) {
        wszNextString = (LPWSTR) (((LPBYTE) ItemBuffer) + dwRequiredSize);
    }
    else {
        wszNextString = NULL;
    }
    for (pThisItem = & (pCounter->pThisRawItemList->pItemArray[0]);
            dwThisItemIndex < dwRetItemCount;
            dwThisItemIndex ++, pThisItem ++, pLastItem ++) {
        szThisItem = (LPWSTR) (((LPBYTE) pCounter->pThisRawItemList) + pThisItem->szName);
        pInstance = NULL;
        Status = PdhiFindInstance(& InstList, szThisItem, TRUE, & pInstance);
        if (Status == ERROR_SUCCESS && pInstance != NULL && pInstance->dwCount > 1) {
            ZeroMemory(szPound, 16 * sizeof(WCHAR));
            _itow(pInstance->dwCount - 1, szPound, 10);
            dwRequiredSize += (lstrlenW(szThisItem) + lstrlenW(szPound) + 2) * sizeof(WCHAR);
        }
        else {
            dwRequiredSize += (lstrlenW(szThisItem) + 1) * sizeof(WCHAR);
        }
        if ((dwRequiredSize <= * lpdwBufferSize) && (wszNextString != NULL)) {
            DWORD dwNextString;

            pThisFmtItem->szName = wszNextString;
            StringCchCopyW(wszNextString, * lpdwBufferSize, szThisItem);
            if (pInstance != NULL) {
                if (pInstance->dwCount > 1) {
                    StringCchCatW(wszNextString, * lpdwBufferSize, cszPoundSign);
                    StringCchCatW(wszNextString, * lpdwBufferSize, szPound);
                }
            }
            dwNextString         = lstrlenW(wszNextString);
            wszNextString       += (dwNextString + 1);
            Status               = ERROR_SUCCESS;
        }
        else {
            Status = PDH_MORE_DATA;
        }

        if (Status == ERROR_SUCCESS) {
            if (pCounter->pThisRawItemList != NULL) {
                pThisRawCounter->CStatus     = pCounter->pThisRawItemList->CStatus;
                pThisRawCounter->TimeStamp   = pCounter->pThisRawItemList->TimeStamp;
                pThisRawCounter->FirstValue  = pThisItem->FirstValue;
                pThisRawCounter->SecondValue = pThisItem->SecondValue;
                pThisRawCounter->MultiCount  = pThisItem->MultiCount;
            }
            else {
                ZeroMemory(pThisRawCounter, sizeof(PDH_RAW_COUNTER));
            }

            pLastRawCounter = NULL;
            if (pCounter->pLastRawItemList != NULL) {
                PPDH_FMT_COUNTERVALUE_ITEM_W pFmtValue;
                DWORD dwLastItem = pCounter->LastValue.MultiCount;
                DWORD i;

                pFmtValue = (PPDH_FMT_COUNTERVALUE_ITEM_W)
                            (((LPBYTE) pCounter->pLastObject) + sizeof(PDH_RAW_COUNTER) * dwLastItem);
                for (i = 0; i < dwLastItem; i ++) {
                    if (lstrcmpiW(pThisFmtItem->szName, pFmtValue->szName) == 0) {
                        pLastRawCounter = (PPDH_RAW_COUNTER)
                                          (((LPBYTE) pCounter->pLastObject) + sizeof(PDH_RAW_COUNTER) * i);
                        break;
                    }
                    else {
                        pFmtValue = (PPDH_FMT_COUNTERVALUE_ITEM_W)
                                    (((LPBYTE) pFmtValue) + sizeof(PDH_FMT_COUNTERVALUE_ITEM_W));
                    }
                }
            }

            PdhFnStatus = PdhiComputeFormattedValue(pCounter->CalcFunc,
                                                    pCounter->plCounterInfo.dwCounterType,
                                                    pCounter->lScale,
                                                    PDH_FMT_DOUBLE | PDH_FMT_NOCAP100,
                                                    pThisRawCounter,
                                                    pLastRawCounter,
                                                    & pCounter->TimeBase,
                                                    0L,
                                                    & pThisFmtItem->FmtValue);
            if (PdhFnStatus != ERROR_SUCCESS) {
                //Status                             = PdhFnStatus;
                pThisFmtItem->FmtValue.CStatus     = PDH_CSTATUS_INVALID_DATA;
                pThisFmtItem->FmtValue.doubleValue = 0;
            }

            pThisRawCounter = (PPDH_RAW_COUNTER) (((LPBYTE) pThisRawCounter) + sizeof(PDH_RAW_COUNTER));
            pThisFmtItem    = (PPDH_FMT_COUNTERVALUE_ITEM_W)
                              (((LPBYTE) pThisFmtItem) + sizeof(PDH_FMT_COUNTERVALUE_ITEM_W));
        }
    }

    dwRetItemCount = dwThisItemIndex;

Cleanup:
    RELEASE_MUTEX(pCounter->pOwner->hMutex);
    if (! IsListEmpty(& InstList)) {
        PLIST_ENTRY pHead = & InstList;
        PLIST_ENTRY pNext = pHead->Flink;
        while (pNext != pHead) {
            pInstance = CONTAINING_RECORD(pNext, PDHI_INSTANCE, Entry);
            pNext     = pNext->Flink;
            RemoveEntryList(& pInstance->Entry);
            G_FREE(pInstance);
        }
    }
    if (Status == ERROR_SUCCESS || Status == PDH_MORE_DATA) {
        * lpdwBufferSize = dwRequiredSize;
        * lpdwItemCount  = dwRetItemCount;
    }
    return Status;
}

LPCSTR g_szSQLStat[8] = {
    "42S01", "S0001", "42S02", "S0002", "42S11", "S0011", "42S12", "S0012"
};

RETCODE
PdhiCheckSQLExist(
    HSTMT  hstmt,
    RETCODE  rcIn
)
{
    static SQLCHAR szSQLStat[6];
    static SQLCHAR szMessage[PDH_SQL_STRING_SIZE];
    RETCODE        rc           = rcIn;
    SQLSMALLINT    iMessage     = PDH_SQL_STRING_SIZE;
    SQLSMALLINT    iSize        = 0;    
    SQLINTEGER     iNativeError = 0;

    ZeroMemory(szSQLStat, 6 * sizeof(SQLCHAR));
    ZeroMemory(szMessage, PDH_SQL_STRING_SIZE * sizeof(SQLCHAR));
    rc = SQLGetDiagRec(SQL_HANDLE_STMT, hstmt, 1, szSQLStat, & iNativeError, szMessage, iMessage, & iSize);
    TRACE((PDH_DBG_TRACE_INFO),
          (__LINE__,
           PDH_LOGSQL,
           ARG_DEF(ARG_TYPE_STR,1) | ARG_DEF(ARG_TYPE_STR, 2),
           ERROR_SUCCESS,
           TRACE_STR(szSQLStat),
           TRACE_STR(szMessage),
           TRACE_DWORD(rcIn),
           TRACE_DWORD(rc),
           NULL));
    if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO) {
        int i;

        for (i = 0; i < 8; i ++) {
            if (lstrcmpi(szSQLStat, g_szSQLStat[i]) == 0) {
                rc = SQL_SUCCESS;
                break;
            }
        }
        if (i >= 8) {
            rc = rcIn;
        }
    }
    else {
        rc = rcIn;
    }
    return rc;
}

PDH_FUNCTION
PdhiSQLUpdateCounterDetailTimeBase(
    PPDHI_LOG pLog,
    DWORD     dwCounterId,
    LONGLONG  lTimeBase,
    BOOL      bBeforeSendRow
)
{
    PDH_STATUS Status    = ERROR_SUCCESS;
    HSTMT      hstmt     = NULL;
    RETCODE    rc;
    LPWSTR     szSQLStmt = NULL;

    if (! bBeforeSendRow) {
        PPDH_SQL_BULK_COPY pBulk = (PPDH_SQL_BULK_COPY) pLog->lpMappedFileBase;

        if (pBulk != NULL && pBulk->dwRecordCount > 0) {
            DBINT rcBCP = bcp_batch(pLog->hdbcSQL);
            if (rcBCP < 0) {
                TRACE((PDH_DBG_TRACE_ERROR),
                      (__LINE__,
                       PDH_LOGSQL,
                       0,
                       PDH_SQL_EXEC_DIRECT_FAILED,
                       TRACE_DWORD(rcBCP),
                       TRACE_DWORD(pBulk->dwRecordCount),
                       NULL));
                ReportSQLError(pLog, SQL_ERROR, NULL, PDH_SQL_EXEC_DIRECT_FAILED);
            }
            pBulk->dwRecordCount = 0;
        }
    }

    szSQLStmt = (LPWSTR) G_ALLOC(SQLSTMTSIZE * sizeof(WCHAR));
    if (szSQLStmt == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
    }
    else {
        StringCchPrintfW(szSQLStmt, SQLSTMTSIZE,
                        L"UPDATE CounterDetails SET TimeBaseA = %d, TimeBaseB = %d WHERE CounterID = %d",
                        LODWORD(lTimeBase), HIDWORD(lTimeBase), dwCounterId);
        rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
        if (! SQLSUCCEEDED(rc)) {
            Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        }
        else {
            rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
            if (! SQLSUCCEEDED(rc)) {
                Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALTER_DETAIL_FAILED);
            }
            SQLFreeStmt(hstmt, SQL_DROP);
        }
        G_FREE(szSQLStmt);
    }
    return Status;
}

PDH_FUNCTION
PdhiSQLExtendCounterDetail(
    PPDHI_LOG pLog
)
{
    PDH_STATUS Status       = ERROR_SUCCESS;
    BOOL       bExtend      = FALSE;
    HSTMT      hstmt        = NULL;    
    RETCODE    rc;
    DWORD      dwTimeBaseA;
    SQLLEN     lenTimeBaseA;
    LPWSTR     szSQLStmt    = NULL;
    LPWSTR     szErrMsg     = NULL;

    szSQLStmt = (LPWSTR) G_ALLOC(2 * SQLSTMTSIZE * sizeof(WCHAR));
    if (szSQLStmt == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
    }
    else {
        szErrMsg = szSQLStmt + SQLSTMTSIZE;

        StringCchCopyW(szSQLStmt, SQLSTMTSIZE, L"SELECT TimeBaseA FROM CounterDetails");
        rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
        if (! SQLSUCCEEDED(rc)) {
            Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        }
        else {
            rc = SQLBindCol(hstmt, 1, SQL_C_LONG, & dwTimeBaseA, 0, & lenTimeBaseA);
            if (! SQLSUCCEEDED(rc)) {
                Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
            }
            else {
                rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
                if (! SQLSUCCEEDED(rc)) {
                    long  iError;
                    short cbErrMsg = SQLSTMTSIZE;

                    SQLErrorW(pLog->henvSQL, pLog->hdbcSQL, hstmt, NULL, & iError, szErrMsg, SQLSTMTSIZE, & cbErrMsg);
                    if (iError == 0x00CF) { // 207, Invalid Column Name.
                        bExtend = TRUE;
                    }
                    else {
                        ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
                    }
                }
            }
            SQLFreeStmt(hstmt, SQL_DROP);
        }

        if (bExtend) {
            StringCchCopyW(szSQLStmt, SQLSTMTSIZE, L"ALTER TABLE CounterDetails ADD TimeBaseA int NULL");
            rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
            if (! SQLSUCCEEDED(rc)) {
                Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
            }
            else {
                rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
                if (! SQLSUCCEEDED(rc)) {
                    Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALTER_DETAIL_FAILED);
                }
                SQLFreeStmt(hstmt, SQL_DROP);
            }

            if (Status == ERROR_SUCCESS) {
                StringCchCopyW(szSQLStmt, SQLSTMTSIZE, L"ALTER TABLE CounterDetails ADD TimeBaseB int NULL");
                rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
                if (! SQLSUCCEEDED(rc)) {
                    Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
                }
                else {
                    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
                    if (! SQLSUCCEEDED(rc)) {
                        Status = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALTER_DETAIL_FAILED);
                    }
                    SQLFreeStmt(hstmt, SQL_DROP);
                }
            }
        }
        G_FREE(szSQLStmt);
    }
    return Status;
}

PDH_FUNCTION 
PdhpCreateSQLTables(
    PPDHI_LOG pLog
)
{
    // INTERNAL FUNCTION to
    //Create the correct perfmon tables in the database
    PDH_STATUS   pdhStatus       = ERROR_SUCCESS;
    HSTMT        hstmt           = NULL;    
    RETCODE      rc;
    BOOL         bExistData      = FALSE;
    LPWSTR       szSQLStmt       = NULL;

    szSQLStmt = (LPWSTR) G_ALLOC(SQLSTMTSIZE * sizeof(WCHAR));
    if (szSQLStmt == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    // difficult to cleanup old tables, also dangerous so we won't...
    // PdhiOpenOutputSQLLog calls this routine to ensure the tables are here without checking
    // create the CounterDetails Table

    StringCchPrintfW(szSQLStmt, SQLSTMTSIZE,
                    L"CREATE TABLE CounterDetails(\
                                    CounterID        int IDENTITY PRIMARY KEY,\
                                    MachineName      varchar(%d) NOT NULL,\
                                    ObjectName       varchar(%d) NOT NULL,\
                                    CounterName      varchar(%d) NOT NULL,\
                                    CounterType      int NOT NULL,\
                                    DefaultScale     int NOT NULL,\
                                    InstanceName     varchar(%d),\
                                    InstanceIndex    int,\
                                    ParentName       varchar(%d),\
                                    ParentObjectID   int,\
                                    TimeBaseA        int,\
                                    TimeBaseB        int\
                                    )",
                    PDH_SQL_STRING_SIZE,
                    PDH_SQL_STRING_SIZE,
                    PDH_SQL_STRING_SIZE,
                    PDH_SQL_STRING_SIZE,
                    PDH_SQL_STRING_SIZE);
    // allocate an hstmt
    rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }
    // execute the create statement
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (!SQLSUCCEEDED(rc))
    {
        rc = PdhiCheckSQLExist(hstmt, rc);
        if (! (SQLSUCCEEDED(rc))) {
            // don't report the error, as this could be called from
            // opening a database that already exists...
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
            goto Cleanup;
        }
        else {
            SQLFreeStmt(hstmt, SQL_DROP);
            hstmt = NULL;

            if ((pdhStatus = PdhiSQLExtendCounterDetail(pLog)) != ERROR_SUCCESS) goto Cleanup;

            StringCchPrintfW(szSQLStmt, SQLSTMTSIZE,
                            L"ALTER TABLE CounterDetails ALTER COLUMN MachineName varchar(%d) NOT NULL",
                            PDH_SQL_STRING_SIZE);
            rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
            if (! SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
                goto Cleanup;
            }
            rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
            if (! SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALTER_DETAIL_FAILED);
                goto Cleanup;
            }
            SQLFreeStmt(hstmt, SQL_DROP);
            hstmt = NULL;

            StringCchPrintfW(szSQLStmt, SQLSTMTSIZE,
                            L"ALTER TABLE CounterDetails ALTER COLUMN ObjectName varchar(%d) NOT NULL",
                            PDH_SQL_STRING_SIZE);
            rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
            if (! SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
                goto Cleanup;
            }
            rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
            if (! SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALTER_DETAIL_FAILED);
                goto Cleanup;
            }
            SQLFreeStmt(hstmt, SQL_DROP);
            hstmt = NULL;

            StringCchPrintfW(szSQLStmt, SQLSTMTSIZE,
                            L"ALTER TABLE CounterDetails ALTER COLUMN CounterName varchar(%d) NOT NULL",
                            PDH_SQL_STRING_SIZE);
            rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
            if (! SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
                goto Cleanup;
            }
            rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
            if (! SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALTER_DETAIL_FAILED);
                goto Cleanup;
            }
            SQLFreeStmt(hstmt, SQL_DROP);
            hstmt = NULL;

            StringCchPrintfW(szSQLStmt, SQLSTMTSIZE,
                            L"ALTER TABLE CounterDetails ALTER COLUMN InstanceName varchar(%d)",
                            PDH_SQL_STRING_SIZE);
            rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
            if (! SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
                goto Cleanup;
            }
            rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
            if (! SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALTER_DETAIL_FAILED);
                goto Cleanup;
            }
            SQLFreeStmt(hstmt, SQL_DROP);
            hstmt = NULL;

            StringCchPrintfW(szSQLStmt, SQLSTMTSIZE,
                            L"ALTER TABLE CounterDetails ALTER COLUMN ParentName varchar(%d)",
                            PDH_SQL_STRING_SIZE);
            rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
            if (! SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
                goto Cleanup;
            }
            rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
            if (! SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALTER_DETAIL_FAILED);
                goto Cleanup;
            }
        }
    }
    SQLFreeStmt(hstmt, SQL_DROP);
    hstmt = NULL;

    // Create the CounterData table
    StringCchCopyW(szSQLStmt, SQLSTMTSIZE,
                    L"CREATE TABLE CounterData(\
                            GUID                     uniqueidentifier NOT NULL,\
                            CounterID                int NOT NULL,\
                            RecordIndex              int NOT NULL,\
                            CounterDateTime          char(24) NOT NULL,\
                            CounterValue             float NOT NULL,\
                            FirstValueA              int,\
                            FirstValueB              int,\
                            SecondValueA             int,\
                            SecondValueB             int,\
                            MultiCount               int,\
                            )");

    // allocate an hstmt
    rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }

    // execute the create statement
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (! SQLSUCCEEDED(rc)) {
        rc = PdhiCheckSQLExist(hstmt, rc);
        if (! (SQLSUCCEEDED(rc))) {
            // don't report the error, as this could be called from
            // opening a database that already exists...
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
            goto Cleanup;
        }
        else {
            bExistData = TRUE;
        }
    }
    SQLFreeStmt(hstmt, SQL_DROP);
    hstmt = NULL;

    if (! bExistData) {
        // add the primary keys
        StringCchCopyW(szSQLStmt, SQLSTMTSIZE, L"ALTER TABLE CounterData ADD PRIMARY KEY (GUID,counterID,RecordIndex)");

        // allocate an hstmt
        rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
            goto Cleanup;
        }

        // execute the create statement
        rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
        if (! SQLSUCCEEDED(rc)) {
            rc = PdhiCheckSQLExist(hstmt, rc);
            if (! (SQLSUCCEEDED(rc))) {
                // don't report the error, as this could be called from
                // opening a database that already exists...
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
                goto Cleanup;
            }
        }
    }
    SQLFreeStmt(hstmt, SQL_DROP);
    hstmt = NULL;

    // create the DisplayToID table
    StringCchPrintfW(szSQLStmt, SQLSTMTSIZE,
                    L"CREATE TABLE DisplayToID(\
                                    GUID              uniqueidentifier NOT NULL PRIMARY KEY,\
                                    RunID             int,\
                                    DisplayString     varchar(%d) NOT NULL UNIQUE,\
                                    LogStartTime      char(24),\
                                    LogStopTime       char(24),\
                                    NumberOfRecords   int,\
                                    MinutesToUTC      int,\
                                    TimeZoneName      char(32)\
                                    )",
                    PDH_SQL_STRING_SIZE);
    // allocate an hstmt
    rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }

    // execute the create statement
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (! SQLSUCCEEDED(rc)) {
        rc = PdhiCheckSQLExist(hstmt, rc);
        if (! (SQLSUCCEEDED(rc))) {
            // don't report the error, as this could be called from 
            // opening a database that already exists...
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
            goto Cleanup;
        }
    }
    SQLFreeStmt(hstmt, SQL_DROP);
    hstmt = NULL;

Cleanup:
    if (hstmt != NULL) SQLFreeStmt(hstmt, SQL_DROP);
    G_FREE(szSQLStmt);
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetSQLLogCounterInfo(
    PPDHI_LOG     pLog,
    PPDHI_COUNTER pCounter
)
{
    PDH_STATUS          pdhStatus   = ERROR_SUCCESS;
    PPDHI_SQL_LOG_INFO  pLogInfo;
    PPDHI_LOG_COUNTER   pLogCounter = NULL;
    DWORD               dwCtrIndex  = 0;
    BOOL                bNoMachine  = FALSE;
    LPWSTR              szMachine;

    pdhStatus = PdhpGetSQLLogHeader(pLog);
    if (pdhStatus != ERROR_SUCCESS) goto Cleanup;

    pLogInfo = (PPDHI_SQL_LOG_INFO) pLog->pPerfmonInfo;
    if (pLogInfo == NULL) {
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
        goto Cleanup;
    }

    if (pCounter->pCounterPath->szMachineName == NULL) {
        bNoMachine = TRUE;
        szMachine  = szStaticLocalMachineName;
    }
    else if (lstrcmpiW(pCounter->pCounterPath->szMachineName, L"\\\\.") == 0) {
        bNoMachine = TRUE;
        szMachine  = szStaticLocalMachineName;
    }
    else {
        szMachine  = pCounter->pCounterPath->szMachineName;
    }

    pLogCounter = PdhiFindLogCounter(pLog,
                                     & pLogInfo->MachineList,
                                     szMachine,
                                     pCounter->pCounterPath->szObjectName,
                                     pCounter->pCounterPath->szCounterName,
                                     0,
                                     0,
                                     pCounter->pCounterPath->szInstanceName,
                                     pCounter->pCounterPath->dwIndex,
                                     pCounter->pCounterPath->szParentName,
                                     0,
                                     & dwCtrIndex,
                                     FALSE);
    if (pLogCounter != NULL) {
        if (bNoMachine) {
            pCounter->pCounterPath->szMachineName = NULL;
        }
        pCounter->TimeBase                           = pLogCounter->TimeBase;
        pCounter->plCounterInfo.dwObjectId           = 0;
        pCounter->plCounterInfo.lInstanceId          = pLogCounter->dwInstance;
        pCounter->plCounterInfo.szInstanceName       = pLogCounter->szInstance;
        pCounter->plCounterInfo.dwParentObjectId     = pLogCounter->dwParent;
        pCounter->plCounterInfo.szParentInstanceName = pLogCounter->szParent;
        pCounter->plCounterInfo.dwCounterId          = pLogCounter->dwCounterID;
        pCounter->plCounterInfo.dwCounterType        = pLogCounter->dwCounterType;
        pCounter->plCounterInfo.lDefaultScale        = pLogCounter->dwDefaultScale;
        pCounter->plCounterInfo.dwCounterSize        = (pLogCounter->dwCounterType & PERF_SIZE_LARGE)
                                                     ? sizeof(LONGLONG) : sizeof(DWORD);
        pCounter->plCounterInfo.dwSQLCounterId       = dwCtrIndex;
        pdhStatus                                    = ERROR_SUCCESS;
    }
    else {
        pdhStatus = PDH_CSTATUS_NO_COUNTER;
    }

Cleanup:
    return pdhStatus;
}

PDH_FUNCTION
PdhiOpenSQLLog(
    PPDHI_LOG pLog,
    BOOL      bOpenInput
)
{
    // string to compare with file name to see if SQL
    LPCWSTR    szSQLType =  L"SQL:";
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    RETCODE    rc        = SQL_SUCCESS;

    pLog->henvSQL = NULL;
    pLog->hdbcSQL = NULL;

    // format is SQL:DSNNAME!COMMENT
    // parse out the DSN name and 'dataset' (comment) name from the LogFileName
    // pLog->szDSN - pointer to Data Source Name within LogFileName
    //         (separators replaced with 0's)
    // pLog->szCommentSQL - pointer to the Comment string that defines the
    //         name of the data set within the SQL database

    pLog->szDSN = pLog->szLogFileName + lstrlenW(szSQLType);
    pLog->szCommentSQL = wcschr((const wchar_t *) pLog->szDSN, '!');
    if (NULL == pLog->szCommentSQL) {
        pdhStatus = PDH_INVALID_DATASOURCE;
        goto Cleanup;
    }
    pLog->szCommentSQL[0] = 0;    // null terminate the DSN name
    pLog->szCommentSQL ++;        // increment past to the Comment string

    if (0 == lstrlenW(pLog->szCommentSQL)) {
        pdhStatus = PDH_INVALID_DATASOURCE;
        goto Cleanup;
    }

    // initialize the rest of the SQL fields
    pLog->dwNextRecordIdToWrite = 1; // start with record 1
    pLog->dwRecord1Size         = 0;
    
    //////////////////////////////////////////////////////////////
    // obtain the ODBC environment and connection
    //

    rc = SQLAllocEnv(&pLog->henvSQL);
    if (! SQLSUCCEEDED(rc)) goto Cleanup;
    
    rc = SQLAllocConnect(pLog->henvSQL, &pLog->hdbcSQL);
    if (! SQLSUCCEEDED(rc)) goto Cleanup;

    rc = SQLSetConnectAttr(pLog->hdbcSQL, SQL_COPT_SS_BCP, (SQLPOINTER) SQL_BCP_ON, SQL_IS_INTEGER);
    if (! SQLSUCCEEDED(rc)) goto Cleanup;

    rc = SQLConnectW(pLog->hdbcSQL, (SQLWCHAR *) pLog->szDSN, SQL_NTS, NULL, SQL_NULL_DATA, NULL, SQL_NULL_DATA);

Cleanup:
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog,rc,NULL,PDH_SQL_ALLOCCON_FAILED);
        if (pLog->hdbcSQL != NULL) {
            SQLDisconnect(pLog->hdbcSQL);        
            SQLFreeHandle(SQL_HANDLE_DBC, pLog->hdbcSQL);
        }
        if (pLog->henvSQL) SQLFreeHandle(SQL_HANDLE_ENV, pLog->henvSQL);
        pLog->henvSQL = NULL;
        pLog->hdbcSQL = NULL;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiOpenInputSQLLog(
    PPDHI_LOG   pLog
)
{
    PDH_STATUS pdhStatus     = ERROR_SUCCESS;
    LPWSTR     szSQLStmt     = NULL;
    DWORD      dwSQLStmt     = 0;
    HSTMT      hstmt         = NULL;    
    RETCODE    rc;
    LONG       lMinutesToUTC = 0;
    WCHAR      szTimeZoneName[TIMEZONE_BUFF_SIZE];
    SQLLEN     dwTimeZoneLen;
    
    pdhStatus = PdhiOpenSQLLog(pLog, TRUE);
    if (SUCCEEDED(pdhStatus)) {
        if ((pdhStatus = PdhiSQLExtendCounterDetail(pLog)) != ERROR_SUCCESS) goto Cleanup;

        // Check that the database exists
        // Select the guid & runid from DisplayToId table
        // allocate an hstmt
        rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
            goto Cleanup;
        }

        dwSQLStmt = MAX_PATH;
        if (pLog->szCommentSQL != NULL) dwSQLStmt += lstrlenW(pLog->szCommentSQL);
        if (dwSQLStmt < SQLSTMTSIZE)    dwSQLStmt  = SQLSTMTSIZE;
        szSQLStmt = G_ALLOC(dwSQLStmt * sizeof(WCHAR));
        if (szSQLStmt == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }

        StringCchPrintfW(szSQLStmt, dwSQLStmt,
                L"select GUID, RunID, NumberOfRecords, MinutesToUTC, TimeZoneName  from DisplayToID where DisplayString = '%ws'",
                pLog->szCommentSQL);
        // bind the columns
        rc = SQLBindCol(hstmt, 1, SQL_C_GUID, & pLog->guidSQL, 0, NULL);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
            goto Cleanup;
        }
        rc = SQLBindCol(hstmt, 2, SQL_C_LONG, & pLog->iRunidSQL, 0, NULL);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
            goto Cleanup;
        }
        rc = SQLBindCol(hstmt, 3, SQL_C_LONG, & pLog->dwNextRecordIdToWrite, 0, NULL);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
            goto Cleanup;
        }
        rc = SQLBindCol(hstmt, 4, SQL_C_LONG, & lMinutesToUTC, 0, NULL);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
            goto Cleanup;
        }
        rc = SQLBindCol(hstmt, 5, SQL_C_WCHAR, szTimeZoneName, TIMEZONE_BUFF_SIZE * sizeof(WCHAR), & dwTimeZoneLen);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
            goto Cleanup;
        }
        rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
            goto Cleanup;
        }
        rc = SQLFetch(hstmt);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_FETCH_FAILED);
            goto Cleanup;
        }
        pLog->dwNextRecordIdToWrite ++; // increment number of current records to get next recordid to write
    }

Cleanup:
    if (hstmt != NULL) SQLFreeStmt(hstmt, SQL_DROP);
    G_FREE(szSQLStmt);
    return pdhStatus;
}

PDH_FUNCTION
PdhiOpenOutputSQLLog(
    PPDHI_LOG   pLog
)
// open SQL database for output
// May have to create DB
{
    PDH_STATUS pdhStatus    = PdhiOpenSQLLog(pLog, FALSE);
    LPWSTR     szSQLStmt    = NULL;
    DWORD      dwSQLStmt    = MAX_PATH;
    HSTMT      hstmt        = NULL;    
    RETCODE    rc;
    SQLLEN     dwGuid       = 0;
    SQLLEN     dwRunIdSQL   = 0;
    SQLLEN     dwNextRecord = 0;

    if (SUCCEEDED(pdhStatus)) {
        // see if we need to create the database
        // creating the tables is harmless, it won't drop
        // them if they already exist, but ignore any errors

        pdhStatus = PdhpCreateSQLTables(pLog);

        if (pLog->szCommentSQL != NULL) dwSQLStmt += lstrlenW(pLog->szCommentSQL);
        if (dwSQLStmt < SQLSTMTSIZE)    dwSQLStmt  = SQLSTMTSIZE;
        szSQLStmt = G_ALLOC(dwSQLStmt * sizeof(WCHAR));
        if (szSQLStmt == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }

        // See if logset already exists. If it does, treat it as an
        // logset append case.
        //
        rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = PDH_SQL_ALLOC_FAILED;
            goto Cleanup;
        }

        StringCchPrintfW(szSQLStmt, dwSQLStmt,
                L"select GUID, RunID, NumberOfRecords from DisplayToID where DisplayString = '%ws'",
                pLog->szCommentSQL);

        rc = SQLBindCol(hstmt, 1, SQL_C_GUID, & pLog->guidSQL, 0, & dwGuid);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = PDH_SQL_BIND_FAILED;
            goto Cleanup;
        }
        rc = SQLBindCol(hstmt, 2, SQL_C_LONG, & pLog->iRunidSQL, 0, & dwRunIdSQL);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = PDH_SQL_BIND_FAILED;
            goto Cleanup;
        }
        rc = SQLBindCol(hstmt, 3, SQL_C_LONG, & pLog->dwNextRecordIdToWrite, 0, & dwNextRecord);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = PDH_SQL_BIND_FAILED;
            goto Cleanup;
        }
        rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = PDH_SQL_EXEC_DIRECT_FAILED;
            goto Cleanup;
        }
        rc = SQLFetch(hstmt);
        if ((! SQLSUCCEEDED(rc)) || (rc == SQL_NO_DATA)) {
            pdhStatus = PDH_SQL_FETCH_FAILED;
            goto Cleanup;
        }

        pLog->dwNextRecordIdToWrite ++;
        pLog->dwRecord1Size = 1;

Cleanup:
        if (hstmt != NULL) SQLFreeStmt(hstmt, SQL_DROP);
        G_FREE(szSQLStmt);

        if (pdhStatus != ERROR_SUCCESS) {
            // initialize the GUID
            HRESULT hr                  = CoCreateGuid(& pLog->guidSQL);
            pLog->dwNextRecordIdToWrite = 1;
            pLog->iRunidSQL             = 0;
            pdhStatus                   = ERROR_SUCCESS;
        }
    }

    if (SUCCEEDED(pdhStatus)) {
        PPDH_SQL_BULK_COPY pBulk = PdhiBindBulkCopyStructure(pLog);
        if (pBulk == NULL) {
            pdhStatus = GetLastError();
        }
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiReportSQLError(
    PPDHI_LOG pLog,
    RETCODE   rc,
    HSTMT     hstmt,
    DWORD     dwEventNumber,
    DWORD     dwLine
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    
    if (! SQLSUCCEEDED(rc))  {
        pdhStatus = dwEventNumber;
    }

    if (FAILED(pdhStatus)) {
        // for now this will be reported only whe specifically enabled
        short  cbErrMsgSize = 512;
        WCHAR  szError[512];
        LPWSTR lpszStrings[1];
        DWORD  dwData[2];
        long   iError;

        lpszStrings[0] = szError;
        SQLErrorW(pLog->henvSQL, pLog->hdbcSQL, hstmt, NULL, & iError, szError, 512, & cbErrMsgSize);
        dwData[0] = iError;
        dwData[1] = dwLine;
        if (pdhStatus == PDH_SQL_EXEC_DIRECT_FAILED && iError == 1105) {
            pdhStatus = ERROR_DISK_FULL;
        }
        ReportEventW(hEventLog,
                     EVENTLOG_ERROR_TYPE,        // error type
                     0,                          // category (not used)
                     (DWORD) dwEventNumber,      // event,
                     NULL,                       // SID (not used),
                     1,                          // number of strings
                     2,                          // sizeof raw data
                     (LPCWSTR *) lpszStrings,    // message text array
                     (LPVOID)  & dwData[0]);     // raw data
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiCloseSQLLog(
    PPDHI_LOG pLog,
    DWORD     dwFlags
)
// close the SQL database
{
    PDH_STATUS              pdhStatus = ERROR_SUCCESS;
    LPWSTR                  szSQLStmt = NULL;
    HSTMT                   hstmt     = NULL;    
    RETCODE                 rc;
    SQLLEN                  dwDateTimeLen;
    WCHAR                   szDateTime[TIME_FIELD_BUFF_SIZE];
    DBINT                   rcBCP;
    DWORD                   dwReturn;
    WCHAR                 * pTimeZone;
    TIME_ZONE_INFORMATION   TimeZone;
    LONG                    lMinutesToUTC = 0;

    UNREFERENCED_PARAMETER(dwFlags);
    szSQLStmt = (LPWSTR) G_ALLOC(SQLSTMTSIZE * sizeof(WCHAR));
    if (szSQLStmt == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    if ((pLog->dwLogFormat & PDH_LOG_ACCESS_MASK) == PDH_LOG_WRITE_ACCESS) {
        // need to save the last datetime in the DisplayToID as well as the number of records written

        // allocate an hstmt
        rc = SQLAllocStmt(pLog->hdbcSQL, &hstmt);
        if (!SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog,rc,hstmt,PDH_SQL_ALLOC_FAILED);
            goto Cleanup;
        }

        // first have to read the date time from the last record

        StringCchPrintfW(szSQLStmt, SQLSTMTSIZE,
                L"select CounterDateTime from CounterData where GUID = '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x' and RecordIndex = %d",
                pLog->guidSQL.Data1, pLog->guidSQL.Data2, pLog->guidSQL.Data3,
                pLog->guidSQL.Data4[0], pLog->guidSQL.Data4[1], pLog->guidSQL.Data4[2],
                pLog->guidSQL.Data4[3], pLog->guidSQL.Data4[4], pLog->guidSQL.Data4[5],
                pLog->guidSQL.Data4[6], pLog->guidSQL.Data4[7], (pLog->dwNextRecordIdToWrite - 1));
        // bind the column
        rc = SQLBindCol(hstmt, 1, SQL_C_WCHAR, szDateTime, sizeof(szDateTime), & dwDateTimeLen);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
            goto Cleanup;
        }
        rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
            goto Cleanup;
        }
        rc = SQLFetch(hstmt);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_FETCH_FAILED);
            goto Cleanup;
        }
        // close the hstmt since we're done, and don't want more rows
        SQLFreeStmt(hstmt, SQL_DROP);
        hstmt = NULL;

        if (SQL_NO_DATA != rc) { // if there is no data, we didn't write any rows
            // allocate an hstmt
            rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
            if (! SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
                goto Cleanup;
            }
            // szDateTime should have the correct date & time in it from above.
            // get MinutesToUTC
            //
            dwReturn = GetTimeZoneInformation(& TimeZone);
            if (dwReturn != TIME_ZONE_ID_INVALID) {
                if (dwReturn == TIME_ZONE_ID_DAYLIGHT)  {
                    pTimeZone = TimeZone.DaylightName;
                    lMinutesToUTC = TimeZone.Bias + TimeZone.DaylightBias;
                }
                else {
                    pTimeZone = TimeZone.StandardName;
                    lMinutesToUTC = TimeZone.Bias + TimeZone.StandardBias;
                }
            }
            StringCchPrintfW(szSQLStmt, SQLSTMTSIZE,
                    L"update DisplayToID set LogStopTime = '%ws', NumberOfRecords = %d, MinutesToUTC = %d, TimeZoneName = '%s' where GUID = '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x'",
                    szDateTime, (pLog->dwNextRecordIdToWrite - 1),
                    lMinutesToUTC,pTimeZone,
                    pLog->guidSQL.Data1, pLog->guidSQL.Data2, pLog->guidSQL.Data3,
                    pLog->guidSQL.Data4[0], pLog->guidSQL.Data4[1], pLog->guidSQL.Data4[2],
                    pLog->guidSQL.Data4[3], pLog->guidSQL.Data4[4], pLog->guidSQL.Data4[5],
                    pLog->guidSQL.Data4[6], pLog->guidSQL.Data4[7]);
            rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
            if (! SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
                goto Cleanup;
            }
        }

        rcBCP = bcp_done(pLog->hdbcSQL);
        if (rcBCP < 0) {
            TRACE((PDH_DBG_TRACE_ERROR),
                  (__LINE__,
                   PDH_LOGSQL,
                   0,
                   PDH_SQL_EXEC_DIRECT_FAILED,
                   TRACE_DWORD(rcBCP),
                   NULL));
            pdhStatus = ReportSQLError(pLog, SQL_ERROR, NULL, PDH_SQL_EXEC_DIRECT_FAILED);
        }

        G_FREE(pLog->lpMappedFileBase);
        pLog->lpMappedFileBase = NULL;

        if (pLog->pPerfmonInfo != NULL) {
            PdhiFreeLogMachineTable((PPDHI_LOG_MACHINE *) (& (pLog->pPerfmonInfo)));
            pLog->pPerfmonInfo = NULL;
        }
        pLog->dwRecord1Size = 0;
    }
    else if (pLog->pPerfmonInfo != NULL) {
        PPDHI_SQL_LOG_INFO pLogInfo = (PPDHI_SQL_LOG_INFO) pLog->pPerfmonInfo;

        PdhiFreeLogMachineTable((PPDHI_LOG_MACHINE *) (& pLogInfo->MachineList));
        if (pLogInfo->LogData != NULL)  {
            DWORD                dwStart = 0;
            DWORD                dwEnd   = pLogInfo->dwMaxCounter - pLogInfo->dwMinCounter;
            PPDHI_SQL_LOG_DATA * LogData = pLogInfo->LogData;

            for (dwStart = 0; dwStart <= dwEnd; dwStart ++) {
                if (LogData[dwStart] != NULL) G_FREE(LogData[dwStart]);
            }
            G_FREE(LogData);
        }
        G_FREE(pLog->pPerfmonInfo);
        pLog->pPerfmonInfo = NULL;
    }

Cleanup:
    G_FREE(szSQLStmt);
    if (hstmt != NULL) SQLFreeStmt(hstmt, SQL_DROP);
    if (pLog->hdbcSQL != NULL) {
        SQLDisconnect(pLog->hdbcSQL);        
        SQLFreeHandle(SQL_HANDLE_DBC, pLog->hdbcSQL);
    }
    if (pLog->henvSQL != NULL) SQLFreeHandle(SQL_HANDLE_ENV, pLog->henvSQL);

    return pdhStatus;
}

PDH_FUNCTION
PdhpWriteSQLCounters(
    PPDHI_LOG   pLog
)
// write the CounterTable entries that are new.
// An entry might already exist for a counter from a previous run
// so the first step is to read a counter (server+object+instance name)
// and see if it exists - if so - just record the counterid in the
// PDHI_LOG structure under pLog->pQuery->pCounterListHead in the
// PDHI_COUNTER.  If the counter doesn't exist - create it in SQL and
// record the counterid in the PDHI_LOG structure under
// pLog->pQuery->pCounterListHead in the PDHI_COUNTER.
{
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    PPDHI_COUNTER   pCtrEntry;

    if(NULL == pLog->pQuery) {
        goto Cleanup; // no counters to process
    }
    pCtrEntry = pLog->pQuery->pCounterListHead;
    if (pCtrEntry == NULL) {
        goto Cleanup; // no counters to process
    }

    do {
        PPDHI_LOG_COUNTER pSqlCounter = NULL;
        pdhStatus = PdhiSqlBuildCounterObjectNode(pLog,
                                                  pCtrEntry->pCounterPath->szMachineName,
                                                  pCtrEntry->pCounterPath->szObjectName);
        if (pdhStatus != ERROR_SUCCESS) break;

        if ((pCtrEntry->dwFlags & PDHIC_MULTI_INSTANCE) == 0) {
            pSqlCounter = PdhiSqlFindCounter(pLog,
                                             (PPDHI_LOG_MACHINE *) (& (pLog->pPerfmonInfo)),
                                             pCtrEntry->pCounterPath->szMachineName,
                                             pCtrEntry->pCounterPath->szObjectName,
                                             pCtrEntry->pCounterPath->szCounterName,
                                             pCtrEntry->plCounterInfo.dwCounterType,
                                             pCtrEntry->plCounterInfo.lDefaultScale,
                                             pCtrEntry->pCounterPath->szInstanceName,
                                             pCtrEntry->pCounterPath->dwIndex,
                                             pCtrEntry->pCounterPath->szParentName,
                                             pCtrEntry->plCounterInfo.dwParentObjectId,
                                             pCtrEntry->TimeBase,
                                             TRUE,
                                             TRUE);
            if (pSqlCounter != NULL) {
                pCtrEntry->pBTreeNode                   = (LPVOID) pSqlCounter;
                pCtrEntry->plCounterInfo.dwSQLCounterId = pSqlCounter->dwCounterID;
                if (pSqlCounter->dwCounterType == PERF_DOUBLE_RAW) {
                    pSqlCounter->dwCounterType = pCtrEntry->plCounterInfo.dwCounterType;
                    pSqlCounter->TimeBase      = pCtrEntry->TimeBase;
                    pdhStatus = PdhiSQLUpdateCounterDetailTimeBase(pLog,
                                                                   pCtrEntry->plCounterInfo.dwSQLCounterId,
                                                                   pCtrEntry->TimeBase,
                                                                   TRUE);
                    if (pdhStatus != ERROR_SUCCESS) {
                        pSqlCounter->dwCounterType = PERF_DOUBLE_RAW;
                        pSqlCounter->TimeBase      = 0;
                    }
                }
            }
        }
        pCtrEntry = pCtrEntry->next.flink;
    }
    while (pCtrEntry != pLog->pQuery->pCounterListHead); // loop thru pCtrEntry's

Cleanup:
    return pdhStatus;
}

PDH_FUNCTION
PdhiWriteSQLLogHeader(
    PPDHI_LOG pLog,
    LPCWSTR   szUserCaption
)
// there is no 'header record' in the SQL database,
// but we need to write the CounterTable entries that are new.
// use PdhpWriteSQLCounters to do that
// then write the DisplayToID record to identify this logset
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    LPWSTR      szSQLStmt = NULL;
    DWORD       dwSQLStmt;
    HSTMT       hstmt     = NULL;    
    RETCODE     rc;

    DBG_UNREFERENCED_PARAMETER(szUserCaption);

    pdhStatus = PdhpWriteSQLCounters(pLog);
    if (pLog->dwRecord1Size == 0) {
        // we also need to write the DisplayToID record at this point
        // allocate an hstmt
        rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
            goto Cleanup;
        }
        dwSQLStmt = MAX_PATH;
        if (pLog->szCommentSQL != NULL) dwSQLStmt += lstrlenW(pLog->szCommentSQL);
        if (dwSQLStmt < SQLSTMTSIZE)    dwSQLStmt  = SQLSTMTSIZE;
        szSQLStmt = G_ALLOC(dwSQLStmt * sizeof(WCHAR));
        if (szSQLStmt == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }

        StringCchPrintfW(szSQLStmt, dwSQLStmt,
                L"insert into DisplayToID values ('%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x',%d,'%ws',0,0,0,0,'')",
                pLog->guidSQL.Data1, pLog->guidSQL.Data2, pLog->guidSQL.Data3,
                pLog->guidSQL.Data4[0], pLog->guidSQL.Data4[1], pLog->guidSQL.Data4[2],
                pLog->guidSQL.Data4[3], pLog->guidSQL.Data4[4], pLog->guidSQL.Data4[5],
                pLog->guidSQL.Data4[6], pLog->guidSQL.Data4[7],
                pLog->iRunidSQL,
                pLog->szCommentSQL);
        rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
            goto Cleanup;
        }
    }

Cleanup:
    if (hstmt != NULL) SQLFreeStmt(hstmt, SQL_DROP);
    G_FREE(szSQLStmt);
    return pdhStatus;
}

PDH_FUNCTION
PdhiWriteOneSQLRecord(
    PPDHI_LOG              pLog,
    PPDHI_COUNTER          pCounter,
    DWORD                  dwCounterID,
    PPDH_RAW_COUNTER       pThisValue,
    PPDH_FMT_COUNTERVALUE  pFmtValue,
    SYSTEMTIME           * stTimeStamp,
    LPWSTR                 szDateTime,
    DWORD                  dwDateTime
)
{
    PDH_STATUS           pdhStatus = ERROR_SUCCESS;
    RETCODE              rc;
    SYSTEMTIME           st;
    PDH_FMT_COUNTERVALUE pdhValue;
    PPDH_SQL_BULK_COPY   pBulk = PdhiBindBulkCopyStructure(pLog);

    if (pThisValue->CStatus != ERROR_SUCCESS || (pThisValue->TimeStamp.dwLowDateTime == 0
                                                 && pThisValue->TimeStamp.dwHighDateTime == 0)) {
        SystemTimeToFileTime(stTimeStamp, & pThisValue->TimeStamp);
    }
    PdhpConvertFileTimeToSQLString(& (pThisValue->TimeStamp), szDateTime, dwDateTime);
    FileTimeToSystemTime(& (pThisValue->TimeStamp), & st);
    if (pBulk == NULL) {
        pdhStatus = GetLastError();
        goto Cleanup;
    }

    pBulk->dbCounterId    = dwCounterID;
    pBulk->dbRecordIndex  = pLog->dwNextRecordIdToWrite;
    pBulk->dbFirstValueA  = LODWORD(pThisValue->FirstValue);
    pBulk->dbFirstValueB  = HIDWORD(pThisValue->FirstValue);
    pBulk->dbSecondValueA = LODWORD(pThisValue->SecondValue);
    pBulk->dbSecondValueB = HIDWORD(pThisValue->SecondValue);
    pBulk->dbMultiCount   = (pCounter->plCounterInfo.dwCounterType == PERF_DOUBLE_RAW)
                          ? MULTI_COUNT_DOUBLE_RAW : pThisValue->MultiCount;
    StringCchPrintfA(pBulk->dbDateTime, TIME_FIELD_BUFF_SIZE,
            "%04d-%02d-%02d %02d:%02d:%02d.%03d",
            st.wYear, st.wMonth,  st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
    pBulk->dbCounterValue = pFmtValue->doubleValue;
    rc = bcp_sendrow(pLog->hdbcSQL);
    if (rc == FAIL) {
        TRACE((PDH_DBG_TRACE_ERROR),
              (__LINE__,
               PDH_LOGSQL,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
               PDH_SQL_EXEC_DIRECT_FAILED,
               TRACE_WSTR(pCounter->szFullName),
               TRACE_STR(pBulk->dbDateTime),
               TRACE_DWORD(pBulk->dbCounterId),
               TRACE_DWORD(pBulk->dbRecordIndex),
               TRACE_DWORD(rc),
               TRACE_DWORD(pBulk->dwRecordCount),
               NULL));
        pdhStatus = ReportSQLError(pLog, SQL_ERROR, NULL, PDH_SQL_EXEC_DIRECT_FAILED);
    }
    else {
        pBulk->dwRecordCount ++;
        if (pBulk->dwRecordCount == PDH_SQL_BULK_COPY_REC) {
            DBINT rcBCP = bcp_batch(pLog->hdbcSQL);
            if (rcBCP < 0) {
                TRACE((PDH_DBG_TRACE_ERROR),
                      (__LINE__,
                       PDH_LOGSQL,
                       0,
                       PDH_SQL_EXEC_DIRECT_FAILED,
                       TRACE_DWORD(rcBCP),
                       TRACE_DWORD(pBulk->dwRecordCount),
                       NULL));
                pdhStatus = ReportSQLError(pLog, SQL_ERROR, NULL, PDH_SQL_EXEC_DIRECT_FAILED);
            }
           pBulk->dwRecordCount = 0;
        }
    }

Cleanup:
    return pdhStatus;
}

PDH_FUNCTION
PdhiWriteSQLLogRecord(
    PPDHI_LOG   pLog,
    SYSTEMTIME  *stTimeStamp,
    LPCWSTR     szUserString
)
// write multiple CounterData rows - one for each counter.  use the
// SQLCounterID from PDHI_COUNTER, pLog->pQuery->pCounterListHead to
// get the counterid for this entry.
{
    PDH_STATUS               pdhStatus = ERROR_SUCCESS;
    PPDHI_COUNTER            pThisCounter;
    LPWSTR                   szSQLStmt = NULL;
    HSTMT                    hstmt     = NULL;    
    RETCODE                  rc;
    WCHAR                    szDateTime[TIME_FIELD_BUFF_SIZE];
    DWORD                    dwReturn;
    DWORD                    dwCounterID;
    WCHAR                  * pTimeZone;
    TIME_ZONE_INFORMATION    TimeZone;
    LONG                     lMinutesToUTC = 0;
    DBINT                    rcBCP;
    PPDH_SQL_BULK_COPY       pBulk;
    PDH_FMT_COUNTERVALUE     PdhValue;
    PPDHI_LOG_COUNTER        pSqlCounter;
    ULONGLONG                ThisTimeStamp;

    UNREFERENCED_PARAMETER(stTimeStamp);
    UNREFERENCED_PARAMETER(szUserString);

    // see if we've written to many records already
    if (0 < pLog->llMaxSize) { // ok we have a limit
        if (pLog->llMaxSize < pLog->dwNextRecordIdToWrite) {
            pdhStatus = PDH_LOG_FILE_TOO_SMALL;
            goto Cleanup;
        }
    }

    // check each counter in the list of counters for this query and
    // write them to the file
    pThisCounter = pLog->pQuery ? pLog->pQuery->pCounterListHead : NULL;

    if (pThisCounter != NULL) {
        // lock the query while we read the data so the values
        // written to the log will all be from the same sample
        WAIT_FOR_AND_LOCK_MUTEX(pThisCounter->pOwner->hMutex);
        do {
            if ((pThisCounter->dwFlags & PDHIC_MULTI_INSTANCE) != 0) {
                DWORD dwSize;
                DWORD dwItem;

                if (pThisCounter->pLastObject != NULL && pThisCounter->pLastObject != pThisCounter->pThisObject) {
                    G_FREE(pThisCounter->pLastObject);
                }
                pThisCounter->pLastObject          = pThisCounter->pThisObject;
                pThisCounter->LastValue.MultiCount = pThisCounter->ThisValue.MultiCount;
                pThisCounter->pThisObject          = NULL;
                pThisCounter->ThisValue.MultiCount = 0;
                dwSize                             = 0;
                pdhStatus                          = PDH_MORE_DATA;

                while (pdhStatus == PDH_MORE_DATA) {
                    pdhStatus = PdhiSqlGetCounterArray(
                                            pThisCounter, & dwSize, & dwItem, (LPVOID) pThisCounter->pThisObject);
                    if (pdhStatus == PDH_MORE_DATA) {
                        LPVOID pTemp = pThisCounter->pThisObject;

                        if (pTemp != NULL) {
                            pThisCounter->pThisObject = G_REALLOC(pTemp, dwSize);
                            if (pThisCounter->pThisObject == NULL) {
                                G_FREE(pTemp);
                                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                            }
                        }
                        else {
                            pThisCounter->pThisObject = G_ALLOC(dwSize);
                            if (pThisCounter->pThisObject == NULL) {
                                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                            }
                        }
                    }
                }
                if (pdhStatus == ERROR_SUCCESS) {
                    PPDH_RAW_COUNTER              pRawValue;
                    PPDH_FMT_COUNTERVALUE_ITEM_W  pFmtValue;
                    DWORD                         dwNewName       = 0;
                    DWORD                         dwCurrentName   = 0;
                    DWORD                         dwInstanceName  = 0;
                    DWORD                         dwParentName    = 0;
                    DWORD                         dwInstanceIndex = 0;
                    LPWSTR                        szInstanceName  = NULL;
                    LPWSTR                        szParentName    = NULL;
                    LPWSTR                        szTmp;

                    pThisCounter->ThisValue.MultiCount = dwItem;
                    pRawValue = (PPDH_RAW_COUNTER) (pThisCounter->pThisObject);
                    pFmtValue = (PPDH_FMT_COUNTERVALUE_ITEM_W)
                                (((LPBYTE) pThisCounter->pThisObject) + sizeof(PDH_RAW_COUNTER) * dwItem);
                    for (dwSize = 0; dwSize < dwItem; dwSize ++) {
                        dwNewName  = lstrlenW(pFmtValue->szName) + 1;
                        if (dwNewName > dwCurrentName) {
                            if (dwNewName < MAX_PATH) {
                                dwNewName = MAX_PATH;
                            }
                            dwCurrentName = dwNewName;
                            if (szInstanceName == NULL) {
                                szInstanceName = G_ALLOC(sizeof(WCHAR) * dwNewName);
                            }
                            else {
                                szTmp = szInstanceName;
                                szInstanceName = G_REALLOC(szTmp, sizeof(WCHAR) * dwNewName);
                                if (szInstanceName == NULL) {
                                    G_FREE(szTmp);
                                }
                            }
                            if (szParentName == NULL) {
                                szParentName = G_ALLOC(sizeof(WCHAR) * dwNewName);
                            }
                            else {
                                szTmp = szParentName;
                                szParentName = G_REALLOC(szTmp, sizeof(WCHAR) * dwNewName);
                                if (szParentName == NULL) {
                                    G_FREE(szTmp);
                                }
                            }
                        }
                        if (szInstanceName != NULL && szParentName != NULL) {
                            dwInstanceName  = dwParentName = dwCurrentName;
                            dwInstanceIndex = 0;
                            PdhParseInstanceNameW(pFmtValue->szName,
                                                  szInstanceName,
                                                  & dwInstanceName,
                                                  szParentName,
                                                  & dwParentName,
                                                  & dwInstanceIndex);
                            pSqlCounter = PdhiSqlFindCounter(pLog,
                                                             (PPDHI_LOG_MACHINE *) (& (pLog->pPerfmonInfo)),
                                                             pThisCounter->pCounterPath->szMachineName,
                                                             pThisCounter->pCounterPath->szObjectName,
                                                             pThisCounter->pCounterPath->szCounterName,
                                                             pThisCounter->plCounterInfo.dwCounterType,
                                                             pThisCounter->plCounterInfo.lDefaultScale,
                                                             szInstanceName,
                                                             dwInstanceIndex,
                                                             szParentName,
                                                             pThisCounter->plCounterInfo.dwParentObjectId,
                                                             pThisCounter->TimeBase,
                                                             FALSE,
                                                             TRUE);
                            ThisTimeStamp = MAKELONGLONG(pRawValue->TimeStamp.dwLowDateTime,
                                                         pRawValue->TimeStamp.dwHighDateTime);
                            if (pSqlCounter != NULL) {
                                if (pSqlCounter->dwCounterType == PERF_DOUBLE_RAW) {
                                    pSqlCounter->dwCounterType = pThisCounter->plCounterInfo.dwCounterType;
                                    pSqlCounter->TimeBase      = pThisCounter->TimeBase;
                                    pdhStatus = PdhiSQLUpdateCounterDetailTimeBase(pLog,
                                                                                   pSqlCounter->dwCounterID,
                                                                                   pThisCounter->TimeBase,
                                                                                   FALSE);
                                    if (pdhStatus != ERROR_SUCCESS) {
                                        pSqlCounter->dwCounterType = PERF_DOUBLE_RAW;
                                        pSqlCounter->TimeBase      = 0;
                                    }
                                }
                                if (pSqlCounter->TimeStamp < ThisTimeStamp) {
                                    dwCounterID = pSqlCounter->dwCounterID;
                                    pSqlCounter->TimeStamp = ThisTimeStamp;
                                    if (dwCounterID == 0) {
                                        TRACE((PDH_DBG_TRACE_WARNING),
                                              (__LINE__,
                                               PDH_LOGSQL,
                                               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2) | ARG_DEF(ARG_TYPE_WSTR, 3),
                                               ERROR_SUCCESS,
                                               TRACE_WSTR(pThisCounter->pCounterPath->szCounterName),
                                               TRACE_WSTR(szInstanceName),
                                               TRACE_WSTR(szParentName),
                                               TRACE_DWORD(dwInstanceIndex),
                                               NULL));
                                    }
                                    pdhStatus = PdhiWriteOneSQLRecord(pLog,
                                                                      pThisCounter,
                                                                      dwCounterID,
                                                                      pRawValue,
                                                                      & (pFmtValue->FmtValue),
                                                                      stTimeStamp,
                                                                      szDateTime, TIME_FIELD_BUFF_SIZE);
                                }
                                else {
                                    TRACE((PDH_DBG_TRACE_WARNING),
                                          (__LINE__,
                                           PDH_LOGSQL,
                                           ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2) | ARG_DEF(ARG_TYPE_ULONG64, 3),
                                           ERROR_SUCCESS,
                                           TRACE_WSTR(pThisCounter->szFullName),
                                           TRACE_WSTR(szInstanceName),
                                           TRACE_LONG64(ThisTimeStamp),
                                           TRACE_DWORD(pThisCounter->plCounterInfo.dwSQLCounterId),
                                           NULL));
                                }
                            }
                            else {
                                TRACE((PDH_DBG_TRACE_WARNING),
                                      (__LINE__,
                                       PDH_LOGSQL,
                                       ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2) | ARG_DEF(ARG_TYPE_ULONG64, 3),
                                       ERROR_SUCCESS,
                                       TRACE_WSTR(pThisCounter->szFullName),
                                       TRACE_WSTR(szInstanceName),
                                       TRACE_LONG64(ThisTimeStamp),
                                       NULL));
                            }
                        }
                        else {
                            G_FREE(szInstanceName);
                            G_FREE(szParentName);
                            szInstanceName = szParentName = NULL;
                            dwCurrentName  = dwNewName    = 0;
                            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        }
                        pRawValue = (PPDH_RAW_COUNTER)
                                    (((LPBYTE) pRawValue) + sizeof(PDH_RAW_COUNTER));
                        pFmtValue = (PPDH_FMT_COUNTERVALUE_ITEM_W)
                                    (((LPBYTE) pFmtValue) + sizeof(PDH_FMT_COUNTERVALUE_ITEM_W));
                    }
                    G_FREE(szInstanceName);
                    G_FREE(szParentName);
                }
            }
            else {
                pSqlCounter   = (PPDHI_LOG_COUNTER) pThisCounter->pBTreeNode;
                ThisTimeStamp = MAKELONGLONG(pThisCounter->ThisValue.TimeStamp.dwLowDateTime,
                                             pThisCounter->ThisValue.TimeStamp.dwHighDateTime);
                if (pSqlCounter != NULL) {
                    if (pSqlCounter->TimeStamp < ThisTimeStamp) {
                        dwCounterID = pThisCounter->plCounterInfo.dwSQLCounterId;
                        pSqlCounter->TimeStamp = ThisTimeStamp;
                        pdhStatus = PdhiComputeFormattedValue(pThisCounter->CalcFunc,
                                                              pThisCounter->plCounterInfo.dwCounterType,
                                                              pThisCounter->lScale,
                                                              PDH_FMT_DOUBLE | PDH_FMT_NOCAP100,
                                                              & (pThisCounter->ThisValue),
                                                              & (pThisCounter->LastValue),
                                                              & (pThisCounter->TimeBase),
                                                              0L,
                                                              & PdhValue);
                        if ((pdhStatus != ERROR_SUCCESS) || (   (PdhValue.CStatus != PDH_CSTATUS_VALID_DATA)
                                                             && (PdhValue.CStatus != PDH_CSTATUS_NEW_DATA))) {
                            PdhValue.doubleValue = 0.0;
                        }
                        if (dwCounterID == 0) {
                            TRACE((PDH_DBG_TRACE_WARNING),
                                  (__LINE__,
                                   PDH_LOGSQL,
                                   ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2) | ARG_DEF(ARG_TYPE_WSTR, 3),
                                   ERROR_SUCCESS,
                                   TRACE_WSTR(pThisCounter->pCounterPath->szCounterName),
                                   TRACE_WSTR(pThisCounter->pCounterPath->szInstanceName),
                                   TRACE_WSTR(pThisCounter->pCounterPath->szParentName),
                                   TRACE_DWORD(pThisCounter->pCounterPath->dwIndex),
                                   NULL));
                        }
                        pdhStatus   = PdhiWriteOneSQLRecord(pLog,
                                                            pThisCounter,
                                                            dwCounterID,
                                                            & (pThisCounter->ThisValue),
                                                            & PdhValue,
                                                            stTimeStamp,
                                                            szDateTime, TIME_FIELD_BUFF_SIZE);
                    }
                    else {
                        TRACE((PDH_DBG_TRACE_WARNING),
                              (__LINE__,
                               PDH_LOGSQL,
                               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_ULONG64, 2),
                               ERROR_SUCCESS,
                               TRACE_WSTR(pThisCounter->szFullName),
                               TRACE_LONG64(ThisTimeStamp),
                               TRACE_DWORD(pThisCounter->plCounterInfo.dwSQLCounterId),
                               NULL));
                    }
                }
                else {
                    TRACE((PDH_DBG_TRACE_WARNING),
                          (__LINE__,
                           PDH_LOGSQL,
                           ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_ULONG64, 2),
                           ERROR_SUCCESS,
                           TRACE_WSTR(pThisCounter->szFullName),
                           TRACE_LONG64(ThisTimeStamp),
                           NULL));
                }
            }
            pThisCounter = pThisCounter->next.flink; // go to next in list
        }
        while (pThisCounter != pLog->pQuery->pCounterListHead);
        // free (i.e. unlock) the query

        rcBCP = bcp_batch(pLog->hdbcSQL);
        if (rcBCP < 0) {
            pBulk = (PPDH_SQL_BULK_COPY) pLog->lpMappedFileBase;
            if (pBulk != NULL) {
                TRACE((PDH_DBG_TRACE_WARNING),
                      (__LINE__,
                       PDH_LOGSQL,
                       0,
                       PDH_SQL_EXEC_DIRECT_FAILED,
                       TRACE_DWORD(rcBCP),
                       TRACE_DWORD(pBulk->dwRecordCount),
                       NULL));
                pBulk->dwRecordCount = 0;
            }
            pdhStatus = ReportSQLError(pLog, SQL_ERROR, NULL, PDH_SQL_EXEC_DIRECT_FAILED);
        }

        RELEASE_MUTEX(pThisCounter->pOwner->hMutex);
        pLog->dwNextRecordIdToWrite++;
    }

    szSQLStmt = (LPWSTR) G_ALLOC(SQLSTMTSIZE * sizeof(WCHAR));
    if (szSQLStmt == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    // if this is the first record then save the start time in DisplayToID
    // we also need to write the DisplayToID record at this point (we just incremented
    // so check for 2)

    if (2 == pLog->dwNextRecordIdToWrite) {
        // allocate an hstmt
        rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        }
        else {
            // szDateTime should have the correct date & time in it from above.
            // get MinutesToUTC
            //
            dwReturn = GetTimeZoneInformation(& TimeZone);
            if (dwReturn != TIME_ZONE_ID_INVALID) {
                if (dwReturn == TIME_ZONE_ID_DAYLIGHT)  {
                    pTimeZone     = TimeZone.DaylightName;
                    lMinutesToUTC = TimeZone.Bias + TimeZone.DaylightBias;
                }
                else {
                    pTimeZone     = TimeZone.StandardName;
                    lMinutesToUTC = TimeZone.Bias + TimeZone.StandardBias;
                }

                StringCchPrintfW(szSQLStmt, SQLSTMTSIZE,
                        L"update DisplayToID set LogStartTime = '%ws', MinutesToUTC = %d, TimeZoneName = '%ws' where GUID = '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x'",
                        szDateTime, lMinutesToUTC,pTimeZone,
                        pLog->guidSQL.Data1, pLog->guidSQL.Data2, pLog->guidSQL.Data3,
                        pLog->guidSQL.Data4[0], pLog->guidSQL.Data4[1], pLog->guidSQL.Data4[2],
                        pLog->guidSQL.Data4[3], pLog->guidSQL.Data4[4], pLog->guidSQL.Data4[5],
                        pLog->guidSQL.Data4[6], pLog->guidSQL.Data4[7]);
                rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
                if (! SQLSUCCEEDED(rc)) {
                    pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
                }
                SQLFreeStmt(hstmt, SQL_DROP);
            }
            else {
                pdhStatus = PDH_LOG_FILE_CREATE_ERROR;
            }
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        }
        else {
            StringCchPrintfW(szSQLStmt, SQLSTMTSIZE,
                    L"update DisplayToID set LogStopTime = '%ws', NumberOfRecords = %d where GUID = '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x'",
                    szDateTime,
                    (pLog->dwNextRecordIdToWrite - 1),
                    pLog->guidSQL.Data1,
                    pLog->guidSQL.Data2,
                    pLog->guidSQL.Data3,
                    pLog->guidSQL.Data4[0],
                    pLog->guidSQL.Data4[1],
                    pLog->guidSQL.Data4[2],
                    pLog->guidSQL.Data4[3],
                    pLog->guidSQL.Data4[4],
                    pLog->guidSQL.Data4[5],
                    pLog->guidSQL.Data4[6],
                    pLog->guidSQL.Data4[7]);
            rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
            if (! SQLSUCCEEDED(rc)) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
            }
            SQLFreeStmt(hstmt, SQL_DROP);
        }
    }

Cleanup:
    G_FREE(szSQLStmt);
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumMachinesFromSQLLog(
    PPDHI_LOG   pLog,
    LPVOID      pBuffer,
    LPDWORD     lpdwBufferSize,
    BOOL        bUnicodeDest
)
{
    PDH_STATUS Status = ERROR_SUCCESS;

    Status = PdhpGetSQLLogHeader(pLog);
    if (Status == ERROR_SUCCESS) {
        PPDHI_SQL_LOG_INFO pLogInfo = (PPDHI_SQL_LOG_INFO) pLog->pPerfmonInfo;
        if (pLogInfo == NULL) {
            Status = PDH_LOG_FILE_OPEN_ERROR;
        }
        else {
            Status = PdhiEnumCachedMachines(pLogInfo->MachineList, pBuffer, lpdwBufferSize, bUnicodeDest);
        }
    }
    return Status;
}

PDH_FUNCTION
PdhiEnumObjectsFromSQLLog(
    PPDHI_LOG   pLog,
    LPCWSTR     szMachineName,
    LPVOID      pBuffer,
    LPDWORD     lpdwBufferSize,
    DWORD       dwDetailLevel,
    BOOL        bUnicodeDest
)
{
    PDH_STATUS Status = ERROR_SUCCESS;

    Status = PdhpGetSQLLogHeader(pLog);
    if (Status == ERROR_SUCCESS) {
        PPDHI_SQL_LOG_INFO pLogInfo = (PPDHI_SQL_LOG_INFO) pLog->pPerfmonInfo;
        if (pLogInfo == NULL) {
            Status = PDH_LOG_FILE_OPEN_ERROR;
        }
        else {
            Status = PdhiEnumCachedObjects(
                    pLogInfo->MachineList, szMachineName, pBuffer, lpdwBufferSize, dwDetailLevel, bUnicodeDest);
        }
    }
    return Status;
}

PDH_FUNCTION
PdhiEnumObjectItemsFromSQLLog(
    PPDHI_LOG          pLog,
    LPCWSTR            szMachineName,
    LPCWSTR            szObjectName,
    PDHI_COUNTER_TABLE CounterTable,
    DWORD              dwDetailLevel,
    DWORD              dwFlags
)
{
    PDH_STATUS Status = ERROR_SUCCESS;

    Status = PdhpGetSQLLogHeader(pLog);
    if (Status == ERROR_SUCCESS) {
        PPDHI_SQL_LOG_INFO pLogInfo = (PPDHI_SQL_LOG_INFO) pLog->pPerfmonInfo;
        if (pLogInfo == NULL) {
            Status = PDH_LOG_FILE_OPEN_ERROR;
        }
        else {
            Status = PdhiEnumCachedObjectItems(
                    pLogInfo->MachineList, szMachineName, szObjectName, CounterTable, dwDetailLevel, dwFlags);
        }
    }
    return Status;
}

PDH_FUNCTION
PdhiGetMatchingSQLLogRecord(
    PPDHI_LOG   pLog,
    LONGLONG  * pStartTime,
    LPDWORD     pdwIndex
)
{
    PDH_STATUS    pdhStatus    = ERROR_SUCCESS;
    LPWSTR        szSQLStmt    = NULL;
    HSTMT         hstmt        = NULL;    
    RETCODE       rc;
    DWORD         dwRecordIndex;
    LONGLONG      locStartTime = (* pStartTime) - 10;
    WCHAR         szStartDate[TIME_FIELD_BUFF_SIZE];

    szSQLStmt = (LPWSTR) G_ALLOC(SQLSTMTSIZE * sizeof(WCHAR));
    if (szSQLStmt == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }
    PdhpConvertFileTimeToSQLString((LPFILETIME) (& locStartTime), szStartDate, TIME_FIELD_BUFF_SIZE);
    StringCchPrintfW(szSQLStmt, SQLSTMTSIZE,
            L"select MIN(RecordIndex) from CounterData where GUID = '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x' and CounterDateTime >= '%ws'",
            pLog->guidSQL.Data1, pLog->guidSQL.Data2, pLog->guidSQL.Data3,
            pLog->guidSQL.Data4[0], pLog->guidSQL.Data4[1], pLog->guidSQL.Data4[2],
            pLog->guidSQL.Data4[3], pLog->guidSQL.Data4[4], pLog->guidSQL.Data4[5],
            pLog->guidSQL.Data4[6], pLog->guidSQL.Data4[7], szStartDate);
    // allocate an hstmt
    rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 1, SQL_C_LONG, & dwRecordIndex, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    // execute the select statement
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
        goto Cleanup;
    }
    rc = SQLFetch(hstmt);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_FETCH_FAILED);
        goto Cleanup;
    }
    if (SQL_NO_DATA == rc) {
        pdhStatus = PDH_NO_DATA;
        goto Cleanup;
    }
    pLog->dwLastRecordRead = dwRecordIndex;
    * pdwIndex = dwRecordIndex;

Cleanup:
    if (hstmt) SQLFreeStmt(hstmt, SQL_DROP);
    G_FREE(szSQLStmt);
    return pdhStatus;
}

PDH_FUNCTION
PdhiBuildCounterCacheFromSQLLog(
    PPDHI_LOG           pLog,
    PPDHI_SQL_LOG_INFO  pLogInfo,
    DWORD               dwIndex
)
{
    PDH_STATUS         pdhStatus  = ERROR_SUCCESS;
    PPDHI_QUERY        pQuery     = NULL;
    PPDHI_COUNTER      pCounter   = NULL;
    DWORD              dwRequest  = 0;
    DWORD              dwIncrease = 0;
    DWORD              dwTotal    = 0;
    LPWSTR             szSQLStmt  = NULL;
    LPWSTR             szCurrent;
    HSTMT              hstmt      = NULL;
    RETCODE            rc;
    FILETIME           ftCounterDateTime;
    BOOL               bCounterDateTime = FALSE;
    DWORD              dwCounterId;
    LARGE_INTEGER      i64FirstValue;
    LARGE_INTEGER      i64SecondValue;
    DWORD              dwMultiCount;
    DOUBLE             dCounterValue = 0.0;
    WCHAR              szCounterDateTime[TIME_FIELD_BUFF_SIZE];
    SQLLEN             dwCounterIdSize        = 0;
    SQLLEN             dwLowFirstValueSize    = 0;
    SQLLEN             dwHighFirstValueSize   = 0;
    SQLLEN             dwLowSecondValueSize   = 0;
    SQLLEN             dwHighSecondValueSize  = 0;
    SQLLEN             dwMultiCountSize       = 0;
    SQLLEN             dwCounterValueSize     = 0;
    SQLLEN             dwDateTimeSize         = 0;
    PPDHI_SQL_LOG_DATA pLogData;
    BOOL               bNewStmt;
    BOOL               bQueryNow;

    if (pLogInfo->dwRunId == dwIndex) {
        return ERROR_SUCCESS;
    }
    else if (dwIndex >= pLog->dwNextRecordIdToWrite) {
        return PDH_NO_MORE_DATA;
    }
    else {
        pQuery = pLog->pQuery;
        if (pQuery == NULL) return PDH_INVALID_HANDLE;
    }

    pCounter = pQuery->pCounterListHead;
    if (pCounter == NULL) goto Cleanup;

    szSQLStmt = (LPWSTR) G_ALLOC(SQLSTMTSIZE * sizeof(WCHAR));
    if (szSQLStmt == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    bNewStmt  = TRUE;
    bQueryNow = FALSE;
    do {
        if (bNewStmt) {
            ZeroMemory(szSQLStmt, SQLSTMTSIZE * sizeof(WCHAR));
            szCurrent  = szSQLStmt;
            StringCchPrintfW(szCurrent, SQLSTMTSIZE,
                    L"select CounterID, FirstValueA, FirstValueB, SecondValueA, SecondValueB, MultiCount, CounterDateTime, CounterValue from CounterData where GUID = '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x' and RecordIndex = %d and CounterID IN (",
                    pLog->guidSQL.Data1,    pLog->guidSQL.Data2,    pLog->guidSQL.Data3,
                    pLog->guidSQL.Data4[0], pLog->guidSQL.Data4[1], pLog->guidSQL.Data4[2],
                    pLog->guidSQL.Data4[3], pLog->guidSQL.Data4[4], pLog->guidSQL.Data4[5],
                    pLog->guidSQL.Data4[6], pLog->guidSQL.Data4[7],
                    dwIndex);
            dwTotal    = lstrlenW(szCurrent);
            szCurrent  = szSQLStmt + dwTotal;
            StringCchPrintfW(szCurrent, SQLSTMTSIZE - dwTotal, L"%d", pCounter->plCounterInfo.dwSQLCounterId);
            dwIncrease = lstrlenW(szCurrent);
            bNewStmt   = FALSE;
            bQueryNow  = FALSE;
        }
        else if (dwTotal + SQL_COUNTER_ID_SIZE < SQLSTMTSIZE) {
            szCurrent  = szSQLStmt + dwTotal;
            StringCchPrintfW(szCurrent, SQLSTMTSIZE - dwTotal, L",%d", pCounter->plCounterInfo.dwSQLCounterId);
            dwIncrease = lstrlenW(szCurrent);
        }
        else {
            bQueryNow  = TRUE;
            dwIncrease = 0;
        }
        pCounter  = pCounter->next.flink;
        dwTotal  += dwIncrease;

        if (bQueryNow != TRUE && pCounter != NULL && pCounter != pQuery->pCounterListHead) continue;

        szCurrent  = szSQLStmt + dwTotal;
        StringCchCopyW(szCurrent, SQLSTMTSIZE - dwTotal, L")");
        dwIncrease = lstrlenW(szCurrent);
        bNewStmt   = TRUE;
        bQueryNow  = FALSE;

        // allocate an hstmt
        rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
            goto Cleanup;
        }
        // bind the columns
        rc = SQLBindCol(hstmt, 1, SQL_C_LONG, & dwCounterId, 0, & dwCounterIdSize);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
            goto Cleanup;
        }
        rc = SQLBindCol(hstmt, 2, SQL_C_LONG, & i64FirstValue.LowPart, 0, & dwLowFirstValueSize);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
            goto Cleanup;
        }
        rc = SQLBindCol(hstmt, 3, SQL_C_LONG, & i64FirstValue.HighPart, 0, & dwHighFirstValueSize);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
            goto Cleanup;
        }
        rc = SQLBindCol(hstmt, 4, SQL_C_LONG, & i64SecondValue.LowPart, 0, & dwLowSecondValueSize);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
            goto Cleanup;
        }
        rc = SQLBindCol(hstmt, 5, SQL_C_LONG, & i64SecondValue.HighPart, 0, & dwHighSecondValueSize);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
            goto Cleanup;
        }
        rc = SQLBindCol(hstmt, 6, SQL_C_LONG, & dwMultiCount, 0, & dwMultiCountSize);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
            goto Cleanup;
        }
        rc = SQLBindCol(hstmt, 7, SQL_C_WCHAR, szCounterDateTime, sizeof(szCounterDateTime), & dwDateTimeSize);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
            goto Cleanup;
        }
        rc = SQLBindCol(hstmt, 8, SQL_C_DOUBLE, & dCounterValue, 0, & dwCounterValueSize);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
            goto Cleanup;
        }
        // execute the select statement
        rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
            goto Cleanup;
        }
        rc = SQLFetch(hstmt);
        while (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO) {
            PdhpConvertSQLStringToFileTime(szCounterDateTime, & ftCounterDateTime);
            bCounterDateTime = TRUE;
            if (dwCounterId >= pLogInfo->dwMinCounter && dwCounterId <= pLogInfo->dwMaxCounter) {
                pLogData = pLogInfo->LogData[dwCounterId - pLogInfo->dwMinCounter];
                if (pLogData == NULL) {
                    pLogData = (PPDHI_SQL_LOG_DATA) G_ALLOC(sizeof(PDHI_SQL_LOG_DATA));
                    if (pLogData != NULL) {
                        pLogInfo->LogData[dwCounterId - pLogInfo->dwMinCounter] = pLogData;
                    }
                    else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        goto Cleanup;
                    }
                }
                pLogData->dwRunId              = dwIndex;
                pLogData->RawData.CStatus      = PDH_CSTATUS_VALID_DATA;
                pLogData->RawData.FirstValue   = i64FirstValue.QuadPart;
                pLogData->RawData.MultiCount   = dwMultiCount;
                pLogData->RawData.SecondValue  = i64SecondValue.QuadPart;
                pLogData->dFormattedValue      = dCounterValue;
                pLogData->RawData.TimeStamp    = ftCounterDateTime;
            }
            rc = SQLFetch(hstmt);
        }

        if (SQL_NO_DATA == rc) {
        }
        else if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_FETCH_FAILED);
            goto Cleanup;
        }

        if (hstmt) {
            SQLFreeStmt(hstmt, SQL_DROP);
            hstmt = NULL;
        }
    }
    while (pCounter != NULL && pCounter != pQuery->pCounterListHead);

    if (bCounterDateTime) {
        pLogInfo->dwRunId    = dwIndex;
        pLogInfo->RecordTime = ftCounterDateTime;
    }

Cleanup:
    if (hstmt) SQLFreeStmt(hstmt, SQL_DROP);
    G_FREE(szSQLStmt);
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetCounterValueFromSQLLog(
    PPDHI_LOG           pLog,
    DWORD               dwIndex,
    PPDHI_COUNTER       pCounter,
    PPDH_RAW_COUNTER    pValue
)
{
    PDH_STATUS         Status      = ERROR_SUCCESS;
    PPDHI_SQL_LOG_INFO pLogInfo    = NULL;
    DWORD              dwCtrIndex  = 0;
    PPDHI_SQL_LOG_DATA pLogData    = NULL;

    Status = PdhpGetSQLLogHeader(pLog);
    if (Status != ERROR_SUCCESS) goto Cleanup;

    pLogInfo = (PPDHI_SQL_LOG_INFO) pLog->pPerfmonInfo;
    if (pLogInfo == NULL) {
        Status = PDH_LOG_FILE_OPEN_ERROR;
        goto Cleanup;
    }

    Status = PdhiBuildCounterCacheFromSQLLog(pLog, pLogInfo, dwIndex);
    if (Status != ERROR_SUCCESS) goto Cleanup;

    dwCtrIndex = pCounter->plCounterInfo.dwSQLCounterId;
    if (dwCtrIndex >= pLogInfo->dwMinCounter && dwCtrIndex <= pLogInfo->dwMaxCounter) {
        pLogData = pLogInfo->LogData[dwCtrIndex - pLogInfo->dwMinCounter];
        if (pLogData != NULL && pLogData->dwRunId == dwIndex) {
            RtlCopyMemory(pValue, & pLogData->RawData, sizeof(PDH_RAW_COUNTER));
            if (pLogData->RawData.MultiCount == MULTI_COUNT_DOUBLE_RAW) {
                pCounter->plCounterInfo.dwCounterType = PERF_DOUBLE_RAW;
                pValue->MultiCount                    = 1;
            }
            else if (pCounter->plCounterInfo.dwCounterType == PERF_DOUBLE_RAW) {
                (double) pValue->FirstValue = pLogData->dFormattedValue;
                pValue->SecondValue         = 0;
                pValue->MultiCount          = 1;
            }
        }
        else {
            pValue->CStatus     = PDH_CSTATUS_INVALID_DATA;
            pValue->TimeStamp   = pLogInfo->RecordTime;
            pValue->FirstValue  = 0;
            pValue->SecondValue = 0;
            pValue->MultiCount  = 1;
        }
    }
    else {
        Status = PDH_CSTATUS_NO_COUNTER;
    }

Cleanup:
    return Status;
}

PDH_FUNCTION
PdhiGetTimeRangeFromSQLLog(
    PPDHI_LOG       pLog,
    LPDWORD         pdwNumEntries,
    PPDH_TIME_INFO  pInfo,
    LPDWORD         pdwBufferSize
)
{
    PDH_STATUS  pdhStatus        = ERROR_SUCCESS;
    LONGLONG    llStartTime      = MAX_TIME_VALUE;
    LONGLONG    llEndTime        = MIN_TIME_VALUE;
    SQLLEN      dwStartTimeStat;
    SQLLEN      dwEndTimeStat;
    HSTMT       hstmt            = NULL;    
    RETCODE     rc;
    WCHAR       szStartTime[TIME_FIELD_BUFF_SIZE];
    WCHAR       szEndTime[TIME_FIELD_BUFF_SIZE];
    DWORD       dwNumberOfRecords;
    SQLLEN      dwNumRecStat;
    LPWSTR      szSQLStmt        = NULL;

    szSQLStmt = (LPWSTR) G_ALLOC(SQLSTMTSIZE * sizeof(WCHAR));
    if (szSQLStmt == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    StringCchPrintfW(szSQLStmt, SQLSTMTSIZE,
            L"select LogStartTime, LogStopTime, NumberOfRecords from DisplayToID where GUID = '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x'",
            pLog->guidSQL.Data1, pLog->guidSQL.Data2, pLog->guidSQL.Data3,
            pLog->guidSQL.Data4[0], pLog->guidSQL.Data4[1], pLog->guidSQL.Data4[2],
            pLog->guidSQL.Data4[3], pLog->guidSQL.Data4[4], pLog->guidSQL.Data4[5],
            pLog->guidSQL.Data4[6], pLog->guidSQL.Data4[7]);
    // allocate an hstmt
    rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }
    // bind the date columns column
    rc = SQLBindCol(hstmt, 1, SQL_C_WCHAR, szStartTime, TIME_FIELD_BUFF_SIZE * sizeof(WCHAR), & dwStartTimeStat);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 2, SQL_C_WCHAR, szEndTime, TIME_FIELD_BUFF_SIZE * sizeof(WCHAR), & dwEndTimeStat);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 3, SQL_C_LONG, &dwNumberOfRecords, 0, & dwNumRecStat);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    // execute the select statement
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
        goto Cleanup;
    }
    rc = SQLFetch(hstmt);
    if (SQL_NO_DATA == rc) {
        pdhStatus = PDH_NO_DATA;
        goto Cleanup;
    }

    // if anything is missing - could try and re-create from existing log file
    if (SQL_NULL_DATA == dwStartTimeStat || SQL_NULL_DATA == dwEndTimeStat || SQL_NULL_DATA == dwNumRecStat) {
        pdhStatus = PDH_INVALID_DATA;
        goto Cleanup;
    }

    // convert the dates
    PdhpConvertSQLStringToFileTime(szStartTime, (LPFILETIME) & llStartTime);
    PdhpConvertSQLStringToFileTime(szEndTime,   (LPFILETIME) & llEndTime);

    // we have the info so update the args.
    if (* pdwBufferSize >=  sizeof(PDH_TIME_INFO)) {
        * (LONGLONG *) (& pInfo->StartTime) = llStartTime;
        * (LONGLONG *) (& pInfo->EndTime)   = llEndTime;
        pInfo->SampleCount                  = dwNumberOfRecords;
        * pdwBufferSize                     = sizeof(PDH_TIME_INFO);
        * pdwNumEntries                     = 1;
    }

Cleanup:
    if (hstmt) SQLFreeStmt(hstmt, SQL_DROP);
    G_FREE(szSQLStmt);
    return pdhStatus;
}

PDH_FUNCTION
PdhiReadRawSQLLogRecord(
    PPDHI_LOG             pLog,
    FILETIME            * ftRecord,
    PPDH_RAW_LOG_RECORD   pBuffer,
    LPDWORD               pdwBufferLength
)
{
    UNREFERENCED_PARAMETER(pLog);
    UNREFERENCED_PARAMETER(ftRecord);
    UNREFERENCED_PARAMETER(pBuffer);
    UNREFERENCED_PARAMETER(pdwBufferLength);
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION
PdhpGetSQLLogHeader(
    PPDHI_LOG pLog
)
{
    PDH_STATUS         pdhStatus       = ERROR_SUCCESS;
    PPDHI_SQL_LOG_INFO pLogInfo;
    HSTMT              hstmt           = NULL;
    RETCODE            rc;
    LPWSTR             szSQLStmt       = NULL;
    LPWSTR             szMachineNamel  = NULL;
    LPWSTR             szObjectNamel   = NULL;
    LPWSTR             szCounterNamel  = NULL;
    LPWSTR             szInstanceNamel = NULL;
    LPWSTR             szParentNamel   = NULL;
    DWORD              dwInstanceIndexl;
    DWORD              dwParentObjIdl;
    DWORD              dwSQLCounterIdl;
    DWORD              dwCounterTypel;
    LARGE_INTEGER      lTimeBase;
    LONG               lDefaultScalel;
    SQLLEN             dwMachineNameLen;
    SQLLEN             dwObjectNameLen;
    SQLLEN             dwCounterNameLen;
    SQLLEN             dwInstanceNameLen;
    SQLLEN             dwParentNameLen;
    SQLLEN             dwInstanceIndexStat;
    SQLLEN             dwParentObjIdStat;
    SQLLEN             dwTimeBaseA;
    SQLLEN             dwTimeBaseB;
    SQLLEN             dwSQLCounterId;

    if (pLog->pPerfmonInfo != NULL) return ERROR_SUCCESS;

    pLogInfo  = (PPDHI_SQL_LOG_INFO) G_ALLOC(sizeof(PDHI_SQL_LOG_INFO));
    szSQLStmt = (LPWSTR) G_ALLOC((SQLSTMTSIZE + 5 * PDH_SQL_STRING_SIZE) * sizeof(WCHAR));
    if (pLogInfo == NULL || szSQLStmt == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    pLog->pPerfmonInfo = pLogInfo;
    szMachineNamel  = szSQLStmt + SQLSTMTSIZE;
    szObjectNamel   = szMachineNamel  + PDH_SQL_STRING_SIZE;
    szCounterNamel  = szObjectNamel   + PDH_SQL_STRING_SIZE;
    szInstanceNamel = szCounterNamel  + PDH_SQL_STRING_SIZE;
    szParentNamel   = szInstanceNamel + PDH_SQL_STRING_SIZE;

    rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }
    StringCchPrintfW(szSQLStmt, SQLSTMTSIZE,
            L"select MAX(CounterID) from CounterData where GUID = '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x' ",
            pLog->guidSQL.Data1,    pLog->guidSQL.Data2,    pLog->guidSQL.Data3,
            pLog->guidSQL.Data4[0], pLog->guidSQL.Data4[1], pLog->guidSQL.Data4[2],
            pLog->guidSQL.Data4[3], pLog->guidSQL.Data4[4], pLog->guidSQL.Data4[5],
            pLog->guidSQL.Data4[6], pLog->guidSQL.Data4[7]);
    rc = SQLBindCol(hstmt, 1, SQL_C_LONG, & pLogInfo->dwMaxCounter, 0, & dwSQLCounterId);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
        goto Cleanup;
    }
    rc = SQLFetch(hstmt);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_FETCH_FAILED);
        goto Cleanup;
    }
    SQLFreeStmt(hstmt, SQL_DROP);
    hstmt = NULL;

    rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }
    StringCchPrintfW(szSQLStmt, SQLSTMTSIZE,
            L"select MIN(CounterID) from CounterData where GUID = '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x' ",
            pLog->guidSQL.Data1,    pLog->guidSQL.Data2,    pLog->guidSQL.Data3,
            pLog->guidSQL.Data4[0], pLog->guidSQL.Data4[1], pLog->guidSQL.Data4[2],
            pLog->guidSQL.Data4[3], pLog->guidSQL.Data4[4], pLog->guidSQL.Data4[5],
            pLog->guidSQL.Data4[6], pLog->guidSQL.Data4[7]);
    rc = SQLBindCol(hstmt, 1, SQL_C_LONG, & pLogInfo->dwMinCounter, 0, & dwSQLCounterId);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
        goto Cleanup;
    }
    rc = SQLFetch(hstmt);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_FETCH_FAILED);
        goto Cleanup;
    }
    SQLFreeStmt(hstmt, SQL_DROP);
    hstmt = NULL;

    pLogInfo->LogData = (PPDHI_SQL_LOG_DATA * )
                        G_ALLOC((pLogInfo->dwMaxCounter - pLogInfo->dwMinCounter + 1) * sizeof(PPDHI_SQL_LOG_DATA));
    if (pLogInfo->LogData == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }
    StringCchPrintfW(szSQLStmt, SQLSTMTSIZE,
            L"select distinct MachineName, ObjectName, CounterName, CounterType, DefaultScale, InstanceName, InstanceIndex, ParentName, ParentObjectID, CounterID, TimeBaseA, TimeBaseB from CounterDetails where CounterID in (select distinct CounterID from CounterData where GUID = '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x') Order by MachineName, ObjectName, CounterName, InstanceName, InstanceIndex ",
            pLog->guidSQL.Data1,    pLog->guidSQL.Data2,    pLog->guidSQL.Data3,
            pLog->guidSQL.Data4[0], pLog->guidSQL.Data4[1], pLog->guidSQL.Data4[2],
            pLog->guidSQL.Data4[3], pLog->guidSQL.Data4[4], pLog->guidSQL.Data4[5],
            pLog->guidSQL.Data4[6], pLog->guidSQL.Data4[7]);

    // note SQL returns the size in bytes without the terminating character
    rc = SQLBindCol(hstmt, 1, SQL_C_WCHAR, szMachineNamel, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwMachineNameLen);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 2, SQL_C_WCHAR, szObjectNamel, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwObjectNameLen);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 3, SQL_C_WCHAR, szCounterNamel, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwCounterNameLen);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 4, SQL_C_LONG, & dwCounterTypel, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 5, SQL_C_LONG, & lDefaultScalel, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    // check for SQL_NULL_DATA on the index's and on Instance Name & Parent Name
    rc = SQLBindCol(hstmt, 6, SQL_C_WCHAR, szInstanceNamel, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwInstanceNameLen);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 7, SQL_C_LONG, & dwInstanceIndexl, 0, & dwInstanceIndexStat);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 8, SQL_C_WCHAR, szParentNamel, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwParentNameLen);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 9, SQL_C_LONG, & dwParentObjIdl, 0, & dwParentObjIdStat);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 10, SQL_C_LONG, & dwSQLCounterIdl, 0, & dwSQLCounterId);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 11, SQL_C_LONG, & lTimeBase.LowPart, 0, & dwTimeBaseA);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }
    rc = SQLBindCol(hstmt, 12, SQL_C_LONG, & lTimeBase.HighPart, 0, & dwTimeBaseB);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto Cleanup;
    }

    // execute the sql command
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
        goto Cleanup;
    }
    rc = SQLFetch(hstmt);
    while (rc != SQL_NO_DATA) {
        PPDHI_LOG_COUNTER pCounter;

        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_FETCH_FAILED);
            break;
        }
        else {
            LPWSTR szInstance = (dwInstanceNameLen != SQL_NULL_DATA) ? (szInstanceNamel) : (NULL);
            LPWSTR szParent   = (dwParentNameLen   != SQL_NULL_DATA) ? (szParentNamel)   : (NULL);

            if (dwInstanceIndexStat == SQL_NULL_DATA) dwInstanceIndexl = 0;
            if (dwParentObjIdStat   == SQL_NULL_DATA) dwParentObjIdl   = 0;

            pCounter = PdhiFindLogCounter(pLog,
                                          & pLogInfo->MachineList,
                                          szMachineNamel,
                                          szObjectNamel,
                                          szCounterNamel,
                                          dwCounterTypel,
                                          lDefaultScalel,
                                          szInstance,
                                          dwInstanceIndexl,
                                          szParent,
                                          dwParentObjIdl,
                                          & dwSQLCounterIdl,
                                          TRUE);
            if (pCounter == NULL) {
                pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_CSTATUS_NO_COUNTER);
                break;
            }
            if (dwTimeBaseA != SQL_NULL_DATA && dwTimeBaseB != SQL_NULL_DATA) {
                pCounter->TimeBase = lTimeBase.QuadPart;
            }
            else {
                pCounter->dwCounterType  = PERF_DOUBLE_RAW;
                pCounter->TimeBase       = 0;
                pCounter->dwDefaultScale = 0;
            }
        }
        rc = SQLFetch(hstmt);
    }

Cleanup:
    if (hstmt) SQLFreeStmt(hstmt, SQL_DROP);
    G_FREE(szSQLStmt);
    if (pdhStatus != ERROR_SUCCESS) {
        G_FREE(pLogInfo);
        pLog->pPerfmonInfo = NULL;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiVerifySQLDB(
    LPCWSTR szDataSource
)
{
    // INTERNAL FUNCTION to
    // Check that a DSN points to a database that contains the correct Perfmon tables.
    // select from the tables and check for an error

    PDH_STATUS    pdhStatus       = ERROR_SUCCESS;
    HSTMT         hstmt           = NULL;    
    RETCODE       rc;
    PDHI_LOG      Log; // a fake log structure - just to make opens work ok
    LPWSTR        szSQLStmt       = NULL;
    LPWSTR        szMachineNamel  = NULL;
    LPWSTR        szObjectNamel   = NULL;
    LPWSTR        szCounterNamel  = NULL;
    LPWSTR        szInstanceNamel = NULL;
    LPWSTR        szParentNamel   = NULL;
    SQLLEN        dwMachineNameLen;
    SQLLEN        dwObjectNameLen;
    SQLLEN        dwCounterNameLen;
    SQLLEN        dwInstanceNameLen;
    SQLLEN        dwParentNameLen;
    DWORD         dwInstanceIndexl;
    DWORD         dwParentObjIdl;
    SQLLEN        dwInstanceIndexStat;
    SQLLEN        dwParentObjIdStat;
    DWORD         dwSQLCounterIdl;
    DWORD         dwCounterTypel;
    LONG          lDefaultScalel;
    LONG          lMinutesToUTC   = 0;
    WCHAR         szTimeZoneName[TIMEZONE_BUFF_SIZE];
    SQLLEN        dwTimeZoneLen;
    DWORD         dwNumOfRecs;
    double        dblCounterValuel;
    DWORD         dwMultiCount;
    WCHAR         szCounterDateTime[TIME_FIELD_BUFF_SIZE];
    LARGE_INTEGER i64FirstValue, i64SecondValue;
 
    ZeroMemory((void *)(& Log), sizeof(PDHI_LOG));

    szSQLStmt = (LPWSTR) G_ALLOC((SQLSTMTSIZE + 5 * PDH_SQL_STRING_SIZE) * sizeof(WCHAR));
    if (szSQLStmt == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto CleanupExit;
    }
    szMachineNamel  = szSQLStmt + SQLSTMTSIZE;
    szObjectNamel   = szMachineNamel  + PDH_SQL_STRING_SIZE;
    szCounterNamel  = szObjectNamel   + PDH_SQL_STRING_SIZE;
    szInstanceNamel = szCounterNamel  + PDH_SQL_STRING_SIZE;
    szParentNamel   = szInstanceNamel + PDH_SQL_STRING_SIZE;

 
    // open the database
    //////////////////////////////////////////////////////////////
    // obtain the ODBC environment and connection
    //
    rc = SQLAllocEnv(& Log.henvSQL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, NULL, PDH_SQL_ALLOC_FAILED);
        goto CleanupExit;
    }
    rc = SQLAllocConnect(Log.henvSQL, & Log.hdbcSQL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, NULL, PDH_SQL_ALLOCCON_FAILED);
        goto CleanupExit;
    }
    rc = SQLSetConnectAttr(Log.hdbcSQL, SQL_COPT_SS_BCP, (SQLPOINTER) SQL_BCP_ON, SQL_IS_INTEGER);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, NULL, PDH_SQL_ALLOCCON_FAILED);
        goto CleanupExit;
    }
    rc = SQLConnectW(Log.hdbcSQL, (SQLWCHAR *) szDataSource, SQL_NTS, NULL, SQL_NULL_DATA, NULL, SQL_NULL_DATA);    
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, NULL, PDH_SQL_CONNECT_FAILED);
        pdhStatus = PDH_INVALID_DATASOURCE;
        goto CleanupExit;
    }

    // do a select on the CounterDetails Table
    StringCchCopyW(szSQLStmt, SQLSTMTSIZE,
            L"select MachineName, ObjectName, CounterName, CounterType, DefaultScale, InstanceName, InstanceIndex, ParentName, ParentObjectID, CounterID from CounterDetails");
    // allocate an hstmt
    rc = SQLAllocStmt(Log.hdbcSQL, & hstmt);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        goto CleanupExit;
    }
    // note SQL returns the size in bytes without the terminating character
    rc = SQLBindCol(hstmt, 1, SQL_C_WCHAR, szMachineNamel, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwMachineNameLen);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 2, SQL_C_WCHAR, szObjectNamel, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwObjectNameLen);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 3, SQL_C_WCHAR, szCounterNamel, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwCounterNameLen);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 4, SQL_C_LONG, & dwCounterTypel, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 5, SQL_C_LONG, & lDefaultScalel, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 6, SQL_C_WCHAR, szInstanceNamel, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwInstanceNameLen);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 7, SQL_C_LONG, & dwInstanceIndexl, 0, & dwInstanceIndexStat);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 8, SQL_C_WCHAR, szParentNamel, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwParentNameLen);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 9, SQL_C_LONG, & dwParentObjIdl, 0, & dwParentObjIdStat);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 10, SQL_C_LONG, & dwSQLCounterIdl, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    // execute the sql command
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = PDH_INVALID_SQLDB;
        goto CleanupExit;
    }
    SQLFreeStmt(hstmt, SQL_DROP);
    hstmt = NULL;

    // do a select on the DisplayToID Table

    StringCchCopyW(szSQLStmt, SQLSTMTSIZE,
            L"select GUID, RunID, DisplayString, LogStartTime, LogStopTime, NumberOfRecords, MinutesToUTC, TimeZoneName from DisplayToID");
    // allocate an hstmt
    rc = SQLAllocStmt(Log.hdbcSQL, & hstmt);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        goto CleanupExit;
    }
    // bind the column names - reuse local strings as needed
    rc = SQLBindCol(hstmt, 1, SQL_C_GUID, & Log.guidSQL, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 2, SQL_C_LONG, & Log.iRunidSQL, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    // DislayString
    rc = SQLBindCol(hstmt, 3, SQL_C_WCHAR, szMachineNamel, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwMachineNameLen);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    //LogStartTime
    rc = SQLBindCol(hstmt, 4, SQL_C_WCHAR, szObjectNamel, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwObjectNameLen);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    //LogStopTime
    rc = SQLBindCol(hstmt, 5, SQL_C_WCHAR, szCounterNamel, PDH_SQL_STRING_SIZE * sizeof(WCHAR), & dwCounterNameLen);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 6, SQL_C_LONG, & dwNumOfRecs, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 7, SQL_C_LONG, & lMinutesToUTC, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 8, SQL_C_WCHAR, szTimeZoneName, TIMEZONE_BUFF_SIZE * sizeof(WCHAR), & dwTimeZoneLen);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    // execute the sql command
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = PDH_INVALID_SQLDB;
        goto CleanupExit;
    }
    SQLFreeStmt(hstmt, SQL_DROP);
    hstmt = NULL;

    // do a select on the CounterData Table

    StringCchCopyW(szSQLStmt, SQLSTMTSIZE,
            L"select GUID, CounterID, RecordIndex, CounterDateTime, CounterValue, FirstValueA, FirstValueB, SecondValueA, SecondValueB, MultiCount from CounterData");

    // allocate an hstmt
    rc = SQLAllocStmt(Log.hdbcSQL, & hstmt);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        goto CleanupExit;
    }
    // bind the columns
    rc = SQLBindCol(hstmt, 1, SQL_C_GUID, & Log.guidSQL, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 2, SQL_C_LONG, & dwSQLCounterIdl, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    // record index
    rc = SQLBindCol(hstmt, 3, SQL_C_LONG, & dwNumOfRecs, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 4, SQL_C_WCHAR, szCounterDateTime, TIME_FIELD_BUFF_SIZE * sizeof(WCHAR), NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 5, SQL_C_DOUBLE, & dblCounterValuel, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 6, SQL_C_LONG, & i64FirstValue.LowPart, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 7, SQL_C_LONG, & i64FirstValue.HighPart, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 8, SQL_C_LONG, & i64SecondValue.LowPart, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 9, SQL_C_LONG, & i64SecondValue.HighPart, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    rc = SQLBindCol(hstmt, 10, SQL_C_LONG, & dwMultiCount, 0, NULL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    // execute the select statement
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = E_FAIL; // PDH_INVALID_SQLDB
        goto CleanupExit;
    }
    // close the database

CleanupExit:  // verify db
    if (hstmt != NULL) SQLFreeStmt(hstmt, SQL_DROP);
    if (Log.hdbcSQL != NULL) {
        SQLDisconnect(Log.hdbcSQL);        
        SQLFreeHandle(SQL_HANDLE_DBC, Log.hdbcSQL);
    }
    if (Log.henvSQL != NULL) SQLFreeHandle(SQL_HANDLE_ENV, Log.henvSQL);
    G_FREE(szSQLStmt);
    return pdhStatus;
}

PDH_FUNCTION
PdhVerifySQLDBA(
    IN  LPCSTR szDataSource
)
{
    //Check that a DSN points to a database that contains the correct Perfmon tables.
    PDH_STATUS pdhStatus     = PDH_INVALID_ARGUMENT;
    LPWSTR     wszDataSource = NULL;

    __try {
        // check args
        if (szDataSource != NULL) {
            if (* szDataSource != '\0' && lstrlenA(szDataSource) <= PDH_MAX_DATASOURCE_PATH) {
                wszDataSource = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szDataSource);
                if (wszDataSource != NULL) {
                    pdhStatus = PdhiVerifySQLDB(wszDataSource);
                    G_FREE(wszDataSource);
                }
                else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            }
        } 
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhVerifySQLDBW(
    IN  LPCWSTR szDataSource
)
{
    //Check that a DSN points to a database that contains the correct Perfmon tables.
    PDH_STATUS pdhStatus = PDH_INVALID_ARGUMENT;
    __try  {
        if (szDataSource != NULL) {
            if (* szDataSource != L'\0' && lstrlenW(szDataSource) <= PDH_MAX_DATASOURCE_PATH) {
                pdhStatus = PdhiVerifySQLDB(szDataSource);
            }
        } 
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiCreateSQLTables(
    LPCWSTR szDataSource
)      
{
    // INTERNAL FUNCTION to
    //Create the correct perfmon tables in the database pointed to by a DSN.
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    RETCODE    rc;
    PDHI_LOG   Log; // a fake log structure - just to make opens work ok

    ZeroMemory((void *)(& Log), sizeof(PDHI_LOG));

    // open the database
    //////////////////////////////////////////////////////////////
    // obtain the ODBC environment and connection
    //
    rc = SQLAllocEnv(& Log.henvSQL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, NULL, PDH_SQL_ALLOC_FAILED);
        goto CleanupExit;
    }
    rc = SQLAllocConnect(Log.henvSQL, & Log.hdbcSQL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, NULL, PDH_SQL_ALLOCCON_FAILED);
        goto CleanupExit;
    }
    rc = SQLSetConnectAttr(Log.hdbcSQL, SQL_COPT_SS_BCP, (SQLPOINTER) SQL_BCP_ON, SQL_IS_INTEGER);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, NULL, PDH_SQL_ALLOCCON_FAILED);
        goto CleanupExit;
    }
    rc = SQLConnectW(Log.hdbcSQL, (SQLWCHAR *) szDataSource, SQL_NTS, NULL, SQL_NULL_DATA, NULL, SQL_NULL_DATA);    
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, NULL, PDH_SQL_CONNECT_FAILED);
        goto CleanupExit;
    }
    // actually create the tables
    pdhStatus = PdhpCreateSQLTables(& Log);

CleanupExit: 
    if (Log.hdbcSQL != NULL) {
        SQLDisconnect(Log.hdbcSQL);        
        SQLFreeHandle(SQL_HANDLE_DBC, Log.hdbcSQL);
    }
    if (Log.henvSQL != NULL) SQLFreeHandle(SQL_HANDLE_ENV, Log.henvSQL);
    return pdhStatus;
}

PDH_FUNCTION
PdhCreateSQLTablesA(
    IN  LPCSTR szDataSource
)      
{
    //Create the correct perfmon tables in the database pointed to by a DSN.
    PDH_STATUS pdhStatus     = PDH_INVALID_ARGUMENT;
    LPWSTR     wszDataSource = NULL;

    __try  {
        // check args
        if (szDataSource != NULL) {
            if (* szDataSource != '\0' && lstrlenA(szDataSource) <= PDH_MAX_DATASOURCE_PATH) {
                wszDataSource = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szDataSource);
                if (wszDataSource != NULL) {
                    pdhStatus = PdhiCreateSQLTables(wszDataSource);
                    G_FREE(wszDataSource);
                }
                else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            }
        } 
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhCreateSQLTablesW(
    IN  LPCWSTR szDataSource
)      
{
    //Create the correct perfmon tables in the database pointed to by a DSN.
    PDH_STATUS pdhStatus = PDH_INVALID_ARGUMENT;

    __try  {
        if (szDataSource != NULL) {
            if (* szDataSource != L'\0' && lstrlenW(szDataSource) <= PDH_MAX_DATASOURCE_PATH) {
                pdhStatus = PdhiCreateSQLTables(szDataSource);
            }
        } 
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumLogSetNames(
    LPCWSTR szDataSource,
    LPVOID  mszDataSetNameList,
    LPDWORD pcchBufferLength,
    BOOL    bUnicodeDest
)
{
    //Return the list of Log set names in the database pointed to by the DSN.
    PDH_STATUS  pdhStatus        = ERROR_SUCCESS;
    PDH_STATUS  pdhBuffStatus    = ERROR_SUCCESS;
    HSTMT       hstmt            = NULL;    
    RETCODE     rc;
    PDHI_LOG    Log; // a fake log structure - just to make opens work ok
    LPWSTR      szSQLStmt        = NULL;
    LPWSTR      szDisplayStringl = NULL;
    SQLLEN      dwDisplayStringLen;
    DWORD       dwNewBuffer;
    DWORD       dwListUsed;

    ZeroMemory((void *) (& Log), sizeof(PDHI_LOG));
    szSQLStmt = (LPWSTR) G_ALLOC((SQLSTMTSIZE + PDH_SQL_STRING_SIZE + 1) * sizeof(WCHAR));
    if (szSQLStmt == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto CleanupExit;
    }
    szDisplayStringl = szSQLStmt + SQLSTMTSIZE;

    // open the database
    //////////////////////////////////////////////////////////////
    // obtain the ODBC environment and connection
    //

    rc = SQLAllocEnv(& Log.henvSQL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, NULL, PDH_SQL_ALLOC_FAILED);
        goto CleanupExit;
    }
    rc = SQLAllocConnect(Log.henvSQL, & Log.hdbcSQL);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, NULL, PDH_SQL_ALLOCCON_FAILED);
        goto CleanupExit;
    }
    rc = SQLSetConnectAttr(Log.hdbcSQL, SQL_COPT_SS_BCP, (SQLPOINTER) SQL_BCP_ON, SQL_IS_INTEGER);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, NULL, PDH_SQL_ALLOCCON_FAILED);
        goto CleanupExit;
    }
    rc = SQLConnectW(Log.hdbcSQL, (SQLWCHAR *) szDataSource, SQL_NTS, NULL, SQL_NULL_DATA, NULL, SQL_NULL_DATA);    
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, NULL, PDH_SQL_CONNECT_FAILED);
        goto CleanupExit;
    }

    // do a select
    // loop around in a fetch and 
    // build the list of names

    StringCchCopyW(szSQLStmt, SQLSTMTSIZE, L"select DisplayString from DisplayToID");

    // allocate an hstmt
    rc = SQLAllocStmt(Log.hdbcSQL, & hstmt);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        goto CleanupExit;
    }
    // bind the machine name column
    rc = SQLBindCol(hstmt, 1, SQL_C_WCHAR, szDisplayStringl, (PDH_SQL_STRING_SIZE + 1) * sizeof(WCHAR), & dwDisplayStringLen);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_BIND_FAILED);
        goto CleanupExit;
    }
    // execute the select statement
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
        goto CleanupExit;
    }

    dwListUsed = 0;  // include the null terminator to start
    // loop around the result set using fetch
    while ((rc = SQLFetch(hstmt)) != SQL_NO_DATA) {
        if (! SQLSUCCEEDED(rc)) {
            pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_FETCH_FAILED);
            goto CleanupExit;
        }

        // Append the DisplayName to the returned list
        dwNewBuffer = lstrlenW(szDisplayStringl) + 1;

        if (mszDataSetNameList != NULL && (dwListUsed + dwNewBuffer) <= * pcchBufferLength) {
            // add the display name
            pdhBuffStatus = AddUniqueWideStringToMultiSz((LPVOID) mszDataSetNameList,
                                                         (LPWSTR) szDisplayStringl,
                                                         * pcchBufferLength - dwListUsed,
                                                         & dwNewBuffer,
                                                         bUnicodeDest);
            if (pdhBuffStatus == ERROR_SUCCESS) {
                if (dwNewBuffer != 0) { // if it got added returned new length in TCHAR
                    dwListUsed = dwNewBuffer; 
                }
            }
            else if (pdhBuffStatus == PDH_MORE_DATA) {
                dwListUsed += dwNewBuffer;
            }
            else {
                pdhStatus = pdhBuffStatus;
                goto CleanupExit;
            }
        }
        else {
            // SQL won't let non unique LogSet names into the database
            // so we don't really have to worry about duplicates
            pdhBuffStatus = PDH_MORE_DATA;
            dwListUsed   += dwNewBuffer;
        }
    } // end of while fetch

    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(& Log, rc, hstmt, PDH_SQL_FETCH_FAILED);
        goto CleanupExit;
    }

    if (pdhBuffStatus == PDH_MORE_DATA) {
        dwListUsed ++;
    }
    * pcchBufferLength = dwListUsed;
    pdhStatus          = pdhBuffStatus;

    // close the database

CleanupExit:
    if (hstmt != NULL) SQLFreeStmt(hstmt, SQL_DROP);
    if (Log.hdbcSQL) {
        SQLDisconnect(Log.hdbcSQL);        
        SQLFreeHandle(SQL_HANDLE_DBC, Log.hdbcSQL);
    }
    if (Log.henvSQL) SQLFreeHandle(SQL_HANDLE_ENV, Log.henvSQL);
    G_FREE(szSQLStmt);
    return pdhStatus;
}

PDH_FUNCTION
PdhEnumLogSetNamesA(
    IN  LPCSTR  szDataSource,
    IN  LPSTR   mszDataSetNameList,
    IN  LPDWORD pcchBufferLength
)
{
    //Return the list of Log set names in the database pointed to by the DSN.
    PDH_STATUS pdhStatus     = ERROR_SUCCESS;
    DWORD      dwBufferSize;
    LPWSTR     wszDataSource = NULL;

    if (szDataSource == NULL || pcchBufferLength == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try  {
            // check args
            dwBufferSize = * pcchBufferLength;
            if (mszDataSetNameList != NULL) {
                mszDataSetNameList[0] = '\0';
                if (dwBufferSize > 1) {
                    mszDataSetNameList[dwBufferSize - 1] = '\0';
                }
            }
            if (* szDataSource != '\0' && lstrlenA(szDataSource) <= PDH_MAX_DATASOURCE_PATH) {
                wszDataSource = PdhiMultiByteToWideChar(_getmbcp(), (LPSTR) szDataSource);
                if (wszDataSource != NULL) {
                    pdhStatus = PdhiEnumLogSetNames(wszDataSource, mszDataSetNameList, pcchBufferLength, FALSE);
                    G_FREE(wszDataSource);
                }
                else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            }
            else {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } 
        __except(EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhEnumLogSetNamesW(
    IN  LPCWSTR szDataSource,
    IN  LPWSTR  mszDataSetNameList,
    IN  LPDWORD pcchBufferLength
)
{
    //Return the list of Log set names in the database pointed to by the DSN.
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    DWORD dwBufferSize;

    if (szDataSource == NULL || pcchBufferLength == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            // check args
            dwBufferSize = * pcchBufferLength;
            if (mszDataSetNameList != NULL) {
                mszDataSetNameList[0] = L'\0';
                if (dwBufferSize > 1) {
                    mszDataSetNameList[dwBufferSize - 1] = L'\0';
                }
            }
            if (* szDataSource == L'\0' || lstrlenW(szDataSource) > PDH_MAX_DATASOURCE_PATH) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
            if (pdhStatus == ERROR_SUCCESS) {
                pdhStatus = PdhiEnumLogSetNames(szDataSource, mszDataSetNameList, pcchBufferLength, TRUE);
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhGetLogSetGUID(
    IN  PDH_HLOG   hLog,             
    IN  GUID     * pGuid,
    IN  int      * pRunId
)
{
    //Retrieve the GUID for an open Log Set
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    PPDHI_LOG  pLog;

    if (IsValidLogHandle(hLog)) {
        pLog      = (PPDHI_LOG) hLog;
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pLog->hLogMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            // make sure it's still valid as it could have 
            //  been deleted while we were waiting
            if (IsValidLogHandle(hLog)) {
                pLog = (PPDHI_LOG) hLog;
                __try {
                    // test the parameters before continuing
                    if (pGuid == NULL && pRunId == NULL) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                    else {
                        if (pGuid != NULL) {
                            // if not NULL, it must be valid
                            * pGuid = pLog->guidSQL;
                        }
                        if (pRunId != NULL) {
                            // if not NULL, it must be valid
                            * pRunId = pLog->iRunidSQL;
                        }
                    }
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    // something failed so give up here
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
            else {
                pdhStatus = PDH_INVALID_HANDLE;
            }
            RELEASE_MUTEX(pLog->hLogMutex);
        }
    }
    else {
        pdhStatus = PDH_INVALID_HANDLE;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiSetLogSetRunID(
    PPDHI_LOG pLog,
    int       RunId
)
{
    //Set the RunID for an open Log Set 
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HSTMT      hstmt     = NULL;
    RETCODE    rc;
    LPWSTR     szSQLStmt = NULL;

    szSQLStmt = (LPWSTR) G_ALLOC(SQLSTMTSIZE * sizeof(WCHAR));
    if (szSQLStmt == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    pLog->iRunidSQL = RunId;

    // allocate an hstmt
    rc = SQLAllocStmt(pLog->hdbcSQL, & hstmt);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_ALLOC_FAILED);
        goto Cleanup;
    }

    StringCchPrintfW(szSQLStmt, SQLSTMTSIZE,
            L"update DisplayToID set RunID = %d where GUID = '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x'",
            RunId,
            pLog->guidSQL.Data1, pLog->guidSQL.Data2, pLog->guidSQL.Data3,
            pLog->guidSQL.Data4[0], pLog->guidSQL.Data4[1], pLog->guidSQL.Data4[2],
            pLog->guidSQL.Data4[3], pLog->guidSQL.Data4[4], pLog->guidSQL.Data4[5],
            pLog->guidSQL.Data4[6], pLog->guidSQL.Data4[7]);
    rc = SQLExecDirectW(hstmt, szSQLStmt, SQL_NTS);
    if (! SQLSUCCEEDED(rc)) {
        pdhStatus = ReportSQLError(pLog, rc, hstmt, PDH_SQL_EXEC_DIRECT_FAILED);
        goto Cleanup;
    }

Cleanup:
    if (hstmt) SQLFreeStmt(hstmt, SQL_DROP);
    G_FREE(szSQLStmt);
    return pdhStatus;
}

PDH_FUNCTION
PdhSetLogSetRunID(
    IN  PDH_HLOG hLog,             
    IN  int      RunId
)
{
    //Set the RunID for an open Log Set 
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    PPDHI_LOG  pLog;

    if (IsValidLogHandle(hLog)) {
        pLog = (PPDHI_LOG) hLog;
        WAIT_FOR_AND_LOCK_MUTEX(pLog->hLogMutex);
        // make sure it's still valid as it could have 
        //  been deleted while we were waiting
        if (IsValidLogHandle(hLog)) {
            pLog      = (PPDHI_LOG) hLog;
            pdhStatus = PdhiSetLogSetRunID(pLog, RunId);
        }
        else {
            pdhStatus = PDH_INVALID_HANDLE;
        }
        RELEASE_MUTEX(pLog->hLogMutex);
    }
    else {
        pdhStatus = PDH_INVALID_HANDLE;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiListHeaderFromSQLLog(
    PPDHI_LOG   pLog,
    LPVOID      pBufferArg,
    LPDWORD     pcchBufferSize,
    BOOL        bUnicode
)
{
    PPDHI_SQL_LOG_INFO           pLogInfo;
    PPDHI_LOG_MACHINE            pMachine;
    PPDHI_LOG_OBJECT             pObject;
    PPDHI_LOG_COUNTER            pCounter;
    PDH_COUNTER_PATH_ELEMENTS_W  pdhPathElem;
    WCHAR                        szPathString[SMALL_BUFFER_SIZE];
    PDH_STATUS                   pdhStatus    = ERROR_SUCCESS;
    DWORD                        dwNewBuffer  = 0;
    DWORD                        dwBufferUsed = 0;
    DWORD                        nItemCount   = 0;

    if (pcchBufferSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
        goto Cleanup;
    }
    pdhStatus = PdhpGetSQLLogHeader(pLog);
    if (pdhStatus != ERROR_SUCCESS) goto Cleanup;

    pLogInfo = (PPDHI_SQL_LOG_INFO) pLog->pPerfmonInfo;
    if (pLogInfo == NULL) {
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
        goto Cleanup;
    }

    for (pMachine = pLogInfo->MachineList; pMachine != NULL; pMachine = pMachine->next) {
        for (pObject = pMachine->ObjList; pObject != NULL; pObject = pObject->next) {
            for (pCounter = pObject->CtrList; pCounter != NULL; pCounter = pCounter->next) {
                ZeroMemory(szPathString,  SMALL_BUFFER_SIZE * sizeof(WCHAR));
                dwNewBuffer = SMALL_BUFFER_SIZE;
                ZeroMemory(& pdhPathElem, sizeof(PDH_COUNTER_PATH_ELEMENTS_W));
                pdhPathElem.szMachineName    = pMachine->szMachine;
                pdhPathElem.szObjectName     = pObject->szObject;
                pdhPathElem.szCounterName    = pCounter->szCounter;
                pdhPathElem.szInstanceName   = pCounter->szInstance;
                pdhPathElem.szParentInstance = pCounter->szParent;
                pdhPathElem.dwInstanceIndex  = (pCounter->dwInstance != 0)
                                             ? (pCounter->dwInstance) : (PERF_NO_UNIQUE_ID);
                pdhStatus = PdhMakeCounterPathW(& pdhPathElem, szPathString, & dwNewBuffer, 0);
                if (pdhStatus != ERROR_SUCCESS || dwNewBuffer == 0) continue;

                if (pBufferArg != NULL && (dwBufferUsed + dwNewBuffer) < * pcchBufferSize) {
                    pdhStatus = AddUniqueWideStringToMultiSz((LPVOID) pBufferArg,
                                                             szPathString,
                                                             * pcchBufferSize - dwBufferUsed,
                                                             & dwNewBuffer,
                                                             bUnicode);
                    if (pdhStatus == ERROR_SUCCESS) {
                        if (dwNewBuffer != 0) { // if it got added returned new length in TCHAR
                            dwBufferUsed = dwNewBuffer;
                        }
                    }
                    else if (pdhStatus == PDH_MORE_DATA) {
                        dwBufferUsed += dwNewBuffer;
                    }
                    else {
                        goto Cleanup;
                    }
                }
                else {
                    dwBufferUsed += dwNewBuffer;
                    pdhStatus     = PDH_MORE_DATA;
                }
                nItemCount ++;
            }
        }
    }

    if (nItemCount > 0 && pdhStatus != PDH_MORE_DATA) {
        pdhStatus = ERROR_SUCCESS;
    }
    if (pBufferArg == NULL) {
        dwBufferUsed ++;
    }

    * pcchBufferSize = dwBufferUsed;

Cleanup:
    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhlog\log_pm.c ===
/*++
Copyright (C) 1996-1999 Microsoft Corporation

Module Name:
    log_pm.c

Abstract:
    <abstract>
--*/

#include <windows.h>
#include "strsafe.h"
#include <limits.h>
#include <pdh.h>
#include "pdhidef.h"
#include "perftype.h"
#include "log_pm.h"
#include "pdhmsg.h"
#include "perftype.h"
#include "perfdata.h"

#define PointerSeek(pBase, lFileOffset) ((PVOID) ((PBYTE) pBase + lFileOffset))

int
PdhiComparePmLogInstance(
    PPDHI_LOG_COUNTER pCounter,
    LPWSTR            szInstance,
    DWORD             dwInstance,
    LPWSTR            szParent,
    BOOL              bUpdate
)
{
    int   iResult = 0;

    if ((pCounter->szInstance != NULL && pCounter->szInstance[0] != L'\0')
                    && (szInstance != NULL && szInstance[0] != L'\0')) {
        iResult = lstrcmpiW(szInstance, pCounter->szInstance);
        if (iResult != 0 && dwInstance != 0 && dwInstance != PERF_NO_UNIQUE_ID
                         && (pCounter->dwInstance == 0 || pCounter->dwInstance == PERF_NO_UNIQUE_ID)) {
            DWORD  dwNewInstance = lstrlenW(szInstance) + 20;
            LPWSTR szNewInstance = (LPWSTR) G_ALLOC(sizeof(WCHAR) * dwNewInstance);

            if (szNewInstance != NULL) {
                StringCchPrintfW(szNewInstance, dwNewInstance, L"%ws#%d", szInstance, dwInstance);
                iResult = lstrcmpiW(szNewInstance, pCounter->szInstance);
                if (iResult == 0) {
                    dwInstance = pCounter->dwInstance;
                }
                G_FREE(szNewInstance);
            }
        }
    }
    else if ((pCounter->szInstance != NULL && pCounter->szInstance[0] != L'\0')
                    && (szInstance == NULL || szInstance[0] == L'\0')) {
        iResult = -1;
    }
    else if ((pCounter->szInstance == NULL || pCounter->szInstance[0] == L'\0')
                    && (szInstance != NULL && szInstance[0] != L'\0')) {
        iResult = 1;
    }
    if (iResult != 0) goto Cleanup;

    iResult = (dwInstance < pCounter->dwInstance) ? (-1) : ((dwInstance > pCounter->dwInstance) ? (1) : (0));
    if (iResult != 0) goto Cleanup;

    if ((pCounter->szParent != NULL && pCounter->szParent[0] != L'\0')
                    && (szParent != NULL && szParent[0] != L'\0')) {
        iResult = lstrcmpiW(szParent, pCounter->szParent);
    }
    else if ((pCounter->szParent != NULL && pCounter->szParent[0] != L'\0')
                    && (szParent == NULL || szParent[0] == L'\0')) {
        iResult = -1;
    }
    else if ((pCounter->szParent == NULL || pCounter->szParent[0] == L'\0')
                    && (szParent != NULL && szParent[0] != L'\0')) {
        iResult = 1;
    }

Cleanup:
    return iResult;
}

PPDHI_LOG_COUNTER
PdhiFindPmCounterInstance(
    PPDHI_LOG_OBJECT pObject,
    LPWSTR           szCounter,
    DWORD            dwCounterType,
    DWORD            dwDefaultScale,
    LPWSTR           szInstance,
    DWORD            dwInstance,
    LPWSTR           szParent,
    DWORD            dwParent,
    LPDWORD          pdwIndex,
    BOOL             bInstance,
    BOOL             bInsert
)
{
    PPDHI_LOG_COUNTER   pCounter = NULL;
    PPDHI_LOG_COUNTER   pNode    = NULL;
    PPDHI_LOG_COUNTER * pStack[MAX_BTREE_DEPTH];
    PPDHI_LOG_COUNTER * pLink;
    int                 dwStack = 0;
    PPDHI_LOG_COUNTER   pParent;
    PPDHI_LOG_COUNTER   pSibling;
    PPDHI_LOG_COUNTER   pChild;
    int                 iCompare;
    HRESULT             hr;

    if (bInstance) {
        pStack[dwStack ++] = & (pObject->InstTable);
        pCounter = pObject->InstTable;
    }
    else {
        pStack[dwStack ++] = & (pObject->CtrTable);
        pCounter = pObject->CtrTable;
    }
    while (pCounter != NULL) {
        if (bInstance) {
            iCompare = PdhiComparePmLogInstance(pCounter, szInstance, dwInstance, szParent, bInsert);
        }
        else {
            iCompare = lstrcmpiW(szCounter, pCounter->szCounter);
        }
        if (iCompare < 0) {
            pStack[dwStack ++] = & (pCounter->left);
            pCounter           = pCounter->left;
        }
        else if (iCompare > 0) {
            pStack[dwStack ++] = & (pCounter->right);
            pCounter            = pCounter->right;
        }
        else {
            break;
        }
    }

    if (bInsert) {
        if (pCounter == NULL) {
            DWORD dwCounterLen  = lstrlenW(szCounter) + 1;
            DWORD dwInstanceLen = 0;
            DWORD dwParentLen   = 0;
            DWORD dwBufSize     = sizeof(PDHI_LOG_COUNTER) + sizeof(WCHAR) * dwCounterLen;
            if (szInstance != NULL) {
                dwInstanceLen = lstrlenW(szInstance) + 1;
                dwBufSize    += (sizeof(WCHAR) * dwInstanceLen);
            }
            else {
                dwBufSize += sizeof(WCHAR);
            }
            if (szParent != NULL) {
                dwParentLen   = lstrlenW(szParent) + 1;
                dwBufSize    += (sizeof(WCHAR) * dwParentLen);
            }
            else {
                dwBufSize += sizeof(WCHAR);
            }

            pCounter = G_ALLOC(dwBufSize);
            if (pCounter == NULL) goto Cleanup;

            if (bInstance) {
                pCounter->next    = pObject->InstList;
                pObject->InstList = pCounter;
            }
            else {
                pCounter->next    = pObject->CtrList;
                pObject->CtrList  = pCounter;
            }
            pCounter->bIsRed      = TRUE;
            pCounter->left        = NULL;
            pCounter->right       = NULL;
            pCounter->dwParent    = dwParent;
            pCounter->TimeStamp   = 0;
            pCounter->dwInstance  = dwInstance;
            pCounter->dwCounterID = (* pdwIndex);
            if (! bInstance) {
                pCounter->dwCounterType  = dwCounterType;
                pCounter->dwDefaultScale = dwDefaultScale;
            }

            if (szCounter == NULL || szCounter[0] == L'\0') {
                pCounter->szCounter = NULL;
            }
            else {
                pCounter->szCounter = (LPWSTR) (((PCHAR) pCounter) + sizeof(PDHI_LOG_COUNTER));
                hr = StringCchCopyW(pCounter->szCounter, dwCounterLen, szCounter);
                if (FAILED(hr)) {
                    G_FREE(pCounter);
                    pCounter = NULL;
                    goto Cleanup;
                }
            }
            if (szInstance == NULL || szInstance[0] == L'\0') {
                pCounter->szInstance = NULL;
            }
            else {
                pCounter->szInstance = (LPWSTR) (((PCHAR) pCounter) + sizeof(PDHI_LOG_COUNTER)
                                                                    + sizeof(WCHAR) * dwCounterLen);
                hr = StringCchCopyW(pCounter->szInstance, dwInstanceLen, szInstance);
                if (FAILED(hr)) {
                    G_FREE(pCounter);
                    pCounter = NULL;
                    goto Cleanup;
                }
            }

            if (szParent == NULL || szParent[0] == L'\0') {
                pCounter->szParent = NULL;
            }
            else {
                if (pCounter->szInstance != NULL) {
                    pCounter->szParent = (LPWSTR) (((PCHAR) pCounter)
                            + sizeof(PDHI_LOG_COUNTER) + sizeof(WCHAR) * (dwCounterLen + dwInstanceLen));
                }
                else {
                    pCounter->szParent = (LPWSTR) (((PCHAR) pCounter) + sizeof(PDHI_LOG_COUNTER)
                                                                      + sizeof(WCHAR) * dwCounterLen);
                }
                hr = StringCchCopyW(pCounter->szParent, dwParentLen, szParent);
                if (FAILED(hr)) {
                    G_FREE(pCounter);
                    pCounter = NULL;
                    goto Cleanup;
                }
            }

            pLink   = pStack[-- dwStack];
            * pLink = pCounter;

            pChild  = NULL;
            pNode   = pCounter;
            while (dwStack > 0) {
                pLink   = pStack[-- dwStack];
                pParent = * pLink;
                if (! pParent->bIsRed) {
                    pSibling = (pParent->left == pNode) ? pParent->right : pParent->left;
                    if (pSibling && pSibling->bIsRed) {
                        pNode->bIsRed    = FALSE;
                        pSibling->bIsRed = FALSE;
                        pParent->bIsRed  = TRUE;
                    }
                    else {
                        if (pChild && pChild->bIsRed) {
                            if (pChild == pNode->left) {
                                if (pNode == pParent->left) {
                                    pParent->bIsRed  = TRUE;
                                    pParent->left    = pNode->right;
                                    pNode->right     = pParent;
                                    pNode->bIsRed    = FALSE;
                                    * pLink          = pNode;
                                }
                                else {
                                    pParent->bIsRed  = TRUE;
                                    pParent->right   = pChild->left;
                                    pChild->left     = pParent;
                                    pNode->left      = pChild->right;
                                    pChild->right    = pNode;
                                    pChild->bIsRed   = FALSE;
                                    * pLink          = pChild;
                                }
                            }
                            else {
                                if (pNode == pParent->right) {
                                    pParent->bIsRed  = TRUE;
                                    pParent->right   = pNode->left;
                                    pNode->left      = pParent;
                                    pNode->bIsRed    = FALSE;
                                    * pLink          = pNode;
                                }
                                else {
                                    pParent->bIsRed  = TRUE;
                                    pParent->left    = pChild->right;
                                    pChild->right    = pParent;
                                    pNode->right     = pChild->left;
                                    pChild->left     = pNode;
                                    pChild->bIsRed   = FALSE;
                                    * pLink          = pChild;
                                }
                            }
                        }
                        break;
                    }
                }
                pChild = pNode;
                pNode  = pParent;
            }
            if (bInstance) {
                pObject->InstTable->bIsRed = FALSE;
            }
            else {
                pObject->CtrTable->bIsRed = FALSE;
            }
        }
        else if (bInstance) {
            pCounter->dwCounterType ++;
            if (pCounter->dwCounterType > pCounter->dwDefaultScale) {
                pCounter->dwDefaultScale = pCounter->dwCounterType;
            }
        }
    }
    else if (pCounter != NULL) {
        * pdwIndex = pCounter->dwCounterID;
    }

Cleanup:
    return pCounter;
}

PDH_FUNCTION
PdhiBuildPmLogIndexTable(
    PPLAYBACKLOG pPmLog
)
{
    PDH_STATUS     Status      = ERROR_SUCCESS;
    PLOGHEADER     pLogHeader  = (PLOGHEADER) pPmLog->pHeader;
    PLOGINDEXBLOCK pIndexBlock = NULL;
    DWORD          dwOffset    = pLogHeader->iLength;
    DWORD          dwIndex     = 0;
    int            i;

    if (dwOffset == sizeof(LOGHEADER)) {
        while (dwOffset != 0 && dwOffset < pPmLog->llFileSize) {
            pIndexBlock = (PLOGINDEXBLOCK) PointerSeek(pLogHeader, dwOffset);
            dwIndex    += pIndexBlock->iNumIndexes;
            dwOffset    = pIndexBlock->lNextBlockOffset;
        }
        if (dwOffset >= pPmLog->llFileSize) {
            Status = PDH_LOG_FILE_OPEN_ERROR;
            goto Cleanup;
        }

        pPmLog->dwLastIndex = dwIndex;
        G_FREE(pPmLog->LogIndexTable);
        pPmLog->LogIndexTable = G_ALLOC(dwIndex * sizeof(PLOGINDEX));
        if (pPmLog->LogIndexTable == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }
        dwIndex  = 0;
        dwOffset = pLogHeader->iLength;
        while (dwOffset != 0 && dwOffset < pPmLog->llFileSize) {
            pIndexBlock = (PLOGINDEXBLOCK) PointerSeek(pLogHeader, dwOffset);
            for (i = 0; i < pIndexBlock->iNumIndexes; i ++) {
                pPmLog->LogIndexTable[dwIndex + i] = & (pIndexBlock->aIndexes[i]);
            }
            dwIndex    += pIndexBlock->iNumIndexes;
            dwOffset    = pIndexBlock->lNextBlockOffset;
        }
        if (dwOffset >= pPmLog->llFileSize) {
            Status = PDH_LOG_FILE_OPEN_ERROR;
            goto Cleanup;
        }
    }
    else {
        Status = PDH_INVALID_ARGUMENT;
    }

Cleanup:
    if (Status != ERROR_SUCCESS) {
        G_FREE(pPmLog->LogIndexTable);
        pPmLog->dwLastIndex    = 0;
        pPmLog->dwCurrentIndex = 0;
    }
    return Status;
}

void
PdhiFreeCounterStringNode(
    PPDHI_PM_STRING pString,
    DWORD           dwLevel
)
{
    if (pString != NULL) {
        if (pString->left != NULL) {
            PdhiFreeCounterStringNode(pString->left, dwLevel + 1);
        }
        if (pString->right != NULL) {
            PdhiFreeCounterStringNode(pString->right, dwLevel + 1);
        }
        G_FREE(pString);
    }
}

void
PdhiFreePmMachineList(
    PPLAYBACKLOG pPmLog
)
{
    PPMLOG_COUNTERNAMES pMachine = pPmLog->pFirstCounterNameTables;
    PPMLOG_COUNTERNAMES pTmpMachine;

    while (pMachine != NULL) {
        pTmpMachine = pMachine;
        pMachine    = pTmpMachine->pNext;
        PdhiFreeCounterStringNode(pTmpMachine->StringTree, 0);
        G_FREE(pTmpMachine);
    }
}

PPDHI_PM_STRING
PdhiFindPmString(
    PPMLOG_COUNTERNAMES pMachine,
    LPCWSTR             szString,
    LPDWORD             pdwIndex,
    BOOL                bInsert
)
{
    PDH_STATUS        Status   = ERROR_SUCCESS;
    PPDHI_PM_STRING * pStack[MAX_BTREE_DEPTH];
    int               iStack   = 0;
    int               iCompare = 0;
    PPDHI_PM_STRING   pString  = pMachine->StringTree;
    PPDHI_PM_STRING * pLink;
    PPDHI_PM_STRING   pNode;
    PPDHI_PM_STRING   pParent;
    PPDHI_PM_STRING   pSibling;
    PPDHI_PM_STRING   pChild;

    pStack[iStack ++] = & pMachine->StringTree;
    while (pString != NULL) {
        iCompare = lstrcmpiW(szString, pString->szString);
        if (iCompare > 0) {
            if (iStack >= MAX_BTREE_DEPTH) {
                Status = PDH_UNABLE_READ_LOG_HEADER;
                break;
            }
            pStack[iStack ++] = & (pString->right);
            pString           = pString->right;
        }
        else if (iCompare < 0) {
            if (iStack >= MAX_BTREE_DEPTH) {
                Status = PDH_UNABLE_READ_LOG_HEADER;
                break;
            }
            pStack[iStack ++] = & (pString->left);
            pString           = pString->left;
        }
        else {
            break;
        }
    }

    if (Status != ERROR_SUCCESS) goto Cleanup;

    if (pString != NULL) {
        if (pdwIndex != NULL) {
            * pdwIndex = pString->dwIndex;
        }
    }
    else if (bInsert && pdwIndex != NULL) {
        pString = G_ALLOC(sizeof(PDHI_PM_STRING));
        if (pString != NULL) {
            pString->szString  = (LPWSTR) szString;
            pString->dwIndex   = * pdwIndex;
            pString->bIsRed    = TRUE;
            pString->left      = NULL;
            pString->right     = NULL;

            pLink   = pStack[-- iStack];
            * pLink = pString;
            pNode   = pString;
            pChild  = NULL;

            while (iStack > 0) {
                pLink   = pStack[-- iStack];
                pParent = * pLink;
                if (! pParent->bIsRed) {
                    pSibling = (pParent->left == pNode) ? pParent->right : pParent->left;
                    if (pSibling && pSibling->bIsRed) {
                        pNode->bIsRed    = FALSE;
                        pSibling->bIsRed = FALSE;
                        pParent->bIsRed  = TRUE;
                    }
                    else {
                        if (pChild && pChild->bIsRed) {
                            if (pChild == pNode->left) {
                                if (pNode == pParent->left) {
                                    pParent->bIsRed  = TRUE;
                                    pParent->left    = pNode->right;
                                    pNode->right     = pParent;
                                    pNode->bIsRed    = FALSE;
                                    * pLink          = pNode;
                                }
                                else {
                                    pParent->bIsRed  = TRUE;
                                    pParent->right   = pChild->left;
                                    pChild->left     = pParent;
                                    pNode->left      = pChild->right;
                                    pChild->right    = pNode;
                                    pChild->bIsRed   = FALSE;
                                    * pLink          = pChild;
                                }
                            }
                            else {
                                if (pNode == pParent->right) {
                                    pParent->bIsRed  = TRUE;
                                    pParent->right   = pNode->left;
                                    pNode->left      = pParent;
                                    pNode->bIsRed    = FALSE;
                                    * pLink          = pNode;
                                }
                                else {
                                    pParent->bIsRed  = TRUE;
                                    pParent->left    = pChild->right;
                                    pChild->right    = pParent;
                                    pNode->right     = pChild->left;
                                    pChild->left     = pNode;
                                    pChild->bIsRed   = FALSE;
                                    * pLink          = pChild;
                                }
                            }
                        }
                        break;
                    }
                }
                pChild = pNode;
                pNode  = pParent;
            }
            pMachine->StringTree->bIsRed = FALSE;
        }
        else {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    }

Cleanup:
    if (Status != ERROR_SUCCESS) SetLastError(Status);
    return pString;
}

PDH_FUNCTION
PdhiBuildPmLogStringTable(
    PPLAYBACKLOG        pPmLog,
    PLOGFILECOUNTERNAME pLogName,
    PPMLOG_COUNTERNAMES pMachine,
    long                lSize
)
{
    PDH_STATUS          Status   = ERROR_SUCCESS;
    PPDHI_PM_STRING     pString;
    LPWSTR              szName;
    DWORD               dwName;
    DWORD               dwIndex;
    long                lUsed    = 0;

    if (lSize > pLogName->lUnmatchCounterNames
                   || pLogName->lCurrentCounterNameOffset < 0
                   || pLogName->lCurrentCounterNameOffset >= pPmLog->llFileSize
                   || pLogName->lCurrentCounterNameOffset + pLogName->lUnmatchCounterNames > pPmLog->llFileSize) {
        Status = PDH_UNABLE_READ_LOG_HEADER;
    }
    else if (pLogName->lBaseCounterNameOffset > 0) {
        PLOGFILECOUNTERNAME pBaseName = (PLOGFILECOUNTERNAME)
                                        PointerSeek(pPmLog->pHeader, pLogName->lBaseCounterNameOffset);
        Status = PdhiBuildPmLogStringTable(pPmLog, pBaseName, pMachine, pLogName->lMatchLength);
    }
    if (Status != ERROR_SUCCESS) goto Cleanup;

    szName = (LPWSTR) PointerSeek(pPmLog->pHeader, pLogName->lCurrentCounterNameOffset);
    while (Status == ERROR_SUCCESS && lUsed <= lSize && szName[0] != L'\0') {
        dwIndex = wcstoul(szName, NULL, 10);
        if (dwIndex > 0 && dwIndex <= pMachine->dwLastIndex) {
            dwName  = lstrlenW(szName) + 1;
            lUsed  += (sizeof(WCHAR) * dwName);
            if (lUsed <= lSize) {
                szName += dwName;
                pMachine->szNameTable[dwIndex] = szName;
                pString = PdhiFindPmString(pMachine, szName, & dwIndex, TRUE);
                if (pString == NULL) Status = GetLastError();
            }
        }
        dwName  = lstrlenW(szName) + 1;
        lUsed  += (sizeof(WCHAR) * dwName);
        szName += dwName;
    }

Cleanup:
    return Status;
}

DWORD
PdhiLookupLogPerfIndexByName(
    PPLAYBACKLOG  pPlaybackLog,
    LPCWSTR       szMachineName,
    DWORD         dwLangId,
    DWORD         dwLastId,
    LPCWSTR       szNameBuffer
)
{
    DWORD               dwIndex  = 0;
    PDH_STATUS          Status   = PDH_CSTATUS_NO_MACHINE;
    PPMLOG_COUNTERNAMES pMachine = pPlaybackLog->pFirstCounterNameTables;

    while (pMachine != NULL) {
        if (lstrcmpiW(szMachineName, pMachine->szSystemName) == 0) break;
        pMachine = pMachine->pNext;
    }
    if (pMachine != NULL) {
        PPDHI_PM_STRING pString = PdhiFindPmString(pMachine, szNameBuffer, & dwIndex, FALSE);
        if (pString == NULL) {
            Status  = GetLastError();
            dwIndex = wcstoul(szNameBuffer, NULL, 10);
        }
    }
    if (dwIndex == 0) SetLastError(Status);
    return dwIndex;
}

LPCWSTR
PdhiLookupLogPerfNameByIndex(
    PPLAYBACKLOG  pPlaybackLog,
    LPCWSTR       szMachineName,
    DWORD         dwLangId,
    DWORD         dwIndex
)
{
    PPMLOG_COUNTERNAMES pMachine = pPlaybackLog->pFirstCounterNameTables;
    LPWSTR              szReturn = NULL;
    static WCHAR        szNumber[16];

    while (pMachine != NULL) {
        if (lstrcmpiW(szMachineName, pMachine->szSystemName) == 0) break;
        pMachine = pMachine->pNext;
    }
    if (pMachine != NULL) {
        if (dwIndex <= pMachine->dwLastIndex && dwLangId == pMachine->dwLangId) {
            szReturn = pMachine->szNameTable[dwIndex];
        }
        if (szReturn == NULL) {
            SetLastError(PDH_CSTATUS_NO_OBJECT);
            ZeroMemory(szNumber, sizeof(szNumber));
            _ltow(dwIndex, szNumber, 10);
            szReturn = szNumber;
        }
    }
    else {
        SetLastError(PDH_CSTATUS_NO_MACHINE);
    }
    return (LPCWSTR) szReturn;
}

PDH_FUNCTION
PdhiCachePerfDataBlock(
    PPLAYBACKLOG pPmLog,
    PLOGINDEX    pIndex
)
{
    PDH_STATUS               Status = ERROR_SUCCESS;
    PPERF_DATA_BLOCK         pBlock;
    PPERF_OBJECT_TYPE        pObject;
    PPERF_COUNTER_DEFINITION pCounter;
    int                      i;
    LPWSTR                   szMachine;
    LPWSTR                   szLogMachine    = NULL;
    LPWSTR                   szObject;
    DWORD                    dwObjects;
    PPDHI_LOG_MACHINE        pLoggedMachine  = NULL;
    PPDHI_LOG_OBJECT         pLoggedObject   = NULL;
    PPMLOG_COUNTERNAMES      pCounterTable   = NULL;
    HRESULT                  hr;

    for (i = 0; i < pIndex->iSystemsLogged; i ++) {
        if (i == 0) {
            pBlock = (PPERF_DATA_BLOCK) PointerSeek(pPmLog->pHeader, pIndex->lDataOffset);
        }
        else {
            pBlock = (PPERF_DATA_BLOCK) PointerSeek(pBlock, pBlock->TotalByteLength);
        }
        if (pBlock->TotalByteLength <= sizeof(PERF_DATA_BLOCK) || pBlock->HeaderLength <= sizeof(PERF_DATA_BLOCK)) {
            continue;
        }
        dwObjects  = pBlock->NumObjectTypes;
        szMachine  = (LPWSTR) PointerSeek(pBlock, sizeof(PERF_DATA_BLOCK));

        G_FREE(szLogMachine);
        szLogMachine = G_ALLOC((lstrlenW(szMachine) + 3) * sizeof(WCHAR));
        if (szLogMachine == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            break;
        }
        hr = StringCchPrintfW(szLogMachine, lstrlenW(szMachine) + 3, L"\\\\%ws", szMachine);
        if (FAILED(hr)) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            break;
        }

        pLoggedMachine = PdhiFindLogMachine(& pPmLog->MachineList, szLogMachine, TRUE);
        if (pLoggedMachine == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            break;
        }

        pCounterTable = pPmLog->pFirstCounterNameTables;
        while (pCounterTable != NULL) {
            if (lstrcmpiW(pCounterTable->szSystemName, szLogMachine) == 0) break;
            pCounterTable = pCounterTable->pNext;
        }
        if (pCounterTable == NULL) continue;

        pObject = FirstObject(pBlock);
        while ((pObject != NULL) && (dwObjects > 0)) {
            dwObjects --;
            if (pObject->TotalByteLength > sizeof(PERF_OBJECT_TYPE)
                            && pObject->DefinitionLength > sizeof(PERF_OBJECT_TYPE)
                            && pObject->ObjectNameTitleIndex <= pCounterTable->dwLastIndex) {
                szObject = (LPWSTR) PdhiLookupLogPerfNameByIndex(pPmLog,
                                                                 szLogMachine,
                                                                 pCounterTable->dwLangId,
                                                                 pObject->ObjectNameTitleIndex);
                if (szObject != NULL) {
                    pLoggedObject = PdhiFindLogObject(pLoggedMachine,
                                                      & pLoggedMachine->ObjTable,
                                                      szObject,
                                                      TRUE);
                    if (pLoggedObject == NULL) {
                        Status = PDH_MEMORY_ALLOCATION_FAILURE;
                        break;
                    }
                    pLoggedObject->bNeedExpand = TRUE;
                    pLoggedObject->dwObject    = pObject->ObjectNameTitleIndex;
                }
            }
            pObject = (dwObjects > 0) ? NextObject(pBlock, pObject) : NULL;
        }
    }

    G_FREE(szLogMachine);
    return Status;
}

PDH_FUNCTION
PdhiCachePmLogHeader(
    PPLAYBACKLOG pPmLog
)
{
    PDH_STATUS   Status           = ERROR_SUCCESS;
    PLOGINDEX  * IndexTable;
    DWORD        i;
    int          iMaxSystemLogged = -1;
    DWORD        dwIndex          = 0;

    if (pPmLog == NULL) {
        Status = PDH_INVALID_ARGUMENT;
        goto Cleanup;
    }
    else if (pPmLog->pFirstCounterNameTables != NULL && pPmLog->MachineList != NULL) {
        goto Cleanup;
    }
    IndexTable = pPmLog->LogIndexTable;
    for (i = 0; i < pPmLog->dwLastIndex; i ++) {
        // Ignore first uFlags 0x00000000 and LogFileIndexBookmark index entries.
        //
        if ((IndexTable[i]->uFlags & LogFileIndexCounterName) != 0) {
            // For LogFileIndexCounterName index entries, cache counter name/explain string table.
            if (IndexTable[i]->lDataOffset < pPmLog->llFileSize) {
                PLOGFILECOUNTERNAME pLogName = (PLOGFILECOUNTERNAME)
                                               PointerSeek(pPmLog->pHeader, IndexTable[i]->lDataOffset);
                PPMLOG_COUNTERNAMES pMachine = pPmLog->pFirstCounterNameTables;

                while (pMachine != NULL) {
                    if (lstrcmpiW(pMachine->szSystemName, pLogName->szComputer) == 0) break;
                    pMachine = pMachine->pNext;
                }
                if (pMachine == NULL) {
                    pMachine = (PPMLOG_COUNTERNAMES) G_ALLOC(
                                    sizeof(PMLOG_COUNTERNAMES) + sizeof(LPWSTR) * (pLogName->dwLastCounterId + 1));
                    if (pMachine != NULL) {
                        pMachine->szSystemName = pLogName->szComputer;
                        pMachine->szNameTable  = PointerSeek(pMachine, sizeof(PMLOG_COUNTERNAMES));
                        pMachine->dwLangId     = pLogName->dwLangId;
                        pMachine->dwLastIndex  = pLogName->dwLastCounterId;
                        pMachine->pNext        = pPmLog->pFirstCounterNameTables;
                        pPmLog->pFirstCounterNameTables = pMachine;
                    }
                    else {
                        Status = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                }
                if (Status == ERROR_SUCCESS) {
                    Status = PdhiBuildPmLogStringTable(pPmLog, pLogName, pMachine, pLogName->lUnmatchCounterNames);
                }
            }
            else {
                Status = PDH_UNABLE_READ_LOG_HEADER;
            }
            if (Status != ERROR_SUCCESS) break;
        }
        else if ((IndexTable[i]->uFlags & LogFileIndexData) != 0) {
            // Process first LogFileIndexData block for initial machine-object cache structure.
            //
            if (IndexTable[i]->iSystemsLogged > iMaxSystemLogged) {
                iMaxSystemLogged = IndexTable[i]->iSystemsLogged;
                dwIndex          = i;
            }
        }
    }
    if (Status == ERROR_SUCCESS) {
        Status = (iMaxSystemLogged > 0) ? PdhiCachePerfDataBlock(pPmLog, IndexTable[dwIndex])
                                        : PDH_UNABLE_READ_LOG_HEADER;
    }
Cleanup:
    return Status;
}

PPERF_DATA_BLOCK
PdhiDataFromIndex(
    PPLAYBACKLOG  pPlaybackLog,
    PLOGINDEX     pLogIndex,
    LPCWSTR       lpszSystemName
)
{
    PPERF_DATA_BLOCK pPerfData;
    PPERF_DATA_BLOCK pRtnBlock            = NULL;
    LPWSTR           szLoggedComputerName = NULL;
    int       iNumSystem ;

    // Note: NULL lpszSystemName means return first logged system name
    //       at the specified index.
    pPerfData = PointerSeek(pPlaybackLog->pHeader, pLogIndex->lDataOffset);

    for (iNumSystem = 0; iNumSystem < pLogIndex->iSystemsLogged; iNumSystem ++) {
        if (pPerfData && pPerfData->Signature[0] == (WCHAR)'P' &&
                         pPerfData->Signature[1] == (WCHAR)'E' &&
                         pPerfData->Signature[2] == (WCHAR)'R' &&
                         pPerfData->Signature[3] == (WCHAR)'F') {
            szLoggedComputerName = (LPWSTR) PointerSeek(pPerfData, pPerfData->SystemNameOffset);
            if (lpszSystemName == NULL) {
                pRtnBlock = pPerfData;
                break;
            }
            else if (lstrlenW(lpszSystemName) > 2 && lpszSystemName[0] == L'\\' && lpszSystemName[1] == L'\\') {
                if (lstrcmpiW(szLoggedComputerName, & (lpszSystemName[2])) == 0) {
                    pRtnBlock = pPerfData;
                    break;
                }
            }
            else if (lstrcmpiW(szLoggedComputerName, lpszSystemName) == 0) {
                pRtnBlock = pPerfData;
                break;
            }
            pPerfData = (PPERFDATA)((PBYTE) pPerfData + pPerfData->TotalByteLength);
        }
        else {
            break;
        }
    }
    return pRtnBlock;
}

PPERF_OBJECT_TYPE
PdhiFindPerfObject(
    PPERF_DATA_BLOCK pBlock,
    DWORD            dwObject
)
{
    DWORD             dwCount = pBlock->NumObjectTypes;
    PPERF_OBJECT_TYPE pObject = FirstObject(pBlock);

    while (pObject != NULL && dwCount > 0) {
        dwCount --;
        if (pObject->ObjectNameTitleIndex == dwObject) break;
        pObject = (dwCount > 0) ? NextObject(pBlock, pObject) : NULL;
    }
    return pObject;
}

PDH_FUNCTION
PdhiCachePmLogObject(
    PPLAYBACKLOG pPmLog,
    LPWSTR       szMachineName,
    LPWSTR       szObjectName
)
{
    PDH_STATUS                Status        = ERROR_SUCCESS;
    PPMLOG_COUNTERNAMES       pCounterTable = NULL;
    PPDHI_LOG_MACHINE         pLogMachine   = PdhiFindLogMachine(& pPmLog->MachineList, szMachineName, FALSE);
    PPDHI_LOG_OBJECT          pLogObject    = NULL;
    PPDHI_LOG_COUNTER         pLogCounter   = NULL;
    PPDHI_LOG_COUNTER         pLogInst;
    PPDHI_LOG_COUNTER         pLogInstHead;
    PPERF_DATA_BLOCK          pBlock;
    PPERF_OBJECT_TYPE         pObject;
    PPERF_OBJECT_TYPE         pParentObject;
    PPERF_COUNTER_DEFINITION  pCounter;
    PPERF_INSTANCE_DEFINITION pInstance;
    PPERF_INSTANCE_DEFINITION pParentInstance;
    LPWSTR                    szCounter;
    LPWSTR                    szInstance;
    LPWSTR                    szParent;
    DWORD                     dwInstance;
    DWORD                     dwParent;
    BOOL                      bInstance     = FALSE;
    DWORD                     i;
    DWORD                     dwCount;
    DWORD                     dwCounterID;

    if (pLogMachine != NULL) {
        pLogObject = PdhiFindLogObject(pLogMachine, & pLogMachine->ObjTable, szObjectName, FALSE);
    }
    if (pLogObject == NULL) {
        Status = PDH_INVALID_ARGUMENT;
    }
    else if (pLogObject->bNeedExpand) {
        pCounterTable = pPmLog->pFirstCounterNameTables;
        while (pCounterTable != NULL) {
            if (lstrcmpiW(pCounterTable->szSystemName, szMachineName) == 0) break;
            pCounterTable = pCounterTable->pNext;
        }
        if (pCounterTable == NULL) {
            Status = PDH_INVALID_ARGUMENT;
            goto Cleanup;
        }

        for (i = 0; i < pPmLog->dwLastIndex; i ++) {
            pBlock = PdhiDataFromIndex(pPmLog, pPmLog->LogIndexTable[i], szMachineName);
            if (pBlock == NULL) continue;

            pObject = PdhiFindPerfObject(pBlock, pLogObject->dwObject);
            if (pObject == NULL) {
                continue;
            }
            else if (pObject->TotalByteLength <= sizeof(PERF_OBJECT_TYPE)
                    || pObject->DefinitionLength <= sizeof(PERF_OBJECT_TYPE)) {
                continue;
            }

            dwCount  = pObject->NumCounters;
            pCounter = FirstCounter(pObject);
            while (pCounter != NULL && dwCount > 0) {
                dwCount --;
                szCounter = (LPWSTR) PdhiLookupLogPerfNameByIndex(pPmLog,
                                                                  szMachineName,
                                                                  pCounterTable->dwLangId,
                                                                  pCounter->CounterNameTitleIndex);
                if (szCounter != NULL) {
                    pLogCounter = PdhiFindPmCounterInstance(pLogObject,
                                                            szCounter,
                                                            pCounter->CounterType,
                                                            pCounter->DefaultScale,
                                                            NULL,
                                                            0,
                                                            NULL,
                                                            pCounter->CounterOffset,
                                                            & pCounter->CounterNameTitleIndex,
                                                            FALSE,
                                                            TRUE);
                    if (pLogCounter == NULL) {
                        Status = PDH_MEMORY_ALLOCATION_FAILURE;
                        break;
                    }
                    else if (pCounter->CounterType  & PERF_TIMER_100NS) {
                        pLogCounter->TimeBase = (LONGLONG) 10000000;
                    }
                    else if (pCounter->CounterType  & PERF_OBJECT_TIMER) {
                        // then get the time base freq from the object
                        pLogCounter->TimeBase = pObject->PerfFreq.QuadPart;
                    }
                    else { // if (pPerfCounter->CounterType & PERF_TIMER_TICK or other)
                        pLogCounter->TimeBase = pBlock->PerfFreq.QuadPart;
                    }
                }
                pCounter = NextCounter(pObject, pCounter);
            }
            if (Status != ERROR_SUCCESS) continue;

            dwCount   = pObject->NumInstances;
            bInstance = (dwCount != PERF_NO_INSTANCES) && (dwCount != 0);
            if (bInstance) {
                for (pLogCounter = pLogObject->InstList; pLogCounter != NULL; pLogCounter = pLogCounter->next) {
                    pLogCounter->dwCounterType = 0;
                }

                pInstance = FirstInstance(pObject);
                while (pInstance != NULL && dwCount > 0) {
                    dwCount --;
                    szInstance = (pInstance->NameOffset != 0) ? (LPWSTR) PointerSeek(pInstance, pInstance->NameOffset)
                                                              : NULL;
                    dwInstance  = pInstance->UniqueID;
                    szParent    = NULL;
                    dwParent    = PERF_NO_UNIQUE_ID;
                    dwCounterID = 0;
                    if (pInstance->ParentObjectTitleIndex != 0) {
                        pParentObject = PdhiFindPerfObject(pBlock, pInstance->ParentObjectTitleIndex);
                        if (pParentObject != NULL && pParentObject->TotalByteLength > sizeof(PERF_OBJECT_TYPE)
                                                  && pParentObject->DefinitionLength > sizeof(PERF_OBJECT_TYPE)) {
                            pParentInstance = GetInstance(pParentObject, pInstance->ParentObjectInstance);
                            if (pParentInstance != NULL) {
                                szParent    = (pParentInstance->NameOffset != 0)
                                            ? (LPWSTR) PointerSeek(pParentInstance, pParentInstance->NameOffset) : NULL;
                                dwParent    = pParentInstance->UniqueID;
                                dwCounterID = 1;
                            }
                        }
                    }
                    if (PdhiFindPmCounterInstance(pLogObject, NULL, 0, 0,
                                    szInstance, dwInstance, szParent, dwParent, & dwCounterID, TRUE, TRUE) == NULL) {
                        Status = PDH_MEMORY_ALLOCATION_FAILURE;
                        break;
                    }

                    pInstance = NextInstance(pObject, pInstance);
                }

            }

            if (pObject->NumInstances == PERF_NO_INSTANCES) break;
        }

        pLogInstHead          = pLogObject->InstList;
        pLogObject->InstList  = NULL;
        pLogObject->InstTable = NULL;
        for (pLogInst = pLogInstHead; pLogInst != NULL; pLogInst = pLogInst->next) {
            if (pLogInst->dwInstance != 0 && pLogInst->dwInstance != PERF_NO_UNIQUE_ID) {
                PdhiFindPmCounterInstance(pLogObject,
                                          NULL,
                                          0,
                                          0,
                                          pLogInst->szInstance,
                                          pLogInst->dwInstance,
                                          pLogInst->szParent,
                                          pLogInst->dwParent,
                                          & pLogInst->dwCounterID,
                                          TRUE,
                                          TRUE);
            }
            else {
                for (i = 0; i < pLogInst->dwDefaultScale; i ++) {
                    PdhiFindPmCounterInstance(pLogObject,
                                              NULL,
                                              0,
                                              0,
                                              pLogInst->szInstance,
                                              i,
                                              pLogInst->szParent,
                                              pLogInst->dwParent,
                                              & pLogInst->dwCounterID,
                                              TRUE,
                                              TRUE);
                }
            }
        }
        while (pLogInstHead != NULL) {
            pLogInst     = pLogInstHead;
            pLogInstHead = pLogInst->next;
            G_FREE(pLogInst);
        }

        pLogObject->bNeedExpand = FALSE;
    }

Cleanup:
    return Status;
}

PDH_FUNCTION
PdhiRewindPmLog(
    PPDHI_LOG    pLog,
    PPLAYBACKLOG pPmLog
)
{
    PDH_STATUS Status = ERROR_SUCCESS;

    if (pPmLog->dwFirstIndex == 0) {
        PLOGINDEX  pIndex = NULL;
        DWORD      i;
        for (i = 0; i < pPmLog->dwLastIndex; i ++) {
            pIndex = pPmLog->LogIndexTable[i];
            if ((pIndex->uFlags & LogFileIndexData) != 0) break;
        }

        if (i < pPmLog->dwLastIndex) {
            pPmLog->dwFirstIndex = i;
        }
    }
    if (pPmLog->dwFirstIndex != pPmLog->dwCurrentIndex) {
        pLog->dwLastRecordRead = pPmLog->dwFirstIndex;
        pPmLog->dwCurrentIndex = pPmLog->dwFirstIndex;
        pLog->pLastRecordRead  = PointerSeek(pPmLog->pHeader,
                                             pPmLog->LogIndexTable[pPmLog->dwFirstIndex]->lDataOffset);
    }
    return Status;
}

PDH_FUNCTION
PdhiOpenInputPerfmonLog(
    PPDHI_LOG pLog
)
{
    PDH_STATUS   pdhStatus  = ERROR_SUCCESS;
    PPLAYBACKLOG pPmPbLog   = (PPLAYBACKLOG) pLog->pPerfmonInfo;

    pLog->StreamFile = (FILE *) ((DWORD_PTR) (-1));

    // map file as a memory array for reading

    if (pLog->hMappedLogFile != NULL && pLog->lpMappedFileBase != NULL) {
        pLog->dwLastRecordRead = 0;
        pLog->pLastRecordRead  = NULL;
        pLog->pPerfmonInfo     = G_ALLOC(sizeof(PLAYBACKLOG));
        if (pLog->pPerfmonInfo != NULL) {
            pPmPbLog   = (PPLAYBACKLOG) pLog->pPerfmonInfo;
            // assumes structure was 0-init'd on allocation
            pPmPbLog->llFileSize              = pLog->llFileSize;
            pPmPbLog->szFilePath              = pLog->szLogFileName;
            pPmPbLog->pHeader                 = pLog->lpMappedFileBase;
            pPmPbLog->iTotalTics              = 1;
            pPmPbLog->dwFirstIndex            = 0;
            pPmPbLog->MachineList             = NULL;
            pPmPbLog->pFirstCounterNameTables = NULL;
            pdhStatus = PdhiBuildPmLogIndexTable(pPmPbLog);
            if (pdhStatus == ERROR_SUCCESS) {
                pdhStatus = PdhiRewindPmLog(pLog, pPmPbLog);
            }
        }
        else {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    }
    else {
        // return PDH Error
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiClosePerfmonLog(
    PPDHI_LOG pLog,
    DWORD     dwFlags
)
{
    PDH_STATUS   pdhStatus    = ERROR_SUCCESS;
    PPLAYBACKLOG pPlaybackLog = (PPLAYBACKLOG) pLog->pPerfmonInfo;

    DBG_UNREFERENCED_PARAMETER(dwFlags);

    if (pPlaybackLog != NULL) {
        G_FREE(pPlaybackLog->LogIndexTable);
        PdhiFreeLogMachineTable(& pPlaybackLog->MachineList);
        PdhiFreePmMachineList(pPlaybackLog);
        G_FREE(pLog->pPerfmonInfo);
        pLog->pPerfmonInfo = NULL;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetPerfmonLogCounterInfo(
    PPDHI_LOG       pLog,
    PPDHI_COUNTER   pCounter
)
{
    PDH_STATUS        pdhStatus    = PDH_LOG_FILE_OPEN_ERROR;
    PPLAYBACKLOG      pPlaybackLog = (PPLAYBACKLOG) pLog->pPerfmonInfo;
    PPDHI_LOG_MACHINE pLogMachine  = NULL;
    PPDHI_LOG_OBJECT  pLogObject   = NULL;
    PPDHI_LOG_COUNTER pLogCounter  = NULL;
    PPDHI_LOG_COUNTER pLogInstance = NULL;
    DWORD             dwCounter;

    PPERF_DATA_BLOCK           pPerfData              = NULL;
    PPERF_OBJECT_TYPE          pObjectDef;
    PPERF_COUNTER_DEFINITION   pPerfCounter;
    PPERF_INSTANCE_DEFINITION  pInstanceDef;
    DWORD                      dwObjectId             = 0;
    LOGPOSITION                LogPosition;
    LOGINDEX                 * pLogIndex;
    LPWSTR                   * pCounterNames          = NULL;
    DWORD                      dwLastCounterNameIndex = 0;
    BOOL                       bObjectNumber          = FALSE;

    if (pPlaybackLog != NULL) {
        pdhStatus = PdhiCachePmLogHeader(pPlaybackLog);
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhiCachePmLogObject(pPlaybackLog,
                                             pCounter->pCounterPath->szMachineName,
                                             pCounter->pCounterPath->szObjectName);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pLogMachine = PdhiFindLogMachine(& pPlaybackLog->MachineList, pCounter->pCounterPath->szMachineName, FALSE);
        pCounter->pThisRawItemList = (LPVOID) pLogMachine;
        if (pLogMachine != NULL) {
            pLogObject = PdhiFindLogObject(
                            pLogMachine, & pLogMachine->ObjTable, pCounter->pCounterPath->szObjectName, FALSE);
            pCounter->pLastRawItemList = (LPVOID) pLogObject;
            if (pLogObject == NULL) {
                pdhStatus = PDH_CSTATUS_NO_OBJECT;
            }
        }
        else {
            pdhStatus = PDH_CSTATUS_NO_MACHINE;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pLogCounter  = PdhiFindPmCounterInstance(pLogObject,
                                                 pCounter->pCounterPath->szCounterName,
                                                 0,
                                                 0,
                                                 NULL,
                                                 0,
                                                 NULL,
                                                 0,
                                                 & dwCounter,
                                                 FALSE,
                                                 FALSE);
        pCounter->pThisObject = (LPVOID) pLogCounter;
        if (pCounter->pCounterPath->szInstanceName != NULL) {
            pLogInstance = PdhiFindPmCounterInstance(pLogObject,
                                                     NULL,
                                                     0,
                                                     0,
                                                     pCounter->pCounterPath->szInstanceName,
                                                     pCounter->pCounterPath->dwIndex,
                                                     pCounter->pCounterPath->szParentName,
                                                     0,
                                                     & dwCounter,
                                                     TRUE,
                                                     FALSE);
            pCounter->pLastObject = (LPVOID) pLogInstance;
        }
    }
    if (pLogCounter != NULL) {
        if (pCounter->pCounterPath->szInstanceName != NULL) {
            if (pLogInstance == NULL) {
                pdhStatus = PDH_CSTATUS_NO_INSTANCE;
            }
        }
        pCounter->plCounterInfo.dwObjectId           = pLogObject->dwObject;
        if (pLogInstance) {
            pCounter->plCounterInfo.lInstanceId      = (pLogInstance->szInstance == NULL)
                                                     ? pLogInstance->dwInstance : PERF_NO_UNIQUE_ID;
            pCounter->plCounterInfo.dwParentObjectId = pLogInstance->dwParent;
        }
        else {
            pCounter->plCounterInfo.lInstanceId      = PERF_NO_UNIQUE_ID;
            pCounter->plCounterInfo.dwParentObjectId = PERF_NO_UNIQUE_ID;
        }
        pCounter->plCounterInfo.szInstanceName       = pCounter->pCounterPath->szInstanceName;
        pCounter->plCounterInfo.szParentInstanceName = pCounter->pCounterPath->szParentName;
        pCounter->plCounterInfo.dwCounterId          = pLogCounter->dwCounterID;
        pCounter->plCounterInfo.dwCounterType        = pLogCounter->dwCounterType;
        pCounter->plCounterInfo.dwCounterSize        = pLogCounter->dwInstance;
        pCounter->plCounterInfo.lDefaultScale        = pLogCounter->dwDefaultScale;
        pCounter->TimeBase                           = pLogCounter->TimeBase;
    }
    else {
        pdhStatus = PDH_CSTATUS_NO_COUNTER;
    }

    return pdhStatus;    
}

PDH_FUNCTION
PdhiEnumMachinesFromPerfmonLog(
    PPDHI_LOG pLog,
    LPVOID    pBuffer,
    LPDWORD   pcchBufferSize,
    BOOL      bUnicodeDest
)
{
    PDH_STATUS   pdhStatus    = PDH_LOG_FILE_OPEN_ERROR;
    PPLAYBACKLOG pPlaybackLog = (PPLAYBACKLOG) pLog->pPerfmonInfo;

    if (pPlaybackLog != NULL) {
        pdhStatus = PdhiCachePmLogHeader(pPlaybackLog);
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhiEnumCachedMachines(pPlaybackLog->MachineList, pBuffer, pcchBufferSize, bUnicodeDest);
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumObjectsFromPerfmonLog(
    PPDHI_LOG pLog,
    LPCWSTR   lpszSystemName,
    LPVOID    pBuffer,
    LPDWORD   pcchBufferSize,
    DWORD     dwDetailLevel,
    BOOL      bUnicodeDest
)
{
    PDH_STATUS   pdhStatus    = PDH_LOG_FILE_OPEN_ERROR;
    PPLAYBACKLOG pPlaybackLog = (PPLAYBACKLOG) pLog->pPerfmonInfo;

    if (pPlaybackLog != NULL) {
        pdhStatus = PdhiCachePmLogHeader(pPlaybackLog);
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhiEnumCachedObjects(
                    pPlaybackLog->MachineList, lpszSystemName, pBuffer, pcchBufferSize, dwDetailLevel, bUnicodeDest);
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumObjectItemsFromPerfmonLog(
    PPDHI_LOG          pLog,
    LPCWSTR            szMachineName,
    LPCWSTR            szObjectName,
    PDHI_COUNTER_TABLE CounterTable,
    DWORD              dwDetailLevel,
    DWORD              dwFlags
)
{
    PDH_STATUS   pdhStatus    = PDH_LOG_FILE_OPEN_ERROR;
    PPLAYBACKLOG pPlaybackLog = (PPLAYBACKLOG) pLog->pPerfmonInfo;
    HRESULT      hr;

    DBG_UNREFERENCED_PARAMETER(dwFlags);
    DBG_UNREFERENCED_PARAMETER(dwDetailLevel);

    if (pPlaybackLog != NULL) {
        pdhStatus = PdhiCachePmLogHeader(pPlaybackLog);
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhiCachePmLogObject(pPlaybackLog, (LPWSTR) szMachineName, (LPWSTR) szObjectName);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        PPDHI_LOG_MACHINE pMachine       = NULL;
        PPDHI_LOG_OBJECT  pObject        = NULL;
        PPDHI_LOG_COUNTER pCtr           = NULL;
        PPDHI_LOG_COUNTER pInst          = NULL;
        PPDHI_INST_LIST   pFirstInstList = NULL;
        PPDHI_INST_LIST   pInstList      = NULL;
        PPDHI_INSTANCE    pInstance      = NULL;
        LONG              nCounterCount  = 0;
        LONG              nInstanceCount = 0;

        pMachine = PdhiFindLogMachine(& pPlaybackLog->MachineList, (LPWSTR) szMachineName, FALSE);
        if (pMachine == NULL) {
            pdhStatus = PDH_CSTATUS_NO_MACHINE;
        }
        else {
            pObject = PdhiFindLogObject(pMachine, & (pMachine->ObjTable), (LPWSTR) szObjectName, FALSE);
            if (pObject == NULL) {
                pdhStatus = PDH_CSTATUS_NO_OBJECT;
            }
        }
        if (pdhStatus == ERROR_SUCCESS) {
            for (pCtr = pObject->CtrList; pCtr != NULL; pCtr = pCtr->next) {
                pdhStatus = PdhiFindCounterInstList(CounterTable, pCtr->szCounter, & pInstList);
                if (pdhStatus != ERROR_SUCCESS) {
                    continue;
                }
                else {
                    nCounterCount ++;
                    if (pFirstInstList == NULL) {
                        pFirstInstList = pInstList;
                    }
                }
            }

            if (pFirstInstList != NULL) {
                pInst = pObject->InstList;
                if (pInst != NULL && pInst != PDH_INVALID_POINTER) {
                    LPWSTR szFullInstance = G_ALLOC((PDH_MAX_INSTANCE_NAME + 1) * sizeof(WCHAR));
                    if (szFullInstance != NULL) {
                        while (pInst != NULL) {
                            ZeroMemory(szFullInstance, (PDH_MAX_INSTANCE_NAME + 1) * sizeof(WCHAR));
                            if (pInst->szInstance != NULL) {
                                if (pInst->dwCounterID != 0) {
                                    if (pInst->szParent != NULL) {
                                        if (pInst->dwInstance != 0 && pInst->dwInstance != PERF_NO_UNIQUE_ID) {
                                            hr = StringCchPrintfW(szFullInstance,
                                                    PDH_MAX_INSTANCE_NAME, L"%ws%ws%ws#%u",
                                                    pInst->szParent, cszSlash, pInst->szInstance, pInst->dwInstance);
                                        }
                                        else {
                                            hr = StringCchPrintfW(szFullInstance,
                                                    PDH_MAX_INSTANCE_NAME, L"%ws%ws%ws",
                                                    pInst->szParent, cszSlash, pInst->szInstance);
                                        }
                                    }
                                    else {
                                        if (pInst->dwInstance != 0 && pInst->dwInstance != PERF_NO_UNIQUE_ID) {
                                            hr = StringCchPrintfW(szFullInstance,
                                                    PDH_MAX_INSTANCE_NAME, L"%u%ws%ws#%u",
                                                    pInst->dwParent, cszSlash, pInst->szInstance, pInst->dwInstance);
                                        }
                                        else {
                                            hr = StringCchPrintfW(szFullInstance,
                                                    PDH_MAX_INSTANCE_NAME, L"%u%ws%ws",
                                                    pInst->dwParent, cszSlash, pInst->szInstance);
                                        }
                                    }
                                }
                                else if (pInst->dwInstance != 0 && pInst->dwInstance != PERF_NO_UNIQUE_ID) {
                                    hr = StringCchPrintfW(szFullInstance, PDH_MAX_INSTANCE_NAME, L"%ws#%u",
                                            pInst->szInstance, pInst->dwInstance);
                                }
                                else {
                                    hr = StringCchCopyW(szFullInstance, PDH_MAX_INSTANCE_NAME, pInst->szInstance);
                                }
                            }
                            else if (pInst->dwCounterID != 0) {
                                if (pInst->szParent != NULL) {
                                    hr = StringCchPrintfW(szFullInstance, PDH_MAX_INSTANCE_NAME, L"%ws%ws%u",
                                            pInst->szParent, cszSlash, pInst->dwInstance);
                                }
                                else {
                                    hr = StringCchPrintfW(szFullInstance, PDH_MAX_INSTANCE_NAME, L"%u%ws%u",
                                            pInst->dwParent, cszSlash, pInst->dwInstance);
                                }
                            }
                            else {
                                hr = StringCchPrintfW(szFullInstance, PDH_MAX_INSTANCE_NAME, L"%u",
                                        pInst->dwInstance);
                            }
                            // ignore checkin hr return, we intend to truncate string to PDH_MAX_INSTANCE_NAME

                            pdhStatus = PdhiFindInstance(& pFirstInstList->InstList, szFullInstance, TRUE, & pInstance);
                            if (pdhStatus == ERROR_SUCCESS) {
                                nInstanceCount ++;
                            }
                            pInst = pInst->next;
                        }
                    }
                    else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                }
            }

            if (nCounterCount == 0 && nInstanceCount == 0) {
                if (pdhStatus == ERROR_SUCCESS) {
                    pdhStatus = PDH_CSTATUS_NO_OBJECT;
                }
            }
            else if (pdhStatus != PDH_MORE_DATA) {
                // then the routine was successful. Errors that occurred
                // while scanning will be ignored as long as at least
                // one entry was successfully read

                pdhStatus = ERROR_SUCCESS;
            }
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetMatchingPerfmonLogRecord(
    PPDHI_LOG   pLog,
    LONGLONG  * pStartTime,
    LPDWORD     pdwIndex
)
{
    PDH_STATUS       pdhStatus    = ERROR_SUCCESS;
    PPLAYBACKLOG     pPlaybackLog = (PPLAYBACKLOG) pLog->pPerfmonInfo;
    DWORD            dwThisIndex  = 0;
    DWORD            dwLastIndex  = 0;
    LONGLONG         llThisTime   = 0;
    PPERF_DATA_BLOCK pPerfData;
    FILETIME         ftGMT;

    if (pPlaybackLog == NULL) {
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;    // log is invalid
    }
    else {
        dwLastIndex = pPlaybackLog->dwFirstIndex;
        for (dwThisIndex = pPlaybackLog->dwFirstIndex; dwThisIndex < pPlaybackLog->dwLastIndex; dwThisIndex ++) {
            pPerfData = (PPERF_DATA_BLOCK) PointerSeek(
                    pPlaybackLog->pHeader, pPlaybackLog->LogIndexTable[dwThisIndex]->lDataOffset);
            if (pPerfData != NULL) {
                SystemTimeToFileTime(& pPerfData->SystemTime, & ftGMT);
                FileTimeToLocalFileTime(& ftGMT, (FILETIME *) & llThisTime);

                if (llThisTime == * pStartTime) {
                    // record found
                    break;
                }
                else if (llThisTime > * pStartTime) {
                    // go back one
                    dwThisIndex = dwLastIndex;
                    break;
                }
                else {
                    dwLastIndex = dwThisIndex;
                    // go to the next one
                }
            }
            else {
                dwLastIndex = dwThisIndex;
                // go to the next one
            }
        }
        if (dwThisIndex == pPlaybackLog->dwLastIndex) {
            // then there's no more records in the log
            pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        if (pdwIndex != NULL) * pdwIndex = dwThisIndex;
        if (pLog->dwLastRecordRead != dwThisIndex) {
            pLog->dwLastRecordRead       = dwThisIndex;
            pPlaybackLog->dwCurrentIndex = dwThisIndex;
            pLog->pLastRecordRead        = PointerSeek(pPlaybackLog->pHeader,
                                                       pPlaybackLog->LogIndexTable[dwThisIndex]->lDataOffset);
        }
    }
    return pdhStatus;
}

DWORD
PdhiGetPmBaseCounterOffset(
    PPDHI_LOG_COUNTER pCounter,
    PPERF_OBJECT_TYPE pPerfObject
)
{
    DWORD dwReturn = pCounter->dwInstance;

    if (pCounter->dwInstance == 0) {
        PPERF_COUNTER_DEFINITION pPerfCounter = FirstCounter(pPerfObject);
        DWORD                    dwCounter    = pPerfObject->NumCounters;

        while (pPerfCounter != NULL && dwCounter > 0) {
            dwCounter --;
            if (pPerfCounter->CounterNameTitleIndex == pCounter->dwCounterID) {
                pPerfCounter = NextCounter(pPerfObject, pPerfCounter);
                if (pPerfCounter == NULL) break;
                if ((pPerfCounter->CounterType & PERF_COUNTER_BASE) != 0) {
                    dwReturn = pPerfCounter->CounterOffset;
                    break;
                }
            }
            pPerfCounter = NextCounter(pPerfObject, pPerfCounter);
        }
        pCounter->dwInstance = dwReturn;
    }
    return dwReturn;
}

PDH_FUNCTION
PdhiGetCounterValueFromPerfmonLog(
    PPDHI_LOG        pLog,
    DWORD            dwIndex,
    PPDHI_COUNTER    pCounter,
    PPDH_RAW_COUNTER pValue
)
{
    PDH_STATUS                pdhStatus    = ERROR_SUCCESS;
    PPLAYBACKLOG              pPlaybackLog = (PPLAYBACKLOG) pLog->pPerfmonInfo;
    PLOGINDEX                 pIndex       = NULL;
    PPERF_DATA_BLOCK          pPerfData    = NULL;
    PPERF_OBJECT_TYPE         pPerfObject  = NULL;
    PPERF_INSTANCE_DEFINITION pPerfInst    = NULL;
    PPERF_COUNTER_BLOCK       pCtrBlock    = NULL;
    LPVOID                    pEndGuard;
    PPDHI_LOG_MACHINE         pLogMachine  = (PPDHI_LOG_MACHINE) pCounter->pThisRawItemList;
    PPDHI_LOG_OBJECT          pLogObject   = (PPDHI_LOG_OBJECT)  pCounter->pLastRawItemList;
    PPDHI_LOG_COUNTER         pLogCounter  = (PPDHI_LOG_COUNTER) pCounter->pThisObject;
    PPDHI_LOG_COUNTER         pLogInstance = (PPDHI_LOG_COUNTER) pCounter->pLastObject;
    BOOL                      bReturn;
    DWORD                     LocalCType;
    DWORD                   * pdwData;
    UNALIGNED LONGLONG      * pllData;
    LPVOID                    pData        = NULL;
    FILETIME                  ftGMT;

    if (pPlaybackLog == NULL) {
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;    // log is invalid
    }
    else if (dwIndex < pPlaybackLog->dwFirstIndex) {
        // invalid dwIndex value
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else if (dwIndex >= pPlaybackLog->dwLastIndex) {
        pdhStatus = PDH_NO_MORE_DATA;
    }
    else if (pLogMachine == NULL || pLogObject == NULL || pLogCounter == NULL) {
        pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
    }
    else {
        if (pLog->dwLastRecordRead != dwIndex) {
            pLog->dwLastRecordRead       = dwIndex;
            pPlaybackLog->dwCurrentIndex = dwIndex;
            pLog->pLastRecordRead        = PointerSeek(pPlaybackLog->pHeader,
                                                       pPlaybackLog->LogIndexTable[dwIndex]->lDataOffset);
        }
        pIndex = pPlaybackLog->LogIndexTable[dwIndex];
    }
    if (pdhStatus == ERROR_SUCCESS) {
        // find a matching system...
        if (pLogMachine->pBlock != NULL && pLogMachine->dwIndex == dwIndex) {
            pPerfData = pLogMachine->pBlock;
        }
        else {
            pPerfData = PdhiDataFromIndex(pPlaybackLog, pIndex, pCounter->pCounterPath->szMachineName);
            pLogMachine->pBlock  = pPerfData;
            pLogMachine->dwIndex = dwIndex;
        }

        if (pPerfData == NULL) {
            pdhStatus            = PDH_CSTATUS_NO_MACHINE;
            pLogObject->pObjData = NULL;
            pLogObject->dwIndex  = dwIndex;
        }
        else if (pLogObject->pObjData != NULL && pLogObject->dwIndex == dwIndex) {
            pPerfObject = pLogObject->pObjData;
        }
        else {
            pEndGuard           = PointerSeek(pPerfData, pPerfData->TotalByteLength);
            pPerfObject         = PdhiFindPerfObject(pPerfData, pLogObject->dwObject);
            pLogObject->dwIndex = dwIndex;
            if (pPerfObject != NULL && ((LPVOID) pPerfObject) < pEndGuard) {
                pLogObject->pObjData = pPerfObject;
            }
            else {
                pLogObject->pObjData = NULL;
                pdhStatus            = PDH_CSTATUS_NO_OBJECT;
            }
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        pEndGuard = PointerSeek(pPerfObject, pPerfObject->TotalByteLength);
        if (pPerfObject->NumInstances == PERF_NO_INSTANCES) {
            pCtrBlock = (PPERF_COUNTER_BLOCK) PointerSeek(pPerfObject, pPerfObject->DefinitionLength);
            if (pCtrBlock != NULL && ((LPVOID) pCtrBlock) < pEndGuard) {
                pData = PointerSeek(pCtrBlock, pLogCounter->dwParent);
                if (pData >= pEndGuard) pData = NULL;
            }
        }
        else if (pLogInstance != NULL) {
            if (pLogInstance->szCounter != NULL && pLogInstance->dwCounterType == dwIndex) {
                pCtrBlock = (PPERF_COUNTER_BLOCK) pLogInstance->szCounter;
            }
            else {
                if (pCounter->plCounterInfo.lInstanceId == PERF_NO_UNIQUE_ID
                                && pCounter->pCounterPath->szInstanceName != NULL) {
                    pPerfInst = GetInstanceByName(pPerfData,
                                                  pPerfObject,
                                                  pCounter->pCounterPath->szInstanceName,
                                                  pCounter->pCounterPath->szParentName,
                                                  pCounter->pCounterPath->dwIndex);
                    if (pPerfInst == NULL && pCounter->pCounterPath->szInstanceName[0] >= L'0'
                                          && pCounter->pCounterPath->szInstanceName[0] <= L'9') {
                        LONG lInstanceId = (LONG) _wtoi(pCounter->pCounterPath->szInstanceName);
                        pPerfInst        = GetInstanceByUniqueId(pPerfObject, lInstanceId);
                    }
                }
                else {
                    pPerfInst = GetInstanceByUniqueId(pPerfObject, pCounter->plCounterInfo.lInstanceId);
                }
                if (((LPVOID) pPerfInst) >= pEndGuard) pPerfInst = NULL;
                if (pPerfInst != NULL) {
                    pCtrBlock = (PPERF_COUNTER_BLOCK) PointerSeek(pPerfInst, pPerfInst->ByteLength);
                    if (((LPVOID) pCtrBlock) >= pEndGuard) pCtrBlock = NULL;
                }
                pLogInstance->szCounter     = (LPVOID) pCtrBlock;
                pLogInstance->dwCounterType = dwIndex;
            }

            if (pCtrBlock != NULL) {
                pData = PointerSeek(pCtrBlock, pLogCounter->dwParent);
                if (pData >= pEndGuard) pData = NULL;
            }
            else {
                pdhStatus = PDH_CSTATUS_NO_INSTANCE;
            }
        }
        else {
            pdhStatus = PDH_CSTATUS_NO_INSTANCE;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        if (pData == NULL) {
            pdhStatus = PDH_INVALID_DATA;
        }
        else {
            // assume success
            bReturn = TRUE;

            // convert system time in GMT to Local File time
            SystemTimeToFileTime(& pPerfData->SystemTime, & ftGMT);
            FileTimeToLocalFileTime(& ftGMT, & pValue->TimeStamp);

            pValue->MultiCount = 1; // unless changed

            // load counter value based on counter type
            LocalCType = pCounter->plCounterInfo.dwCounterType;
            switch (LocalCType) {
            //
            // these counter types are loaded as:
            //      Numerator = Counter data from perf data block
            //      Denominator = Perf Time from perf data block
            //      (the time base is the PerfFreq)
            //
            case PERF_COUNTER_COUNTER:
            case PERF_COUNTER_QUEUELEN_TYPE:
            case PERF_SAMPLE_COUNTER:
                pValue->FirstValue  = (LONGLONG) (* (DWORD *) pData);
                pValue->SecondValue = pPerfData->PerfTime.QuadPart;
                break;

            case PERF_OBJ_TIME_TIMER:
                pValue->FirstValue  = (LONGLONG) (* (DWORD *) pData);
                pValue->SecondValue = pPerfObject->PerfTime.QuadPart;
                break;

            case PERF_COUNTER_100NS_QUEUELEN_TYPE:
                pllData             = (UNALIGNED LONGLONG *) pData;
                pValue->FirstValue  = * pllData;
                pValue->SecondValue = pPerfData->PerfTime100nSec.QuadPart;
                break;

            case PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
                pllData             = (UNALIGNED LONGLONG *) pData;
                pValue->FirstValue  = * pllData;
                pValue->SecondValue = pPerfObject->PerfTime.QuadPart;
                break;

            case PERF_COUNTER_TIMER:
            case PERF_COUNTER_TIMER_INV:
            case PERF_COUNTER_BULK_COUNT:
            case PERF_COUNTER_MULTI_TIMER:
            case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
                pllData             = (UNALIGNED LONGLONG *) pData;
                pValue->FirstValue  = * pllData;
                pValue->SecondValue = pPerfData->PerfTime.QuadPart;
                if ((LocalCType & PERF_MULTI_COUNTER) == PERF_MULTI_COUNTER) {
                    pValue->MultiCount = (DWORD) * ++ pllData;
                }
                break;
            //
            //  These counters do not use any time reference
            //
            case PERF_COUNTER_RAWCOUNT:
            case PERF_COUNTER_RAWCOUNT_HEX:
                pValue->FirstValue  = (LONGLONG) (* (DWORD *) pData);
                pValue->SecondValue = 0;
                break;

            case PERF_COUNTER_LARGE_RAWCOUNT:
            case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
                pValue->FirstValue  = * (LONGLONG *) pData;
                pValue->SecondValue = 0;
                break;
            //
            //  These counters use the 100 Ns time base in thier calculation
            //
            case PERF_100NSEC_TIMER:
            case PERF_100NSEC_TIMER_INV:
            case PERF_100NSEC_MULTI_TIMER:
            case PERF_100NSEC_MULTI_TIMER_INV:
                pllData             = (UNALIGNED LONGLONG *) pData;
                pValue->FirstValue  = * pllData;
                pValue->SecondValue = pPerfData->PerfTime100nSec.QuadPart;
                if ((LocalCType & PERF_MULTI_COUNTER) == PERF_MULTI_COUNTER) {
                    ++ pllData;
                    pValue->MultiCount = * (DWORD *) pllData;
                }
                break;
            //
            //  These counters use two data points, the one pointed to by
            //  pData and the one immediately after
            //
            case PERF_SAMPLE_FRACTION:
            case PERF_RAW_FRACTION:
                pdwData            = (DWORD *) pData;
                pValue->FirstValue = (LONGLONG) (* pdwData);
                // find the pointer to the base value in the structure
                PdhiGetPmBaseCounterOffset(pLogCounter, pPerfObject);
                if (pLogCounter->dwInstance > 0) {
                    pData               = PointerSeek(pCtrBlock, pLogCounter->dwInstance);
                    pdwData             = (DWORD *) pData;
                    pValue->SecondValue = (LONGLONG) (* pdwData);
                }
                else {
                    // unable to locate base value
                    pValue->SecondValue = 0;
                    bReturn             = FALSE;
                }
                break;

            case PERF_PRECISION_SYSTEM_TIMER:
            case PERF_PRECISION_100NS_TIMER:
            case PERF_PRECISION_OBJECT_TIMER:
                pllData            = (LONGLONG *) pData;
                pValue->FirstValue = * pllData;
                // find the pointer to the base value in the structure
                PdhiGetPmBaseCounterOffset(pLogCounter, pPerfObject);
                if (pLogCounter->dwInstance > 0) {
                    pData               = PointerSeek(pCtrBlock, pLogCounter->dwInstance);
                    pllData             = (LONGLONG *) pData;
                    pValue->SecondValue = * pllData;
                }
                else {
                    // unable to locate base value
                    pValue->SecondValue = 0;
                    bReturn             = FALSE;
                }
                break;

            case PERF_AVERAGE_TIMER:
            case PERF_AVERAGE_BULK:
                // counter (numerator) is a LONGLONG, while the
                // denominator is just a DWORD
                pllData            = (UNALIGNED LONGLONG *) pData;
                pValue->FirstValue = * pllData;
                PdhiGetPmBaseCounterOffset(pLogCounter, pPerfObject);
                if (pLogCounter->dwInstance > 0) {
                    pData               = PointerSeek(pCtrBlock, pLogCounter->dwInstance);
                    pdwData             = (DWORD *) pData;
                    pValue->SecondValue = * pdwData;
                }
                else {
                    pValue->SecondValue = 0;
                    bReturn             = FALSE;
                }
                break;
            //
            //  These counters are used as the part of another counter
            //  and as such should not be used, but in case they are
            //  they'll be handled here.
            //
            case PERF_SAMPLE_BASE:
            case PERF_AVERAGE_BASE:
            case PERF_COUNTER_MULTI_BASE:
            case PERF_RAW_BASE:
                pValue->FirstValue  = 0;
                pValue->SecondValue = 0;
                break;

            case PERF_ELAPSED_TIME:
                // this counter type needs the object perf data as well
                pValue->SecondValue = pPerfObject->PerfTime.QuadPart;
                pCounter->TimeBase  = pPerfObject->PerfFreq.QuadPart;
                pllData            = (UNALIGNED LONGLONG *) pData;
                pValue->FirstValue = *pllData;
                break;
            //
            //  These counters are not supported by this function (yet)
            //
            case PERF_COUNTER_TEXT:
            case PERF_COUNTER_NODATA:
            case PERF_COUNTER_HISTOGRAM_TYPE:
                pValue->FirstValue  = 0;
                pValue->SecondValue = 0;
                break;

            default:
                // an unidentified counter was returned so
                pValue->FirstValue  = 0;
                pValue->SecondValue = 0;
                bReturn             = FALSE;
                break;
            }
            pValue->CStatus = PDH_CSTATUS_VALID_DATA;
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetTimeRangeFromPerfmonLog(
    PPDHI_LOG       pLog,
    LPDWORD         pdwNumEntries,
    PPDH_TIME_INFO  pInfo,
    LPDWORD         pdwBufferSize
)
/*++
    the first entry in the buffer returned is the total time range covered
    in the file, if there are multiple time blocks in the log file, then
    subsequent entries will identify each segment in the file.
--*/
{
    PDH_STATUS       pdhStatus     = ERROR_SUCCESS;
    PPLAYBACKLOG     pPlaybackLog  = (PLAYBACKLOG *) pLog->pPerfmonInfo;
    PDH_TIME_INFO    LocalTimeInfo = {0,0,0}; 
    PPERF_DATA_BLOCK pPerfData;
    FILETIME         ftGMT;

    if (pPlaybackLog == NULL) {
        pdhStatus = PDH_INVALID_HANDLE;    // log is invalid
    }
    else {
        pPerfData = (PPERF_DATA_BLOCK) PointerSeek(
                pPlaybackLog->pHeader, pPlaybackLog->LogIndexTable[pPlaybackLog->dwFirstIndex]->lDataOffset);
        if (pPerfData != NULL) {
            SystemTimeToFileTime(& pPerfData->SystemTime, & ftGMT);
            FileTimeToLocalFileTime(& ftGMT, (FILETIME *) & LocalTimeInfo.StartTime);
        }
        else {
            pdhStatus = PDH_NO_DATA;
        }

        pPerfData = (PPERF_DATA_BLOCK) PointerSeek(
                pPlaybackLog->pHeader, pPlaybackLog->LogIndexTable[pPlaybackLog->dwLastIndex - 1]->lDataOffset);
        if (pPerfData != NULL) {
            SystemTimeToFileTime(& pPerfData->SystemTime, & ftGMT);
            FileTimeToLocalFileTime(& ftGMT, (FILETIME *) & LocalTimeInfo.EndTime);
        }
        else {
            pdhStatus = PDH_NO_DATA;
        }
    }
    if (pdhStatus == ERROR_SUCCESS) {
        LocalTimeInfo.SampleCount = pPlaybackLog->dwLastIndex - pPlaybackLog->dwFirstIndex;
        if (pInfo != NULL && * pdwBufferSize >= sizeof(PDH_TIME_INFO)) {
            * pdwNumEntries = 1;
            * pInfo         = LocalTimeInfo;
            * pdwBufferSize = sizeof(PDH_TIME_INFO);
            pdhStatus       = ERROR_SUCCESS;
        }
        else {
            * pdwBufferSize = sizeof(PDH_TIME_INFO);
            pdhStatus       = PDH_MORE_DATA;
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiReadRawPerfmonLogRecord(
    PPDHI_LOG             pLog,
    FILETIME            * ftRecord,
    PPDH_RAW_LOG_RECORD   pBuffer,
    LPDWORD               pdwBufferLength
)
{
    PDH_STATUS  pdhStatus = PDH_NOT_IMPLEMENTED;

    DBG_UNREFERENCED_PARAMETER(pLog);
    DBG_UNREFERENCED_PARAMETER(ftRecord);
    DBG_UNREFERENCED_PARAMETER(pBuffer);
    DBG_UNREFERENCED_PARAMETER(pdwBufferLength);

    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhlog\log_sql.h ===
/*++
Copyright (C) 1998-1999 Microsoft Corporation

Module Name:
    log_SQL.h

Abstract:
    <abstract>
--*/

#ifndef _LOG_SQL_H_
#define _LOG_SQL_H_

PDH_FUNCTION
PdhiOpenInputSQLLog(
    PPDHI_LOG   pLog
);

PDH_FUNCTION
PdhiOpenOutputSQLLog(
    PPDHI_LOG   pLog
);

PDH_FUNCTION
PdhiCloseSQLLog(
    PPDHI_LOG   pLog,
    DWORD       dwFlags
);

PDH_FUNCTION
PdhiReportSQLError(
    PPDHI_LOG      pLog,
    signed short   rc,
    void         * hstmt,
    DWORD          dwEventNumber,
    DWORD          dwLine
);

PDH_FUNCTION
PdhiGetSQLLogCounterInfo(
    PPDHI_LOG       pLog,
    PPDHI_COUNTER   pCounter
);

PDH_FUNCTION
PdhiWriteSQLLogHeader(
    PPDHI_LOG   pLog,
    LPCWSTR     szUserCaption
);

PDH_FUNCTION
PdhiWriteSQLLogRecord(
    PPDHI_LOG   pLog,
    SYSTEMTIME  *pTimeStamp,
    LPCWSTR     szUserString
);


PDH_FUNCTION
PdhiEnumMachinesFromSQLLog(
    PPDHI_LOG   pLog,
    LPVOID      pBuffer,
    LPDWORD     lpdwBufferSize,
    BOOL        bUnicodeDest
);


PDH_FUNCTION
PdhiEnumObjectsFromSQLLog(
    PPDHI_LOG   pLog,
    LPCWSTR     szMachineName,
    LPVOID      mszObjectList,
    LPDWORD     pcchBufferSize,
    DWORD       dwDetailLevel,
    BOOL        bUnicode
);


PDH_FUNCTION
PdhiEnumObjectItemsFromSQLLog(
    PPDHI_LOG          hDataSource,
    LPCWSTR            szMachineName,
    LPCWSTR            szObjectName,
    PDHI_COUNTER_TABLE CounterTable,
    DWORD              dwDetailLevel,
    DWORD              dwFlags
);

PDH_FUNCTION
PdhiGetMatchingSQLLogRecord(
    PPDHI_LOG   pLog,
    LONGLONG  * pStartTime,
    LPDWORD     pdwIndex
);

PDH_FUNCTION
PdhiGetCounterValueFromSQLLog(
    PPDHI_LOG        hLog,
    DWORD            dwIndex,
    PPDHI_COUNTER    pPath,
    PPDH_RAW_COUNTER pValue
);

PDH_FUNCTION
PdhiGetTimeRangeFromSQLLog(
    PPDHI_LOG       hLog,
    LPDWORD         pdwNumEntries,
    PPDH_TIME_INFO  pInfo,
    LPDWORD         dwBufferSize
);

PDH_FUNCTION
PdhiReadRawSQLLogRecord(
    PPDHI_LOG             pLog,
    FILETIME            * ftRecord,
    PPDH_RAW_LOG_RECORD   pBuffer,
    LPDWORD               pdwBufferLength
);

PDH_FUNCTION
PdhiListHeaderFromSQLLog(
    PPDHI_LOG    pLog,
    LPVOID       mszHeaderList,
    LPDWORD      pcchHeaderListSize,
    BOOL         bUnicode
);

#endif   // _LOG_SQL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhlog\log_pm.h ===
/*++
Copyright (C) 1996-1999 Microsoft Corporation

Module Name:
    log_pm.h

Abstract:
    <abstract>
--*/

#ifndef _LOG_PM_H_
#define _LOG_PM_H_

#include <windows.h>
#include <winperf.h>
#include "strings.h"

// Filetimes are in 100NS units
#define FILETIMES_PER_SECOND     10000000

typedef PERF_DATA_BLOCK * PPERFDATA;

//BEGIN definitions included from PERFMON\sizes.h
#define MAX_SYSTEM_NAME_LENGTH  128
//END definitions included from PERFMON\sizes.h

#define LogFileIndexData          0x01
#define LogFileIndexBookmark      0x02
#define LogFileIndexCounterName  0x010

#define PlayingBackLog()           (PlaybackLog.iStatus == iPMStatusPlaying)
#define IsDataIndex(pIndex)        (pIndex->uFlags & LogFileIndexData)
#define IsBookmarkIndex(pIndex)    (pIndex->uFlags & LogFileIndexBookmark)
#define IsCounterNameIndex(pIndex) (pIndex->uFlags & LogFileIndexCounterName)

//BEGIN definitions included from PERFMON\typedefs.h
typedef struct _COUNTERTEXT {
    struct  _COUNTERTEXT * pNextTable;
    DWORD                  dwLangId;
    DWORD                  dwLastId;
    DWORD                  dwCounterSize;
    DWORD                  dwHelpSize;
    LPWSTR                 * TextString;
    LPWSTR                 HelpTextString;
} COUNTERTEXT, * PCOUNTERTEXT;

typedef struct PERFSYSTEMSTRUCT {
    struct  PERFSYSTEMSTRUCT * pSystemNext;
    WCHAR                      sysName[MAX_SYSTEM_NAME_LENGTH+1];
    HKEY                       sysDataKey;
    COUNTERTEXT                CounterInfo;
    DWORD                      FailureTime;
    LPWSTR                     lpszValue;
    BOOL                       bSystemNoLongerNeeded;
    BOOL                       bSystemCounterNameSaved;
    // the following used by perf data thread
    DWORD                      dwThreadID;
    HANDLE                     hThread;
    DWORD                      StateData;
    HANDLE                     hStateDataMutex;
    HANDLE                     hPerfDataEvent;
    PPERFDATA                  pSystemPerfData;
    // mainly used by Alert to report system up/down   
    DWORD                      dwSystemState;
    // system version
    DWORD                      SysVersion;
} PERFSYSTEM, * PPERFSYSTEM, ** PPPERFSYSTEM;

//======================================//
// Log File Data Types                  //
//======================================//
#define LogFileSignatureLen      6
#define LogFileBlockMaxIndexes   100

typedef struct LOGHEADERSTRUCT { // LOGHEADER
    WCHAR  szSignature[LogFileSignatureLen];
    int    iLength;
    WORD   wVersion;
    WORD   wRevision;
    long   lBaseCounterNameOffset;
} LOGHEADER, * PLOGHEADER;

typedef struct LOGINDEXSTRUCT { // LOGINDEX
    UINT       uFlags;
    SYSTEMTIME SystemTime;
    long       lDataOffset;
    int        iSystemsLogged;
} LOGINDEX, * PLOGINDEX;

#define LogIndexSignatureLen  7
#define LogIndexSignature     L"Index "
#define LogIndexSignature1    "Perfmon Index"

typedef struct LOGFILEINDEXBLOCKSTRUCT {
    WCHAR    szSignature[LogIndexSignatureLen];
    int      iNumIndexes ;
    LOGINDEX aIndexes[LogFileBlockMaxIndexes];
    DWORD    lNextBlockOffset ;
} LOGINDEXBLOCK, * PLOGINDEXBLOCK;

typedef struct LOGPOSITIONSTRUCT {
    PLOGINDEXBLOCK pIndexBlock;
    int            iIndex;
    int            iPosition;
} LOGPOSITION, * PLOGPOSITION;

//======================================//
// Bookmark Data Type                   //
//======================================//
#define BookmarkCommentLen    256

typedef struct BOOKMARKSTRUCT {
    struct BOOKMARKSTRUCT * pBookmarkNext;
    SYSTEMTIME              SystemTime;
    WCHAR                   szComment[BookmarkCommentLen];
    int                     iTic;
} BOOKMARK, * PBOOKMARK, ** PPBOOKMARK;

typedef struct _LOGFILECOUNTERNAME {
    WCHAR  szComputer[MAX_SYSTEM_NAME_LENGTH];
    DWORD  dwLastCounterId;
    DWORD  dwLangId;
    long   lBaseCounterNameOffset;
    long   lCurrentCounterNameOffset;
    long   lMatchLength;
    long   lUnmatchCounterNames;
} LOGFILECOUNTERNAME, * PLOGFILECOUNTERNAME, ** PPLOGFILECOUNTERNAME;

typedef struct COUNTERNAMESTRUCT {
    struct COUNTERNAMESTRUCT * pCounterNameNext;
    LOGFILECOUNTERNAME         CounterName;
    LPWSTR                     pRemainNames;
} LOGCOUNTERNAME, * PLOGCOUNTERNAME;

typedef struct _PDHI_PM_STRING PDHI_PM_STRING, * PPDHI_PM_STRING;
struct _PDHI_PM_STRING {
    PPDHI_PM_STRING left;
    PPDHI_PM_STRING right;
    LPWSTR          szString;
    DWORD           dwIndex;
    BOOL            bIsRed;
};

typedef struct _PMLOG_COUNTERNAMES PMLOG_COUNTERNAMES, * PPMLOG_COUNTERNAMES;
struct _PMLOG_COUNTERNAMES {
    PPMLOG_COUNTERNAMES   pNext;
    LPWSTR                szSystemName;
    LPWSTR              * szNameTable;
    PPDHI_PM_STRING       StringTree;
    DWORD                 dwLangId;
    DWORD                 dwLastIndex;
};

typedef struct PLAYBACKLOGSTRUCT {
    LONGLONG            llFileSize;
    LPWSTR              szFilePath;
    PLOGHEADER          pHeader;
    PPMLOG_COUNTERNAMES pFirstCounterNameTables;
    PPDHI_LOG_MACHINE   MachineList;
    PLOGINDEX         * LogIndexTable;
    DWORD               dwFirstIndex;
    DWORD               dwLastIndex;
    DWORD               dwCurrentIndex;

    int                 iTotalTics;
    int                 iSelectedTics;
    LOGPOSITION         BeginIndexPos;
    LOGPOSITION         EndIndexPos;
    LOGPOSITION         StartIndexPos;
    LOGPOSITION         StopIndexPos;
    LOGPOSITION         LastIndexPos; // pos of last index read
    PBOOKMARK           pBookmarkFirst;
    LPWSTR              pBaseCounterNames;
    long                lBaseCounterNameSize;
    long                lBaseCounterNameOffset;
    PLOGCOUNTERNAME     pLogCounterNameFirst;
} PLAYBACKLOG, * PPLAYBACKLOG;

PDH_FUNCTION
PdhiOpenInputPerfmonLog(
    PPDHI_LOG pLog
);

PDH_FUNCTION
PdhiClosePerfmonLog(
    PPDHI_LOG pLog,
    DWORD     dwFlags
);

PDH_FUNCTION
PdhiGetPerfmonLogCounterInfo(
    PPDHI_LOG     pLog,
    PPDHI_COUNTER pCounter
);

PDH_FUNCTION
PdhiEnumMachinesFromPerfmonLog(
    PPDHI_LOG pLog,
    LPVOID    pBuffer,
    LPDWORD   lpdwBufferSize,
    BOOL      bUnicodeDest
);

PDH_FUNCTION
PdhiEnumObjectsFromPerfmonLog(
    PPDHI_LOG pLog,
    LPCWSTR   szMachineName,
    LPVOID    mszObjectList,
    LPDWORD   pcchBufferSize,
    DWORD     dwDetailLevel,
    BOOL      bUnicode
);

PDH_FUNCTION
PdhiEnumObjectItemsFromPerfmonLog(
    PPDHI_LOG          hDataSource,
    LPCWSTR            szMachineName,
    LPCWSTR            szObjectName,
    PDHI_COUNTER_TABLE CounterTable,
    DWORD              dwDetailLevel,
    DWORD              dwFlags
);

PDH_FUNCTION
PdhiGetMatchingPerfmonLogRecord(
    PPDHI_LOG   pLog,
    LONGLONG  * pStartTime,
    LPDWORD     pdwIndex
);

PDH_FUNCTION
PdhiGetCounterValueFromPerfmonLog(
    PPDHI_LOG        hLog,
    DWORD            dwIndex,
    PPDHI_COUNTER    pCounter,
    PPDH_RAW_COUNTER pValue
);

PDH_FUNCTION
PdhiGetTimeRangeFromPerfmonLog(
    PPDHI_LOG       hLog,
    LPDWORD         pdwNumEntries,
    PPDH_TIME_INFO  pInfo,
    LPDWORD         dwBufferSize
);

PDH_FUNCTION
PdhiReadRawPerfmonLogRecord(
    PPDHI_LOG             pLog,
    FILETIME            * ftRecord,
    PPDH_RAW_LOG_RECORD   pBuffer,
    LPDWORD               pdwBufferLength
);

#endif   // _LOG_PM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhlog\log_bin.h ===
/*++
Copyright (C) 1996-1999 Microsoft Corporation

Module Name:
    log_bin.h

Abstract:
    <abstract>
--*/

#ifndef _LOG_BIN_H_
#define _LOG_BIN_H_

// define record locations in the file
#define BINLOG_TYPE_ID_RECORD    ((DWORD) 1)
#define BINLOG_HEADER_RECORD     ((DWORD) 2)
#define BINLOG_FIRST_DATA_RECORD ((DWORD) 3)

// Record type definition
// low WORD of the type header field is "BL" to help re-sync records
// that may have been corrupted
#define BINLOG_START_WORD           ((WORD) 0x4C42)
#define BINLOG_TYPE_HEADER          ((DWORD) (0x00010000 | (DWORD) (BINLOG_START_WORD)))
#define BINLOG_TYPE_CATALOG         ((DWORD) (0x00020000 | (DWORD) (BINLOG_START_WORD)))
#define BINLOG_TYPE_CATALOG_LIST    ((DWORD) (0x01020000 | (DWORD) (BINLOG_START_WORD)))
#define BINLOG_TYPE_CATALOG_HEAD    ((DWORD) (0x02020000 | (DWORD) (BINLOG_START_WORD)))
#define BINLOG_TYPE_CATALOG_ITEM    ((DWORD) (0x03020000 | (DWORD) (BINLOG_START_WORD)))
#define BINLOG_TYPE_DATA            ((DWORD) (0x00030000 | (DWORD) (BINLOG_START_WORD)))
#define BINLOG_TYPE_DATA_SINGLE     ((DWORD) (0x01030000 | (DWORD) (BINLOG_START_WORD)))
#define BINLOG_TYPE_DATA_MULTI      ((DWORD) (0x02030000 | (DWORD) (BINLOG_START_WORD)))
#define BINLOG_TYPE_DATA_PSEUDO     ((DWORD) (0x03030000 | (DWORD) (BINLOG_START_WORD)))
#define BINLOG_TYPE_DATA_OBJECT     ((DWORD) (0x04030000 | (DWORD) (BINLOG_START_WORD)))
#define BINLOG_TYPE_DATA_LOC_OBJECT ((DWORD) (0x05030000 | (DWORD) (BINLOG_START_WORD)))
#define BINLOG_VERSION              ((DWORD) (0x000005ff))  // debug value for now

//
//  this is the field at the beginning of each record in the log file
//  after the text log file type record
//
typedef struct _PDHI_BINARY_LOG_RECORD_HEADER {
    DWORD dwType;
    DWORD dwLength;
} PDHI_BINARY_LOG_RECORD_HEADER, * PPDHI_BINARY_LOG_RECORD_HEADER;

//
// the first data record after the log file type record is
// an information record followed by the list of counters contained in this
// log file. the record length is the size of the info header record and
// all the counter info blocks in bytes.
// note that this record can occur later in the log file if the query
// is changed or the log file is appended.
//
typedef struct _PDHI_BINARY_LOG_INFO {
    LONGLONG    FileLength;         // file space allocated (optional)
    DWORD       dwLogVersion;       // version stamp
    DWORD       dwFlags;            // option flags
    LONGLONG    StartTime;
    LONGLONG    EndTime;
    LONGLONG    CatalogOffset;      // offset in file to wild card catalog
    LONGLONG    CatalogChecksum;    // checksum of catalog header
    LONGLONG    CatalogDate;        // date/time catalog was updated
    LONGLONG    FirstRecordOffset;  // pointer to first record [to read] in log
    LONGLONG    LastRecordOffset;   // pointer to last record [to read] in log
    LONGLONG    NextRecordOffset;   // pointer to where next one goes
    LONGLONG    WrapOffset;         // pointer to last byte used in file
    LONGLONG    LastUpdateTime;     // date/time last record was written
    LONGLONG    FirstDataRecordOffset; // location of first data record in file
    // makes the info struct 256 bytes
    // and leaves room for future information
    DWORD       dwReserved[38];
} PDHI_BINARY_LOG_INFO, * PPDHI_BINARY_LOG_INFO;

typedef struct _PDHI_BINARY_LOG_HEADER_RECORD {
    PDHI_BINARY_LOG_RECORD_HEADER   RecHeader;
    PDHI_BINARY_LOG_INFO            Info;
} PDHI_BINARY_LOG_HEADER_RECORD, * PPDHI_BINARY_LOG_HEADER_RECORD;

typedef struct _PDHI_LOG_COUNTER_PATH {
    // this value is in bytes used by the entire structure & buffers
    DWORD     dwLength;           // total structure Length (including strings)
    DWORD     dwFlags;            // flags that describe the counter
    DWORD     dwUserData;         // user data from PDH Counter
    DWORD     dwCounterType;      // perflib counter type value
    LONGLONG  llTimeBase;         // time base (freq) used by this counter
    LONG      lDefaultScale;      // default display scaling factor
    // the following values are in BYTES from the first byte in
    // the Buffer array.
    LONG      lMachineNameOffset; // offset to start of machine name
    LONG      lObjectNameOffset;  // offset to start of object name
    LONG      lInstanceOffset;    // offset to start of instance name
    LONG      lParentOffset;      // offset to start of parent instance name
    DWORD     dwIndex;            // index value for duplicate instances
    LONG      lCounterOffset;     // offset to start of counter name
    WCHAR     Buffer[1];          // start of string storage
} PDHI_LOG_COUNTER_PATH, * PPDHI_LOG_COUNTER_PATH;

typedef struct _PDHI_LOG_CAT_ENTRY {
    DWORD dwEntrySize;               // size of this machine\object entry
    DWORD dwStringSize;              // size of MSZ containing instance strings
    DWORD dwMachineObjNameOffset;    // offset from the base of this struct to the machine name
    DWORD dwInstanceStringOffset;    // offset to the first object entry in the list
} PDHI_LOG_CAT_ENTRY, * PPDHI_LOG_CAT_ENTRY;

PDH_FUNCTION
PdhiOpenInputBinaryLog(
    PPDHI_LOG pLog
);

#if 0
PDH_FUNCTION
PdhiOpenOutputBinaryLog(
    PPDHI_LOG pLog
);

PDH_FUNCTION
PdhiOpenUpdateBinaryLog(
    PPDHI_LOG pLog
);

PDH_FUNCTION
PdhiUpdateBinaryLogFileCatalog(
    PPDHI_LOG pLog
);

PDH_FUNCTION
PdhiWriteBinaryLogHeader(
    PPDHI_LOG pLog,
    LPCWSTR   szUserCaption
);

PDH_FUNCTION
PdhiWriteBinaryLogRecord(
    PPDHI_LOG    pLog,
    SYSTEMTIME * stTimeStamp,
    LPCWSTR      szUserString
);
#endif

PDH_FUNCTION
PdhiCloseBinaryLog(
    PPDHI_LOG pLog,
    DWORD     dwFlags
);

PDH_FUNCTION
PdhiGetBinaryLogCounterInfo(
    PPDHI_LOG     pLog,
    PPDHI_COUNTER pCounter
);

PDH_FUNCTION
PdhiEnumMachinesFromBinaryLog(
    PPDHI_LOG pLog,
    LPVOID    pBuffer,
    LPDWORD   lpdwBufferSize,
    BOOL      bUnicodeDest
);

PDH_FUNCTION
PdhiEnumObjectsFromBinaryLog(
    PPDHI_LOG pLog,
    LPCWSTR   szMachineName,
    LPVOID    mszObjectList,
    LPDWORD   pcchBufferSize,
    DWORD     dwDetailLevel,
    BOOL      bUnicode
);

PDH_FUNCTION
PdhiEnumObjectItemsFromBinaryLog(
    PPDHI_LOG          hDataSource,
    LPCWSTR            szMachineName,
    LPCWSTR            szObjectName,
    PDHI_COUNTER_TABLE CounterTable,
    DWORD              dwDetailLevel,
    DWORD              dwFlags
);

PDH_FUNCTION
PdhiGetMatchingBinaryLogRecord(
    PPDHI_LOG   pLog,
    LONGLONG  * pStartTime,
    LPDWORD     pdwIndex
);

PDH_FUNCTION
PdhiGetCounterValueFromBinaryLog(
    PPDHI_LOG     hLog,
    DWORD         dwIndex,
    PPDHI_COUNTER pCounter
);

PDH_FUNCTION
PdhiGetTimeRangeFromBinaryLog(
    PPDHI_LOG       hLog,
    LPDWORD         pdwNumEntries,
    PPDH_TIME_INFO  pInfo,
    LPDWORD         dwBufferSize
);

PDH_FUNCTION
PdhiReadRawBinaryLogRecord(
    PPDHI_LOG             pLog,
    FILETIME            * ftRecord,
    PPDH_RAW_LOG_RECORD   pBuffer,
    LPDWORD               pdwBufferLength
);


PDH_FUNCTION
PdhiListHeaderFromBinaryLog(
    PPDHI_LOG pLogFile,
    LPVOID    pBufferArg,
    LPDWORD   pcchBufferSize,
    BOOL      bUnicode
);

PDH_FUNCTION
PdhiGetCounterArrayFromBinaryLog(
    PPDHI_LOG                      pLog,
    DWORD                          dwIndex,
    PPDHI_COUNTER                  pCounter,
    PPDHI_RAW_COUNTER_ITEM_BLOCK * ppValue
);

PPDHI_BINARY_LOG_RECORD_HEADER
PdhiGetSubRecord(
    PPDHI_BINARY_LOG_RECORD_HEADER  pRecord,
    DWORD                           dwRecordId
);

#endif   // _LOG_BIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhlog\log_wmi.c ===
/*++
Copyright (C) 1996-1999 Microsoft Corporation

Module Name:
    log_wmi.c

Abstract:
    <abstract>
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <strsafe.h>
#include <pdh.h>
#include "pdhidef.h"
#include "perfdata.h"
#include "log_bin.h"
#include "log_wmi.h"
#include "strings.h"
#include "pdhmsg.h"
#pragma warning ( disable : 4201 )
#include <initguid.h>
#include <wmistr.h>
#include <wmiguid.h>
#include <wmium.h>
#include <ntwmi.h>
#pragma warning ( default : 4201 )

GUID PdhTransactionGuid = { // 933f3bb3-943e-490d-9ced-3cbb14c14479
    0x933f3bb3, 0x943e, 0x490d, 0x9c, 0xed, 0x3c, 0xbb, 0x14, 0xc1, 0x44, 0x79
};

PDHI_BINARY_LOG_RECORD_HEADER PdhNullCounterHeader = {
        BINLOG_TYPE_DATA_PSEUDO, 48
};
PDH_RAW_COUNTER PdhNullCounter = {
        0,          // CStatus
        { 0, 0 },   // TimeStamp
        0,          // FirstValue
        0,          // SecondValue
        0           // MultiCount
};

#define PDH_MAX_LOGFILES               32
#define PDH_MAX_PATH                 1024
#define PDH_BLOCK_BUFFER_SIZE        8000
#define PDH_WMI_BUFFER_SIZE          64
#define PDH_WMI_BUFFER_SIZE_BYTE     64 * 1024

#define PDH_LOG_HEADER_EVENT         0x20
#define PDH_LOG_DATA_BLOCK_EVENT     0x22
#define PDH_LOG_CATALOG_LIST_EVENT   0x23
#define PDH_LOG_COUNTER_STRING_EVENT 0x24
#define PDH_EVENT_VERSION              60
#define PDH_WMI_MAX_BUFFERS           512
#define PDH_WMI_DEFAULT_BUFFERS        32
#define PDH_WMI_BUFFER_INCREMENT       16

#define PDH_RESOURCE_NAME L"MofResource"

#define TIME_DELTA                 100000

TRACEHANDLE PdhTraceRegistrationHandle = (TRACEHANDLE) 0;
LPCWSTR     gszTotal                   = L"_Total";

// For PDH WMI event trace logfile output
//
typedef struct _PDH_WMI_LOG_INFO {
    DWORD       dwLogVersion;       // version stamp
    DWORD       dwFlags;            // option flags
} PDH_WMI_LOG_INFO, * PPDH_WMI_LOG_INFO;

typedef struct _PDH_EVENT_TRACE_PROPERTIES {
    EVENT_TRACE_PROPERTIES LoggerInfo;
    WCHAR                  LoggerName[PDH_MAX_PATH];
    WCHAR                  LogFileName[PDH_MAX_PATH];
    GUID                   LogFileGuid;
    LONGLONG               TimeStamp;
    LPWSTR                 MachineList;
    DWORD                  MachineListSize;
    BOOLEAN                bHeaderEvent;
    BOOLEAN                bDisable;
} PDH_EVENT_TRACE_PROPERTIES, * PPDH_EVENT_TRACE_PROPERTIES;

PPDHI_LOG lpPdhBlgLog[PDH_MAX_LOGFILES];
DWORD     dwPdhBlgLog = 0;

typedef struct _PDH_WMI_EVENT_TRACE {
    EVENT_TRACE_HEADER EventHeader;
    MOF_FIELD          MofFields[4];
} PDH_WMI_EVENT_TRACE, * PPDH_WMI_EVENT_TRACE;

// For PDH WMI event trace logfile input
//
typedef enum _PDH_PROCESS_TRACE_STATE {
    PdhProcessTraceStart,
    PdhProcessTraceFirstPath,
    PdhProcessTraceNormal,
    PdhProcessTraceRewind,
    PdhProcessTraceComplete,
    PdhProcessTraceEnd,
    PdhProcessTraceExit
} PDH_PROCESS_TRACE_STATE;

typedef struct _PDH_WMI_PERF_MACHINE {
    LIST_ENTRY   Entry;
    LIST_ENTRY   LogObjectList;
    LPWSTR       pszBuffer;
    DWORD        dwLastId;
    DWORD        dwBufSize;
    LPWSTR     * ptrStrAry;
} PDH_WMI_PERF_MACHINE, * PPDH_WMI_PERF_MACHINE;

typedef struct _PDH_WMI_PERF_OBJECT {
    LIST_ENTRY  Entry;
    DWORD       dwObjectId;
    LPWSTR      szObjectName;
    PVOID       ptrBuffer;
} PDH_WMI_PERF_OBJECT, * PPDH_WMI_PERF_OBJECT;

typedef struct _PDH_COUNTER_PATH {
    LIST_ENTRY  Entry;
    ULONGLONG   TimeStamp;
    PVOID       CounterPathBuffer;
    ULONG       CounterPathSize;
    ULONG       CounterCount;
} PDH_COUNTER_PATH, * PPDH_COUNTER_PATH;

typedef struct _PDH_WMI_LOGFILE_INFO {
    GUID              LogFileGuid;
    LIST_ENTRY        CounterPathList;
    LIST_ENTRY        PerfMachineList;
    ULONGLONG         TimeStart;
    ULONGLONG         TimeEnd;
    ULONGLONG         TimePrev;
    PVOID             DataBlock;
    PPDHI_LOG_MACHINE MachineList;
    ULONG             ValidEntries;
    ULONG             DataBlockSize;
    ULONG             DataBlockAlloc;
    ULONG             ulNumDataBlocks;
    ULONG             ulDataBlocksCopied;
    ULONG             ulCounters;
} PDH_WMI_LOGFILE_INFO, * PPDH_WMI_LOGFILE_INFO;

typedef struct _PDH_LOGGER_CONTEXT {
    PDH_WMI_LOGFILE_INFO    LogInfo[PDH_MAX_LOGFILES];
    TRACEHANDLE             LogFileHandle[PDH_MAX_LOGFILES];
    LPWSTR                  LogFileName[PDH_MAX_LOGFILES];
    HANDLE                  hThreadWork;
    HANDLE                  hSyncPDH;
    HANDLE                  hSyncWMI;
    PVOID                   CounterPathBuffer;
    PVOID                   tmpBuffer;
    PDH_PROCESS_TRACE_STATE LoggerState;
    ULONG                   LogFileCount;
    ULONG                   LoggerCount;
    ULONG                   RefCount;
    DWORD                   dwThread;
    DWORD                   dwBuffers;
    DWORD                   dwEvents;
    BOOLEAN                 bCounterPathChanged;
    BOOLEAN                 bFirstDataBlockRead;
    BOOLEAN                 bDataBlockProcessed;
    BOOLEAN                 bFirstRun;
    BOOLEAN                 bBulkProcess;
} PDH_LOGGER_CONTEXT, * PPDH_LOGGER_CONTEXT;

PPDH_LOGGER_CONTEXT ContextTable[PDH_MAX_LOGFILES];
DWORD               ContextCount = 0;
HANDLE              hPdhContextMutex;

typedef struct _PDH_DATA_BLOCK_TRANSFER {
    ULONGLONG  CurrentTime;
    PVOID      pRecord;
    DWORD      dwCurrentSize;
    PDH_STATUS Status;
} PDH_DATA_BLOCK_TRANSFER, * PPDH_DATA_BLOCK_TRANSFER;

PDH_DATA_BLOCK_TRANSFER DataBlockInfo = { 0, NULL, 0, ERROR_SUCCESS };

ULONG
PdhTraceNotificationCallback(
    PWNODE_HEADER pWnode,
    UINT_PTR      LogFileIndex
)
{
    LPGUID lpErrorGuid;
    DWORD  i;
    ULONG  lStatus = ERROR_SUCCESS;

    if (pWnode == NULL) {
        lStatus = ERROR_INVALID_PARAMETER;
    }
    else {
        __try {
            lpErrorGuid = & pWnode->Guid;
            i           = pWnode->BufferSize;
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            lStatus = ERROR_INVALID_PARAMETER;
        }
        if (lStatus == ERROR_SUCCESS) {
            if ((IsEqualGUID(lpErrorGuid, & TraceErrorGuid)) && (i >= (sizeof(WNODE_HEADER) + sizeof(ULONG)))) {
                ULONGLONG LoggerId = pWnode->HistoricalContext;
                ULONG     ulStatus = * ((ULONG *) (((PUCHAR) pWnode) + sizeof(WNODE_HEADER)));

                if (ulStatus == STATUS_LOG_FILE_FULL) {
                    if (WAIT_FOR_AND_LOCK_MUTEX(hPdhContextMutex) == ERROR_SUCCESS) {
                        PPDH_EVENT_TRACE_PROPERTIES LoggerInfo;

                        for (i = 0; i < dwPdhBlgLog; i ++) {
                            LoggerInfo = (PPDH_EVENT_TRACE_PROPERTIES) lpPdhBlgLog[i]->lpMappedFileBase;
                            if (LoggerInfo->LoggerInfo.Wnode.HistoricalContext == LoggerId) {
                                LoggerInfo->bDisable = TRUE;
                            }
                        }
                        RELEASE_MUTEX(hPdhContextMutex);
                    }
                }
            }
        }
    }
    return lStatus;
}

void
GuidToString(
    LPWSTR s,
    DWORD  dwSize,
    LPGUID piid
)
{
    StringCchPrintfW(s, dwSize, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
             piid->Data1, piid->Data2, piid->Data3,
             piid->Data4[0], piid->Data4[1], piid->Data4[2], piid->Data4[3],
             piid->Data4[4], piid->Data4[5], piid->Data4[6], piid->Data4[7]);
}

PPDH_LOGGER_CONTEXT
PdhWmiGetCurrentContext(
    DWORD dwLine
)
{
    PPDH_LOGGER_CONTEXT CurrentContext = NULL;
    DWORD               dwThread       = GetCurrentThreadId();
    DWORD               i;

    if (WAIT_FOR_AND_LOCK_MUTEX(hPdhContextMutex) == ERROR_SUCCESS) {
        for (i = 0; i < ContextCount; i ++) {
            if (ContextTable[i]->dwThread == dwThread) {
                CurrentContext = ContextTable[i];
                break;
            }
        }
        RELEASE_MUTEX(hPdhContextMutex);
    }
    return CurrentContext;
}

DWORD
PdhWmiGetLoggerContext(
    DWORD               dwLine,
    PPDH_LOGGER_CONTEXT pLoggerContext
)
{
    DWORD i = ContextCount;

    if (pLoggerContext != NULL) {
        if (WAIT_FOR_AND_LOCK_MUTEX(hPdhContextMutex) == ERROR_SUCCESS) {
            for (i = 0; i < ContextCount; i ++) {
                if (ContextTable[i] == pLoggerContext) {
                    break;
                }
            }
            RELEASE_MUTEX(hPdhContextMutex);
        }
    }
    return i;
}

#define GetCurrentContext() PdhWmiGetCurrentContext(__LINE__)
#define GetLoggerContext(X) PdhWmiGetLoggerContext(__LINE__,X)

PDH_FUNCTION
PdhWmiTraceEvent(
    PPDHI_LOG pLog,
    ULONG     PdhEventType,
    ULONGLONG TimeStamp,
    ULONG     lenMofData,
    PVOID     ptrMofData
);

PDH_FUNCTION
PdhiBuildPerfCounterList(
    PPDHI_LOG  pLog,
    PPDH_EVENT_TRACE_PROPERTIES LoggerInfo,
    PPDHI_COUNTER               pCounter
)
{
    PDH_STATUS      Status    = ERROR_SUCCESS;
    PPERF_MACHINE   pMachine  = pCounter->pQMachine->pMachine;
    LPWSTR        * pString   = pMachine->szPerfStrings;
    BYTE          * pType     = pMachine->typePerfStrings;
    DWORD           dwLastId  = pMachine->dwLastPerfString;
    DWORD           i;
    DWORD           dwBufSize = 0;
    LPWSTR          pszBuffer = NULL;
    LPWSTR          pszCurrent;
    BOOLEAN         bNewEvent = TRUE;

    if (LoggerInfo->MachineList != NULL) {
        pszCurrent = LoggerInfo->MachineList;
        while (* pszCurrent != L'\0') {
            if (lstrcmpiW(pszCurrent, pMachine->szName) == 0) {
                // Machine Perf Counter List already there, bail out.
                //
                goto Cleanup;
            }
            pszCurrent += (lstrlenW(pszCurrent) + 1);
        }
    }

    if (LoggerInfo->MachineList != NULL) {
        LPWSTR pszTemp          = LoggerInfo->MachineList;
        dwBufSize               = lstrlenW(pMachine->szName) + 1;
        LoggerInfo->MachineList = G_REALLOC(pszTemp, sizeof(WCHAR) * (LoggerInfo->MachineListSize + dwBufSize));
        if (LoggerInfo->MachineList != NULL) {
            pszCurrent                   = LoggerInfo->MachineList + (LoggerInfo->MachineListSize - 1);
            LoggerInfo->MachineListSize += dwBufSize;
        }
        else {
            G_FREE(pszTemp);
        }
    }
    else {
        dwBufSize                   = lstrlenW(pMachine->szName) + 2;
        LoggerInfo->MachineListSize = dwBufSize;
        LoggerInfo->MachineList = G_ALLOC(sizeof(WCHAR) * LoggerInfo->MachineListSize);
        if (LoggerInfo->MachineList != NULL) {
            pszCurrent = LoggerInfo->MachineList;
        }
    }
    if (LoggerInfo->MachineList == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    StringCchCopyW(pszCurrent, dwBufSize, pMachine->szName);
    dwBufSize = sizeof(WCHAR) * (lstrlenW(pMachine->szName) + 1);
    pszBuffer = (LPWSTR) G_ALLOC(PDH_BLOCK_BUFFER_SIZE);
    if (pszBuffer == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    __try {
        WCHAR szIndex[10];
        DWORD dwNewSize = 0;

        for (i = 0; i < dwLastId; i ++) {

            if (pString[i] == NULL || pType[i] != STR_COUNTER) continue;
            ZeroMemory(szIndex, sizeof(WCHAR) * 10);
            _ltow(i, szIndex, 10);
            dwNewSize = sizeof(WCHAR) * (lstrlenW(szIndex) + 1 + lstrlenW(pString[i]) + 1);
            if (dwBufSize + dwNewSize >= PDH_BLOCK_BUFFER_SIZE) {
                Status = PdhWmiTraceEvent(pLog,
                                          PDH_LOG_COUNTER_STRING_EVENT,
                                          LoggerInfo->TimeStamp - 1,
                                          dwBufSize,
                                          pszBuffer);
                bNewEvent = TRUE;
            }
            if (bNewEvent) {
                ZeroMemory(pszBuffer, PDH_BLOCK_BUFFER_SIZE);
                StringCbCopyW(pszBuffer, PDH_BLOCK_BUFFER_SIZE, pMachine->szName);
                pszCurrent  = pszBuffer + (lstrlenW(pszBuffer) + 1);
                dwBufSize   = sizeof(WCHAR) * (lstrlenW(pMachine->szName) + 1);
                bNewEvent   = FALSE;
            }
            StringCbCopyW(pszCurrent, PDH_BLOCK_BUFFER_SIZE - dwBufSize, szIndex);
            pszCurrent += (lstrlenW(pszCurrent) + 1);
            dwBufSize  += sizeof(WCHAR) * (lstrlenW(szIndex) + 1);
            StringCchCopyW(pszCurrent, PDH_BLOCK_BUFFER_SIZE - dwBufSize, pString[i]);
            pszCurrent += (lstrlenW(pszCurrent) + 1);
            dwBufSize  += sizeof(WCHAR) * (lstrlenW(pString[i]) + 1);
        }
        Status = PdhWmiTraceEvent(pLog, PDH_LOG_COUNTER_STRING_EVENT, LoggerInfo->TimeStamp - 1, dwBufSize, pszBuffer);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

Cleanup:
    G_FREE(pszBuffer);
    return Status;
}

PDH_FUNCTION
PdhiBuildLogHeaderBlock(
    PPDHI_LOG   pLog,
    PPDH_EVENT_TRACE_PROPERTIES LoggerInfo
)
{
    PDH_STATUS             Status       = ERROR_SUCCESS;
    PVOID                  ptrOutBuffer = NULL;
    PVOID                  ptrTemp;
    PPDH_WMI_LOG_INFO      pLogInfo     = NULL;
    DWORD                  SizeAlloc    = sizeof(PDH_WMI_LOG_INFO);
    DWORD                  NewSizeAlloc;
    PPDHI_COUNTER          pThisCounter;
    PPDHI_COUNTER          pThisCounterHead;
    DWORD                  dwPathBufSize;
    PPDHI_LOG_COUNTER_PATH pLogCounter;
    LONG                   lBufOffset;
    PWCHAR                 pBufferBase;

    ptrOutBuffer = G_ALLOC(sizeof(PDH_WMI_LOG_INFO));
    if (ptrOutBuffer == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }
    pLogInfo               = (PPDH_WMI_LOG_INFO) ptrOutBuffer;
    pLogInfo->dwLogVersion = WMILOG_VERSION;
    pLogInfo->dwFlags      = pLog->dwLogFormat;

    pThisCounter = pThisCounterHead = (pLog->pQuery) ? (pLog->pQuery->pCounterListHead) : (NULL);
    if (pThisCounter != NULL) {
        do {
            dwPathBufSize = sizeof(PDHI_LOG_COUNTER_PATH) + sizeof(DWORD);
            if (pThisCounter->pCounterPath->szMachineName != NULL) {
                dwPathBufSize += sizeof(WCHAR) * (1 + lstrlenW(pThisCounter->pCounterPath->szMachineName));
            }
            if (pThisCounter->pCounterPath->szObjectName != NULL) {
                dwPathBufSize += sizeof(WCHAR) * (1 + lstrlenW(pThisCounter->pCounterPath->szObjectName));
            }
            if (pThisCounter->dwFlags & PDHIC_COUNTER_OBJECT) {
                Status = PdhiBuildPerfCounterList(pLog, LoggerInfo, pThisCounter);
                if (Status != ERROR_SUCCESS) {
                    goto Cleanup;
                }
            }
            if (pThisCounter->pCounterPath->szInstanceName != NULL) {
                dwPathBufSize += sizeof(WCHAR) * (1 + lstrlenW(pThisCounter->pCounterPath->szInstanceName));
            }
            if (pThisCounter->pCounterPath->szParentName != NULL) {
                dwPathBufSize += sizeof(WCHAR) * (1 + lstrlenW(pThisCounter->pCounterPath->szParentName));
            }
            if (pThisCounter->pCounterPath->szCounterName != NULL) {
                dwPathBufSize += sizeof(WCHAR) * (1 + lstrlenW(pThisCounter->pCounterPath->szCounterName));
            }
            dwPathBufSize = QWORD_MULTIPLE(dwPathBufSize);

            NewSizeAlloc  = SizeAlloc + dwPathBufSize;
            ptrTemp       = ptrOutBuffer;
            ptrOutBuffer  = G_REALLOC(ptrTemp, NewSizeAlloc);
            if (ptrOutBuffer == NULL) {
                G_FREE(ptrTemp);
                Status = PDH_MEMORY_ALLOCATION_FAILURE;
                goto Cleanup;
            }
            pLogCounter   = (PPDHI_LOG_COUNTER_PATH) (((LPBYTE) ptrOutBuffer) + SizeAlloc);
            SizeAlloc     = NewSizeAlloc;

            RtlZeroMemory(pLogCounter, dwPathBufSize);
            pLogCounter->dwLength      = dwPathBufSize;
            pLogCounter->dwFlags       = pThisCounter->dwFlags;
            pLogCounter->dwUserData    = pThisCounter->dwUserData;
            if (pThisCounter->dwFlags & PDHIC_COUNTER_OBJECT) {
                pLogCounter->dwCounterType = PDHIC_COUNTER_OBJECT;
                pLogCounter->lDefaultScale = 0;
                pLogCounter->dwIndex       = 0;
            }
            else {
                pLogCounter->dwCounterType = pThisCounter->plCounterInfo.dwCounterType;
                pLogCounter->lDefaultScale = pThisCounter->plCounterInfo.lDefaultScale;
                pLogCounter->dwIndex       = pThisCounter->pCounterPath->dwIndex;
            }
            pLogCounter->llTimeBase    = pThisCounter->TimeBase;

            // if this is a wild card path, then move the strings up
            // 1 dword in the buffer allowing the first DWORD of the
            // the buffer to contain the offset into the catalog
            // of the instances found in this log file. This list
            // will be built after the log is closed.

            lBufOffset = 0; // in WORDS (not bytes)
            if (pThisCounter->pCounterPath->szInstanceName != NULL) {
                if (* pThisCounter->pCounterPath->szInstanceName == SPLAT_L) {
                    lBufOffset = sizeof(DWORD);
                }
            }
#if DBG
            if (lBufOffset > 0)
                * (LPDWORD) (& pLogCounter->Buffer[0]) = 0x12345678;
#endif
            if (pThisCounter->pCounterPath->szMachineName != NULL) {
                pLogCounter->lMachineNameOffset = lBufOffset;
                pBufferBase = (PWCHAR) ((LPBYTE) & pLogCounter->Buffer[0] + lBufOffset);
                StringCchCopyW(pBufferBase,
                               lstrlenW(pThisCounter->pCounterPath->szMachineName) + 1,
                               pThisCounter->pCounterPath->szMachineName);
                lBufOffset += sizeof(WCHAR) * (1 + lstrlenW(pThisCounter->pCounterPath->szMachineName));
            }
            else {
                pLogCounter->lMachineNameOffset = (LONG) -1;
            }
            if (pThisCounter->pCounterPath->szObjectName != NULL) {
                pLogCounter->lObjectNameOffset = lBufOffset;
                pBufferBase = (PWCHAR) ((LPBYTE) & pLogCounter->Buffer[0] + lBufOffset);
                StringCchCopyW(pBufferBase,
                               lstrlenW(pThisCounter->pCounterPath->szObjectName) + 1,
                               pThisCounter->pCounterPath->szObjectName);
                lBufOffset += sizeof(WCHAR) * (1 + lstrlenW(pThisCounter->pCounterPath->szObjectName));
            }
            else {
                pLogCounter->lObjectNameOffset = (LONG) -1;
            }
            if (pThisCounter->pCounterPath->szInstanceName != NULL) {
                pLogCounter->lInstanceOffset = lBufOffset;
                pBufferBase = (PWCHAR) ((LPBYTE) & pLogCounter->Buffer[0] + lBufOffset);
                StringCchCopyW(pBufferBase,
                               lstrlenW(pThisCounter->pCounterPath->szInstanceName) + 1,
                               pThisCounter->pCounterPath->szInstanceName);
                lBufOffset += sizeof(WCHAR) * (1 + lstrlenW(pThisCounter->pCounterPath->szInstanceName));
            }
            else {
                pLogCounter->lInstanceOffset = (LONG) -1;
            }
            if (pThisCounter->pCounterPath->szParentName != NULL) {
                pLogCounter->lParentOffset = lBufOffset;
                pBufferBase = (PWCHAR) ((LPBYTE) & pLogCounter->Buffer[0] + lBufOffset);
                StringCchCopyW(pBufferBase,
                               lstrlenW(pThisCounter->pCounterPath->szParentName) + 1,
                               pThisCounter->pCounterPath->szParentName);
                lBufOffset += sizeof(WCHAR) * (1 + lstrlenW(pThisCounter->pCounterPath->szParentName));
            }
            else {
                pLogCounter->lParentOffset = (LONG) -1;
            }
            if (pThisCounter->pCounterPath->szCounterName != NULL) {
                pLogCounter->lCounterOffset = lBufOffset;
                pBufferBase = (PWCHAR) ((LPBYTE) & pLogCounter->Buffer[0] + lBufOffset);
                StringCchCopyW(pBufferBase,
                               lstrlenW(pThisCounter->pCounterPath->szCounterName) + 1,
                               pThisCounter->pCounterPath->szCounterName);
                lBufOffset += sizeof(WCHAR) * (1 + lstrlenW(pThisCounter->pCounterPath->szCounterName));
            }
            else {
                pLogCounter->lCounterOffset = (LONG) -1;
            }
            pThisCounter = pThisCounter->next.flink;
        }
        while (pThisCounter != pThisCounterHead);
    }
    if (Status == ERROR_SUCCESS) {
        Status = PdhWmiTraceEvent(pLog, PDH_LOG_HEADER_EVENT, LoggerInfo->TimeStamp - 1, SizeAlloc, ptrOutBuffer);
    }

Cleanup:
    G_FREE(ptrOutBuffer);
    return Status;
}

PDH_FUNCTION
PdhWmiTraceEvent(
    PPDHI_LOG pLog,
    ULONG     PdhEventType,
    ULONGLONG TimeStamp,
    ULONG     lenMofData,
    PVOID     ptrMofData
)
{
    PDH_STATUS Status = PDH_INVALID_HANDLE;

    if ((pLog->dwLogFormat & PDH_LOG_WRITE_ACCESS) && ((TRACEHANDLE) pLog->hLogFileHandle != (TRACEHANDLE) 0)) {
        PDH_WMI_EVENT_TRACE         Wnode;
        PPDH_EVENT_TRACE_PROPERTIES LoggerInfo      = (PPDH_EVENT_TRACE_PROPERTIES) pLog->lpMappedFileBase;
        DWORD                       dwNumEvents     = (lenMofData / PDH_BLOCK_BUFFER_SIZE);
        DWORD                       dwCurrentEvent  = 1;
        PVOID                       ptrCurrentMof   = ptrMofData;
        BOOL                        bIncreaseBuffer = TRUE;

        if (LoggerInfo->bDisable) {
            return ERROR_DISK_FULL;
        }
        if (lenMofData > PDH_BLOCK_BUFFER_SIZE * dwNumEvents) {
            dwNumEvents ++;
        }
        for (Status = ERROR_SUCCESS, dwCurrentEvent = 1;
                        (Status == ERROR_SUCCESS) && (dwCurrentEvent <= dwNumEvents);
                             dwCurrentEvent ++) {
            USHORT sMofLen = (lenMofData > PDH_BLOCK_BUFFER_SIZE) ? (PDH_BLOCK_BUFFER_SIZE) : ((USHORT) lenMofData);
            RtlZeroMemory(& Wnode, sizeof(PDH_WMI_EVENT_TRACE));
            Wnode.EventHeader.Size          = sizeof(PDH_WMI_EVENT_TRACE);
            Wnode.EventHeader.Class.Type    = (UCHAR) PdhEventType;
            Wnode.EventHeader.Class.Version = PDH_EVENT_VERSION;
            Wnode.EventHeader.GuidPtr       = (ULONGLONG) & PdhTransactionGuid;
            Wnode.EventHeader.Flags         = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_GUID_PTR
                                                    | WNODE_FLAG_USE_MOF_PTR | WNODE_FLAG_USE_TIMESTAMP;
            if (PdhEventType == PDH_LOG_HEADER_EVENT || PdhEventType == PDH_LOG_COUNTER_STRING_EVENT) {
                Wnode.EventHeader.Flags  |= WNODE_FLAG_PERSIST_EVENT;
            }
            Wnode.EventHeader.TimeStamp.QuadPart = TimeStamp;
            Wnode.MofFields[0].Length            = sizeof(GUID);
            Wnode.MofFields[0].DataPtr           = (ULONGLONG) & LoggerInfo->LogFileGuid;
            Wnode.MofFields[1].Length            = sizeof(DWORD);
            Wnode.MofFields[1].DataPtr           = (ULONGLONG) & dwCurrentEvent;
            Wnode.MofFields[2].Length            = sizeof(DWORD);
            Wnode.MofFields[2].DataPtr           = (ULONGLONG) & dwNumEvents;
            Wnode.MofFields[3].Length            = sMofLen;
            Wnode.MofFields[3].DataPtr           = (ULONGLONG) ptrCurrentMof;
            bIncreaseBuffer = TRUE;
            while (bIncreaseBuffer == TRUE) {
                Status = TraceEvent((TRACEHANDLE) pLog->hLogFileHandle, (PEVENT_TRACE_HEADER) & Wnode);
                if (Status == ERROR_NOT_ENOUGH_MEMORY) {
                    if (LoggerInfo->LoggerInfo.MaximumBuffers >= PDH_WMI_MAX_BUFFERS) {
                        bIncreaseBuffer = FALSE;
                    }
                    else {
                        EVENT_TRACE_PROPERTIES tmpLoggerInfo;
                        LoggerInfo->LoggerInfo.MaximumBuffers += PDH_WMI_BUFFER_INCREMENT;
                        RtlCopyMemory(& tmpLoggerInfo, & LoggerInfo->LoggerInfo, sizeof(EVENT_TRACE_PROPERTIES));
                        tmpLoggerInfo.Wnode.BufferSize  = sizeof(EVENT_TRACE_PROPERTIES);
                        tmpLoggerInfo.LoggerNameOffset  = 0;
                        tmpLoggerInfo.LogFileNameOffset = 0;
                        Status = ControlTraceW((TRACEHANDLE) pLog->hLogFileHandle,
                                               LoggerInfo->LoggerName,
                                               (PEVENT_TRACE_PROPERTIES) & tmpLoggerInfo,
                                               EVENT_TRACE_CONTROL_UPDATE);
                        TRACE((PDH_DBG_TRACE_INFO),
                              (__LINE__,
                               PDH_LOGWMI,
                               ARG_DEF(ARG_TYPE_PTR, 1),
                               Status,
                               TRACE_PTR(pLog->hLogFileHandle),
                               TRACE_DWORD(LoggerInfo->LoggerInfo.MaximumBuffers),
                               NULL));
                        bIncreaseBuffer = (Status == ERROR_SUCCESS || Status == ERROR_MORE_DATA) ? (TRUE) : (FALSE);
                    }
                }
                else {
                    bIncreaseBuffer = FALSE;
                }
            }
            if (Status != ERROR_SUCCESS) {
                DWORD dwMofLen = sMofLen;
                TRACE((PDH_DBG_TRACE_ERROR),
                      (__LINE__,
                       PDH_LOGWMI,
                       ARG_DEF(ARG_TYPE_PTR, 1) | ARG_DEF(ARG_TYPE_ULONGX, 6) | ARG_DEF(ARG_TYPE_ULONG64, 7),
                       Status,
                       TRACE_PTR(pLog->hLogFileHandle),
                       TRACE_DWORD(PdhEventType),
                       TRACE_DWORD(dwCurrentEvent),
                       TRACE_DWORD(dwNumEvents),
                       TRACE_DWORD(dwMofLen),
                       TRACE_DWORD(Wnode.EventHeader.Flags),
                       TRACE_LONG64(Wnode.EventHeader.TimeStamp.QuadPart),
                       NULL));
            }
            if (Status == ERROR_SUCCESS) {
                lenMofData   -= sMofLen;
                ptrCurrentMof = (PVOID) (((LPBYTE) ptrCurrentMof) + sMofLen);
            }
        }
    }
    return Status;
}

ULONG whextoi(
    WCHAR * s
)
{
    long len;
    ULONG num, base, hex;

    if (s == NULL || s[0] == L'\0') {
        return 0;
    }
    len = (long) wcslen(s); // we expect all strings to be less than MAXSTR
    if (len == 0) {
        return 0;
    }

    hex  = 0;
    base = 1;
    num  = 0;
    while (-- len >= 0) {
        if (s[len] >= L'0' && s[len] <= L'9')      num = s[len] - L'0';
        else if (s[len] >= L'a' && s[len] <= L'f') num = (s[len] - L'a') + 10;
        else if (s[len] >= L'A' && s[len] <= L'F') num = (s[len] - L'A') + 10;
        else                                       continue;
        hex += num * base;
        base = base * 16;
    }
    return hex;
}

PDH_FUNCTION
PdhiCheckWmiLogFileType(
    LPCWSTR LogFileName,
    LPDWORD LogFileType
)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HANDLE     hFile     = NULL;

    hFile = CreateFileW(LogFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (hFile == NULL || hFile == INVALID_HANDLE_VALUE) {
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
    }
    else {
        LPBYTE TraceBuffer = NULL;

        TraceBuffer = G_ALLOC(sizeof(BYTE) * PDH_WMI_BUFFER_SIZE_BYTE);
        if (TraceBuffer != NULL) {
            ULONG  ByteRead = 0;
            INT    bResult  = ReadFile(hFile, (LPVOID) TraceBuffer, PDH_WMI_BUFFER_SIZE_BYTE, & ByteRead, NULL);
            if (bResult > 0 && ByteRead == PDH_WMI_BUFFER_SIZE_BYTE) {
                PWMI_BUFFER_HEADER    BufferHeader;
                PTRACE_LOGFILE_HEADER LogFileHeader;

                BufferHeader  = (PWMI_BUFFER_HEADER) TraceBuffer;
                LogFileHeader = (PTRACE_LOGFILE_HEADER) (TraceBuffer + sizeof(WMI_BUFFER_HEADER)
                                                                     + sizeof(SYSTEM_TRACE_HEADER));
                if (BufferHeader->Wnode.BufferSize == PDH_WMI_BUFFER_SIZE_BYTE
                                && LogFileHeader->BufferSize == PDH_WMI_BUFFER_SIZE_BYTE) {
                    // preassume that this is PDH event trace counter logfile
                    //
                    * LogFileType = PDH_LOG_TYPE_BINARY;
                }
                else {
                    * LogFileType = PDH_LOG_TYPE_UNDEFINED;
                }
            }
            G_FREE(TraceBuffer);
        }
        else {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        CloseHandle(hFile);
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhWmiGetLoggerName(
    PPDHI_LOG                   pLog,
    PPDH_EVENT_TRACE_PROPERTIES LoggerInfo
)
{
    PDH_STATUS Status      = ERROR_SUCCESS;
    LPBYTE     TraceBuffer = NULL;

    TraceBuffer = G_ALLOC(sizeof(BYTE) * PDH_WMI_BUFFER_SIZE_BYTE);
    if (TraceBuffer != NULL) {
        HANDLE hFile;
        ULONG  ByteRead = 0;

        // read in the first trace buffer

        hFile = CreateFileW(LoggerInfo->LogFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
        if (hFile == NULL || hFile == INVALID_HANDLE_VALUE) {
            Status = PDH_LOG_FILE_OPEN_ERROR;
        }
        else {
            INT bResult = ReadFile(hFile, (LPVOID) TraceBuffer, PDH_WMI_BUFFER_SIZE_BYTE, & ByteRead, NULL);
            if (bResult == 0 || ByteRead != PDH_WMI_BUFFER_SIZE_BYTE) {
                Status = PDH_LOG_FILE_OPEN_ERROR;
            }
            CloseHandle(hFile);
        }
    }
    else {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
    }

    if (Status == ERROR_SUCCESS) {
        PTRACE_LOGFILE_HEADER pHeader = (PTRACE_LOGFILE_HEADER) (TraceBuffer + sizeof(WMI_BUFFER_HEADER)
                                                                             + sizeof(SYSTEM_TRACE_HEADER));
        if (pHeader->BuffersWritten > 1) {
            UINT    i;
            WCHAR   strTmp[PDH_MAX_PATH];
            LPWSTR  LoggerName = (LPWSTR) (((LPBYTE) pHeader) + sizeof(TRACE_LOGFILE_HEADER));
            StringCchCopyW(LoggerInfo->LoggerName, PDH_MAX_PATH, LoggerName);

            StringCchCopyW(strTmp, 9, LoggerName);
            strTmp[8] = L'\0';
            LoggerInfo->LogFileGuid.Data1 = whextoi(strTmp);

            StringCchCopyW(strTmp, 5, & LoggerName[9]);
            strTmp[4] = L'\0';
            LoggerInfo->LogFileGuid.Data2 = (USHORT) whextoi(strTmp);

            StringCchCopyW(strTmp, 5, & LoggerName[14]);
            strTmp[4] = L'\0';
            LoggerInfo->LogFileGuid.Data3 = (USHORT) whextoi(strTmp);

            for (i = 0; i < 2; i ++) {
                StringCchCopyW(strTmp, 3, & LoggerName[19 + (i * 2)]);
                strTmp[2] = L'\0';
                LoggerInfo->LogFileGuid.Data4[i] = (UCHAR) whextoi(strTmp);
            }

            for (i = 2; i < 8; i ++) {
                StringCchCopyW(strTmp, 3, & LoggerName[20 + (i * 2)]);
                strTmp[2] = L'\0';
                LoggerInfo->LogFileGuid.Data4[i] = (UCHAR) whextoi(strTmp);
            }
        }
        else {
            // Only 1 trace buffer written, no PDH events yet.
            // It is safe to discard this one and create a new one.
            //
            Status = PDH_LOG_FILE_OPEN_ERROR;
            TRACE((PDH_DBG_TRACE_ERROR),
                  (__LINE__,
                   PDH_LOGWMI,
                   ARG_DEF(ARG_TYPE_PTR, 1) | ARG_DEF(ARG_TYPE_PTR, 2)
                                            | ARG_DEF(ARG_TYPE_WSTR, 3),
                   Status,
                   TRACE_PTR(pLog),
                   TRACE_PTR(LoggerInfo),
                   TRACE_WSTR(LoggerInfo->LogFileName),
                   NULL));
        }
    }
    G_FREE(TraceBuffer);
    return Status;
}

PDH_FUNCTION
PdhiOpenOutputWmiLog(
    PPDHI_LOG pLog
)
{
    PDH_STATUS                  Status = PDH_LOG_FILE_CREATE_ERROR;
    PPDH_EVENT_TRACE_PROPERTIES LoggerInfo;

    pLog->lpMappedFileBase = G_ALLOC(sizeof(PDH_EVENT_TRACE_PROPERTIES));
    if (pLog->lpMappedFileBase == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }
    LoggerInfo = (PPDH_EVENT_TRACE_PROPERTIES) pLog->lpMappedFileBase;
    RtlZeroMemory(LoggerInfo, sizeof(PDH_EVENT_TRACE_PROPERTIES));

    // Start PDH kernel logger
    //
    LoggerInfo->LoggerInfo.Wnode.BufferSize    = sizeof(PDH_EVENT_TRACE_PROPERTIES);
    LoggerInfo->LoggerInfo.Wnode.Flags         = WNODE_FLAG_TRACED_GUID;
    LoggerInfo->LoggerInfo.Wnode.ClientContext = EVENT_TRACE_CLOCK_SYSTEMTIME;
    LoggerInfo->LoggerInfo.BufferSize          = PDH_WMI_BUFFER_SIZE;
    LoggerInfo->LoggerInfo.LoggerNameOffset    = sizeof(EVENT_TRACE_PROPERTIES);
    LoggerInfo->LoggerInfo.LogFileNameOffset   = sizeof(EVENT_TRACE_PROPERTIES) + sizeof(WCHAR) * PDH_MAX_PATH;
    _wfullpath(LoggerInfo->LogFileName, pLog->szLogFileName, PDH_MAX_PATH);
    if (! (pLog->dwLogFormat & PDH_LOG_OPT_CIRCULAR) &&  (pLog->dwLogFormat & PDH_LOG_OPT_APPEND)) {
        Status = PdhWmiGetLoggerName(pLog, LoggerInfo);
        if (Status != ERROR_SUCCESS) {
            // if cannot get LogFileGuid from logfile, erase the old one
            // and create new one
            //
            RPC_STATUS rpcStatus = UuidCreate(& LoggerInfo->LogFileGuid);
            GuidToString(LoggerInfo->LoggerName, PDH_MAX_PATH, & LoggerInfo->LogFileGuid);
        }
        else {
            LoggerInfo->LoggerInfo.LogFileMode |= EVENT_TRACE_FILE_MODE_APPEND;
        }
    }
    else {
        RPC_STATUS rpcStatus = UuidCreate(& LoggerInfo->LogFileGuid);
        GuidToString(LoggerInfo->LoggerName, PDH_MAX_PATH, & LoggerInfo->LogFileGuid);
    }
    if (pLog->dwLogFormat & PDH_LOG_OPT_CIRCULAR) {
        LoggerInfo->LoggerInfo.LogFileMode |= EVENT_TRACE_FILE_MODE_CIRCULAR_PERSIST;

    }
    else {
        LoggerInfo->LoggerInfo.LogFileMode |= EVENT_TRACE_FILE_MODE_SEQUENTIAL;
    }
    LoggerInfo->LoggerInfo.LogFileMode |= EVENT_TRACE_USE_PAGED_MEMORY;
    if (pLog->llMaxSize == 0) {
        LoggerInfo->LoggerInfo.MaximumFileSize = 0;
    }
    else {
        LoggerInfo->LoggerInfo.MaximumFileSize = (ULONG) ((pLog->llMaxSize / 1024) / 1024);
    }
    LoggerInfo->LoggerInfo.MaximumBuffers = PDH_WMI_DEFAULT_BUFFERS;
    LoggerInfo->bHeaderEvent = FALSE;
    LoggerInfo->bDisable     = FALSE;
    Status = StartTraceW((PTRACEHANDLE) & pLog->hLogFileHandle,
                         LoggerInfo->LoggerName,
                         (PEVENT_TRACE_PROPERTIES) LoggerInfo);
    if (Status != ERROR_SUCCESS) {
        TRACE((PDH_DBG_TRACE_ERROR),
              (__LINE__,
               PDH_LOGWMI,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2) | ARG_DEF(ARG_TYPE_ULONGX, 3)
                                         | ARG_DEF(ARG_TYPE_ULONG64, 4),
               Status,
               TRACE_WSTR(LoggerInfo->LoggerName),
               TRACE_WSTR(LoggerInfo->LogFileName),
               TRACE_DWORD(LoggerInfo->LoggerInfo.LogFileMode),
               TRACE_LONG64(pLog->llMaxSize),
               NULL));
    }

Cleanup:
    if (Status != ERROR_SUCCESS) {
        G_FREE(pLog->lpMappedFileBase);
        pLog->lpMappedFileBase = NULL;
        Status = PDH_LOG_FILE_CREATE_ERROR;
    }
    else if (WAIT_FOR_AND_LOCK_MUTEX(hPdhContextMutex) == ERROR_SUCCESS) {
        if (dwPdhBlgLog == 0) {
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4152)
            WmiNotificationRegistration((const LPGUID) & TraceErrorGuid,
                                        TRUE,
                                        PdhTraceNotificationCallback,
                                        0,
                                        NOTIFICATION_CALLBACK_DIRECT);
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif
        }
        lpPdhBlgLog[dwPdhBlgLog] = pLog;
        dwPdhBlgLog ++;
        RELEASE_MUTEX(hPdhContextMutex);
    }
    return Status;
}

PDH_FUNCTION
PdhiWriteWmiLogRecord(
    PPDHI_LOG    pLog,
    SYSTEMTIME * stTimeStamp,
    LPCWSTR      szUserString
)
{
    PDH_STATUS                     pdhStatus         = ERROR_SUCCESS;
    PPDHI_BINARY_LOG_RECORD_HEADER pLogCounterBuffer = NULL;
    PPDHI_BINARY_LOG_RECORD_HEADER pThisLogCounter   = NULL;
    PPDH_RAW_COUNTER               pSingleCounter;
    PPDHI_RAW_COUNTER_ITEM_BLOCK   pMultiCounter;
    PPDHI_COUNTER                  pThisCounter;
    PPERF_DATA_BLOCK               pObjectCounter;
    DWORD                          dwBufSize         = 0;
    ULONGLONG                      TimeStamp         = 0;
    FILETIME                       tFileTime;
    PPDH_EVENT_TRACE_PROPERTIES    LoggerInfo        = (PPDH_EVENT_TRACE_PROPERTIES) pLog->lpMappedFileBase;

    DBG_UNREFERENCED_PARAMETER(szUserString);

    tFileTime.dwLowDateTime = tFileTime.dwHighDateTime = 0;
    SystemTimeToFileTime(stTimeStamp, & tFileTime);

    pThisCounter = pLog->pQuery ? pLog->pQuery->pCounterListHead : NULL;
    if (pThisCounter == NULL) {
        return PDH_NO_DATA;
    }

    do {
        DWORD dwType       = (pThisCounter->dwFlags & PDHIC_COUNTER_OBJECT)
                           ? (PDHIC_COUNTER_OBJECT)
                           : ((pThisCounter->dwFlags & PDHIC_MULTI_INSTANCE) ? (PDHIC_MULTI_INSTANCE) : (0));
        DWORD dwCtrBufSize = sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
        DWORD dwNewSize;
        int   nItem;

        switch (dwType) {
        case PDHIC_MULTI_INSTANCE:
            if (pThisCounter->pThisRawItemList) {
                dwCtrBufSize += pThisCounter->pThisRawItemList->dwLength;
            }
            else {
                dwCtrBufSize += sizeof(PDHI_RAW_COUNTER_ITEM_BLOCK);
            }
            break;

        case PDHIC_COUNTER_OBJECT:
            if (pThisCounter->pThisObject) {
                dwCtrBufSize += pThisCounter->pThisObject->TotalByteLength;
            }
            else {
                dwCtrBufSize += sizeof(PERF_DATA_BLOCK);
            }
            break;

        default:
            dwCtrBufSize += sizeof(PDH_RAW_COUNTER);
            break;
        }

        if (dwCtrBufSize > 0) {
            // extend buffer to accomodate this new counter
            //
            if (pLogCounterBuffer == NULL) {
                // add in room for the master record header
                // then allocate the first one
                //
                dwBufSize = (dwCtrBufSize + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
                pLogCounterBuffer = G_ALLOC(dwBufSize);

                // set counter data pointer to just after the master
                // record header
                //
                if (pLogCounterBuffer == NULL) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    break;
                }
                pThisLogCounter = (PPDHI_BINARY_LOG_RECORD_HEADER)
                                  (((PUCHAR) pLogCounterBuffer) + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
                pThisLogCounter->dwLength = LOWORD(dwCtrBufSize);
            }
            else  {
                PPDHI_BINARY_LOG_RECORD_HEADER ptrTemp = pLogCounterBuffer;
                dwNewSize         = (dwBufSize + dwCtrBufSize);
                pLogCounterBuffer = G_REALLOC(ptrTemp, dwNewSize);
                if (pLogCounterBuffer == NULL) {
                    G_FREE(ptrTemp);
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    break;
                }
                pThisLogCounter   = (PPDHI_BINARY_LOG_RECORD_HEADER) ((LPBYTE) pLogCounterBuffer + dwBufSize);
                dwBufSize        += dwCtrBufSize;
                pThisLogCounter->dwLength = LOWORD(dwCtrBufSize);
            }
        }

        if (dwType == PDHIC_COUNTER_OBJECT) {
            FILETIME LocFileTime;
            pThisLogCounter->dwType = BINLOG_TYPE_DATA_LOC_OBJECT;
            pObjectCounter = (PPERF_DATA_BLOCK) ((LPBYTE) pThisLogCounter + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
            if (pThisCounter->pThisObject != NULL && pThisCounter->pThisObject != pThisCounter->pLastObject) {
                ZeroMemory(& LocFileTime, sizeof(FILETIME));
                RtlCopyMemory(pObjectCounter, pThisCounter->pThisObject, pThisCounter->pThisObject->TotalByteLength);
                SystemTimeToFileTime(& pThisCounter->pThisObject->SystemTime, & LocFileTime);
            }
            else {
                if (TimeStamp != 0) {
                    LocFileTime.dwLowDateTime  = LODWORD(TimeStamp);
                    LocFileTime.dwHighDateTime = HIDWORD(TimeStamp);
                }
                else {
                    LocFileTime = tFileTime;
                }
                pObjectCounter->Signature[0]              = L'P';
                pObjectCounter->Signature[1]              = L'E';
                pObjectCounter->Signature[2]              = L'R';
                pObjectCounter->Signature[3]              = L'F';
                pObjectCounter->LittleEndian              = TRUE;
                pObjectCounter->Version                   = PERF_DATA_VERSION;
                pObjectCounter->Revision                  = PERF_DATA_REVISION;
                pObjectCounter->TotalByteLength           = sizeof(PERF_DATA_BLOCK);
                pObjectCounter->NumObjectTypes            = 1;
                pObjectCounter->DefaultObject             = pThisCounter->plCounterInfo.dwObjectId;
                pObjectCounter->SystemNameLength          = 0;
                pObjectCounter->SystemNameOffset          = 0;
                pObjectCounter->HeaderLength              = sizeof(PERF_DATA_BLOCK);
                pObjectCounter->PerfTime.QuadPart         = 0;
                pObjectCounter->PerfFreq.QuadPart         = 0;
                pObjectCounter->PerfTime100nSec.QuadPart  = 0;
                FileTimeToSystemTime(& LocFileTime, & pObjectCounter->SystemTime);
            }
            TimeStamp = MAKELONGLONG(LocFileTime.dwLowDateTime, LocFileTime.dwHighDateTime);
        }
        else if (dwType == PDHIC_MULTI_INSTANCE) {
            // multiple counter
            //
            pThisLogCounter->dwType = BINLOG_TYPE_DATA_MULTI;
            pMultiCounter = (PPDHI_RAW_COUNTER_ITEM_BLOCK)
                                    ((LPBYTE) pThisLogCounter + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
            if (pThisCounter->pThisRawItemList) {
                RtlCopyMemory(pMultiCounter, pThisCounter->pThisRawItemList, pThisCounter->pThisRawItemList->dwLength);
            }
            else {
                FILETIME LocFileTime;
                if (TimeStamp != 0) {
                    LocFileTime.dwLowDateTime  = LODWORD(TimeStamp);
                    LocFileTime.dwHighDateTime = HIDWORD(TimeStamp);
                }
                else {
                    LocFileTime = tFileTime;
                }
                ZeroMemory(pMultiCounter, sizeof(PDHI_RAW_COUNTER_ITEM_BLOCK));
                pMultiCounter->CStatus                  = PDH_CSTATUS_INVALID_DATA;
                pMultiCounter->TimeStamp.dwLowDateTime  = LocFileTime.dwLowDateTime;
                pMultiCounter->TimeStamp.dwHighDateTime = LocFileTime.dwHighDateTime;
            }
            TimeStamp = MAKELONGLONG(pMultiCounter->TimeStamp.dwLowDateTime, pMultiCounter->TimeStamp.dwHighDateTime);
        }
        else {
            pThisLogCounter->dwType = BINLOG_TYPE_DATA_SINGLE;
            pSingleCounter = (PPDH_RAW_COUNTER) ((LPBYTE) pThisLogCounter + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
            RtlCopyMemory(pSingleCounter, & pThisCounter->ThisValue, sizeof(PDH_RAW_COUNTER));
            if (pSingleCounter->CStatus != ERROR_SUCCESS) {
                if (TimeStamp != 0) {
                    pSingleCounter->TimeStamp.dwLowDateTime  = LODWORD(TimeStamp);
                    pSingleCounter->TimeStamp.dwHighDateTime = HIDWORD(TimeStamp);
                }
                else {
                    pSingleCounter->TimeStamp.dwLowDateTime  = tFileTime.dwLowDateTime;
                    pSingleCounter->TimeStamp.dwHighDateTime = tFileTime.dwHighDateTime;
                }
            }
            TimeStamp = (ULONGLONG) MAKELONGLONG(pSingleCounter->TimeStamp.dwLowDateTime,
                                                 pSingleCounter->TimeStamp.dwHighDateTime);
        }
        pThisCounter = pThisCounter->next.flink; // go to next in list

    }
    while (pThisCounter != pLog->pQuery->pCounterListHead);

    if (TimeStamp == 0) {
        TimeStamp = MAKELONGLONG(tFileTime.dwLowDateTime, tFileTime.dwHighDateTime);
    }
    if (pdhStatus == ERROR_SUCCESS && pLogCounterBuffer) {
        pLogCounterBuffer->dwType   = BINLOG_TYPE_DATA;
        pLogCounterBuffer->dwLength = dwBufSize;
        LoggerInfo->TimeStamp       = TimeStamp;

        if (! LoggerInfo->bHeaderEvent) {
            ULONG HeaderMofLength = 0;
            PVOID HeaderMofData   = NULL;
            ULONG EventType;

            if (! (LoggerInfo->LoggerInfo.LogFileMode & EVENT_TRACE_FILE_MODE_APPEND)) {
                pdhStatus = PdhiBuildLogHeaderBlock(pLog, LoggerInfo);
            }
            LoggerInfo->bHeaderEvent = TRUE;
        }
    }

    if (pdhStatus == ERROR_SUCCESS && pLogCounterBuffer) {
        pdhStatus = PdhWmiTraceEvent(pLog, PDH_LOG_DATA_BLOCK_EVENT, TimeStamp, dwBufSize, (PVOID)  pLogCounterBuffer);
    }
    G_FREE(pLogCounterBuffer);
    return pdhStatus;
}

PDH_FUNCTION
PdhiWriteWmiLogHeader(
    PPDHI_LOG pLog,
    LPCWSTR   szUserCaption
)
{
    UNREFERENCED_PARAMETER(pLog);
    UNREFERENCED_PARAMETER(szUserCaption);
    return ERROR_SUCCESS;
}

PDH_FUNCTION
PdhiCloseWmiLog(
    PPDHI_LOG pLog,
    DWORD     dwFlags
)
{
    PDH_STATUS Status = PDH_INVALID_ARGUMENT;
    ULONG      i;

    UNREFERENCED_PARAMETER(pLog);
    UNREFERENCED_PARAMETER(dwFlags);

    if (pLog->dwLogFormat & PDH_LOG_WRITE_ACCESS) {
        if ((TRACEHANDLE) pLog->hLogFileHandle != (TRACEHANDLE) 0) {
            PPDH_EVENT_TRACE_PROPERTIES LoggerInfo = (PPDH_EVENT_TRACE_PROPERTIES) pLog->lpMappedFileBase;
            if (LoggerInfo == NULL) {
                Status = PDH_INVALID_HANDLE;
            }
            else {
                ULONG HeaderMofLength = 0;
                PVOID HeaderMofData   = NULL;
                Status = ControlTraceW((TRACEHANDLE) pLog->hLogFileHandle,
                                       LoggerInfo->LoggerName,
                                       (PEVENT_TRACE_PROPERTIES) LoggerInfo,
                                       EVENT_TRACE_CONTROL_STOP);
                if (Status != ERROR_SUCCESS) {
                    TRACE((PDH_DBG_TRACE_ERROR),
                          (__LINE__,
                           PDH_LOGWMI,
                           ARG_DEF(ARG_TYPE_PTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2)
                                                    | ARG_DEF(ARG_TYPE_WSTR, 3),
                           Status,
                           TRACE_PTR(pLog->hLogFileHandle),
                           TRACE_WSTR(LoggerInfo->LoggerName),
                           TRACE_WSTR(LoggerInfo->LogFileName),
                           NULL));
                }
                if (WAIT_FOR_AND_LOCK_MUTEX(hPdhContextMutex) == ERROR_SUCCESS) {
                    for (i = 0; i < dwPdhBlgLog; i ++) {
                        if (lpPdhBlgLog[i] == pLog) {
                            dwPdhBlgLog --;
                            if (i < dwPdhBlgLog) {
                                lpPdhBlgLog[i] = lpPdhBlgLog[dwPdhBlgLog];
                            }
                            break;
                        }
                    }
                    if (dwPdhBlgLog == 0) {
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4152 )
                        WmiNotificationRegistration((const LPGUID) & TraceErrorGuid,
                                                    FALSE,
                                                    PdhTraceNotificationCallback,
                                                    0,
                                                    NOTIFICATION_CALLBACK_DIRECT);
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif
                    }
                    RELEASE_MUTEX(hPdhContextMutex);
                }
                G_FREE(LoggerInfo->MachineList);
                G_FREE(pLog->lpMappedFileBase);
                pLog->lpMappedFileBase = NULL;
            }
            pLog->hLogFileHandle = INVALID_HANDLE_VALUE;
            if (PdhTraceRegistrationHandle != (TRACEHANDLE) 0) {
                Status = UnregisterTraceGuids(PdhTraceRegistrationHandle);
                if (Status != ERROR_SUCCESS) {
                    TRACE((PDH_DBG_TRACE_ERROR),
                          (__LINE__,
                           PDH_LOGWMI,
                           ARG_DEF(ARG_TYPE_PTR,1),
                           Status,
                           TRACE_PTR(PdhTraceRegistrationHandle),
                           NULL));
                }
            }
        }
        else {
            Status = PDH_INVALID_HANDLE;
        }
    }
    else if (pLog->dwLogFormat & PDH_LOG_READ_ACCESS) {
        DWORD               dwExitCode;
        PPDH_LOGGER_CONTEXT CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
        DWORD               dwContext      = GetLoggerContext(CurrentContext);

        if (dwContext < ContextCount) {
            Status = WAIT_FOR_AND_LOCK_MUTEX(hPdhContextMutex);
            if (Status == ERROR_SUCCESS) {
                CurrentContext->RefCount --;
                if (CurrentContext->RefCount > 0) {
                    RELEASE_MUTEX(hPdhContextMutex);
                    return ERROR_SUCCESS;
                }
            }
            else {
                return Status;
            }
            if (dwContext != ContextCount - 1) {
                ContextTable[dwContext] = ContextTable[ContextCount - 1];
            }
            ContextCount --;
            ContextTable[ContextCount] = NULL;
            RELEASE_MUTEX(hPdhContextMutex);

            if (CurrentContext->hThreadWork != NULL
                && CurrentContext->hThreadWork != INVALID_HANDLE_VALUE) {
                if (GetExitCodeThread(CurrentContext->hThreadWork, & dwExitCode) && dwExitCode == STILL_ACTIVE) {
                    CurrentContext->LoggerState = PdhProcessTraceEnd;
                    SetEvent(CurrentContext->hSyncWMI);
                    while (CurrentContext->LoggerState != PdhProcessTraceExit) {
                        _sleep(1);
                    }
                    if (WaitForSingleObject(CurrentContext->hThreadWork, 5000) == WAIT_TIMEOUT) {
                        // wait too long, call TerminateThread() to foce working thread ends.
                        if (TerminateThread(CurrentContext->hThreadWork, 0)) {
                            WaitForSingleObject(CurrentContext->hThreadWork, INFINITE);
                        }
                    }
                }
            }

            if (CurrentContext->hSyncWMI != NULL) {
                CloseHandle(CurrentContext->hSyncWMI);
            }
            if (CurrentContext->hSyncPDH != NULL) {
                CloseHandle(CurrentContext->hSyncPDH);
            }

            for (i = 0; i < CurrentContext->LoggerCount; i ++) {
                PdhiFreeLogMachineTable(& CurrentContext->LogInfo[i].MachineList);
                if (! IsListEmpty(& CurrentContext->LogInfo[i].CounterPathList)) {
                    PLIST_ENTRY       PathHead = & CurrentContext->LogInfo[i].CounterPathList;
                    PLIST_ENTRY       PathNext = PathHead->Flink;
                    PPDH_COUNTER_PATH pCounterPath;

                    while (PathHead != PathNext) {
                        pCounterPath = CONTAINING_RECORD(PathNext, PDH_COUNTER_PATH, Entry);
                        PathNext     = PathNext->Flink;
                        RemoveEntryList(& pCounterPath->Entry);
                        G_FREE(pCounterPath->CounterPathBuffer);
                        G_FREE(pCounterPath);
                    }
                }
                if (! IsListEmpty(& CurrentContext->LogInfo[i].PerfMachineList)) {
                    PLIST_ENTRY           PathHead = & CurrentContext->LogInfo[i].PerfMachineList;
                    PLIST_ENTRY           PathNext = PathHead->Flink;
                    PPDH_WMI_PERF_MACHINE pPerfMachine;

                    while (PathHead != PathNext) {
                        pPerfMachine = CONTAINING_RECORD(PathNext, PDH_WMI_PERF_MACHINE, Entry);
                        PathNext     = PathNext->Flink;
                        RemoveEntryList(& pPerfMachine->Entry);
                        if (! IsListEmpty(& pPerfMachine->LogObjectList)) {
                            PLIST_ENTRY          pHead = & pPerfMachine->LogObjectList;
                            PLIST_ENTRY          pNext = pHead->Flink;
                            PPDH_WMI_PERF_OBJECT pPerfObject;

                            while (pHead != pNext) {
                                pPerfObject = CONTAINING_RECORD(pNext, PDH_WMI_PERF_OBJECT, Entry);
                                pNext       = pNext->Flink;
                                RemoveEntryList(& pPerfObject->Entry);
                                G_FREE(pPerfObject->ptrBuffer);
                                G_FREE(pPerfObject);
                            }
                        }
                        G_FREE(pPerfMachine->pszBuffer);
                        G_FREE(pPerfMachine->ptrStrAry);
                        G_FREE(pPerfMachine);
                    }
                }
                G_FREE(CurrentContext->LogInfo[i].DataBlock);
            }
            G_FREE(CurrentContext->tmpBuffer);
            G_FREE(CurrentContext->CounterPathBuffer);
            G_FREE(pLog->pPerfmonInfo);
            G_FREE(pLog->lpMappedFileBase);
            pLog->pPerfmonInfo     = NULL;
            pLog->lpMappedFileBase = NULL;
            pLog->pLastRecordRead  = NULL;

            Status = ERROR_SUCCESS;
        }
        else {
            Status = PDH_INVALID_HANDLE;
        }
    }
    return Status;
}

PDH_FUNCTION
PdhiAddWmiLogFileGuid(
    PPDH_LOGGER_CONTEXT CurrentContext,
    LPGUID              pGuid
)
{
    PDH_STATUS Status = ERROR_SUCCESS;
    ULONG      i;

    for (i = 0; i < CurrentContext->LoggerCount; i ++) {
        if (IsEqualGUID(pGuid, & CurrentContext->LogInfo[i].LogFileGuid))
            break;
    }
    if (i == CurrentContext->LoggerCount) {
        CurrentContext->LogInfo[i].LogFileGuid = * pGuid;
        CurrentContext->LoggerCount ++;
        if (CurrentContext->LoggerCount > CurrentContext->LogFileCount) {
            TRACE((PDH_DBG_TRACE_ERROR),
                  (__LINE__,
                   PDH_LOGWMI,
                   ARG_DEF(ARG_TYPE_PTR, 1),
                   Status,
                   TRACE_PTR(CurrentContext),
                   TRACE_DWORD(CurrentContext->LoggerCount),
                   TRACE_DWORD(CurrentContext->LogFileCount),
                   NULL));
        }
    }
    return Status;
}

ULONG
PdhiFindLogFileGuid(
    PPDH_LOGGER_CONTEXT CurrentContext,
    LPGUID              pGuid
)
{
    ULONG i;

    for (i = 0; i < CurrentContext->LoggerCount; i ++) {
        if (IsEqualGUID(pGuid, & CurrentContext->LogInfo[i].LogFileGuid))
            break;
    }
    return i;
}

ULONGLONG
PdhWmiGetDataBlockTimeStamp(
    PPDH_LOGGER_CONTEXT CurrentContext,
    PEVENT_TRACE        pEvent,
    BOOLEAN             bFirstRun
)
{
    PVOID     pDataBlock = pEvent->MofData;
    ULONGLONG TimeStamp  = pEvent->Header.TimeStamp.QuadPart;

    if (TimeStamp > 0) {
        LPGUID pLogFileGuid = (LPGUID) pDataBlock;
        ULONG  i;

        for (i = 0; i < CurrentContext->LoggerCount; i ++) {
            if (IsEqualGUID(pLogFileGuid, & CurrentContext->LogInfo[i].LogFileGuid)) {
                break;
            }
        }

        if (i < CurrentContext->LoggerCount) {
            if (bFirstRun) {
                if (CurrentContext->LogInfo[i].TimePrev < TimeStamp) {
                    CurrentContext->LogInfo[i].ValidEntries ++;
                }
                if (CurrentContext->LogInfo[i].TimeStart == 0) {
                    CurrentContext->LogInfo[i].TimeStart = TimeStamp;
                    CurrentContext->LogInfo[i].TimePrev  = TimeStamp;
                }
                else {
                    // no need to update StartTime.
                    // Always assume the first trace event has the StartTime.
                    //
                    if (CurrentContext->LogInfo[i].TimeEnd < TimeStamp) {
                        CurrentContext->LogInfo[i].TimeEnd = TimeStamp;
                    }
                    CurrentContext->LogInfo[i].TimePrev = TimeStamp;
                }
            }
            else {
                CurrentContext->LogInfo[i].TimePrev = TimeStamp;
            }
        }
    }
    return TimeStamp;
}

PDH_FUNCTION
PdhiWmiComputeCounterBlocks(
    PPDH_LOGGER_CONTEXT CurrentContext,
    PEVENT_TRACE        pEvent
)
{
    LPGUID     pLogFileGuid;
    PDH_STATUS Status       = ERROR_SUCCESS;
    PVOID      pDataBlock;
    ULONG      i;
    ULONG      ulNumDataBlocks;
    ULONG      ulDataBlocksCopied;
    ULONG      ulBufferSize;
    ULONG      ulBlockIndex;

    if (CurrentContext == NULL || pEvent == NULL) {
        return PDH_INVALID_DATA;
    }

    pLogFileGuid = (LPGUID) pEvent->MofData;
    if (pLogFileGuid == NULL) {
        return PDH_INVALID_DATA;
    }
    for (i = 0; i < CurrentContext->LoggerCount; i ++) {
        if (IsEqualGUID(pLogFileGuid, & CurrentContext->LogInfo[i].LogFileGuid)) {
            break;
        }
    }
    if (i == CurrentContext->LoggerCount) {
        return PDH_INVALID_DATA;
    }

    ulNumDataBlocks    = CurrentContext->LogInfo[i].ulNumDataBlocks;
    ulDataBlocksCopied = CurrentContext->LogInfo[i].ulDataBlocksCopied;

    if (ulNumDataBlocks > 0 && ulNumDataBlocks == ulDataBlocksCopied) {
        if (CurrentContext->LogInfo[i].DataBlock != NULL) {
            G_FREE(CurrentContext->LogInfo[i].DataBlock);
            CurrentContext->LogInfo[i].DataBlock = NULL;
        }
        goto Cleanup;
    }

    if (ulNumDataBlocks == 0) {
        ulNumDataBlocks = * (DWORD *) (((LPBYTE) pEvent->MofData) + sizeof(GUID) + sizeof(DWORD));
        ulBufferSize    = ulNumDataBlocks * PDH_BLOCK_BUFFER_SIZE + sizeof(GUID);

        if (CurrentContext->LogInfo[i].DataBlock != NULL) {
            G_FREE(CurrentContext->LogInfo[i].DataBlock);
            CurrentContext->LogInfo[i].DataBlock = NULL;
        }
        CurrentContext->LogInfo[i].DataBlock = G_ALLOC(ulBufferSize);
        if (CurrentContext->LogInfo[i].DataBlock == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }

        CurrentContext->LogInfo[i].ulNumDataBlocks    = ulNumDataBlocks;
        CurrentContext->LogInfo[i].ulDataBlocksCopied = 0;
        CurrentContext->LogInfo[i].DataBlockAlloc     = ulBufferSize;
    }

    ulBlockIndex = * (DWORD *) (((LPBYTE) pEvent->MofData) + sizeof(GUID));
    pDataBlock = (PVOID) (((LPBYTE) CurrentContext->LogInfo[i].DataBlock)
                                    + sizeof(GUID) + PDH_BLOCK_BUFFER_SIZE * (ulBlockIndex - 1));
    RtlCopyMemory(pDataBlock,
                  (PVOID) (((LPBYTE) pEvent->MofData) + sizeof(GUID) + sizeof(DWORD) + sizeof(DWORD)),
                  pEvent->MofLength - sizeof(GUID) - sizeof(DWORD) - sizeof(DWORD));
    CurrentContext->LogInfo[i].ulDataBlocksCopied ++;

    if (CurrentContext->LogInfo[i].ulDataBlocksCopied >= CurrentContext->LogInfo[i].ulNumDataBlocks) {
        DWORD                          dwTotal;
        DWORD                          dwCurrent;
        DWORD                          dwCounters  = 0;
        BOOLEAN                        bValidBlock = TRUE;
        PPDHI_BINARY_LOG_RECORD_HEADER pCurrent;
        PPDHI_BINARY_LOG_RECORD_HEADER pMasterRec;

        pDataBlock = CurrentContext->LogInfo[i].DataBlock;
        pMasterRec = (PPDHI_BINARY_LOG_RECORD_HEADER) ((LPBYTE) pDataBlock + sizeof(GUID));
        dwTotal    = pMasterRec->dwLength;
        pCurrent   = pMasterRec;
        dwCurrent  = sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
        while (bValidBlock && dwCurrent < dwTotal) {
            pCurrent   = (PPDHI_BINARY_LOG_RECORD_HEADER) ((LPBYTE) pMasterRec + dwCurrent);
            if (LOWORD(pCurrent->dwType) != BINLOG_START_WORD) {
                bValidBlock = FALSE;
            }
            else {
                dwCurrent += pCurrent->dwLength;
                dwCounters ++;
            }
        }
        if (bValidBlock) {
            CurrentContext->LogInfo[i].ulCounters += dwCounters;
        }
    }

Cleanup:
    return Status;
}

PDH_FUNCTION
PdhiAddCounterPathRecord(
    PPDH_LOGGER_CONTEXT CurrentContext,
    PEVENT_TRACE        pEvent,
    LPGUID              pLogFileGuid,
    ULONG               BufferSize,
    PVOID               pBuffer,
    ULONGLONG           TimeStamp,
    DWORD               dwIndex,
    DWORD               dwCount,
    BOOLEAN           * pNeedUpdate
)
{
    PPDH_COUNTER_PATH pNewCounter;
    ULONG             i;
    PVOID             pCounterPath;

    i = PdhiFindLogFileGuid(CurrentContext, pLogFileGuid);
    if (i == CurrentContext->LoggerCount) {
        return PDH_INVALID_DATA;
    }

    if ( CurrentContext->LogInfo[i].DataBlock && CurrentContext->LogInfo[i].ulNumDataBlocks != dwCount) {
        G_FREE(CurrentContext->LogInfo[i].DataBlock);
        CurrentContext->LogInfo[i].DataBlock = NULL;
    }
    if (CurrentContext->LogInfo[i].DataBlock == NULL) {
        CurrentContext->LogInfo[i].DataBlock = G_ALLOC(PDH_BLOCK_BUFFER_SIZE * dwCount);
        if (CurrentContext->LogInfo[i].DataBlock == NULL) {
            return PDH_MEMORY_ALLOCATION_FAILURE;
        }
        CurrentContext->LogInfo[i].DataBlockAlloc     = PDH_BLOCK_BUFFER_SIZE * dwCount;
        CurrentContext->LogInfo[i].DataBlockSize      = 0;
        CurrentContext->LogInfo[i].ulNumDataBlocks    = dwCount;
        CurrentContext->LogInfo[i].ulDataBlocksCopied = 0;
    }

    pCounterPath = (PVOID) (((LPBYTE) CurrentContext->LogInfo[i].DataBlock)
                            + (dwIndex - 1) * PDH_BLOCK_BUFFER_SIZE);
    if (BufferSize > PDH_BLOCK_BUFFER_SIZE) {
        BufferSize = PDH_BLOCK_BUFFER_SIZE;
    }
    RtlCopyMemory(pCounterPath, pBuffer, BufferSize);
    CurrentContext->LogInfo[i].ulDataBlocksCopied ++;
    CurrentContext->LogInfo[i].DataBlockSize += BufferSize;

    if (CurrentContext->LogInfo[i].ulDataBlocksCopied < CurrentContext->LogInfo[i].ulNumDataBlocks) {
        return ERROR_SUCCESS;
    }

    pCounterPath = (PVOID) (((LPBYTE) CurrentContext->LogInfo[i].DataBlock) + sizeof(PDH_WMI_LOG_INFO));
    BufferSize   = CurrentContext->LogInfo[i].DataBlockSize - sizeof(PDH_WMI_LOG_INFO);

    if (! IsListEmpty(& CurrentContext->LogInfo[i].CounterPathList)) {
        PLIST_ENTRY PathHead = & CurrentContext->LogInfo[i].CounterPathList;
        PLIST_ENTRY PathNext = PathHead->Flink;

        while (PathHead != PathNext) {
            pNewCounter = CONTAINING_RECORD(PathNext, PDH_COUNTER_PATH, Entry);
            PathNext    = PathNext->Flink;
            if (TimeStamp == pNewCounter->TimeStamp) {
                // CounterPath record is already in the list
                //
                return ERROR_SUCCESS;
            }
        }
    }

    pNewCounter = G_ALLOC(sizeof(PDH_COUNTER_PATH));
    if (pNewCounter == NULL) {
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }

    pNewCounter->TimeStamp   = TimeStamp;
    pNewCounter->CounterPathBuffer = G_ALLOC(BufferSize);
    if (pNewCounter->CounterPathBuffer == NULL) {
        G_FREE(pNewCounter);
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }
    pNewCounter->CounterPathSize = BufferSize;
    RtlCopyMemory(pNewCounter->CounterPathBuffer, pCounterPath, BufferSize);

    pNewCounter->CounterCount = 0;
    {
        PPDHI_LOG_COUNTER_PATH pPath = pNewCounter->CounterPathBuffer;
        ULONG dwProcessed = 0;

        while (dwProcessed < BufferSize) {
            pNewCounter->CounterCount ++;
            dwProcessed += pPath->dwLength;
            pPath = (PPDHI_LOG_COUNTER_PATH) (((LPBYTE) pPath) + pPath->dwLength);
        }
    }

    InsertTailList(& CurrentContext->LogInfo[i].CounterPathList, & pNewCounter->Entry);
    * pNeedUpdate = TRUE;

    G_FREE(CurrentContext->LogInfo[i].DataBlock);
    CurrentContext->LogInfo[i].DataBlock          = NULL;
    CurrentContext->LogInfo[i].DataBlockAlloc     = 0;
    CurrentContext->LogInfo[i].DataBlockSize      = 0;
    CurrentContext->LogInfo[i].ulNumDataBlocks    = 0;
    CurrentContext->LogInfo[i].ulDataBlocksCopied = 0;

    return ERROR_SUCCESS;
}

PDH_FUNCTION
PdhiAddPerfMachine(
    PPDH_LOGGER_CONTEXT CurrentContext,
    PVOID               pMofDataBlock,
    DWORD               dwMofLength
)
{
    PDH_STATUS            Status         = ERROR_SUCCESS;
    LPGUID                pLogFileGuid   = (LPGUID) pMofDataBlock;
    LPWSTR                pszMachineName = (LPWSTR)
                                           (((LPBYTE) pMofDataBlock) + sizeof(GUID) + sizeof(DWORD) + sizeof(DWORD));
    DWORD                 dwBufSize      = dwMofLength - sizeof(GUID) - sizeof(DWORD) - sizeof(DWORD);
    ULONG                 i;
    LPWSTR                pszTmpBuffer;
    DWORD                 dwThisId;
    DWORD                 dwBufUsed;
    PPDH_WMI_PERF_MACHINE pCurrentMachine = NULL;
    BOOLEAN               bNewMachine     = TRUE;

    i = PdhiFindLogFileGuid(CurrentContext, pLogFileGuid);
    if (i == CurrentContext->LoggerCount) {
        Status = PDH_INVALID_DATA;
        goto Cleanup;
    }

    if (! IsListEmpty(& CurrentContext->LogInfo[i].PerfMachineList)) {
        PLIST_ENTRY pHead = & CurrentContext->LogInfo[i].PerfMachineList;
        PLIST_ENTRY pNext = pHead->Flink;
        while (pNext != pHead) {
            PPDH_WMI_PERF_MACHINE pMachine = CONTAINING_RECORD(pNext, PDH_WMI_PERF_MACHINE, Entry);
            if (lstrcmpiW(pMachine->pszBuffer, pszMachineName) == 0) {
                pCurrentMachine = pMachine;
                bNewMachine     = FALSE;
                break;
            }
            pNext = pNext->Flink;
        }
    }

    if (bNewMachine) {
        pCurrentMachine = G_ALLOC(sizeof(PDH_WMI_PERF_MACHINE));
        if (pCurrentMachine == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }
        InsertTailList(& CurrentContext->LogInfo[i].PerfMachineList, & pCurrentMachine->Entry);
        pCurrentMachine->pszBuffer = G_ALLOC(dwBufSize);
        if (pCurrentMachine->pszBuffer == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }
        RtlCopyMemory(pCurrentMachine->pszBuffer, pszMachineName, dwBufSize);
        pCurrentMachine->dwBufSize = dwBufSize;
        InitializeListHead(& pCurrentMachine->LogObjectList);
    }
    else {
        pszTmpBuffer    = pCurrentMachine->pszBuffer;
        dwBufSize      -= (sizeof(WCHAR) * (lstrlenW(pszMachineName) + 1));
        pszMachineName += (lstrlenW(pszMachineName) + 1);
        pCurrentMachine->pszBuffer = G_ALLOC(pCurrentMachine->dwBufSize + dwBufSize);
        if (pCurrentMachine->pszBuffer == NULL) {
            pCurrentMachine->pszBuffer = pszTmpBuffer;
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }
        RtlCopyMemory(pCurrentMachine->pszBuffer, pszTmpBuffer, pCurrentMachine->dwBufSize);
        G_FREE(pszTmpBuffer);
        pszTmpBuffer = (LPWSTR) (((LPBYTE) pCurrentMachine->pszBuffer) + pCurrentMachine->dwBufSize);
        RtlCopyMemory(pszTmpBuffer, pszMachineName, dwBufSize);
        pCurrentMachine->dwBufSize += dwBufSize;
    }
    dwBufSize = pCurrentMachine->dwBufSize;

    pCurrentMachine->dwLastId = 0;
    i            = lstrlenW(pCurrentMachine->pszBuffer) + 1;
    pszTmpBuffer = pCurrentMachine->pszBuffer + i;
    dwBufUsed    = sizeof(WCHAR) * i;
    while ((dwBufUsed < dwBufSize) && (* pszTmpBuffer)) {
        do {
            dwThisId = wcstoul(pszTmpBuffer, NULL, 10);
            if (dwThisId > pCurrentMachine->dwLastId) {
                pCurrentMachine->dwLastId = dwThisId;
            }
            i = lstrlenW(pszTmpBuffer) + 1;
            dwBufUsed += (sizeof(WCHAR) * i);
            if (dwBufUsed < dwBufSize) {
                pszTmpBuffer += i;
            }
        }
        while ((dwThisId == 0) && (* pszTmpBuffer) && dwBufUsed < dwBufSize);

        i = lstrlenW(pszTmpBuffer) + 1;
        dwBufUsed += (sizeof(WCHAR) * i);
        if ((* pszTmpBuffer) && (dwBufUsed < dwBufSize)) {
            pszTmpBuffer += i;
        }
    }

    if (pCurrentMachine->dwLastId == 0) {
        Status = PDH_CANNOT_READ_NAME_STRINGS;
        goto Cleanup;
    }

    if (! bNewMachine) {
        G_FREE(pCurrentMachine->ptrStrAry);
        pCurrentMachine->ptrStrAry = NULL;
    }
    pCurrentMachine->ptrStrAry = G_ALLOC(sizeof(LPWSTR) * (pCurrentMachine->dwLastId + 1));
    if (pCurrentMachine->ptrStrAry == NULL) {
        Status = PDH_CANNOT_READ_NAME_STRINGS;
        goto Cleanup;
    }

    i            = lstrlenW(pCurrentMachine->pszBuffer) + 1;
    pszTmpBuffer = pCurrentMachine->pszBuffer + i;
    dwBufUsed    = sizeof(WCHAR) * i;
    while ((dwBufUsed < dwBufSize) && (* pszTmpBuffer)) {
        do {
            dwThisId = wcstoul(pszTmpBuffer, NULL, 10);
            i = lstrlenW(pszTmpBuffer) + 1;
            dwBufUsed += (sizeof(WCHAR) * i);
            if (dwBufUsed < dwBufSize) {
                pszTmpBuffer += i;
            }
        }
        while ((dwThisId == 0) && (* pszTmpBuffer) && dwBufUsed < dwBufSize);

        if (dwThisId > 0 && dwThisId <= pCurrentMachine->dwLastId) {
            pCurrentMachine->ptrStrAry[dwThisId] = pszTmpBuffer;
        }

        i = lstrlenW(pszTmpBuffer) + 1;
        dwBufUsed += (sizeof(WCHAR) * i);
        if ((* pszTmpBuffer) && (dwBufUsed < dwBufSize)) {
            pszTmpBuffer += i;
        }
    }

Cleanup:
    if (Status != ERROR_SUCCESS) {
        if (bNewMachine) {
            if (pCurrentMachine != NULL) {
                G_FREE(pCurrentMachine->pszBuffer);
                RemoveEntryList(& pCurrentMachine->Entry);
                G_FREE(pCurrentMachine);
            }
        }
        else if (pCurrentMachine != NULL) {
            G_FREE(pCurrentMachine->pszBuffer);
            RemoveEntryList(& pCurrentMachine->Entry);
            G_FREE(pCurrentMachine);
        }
    }
    return Status;
}

PDH_FUNCTION
PdhiGetCounterPathRecord(
    PPDH_LOGGER_CONTEXT CurrentContext,
    PVOID               pRecord,
    ULONG               dwMaxSize
)
{
    PDH_STATUS Status = ERROR_SUCCESS;
    DWORD CurrentSize = sizeof(PDHI_BINARY_LOG_HEADER_RECORD);

    if (CurrentContext->bCounterPathChanged) {
        PPDHI_BINARY_LOG_HEADER_RECORD pBinLogHeader = NULL;
        PVOID pCounterPath;
        ULONG i;

        if (CurrentContext->CounterPathBuffer) {
            G_FREE(CurrentContext->CounterPathBuffer);
        }
        CurrentContext->CounterPathBuffer = G_ALLOC(CurrentSize);
        if (CurrentContext->CounterPathBuffer == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }

        for (i = 0; i < CurrentContext->LoggerCount; i ++) {
            if (! IsListEmpty(& CurrentContext->LogInfo[i].CounterPathList)) {
                PLIST_ENTRY  PathHead = & CurrentContext->LogInfo[i].CounterPathList;
                PLIST_ENTRY  PathNext = PathHead->Flink;
                PPDH_COUNTER_PATH pCurrentPath;

                while (Status == ERROR_SUCCESS && PathNext != PathHead) {
                    PVOID ptrTemp;

                    pCurrentPath = CONTAINING_RECORD(PathNext, PDH_COUNTER_PATH, Entry);
                    PathNext     = PathNext->Flink;

                    ptrTemp      = CurrentContext->CounterPathBuffer;
                    CurrentContext->CounterPathBuffer = G_REALLOC(ptrTemp, CurrentSize + pCurrentPath->CounterPathSize);
                    if (CurrentContext->CounterPathBuffer == NULL) {
                        G_FREE(ptrTemp);
                        Status = PDH_MEMORY_ALLOCATION_FAILURE;
                        goto Cleanup;
                    }

                    pCounterPath  = (PVOID) (((PUCHAR) CurrentContext->CounterPathBuffer) + CurrentSize);
                    RtlCopyMemory(pCounterPath, pCurrentPath->CounterPathBuffer, pCurrentPath->CounterPathSize);
                    CurrentSize += pCurrentPath->CounterPathSize;
                }
            }
        }
        pBinLogHeader = (PPDHI_BINARY_LOG_HEADER_RECORD) CurrentContext->CounterPathBuffer;
        RtlZeroMemory(pBinLogHeader, sizeof(PDHI_BINARY_LOG_HEADER_RECORD));
        pBinLogHeader->RecHeader.dwType  = BINLOG_TYPE_CATALOG_LIST;
        pBinLogHeader->Info.dwLogVersion = BINLOG_VERSION;

        pBinLogHeader->RecHeader.dwLength = CurrentSize;
        CurrentContext->bCounterPathChanged = FALSE;
    }
    else if (CurrentContext->CounterPathBuffer == NULL) {
        return PDH_ENTRY_NOT_IN_LOG_FILE;
    }
    else {
        CurrentSize = ((PPDHI_BINARY_LOG_HEADER_RECORD)
                        CurrentContext->CounterPathBuffer)->RecHeader.dwLength;
    }

    if (pRecord != NULL) {
        if (dwMaxSize < CurrentSize) {
            CurrentSize = dwMaxSize;
            Status = PDH_MORE_DATA;
        }
        RtlCopyMemory(pRecord, CurrentContext->CounterPathBuffer, CurrentSize);
    }

Cleanup:
    return Status;
}

PDH_FUNCTION
PdhWmiEnsureFirstRun(
    PPDH_LOGGER_CONTEXT CurrentContext
)
{
    PDH_STATUS Status = ERROR_SUCCESS;
    LONG       i;

    if (CurrentContext->LoggerState == PdhProcessTraceStart) {
        CurrentContext->LoggerState = PdhProcessTraceFirstPath;
        SetEvent(CurrentContext->hSyncWMI);
    }
    while (CurrentContext->LoggerState == PdhProcessTraceFirstPath) {
        Sleep(1);
    }

    for (i = 0; Status == ERROR_SUCCESS && i < (LONG) CurrentContext->LoggerCount; i ++) {
        if (IsListEmpty(& CurrentContext->LogInfo[i].CounterPathList)) {
            Status = PDH_BINARY_LOG_CORRUPT;
        }
        else if (CurrentContext->LogInfo[i].ValidEntries < 2) {
            Status = PDH_LOG_SAMPLE_TOO_SMALL;
        }
    }
    return Status;
}

ULONG
WINAPI
PdhWmiBufferCallback(
    PEVENT_TRACE_LOGFILEW LogFile
)
{
    ULONG               bResult = TRUE;
    PPDH_LOGGER_CONTEXT CurrentContext;

    UNREFERENCED_PARAMETER(LogFile);
    CurrentContext = GetCurrentContext();
    if (CurrentContext != NULL) {
        CurrentContext->dwBuffers ++;
        bResult  = (CurrentContext->LoggerState != PdhProcessTraceNormal
                                 && CurrentContext->LoggerState != PdhProcessTraceFirstPath)
                 ? (FALSE) : (TRUE);
    }
    return bResult;
}

void
WINAPI
PdhWmiEventCallback(
    PEVENT_TRACE pEvent
)
{
    LPGUID              pLogFileGuid;
    ULONG               iLogFile;
    BOOLEAN             bNotifyPDH      = FALSE;
    ULONGLONG           EventTime       = 0;
    ULONGLONG           EventTimePrev   = 0;
    DWORD               dwNumDataBlocks = 0;
    DWORD               dwBlockIndex    = 0;
    DWORD               dwBufferSize    = 0;
    PPDH_LOGGER_CONTEXT CurrentContext  = GetCurrentContext();

    if (pEvent == NULL || CurrentContext == NULL) {
        goto Cleanup;
    }
    else if (CurrentContext->LoggerState == PdhProcessTraceEnd
                            || CurrentContext->LoggerState == PdhProcessTraceExit
                            || CurrentContext->LoggerState == PdhProcessTraceRewind) {
        goto Cleanup;
    }
    else if (CurrentContext->LoggerState == PdhProcessTraceStart) {
        SetEvent(CurrentContext->hSyncPDH);
        WaitForSingleObject(CurrentContext->hSyncWMI, INFINITE);

        if (CurrentContext->LoggerState != PdhProcessTraceFirstPath) {
            goto Cleanup;
        }
    }

    if ((! IsEqualGUID(& pEvent->Header.Guid, & PdhTransactionGuid))) {
        goto Cleanup;
    }
    else if (CurrentContext->LoggerState != PdhProcessTraceFirstPath
                    && CurrentContext->LoggerState != PdhProcessTraceNormal) {
        goto Cleanup;
    }

    CurrentContext->dwEvents ++;

    switch (pEvent->Header.Class.Type) {
    case PDH_LOG_HEADER_EVENT:
        if (CurrentContext->LoggerState == PdhProcessTraceFirstPath) {
            DWORD dwCurrentBlock;
            DWORD dwTotalBlocks;
            DWORD dwMofHeader = sizeof(GUID) + sizeof(DWORD) + sizeof(DWORD);

            PdhiAddWmiLogFileGuid(CurrentContext, (LPGUID) pEvent->MofData);
            dwCurrentBlock = * (DWORD *) (((LPBYTE) pEvent->MofData) + sizeof(GUID));
            dwTotalBlocks  = * (DWORD *) (((LPBYTE) pEvent->MofData) + sizeof(GUID) + sizeof(DWORD));
            PdhiAddCounterPathRecord(CurrentContext,
                                     pEvent,
                                     (LPGUID) pEvent->MofData,
                                     pEvent->MofLength - dwMofHeader,
                                     (PVOID) (((PUCHAR) pEvent->MofData) + dwMofHeader),
                                     pEvent->Header.TimeStamp.QuadPart,
                                     dwCurrentBlock,
                                     dwTotalBlocks,
                                     & CurrentContext->bCounterPathChanged);
        }
        break;

    case PDH_LOG_COUNTER_STRING_EVENT:
        if (CurrentContext->LoggerState == PdhProcessTraceFirstPath) {
            PdhiAddWmiLogFileGuid(CurrentContext, (LPGUID) pEvent->MofData);
            PdhiAddPerfMachine(CurrentContext, pEvent->MofData, pEvent->MofLength);
        }
        break;

    case PDH_LOG_DATA_BLOCK_EVENT:
        if (CurrentContext->LoggerState == PdhProcessTraceFirstPath) {
            PdhiAddWmiLogFileGuid(CurrentContext, (LPGUID) pEvent->MofData);
            PdhWmiGetDataBlockTimeStamp(CurrentContext, pEvent, TRUE);
            PdhiWmiComputeCounterBlocks(CurrentContext, pEvent);
        }
        else {
            pLogFileGuid  = (LPGUID) pEvent->MofData;
            iLogFile      = PdhiFindLogFileGuid(CurrentContext, pLogFileGuid);

            if (iLogFile >= CurrentContext->LoggerCount) {
                break;
            }

            EventTimePrev = CurrentContext->LogInfo[iLogFile].TimePrev;
            EventTime     = PdhWmiGetDataBlockTimeStamp(CurrentContext, pEvent, FALSE);
            if (EventTime == 0 || EventTimePrev > EventTime) {
                break;
            }

            if (EventTimePrev < EventTime) {
                dwNumDataBlocks = * (DWORD *) (((LPBYTE) pEvent->MofData) + sizeof(GUID) + sizeof(DWORD));
                dwBufferSize = dwNumDataBlocks * PDH_BLOCK_BUFFER_SIZE + sizeof(GUID);

                if (CurrentContext->LogInfo[iLogFile].DataBlock == NULL) {
                    CurrentContext->LogInfo[iLogFile].DataBlock = G_ALLOC(dwBufferSize);
                }
                else if (CurrentContext->LogInfo[iLogFile].DataBlockAlloc < dwBufferSize) {
                    PVOID ptrTemp = CurrentContext->LogInfo[iLogFile].DataBlock;
                    CurrentContext->LogInfo[iLogFile].DataBlock = G_REALLOC(ptrTemp, dwBufferSize);
                    if (CurrentContext->LogInfo[iLogFile].DataBlock == NULL) {
                        G_FREE(ptrTemp);
                    }
                }
                if (CurrentContext->LogInfo[iLogFile].DataBlock != NULL) {
                    RtlCopyMemory(CurrentContext->LogInfo[iLogFile].DataBlock, pLogFileGuid, sizeof(GUID));
                    CurrentContext->LogInfo[iLogFile].DataBlockSize   = sizeof(GUID);
                    CurrentContext->LogInfo[iLogFile].DataBlockAlloc  = dwBufferSize;
                    CurrentContext->LogInfo[iLogFile].ulNumDataBlocks = dwNumDataBlocks;
                    CurrentContext->LogInfo[iLogFile].ulDataBlocksCopied = 0;
                }
            }

            dwBlockIndex = * (DWORD *) (((LPBYTE) pEvent->MofData) + sizeof(GUID));
            if (CurrentContext->LogInfo[iLogFile].DataBlock != NULL) {
                PVOID ptrDataBlock = (PVOID) (((LPBYTE) CurrentContext->LogInfo[iLogFile].DataBlock)
                                              + sizeof(GUID) + PDH_BLOCK_BUFFER_SIZE * (dwBlockIndex - 1));
                RtlCopyMemory(ptrDataBlock,
                              (PVOID) (((LPBYTE) pEvent->MofData) + sizeof(GUID) + sizeof(DWORD) + sizeof(DWORD)),
                              pEvent->MofLength - sizeof(GUID) - sizeof(DWORD) - sizeof(DWORD));
                CurrentContext->LogInfo[iLogFile].ulDataBlocksCopied ++;
                CurrentContext->LogInfo[iLogFile].DataBlockSize +=
                        pEvent->MofLength - sizeof(GUID) - sizeof(DWORD) - sizeof(DWORD);
            }

            if (CurrentContext->LogInfo[iLogFile].ulDataBlocksCopied
                            >= CurrentContext->LogInfo[iLogFile].ulNumDataBlocks) {
                if (DataBlockInfo.CurrentTime == (ULONGLONG) 0) {
                    // no CurrentTime comparison, just get the data block
                    //
                    DataBlockInfo.CurrentTime = EventTime;
                }

                if (DataBlockInfo.CurrentTime <= EventTime) {
                    DataBlockInfo.pRecord       = CurrentContext->LogInfo[iLogFile].DataBlock;
                    DataBlockInfo.dwCurrentSize = CurrentContext->LogInfo[iLogFile].DataBlockSize;
                    DataBlockInfo.Status        = ERROR_SUCCESS;
                    bNotifyPDH                  = TRUE;
                    CurrentContext->bDataBlockProcessed = FALSE;
                }
            }
        }
        break;

    default:
        TRACE((PDH_DBG_TRACE_WARNING),
              (__LINE__,
               PDH_LOGWMI,
               0,
               ERROR_SUCCESS,
               TRACE_DWORD(pEvent->Header.Class.Type),
               NULL));
        break;
    }

Cleanup:
    if (bNotifyPDH) {
        if (CurrentContext->bFirstRun) {
            CurrentContext->bFirstRun = FALSE;
        }
        else {
            // Signal that we get the current DataBlock event, then wait for next
            // DataBlock requests.
            //
            SetEvent(CurrentContext->hSyncPDH);
        }
        WaitForSingleObject(CurrentContext->hSyncWMI, INFINITE);
    }
}

PDH_FUNCTION
PdhiCacheWmiHeaderEvent(
    PPDH_LOGGER_CONTEXT pContext
)
{
    PDH_STATUS             Status  = ERROR_SUCCESS;
    DWORD                  dwIndex = 0;
    DWORD                  dwSize;
    DWORD                  dwProcess;
    PPDHI_LOG_COUNTER_PATH pPath;
    LPBYTE                 pString;
    LPWSTR                 szMachine;
    LPWSTR                 szObject;
    LPWSTR                 szCounter;
    LPWSTR                 szInstance;
    LPWSTR                 szParent;
    PPDHI_LOG_MACHINE      pMachine;
    PPDHI_LOG_OBJECT       pObject;
    PPDHI_LOG_COUNTER      pCounter;
    DWORD                  i;
    PLIST_ENTRY            pHead;
    PLIST_ENTRY            pNext;
    PPDH_COUNTER_PATH      pCtrPath;

    for (i = 0; i < pContext->LoggerCount; i ++) {
        if (! IsListEmpty(& pContext->LogInfo[i].CounterPathList)) {
            pHead = & pContext->LogInfo[i].CounterPathList;
            pNext = pHead->Flink;
            while (Status == ERROR_SUCCESS && pNext != pHead) {
                pCtrPath = CONTAINING_RECORD(pNext, PDH_COUNTER_PATH, Entry);
                pNext    = pNext->Flink;

                if (pCtrPath == NULL) continue;

                pPath     = (PPDHI_LOG_COUNTER_PATH) pCtrPath->CounterPathBuffer;
                dwSize    = pCtrPath->CounterPathSize;
                dwProcess = 0;

                while (pPath != NULL && dwProcess < dwSize) {
                    dwIndex ++;
                    pString   = (LPBYTE) & pPath->Buffer[0];
                    szMachine = (pPath->lMachineNameOffset >= 0)
                              ? (LPWSTR) (pString + pPath->lMachineNameOffset) : NULL;
                    szObject  = (pPath->lObjectNameOffset >= 0)
                              ? (LPWSTR) (pString + pPath->lObjectNameOffset) : NULL;

                    if (szMachine != NULL && szMachine[0] != L'\0' && szObject != NULL && szObject[0] != L'\0') {
                        if (pPath->dwFlags & PDHIC_COUNTER_OBJECT) {
                            pMachine = PdhiFindLogMachine(& pContext->LogInfo[i].MachineList, szMachine, TRUE);
                            if (pMachine != NULL) {
                                pObject = PdhiFindLogObject(pMachine, & pMachine->ObjTable, szObject, TRUE);
                                if (pObject != NULL) {
                                    pObject->bNeedExpand = TRUE;
                                    if (pObject->pObjData == NULL) {
                                        pObject->pObjData = (PPERF_OBJECT_TYPE)
                                                            G_ALLOC(sizeof(DWORD) * pContext->LoggerCount);
                                        pObject->dwIndex  = 0;
                                    }
                                    if (pObject->pObjData != NULL) {
                                        LPDWORD pdwCounter = (LPDWORD) pObject->pObjData;
                                        pObject->dwIndex = i;
                                        pdwCounter[i]    = dwIndex;
                                    }
                                }
                            }
                        }
                        else if (pPath->dwFlags & PDHIC_MULTI_INSTANCE) {
                            szCounter = (pPath->lCounterOffset >= 0)
                                      ? (LPWSTR) (pString + pPath->lCounterOffset) : NULL;
                            if (szCounter != NULL && szCounter[0] != L'\0') {
                                pCounter = PdhiFindLogCounter(NULL,
                                                              & pContext->LogInfo[i].MachineList,
                                                              szMachine,
                                                              szObject,
                                                              szCounter,
                                                              pPath->dwCounterType,
                                                              pPath->lDefaultScale,
                                                              NULL,
                                                              0,
                                                              NULL,
                                                              0,
                                                              & dwIndex,
                                                              TRUE);
                                if (pCounter != NULL) {
                                    pCounter->bMultiInstance = TRUE;
                                    if (pCounter->pCtrData == NULL) {
                                        pCounter->pCtrData    = (LPDWORD)
                                                                G_ALLOC(sizeof(DWORD) * pContext->LoggerCount);
                                        pCounter->dwCounterID = 0;
                                    }
                                    if (pCounter->pCtrData != NULL) {
                                        pCounter->dwCounterID = i;
                                        pCounter->pCtrData[i] = dwIndex;
                                    }
                                }
                            }
                        }
                        else {
                            szCounter  = (pPath->lCounterOffset >= 0)
                                       ? (LPWSTR) (pString + pPath->lCounterOffset)  : NULL;
                            szInstance = (pPath->lInstanceOffset >= 0)
                                       ? (LPWSTR) (pString + pPath->lInstanceOffset) : NULL;
                            szParent   = (pPath->lParentOffset >= 0)
                                       ? (LPWSTR) (pString + pPath->lParentOffset)   : NULL;
                            if (szCounter != NULL && szCounter[0] != L'\0') {
                                pCounter = PdhiFindLogCounter(NULL,
                                                              & pContext->LogInfo[i].MachineList,
                                                              szMachine,
                                                              szObject,
                                                              szCounter,
                                                              pPath->dwCounterType,
                                                              pPath->lDefaultScale,
                                                              szInstance,
                                                              pPath->dwIndex,
                                                              szParent,
                                                              0,
                                                              & dwIndex,
                                                              TRUE);
                                if (pCounter != NULL) {
                                    if (pCounter->pCtrData == NULL) {
                                        pCounter->pCtrData    = (LPDWORD)
                                                                G_ALLOC(sizeof(DWORD) * pContext->LoggerCount);
                                        pCounter->dwCounterID = 0;
                                    }
                                    if (pCounter->pCtrData != NULL) {
                                        pCounter->dwCounterID = i;
                                        pCounter->pCtrData[i] = dwIndex;
                                    }
                                }
                            }
                        }
                    }

                    dwProcess += pPath->dwLength;
                    pPath      = (dwProcess < dwSize)
                               ? (PPDHI_LOG_COUNTER_PATH) (((LPBYTE) pPath) + pPath->dwLength) : NULL;
                }
            }
        }
    }
    return Status;
}

PDH_FUNCTION
PdhProcessLog(
    PPDH_LOGGER_CONTEXT CurrentContext
)
{
    PDH_STATUS Status    = ERROR_SUCCESS;
    LONG       i;

    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        return PDH_INVALID_HANDLE;
    }
    CurrentContext->LoggerState = PdhProcessTraceStart;
    CurrentContext->bFirstRun   = TRUE;
    CurrentContext->dwThread    = GetCurrentThreadId();

    do {
        if (CurrentContext->LoggerState != PdhProcessTraceStart) {
            CurrentContext->LoggerState = PdhProcessTraceNormal;
        }
        CurrentContext->bFirstDataBlockRead = FALSE;
        CurrentContext->bDataBlockProcessed = FALSE;
        for (i = 0; i < (LONG) CurrentContext->LoggerCount; i ++) {
            CurrentContext->LogInfo[i].TimePrev = 0;
            if (CurrentContext->LogInfo[i].DataBlock) {
                G_FREE(CurrentContext->LogInfo[i].DataBlock);
                CurrentContext->LogInfo[i].DataBlock = NULL;
            }
            CurrentContext->LogInfo[i].DataBlockSize = 0;
        }

        RtlZeroMemory(& DataBlockInfo, sizeof(PDH_DATA_BLOCK_TRANSFER));
        CurrentContext->dwBuffers = CurrentContext->dwEvents = 0;
        Status = ProcessTrace(CurrentContext->LogFileHandle, CurrentContext->LogFileCount, NULL, NULL);
        if (Status != ERROR_SUCCESS && Status != ERROR_CANCELLED) {
            TRACE((PDH_DBG_TRACE_ERROR),
                  (__LINE__,
                   PDH_LOGWMI,
                   ARG_DEF(ARG_TYPE_PTR, 1),
                   Status,
                   TRACE_PTR(CurrentContext),
                   TRACE_DWORD(CurrentContext->LogFileCount),
                   NULL));
        }

        if (CurrentContext->LoggerState == PdhProcessTraceFirstPath) {
            Status = PdhiCacheWmiHeaderEvent(CurrentContext);
            CurrentContext->LoggerState = PdhProcessTraceRewind;
        }
        else if (CurrentContext->LoggerState == PdhProcessTraceNormal) {
            CurrentContext->LoggerState = PdhProcessTraceComplete;
            DataBlockInfo.Status = PDH_END_OF_LOG_FILE;

            // Wake up PDH main thread so that PdhiReadNextWmiRecord() will
            // notice END_OF_LOG_FILE condition. Wait PDH main thread to wake
            // me up and rewind logger. After wake up, LoggerState should
            // be reset to PdhProcessTraceNormal.
            //
            SetEvent(CurrentContext->hSyncPDH);
            Status = WaitForSingleObject(CurrentContext->hSyncWMI, INFINITE);
        }
    }
    while (CurrentContext->LoggerState == PdhProcessTraceRewind);

    for (i = 0; i < (LONG) CurrentContext->LogFileCount; i ++) {
        Status = CloseTrace(CurrentContext->LogFileHandle[i]);
        if (Status != ERROR_SUCCESS) {
            TRACE((PDH_DBG_TRACE_ERROR),
                  (__LINE__,
                   PDH_LOGWMI,
                   ARG_DEF(ARG_TYPE_ULONG64, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                   Status,
                   TRACE_LONG64(CurrentContext->LogFileHandle[i]),
                   TRACE_WSTR(CurrentContext->LogFileName[i]),
                   NULL));
        }
    }

    CurrentContext->LoggerState = PdhProcessTraceExit;
    return Status;
}

PDH_FUNCTION
PdhiOpenInputWmiLog(
    PPDHI_LOG pLog
)
{
    PDH_STATUS           Status         = ERROR_SUCCESS;
    PPDHI_LOG            pLogCurrent    = pLog;
    PPDH_LOGGER_CONTEXT  CurrentContext;
    EVENT_TRACE_LOGFILEW EvmFile;
    WCHAR                LogFileName[PDH_MAX_PATH];
    LONG                 i;
    DWORD                ThreadId;

    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (CurrentContext != NULL) {
        if (GetLoggerContext(CurrentContext) < ContextCount) {
            CurrentContext->RefCount ++;
            pLog->lpMappedFileBase = (PVOID) CurrentContext;
            return ERROR_SUCCESS;
        }
        else {
            TRACE((PDH_DBG_TRACE_ERROR),
                  (__LINE__,
                   PDH_LOGWMI,
                   ARG_DEF(ARG_TYPE_PTR, 1) | ARG_DEF(ARG_TYPE_PTR, 2)
                                            | ARG_DEF(ARG_TYPE_PTR, 3),
                   PDH_INVALID_ARGUMENT,
                   TRACE_PTR(pLog),
                   TRACE_PTR(pLog->lpMappedFileBase),
                   TRACE_PTR(CurrentContext),
                   NULL));
            return PDH_INVALID_ARGUMENT;
        }
    }

    CurrentContext = (PPDH_LOGGER_CONTEXT) G_ALLOC(sizeof(PDH_LOGGER_CONTEXT));
    if (CurrentContext == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }
    pLog->lpMappedFileBase = (PVOID) CurrentContext;
    RtlZeroMemory(CurrentContext, sizeof(PDH_LOGGER_CONTEXT));

    CurrentContext->bBulkProcess = (pLog->iRunidSQL != 0) ? TRUE : FALSE;

    for (i = 0; i < PDH_MAX_LOGFILES && pLogCurrent; i ++) {
        CurrentContext->LogFileName[i] = pLogCurrent->szLogFileName;
        pLogCurrent                    = pLogCurrent->NextLog;
    }
    CurrentContext->LogFileCount = i;
    CurrentContext->LoggerCount  = 0;

    for (i = 0; i < (LONG) CurrentContext->LogFileCount; i ++) {
        InitializeListHead(& CurrentContext->LogInfo[i].CounterPathList);
        InitializeListHead(& CurrentContext->LogInfo[i].PerfMachineList);
    }
    CurrentContext->RefCount = 1;
    CurrentContext->hSyncWMI = CreateEvent(NULL, FALSE, FALSE, NULL);
    CurrentContext->hSyncPDH = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (CurrentContext->hSyncWMI == NULL || CurrentContext->hSyncPDH == NULL) {
        Status = PDH_INVALID_HANDLE;
        goto Cleanup;
    }

    Status = WAIT_FOR_AND_LOCK_MUTEX(hPdhContextMutex);
    if (Status == ERROR_SUCCESS) {
        if (ContextCount < PDH_MAX_LOGFILES) {
            ContextTable[ContextCount] = CurrentContext;
            ContextCount ++;
        }
        else {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        RELEASE_MUTEX(hPdhContextMutex);
    }
    if (Status != ERROR_SUCCESS) {
        goto Cleanup;
    }

    for (i = 0; i < (LONG) CurrentContext->LogFileCount; i ++) {
        RtlZeroMemory(& EvmFile, sizeof(EVENT_TRACE_LOGFILE));
        EvmFile.BufferCallback = PdhWmiBufferCallback;
        EvmFile.EventCallback  = PdhWmiEventCallback;
        EvmFile.LogFileName    = LogFileName;
        _wfullpath(EvmFile.LogFileName, CurrentContext->LogFileName[i], PDH_MAX_PATH);
        CurrentContext->LogFileHandle[i] = OpenTraceW(& EvmFile);
        if (CurrentContext->LogFileHandle[i] == 0
                        || CurrentContext->LogFileHandle[i] == (TRACEHANDLE) INVALID_HANDLE_VALUE) {
            TRACE((PDH_DBG_TRACE_ERROR),
                  (__LINE__,
                   PDH_LOGWMI,
                   ARG_DEF(ARG_TYPE_WSTR, 1),
                   Status,
                   TRACE_WSTR(CurrentContext->LogFileName[i]),
                   TRACE_DWORD(i),
                   NULL));

            while (--i >= 0) {
                CloseTrace(CurrentContext->LogFileHandle[i]);
            }

            Status = PDH_LOG_FILE_OPEN_ERROR;
            goto Cleanup;
        }
    }

    CurrentContext->hThreadWork = CreateThread(NULL,
                                               0,
                                               (LPTHREAD_START_ROUTINE) PdhProcessLog,
                                               CurrentContext,
                                               0,
                                               (LPDWORD) & ThreadId);
    if (CurrentContext->hThreadWork == NULL) {
        Status = GetLastError();
        TRACE((PDH_DBG_TRACE_ERROR), (__LINE__, PDH_LOGWMI, 0, Status, NULL));
        for (i = 0; i < (LONG) CurrentContext->LogFileCount; i ++) {
            Status = CloseTrace(CurrentContext->LogFileHandle[i]);
            if (Status != ERROR_SUCCESS) {
                TRACE((PDH_DBG_TRACE_ERROR),
                      (__LINE__,
                       PDH_LOGWMI,
                       ARG_DEF(ARG_TYPE_ULONG64, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                       Status,
                       TRACE_LONG64(CurrentContext->LogFileHandle[i]),
                       TRACE_WSTR(CurrentContext->LogFileName[i]),
                       NULL));
            }
        }
        goto Cleanup;
    }
    WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);

Cleanup:
    if (Status != ERROR_SUCCESS) {
        if (pLog->lpMappedFileBase != NULL) {
            DWORD dwTmpLogFormat = pLog->dwLogFormat;
            pLog->dwLogFormat |= PDH_LOG_READ_ACCESS;
            PdhiCloseWmiLog(pLog, 0);
            pLog->dwLogFormat = dwTmpLogFormat;
        }
    }
    return Status;
}

PDH_FUNCTION
PdhiRewindWmiLog(
    PPDHI_LOG pLog
)
{
    PDH_STATUS          Status  = PDH_INVALID_HANDLE;
    PPDH_LOGGER_CONTEXT CurrentContext;

    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (GetLoggerContext(CurrentContext) < ContextCount) {
        if (CurrentContext->LoggerState != PdhProcessTraceStart
                && CurrentContext->LoggerState != PdhProcessTraceEnd
                && CurrentContext->LoggerState != PdhProcessTraceFirstPath) {
            CurrentContext->LoggerState = PdhProcessTraceRewind;
            SetEvent(CurrentContext->hSyncWMI);
            WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);
        }
        Status = ERROR_SUCCESS;
    }

    return Status;
}

PDH_FUNCTION
PdhiReadWmiHeaderRecord(
    PPDHI_LOG pLog,
    LPVOID    pRecord,
    DWORD     dwMaxSize
)
{
    PDH_STATUS          Status         = ERROR_SUCCESS;
    PPDH_LOGGER_CONTEXT CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;

    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        return PDH_INVALID_HANDLE;
    }

    // Wait until logfiles are scaned first to collect
    // 1) Counter Path information
    // 2) Time Range information
    //
    Status = PdhWmiEnsureFirstRun(CurrentContext);
    if (Status == ERROR_SUCCESS) {
        Status = PdhiGetCounterPathRecord(CurrentContext, pRecord, dwMaxSize);
        pLog->pLastRecordRead = CurrentContext->CounterPathBuffer;
    }
    return Status;
}

PDH_FUNCTION
PdhiBuildDataBlock(
    PPDHI_LOG pLog,
    ULONGLONG TimeStamp
)
{
    PDH_STATUS                     pdhStatus   = ERROR_SUCCESS;
    LONG                           Offset      = sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
    LONG                           CopySize;
    LONG                           CheckSize;
    ULONG                          i;
    LONG                           CurrentSize = PDH_WMI_BUFFER_SIZE_BYTE;
    PPDH_LOGGER_CONTEXT            CurrentContext;
    PPDHI_BINARY_LOG_RECORD_HEADER pHeader;
    PVOID                          pBlock;
    PPDHI_BINARY_LOG_RECORD_HEADER pCounterHeader;
    PPDH_RAW_COUNTER               pSingleCounter;
    PPDHI_LOG_COUNTER_PATH         pCounterPath;
    BOOLEAN                        bValidBlock;

    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        return PDH_INVALID_HANDLE;
    }

    if (CurrentContext->tmpBuffer != NULL) {
        G_FREE(CurrentContext->tmpBuffer);
        CurrentContext->tmpBuffer = NULL;
    }
    pHeader = (PPDHI_BINARY_LOG_RECORD_HEADER) G_ALLOC(PDH_WMI_BUFFER_SIZE_BYTE);
    if (pHeader == NULL) {
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }
    pHeader->dwType = BINLOG_TYPE_DATA;

    for (i = 0; i < CurrentContext->LoggerCount; i ++) {
        CopySize    = CurrentContext->LogInfo[i].DataBlockSize - sizeof(GUID) - sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
        bValidBlock = TRUE;
        if (Offset + CopySize > CurrentSize) {
            while (Offset + CopySize > CurrentSize) {
                CurrentSize += PDH_WMI_BUFFER_SIZE_BYTE;
            }
            CurrentContext->tmpBuffer = pHeader;
            pHeader = G_REALLOC(CurrentContext->tmpBuffer, CurrentSize);
            if (pHeader == NULL) {
                G_FREE(CurrentContext->tmpBuffer);
                CurrentContext->tmpBuffer = NULL;
                return PDH_MEMORY_ALLOCATION_FAILURE;
            }
            CurrentContext->tmpBuffer = NULL;
        }
        pBlock   = (PVOID) (((PUCHAR) pHeader) + Offset);

        if ((CurrentContext->LogInfo[i].DataBlock) && (CopySize > 0)
                        && (DataBlockInfo.CurrentTime <= CurrentContext->LogInfo[i].TimeEnd)) {
            CheckSize = sizeof(GUID);
            while (bValidBlock && CheckSize < CopySize) {
                pCounterHeader = (PPDHI_BINARY_LOG_RECORD_HEADER)
                        (((PUCHAR) CurrentContext->LogInfo[i].DataBlock) + CheckSize);
                if (LOWORD(pCounterHeader->dwType) == BINLOG_START_WORD) {
                    CheckSize += pCounterHeader->dwLength;
                }
                else {
                    bValidBlock = FALSE;
                }
            }
        }
        else {
            bValidBlock = FALSE;
        }

        if (bValidBlock == TRUE) {
            RtlCopyMemory(pBlock,
                          (PVOID) (((PUCHAR) CurrentContext->LogInfo[i].DataBlock) + sizeof(GUID)
                                                   + sizeof(PDHI_BINARY_LOG_RECORD_HEADER)),
                          CopySize);
            Offset += CopySize;
        }
        else {
            // need to sneak in pseudo counter block
            //
            PVOID pCounterBlock;
            ULONG BlockSize = 0;
            ULONG j;

            for (j = 0; j < CurrentContext->LogInfo[i].ulCounters; j ++) {
                pBlock       = (PVOID) (((PUCHAR) pHeader) + Offset);
                RtlCopyMemory(pBlock, & PdhNullCounterHeader, sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
                pSingleCounter = (PPDH_RAW_COUNTER) (((PUCHAR) pBlock) + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
                RtlCopyMemory(pSingleCounter, & PdhNullCounter, sizeof(PDH_RAW_COUNTER));
                pSingleCounter->TimeStamp.dwLowDateTime  = LODWORD(TimeStamp);
                pSingleCounter->TimeStamp.dwHighDateTime = HIDWORD(TimeStamp);
                Offset         = Offset + sizeof(PDH_RAW_COUNTER) + sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
            }
        }
    }
    pHeader->dwLength = Offset;
    CurrentContext->tmpBuffer = pHeader;

    return pdhStatus;
}

PDH_FUNCTION
PdhiReadNextWmiRecord(
    PPDHI_LOG pLog,
    LPVOID    pRecord,
    DWORD     dwMaxSize,
    BOOLEAN   bAllCounter
)
{
    PDH_STATUS          Status = ERROR_SUCCESS;
    PPDH_LOGGER_CONTEXT CurrentContext;
    ULONGLONG           CurrentTime;

    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        Status = PDH_INVALID_HANDLE;
        goto Cleanup;
    }

    // Wait until logfiles are scaned first to collect
    // 1) Counter Path information
    // 2) Time Range information
    //
    Status = PdhWmiEnsureFirstRun(CurrentContext);
    if (Status != ERROR_SUCCESS) {
        goto Cleanup;
    }

    if (CurrentContext->LoggerState == PdhProcessTraceComplete) {
        CurrentContext->LoggerState = PdhProcessTraceRewind;
        SetEvent(CurrentContext->hSyncWMI);
        WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);
        Status = PDH_END_OF_LOG_FILE;
        goto Cleanup;
    }

    if (! CurrentContext->bFirstDataBlockRead) {
        CurrentContext->bFirstDataBlockRead = TRUE;
        CurrentContext->bDataBlockProcessed = TRUE;
    }
    else if (! CurrentContext->bDataBlockProcessed) {
        CurrentContext->bDataBlockProcessed = TRUE;
    }
    else {
        DataBlockInfo.CurrentTime = (ULONGLONG) 0;
        SetEvent(CurrentContext->hSyncWMI);
        WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);
    }

    if (CurrentContext->LoggerState == PdhProcessTraceComplete) {
        CurrentContext->LoggerState = PdhProcessTraceRewind;
        SetEvent(CurrentContext->hSyncWMI);
        WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);
        Status = PDH_END_OF_LOG_FILE;
        goto Cleanup;
    }

    if (bAllCounter && CurrentContext->LogFileCount > 1) {
        CurrentTime = DataBlockInfo.CurrentTime;

        while ((CurrentContext->LoggerState != PdhProcessTraceComplete)
                        && (DataBlockInfo.CurrentTime - CurrentTime <= TIME_DELTA)) {
            DataBlockInfo.CurrentTime = (ULONGLONG) 0;
            SetEvent(CurrentContext->hSyncWMI);
            WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);
        }

        CurrentContext->bDataBlockProcessed = FALSE;
        Status = DataBlockInfo.Status;
        if (Status == ERROR_SUCCESS) {
            Status = PdhiBuildDataBlock(pLog, CurrentTime);
        }
        if (Status == ERROR_SUCCESS) {
            pLog->pLastRecordRead = CurrentContext->tmpBuffer;
        }
    }
    else {
        if (bAllCounter) {
            pLog->pLastRecordRead = (((PUCHAR) DataBlockInfo.pRecord) + sizeof(GUID));
        }
        else {
            pLog->pLastRecordRead = ((PUCHAR) DataBlockInfo.pRecord);
        }
        CurrentContext->bDataBlockProcessed = TRUE;
        Status = DataBlockInfo.Status;
        pLog->llFileSize = DataBlockInfo.CurrentTime;
    }

    if (Status == ERROR_SUCCESS) {
        if (dwMaxSize < DataBlockInfo.dwCurrentSize - sizeof(GUID)) {
            Status = PDH_MORE_DATA;
        }
        if (pRecord) {
            RtlCopyMemory(pRecord,
                          pLog->pLastRecordRead,
                          (Status == ERROR_SUCCESS) ? (DataBlockInfo.dwCurrentSize) : (dwMaxSize));
        }
    }

Cleanup:
    return Status;
}

PDH_FUNCTION
PdhiReadTimeWmiRecord(
    PPDHI_LOG pLog,
    ULONGLONG TimeStamp,
    LPVOID    pRecord,
    DWORD     dwMaxSize
)
{
    PDH_STATUS          Status      = ERROR_SUCCESS;
    PPDH_LOGGER_CONTEXT CurrentContext;
    BOOLEAN             TimeInRange = FALSE;
    BOOLEAN             bRewind     = TRUE;
    ULONG               i;

    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        Status = PDH_INVALID_HANDLE;
        goto Cleanup;
    }

    // Wait until logfiles are scaned first to collect
    // 1) Counter Path information
    // 2) Time Range information
    //
    Status = PdhWmiEnsureFirstRun(CurrentContext);
    if (Status != ERROR_SUCCESS) {
        goto Cleanup;
    }

    if (TimeStamp == MIN_TIME_VALUE) {
        TimeStamp = CurrentContext->LogInfo[0].TimeStart;
    }
    if (TimeStamp == MAX_TIME_VALUE) {
        TimeStamp = CurrentContext->LogInfo[0].TimeEnd;
    }
    for (i = 0; i < (ULONG) CurrentContext->LoggerCount; i ++) {
        if (TimeStamp >= CurrentContext->LogInfo[i].TimeStart && TimeStamp <= CurrentContext->LogInfo[i].TimeEnd) {
            TimeInRange = TRUE;
            break;
        }
    }

    if (! TimeInRange) {
        Status = PDH_INVALID_ARGUMENT;
        goto Cleanup;
    }

    if (CurrentContext->LoggerState == PdhProcessTraceComplete) {
        CurrentContext->LoggerState = PdhProcessTraceRewind;
        SetEvent(CurrentContext->hSyncWMI);
        WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);
        Status = PDH_END_OF_LOG_FILE;
        goto Cleanup;
    }

ReScan:
    if (! CurrentContext->bFirstDataBlockRead) {
        CurrentContext->bFirstDataBlockRead = TRUE;
        CurrentContext->bDataBlockProcessed = TRUE;
    }
    else if (! CurrentContext->bDataBlockProcessed) {
        CurrentContext->bDataBlockProcessed = TRUE;
    }
    else {
        DataBlockInfo.CurrentTime = 0;
        SetEvent(CurrentContext->hSyncWMI);
        WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);
    }

    if (CurrentContext->LoggerState == PdhProcessTraceComplete) {
        CurrentContext->LoggerState = PdhProcessTraceRewind;
        SetEvent(CurrentContext->hSyncWMI);
        WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);
        Status = PDH_END_OF_LOG_FILE;
        goto Cleanup;
    }
    else if (DataBlockInfo.CurrentTime > TimeStamp) {
        if (bRewind) {
            bRewind = FALSE;
            CurrentContext->LoggerState = PdhProcessTraceRewind;
            SetEvent(CurrentContext->hSyncWMI);
            WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);
            goto ReScan;
        }
    }

    while ((CurrentContext->LoggerState != PdhProcessTraceComplete)
                    && ((((LONGLONG) TimeStamp) - ((LONGLONG) DataBlockInfo.CurrentTime)) > TIME_DELTA)) {
        DataBlockInfo.CurrentTime = (ULONGLONG) 0;
        SetEvent(CurrentContext->hSyncWMI);
        WaitForSingleObject(CurrentContext->hSyncPDH, INFINITE);
    }

    CurrentContext->bDataBlockProcessed = TRUE;
    Status = DataBlockInfo.Status;
    if (Status == ERROR_SUCCESS) {
        Status = PdhiBuildDataBlock(pLog, TimeStamp);
    }
    if (Status == ERROR_SUCCESS) {
        pLog->pLastRecordRead = CurrentContext->tmpBuffer;
        pLog->llFileSize = DataBlockInfo.CurrentTime;
    }

    if (Status == ERROR_SUCCESS) {
        if (dwMaxSize < DataBlockInfo.dwCurrentSize - sizeof(GUID)) {
            Status = PDH_MORE_DATA;
        }
        if (pRecord) {
            RtlCopyMemory(pRecord,
                         (((PUCHAR) DataBlockInfo.pRecord) + sizeof(GUID)),
                         (Status == ERROR_SUCCESS) ? (DataBlockInfo.dwCurrentSize) : (dwMaxSize));
        }
    }

Cleanup:
    return Status;
}

PDH_FUNCTION
PdhiGetTimeRangeFromWmiLog(
    PPDHI_LOG      pLog,
    LPDWORD        pdwNumEntries,
    PPDH_TIME_INFO pInfo,
    LPDWORD        pdwBufferSize
)
{
    PDH_STATUS          Status = ERROR_SUCCESS;
    PPDH_LOGGER_CONTEXT CurrentContext;
    ULONG               i;
    ULONGLONG           StartTime;
    ULONGLONG           EndTime;
    ULONG               EntryCount;

    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        return PDH_INVALID_HANDLE;
    }

    // Wait until logfiles are scaned first to collect
    // 1) Counter Path information
    // 2) Time Range information
    //
    Status = PdhWmiEnsureFirstRun(CurrentContext);
    if (Status != ERROR_SUCCESS) {
        return Status;
    }

    for (StartTime  = CurrentContext->LogInfo[0].TimeStart,
                    EndTime    = CurrentContext->LogInfo[0].TimeEnd,
                    EntryCount = CurrentContext->LogInfo[0].ValidEntries,
                    i = 1;
            i < CurrentContext->LoggerCount;
            i ++) {
        if (StartTime == 0
                || (CurrentContext->LogInfo[i].TimeStart != 0 && StartTime > CurrentContext->LogInfo[i].TimeStart)) {
            StartTime = CurrentContext->LogInfo[i].TimeStart;
        }
        if (EndTime   < CurrentContext->LogInfo[i].TimeEnd)
            EndTime   = CurrentContext->LogInfo[i].TimeEnd;
        EntryCount   += CurrentContext->LogInfo[i].ValidEntries;
    }

    if (* pdwBufferSize >=  sizeof(PDH_TIME_INFO)) {
        * (LONGLONG *) (& pInfo->StartTime) = StartTime;
        * (LONGLONG *) (& pInfo->EndTime)   = EndTime;
        pInfo->SampleCount                  = EntryCount;
        * pdwBufferSize                     = sizeof(PDH_TIME_INFO);
        * pdwNumEntries                     = 1;
    }
    else {
        Status = PDH_MORE_DATA;
    }

    return Status;
}

PPDH_WMI_PERF_MACHINE
PdhWmiGetLogNameTable(
    PPDHI_LOG pLog,
    LPCWSTR   szMachineName,
    DWORD     dwLangId
)
{
    PPDH_WMI_PERF_MACHINE pReturnMachine = NULL;
    PPDH_LOGGER_CONTEXT   CurrentContext;
    DWORD                 i;

    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        return NULL;
    }

    for (i = 0; pReturnMachine == NULL && i < CurrentContext->LoggerCount; i ++) {
        if (! IsListEmpty(& CurrentContext->LogInfo[i].PerfMachineList)) {
            PLIST_ENTRY pHead = & CurrentContext->LogInfo[i].PerfMachineList;
            PLIST_ENTRY pNext = pHead->Flink;
            while (pNext != pHead) {
                PPDH_WMI_PERF_MACHINE pMachine = CONTAINING_RECORD(pNext, PDH_WMI_PERF_MACHINE, Entry);
                if (lstrcmpiW(pMachine->pszBuffer, szMachineName) == 0) {
                    pReturnMachine = pMachine;
                    break;
                }
                pNext = pNext->Flink;
            }
        }
    }
    return pReturnMachine;
}

PPDH_WMI_PERF_OBJECT
PdhWmiAddPerfObject(
    PPDHI_LOG        pLog,
    LPCWSTR          szMachineName,
    DWORD            dwLangId,
    LPCWSTR          szObjectName,
    DWORD            dwObjectId,
    PPERF_DATA_BLOCK pDataBlock
)
{
    PPDH_WMI_PERF_OBJECT  pPerfObject  = NULL;
    PPDH_WMI_PERF_MACHINE pPerfMachine = PdhWmiGetLogNameTable(pLog, szMachineName, dwLangId);
    PLIST_ENTRY           pHead;
    PLIST_ENTRY           pNext;
    PPDH_WMI_PERF_OBJECT  pCurrentObj;

    if (pPerfMachine == NULL) {
        SetLastError(PDH_ENTRY_NOT_IN_LOG_FILE);
        goto Cleanup;
    }

    pHead = & pPerfMachine->LogObjectList;
    pNext = pHead->Flink;
    while (pNext != pHead) {
        pCurrentObj = CONTAINING_RECORD(pNext, PDH_WMI_PERF_OBJECT, Entry);
        if (lstrcmpiW(pCurrentObj->szObjectName, szObjectName) == 0) {
            pPerfObject = pCurrentObj;
            break;
        }
        pNext = pNext->Flink;
    }

    if (pPerfObject != NULL) {
        goto Cleanup;
    }

    pPerfObject = G_ALLOC(sizeof(PDH_WMI_PERF_OBJECT));
    if (pPerfObject == NULL) {
        SetLastError(PDH_MEMORY_ALLOCATION_FAILURE);
        goto Cleanup;
    }
    pPerfObject->ptrBuffer = G_ALLOC(pDataBlock->TotalByteLength + sizeof(WCHAR) * (lstrlenW(szObjectName) + 1));
    if (pPerfObject->ptrBuffer == NULL) {
        G_FREE(pPerfObject);
        SetLastError(PDH_MEMORY_ALLOCATION_FAILURE);
        goto Cleanup;
    }
    pPerfObject->dwObjectId = dwObjectId;
    RtlCopyMemory(pPerfObject->ptrBuffer, pDataBlock, pDataBlock->TotalByteLength);
    pPerfObject->szObjectName = (LPWSTR) (((LPBYTE) pPerfObject->ptrBuffer) + pDataBlock->TotalByteLength);
    StringCchCopyW(pPerfObject->szObjectName, lstrlenW(szObjectName) + 1, szObjectName);
    InsertTailList(& pPerfMachine->LogObjectList, & pPerfObject->Entry);

Cleanup:
    return pPerfObject;
}

DWORD
PdhWmiGetLogPerfIndexByName(
    PPDHI_LOG pLog,
    LPCWSTR   szMachineName,
    DWORD     dwLangId,
    LPCWSTR   szNameBuffer
)
{
    PPDH_WMI_PERF_MACHINE pMachine;
    DWORD                 dwLastIndex;
    LPWSTR              * pNameArray;
    DWORD                 dwIndex;

    SetLastError(ERROR_SUCCESS);

    pMachine = PdhWmiGetLogNameTable(pLog, szMachineName, dwLangId);
    if (pMachine != NULL && pMachine->ptrStrAry != NULL) {
        dwLastIndex = pMachine->dwLastId;
        pNameArray  = pMachine->ptrStrAry;

        for (dwIndex = 1; dwIndex <= dwLastIndex; dwIndex ++) {
            if (lstrcmpiW(szNameBuffer, pNameArray[dwIndex]) == 0) {
                if ((dwIndex & 0x00000001) == 0) {
                    // counter name index should be even integer
                    //
                    break;
                }
            }
        }

        if (dwIndex > dwLastIndex) {
            SetLastError(PDH_STRING_NOT_FOUND);
            dwIndex = 0;
        }
    }
    else {
        SetLastError(PDH_ENTRY_NOT_IN_LOG_FILE);
        dwIndex = 0;
    }

    return dwIndex;
}

LPWSTR
PdhWmiGetLogPerfNameByIndex(
    PPDHI_LOG pLog,
    LPCWSTR   szMachineName,
    DWORD     dwLangId,
    DWORD     dwIndex
)
{
    PPDH_WMI_PERF_MACHINE pMachine;
    LPWSTR                pszReturnName = NULL;
    LPWSTR              * pNameArray;
    static WCHAR          szNumber[16];

    pMachine = PdhWmiGetLogNameTable(pLog, szMachineName, dwLangId);
    if (pMachine != NULL && pMachine->ptrStrAry != NULL && dwIndex < pMachine->dwLastId) {
        pNameArray    = pMachine->ptrStrAry;
        pszReturnName = pNameArray[dwIndex];
    }

    if (pszReturnName == NULL) {
        // unable to find name string, return numeric index string
        //
        ZeroMemory(szNumber, sizeof(szNumber));
        _ltow(dwIndex, szNumber, 10);
        pszReturnName = szNumber;
    }
    return pszReturnName;
}

PPDHI_BINARY_LOG_RECORD_HEADER
PdhiGetWmiSubRecord(
    PPDHI_LOG                      pLog,
    PPDHI_BINARY_LOG_RECORD_HEADER pRecord,
    DWORD                          dwRecordId,
    LPGUID                         LogFileGuid
)
{
    PPDHI_BINARY_LOG_RECORD_HEADER pThisRecord;
    PPDH_LOGGER_CONTEXT            CurrentContext;
    DWORD                          dwRecordType;
    DWORD                          dwRecordLength;
    DWORD                          dwBytesProcessed;
    DWORD                          dwThisSubRecordId;
    DWORD                          dwLocalIndex;
    ULONG                          i;

    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        return (NULL);
    }

    dwLocalIndex = dwRecordId;
    for (i = 0; i < CurrentContext->LoggerCount; i ++) {
        PLIST_ENTRY pHead = & CurrentContext->LogInfo[i].CounterPathList;
        if (! IsListEmpty(pHead)) {
            PLIST_ENTRY pNext = pHead->Flink;
            PPDH_COUNTER_PATH pCounterPath = CONTAINING_RECORD(pNext, PDH_COUNTER_PATH, Entry);
            if (dwLocalIndex <= pCounterPath->CounterCount) {
                break;
            }
            dwLocalIndex -= pCounterPath->CounterCount;
        }
    }

    __try {
        if ((i >= CurrentContext->LoggerCount)
                        || (! IsEqualGUID(LogFileGuid, & CurrentContext->LogInfo[i].LogFileGuid))) {
            // binary log record does not contain intended object's counter
            //
            return NULL;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }

    dwRecordType   = ((PPDHI_BINARY_LOG_RECORD_HEADER) pRecord)->dwType;
    dwRecordLength = ((PPDHI_BINARY_LOG_RECORD_HEADER) pRecord)->dwLength;

    pThisRecord = (PPDHI_BINARY_LOG_RECORD_HEADER) (((LPBYTE) pRecord) + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
    dwBytesProcessed = sizeof(PDHI_BINARY_LOG_RECORD_HEADER);

    if (dwBytesProcessed < dwRecordLength) {
        dwThisSubRecordId = 1;
        while (dwThisSubRecordId < dwLocalIndex) {
            if ((WORD)(pThisRecord->dwType & 0x0000FFFF) == BINLOG_START_WORD) {
                dwBytesProcessed += pThisRecord->dwLength;
                pThisRecord = (PPDHI_BINARY_LOG_RECORD_HEADER) (((LPBYTE)pThisRecord) + pThisRecord->dwLength);
                if (dwBytesProcessed >= dwRecordLength) {
                    break;
                }
                else {
                    dwThisSubRecordId ++;
                }
            }
            else {
                break;
            }
        }
    }
    else {
        dwThisSubRecordId = 0;
    }

    if (dwThisSubRecordId == dwLocalIndex) {
        if ((WORD)(pThisRecord->dwType & 0x0000FFFF) != BINLOG_START_WORD) {
            pThisRecord = NULL;
        }
    }
    else {
        pThisRecord = NULL;
    }

    return pThisRecord;
}

PDH_FUNCTION
PdhWmiEnumObjectItemsFromDataBlock(
    PPDHI_LOG          pLog,
    PPERF_DATA_BLOCK   pDataBlock,
    LPCWSTR            szMachineName,
    LPCWSTR            szObjectName,
    DWORD              dwObjectId,
    DWORD              dwLangId,
    PDHI_COUNTER_TABLE CounterTable
)
{
    PDH_STATUS                 Status         = ERROR_SUCCESS;
    PPERF_OBJECT_TYPE          pObjectDef     = GetObjectDefByTitleIndex(pDataBlock, dwObjectId);
    PPERF_COUNTER_DEFINITION   pCountDef;
    PPERF_INSTANCE_DEFINITION  pInstDef;
    DWORD                      dwItems;
    LPWSTR                     szItemName;
    DWORD                      dwItemLen;
    WCHAR                      szInstanceName[PDH_MAX_COUNTER_PATH];
    PPDHI_INST_LIST            pInstList      = NULL;
    PPDHI_INSTANCE             pInstance      = NULL;
    PPDHI_INST_LIST            pFirstInstList = NULL;

    PPDH_WMI_PERF_OBJECT pPerfObj;

    if (pObjectDef == NULL) {
        Status = PDH_ENTRY_NOT_IN_LOG_FILE;
        goto Cleanup;
    }
    pPerfObj = PdhWmiAddPerfObject(pLog, szMachineName, 9, szObjectName, dwObjectId, pDataBlock);
    if (pPerfObj == NULL) {
        Status = GetLastError();
        goto Cleanup;
    }

    pCountDef = FirstCounter(pObjectDef);
    if (pCountDef == NULL) {
        Status = PDH_NO_COUNTERS;
        goto Cleanup;
    }

    dwItems   = 0;
    while (pCountDef != NULL && dwItems < (DWORD) pObjectDef->NumCounters) {
        szItemName = PdhWmiGetLogPerfNameByIndex( pLog, szMachineName, dwLangId, pCountDef->CounterNameTitleIndex);
        Status = PdhiFindCounterInstList( CounterTable, szItemName, & pInstList);
        if (Status == ERROR_SUCCESS && pFirstInstList == NULL && pInstList != NULL) {
            pFirstInstList = pInstList;
        }
        dwItems ++;
        pCountDef  = NextCounter(pObjectDef, pCountDef);
    }

    if (pFirstInstList == NULL) {
        Status = PDH_NO_COUNTERS;
        goto Cleanup;
    }

    if (pObjectDef->NumInstances != PERF_NO_INSTANCES) {
        dwItems  = 0;
        pInstDef = FirstInstance(pObjectDef);
        while (pInstDef != NULL && dwItems < (DWORD) pObjectDef->NumInstances) {
            ZeroMemory(szInstanceName, sizeof(WCHAR) * PDH_MAX_COUNTER_PATH);
            dwItemLen = GetFullInstanceNameStr(pDataBlock, pObjectDef, pInstDef, szInstanceName, PDH_MAX_COUNTER_PATH);
            if (dwItemLen > 0) {
                Status = PdhiFindInstance(& pFirstInstList->InstList,
                                          szInstanceName,
                                          (lstrcmpiW(szInstanceName, gszTotal) == 0) ? FALSE : TRUE,
                                          & pInstance);
            }
            dwItems ++;
            pInstDef  = NextInstance(pObjectDef, pInstDef);
        }
    }

Cleanup:
    return Status;
}

PPERF_DATA_BLOCK
PdhWmiMergeObjectBlock(
    PPDHI_LOG                       pLog,
    LPWSTR                          szMachine,
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisMasterRecord,
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisSubRecord
)
{
    PPERF_DATA_BLOCK               pDataBlock  = (PPERF_DATA_BLOCK)
                                                 ((LPBYTE) pThisSubRecord + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
    DWORD                          dwType      = pThisMasterRecord->dwType;
    DWORD                          dwSize      = sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
    DWORD                          dwTotal     = pThisMasterRecord->dwLength;
    DWORD                          dwCopied    = 0;
    LPWSTR                         szLocalMachine;
    LPDWORD                        pdwMachine;
    LARGE_INTEGER                  PerfTime;
    LPDWORD                        pdwCopied;
    PPDHI_BINARY_LOG_RECORD_HEADER pThisRecord = NULL;
    PPERF_DATA_BLOCK               pRtnBlock   = NULL;
    PPERF_DATA_BLOCK               pBlock      = NULL;
    PPERF_OBJECT_TYPE              pObject     = NULL;

    PPDH_LOGGER_CONTEXT            CurrentContext;
    PPDHI_BINARY_LOG_HEADER_RECORD pBinLogHeader;
    DWORD                          dwCtrTotal;
    DWORD                          dwCtrSize;
    PPDHI_LOG_COUNTER_PATH         pPath;


    if (pLog->pPerfmonInfo != NULL) {
        szLocalMachine = (LPWSTR) (((LPBYTE) pLog->pPerfmonInfo) + sizeof(LARGE_INTEGER)
                                                                 + sizeof(LONGLONG) + sizeof(LONGLONG));
        if (lstrcmpiW(szLocalMachine, szMachine) != 0) {
            G_FREE(pLog->pPerfmonInfo);
            pLog->pPerfmonInfo = NULL;
        }
        else {
            RtlCopyMemory(& PerfTime, pLog->pPerfmonInfo, sizeof(LARGE_INTEGER));

            if (PerfTime.QuadPart != pDataBlock->PerfTime.QuadPart) {
                G_FREE(pLog->pPerfmonInfo);
                pLog->pPerfmonInfo = NULL;
            }
            else {
                dwCopied = * (LPDWORD) (((LPBYTE) pLog->pPerfmonInfo) + sizeof(LARGE_INTEGER));
                if (dwCopied != 0) {
                    pdwMachine = (LPDWORD) (((LPBYTE) pLog->pPerfmonInfo) + sizeof(LARGE_INTEGER) + sizeof(LONGLONG));
                    pDataBlock = (PPERF_DATA_BLOCK)
                                    (((LPBYTE) pdwMachine) + sizeof(LONGLONG) + (* pdwMachine));
                }
                goto Cleanup;
            }
        }
    }

    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        goto Cleanup;
    }

    pBinLogHeader = (PPDHI_BINARY_LOG_HEADER_RECORD) CurrentContext->CounterPathBuffer;
    if (pBinLogHeader == NULL) {
        goto Cleanup;
    }
    dwCtrTotal = pBinLogHeader->RecHeader.dwLength;
    dwCtrSize  = sizeof(PDHI_BINARY_LOG_HEADER_RECORD);
    pPath      = (PPDHI_LOG_COUNTER_PATH) (PPDHI_LOG_COUNTER_PATH) (((LPBYTE) pBinLogHeader) + dwCtrSize);

    dwCopied = QWORD_MULTIPLE((lstrlenW(szMachine) + 1) * sizeof(WCHAR));
    pLog->pPerfmonInfo = G_ALLOC(dwTotal + sizeof(LARGE_INTEGER) + sizeof(LONGLONG) + sizeof(LONGLONG) + dwCopied);
    if (pLog->pPerfmonInfo == NULL) goto Cleanup;

    pdwMachine     = (LPDWORD) (((LPBYTE) pLog->pPerfmonInfo) + sizeof(LARGE_INTEGER) + sizeof(LONGLONG));
    * pdwMachine   = dwCopied;
    szLocalMachine = (LPWSTR) (((LPBYTE) pdwMachine) + sizeof(LONGLONG));
    StringCbCopyW(szLocalMachine, dwCopied, szMachine);

    pRtnBlock = (PPERF_DATA_BLOCK) (((LPBYTE) szLocalMachine) + dwCopied);
    dwCopied  = 0;

    if (dwSize >= dwTotal) {
        pThisRecord = NULL;
    }
    else {
        pThisRecord = (PPDHI_BINARY_LOG_RECORD_HEADER)
                      (((LPBYTE) pThisMasterRecord) + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
    }

    while (pThisRecord != NULL) {
        dwSize += pThisRecord->dwLength;
        if (pThisRecord->dwLength > 0 && (WORD)(pThisRecord->dwType & 0x0000FFFF) == BINLOG_START_WORD) {
            szLocalMachine = (pPath->lMachineNameOffset != 0xFFFFFFFF)
                           ? (LPWSTR) (((LPBYTE) & (pPath->Buffer[0])) + pPath->lMachineNameOffset)
                           : szMachine;
            if (lstrcmpiW(szLocalMachine, szMachine) == 0) {
                if (pThisRecord->dwType == BINLOG_TYPE_DATA_LOC_OBJECT) {
                    pBlock = (PPERF_DATA_BLOCK) (((LPBYTE) pThisRecord) + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
                    if (dwCopied == 0) {
                        RtlCopyMemory(pRtnBlock, pBlock, pBlock->TotalByteLength);
                        dwCopied = pBlock->TotalByteLength;
                    }
                    else {
                        PPERF_OBJECT_TYPE pEndObject = (PPERF_OBJECT_TYPE) (((LPBYTE) pBlock) + pBlock->TotalByteLength);

                        pObject = FirstObject(pBlock);
                        if ((pObject != NULL) && (pObject < pEndObject)
                                              && (pObject->TotalByteLength < pBlock->TotalByteLength)) {
                            RtlCopyMemory((((LPBYTE) pRtnBlock) + dwCopied), pObject, pObject->TotalByteLength);
                            dwCopied += pObject->TotalByteLength;
                            pRtnBlock->TotalByteLength = dwCopied;
                            pRtnBlock->NumObjectTypes ++;
                        }
                    }
                }
            }

            dwCtrSize += pPath->dwLength;
            if (dwCtrSize >= dwCtrTotal) {
                pThisRecord = NULL;
            }
            else if (dwSize >= dwTotal) {
                pThisRecord = NULL;
            }
            else {
                pPath       = (PPDHI_LOG_COUNTER_PATH) (((LPBYTE) pPath) + pPath->dwLength);
                pThisRecord = (PPDHI_BINARY_LOG_RECORD_HEADER) (((LPBYTE) pThisRecord) + pThisRecord->dwLength);
            }
        }
        else {
            pThisRecord = NULL;
        }
    }

    pdwCopied   = (LPDWORD) (((LPBYTE) pLog->pPerfmonInfo) + sizeof(LARGE_INTEGER));
    * pdwCopied = dwCopied;

    if (dwCopied == 0) {
        G_FREE(pRtnBlock);
    }
    else {
        RtlCopyMemory(pLog->pPerfmonInfo, & pRtnBlock->PerfTime, sizeof(LARGE_INTEGER));
        pDataBlock = pRtnBlock;
    }

Cleanup:
    return pDataBlock;
}

PDH_FUNCTION
PdhiEnumMachinesFromWmiLog(
    PPDHI_LOG   pLog,
    LPVOID      pBuffer,
    LPDWORD     lpdwBufferSize,
    BOOL        bUnicodeDest
)
{
    PDH_STATUS          Status          = ERROR_SUCCESS;
    PPDH_LOGGER_CONTEXT CurrentContext  = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    DWORD               dwBufferUsed    = 0;
    DWORD               dwNewBuffer     = 0;
    DWORD               dwItemCount     = 0;
    LPVOID              LocalBuffer     = NULL;
    LPVOID              TempBuffer      = NULL;
    DWORD               LocalBufferSize = 0;
    PPDHI_LOG_MACHINE   pMachine;
    DWORD               dwLogger;

    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        Status = PDH_INVALID_ARGUMENT;
    }
    else {
        Status = PdhWmiEnsureFirstRun(CurrentContext);
        if (Status == ERROR_SUCCESS) {
            LocalBufferSize = MEDIUM_BUFFER_SIZE;
            LocalBuffer     = G_ALLOC(LocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
            if (LocalBuffer == NULL) {
                Status = PDH_MEMORY_ALLOCATION_FAILURE;
                goto Cleanup;
            }

            dwItemCount  = 0;
            dwBufferUsed = 0;
            dwItemCount  = 0;
            for (dwLogger = 0; dwLogger < CurrentContext->LoggerCount; dwLogger ++) {
                for (pMachine = CurrentContext->LogInfo[dwLogger].MachineList;
                                                pMachine != NULL; pMachine = pMachine->next) {
                    if (pMachine->szMachine != NULL) {
                        dwNewBuffer = lstrlenW(pMachine->szMachine) + 1;
                        while (LocalBufferSize  < (dwBufferUsed + dwNewBuffer)) {
                            TempBuffer       = LocalBuffer;
                            LocalBufferSize += MEDIUM_BUFFER_SIZE;
                            LocalBuffer      = G_REALLOC(TempBuffer,
                                                    LocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
                            if (LocalBuffer == NULL) {
                                if (TempBuffer != NULL) G_FREE(TempBuffer);
                                Status = PDH_MEMORY_ALLOCATION_FAILURE;
                                goto Cleanup;
                            }
                        }
                        Status = AddUniqueWideStringToMultiSz((LPVOID) LocalBuffer,
                                                                 pMachine->szMachine,
                                                                 LocalBufferSize - dwBufferUsed,
                                                                 & dwNewBuffer,
                                                                 bUnicodeDest);
                        if (Status == ERROR_SUCCESS) {
                            if (dwNewBuffer > 0) {
                                dwBufferUsed = dwNewBuffer;
                                dwItemCount ++;
                            }
                        }
                        else {
                            // PDH_MORE_DATA should not happen because we enlarge buffer before
                            // AddUniqueWideStringToMultiSz() call.
                            if (Status == PDH_MORE_DATA) Status = PDH_INVALID_DATA;
                            break;
                        }
                    }
                    else {
                        dwNewBuffer = 0;
                    }
                }
            }
        }
    }

    if (Status == ERROR_SUCCESS) {
        if (dwItemCount > 0) {
            dwBufferUsed ++;
        }
        if (pBuffer && (dwBufferUsed <= * lpdwBufferSize)) {
            RtlCopyMemory(pBuffer, LocalBuffer, dwBufferUsed * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
        }
        else {
            if (pBuffer) RtlCopyMemory(pBuffer,
                                       LocalBuffer,
                                       (* lpdwBufferSize) * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
            Status = PDH_MORE_DATA;
        }
        * lpdwBufferSize = dwBufferUsed;
    }

Cleanup:
    if (LocalBuffer != NULL) G_FREE(LocalBuffer);
    return Status;
}

PDH_FUNCTION
PdhiEnumObjectsFromWmiLog(
    PPDHI_LOG pLog,
    LPCWSTR   szMachineName,
    LPVOID    pBuffer,
    LPDWORD   pcchBufferSize,
    DWORD     dwDetailLevel,
    BOOL      bUnicodeDest
)
{
    PDH_STATUS          Status           = ERROR_SUCCESS;
    PPDH_LOGGER_CONTEXT CurrentContext   = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    DWORD               dwBufferUsed     = 0;
    DWORD               dwNewBuffer      = 0;
    DWORD               dwItemCount      = 0;
    LPVOID              LocalBuffer      = NULL;
    LPVOID              TempBuffer       = NULL;
    DWORD               LocalBufferSize  = 0;
    PPDHI_LOG_MACHINE   pMachine         = NULL;
    PPDHI_LOG_OBJECT    pObject          = NULL;
    LPWSTR              szLocMachine     = (LPWSTR) szMachineName;
    DWORD               dwLogger;
    BOOL                bNoMachine       = TRUE;

    UNREFERENCED_PARAMETER(dwDetailLevel);

    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        Status = PDH_INVALID_ARGUMENT;
    }
    else {
        Status = PdhWmiEnsureFirstRun(CurrentContext);
        if (Status == ERROR_SUCCESS) {

            LocalBufferSize = MEDIUM_BUFFER_SIZE;
            LocalBuffer     = G_ALLOC(LocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
            if (LocalBuffer == NULL) {
                Status = PDH_MEMORY_ALLOCATION_FAILURE;
                goto Cleanup;
            }

            if (szLocMachine == NULL) szLocMachine = (LPWSTR) szStaticLocalMachineName;

            dwBufferUsed = 0;
            dwNewBuffer  = 0;
            dwItemCount  = 0;

            for (dwLogger = 0; dwLogger < CurrentContext->LoggerCount; dwLogger ++) {
                for (pMachine = CurrentContext->LogInfo[dwLogger].MachineList;
                                                    pMachine != NULL; pMachine = pMachine->next) {
                    if (lstrcmpiW(pMachine->szMachine, szLocMachine) == 0) break;
                }
                if (pMachine == NULL) continue;

                bNoMachine   = FALSE;
                for (pObject = pMachine->ObjList; pObject != NULL; pObject = pObject->next) {
                    if (pObject->szObject != NULL) {
                        dwNewBuffer = (lstrlenW(pObject->szObject) + 1);
                        while (LocalBufferSize  < (dwBufferUsed + dwNewBuffer)) {
                            LocalBufferSize += MEDIUM_BUFFER_SIZE;
                            TempBuffer       = LocalBuffer;
                            LocalBuffer      = G_REALLOC(TempBuffer,
                                                 LocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
                            if (LocalBuffer == NULL) {
                                if (TempBuffer != NULL) G_FREE(TempBuffer);
                                Status = PDH_MEMORY_ALLOCATION_FAILURE;
                                goto Cleanup;
                            }
                        }
                        Status = AddUniqueWideStringToMultiSz((LPVOID) LocalBuffer,
                                                              pObject->szObject,
                                                              LocalBufferSize - dwBufferUsed,
                                                              & dwNewBuffer,
                                                              bUnicodeDest);
                        if (Status == ERROR_SUCCESS) {
                            if (dwNewBuffer > 0) {
                                dwBufferUsed = dwNewBuffer;
                                dwItemCount ++;
                            }
                        }
                        else {
                            // PDH_MORE_DATA should not happen because we enlarge buffer before
                            // AddUniqueWideStringToMultiSz() call.
                            if (Status == PDH_MORE_DATA) Status = PDH_INVALID_DATA;
                            break;
                        }
                    }
                    else {
                        dwNewBuffer = 0;
                    }
                }
            }
        }
    }

    if (Status == ERROR_SUCCESS) {
        if (bNoMachine) {
            Status = PDH_CSTATUS_NO_MACHINE;
        }
        else if (dwItemCount == 0) {
            Status = PDH_CSTATUS_NO_OBJECT;
        }
        else {
            dwBufferUsed ++;
        }
        if (Status == ERROR_SUCCESS && dwBufferUsed > 0) {
            if (pBuffer && (dwBufferUsed <= * pcchBufferSize)) {
                RtlCopyMemory(pBuffer, LocalBuffer, dwBufferUsed * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
            }
            else {
                if (pBuffer) RtlCopyMemory(pBuffer,
                                           LocalBuffer,
                                           (* pcchBufferSize) * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
                Status = PDH_MORE_DATA;
            }
        }
        * pcchBufferSize = dwBufferUsed;
    }

Cleanup:
    G_FREE(LocalBuffer);
    return Status;
}

PDH_FUNCTION
PdhiEnumObjectItemsFromWmiLog(
    PPDHI_LOG          pLog,
    LPCWSTR            szMachineName,
    LPCWSTR            szObjectName,
    PDHI_COUNTER_TABLE CounterTable,
    DWORD              dwDetailLevel,
    DWORD              dwFlags
)
{
    DWORD                          dwTempBufferSize;
    LPVOID                         pTempBuffer             = NULL;
    LPVOID                         ptrTemp;
    PDH_STATUS                     pdhStatus               = ERROR_SUCCESS;
    PPDHI_LOG_COUNTER_PATH         pPath;
    PPDHI_BINARY_LOG_RECORD_HEADER pThisMasterRecord;
    PPDHI_BINARY_LOG_RECORD_HEADER pThisSubRecord;
    PPDHI_RAW_COUNTER_ITEM_BLOCK   pDataBlock;
    PPDHI_RAW_COUNTER_ITEM         pDataItem;
    DWORD                          dwBytesProcessed;
    LONG                           nItemCount              = 0;
    LPBYTE                         pFirstChar;
    LPWSTR                         szThisMachineName       = NULL;
    LPWSTR                         szThisObjectName        = NULL;
    LPWSTR                         szThisCounterName       = NULL;
    LPWSTR                         szThisInstanceName      = NULL;
    LPWSTR                         szThisParentName;
    WCHAR                          szCompositeInstance[PDH_MAX_COUNTER_PATH];
    DWORD                          dwRecordLength;
    BOOL                           bCopyThisObject;
    BOOL                           bInstanceListScanned    = FALSE;
    DWORD                          dwIndex;
    DWORD                          dwDataItemIndex;
    DWORD                          dwObjectId;
    PPERF_DATA_BLOCK               pPerfBlock;
    PPDHI_INST_LIST                pInstList               = NULL;
    PPDHI_INSTANCE                 pInstance               = NULL;
    PPDH_LOGGER_CONTEXT            CurrentContext;

    UNREFERENCED_PARAMETER(dwDetailLevel);
    UNREFERENCED_PARAMETER(dwFlags);

    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (GetLoggerContext(CurrentContext) >= ContextCount) {
        pdhStatus = PDH_INVALID_ARGUMENT;
        goto Cleanup;
    }

    if (pLog->dwMaxRecordSize == 0) {
        // no size is defined so start with 64K
        pLog->dwMaxRecordSize = 0x010000;
    }

    dwTempBufferSize = pLog->dwMaxRecordSize;
    pTempBuffer = G_ALLOC(dwTempBufferSize);
    if (pTempBuffer == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    // read in the catalog record

    pdhStatus = PdhiReadWmiHeaderRecord(pLog, pTempBuffer, dwTempBufferSize);
    while (pdhStatus == PDH_MORE_DATA) {
        if (* (WORD *) pTempBuffer == BINLOG_START_WORD) {
            dwTempBufferSize = ((DWORD *) pTempBuffer)[1];
            if (dwTempBufferSize < pLog->dwMaxRecordSize) {
                pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
            }
            else {
                pLog->dwMaxRecordSize = dwTempBufferSize;
            }
        }
        else {
            pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
        }

        ptrTemp     = pTempBuffer;
        pTempBuffer = G_REALLOC(ptrTemp, dwTempBufferSize);
        if (pTempBuffer == NULL) {
            G_FREE(ptrTemp);
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        if (pdhStatus == PDH_MORE_DATA) {
            pdhStatus = PdhiReadWmiHeaderRecord(pLog, pTempBuffer, dwTempBufferSize);
        }
    }

    if (pdhStatus != ERROR_SUCCESS) {
        goto Cleanup;
    }

    dwRecordLength = ((PPDHI_BINARY_LOG_RECORD_HEADER) pTempBuffer)->dwLength;
    pPath = (PPDHI_LOG_COUNTER_PATH) ((LPBYTE) pTempBuffer + sizeof(PDHI_BINARY_LOG_HEADER_RECORD));
    dwBytesProcessed = sizeof(PDHI_BINARY_LOG_HEADER_RECORD);

    dwIndex = 0;
    while (dwBytesProcessed < dwRecordLength) {
        bCopyThisObject  = FALSE;
        szThisObjectName = NULL;
        dwIndex ++;
        pFirstChar       = (LPBYTE) & pPath->Buffer[0];

        if (pPath->lMachineNameOffset >= 0L) {
            szThisMachineName = (LPWSTR) ((LPBYTE) pFirstChar + pPath->lMachineNameOffset);
            if (lstrcmpiW(szThisMachineName, szMachineName) == 0) {
                if (pPath->lObjectNameOffset >= 0) {
                    szThisObjectName = (LPWSTR) ((LPBYTE) pFirstChar + pPath->lObjectNameOffset);
                    if (lstrcmpiW(szThisObjectName, szObjectName) == 0) {
                        bCopyThisObject = TRUE;
                    }
                }
            }
        }
        else if (pPath->lObjectNameOffset >= 0) {
            szThisObjectName = (LPWSTR) ((LPBYTE) pFirstChar + pPath->lObjectNameOffset);
            if (lstrcmpiW(szThisObjectName, szObjectName) == 0) {
                bCopyThisObject = TRUE;
            }
        }

        dwObjectId = 0;
        if (bCopyThisObject) {
            if (pPath->dwFlags & PDHIC_COUNTER_OBJECT) {
                dwObjectId = PdhWmiGetLogPerfIndexByName(pLog, szMachineName, 9, szObjectName);
                if (dwObjectId == 0) {
                    dwObjectId = wcstoul(szObjectName, NULL, 10);
                    if (dwObjectId == 0) {
                        szThisCounterName = NULL;
                        bCopyThisObject   = FALSE;
                    }
                }
            }
            else if (pPath->lCounterOffset > 0) {
                szThisCounterName = (LPWSTR) ((LPBYTE) pFirstChar + pPath->lCounterOffset);
            }
            else {
                szThisCounterName = NULL;
                bCopyThisObject   = FALSE;
            }
        }

        if (bCopyThisObject) {
            if (dwObjectId == 0) {
                pdhStatus = PdhiFindCounterInstList(CounterTable, szThisCounterName, & pInstList);
                if (pdhStatus == ERROR_SUCCESS && pInstList != NULL) {
                    nItemCount ++;
                }
            }

            if (pPath->lInstanceOffset >= 0) {
                szThisInstanceName = (LPWSTR) ((LPBYTE) pFirstChar + pPath->lInstanceOffset);
            }

            if (dwObjectId > 0 || (pInstList != NULL && szThisInstanceName != NULL)) {
                if (szThisInstanceName && * szThisInstanceName != SPLAT_L) {
                    if (pPath->lParentOffset >= 0) {
                        szThisParentName = (LPWSTR) ((LPBYTE) pFirstChar + pPath->lParentOffset);
                        StringCchPrintfW(szCompositeInstance, PDH_MAX_COUNTER_PATH, L"%ws%ws%ws",
                                        szThisParentName, cszSlash, szThisInstanceName);
                    }
                    else {
                        StringCchCopyW(szCompositeInstance, PDH_MAX_COUNTER_PATH, szThisInstanceName);
                    }

                    if (pPath->dwIndex > 0 && pPath->dwIndex != PERF_NO_UNIQUE_ID) {
                            StringCchCatW(szCompositeInstance, PDH_MAX_COUNTER_PATH, L"#");
                            _ltow(pPath->dwIndex, (LPWSTR)(szCompositeInstance + lstrlenW(szCompositeInstance)), 10L);
                    }
                    pdhStatus = PdhiFindInstance(& pInstList->InstList,
                                                 szCompositeInstance,
                                                 (lstrcmpiW(szCompositeInstance, gszTotal) == 0) ? FALSE : TRUE,
                                                 & pInstance);
                    if (pdhStatus == ERROR_SUCCESS && pInstance != NULL) {
                        nItemCount ++;
                    }
                }
                else if (dwObjectId > 0 || !bInstanceListScanned) {
                    pdhStatus = PdhiRewindWmiLog(pLog);
                    if (pdhStatus == ERROR_SUCCESS) {
                        pdhStatus = PdhiReadNextWmiRecord(pLog, NULL, 0, FALSE);
                        while (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
                            PdhiResetInstanceCount(CounterTable);
                            pdhStatus = ERROR_SUCCESS;
                            pThisMasterRecord = (PPDHI_BINARY_LOG_RECORD_HEADER)
                                                (((PUCHAR) pLog->pLastRecordRead) + sizeof(GUID));
                            pThisSubRecord = PdhiGetWmiSubRecord(
                                    pLog, pThisMasterRecord, dwIndex, (LPGUID)(pLog->pLastRecordRead));
                            if (pThisSubRecord == NULL) {
                                // this data record does not contain
                                // counter record for selected object,
                                // skip to next one.
                                //
                                pdhStatus = PdhiReadNextWmiRecord(pLog, NULL, 0, FALSE);
                                continue;
                            }

                            if (pThisSubRecord->dwType == BINLOG_TYPE_DATA_LOC_OBJECT) {
                                PPERF_DATA_BLOCK pTmpBlock = (PPERF_DATA_BLOCK)
                                        ((LPBYTE) pThisSubRecord + sizeof(PDHI_BINARY_LOG_RECORD_HEADER));
                                pPerfBlock = PdhWmiMergeObjectBlock(
                                                pLog, (LPWSTR) szMachineName, pThisMasterRecord, pThisSubRecord);
                                pdhStatus = PdhWmiEnumObjectItemsFromDataBlock(
                                        pLog, pPerfBlock, szMachineName, szObjectName, dwObjectId, 9, CounterTable);
                                if (pdhStatus == PDH_ENTRY_NOT_IN_LOG_FILE) {
                                    pdhStatus = ERROR_SUCCESS;
                                }
                            }
                            else {
                                pDataBlock = (PPDHI_RAW_COUNTER_ITEM_BLOCK)
                                             ((LPBYTE)pThisSubRecord + sizeof (PDHI_BINARY_LOG_RECORD_HEADER));
                                if (pDataBlock->dwLength > 0) {
                                    for (dwDataItemIndex = 0;
                                                    dwDataItemIndex < pDataBlock->dwItemCount;
                                                    dwDataItemIndex++) {
                                         pDataItem = & pDataBlock->pItemArray[dwDataItemIndex];
                                         szThisInstanceName = (LPWSTR) (((LPBYTE) pDataBlock) + pDataItem->szName);
                                        pdhStatus = PdhiFindInstance(& pInstList->InstList,
                                                                     szThisInstanceName,
                                                                     (lstrcmpiW(szThisInstanceName, gszTotal) == 0)
                                                                                     ? FALSE : TRUE,
                                                                     & pInstance);
                                        if (pdhStatus == ERROR_SUCCESS) {
                                            nItemCount++;
                                        }
                                    }
                                }
                            }

                            if (pdhStatus != ERROR_SUCCESS) {
                                break;
                            }
                            else {
                                pdhStatus = PdhiReadNextWmiRecord(pLog, NULL, 0, FALSE);
                            }
                        }
                        if (pdhStatus == PDH_END_OF_LOG_FILE) {
                            pdhStatus = ERROR_SUCCESS;
                        }
                        if (pdhStatus == ERROR_SUCCESS) {
                            bInstanceListScanned = TRUE;
                        }
                    }
                }
            }
        }
        ZeroMemory(szCompositeInstance, sizeof(szCompositeInstance));
        dwBytesProcessed += pPath->dwLength;
        pPath             = (PPDHI_LOG_COUNTER_PATH) ((LPBYTE) pPath + pPath->dwLength);
    }

    if (nItemCount > 0 && pdhStatus != PDH_MORE_DATA) {
            pdhStatus = ERROR_SUCCESS;
    }

Cleanup:
    G_FREE(pTempBuffer);
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetWmiLogCounterInfo(
    PPDHI_LOG       pLog,
    PPDHI_COUNTER   pCounter
)
{
    PDH_STATUS                 Status         = ERROR_SUCCESS;
    DWORD                      dwObjectId;
    DWORD                      dwCounterId    = wcstoul(pCounter->pCounterPath->szCounterName, NULL, 10);
    PPDH_WMI_PERF_MACHINE      pMachine       = NULL;
    PPDH_WMI_PERF_OBJECT       pObject        = NULL;
    PLIST_ENTRY                pHead;
    PLIST_ENTRY                pNext;
    PPERF_DATA_BLOCK           pDataBlock     = NULL;
    PPERF_OBJECT_TYPE          pPerfObject    = NULL;
    DWORD                      dwItems        = 0;
    PPERF_COUNTER_DEFINITION   pPerfCounter;
    PPERF_INSTANCE_DEFINITION  pPerfInstance;
    PPDH_LOGGER_CONTEXT        CurrentContext;
    BOOL                       bNeedEnumerate = TRUE;

    dwObjectId = PdhWmiGetLogPerfIndexByName(
                    pLog, pCounter->pCounterPath->szMachineName, 9, pCounter->pCounterPath->szObjectName);
    CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
    if (GetLoggerContext(CurrentContext) < ContextCount) {
        pMachine = PdhWmiGetLogNameTable(pLog, pCounter->pCounterPath->szMachineName, 9);
        if (pMachine == NULL) {
            Status = PDH_ENTRY_NOT_IN_LOG_FILE;
            goto Cleanup;
        }
        pHead = & pMachine->LogObjectList;
        pNext = pHead->Flink;
        while (pNext != pHead) {
            pObject = CONTAINING_RECORD(pNext, PDH_WMI_PERF_OBJECT, Entry);
            if (pObject->dwObjectId == dwObjectId) {
                bNeedEnumerate = FALSE;
                break;
            }
            pNext = pNext->Flink;
        }

        if (bNeedEnumerate) {
            DWORD dwCounterSize  = 0;
            DWORD dwInstanceSize = 0;
            Status = PdhiEnumLoggedObjectItems((PDH_HLOG) pLog,
                                               pCounter->pCounterPath->szMachineName,
                                               pCounter->pCounterPath->szObjectName,
                                               NULL,
                                               & dwCounterSize,
                                               NULL,
                                               & dwInstanceSize,
                                               0,
                                               0,
                                               TRUE);
            if (Status != ERROR_SUCCESS && Status != PDH_MORE_DATA) {
                goto Cleanup;
            }
            Status = ERROR_SUCCESS;
        }
    }
    else {
        Status = PDH_INVALID_ARGUMENT;
        goto Cleanup;
    }

    if (dwObjectId == 0) {
        dwObjectId = wcstoul(pCounter->pCounterPath->szObjectName, NULL, 10);
        if (dwObjectId != 0) {
            Status = ERROR_SUCCESS;
        }
        else {
            Status = PDH_ENTRY_NOT_IN_LOG_FILE;
        }
    }
    else {
        Status = ERROR_SUCCESS;
    }

    if (Status != ERROR_SUCCESS) {
        goto Cleanup;
    }
    pMachine = PdhWmiGetLogNameTable(pLog, pCounter->pCounterPath->szMachineName, 9);
    if (pMachine == NULL) {
        Status = PDH_ENTRY_NOT_IN_LOG_FILE;
        goto Cleanup;
    }
    pHead = & pMachine->LogObjectList;
    pNext = pHead->Flink;
    while (pNext != pHead) {
        PPDH_WMI_PERF_OBJECT pThisObject = CONTAINING_RECORD(pNext, PDH_WMI_PERF_OBJECT, Entry);
        if (pThisObject->dwObjectId == dwObjectId) {
            pObject = pThisObject;
            break;
        }
        pNext = pNext->Flink;
    }
    if (pObject == NULL) {
        Status = PDH_ENTRY_NOT_IN_LOG_FILE;
        goto Cleanup;
    }

    pDataBlock = (PPERF_DATA_BLOCK) pObject->ptrBuffer;
    if (pDataBlock == NULL) {
        Status = PDH_ENTRY_NOT_IN_LOG_FILE;
        goto Cleanup;
    }
    pPerfObject = GetObjectDefByTitleIndex(pDataBlock, dwObjectId);
    if (pPerfObject == NULL) {
        Status = PDH_CSTATUS_NO_OBJECT;
        goto Cleanup;
    }

    dwItems      = 0;
    pPerfCounter = FirstCounter(pPerfObject);
    if (pPerfCounter != NULL) {
        while (pPerfCounter != NULL && dwItems < pPerfObject->NumCounters) {
            if (pPerfCounter->CounterNameTitleIndex > 0 && pPerfCounter->CounterNameTitleIndex <= pMachine->dwLastId) {
                if (lstrcmpiW(pCounter->pCounterPath->szCounterName,
                              pMachine->ptrStrAry[pPerfCounter->CounterNameTitleIndex]) == 0) {
                    break;
                }
                if (dwCounterId != 0 && dwCounterId == pPerfCounter->CounterNameTitleIndex) {
                    break;
                }
            }
            dwItems ++;
            if (dwItems < pPerfObject->NumCounters) {
                pPerfCounter = NextCounter(pPerfObject, pPerfCounter);
                if (pPerfCounter == NULL) {
                    break;
                }
            }
            else {
                pPerfCounter = NULL;
            }
        }
    }
    if (dwItems == pPerfObject->NumCounters) {
        pPerfCounter = NULL;
    }
    if (pPerfCounter == NULL) {
        Status = PDH_CSTATUS_NO_OBJECT;
        goto Cleanup;
    }

    pCounter->plCounterInfo.dwObjectId    = dwObjectId;
    pCounter->plCounterInfo.dwCounterId   = pPerfCounter->CounterNameTitleIndex;
    pCounter->plCounterInfo.dwCounterType = pPerfCounter->CounterType;
    pCounter->plCounterInfo.dwCounterSize = pPerfCounter->CounterSize;
    pCounter->plCounterInfo.lDefaultScale = pPerfCounter->DefaultScale;
    if (pCounter->plCounterInfo.dwCounterType  & PERF_TIMER_100NS) {
        pCounter->TimeBase = (LONGLONG) 10000000;
    }
    else if (pCounter->plCounterInfo.dwCounterType  & PERF_OBJECT_TIMER) {
        pCounter->TimeBase = pPerfObject->PerfFreq.QuadPart;
    }
    else {
        pCounter->TimeBase = pDataBlock->PerfFreq.QuadPart;
    }

    if (pPerfObject->NumInstances == PERF_NO_INSTANCES) {
        pCounter->plCounterInfo.lInstanceId          = 0;
        pCounter->plCounterInfo.szInstanceName       = NULL;
        pCounter->plCounterInfo.dwParentObjectId     = 0;
        pCounter->plCounterInfo.szParentInstanceName = NULL;
    }
    else {
        pPerfInstance = FirstInstance(pPerfObject);
        if (pPerfInstance != NULL) {
            if (pPerfInstance->UniqueID == PERF_NO_UNIQUE_ID) {
                pCounter->plCounterInfo.lInstanceId          = PERF_NO_UNIQUE_ID;
                pCounter->plCounterInfo.szInstanceName       = pCounter->pCounterPath->szInstanceName;
                pCounter->plCounterInfo.dwParentObjectId     = (DWORD) PERF_NO_UNIQUE_ID;
                pCounter->plCounterInfo.szParentInstanceName = pCounter->pCounterPath->szParentName;
            }
            else {
                LONG lTempId;
                if (pCounter->pCounterPath->szInstanceName != NULL) {
                    lTempId = wcstoul(pCounter->pCounterPath->szInstanceName, NULL, 10);
                }
                else {
                    lTempId = 0;
                }
                pCounter->plCounterInfo.lInstanceId    = lTempId;
                pCounter->plCounterInfo.szInstanceName = NULL;

                if (pCounter->pCounterPath->szParentName != NULL) {
                    lTempId = wcstoul(pCounter->pCounterPath->szParentName, NULL, 10);
                }
                else {
                    lTempId = 0;
                }
                pCounter->plCounterInfo.dwParentObjectId     = lTempId;
                pCounter->plCounterInfo.szParentInstanceName = NULL;
            }
        }
        else {
            Status = PDH_ENTRY_NOT_IN_LOG_FILE;
        }
    }

Cleanup:
    return Status;
}

PDH_FUNCTION
PdhiGetWmiLogFileSize(
    PPDHI_LOG  pLog,
    LONGLONG * llSize
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    LONGLONG    SizeSum   = 0;
    DWORD       dwFileSizeLow;
    DWORD       dwFileSizeHigh;
    DWORD       dwError;
    HANDLE      hFile;

    if (pLog->dwLogFormat & PDH_LOG_WRITE_ACCESS) {
        PPDH_EVENT_TRACE_PROPERTIES LoggerInfo = (PPDH_EVENT_TRACE_PROPERTIES) pLog->lpMappedFileBase;
        if (LoggerInfo != NULL && LoggerInfo->LogFileName != NULL && LoggerInfo->LogFileName[0] != L'\0') {
            hFile = CreateFileW(LoggerInfo->LogFileName,
                                GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
            if (hFile == NULL || hFile == INVALID_HANDLE_VALUE) {
                DWORD Win32Error = GetLastError();
                switch (Win32Error) {
                case ERROR_FILE_NOT_FOUND:
                    pdhStatus = PDH_FILE_NOT_FOUND;
                    break;

                case ERROR_ALREADY_EXISTS:
                    pdhStatus = PDH_FILE_ALREADY_EXISTS;
                    break;

                default:
                    pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
                    break;
                }
            }
            else {
                dwFileSizeLow = GetFileSize(hFile, & dwFileSizeHigh);
                if ((dwFileSizeLow == 0xFFFFFFFF) && ((dwError = GetLastError()) != NO_ERROR)) {
                    pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
                }
                else {
                    if (dwFileSizeHigh != 0) {
                        SizeSum += (((LONGLONG) dwFileSizeHigh) << (sizeof(DWORD) * 8));
                    }
                    SizeSum += dwFileSizeLow;
                }
                CloseHandle(hFile);
            }
        }
        else {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    else {
        PPDH_LOGGER_CONTEXT CurrentContext = (PPDH_LOGGER_CONTEXT) pLog->lpMappedFileBase;
        if (GetLoggerContext(CurrentContext) < ContextCount) {
            LONG     i;

            for (i = 0, hFile = NULL, dwFileSizeLow = 0, dwFileSizeHigh = 0;
                         (pdhStatus == ERROR_SUCCESS) && (i < (LONG) CurrentContext->LogFileCount);
                          i ++, hFile = NULL, dwFileSizeLow = 0, dwFileSizeHigh = 0) {
                hFile = CreateFileW(CurrentContext->LogFileName[i],
                                    GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);
                if (hFile == NULL || hFile == INVALID_HANDLE_VALUE) {
                    DWORD Win32Error = GetLastError();
                    switch (Win32Error) {
                    case ERROR_FILE_NOT_FOUND:
                        pdhStatus = PDH_FILE_NOT_FOUND;
                        break;

                    case ERROR_ALREADY_EXISTS:
                        pdhStatus = PDH_FILE_ALREADY_EXISTS;
                        break;

                    default:
                        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
                        break;
                    }
                    break;
                }
                dwFileSizeLow = GetFileSize(hFile, & dwFileSizeHigh);
                if ((dwFileSizeLow == 0xFFFFFFFF) && ((dwError = GetLastError()) != NO_ERROR)) {
                    pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
                }
                else {
                    if (dwFileSizeHigh != 0) {
                        SizeSum = SizeSum + (((LONGLONG) dwFileSizeHigh) << (sizeof(DWORD) * 8));
                    }
                    SizeSum += dwFileSizeLow;
                }
                CloseHandle(hFile);
            }
        }
        else {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        __try {
            * llSize = SizeSum;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhlog\log_text.h ===
/*++
Copyright (C) 1998-1999 Microsoft Corporation

Module Name:
    log_text.h

Abstract:
    <abstract>
--*/

#ifndef _LOG_TEXT_H_
#define _LOG_TEXT_H_

PDH_FUNCTION
PdhiOpenInputTextLog(
    PPDHI_LOG   pLog
);

PDH_FUNCTION
PdhiOpenOutputTextLog(
    PPDHI_LOG   pLog
);

PDH_FUNCTION
PdhiCloseTextLog(
    PPDHI_LOG   pLog,
    DWORD       dwFlags
);

PDH_FUNCTION
PdhiGetTextLogCounterInfo(
    PPDHI_LOG       pLog,
    PPDHI_COUNTER   pCounter
);

PDH_FUNCTION
PdhiWriteTextLogHeader(
    PPDHI_LOG   pLog,
    LPCWSTR     szUserCaption
);

PDH_FUNCTION
PdhiWriteTextLogRecord(
    PPDHI_LOG    pLog,
    SYSTEMTIME * pTimeStamp,
    LPCWSTR      szUserString
);

PDH_FUNCTION
PdhiEnumMachinesFromTextLog(
    PPDHI_LOG   pLog,
    LPVOID      pBuffer,
    LPDWORD     lpdwBufferSize,
    BOOL        bUnicodeDest
);

PDH_FUNCTION
PdhiEnumObjectsFromTextLog(
    PPDHI_LOG   pLog,
    LPCWSTR     szMachineName,
    LPVOID      mszObjectList,
    LPDWORD     pcchBufferSize,
    DWORD       dwDetailLevel,
    BOOL        bUnicode
);

PDH_FUNCTION
PdhiEnumObjectItemsFromTextLog(
    PPDHI_LOG          hDataSource,
    LPCWSTR            szMachineName,
    LPCWSTR            szObjectName,
    PDHI_COUNTER_TABLE CounterTable,
    DWORD              dwDetailLevel,
    DWORD              dwFlags
);

PDH_FUNCTION
PdhiGetMatchingTextLogRecord(
    PPDHI_LOG   pLog,
    LONGLONG  * pStartTime,
    LPDWORD     pdwIndex
);

PDH_FUNCTION
PdhiGetCounterValueFromTextLog(
    PPDHI_LOG          hLog,
    DWORD              dwIndex,
    PERFLIB_COUNTER  * pPath,
    PPDH_RAW_COUNTER   pValue
);

PDH_FUNCTION
PdhiGetTimeRangeFromTextLog(
    PPDHI_LOG       hLog,
    LPDWORD         pdwNumEntries,
    PPDH_TIME_INFO  pInfo,
    LPDWORD         dwBufferSize
);

PDH_FUNCTION
PdhiReadRawTextLogRecord(
    PPDHI_LOG             pLog,
    FILETIME            * ftRecord,
    PPDH_RAW_LOG_RECORD   pBuffer,
    LPDWORD               pdwBufferLength
);

PDH_FUNCTION
PdhiListHeaderFromTextLog(
    PPDHI_LOG   pLogFile,
    LPVOID      pBufferArg,
    LPDWORD     pcchBufferSize,
    BOOL        bUnicode
);

#endif   // _LOG_TEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhlog\log_text.c ===
/*++
Copyright (C) 1996-1999 Microsoft Corporation

Module Name:
    log_text.c

Abstract:
    <abstract>
--*/

#include <windows.h>
#include <mbctype.h>
#include <strsafe.h>
#include <pdh.h>
#include "pdhidef.h"
#include "log_text.h"
#include "pdhmsg.h"
#include "strings.h"    

#pragma warning ( disable : 4213)

#define TAB_DELIMITER       '\t'
#define COMMA_DELIMITER     ','
#define DOUBLE_QUOTE        '\"'
#define VALUE_BUFFER_SIZE   32

LPCSTR  PdhiszFmtTimeStamp   = "\"%2.2d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d.%3.3d\"";
LPCSTR  PdhiszFmtStringValue = "%c\"%s\"";
LPCSTR  PdhiszFmtRealValue   = "%c\"%.20g\"";
TIME_ZONE_INFORMATION TimeZone;

extern  LPCSTR  PdhiszRecordTerminator;
extern  DWORD   PdhidwRecordTerminatorLength;

#define TEXTLOG_TYPE_ID_RECORD     1
#define TEXTLOG_HEADER_RECORD      1
#define TEXTLOG_FIRST_DATA_RECORD  2
#define TIME_FIELD_COUNT           7
#define TIME_FIELD_BUFF_SIZE      24
DWORD   dwTimeFieldOffsetList[TIME_FIELD_COUNT] = {2, 5, 10, 13, 16, 19, 23};

#define MAX_TEXT_FILE_SIZE          ((LONGLONG) 0x0000000077FFFFFF)
#define PDH_TEXT_REC_MODE_NONE      0x00000000
#define PDH_TEXT_REC_MODE_TIMESTAMP 0x00000001
#define PDH_TEXT_REC_MODE_VALUE     0x00000002
#define PDH_TEXT_REC_MODE_ALL       0x00000003

typedef struct _PDHI_TEXT_LOG_INFO {
    LONGLONG            ThisTime;
    PPDHI_LOG_MACHINE   MachineList;
    DOUBLE            * CtrList;
    DWORD               dwCounter;
    DWORD               dwSuccess;
    DWORD               dwRecMode;
} PDHI_TEXT_LOG_INFO, * PPDHI_TEXT_LOG_INFO;

PDH_FUNCTION
PdhiBuildFullCounterPath(
    BOOL               bMachine,
    PPDHI_COUNTER_PATH pCounterPath,
    LPWSTR             szObjectName,
    LPWSTR             szCounterName,
    LPWSTR             szFullPath,
    DWORD              dwFullPath
);

STATIC_BOOL
PdhiDateStringToFileTimeA(
    LPSTR      szDateTimeString,
    LPFILETIME pFileTime
)
{
    CHAR       mszTimeFields[TIME_FIELD_BUFF_SIZE];
    DWORD      dwThisField;
    LONG       lValue;
    SYSTEMTIME st;

    // make string into msz
    ZeroMemory(mszTimeFields, TIME_FIELD_BUFF_SIZE * sizeof(CHAR));
    StringCchCopyA(mszTimeFields, TIME_FIELD_BUFF_SIZE, szDateTimeString);
    for (dwThisField = 0; dwThisField < TIME_FIELD_COUNT; dwThisField ++) {
        mszTimeFields[dwTimeFieldOffsetList[dwThisField]] = '\0';
    }

    // read string into system time structure
    dwThisField      = 0;
    st.wDayOfWeek    = 0;
    lValue           = atol(& mszTimeFields[0]);
    st.wMonth        = LOWORD(lValue);
    lValue           = atol(& mszTimeFields[dwTimeFieldOffsetList[dwThisField ++] + 1]);
    st.wDay          = LOWORD(lValue);
    lValue           = atol(& mszTimeFields[dwTimeFieldOffsetList[dwThisField ++] + 1]);
    st.wYear         = LOWORD(lValue);
    lValue           = atol(& mszTimeFields[dwTimeFieldOffsetList[dwThisField ++] + 1]);
    st.wHour         = LOWORD(lValue);
    lValue           = atol(& mszTimeFields[dwTimeFieldOffsetList[dwThisField ++] + 1]);
    st.wMinute       = LOWORD(lValue);
    lValue           = atol(& mszTimeFields[dwTimeFieldOffsetList[dwThisField ++] + 1]);
    st.wSecond       = LOWORD(lValue);
    lValue           = atol(& mszTimeFields[dwTimeFieldOffsetList[dwThisField ++] + 1]);
    st.wMilliseconds = LOWORD(lValue);

    return SystemTimeToFileTime(& st, pFileTime);
}

#define PDHI_GSFDL_REMOVE_QUOTES    0x00000001
#define PDHI_GSFDL_REMOVE_NONPRINT  0x00000002
STATIC_DWORD
PdhiGetStringFromDelimitedListA(
    LPSTR szInputString,
    DWORD dwItemIndex,
    CHAR  cDelimiter,
    DWORD dwFlags,
    LPSTR szOutputString,
    DWORD cchBufferLength
)
{
    DWORD dwCurrentIndex = 0;
    LPSTR szCurrentItem;
    LPSTR szSrcPtr, szDestPtr;
    DWORD dwReturn       = 0;
    BOOL  bInsideQuote   = FALSE;

    // go to desired entry in string, 0 = first entry
    szCurrentItem = szInputString;

    while (dwCurrentIndex < dwItemIndex) {
        // goto next delimiter or terminator
        while (* szCurrentItem != cDelimiter || bInsideQuote) {
            if (* szCurrentItem == '\0') {
                break;
            }
            else if (* szCurrentItem == DOUBLEQUOTE_A) {
                bInsideQuote = ! bInsideQuote;
            }
            szCurrentItem ++;
        }
        if (* szCurrentItem != '\0') szCurrentItem ++;
        dwCurrentIndex++;
    }
    if (* szCurrentItem != '\0') {
        // then copy to the user's buffer, as long as it fits
        szSrcPtr     = szCurrentItem;
        szDestPtr    = szOutputString;
        dwReturn     = 0;
        bInsideQuote = FALSE;

        while ((dwReturn < cchBufferLength) && (* szSrcPtr != 0) && (* szSrcPtr != cDelimiter || bInsideQuote)) {
            if (* szSrcPtr == DOUBLEQUOTE_A) {
                bInsideQuote = ! bInsideQuote;
                if (dwFlags & PDHI_GSFDL_REMOVE_QUOTES) {
                    // skip the quote
                    szSrcPtr ++;
                    continue;
                }
            }

            if (dwFlags & PDHI_GSFDL_REMOVE_NONPRINT) {
                if ((UCHAR) * szSrcPtr < (UCHAR) ' ') {
                    // skip the control char
                    szSrcPtr ++;
                    continue;
                }
            }

            // copy character
            * szDestPtr ++ = * szSrcPtr ++;
            dwReturn ++; // increment length
        }
        if (dwReturn > 0) {
            * szDestPtr = 0; // add terminator char
        }
    }
    return dwReturn;
}

int
PdhiCompareLogCounterInstance(
    PPDHI_LOG_COUNTER pCounter,
    LPWSTR            szCounter,
    LPWSTR            szInstance,
    DWORD             dwInstance,
    LPWSTR            szParent
)
{
    int   iResult = 0;
    WCHAR szTmp[PDH_SQL_STRING_SIZE];

    if (pCounter->szCounter != NULL && pCounter->szCounter[0] != L'\0') {
        if (szCounter != NULL && szCounter[0] != L'\0') {
            ZeroMemory(szTmp, PDH_SQL_STRING_SIZE * sizeof(WCHAR));
            StringCchCopyW(szTmp, PDH_SQL_STRING_SIZE, szCounter);
            iResult = lstrcmpiW(szTmp, pCounter->szCounter);
        }
        else {
            iResult = -1;
        }
    }
    else if (szCounter != NULL && szCounter[0] != L'\0') {
        iResult = 1;
    }
    if (iResult != 0) goto Cleanup;

    if ((pCounter->szInstance != NULL && pCounter->szInstance[0] != L'\0')
                    && (szInstance != NULL && szInstance[0] != L'\0')) {
        ZeroMemory(szTmp, PDH_SQL_STRING_SIZE * sizeof(WCHAR));
        StringCchCopyW(szTmp, PDH_SQL_STRING_SIZE, szInstance);
        iResult = lstrcmpiW(szTmp, pCounter->szInstance);
    }
    else if ((pCounter->szInstance != NULL && pCounter->szInstance[0] != L'\0')
                    && (szInstance == NULL || szInstance[0] == L'\0')) {
        iResult = -1;
    }
    else if ((pCounter->szInstance == NULL || pCounter->szInstance[0] == L'\0')
                    && (szInstance != NULL && szInstance[0] != L'\0')) {
        iResult = 1;
    }
    if (iResult != 0) goto Cleanup;

    iResult = (dwInstance < pCounter->dwInstance) ? (-1) : ((dwInstance > pCounter->dwInstance) ? (1) : (0));
    if (iResult != 0) goto Cleanup;

    if ((pCounter->szParent != NULL && pCounter->szParent[0] != L'\0')
                    && (szParent != NULL && szParent[0] != L'\0')) {
        ZeroMemory(szTmp, PDH_SQL_STRING_SIZE * sizeof(WCHAR));
        StringCchCopyW(szTmp, PDH_SQL_STRING_SIZE, szParent);
        iResult = lstrcmpiW(szTmp, pCounter->szParent);
    }
    else if ((pCounter->szParent != NULL && pCounter->szParent[0] != L'\0')
                    && (szParent == NULL || szParent[0] == L'\0')) {
        iResult = -1;
    }
    else if ((pCounter->szParent == NULL || pCounter->szParent[0] == L'\0')
                    && (szParent != NULL && szParent[0] != L'\0')) {
        iResult = 1;
    }

Cleanup:
    return iResult;
}

void
PdhiFreeLogCounterNode(
    PPDHI_LOG_COUNTER pCounter,
    DWORD             dwLevel
)
{
    if (pCounter == NULL) return;

    if (pCounter->left != NULL) {
        PdhiFreeLogCounterNode(pCounter->left, dwLevel + 1);
    }
    if (pCounter->right != NULL) {
        PdhiFreeLogCounterNode(pCounter->right, dwLevel + 1);
    }
    G_FREE(pCounter->pCtrData);
    G_FREE(pCounter);
}

void
PdhiFreeLogObjectNode(
    PPDHI_LOG_OBJECT pObject,
    DWORD            dwLevel
)
{
    if (pObject == NULL) return;

    if (pObject->left != NULL) {
        PdhiFreeLogObjectNode(pObject->left, dwLevel + 1);
    }
    G_FREE(pObject->pObjData);
    PdhiFreeLogCounterNode(pObject->CtrTable, 0);
    if (pObject->InstTable != PDH_INVALID_POINTER) {
        PdhiFreeLogCounterNode(pObject->InstTable, 0);
    }
    if (pObject->right != NULL) {
        PdhiFreeLogObjectNode(pObject->right, dwLevel + 1);
    }
    G_FREE(pObject);
}

void
PdhiFreeLogMachineTable(
    PPDHI_LOG_MACHINE * MachineTable
)
{
    PPDHI_LOG_MACHINE pMachine;
    PPDHI_LOG_OBJECT  pObject;
    PPDHI_LOG_COUNTER pCounter;

    if (MachineTable == NULL) return;

    pMachine = * MachineTable;
    while (pMachine != NULL) {
        PPDHI_LOG_MACHINE pDelMachine = pMachine;
        pMachine = pMachine->next;
        PdhiFreeLogObjectNode(pDelMachine->ObjTable, 0);
        G_FREE(pDelMachine);
    }
    * MachineTable = NULL;
}

PPDHI_LOG_MACHINE
PdhiFindLogMachine(
    PPDHI_LOG_MACHINE * MachineTable,
    LPWSTR              szMachine,
    BOOL                bInsert
)
{
    PPDHI_LOG_MACHINE pMachine = NULL;

    if (MachineTable != NULL) {
        for (pMachine = (* MachineTable);
                pMachine && lstrcmpiW(pMachine->szMachine, szMachine) != 0;
                pMachine = pMachine->next);
        if (bInsert && pMachine == NULL) {
            pMachine = G_ALLOC(sizeof(PDHI_LOG_MACHINE) + (lstrlenW(szMachine) + 1) * sizeof(WCHAR));
            if (pMachine != NULL) {
                pMachine->szMachine = (LPWSTR) (((PCHAR) pMachine) + sizeof(PDHI_LOG_MACHINE));
                StringCchCopyW(pMachine->szMachine, lstrlenW(szMachine) + 1, szMachine);
                pMachine->ObjTable  = NULL;
                pMachine->next      = (* MachineTable);
                * MachineTable      = pMachine;
            }
        }
    }
    return pMachine;
}

PPDHI_LOG_OBJECT
PdhiFindLogObject(
    PPDHI_LOG_MACHINE  pMachine,
    PPDHI_LOG_OBJECT * ObjectTable,
    LPWSTR             szObject,
    BOOL               bInsert
)
{
    PPDHI_LOG_OBJECT  * pStack[MAX_BTREE_DEPTH];
    PPDHI_LOG_OBJECT  * pLink;
    int                 dwStack     = 0;
    PPDHI_LOG_OBJECT    pNode       = * ObjectTable;
    PPDHI_LOG_OBJECT    pObject     = NULL;
    PPDHI_LOG_OBJECT    pParent;
    PPDHI_LOG_OBJECT    pSibling;
    PPDHI_LOG_OBJECT    pChild;
    int                 iCompare;
    LPWSTR              szTmpObject = NULL;

    szTmpObject = G_ALLOC(PDH_SQL_STRING_SIZE * sizeof(WCHAR));
    if (szTmpObject == NULL) {
        goto Cleanup;
    }
    StringCchCopyW(szTmpObject, PDH_SQL_STRING_SIZE, szObject);

    pStack[dwStack ++] = ObjectTable;
    while (pNode != NULL) {
        iCompare = lstrcmpiW(szTmpObject, pNode->szObject);
        if (iCompare < 0) {
            pStack[dwStack ++] = & (pNode->left);
            pNode = pNode->left;
        }
        else if (iCompare > 0) {
            pStack[dwStack ++] = & (pNode->right);
            pNode = pNode->right;
        }
        else {
            break;
        }
    }

    if (pNode != NULL) {
        pObject = pNode;
    }
    else if (bInsert) {
        pObject = G_ALLOC(sizeof(PDHI_LOG_OBJECT) + (PDH_SQL_STRING_SIZE + 1) * sizeof(WCHAR));
        if (pObject == NULL) goto Cleanup;

        pObject->next     = pMachine->ObjList;
        pMachine->ObjList = pObject;
        pObject->bIsRed   = TRUE;
        pObject->left     = NULL;
        pObject->right    = NULL;
        pObject->CtrTable = NULL;
        pObject->szObject = (LPWSTR) (((PCHAR) pObject) + sizeof(PDHI_LOG_OBJECT));
        StringCchCopyW(pObject->szObject, PDH_SQL_STRING_SIZE, szTmpObject);

        pLink   = pStack[-- dwStack];
        * pLink = pObject;
        pChild  = NULL;
        pNode   = pObject;
        while (dwStack > 0) {
            pLink   = pStack[-- dwStack];
            pParent = * pLink;
            if (! pParent->bIsRed) {
                pSibling = (pParent->left == pNode) ? pParent->right : pParent->left;
                if (pSibling && pSibling->bIsRed) {
                    pNode->bIsRed    = FALSE;
                    pSibling->bIsRed = FALSE;
                    pParent->bIsRed  = TRUE;
                }
                else {
                    if (pChild && pChild->bIsRed) {
                        if (pChild == pNode->left) {
                            if (pNode == pParent->left) {
                                pParent->bIsRed = TRUE;
                                pParent->left   = pNode->right;
                                pNode->right    = pParent;
                                pNode->bIsRed   = FALSE;
                                * pLink         = pNode;
                            }
                            else {
                                pParent->bIsRed = TRUE;
                                pParent->right  = pChild->left;
                                pChild->left    = pParent;
                                pNode->left     = pChild->right;
                                pChild->right   = pNode;
                                pChild->bIsRed  = FALSE;
                                * pLink         = pChild;
                            }
                        }
                        else {
                            if (pNode == pParent->right) {
                                pParent->bIsRed = TRUE;
                                pParent->right  = pNode->left;
                                pNode->left     = pParent;
                                pNode->bIsRed   = FALSE;
                                * pLink         = pNode;
                            }
                            else {
                                pParent->bIsRed = TRUE;
                                pParent->left   = pChild->right;
                                pChild->right   = pParent;
                                pNode->right    = pChild->left;
                                pChild->left    = pNode;
                                pChild->bIsRed  = FALSE;
                                * pLink         = pChild;
                            }
                        }
                    }
                    break;
                }
            }
            pChild = pNode;
            pNode  = pParent;
        }

        (* ObjectTable)->bIsRed = FALSE;
    }
    else {
        pObject = NULL;
    }

Cleanup:
    G_FREE(szTmpObject);
    return pObject;
}

PPDHI_LOG_COUNTER
PdhiFindObjectCounter(
    PPDHI_LOG           pLog,
    PPDHI_LOG_OBJECT    pObject,
    LPWSTR              szCounter,
    DWORD               dwCounterType,
    DWORD               dwDefaultScale,
    LPWSTR              szInstance,
    DWORD               dwInstance,
    LPWSTR              szParent,
    DWORD               dwParent,
    LPDWORD             pdwIndex,
    BOOL                bInsert
)
{
    PPDHI_LOG_COUNTER   pCounter = NULL;
    PPDHI_LOG_COUNTER   pNode    = NULL;
    PPDHI_LOG_COUNTER * pStack[MAX_BTREE_DEPTH];
    PPDHI_LOG_COUNTER * pLink;
    int                 dwStack = 0;
    PPDHI_LOG_COUNTER   pParent;
    PPDHI_LOG_COUNTER   pSibling;
    PPDHI_LOG_COUNTER   pChild;
    int                 iCompare;

    pStack[dwStack ++] = & (pObject->CtrTable);
    pCounter = pObject->CtrTable;
    while (pCounter != NULL) {
        iCompare = PdhiCompareLogCounterInstance(pCounter, szCounter, szInstance, dwInstance, szParent);
        if (iCompare < 0) {
            pStack[dwStack ++] = & (pCounter->left);
            pCounter           = pCounter->left;
        }
        else if (iCompare > 0) {
            pStack[dwStack ++] = & (pCounter->right);
            pCounter            = pCounter->right;
        }
        else {
            break;
        }
    }

    if (bInsert) {
        if (pCounter == NULL) {
            DWORD dwBufSize = sizeof(PDHI_LOG_COUNTER) + sizeof(WCHAR) * (PDH_SQL_STRING_SIZE + 1);
            if (szInstance != NULL) {
                dwBufSize += (sizeof(WCHAR) * (PDH_SQL_STRING_SIZE + 1));
            }
            else {
                dwBufSize += sizeof(WCHAR);
            }
            if (szParent != NULL) {
                dwBufSize += (sizeof(WCHAR) * (PDH_SQL_STRING_SIZE + 1));
            }
            else {
                dwBufSize += sizeof(WCHAR);
            }

            pCounter = G_ALLOC(dwBufSize);
            if (pCounter == NULL) goto Cleanup;

            pCounter->next           = pObject->CtrList;
            pObject->CtrList         = pCounter;
            pCounter->bIsRed         = TRUE;
            pCounter->left           = NULL;
            pCounter->right          = NULL;
            pCounter->dwCounterID    = * pdwIndex;
            pCounter->dwCounterType  = dwCounterType;
            pCounter->dwDefaultScale = dwDefaultScale;
            pCounter->dwInstance     = dwInstance;
            pCounter->dwParent       = dwParent;
            pCounter->TimeStamp      = 0;

            pCounter->szCounter = (LPWSTR) (((PCHAR) pCounter) + sizeof(PDHI_LOG_COUNTER));
            StringCchCopyW(pCounter->szCounter, PDH_SQL_STRING_SIZE, szCounter);
            if (szInstance == NULL || szInstance[0] == L'\0') {
                pCounter->szInstance = NULL;
            }
            else {
                pCounter->szInstance = (LPWSTR) (((PCHAR) pCounter) + sizeof(PDHI_LOG_COUNTER)
                                                                    + sizeof(WCHAR) * (PDH_SQL_STRING_SIZE + 1));
                StringCchCopyW(pCounter->szInstance, PDH_SQL_STRING_SIZE, szInstance);
            }

            if (szParent == NULL || szParent[0] == L'\0') {
                pCounter->szParent = NULL;
            }
            else {
                if (pCounter->szInstance != NULL) {
                    pCounter->szParent = (LPWSTR) (((PCHAR) pCounter) + sizeof(PDHI_LOG_COUNTER)
                                                                      + 2 * sizeof(WCHAR) * (PDH_SQL_STRING_SIZE + 1));
                }
                else {
                    pCounter->szParent = (LPWSTR) (((PCHAR) pCounter) + sizeof(PDHI_LOG_COUNTER)
                                                                      + sizeof(WCHAR) * (PDH_SQL_STRING_SIZE + 1));
                }
                StringCchCopyW(pCounter->szParent, PDH_SQL_STRING_SIZE, szParent);
            }

            pLink   = pStack[-- dwStack];
            * pLink = pCounter;

            pChild  = NULL;
            pNode   = pCounter;
            while (dwStack > 0) {
                pLink   = pStack[-- dwStack];
                pParent = * pLink;
                if (! pParent->bIsRed) {
                    pSibling = (pParent->left == pNode) ? pParent->right : pParent->left;
                    if (pSibling && pSibling->bIsRed) {
                        pNode->bIsRed    = FALSE;
                        pSibling->bIsRed = FALSE;
                        pParent->bIsRed  = TRUE;
                    }
                    else {
                        if (pChild && pChild->bIsRed) {
                            if (pChild == pNode->left) {
                                if (pNode == pParent->left) {
                                    pParent->bIsRed  = TRUE;
                                    pParent->left    = pNode->right;
                                    pNode->right     = pParent;
                                    pNode->bIsRed    = FALSE;
                                    * pLink          = pNode;
                                }
                                else {
                                    pParent->bIsRed  = TRUE;
                                    pParent->right   = pChild->left;
                                    pChild->left     = pParent;
                                    pNode->left      = pChild->right;
                                    pChild->right    = pNode;
                                    pChild->bIsRed   = FALSE;
                                    * pLink          = pChild;
                                }
                            }
                            else {
                                if (pNode == pParent->right) {
                                    pParent->bIsRed  = TRUE;
                                    pParent->right   = pNode->left;
                                    pNode->left      = pParent;
                                    pNode->bIsRed    = FALSE;
                                    * pLink          = pNode;
                                }
                                else {
                                    pParent->bIsRed  = TRUE;
                                    pParent->left    = pChild->right;
                                    pChild->right    = pParent;
                                    pNode->right     = pChild->left;
                                    pChild->left     = pNode;
                                    pChild->bIsRed   = FALSE;
                                    * pLink          = pChild;
                                }
                            }
                        }
                        break;
                    }
                }
                pChild = pNode;
                pNode  = pParent;
            }

            pObject->CtrTable->bIsRed = FALSE;
        }
    }
    else if (pCounter != NULL) {
        * pdwIndex = pCounter->dwCounterID;
    }

Cleanup:
    return pCounter;
}

PPDHI_LOG_COUNTER
PdhiFindLogCounter(
    PPDHI_LOG           pLog,
    PPDHI_LOG_MACHINE * MachineTable,
    LPWSTR              szMachine,
    LPWSTR              szObject,
    LPWSTR              szCounter,
    DWORD               dwCounterType,
    DWORD               dwDefaultScale,
    LPWSTR              szInstance,
    DWORD               dwInstance,
    LPWSTR              szParent,
    DWORD               dwParent,
    LPDWORD             pdwIndex,
    BOOL                bInsert
)
{
    PPDHI_LOG_MACHINE pMachine = PdhiFindLogMachine(MachineTable, szMachine, bInsert);
    PPDHI_LOG_OBJECT  pObject  = NULL;
    PPDHI_LOG_COUNTER pCounter = NULL;

    if (pMachine != NULL) {
        pObject = PdhiFindLogObject(pMachine, & (pMachine->ObjTable), szObject, bInsert);
    }
    if (pObject != NULL) {
        pCounter = PdhiFindObjectCounter(pLog,
                                         pObject,
                                         szCounter,
                                         dwCounterType,
                                         dwDefaultScale,
                                         szInstance,
                                         dwInstance,
                                         szParent,
                                         dwParent,
                                         pdwIndex,
                                         bInsert);
    }

    return pCounter;
}

STATIC_PDH_FUNCTION 
PdhiReadOneTextLogRecord(
    PPDHI_LOG   pLog,
    DWORD   dwRecordId,
    LPSTR   szRecord,
    DWORD   dwMaxSize
)
// reads the specified record from the log file and returns it as an ANSI
// character string
{
    LPSTR       szTempBuffer;
    LPSTR       szOldBuffer;
    LPSTR       szTempBufferPtr;
    LPSTR       szReturn;
    PDH_STATUS  pdhStatus;
    int         nFileError = 0;
    DWORD       dwRecordLength;
    DWORD       dwBytesRead = 0;

    if (pLog->dwMaxRecordSize == 0) {
        // initialize with a default value
        dwRecordLength = SMALL_BUFFER_SIZE;
    }
    else {
        // use current maz record size max.
        dwRecordLength = pLog->dwMaxRecordSize;
    }

    szTempBuffer = G_ALLOC(dwRecordLength);
    if (szTempBuffer == NULL) {
        return PDH_MEMORY_ALLOCATION_FAILURE;
    }
    // position file pointer to desired record;

    if (dwRecordId == pLog->dwLastRecordRead) {
        // then return the current record from the cached buffer
        if ((DWORD) lstrlenA((LPSTR) pLog->pLastRecordRead) < dwMaxSize) {
            StringCchCopyA(szRecord, dwMaxSize, (LPSTR) pLog->pLastRecordRead);
            pdhStatus = ERROR_SUCCESS;
        }
        else {
            pdhStatus = PDH_MORE_DATA;
        }
        // free temp buffer
        if (szTempBuffer != NULL) {
            G_FREE(szTempBuffer);
        }
    }
    else {
        if ((dwRecordId < pLog->dwLastRecordRead) || (pLog->dwLastRecordRead == 0)){
            // the desired record is before the current position
            // or the counter has been reset so we have to
            // go to the beginning of the file and read up to the specified
            // record.
            pLog->dwLastRecordRead = 0;
            rewind(pLog->StreamFile);
        }

        // free old buffer
        if (pLog->pLastRecordRead != NULL) {
            G_FREE(pLog->pLastRecordRead);
            pLog->pLastRecordRead = NULL;
        }

        // now seek to the desired entry
        do {
            szReturn = fgets(szTempBuffer, dwRecordLength, pLog->StreamFile);
            if (szReturn == NULL) {
                if (! feof(pLog->StreamFile)) {
                    nFileError = ferror(pLog->StreamFile);
                }
                break; // end of file
            }
            else {
                // see if an entire record was read
                dwBytesRead = lstrlenA(szTempBuffer);
                // see if the last char is a new line
                if ((dwBytesRead > 0) && (szTempBuffer[dwBytesRead-1] != '\r') &&
                                         (szTempBuffer[dwBytesRead-1] != '\n')) {
                    // then if the record size is the same as the buffer
                    // or there's more text in this record...
                    // just to be safe, we'll realloc the buffer and try
                    // reading some more
                    while (dwBytesRead == dwRecordLength-1) {
                        dwRecordLength += SMALL_BUFFER_SIZE;
                        szOldBuffer     = szTempBuffer;
                        szTempBuffer    = G_REALLOC(szOldBuffer, dwRecordLength);
                        if (szTempBuffer == NULL) {
                            G_FREE(szOldBuffer);
                            pLog->dwLastRecordRead = 0;
                            pdhStatus              = PDH_MEMORY_ALLOCATION_FAILURE;
                            goto Cleanup;
                        }
                        // position read pointer at end of bytes already read
                        szTempBufferPtr = szTempBuffer + dwBytesRead;

                        szReturn = fgets(szTempBufferPtr, dwRecordLength - dwBytesRead, pLog->StreamFile);
                        if (szReturn == NULL) {
                            if (! feof(pLog->StreamFile)) {
                                nFileError = ferror(pLog->StreamFile);
                            }
                            break; // end of file
                        }
                        else {
                            // the BytesRead value already includes the NULL
                            dwBytesRead += lstrlenA(szTempBufferPtr);
                        }
                    } // end while finding the end of the record
                    // update the record length
                    // add one byte to the length read to prevent entering the
                    // recalc loop on records of the same size
                    dwRecordLength = dwBytesRead + 1;
                    szOldBuffer    = szTempBuffer;
                    szTempBuffer   = G_REALLOC(szOldBuffer, dwRecordLength);
                    if (szTempBuffer == NULL) {
                        G_FREE(szOldBuffer);
                        pLog->dwLastRecordRead = 0;
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        goto Cleanup;
                    }
                } // else the whole record fit
            }
        } while (++ pLog->dwLastRecordRead < dwRecordId);

        // update the max record length for the log file.
        if (dwRecordLength > pLog->dwMaxRecordSize) {
            pLog->dwMaxRecordSize = dwRecordLength;
        }

        // if the desired one was found then return it
        if (szReturn != NULL) {
            // then a record was read so update the cached values and return
            // the data
            pLog->pLastRecordRead = (LPVOID) szTempBuffer;

            // copy to the caller's buffer
            if (dwBytesRead < dwMaxSize) {
                StringCchCopyA(szRecord, dwMaxSize, (LPSTR) pLog->pLastRecordRead);
                pdhStatus = ERROR_SUCCESS;
            }
            else {
                pdhStatus = PDH_MORE_DATA;
            }
        }
        else {
            // reset the pointers and buffers
            pLog->dwLastRecordRead = 0;
            G_FREE(szTempBuffer);
            pdhStatus = PDH_END_OF_LOG_FILE;
        }
    }

Cleanup:
    return pdhStatus;
}

PDH_FUNCTION
PdhiBuildTextHeaderCache(
    PPDHI_LOG pLog
)
{
    PDH_STATUS          Status         = ERROR_SUCCESS;
    CHAR                cDelim         = (CHAR) ((LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_CSV)
                                                 ? (COMMA_DELIMITER) : (TAB_DELIMITER));
    CHAR                szTemp[4];
    LPSTR               szReturn       = NULL;
    LPSTR               szThisItem     = NULL;
    PPDHI_TEXT_LOG_INFO pLogInfo       = (PPDHI_TEXT_LOG_INFO) pLog->pPerfmonInfo;
    DWORD               dwBufferLength = 0;
    BOOL                bInsideQuote   = FALSE;
    LPSTR               szCurrent      = NULL;
    LPWSTR              szCounter      = NULL;
    DWORD               dwSize         = MEDIUM_BUFFER_SIZE;
    PPDHI_COUNTER_PATH  pCtrInfo       = NULL;
    DWORD               dwIndex        = 0;
    DWORD               dwSuccess      = 0;
    DWORD               dwTotal        = 0;

    if (pLogInfo->MachineList != NULL && pLogInfo->dwCounter > 0) goto Cleanup;

    szReturn = szTemp;
    Status   = PdhiReadOneTextLogRecord(pLog, TEXTLOG_HEADER_RECORD, szReturn, 1);
    if (Status != ERROR_SUCCESS && Status != PDH_MORE_DATA) goto Cleanup;

    Status              = ERROR_SUCCESS;
    pLogInfo->dwRecMode = PDH_TEXT_REC_MODE_NONE;

    if (pLog->dwLastRecordRead != TEXTLOG_HEADER_RECORD) {
        Status = PDH_UNABLE_READ_LOG_HEADER;
        goto Cleanup;
    }

    dwBufferLength = lstrlenA((LPSTR) pLog->pLastRecordRead) + 2;
    szReturn       = G_ALLOC(dwBufferLength * sizeof(CHAR));
    szCounter      = G_ALLOC(dwBufferLength * sizeof(WCHAR));
    pCtrInfo       = G_ALLOC(dwSize);
    if (szReturn == NULL || szCounter == NULL || pCtrInfo == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    StringCchCopyA(szReturn, dwBufferLength, (LPSTR) pLog->pLastRecordRead);
    dwTotal = 0;
    for (szCurrent = szReturn; * szCurrent != '\0'; szCurrent ++) {
        if (* szCurrent == DOUBLEQUOTE_A) {
            bInsideQuote = ! bInsideQuote;
        }
        else if ((* szCurrent == cDelim) && (! bInsideQuote)) {
            * szCurrent = '\0';
            dwTotal ++;
        }
    }
    dwTotal ++;

    dwIndex = 0;
    for (szCurrent = szReturn; * szCurrent != '\0'; szCurrent += (lstrlenA(szCurrent) + 1)) {
        if (dwIndex > 0) {
            LPWSTR szThisCounter = NULL;
            LPWSTR szEndCounter  = NULL;
            BOOL   bReverse      = FALSE;

            dwSize = MEDIUM_BUFFER_SIZE;
            ZeroMemory(szCounter, dwBufferLength * sizeof(WCHAR));
            ZeroMemory(pCtrInfo, dwSize);
            MultiByteToWideChar(_getmbcp(), 0, szCurrent, lstrlenA(szCurrent), (LPWSTR) szCounter, dwBufferLength);
            for (szThisCounter = szCounter; * szThisCounter == L'\"';) {
                szThisCounter ++;
            }
            for (szEndCounter = szThisCounter; * szEndCounter != L'\0' && * szEndCounter != L'\"'; szEndCounter ++);
            if (* szEndCounter == L'\"') {
                bReverse       = TRUE;
                * szEndCounter = L'\0';
            }
            if (ParseFullPathNameW(szThisCounter, & dwSize, pCtrInfo, FALSE)) {
                if (szThisCounter[1] != L'\\') {
                    pCtrInfo->szMachineName[0] = L'.';
                    pCtrInfo->szMachineName[1] = L'\0';
                }
                if (PdhiFindLogCounter(pLog,
                                       & pLogInfo->MachineList,
                                       pCtrInfo->szMachineName,
                                       pCtrInfo->szObjectName,
                                       pCtrInfo->szCounterName,
                                       PERF_DOUBLE_RAW,
                                       0,
                                       pCtrInfo->szInstanceName,
                                       pCtrInfo->dwIndex,
                                       pCtrInfo->szParentName,
                                       0,
                                       & dwIndex,
                                       TRUE) != NULL) {
                    dwSuccess ++;
                }
                else {
                    // This is the case that PDH cannot insert counter path into internal
                    // cached BTRESS structure. Something might be wrong but we can still
                    // ignore this counter path and continue.
                    //
                    DebugPrint((1,"PDhiFindLogCounter(\"%ws\",%d,%d,%d)\n",
                                    szThisCounter, dwIndex, dwSuccess,dwTotal));
#if 0
                    Status = PDH_INVALID_DATA;
                    break;
#endif
                }
            }
            else {
                // If (dwIndex + 1 == dwTotal), this is the last string of the first line in CSV
                // counter logfile, and this might be the user comment at the end.
                // Otherwise this is not a valid counter path.
                // In either case, just ignore it.
                //
                DebugPrint((1,"ParseFullPathNameW(\"%ws\",%d,%d,%d,%d) Fails\n",
                                szThisCounter, dwSize, dwIndex, dwSuccess,dwTotal));
#if 0
                if (dwIndex + 1 < dwTotal) {
                    Status = PDH_CSTATUS_BAD_COUNTERNAME;
                    break;
                }
#endif
            }
            if (bReverse && szEndCounter != NULL) {
                * szEndCounter = L'\"';
            }
        }
        dwIndex ++;
    }

    if (dwSuccess == 0) {
        Status = PDH_INVALID_DATA;
    }

    if (Status == ERROR_SUCCESS) {
        pLogInfo->dwCounter = dwIndex;
        pLogInfo->dwSuccess = dwSuccess;
        pLogInfo->CtrList = G_ALLOC(sizeof(DOUBLE) * pLogInfo->dwCounter);
        if (pLogInfo->CtrList == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }
    }

Cleanup:
    G_FREE(szReturn);
    G_FREE(szCounter);
    G_FREE(pCtrInfo);

    if (Status != ERROR_SUCCESS) {
        G_FREE(pLogInfo->CtrList);
        if (pLogInfo->MachineList != NULL) {
            PdhiFreeLogMachineTable(& pLogInfo->MachineList);
        }
        ZeroMemory(pLogInfo, sizeof(PDHI_TEXT_LOG_INFO));
    }
    return Status;
}

PDH_FUNCTION
PdhiBuildTextRecordCache(
    PPDHI_LOG  pLog,
    DWORD      dwLine,
    DWORD      RequestMode
)
{
    PDH_STATUS          Status       = ERROR_SUCCESS;
    PPDHI_TEXT_LOG_INFO pLogInfo     = (PPDHI_TEXT_LOG_INFO) pLog->pPerfmonInfo;
    LPSTR               szLine       = NULL;
    LPSTR               szThisChar   = NULL;
    CHAR                cDelim       = (CHAR) ((LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_CSV)
                                               ? (COMMA_DELIMITER) : (TAB_DELIMITER));
    DWORD               dwLineSize   = 0;
    DWORD               dwIndex      = 0;
    BOOL                bInsideQuote = FALSE;

    if (dwLine == TEXTLOG_HEADER_RECORD) goto Cleanup;

    if (pLogInfo == NULL) {
        Status = PDH_LOG_FILE_OPEN_ERROR;
        goto Cleanup;
    }

    if (dwLine != pLog->dwLastRecordRead) {
        CHAR  szTemp[4];
        LPSTR szReturn = szTemp;
        Status = PdhiReadOneTextLogRecord(pLog, dwLine, szReturn, 1);
        if (Status == PDH_MORE_DATA) {
            Status = ERROR_SUCCESS;
        }
        if (Status != ERROR_SUCCESS) goto Cleanup;
        pLogInfo->dwRecMode = PDH_TEXT_REC_MODE_NONE;
    }
    if (RequestMode <= pLogInfo->dwRecMode) goto Cleanup;

    dwLineSize = lstrlenA((LPSTR) pLog->pLastRecordRead) + 2;
    szLine     = G_ALLOC(dwLineSize * sizeof(CHAR));
    if (szLine == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    StringCchCopyA(szLine, dwLineSize, (LPSTR) pLog->pLastRecordRead);
    bInsideQuote = FALSE;
    for (szThisChar = szLine; * szThisChar != '\0'; szThisChar ++) {
        if (* szThisChar == DOUBLEQUOTE_A) {
            bInsideQuote = ! bInsideQuote;
        }
        else if ((* szThisChar == cDelim) && (! bInsideQuote)) {
            * szThisChar = '\0';
        }
    }

    dwIndex = 0;
    for (szThisChar = szLine; * szThisChar != '\0'; szThisChar += (lstrlenA(szThisChar) + 1)) {
        LPSTR szStart;
        LPSTR szEnd;
        BOOL  bReverse = FALSE;

        for (szStart = szThisChar; * szStart == '\"';) {
            szStart ++;
        }
        for (szEnd = szStart; * szEnd != '\0' && * szEnd != '\"'; szEnd ++);
        if (* szEnd == '\"') {
            bReverse = TRUE;
            * szEnd  = '\0';
        }

        if (dwIndex == 0) {
            FILETIME thisFileTime;
            if ((pLogInfo->dwRecMode & PDH_TEXT_REC_MODE_TIMESTAMP) == 0) {
                if (PdhiDateStringToFileTimeA(szStart, & thisFileTime)) {
                    pLogInfo->ThisTime   = MAKELONGLONG(thisFileTime.dwLowDateTime, thisFileTime.dwHighDateTime);
                    pLogInfo->dwRecMode |= PDH_TEXT_REC_MODE_TIMESTAMP;
                }
                else {
                    pLogInfo->ThisTime = 0;
                    Status             = GetLastError();
                    goto Cleanup;
                }
            }
            if ((RequestMode & PDH_TEXT_REC_MODE_VALUE) == 0) {
                goto Cleanup;
            }
        }
        else if ((RequestMode & PDH_TEXT_REC_MODE_VALUE) == 0) {
            goto Cleanup;
        }
        else {
            if (dwIndex > pLogInfo->dwCounter) {
                DOUBLE * pTmpLine = pLogInfo->CtrList;

                if (pLogInfo->CtrList == NULL) {
                    pLogInfo->CtrList = G_ALLOC(dwIndex * sizeof(DOUBLE));
                }
                else {
                    pLogInfo->CtrList = G_REALLOC(pTmpLine, dwIndex * sizeof(DOUBLE));
                }
                if (pLogInfo->CtrList == NULL) {
                    if (pTmpLine != NULL) G_FREE(pTmpLine);
                    Status = PDH_MEMORY_ALLOCATION_FAILURE;
                    goto Cleanup;
                }
                pLogInfo->dwCounter = dwIndex;
            }

            if (* szStart >= '0' && * szStart <= '9') {
                pLogInfo->CtrList[dwIndex - 1] = atof(szStart);
            }
            else {
                pLogInfo->CtrList[dwIndex - 1] = -1.0;
            }
        }
        if (bReverse && szEnd != NULL) {
            * szEnd = '\"';
        }
        dwIndex ++;
    }

    pLogInfo->dwRecMode |= PDH_TEXT_REC_MODE_VALUE;

Cleanup:
    G_FREE(szLine);
    return Status;
}

PDH_FUNCTION
PdhiGetTextLogCounterInfo(
    PPDHI_LOG     pLog,
    PPDHI_COUNTER pCounter
)
{
    PDH_STATUS          pdhStatus   = ERROR_SUCCESS;
    PPDHI_TEXT_LOG_INFO pLogInfo    = NULL;
    PPDHI_LOG_COUNTER   pLogCounter = NULL;
    DWORD               dwCtrIndex  = 0;
    BOOL                bNoMachine  = FALSE;

    pdhStatus = PdhiBuildTextHeaderCache(pLog);
    if (pdhStatus != ERROR_SUCCESS) goto Cleanup;

    pLogInfo = (PPDHI_TEXT_LOG_INFO) pLog->pPerfmonInfo;
    if (pLogInfo == NULL) {
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
        goto Cleanup;
    }

    if (lstrcmpiW(pCounter->pCounterPath->szMachineName, L"\\\\.") == 0) {
        bNoMachine = TRUE;
    }
    pLogCounter = PdhiFindLogCounter(pLog,
                                     & (pLogInfo->MachineList),
                                     pCounter->pCounterPath->szMachineName,
                                     pCounter->pCounterPath->szObjectName,
                                     pCounter->pCounterPath->szCounterName,
                                     PERF_DOUBLE_RAW,
                                     0,
                                     pCounter->pCounterPath->szInstanceName,
                                     pCounter->pCounterPath->dwIndex,
                                     pCounter->pCounterPath->szParentName,
                                     0,
                                     & dwCtrIndex,
                                     FALSE);
    if (pLogCounter != NULL) {
        if (bNoMachine) {
            pCounter->pCounterPath->szMachineName = NULL;
        }
        pCounter->plCounterInfo.dwObjectId           = 0;
        pCounter->plCounterInfo.lInstanceId          = pCounter->pCounterPath->dwIndex;
        pCounter->plCounterInfo.szInstanceName       = NULL;
        pCounter->plCounterInfo.dwParentObjectId     = 0;
        pCounter->plCounterInfo.szParentInstanceName = NULL;
        pCounter->plCounterInfo.dwCounterId          = dwCtrIndex;
        pCounter->plCounterInfo.dwCounterType        = PERF_DOUBLE_RAW;
        pCounter->plCounterInfo.dwCounterSize        = 8;
        pdhStatus                                    = ERROR_SUCCESS;
    }
    else {
        pdhStatus = PDH_CSTATUS_NO_COUNTER;
    }

Cleanup:
    return pdhStatus;
}

PDH_FUNCTION
PdhiOpenInputTextLog(
    PPDHI_LOG pLog
)
{
    PDH_STATUS          pdhStatus = ERROR_SUCCESS;
    PPDHI_TEXT_LOG_INFO pLogInfo  = NULL;

    // open a stream handle for easy C RTL I/O
    pLog->StreamFile = _wfopen (pLog->szLogFileName, (LPCWSTR)L"rt");
    if (pLog->StreamFile == NULL || pLog->StreamFile == (FILE *) ((DWORD_PTR) (-1))) {
        pLog->StreamFile = (FILE *) ((DWORD_PTR) (-1));
        pdhStatus        = PDH_LOG_FILE_OPEN_ERROR;
    }
    else {
        pdhStatus = ERROR_SUCCESS;
    }

    pLogInfo = G_ALLOC(sizeof(PDHI_TEXT_LOG_INFO));
    if (pLogInfo != NULL) {
        pLog->pPerfmonInfo  = pLogInfo;
        pLogInfo->dwRecMode = PDH_TEXT_REC_MODE_NONE;
    }
    else {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiOpenOutputTextLog(
    PPDHI_LOG pLog
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    pLog->StreamFile    = (FILE *) ((DWORD_PTR) (-1));
    pLog->dwRecord1Size = 0;
    return pdhStatus;
}

PDH_FUNCTION
PdhiCloseTextLog(
    PPDHI_LOG pLog,
    DWORD     dwFlags
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;

    UNREFERENCED_PARAMETER (dwFlags);
    if (pLog->pPerfmonInfo != NULL) {
        PPDHI_TEXT_LOG_INFO pTextLogInfo = (PPDHI_TEXT_LOG_INFO) pLog->pPerfmonInfo;

        PdhiFreeLogMachineTable(& pTextLogInfo->MachineList);
        G_FREE(pTextLogInfo->CtrList);
        G_FREE(pTextLogInfo);
        pLog->pPerfmonInfo = NULL;
    }
    if (pLog->StreamFile != NULL && pLog->StreamFile != (FILE *)((DWORD_PTR)(-1))) {
       fclose(pLog->StreamFile);
       pLog->StreamFile = (FILE *) ((DWORD_PTR) (-1));
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiWriteTextLogHeader(
    PPDHI_LOG pLog,
    LPCWSTR   szUserCaption
)
{
    PDH_STATUS    pdhStatus          = ERROR_SUCCESS;
    PPDHI_COUNTER pThisCounter;
    CHAR          cDelim;
    CHAR          szLeadDelim[4];
    DWORD         dwLeadSize;
    CHAR          szTrailDelim[4];
    DWORD         dwTrailSize;
    DWORD         dwBytesWritten;
    LPSTR         szCounterPath      = NULL;
    LPWSTR        wszCounterPath     = NULL;
    LPSTR         szLocalCaption     = NULL;
    DWORD         dwCaptionSize      = 0;
    BOOL          bDefaultCaption;
    LPSTR         szOutputString     = NULL;
    LPSTR         szTmpString;
    DWORD         dwStringBufferSize = 0;
    DWORD         dwStringBufferUsed = 0;
    DWORD         dwNewStringLen;

    szCounterPath  = G_ALLOC(MEDIUM_BUFFER_SIZE * sizeof(CHAR));
    wszCounterPath = G_ALLOC(MEDIUM_BUFFER_SIZE * sizeof(WCHAR));
    szOutputString = G_ALLOC(MEDIUM_BUFFER_SIZE * sizeof(CHAR));
    if (szCounterPath == NULL || wszCounterPath == NULL || szOutputString == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }
    else if (pLog->pQuery == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
        goto Cleanup;
    }
    dwStringBufferSize = MEDIUM_BUFFER_SIZE;
    cDelim             = (CHAR) ((LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_CSV) ? COMMA_DELIMITER : TAB_DELIMITER);
    szLeadDelim[0]     = cDelim;
    szLeadDelim[1]     = DOUBLE_QUOTE;
    szLeadDelim[2]     = 0;
    szLeadDelim[3]     = 0;
    dwLeadSize         = 2 * sizeof(szLeadDelim[0]);
    szTrailDelim[0]    = DOUBLE_QUOTE;
    szTrailDelim[1]    = 0;
    szTrailDelim[2]    = 0;
    szTrailDelim[3]    = 0;
    dwTrailSize        = 1 * sizeof(szTrailDelim[0]);

    // we'll assume the buffer allocated is large enough to hold the timestamp 
    // and 1st counter name. After that we'll test the size first.

    StringCchCopyA(szOutputString, dwStringBufferSize, szTrailDelim);
    StringCchCatA(szOutputString, dwStringBufferSize,
                  (LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_CSV ? szCsvLogFileHeader : szTsvLogFileHeader));

    {
        // Add TimeZone information
        //
        DWORD dwReturn = GetTimeZoneInformation(&TimeZone);
        CHAR  strTimeZone[MAX_PATH];

        if (dwReturn != TIME_ZONE_ID_INVALID) {
            if (dwReturn == TIME_ZONE_ID_DAYLIGHT) {
                StringCchPrintfA(strTimeZone, MAX_PATH, " (%ws)(%d)",
                                TimeZone.DaylightName, TimeZone.Bias + TimeZone.DaylightBias);
                TRACE((PDH_DBG_TRACE_INFO),
                      (__LINE__,
                       PDH_LOGTEXT,
                       ARG_DEF(ARG_TYPE_STR,1),
                       ERROR_SUCCESS,
                       TRACE_STR(strTimeZone),
                       TRACE_DWORD(dwReturn),
                       TRACE_DWORD(TimeZone.Bias),
                       TRACE_DWORD(TimeZone.DaylightBias),
                       NULL));
            }
            else {
                StringCchPrintfA(strTimeZone, MAX_PATH, " (%ws)(%d)",
                                TimeZone.StandardName, TimeZone.Bias + TimeZone.StandardBias);
                TRACE((PDH_DBG_TRACE_INFO),
                      (__LINE__,
                       PDH_LOGTEXT,
                       ARG_DEF(ARG_TYPE_STR,1),
                       ERROR_SUCCESS,
                       TRACE_STR(strTimeZone),
                       TRACE_DWORD(dwReturn),
                       TRACE_DWORD(TimeZone.Bias),
                       TRACE_DWORD(TimeZone.StandardBias),
                       NULL));
            }
            StringCchCatA(szOutputString, dwStringBufferSize, strTimeZone);
            pLog->dwRecord1Size = 1;
        }
    }

    StringCchCatA(szOutputString, MEDIUM_BUFFER_SIZE, szTrailDelim);

    // get buffer size here
    dwStringBufferUsed = lstrlenA(szOutputString);

    // check each counter in the list of counters for this query and
    // write them to the file

    // output the path names
    pThisCounter = pLog->pQuery->pCounterListHead;

    if (pThisCounter != NULL) {
        do {
            // get the counter path information from the counter
            ZeroMemory(wszCounterPath, sizeof(WCHAR) * MEDIUM_BUFFER_SIZE);
            ZeroMemory(szCounterPath,  sizeof(CHAR)  * MEDIUM_BUFFER_SIZE);

            PdhiBuildFullCounterPath(TRUE,
                                     pThisCounter->pCounterPath,
                                     pThisCounter->pCounterPath->szObjectName,
                                     pThisCounter->pCounterPath->szCounterName,
                                     wszCounterPath,
                                     MEDIUM_BUFFER_SIZE);
            WideCharToMultiByte(_getmbcp(),
                                0,
                                wszCounterPath,
                                lstrlenW(wszCounterPath),
                                (LPSTR) szCounterPath,
                                MEDIUM_BUFFER_SIZE,
                                NULL,
                                NULL);
            dwNewStringLen  = lstrlenA(szCounterPath);
            dwNewStringLen += dwLeadSize;
            dwNewStringLen += dwTrailSize;

            TRACE((PDH_DBG_TRACE_INFO),
                  (__LINE__,
                   PDH_LOGTEXT,
                   ARG_DEF(ARG_TYPE_STR,1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                   ERROR_SUCCESS,
                   TRACE_STR(szCounterPath),
                   TRACE_WSTR(wszCounterPath),
                   TRACE_DWORD(dwNewStringLen),
                   TRACE_DWORD(dwLeadSize),
                   TRACE_DWORD(dwTrailSize),
                   TRACE_DWORD(dwStringBufferUsed),
                   TRACE_DWORD(dwStringBufferSize),
                   NULL));

            if ((dwNewStringLen + dwStringBufferUsed) >= dwStringBufferSize) {
                dwStringBufferSize += SMALL_BUFFER_SIZE;
                szTmpString         = szOutputString;
                szOutputString      = G_REALLOC(szTmpString, dwStringBufferSize);
                if (szOutputString == NULL) {
                    G_FREE(szTmpString);
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    break; // out of DO loop
                }
            }
            else {
                // mem alloc ok, so continue
            }

            StringCchCatA(szOutputString, dwStringBufferSize, szLeadDelim);
            if (pdhStatus == ERROR_SUCCESS) {
                StringCchCatA(szOutputString, dwStringBufferSize, szCounterPath);
            }
            else {
                // just write the delimiters and no string inbetween
            }
            StringCchCatA(szOutputString, dwStringBufferSize, szTrailDelim);

            dwStringBufferUsed += dwNewStringLen;
            pThisCounter        = pThisCounter->next.flink; // go to next in list
        }
        while (pThisCounter != pLog->pQuery->pCounterListHead);
    }

    // test to see if the caller wants to append user strings to the log

    if (((pLog->dwLogFormat & PDH_LOG_OPT_MASK) == PDH_LOG_OPT_USER_STRING) && (pdhStatus == ERROR_SUCCESS)) { 
        // they want to write user data  so  see if they've passed in a
        // caption string
        if (szUserCaption != NULL) {
            dwCaptionSize  = lstrlenW(szUserCaption) + 1;
            // allocate larger buffer to accomodate DBCS characters
            dwCaptionSize  = dwCaptionSize * 3 * sizeof (CHAR);
            szLocalCaption = (LPSTR) G_ALLOC(dwCaptionSize);
            if (szLocalCaption != NULL) {
                dwCaptionSize = WideCharToMultiByte(_getmbcp(),
                                                    0,
                                                    szUserCaption,
                                                    lstrlenW(szUserCaption),
                                                    szLocalCaption,
                                                    dwCaptionSize,
                                                    NULL,
                                                    NULL);
                bDefaultCaption = FALSE;
            }
            else {
                bDefaultCaption = TRUE;
            }
        }
        else {
            bDefaultCaption = TRUE;
        }

        if (bDefaultCaption) {
            szLocalCaption = (LPSTR) caszDefaultLogCaption;
            dwCaptionSize  = lstrlenA(szLocalCaption);
        }

        dwNewStringLen  = (DWORD)dwCaptionSize;
        dwNewStringLen += dwLeadSize;
        dwNewStringLen += dwTrailSize;

        if ((dwNewStringLen + dwStringBufferUsed) >= dwStringBufferSize) {
            dwStringBufferSize += SMALL_BUFFER_SIZE;
            szTmpString = szOutputString;
            szOutputString = G_REALLOC(szTmpString, dwStringBufferSize);
            if (szOutputString == NULL) {
                G_FREE(szTmpString);
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
        else {
            // mem alloc ok, so continue
        }

        if (pdhStatus == ERROR_SUCCESS) {
            StringCchCatA(szOutputString, dwStringBufferSize, szLeadDelim);
#pragma warning (disable : 4701 )    // szLocalCaption is initialized above
            StringCchCatA(szOutputString, dwStringBufferSize, szLocalCaption);
#pragma warning (default : 4701)    
            StringCchCatA(szOutputString, dwStringBufferSize, szTrailDelim);
        }

        dwStringBufferUsed += dwNewStringLen;
        if (! bDefaultCaption) {
            G_FREE(szLocalCaption);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if ((PdhidwRecordTerminatorLength + dwStringBufferUsed) >= dwStringBufferSize) {
            dwStringBufferSize += PdhidwRecordTerminatorLength;
            szTmpString         = szOutputString;
            szOutputString      = G_REALLOC(szTmpString, dwStringBufferSize);
            if (szOutputString == NULL) {
                G_FREE(szTmpString);
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
        else {
            // mem alloc ok, so continue
        }

        if (pdhStatus == ERROR_SUCCESS) {
            StringCchCatA(szOutputString, dwStringBufferSize, PdhiszRecordTerminator);
            dwStringBufferUsed += PdhidwRecordTerminatorLength;

            // write  the record
            if (! WriteFile(pLog->hLogFileHandle,
                            (LPCVOID) szOutputString,
                            dwStringBufferUsed,
                            & dwBytesWritten,
                            NULL)) {
                pdhStatus = GetLastError();
            }
            else if (pLog->pQuery->hLog == H_REALTIME_DATASOURCE || pLog->pQuery->hLog == H_WBEM_DATASOURCE) {
                FlushFileBuffers(pLog->hLogFileHandle);
            }
            if (dwStringBufferUsed > pLog->dwMaxRecordSize) {
                // then update the buffer size
                pLog->dwMaxRecordSize = dwStringBufferUsed;
            }
        }
    }

Cleanup:
    G_FREE(szCounterPath);
    G_FREE(wszCounterPath);
    G_FREE(szOutputString);
    return pdhStatus;
}

PDH_FUNCTION
PdhiWriteTextLogRecord(
    PPDHI_LOG    pLog,
    SYSTEMTIME * stTimeStamp,
    LPCWSTR      szUserString
)
{
    PDH_STATUS           pdhStatus         = ERROR_SUCCESS;
    PPDHI_COUNTER        pThisCounter;
    CHAR                 cDelim;
    DWORD                dwBytesWritten;
    CHAR                 szValueBuffer[VALUE_BUFFER_SIZE];
    PDH_FMT_COUNTERVALUE pdhValue;
    DWORD                dwUserStringSize;
    LPSTR                szLocalUserString  = NULL;
    BOOL                 bDefaultUserString;
    LPSTR                szOutputString     = NULL;
    DWORD                dwStringBufferSize = 0;
    DWORD                dwStringBufferUsed = 0;
    DWORD                dwNewStringLen;
    SYSTEMTIME           lstTimeStamp;
    LARGE_INTEGER        liFileSize;

    dwStringBufferSize = (MEDIUM_BUFFER_SIZE > pLog->dwMaxRecordSize ?  MEDIUM_BUFFER_SIZE : pLog->dwMaxRecordSize);

    szOutputString = G_ALLOC (dwStringBufferSize);
    if (szOutputString == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto endLogText; 
    }
    else if (pLog->pQuery == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
        goto endLogText; 
    }

    cDelim = (CHAR)((LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_CSV) ? COMMA_DELIMITER : TAB_DELIMITER);

    // format and write the time stamp title
    lstTimeStamp       = * stTimeStamp;
    StringCchPrintfA(szOutputString, dwStringBufferSize, PdhiszFmtTimeStamp,
                            lstTimeStamp.wMonth, lstTimeStamp.wDay,    lstTimeStamp.wYear,
                            lstTimeStamp.wHour,  lstTimeStamp.wMinute, lstTimeStamp.wSecond,
                            lstTimeStamp.wMilliseconds);
    dwStringBufferUsed = lstrlenA(szOutputString);

    // check each counter in the list of counters for this query and
    // write them to the file

    pThisCounter = pLog->pQuery->pCounterListHead;

    if (pThisCounter != NULL) {
        // lock the query while we read the data so the values
        // written to the log will all be from the same sample
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pThisCounter->pOwner->hMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            do {
                // get the formatted value from the counter

                // compute and format current value
                pdhStatus = PdhiComputeFormattedValue(pThisCounter->CalcFunc,
                                                      pThisCounter->plCounterInfo.dwCounterType,
                                                      pThisCounter->lScale,
                                                      PDH_FMT_DOUBLE | PDH_FMT_NOCAP100,
                                                      & pThisCounter->ThisValue,
                                                      & pThisCounter->LastValue,
                                                      & pThisCounter->TimeBase,
                                                      0L,
                                                      & pdhValue);
                if ((pdhStatus == ERROR_SUCCESS) &&
                    ((pdhValue.CStatus == PDH_CSTATUS_VALID_DATA) || (pdhValue.CStatus == PDH_CSTATUS_NEW_DATA))) {
                    // then this is a valid data value so print it
                    StringCchPrintfA(szValueBuffer, VALUE_BUFFER_SIZE, PdhiszFmtRealValue,
                                            cDelim, pdhValue.doubleValue);
                }
                else {
                    // invalid data so show a blank data value
                    StringCchPrintfA(szValueBuffer, VALUE_BUFFER_SIZE, PdhiszFmtStringValue,
                                            cDelim, caszSpace);
                    // reset error
                    pdhStatus = ERROR_SUCCESS;
                }

                dwNewStringLen = lstrlenA(szValueBuffer);

                if ((dwNewStringLen + dwStringBufferUsed) >= dwStringBufferSize) {
                    LPTSTR szNewString;
                    dwStringBufferSize += SMALL_BUFFER_SIZE;
                    szNewString         = G_REALLOC(szOutputString, dwStringBufferSize);
                    if (szNewString == NULL) {
                        if (szOutputString != NULL) G_FREE(szOutputString);
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        break; // out of DO loop
                    }
                    else {
                        szOutputString = szNewString;
                    }
                }

                if (pdhStatus != PDH_MEMORY_ALLOCATION_FAILURE) {
                    StringCchCatA(szOutputString, dwStringBufferSize, szValueBuffer);
                    dwStringBufferUsed += dwNewStringLen;
                }

                // goto the next counter in the list
                pThisCounter = pThisCounter->next.flink; // go to next in list
            }
            while (pThisCounter != pLog->pQuery->pCounterListHead);
            // free (i.e. unlock) the query
            RELEASE_MUTEX(pThisCounter->pOwner->hMutex);
        }
    }

    if (pdhStatus == PDH_MEMORY_ALLOCATION_FAILURE) // cannot go further
        goto  endLogText;

    // test to see if the caller wants to append user strings to the log

    if ((pLog->dwLogFormat & PDH_LOG_OPT_MASK) == PDH_LOG_OPT_USER_STRING) {
        // they want to write user data  so  see if they've passed in a
        // display string
        if (szUserString != NULL) {
            // get size in chars
            dwUserStringSize = lstrlenW(szUserString) + 1;
            // allocate larger buffer to accomodate DBCS characters
            dwUserStringSize = dwUserStringSize * 3 * sizeof(CHAR);
            szLocalUserString = (LPSTR) G_ALLOC(dwUserStringSize);
            if (szLocalUserString != NULL) {
                ZeroMemory(szLocalUserString, dwUserStringSize);
                dwUserStringSize = WideCharToMultiByte(_getmbcp(),
                                                       0,
                                                       szUserString,
                                                       lstrlenW(szUserString),
                                                       szLocalUserString,
                                                       dwUserStringSize,
                                                       NULL,
                                                       NULL);
                bDefaultUserString = FALSE;
            }
            else {
                bDefaultUserString = TRUE;
            }
        }
        else {
            bDefaultUserString = TRUE;
        }

        if (bDefaultUserString) {
            szLocalUserString = (LPSTR) caszSpace;
            dwUserStringSize = lstrlenA(szLocalUserString);
        }

#pragma warning (disable : 4701) // szLocalUserString is init'd above
        StringCchPrintfA(szValueBuffer, VALUE_BUFFER_SIZE, PdhiszFmtStringValue, cDelim, szLocalUserString);
#pragma warning (default : 4701)    

        dwNewStringLen = lstrlenA(szValueBuffer);

        if ((dwNewStringLen + dwStringBufferUsed) >= dwStringBufferSize) {
            LPTSTR szNewString;

            dwStringBufferSize += SMALL_BUFFER_SIZE;
            szNewString         = G_REALLOC(szOutputString, dwStringBufferSize);
            if (szNewString == NULL) {
                if (szOutputString != NULL) G_FREE(szOutputString);
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
            else {
                szOutputString = szNewString;
            }
        }
        if (pdhStatus != PDH_MEMORY_ALLOCATION_FAILURE) {
            StringCchCatA(szOutputString, dwStringBufferSize, szValueBuffer);
            dwStringBufferUsed += dwNewStringLen;
        }
        if (! bDefaultUserString) {
            G_FREE(szLocalUserString);
        }
    }

    if (pdhStatus == PDH_MEMORY_ALLOCATION_FAILURE)
        goto endLogText;

    if ((PdhidwRecordTerminatorLength + dwStringBufferUsed) >= dwStringBufferSize) {
        LPTSTR szNewString;
        dwStringBufferSize += PdhidwRecordTerminatorLength;
        szNewString         = G_REALLOC(szOutputString, dwStringBufferSize);
        if (szNewString == NULL) {
            if (szOutputString != NULL) G_FREE(szOutputString);
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        else {
            szOutputString = szNewString;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        StringCchCatA(szOutputString, dwStringBufferSize, PdhiszRecordTerminator);
        dwStringBufferUsed += PdhidwRecordTerminatorLength;

        liFileSize.LowPart = GetFileSize(pLog->hLogFileHandle, (LPDWORD) & liFileSize.HighPart);
        // add in new record to see if it will fit.
        liFileSize.QuadPart += dwStringBufferUsed;
        // test for maximum allowable filesize
        if (liFileSize.QuadPart <= MAX_TEXT_FILE_SIZE) {
            // write  the record terminator
            if (! WriteFile(pLog->hLogFileHandle,
                            (LPCVOID) szOutputString,
                            dwStringBufferUsed,
                            & dwBytesWritten,
                            NULL)) {
                pdhStatus = GetLastError();
            }
            else if (pLog->pQuery->hLog == H_REALTIME_DATASOURCE || pLog->pQuery->hLog == H_WBEM_DATASOURCE) {
                FlushFileBuffers(pLog->hLogFileHandle);
            }
        }
        else {
            pdhStatus = ERROR_LOG_FILE_FULL;
        } 

        if (dwStringBufferUsed> pLog->dwMaxRecordSize) {
            // then update the buffer size
            pLog->dwMaxRecordSize = dwStringBufferUsed;
        }
    }

endLogText: 
    G_FREE(szOutputString);
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumCachedMachines(
    PPDHI_LOG_MACHINE MachineList,
    LPVOID            pBuffer,
    LPDWORD           lpdwBufferSize,
    BOOL              bUnicodeDest
)
{
    PDH_STATUS        pdhStatus       = ERROR_SUCCESS;
    DWORD             dwBufferUsed    = 0;
    DWORD             dwNewBuffer     = 0;
    DWORD             dwItemCount     = 0;
    LPVOID            LocalBuffer     = NULL;
    LPVOID            TempBuffer      = NULL;
    DWORD             LocalBufferSize = 0;
    PPDHI_LOG_MACHINE pMachine;

    LocalBufferSize = MEDIUM_BUFFER_SIZE;
    LocalBuffer     = G_ALLOC(LocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
    if (LocalBuffer == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    dwItemCount  = 0;
    dwBufferUsed = 0;
    dwItemCount  = 0;
    for (pMachine = MachineList; pMachine != NULL; pMachine = pMachine->next) {
        if (pMachine->szMachine != NULL) {
            dwNewBuffer = (lstrlenW(pMachine->szMachine) + 1);
            while (LocalBufferSize  < (dwBufferUsed + dwNewBuffer)) {
                TempBuffer       = LocalBuffer;
                LocalBufferSize += MEDIUM_BUFFER_SIZE;
                LocalBuffer = G_REALLOC(TempBuffer, LocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
                if (LocalBuffer == NULL) {
                    if (TempBuffer != NULL) G_FREE(TempBuffer);
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    goto Cleanup;
                }
            }
            pdhStatus = AddUniqueWideStringToMultiSz((LPVOID) LocalBuffer,
                                                     pMachine->szMachine,
                                                     LocalBufferSize - dwBufferUsed,
                                                     & dwNewBuffer,
                                                     bUnicodeDest);
            if (pdhStatus == ERROR_SUCCESS) {
                if (dwNewBuffer > 0) {
                    dwBufferUsed = dwNewBuffer;
                    dwItemCount ++;
                }
            }
            else {
                // PDH_MORE_DATA should not happen because we enlarge buffer before
                // AddUniqueWideStringToMultiSz() call.
                if (pdhStatus == PDH_MORE_DATA) pdhStatus = PDH_INVALID_DATA;
                break;
            }
        }
        else {
            dwNewBuffer = 0;

        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwItemCount > 0) {
            dwBufferUsed ++;
        }
        if (pBuffer && (dwBufferUsed <= * lpdwBufferSize)) {
            RtlCopyMemory(pBuffer, LocalBuffer, dwBufferUsed * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
        }
        else {
            if (pBuffer) RtlCopyMemory(pBuffer,
                                       LocalBuffer,
                                       (* lpdwBufferSize) * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
            pdhStatus = PDH_MORE_DATA;
        }
        * lpdwBufferSize = dwBufferUsed;
    }

Cleanup:
    if (LocalBuffer != NULL) G_FREE(LocalBuffer);
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumMachinesFromTextLog(
    PPDHI_LOG   pLog,
    LPVOID      pBuffer,
    LPDWORD     lpdwBufferSize,
    BOOL        bUnicodeDest
)
{
    PDH_STATUS Status = ERROR_SUCCESS;

    Status = PdhiBuildTextHeaderCache(pLog);
    if (Status == ERROR_SUCCESS) {
        PPDHI_TEXT_LOG_INFO pLogInfo = (PPDHI_TEXT_LOG_INFO) pLog->pPerfmonInfo;
        if (pLogInfo == NULL) {
            Status = PDH_LOG_FILE_OPEN_ERROR;
        }
        else {
            Status = PdhiEnumCachedMachines(pLogInfo->MachineList, pBuffer, lpdwBufferSize, bUnicodeDest);
        }
    }
    return Status;
}

PDH_FUNCTION
PdhiEnumCachedObjects(
    PPDHI_LOG_MACHINE MachineList,
    LPCWSTR           szMachineName,
    LPVOID            pBuffer,
    LPDWORD           pcchBufferSize,
    DWORD             dwDetailLevel,
    BOOL              bUnicodeDest
)
{
    PDH_STATUS          pdhStatus        = ERROR_SUCCESS;
    DWORD               dwBufferUsed     = 0;
    DWORD               dwNewBuffer      = 0;
    DWORD               dwItemCount      = 0;
    LPVOID              LocalBuffer      = NULL;
    LPVOID              TempBuffer       = NULL;
    DWORD               LocalBufferSize  = 0;
    PPDHI_LOG_MACHINE   pMachine         = NULL;
    PPDHI_LOG_OBJECT    pObject          = NULL;
    LPWSTR              szLocMachine     = (LPWSTR) szMachineName;

    UNREFERENCED_PARAMETER(dwDetailLevel);

    LocalBufferSize = MEDIUM_BUFFER_SIZE;
    LocalBuffer     = G_ALLOC(LocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
    if (LocalBuffer == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    if (szLocMachine == NULL) szLocMachine = (LPWSTR) szStaticLocalMachineName;

    dwBufferUsed = 0;
    dwNewBuffer  = 0;
    dwItemCount  = 0;

    for (pMachine = MachineList; pMachine != NULL; pMachine = pMachine->next) {
        if (lstrcmpiW(pMachine->szMachine, szLocMachine) == 0) break;
    }

    if (pMachine != NULL) {
        for (pObject = pMachine->ObjList; pObject != NULL; pObject = pObject->next) {
            if (pObject->szObject != NULL) {
                dwNewBuffer = (lstrlenW(pObject->szObject) + 1);
                while (LocalBufferSize  < (dwBufferUsed + dwNewBuffer)) {
                    LocalBufferSize += MEDIUM_BUFFER_SIZE;
                    TempBuffer       = LocalBuffer;
                    LocalBuffer      = G_REALLOC(TempBuffer,
                                                 LocalBufferSize * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
                    if (LocalBuffer == NULL) {
                        if (TempBuffer != NULL) G_FREE(TempBuffer);
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        goto Cleanup;
                    }
                }
                pdhStatus = AddUniqueWideStringToMultiSz((LPVOID) LocalBuffer,
                                                         pObject->szObject,
                                                         LocalBufferSize - dwBufferUsed,
                                                         & dwNewBuffer,
                                                         bUnicodeDest);
                if (pdhStatus == ERROR_SUCCESS) {
                    if (dwNewBuffer > 0) {
                        dwBufferUsed = dwNewBuffer;
                        dwItemCount ++;
                    }
                }
                else {
                    // PDH_MORE_DATA should not happen because we enlarge buffer before
                    // AddUniqueWideStringToMultiSz() call.
                    if (pdhStatus == PDH_MORE_DATA) pdhStatus = PDH_INVALID_DATA;
                    break;
                }
            }
            else {
                dwNewBuffer = 0;

            }
        }
    }
    else {
        pdhStatus = PDH_CSTATUS_NO_MACHINE;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (dwItemCount > 0) {
            dwBufferUsed ++;
        }
        if (dwBufferUsed > 0) {
            if (pBuffer && (dwBufferUsed <= * pcchBufferSize)) {
                RtlCopyMemory(pBuffer, LocalBuffer, dwBufferUsed * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
            }
            else {
                if (pBuffer) RtlCopyMemory(pBuffer,
                                           LocalBuffer,
                                           (* pcchBufferSize) * (bUnicodeDest ? sizeof(WCHAR) : sizeof(CHAR)));
                pdhStatus = PDH_MORE_DATA;
            }
        }
        * pcchBufferSize = dwBufferUsed;
    }

Cleanup:
    G_FREE(LocalBuffer);
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumObjectsFromTextLog(
    PPDHI_LOG pLog,
    LPCWSTR   szMachineName,
    LPVOID    pBuffer,
    LPDWORD   pcchBufferSize,
    DWORD     dwDetailLevel,
    BOOL      bUnicodeDest
)
{
    PDH_STATUS Status = ERROR_SUCCESS;

    Status = PdhiBuildTextHeaderCache(pLog);
    if (Status == ERROR_SUCCESS) {
        PPDHI_TEXT_LOG_INFO pLogInfo = (PPDHI_TEXT_LOG_INFO) pLog->pPerfmonInfo;
        if (pLogInfo == NULL) {
            Status = PDH_LOG_FILE_OPEN_ERROR;
        }
        else {
            Status = PdhiEnumCachedObjects(pLogInfo->MachineList,
                                           szMachineName,
                                           pBuffer,
                                           pcchBufferSize,
                                           dwDetailLevel,
                                           bUnicodeDest);
        }
    }
    return Status;
}

ULONG HashCounter(
    LPWSTR szCounterName
)
{
    ULONG       h = 0;
    ULONG       a = 31415;  //a, b, k are primes
    const ULONG k = 16381;
    const ULONG b = 27183;
    LPWSTR      szThisChar;

    if (szCounterName) {
        for (szThisChar = szCounterName; * szThisChar; szThisChar ++) {
            h = (a * h + ((ULONG) (* szThisChar))) % k;
            a = a * b % (k - 1);
        }
    }
    return (h % HASH_TABLE_SIZE);
}

void
PdhiInitCounterHashTable(
    PDHI_COUNTER_TABLE pTable
)
{
    ZeroMemory(pTable, sizeof(PDHI_COUNTER_TABLE));
}

void
PdhiResetInstanceCount(
    PDHI_COUNTER_TABLE pTable
)
{
    PLIST_ENTRY     pHeadInst;
    PLIST_ENTRY     pNextInst;
    PPDHI_INSTANCE  pInstance;
    PPDHI_INST_LIST pInstList;
    DWORD           i;

    for (i = 0; i < HASH_TABLE_SIZE; i ++) {
        pInstList = pTable[i];
        while (pInstList != NULL) {
            if (! IsListEmpty(& pInstList->InstList)) {
                pHeadInst = & pInstList->InstList;
                pNextInst = pHeadInst->Flink;
                while (pNextInst != pHeadInst) {
                    pInstance          = CONTAINING_RECORD(pNextInst, PDHI_INSTANCE, Entry);
                    pInstance->dwCount = 0;
                    pNextInst          = pNextInst->Flink;
                }
            }
            pInstList = pInstList->pNext;
        }
    }
}

PDH_FUNCTION
PdhiFindCounterInstList(
    PDHI_COUNTER_TABLE pHeadList,
    LPWSTR             szCounter,
    PPDHI_INST_LIST  * pInstList
)
{
    PDH_STATUS      Status     = ERROR_SUCCESS;
    ULONG           lIndex     = HashCounter(szCounter);
    PPDHI_INST_LIST pLocalList = pHeadList[lIndex];
    PPDHI_INST_LIST pRtnList   = NULL;

    * pInstList = NULL;
    while (pLocalList != NULL) {
        if (lstrcmpiW(pLocalList->szCounter, szCounter) == 0) {
            pRtnList = pLocalList;
            break;
        }
        pLocalList = pLocalList->pNext;
    }

    if (pRtnList == NULL) {
        pRtnList = G_ALLOC(sizeof(PDHI_INST_LIST) + sizeof(WCHAR) * (lstrlenW(szCounter) + 1));
        if (pRtnList == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }
        pRtnList->szCounter = (LPWSTR) (((LPBYTE) pRtnList) + sizeof(PDHI_INST_LIST));
        StringCchCopyW(pRtnList->szCounter, lstrlenW(szCounter) + 1, szCounter);
        InitializeListHead(& pRtnList->InstList);

        pRtnList->pNext   = pHeadList[lIndex];
        pHeadList[lIndex] = pRtnList;
    }

Cleanup:
    if (Status == ERROR_SUCCESS) {
        * pInstList = pRtnList;
    }
    return Status;
}

PDH_FUNCTION
PdhiFindInstance(
    PLIST_ENTRY      pHeadInst,
    LPWSTR           szInstance,
    BOOLEAN          bUpdateCount,
    PPDHI_INSTANCE * pInstance
)
{
    PDH_STATUS      Status   = ERROR_SUCCESS;
    PLIST_ENTRY     pNextInst;
    PPDHI_INSTANCE  pLocalInst;
    PPDHI_INSTANCE  pRtnInst = NULL;

    * pInstance = NULL;
    if (! IsListEmpty(pHeadInst)) {
        pNextInst = pHeadInst->Flink;
        while (pNextInst != pHeadInst) {
            pLocalInst = CONTAINING_RECORD(pNextInst, PDHI_INSTANCE, Entry);
            if (lstrcmpiW(pLocalInst->szInstance, szInstance) == 0) {
                pRtnInst = pLocalInst;
                break;
            }
            pNextInst = pNextInst->Flink;
        }
    }

    if (pRtnInst == NULL) {
        pRtnInst = G_ALLOC(sizeof(PDHI_INSTANCE) + sizeof(WCHAR) * (lstrlenW(szInstance) + 1));
        if (pRtnInst == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }
        pRtnInst->szInstance = (LPWSTR) (((LPBYTE) pRtnInst) + sizeof(PDHI_INSTANCE));
        StringCchCopyW(pRtnInst->szInstance, lstrlenW(szInstance) + 1, szInstance);
        pRtnInst->dwCount = pRtnInst->dwTotal = 0;
        InsertTailList(pHeadInst, & pRtnInst->Entry);
    }

    if (bUpdateCount) {
        pRtnInst->dwCount ++;
        if (pRtnInst->dwCount > pRtnInst->dwTotal) {
            pRtnInst->dwTotal = pRtnInst->dwCount;
        }
    }
    else if (pRtnInst->dwCount == 0) {
        pRtnInst->dwCount = pRtnInst->dwTotal = 1;
    }

Cleanup:
    if (Status == ERROR_SUCCESS) {
        * pInstance = pRtnInst;
    }
    return Status;
}

DWORD
AddStringToMultiSz(
    LPVOID  mszDest,
    LPWSTR  szSource,
    BOOL    bUnicodeDest
)
{
    LPVOID szDestElem;
    DWORD  dwReturnLength;
    LPSTR  aszSource = NULL;
    DWORD  dwLength;

    if ((mszDest == NULL) || (szSource == NULL) || (* szSource == L'\0')) {
        return 0;
    }

    if (!bUnicodeDest) {
        dwLength = lstrlenW(szSource) + 1;
        aszSource = G_ALLOC(dwLength * 3 * sizeof(CHAR));
        if (aszSource != NULL) {
            WideCharToMultiByte(_getmbcp(), 0, szSource, lstrlenW(szSource), aszSource, dwLength, NULL, NULL);
            dwReturnLength = 1;
        }
        else {
            dwReturnLength = 0;
        }
    }
    else {
        dwReturnLength = 1;
    }

    if (dwReturnLength > 0) {
        for (szDestElem = mszDest;
                        (bUnicodeDest ? (* (LPWSTR) szDestElem != L'\0') : (* (LPSTR)  szDestElem != '\0')); ) {
            if (bUnicodeDest) {
                szDestElem = (LPVOID) ((LPWSTR) szDestElem + (lstrlenW((LPCWSTR) szDestElem) + 1));
            }
            else {
                szDestElem = (LPVOID) ((LPSTR) szDestElem + (lstrlenA((LPCSTR) szDestElem) + 1));
            }
        }

        if (bUnicodeDest) {
            StringCchCopyW((LPWSTR) szDestElem, lstrlenW(szSource) + 1, szSource);
            szDestElem              = (LPVOID) ((LPWSTR) szDestElem + lstrlenW(szSource) + 1);
            * ((LPWSTR) szDestElem) = L'\0';
            dwReturnLength          = (DWORD) ((LPWSTR) szDestElem - (LPWSTR) mszDest);
        }
        else {
            StringCchCopyA((LPSTR) szDestElem, lstrlenA(aszSource) + 1, aszSource);
            szDestElem            = (LPVOID)((LPSTR)szDestElem + lstrlenA(szDestElem) + 1);
            * ((LPSTR)szDestElem) = '\0';
            dwReturnLength        = (DWORD) ((LPSTR) szDestElem - (LPSTR) mszDest);
        }
    }

    G_FREE(aszSource);

    return (DWORD) dwReturnLength;
}

PDH_FUNCTION
PdhiEnumCachedObjectItems(
    PPDHI_LOG_MACHINE  MachineList,
    LPCWSTR            szMachineName,
    LPCWSTR            szObjectName,
    PDHI_COUNTER_TABLE CounterTable,
    DWORD              dwDetailLevel,
    DWORD              dwFlags
)
{
    PDH_STATUS          pdhStatus       = ERROR_SUCCESS;
    DWORD               dwItemCount     = 0;
    LPWSTR              szFullInstance  = NULL;
    DWORD               dwFullInstance  = SMALL_BUFFER_SIZE;
    LPWSTR              szLocMachine    = (LPWSTR) szMachineName;
    PPDHI_INSTANCE      pInstance;
    PPDHI_INST_LIST     pInstList;
    PPDHI_LOG_MACHINE   pMachine        = NULL;
    PPDHI_LOG_OBJECT    pObject         = NULL;
    PPDHI_LOG_COUNTER   pCounter        = NULL;

    UNREFERENCED_PARAMETER(dwDetailLevel);
    UNREFERENCED_PARAMETER(dwFlags);

    if (szLocMachine == NULL) szLocMachine = (LPWSTR) szStaticLocalMachineName;

    for (pMachine = MachineList; pMachine != NULL; pMachine = pMachine->next) {
        if (lstrcmpiW(pMachine->szMachine, szLocMachine) == 0) break;
    }

    if (pMachine != NULL) {
        pObject = PdhiFindLogObject(pMachine, & (pMachine->ObjTable), (LPWSTR) szObjectName, FALSE);
    }
    else {
        pdhStatus = PDH_CSTATUS_NO_MACHINE;
        pObject   = NULL;
    }

    if (pObject != NULL) {
        WCHAR szIndexNumber[20];

        szFullInstance = G_ALLOC(dwFullInstance * sizeof(WCHAR));
        if (szFullInstance == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }

        for (pCounter = pObject->CtrList; pCounter != NULL; pCounter = pCounter->next) {
            pdhStatus = PdhiFindCounterInstList(CounterTable, pCounter->szCounter, & pInstList);
            if (pdhStatus != ERROR_SUCCESS) continue;

            if (pCounter->szInstance != NULL && pCounter->szInstance[0] != L'\0') {
                if (pCounter->szParent != NULL && pCounter->szParent[0] != L'\0') {
                    StringCchPrintfW(szFullInstance, dwFullInstance, L"%ws%ws%ws",
                            pCounter->szParent, L"/", pCounter->szInstance);
                }
                else {
                    StringCchCopyW(szFullInstance, dwFullInstance, pCounter->szInstance);
                }
                if (pCounter->dwInstance > 0) {
                    ZeroMemory(szIndexNumber, 20 * sizeof(WCHAR));
                    _ultow(pCounter->dwInstance, szIndexNumber, 10);
                    StringCchCatW(szFullInstance, dwFullInstance, L"#");
                    StringCchCatW(szFullInstance, dwFullInstance, szIndexNumber);
                }
                pdhStatus = PdhiFindInstance(& pInstList->InstList, szFullInstance, TRUE, & pInstance);
            }

            if (pdhStatus == ERROR_SUCCESS) {
                dwItemCount ++;
            }
        }
    }
    else if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PDH_CSTATUS_NO_OBJECT;
    }
    if (dwItemCount > 0) {
        // then the routine was successful. Errors that occurred
        // while scanning will be ignored as long as at least
        // one entry was successfully read

        pdhStatus = ERROR_SUCCESS;
    }

Cleanup:
    G_FREE(szFullInstance);
    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumObjectItemsFromTextLog(
    PPDHI_LOG          pLog,
    LPCWSTR            szMachineName,
    LPCWSTR            szObjectName,
    PDHI_COUNTER_TABLE CounterTable,
    DWORD              dwDetailLevel,
    DWORD              dwFlags
)
{
    PDH_STATUS Status = ERROR_SUCCESS;

    Status = PdhiBuildTextHeaderCache(pLog);
    if (Status == ERROR_SUCCESS) {
        PPDHI_TEXT_LOG_INFO pLogInfo = (PPDHI_TEXT_LOG_INFO) pLog->pPerfmonInfo;
        if (pLogInfo == NULL) {
            Status = PDH_LOG_FILE_OPEN_ERROR;
        }
        else {
            Status = PdhiEnumCachedObjectItems(pLogInfo->MachineList,
                                               szMachineName,
                                               szObjectName,
                                               CounterTable,
                                               dwDetailLevel,
                                               dwFlags);
        }
    }
    return Status;
}

PDH_FUNCTION
PdhiGetMatchingTextLogRecord(
    PPDHI_LOG   pLog,
    LONGLONG  * pStartTime,
    LPDWORD     pdwIndex
)
{
    PDH_STATUS          pdhStatus        = ERROR_SUCCESS;
    DWORD               dwRecordId       = TEXTLOG_FIRST_DATA_RECORD;
    LONGLONG            LastTimeValue    = 0;
    PPDHI_TEXT_LOG_INFO pLogInfo;

    pdhStatus = PdhiBuildTextHeaderCache(pLog);
    if (pdhStatus != ERROR_SUCCESS) goto Cleanup;

    pLogInfo = (PPDHI_TEXT_LOG_INFO) pLog->pPerfmonInfo;
    if (pLogInfo == NULL) {
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
        goto Cleanup;
    }

    if ((* pStartTime & 0xFFFFFFFF00000000) == 0xFFFFFFFF00000000) {
        dwRecordId    = (DWORD) (* pStartTime & 0x00000000FFFFFFFF);
        LastTimeValue = * pStartTime;
        if (dwRecordId == 0) return PDH_ENTRY_NOT_IN_LOG_FILE;
    }
    else {
        dwRecordId = TEXTLOG_FIRST_DATA_RECORD;
    }

    pdhStatus = PdhiBuildTextRecordCache(pLog, dwRecordId, PDH_TEXT_REC_MODE_TIMESTAMP);
    while (pdhStatus == ERROR_SUCCESS) {
        if ((* pStartTime == pLogInfo->ThisTime) || (* pStartTime == 0)) {
            LastTimeValue = pLogInfo->ThisTime;
            break;
        }
        else if (* pStartTime < pLogInfo->ThisTime) {
            if (dwRecordId > TEXTLOG_FIRST_DATA_RECORD) {
                if (LastTimeValue <= * pStartTime) {
                    // No need for exact match. Just return the record with largest timestamp
                    // but less than the input one.
                    // pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
                    break;
                }
                else {
                    LastTimeValue = pLogInfo->ThisTime;
                    dwRecordId --;
                }
            }
            else {
                // The input time is before the timestamp of the first record.
                // Return the first record.
                //
                LastTimeValue = pLogInfo->ThisTime;
                break;
            }
        }
        else if (* pStartTime <= LastTimeValue) {
            // No need for exact match. Just return the record with largest timestamp
            // but less than the input one.
            // pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
            LastTimeValue = pLogInfo->ThisTime;
            break;
        }
        else {
            LastTimeValue = pLogInfo->ThisTime;
            dwRecordId ++;
        }
        pdhStatus = PdhiBuildTextRecordCache(pLog, dwRecordId, PDH_TEXT_REC_MODE_TIMESTAMP);
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // then dwRecordId is the desired entry
        * pdwIndex   = dwRecordId;
        * pStartTime = LastTimeValue;
        pdhStatus    = ERROR_SUCCESS;
    }
    else {
        pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
    }

Cleanup:
    return pdhStatus;
}

PDH_FUNCTION
PdhiGetCounterValueFromTextLog(
    IN  PPDHI_LOG           pLog,
    IN  DWORD               dwIndex,
    IN  PERFLIB_COUNTER   * pPath,
    IN  PPDH_RAW_COUNTER    pValue
)
{
    PDH_STATUS          pdhStatus = ERROR_SUCCESS;
    FILETIME            RecordTimeStamp;
    DOUBLE              dValue    = 0.0;
    PPDHI_TEXT_LOG_INFO pLogInfo  = (PPDHI_TEXT_LOG_INFO) pLog->pPerfmonInfo;

    if (pLogInfo == NULL) {
        return PDH_LOG_FILE_OPEN_ERROR;
    }

    pdhStatus = PdhiBuildTextRecordCache(pLog, dwIndex, PDH_TEXT_REC_MODE_ALL);
    if (pdhStatus == ERROR_SUCCESS) {
        RecordTimeStamp.dwLowDateTime  = LODWORD(pLogInfo->ThisTime);
        RecordTimeStamp.dwHighDateTime = HIDWORD(pLogInfo->ThisTime);
        if (pPath->dwCounterId <= pLogInfo->dwCounter) {
            dValue          = pLogInfo->CtrList[pPath->dwCounterId - 1];
            pValue->CStatus = PDH_CSTATUS_VALID_DATA;
            if (dValue < 0) {
                dValue          = 0.0;
                pValue->CStatus = PDH_CSTATUS_NO_INSTANCE;
            }
        }
        else {
            dValue          = 0.0;
            pValue->CStatus = PDH_CSTATUS_NO_INSTANCE;
        }
        pValue->TimeStamp           = RecordTimeStamp;
        (double) pValue->FirstValue = dValue;
        pValue->SecondValue         = 0;
        pValue->MultiCount          = 1;
    }
    else {
        if (pdhStatus == PDH_END_OF_LOG_FILE) {
            pdhStatus = PDH_NO_MORE_DATA;
        }
        RecordTimeStamp.dwLowDateTime  = 0;
        RecordTimeStamp.dwHighDateTime = 0;
        // unable to find entry in the log file
        pValue->CStatus                = PDH_CSTATUS_INVALID_DATA;
        pValue->TimeStamp              = RecordTimeStamp;
        (double) pValue->FirstValue    = (double) 0.0f;
        pValue->SecondValue            = 0;
        pValue->MultiCount             = 1;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiGetTimeRangeFromTextLog(
    PPDHI_LOG       pLog,
    LPDWORD         pdwNumEntries,
    PPDH_TIME_INFO  pInfo,
    LPDWORD         pdwBufferSize
)
/*++
    the first entry in the buffer returned is the total time range covered
    in the file, if there are multiple time blocks in the log file, then
    subsequent entries will identify each segment in the file.
--*/
{
    PDH_STATUS pdhStatus;
    LONGLONG   llStartTime    = MAX_TIME_VALUE;
    LONGLONG   llEndTime      = MIN_TIME_VALUE;
    LONGLONG   llThisTime     = 0;
    CHAR       cDelim;
    DWORD      dwThisRecord   = TEXTLOG_FIRST_DATA_RECORD;
    DWORD      dwValidEntries = 0;
    CHAR       szSmallBuffer[VALUE_BUFFER_SIZE];
    
    // read the first data record in the log file
    // note that the record read is not copied to the local buffer
    // rather the internal buffer is used in "read-only" mode
    cDelim = (CHAR) ((LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_CSV) ? COMMA_DELIMITER : TAB_DELIMITER);

    pdhStatus = PdhiReadOneTextLogRecord(pLog, dwThisRecord, szSmallBuffer, 1); // to prevent copying the record
    while (pdhStatus == ERROR_SUCCESS || pdhStatus == PDH_MORE_DATA) {
        if (PdhiGetStringFromDelimitedListA((LPSTR) pLog->pLastRecordRead,
                                            0,  // timestamp is first entry
                                            cDelim,
                                            PDHI_GSFDL_REMOVE_QUOTES | PDHI_GSFDL_REMOVE_NONPRINT,
                                            szSmallBuffer,
                                            MAX_PATH) > 0) {
            // convert ASCII timestamp to LONGLONG value for comparison
            PdhiDateStringToFileTimeA(szSmallBuffer, (LPFILETIME) & llThisTime);
            if (llThisTime < llStartTime) {
                llStartTime = llThisTime;
            }
            if (llThisTime > llEndTime) {
                llEndTime = llThisTime;
            }
            dwValidEntries ++;
        }
        else {
            // no timestamp field so ignore this record.
        }
        // read the next record in the file
        pdhStatus = PdhiReadOneTextLogRecord(pLog, ++dwThisRecord, szSmallBuffer, 1); // to prevent copying the record
    }

    if (pdhStatus == PDH_END_OF_LOG_FILE) {
        // then the whole file was read so update the args.
        if (* pdwBufferSize >=  sizeof(PDH_TIME_INFO)) {
            * (LONGLONG *) (& pInfo->StartTime) = llStartTime;
            * (LONGLONG *) (& pInfo->EndTime)   = llEndTime;
            pInfo->SampleCount                  = dwValidEntries;
            * pdwBufferSize                     = sizeof(PDH_TIME_INFO);
            * pdwNumEntries                     = 1;
        }
        else {
            pdhStatus = PDH_MORE_DATA;
        }
        pdhStatus = ERROR_SUCCESS;
    }
    else {
        pdhStatus = PDH_ENTRY_NOT_IN_LOG_FILE;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiReadRawTextLogRecord(
    PPDHI_LOG             pLog,
    FILETIME            * ftRecord,
    PPDH_RAW_LOG_RECORD   pBuffer,
    LPDWORD               pdwBufferLength
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    LONGLONG    llStartTime;
    DWORD       dwIndex   = 0;
    DWORD       dwSizeRequired;
    DWORD       dwLocalRecordLength; // including terminating NULL

    llStartTime = MAKELONGLONG(ftRecord->dwLowDateTime, ftRecord->dwHighDateTime);
    pdhStatus   = PdhiGetMatchingTextLogRecord(pLog, & llStartTime, & dwIndex);

    // copy results from internal log buffer if it'll fit.

    if (pdhStatus == ERROR_SUCCESS) {
        dwLocalRecordLength = (lstrlenA((LPSTR) pLog->pLastRecordRead)) * sizeof (CHAR);
        dwSizeRequired      = sizeof(PDH_RAW_LOG_RECORD) - sizeof (UCHAR) + dwLocalRecordLength;

        if (*pdwBufferLength >= dwSizeRequired) {
            pBuffer->dwRecordType = (DWORD)(LOWORD(pLog->dwLogFormat));
            pBuffer->dwItems      = dwLocalRecordLength;
            // copy it
            memcpy(& pBuffer->RawBytes[0], pLog->pLastRecordRead, dwLocalRecordLength);
            pBuffer->dwStructureSize = dwSizeRequired;

        }
        else {
            pdhStatus = PDH_MORE_DATA;
        }

        * pdwBufferLength = dwSizeRequired;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiListHeaderFromTextLog(
    PPDHI_LOG pLogFile,
    LPVOID    pBufferArg,
    LPDWORD   pcchBufferSize,
    BOOL      bUnicode
)
{
    LPVOID              pTempBuffer       = NULL;
    LPVOID              pOldBuffer;
    DWORD               dwTempBufferSize;
    LPSTR               szLocalPathBuffer = NULL;
    DWORD               dwIndex;
    DWORD               dwBufferRemaining;
    LPVOID              pNextChar;
    DWORD               dwReturnSize;
    CHAR                cDelimiter;
    PDH_STATUS          pdhStatus         = ERROR_SUCCESS;
    PPDHI_TEXT_LOG_INFO pLogInfo          = NULL;

    if (pLogFile->dwMaxRecordSize == 0) {
        // no size is defined so start with 64K
        pLogFile->dwMaxRecordSize = 0x010000;
    }

    pdhStatus = PdhiBuildTextHeaderCache(pLogFile);
    if (pdhStatus != ERROR_SUCCESS) goto Cleanup;

    pLogInfo = (PPDHI_TEXT_LOG_INFO) pLogFile->pPerfmonInfo;
    if (pLogInfo == NULL) {
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
        goto Cleanup;
    }

    dwTempBufferSize = pLogFile->dwMaxRecordSize;
    pTempBuffer      = G_ALLOC(dwTempBufferSize);
    if (pTempBuffer == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    cDelimiter = (CHAR) ((LOWORD(pLogFile->dwLogFormat) == PDH_LOG_TYPE_CSV) ? COMMA_DELIMITER : TAB_DELIMITER);

    // read in the catalog record

    while ((pdhStatus = PdhiReadOneTextLogRecord(
                            pLogFile, TEXTLOG_HEADER_RECORD, pTempBuffer, dwTempBufferSize)) != ERROR_SUCCESS) {
        if (pdhStatus == PDH_MORE_DATA) { 
            // read the 1st WORD to see if this is a valid record
            pLogFile->dwMaxRecordSize *= 2;
            // realloc a new buffer
            pOldBuffer  = pTempBuffer;
            pTempBuffer = G_REALLOC(pOldBuffer, dwTempBufferSize);
            if (pTempBuffer == NULL) {
                // return memory error
                G_FREE(pOldBuffer);
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                break;
            } 
        }
        else {
            // some other error was returned so
            // return error from read function
            break;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // parse header record into MSZ
        dwIndex           = 1;
        dwBufferRemaining = * pcchBufferSize;
        pNextChar         = pBufferArg;
        // initialize first character in buffer
        if (bUnicode) {
            * (PWCHAR) pNextChar = L'\0';
        } else {
            * (LPBYTE) pNextChar = '\0';
        }

        if (dwTempBufferSize < SMALL_BUFFER_SIZE) dwTempBufferSize = SMALL_BUFFER_SIZE;
        szLocalPathBuffer = (LPSTR) G_ALLOC(dwTempBufferSize * sizeof(CHAR));
        if (szLocalPathBuffer == NULL) {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            goto Cleanup;
        }
        do {
            dwReturnSize = PdhiGetStringFromDelimitedListA((LPSTR) pTempBuffer,
                                                           dwIndex,
                                                           cDelimiter,
                                                           PDHI_GSFDL_REMOVE_QUOTES | PDHI_GSFDL_REMOVE_NONPRINT,
                                                           szLocalPathBuffer,
                                                           dwTempBufferSize);
            if (dwReturnSize > 0) {
                // copy to buffer
                if (dwReturnSize < dwBufferRemaining) {
                    if (bUnicode) {
                        MultiByteToWideChar(_getmbcp(),
                                            0,
                                            szLocalPathBuffer,
                                            lstrlenA(szLocalPathBuffer),
                                            (LPWSTR) pNextChar,
                                            dwReturnSize);
                        pNextChar            = (LPVOID) ((PWCHAR) pNextChar + dwReturnSize);
                        * (PWCHAR) pNextChar = L'\0';
                        pNextChar            = (LPVOID) ((PWCHAR) pNextChar + 1);
                    }
                    else {
                        StringCchCopyA((LPSTR) pNextChar, dwBufferRemaining, szLocalPathBuffer);
                        pNextChar            = (LPVOID)((LPBYTE) pNextChar + dwReturnSize);
                        * (LPBYTE) pNextChar = '\0';
                        pNextChar            = (LPVOID) ((PCHAR) pNextChar + 1);
                    }
                    dwBufferRemaining -= dwReturnSize;
                }
                else {
                    pdhStatus = PDH_MORE_DATA;
                }
                dwIndex++;
            }
        }
        while (dwReturnSize > 0); // end loop

        // add MSZ terminator
        if (1 < dwBufferRemaining) {
            if (bUnicode) {
                * (PWCHAR) pNextChar = L'\0';
                pNextChar            = (LPVOID) ((PWCHAR) pNextChar + 1);
            }
            else {
                * (LPBYTE) pNextChar = '\0';
                pNextChar            = (LPVOID) ((PCHAR) pNextChar + 1);
            }
            dwBufferRemaining -= dwReturnSize;
            pdhStatus          = ERROR_SUCCESS;
        }
        else {
            pdhStatus = PDH_MORE_DATA;
        }
    }

Cleanup:
    G_FREE(pTempBuffer);
    G_FREE(szLocalPathBuffer);
    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhlog\relog.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <pdh.h>
#include <pdhp.h>

#include "pdhidef.h"
#include "log_bin.h"
#include "log_wmi.h"
#include "log_text.h"
#include "log_sql.h"
#include "strings.h"
#include "pdhmsg.h"

LPWSTR
PlaiStringDuplicate( LPWSTR sz );

BOOL __stdcall
IsValidLogHandle (
    IN  HLOG    hLog    
);

PDH_FUNCTION
PdhiWriteRelogRecord(
    IN  PPDHI_LOG   pLog,
    IN  SYSTEMTIME  *st
)
{
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    LPWSTR szUserString = NULL;

    pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (pLog->hLogMutex);

    if (pdhStatus == ERROR_SUCCESS) {

        switch (LOWORD(pLog->dwLogFormat)) {
            case PDH_LOG_TYPE_CSV:
            case PDH_LOG_TYPE_TSV:
                pdhStatus =PdhiWriteTextLogRecord (
                                  pLog,
                                  st,
                                  (LPCWSTR)szUserString);
                break;

            case PDH_LOG_TYPE_RETIRED_BIN:
                pdhStatus = PDH_NOT_IMPLEMENTED;
                break;

            case PDH_LOG_TYPE_BINARY:
                pdhStatus = PdhiWriteWmiLogRecord(
                                  pLog,
                                  st,
                                  (LPCWSTR) szUserString);
                break;
            case PDH_LOG_TYPE_SQL:
                pdhStatus =PdhiWriteSQLLogRecord (
                                  pLog,
                                  st,
                                  (LPCWSTR)szUserString);
                break;

            case PDH_LOG_TYPE_PERFMON:
            default:
                pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                break;
        }

        RELEASE_MUTEX (pLog->hLogMutex);
    } 
 
    return pdhStatus;
}

PDH_FUNCTION
PdhRelogA(
        HLOG    hLogIn,
        PPDH_RELOG_INFO_A pRelogInfo
    )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    PDH_RELOG_INFO_W RelogInfo;

    ZeroMemory( &RelogInfo, sizeof(PDH_RELOG_INFO_W) );

    if( NULL == pRelogInfo ){
        return PDH_INVALID_ARGUMENT;
    }

    __try{

        RelogInfo.dwFlags = pRelogInfo->dwFlags;
        RelogInfo.dwFileFormat = pRelogInfo->dwFileFormat;
        memcpy( &RelogInfo.TimeInfo, &pRelogInfo->TimeInfo, sizeof(PDH_TIME_INFO) );
        RelogInfo.ftInterval = pRelogInfo->ftInterval;
        RelogInfo.StatusFunction = pRelogInfo->StatusFunction;
        RelogInfo.Reserved1 = pRelogInfo->Reserved1;
        RelogInfo.Reserved2 = pRelogInfo->Reserved2;
    
        if( NULL != pRelogInfo->strLog ){
        
            RelogInfo.strLog = (LPWSTR)G_ALLOC( 
                (strlen(pRelogInfo->strLog)+1) * sizeof(WCHAR) );
        
            if( RelogInfo.strLog ){
        
                mbstowcs( 
                        RelogInfo.strLog, 
                        pRelogInfo->strLog, 
                        (strlen(pRelogInfo->strLog)+1) 
                    );
            }
    
        }else{
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = PdhRelogW( hLogIn, &RelogInfo );
    }

    G_FREE( RelogInfo.strLog );

    return pdhStatus;
}

PDH_FUNCTION
PdhRelogW( 
        HLOG    hLogIn,
        PPDH_RELOG_INFO_W pRelogInfo
    )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HLOG      hLogOut;
    PPDHI_LOG pLogIn;
    PPDHI_LOG pLogOut;
    DWORD dwLogFormat;
    PDH_RELOG_INFO_W RelogInfo;

    SYSTEMTIME      ut;
    FILETIME        lt;
    ULONG           nSampleCount = 0;
    ULONG           nSamplesWritten = 0;
    PDH_TIME_INFO   TimeInfo;
    DWORD dwNumEntries = 1;
    DWORD dwBufferSize = sizeof(PDH_TIME_INFO);

    if( NULL == pRelogInfo ){
        return PDH_INVALID_ARGUMENT;
    }

    ZeroMemory( &RelogInfo, sizeof(PDH_RELOG_INFO_W) );
    ZeroMemory( &TimeInfo, sizeof( PDH_TIME_INFO ) );

    pdhStatus = PdhGetDataSourceTimeRangeH (
                        hLogIn,
                        &dwNumEntries,
                        &TimeInfo,
                        &dwBufferSize
                    );

    if( ERROR_SUCCESS == pdhStatus ){
        if( TimeInfo.SampleCount == 0 ){
            return PDH_NO_DATA;
        }
    }else{
        return pdhStatus;
    }

    if( NULL != pRelogInfo ){
        __try{
            memcpy( &RelogInfo, pRelogInfo, sizeof(PDH_RELOG_INFO_W) );
            RelogInfo.strLog = PlaiStringDuplicate( pRelogInfo->strLog );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }else{
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if( IsValidLogHandle(hLogIn) && ERROR_SUCCESS == pdhStatus ){

        HCOUNTER hCounter;
        HQUERY hQuery;
        ULONG nRecordSkip;

        pLogIn = (PPDHI_LOG)hLogIn;
        __try{
            hQuery = (HQUERY)pLogIn->pQuery;
            dwLogFormat = pLogIn->dwLogFormat;
            if( NULL == pLogIn->pQuery->pCounterListHead ){
                pdhStatus = PDH_NO_DATA;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        if( pdhStatus == ERROR_SUCCESS ){
            pdhStatus = PdhOpenLogW(
                    RelogInfo.strLog, 
                    RelogInfo.dwFlags,
                    &RelogInfo.dwFileFormat, 
                    hQuery,
                    0,
                    NULL,
                    &hLogOut
                );
        }

        if( pdhStatus == ERROR_SUCCESS ){

            pLogOut= (PPDHI_LOG)hLogOut;
            
            __try {
                if( RelogInfo.TimeInfo.StartTime == 0 || 
                    RelogInfo.TimeInfo.StartTime < TimeInfo.StartTime ){

                    pLogIn->pQuery->TimeRange.StartTime = TimeInfo.StartTime;
                    pRelogInfo->TimeInfo.StartTime = TimeInfo.StartTime;
    
                }else{
                    pLogIn->pQuery->TimeRange.StartTime = RelogInfo.TimeInfo.StartTime;
                }

                if( RelogInfo.TimeInfo.EndTime == 0 || 
                    RelogInfo.TimeInfo.EndTime > TimeInfo.EndTime ){

                    pLogIn->pQuery->TimeRange.EndTime = TimeInfo.EndTime;
                    pRelogInfo->TimeInfo.EndTime = TimeInfo.EndTime;
                }else{
                    pLogIn->pQuery->TimeRange.EndTime = RelogInfo.TimeInfo.EndTime;
                }
            }__except (EXCEPTION_EXECUTE_HANDLER) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }

            nRecordSkip = RelogInfo.TimeInfo.SampleCount >= 1 ? RelogInfo.TimeInfo.SampleCount : 1;
    
            PdhiResetLogBuffers(hLogIn);

            while (ERROR_SUCCESS == pdhStatus) {
    
                pdhStatus = PdhiCollectQueryData((PPDHI_QUERY) hQuery, (LONGLONG *) & lt);
                FileTimeToSystemTime(& lt, & ut);

                if( NULL != RelogInfo.StatusFunction ){
                    if( !(nSampleCount % 10) ){
                        __try{
                            RelogInfo.StatusFunction(
                                PDH_RELOG_STATUS_PROCESSING,
                                (double)nSampleCount/(double)TimeInfo.SampleCount
                                );
                        } __except (EXCEPTION_EXECUTE_HANDLER) {
                            RelogInfo.StatusFunction = NULL;
                        }
                    }
                }


                if (nSampleCount ++ % nRecordSkip) {
                    continue;
                }

                if (ERROR_SUCCESS == pdhStatus) {
                    pdhStatus = PdhiWriteRelogRecord(pLogOut, & ut);
                    nSamplesWritten++;
                }
                else if (PDH_NO_DATA == pdhStatus) {
                    // Reset pdhStatus. PDH_NO_DATA means that there are no new counter data
                    // for collected counters. Skip current record and continue.
                    //

                    pdhStatus = ERROR_SUCCESS;
                }
            }

            //
            // Check for valid exit status codes
            //
            if( PDH_NO_MORE_DATA == pdhStatus ){
                pdhStatus = ERROR_SUCCESS;
            }else{
                switch( LOWORD(dwLogFormat) ){
                case PDH_LOG_TYPE_BINARY:
                case PDH_LOG_TYPE_PERFMON:
                    if( PDH_ENTRY_NOT_IN_LOG_FILE == pdhStatus ){
                        pdhStatus = ERROR_SUCCESS;
                    }
                    break;
                }
                // 
                // No Default:
                // All other errors are really errors
                //
            }
            
            if( ERROR_SUCCESS == pdhStatus ){
                pdhStatus = PdhCloseLog( hLogOut, 0 );
            }else{
                PdhCloseLog( hLogOut, 0 );
            }
    
            __try {
                ((PPDHI_QUERY)hQuery)->hOutLog = NULL;
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }

        }
    
    }else{
        pdhStatus = PDH_INVALID_HANDLE;
    }
    
    if( ERROR_SUCCESS == pdhStatus ){
        __try {
            pRelogInfo->TimeInfo.SampleCount = nSamplesWritten;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    G_FREE( RelogInfo.strLog );

    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\pdh\pdhpla\plogman.cpp ===
/*****************************************************************************\

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winbase.h>
#include <userenv.h>

#include <wmistr.h>
#include <evntrace.h>

#include <pdh.h>
#include <pdhp.h>
#include <pdhmsg.h>

#include <wincrypt.h>

#include <shlwapi.h>

#include "plogman.h"
#include "pdhdlgs.h"

HANDLE hPdhPlaMutex = NULL;

/*****************************************************************************\
    Strings            
\*****************************************************************************/

// Common
LPCWSTR szCollection =          L"Collection Name";
LPCWSTR szKey =                 L"Key";
LPCWSTR szRunAs =               L"Run As";
LPCWSTR szSysmonLog =           L"SysmonLog";
LPCWSTR szCurrentState =        L"Current State";
LPCWSTR szLogType =             L"Log Type";
LPCWSTR szLogBaseName =         L"Log File Base Name";
LPCWSTR szStart =               L"Start";
LPCWSTR szStop =                L"Stop";
LPCWSTR szRestart =             L"Restart";
LPCWSTR szLogMaxSize =          L"Log File Max Size";
LPCWSTR szCurrentLogFile =      L"Current Log File Name";
LPCWSTR szLogSerialNumber =     L"Log File Serial Number";
LPCWSTR szLogAutoFormat =       L"Log File Auto Format";
LPCWSTR szComment =             L"Comment";
LPCWSTR szEOFCmd =              L"EOF Command File";
LPCWSTR szLogFolder =           L"Log File Folder";
LPCWSTR szLogFileType =         L"Log File Type";
LPCWSTR szRepeatSchedule =      L"Repeat Schedule";
LPCWSTR szRepeatScheduleBegin = L"Repeat Schedule Start";
LPCWSTR szRepeatScheduleEnd =   L"Repeat Schedule Stop";
LPCWSTR szCreateNewFile =       L"Create New File";
LPCWSTR szDatastoreAttributes = L"Data Store Attributes";

// Trace
LPCWSTR szTraceProviderCount =  L"Trace Provider Count";
LPCWSTR szTraceBufferSize =     L"Trace Buffer Size";
LPCWSTR szTraceBufferMin =      L"Trace Buffer Min Count";
LPCWSTR szTraceBufferMax =      L"Trace Buffer Max Count";
LPCWSTR szTraceFlushInterval =  L"Trace Buffer Flush Interval";
LPCWSTR szTraceFlags =          L"Trace Flags";
LPCWSTR szTraceProviderList =   L"Trace Provider List";
LPCWSTR szTraceProviderFlags =  L"Trace Provider Flags";
LPCWSTR szTraceProviderLevels = L"Trace Provider Levels";
LPCWSTR szTraceMode =           L"Trace Mode";
LPCWSTR szTraceLoggerName =     L"Trace Logger Name";

// Performance
LPCWSTR szPerfCounterList =     L"Counter List";
LPCWSTR szSqlBaseName =         L"Sql Log Base Name";
LPCWSTR szSampleInterval =      L"Sample Interval";

/*****************************************************************************/

extern "C" 
{

LPWSTR
PlaiStringDuplicate( LPWSTR sz )
{
    LPWSTR szDup = NULL;

    __try {
        if( NULL != sz ){
            size_t cbSize = ( _tcslen( sz ) + 1 ) * sizeof(WCHAR);
            szDup = (LPWSTR)G_ALLOC( cbSize );
            if( NULL != szDup ){
                StringCbCopy( szDup, cbSize, sz );
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        G_FREE( szDup );
        szDup = NULL;
    }

    return szDup;
}

}

#define CHECK_NAMES( szName, szCom, strCom ) \
if( szName == NULL ){ \
    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE; \
    goto cleanup;  \
} \
if( NULL != strCom && NULL == szCom ){ \
    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE; \
    goto cleanup; \
} 


PDH_FUNCTION
PlaiErrorToPdhStatus( DWORD dwStatus )
{
    switch( dwStatus ){
    case ERROR_SUCCESS:                 return ERROR_SUCCESS;
    case ERROR_FILE_NOT_FOUND:          return PDH_PLA_COLLECTION_NOT_FOUND;
    case ERROR_SERVICE_ALREADY_RUNNING: return PDH_PLA_COLLECTION_ALREADY_RUNNING;
    case ERROR_DIRECTORY:               return PDH_PLA_ERROR_FILEPATH;
    case ERROR_OUTOFMEMORY:             return PDH_MEMORY_ALLOCATION_FAILURE;
    case ERROR_NOT_ENOUGH_MEMORY:       return PDH_MEMORY_ALLOCATION_FAILURE;
    case ERROR_NO_DATA:                 return PDH_NO_DATA;
    case ERROR_ACCESS_DENIED:           return PDH_ACCESS_DENIED;
    case WBEM_E_NOT_FOUND:              return PDH_WBEM_ERROR;
    case E_FAIL:                        return PDH_WBEM_ERROR;
    case WBEM_E_PROVIDER_FAILURE:       return PDH_WBEM_ERROR;
    case WBEM_E_OUT_OF_MEMORY:          return PDH_MEMORY_ALLOCATION_FAILURE;
    case ERROR_BAD_NETPATH:             return PDH_ACCESS_DENIED;
    case WBEM_E_ACCESS_DENIED:          return PDH_ACCESS_DENIED;
    default:                            return PDH_INVALID_DATA;
    }
}

ULONG 
PlaMszStrLenA( LPSTR mszString )
{
    ULONG nLength = 0;
    ULONG nTotalLength = 0;
    LPSTR strScan = mszString;
    
    if( mszString == NULL ){
        return 0;
    }
    while( *strScan != '\0' ){
        nLength = (strlen( strScan )+1);
        strScan += nLength;
        nTotalLength += nLength;
    }
 
    return (nTotalLength*sizeof(char) + (sizeof(char) * 2));
}

ULONG 
PlaMszStrLenW( LPWSTR mszString )
{
    ULONG nLength = 0;
    ULONG nTotalLength = 0;
    LPTSTR strScan = mszString;
    
    if( mszString == NULL ){
        return 0;
    }
    while( *strScan != L'\0' ){
        nLength = (wcslen( strScan )+1);
        strScan += nLength;
        nTotalLength += nLength;
    }
   
    return (nTotalLength*sizeof(WCHAR) + (sizeof(WCHAR)));
}

_inline BOOL 
PlaiIsStringEmpty( LPWSTR str )
{
    if( NULL == str ){
        return TRUE;
    }
    if( L'\0' == *str ){
        return TRUE;
    }

    return FALSE;
}

_inline BOOL 
PlaiIsCharWhitespace( WCHAR ch )
{
    switch( ch ){
    case L' ':
    case L'\r':
    case L'\n':
    case L'\t':
        return TRUE;
    default:
        return FALSE;
    }
}

PDH_FUNCTION 
Plaiatow( LPSTR strA, LPWSTR &strW )
{
    if( NULL == strA ){
        strW = NULL;
        return ERROR_SUCCESS;
    }

    strW = (LPWSTR)G_ALLOC( (strlen(strA)+1) * sizeof(WCHAR) );
    if( strW ){
        mbstowcs( strW, strA, (strlen(strA)+1) );
        return ERROR_SUCCESS;
    }

    strW = NULL;
    return PDH_MEMORY_ALLOCATION_FAILURE;
}

ULONG 
Plaihextoi( LPWSTR s )
{
    long len;
    ULONG num, base, hex;

    if ( PlaiIsStringEmpty( s ) ) {
        return 0;
    }
    
    len = (long) wcslen(s);
    
    if (len == 0) {
        return 0;
    }

    hex  = 0;
    base = 1;
    num  = 0;

    while (-- len >= 0) {
        if (s[len] >= L'0' && s[len] <= L'9'){
            num = s[len] - L'0';
        }else if (s[len] >= L'a' && s[len] <= L'f'){
            num = (s[len] - L'a') + 10;
        }else if (s[len] >= L'A' && s[len] <= L'F'){
            num = (s[len] - L'A') + 10;
        }else if( s[len] == L'x' || s[len] == L'X'){
            break;
        }else{
            continue;
        }

        hex += num * base;
        base = base * 16;
    }

    return hex;
}

PDH_FUNCTION
PlaiTranslateKernelFlags( LPDWORD pdwInternal, LPDWORD pdwReal )
{
    if( *pdwReal & EVENT_TRACE_FLAG_PROCESS ){
        *pdwInternal |= PLA_TLI_ENABLE_PROCESS_TRACE;
    }
    if( *pdwReal & EVENT_TRACE_FLAG_THREAD ){
        *pdwInternal |= PLA_TLI_ENABLE_THREAD_TRACE;
    }
    if( *pdwReal & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS ){
        *pdwInternal |= PLA_TLI_ENABLE_MEMMAN_TRACE;
    }
    if( *pdwReal & EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS ){
        *pdwInternal |= PLA_TLI_ENABLE_MEMMAN_TRACE;
    }
    if( *pdwReal & EVENT_TRACE_FLAG_DISK_IO ){
        *pdwInternal |= PLA_TLI_ENABLE_DISKIO_TRACE;
    }
    if( *pdwReal & EVENT_TRACE_FLAG_NETWORK_TCPIP ){
        *pdwInternal |= PLA_TLI_ENABLE_NETWORK_TCPIP_TRACE;
    }
    if( *pdwReal & EVENT_TRACE_FLAG_DISK_FILE_IO ){
        *pdwInternal |= PLA_TLI_ENABLE_FILEIO_TRACE;
    }

    return ERROR_SUCCESS;
}

BOOL
PlaiIsLocalComputer( LPWSTR strComputer )
{    
    if( PlaiIsStringEmpty( strComputer ) ){
        return TRUE;
    }else{
        LPWSTR str = strComputer;

        WCHAR buffer[MAX_COMPUTERNAME_LENGTH+1];
        DWORD dwSize = MAX_COMPUTERNAME_LENGTH+1; 
        BOOL bResult;
        
        bResult = GetComputerName( buffer, &dwSize );
        
        if( bResult ){
        
            while( *str == L'\\' ){
                str++;
            }

            return (_wcsicmp( buffer, str ) == 0);

        }else{
            return TRUE;
        }
    }

    return FALSE;
}

/*****************************************************************************/

DWORD
PlaiUpdateServiceMode( LPTSTR strComputer )
{
    DWORD           dwStatus = ERROR_SUCCESS;
    BOOL            bStatus;
    PDH_STATUS      pdhStatus;
    SC_HANDLE       hSC = NULL;
    SC_HANDLE       hService = NULL;
    QUERY_SERVICE_CONFIG*    pServiceConfig = NULL;
    DWORD dwSize = 0;
    BOOL bAutoStart = FALSE;
    PDH_PLA_INFO_W  info;

    LPWSTR mszCollections = NULL;

    pdhStatus = PdhPlaEnumCollections( strComputer, &dwSize, mszCollections );

    if( ERROR_SUCCESS == pdhStatus || PDH_INSUFFICIENT_BUFFER == pdhStatus ){
        
        mszCollections = (LPWSTR)G_ALLOC( dwSize * sizeof(TCHAR) );
        
        if( mszCollections ){
            
            LPTSTR strCollection;
        
            pdhStatus = PdhPlaEnumCollections( strComputer, &dwSize, mszCollections );
            if( ERROR_SUCCESS == pdhStatus && NULL != mszCollections ){
            
                dwSize = sizeof( PDH_PLA_INFO_W );
                strCollection = mszCollections;
                
                while( *strCollection != L'\0' ){
                    
                    info.dwMask = PLA_INFO_FLAG_BEGIN;
                    strCollection += ( wcslen( strCollection ) + 1 );
                    pdhStatus = PdhPlaGetInfoW( strCollection, strComputer, &dwSize, &info );
                
                    if( ERROR_SUCCESS == pdhStatus ){

                        if( (info.dwMask & PLA_INFO_FLAG_BEGIN) && 
                            info.ptLogBeginTime.dwAutoMode != PLA_AUTO_MODE_NONE ){

                            bAutoStart = TRUE;
                            break;
                        }
                    }
                }
            }
        }else{ 
            dwStatus = ERROR_OUTOFMEMORY;
        }
    }else{
        dwStatus = ERROR_FILE_NOT_FOUND;
    }

    if( ERROR_SUCCESS != dwStatus ){
        goto cleanup;
    }


    hSC = OpenSCManager ( strComputer, NULL, GENERIC_READ );

    if (hSC == NULL) {
        dwStatus = GetLastError();
        goto cleanup;
    }
    
    BOOL bUpdate = FALSE;

    dwSize = 4096;
    pServiceConfig = (QUERY_SERVICE_CONFIG*)G_ALLOC( dwSize );
    if( NULL == pServiceConfig ){
        dwStatus = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    ZeroMemory( pServiceConfig, dwSize );

    hService = OpenService (
                        hSC, 
                        szSysmonLog,
                        SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG | SERVICE_START 
                    );

    if( NULL == hService ){
        dwStatus = GetLastError();
        goto cleanup;
    }

    bStatus = QueryServiceConfig (
                        hService, 
                        pServiceConfig,
                        dwSize, 
                        &dwSize
                    );
    if( !bStatus ){
        dwStatus = GetLastError();
        goto cleanup;
    }

    if ( bAutoStart ) {
        if ( SERVICE_DEMAND_START == pServiceConfig->dwStartType ) {
            bUpdate = TRUE;
        }
    } else {
        if ( SERVICE_AUTO_START == pServiceConfig->dwStartType ) {
            bUpdate = TRUE;
        }
    }

    if( bUpdate ){

        SC_ACTION  ServiceControlAction[3];
        SERVICE_FAILURE_ACTIONS  FailActions;

        bStatus = ChangeServiceConfig (
                        hService,
                        SERVICE_NO_CHANGE,
                        (bAutoStart ? SERVICE_AUTO_START : SERVICE_DEMAND_START),
                        SERVICE_NO_CHANGE,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL 
                    );

        if( !bStatus ){
            dwStatus = GetLastError();
            goto cleanup;
        }

        ZeroMemory( ServiceControlAction, sizeof(SC_ACTION) * 3 );
        ZeroMemory( &FailActions, sizeof(SERVICE_FAILURE_ACTIONS) );

        if ( bAutoStart ) {
            ServiceControlAction[0].Type = SC_ACTION_RESTART;
            ServiceControlAction[1].Type = SC_ACTION_RESTART;
            ServiceControlAction[2].Type = SC_ACTION_RESTART;
        } else {
            ServiceControlAction[0].Type = SC_ACTION_NONE;
            ServiceControlAction[1].Type = SC_ACTION_NONE;
            ServiceControlAction[2].Type = SC_ACTION_NONE;
        }

        FailActions.dwResetPeriod = 60;
        FailActions.cActions = 3;
        FailActions.lpsaActions = ServiceControlAction;

        bStatus = ChangeServiceConfig2(
                            hService,
                            SERVICE_CONFIG_FAILURE_ACTIONS,
                            &FailActions 
                        );

        if ( ! bStatus ) {
            dwStatus = GetLastError();
        }
    }

cleanup:
    G_FREE( mszCollections );
    G_FREE( pServiceConfig );
    if( NULL != hService ){
        CloseServiceHandle (hService);
    }
    if( NULL != hSC ){
        CloseServiceHandle (hSC);
    }

    return dwStatus;
}

DWORD 
PlaiGetServiceState ( 
    LPCWSTR szComputerName,
    DWORD&  rdwState 
    )
{
    DWORD dwStatus = ERROR_SUCCESS;

    SERVICE_STATUS  ssData;
    SC_HANDLE       hSC;
    SC_HANDLE       hLogService;
    
    rdwState = 0;       // Error by default.

    // open SC database
    hSC = OpenSCManagerW ( szComputerName, NULL, SC_MANAGER_CONNECT);

    if (hSC != NULL) {
     
        // open service
        hLogService = OpenServiceW (
                        hSC, 
                        szSysmonLog,
                        SERVICE_INTERROGATE );
    
        if (hLogService != NULL) {
            if ( ControlService (
                    hLogService, 
                    SERVICE_CONTROL_INTERROGATE,
                    &ssData)) {

                rdwState = ssData.dwCurrentState;
            } else {
                dwStatus = GetLastError();
                rdwState = SERVICE_STOPPED;
            }

            CloseServiceHandle (hLogService);
        
        } else {
            dwStatus = GetLastError();
        }

        CloseServiceHandle (hSC);
    } else {
        dwStatus = GetLastError();
    }

    if ( ERROR_SERVICE_NOT_ACTIVE == dwStatus || ERROR_SERVICE_REQUEST_TIMEOUT == dwStatus ) {
        rdwState = SERVICE_STOPPED;
        dwStatus = ERROR_SUCCESS;
    }

    return dwStatus;
}

PDH_FUNCTION
PlaiSynchronize( LPCWSTR szComputerName )
{
    // If the service is running, tell it to synchronize itself,
    // Check the state afterwards to see if it got the message.
    // If stop pending or stopped, wait until the service is
    // stopped and then attempt to start it.  The service 
    // synchronizes itself from the registry when it is started.

    // Return ERROR_SUCCESS for success, other for failure.

    SC_HANDLE   hSC = NULL;
    SC_HANDLE   hLogService = NULL;
    SERVICE_STATUS  ssData;
    DWORD       dwCurrentState;
    DWORD       dwTimeout = 25;
    DWORD       dwStatus = ERROR_SUCCESS;

    dwStatus = PlaiGetServiceState ( szComputerName, dwCurrentState );

    if ( ERROR_SUCCESS == dwStatus && 0 != dwCurrentState ) {
        // open SC database
        hSC = OpenSCManagerW ( szComputerName, NULL, SC_MANAGER_CONNECT);

        if ( NULL != hSC ) {
            // open service
            hLogService = OpenServiceW (
                            hSC, 
                            szSysmonLog,
                            SERVICE_USER_DEFINED_CONTROL 
                            | SERVICE_START );
    
            if ( NULL != hLogService ) {

                if ( ( SERVICE_STOPPED != dwCurrentState ) 
                        && ( SERVICE_STOP_PENDING != dwCurrentState ) ) {

                    // Wait 100 milliseconds before synchronizing service,
                    // to ensure that registry values are written.
                    _sleep ( 100 );

                    ControlService ( 
                        hLogService, 
                        PLA_SERVICE_CONTROL_SYNCHRONIZE, 
                        &ssData);
                
                    dwCurrentState = ssData.dwCurrentState;
                }

                // Make sure that the ControlService call reached the service
                // while it was in run state.
                if ( ( SERVICE_STOPPED == dwCurrentState ) 
                    || ( SERVICE_STOP_PENDING == dwCurrentState ) ) {

                    if ( SERVICE_STOP_PENDING == dwCurrentState ) {
                        // wait for the service to stop before starting it.
                        while ( --dwTimeout && ERROR_SUCCESS == dwStatus ) {
                            dwStatus = PlaiGetServiceState ( szComputerName, dwCurrentState );
                            if ( SERVICE_STOP_PENDING == dwCurrentState ) {
                                _sleep(200);
                            } else {
                                break;
                            }
                        }
                    }
                    dwTimeout = 25;
                    if ( SERVICE_STOPPED == dwCurrentState ) {
                        if ( StartService (hLogService, 0, NULL) ) {
                            // wait for the service to start or stop 
                            // before returning
                            while ( --dwTimeout && ERROR_SUCCESS == dwStatus ) {
                                dwStatus = PlaiGetServiceState ( szComputerName, dwCurrentState );
                                if ( SERVICE_START_PENDING == dwCurrentState ) {
                                    _sleep(200);
                                } else {
                                    break;
                                }
                            }
                        } else {
                            dwStatus = GetLastError();
                        }
                    }
                }
            }
            CloseServiceHandle ( hLogService );

        } else {
            dwStatus = GetLastError();
        }

        CloseServiceHandle (hSC);

    } else {
        dwStatus = GetLastError();
    }

    if( 0 == dwCurrentState || ERROR_SUCCESS != dwStatus ){
        return PDH_PLA_SERVICE_ERROR;
    }

    return ERROR_SUCCESS;
}

/*****************************************************************************\

    PdhPlaSchedule
    
    Sets the start/stop attributes of a log query

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to
        
        DWORD fType
                PLA_AUTO_MODE_NONE      Sets schedule to manual start if pInfo->StartTime is non-zero
                                        Sets schedule to manula stop if pInfo->EndTime is non-zero and
                                        
                                        Stops logger if it is running


                PLA_AUTO_MODE_AT        Uses pInfo for start and end times

                PLA_AUTO_MODE_AFTER     Sets the logger to run for a specified
                                        period.  Does not start the logger.
                                        Uses pInfo->SampleCount for interval type
                                            PLA_TT_UTYPE_SECONDS
                                            PLA_TT_UTYPE_MINUTES
                                            PLA_TT_UTYPE_HOURS
                                            PLA_TT_UTYPE_DAYS

         PPDH_TIME_INFO pInfo
                Start and Stop times

    Return:
        PDH_INVALID_ARGUMENT
                A required argument is missing or incorrect.
        PDH_PLA_COLLECTION_ALREADY_RUNNING
                The Query is currently running, no action taken
        PDH_PLA_ERROR_SCHEDULE_OVERLAP
                The start and stop times overlap.
        PDH_PLA_COLLECTION_NOT_FOUND
                Query does not exist
        PDH_PLA_ERROR_SCHEDULE_ELAPSED
                The end time has elapsed
        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION 
PlaiSchedule( 
        LPWSTR strComputer,
        HKEY   hkeyQuery,
        DWORD  fType,
        PPDH_TIME_INFO pInfo
    )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    PLA_TIME_INFO   stiData;
    DWORD           dwRegValue;

    RegFlushKey( hkeyQuery );

    // Make sure its not already running
    pdhStatus = PlaiReadRegistryDwordValue(
                    hkeyQuery, 
                    szCurrentState, 
                    &dwRegValue );
    
    if( ERROR_SUCCESS == pdhStatus  ){
        if( PLA_QUERY_RUNNING == dwRegValue ){
            DWORD dwState;
            PlaiGetServiceState( strComputer, dwState );
            if( dwState != SERVICE_STOPPED ){
                RegCloseKey( hkeyQuery );
                return PDH_PLA_COLLECTION_ALREADY_RUNNING;
            }
        }
    }

    memset (&stiData, 0, sizeof(stiData));

    switch( fType ){
    case PLA_AUTO_MODE_NONE:
        stiData.wDataType = PLA_TT_DTYPE_DATETIME;
        stiData.dwAutoMode = PLA_AUTO_MODE_NONE;
        
        PlaiRemoveRepeat( hkeyQuery );

        stiData.llDateTime = MIN_TIME_VALUE;
        if( pInfo->StartTime ){
            stiData.wTimeType = PLA_TT_TTYPE_START;
            pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szStart, &stiData );    
        }

        if( pInfo->EndTime ){
            stiData.wTimeType = PLA_TT_TTYPE_STOP;
            pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szStop, &stiData );
        }

        break;
    case PLA_AUTO_MODE_AT:
        {
            SYSTEMTIME      stLocalTime;
            FILETIME        ftLocalTime;
            LONGLONG        llLocalTime;

            // get local time
            GetLocalTime (&stLocalTime);
            SystemTimeToFileTime (&stLocalTime, &ftLocalTime);
                            
            llLocalTime = 
                (((ULONGLONG) ftLocalTime.dwHighDateTime) << 32) + 
                ftLocalTime.dwLowDateTime;

            if( pInfo->StartTime && pInfo->EndTime ){
                if( pInfo->StartTime > pInfo->EndTime ){
                    return PDH_PLA_ERROR_SCHEDULE_OVERLAP;
                }
            }

            stiData.wDataType = PLA_TT_DTYPE_DATETIME;
            stiData.dwAutoMode = PLA_AUTO_MODE_AT;

            if( pInfo->StartTime ){

                stiData.wTimeType = PLA_TT_TTYPE_START;
                stiData.llDateTime = pInfo->StartTime;
                pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szStart, &stiData );
                if( ! pInfo->EndTime && pInfo->StartTime < llLocalTime ){
                    PLA_TIME_INFO   stiStopData;
                    pdhStatus = PlaiReadRegistryPlaTime( hkeyQuery, szStop, &stiStopData );
                    if( ERROR_SUCCESS == pdhStatus && stiStopData.dwAutoMode == PLA_AUTO_MODE_NONE ){
                        stiStopData.llDateTime = MAX_TIME_VALUE;
                        PlaiWriteRegistryPlaTime( hkeyQuery, szStop, &stiStopData );
                    }
                }else if( ! pInfo->EndTime ){
                    PLA_TIME_INFO   stiStopData;
                    pdhStatus = PlaiReadRegistryPlaTime ( hkeyQuery, szStop, &stiStopData );
                    if( ERROR_SUCCESS == pdhStatus ){
                        if( PLA_AUTO_MODE_NONE == stiStopData.dwAutoMode ){
                            stiData.wTimeType = PLA_TT_TTYPE_STOP;
                            stiData.llDateTime = MAX_TIME_VALUE;
                            stiData.dwAutoMode = PLA_AUTO_MODE_NONE;
                            pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szStop, &stiData );
                        }
                    }

                }
            }

            if( pInfo->EndTime ){
                if( pInfo->EndTime < llLocalTime ){
                    return PDH_PLA_ERROR_SCHEDULE_ELAPSED;
                }
                stiData.wTimeType = PLA_TT_TTYPE_STOP;
                stiData.llDateTime = pInfo->EndTime;
                pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szStop, &stiData );
            }                
    
        }
        break;
    case PLA_AUTO_MODE_AFTER:
        stiData.wTimeType = PLA_TT_TTYPE_STOP;
        stiData.wDataType = PLA_TT_DTYPE_UNITS;
        stiData.dwAutoMode = PLA_AUTO_MODE_AFTER;
        stiData.dwValue = (DWORD)pInfo->EndTime;
        stiData.dwUnitType = pInfo->SampleCount;
        pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szStop, &stiData );
        break;
    default:
        return PDH_INVALID_ARGUMENT;
    }

    return pdhStatus;
}

PDH_FUNCTION
PlaiRemoveRepeat( HKEY hkeyQuery )
{
    PLA_TIME_INFO info;
    PDH_STATUS pdhStatus;

    ZeroMemory( &info, sizeof( PLA_TIME_INFO ) );
    pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szRepeatSchedule, &info );    
    
    return pdhStatus;
}

PDH_FUNCTION 
PdhPlaScheduleA(
        LPSTR strName, 
        LPSTR strComputer,
        DWORD fType,
        PPDH_TIME_INFO pInfo
    )
{
    PDH_STATUS pdhStatus;
    LPWSTR wstrName = NULL;
    LPWSTR wstrComputer = NULL;

    VALIDATE_QUERY( strName );

    pdhStatus = Plaiatow( strComputer, wstrComputer );
    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = Plaiatow( strName, wstrName );
        if( ERROR_SUCCESS == pdhStatus ){
            pdhStatus = PdhPlaScheduleW( wstrName, wstrComputer, fType, pInfo );
        }
    }
   
    G_FREE( wstrComputer );
    G_FREE( wstrName );
    
    return pdhStatus;
}

PDH_FUNCTION 
PdhPlaScheduleW( 
        LPWSTR strName, 
        LPWSTR strComputer,
        DWORD  fType,
        PPDH_TIME_INFO pInfo
    )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HKEY    hkeyQuery = NULL;
    
    VALIDATE_QUERY( strName );

    LPWSTR szName = PlaiStringDuplicate( strName );
    LPWSTR szComputer = PlaiStringDuplicate( strComputer );
    CHECK_NAMES( szName, szComputer, strComputer );
    
    PDH_TIME_INFO TimeInfo;

    __try {
        if( NULL != pInfo ){
            memcpy( &TimeInfo, pInfo, sizeof(PDH_TIME_INFO) );
        }else{
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    
    CHECK_STATUS( pdhStatus );

    pdhStatus = PlaiConnectAndLockQuery ( szComputer, szName, hkeyQuery );

    if( ERROR_SUCCESS == pdhStatus ){
     
        pdhStatus = PlaiSchedule( szComputer, hkeyQuery, fType, &TimeInfo );                
        RELEASE_MUTEX(hPdhPlaMutex);
    }

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }

    if( SUCCEEDED( pdhStatus ) ){
        pdhStatus = PlaiSynchronize( szComputer );
        PlaiUpdateServiceMode( szComputer );
    }

    __try {
        memcpy( pInfo, &TimeInfo, sizeof(PDH_TIME_INFO) );
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

cleanup:
    G_FREE( szName );
    G_FREE( szComputer );

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaGetSchedule


    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to
        
    Return:

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PdhPlaGetScheduleA(
        LPSTR strName, 
        LPSTR strComputer,
        LPDWORD pdwTypeStart,
        LPDWORD pdwTypeStop,
        PPDH_TIME_INFO pInfo
    )
{
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION
PdhPlaGetScheduleW(
        LPWSTR strName, 
        LPWSTR strComputer,
        LPDWORD pdwTypeStart,
        LPDWORD pdwTypeStop,
        PPDH_TIME_INFO pInfo
    )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HKEY    hkeyQuery = NULL;
    BOOL bMutex = FALSE;

    VALIDATE_QUERY( strName );

    LPWSTR szName = PlaiStringDuplicate( strName );
    LPWSTR szComputer = PlaiStringDuplicate( strComputer );
    CHECK_NAMES( szName, szComputer, strComputer );

    DWORD dwTypeStart;
    DWORD dwTypeStop;
    PDH_TIME_INFO TimeInfo;

    pdhStatus = PlaiConnectAndLockQuery ( szComputer, szName, hkeyQuery, FALSE );

    if ( ERROR_SUCCESS == pdhStatus ) {
        PLA_TIME_INFO   ptiStartInfo;
        PLA_TIME_INFO   ptiStopInfo;
        PLA_TIME_INFO   ptiRepeatInfo;
        
        ZeroMemory( &TimeInfo, sizeof(PDH_TIME_INFO) );

        bMutex = TRUE;
        
        pdhStatus = PlaiReadRegistryPlaTime ( hkeyQuery, szRepeatSchedule, &ptiRepeatInfo );
        if( ERROR_SUCCESS == pdhStatus && PLA_AUTO_MODE_CALENDAR == ptiRepeatInfo.dwAutoMode ){
            dwTypeStart = PLA_AUTO_MODE_CALENDAR;
            pdhStatus = PlaiReadRegistryPlaTime ( hkeyQuery, szRepeatScheduleBegin, &ptiStartInfo );
            if( ERROR_SUCCESS != pdhStatus ){
                pdhStatus = PlaiReadRegistryPlaTime ( hkeyQuery, szStart, &ptiStartInfo );
            }
            CHECK_STATUS( pdhStatus );

            pdhStatus = PlaiReadRegistryPlaTime ( hkeyQuery, szRepeatScheduleEnd, &ptiStopInfo );
            if( ERROR_SUCCESS != pdhStatus ){
                pdhStatus = PlaiReadRegistryPlaTime ( hkeyQuery, szStop, &ptiStopInfo );
            }
            CHECK_STATUS( pdhStatus );
            dwTypeStop = ptiStopInfo.dwAutoMode;
        }else{
            pdhStatus = PlaiReadRegistryPlaTime ( hkeyQuery, szStart, &ptiStartInfo );
            CHECK_STATUS( pdhStatus );
            dwTypeStart = ptiStartInfo.dwAutoMode;

            pdhStatus = PlaiReadRegistryPlaTime ( hkeyQuery, szStop, &ptiStopInfo );
            CHECK_STATUS( pdhStatus );
            dwTypeStop = ptiStopInfo.dwAutoMode;
        }

        __try {
            pInfo->StartTime = ptiStartInfo.llDateTime;
            pInfo->EndTime = ptiStopInfo.llDateTime;
            *pdwTypeStart = dwTypeStart;
            *pdwTypeStop = dwTypeStop;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

cleanup:
    if( bMutex ){
        RELEASE_MUTEX(hPdhPlaMutex);
    }

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }
    
    G_FREE( szName );
    G_FREE( szComputer );

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaStart

    Starts a log query

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to
        
    Return:

        PDH_PLA_COLLECTION_ALREADY_RUNNING
                The Query is currently running, no action taken

        PDH_INVALID_ARGUMENT
                The query does not exist

        PDH_PLA_ERROR_SCHEDULE_ELAPSED
                The query was scheduled to stop in the past, no action taken

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PdhPlaStartA( LPSTR strName, LPSTR strComputer )
{
    PDH_STATUS pdhStatus;
    LPWSTR wstrName = NULL;
    LPWSTR wstrComputer = NULL;

    VALIDATE_QUERY( strName );

    pdhStatus = Plaiatow( strComputer, wstrComputer );
    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = Plaiatow( strName, wstrName );
        if( ERROR_SUCCESS == pdhStatus ){
            pdhStatus = PdhPlaStartW( wstrName, wstrComputer );
        }
    }
   
    G_FREE( wstrComputer );
    G_FREE( wstrName );

    return pdhStatus;
}

PDH_FUNCTION
PdhPlaStartW( LPWSTR strName, LPWSTR strComputer )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HKEY    hkeyQuery = NULL;

    VALIDATE_QUERY( strName );

    LPWSTR szName = PlaiStringDuplicate( strName );
    LPWSTR szComputer = PlaiStringDuplicate( strComputer );
    CHECK_NAMES( szName, szComputer, strComputer );

    pdhStatus = PlaiConnectAndLockQuery ( szComputer, szName, hkeyQuery );

    if ( ERROR_SUCCESS == pdhStatus ) {
        PLA_TIME_INFO   stiData;
        PLA_TIME_INFO   stiStopData;
        DWORD           dwRegValue;
   
        // Make sure its not already running
        pdhStatus = PlaiReadRegistryDwordValue(
                        hkeyQuery, 
                        szCurrentState, 
                        &dwRegValue );
        
        if( ERROR_SUCCESS == pdhStatus ){
            if( PLA_QUERY_RUNNING == dwRegValue ){
                DWORD dwState;
                PlaiGetServiceState( szComputer, dwState );
                if( dwState != SERVICE_STOPPED ){
                    RegCloseKey( hkeyQuery );
                    RELEASE_MUTEX(hPdhPlaMutex);
                    return PDH_PLA_COLLECTION_ALREADY_RUNNING;
                }
            }
        }

        //Make sure it was not set to stop in the past
        pdhStatus = PlaiReadRegistryPlaTime ( hkeyQuery, szStop, &stiStopData );

        if( ERROR_SUCCESS == pdhStatus ) {
            if ( PLA_AUTO_MODE_AT == stiStopData.dwAutoMode ) {
                SYSTEMTIME      stLocalTime;
                FILETIME        ftLocalTime;
                LONGLONG        llLocalTime;

                // get local time
                GetLocalTime (&stLocalTime);
                SystemTimeToFileTime (&stLocalTime, &ftLocalTime);
        
                llLocalTime = 
                    (((ULONGLONG) ftLocalTime.dwHighDateTime) << 32) + 
                    ftLocalTime.dwLowDateTime;

                if ( llLocalTime > stiStopData.llDateTime ) {
                    RELEASE_MUTEX(hPdhPlaMutex);
                    RegCloseKey( hkeyQuery );
                    return PDH_PLA_ERROR_SCHEDULE_ELAPSED;
                }
            }
        }
        
        memset (&stiData, 0, sizeof(stiData));
        stiData.wTimeType = PLA_TT_TTYPE_START;
        stiData.wDataType = PLA_TT_DTYPE_DATETIME;
        stiData.dwAutoMode = PLA_AUTO_MODE_NONE;
        stiData.llDateTime = MIN_TIME_VALUE;
        
        PlaiRemoveRepeat( hkeyQuery );
        
        pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szStart, &stiData );
        
        if( PLA_AUTO_MODE_NONE == stiStopData.dwAutoMode ){
            stiData.wTimeType = PLA_TT_TTYPE_STOP;
            stiData.llDateTime = MAX_TIME_VALUE;
            pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szStop, &stiData );
        }

        if ( ERROR_SUCCESS == pdhStatus ) {
            dwRegValue = PLA_QUERY_START_PENDING;
            pdhStatus = PlaiWriteRegistryDwordValue ( 
                        hkeyQuery, 
                        szCurrentState, 
                        &dwRegValue );
        }

        // Set LastModified
        if ( ERROR_SUCCESS == pdhStatus ) { 
            pdhStatus = PlaiWriteRegistryLastModified ( hkeyQuery );
        }

        RELEASE_MUTEX(hPdhPlaMutex);

        // Start the service on the target machine
        if ( SUCCEEDED( pdhStatus ) ) { 

            pdhStatus = PlaiSynchronize( szComputer );
            
            if( ERROR_SUCCESS == pdhStatus ){
                DWORD dwTimeOut = 25;
                while( --dwTimeOut > 0 ){
                    pdhStatus = PlaiReadRegistryDwordValue(
                                hkeyQuery, 
                                szCurrentState, 
                                &dwRegValue
                            );
                    if( ERROR_SUCCESS == pdhStatus && dwRegValue != PLA_QUERY_RUNNING ){
                        pdhStatus = PDH_PLA_ERROR_NOSTART;
                    }else{
                        pdhStatus = ERROR_SUCCESS;
                        break;
                    }
                    _sleep(200);
                }
            }

        }   

    }

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }

cleanup:
    G_FREE( szName );
    G_FREE( szComputer );

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaStop

    Stops a log query

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to
        
    Return:

        PDH_INVALID_ARGUMENT
                The query does not exist

        ERROR_SUCCESS
        
\*****************************************************************************/


PDH_FUNCTION
PdhPlaStopA( LPSTR strName, LPSTR strComputer )
{
    PDH_STATUS pdhStatus;
    LPWSTR wstrName = NULL;
    LPWSTR wstrComputer = NULL;
    
    VALIDATE_QUERY( strName );


    pdhStatus = Plaiatow( strComputer, wstrComputer );
    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = Plaiatow( strName, wstrName );
        if( ERROR_SUCCESS == pdhStatus ){
            pdhStatus = PdhPlaStopW( wstrName, wstrComputer );
        }
    }
   
    G_FREE( wstrComputer );
    G_FREE( wstrName );

    return pdhStatus;
}

PDH_FUNCTION
PdhPlaStopW( LPWSTR strName, LPWSTR strComputer )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HKEY    hkeyQuery = NULL;

    VALIDATE_QUERY( strName );

    LPWSTR szName = PlaiStringDuplicate( strName );
    LPWSTR szComputer = PlaiStringDuplicate( strComputer );
    CHECK_NAMES( szName, szComputer, strComputer );

    pdhStatus = PlaiConnectAndLockQuery( szComputer, szName, hkeyQuery );

    if ( ERROR_SUCCESS == pdhStatus ) {
        PLA_TIME_INFO stiData;
        DWORD dwRestartMode = 0;
        DWORD dwState;

        pdhStatus = PlaiReadRegistryDwordValue(
                        hkeyQuery, 
                        szCurrentState, 
                        &dwState );
        
        if( ERROR_SUCCESS == pdhStatus ){
            if( PLA_QUERY_STOPPED != dwState ){
                PlaiGetServiceState( szComputer, dwState );
                if( dwState == SERVICE_STOPPED ){
                    dwState = PLA_QUERY_STOPPED;
                    PlaiWriteRegistryDwordValue ( hkeyQuery, szCurrentState, &dwState );
                }
            }
        }
        
        // If query is set to restart on end, clear the restart flag.
        pdhStatus = PlaiReadRegistryDwordValue ( hkeyQuery, szRestart, &dwRestartMode );

        if ( ERROR_SUCCESS == pdhStatus && PLA_AUTO_MODE_NONE != dwRestartMode ) {
            dwRestartMode = PLA_AUTO_MODE_NONE;
            pdhStatus = PlaiWriteRegistryDwordValue ( hkeyQuery, szRestart, &dwRestartMode );
        }

        PlaiRemoveRepeat( hkeyQuery );

        // Set stop mode to manual, stop time to MIN_TIME_VALUE
        if ( ERROR_SUCCESS == pdhStatus ) {
            memset (&stiData, 0, sizeof(stiData));
            stiData.wTimeType = PLA_TT_TTYPE_STOP;
            stiData.wDataType = PLA_TT_DTYPE_DATETIME;
            stiData.dwAutoMode = PLA_AUTO_MODE_NONE;
            stiData.llDateTime = MIN_TIME_VALUE;

            pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szStop, &stiData );
        }

        // If start time mode set to manual, set the value to MAX_TIME_VALUE
        if ( ERROR_SUCCESS == pdhStatus ) {
            pdhStatus = PlaiReadRegistryPlaTime ( hkeyQuery, szStart, &stiData );

            if ( ERROR_SUCCESS == pdhStatus && PLA_AUTO_MODE_NONE == stiData.dwAutoMode ) {
                stiData.llDateTime = MAX_TIME_VALUE;
                pdhStatus = PlaiWriteRegistryPlaTime ( hkeyQuery, szStart, &stiData );
            }
        }

        PlaiWriteRegistryLastModified ( hkeyQuery );
        RELEASE_MUTEX(hPdhPlaMutex);

        if ( SUCCEEDED( pdhStatus ) ) { 
            pdhStatus = PlaiSynchronize ( szComputer );
        }

    }

cleanup:
    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }

    G_FREE( szName );
    G_FREE( szComputer );

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaCreate

    Creates a new log query

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to

        DWORD fType 
                PLA_COUNTER_LOG 
                PLA_TRACE_LOG                
    Return:

        ERROR_ALREADY_EXISTS
                The Query is currently running, no action taken

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PlaiInitializeNewQuery(
    HKEY            hkeyLogQueries,
    HKEY&           rhKeyQuery,
    LPCWSTR         strComputer,
    LPCWSTR         strName 
    )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    DWORD   dwDisposition = 0;
    DWORD   dwValue;
    PLA_TIME_INFO   stiData;
    PLA_VERSION version;

    pdhStatus = PdhiPlaGetVersion( strComputer, &version );

    if( ERROR_SUCCESS == pdhStatus && version.dwBuild > 2195 ){

        GUID guid;
        UNICODE_STRING strGUID;

        dwStatus = UuidCreate( &guid );
        if( !( dwStatus == RPC_S_OK || dwStatus == RPC_S_UUID_LOCAL_ONLY ) ){
            return PlaiErrorToPdhStatus( dwStatus );
        }

        dwStatus = RtlStringFromGUID( guid, &strGUID );
        if( ERROR_SUCCESS != dwStatus ){
            return PlaiErrorToPdhStatus( dwStatus );
        }
    
        dwStatus = RegCreateKeyExW (
                hkeyLogQueries,
                strGUID.Buffer,
                0,
                NULL, 
                0,
                KEY_READ|KEY_WRITE,
                NULL,
                &rhKeyQuery,
                &dwDisposition
            );

        RtlFreeUnicodeString( &strGUID );
        pdhStatus = PlaiErrorToPdhStatus( dwStatus );
    }else{

        dwStatus = RegCreateKeyExW (
                hkeyLogQueries,
                strName,
                0,
                NULL, 
                0,
                KEY_READ|KEY_WRITE,
                NULL,
                &rhKeyQuery,
                &dwDisposition
            );
        pdhStatus = PlaiErrorToPdhStatus( dwStatus );
    }
    

    if ( ERROR_SUCCESS == pdhStatus ) {
        
        PlaiWriteRegistryStringValue( rhKeyQuery, szCollection, REG_SZ, strName, 0 );

        dwValue = PLA_QUERY_STOPPED;
        pdhStatus = PlaiWriteRegistryDwordValue ( 
                    rhKeyQuery, 
                    szCurrentState, 
                    &dwValue );

        if ( ERROR_SUCCESS == pdhStatus ) {
            // Initialize the log type to "new" to indicate partially created logs
            
            dwValue = PLA_NEW_LOG;
            pdhStatus = PlaiWriteRegistryDwordValue (
                        rhKeyQuery,
                        szLogType,
                        &dwValue );
            
            PlaiWriteRegistryStringValue( rhKeyQuery, szLogBaseName, REG_SZ, strName, 0 );

            memset (&stiData, 0, sizeof(stiData));
            stiData.wTimeType = PLA_TT_TTYPE_START;
            stiData.wDataType = PLA_TT_DTYPE_DATETIME;
            stiData.dwAutoMode = PLA_AUTO_MODE_NONE;
            stiData.llDateTime = MIN_TIME_VALUE;

            pdhStatus = PlaiWriteRegistryPlaTime ( rhKeyQuery, szStart, &stiData );

            stiData.wTimeType = PLA_TT_TTYPE_STOP;
            pdhStatus = PlaiWriteRegistryPlaTime ( rhKeyQuery, szStop, &stiData );
            
            memset (&stiData, 0, sizeof(stiData));
            stiData.dwAutoMode = PLA_AUTO_MODE_NONE;
            PlaiWriteRegistryPlaTime( rhKeyQuery, szCreateNewFile, &stiData );

            dwValue = 0;
            PlaiWriteRegistryDwordValue( rhKeyQuery, szRestart, &dwValue );
        
            dwValue = PLA_QUERY_STOPPED;
            PlaiWriteRegistryDwordValue( rhKeyQuery, szCurrentState, &dwValue );
        
            dwValue = PLA_DISK_MAX_SIZE;
            PlaiWriteRegistryDwordValue( rhKeyQuery, szLogMaxSize, &dwValue );
            
            dwValue = 1;
            PlaiWriteRegistryDwordValue( rhKeyQuery, szLogSerialNumber, &dwValue );
            
            dwValue = 1;
            PlaiWriteRegistryDwordValue( rhKeyQuery, szLogAutoFormat, &dwValue );
        
            PlaiWriteRegistryStringValue( rhKeyQuery, szComment, REG_SZ, NULL, 0 );

            PlaiWriteRegistryStringValue( rhKeyQuery, szEOFCmd, REG_SZ, NULL, 0 );

            if( PlaiIsStringEmpty( (LPWSTR)strComputer ) ){
                LPWSTR strDrive = _wgetenv( L"SystemDrive" );
                if( strDrive != NULL && wcslen(strDrive) < 5 ){
                    WCHAR buffer[16];
                    StringCchPrintf( buffer, 16, L"%s\\PerfLogs", strDrive );
                    PlaiWriteRegistryStringValue( rhKeyQuery, szLogFolder, REG_SZ, buffer, 0 );
                }
            }else{
                PlaiWriteRegistryStringValue( rhKeyQuery, szLogFolder, REG_SZ, L"%SystemDrive%\\PerfLogs", 0 );
            }
        }
    } 

    return pdhStatus;
}

PDH_FUNCTION
PlaiCreateCounterQuery( HKEY hkeyQuery )
{
    PDH_STATUS pdhStatus;
    DWORD dwValue;

    dwValue = PLA_BIN_FILE;
    pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szLogFileType, &dwValue );
    
    PLA_TIME_INFO   stiData;

    stiData.wTimeType = PLA_TT_TTYPE_SAMPLE;
    stiData.dwAutoMode = PLA_AUTO_MODE_AFTER;
    stiData.wDataType = PLA_TT_DTYPE_UNITS;
    stiData.dwUnitType = PLA_TT_UTYPE_SECONDS;
    stiData.dwValue = 0x000F;
    
    pdhStatus = PlaiWriteRegistryPlaTime( hkeyQuery, szSampleInterval, &stiData );

    PlaiWriteRegistryStringValue( hkeyQuery, szPerfCounterList, REG_MULTI_SZ, NULL, 0 );

    pdhStatus = PlaiWriteRegistryLastModified ( hkeyQuery );

    dwValue = PLA_DATASTORE_SIZE_KB|PLA_DATASTORE_APPEND;
    PlaiWriteRegistryDwordValue( hkeyQuery, szDatastoreAttributes, &dwValue );
    PlaiWriteRegistryStringValue(hkeyQuery, szPerfCounterList, REG_MULTI_SZ, NULL, 0 );

    return ERROR_SUCCESS;
}

PDH_FUNCTION
PlaiCreateTraceQuery( HKEY hkeyQuery )
{
    PDH_STATUS pdhStatus;
    DWORD dwValue;

    dwValue = 0;
    pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szTraceProviderCount, &dwValue );
    
    dwValue = 128;
    PlaiWriteRegistryDwordValue( hkeyQuery, szTraceBufferSize, &dwValue );
    
    dwValue = 8;
    PlaiWriteRegistryDwordValue( hkeyQuery, szTraceBufferMin, &dwValue );
    
    dwValue = 32;
    PlaiWriteRegistryDwordValue( hkeyQuery, szTraceBufferMax, &dwValue );
    
    dwValue = 0;
    PlaiWriteRegistryDwordValue( hkeyQuery, szTraceFlushInterval, &dwValue );

    dwValue = 0;
    PlaiWriteRegistryDwordValue( hkeyQuery, szTraceMode, &dwValue );

    PlaiWriteRegistryStringValue( hkeyQuery, szTraceProviderList, REG_MULTI_SZ, NULL, 0 );

    dwValue = 
        PLA_TLI_ENABLE_KERNEL_TRACE |
        PLA_TLI_ENABLE_PROCESS_TRACE |
        PLA_TLI_ENABLE_THREAD_TRACE |
        PLA_TLI_ENABLE_DISKIO_TRACE |
        PLA_TLI_ENABLE_NETWORK_TCPIP_TRACE;

    dwValue = PLA_DATASTORE_SIZE_MB|PLA_DATASTORE_APPEND;
    PlaiWriteRegistryDwordValue( hkeyQuery, szDatastoreAttributes, &dwValue );

    PlaiWriteRegistryDwordValue( hkeyQuery, szTraceFlags, &dwValue );
    
    dwValue = PLA_SEQ_TRACE_FILE;
    PlaiWriteRegistryDwordValue( hkeyQuery, szLogFileType, &dwValue );

    PlaiWriteRegistryLastModified ( hkeyQuery );

    return ERROR_SUCCESS;
}

PDH_FUNCTION
PdhPlaCreateA( LPSTR /*strName*/, LPSTR /*strComputer*/, PPDH_PLA_INFO_A /*pInfo*/ )
{
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION
PdhPlaCreateW( LPWSTR strName, LPWSTR strComputer, PPDH_PLA_INFO_W pInfo )
{
    PDH_STATUS pdhStatus;
    PDH_STATUS pdhWarning = ERROR_SUCCESS;
    HKEY    hkeyQuery = NULL;
    HKEY    rhkeyLogQueries = NULL;
    BOOL    bMutex = FALSE;

    VALIDATE_QUERY( strName );

    LPWSTR szName = PlaiStringDuplicate( strName );
    LPWSTR szComputer = PlaiStringDuplicate( strComputer );
    CHECK_NAMES( szName, szComputer, strComputer );

    pdhStatus = PlaiScanForInvalidChar( szName );
    CHECK_STATUS(pdhStatus);

    pdhStatus = PlaiConnectAndLockQuery( szComputer, szName, hkeyQuery );

    if( ERROR_SUCCESS == pdhStatus ){
        bMutex = TRUE;
        pdhStatus = PDH_PLA_ERROR_ALREADY_EXISTS;
        goto cleanup;
    }
 
    pdhStatus = PdhPlaValidateInfoW( szName, szComputer, pInfo );
    switch( SEVERITY(pdhStatus) ){
    case STATUS_SEVERITY_ERROR:
        goto cleanup;
    case STATUS_SEVERITY_WARNING:
        pdhWarning = pdhStatus;
        pdhStatus = ERROR_SUCCESS;
    }

    pdhStatus = PlaiConnectToRegistry( szComputer, rhkeyLogQueries, TRUE );

    if( ERROR_SUCCESS == pdhStatus ){
        DWORD dwStatus;
        dwStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhPlaMutex);
    
        if( ERROR_SUCCESS == dwStatus || WAIT_ABANDONED == dwStatus ){
            bMutex = TRUE;
            pdhStatus = PlaiInitializeNewQuery (
                            rhkeyLogQueries,
                            hkeyQuery,
                            szComputer,
                            szName
                            );

            switch( pInfo->dwType ){
            case PLA_COUNTER_LOG:
                pdhStatus = PlaiCreateCounterQuery( hkeyQuery );
                break;

            case PLA_TRACE_LOG:
                pdhStatus = PlaiCreateTraceQuery( hkeyQuery );
                break;
            }
        }else{
            pdhStatus = PlaiErrorToPdhStatus( dwStatus );
        }
    }

    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = PlaiSetInfo( szComputer, hkeyQuery, pInfo );
    }

    if( bMutex ){
        RELEASE_MUTEX(hPdhPlaMutex);
        bMutex = FALSE;
    }

    __try {
        if( ERROR_SUCCESS == pdhStatus && (pInfo->dwMask & PLA_INFO_FLAG_USER) ){
            pdhStatus = PdhPlaSetRunAsW( szName, szComputer, pInfo->strUser, pInfo->strPassword );
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    
    if( ERROR_SUCCESS == pdhStatus ){
        DWORD dwStatus;
        dwStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhPlaMutex);
        if( ERROR_SUCCESS == dwStatus || WAIT_ABANDONED == dwStatus ){
            DWORD dwValue;
            bMutex = TRUE;
            switch( pInfo->dwType ){
            case PLA_COUNTER_LOG:
                dwValue = PLA_COUNTER_LOG;
                pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szLogType, &dwValue );
                break;

            case PLA_TRACE_LOG:
                dwValue = PLA_TRACE_LOG;
                pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szLogType, &dwValue );
                break;
            }
        }else{
            pdhStatus = PlaiErrorToPdhStatus( dwStatus );
        }

    }

cleanup:
    if( bMutex ){
        RELEASE_MUTEX(hPdhPlaMutex);
    }

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }
    
    if( SUCCEEDED( pdhStatus ) ){
        pdhStatus = PlaiSynchronize( szComputer );
        
        DWORD dwMask;
        
        __try {
            dwMask = pInfo->dwMask;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        if( ERROR_SUCCESS == pdhStatus && (dwMask & PLA_INFO_FLAG_BEGIN) ){

            PlaiUpdateServiceMode( szComputer );
        }
    }else if( PDH_PLA_ERROR_ALREADY_EXISTS != pdhStatus ){
        PdhPlaDeleteW( szName, szComputer );
    }

    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = pdhWarning;
    }

    G_FREE( szName );
    G_FREE( szComputer );

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaDelete

    Deletes an existing log query

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to
    Return:

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PdhPlaDeleteA( LPSTR strName, LPSTR strComputer )
{
    PDH_STATUS pdhStatus;
    LPWSTR wstrName = NULL;
    LPWSTR wstrComputer = NULL;
    
    VALIDATE_QUERY( strName );

    pdhStatus = Plaiatow( strComputer, wstrComputer );
    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = Plaiatow( strName, wstrName );
        if( ERROR_SUCCESS == pdhStatus ){
            pdhStatus = PdhPlaDeleteW( wstrName, wstrComputer );
        }
    }
   
    G_FREE( wstrComputer );
    G_FREE( wstrName );

    return pdhStatus;
}

PDH_FUNCTION
PdhPlaDeleteW( LPWSTR strName, LPWSTR strComputer )
{
    DWORD dwStatus = ERROR_SUCCESS;
    PDH_STATUS pdhStatus;
    HKEY  hkeyLogQueries = NULL;
                
    VALIDATE_QUERY( strName );

    LPWSTR szName = PlaiStringDuplicate( strName );
    LPWSTR szComputer = PlaiStringDuplicate( strComputer );
    CHECK_NAMES( szName, szComputer, strComputer );

    pdhStatus = PlaiConnectToRegistry ( szComputer, hkeyLogQueries, TRUE );

    if( ERROR_SUCCESS == pdhStatus ){

        dwStatus = WAIT_FOR_AND_LOCK_MUTEX( hPdhPlaMutex );

        if( ERROR_SUCCESS == dwStatus || WAIT_ABANDONED == dwStatus ){
            DWORD nCollections = 0;
            DWORD nMaxSubKeyLength = 0;

            dwStatus = RegQueryInfoKey(
                        hkeyLogQueries,
                        NULL,
                        NULL,
                        NULL,
                        &nCollections,
                        &nMaxSubKeyLength,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL 
                    );

            if( ERROR_SUCCESS == dwStatus ){
            
                LPWSTR strCollection;
                LPWSTR strQueryName = NULL;
                DWORD dwQueryName = 0;
                HKEY hkeyQuery = NULL;

                DWORD dwSize = (sizeof(WCHAR)*(nMaxSubKeyLength+1));

                strCollection = (LPWSTR)G_ALLOC( dwSize );

                if( strCollection ){
                    BOOL bFound = FALSE;                
                    for( ULONG i = 0; i<nCollections; i++ ){
                        dwStatus = RegEnumKey( hkeyLogQueries, i, strCollection, dwSize );
                        if( ERROR_SUCCESS == dwStatus ) {

                            dwStatus = RegOpenKeyExW (
                                    hkeyLogQueries,
                                    strCollection,
                                    0,
                                    KEY_READ|KEY_WRITE,
                                    &hkeyQuery 
                                );

                            if( ERROR_SUCCESS == dwStatus && !PlaiIsStringEmpty( strCollection ) ){
                                if( !_wcsicmp( strCollection, strName ) ){
                                    bFound = TRUE;
                                }else{

                                    PlaiReadRegistryStringValue( hkeyQuery, szCollection, READ_REG_MUI, &strQueryName, &dwQueryName );
                            
                                    if( !PlaiIsStringEmpty( strQueryName ) ){
                                        if( !_wcsicmp( strQueryName, szName ) ){
                                            bFound = TRUE;
                                        }
                                    }
                                }

                                if( bFound ){

                                    DWORD dwState;
                                    dwStatus = PlaiReadRegistryDwordValue(
                                                    hkeyQuery, 
                                                    szCurrentState, 
                                                    &dwState );
    
                                    if( ERROR_SUCCESS == dwStatus ){
                                        if( PLA_QUERY_RUNNING == dwState ){
                                            PlaiGetServiceState( szComputer, dwState );
                                            if( dwState != SERVICE_STOPPED ){
                                                dwStatus = ERROR_SERVICE_ALREADY_RUNNING;
                                            }
                                        }
                                    }
                                    
                                    if( ERROR_SUCCESS == dwStatus ){
                                        RegCloseKey( hkeyQuery );
                                        dwStatus = RegDeleteKey( hkeyLogQueries, strCollection ); 
                                    }

                                    break;
                                }

                                dwStatus = ERROR_FILE_NOT_FOUND;

                                if ( NULL != hkeyQuery ) {
                                    RegCloseKey ( hkeyQuery );
                                }
                            }
                        }
                    }

                    G_FREE( strQueryName );
                    G_FREE( strCollection );

                }else{
                    dwStatus = ERROR_OUTOFMEMORY;
                }
            }
        }

        RegCloseKey ( hkeyLogQueries );

        RELEASE_MUTEX(hPdhPlaMutex);
    }else{        
        return pdhStatus;
    }

    if( ERROR_SUCCESS == dwStatus ){
        PlaiSynchronize( szComputer );
        PlaiUpdateServiceMode( szComputer );
    }

cleanup:
    G_FREE( szName );
    G_FREE( szComputer );

    return PlaiErrorToPdhStatus( dwStatus );
}

/*****************************************************************************\

    PdhPlaSetItemList

    Sets the list of Items for a log query

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to

        LPTSTR  mszItems
                Multistring of the Items for the query to collect.  Any 
                existing Items will be overwritten.

        ULONG   length
                Length of the mszItems buffer

    Return:

        PDH_INVALID_ARGUMENT
                The query does not exist or pItems->dwType != Log Type

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PlaiIsKernel( LPWSTR mszGuid, BOOL* pbKernel, ULONG* pnCount )
{
    DWORD dwStatus;
    LPTSTR strGuid = mszGuid;
    UNICODE_STRING strKernel;
        
    *pbKernel = FALSE;
    *pnCount = 0;

    dwStatus = RtlStringFromGUID( SystemTraceControlGuid, &strKernel );
    
    if( ERROR_SUCCESS != dwStatus ){
        return PlaiErrorToPdhStatus( dwStatus );
    }
    
    if( NULL != mszGuid ){
        while( *strGuid != L'\0' ){
            if( ! wcscmp( strGuid, strKernel.Buffer ) ){
                *pbKernel = TRUE;
            }
            strGuid += (wcslen( strGuid) + 1 );
            (*pnCount)++;
        }
    }
    
    RtlFreeUnicodeString( &strKernel );
    
    return PlaiErrorToPdhStatus( dwStatus );
}

PDH_FUNCTION
PlaiSetItemList(
        HKEY    hkeyQuery,
        PPDH_PLA_ITEM_W pItems
    )
{
    PDH_STATUS pdhStatus;
        
    DWORD dwValue;
    pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szLogType, &dwValue );

    __try {

        if( ERROR_SUCCESS == pdhStatus && 
            (dwValue != pItems->dwType && 
            PLA_NEW_LOG != dwValue) ){

            pdhStatus = PDH_PLA_ERROR_TYPE_MISMATCH;
        }

        if( ERROR_SUCCESS == pdhStatus ){
        
            switch( pItems->dwType ){
            case PLA_TRACE_LOG:
                {
                    BOOL bKernel;
                    ULONG nCount;
                    pdhStatus = PlaiIsKernel( pItems->strProviders, &bKernel, &nCount );
                    if( ERROR_SUCCESS != pdhStatus ){
                        return pdhStatus;
                    }
                    if( bKernel ){
                
                        if( nCount == 1 ){
                            DWORD dwFlags = Plaihextoi( pItems->strFlags );
                            DWORD dwInternal = 0;

                            pdhStatus = PlaiTranslateKernelFlags( &dwInternal, &dwFlags );

                            pdhStatus = PlaiWriteRegistryDwordValue( 
                                        hkeyQuery, 
                                        szTraceFlags, 
                                        &dwInternal
                                    );
                    
                            pdhStatus = PlaiWriteRegistryStringValue( 
                                        hkeyQuery, 
                                        szTraceProviderList, 
                                        REG_MULTI_SZ, 
                                        NULL, 
                                        0
                                    );
                        

                        }else{
                            return PDH_INVALID_ARGUMENT;
                        }
                    }else{
                        DWORD dwFlags = 0;

                        pdhStatus = PlaiWriteRegistryDwordValue( 
                                    hkeyQuery, 
                                    szTraceFlags, 
                                    &dwFlags 
                                );

                        pdhStatus = PlaiWriteRegistryStringValue( 
                                    hkeyQuery, 
                                    szTraceProviderList, 
                                    REG_MULTI_SZ, 
                                    pItems->strProviders, 
                                    PlaMszStrLenW( pItems->strProviders )
                                );
                    }

                    pdhStatus = PlaiWriteRegistryStringValue( 
                                hkeyQuery, 
                                szTraceProviderFlags, 
                                REG_MULTI_SZ, 
                                pItems->strFlags, 
                                PlaMszStrLenW( pItems->strFlags )
                            );

                    pdhStatus = PlaiWriteRegistryStringValue( 
                                hkeyQuery, 
                                szTraceProviderLevels, 
                                REG_MULTI_SZ, 
                                pItems->strLevels, 
                                PlaMszStrLenW( pItems->strLevels )
                            );

                break;
                }
            case PLA_COUNTER_LOG:
                {
                    if( PLA_ENGLISH ){

                        pdhStatus = PlaiWriteRegistryStringValue( 
                                    hkeyQuery, 
                                    szPerfCounterList, 
                                    REG_MULTI_SZ, 
                                    pItems->strCounters, 
                                    PlaMszStrLenW( pItems->strCounters )
                                );

                    }else{

                        LPWSTR strCounter = pItems->strCounters;

                        pdhStatus = PlaiWriteRegistryStringValue( 
                                hkeyQuery, 
                                szPerfCounterList, 
                                REG_MULTI_SZ, 
                                L"\0", 
                                sizeof(WCHAR) 
                            );

                        if( ERROR_SUCCESS == pdhStatus && NULL != strCounter ){

                            PDH_PLA_ITEM_W Counter;
                            Counter.dwType = PLA_COUNTER_LOG;
                            while( *strCounter != L'\0' ){
                                Counter.strCounters = strCounter;
                                pdhStatus = PlaiAddItem( hkeyQuery, &Counter );
                                if( ERROR_SUCCESS != pdhStatus ){
                                    break;
                                }
                                strCounter += (wcslen(strCounter)+1);
                            }
                        }

                    }
                }
                break;
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhPlaSetItemListA(
        LPSTR  /*strName*/,
        LPSTR  /*strComputer*/,
        PPDH_PLA_ITEM_A  /*pItems*/
    )
{
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION
PdhPlaSetItemListW(
        LPWSTR  strName,
        LPWSTR  strComputer,
        PPDH_PLA_ITEM_W pItems
    )
{
    PDH_STATUS pdhStatus;
    HKEY hkeyQuery = NULL;

    VALIDATE_QUERY( strName );

    LPWSTR szName = PlaiStringDuplicate( strName );
    LPWSTR szComputer = PlaiStringDuplicate( strComputer );
    CHECK_NAMES( szName, szComputer, strComputer );

    pdhStatus = PlaiConnectAndLockQuery( szComputer, szName, hkeyQuery );

    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = PlaiSetItemList( hkeyQuery, pItems );        
    }

    RELEASE_MUTEX(hPdhPlaMutex);

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }

cleanup:
    G_FREE( szName );
    G_FREE( szComputer );

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaAddItem

    Sets the list of items ( counters or providers ) for a log query

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to

        LPTSTR  strItem
                A single item to be added to the list of Items or providers
                the query will collect

    Return:
        PDH_MEMORY_ALLOCATION_FAILURE
                The total list of items will not fit in the available 
                memory.

        PDH_PLA_COLLECTION_NOT_FOUND
                The query does not exist

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION 
PlaiRegAddItem(
        HKEY    hkeyQuery,
        LPCWSTR  strList,
        LPWSTR  strItem
    )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    
    LPWSTR  strOldList = NULL;
    LPWSTR  strNewList = NULL;

    DWORD   dwNewDataSize = ( wcslen( strItem ) ) * sizeof(WCHAR);
    DWORD   dwOldDataSize = 0;
    DWORD   dwTermSize = sizeof(WCHAR) * 2;
    
    if( PlaiIsStringEmpty( strItem ) ){
        return PDH_INVALID_ARGUMENT;
    }

    if( ERROR_SUCCESS == pdhStatus ){

        pdhStatus = PlaiReadRegistryStringValue( hkeyQuery, strList, 0, &strOldList, &dwOldDataSize );
    
        strNewList = (LPWSTR)G_ALLOC( dwOldDataSize + dwNewDataSize + dwTermSize);

        if( NULL == strNewList ){
            G_FREE( strOldList );
            return PDH_MEMORY_ALLOCATION_FAILURE;
        }

        ZeroMemory( strNewList, dwOldDataSize + dwNewDataSize + dwTermSize );

        if( dwOldDataSize ){
            memcpy( strNewList, strOldList, dwOldDataSize );
            memcpy( (((PUCHAR)strNewList) + (dwOldDataSize-sizeof(WCHAR))), strItem, dwNewDataSize );
        }else{
            memcpy( strNewList, strItem, dwNewDataSize );
        }
        
        pdhStatus = PlaiWriteRegistryStringValue( 
                hkeyQuery, 
                strList, 
                REG_MULTI_SZ, 
                strNewList, 
                (dwOldDataSize + dwNewDataSize + sizeof(WCHAR)) 
            );
    }

    G_FREE( strOldList );
    G_FREE( strNewList );
 
    return pdhStatus;
}

PDH_FUNCTION
PlaiAddItem( 
        HKEY hkeyQuery,
        PPDH_PLA_ITEM_W pItem 
    )
{
    PDH_STATUS pdhStatus;
    DWORD dwValue;

    pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szLogType, &dwValue );

    __try {
    
        if( ERROR_SUCCESS == pdhStatus && dwValue != pItem->dwType && PLA_NEW_LOG != dwValue ){
            pdhStatus = PDH_PLA_ERROR_TYPE_MISMATCH;
        }
        if( ERROR_SUCCESS == pdhStatus ){
            switch( pItem->dwType ){
            case PLA_TRACE_LOG:
                {
                    BOOL bKernel;
                    ULONG nCount;
                    pdhStatus = PlaiIsKernel( pItem->strProviders, &bKernel, &nCount );
                    if( ERROR_SUCCESS == pdhStatus ){
                        if( bKernel ){
                            DWORD dwFlags = Plaihextoi( pItem->strFlags );
                
                            pdhStatus = PlaiWriteRegistryDwordValue( 
                                        hkeyQuery, 
                                        szTraceFlags, 
                                        &dwFlags
                                    );
                
                            pdhStatus = PlaiWriteRegistryStringValue( 
                                        hkeyQuery, 
                                        szTraceProviderList, 
                                        REG_MULTI_SZ, 
                                        NULL,
                                        0
                                    );
                        }else{
                            DWORD dwFlags = 0;
                            pdhStatus = PlaiWriteRegistryDwordValue( 
                                        hkeyQuery, 
                                        szTraceFlags, 
                                        &dwFlags
                                    );

                            pdhStatus = PlaiRegAddItem( hkeyQuery, szTraceProviderList, pItem->strProviders );
                            if( ERROR_SUCCESS == pdhStatus ){
                                pdhStatus = PlaiRegAddItem( hkeyQuery, szTraceProviderFlags, pItem->strFlags );
                                if( ERROR_SUCCESS == pdhStatus ){
                                    pdhStatus = PlaiRegAddItem( hkeyQuery, szTraceProviderLevels, pItem->strLevels );
                                }
                            }
                        }
                    }
                }
                break;
            case PLA_COUNTER_LOG:
                {
                    if( PLA_ENGLISH ){
                        pdhStatus = PlaiRegAddItem( hkeyQuery, szPerfCounterList, pItem->strCounters );
                    }else{
                        LPWSTR strLocaleCounter = pItem->strCounters;
                        LPWSTR strEnglishCounter = NULL;
                        DWORD dwSize = MAX_PATH;
                
                        strEnglishCounter = (LPWSTR)G_ALLOC( dwSize*sizeof(WCHAR) );
                        if( NULL != strEnglishCounter ){

                            pdhStatus = PdhTranslate009CounterW( strLocaleCounter, strEnglishCounter, &dwSize );
                            if( PDH_MORE_DATA == pdhStatus ){
                                LPTSTR strBuffer = (LPWSTR)G_REALLOC( strEnglishCounter, (dwSize*sizeof(WCHAR)) );
                                if( NULL != strBuffer ){
                                    strEnglishCounter = strBuffer;
                                    pdhStatus = PdhTranslate009CounterW( strLocaleCounter, strEnglishCounter, &dwSize );
                                }else{
                                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                                }
                            }
                            if( ERROR_SUCCESS == pdhStatus ){
                                pdhStatus = PlaiRegAddItem( hkeyQuery, szPerfCounterList, strEnglishCounter );
                            }else{
                                pdhStatus = PlaiRegAddItem( hkeyQuery, szPerfCounterList, pItem->strCounters );
                            }
        
                            G_FREE( strEnglishCounter );
                        }else{
                            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                        }
                    }

                }
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    return pdhStatus;
}

PDH_FUNCTION 
PdhPlaAddItemA(
        LPSTR  strName,
        LPSTR  strComputer,
        PPDH_PLA_ITEM_A pItem
    )
{
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION 
PdhPlaAddItemW(
        LPWSTR  strName,
        LPWSTR  strComputer,
        PPDH_PLA_ITEM_W pItem
    )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HKEY    hkeyQuery = NULL;
    
    VALIDATE_QUERY( strName );

    LPWSTR szName = PlaiStringDuplicate( strName );
    LPWSTR szComputer = PlaiStringDuplicate( strComputer );
    CHECK_NAMES( szName, szComputer, strComputer );

    pdhStatus = PlaiConnectAndLockQuery( szComputer, szName, hkeyQuery );

    if( ERROR_SUCCESS == pdhStatus ){
        
        pdhStatus = PlaiAddItem( hkeyQuery, pItem );

        RELEASE_MUTEX(hPdhPlaMutex);
    }

cleanup:
    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }
    
    G_FREE( szName  );
    G_FREE( szComputer );

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaRemoveAllItems

    Removes all entries for the list of Items the log query will collect

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to

    Return:
        PDH_INVALID_ARGUMENT
                The query does not exist

        ERROR_SUCCESS
        
\*****************************************************************************/


PDH_FUNCTION
PdhPlaRemoveAllItemsA( LPSTR strName, LPSTR strComputer )
{
    PDH_STATUS pdhStatus;
    LPWSTR wstrName = NULL;
    LPWSTR wstrComputer = NULL;

    VALIDATE_QUERY( strName );
    
    pdhStatus = Plaiatow( strComputer, wstrComputer );
    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = Plaiatow( strName, wstrName );
        if( ERROR_SUCCESS == pdhStatus ){
            pdhStatus = PdhPlaRemoveAllItemsW( wstrName, wstrComputer );
        }
    }
   
    G_FREE( wstrComputer );
    G_FREE( wstrName );

    return pdhStatus;
}

PDH_FUNCTION 
PdhPlaRemoveAllItemsW(
        LPWSTR strName,
        LPWSTR strComputer
    )
{
    PDH_STATUS pdhStatus;
    HKEY    hkeyQuery = NULL;

    VALIDATE_QUERY( strName );

    LPWSTR szName = PlaiStringDuplicate( strName );
    LPWSTR szComputer = PlaiStringDuplicate( strComputer );
    CHECK_NAMES( szName, szComputer, strComputer );

    pdhStatus = PlaiConnectAndLockQuery( szComputer, szName, hkeyQuery );
    
    if( ERROR_SUCCESS == pdhStatus ){
        DWORD dwValue;
        pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szLogType, &dwValue );
        
        if( ERROR_SUCCESS == pdhStatus ){
            
            switch( dwValue ){
            case PLA_TRACE_LOG:
                pdhStatus = PlaiWriteRegistryStringValue( 
                            hkeyQuery, 
                            szTraceProviderList, 
                            REG_MULTI_SZ, L"\0", 
                            sizeof(WCHAR) 
                        );
                pdhStatus = PlaiWriteRegistryStringValue( 
                            hkeyQuery, 
                            szTraceProviderFlags, 
                            REG_MULTI_SZ, L"\0", 
                            sizeof(WCHAR) 
                        );
                pdhStatus = PlaiWriteRegistryStringValue( 
                            hkeyQuery, 
                            szTraceProviderLevels, 
                            REG_MULTI_SZ, L"\0", 
                            sizeof(WCHAR) 
                        );
                break;
            case PLA_COUNTER_LOG:
                pdhStatus = PlaiWriteRegistryStringValue( 
                            hkeyQuery, 
                            szPerfCounterList, 
                            REG_MULTI_SZ, 
                            L"\0", 
                            sizeof(WCHAR) 
                        );
                break;
            }
        }
    
        RELEASE_MUTEX(hPdhPlaMutex);
    }

cleanup:
    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }

    G_FREE( szName  );
    G_FREE( szComputer );

    return pdhStatus;
}


/*****************************************************************************\

    PdhPlaGetInfo

    Fills the PDH_PLA_INFO structure with the properties of the requested 
    log query.

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to

        PPDH_PLA_INFO pInfo
                Information block

    Return:
        PDH_INVALID_ARGUMENT
                The query does not exist

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PlaiAssignInfoString(
    LPWSTR strName,
    HKEY hkeyQuery, 
    PPDH_PLA_INFO_W pInfo, 
    LPDWORD dwTotalSize,
    LPWSTR& strCopy,
    DWORD dwBufferSize,
    DWORD dwMask,
    DWORD dwQueryMask,
    LPCTSTR szKey, 
    DWORD dwRegFlag
    )
{
    
    LPWSTR strKeyValue = NULL;
    LPWSTR strInfo = NULL;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    DWORD dwKeySize = 0;
    BOOL bRead = TRUE;
    
    VALIDATE_QUERY( strName );
    
    if( pInfo != NULL ){
        if( !(dwQueryMask & dwMask) ){
            bRead = FALSE;
        }
    }

    if( bRead ){
        pdhStatus = PlaiReadRegistryStringValue( hkeyQuery, szKey, dwRegFlag, &strKeyValue, &dwKeySize );
        
        if( (ERROR_SUCCESS == pdhStatus) && 
            (!PlaiIsStringEmpty(strKeyValue)) && 
            (dwKeySize > sizeof(WCHAR)) ){

            *dwTotalSize += dwKeySize;

        }else if( dwMask == PLA_INFO_FLAG_USER ){
            
            G_FREE( strKeyValue );
            strKeyValue = (LPWSTR)G_ALLOC(PLA_ACCOUNT_BUFFER*sizeof(WCHAR) );
            
            if( strKeyValue != NULL ){
                dwKeySize = LoadStringW( 
                        (HINSTANCE)ThisDLLHandle, 
                        IDS_DEFAULT_ACCOUNT, 
                        strKeyValue, 
                        PLA_ACCOUNT_BUFFER 
                    );
                
                if( dwKeySize ){
                    dwKeySize = BYTE_SIZE( strKeyValue ) + sizeof(WCHAR);
                    *dwTotalSize += dwKeySize;
                }
            }else{
                bRead = FALSE;
            }
            
        }else if( (dwMask == PLA_INFO_FLAG_LOGGERNAME) || 
                  ((dwMask == PLA_INFO_FLAG_FILENAME) && (ERROR_SUCCESS != pdhStatus)) ){

            G_FREE( strKeyValue );
            dwKeySize = BYTE_SIZE( strName ) + sizeof(WCHAR);
            *dwTotalSize += dwKeySize;
            strKeyValue = (LPWSTR)G_ALLOC(dwKeySize);
            if( NULL != strKeyValue && !PlaiIsStringEmpty( strName ) ){
                StringCbCopy( strKeyValue, dwKeySize, strName );
            }else{
                bRead = FALSE;
            }

        }else{
            dwKeySize = 0;
        }
    }

    if( pInfo != NULL && bRead ){
        if( dwKeySize && (dwBufferSize >= *dwTotalSize) ){
            memcpy( (void*)strCopy, (void*)strKeyValue, dwKeySize );
            strInfo = strCopy;
            strCopy = (LPWSTR)((PUCHAR)strCopy + dwKeySize );
        }
        
        __try{
            switch( dwMask ){
            case PLA_INFO_FLAG_COUNTERS:
                pInfo->dwMask |= PLA_INFO_FLAG_COUNTERS;
                pInfo->Perf.piCounterList.strCounters = strInfo;
                break;
            case PLA_INFO_FLAG_SQLNAME: 
                pInfo->dwMask |= PLA_INFO_FLAG_SQLNAME;
                pInfo->strSqlName = strInfo;
                break;
            case PLA_INFO_FLAG_FILENAME:
                pInfo->dwMask |= PLA_INFO_FLAG_FILENAME;
                pInfo->strBaseFileName = strInfo;
                break;
            case PLA_INFO_FLAG_PROVIDERS:
                pInfo->dwMask |= PLA_INFO_FLAG_PROVIDERS;
                pInfo->Trace.piProviderList.strProviders = strInfo;
                break;
            case PLA_INFO_FLAG_LOGGERNAME:
                pInfo->dwMask |= PLA_INFO_FLAG_LOGGERNAME;
                pInfo->Trace.strLoggerName = strInfo;
                break;
            case PLA_INFO_FLAG_USER:
                pInfo->dwMask |= PLA_INFO_FLAG_USER;
                pInfo->strUser = strInfo;
                break;
            case PLA_INFO_FLAG_DEFAULTDIR:
                pInfo->dwMask |= PLA_INFO_FLAG_DEFAULTDIR;
                pInfo->strDefaultDir = strInfo;
                break;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {

        }
    }
        
    G_FREE( strKeyValue );
    
    return ERROR_SUCCESS;
}

PDH_FUNCTION
PdhPlaGetInfoA(
        LPSTR /*strName*/,
        LPSTR /*strComputer*/,
        LPDWORD /*pdwBufferSize*/,
        PPDH_PLA_INFO_A /*pInfo*/
    )
{
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION
PdhPlaGetInfoW(
        LPWSTR strName,
        LPWSTR strComputer,
        LPDWORD pdwBufferSize,
        PPDH_PLA_INFO_W pInfo
    )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HKEY hkeyQuery = NULL;
    DWORD dwSize = 0;
    LPWSTR strCopy = NULL;
    LPWSTR strKey = NULL; 
    DWORD  dwKeySize = 0;
    DWORD dwMask = 0;
    
    VALIDATE_QUERY( strName );
    DWORD dwBufferSize;

    __try {
        dwBufferSize = *pdwBufferSize;
        if( pInfo != NULL ){
            dwMask = pInfo->dwMask;
            pInfo->dwMask = 0;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    CHECK_STATUS( pdhStatus ); 

    LPWSTR szName = PlaiStringDuplicate( strName );
    LPWSTR szComputer = PlaiStringDuplicate( strComputer );
    CHECK_NAMES( szName, szComputer, strComputer );

    pdhStatus = PlaiConnectAndLockQuery( szComputer, szName, hkeyQuery, FALSE );

    if( ERROR_SUCCESS == pdhStatus ){

        DWORD dwType = 0;
        dwSize = sizeof(PDH_PLA_INFO_W);
        
        if( pInfo == NULL ){
            dwBufferSize = 0;
        }else{
            strCopy = (LPWSTR)( (PUCHAR)pInfo+ sizeof(PDH_PLA_INFO_W) );
        }

        PlaiReadRegistryDwordValue( hkeyQuery, szLogType, &dwType );
        
        if( pInfo != NULL ){
            __try {
                if( dwMask & PLA_INFO_FLAG_TYPE ){
                    pInfo->dwMask |= PLA_INFO_FLAG_TYPE;
                    pInfo->dwType = dwType;
                }
                if( dwMask & PLA_INFO_FLAG_AUTOFORMAT ){
                    pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szLogAutoFormat, &pInfo->dwAutoNameFormat );
                    if( ERROR_SUCCESS == pdhStatus ){
                        pInfo->dwMask |= PLA_INFO_FLAG_AUTOFORMAT;
                    }
                }
                if( dwMask & PLA_INFO_FLAG_SRLNUMBER ){
                    pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szLogSerialNumber, &pInfo->dwLogFileSerialNumber );
                    if( ERROR_SUCCESS == pdhStatus ){
                        pInfo->dwMask |= PLA_INFO_FLAG_SRLNUMBER;
                    }
                }
                if( dwMask & PLA_INFO_FLAG_REPEAT ){
                    pdhStatus = PlaiReadRegistryPlaTime( hkeyQuery, szRepeatSchedule, &pInfo->ptRepeat );
                    if( ERROR_SUCCESS == pdhStatus ){
                        pInfo->dwMask |= PLA_INFO_FLAG_REPEAT;
                    }
                }
                if( dwMask & PLA_INFO_FLAG_STATUS ){
                    pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szCurrentState, &pInfo->dwStatus );
                    if( ERROR_SUCCESS == pdhStatus ){
                        pInfo->dwMask |= PLA_INFO_FLAG_STATUS;
                    }
                }
                if( dwMask & PLA_INFO_FLAG_FORMAT ){
                    pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szLogFileType, &pInfo->dwFileFormat );
                    if( ERROR_SUCCESS == pdhStatus ){
                        pInfo->dwMask |= PLA_INFO_FLAG_FORMAT;
                    }
                }
                if( dwMask & PLA_INFO_FLAG_DATASTORE ){
                    pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szDatastoreAttributes, &pInfo->dwDatastoreAttributes );
                    if( ERROR_SUCCESS == pdhStatus ){
                        pInfo->dwMask |= PLA_INFO_FLAG_DATASTORE;
                    }
                }
                if( dwMask & PLA_INFO_FLAG_CRTNEWFILE ){
                    pdhStatus = PlaiReadRegistryPlaTime( hkeyQuery, szCreateNewFile, &pInfo->ptCreateNewFile);
                    if( ERROR_SUCCESS == pdhStatus ){
                        pInfo->dwMask |= PLA_INFO_FLAG_CRTNEWFILE;
                    }
                }
                if( dwMask & PLA_INFO_FLAG_END ){
                    pdhStatus = PlaiReadRegistryPlaTime( hkeyQuery, szStop, &pInfo->ptLogEndTime );
                    if( ERROR_SUCCESS == pdhStatus ){
                        pInfo->dwMask |= PLA_INFO_FLAG_END;
                    }
                }
                if( dwMask & PLA_INFO_FLAG_BEGIN ){
                    pdhStatus = PlaiReadRegistryPlaTime( hkeyQuery, szStart, &pInfo->ptLogBeginTime );
                    if( ERROR_SUCCESS == pdhStatus ){
                        pInfo->dwMask |= PLA_INFO_FLAG_BEGIN;
                    }
                }
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }

        }   
        
        pdhStatus = PlaiAssignInfoString( szName, hkeyQuery, pInfo, &dwSize, strCopy, dwBufferSize, 
            PLA_INFO_FLAG_FILENAME, dwMask, szLogBaseName, READ_REG_MUI );
                
        pdhStatus = PlaiAssignInfoString( szName, hkeyQuery, pInfo, &dwSize, strCopy, dwBufferSize, 
            PLA_INFO_FLAG_USER, dwMask, szRunAs, 0 );
        
        pdhStatus = PlaiAssignInfoString( szName, hkeyQuery, pInfo, &dwSize, strCopy, dwBufferSize, 
            PLA_INFO_FLAG_DEFAULTDIR, dwMask, szLogFolder, READ_REG_MUI );

        __try {
            switch( dwType ){
            case PLA_TRACE_LOG:   // Trace Fields
                if( NULL != pInfo ){
                    if( dwMask & PLA_INFO_FLAG_MODE ){
                        pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szTraceMode, &pInfo->Trace.dwMode );
                        if( ERROR_SUCCESS == pdhStatus ){
                            pInfo->dwMask |= PLA_INFO_FLAG_MODE;
                        }
                    }
                    if( dwMask & PLA_INFO_FLAG_BUFFERSIZE ){
                        pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szTraceBufferSize, &pInfo->Trace.dwBufferSize );
                        if( ERROR_SUCCESS == pdhStatus ){
                            pInfo->dwMask |= PLA_INFO_FLAG_BUFFERSIZE;
                        }
                    }
                    if( dwMask & PLA_INFO_FLAG_PROVIDERS ){
                        pInfo->Trace.piProviderList.dwType = PLA_TRACE_LOG;
                    }
                }
                pdhStatus = PlaiAssignInfoString( szName, hkeyQuery, pInfo, &dwSize, strCopy, dwBufferSize, 
                        PLA_INFO_FLAG_PROVIDERS, dwMask, szTraceProviderList, 0 );

                pdhStatus = PlaiAssignInfoString( szName, hkeyQuery, pInfo, &dwSize, strCopy, dwBufferSize, 
                        PLA_INFO_FLAG_LOGGERNAME, dwMask, szTraceLoggerName, 0 );
                break;

            case PLA_COUNTER_LOG:  // Performance Fields
                if( NULL != pInfo ){
                    if( dwMask & PLA_INFO_FLAG_COUNTERS ){
                        pInfo->Perf.piCounterList.dwType = PLA_COUNTER_LOG;
                    }
                }
                pdhStatus = PlaiAssignInfoString( szName, hkeyQuery, pInfo, &dwSize, strCopy, dwBufferSize, 
                        PLA_INFO_FLAG_COUNTERS, dwMask, szPerfCounterList, 0 );

                pdhStatus = PlaiAssignInfoString( szName, hkeyQuery, pInfo, &dwSize, strCopy, dwBufferSize, 
                        PLA_INFO_FLAG_SQLNAME, dwMask, szSqlBaseName, 0 );
                break;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

        RELEASE_MUTEX(hPdhPlaMutex);
    }

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }

    __try {
        *pdwBufferSize = dwSize;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

cleanup:
    G_FREE( szName );
    G_FREE( szComputer );

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaSetInfo
    
    Sets the information in the log query to the parameters in the 
    PDH_PLA_INFO block according to the info mask.

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to

        PPDH_PLA_INFO pInfo
                Information block

    Return:
        PDH_INVALID_ARGUMENT
                The query does not exist or pInfo is NULL

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PlaiSetInfo(
    LPWSTR strComputer,
    HKEY hkeyQuery,
    PPDH_PLA_INFO_W pInfo
)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    DWORD dwType = 0;
    DWORD dwFormat = 0;
    DWORD dwDatastoreAttributes = 0;

    __try {

        // General Fields
        if( pInfo->dwMask & PLA_INFO_FLAG_AUTOFORMAT ){
            pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szLogAutoFormat, &pInfo->dwAutoNameFormat );
        }
        if( pInfo->dwMask & PLA_INFO_FLAG_REPEAT ){
            pdhStatus = PlaiWriteRegistryPlaTime( hkeyQuery, szRepeatSchedule, &pInfo->ptRepeat );
        }
        if( pInfo->dwMask & PLA_INFO_FLAG_RUNCOMMAND ){
            pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szEOFCmd, REG_SZ, pInfo->strCommandFileName, 0 );
        }
        if( pInfo->dwMask & PLA_INFO_FLAG_CRTNEWFILE ){
            pdhStatus = PlaiWriteRegistryPlaTime( hkeyQuery, szCreateNewFile, &pInfo->ptCreateNewFile );
        }
        if( pInfo->dwMask & PLA_INFO_FLAG_MAXLOGSIZE ){
            pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szLogMaxSize, &pInfo->dwMaxLogSize );
        }
        if( pInfo->dwMask & (PLA_INFO_FLAG_SQLNAME|PLA_INFO_FLAG_FILENAME|PLA_INFO_FLAG_DEFAULTDIR) ){
            if( pInfo->dwMask & PLA_INFO_FLAG_FORMAT ){
                dwFormat = pInfo->dwFileFormat;
                pdhStatus = ERROR_SUCCESS;
            }else{
                pdhStatus = PlaiReadRegistryDwordValue( hkeyQuery, szLogFileType, &dwFormat );
            }
            if( (ERROR_SUCCESS == pdhStatus) && (PLA_SQL_LOG == dwFormat) ){
                if( pInfo->dwMask & PLA_INFO_FLAG_SQLNAME ){
                    pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szSqlBaseName, REG_SZ, pInfo->strSqlName, 0 );
                }else if( pInfo->dwMask & PLA_INFO_FLAG_FILENAME ){
                    pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szSqlBaseName, REG_SZ, pInfo->strBaseFileName, 0 );
                }else if( pInfo->dwMask & PLA_INFO_FLAG_DEFAULTDIR ){
                    pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szSqlBaseName, REG_SZ, pInfo->strDefaultDir, 0 );
                }
            }else{
                if( pInfo->dwMask & PLA_INFO_FLAG_SQLNAME ){
                    pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szSqlBaseName, REG_SZ, pInfo->strSqlName, 0 );
                }
                if( pInfo->dwMask & PLA_INFO_FLAG_FILENAME ){
                    pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szLogBaseName, REG_SZ, pInfo->strBaseFileName, 0 );
                }
                if( pInfo->dwMask & PLA_INFO_FLAG_DEFAULTDIR ){
                    pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szLogFolder, REG_SZ, pInfo->strDefaultDir, 0 );
                }
            }
        }
        if( pInfo->dwMask & PLA_INFO_FLAG_TYPE ){
            // Do not write it to the registry because it may be a new collection
            dwType = pInfo->dwType;
        }else{
            PlaiReadRegistryDwordValue( hkeyQuery, szLogType, &dwType );
        }


        switch( dwType ){
        case PLA_TRACE_LOG:   // Trace Fields
            if( pInfo->dwMask & PLA_INFO_FLAG_FORMAT ){
                dwFormat = pInfo->dwFileFormat;
                switch( dwFormat ){
                case PLA_BIN_FILE:        dwFormat = PLA_SEQ_TRACE_FILE; break;
                case PLA_BIN_CIRC_FILE:   dwFormat = PLA_CIRC_TRACE_FILE; break;
                }
                pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szLogFileType, &dwFormat );
            }else{
                PlaiReadRegistryDwordValue( hkeyQuery, szLogFileType, &dwFormat );
            }
            if( pInfo->dwMask & PLA_INFO_FLAG_DATASTORE ){
                if( ! (pInfo->dwDatastoreAttributes & PLA_DATASTORE_APPEND_MASK ) ){
                    if( dwFormat == PLA_SEQ_TRACE_FILE ){
                        pInfo->dwDatastoreAttributes |= PLA_DATASTORE_APPEND;
                    }else{
                        pInfo->dwDatastoreAttributes |= PLA_DATASTORE_OVERWRITE;
                    }
                }
                if( ! (pInfo->dwDatastoreAttributes & PLA_DATASTORE_SIZE_MASK ) ){
                    pInfo->dwDatastoreAttributes |= PLA_DATASTORE_SIZE_MB;
                }
                pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szDatastoreAttributes, &pInfo->dwDatastoreAttributes );
            }
            if( pInfo->dwMask & PLA_INFO_FLAG_BUFFERSIZE ){
                pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szTraceBufferSize, &pInfo->Trace.dwBufferSize );
            }
            if( pInfo->dwMask & PLA_INFO_FLAG_MINBUFFERS ){
                pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szTraceBufferMin, &pInfo->Trace.dwMinimumBuffers );
            }
            if( pInfo->dwMask & PLA_INFO_FLAG_MAXBUFFERS ){
                pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szTraceBufferMax, &pInfo->Trace.dwMaximumBuffers );
            }
            if( pInfo->dwMask & PLA_INFO_FLAG_FLUSHTIMER ){
                pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szTraceFlushInterval, &pInfo->Trace.dwFlushTimer );
            }
            if( pInfo->dwMask & PLA_INFO_FLAG_MODE ){
                pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szTraceMode, &pInfo->Trace.dwMode );
            }
            if( pInfo->dwMask & PLA_INFO_FLAG_LOGGERNAME ){
                pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szTraceLoggerName, REG_SZ, pInfo->Trace.strLoggerName, 0 );
            }
            if( pInfo->dwMask & PLA_INFO_FLAG_PROVIDERS ){
                pdhStatus = PlaiSetItemList( hkeyQuery, &pInfo->Trace.piProviderList );
            }
            break;

        case PLA_COUNTER_LOG:  // Performance Fields
            if( pInfo->dwMask & PLA_INFO_FLAG_FORMAT ){
                dwFormat = pInfo->dwFileFormat;
                switch( dwFormat ){
                case PLA_CIRC_TRACE_FILE: dwFormat = PLA_BIN_CIRC_FILE; break;
                case PLA_SEQ_TRACE_FILE:  dwFormat = PLA_BIN_FILE; break;
                }
                pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szLogFileType, &dwFormat );
            }else{
                PlaiReadRegistryDwordValue( hkeyQuery, szLogFileType, &dwFormat );
            }
            if( pInfo->dwMask & PLA_INFO_FLAG_DATASTORE ){
                if( PLA_SQL_LOG == dwFormat ){
                    pInfo->dwDatastoreAttributes = (pInfo->dwDatastoreAttributes & 0xFFFFFF00) | 
                                                    PLA_DATASTORE_APPEND | PLA_DATASTORE_SIZE_ONE_RECORD;
                }else{
                    if( ! (pInfo->dwDatastoreAttributes & PLA_DATASTORE_APPEND_MASK ) ){
                        if( dwFormat == PLA_BIN_FILE ){
                            dwDatastoreAttributes |= PLA_DATASTORE_APPEND;  
                        }else{
                            dwDatastoreAttributes |= PLA_DATASTORE_OVERWRITE;  
                        }
                    }
                    if( ! (pInfo->dwDatastoreAttributes & PLA_DATASTORE_SIZE_MASK ) ){
                        dwDatastoreAttributes |= PLA_DATASTORE_SIZE_KB;
                    }
                }
                pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szDatastoreAttributes, &pInfo->dwDatastoreAttributes );
            }
            if( pInfo->dwMask & PLA_INFO_FLAG_MAXLOGSIZE ){
                DWORD dwMaxSize = pInfo->dwMaxLogSize;
                PlaiReadRegistryDwordValue( hkeyQuery, szDatastoreAttributes, &dwDatastoreAttributes );
                if( (dwDatastoreAttributes & PLA_DATASTORE_SIZE_MASK) == PLA_DATASTORE_SIZE_KB ){
                    dwMaxSize *= 1024;
                }
                pdhStatus = PlaiWriteRegistryDwordValue( hkeyQuery, szLogMaxSize, &dwMaxSize );
            }
            if( pInfo->dwMask & PLA_INFO_FLAG_INTERVAL ){
                pdhStatus = PlaiWriteRegistryPlaTime( hkeyQuery, szSampleInterval, &pInfo->Perf.ptSampleInterval );
            }
            if( pInfo->dwMask & PLA_INFO_FLAG_COUNTERS ){
                pdhStatus = PlaiSetItemList( hkeyQuery, &pInfo->Perf.piCounterList );
            }
            break;

        case PLA_ALERT:
            break;
        }

        if( (pInfo->dwMask & PLA_INFO_FLAG_BEGIN) || (pInfo->dwMask & PLA_INFO_FLAG_END) ){
            PDH_TIME_INFO info;
            ZeroMemory( &info, sizeof(PDH_TIME_INFO) );

            if(pInfo->dwMask & PLA_INFO_FLAG_BEGIN){
                info.StartTime = pInfo->ptLogBeginTime.llDateTime;
            }

            if(pInfo->dwMask & PLA_INFO_FLAG_END){
                info.EndTime = pInfo->ptLogEndTime.llDateTime;
            }

            pdhStatus = PlaiSchedule( 
                    strComputer, 
                    hkeyQuery,
                    PLA_AUTO_MODE_AT, 
                    &info 
                );
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhPlaSetInfoA(
    LPSTR /*strName*/,
    LPSTR /*strComputer*/,
    PPDH_PLA_INFO_A /*pInfo*/
)
{
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION
PdhPlaSetInfoW(
    LPWSTR strName,
    LPWSTR strComputer,
    PPDH_PLA_INFO_W pInfo
)
{
    PDH_STATUS pdhStatus;
    PDH_STATUS pdhWarning = ERROR_SUCCESS;
    HKEY    hkeyQuery = NULL;
    DWORD dwMask;

    VALIDATE_QUERY( strName );

    LPWSTR szName = PlaiStringDuplicate( strName );
    LPWSTR szComputer = PlaiStringDuplicate( strComputer );
    CHECK_NAMES( szName, szComputer, strComputer );
    
    if( NULL == pInfo ){
        return PDH_INVALID_ARGUMENT;
    }

    pdhStatus = PdhPlaValidateInfoW( szName, szComputer, pInfo );
    switch( SEVERITY(pdhStatus) ){
    case STATUS_SEVERITY_ERROR:
        goto cleanup;
    case STATUS_SEVERITY_WARNING:
        pdhWarning = pdhStatus;
        pdhStatus = ERROR_SUCCESS;
    }
    __try{
        
        dwMask = pInfo->dwMask;

        if( dwMask & PLA_INFO_FLAG_USER ){
            pdhStatus = PdhPlaSetRunAs( szName, szComputer, pInfo->strUser, pInfo->strPassword );
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    CHECK_STATUS(pdhStatus);
    
    pdhStatus = PlaiConnectAndLockQuery( szComputer, szName, hkeyQuery );
    
    if( ERROR_SUCCESS == pdhStatus ){
        
        if( ERROR_SUCCESS == pdhStatus ){
            pdhStatus = PlaiSetInfo( szComputer, hkeyQuery, pInfo );
        }
    
        PlaiWriteRegistryLastModified ( hkeyQuery );
        RELEASE_MUTEX(hPdhPlaMutex);

        if( SUCCEEDED( pdhStatus ) ){
            pdhStatus = PlaiSynchronize( szComputer );
            if( SUCCEEDED( pdhStatus ) && ( dwMask & PLA_INFO_FLAG_BEGIN) ){

                PlaiUpdateServiceMode( szComputer );
            }
        }
    }

cleanup:
    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }
    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = pdhWarning;
    }
    G_FREE( szName );
    G_FREE( szComputer );

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaValidateInfo

    Checks the PDH_PLA_INFO structure for valid fields.  Only checks the fields
    specified by the mask.  Returns on first invalid field and set the mask
    to the invalid field

    Arguments:

        LPTSTR  strName 
                Log Name, if NULL checks for valid argument only
        
        LPTSTR  strComputer
                Computer to connect to
        
        PPDH_PLA_INFO pInfo
                Information block

    Return:
        
        PDH_INVALID_ARGUMENT
            One of the fields is invalid.  Specified by the pInfo->dwMask
        
        PDH_LOG_TYPE_NOT_FOUND
            There is a mismatch between log type and specified parameters

        PDH_INVALID_ARGUMENT
            Arguments passed are not valid

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PlaiCheckFile( LPWSTR strFileLocation, BOOL bDirOnly )
{
    DWORD dwFile;
    DWORD dwStatus = ERROR_SUCCESS;
    LPWSTR strFile = NULL;

    __try{
        if( strFileLocation == NULL ){
            return PDH_INVALID_ARGUMENT;
        }

        dwFile = BYTE_SIZE( strFileLocation ) + sizeof(WCHAR);
        strFile = (LPWSTR)G_ALLOC( dwFile );
        if( NULL == strFile ){
            dwStatus = ERROR_OUTOFMEMORY;
            goto cleanup;
        }
        StringCbCopy( strFile, dwFile, strFileLocation );

        if( bDirOnly ){
            LPWSTR sz = strFile;
            sz += wcslen( strFile );
            while( sz > strFile ){
                if( *sz == L'\\' ){
                    *sz = L'\0';
                    break;
                }
                sz--;
            }
        }

        dwFile = GetFileAttributes( strFile );
    
        if( (DWORD)-1 == dwFile ){
            dwStatus = GetLastError();
        }

        if( ERROR_SUCCESS == dwStatus && bDirOnly ){
            if( ! (dwFile & FILE_ATTRIBUTE_DIRECTORY) ){
                dwStatus = ERROR_DIRECTORY;
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

cleanup:
    G_FREE( strFile );
    
    return PlaiErrorToPdhStatus( dwStatus );
}

PDH_FUNCTION
PdhPlaValidateInfoA(
        LPSTR /*strName*/,
        LPSTR /*strComputer*/,
        PPDH_PLA_INFO_A /*pInfo*/
    )
{
    return PDH_NOT_IMPLEMENTED;
}

#define VALIDATE_TYPE( type, flag )                 \
if( dwType != PLA_NEW_LOG && dwType != type ){      \
    dwErrorMask |= flag;                            \
    bTypeMismatch = TRUE;                           \
}else{                                              \
    dwType = type;                                  \
}                                                   \

#define PROBE_STRING( sz, flag )                    \
__try {                                             \
    if( NULL != sz ){                               \
        size_t string_size = wcslen( sz );          \
    }else{                                          \
        dwErrorMask |= flag;                        \
    }                                               \
} __except (EXCEPTION_EXECUTE_HANDLER) {            \
    dwErrorMask |= flag;                            \
}                                                   \

PDH_FUNCTION
PdhPlaValidateInfoW(
        LPWSTR strName,
        LPWSTR strComputer,
        PPDH_PLA_INFO_W pInfo
    )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    DWORD dwWarningMask = 0;
    DWORD dwErrorMask = 0;
    DWORD dwType = PLA_NEW_LOG;
    DWORD dwFormat = 0;
    PVOID pBuffer = NULL;
    PPDH_PLA_INFO_W pCurrentInfo = NULL;
    BOOL bTypeMismatch = FALSE;
    DWORD dwMask;

    if( NULL == pInfo ){
        return PDH_INVALID_ARGUMENT;
    }

    LPWSTR szName = PlaiStringDuplicate( strName );
    LPWSTR szComputer = PlaiStringDuplicate( strComputer );
    CHECK_NAMES( szName, szComputer, strComputer );

    __try{
        dwMask = pInfo->dwMask;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    CHECK_STATUS(pdhStatus);

    if( szName != NULL ){
        DWORD dwInfoSize = 0;
        
        if( wcslen( szName ) > PLA_MAX_COLLECTION_NAME ){
            pdhStatus = PDH_PLA_ERROR_NAME_TOO_LONG;
        }
        CHECK_STATUS(pdhStatus);

        pdhStatus = PdhPlaGetInfoW( szName, szComputer, &dwInfoSize, pCurrentInfo );
        if( ERROR_SUCCESS == pdhStatus ){
            pCurrentInfo = (PPDH_PLA_INFO)G_ALLOC(dwInfoSize);
            if( NULL != pCurrentInfo ){
                pCurrentInfo->dwMask = PLA_INFO_FLAG_ALL;
                pdhStatus = PdhPlaGetInfoW( szName, szComputer, &dwInfoSize, pCurrentInfo );
            
                if( pCurrentInfo->dwMask & PLA_INFO_FLAG_USER ){
                    if( !PlaiIsStringEmpty( pCurrentInfo->strUser ) ){
                        WCHAR buffer[PLA_ACCOUNT_BUFFER];
                        LoadStringW( (HINSTANCE)ThisDLLHandle, IDS_DEFAULT_ACCOUNT, buffer, PLA_ACCOUNT_BUFFER );
                        if( ! (dwMask & PLA_INFO_FLAG_USER) && wcscmp( buffer, pCurrentInfo->strUser ) != 0 ){
                            pdhStatus = PDH_ACCESS_DENIED;
                        }
                    }
                }

                if( pCurrentInfo->dwMask & PLA_INFO_FLAG_TYPE ){
                    dwType = pCurrentInfo->dwType;
                }
            }
            CHECK_STATUS(pdhStatus);
        }else{
            // collection does not exist yet
            pdhStatus = ERROR_SUCCESS;
        }
    }
    
    __try{
        if( dwMask & PLA_INFO_FLAG_TYPE ){
        
            VALIDATE_TYPE( pInfo->dwType, PLA_INFO_FLAG_TYPE );

            switch( pInfo->dwType ){
            case PLA_COUNTER_LOG:
            case PLA_TRACE_LOG:
            case PLA_ALERT:
                break;
            default:
                dwErrorMask |= PLA_INFO_FLAG_TYPE;
            }

            dwType = pInfo->dwType;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    CHECK_STATUS(pdhStatus);

    __try{
        if( dwMask & PLA_INFO_FLAG_FORMAT ){
            dwFormat = pInfo->dwFileFormat;
            switch( dwType ){
            case PLA_COUNTER_LOG:
                switch( (pInfo->dwFileFormat&0x0000FFFF) ){
                case PLA_CSV_FILE:
                case PLA_TSV_FILE:
                case PLA_BIN_FILE:
                case PLA_BIN_CIRC_FILE:
                case PLA_SQL_LOG:
                    break;
                default:
                    dwErrorMask |= PLA_INFO_FLAG_FORMAT;
                }
                break;
            case PLA_TRACE_LOG:
                switch( (pInfo->dwFileFormat&0x0000FFFF) ){
                // These will get translated to the correct flag
                case PLA_BIN_FILE: 
                case PLA_BIN_CIRC_FILE:
            
                case PLA_CIRC_TRACE_FILE:
                case PLA_SEQ_TRACE_FILE:
                    break;
                default:
                    dwErrorMask |= PLA_INFO_FLAG_FORMAT;
                }
                break;
            default:
                switch( (pInfo->dwFileFormat&0x0000FFFF) ){
                case PLA_CSV_FILE:
                case PLA_TSV_FILE:
                case PLA_BIN_FILE:
                case PLA_BIN_CIRC_FILE:
                case PLA_CIRC_TRACE_FILE:
                case PLA_SEQ_TRACE_FILE:
                case PLA_SQL_LOG:
                    break;
                default:
                    dwErrorMask |= PLA_INFO_FLAG_FORMAT;
                }
                break;
            }
        }else if( NULL != pCurrentInfo ){
            if( pCurrentInfo->dwMask & PLA_INFO_FLAG_FORMAT ){
                dwFormat = pCurrentInfo->dwFileFormat;
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    CHECK_STATUS(pdhStatus);

    if( dwMask & PLA_INFO_FLAG_COUNTERS ){
        PPDH_COUNTER_PATH_ELEMENTS pdhElements = NULL;

        VALIDATE_TYPE( PLA_COUNTER_LOG, PLA_INFO_FLAG_COUNTERS );

        __try {
            LPWSTR strCounter = pInfo->Perf.piCounterList.strCounters;
            DWORD dwCounters = 0;
            if( NULL == strCounter ){
                dwErrorMask |= PLA_INFO_FLAG_COUNTERS;
            }else{
                pBuffer = G_ALLOC(1024);
                pdhElements = (PPDH_COUNTER_PATH_ELEMENTS)pBuffer;

                if( pdhElements == NULL ){
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                CHECK_STATUS(pdhStatus);

                while( *strCounter != L'\0' ){
                    DWORD dwSize = (DWORD)G_SIZE(pBuffer);
                    ZeroMemory( pdhElements, dwSize );
                    pdhStatus = PdhParseCounterPath( strCounter, pdhElements, &dwSize, 0 );
                    switch(pdhStatus){
                    case PDH_MORE_DATA:
                    case PDH_MEMORY_ALLOCATION_FAILURE:
                    case PDH_INSUFFICIENT_BUFFER:
                    case ERROR_SUCCESS:
                        pdhStatus = ERROR_SUCCESS;
                        break;
                    default:
                        pInfo->dwReserved1 = dwCounters;
                        dwErrorMask |= PLA_INFO_FLAG_COUNTERS;
                    }
                    if( ERROR_SUCCESS != pdhStatus ){
                        pdhStatus = ERROR_SUCCESS;
                        break;
                    }
                    dwCounters++;
                    strCounter += (wcslen(strCounter)+1);
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwErrorMask |= PLA_INFO_FLAG_COUNTERS;
        }
    }

    if( dwMask & PLA_INFO_FLAG_PROVIDERS ){

        VALIDATE_TYPE( PLA_TRACE_LOG, PLA_INFO_FLAG_PROVIDERS );

        __try {
            LPWSTR strProvider = pInfo->Trace.piProviderList.strProviders;
            if( NULL == strProvider ){
                dwErrorMask |= PLA_INFO_FLAG_PROVIDERS;
            }else{
                while( *strProvider != L'\0' ){
                    strProvider += (wcslen(strProvider)+1);
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwErrorMask |= PLA_INFO_FLAG_PROVIDERS;
        }
    }

    if( dwMask & PLA_INFO_FLAG_DEFAULTDIR ){
        __try {
            ULONG dwSize;
            dwSize = wcslen( pInfo->strDefaultDir );
            if( dwSize > MAX_PATH ){
                dwErrorMask |= PLA_INFO_FLAG_DEFAULTDIR;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwErrorMask |= PLA_INFO_FLAG_DEFAULTDIR;
        }
    }

    if( dwMask & PLA_INFO_FLAG_FILENAME ){
        __try {
            ULONG dwSize;
            dwSize = wcslen( pInfo->strBaseFileName );
            if( dwSize > PLA_MAX_COLLECTION_NAME ){
                dwErrorMask |= PLA_INFO_FLAG_FILENAME;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwErrorMask |= PLA_INFO_FLAG_FILENAME;
        }
    }

    if( dwMask & PLA_INFO_CREATE_FILENAME ){
        DWORD dwSize = MAX_PATH;
        WCHAR buffer[MAX_PATH];
        __try {
            DWORD dwOriginalType = 0;
            BOOL bHaveType = (pInfo->dwMask & PLA_INFO_FLAG_TYPE);
            if( ! bHaveType ){
                pInfo->dwMask |= PLA_INFO_FLAG_TYPE;
                dwOriginalType = pInfo->dwType;
                pInfo->dwType = dwType;
            }
            pdhStatus = PdhPlaGetLogFileNameW( szName, szComputer, pInfo, 0, &dwSize, buffer );
            if( !bHaveType ){
                pInfo->dwMask &= ~PLA_INFO_FLAG_TYPE;
                pInfo->dwType = dwOriginalType;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwWarningMask |= PLA_INFO_FLAG_FILENAME;
        }
        switch( pdhStatus ){
        case ERROR_SUCCESS:
            {
                if( PlaiIsLocalComputer( szComputer ) ){
                    if( PLA_SQL_LOG != dwFormat ){
                        pdhStatus = PlaiCheckFile( buffer, TRUE );
                        if( ERROR_SUCCESS != pdhStatus ){
                            dwWarningMask |= PLA_INFO_FLAG_FILENAME;
                            pdhStatus = ERROR_SUCCESS;
                        }
                    }
                }
            }
        case PDH_INVALID_ARGUMENT:
        case PDH_PLA_VALIDATION_ERROR:
        case PDH_INSUFFICIENT_BUFFER:
            pdhStatus = ERROR_SUCCESS;
            break;
        case PDH_PLA_ERROR_FILEPATH:
        default:
            dwErrorMask |= PLA_INFO_FLAG_FILENAME;
            pdhStatus = ERROR_SUCCESS;
        }
    }

    __try{
        if( dwMask & PLA_INFO_FLAG_MODE ){

            VALIDATE_TYPE( PLA_TRACE_LOG, PLA_INFO_FLAG_MODE );

            switch( pInfo->Trace.dwMode & 0x0000000F ){
            case EVENT_TRACE_FILE_MODE_NONE:
            case EVENT_TRACE_FILE_MODE_SEQUENTIAL:
            case EVENT_TRACE_FILE_MODE_CIRCULAR:
            case EVENT_TRACE_FILE_MODE_NEWFILE:
                break;
            default:
                dwErrorMask = PLA_INFO_FLAG_MODE;
            }
            if( (pInfo->Trace.dwMode & EVENT_TRACE_REAL_TIME_MODE) &&
                (pInfo->Trace.dwMode & EVENT_TRACE_PRIVATE_LOGGER_MODE ) ){

                dwErrorMask |= PLA_INFO_FLAG_MODE;
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    CHECK_STATUS(pdhStatus);

    __try{
        if( dwMask & PLA_INFO_FLAG_REPEAT ){
        
            LONGLONG llBegin = 0;
            LONGLONG llEnd = 0;
            PPDH_PLA_INFO_W pCheckInfo;
        
            if( pInfo->ptRepeat.dwAutoMode == PLA_AUTO_MODE_CALENDAR ){
                if( dwMask & PLA_INFO_FLAG_BEGIN ){
                    pCheckInfo = pInfo;
                }else{
                    pCheckInfo = pCurrentInfo;
                }

                if( NULL != pCheckInfo ){
                    if( pCheckInfo->dwMask & PLA_INFO_FLAG_BEGIN ){
                        if( pCheckInfo->ptLogBeginTime.dwAutoMode != PLA_AUTO_MODE_AT ){
                            dwErrorMask |= PLA_INFO_FLAG_REPEAT;
                        }else{
                            llBegin = pCheckInfo->ptLogBeginTime.llDateTime;
                        }
                    }        
                }
            
                if( dwMask & PLA_INFO_FLAG_END ){
                    pCheckInfo = pInfo;
                }else{
                    pCheckInfo = pCurrentInfo;
                }

                if( NULL != pCheckInfo ){
                    if( pCheckInfo->dwMask & PLA_INFO_FLAG_END ){
                        if( pCheckInfo->ptLogEndTime.dwAutoMode != PLA_AUTO_MODE_AT ){
                            dwErrorMask |= PLA_INFO_FLAG_REPEAT;
                        }else{
                            llEnd = pCheckInfo->ptLogEndTime.llDateTime;
                        }
                    }        
                }
        
                if( 0 == llBegin || 0 == llEnd || ((llEnd - llBegin) >= FILE_TICS_PER_DAY) ){
                    dwErrorMask |= PLA_INFO_FLAG_REPEAT;
                }
            }
        }

        if( dwMask & PLA_INFO_FLAG_DATASTORE ){
            switch( pInfo->dwDatastoreAttributes & PLA_DATASTORE_APPEND_MASK ){
            case 0:
            case PLA_DATASTORE_APPEND:
                if( (dwType == PLA_TRACE_LOG && dwFormat != PLA_SEQ_TRACE_FILE ) ||
                    (dwType == PLA_COUNTER_LOG && dwFormat != PLA_BIN_FILE ) ){
                
                    dwErrorMask |= PLA_INFO_FLAG_DATASTORE;
                }
                break;
            case PLA_DATASTORE_OVERWRITE:
                if( dwFormat == PLA_SQL_LOG ){
                    dwErrorMask |= PLA_INFO_FLAG_DATASTORE;
                }
                break;
            default:
                dwErrorMask |= PLA_INFO_FLAG_DATASTORE;
            }

            switch( pInfo->dwDatastoreAttributes & PLA_DATASTORE_SIZE_MASK ){
            case 0:
            case PLA_DATASTORE_SIZE_ONE_RECORD:
            case PLA_DATASTORE_SIZE_MB:
            case PLA_DATASTORE_SIZE_KB:
                break;
            default:
                dwErrorMask |= PLA_INFO_FLAG_DATASTORE;
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    CHECK_STATUS(pdhStatus);

    if( dwMask & PLA_INFO_FLAG_SQLNAME ){

        VALIDATE_TYPE( PLA_COUNTER_LOG, PLA_INFO_FLAG_SQLNAME );     

        if( dwFormat != 0 && dwFormat != PLA_SQL_LOG ){
            dwErrorMask |= PLA_INFO_FLAG_SQLNAME;
        }else{
            dwFormat = PLA_SQL_LOG;
        }

        PROBE_STRING( pInfo->strSqlName, PLA_INFO_FLAG_SQLNAME );
    }

    if( dwMask & PLA_INFO_FLAG_LOGGERNAME ){
        
        VALIDATE_TYPE( PLA_TRACE_LOG, PLA_INFO_FLAG_LOGGERNAME );
        
        PROBE_STRING( pInfo->Trace.strLoggerName, PLA_INFO_FLAG_LOGGERNAME );
    }

    if( dwMask & PLA_INFO_FLAG_USER ){
        PROBE_STRING( pInfo->strUser, PLA_INFO_FLAG_USER );
        __try{
            if( NULL != pInfo->strPassword ){
                size_t size = wcslen( pInfo->strPassword );
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwErrorMask |= PLA_INFO_FLAG_USER;
        }
    }

    __try{
        if( dwMask & PLA_INFO_FLAG_INTERVAL ){
            LONGLONG llMS;

            VALIDATE_TYPE( PLA_COUNTER_LOG, PLA_INFO_FLAG_INTERVAL );

            pdhStatus = PlaTimeInfoToMilliSeconds (&pInfo->Perf.ptSampleInterval, &llMS );

            // 45 days in milliseconds = 1000*60*60*24*45 = 0xE7BE2C00
            if( (ERROR_SUCCESS != pdhStatus) || (llMS > (0xE7BE2C00)) || (llMS < 1000) ){
                dwErrorMask |= PLA_INFO_FLAG_INTERVAL;
                pdhStatus = ERROR_SUCCESS;
            }
        }

        if( dwMask & PLA_INFO_FLAG_BUFFERSIZE ){

            VALIDATE_TYPE( PLA_TRACE_LOG, PLA_INFO_FLAG_BUFFERSIZE );

            if( pInfo->Trace.dwBufferSize < 1 || pInfo->Trace.dwBufferSize > 1024 ){
                dwErrorMask |= PLA_INFO_FLAG_BUFFERSIZE;
            }
        }

        if( dwMask & PLA_INFO_FLAG_MINBUFFERS ){

            VALIDATE_TYPE( PLA_TRACE_LOG, PLA_INFO_FLAG_MINBUFFERS );

            if( pInfo->Trace.dwMinimumBuffers < 2 || pInfo->Trace.dwMinimumBuffers > 400 ){
                dwErrorMask |= PLA_INFO_FLAG_MINBUFFERS;
            }
        }
        if( dwMask & PLA_INFO_FLAG_MAXBUFFERS ){
        
            VALIDATE_TYPE( PLA_TRACE_LOG, PLA_INFO_FLAG_MAXBUFFERS );

            if( pInfo->Trace.dwMaximumBuffers < 2 || pInfo->Trace.dwMaximumBuffers > 400 ){
                dwErrorMask |= PLA_INFO_FLAG_MAXBUFFERS;
            }
        }
    
        if( dwMask & PLA_INFO_FLAG_FLUSHTIMER ){

            VALIDATE_TYPE( PLA_TRACE_LOG, PLA_INFO_FLAG_FLUSHTIMER );
        
            if( pInfo->Trace.dwFlushTimer < 1 ){
                dwErrorMask |= PLA_INFO_FLAG_FLUSHTIMER;
            }
        }
    
        if( dwMask & PLA_INFO_FLAG_MAXLOGSIZE ){
            if( pInfo->dwMaxLogSize != PLA_DISK_MAX_SIZE ){
                if( dwType == PLA_COUNTER_LOG ){
                    if( !( pInfo->dwMaxLogSize >= 1 && pInfo->dwMaxLogSize < 0x00000400) ){
                        dwErrorMask = PLA_INFO_FLAG_MAXLOGSIZE;
                    }
                }else{
                    if( !(pInfo->dwMaxLogSize >=1 && pInfo->dwMaxLogSize < 0xFFFFFFFF) ){
                        dwErrorMask |= PLA_INFO_FLAG_MAXLOGSIZE;
                    }
                }      
            }
        }

        if( dwMask & PLA_INFO_FLAG_AUTOFORMAT ){
            switch( pInfo->dwAutoNameFormat ){
            case PLA_SLF_NAME_NONE:
            case PLA_SLF_NAME_MMDDHH:
            case PLA_SLF_NAME_NNNNNN:
            case PLA_SLF_NAME_YYYYDDD:
            case PLA_SLF_NAME_YYYYMM:
            case PLA_SLF_NAME_YYYYMMDD:
            case PLA_SLF_NAME_YYYYMMDDHH:
            case PLA_SLF_NAME_MMDDHHMM:
                break;
            default:
                dwErrorMask |= PLA_INFO_FLAG_AUTOFORMAT;
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    CHECK_STATUS(pdhStatus);
    
    

    if( dwMask & PLA_INFO_FLAG_RUNCOMMAND ){

        PROBE_STRING( pInfo->strCommandFileName, PLA_INFO_FLAG_RUNCOMMAND );

        __try {
            if( NULL == szComputer ){
                if( PLA_SQL_LOG != dwFormat ){
                    pdhStatus = PlaiCheckFile( pInfo->strCommandFileName, FALSE );
                    if( ERROR_SUCCESS != pdhStatus ){
                        dwWarningMask |= PLA_INFO_FLAG_RUNCOMMAND;
                        pdhStatus = ERROR_SUCCESS;
                    }
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            dwErrorMask = PLA_INFO_FLAG_RUNCOMMAND;
        }
    }

cleanup:
    G_FREE( pBuffer );
    G_FREE( pCurrentInfo );
    G_FREE( szName );
    G_FREE( szComputer );

    if( 0 != dwWarningMask ){
        pInfo->dwReserved2 = dwWarningMask;
        pdhStatus = PDH_PLA_VALIDATION_WARNING;
    }

    if( 0 != dwErrorMask ){
        pInfo->dwMask = dwErrorMask;
        if( dwErrorMask & PLA_INFO_FLAG_FILENAME ){
            pdhStatus = PDH_PLA_ERROR_FILEPATH;
        }else{
            pdhStatus = PDH_PLA_VALIDATION_ERROR;
        }
    }

    if( TRUE == bTypeMismatch ){
        pdhStatus = PDH_PLA_ERROR_TYPE_MISMATCH;
    }

    return pdhStatus;
}

/*****************************************************************************\

    PdhiPlaRunAs
    
    Authenticate as saved user

    Arguments:
        
        LPTSTR  strKey
                Guid string 
        
    Return:
        PDH_INVALID_ARGUMENT
                The query does not exist

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PdhiPlaRunAs( 
    LPWSTR strName,
    LPWSTR strComputer,
    HANDLE* hToken
)
{
    PDH_STATUS pdhStatus;
    LPWSTR  strKey = NULL;
    LPWSTR  strRunAs = NULL;
    DWORD   dwKeySize = 0;
    DWORD   dwSize = 0;
    HKEY    hkeyQuery = NULL;
    HANDLE  hUserToken = NULL;
    
    VALIDATE_QUERY( strName );

    LPWSTR szName = PlaiStringDuplicate( strName );
    LPWSTR szComputer = PlaiStringDuplicate( strComputer );
    CHECK_NAMES( szName, szComputer, strComputer );

    if( hToken != NULL ){
        __try{
            *hToken = NULL;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    pdhStatus = PlaiConnectAndLockQuery( szComputer, szName, hkeyQuery );
        
    if( ERROR_SUCCESS == pdhStatus ){

        pdhStatus = PlaiReadRegistryStringValue( hkeyQuery, szRunAs, 0, &strRunAs, &dwSize );

        if( PDH_PLA_COLLECTION_NOT_FOUND == pdhStatus || PlaiIsStringEmpty(strRunAs) ){
            // The key is missing so return success
            pdhStatus = ERROR_SUCCESS;
            goto cleanup;
        }

        if( ERROR_SUCCESS == pdhStatus ){

            BOOL bResult;

            DATA_BLOB crypt;
            DATA_BLOB data;
            
            LPWSTR strUser = NULL;
            LPWSTR strDomain = NULL;
            LPWSTR strPassword = NULL;
            LPWSTR strScan = strRunAs;

            strUser = strScan;

            while( *strScan != L'\0' ){

                if( *strScan == L'\\' ){
                    *strScan = L'\0';
                    strScan++;
                    strDomain = strUser;
                    strUser = strScan;
                    break;
                }
                
                strScan++;
            }

            pdhStatus = PlaiReadRegistryStringValue( hkeyQuery, szKey, READ_REG_BLOB, &strKey, &dwKeySize );

            if( ERROR_SUCCESS == pdhStatus && !PlaiIsStringEmpty( strKey ) ){
    
                HANDLE hNetToken = NULL;

                crypt.cbData = dwKeySize;
                crypt.pbData = (BYTE*)strKey;

                bResult= LogonUserW(
                        L"NetworkService",
                        L"NT AUTHORITY",
                        L"",
                        LOGON32_LOGON_SERVICE,
                        LOGON32_PROVIDER_WINNT50,
                        &hNetToken
                    );

                if( bResult == TRUE ){
                    bResult = ImpersonateLoggedOnUser( hNetToken );
                }

                if( bResult != TRUE ){
                    pdhStatus = PlaiErrorToPdhStatus( GetLastError() );
                }
                
                ZeroMemory( &data, sizeof(DATA_BLOB) );
                bResult = CryptUnprotectData( &crypt, NULL, NULL, NULL, NULL, CRYPTPROTECT_UI_FORBIDDEN, &data );

                if( bResult == FALSE ){
                    pdhStatus = PlaiErrorToPdhStatus( GetLastError() );
                }else{
                    strPassword = (LPWSTR)data.pbData;
                    pdhStatus = ERROR_SUCCESS;
                }

                bResult = RevertToSelf();
                if( NULL != hNetToken ){
                    CloseHandle(hNetToken);
                }
                
            }else{
                strPassword = _T("");
            }

            if( ERROR_SUCCESS == pdhStatus ){

                bResult= LogonUserW(
                        strUser,
                        strDomain,
                        strPassword,
                        LOGON32_LOGON_NETWORK_CLEARTEXT,
                        LOGON32_PROVIDER_DEFAULT,
                        &hUserToken
                    );

                if( bResult == TRUE ){
                    bResult = ImpersonateLoggedOnUser( hUserToken );
                    CloseHandle( hUserToken );

                    if( bResult == TRUE ){
                        bResult= LogonUserW(
                                strUser,
                                strDomain,
                                strPassword,
                                LOGON32_LOGON_INTERACTIVE,
                                LOGON32_PROVIDER_DEFAULT,
                                &hUserToken
                            );

                        if( bResult && hToken != NULL ){
                            __try{
                                *hToken = hUserToken;
                            } __except (EXCEPTION_EXECUTE_HANDLER) {
                                pdhStatus = PDH_INVALID_ARGUMENT;
                            }
                        }
                    }
                }

                if( bResult == FALSE ){
                    pdhStatus = PlaiErrorToPdhStatus( GetLastError() );
                }
            }

            if( data.cbData > 0 ){
                ZeroMemory( data.pbData, data.cbData );
                LocalFree( data.pbData );
            }
        }
    }

cleanup:

    RELEASE_MUTEX(hPdhPlaMutex);
    
    G_FREE( szName );
    G_FREE( szComputer );
    G_FREE( strRunAs );
    G_FREE( strKey );

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaSetRunAs
    
    Set the security for to run as when the log is active

    Arguments:
        
        LPTSTR  strName 
                Log Name
        
        LPTSTR  strComputer
                Computer to connect to
        
        LPTSTR  strUser
                User to run as
        
        LPTSTR  strPassword
                Users password

    Return:
        PDH_INVALID_ARGUMENT
                The query does not exist

        ERROR_SUCCESS
        
\*****************************************************************************/

BOOL
PlaiIsNetworkService( BOOL bLogon )
{
    //
    // If bLogon is TRUE this function will try to Impersonate the
    // NetworkService if you is not already running that way.
    // RevertToSelf() should be called after you are done being the
    // NetworkService
    //

    DWORD   dwStatus = ERROR_SUCCESS;
    BOOL    bResult;
    HKEY    hkeyQuery = NULL;
    HANDLE  hProcess;
    PSID    NetworkService = NULL;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    HANDLE hToken = NULL;
    DWORD  dwSize;
    PTOKEN_OWNER pOwnerInfo = NULL;

    bResult = OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken );

    if( bResult ){

        bResult = GetTokenInformation( hToken, TokenOwner, NULL, 0, &dwSize );
        dwStatus = GetLastError();

        if( ERROR_INSUFFICIENT_BUFFER == dwStatus ){

            pOwnerInfo = (PTOKEN_OWNER)G_ALLOC(dwSize);
            if( NULL == pOwnerInfo ) {
                bResult = FALSE;
                goto cleanup;
            }

            bResult = GetTokenInformation( 
                                hToken, 
                                TokenOwner, 
                                pOwnerInfo, 
                                dwSize, 
                                &dwSize 
                            );

            if( bResult ) {
            
                bResult = AllocateAndInitializeSid(
                                    &NtAuthority,
                                    1,
                                    SECURITY_NETWORK_SERVICE_RID,
                                    0,0,0,0,0,0,0,
                                    &NetworkService
                                );
            }
        }else{
            bResult = FALSE;
            goto cleanup;
        }
    }
    
    if( bResult ){
        bResult = EqualSid( NetworkService, pOwnerInfo->Owner );
    }
    
    if( (!bResult) && bLogon ){
        HANDLE hNetwork = NULL;
 
        bResult= LogonUserW(
                L"NetworkService",
                L"NT AUTHORITY",
                L"",
                LOGON32_LOGON_SERVICE,
                LOGON32_PROVIDER_WINNT50,
                &hNetwork
            );

        if( bResult ){
            bResult = ImpersonateLoggedOnUser( hNetwork );
        }

        if( INVALID_HANDLE_VALUE != hNetwork ){
            CloseHandle( hNetwork );
        }
    }

cleanup:
    G_FREE( pOwnerInfo );

    if( INVALID_HANDLE_VALUE != hToken ){
        CloseHandle( hToken );
    }

    if( NULL != NetworkService){
        FreeSid(NetworkService);
    }

    return bResult;
}

PDH_FUNCTION
PlaiSetRunAs(
    HKEY hkeyQuery,
    LPWSTR strUser,
    LPWSTR strPassword
)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    BOOL    bResult = FALSE;
    WCHAR buffer[PLA_ACCOUNT_BUFFER];

    if( LoadStringW( (HINSTANCE)ThisDLLHandle, IDS_DEFAULT_ACCOUNT, buffer, PLA_ACCOUNT_BUFFER ) ){
        bResult = ( wcscmp( buffer, strUser ) == 0 );
    }

    if( strPassword == NULL || bResult ){

        pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szKey, REG_SZ, NULL, 0 );
        if( bResult ){
            pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szRunAs, REG_SZ, NULL, 0 );
        }

    }else{

        DATA_BLOB data;
        DATA_BLOB crypt;
        HANDLE hToken = NULL;

        bResult = PlaiIsNetworkService(TRUE);

        if( bResult != TRUE ){
            pdhStatus = PlaiErrorToPdhStatus( GetLastError() );
        }
        
        if( ERROR_SUCCESS == pdhStatus ){
            
            data.cbData = BYTE_SIZE( strPassword ) + (DWORD)sizeof(UNICODE_NULL);

            data.pbData = (BYTE*)strPassword;

            bResult = CryptProtectData(
                    &data,
                    NULL, NULL, NULL, 0,
                    CRYPTPROTECT_UI_FORBIDDEN,
                    &crypt
                );

            if( bResult == TRUE ){

                DWORD dwStatus = RegSetValueEx( hkeyQuery, szKey, 0, REG_BINARY, crypt.pbData, crypt.cbData );

                pdhStatus = PlaiErrorToPdhStatus( dwStatus );
            
                if( crypt.pbData ){
                    LocalFree(crypt.pbData);
                }

            }else{
                pdhStatus = PlaiErrorToPdhStatus( GetLastError() );
            }

            RevertToSelf();
        }
    }

    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = PlaiWriteRegistryStringValue( hkeyQuery, szRunAs, REG_SZ, strUser, 0 );
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiPlaSetRunAs(
    LPWSTR strName,
    LPWSTR strComputer,
    LPWSTR strUser,
    LPWSTR strPassword
)
{
    //
    // Only make this call if you are sure you have no better chance
    // of being logged on as the NetworkService account.  If you are
    // not the NetworkService and can not log on as the NetworkService
    // this call will fail.
    //

    PDH_STATUS pdhStatus;
    HKEY    hkeyQuery = NULL;

    VALIDATE_QUERY( strName );

    LPWSTR szName = PlaiStringDuplicate( strName );
    LPWSTR szComputer = PlaiStringDuplicate( strComputer );
    CHECK_NAMES( szName, szComputer, strComputer );

    LPWSTR szUser = PlaiStringDuplicate( strUser );
    LPWSTR szPassword = PlaiStringDuplicate( strPassword );

    pdhStatus = PlaiConnectAndLockQuery( szComputer, szName, hkeyQuery );

    if( ERROR_SUCCESS == pdhStatus ){
        pdhStatus = PlaiSetRunAs( hkeyQuery, szUser, szPassword );
        RELEASE_MUTEX(hPdhPlaMutex);
    }        

    if ( NULL != hkeyQuery ) {
        RegCloseKey ( hkeyQuery );
    }

    if( NULL != szPassword ){
        ZeroMemory( szPassword, wcslen(szPassword)*sizeof(WCHAR) );
    }

    G_FREE( szUser );
    G_FREE( szPassword );

cleanup:
    G_FREE( szName );
    G_FREE( szComputer );
    
    return pdhStatus;
}

PDH_FUNCTION
PdhPlaSetRunAsA(
    LPSTR /*strName*/,
    LPSTR /*strComputer*/,
    LPSTR /*strUser*/,
    LPSTR /*strPassword*/
)
{
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION
PdhPlaSetRunAsW(
    LPWSTR strName,
    LPWSTR strComputer,
    LPWSTR strUser,
    LPWSTR strPassword
)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    BOOL    bResult;

    VALIDATE_QUERY( strName );

    LPWSTR szName = PlaiStringDuplicate( strName );
    LPWSTR szComputer = PlaiStringDuplicate( strComputer );
    CHECK_NAMES( szName, szComputer, strComputer );

    bResult = PlaiIsNetworkService(TRUE);

    if( bResult ){
        bResult = PlaiIsLocalComputer( szComputer );
    }

    if( bResult ){

        pdhStatus = PdhiPlaSetRunAs( szName, szComputer, strUser, strPassword );

        RevertToSelf();

    }else{
        pdhStatus = PdhPlaWbemSetRunAs( szName, szComputer, strUser, strPassword );
    }

cleanup:
    G_FREE( szName );
    G_FREE( szComputer );

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaEnumCollections
    
    Set the security for to run as when the log is active

    Arguments:
              
        LPTSTR  strComputer
                Computer to connect to
        
        LPDWORD pcchBufferSize
                [IN] Size of buffer in TCHAR's pointed to by mszCollections.  
                [OUT] Size required or number of characters written.
        
        LPTSTR  mszCollections
                Multistring of the existing collections.

    Return:
         ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PdhPlaEnumCollectionsA( 
        LPSTR   /*strComputer*/,
        LPDWORD /*pcchBufferSize*/,
        LPSTR   /*mszCollections*/
    )
{
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION
PdhPlaEnumCollectionsW( 
        LPWSTR strComputer,
        LPDWORD pcchBufferSize, /* Character Count */
        LPWSTR mszCollections
    )
{
    DWORD dwStatus;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HKEY  hkeyQueries = NULL;
    DWORD cchTotalLength = 0;
    DWORD cchBufferLeft = 0;
    DWORD nCollections = 0;
    DWORD nMaxSubKeyLength = 0;
    DWORD dwSize;
    LPWSTR strCollection;
    LPWSTR str;

    __try{
        if( mszCollections != NULL && pcchBufferSize > 0 ){
            ZeroMemory( mszCollections, *pcchBufferSize * sizeof(WCHAR) );
            str = mszCollections;
            cchBufferLeft = *pcchBufferSize;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    CHECK_STATUS( pdhStatus );

    LPWSTR szComputer = PlaiStringDuplicate( strComputer );
    if( NULL == szComputer && NULL != strComputer ){
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        goto cleanup;
    }

    dwStatus = WAIT_FOR_AND_LOCK_MUTEX( hPdhPlaMutex );
    if( dwStatus != ERROR_SUCCESS && dwStatus != WAIT_ABANDONED ){
        return PlaiErrorToPdhStatus( dwStatus );
    }

    pdhStatus = PlaiConnectToRegistry( szComputer, hkeyQueries, TRUE, FALSE );
    CHECK_STATUS( pdhStatus );

    dwStatus = RegQueryInfoKey(
                hkeyQueries,
                NULL,
                NULL,
                NULL,
                &nCollections,
                &nMaxSubKeyLength,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL 
            );
    CHECK_STATUS( dwStatus );

    dwSize = (sizeof(WCHAR)*(nMaxSubKeyLength+1));

    strCollection = (LPWSTR)G_ALLOC( dwSize );

    if( strCollection ){

        for( ULONG i = 0; i<nCollections && ERROR_SUCCESS == dwStatus; i++ ){
            LPWSTR strQueryName = NULL;
            DWORD dwQueryName = 0;

            dwStatus = RegEnumKey( hkeyQueries, i, strCollection, dwSize );
            
            if( ERROR_SUCCESS == dwStatus ){

                HKEY hkeyQuery = NULL;

                dwStatus = RegOpenKeyExW (
                            hkeyQueries,
                            strCollection,
                            0,
                            KEY_READ,
                            &hkeyQuery                            
                        );

                if( ERROR_SUCCESS == dwStatus ){
                    
                    DWORD cchNameSize = 0;
                    LPWSTR szName = NULL;

                    pdhStatus = PlaiReadRegistryStringValue( 
                                hkeyQuery, 
                                szCollection, 
                                READ_REG_MUI, 
                                &strQueryName, 
                                &dwQueryName 
                            );

                    __try{
                        if( pdhStatus == ERROR_SUCCESS && 
                            strQueryName != NULL && 
                            dwQueryName > sizeof(WCHAR) ){

                            cchNameSize = wcslen( strQueryName ) + 1;
                            szName = strQueryName;

                        }else{
                            pdhStatus = ERROR_SUCCESS;
                            
                            cchNameSize = wcslen( strCollection ) + 1;
                            szName = strCollection;
                        }

                        cchTotalLength += cchNameSize;

                        if( NULL != mszCollections && cchTotalLength < *pcchBufferSize ){
                            StringCchCopy( str, cchBufferLeft, szName );
                            cchBufferLeft -= cchNameSize;
                            str += ( wcslen(str) + 1 );
                        }

                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }

                    G_FREE( strQueryName );
                }

                if( NULL != hkeyQuery ){
                    RegCloseKey( hkeyQuery );
                }
            }
        }
        
        G_FREE( strCollection );
        __try{
            if( ERROR_SUCCESS == dwStatus ){
                if( (cchTotalLength + 1) > *pcchBufferSize ){
                    pdhStatus = PDH_INSUFFICIENT_BUFFER;
                }
                *pcchBufferSize = cchTotalLength + 1;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }

    }else{
        dwStatus = ERROR_OUTOFMEMORY;
    }

cleanup:
    RELEASE_MUTEX( hPdhPlaMutex );

    if ( NULL != hkeyQueries ) {
        RegCloseKey ( hkeyQueries );
    }
    
    G_FREE( szComputer );

    if( ERROR_SUCCESS == pdhStatus ){
        return PlaiErrorToPdhStatus( dwStatus );
    }else{
        return pdhStatus;
    }
}

/*****************************************************************************\

    PlaTimeInfoToMilliSeconds
    
    Converts the PLA_TIME_INFO structure to ms in a LONGLONG

    Arguments:
        
        PLA_TIME_INFO* pTimeInfo

        LONGLONG* pllmsecs
              

    Return:
        PDH_INVALID_ARGUMENT
            The pTimeInfo->wDataType is not PLA_TT_DTYPE_UNITS

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PlaTimeInfoToMilliSeconds (
    PLA_TIME_INFO* pTimeInfo,
    LONGLONG* pllmsecs)
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    
    __try{
        if( PLA_TT_DTYPE_UNITS != pTimeInfo->wDataType ){
            pdhStatus = PDH_INVALID_ARGUMENT;
        }else{
            switch (pTimeInfo->dwUnitType) {
                case PLA_TT_UTYPE_SECONDS:
                    *pllmsecs = pTimeInfo->dwValue;
                    break;
                case PLA_TT_UTYPE_MINUTES:
                    *pllmsecs = pTimeInfo->dwValue * PLA_SECONDS_IN_MINUTE;
                    break;

                case PLA_TT_UTYPE_HOURS:
                    *pllmsecs = pTimeInfo->dwValue * PLA_SECONDS_IN_HOUR;
                    break;

                case PLA_TT_UTYPE_DAYS:
                    *pllmsecs = pTimeInfo->dwValue * PLA_SECONDS_IN_DAY;
                    break;

                default:
                    *pllmsecs = 0;
            }

            *pllmsecs *= 1000;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    return pdhStatus;
}

/*****************************************************************************\

    PdhiPlaFormatBlanks
    
    Replaces blanks with the character specified by:
    
    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\SysmonLog\Replace Blanks
    
    Arguments:
        

    Return:
        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PdhiPlaFormatBlanksA( LPSTR strComputer, LPSTR strFormat )
{
    return PDH_NOT_IMPLEMENTED;
}

PDH_FUNCTION
PdhiPlaFormatBlanksW( LPWSTR strComputer, LPWSTR strFormat )
{
    HKEY hkey = NULL;
    LPWSTR strScan = strFormat;
    PDH_STATUS pdhStatus;
    LPWSTR strBlank = NULL;
    DWORD dwSize = 0;

    if( PlaiIsStringEmpty( strFormat ) ){
        return ERROR_SUCCESS;
    }
        
    pdhStatus = PlaiConnectToRegistry( strComputer, hkey, FALSE );
    CHECK_STATUS( pdhStatus );

    pdhStatus = PlaiReadRegistryStringValue( 
                    hkey, 
                    L"Replace Blanks", 
                    READ_REG_MUI, 
                    &strBlank, 
                    &dwSize 
                );

    if( ERROR_SUCCESS != pdhStatus || PlaiIsStringEmpty( strBlank ) ){
        pdhStatus = ERROR_SUCCESS;
        goto cleanup;
    }

    __try {
        while( *strScan != L'\0' ){
            if( *strScan == L' ' ){
                *strScan = *strBlank;
            }
            strScan++;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

cleanup:

    G_FREE( strBlank );
    
    if( hkey != NULL ){
        RegCloseKey ( hkey );
    }

    return pdhStatus;
}

/*****************************************************************************\

    PdhPlaGetLogFileName
    

    Arguments:
        

    Return:
        PDH_PLA_ERROR_FILEPATH
            Not all needed fields we set in the passed info block
        
        ERROR_INVALID_NAME
            The final path contains invalid characters

        ERROR_SUCCESS
        
\*****************************************************************************/

PDH_FUNCTION
PlaiScanForInvalidChar( LPWSTR strScan )
{
    LPWSTR strCheck = strScan;

    if( PlaiIsStringEmpty( strScan ) ){
        return PDH_INVALID_ARGUMENT;
    }

    if( PlaiIsCharWhitespace( *strCheck ) ){
        return PDH_PLA_ERROR_FILEPATH;
    }

    if( PlaiIsCharWhitespace( strCheck[wcslen(strCheck)-1] ) ){
        return PDH_PLA_ERROR_FILEPATH;
    }

    while( *strCheck != L'\0' ){
        switch( *strCheck ){
        case L'?':
        case L'*':
        case L'|':
        case L'<':
        case L'>':
        case L'/':
        case L'\"':
            return PDH_PLA_ERROR_FILEPATH;
        case L'\\':
            if( strCheck > strScan ){
                if( PlaiIsCharWhitespace( *((WCHAR*)strCheck-1)) ){
                    return PDH_PLA_ERROR_FILEPATH;
                }
            }
        }
        strCheck++;
    }
    
    return ERROR_SUCCESS;
}

long PlaiJulianDate( SYSTEMTIME st )
{
    long day = 0;
    BOOL bLeap = FALSE;
    
    static int cDaysInMonth[] = 
        { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

    for( int i = 0; i < st.wMonth - 1 && i<12; i++ ){
        day += cDaysInMonth[i];
    }

    day += st.wDay;

    if( st.wYear % 400 == 0){
        bLeap = TRUE;
    }else if( st.wYear % 100 == 0){
        bLeap = FALSE;
    }else if( st.wYear % 4 ){
        bLeap = TRUE;
    }

    if( st.wMonth > 2 && bLeap ){
        day++;
    }

    return day;
}

PDH_FUNCTION
PlaiGetLogFileName(
    DWORD dwFlags,
    PPDH_PLA_INFO_W pInfo,
    LPDWORD pcchBufferSize,
    LPWSTR strFileName
    )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    DWORD cchExpanded = 0;
    WCHAR buffer[128];
    LPWSTR strExpand;
    DWORD cchSize;
    DWORD dwSwitch;

    SYSTEMTIME  st;
    GetLocalTime (&st);
    
    LPWSTR strWhack = L"\\";
    LPWSTR strUnder = L"_";
    DWORD cchTotalSize = 0;
    LPWSTR strLocalFileName = NULL;
    LPWSTR strBaseFileName = NULL;
    LPWSTR strDefaultDir = NULL;
    LPWSTR strSQL = L"";
    TCHAR strBuffer[MAX_PATH];
    
    if( pInfo->dwMask & PLA_INFO_FLAG_FILENAME ){
        strBaseFileName = pInfo->strBaseFileName;
    }
    if( pInfo->dwMask & PLA_INFO_FLAG_DEFAULTDIR ){
        strDefaultDir = pInfo->strDefaultDir;
    }

    if( (pInfo->dwMask & PLA_INFO_FLAG_FORMAT) && 
        pInfo->dwFileFormat == PLA_SQL_LOG ){
        
        if( (pInfo->dwMask & PLA_INFO_FLAG_SQLNAME) && 
            ! PlaiIsStringEmpty( pInfo->strSqlName ) ){

            strDefaultDir = pInfo->strSqlName;
        }else{
            strDefaultDir = strBaseFileName;
        }

        strBaseFileName = L"";

        if( ! PlaiIsStringEmpty( strDefaultDir ) ){
            
            BOOL bBang = FALSE;
            BOOL bLogSet = FALSE;

            LPWSTR strLogSet = wcsstr( strDefaultDir, L"!" );
            
            if( ! PlaiIsStringEmpty( strLogSet ) ){
                bBang = TRUE;
                if( wcslen( strLogSet ) > 1 ){
                    bLogSet = TRUE;
                }
            }
            
            if( pInf