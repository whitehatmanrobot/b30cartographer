,
        cchMemAlloc);
    *pstrBinaryPath = paszCommandT;

    if (pfAbend != NULL)
        {
        INT cStringSubstitutions;    // Number of string substitutions
    
        // Find out if the string contains "/fail=%1%"
        cStringSubstitutions = Str_SubstituteStrStr(
            OUT pszCommandArguments,
            IN pszCommandArguments,
            IN szAbend,
            L"");
        Report((cStringSubstitutions == 0 || cStringSubstitutions == 1) &&
            "INFO: Multiple substitutions will be consolidated.");
        *pfAbend = cStringSubstitutions != 0;
        }
    *pstrParameters = pszCommandArguments;
    TrimString(*pstrParameters);

    delete paszCommandT;
    } // Service_SplitCommandLine()


/////////////////////////////////////////////////////////////////////
//    Service_UnSplitCommandLine()
//
//    Just do the opposite of Service_SplitCommandLine().
//    Combine the executable path and its arguments into a single string.
//
void
Service_UnSplitCommandLine(
    CString * pstrFullCommand,    // OUT: Full command line
    LPCTSTR pszBinaryPath,        // IN: Path of the executable binary
    LPCTSTR pszParameters)        // IN: Parameters for the executable
    {
    Assert(pstrFullCommand != NULL);
    Assert(pszBinaryPath != NULL);
    Assert(pszParameters != NULL);

    TCHAR * psz;
    psz = pstrFullCommand->GetBuffer(lstrlen(pszBinaryPath) + lstrlen(pszParameters) + 32);
    // Build a string with the binary path surrounded by quotes
    wsprintf(OUT psz, L"\"%s\" %s", pszBinaryPath, pszParameters);
    pstrFullCommand->ReleaseBuffer();
    } // Service_UnSplitCommandLine()

    
/////////////////////////////////////////////////////////////////////
//    LoadSystemString()
//
//    Load a string from system's resources.  This function will check if
//    the string Id can be located in netmsg.dll before attempting to
//    load the string from the 'system resource'.
//    If string cannot be loaded, *ppaszBuffer is set to NULL.
//
//    RETURN
//    Pointer to allocated string and number of characters put
//    into *ppaszBuffer.
//
//    INTERFACE NOTES
//    Caller must call LocalFree(*ppaszBuffer) when done with the string.
//
//    HISTORY
//    96.10.21    t-danmo        Copied from net\ui\common\src\string\string\strload.cxx.
//
DWORD
LoadSystemString(
    UINT wIdString,            // IN: String Id.  Typically error code from GetLastError().
    LPTSTR * ppaszBuffer)    // OUT: Address of pointer to allocated string.
    {
    Assert(ppaszBuffer != NULL);

    UINT cch;
    HMODULE hModule = NULL;
    DWORD dwFlags =  FORMAT_MESSAGE_ALLOCATE_BUFFER |
                     FORMAT_MESSAGE_IGNORE_INSERTS  |
                     FORMAT_MESSAGE_MAX_WIDTH_MASK;

    if ((wIdString >= MIN_LANMAN_MESSAGE_ID) && (wIdString <= MAX_LANMAN_MESSAGE_ID))
        {
        // Network Errors
        dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
        hModule = ::LoadLibrary(_T("netmsg.dll"));
        if (hModule == NULL)
            {
            TRACE1("LoadLibrary(\"netmsg.dll\") failed.  err=%u.\n", GetLastError());
            Report("Unable to get module handle for netmsg.dll");
            }
        }
    else
        {
        // Other system errors
        dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
        }

    *ppaszBuffer = NULL;        // Just in case
    cch = ::FormatMessage(
        dwFlags,
        hModule,
        wIdString,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        OUT (LPTSTR)ppaszBuffer,    // Buffer will be allocated by FormatMessage()
        0,
        NULL);
    Report((cch > 0) && "FormatMessage() returned an empty string");
    if (hModule != NULL)
        {
        VERIFY(FreeLibrary(hModule));
        }
    return cch;
    } // LoadSystemString()


/////////////////////////////////////////////////////////////////////
//    GetMsgHelper()
//
//    This function will retrieve the error msg if dwErr is specified,
//    load resource string if specified, and format the string with
//    the error msg and other optional arguments.
//
//
HRESULT
GetMsgHelper(
    OUT CString& strMsg,// OUT: the message
    DWORD dwErr,        // IN: Error code from GetLastError()
    UINT wIdString,     // IN: String ID
    va_list* parglist   // IN: OPTIONAL arguments
    )
{
    if (!dwErr && !wIdString) 
        return E_INVALIDARG;

    TCHAR *pszMsgResourceString = NULL;
    TCHAR *pszT = L"";

    //
    // retrieve error msg
    //
    CString strErrorMessage;
    if (dwErr != 0)
    {
        GetErrorMessage(dwErr, strErrorMessage);
        pszT = (LPTSTR)(LPCTSTR)strErrorMessage;
    }

    //
    // load string resource, and format it with the error msg and 
    // other optional arguments
    //
    if (wIdString == 0)
    {
        strMsg = pszT;
    } else
    {
        pszMsgResourceString = PaszLoadStringPrintf(wIdString, *parglist);
        if (dwErr == 0)
            strMsg = pszMsgResourceString;
        else if ((HRESULT)dwErr < 0)
            LoadStringPrintf(IDS_sus_ERROR_HR, OUT &strMsg, pszMsgResourceString, dwErr, pszT);
        else
            LoadStringPrintf(IDS_sus_ERROR, OUT &strMsg, pszMsgResourceString, dwErr, pszT);
    }

    if (pszMsgResourceString)
        LocalFree(pszMsgResourceString);

    return S_OK;
} // GetMsgHelper()

/////////////////////////////////////////////////////////////////////
//    GetMsg()
//
//    This function will call GetMsgHelp to retrieve the error msg
//    if dwErr is specified, load resource string if specified, and
//    format the string with the error msg and other optional arguments.
//
//
void
GetMsg(
    OUT CString& strMsg,// OUT: the message
    DWORD dwErr,        // IN: Error code from GetLastError()
    UINT wIdString,     // IN: String resource Id
    ...)                // IN: Optional arguments
{
    va_list arglist;
    va_start(arglist, wIdString);

    HRESULT hr = GetMsgHelper(strMsg, dwErr, wIdString, &arglist);
    if (FAILED(hr))
        strMsg.Format(_T("0x%x"), hr);

    va_end(arglist);

} // GetMsg()

/////////////////////////////////////////////////////////////////////
//    DoErrMsgBox()
//
//    Display a message box for the error code.  This function will
//    load the error message from the system resource and append
//    the optional string (if any)
//
//    EXAMPLE
//        DoErrMsgBox(GetActiveWindow(), MB_OK, GetLastError(), IDS_s_FILE_READ_ERROR, L"foo.txt");
//
INT
DoErrMsgBoxHelper(
    HWND hwndParent,    // IN: Parent of the dialog box
    UINT uType,         // IN: style of message box
    DWORD dwErr,        // IN: Error code from GetLastError()
    UINT wIdString,     // IN: String resource Id
	bool fServicesSnapin, // IN: Is this filemgmt or svcmgmt?
    va_list& arglist)   // IN: Optional arguments
{
    //
    // get string and the error msg
    //
    CString strMsg;
    HRESULT hr = GetMsgHelper(strMsg, dwErr, wIdString, &arglist);
    if (FAILED(hr))
        strMsg.Format(_T("0x%x"), hr);

    //
    // Load the caption
    //
    CString strCaption;
    strCaption.LoadString(
        (fServicesSnapin) ? IDS_CAPTION_SERVICES : IDS_CAPTION_FILEMGMT);

    //
    // Display the message.
    //
    CThemeContextActivator activator;;
    return MessageBox(hwndParent, strMsg, strCaption, uType);

} // DoErrMsgBox()

INT
DoErrMsgBox(
    HWND hwndParent,    // IN: Parent of the dialog box
    UINT uType,         // IN: style of message box
    DWORD dwErr,        // IN: Error code from GetLastError()
    UINT wIdString,     // IN: String resource Id
    ...)                // IN: Optional arguments
{
    //
    // get string and the error msg
    //
    va_list arglist;
    va_start(arglist, wIdString);

    INT retval = DoErrMsgBoxHelper(
        hwndParent, uType, dwErr, wIdString, false, arglist );

    va_end(arglist);

    return retval;

} // DoErrMsgBox()

//
// JonN 3/5/01 4635
// Services Snapin - String length error dialog title shouldn't be "File Service Management"
//
INT
DoServicesErrMsgBox(
    HWND hwndParent,    // IN: Parent of the dialog box
    UINT uType,         // IN: style of message box
    DWORD dwErr,        // IN: Error code from GetLastError()
    UINT wIdString,     // IN: String resource Id
    ...)                // IN: Optional arguments
{
    //
    // get string and the error msg
    //
    va_list arglist;
    va_start(arglist, wIdString);

    INT retval = DoErrMsgBoxHelper(
        hwndParent, uType, dwErr, wIdString, true, arglist );

    va_end(arglist);

    return retval;

}

//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForUsers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick one user.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Sample code InitObjectPickerForGroups
//              10-14-1998   JonN       Changed to InitObjectPickerForUsers
//              11-11-2000   JonN       188203 support LocalService/NetworkService
//
//---------------------------------------------------------------------------

// CODEWORK do I want to allow USER_ENTERED?
HRESULT
InitObjectPickerForUsers(
    IDsObjectPicker *pDsObjectPicker,
    LPCTSTR pszServerName)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 5;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Target computer scope.  This adds a "Look In" entry for the
    // target computer.  Computer scopes are always treated as
    // downlevel (i.e., they use the WinNT provider).
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
    aScopeInit[0].flScope =   DSOP_SCOPE_FLAG_STARTING_SCOPE
                            | DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    // JonN 11/14/00 188203 support LocalService/NetworkService
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS
                                          | DSOP_DOWNLEVEL_FILTER_LOCAL_SERVICE
                                          | DSOP_DOWNLEVEL_FILTER_NETWORK_SERVICE;

    //
    // The domain to which the target computer is joined.  Note we're
    // combining two scope types into flType here for convenience.
    //

    aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[1].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                         | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    aScopeInit[1].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    aScopeInit[1].FilterFlags.Uplevel.flNativeModeOnly =
      DSOP_FILTER_USERS;
    aScopeInit[1].FilterFlags.Uplevel.flMixedModeOnly =
      DSOP_FILTER_USERS;
    aScopeInit[1].FilterFlags.flDownlevel =
      DSOP_DOWNLEVEL_FILTER_USERS;

    //
    // The domains in the same forest (enterprise) as the domain to which
    // the target machine is joined.  Note these can only be DS-aware
    //

    aScopeInit[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[2].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    aScopeInit[2].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    aScopeInit[2].FilterFlags.Uplevel.flNativeModeOnly =
      DSOP_FILTER_USERS;
    aScopeInit[2].FilterFlags.Uplevel.flMixedModeOnly =
      DSOP_FILTER_USERS;

    //
    // Domains external to the enterprise but trusted directly by the
    // domain to which the target machine is joined.
    //
    // If the target machine is joined to an NT4 domain, only the
    // external downlevel domain scope applies, and it will cause
    // all domains trusted by the joined domain to appear.
    //

    aScopeInit[3].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[3].flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                         | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;
    aScopeInit[3].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;

    aScopeInit[3].FilterFlags.Uplevel.flNativeModeOnly =
      DSOP_FILTER_USERS;

    aScopeInit[3].FilterFlags.Uplevel.flMixedModeOnly =
      DSOP_FILTER_USERS;

    aScopeInit[3].FilterFlags.flDownlevel =
      DSOP_DOWNLEVEL_FILTER_USERS;

    //
    // The Global Catalog
    //

    aScopeInit[4].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[4].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    aScopeInit[4].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;

    // Only native mode applies to gc scope.

    aScopeInit[4].FilterFlags.Uplevel.flNativeModeOnly =
      DSOP_FILTER_USERS;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);

    //
    // The pwzTargetComputer member allows the object picker to be
    // retargetted to a different computer.  It will behave as if it
    // were being run ON THAT COMPUTER.
    //

    InitInfo.pwzTargetComputer = pszServerName;  // NULL == local machine
//    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;

    // JonN 11/14/00 188203 support LocalService/NetworkService
    static PCWSTR g_pszObjectSid = L"objectSid";
    InitInfo.cAttributesToFetch = 1;
    InitInfo.apwzAttributeNames = &g_pszObjectSid;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    HRESULT hr = pDsObjectPicker->Initialize(&InitInfo);
    ASSERT( SUCCEEDED(hr) );

    return hr;
} // InitObjectPickerForUsers

//+--------------------------------------------------------------------------
//
//  Function:   ExtractADsPathAndUPN
//
//  Synopsis:   Retrieve the selected username from the data object
//              created by the object picker.
//
//  Arguments:  [pdo] - data object returned by object picker
//
//  History:    10-14-1998   DavidMun   Sample code ProcessSelectedObjects
//              10-14-1998   JonN       Changed to ExtractADsPath
//              01-25-1999   JonN       Added pflScopeType parameter
//              03-16-1999   JonN       Changed to ExtractADsPathAndUPN
//              11-14-2000   JonN       Added svarrefObjectSid for 188203
//
//---------------------------------------------------------------------------

UINT g_cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

HRESULT
ExtractADsPathAndUPN(
    IN IDataObject *pdo,
    OUT CString& strrefADsPath,
    OUT CString& strrefUPN,
    OUT CComVariant& svarrefObjectSid,
    OUT ULONG *pflScopeType)
{
    if (NULL == pdo)
        return E_POINTER;

    HRESULT hr = S_OK;

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    FORMATETC formatetc =
    {
        (CLIPFORMAT)g_cfDsObjectPicker,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    bool fGotStgMedium = false;

    do
    {
        hr = pdo->GetData(&formatetc, &stgmedium);
        if (FAILED(hr))
        {
          ASSERT(FALSE);
          break;
        }

        fGotStgMedium = true;

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        if (   NULL == pDsSelList
            || 1 != pDsSelList->cItems
           )
        {
          ASSERT(FALSE);
          hr = E_FAIL;
          break;
        }

        DS_SELECTION& sel = pDsSelList->aDsSelection[0];
        strrefADsPath = sel.pwzADsPath;
        strrefUPN     = sel.pwzUPN;
        if ( sel.pvarFetchedAttributes )
            svarrefObjectSid = sel.pvarFetchedAttributes[0];

        if (NULL != pflScopeType)
          *pflScopeType = pDsSelList->aDsSelection[0].flScopeType;

        GlobalUnlock(stgmedium.hGlobal);
    } while (0);

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////
//    UiGetUser()
//
//    Invoke a user picker dialog.
//
//    Return TRUE iff an account was selected.
//    
//    HISTORY
//    96.10.12    t-danmo        Creation. Inspired from function GetUser() located
//                            at \nt\private\windows\shell\security\aclui\misc.cpp.
//    96.10.30    t-danmo        Added/modified comments.
//    98.03.17    jonn        Modified to use User/Group Picker
//    98.10.20    jonn        Modified to use updated Object Picker interfaces
//

//+--------------------------------------------------------------------------
//
//  Function:   ExtractDomainUserString
//
//  Synopsis:   Converts an ADspath to the format needed by Service Controller
//
//  History:    10-14-1998   JonN       Created
//              01-25-1999   JonN       added flScopeType parameter
//
//---------------------------------------------------------------------------

HRESULT
ExtractDomainUserString(
    IN LPCTSTR pwzADsPath,
    IN ULONG flScopeType,
    IN OUT CString& strrefDomainUser)
{
    HRESULT hr = S_OK;

    CComPtr<IADsPathname> spIADsPathname;
    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (PVOID *)&spIADsPathname);
    RETURN_HR_IF_FAIL;

    hr = spIADsPathname->Set( const_cast<LPTSTR>(pwzADsPath), ADS_SETTYPE_FULL );
    RETURN_HR_IF_FAIL;

    CComBSTR sbstrUser;
    hr = spIADsPathname->GetElement( 0, &sbstrUser );
    RETURN_HR_IF_FAIL;

    CComBSTR sbstrDomain = OLESTR(".");
    if (DSOP_SCOPE_TYPE_TARGET_COMPUTER != flScopeType)
    {
        long lnNumPathElements = 0;
        hr = spIADsPathname->GetNumElements( &lnNumPathElements );
        RETURN_FALSE_IF_FAIL;

        switch (lnNumPathElements)
        {
        case 1:
            hr = spIADsPathname->Retrieve( ADS_FORMAT_SERVER, &sbstrDomain );
            RETURN_HR_IF_FAIL;
            break;
        case 2:
            hr = spIADsPathname->GetElement( 1, &sbstrDomain );
            RETURN_HR_IF_FAIL;
            break;
        default:
            ASSERT(FALSE);
            return E_FAIL;
        }
    }

    strrefDomainUser.Format(L"%s\\%s", sbstrDomain, sbstrUser);

    return hr;
} // ExtractDomainUserString


BOOL
UiGetUser(
    HWND hwndOwner,            // IN: Owner window
    BOOL /*fIsContainer*/,        // IN: TRUE if invoked for a container
    LPCTSTR pszServerName,    // IN: Initial target machine name
    OUT CString& strrefUser) // IN: Allocated buffer containing the user details
{
  HRESULT hr = S_OK;

  CComPtr<IDsObjectPicker> spDsObjectPicker;
  hr = CoCreateInstance(CLSID_DsObjectPicker, NULL, CLSCTX_INPROC_SERVER,
                        IID_IDsObjectPicker, (PVOID *)&spDsObjectPicker);
  RETURN_FALSE_IF_FAIL;
  ASSERT( !!spDsObjectPicker );

  hr = InitObjectPickerForUsers(spDsObjectPicker, pszServerName);
  RETURN_FALSE_IF_FAIL;

  CComPtr<IDataObject> spDataObject;
  hr = spDsObjectPicker->InvokeDialog(hwndOwner, &spDataObject);
  RETURN_FALSE_IF_FAIL;
  if (S_FALSE == hr)
    return FALSE; // user cancelled
  ASSERT( !!spDataObject );

  CString strADsPath;
  ULONG flScopeType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
  CComVariant svarObjectSid;
  hr = ExtractADsPathAndUPN( spDataObject,
                             strADsPath,
                             strrefUser,
                             svarObjectSid,
                             &flScopeType );
  RETURN_FALSE_IF_FAIL;

  // JonN 11/15/00 188203 check for LocalService/NetworkService
  if (svarObjectSid.vt == (VT_ARRAY|VT_UI1))
  {
    PSID pSid = svarObjectSid.parray->pvData;
    if ( IsWellKnownSid(pSid, WinLocalServiceSid) )
    {
      strrefUser = TEXT("NT AUTHORITY\\LocalService");
      return TRUE;
    }
    else if ( IsWellKnownSid(pSid, WinNetworkServiceSid) )
    {
      strrefUser = TEXT("NT AUTHORITY\\NetworkService");
      return TRUE;
    }
  }

  if (strrefUser.IsEmpty())
  {
    if (strADsPath.IsEmpty())
    {
      ASSERT(FALSE);
      return FALSE;
    }
    hr = ExtractDomainUserString( strADsPath, flScopeType, strrefUser );
    RETURN_FALSE_IF_FAIL;
  }

  return TRUE;
} // UiGetUser()


/////////////////////////////////////////////////////////////////////
//    DoHelp()
//
//    This routine handles context help for the WM_HELP message.
//
//    The return value is always TRUE.
//
BOOL DoHelp(
    LPARAM lParam,                // Pointer to HELPINFO structure
    const DWORD rgzHelpIDs[])    // Array of HelpIDs
    {
    Assert(rgzHelpIDs != NULL);
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;

    if (pHelpInfo != NULL)
       {
        if (pHelpInfo->iContextType == HELPINFO_WINDOW)
            {
            const HWND hwnd = (HWND)pHelpInfo->hItemHandle;
            Assert(IsWindow(hwnd));
            // Display context help for a control
            WinHelp(
                hwnd,
                g_szHelpFileFilemgmt,
                HELP_WM_HELP,
                (DWORD_PTR)rgzHelpIDs);
            }
        }
    return TRUE;
    } // DoHelp()

/////////////////////////////////////////////////////////////////////
//    DoContextHelp()
//    
//    This routine handles context help for the WM_CONTEXTMENU message.
//
//    The return value is always TRUE.
//
BOOL DoContextHelp(
    WPARAM wParam,                // Window requesting help
    const DWORD rgzHelpIDs[])    // Array of HelpIDs
    {
    const HWND hwnd = (HWND)wParam;
    Assert(IsWindow(hwnd));
    Assert(rgzHelpIDs != NULL);
    WinHelp(hwnd, g_szHelpFileFilemgmt, HELP_CONTEXTMENU, (DWORD_PTR)rgzHelpIDs);
    return TRUE;
    } // DoContextHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\filemgmt\toolbar.cpp ===
// toolbar.cpp : Implementation of toolbars for snapin

#include "stdafx.h"
#include "cookie.h"
#include "cmponent.h"
#include "compdata.h"

#include <compuuid.h> // UUIDs for Computer Management

#include "macros.h"
USE_HANDLE_MACROS("FILEMGMT(toolbar.cpp)")

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

// We keep the strings in globals because multiple IComponents will all
// have their own IToolbars.  We do not keep the bitmaps in globals because
// of difficulties with the global destruction mechanism, see compdata.h.

// The MMCBUTTON structures contain resource IDs for the strings which will
// be loaded into the CString array when the first instance of the toolbar
// is loaded.
//
// CODEWORK We need a mechanism to free these strings.

MMCBUTTON g_FileMgmtSnapinButtons[] =
{
 { 0, IDS_BUTTON_NEWSHARE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
};
CString* g_astrFileMgmtButtonStrings = NULL; // dynamic array of CStrings
BOOL g_bLoadedFileMgmtStrings = FALSE;

MMCBUTTON g_SvcMgmtSnapinButtons[] =
{
 // The first button will be either Start or Resume.
 // One of these two entries will be removed later.
 { 0, cmServiceResume, !TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
 { 0, cmServiceStart, !TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
 { 1, cmServiceStop, !TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
 { 2, cmServicePause, !TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
 { 3, cmServiceRestart, !TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
};
CString* g_astrSvcMgmtButtonStrings = NULL; // dynamic array of CStrings
BOOL g_bLoadedSvcMgmtStrings = FALSE;


void LoadButtonArray(
  MMCBUTTON* pButtonArray,
  BOOL* pbLoadedStrings,
  CString** pastrStringArray,
  UINT cButtons
  )
{
  ASSERT( NULL != pbLoadedStrings &&
      NULL != pButtonArray &&
      NULL != pastrStringArray);

  if ( !*pbLoadedStrings )
  {
    // load strings
    MMCBUTTON* pLoadButtonArray = pButtonArray;
    UINT cLoadButtons = cButtons;
    *pastrStringArray = new CString[2*cButtons];
    for (UINT i = 0; i < cButtons; i++)
    {
      UINT iButtonTextId = 0, iTooltipTextId = 0;
      
      switch (pButtonArray[i].idCommand)
      {
      case IDS_BUTTON_NEWSHARE:
        iButtonTextId = IDS_BUTTON_NEWSHARE;
        iTooltipTextId = IDS_TOOLTIP_NEWSHARE;
        break;
      case cmServiceResume:
        iButtonTextId = IDS_BUTTON_SERVICE_RESUME;
        iTooltipTextId = IDS_TOOLTIP_SERVICE_RESUME;
        break;
      case cmServiceStart:
        iButtonTextId = IDS_BUTTON_SERVICE_START;
        iTooltipTextId = IDS_TOOLTIP_SERVICE_START;
        break;
      case cmServiceStop:
        iButtonTextId = IDS_BUTTON_SERVICE_STOP;
        iTooltipTextId = IDS_TOOLTIP_SERVICE_STOP;
        break;
      case cmServicePause:
        iButtonTextId = IDS_BUTTON_SERVICE_PAUSE;
        iTooltipTextId = IDS_TOOLTIP_SERVICE_PAUSE;
        break;
      case cmServiceRestart:
        iButtonTextId = IDS_BUTTON_SERVICE_RESTART;
        iTooltipTextId = IDS_TOOLTIP_SERVICE_RESTART;
        break;
      default:
        ASSERT(FALSE);
        break;
      }

      VERIFY( (*pastrStringArray)[i*2].LoadString(iButtonTextId) );
      pButtonArray[i].lpButtonText =
        const_cast<BSTR>((LPCTSTR)((*pastrStringArray)[i*2]));

      VERIFY( (*pastrStringArray)[(i*2)+1].LoadString(iTooltipTextId) );
      pButtonArray[i].lpTooltipText =
        const_cast<BSTR>((LPCTSTR)((*pastrStringArray)[(i*2)+1]));
    }

    *pbLoadedStrings = TRUE;
  }
}


HRESULT LoadToolbar(
  LPTOOLBAR pToolbar,
  CBitmap& refbitmap,
  MMCBUTTON* pButtonArray,
  UINT cButtons
  )
{
  ASSERT( NULL != pToolbar &&
        NULL != pButtonArray );

  HRESULT hr = pToolbar->AddBitmap(cButtons, refbitmap, 16, 16, RGB(255,0,255) );
  if ( FAILED(hr) )
  {
    ASSERT(FALSE);
    return hr;
  }

  hr = pToolbar->AddButtons(cButtons, pButtonArray);
  if ( FAILED(hr) )
  {
    ASSERT(FALSE);
    return hr;
  }

  return hr;
}

STDMETHODIMP CFileMgmtComponent::SetControlbar(LPCONTROLBAR pControlbar)
{
  MFC_TRY;

  SAFE_RELEASE(m_pControlbar); // just in case

  if (NULL != pControlbar)
  {
    m_pControlbar = pControlbar; // CODEWORK should use smartpointer
    m_pControlbar->AddRef();
  }

  return S_OK;

  MFC_CATCH;
}

STDMETHODIMP CFileMgmtComponent::ControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
  MFC_TRY;

  #ifdef SNAPIN_PROTOTYPER
  return S_OK;
  #endif

    HRESULT hr=S_OK;

    switch (event)
    {

    case MMCN_BTN_CLICK:
    TRACE(_T("CFileMgmtComponent::ControlbarNotify - MMCN_BTN_CLICK\n"));
    {
      LPDATAOBJECT pDataObject = reinterpret_cast<LPDATAOBJECT>(arg);
      UINT idButton = (UINT)param;
      hr = OnToolbarButton( pDataObject, idButton );
    }
    break;

    case MMCN_SELECT:
    TRACE(_T("CFileMgmtComponent::ControlbarNotify - MMCN_SELECT\n"));
    {
      if (!(LOWORD(arg))) // bScope
      {
        // result pane
        hr = UpdateToolbar(
          reinterpret_cast<LPDATAOBJECT>(param),
          !!(HIWORD(arg)) );
      }
      else
      {
        // scope pane
        hr = AddToolbar( reinterpret_cast<LPDATAOBJECT>(param),
                                 !!(HIWORD(arg))  );
      }
    }
    break;
    
    default:
        ASSERT(FALSE); // Unhandled event 
    }

    return hr;

  MFC_CATCH;
}

HRESULT CFileMgmtComponent::ServiceToolbarButtonState(
  LPDATAOBJECT pServiceDataObject,
  BOOL fSelected )
{
  BOOL rgfMenuFlags[iServiceActionMax];
  for (INT i = 0; i < iServiceActionMax; i++)
    rgfMenuFlags[i] = FALSE;

  if ( fSelected )
  {
    CString strMachineName;
    CString strServiceName;
    if (!QueryComponentDataRef().Service_FGetServiceInfoFromIDataObject(
      pServiceDataObject,
      OUT &strMachineName,
      OUT &strServiceName,
      NULL))
    {
      ASSERT(FALSE);
    }
    else
    {
      if (strMachineName.IsEmpty())
        strMachineName = g_strLocalMachine;

      // Get the menu flags
      {
        ASSERT(NULL != QueryComponentDataRef().m_hScManager);
        CWaitCursor wait;
        if (!Service_FGetServiceButtonStatus( // this will report errors itself
          QueryComponentDataRef().m_hScManager,
          strServiceName,
          OUT rgfMenuFlags,
          NULL,  // pdwCurrentState
          TRUE)) // fSilentError
        {
          // let's not do this m_hScManager = NULL;
        }
      }
    }
  }

  // update toolbar
  ASSERT( NULL != m_pSvcMgmtToolbar );
//
// JonN 5/2/00 106431:
// Services snapin calls DeleteButton with an index but never called InsertButton
//
//  HRESULT hr = m_pSvcMgmtToolbar->DeleteButton(0);
//  if ( FAILED(hr) )
//    return hr;
  HRESULT hr = S_OK;

  // JonN 3/15/01 210065
  // Services snapin: "Resume service" toolbar button stays enabled after it is first displayed
  BOOL fShowResumeButton = !rgfMenuFlags[iServiceActionStart] &&
                            rgfMenuFlags[iServiceActionResume];
  VERIFY( SUCCEEDED( m_pSvcMgmtToolbar->SetButtonState(
      cmServiceStart, HIDDEN, fShowResumeButton)));
  VERIFY( SUCCEEDED( m_pSvcMgmtToolbar->SetButtonState(
      cmServiceResume, HIDDEN, !fShowResumeButton)));
  VERIFY( SUCCEEDED( m_pSvcMgmtToolbar->SetButtonState(
      cmServiceStart, ENABLED, rgfMenuFlags[iServiceActionStart])));
  VERIFY( SUCCEEDED( m_pSvcMgmtToolbar->SetButtonState(
      cmServiceResume, ENABLED, rgfMenuFlags[iServiceActionResume])));

  hr = m_pSvcMgmtToolbar->SetButtonState(
        cmServiceStop, ENABLED, rgfMenuFlags[iServiceActionStop] );
  if ( FAILED(hr) )
    return hr;
  hr = m_pSvcMgmtToolbar->SetButtonState(
        cmServicePause, ENABLED, rgfMenuFlags[iServiceActionPause] );
  if ( FAILED(hr) )
    return hr;
  hr = m_pSvcMgmtToolbar->SetButtonState(
        cmServiceRestart, ENABLED, rgfMenuFlags[iServiceActionRestart] );
  return hr;
}

// CODEWORK  The following algorithm is imperfect, but will do
// for now.  We ignore the old selection, and attach
// our fixed toolbar iff the new selection is our type.
HRESULT CFileMgmtComponent::AddToolbar(LPDATAOBJECT pdoScopeIsSelected,
                                       BOOL fSelected)
{
  HRESULT hr = S_OK;
  int i = 0;
  GUID guidSelectedObject;
  do { // false loop
    if (NULL == pdoScopeIsSelected)
    {
      // toolbar will be automatically detached
      return S_OK;
    }

    if ( FAILED(ExtractObjectTypeGUID(pdoScopeIsSelected,
                                    &guidSelectedObject)) )
    {
      ASSERT(FALSE); // shouldn't have given me non-MMC data object
      return S_OK;
    }
    if (NULL == m_pControlbar)
    {
      ASSERT(FALSE);
      return S_OK;
    }
#ifdef DEBUG
    if ( QueryComponentDataRef().IsExtendedNodetype(guidSelectedObject) )
    {
      ASSERT(FALSE && "shouldn't have given me extension parent nodetype");
      return S_OK;
    }
#endif

    switch (CheckObjectTypeGUID( &guidSelectedObject ) )
    {
    case FILEMGMT_SHARES:
      if (QueryComponentDataRef().GetIsSimpleUI() || IsServiceSnapin())
        break;
      if (NULL == m_pFileMgmtToolbar)
      {
        hr = m_pControlbar->Create( 
          TOOLBAR, this, reinterpret_cast<LPUNKNOWN*>(&m_pFileMgmtToolbar) );
        if ( FAILED(hr) )
        {
          ASSERT(FALSE);
          break;
        }
        ASSERT(NULL != m_pFileMgmtToolbar);
        if ( !QueryComponentDataRef().m_fLoadedFileMgmtToolbarBitmap )
        {
          VERIFY( QueryComponentDataRef().m_bmpFileMgmtToolbar.LoadBitmap(
            IDB_FILEMGMT_TOOLBAR ) );
          QueryComponentDataRef().m_fLoadedFileMgmtToolbarBitmap = TRUE;
        }
        LoadButtonArray(
          g_FileMgmtSnapinButtons,
          &g_bLoadedFileMgmtStrings,
          &g_astrFileMgmtButtonStrings,
          ARRAYLEN(g_FileMgmtSnapinButtons)
          );
        hr = LoadToolbar(
          m_pFileMgmtToolbar,
          QueryComponentDataRef().m_bmpFileMgmtToolbar,
          g_FileMgmtSnapinButtons,
          ARRAYLEN(g_FileMgmtSnapinButtons)
          );
      }
      if (FAILED(hr))
        break;
      // New Share is always enabled
      VERIFY( SUCCEEDED(m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pFileMgmtToolbar)) );
      for (i = 0; i < ARRAYLEN(g_FileMgmtSnapinButtons); i++) {
        m_pFileMgmtToolbar->SetButtonState(
          g_FileMgmtSnapinButtons[i].idCommand, 
          ENABLED, 
          fSelected);
      }
      break;
    case FILEMGMT_SERVICES:
      if ( !IsServiceSnapin() )
        break;
      if (NULL == m_pSvcMgmtToolbar)
      {
        hr = m_pControlbar->Create( 
          TOOLBAR, this, reinterpret_cast<LPUNKNOWN*>(&m_pSvcMgmtToolbar) );
        if ( FAILED(hr) )
        {
          ASSERT(FALSE);
          break;
        }
        ASSERT(NULL != m_pSvcMgmtToolbar);
        if ( !QueryComponentDataRef().m_fLoadedSvcMgmtToolbarBitmap )
        {
          VERIFY( QueryComponentDataRef().m_bmpSvcMgmtToolbar.LoadBitmap(
            IDB_SVCMGMT_TOOLBAR ) );
          QueryComponentDataRef().m_fLoadedSvcMgmtToolbarBitmap = TRUE;
        }
        LoadButtonArray(
          g_SvcMgmtSnapinButtons,
          &g_bLoadedSvcMgmtStrings,
          &g_astrSvcMgmtButtonStrings,
          ARRAYLEN(g_SvcMgmtSnapinButtons)
          );
        // JonN 3/15/01 210065
        // "Resume service" toolbar button stays enabled after it is first displayed
        hr = LoadToolbar(
          m_pSvcMgmtToolbar,
          QueryComponentDataRef().m_bmpSvcMgmtToolbar,
          g_SvcMgmtSnapinButtons,
          ARRAYLEN(g_SvcMgmtSnapinButtons)
          );
      }
      if (FAILED(hr))
        break;
      VERIFY( SUCCEEDED(m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pSvcMgmtToolbar)) );
      break;
    case FILEMGMT_ROOT:
    case FILEMGMT_SESSIONS:
    case FILEMGMT_RESOURCES:
      if (m_pControlbar && m_pFileMgmtToolbar)
      {
        m_pControlbar->Detach(m_pFileMgmtToolbar);
      }
      break;

    #ifdef SNAPIN_PROTOTYPER
    case FILEMGMT_PROTOTYPER:
      break; // no toolbar
    case FILEMGMT_PROTOTYPER_LEAF:
      break; // no toolbar
    #endif    

    default:
          ASSERT(FALSE); // unknown type
      break;
    }
  } while (FALSE); // false loop

  return hr;
}

HRESULT CFileMgmtComponent::UpdateToolbar(
  LPDATAOBJECT pdoResultIsSelected,
  BOOL fSelected )
{
  int i = 0;
  GUID guidSelectedObject;
  if ( FAILED(ExtractObjectTypeGUID(pdoResultIsSelected,
                                    &guidSelectedObject)) )
  {
    ASSERT(FALSE); // shouldn't have given me non-MMC data object
    return S_OK;
  }
  int objecttype = CheckObjectTypeGUID( &guidSelectedObject );

  switch (objecttype)
  {
  case FILEMGMT_SERVICE:
    ServiceToolbarButtonState( pdoResultIsSelected, fSelected );
    break;
  case FILEMGMT_SHARES:
    if (m_pControlbar && m_pFileMgmtToolbar && !QueryComponentDataRef().GetIsSimpleUI())
    {
      m_pControlbar->Attach(TOOLBAR, m_pFileMgmtToolbar);
      for (i = 0; i < ARRAYLEN(g_FileMgmtSnapinButtons); i++) {
        m_pFileMgmtToolbar->SetButtonState(
          g_FileMgmtSnapinButtons[i].idCommand, 
          ENABLED, 
          fSelected);
      }
    }
    break;
  case FILEMGMT_SHARE:
  case FILEMGMT_SESSIONS:
  case FILEMGMT_RESOURCES:
    if (m_pControlbar && m_pFileMgmtToolbar)
    {
      m_pControlbar->Detach(m_pFileMgmtToolbar);
    }
  case FILEMGMT_SESSION:
  case FILEMGMT_RESOURCE:
    break;
  default:
    break;
  }

  return S_OK;
}

HRESULT CFileMgmtComponent::OnToolbarButton(LPDATAOBJECT pDataObject, UINT idButton)
{
  switch (idButton)
  {
  case IDS_BUTTON_NEWSHARE:
    {
      BOOL fRefresh = QueryComponentDataRef().NewShare( pDataObject );
      if (fRefresh)
      {
        // JonN 12/03/98 updated to use new method
        VERIFY(SUCCEEDED( RefreshAllViews(pDataObject) ));
      }
    }
    break;
  case cmServiceStart:
  case cmServiceStop:
  case cmServicePause:
  case cmServiceResume:
  case cmServiceRestart:
    VERIFY( SUCCEEDED(Command(idButton, pDataObject)) );
    break;
  default:
    ASSERT(FALSE);
    break;
  }
  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\filemgmt\utils.cpp ===
/////////////////////////////////////////////////////////////////////
//
//	Utils.cpp
//
//	General-purpose routines that are project independent.
//
//	HISTORY
//	t-danmo		96.09.22	Creation.
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "progress.h" // CServiceControlProgress
#include "macros.h"   // MFC_TRY/MFC_CATCH
USE_HANDLE_MACROS("FILEMGMT(utils.cpp)")


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Fusion MFC-based property page
//
HPROPSHEETPAGE MyCreatePropertySheetPage(AFX_OLDPROPSHEETPAGE* psp)
{
    PROPSHEETPAGE_V3 sp_v3 = {0};
    CopyMemory (&sp_v3, psp, psp->dwSize);
    sp_v3.dwSize = sizeof(sp_v3);

    return (::CreatePropertySheetPage (&sp_v3));
}

/////////////////////////////////////////////////////////////////////
void
ComboBox_FlushContent(HWND hwndCombo)
	{
	Assert(IsWindow(hwndCombo));
	SendMessage(hwndCombo, CB_RESETCONTENT, 0, 0);
	}


/////////////////////////////////////////////////////////////////////
//	ComboBox_FFill()
//
//	Fill a combo box with the array of string Ids.
//
//	Return FALSE if an error occurs (such as stringId not found).
//
BOOL
ComboBox_FFill(
	const HWND hwndCombo,				// IN: Handle of the combobox
	const TStringParamEntry rgzSPE[],	// IN: SPE aray zero terminated
	const LPARAM lItemDataSelect)		// IN: Which item to select
	{	
	CString str;
	TCHAR szBuffer[1024];
	LRESULT lResult;

	Assert(IsWindow(hwndCombo));
	Assert(rgzSPE != NULL);

	for (int i = 0; rgzSPE[i].uStringId != 0; i++)
		{
		if (!::LoadString(g_hInstanceSave, rgzSPE[i].uStringId,
			OUT szBuffer, LENGTH(szBuffer)))
			{
			TRACE1("Unable to load string Id=%d.\n", rgzSPE[i].uStringId);
			Assert(FALSE && "Unable to load string");
			return FALSE;
			}
		lResult = SendMessage(hwndCombo, CB_ADDSTRING, 0,
			reinterpret_cast<LPARAM>(szBuffer));
		Report(lResult >= 0);
		const WPARAM iIndex = lResult;
		lResult = SendMessage(hwndCombo, CB_SETITEMDATA, iIndex,
			rgzSPE[i].lItemData);
		Report(lResult != CB_ERR);
		if (rgzSPE[i].lItemData == lItemDataSelect)
			{
			SendMessage(hwndCombo, CB_SETCURSEL, iIndex, 0);
			}
		} // for
	return TRUE;
	} // ComboBox_FFill()


/////////////////////////////////////////////////////////////////////
//	ComboBox_FGetSelectedItemData()
//
//	Get the value of the lParam field of the current selected item.
//
//	If an error occurs return -1 (CB_ERR).
//	Otherwise the value of the selected item.
//
LPARAM
ComboBox_GetSelectedItemData(HWND hwndComboBox)
	{
	LPARAM l;

	Assert(IsWindow(hwndComboBox));
	l = SendMessage(hwndComboBox, CB_GETCURSEL, 0, 0);
	Report(l != CB_ERR && "Combobox has no item selected");
	l = SendMessage(hwndComboBox, CB_GETITEMDATA, l, 0);
	Assert(l != CB_ERR && "Cannot extract item data from combobox");
	if (l == CB_ERR)
		{
		Assert(CB_ERR == -1);
		return -1;
		}
	return l;
	} // ComboBox_GetSelectedItemData()


/////////////////////////////////////////////////////////////////////
HWND
HGetDlgItem(HWND hdlg, INT nIdDlgItem)
	{
	Assert(IsWindow(hdlg));
	Assert(IsWindow(GetDlgItem(hdlg, nIdDlgItem)));
	return GetDlgItem(hdlg, nIdDlgItem);
	} // HGetDlgItem()


/////////////////////////////////////////////////////////////////////
void
SetDlgItemFocus(HWND hdlg, INT nIdDlgItem)
	{
	Assert(IsWindow(hdlg));
	Assert(IsWindow(GetDlgItem(hdlg, nIdDlgItem)));
	SetFocus(GetDlgItem(hdlg, nIdDlgItem));
	}

/////////////////////////////////////////////////////////////////////
void
EnableDlgItem(HWND hdlg, INT nIdDlgItem, BOOL fEnable)
	{
	Assert(IsWindow(hdlg));
	Assert(IsWindow(GetDlgItem(hdlg, nIdDlgItem)));
	EnableWindow(GetDlgItem(hdlg, nIdDlgItem), fEnable);
	}

/////////////////////////////////////////////////////////////////////
//	Enable/disable one or more controls in a dialog.
void
EnableDlgItemGroup(
	HWND hdlg,				// IN: Parent dialog of the controls
	const UINT rgzidCtl[],	// IN: Group (array) of control Ids to be enabled (or disabled)
	BOOL fEnableAll)		// IN: TRUE => We want to enable the controls; FALSE => We want to disable the controls
	{
	Assert(IsWindow(hdlg));
	Assert(rgzidCtl != NULL);
	for (const UINT * pidCtl = rgzidCtl; *pidCtl != 0; pidCtl++)
		{
		EnableWindow(HGetDlgItem(hdlg, *pidCtl), fEnableAll);
		}
	} // EnableDlgItemGroup()


/////////////////////////////////////////////////////////////////////
//	Show/hide one or more controls in a dialog.
void
ShowDlgItemGroup(
	HWND hdlg,				// IN: Parent dialog of the controls
	const UINT rgzidCtl[],	// IN: Group (array) of control Ids to be shown (or hidden)
	BOOL fShowAll)			// IN: TRUE => We want to show the controls; FALSE => We want to hide the controls
	{
	Assert(IsWindow(hdlg));
	Assert(rgzidCtl != NULL);
	INT nCmdShow = fShowAll ? SW_SHOW : SW_HIDE;
	for (const UINT * pidCtl = rgzidCtl; *pidCtl != 0; pidCtl++)
		{
		ShowWindow(HGetDlgItem(hdlg, *pidCtl), nCmdShow);
		}
	} // ShowDlgItemGroup()


/////////////////////////////////////////////////////////////////////
//	Str_PchCopyChN()
//
//	Copy a string until reaching character chStop or destination buffer full.
//
//	RETURNS
//	Pointer to the last character of source buffer not copied into destination buffer.
//	This may be useful to parse the rest of the source string.
//
//	INTERFACE NOTES
//	Character chStop is not copied into the destination buffer.
//	If cchDstMax==0, the number of characters will not be limited.
//
TCHAR *
Str_PchCopyChN(
	TCHAR * szDst,			// OUT: Destination buffer
	CONST TCHAR * szSrc,	// IN: Source buffer
	TCHAR chStop,			// IN: Character to stop the copying
	INT cchDstMax)			// IN: Length of the output buffer
	{
	Assert(szDst != NULL);
	Assert(szSrc != NULL);
	Assert(cchDstMax >= 0);

	while (*szSrc != '\0' && *szSrc != chStop && --cchDstMax != 0)
		{
		*szDst++ = *szSrc++;
		}
	*szDst = '\0';
	return const_cast<TCHAR *>(szSrc);
	} // Str_PchCopyChN()


/////////////////////////////////////////////////////////////////////
//	Str_SubstituteStrStr()
//
//	Scan the source string and replace every occurrence of a
//	sub-string by another sub-string.  This routine may
//	be used to count the number of sub-strings in the
//	source string.
//
//	RETURNS
//	Return the number of subsitutions performed.
//
//	INTERFACE NOTES
//	The source and destination buffer may overlap as long
//	as the length of the token to replace is shorter than
//	the token to search.
//
INT
Str_SubstituteStrStr(
	TCHAR * szDst,				// OUT: Destination buffer
	CONST TCHAR * szSrc,		// IN: Source buffer
	CONST TCHAR * szToken,		// IN: Token to find
	CONST TCHAR * szReplace)	// IN: Token to replace
	{
	INT cSubtitutions = 0;

	Assert(szDst != NULL);
	Assert(szSrc != NULL);
	Assert(szToken != NULL);
	Assert(szReplace != NULL);
	Endorse(szDst == szSrc);

	while (*szSrc != '\0')
		{
		if (*szSrc == *szToken)
			{
			// Check if we match the token
			CONST TCHAR * pchSrc = szSrc;
			CONST TCHAR * pchToken = szToken;
			while (*pchToken != '\0')
				{
				if (*pchSrc++ != *pchToken++)
					goto TokenNotMatch;
				}
			cSubtitutions++;
			szSrc = pchSrc;
			pchSrc = szReplace;
			while (*pchSrc != '\0')
				*szDst++ = *pchSrc++;
			continue;
		TokenNotMatch:
			;
			} // if
		*szDst++ = *szSrc++;

		} // while
	*szDst = '\0';
	return cSubtitutions;
	} // Str_SubstituteStrStr()


/////////////////////////////////////////////////////////////////////
//	PchParseCommandLine()
//
//	Split a command line into its path to its executable binary and
//	its command line arguments.  The path to the executable is
//	copied into the output buffer.
//
//	RETURNS
//	Pointer to the next character after path to the executable (Pointer
//  may point to an empty string).  If an error occurs, return NULL.
//
//	FORMATS SUPPORTED
//	1.	"c:\\winnt\\foo.exe /bar"
//	2.	""c:\\winnt\\foo.exe" /bar"
//	The double quotes around the binary path allow
//	the binary path to have spaces.
//
TCHAR *
PchParseCommandLine(
	CONST TCHAR szFullCommand[],	// IN: Full command line
	TCHAR szBinPath[],				// OUT: Path of the executable binary
	INT cchBinPathBuf)				// IN: Size of the buffer
	{
    UNREFERENCED_PARAMETER (cchBinPathBuf);
	CONST TCHAR * pchSrc = szFullCommand;
	TCHAR * pchDst = szBinPath;
	BOOL fQuotesFound = FALSE;		// TRUE => The binary path is surrounded by quotes (")

	Assert(szFullCommand != NULL);
	Assert(szBinPath != NULL);

	// Skip leading spaces
	while (*pchSrc == _T(' '))
		pchSrc++;
	if (*pchSrc == _T('\"'))
		{
		fQuotesFound = TRUE;
		pchSrc++;
		}
	while (TRUE)
		{
		*pchDst = *pchSrc;
		if (*pchSrc == _T('\0'))
			break;
		if (*pchSrc == _T('\"') && fQuotesFound)
			{
			pchSrc++;
			break;
			}
		if (*pchSrc == _T(' ') && !fQuotesFound)
			{
			pchSrc++;
			break;
			}
		pchSrc++;
		pchDst++;
		}
	Assert(pchDst - szBinPath < cchBinPathBuf);
	*pchDst = _T('\0');

	return const_cast<TCHAR *>(pchSrc);	// Return character where arguments starts
	} // PchParseCommandLine()


/////////////////////////////////////////////////////////////////////
void TrimString(CString& rString)
	{
	rString.TrimLeft();
	rString.TrimRight();
	}

/////////////////////////////////////////////////////////////////////
//	PargzpszFromPgrsz()
//
//	Parse a group of strings into an array of pointers to strings.
//	This routine is somewhat similar to CommandLineToArgvW() but
//	uses a group of strings instead of a normal string.
//
//	RETURN
//	Return a pointer to an allocated array of pointers to strings.
//	The array of pointers allocated with the new() operator,
//	therefore the caller must call ONCE delete() to free memory.
//
//	BACKGROUND
//	You need to 'understand' hungarian prefixes to appreciate the
//	name of the function.
//
//	p		Pointer to something
//	psz		Pointer to string terminated.
//	pa		Pointer dynamically allocated.  For instance, pasz is
//			a pointer to an allocated string.  The allocation is
//			to remind the developper he/she have to free the memory
//			when done with the variable.
//	rg		Array (range).  Array (rg) is similar to pointer (p)
//			but may point to more than one element.
//			rgch is an array of characters while pch points to
//			a single character.
//	rgz		Array of which the last element is zero.  The 'last element'
//			may be a character, an integer, a pointer or any other
//			data type found in the array.
//			For instance rgzch would be an array of characters having
//			its last character zero -- a string (sz).
//	gr		Group.  This is different than array because indexing
//			cannot be used.  For instance, a group of strings is
//			not the same as an array of strings.
//			char grsz[] = "DOS\0WfW\0Win95\0WinNT\0";
//			char * rgpsz[] = { "DOS", "WfW", "Win95", "WinNT" };
//			char * rgzpsz[] = { "DOS", "WfW", "Win95", "WinNT", NULL };
//
//	Now it is time to put all the pieces together.
//	pargzpsz = "pa" + "rgz" + "psz"
//	pgrsz = "p" + "gr" + "sz"
//
//	USAGE
//		LPTSTR * pargzpsz;
//		pargzpsz = PargzpszFromPgrsz("DOS\0WfW\0Win95\0WinNT\0", OUT &cStringCount);
//		delete pargzpsz;	// Single delete to free memory
//	
LPTSTR *
PargzpszFromPgrsz(
	CONST LPCTSTR pgrsz,	// IN: Pointer to group of strings
	INT * pcStringCount)	// OUT: OPTIONAL: Count of strings in the  stored into returned value
	{
	Assert(pgrsz != NULL);
	Endorse(pcStringCount == NULL);

	// Compute how much memory is needed for allocation
	CONST TCHAR * pchSrc = pgrsz;
	INT cStringCount = 0;
	INT cch = sizeof(TCHAR *);
	while (*pchSrc != _T('\0'))
		{
		cStringCount++;
		for ( ; *pchSrc != _T('\0'); pchSrc++)
			cch++;
		cch = sizeof(TCHAR *) + ((cch + 4) & ~3);	// Align to next DWORD
		pchSrc++;
		} // while

	// Allocate a single block of memory for all the data
	LPTSTR * pargzpsz = (LPTSTR *)new TCHAR[cch];
	Assert(pargzpsz != NULL);
	TCHAR * pchDst = (TCHAR *)&pargzpsz[cStringCount+1];

	pchSrc = pgrsz;
	for (INT iString = 0; iString < cStringCount; iString++)
		{
		pargzpsz[iString] = pchDst;
		// Copy string
		while (*pchSrc != '\0')
			{
			*pchDst++ = *pchSrc++;
			}
		*pchDst++ = *pchSrc++;	// Copy null-terminator
		pchDst = (TCHAR *)(((INT_PTR)pchDst + 3) & ~3);	// Align pointer to next DWORD
		} // for
	pargzpsz[cStringCount] = NULL;
	if (pcStringCount != NULL)
		*pcStringCount = cStringCount;
	return pargzpsz;
	} // PargzpszFromPgrsz()


/////////////////////////////////////////////////////////////////////
void
ListView_AddColumnHeaders(
	HWND hwndListview,		// IN: Handle of the listview we want to add columns
	const TColumnHeaderItem rgzColumnHeader[])	// IN: Array of column header items
	{
	RECT rcClient;
	INT cxTotalWidth;		// Total width of the listview control
	LV_COLUMN lvColumn;
	INT cxColumn;	// Width of the individual column
	TCHAR szBuffer[1024];

	Assert(IsWindow(hwndListview));
	Assert(rgzColumnHeader != NULL);

	GetClientRect(hwndListview, OUT &rcClient);
	cxTotalWidth = rcClient.right;
	lvColumn.pszText = szBuffer;

	for (INT i = 0; rgzColumnHeader[i].uStringId != 0; i++)
		{
		if (!::LoadString(g_hInstanceSave, rgzColumnHeader[i].uStringId,
			OUT szBuffer, LENGTH(szBuffer)))
			{
			TRACE1("Unable to load string Id=%d\n", rgzColumnHeader[i].uStringId);
			Assert(FALSE);
			continue;
			}
		lvColumn.mask = LVCF_TEXT;
		cxColumn = rgzColumnHeader[i].nColWidth;
		if (cxColumn > 0)
			{
			Assert(cxColumn <= 100);
			cxColumn = (cxTotalWidth * cxColumn) / 100;
			lvColumn.mask |= LVCF_WIDTH;
			lvColumn.cx = cxColumn;
			}

		INT iColRet = ListView_InsertColumn(hwndListview, i, IN &lvColumn);
		Report(iColRet == i);
		} // for

	} // ListView_AddColumnHeaders()


/////////////////////////////////////////////////////////////////////
int
ListView_InsertItemEx(
    HWND hwndListview,			// IN: Handle of the listview we want to add item
    CONST LV_ITEM * pLvItem)	// IN: Pointer to listview item
	{
	LV_ITEM lvItemT;	// Temporary variable
	TCHAR szT[1024];	// Temporary buffer
	TCHAR * pch;
	INT iItem;	// Index of the item

	Assert(IsWindow(hwndListview));
	Assert(pLvItem != NULL);

	lvItemT = *pLvItem;		// Copy the whole structure
	lvItemT.iSubItem = 0;
	lvItemT.pszText = szT;

	// Copy until the next
	pch = Str_PchCopyChN(OUT szT, pLvItem->pszText, '\t', LENGTH(szT));
	Assert(pch != NULL);

	iItem = ListView_InsertItem(hwndListview, IN &lvItemT);
	Report(iItem >= 0);
	if (*pch == '\0')
		return iItem;
	Assert(*pch == '\t');

	lvItemT.mask = LVIF_TEXT;
	lvItemT.iItem = iItem;
	lvItemT.iSubItem = 1;

	while (*pch != '\0')
		{
		pch = Str_PchCopyChN(OUT szT, pch + 1, '\t', LENGTH(szT));
		BOOL fRet = ListView_SetItem(hwndListview, IN &lvItemT);
		Report(fRet != FALSE);
		lvItemT.iSubItem++;
		break;
		}
	return iItem;
	} // ListView_InsertItemEx()


/////////////////////////////////////////////////////////////////////
//	Display the common dialog to get a filename.
BOOL
UiGetFileName(
	HWND hwnd,
	TCHAR szFileName[],		// OUT: Filename we want to get
	INT cchBufferLength)	// IN: Length of szFileName buffer
	{
    OPENFILENAME ofn;

	Assert(szFileName != NULL);
	Assert(cchBufferLength > 10);		// At least 10 characters

	TCHAR szBufferT[2048];
	::ZeroMemory( szBufferT, sizeof(szBufferT) );
	VERIFY(::LoadString(g_hInstanceSave, IDS_OPENFILE_FILTER, szBufferT, LENGTH(szBufferT)));
	
	::ZeroMemory(OUT &ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(OPENFILENAME);
	ofn.hwndOwner = hwnd;
	ofn.hInstance = g_hInstanceSave;
	ofn.lpstrFilter = szBufferT;
	ofn.nFilterIndex = 1;
	ofn.lpstrFile = szFileName;
	ofn.nMaxFile = cchBufferLength;
	ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY;

	return GetOpenFileName(&ofn);
	} // UiGetFileName()


/////////////////////////////////////////////////////////////////////
//	PaszLoadStringPrintf()
//
//	Load a string from the resource, and format it and return
//	pointer allocated string.
//
//	RETURNS
//	Pointer to allocated string.  Must call LocalFree() when
//	done with string.
//
//	INTERFACE NOTES
//	The format of the resource string uses %1 throuth %99 and
//	assumes the arguments are pointers to strings.
//	
//	If you have an argument other than a string, you can append a
//	printf-type within two exclamation marks. 
//	!s!		Insert a string (default)
//	!d!		Insert a decimal integer
//	!u!		Insert an unsigned integer
//	!x!		Insert an hexadecimal integer
//
//	HOW TO AVOID BUGS
//	To avoid bugs using this routine, I strongly suggest to include
//	the format of the string as part of the name of the string Id.
//	If you change the format of the string, you should rename
//	the string Id to reflect the new format.  This will guarantee
//	the correct type and number of arguments are used.
//
//	EXAMPLES
//		IDS_s_PROPERTIES = "%1 Properties"
//		IDS_ss_PROPERTIES = "%1 Properties on %2"
//		IDS_sus_SERVICE_ERROR = "Service %1 encountered error %2!u! while connecting to %3"
//
//	HISTORY
//	96.10.30	t-danmo		Creation
//
TCHAR *
PaszLoadStringPrintf(
	UINT wIdString,			// IN: String Id
	va_list arglist)		// IN: Arguments (if any)
	{
	Assert(wIdString != 0);

	TCHAR szBufferT[2048];
	LPTSTR paszBuffer = NULL;	// Pointer to allocated buffer. Caller must call LocalFree() to free it

	// Load the string from the resource
	VERIFY(::LoadString(g_hInstanceSave, wIdString, szBufferT, LENGTH(szBufferT)));
	
	// Format the string
	::FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
		szBufferT,
		0,
		0,
		OUT (LPTSTR)&paszBuffer,		// Buffer will be allocated by FormatMessage()
		0,
		&arglist);
	
#ifdef DEBUG
	if (paszBuffer == NULL)
		{
		DWORD dw = GetLastError();
		Report(FALSE && "FormatMessage() failed.");
		}
#endif
	return paszBuffer;
	} // PaszLoadStringPrintf()


/////////////////////////////////////////////////////////////////////
//	LoadStringPrintf()
//
//	Load a string from the resources, format it and copy the result string
//	into the CString object.
//
//	Can also use LoadStringWithInsertions()
//	AFX_MANAGE_STATE(AfxGetStaticModuleState())
//
//	EXAMPLES
//		LoadStrigPrintf(IDS_s_PROPERTIES, OUT &strCaption, szServiceName);
//		LoadStrigPrintf(IDS_ss_PROPERTIES, OUT &strCaption, szServiceName, szMachineName);
//		LoadStrigPrintf(IDS_sus_SERVICE_ERROR, OUT &strMessage, szServiceName, ::GetLastError(), szMachineName);
//
void
LoadStringPrintf(
	UINT wIdString,		// IN: String Id
	CString * pString,	// OUT: String to receive the characters
	...)				// IN: Optional arguments
	{
	Assert(wIdString != NULL);
	Assert(pString != NULL);

	va_list arglist;
	va_start(arglist, pString);

	TCHAR * paszBuffer = PaszLoadStringPrintf(wIdString, arglist);
	*pString = paszBuffer;	// Copy the string into the CString object
	LocalFree(paszBuffer);
	}


/////////////////////////////////////////////////////////////////////
//	SetWindowTextPrintf()
//
//	Load a string from the resource, format it and set the window text.
//
//	EXAMPLE
//		SetWindowText(hwndStatic, IDS_s_PROPERTIES, szObjectName);
//
//	HISTORY
//	96.10.30	t-danmo		Creation. Core copied from LoadStringPrintf()
//
void
SetWindowTextPrintf(HWND hwnd, UINT wIdString, ...)
	{
	ASSERT(IsWindow(hwnd));
	ASSERT(wIdString != 0);

	va_list arglist;
	va_start(arglist, wIdString);
	TCHAR * paszBuffer = PaszLoadStringPrintf(wIdString, arglist);
	if (NULL != paszBuffer) // JonN 5/30/00 PREFIX 110941
		SetWindowText(hwnd, paszBuffer);	// Set the text of the window
	LocalFree(paszBuffer);
	} // SetWindowTextPrintf()

#ifdef SNAPIN_PROTOTYPER

const TCHAR rgchHexDigits[]		= _T("00112233445566778899aAbBcCdDeEfF");
const TCHAR szSpcTab[] 			= _T(" \t");
const TCHAR szWhiteSpaces[] 	= _T(" \t\n\r\f\v");
const TCHAR szDecimalDigits[]	= _T("0123456789");

#ifdef UNICODE
	#define strchrT		wcschr
#else
	#define strchrT		strchr
#endif

/////////////////////////////////////////////////////////////////////
//	FParseInteger()
//
//	Parse the source string pchSrc and extract
//	its integer value.
//
//	RETURNS
//	Return TRUE if successful and set uData to integer value
//	of the parsed string.
//	If not successful (ie, illegal digit or overflow), return FALSE,
//	set uData to zero and set nErrCode to error found.
//	Field pi.pchStop is always set to the last valid character
//	parsed.
//
//	INTERFACE NOTES
//	Fields pPI->pchSrc and pPI->nFlags are preserved during
//	the execution of FParseInteger().
//
BOOL
FParseInteger(INOUT TParseIntegerInfo * pPI)
	{
	UINT uDataT;
	UINT uBase;
	UINT iDigit;
	UINT cDigitParsed; // Number of digits parsed
	BOOL fIsNegative = FALSE;
	const TCHAR * pchDigit;

	Assert(pPI != NULL);
	Assert(pPI->pchSrc != NULL);
	pPI->pchStop = pPI->pchSrc;
	pPI->nErrCode = PI_errOK; // No error yet
	pPI->uData = 0;
	uBase = (pPI->nFlags & PI_mskfHexBaseOnly) ? 16 : 10;
	cDigitParsed = 0;

	// Skip leading blanks
	while (*pPI->pchStop ==_T(' '))
		pPI->pchStop++;
	// Check for a minus sign
	if (*pPI->pchStop == _T('-'))
		{
		if (pPI->nFlags & PI_mskfNoMinusSign)
			{
			pPI->nErrCode = PI_errMinusSignFound;
			return FALSE;
			}
		fIsNegative = TRUE;
		pPI->pchStop++;
		}
	//  Skip leading zeroes
	while (*pPI->pchStop == _T('0'))
		{
		pPI->pchStop++;
		cDigitParsed++;
		}
	// Look for the hexadecimal prefix (0x or 0X)
	if (*pPI->pchStop == _T('x') || *pPI->pchStop == _T('X'))
		{
		if ((pPI->nFlags & PI_mskfAllowHexBase) == 0)
			{
			pPI->nErrCode = PI_errInvalidInteger;
			return FALSE;
			}
		pPI->pchStop++;
		cDigitParsed = 0;
		uBase = 16;
		} // if

	while (*pPI->pchStop != _T('\0'))
		{
		pchDigit = wcschr(rgchHexDigits, *pPI->pchStop);
		if (pchDigit == NULL)
			{
			if (pPI->nFlags & PI_mskfAllowRandomTail)
				break;
			// Digit not found while random tail not allowed
			pPI->nErrCode = PI_errInvalidInteger;
			return FALSE;
			} // if
		Assert(pchDigit >= rgchHexDigits);
		iDigit = (pchDigit - rgchHexDigits) >> 1;
		Assert(iDigit <= 0x0F);
		if (iDigit >= uBase)
			{
			// Hex digit found while parsing a decimal string
			pPI->nErrCode = PI_errInvalidInteger;
			return FALSE;
			}
		cDigitParsed++;
		uDataT = pPI->uData * uBase + iDigit;
		if (pPI->uData > ((UINT)-1)/10 || uDataT < pPI->uData)
			{
			pPI->nErrCode = PI_errIntegerOverflow;
			return FALSE;
			}
		pPI->uData = uDataT;
		pPI->pchStop++;
		} // while

	if ((cDigitParsed == 0) && (pPI->nFlags & PI_mskfNoEmptyString))
		{
		// Empty String found while not allowed
		Assert(pPI->uData == 0);
		pPI->nErrCode = PI_errEmptyString;
		return FALSE;
		}
	if (fIsNegative)
		{
		pPI->uData = -(int)pPI->uData;
		}
	if (pPI->nFlags & PI_mskfSingleEntry)
		{
		// Check if there are no more digits at the end of the string
		// Only spaces are allowed
		while (*pPI->pchStop == _T(' '))
			pPI->pchStop++;
		if (*pPI->pchStop != _T('\0'))
			{
			pPI->nErrCode = PI_errInvalidInteger;
			return FALSE;
			}
		}
	return TRUE;
	} // FParseInteger()


/////////////////////////////////////////////////////////////////////
//	FScanf()
//
//	Parse a formatted string and extract the values.
//	FScanf() behaves like the well known scanf() function but
//	has range checking and pattern matching.  The wildcard (*)
//	may be substituded by "%s" with a NULL pointer.
//
//	Return TRUE if successful, otherwise return FALSE
//	and set nErrCode to the error found.
//
//	Formats supported:
//		%d		Extract a decimal integer
//		%i		Extract a generic integer (decimal or hexadecimal)
//		%u		Extract an unsigned decimal integer (return error if minus sign found)
//		%x		Force extraction of an hexadecimal integer
//		%s		Extract a string
//		%v		Void the spaces and tabs characters
//
//	Note:
//	Fields sfi.pchSrc and sfi.nFlags are preserved during
//	the execution of FScanf().
//
//  Example:
//  FScanf(&sfi, "%v%s.%s", " \t foobar.txt",
//      OUT szName, LENGTH(szName), OUT szExt, LENGTH(szExt));
//
BOOL FScanf(
	SCANF_INFO * pSFI,		// INOUT: Control structure
	const TCHAR * pchFmt, 	// IN: Format template string
	...)					// OUT: scanf() arguments
	{
	va_list arglist;
	TParseIntegerInfo pi;

	Assert(pSFI != 0);
	Assert(pchFmt != NULL);
	Assert(pSFI->pchSrc != NULL);

	va_start(INOUT arglist, pchFmt);
	pSFI->pchSrcStop = pSFI->pchSrc;
	pSFI->nErrCode = SF_errOK;
	pSFI->cArgParsed = 0;

	while (TRUE)
		{
		switch (*pchFmt++)
			{
		case 0:	// End of string
			return TRUE;

		case '%':
			switch (*pchFmt++)
				{
			case '%': // "%%"
				if (*pSFI->pchSrcStop++ != '%')
					{
					pSFI->pchSrcStop--;
					pSFI->nErrCode = SF_errTemplateMismatch;
					return FALSE;
					}
				break;

			case 'v':
				while (*pSFI->pchSrcStop == ' ' || *pSFI->pchSrcStop == '\t')
					pSFI->pchSrcStop++;
				break;

			case 'V':
				while ((*pSFI->pchSrcStop != '\0') && 
					(strchrT(szWhiteSpaces, *pSFI->pchSrcStop) != NULL))
					pSFI->pchSrcStop++;
				break;

			case 'd': // "%d" Decimal integer (signed | unsigned)
			case 'u': // "%u" Decimal unsigned integer
			case 'i': // "%i" Generic integer (decimal | hexadecimal / signed | unsigned)
			case 'x': // "%x" Hexadecimal integer
				{
				int * p;

				pi.nFlags = PI_mskfNoEmptyString | PI_mskfAllowRandomTail;
				switch (*(pchFmt-1))
					{
				case 'u':
					pi.nFlags |= PI_mskfNoMinusSign;
					break;
				case 'i':
					pi.nFlags |= PI_mskfAllowHexBase;
					break;
				case 'x':
					pi.nFlags |= PI_mskfHexBaseOnly | PI_mskfNoMinusSign;
					} // switch
				pi.pchSrc = pSFI->pchSrcStop;
				if (!FParseInteger(INOUT &pi))
					{
					pSFI->pchSrcStop = pi.pchStop;
					return FALSE;
					} // if
				pSFI->pchSrcStop = pi.pchStop;
				pSFI->cArgParsed++;
				p = (int *)va_arg(arglist, int *);
				Assert(p != NULL);
				*p = pi.uData;
				}
				break; // Integer

			case 's': // "%s" String
				{
				// To get a clean string, use the format "%v%s%v"
				// which will strip all the spaces and tabs around
				// the string.
				TCHAR * pchDest; 	// Destination buffer
				int cchDestMax;		// Size of destination buffer
				TCHAR chEndScan;
				const TCHAR * pchEndScan = NULL;
	
				// Find out the ending character(s)
				if (*pchFmt == '%')
					{
					switch (*(pchFmt+1))
						{
					case 'd':
					case 'u':
					case 'i':
						pchEndScan = szDecimalDigits;
						chEndScan = '\0';
						break;
					case 'v':	// %v
						pchEndScan = szSpcTab;
						chEndScan = *(pchFmt+2);
						break;
					case 'V':	// %V
						pchEndScan = szWhiteSpaces;
						chEndScan = *(pchFmt+2);
						break;
					case '%':	// %%
						chEndScan = '%';
					default:
						Assert(FALSE);	// Ambiguous compound format (not supported anyway!)
						} // switch
					}
				else
					{
					chEndScan = *pchFmt;
					} // if...else
				
				pSFI->cArgParsed++;
				pchDest = (TCHAR *)va_arg(arglist, TCHAR *);
                if (pchDest != NULL)
                    {
    				cchDestMax = va_arg(arglist, int) - 1;
	    			// Verify if the size of destination buffer
		    		// is a valid size.
			    	// Otherwise, this may be the address of the
				    // next argument
    				Assert(cchDestMax > 0 && cchDestMax < 5000);

	    			while (cchDestMax-- > 0)
		    			{
						if (*pSFI->pchSrcStop == chEndScan)
							break;
						else if (*pSFI->pchSrcStop == '\0')
							break;
						else if (pchEndScan != NULL)
							{
							if (strchrT(pchEndScan, *pSFI->pchSrcStop))
								break;
							} // if...else
						// Copy the character into destination buffer
			    		*pchDest++ = *pSFI->pchSrcStop++;
				    	}
		    		*pchDest = '\0';
                    } // if
				// Skip the characters until reaching either end character
				while (TRUE)
					{
						if (*pSFI->pchSrcStop == chEndScan)
							break;
						else if (*pSFI->pchSrcStop == '\0')
							break;
						else if (pchEndScan != NULL)
							{
							if (strchrT(pchEndScan, *pSFI->pchSrcStop))
								break;
							} // if...else
					pSFI->pchSrcStop++;
					} // while
				}
				break; // "%s"

			default:
				// Unknown "%?" format
				Assert(FALSE);
				pSFI->pchSrcStop--;


				} // switch
			break; // case '%'

		default:
			if (*(pchFmt-1) != *pSFI->pchSrcStop++)
				{
				pSFI->pchSrcStop--;
				pSFI->nErrCode = SF_errTemplateMismatch;
				return FALSE;
				}
			} // switch

		} // while

	return TRUE;
	} // FScanf()


/////////////////////////////////////////////////////////////////////
//	Query the a registry key of type REG_SZ without trowing an exception.
//
BOOL
RegKey_FQueryString(
	HKEY hKey,
	LPCTSTR pszValueName,		// IN: Name of the key
	CString& rstrKeyData)		// OUT: Value (data) of registry key
	{
	Assert(hKey != NULL);
	Assert(pszValueName != NULL);

	TCHAR szBufferT[4096];
	DWORD cbBufferLength = sizeof(szBufferT);
	DWORD dwType;
	DWORD dwErr;

	dwErr = ::RegQueryValueEx(
		hKey,
		pszValueName,
		0,
		OUT &dwType,
		OUT (BYTE *)szBufferT,
		INOUT &cbBufferLength);
	if ((dwErr == ERROR_SUCCESS) && (dwType == REG_SZ))
		{
		rstrKeyData = szBufferT;	// Copy the string
		return TRUE;
		}
	else
		{
		rstrKeyData.Empty();
		return FALSE;
		}
	} // RegKey_FQueryString()

#endif 	// SNAPIN_PROTOTYPER


DWORD DisplayNameHelper(
		HWND hwndParent,
		BSTR pszMachineName,
		BSTR pszServiceName,
		DWORD dwDesiredAccess,
		SC_HANDLE* phSC,
		BSTR* pbstrServiceDisplayName)
{
	*phSC = ::OpenSCManager(
		pszMachineName,
		NULL,
		SC_MANAGER_CONNECT);
	if (NULL == *phSC)
	{
		DWORD dwErr = ::GetLastError();
		ASSERT( NO_ERROR != dwErr );
		return dwErr;
	}

	SC_HANDLE hService = ::OpenService(
		*phSC,
		pszServiceName,
		dwDesiredAccess | SERVICE_QUERY_CONFIG);
	if (NULL == hService)
	{
		DWORD dwErr = ::GetLastError();
		ASSERT( NO_ERROR != dwErr );
		::CloseServiceHandle(*phSC);
		*phSC = NULL;
		return dwErr;
	}

	union
		{
		// Service config
		QUERY_SERVICE_CONFIG qsc;
		BYTE rgbBufferQsc[SERVICE_cbQueryServiceConfigMax];
		};
	::ZeroMemory(&qsc, max(sizeof(qsc), sizeof(rgbBufferQsc)));
	DWORD cbBytesNeeded = 0;
	if (!::QueryServiceConfigW(
			hService,
			OUT &qsc,
			max(sizeof(qsc), sizeof(rgbBufferQsc)),
			OUT &cbBytesNeeded))
	{
		DWORD dwErr = ::GetLastError();
		ASSERT( NO_ERROR != dwErr );
		::CloseServiceHandle(hService);
		::CloseServiceHandle(*phSC);
		*phSC = NULL;
		return dwErr;
	}

	*pbstrServiceDisplayName = ::SysAllocString(
		(qsc.lpDisplayName && qsc.lpDisplayName[0])
			? qsc.lpDisplayName
			: pszServiceName);
	if (NULL == *pbstrServiceDisplayName)
	{
		::CloseServiceHandle(hService);
		::CloseServiceHandle(*phSC);
		*phSC = NULL;
		return E_OUTOFMEMORY;
	}

	::CloseServiceHandle(hService);
	return NO_ERROR;
}

HRESULT CStartStopHelper::StartServiceHelper(
		HWND hwndParent,
		BSTR pszMachineName,
		BSTR pszServiceName,
		DWORD dwNumServiceArgs,
		BSTR * lpServiceArgVectors)
{
	MFC_TRY;

	if (   (   (NULL != pszMachineName)
	        && ::IsBadStringPtr(pszMachineName,0x7FFFFFFF))
		|| ::IsBadStringPtr(pszServiceName,0x7FFFFFFF))
	{
		ASSERT(FALSE);
		return E_POINTER;
	}
	if (0 < dwNumServiceArgs)
	{
		if (::IsBadReadPtr(lpServiceArgVectors,sizeof(lpServiceArgVectors)))
		{
			ASSERT(FALSE);
			return E_POINTER;
		}
		for (DWORD i = 0; i < dwNumServiceArgs; i++)
		{
			if (   (NULL != lpServiceArgVectors[i])
				&& ::IsBadStringPtr(lpServiceArgVectors[i],0x7FFFFFFF))
			{
				ASSERT(FALSE);
				return E_POINTER;
			}
		}
	}

	SC_HANDLE hScManager = NULL;
	CComBSTR sbstrServiceDisplayName;

	DWORD dwErr = DisplayNameHelper(
		hwndParent,
		pszMachineName,
		pszServiceName,
		SERVICE_START,
		&hScManager,
		&sbstrServiceDisplayName);
	if (NO_ERROR != dwErr)
	{
		(void) DoServicesErrMsgBox(
			hwndParent,
			MB_OK | MB_ICONSTOP,
			dwErr,
			IDS_MSG_sss_UNABLE_TO_START_SERVICE,
			pszServiceName,
			(pszMachineName && pszMachineName[0])
				? pszMachineName : (LPCTSTR)g_strLocalMachine,
			L"");
	}
	else
	{
		dwErr = CServiceControlProgress::S_EStartService(
			hwndParent,
			hScManager,
			pszMachineName,
			pszServiceName,
			sbstrServiceDisplayName,
			dwNumServiceArgs,
			(LPCTSTR *)lpServiceArgVectors);
	}

	if (NULL != hScManager)
		(void) ::CloseServiceHandle( hScManager );

	switch (dwErr)
	{
	case CServiceControlProgress::errUserCancelStopDependentServices:
	case CServiceControlProgress::errCannotInitialize:
	case CServiceControlProgress::errUserAbort:
		return S_FALSE;
	default:
		break;
	}
	return HRESULT_FROM_WIN32(dwErr);

	MFC_CATCH;
}

HRESULT CStartStopHelper::ControlServiceHelper(
		HWND hwndParent,
		BSTR pszMachineName,
		BSTR pszServiceName,
		DWORD dwControlCode)
{
	MFC_TRY;

	if (   (   (NULL != pszMachineName)
	        && ::IsBadStringPtr(pszMachineName,0x7FFFFFFF))
		|| ::IsBadStringPtr(pszServiceName,0x7FFFFFFF))
	{
		ASSERT(FALSE);
		return E_POINTER;
	}

	SC_HANDLE hScManager = NULL;
	CComBSTR sbstrServiceDisplayName;
	DWORD dwDesiredAccess = SERVICE_USER_DEFINED_CONTROL;
	UINT idErrorMessageTemplate = IDS_MSG_sss_UNABLE_TO_STOP_SERVICE; // CODEWORK
	switch (dwControlCode)
	{
	case SERVICE_CONTROL_STOP:
		idErrorMessageTemplate = IDS_MSG_sss_UNABLE_TO_STOP_SERVICE;
		dwDesiredAccess = SERVICE_STOP;
		break;
	case SERVICE_CONTROL_PAUSE:
		idErrorMessageTemplate = IDS_MSG_sss_UNABLE_TO_PAUSE_SERVICE;
		dwDesiredAccess = SERVICE_PAUSE_CONTINUE;
		break;
	case SERVICE_CONTROL_CONTINUE:
		idErrorMessageTemplate = IDS_MSG_sss_UNABLE_TO_RESUME_SERVICE;
		dwDesiredAccess = SERVICE_PAUSE_CONTINUE;
		break;
	default:
		break;
	}

	DWORD dwErr = DisplayNameHelper(
		hwndParent,
		pszMachineName,
		pszServiceName,
		dwDesiredAccess,
		&hScManager,
		&sbstrServiceDisplayName);
	if (NO_ERROR != dwErr)
	{
		(void) DoServicesErrMsgBox(
			hwndParent,
			MB_OK | MB_ICONSTOP,
			dwErr,
			idErrorMessageTemplate,
			pszServiceName,
			(pszMachineName && pszMachineName[0])
				? pszMachineName : (LPCTSTR)g_strLocalMachine,
			L"");
	}
	else
	{
		dwErr = CServiceControlProgress::S_EControlService(
			hwndParent,
			hScManager,
			pszMachineName,
			pszServiceName,
			sbstrServiceDisplayName,
			dwControlCode);
	}

	if (NULL != hScManager)
		(void) ::CloseServiceHandle( hScManager );

	switch (dwErr)
	{
	case CServiceControlProgress::errUserCancelStopDependentServices:
	case CServiceControlProgress::errCannotInitialize:
	case CServiceControlProgress::errUserAbort:
		return S_FALSE;
	default:
		break;
	}
	return HRESULT_FROM_WIN32(dwErr);

	MFC_CATCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\filemgmt\wraps.cpp ===
//
// wraps.cpp - wrapper functions for apis
//

#include "stdafx.h"
#include "cmponent.h"

#define DONT_WANT_SHELLDEBUG
#include "shlobjp.h"     // LPITEMIDLIST

#if _WIN32_IE >= 0x0400

//
// Wrapper unnecessary for WIN64
//

#else

//
// We need this wrapper for ILCreateFromPath since it was a TCHAR exported by ordinal
// on NT4 and now has A/W versions on NT5. Since we want to be able to run on both of
// these platforms we wrap the API here.
//
// This api just loads shell32, and calls ordinal 157 which is the old TCHAR export
//
typedef LPITEMIDLIST (__stdcall *PFNILCREATEFROMPATH)(LPCTSTR pszPath);

STDAPI_(LPITEMIDLIST) Wrap_ILCreateFromPath(LPCWSTR pszPath)
{
    static PFNILCREATEFROMPATH pfn = (PFNILCREATEFROMPATH)-1;

    if (pfn == (PFNILCREATEFROMPATH)-1)
    {
        HINSTANCE hinst = LoadLibrary(TEXT("shell32.dll"));

        if (hinst)
        {
            pfn = (PFNILCREATEFROMPATH) GetProcAddress(hinst, (LPCSTR)157);
        }
        else
        {
            pfn = NULL;
        }
    }

    if (pfn)
    {
        return pfn(pszPath);
    }
    
    // If we failed for some reason, just return NULL
    return NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\filemgmt\svcutils.h ===
//	SvcUtils.h

#include "stdutils.h" // FCompareMachineNames

// Help file for filemgmt.dll
const TCHAR g_szHelpFileFilemgmt[] = _T("filemgmt.hlp");	// Not subject to localization


// This enumeration should not be changed unless the string resources
// and all the array indices updated.
enum
	{
	iServiceActionNil = -1,
	iServiceActionStart,		// Start service
	iServiceActionStop,			// Stop service
	iServiceActionPause,		// Pause service
	iServiceActionResume,		// Resume service
	iServiceActionRestart,		// Stop and Start service

	iServiceActionMax			// Must be last
	};

/////////////////////////////////////////////////////////////////////
// String szAbend
// This string is used for the 'Service Failure Recovery' dialog
// to append the 'Fail Count' to the command line.  This string
// is not localized, so it should not be moved into the
// resources.
//
// NOTES
// The variable should be renamed to reflect its content.  Currently
// 'abend' means 'fails'.
const TCHAR szAbend[] = L" /fail=%1%";


//
//	Service running state
//
extern CString g_strSvcStateStarted;
extern CString g_strSvcStateStarting;
extern CString g_strSvcStateStopped;
extern CString g_strSvcStateStopping;
extern CString g_strSvcStatePaused;
extern CString g_strSvcStatePausing;
extern CString g_strSvcStateResuming;

//
//	Service startup type
//
extern CString g_strSvcStartupBoot;
extern CString g_strSvcStartupSystem;
extern CString g_strSvcStartupAutomatic;
extern CString g_strSvcStartupManual;
extern CString g_strSvcStartupDisabled;

//
//	Service startup account
//  JonN 188203 11/13/00
//
extern CString g_strLocalSystem;
extern CString g_strLocalService;
extern CString g_strNetworkService;

extern CString g_strUnknown;
extern CString g_strLocalMachine;


void Service_LoadResourceStrings();

LPCTSTR Service_PszMapStateToName(DWORD dwServiceState, BOOL fLongString = FALSE);

// -1L is blank string
LPCTSTR Service_PszMapStartupTypeToName(DWORD dwStartupType);

// JonN 11/14/00 188203 support LocalService/NetworkService
LPCTSTR Service_PszMapStartupAccountToName(LPCTSTR pcszStartupAccount);

BOOL Service_FGetServiceButtonStatus(
	SC_HANDLE hScManager,
	CONST TCHAR * pszServiceName,
	OUT BOOL rgfEnableButton[iServiceActionMax],
	OUT DWORD * pdwCurrentState = NULL,
	BOOL fSilentError = FALSE);

void Service_SplitCommandLine(
	LPCTSTR pszFullCommand,
	CString * pstrBinaryPath,
	CString * pstrParameters,
	BOOL * pfAbend = NULL);

void Service_UnSplitCommandLine(
	CString * pstrFullCommand,
	LPCTSTR pszBinaryPath,
	LPCTSTR pszParameters);

void GetMsg(OUT CString& strMsg, DWORD dwErr, UINT wIdString = 0, ...);

// title is "Shared Folders"
INT DoErrMsgBox(HWND hwndParent, UINT uType, DWORD dwErr, UINT wIdString = 0, ...);

// title is "Services"
INT DoServicesErrMsgBox(HWND hwndParent, UINT uType, DWORD dwErr, UINT wIdString = 0, ...);

BOOL UiGetUser(
	HWND hwndOwner,
	BOOL fIsContainer,
	LPCTSTR pszServerName,
	IN OUT CString& strrefUser);

// Help Support
#define HELP_DIALOG_TOPIC(DialogName)	g_aHelpIDs_##DialogName

BOOL DoHelp(LPARAM lParam, const DWORD rgzHelpIDs[]);
BOOL DoContextHelp(WPARAM wParam, const DWORD rgzHelpIDs[]);


#ifdef SNAPIN_PROTOTYPER
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
class CStringIterator
{
  private:
	CString m_strData;		// Data string to parse
	CONST TCHAR * m_pszDataNext;	// Pointer to the next data to parse

  public:
	CStringIterator()
		{
		m_pszDataNext = m_strData;
		}

	void SetString(CONST TCHAR * pszStringData)
		{
		m_strData = pszStringData;
		m_pszDataNext = m_strData;
		}

	BOOL FGetNextString(OUT CString& rStringOut)
		{
		Assert(m_pszDataNext != NULL);

		if (*m_pszDataNext == '\0')
			{
			rStringOut.Empty();
			return FALSE;
			}
		CONST TCHAR * pchStart = m_pszDataNext;
		while (*m_pszDataNext != '\0')
			{
			if (*m_pszDataNext == ';')
				{
				// HACK: Truncating the string
				*(TCHAR *)m_pszDataNext++ = '\0';
				break;
				}
			m_pszDataNext++;
			}
		rStringOut = pchStart;	// Copy the string
		return TRUE;
		}
}; // CStringIterator

#endif // SNAPIN_PROTOTYPER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\filemgmt\wraps.h ===
// wraps.h: prototypes for wrapped headers

#ifndef __WRAPS_H_INCLUDED__
#define __WRAPS_H_INCLUDED__

#if !defined(_WIN64)
STDAPI_(LPITEMIDLIST) Wrap_ILCreateFromPath(LPCTSTR pszPath);
#endif


#endif // ~__WRAPS_H_INCLUDED__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\framewrk\islocal.cpp ===
/////////////////////////////////////////////////////////////////////
//	IsLocal.cpp
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//
//	Determines whether a computername is the local computer
//
//
//	HISTORY
//	09-Jan-1999		jonn  		Creation.
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "dns.h"
#include <winsock.h>
#include "stdutils.h"

#if _WIN32_WINNT < 0x0500
//
// CODEWORK This was taken from winbase.h.  MFC requires _WIN32_WINNT=0x4000 whereas
// winbase.h only includes this for _WIN32_WINNT=0x5000.  JonN 1/14/99
//
extern "C" {
typedef enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
} COMPUTER_NAME_FORMAT ;
WINBASEAPI
BOOL
WINAPI
GetComputerNameExA (
    IN COMPUTER_NAME_FORMAT NameType,
    OUT LPSTR lpBuffer,
    IN OUT LPDWORD nSize
    );
WINBASEAPI
BOOL
WINAPI
GetComputerNameExW (
    IN COMPUTER_NAME_FORMAT NameType,
    OUT LPWSTR lpBuffer,
    IN OUT LPDWORD nSize
    );
#ifdef UNICODE
#define GetComputerNameEx  GetComputerNameExW
#else
#define GetComputerNameEx  GetComputerNameExA
#endif // !UNICODE
} // extern "C"

#endif


// CODEWORK never freed
LPTSTR g_ptzComputerName = NULL;
LPTSTR g_ptzDnsComputerName = NULL;

/////////////////////////////////////////////////////////////////////
//	IsLocalComputername()
//
BOOL
IsLocalComputername( IN LPCTSTR pszMachineName )
{
	if ( NULL == pszMachineName || L'\0' == pszMachineName[0] )
		return TRUE;

	if ( L'\\' == pszMachineName[0] && L'\\' == pszMachineName[1] )
		pszMachineName += 2;

	// compare with the local computer name
	if ( NULL == g_ptzComputerName )
	{
		TCHAR achComputerName[ MAX_COMPUTERNAME_LENGTH+1 ];
		DWORD dwSize = sizeof(achComputerName)/sizeof(TCHAR);
		if ( !GetComputerName( achComputerName, &dwSize ) )
		{
			ASSERT(FALSE);
		}
		else
		{
			g_ptzComputerName = SysAllocString( achComputerName );
			ASSERT( NULL != g_ptzComputerName );
		}
	}
	if ( NULL != g_ptzComputerName && 0 == _tcsicmp( pszMachineName, g_ptzComputerName ) )
	{
		return TRUE;
	}

	// compare with the local DNS name
  // SKwan confirms that ComputerNameDnsFullyQualified is the right name to use
  // when clustering is taken into account
	if ( NULL == g_ptzDnsComputerName )
	{
		TCHAR achDnsComputerName[DNS_MAX_NAME_BUFFER_LENGTH];
		DWORD dwSize = sizeof(achDnsComputerName)/sizeof(TCHAR);
		if ( !GetComputerNameEx(
			ComputerNameDnsFullyQualified,
			achDnsComputerName,
			&dwSize ) )
		{
			ASSERT(FALSE);
		}
		else
		{
			g_ptzDnsComputerName = SysAllocString( achDnsComputerName );
			ASSERT( NULL != g_ptzDnsComputerName );
		}
	}
	if ( NULL != g_ptzDnsComputerName && 0 == _tcsicmp( pszMachineName, g_ptzDnsComputerName ) )
	{
		return TRUE;
	}

  /*
	// compare with alternate DNS names
	do {
		hostent* phostent = gethostbyname( NULL );
		if (NULL == phostent)
			break;
		USES_CONVERSION;
		char** ppaliases = phostent->h_aliases;
		for ( ; *ppaliases != NULL; ppaliases++ )
		{
			TCHAR* ptsz = A2OLE(*ppaliases);
			if (0 == _tcsicmp( pszMachineName, ptsz ))
			{
				return TRUE;
			}
		}
		// these are IP addresses, not strings
		// char** ppaddresses = phostent->h_addr_list;
		// for ( ; *ppaddresses != NULL; ppaliases++ )
		// {
		// 	TCHAR* ptsz = A2OLE(*ppaddresses);
		// 	if (0 == _tcsicmp( pszMachineName, ptsz ))
		// 	{
		// 		return TRUE;
		// 	}
		// }
	} while (false); // false loop
	*/

	return FALSE;

} // IsLocalComputername()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\filemgmt\utils.h ===
/////////////////////////////////////////////////////////////////////
//
//	Utils.h
//
//	General-purpose windows utilities routines.
//
//	HISTORY
//	t-danmo		96.09.22	Creation.
//
/////////////////////////////////////////////////////////////////////

#ifndef __UTILS_H__
#define __UTILS_H__

extern HINSTANCE g_hInstanceSave;  // Instance handle of the DLL (initialized during CFileMgmtComponent::Initialize)

HRESULT 
GetErrorMessage(
  IN  DWORD        i_dwError,
  OUT CString&     cstrErrorMsg
);

void mystrtok(
    IN LPCTSTR  pszString,
    IN OUT int* pnIndex,  // start from 0
    IN LPCTSTR  pszCharSet,
    OUT CString& strToken
    );

BOOL IsInvalidSharename(LPCTSTR psz);

/////////////////////////////////////////////////////////////////////
//	Structure used to add items to a listbox or combobox.
//
struct TStringParamEntry	// spe
	{
	UINT uStringId;		// Id of the resource string
	LPARAM lItemData;	// Optional parameter for the string (stored in lParam field)
	};


void ComboBox_FlushContent(HWND hwndCombo);

BOOL ComboBox_FFill(
	const HWND hwndCombo,				// IN: Handle of the combobox
	const TStringParamEntry rgzSPE[],	// IN: SPE aray zero terminated
	const LPARAM lItemDataSelect);		// IN: Which item to select

LPARAM ComboBox_GetSelectedItemData(HWND hwndComboBox);

HWND HGetDlgItem(HWND hdlg, INT nIdDlgItem);

void SetDlgItemFocus(HWND hdlg, INT nIdDlgItem);

void EnableDlgItem(HWND hdlg, INT nIdDlgItem, BOOL fEnable);

void EnableDlgItemGroup(
	HWND hdlg,
	const UINT rgzidCtl[],
	BOOL fEnable);

void ShowDlgItemGroup(
	HWND hdlg,
	const UINT rgzidCtl[],
	BOOL fShowAll);

TCHAR * Str_PchCopyChN(
	TCHAR * szDst,			// OUT: Destination buffer
	CONST TCHAR * szSrc,	// IN: Source buffer
	TCHAR chStop,			// IN: Character to stop the copying
	INT cchDstMax);			// IN: Length of the output buffer

INT Str_SubstituteStrStr(
	TCHAR * szDst,				// OUT: Destination buffer
	CONST TCHAR * szSrc,		// IN: Source buffer
	CONST TCHAR * szToken,		// IN: Token to find
	CONST TCHAR * szReplace);	// IN: Token to replace

TCHAR * PchParseCommandLine(
	CONST TCHAR szFullCommand[],	// IN: Full command line
	TCHAR szBinPath[],				// OUT: Path of the executable binary
	INT cchBinPathBuf);				// IN: Size of the buffer

void TrimString(CString& rString);

/////////////////////////////////////////////////////////////////////
struct TColumnHeaderItem
	{
	UINT uStringId;		// Resource Id of the string
	INT nColWidth;		// % of total width of the column (0 = autowidth, -1 = fill rest of space)
	};

void ListView_AddColumnHeaders(
	HWND hwndListview,
	const TColumnHeaderItem rgzColumnHeader[]);

int ListView_InsertItemEx(
    HWND hwndListview,
    CONST LV_ITEM * pLvItem);

LPTSTR * PargzpszFromPgrsz(CONST LPCTSTR pgrsz, INT * pcStringCount);

BOOL UiGetFileName(HWND hwnd, TCHAR szFileName[], INT cchBufferLength);

//
//	Printf-type functions
//
TCHAR * PaszLoadStringPrintf(UINT wIdString, va_list arglist);
void LoadStringPrintf(UINT wIdString, CString * pString, ...);
void SetWindowTextPrintf(HWND hwnd, UINT wIdString, ...);

// If you are looking for MsgBoxPrintf() for slate, go
// take a look at DoErrMsgBox()/DoServicesErrMsgBox() in svcutils.h

// Function LoadStringWithInsertions() is exactly LoadStringPrintf()
#define LoadStringWithInsertions	LoadStringPrintf

#ifdef SNAPIN_PROTOTYPER

///////////////////////////////////////
struct TParseIntegerInfo	// pi
	{
	int nFlags;				// IN: Parsing flags
	const TCHAR * pchSrc;	// IN: Source string
	const TCHAR * pchStop;	// OUT: Pointer to where the parsing stopped
	int nErrCode;			// OUT: Error code
	UINT uData;				// OUT: Integer value
	UINT uRangeBegin;		// IN: Lowest value for range checking
	UINT uRangeEnd;			// IN: Highest value for range checking (inclusive)
	};

#define PI_mskfDecimalBase		0x0000 // Use decimal base (default)
#define PI_mskfHexBaseOnly      0x0001 // Use hexadecimal base only
#define PI_mskfAllowHexBase     0x0002 // Look for a 0x prefix and select the appropriate base
#define PI_mskfAllowRandomTail  0x0010 // Stop parsing as soon as you reach a non-digit character without returning an error
#define PI_mskfNoEmptyString	0x0020 // Interpret an empty string as an error instead of the value zero
#define PI_mskfNoMinusSign		0x0040 // Interpret the minus sign as an error
#define PI_mskfSingleEntry		0x0080 // Return an error if there are more than one integer
#define PI_mskfCheckRange		0x0100 // NYI: Use uRangeBegin and uRangeEnd to validate uData

#define PI_mskfSilentParse		0x8000 // NYI: Used only when calling GetWindowInteger()

#define PI_errOK                0  // No error
#define PI_errIntegerOverflow   1  // Integer too large
#define PI_errInvalidInteger    2  // String is not a valid integer (typically an invalid digit)
#define PI_errEmptyString       3  // Empty string found while not allowed
#define PI_errMinusSignFound	4  // The number was negative

BOOL FParseInteger(INOUT TParseIntegerInfo * pPI);

///////////////////////////////////////
typedef struct _SCANF_INFO	// Scanf info structure (sfi)
	{
	const TCHAR * pchSrc;  		// IN: Source string to be parsed
	const TCHAR * pchSrcStop;	// OUT: Pointer to where the parsing stopped
	int nErrCode;         		// OUT: Error code
	int cArgParsed;       		// OUT: Number of argument parsed
	} SCANF_INFO;

#define SF_errInvalidFormat		(-1)	// Illegal format
#define SF_errOK                 0		// No error parsing
#define SF_errTemplateMismatch   1		// Source string do not match with template string pchFmt

///////////////////////////////////////////////////////////
BOOL FScanf(INOUT SCANF_INFO * pSFI, IN const TCHAR * pchFmt, OUT ...);

BOOL RegKey_FQueryString(
	HKEY hKey,
	LPCTSTR pszValueName,
	CString& rstrKeyData);

#endif // SNAPIN_PROTOTYPER

class CStartStopHelper : public CComObjectRoot,
    public ISvcMgmtStartStopHelper,
	public CComCoClass<CStartStopHelper, &CLSID_SvcMgmt>
{
BEGIN_COM_MAP(CStartStopHelper)
        COM_INTERFACE_ENTRY(ISvcMgmtStartStopHelper)
END_COM_MAP()

public:
//  CStartStopHelper () {}
//  ~CStartStopHelper () {}

DECLARE_AGGREGATABLE(CStartStopHelper)
DECLARE_REGISTRY(CStartStopHelper, _T("SVCMGMT.StartStopObject.1"), _T("SVCMGMT.StartStopObject.1"), IDS_SVCVWR_DESC, THREADFLAGS_BOTH)

    STDMETHOD(StartServiceHelper)(
			HWND hwndParent,
			BSTR pszMachineName,
			BSTR pszServiceName,
			DWORD dwNumServiceArgs,
			BSTR * lpServiceArgVectors );

    STDMETHOD(ControlServiceHelper)(
			HWND hwndParent,
			BSTR pszMachineName,
			BSTR pszServiceName,
			DWORD dwControlCode );
};

DEFINE_GUID(IID_ISvcMgmtStartStopHelper,0xF62DEC25,0xE3CB,0x4D45,0x9E,0x98,0x93,0x3D,0xB9,0x5B,0xCA,0xEA);


#endif // ~__UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\framewrk\dynamlnk.cpp ===
// DynamLnk.cpp : base class for DLLs which are loaded only when needed

#include "stdafx.h"
#include "DynamLnk.h"

DynamicDLL::DynamicDLL(LPCTSTR ptchLibraryName, LPCSTR* apchFunctionNames)
: m_hLibrary( (HMODULE)-1 ),
  m_apfFunctions( NULL ),
  m_ptchLibraryName( ptchLibraryName ),
  m_apchFunctionNames( apchFunctionNames ),
  m_nNumFunctions( 0 )
{
	ASSERT( !IsBadStringPtr(m_ptchLibraryName,MAX_PATH) );
	ASSERT( NULL != apchFunctionNames );
	for (LPCSTR pchFunctionName = *apchFunctionNames;
	     NULL != pchFunctionName;
		 pchFunctionName = *(++apchFunctionNames) )
	{
		m_nNumFunctions++;
		ASSERT( !IsBadStringPtrA(pchFunctionName,MAX_PATH) );
	}
}

DynamicDLL::~DynamicDLL()
{
	if (NULL != m_apfFunctions)
	{
		delete m_apfFunctions;
		m_apfFunctions = NULL;
	}
	if ((HMODULE)-1 != m_hLibrary && NULL != m_hLibrary)
	{
		VERIFY( ::FreeLibrary( m_hLibrary ) );
		m_hLibrary = NULL;
	}
}

BOOL DynamicDLL::LoadFunctionPointers()
{
	if ((HMODULE)-1 != m_hLibrary)
		return (NULL != m_hLibrary);

	m_hLibrary = ::LoadLibrary( m_ptchLibraryName );
	if (NULL == m_hLibrary)
	{
		// The library is not present
		return FALSE;
	}

	// let this throw an exception
	m_apfFunctions = new FARPROC[m_nNumFunctions];

	for (INT i = 0; i < m_nNumFunctions; i++)
	{
		m_apfFunctions[i] = ::GetProcAddress( m_hLibrary, m_apchFunctionNames[i] );
		if ( NULL == m_apfFunctions[i] )
		{
			// The library is present but does not have all of the entrypoints
			VERIFY( ::FreeLibrary( m_hLibrary ) );
			m_hLibrary = NULL;
			return FALSE;
		}
	}

	return TRUE;
}


FARPROC DynamicDLL::QueryFunctionPtr(INT i) const
{
	if ( 0 > i || m_nNumFunctions <= i || NULL == m_apfFunctions || NULL == m_apfFunctions[i] )
	{
		ASSERT( FALSE );
		return NULL;
	}
	return m_apfFunctions[i];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\framewrk\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED_)
#define AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>
#include <afxtempl.h> // CTypedPtrList
#include <afxdlgs.h>  // CPropertyPage

// #define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

// #include "dbg.h"
#include "mmc.h"

EXTERN_C const CLSID CLSID_MyComputer;

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\framewrk\inc\dynamlnk.h ===
// DynamLnk.h : Base class for DLLs which are loaded only when needed

#ifndef __DYNAMLNK_H_INCLUDED__
#define __DYNAMLNK_H_INCLUDED__

class DynamicDLL
{
public:
	// These strings must remain unchanged until the FileServiceProvider is released
	DynamicDLL(LPCTSTR ptchLibraryName, LPCSTR* apchFunctionNames);
	virtual ~DynamicDLL();

	BOOL LoadFunctionPointers();

	FARPROC QueryFunctionPtr(INT i) const;
	inline FARPROC operator[] (INT i) const
		{ return QueryFunctionPtr(i); }

private:
	HMODULE m_hLibrary;
	FARPROC* m_apfFunctions;
	LPCTSTR m_ptchLibraryName;
	LPCSTR* m_apchFunctionNames;
	INT m_nNumFunctions;
};
#endif // ~__DYNAMLNK_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\framewrk\snapreg.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       SnpInReg.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11/10/1998 JonN    Created
//
//____________________________________________________________________________


#include "stdafx.h"
#pragma hdrstop
#include "..\corecopy\regkey.h"
#include "snapreg.h"
#include "stdutils.h" // g_aNodetypeGUIDs


HRESULT RegisterNodetypes(
	AMC::CRegKey& regkeyParent,
	int* aiNodetypeIndexes,
	int  cNodetypeIndexes )
{
	try
	{
		AMC::CRegKey regkeyNodeTypes;
		regkeyNodeTypes.CreateKeyEx( regkeyParent, _T("NodeTypes") );
		AMC::CRegKey regkeyNodeType;
		for (int i = 0; i < cNodetypeIndexes; i++)
		{
			regkeyNodeType.CreateKeyEx(
				regkeyNodeTypes,
				g_aNodetypeGuids[aiNodetypeIndexes[i]].bstr );
			regkeyNodeType.CloseKey();
		}
	}
	catch (COleException* e)
	{
		ASSERT(FALSE);
        e->Delete();
		return SELFREG_E_CLASS;
    }
	return S_OK;
}


HRESULT RegisterSnapin(
	AMC::CRegKey& regkeySnapins,
	LPCTSTR pszSnapinGUID,
	BSTR bstrPrimaryNodetype,
	UINT residSnapinName,
	UINT residProvider,
	UINT residVersion,
	bool fStandalone,
	LPCTSTR pszAboutGUID,
	int* aiNodetypeIndexes,
	int  cNodetypeIndexes )
{
	HRESULT hr = S_OK;
	try
	{
		AMC::CRegKey regkeySnapin;
		CString strSnapinName, strProvider, strVersion;
		if (   !strSnapinName.LoadString(residSnapinName)
			|| !strProvider.LoadString(residProvider)
			|| !strVersion.LoadString(residVersion)
		   )
		{
			ASSERT(FALSE);
			return SELFREG_E_CLASS;
		}
		regkeySnapin.CreateKeyEx( regkeySnapins, pszSnapinGUID );
		if (NULL != bstrPrimaryNodetype)
		{
			regkeySnapin.SetString( _T("NodeType"), bstrPrimaryNodetype );
		}
		regkeySnapin.SetString( _T("NameString"), strSnapinName );
		regkeySnapin.SetString( _T("Provider"), strProvider );
		regkeySnapin.SetString( _T("Version"), strVersion );
		if (fStandalone)
		{
			AMC::CRegKey regkeyStandalone;
			regkeyStandalone.CreateKeyEx( regkeySnapin, _T("StandAlone") );
		}
		if (NULL != pszAboutGUID)
		{
			regkeySnapin.SetString( _T("About"), pszAboutGUID );
		}
		if ( NULL != aiNodetypeIndexes && 0 != cNodetypeIndexes )
		{
			hr = RegisterNodetypes(
				regkeySnapin,
				aiNodetypeIndexes,
				cNodetypeIndexes );
		}

		//
		// JonN 4/25/00
		// 100624: MUI: MMC: Shared Folders snap-in stores
		//         its display information in the registry
		//
		// MMC now supports NameStringIndirect
		//
		TCHAR achModuleFileName[MAX_PATH+20];
		if (0 < ::GetModuleFileName(
		             AfxGetInstanceHandle(),
		             achModuleFileName,
		             sizeof(achModuleFileName)/sizeof(TCHAR) ))
		{
			CString strNameIndirect;
			strNameIndirect.Format( _T("@%s,-%d"),
			                        achModuleFileName,
			                        residSnapinName );
			regkeySnapin.SetString( _T("NameStringIndirect"),
			                        strNameIndirect );
		}
	}
	catch (COleException* e)
	{
		ASSERT(FALSE);
        e->Delete();
		return SELFREG_E_CLASS;
    }
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\framewrk\inc\snapreg.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       SnpInReg.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11/10/1998 JonN    Created
//
//____________________________________________________________________________


#ifndef _SNPINREG_H_
#define _SNPINREG_H_

HRESULT RegisterSnapin(
	AMC::CRegKey& regkeySnapins,
	LPCTSTR pszSnapinGUID,
	BSTR bstrPrimaryNodetype,
	UINT residSnapinName,
	UINT residProvider,
	UINT residVersion,
	bool fStandalone,
	LPCTSTR pszAboutGUID,
	int* aiNodetypeIndexes,
	int  cNodetypeIndexes );

#endif // _SNPINREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\framewrk\inc\persist.h ===
// persist.h : Declaration of PersistStorage and PersistStream

#ifndef __PERSIST_H_INCLUDED__
#define __PERSIST_H_INCLUDED__

class PersistStorage : public IPersistStorage
{
public:
	STDMETHOD(GetClassID)(CLSID __RPC_FAR * pClassID)
	{
        UNREFERENCED_PARAMETER (pClassID);
		return E_NOTIMPL;
	}

    STDMETHOD(IsDirty)()
	{
		return (m_fDirty) ? S_OK : S_FALSE;
	}

    STDMETHOD(InitNew)(IStorage __RPC_FAR * pStg)
	{
        UNREFERENCED_PARAMETER (pStg);
		return S_OK;
	}

    STDMETHOD(Load)(IStorage __RPC_FAR * pStg)
	{
        UNREFERENCED_PARAMETER (pStg);
		return S_OK;
	}

    STDMETHOD(Save)(IStorage __RPC_FAR * pStgSave, BOOL fSameAsLoad)
	{
        UNREFERENCED_PARAMETER (pStgSave);
        UNREFERENCED_PARAMETER (fSameAsLoad);
		return S_OK;
	}

    STDMETHOD(SaveCompleted)(IStorage __RPC_FAR * pStgNew)
	{
        UNREFERENCED_PARAMETER (pStgNew);
		return S_OK;
	}

    STDMETHOD(HandsOffStorage)()
	{
		return S_OK;
	}

	void SetDirty( BOOL fDirty = TRUE ) { m_fDirty = fDirty; }

	BOOL m_fDirty;

	PersistStorage::PersistStorage() : m_fDirty( FALSE ) {}

}; // class PersistStorage

class PersistStream : public IPersistStream
{
public:
	STDMETHOD(GetClassID)(CLSID __RPC_FAR * pClassID)
	{
        UNREFERENCED_PARAMETER (pClassID);
		return E_NOTIMPL;
	}

    STDMETHOD(IsDirty)()
	{
		return (m_fDirty) ? S_OK : S_FALSE;
	}

    STDMETHOD(Load)(IStorage __RPC_FAR * pStg)
	{
	    UNREFERENCED_PARAMETER (pStg);	
        return S_OK;
	}

    STDMETHOD(Save)(IStorage __RPC_FAR * pStgSave, BOOL fSameAsLoad)
	{
        UNREFERENCED_PARAMETER (pStgSave);
        UNREFERENCED_PARAMETER (fSameAsLoad);
		return S_OK;
	}

    STDMETHOD(GetSizeMax)(ULARGE_INTEGER __RPC_FAR *pcbSize)
	{
		ASSERT(pcbSize);
		if (!pcbSize)
			return E_INVALIDARG;
		::memset(pcbSize, 0, sizeof(*pcbSize));
		return S_OK;
	}

	void SetDirty( BOOL fDirty = TRUE ) { m_fDirty = fDirty; }

	BOOL m_fDirty;

	PersistStream::PersistStream() : m_fDirty( FALSE ) {}

}; // class PersistStream

#endif // ~__PERSIST_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\framewrk\stdutils.cpp ===
/////////////////////////////////////////////////////////////////////
//
//	StdUtils.cpp
//
//	Utilities routines for any snapin.
//
//	HISTORY
//	t-danmo		96.10.10	Creation.
//
/////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "stdutils.h"


/////////////////////////////////////////////////////////////////////
//	CompareMachineNames()
//
//	Compare if the strings refer to the same machine (computer).
//
//	Return 0 if both strings map to the same machine, otherwise
//	return -1 or +1 if machine name differs.
//
//	INTERFACE NOTES:
//	An empty string means the local machine.
//
//	HISTORY
//	02-Jun-97	t-danm		Creation.
//	14-Jul-97	t-danm		Comment update.
//	29-Jul-97	t-danm		Renamed from FCompareMachineNames().
//
int
CompareMachineNames(
	LPCTSTR pszMachineName1,
	LPCTSTR pszMachineName2)
	{
	TCHAR szThisMachineName[MAX_COMPUTERNAME_LENGTH + 4];

	BOOL fMachine1IsLocal = (pszMachineName1 == NULL || *pszMachineName1 == '\0');
	BOOL fMachine2IsLocal = (pszMachineName2 == NULL || *pszMachineName2 == '\0');
	if (fMachine1IsLocal)
		pszMachineName1 = szThisMachineName;
	if (fMachine2IsLocal)
		pszMachineName2 = szThisMachineName;
	if (pszMachineName1 == pszMachineName2)
		return 0;
	if (fMachine1IsLocal || fMachine2IsLocal)
		{
		// Get the computer name
		szThisMachineName[0] = _T('\\');
		szThisMachineName[1] = _T('\\');
		DWORD cchBuffer = MAX_COMPUTERNAME_LENGTH + 1;
		VERIFY(::GetComputerName(OUT &szThisMachineName[2], &cchBuffer));
		ASSERT(szThisMachineName[2] != _T('\\') && "Machine name has too many backslashes");
		}
	return lstrcmpi(pszMachineName1, pszMachineName2);
	} // CompareMachineNames()


/////////////////////////////////////////////////////////////////////
//	HrLoadOleString()
//
//	Load a string from the resource and return pointer to allocated
//	OLE string.
//
//	HISTORY
//	29-Jul-97	t-danm		Creation.
//
HRESULT
HrLoadOleString(
	UINT uStringId,					// IN: String Id to load from the resource
	OUT LPOLESTR * ppaszOleString)	// OUT: Pointer to pointer to allocated OLE string
	{
	if (ppaszOleString == NULL)
		{
		TRACE0("HrLoadOleString() - ppaszOleString is NULL.\n");
		return E_POINTER;
		}
	CString strT;		// Temporary string
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Needed for LoadString()
	VERIFY( strT.LoadString(uStringId) );
    *ppaszOleString = reinterpret_cast<LPOLESTR>
            (CoTaskMemAlloc((strT.GetLength() + 1)* sizeof(wchar_t)));
	if (*ppaszOleString == NULL)
		return E_OUTOFMEMORY;
	USES_CONVERSION;
    wcscpy(OUT *ppaszOleString, T2OLE((LPTSTR)(LPCTSTR)strT));
	return S_OK;
	} // HrLoadOleString()

//
// Nodetype utility routines
// aNodetypeGuids must be defined by the subclass
//

int CheckObjectTypeGUID( const BSTR lpszObjectTypeGUID )
{
	ASSERT(NULL != lpszObjectTypeGUID);
	for (	int objecttype = 0;
			objecttype < g_cNumNodetypeGuids;
			objecttype += 1 )
	{
		if ( !::lstrcmpiW(lpszObjectTypeGUID,g_aNodetypeGuids[objecttype].bstr) )
			return objecttype;
	}
	ASSERT( FALSE );
	return 0;
}

int CheckObjectTypeGUID( const GUID* pguid )
{
	ASSERT(NULL != pguid);
	for (	int objecttype = 0;
			objecttype < g_cNumNodetypeGuids;
			objecttype += 1 )
	{
		if ( g_aNodetypeGuids[objecttype].guid == *pguid )
			return objecttype;
	}
	ASSERT( FALSE );
	return 0;
}

/////////////////////////////////////////////////////////////////////
//	FilemgmtCheckObjectTypeGUID()
//
//	Compare the GUID and return the objecttype associated with
//	the guid.
//	If no match found, return -1.
//
//	HISTORY
//	14-Jul-97	t-danm		Creation.  Inspired from CheckObjectTypeGUID()
//							but does not assert if the GUID is not found.
//
int FilemgmtCheckObjectTypeGUID(const GUID* pguid )
{
	ASSERT(NULL != pguid);
	for (	int objecttype = 0;
			objecttype < g_cNumNodetypeGuids;
			objecttype += 1 )
	{
		if ( g_aNodetypeGuids[objecttype].guid == *pguid )
			return objecttype;
	}
	return -1;
} // FilemgmtCheckObjectTypeGUID()


const BSTR GetObjectTypeString( int objecttype )
{
	if (objecttype < 0 || objecttype >= g_cNumNodetypeGuids)
	{
		ASSERT( FALSE );
		objecttype = 0;
	}
	return g_aNodetypeGuids[objecttype].bstr;
}

const GUID* GetObjectTypeGUID( int objecttype )
{
	if (objecttype < 0 || objecttype >= g_cNumNodetypeGuids)
	{
		ASSERT( FALSE );
		objecttype = 0;
	}
	return &(g_aNodetypeGuids[objecttype].guid);
}

//+--------------------------------------------------------------------------- 
//                                                                             
//  Function:   SynchronousCreateProcess                             
//                                                                             
//  Synopsis:   Invoke a separate UI process as a modal window.                                                    
//                                                                             
//---------------------------------------------------------------------------- 
HRESULT SynchronousCreateProcess(
    HWND    hWnd,
    LPCTSTR pszAppName,
    LPCTSTR pszCommandLine,
    LPDWORD lpdwExitCode
)
{
  HRESULT hr = S_OK;
  BOOL bReturn = FALSE;
  STARTUPINFO si;
  PROCESS_INFORMATION pi;

  //
  // disable the MMC main frame window to prevent it from
  // being shut down. The process we're going to create must
  // display a UI, such that, it behaves like a modal window.
  //
  ::EnableWindow(hWnd, FALSE);

  *lpdwExitCode = 0;

  ZeroMemory(&si, sizeof(STARTUPINFO));
  si.cb = sizeof(STARTUPINFO);
  
  bReturn = CreateProcess(
                pszAppName, //LPCTSTR lpApplicationName
                const_cast<LPTSTR>(pszCommandLine), //LPTSTR lpCommandLine
                NULL, //LPSECURITY_ATTRIBUTES lpProcessAttributes
                NULL, //LPSECURITY_ATTRIBUTES lpThreadAttributes
                FALSE, //BOOL bInheritHandles
                NORMAL_PRIORITY_CLASS, //DWORD dwCreationFlags
                NULL, //LPVOID lpEnvironment
                NULL, //lpCurrentDirectory
                &si, //LPSTARTUPINFO lpStartupInfo
                &pi //LPPROCESS_INFORMATION lpProcessInformation 
                );

  if (!bReturn)
  {
    hr = HRESULT_FROM_WIN32(GetLastError());
  } else
  {
    //
    // while process is still running, pump message to MMC main window,
    // such that it will repaint itself
    //
    while (TRUE)
    {
      MSG tempMSG;
      DWORD dwWait;

      while(::PeekMessage(&tempMSG,NULL, 0, 0, PM_REMOVE))
        DispatchMessage(&tempMSG);

      dwWait = MsgWaitForMultipleObjects(1, &(pi.hProcess), FALSE, INFINITE, QS_ALLINPUT);
      if ( 0 == (dwWait - WAIT_OBJECT_0))
        break;  // process is done
    };

    bReturn = GetExitCodeProcess(pi.hProcess, lpdwExitCode);
    if (!bReturn)
      hr = HRESULT_FROM_WIN32(GetLastError());

    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
  }

  //
  // enable MMC main frame window before return
  //
  ::EnableWindow(hWnd, TRUE);

  return hr;
}

/*

This code is not working yet.  The problem is that it hangs the
message loop, preventing redraw.  One possible approach is to disable the
top-level window and spin off a thread which waits for the process to stop,
then the thread reenables the top-level window and calls UpdateAllViews.

DWORD WINAPI ProcessMonitor(LPVOID pv)
{
}

class CSyncThread : public CThread
{
};

HRESULT SynchronousCreateProcess(LPCTSTR cpszCommandLine,
								 SynchronousProcessCompletionRoutine pfunc,
								 PVOID pvFuncParams)
// does not handle completion routine
{
	PROCESS_INFORMATION piProcInfo;
	(void) ::memset(&piProcInfo,0,sizeof(piProcInfo));
	STARTUPINFO si;
	(void) ::memset(&si,0,sizeof(si));
	::GetStartupInfo( &si );

	//
	// MarkL 1/30/97: Is pszCommandLine a static string?
	// It can not be read only. It is modified temporarily by the call
	// if you do not specify lpszImageName. There is no query to see
	// if a process is running. You can test to see if it has exited
	// using waitforsingleobject to see if the process object is signaled.
	//
	// MarkL also confirms that the handle should absolutely always
	// be signalled when the process dies.
	//
	LPTSTR pszCommandLine = (LPTSTR)
		::alloca(sizeof(TCHAR)*(::_tcslen(cpszCommandLine)+1));
	::_tcscpy(pszCommandLine,cpszCommandLine);
	if ( !::CreateProcess(
		NULL,			// LPCTSTR lpszImageName
		pszCommandLine,	// LPTSTR lpszCommandLine
		NULL,			// LPSECURITY_ATTRIBUTES lpsaProcess
		NULL,			// LPSECURITY_ATTRIBUTES lpsaThread
		FALSE,			// BOOL fInheritHandles
		0L,				// DWORD fdwCreate
		NULL,			// LPVOID lpvEnvironment
		NULL,			// LPTSTR lpszCurDir
		&si,			// LPSTARTUPINFO lpsiStartInfo
		&piProcInfo		// LPPROCESS_INFORMATION lppiProcInfo
		) )
	{
		DWORD dwErr = ::GetLastError();
		ASSERT( ERROR_SUCCESS != dwErr );
		return HRESULT_FROM_WIN32(dwErr);
	}
	ASSERT( NULL != piProcInfo.hProcess );

	VERIFY( WAIT_OBJECT_0 ==
		::WaitForSingleObject( piProcInfo.hProcess, INFINITE ) );

	VERIFY( ::CloseHandle( piProcInfo.hProcess ) );
	VERIFY( ::CloseHandle( piProcInfo.hThread  ) );
	return S_OK;
}
*/

LPOLESTR CoTaskAllocString( LPCOLESTR psz )
{
	if (NULL == psz)
		return NULL;
	LPOLESTR pszReturn = (LPOLESTR)CoTaskMemAlloc( (lstrlen(psz)+1)*sizeof(OLECHAR) );
	if (NULL != pszReturn)
		lstrcpy( pszReturn, psz );
	ASSERT( NULL != pszReturn );
	return pszReturn;
}

LPOLESTR CoTaskLoadString( UINT nResourceID )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// load the resource
	CString strText;
	strText.LoadString( nResourceID );
	ASSERT( !strText.IsEmpty() );
	return CoTaskAllocString( const_cast<BSTR>((LPCTSTR)strText) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\framewrk\inc\stdabout.h ===
/////////////////////////////////////////////////////////////////////
//	StdAbout.h
//
//	HISTORY
//	31-Jul-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

#ifndef __STDABOUT_H_INCLUDED__
#define __STDABOUT_H_INCLUDED__


class CSnapinAbout :
	public ISnapinAbout,
	public CComObjectRoot
{
BEGIN_COM_MAP(CSnapinAbout)
	COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()
public:
	CSnapinAbout();
    virtual ~CSnapinAbout ();

// ISnapinAbout
	STDMETHOD(GetSnapinDescription)(OUT LPOLESTR __RPC_FAR *lpDescription);
	STDMETHOD(GetProvider)(OUT LPOLESTR __RPC_FAR *lpName);
	STDMETHOD(GetSnapinVersion)(OUT LPOLESTR __RPC_FAR *lpVersion);
	STDMETHOD(GetSnapinImage)(OUT HICON __RPC_FAR *hAppIcon);
	STDMETHOD(GetStaticFolderImage)(
            OUT HBITMAP __RPC_FAR *hSmallImage,
            OUT HBITMAP __RPC_FAR *hSmallImageOpen,
            OUT HBITMAP __RPC_FAR *hLargeImage,
            OUT COLORREF __RPC_FAR *crMask);
protected:
	// The following data members MUST be initialized by the constructor
	// of the derived class.
	UINT m_uIdStrDestription;		// Resource Id of the description
	UINT m_uIdStrProvider;		// Resource Id of the provider (ie, Microsoft Corporation)
	UINT m_uIdStrVersion;			// Resource Id of the version of the snapin
	UINT m_uIdIconImage;			// Resource Id for the icon/image of the snapin
	UINT m_uIdBitmapSmallImage;
	UINT m_uIdBitmapSmallImageOpen;
	UINT m_uIdBitmapLargeImage;
	COLORREF m_crImageMask;
    HBITMAP m_hSmallImage;          // cached bitmap for GetStaticFolderImage
    HBITMAP m_hSmallImageOpen;      // cached bitmap for GetStaticFolderImage
    HBITMAP m_hLargeImage;          // cached bitmap for GetStaticFolderImage
}; // CSnapinAbout()

#endif // ~__STDABOUT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\framewrk\inc\stdcdata.cpp ===
// stdcdata.cpp : Implementation of CComponentData

#include "stdcdata.h"
#include "guidhelp.h" // ExtractObjectTypeGUID
#include "stddtobj.h" // CDataObject::m_CFRawCookie
#include "stdrsrc.h"  // IDS_FRAMEWORK_*

//
// CComponentData
//

CComponentData::CComponentData()
: m_pConsole( NULL ),
  m_pConsoleNameSpace( NULL )
{
}

CComponentData::~CComponentData()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
  ASSERT(NULL == m_pConsole && NULL == m_pConsoleNameSpace); // object should be Destroy()ed before being Release()d
  SAFE_RELEASE( m_pConsole );
  SAFE_RELEASE( m_pConsoleNameSpace );
}

HRESULT CComponentData::OnNotifyExpand(LPDATAOBJECT /*lpDataObject*/, BOOL /*bExpanding*/, HSCOPEITEM /*hParent*/)
{
  return S_OK;
}

HRESULT CComponentData::OnNotifyPreload(LPDATAOBJECT /*lpDataObject*/, HSCOPEITEM /*hRootScopeItem*/)
{
  return S_OK;
}

HRESULT CComponentData::OnNotifyRename(LPDATAOBJECT /*lpDataObject*/, LPARAM arg, LPARAM /*param*/)
{
  // by default, do not allow rename
  return (0 == arg) ? S_FALSE : S_OK;
}

HRESULT CComponentData::OnNotifyDelete(LPDATAOBJECT /*lpDataObject*/)
{
  ASSERT(FALSE); // Why did you enable the Delete command if you won't handle it?
  return S_OK;
}
HRESULT CComponentData::OnNotifyRelease(LPDATAOBJECT /*lpDataObject*/, HSCOPEITEM /*hItem*/)
{
  ASSERT(FALSE); // You will leak memory if you don't handle this
  return S_OK;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponentData::IComponentData::Notify(MMCN_PROPERTY_CHANGE)
// OnPropertyChange() is generated by MMCPropertyChangeNotify( param )
HRESULT CComponentData::OnPropertyChange( LPARAM /*param*/ )
{
  return S_OK;
}


/*
 *  IComponentData
 */

STDMETHODIMP CComponentData::Initialize(LPUNKNOWN pUnknown)
{
	MFC_TRY;
    ASSERT(pUnknown != NULL);

    // MMC should only call ::Initialize once!
    ASSERT(NULL == m_pConsoleNameSpace);
  SAFE_RELEASE( m_pConsoleNameSpace );
    HRESULT hr = pUnknown->QueryInterface(IID_IConsoleNameSpace,
                    reinterpret_cast<void**>(&m_pConsoleNameSpace));
    ASSERT( SUCCEEDED(hr) );

    // add the images for the scope tree
    LPIMAGELIST lpScopeImage = NULL;

  ASSERT(NULL == m_pConsole);
  SAFE_RELEASE( m_pConsole );
    hr = pUnknown->QueryInterface(IID_IConsole, reinterpret_cast<void**>(&m_pConsole));
    ASSERT( SUCCEEDED(hr) );

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);
    ASSERT( SUCCEEDED(hr) );

    hr = LoadIcons(lpScopeImage, FALSE);
    ASSERT( SUCCEEDED(hr) );

    lpScopeImage->Release();

    MFC_CATCH;
    return S_OK;
}

STDMETHODIMP CComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;
    MFC_TRY;

    switch(event)
    {
    case MMCN_EXPAND:
    hr = OnNotifyExpand( lpDataObject, (BOOL)arg, (HSCOPEITEM)param );
        break;
    case MMCN_RENAME:
    hr = OnNotifyRename( lpDataObject, arg, param );
        break;
    case MMCN_DELETE:
    hr = OnNotifyDelete( lpDataObject );
    break;
  case MMCN_REMOVE_CHILDREN:
    hr = OnNotifyRelease( lpDataObject, arg );
    break;

  case MMCN_PRELOAD:
    hr = OnNotifyPreload (lpDataObject, (HSCOPEITEM) arg);
    break;

  case MMCN_PROPERTY_CHANGE:
    // CODEWORK arg is "fScopePane", should this be passed on?
    hr = OnPropertyChange( param );
    break;

  default:
    TRACE1("INFO: CComponentData::Notify () - Unknown Event %d.\n", event); // add new method for this notification
    break;
    }

    MFC_CATCH;
    return hr;
}

STDMETHODIMP CComponentData::Destroy()
{
    MFC_TRY;
    SAFE_RELEASE(m_pConsoleNameSpace);
    SAFE_RELEASE(m_pConsole);
    MFC_CATCH;
  return S_OK;
}

STDMETHODIMP CComponentData::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
    MFC_TRY;
  // WARNING cookie cast
    CCookie* pcookie = reinterpret_cast<CCookie*>(pScopeDataItem->lParam);
    ASSERT(NULL != pcookie);

  ASSERT( NULL != pScopeDataItem ); // result items never have NULL cookie
  if (SDI_STR & pScopeDataItem->mask)
  {
    pScopeDataItem->displayname = QueryResultColumnText( *pcookie, 0 );
    if ( NULL == pScopeDataItem->displayname )
      pScopeDataItem->displayname = L""; // just in case
  }
  if ( (SDI_IMAGE|SDI_OPENIMAGE) & pScopeDataItem->mask )
  {
    pScopeDataItem->nImage = QueryImage(
      *pcookie, !!(SDI_OPENIMAGE & pScopeDataItem->mask) );
  }
  MFC_CATCH;
  return S_OK;
/*
    ASSERT(pScopeDataItem->mask == TVIF_TEXT);
  pScopeDataItem->displayname = QueryResultColumnText(*pcookie,0);
    ASSERT(pScopeDataItem->displayname != NULL);

    return S_OK;
*/
}

STDMETHODIMP CComponentData::CompareObjects(
  LPDATAOBJECT lpDataObjectA,
  LPDATAOBJECT lpDataObjectB)
{
  int nResult = COMPARESIMILARCOOKIE_FULL;  // a full cookie comparison is desired.
  MFC_TRY;
  GUID guidA, guidB;
  HRESULT hr = ::ExtractObjectTypeGUID( lpDataObjectA, &guidA );
  if ( FAILED(hr) )
    return hr;
  hr = ::ExtractObjectTypeGUID( lpDataObjectB, &guidB );
  if ( FAILED(hr) )
    return hr;
  if ( 0 != ::memcmp( &guidA, &guidB, sizeof(GUID) ) )
    return S_FALSE; // different nodetypes

  // If the two nodetypes are the same, both of these objects
  // must belong to this snapin

  // Extract cookies
  // WARNING cookie cast
  CCookie* pcookieA = NULL;
  hr = ExtractData( lpDataObjectA,
                      CDataObject::m_CFRawCookie,
            &pcookieA,
            sizeof(pcookieA) );
  if ( FAILED(hr) )
  {
    ASSERT( FALSE );
    return hr;
  }
  pcookieA = ActiveBaseCookie(pcookieA);
  // WARNING cookie cast
  CCookie* pcookieB = NULL;
  hr = ExtractData( lpDataObjectB,
                      CDataObject::m_CFRawCookie,
            &pcookieB,
            sizeof(pcookieB) );
  if ( FAILED(hr) )
  {
    ASSERT( FALSE );
    return hr;
  }
  pcookieB = ActiveBaseCookie(pcookieB);

  // Compare cookies
  if (pcookieA == pcookieB)
    return S_OK;
  hr = pcookieA->CompareSimilarCookies( pcookieB, &nResult );
  if( FAILED(hr) )
    return hr;

  MFC_CATCH;
  return (0 == nResult) ? S_OK : S_FALSE;
}

int
GetErrorMsg(
    IN DWORD    dwError, 
    OUT PTSTR*  pptzMsg
)
{
  ASSERT(dwError != ERROR_SUCCESS);

  int cch = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER 
        | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL, dwError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (PTSTR)pptzMsg, 0, NULL);

  if (0 == cch)
  {
    static HMODULE g_hNetMod = 0;
    if (0 == g_hNetMod)
      g_hNetMod = GetModuleHandle (L"netmsg.dll");

    if (g_hNetMod)
      cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_HMODULE,
                        g_hNetMod, dwError,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (PTSTR)pptzMsg, 0, NULL);
  }

  return cch;
}

INT CComponentData::DoPopup( INT nResourceID, DWORD dwErrorNumber, LPCTSTR pszInsertionString, UINT fuStyle )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
  CString strTitle;
  VERIFY( strTitle.LoadString(
    (MB_ICONSTOP == (fuStyle & 0x000000F0))
    ? IDS_FRAMEWORK_TITLE_ERROR : IDS_FRAMEWORK_TITLE_WARNING ) );
  CString strError;
  if (0 != dwErrorNumber || NULL != pszInsertionString)
  {
    CString strFormat;
    VERIFY( strFormat.LoadString( nResourceID ) );

    strError.Format( strFormat, dwErrorNumber, pszInsertionString );

    if (0 != dwErrorNumber)
    {
      PTSTR pszErrorMsg = NULL;
      int cch = GetErrorMsg(dwErrorNumber, &pszErrorMsg);
      if (cch > 0)
      {
        strError += _T("\n\n");
        strError += pszErrorMsg;

        LocalFree(pszErrorMsg);
      }
    }
  }
  else
  {
    VERIFY( strError.LoadString( nResourceID ) );
  }

  INT iRetval = 0;
  USES_CONVERSION;
  HRESULT hr = m_pConsole->MessageBox(
    T2OLE(const_cast<LPTSTR>((LPCTSTR)strError)),
    T2OLE(const_cast<LPTSTR>((LPCTSTR)strTitle)),
    fuStyle,
    &iRetval );
  ASSERT( SUCCEEDED(hr) );

  return iRetval;
}

/////////////////////////////////////////////////////////////////////////////
// CMyComputerComponentData::ISnapinHelp members

// Help on IComponentData just returns the file and no particular topic
STDMETHODIMP CComponentData::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
  MFC_TRY;
  if (lpCompiledHelpFile == NULL)
      return E_INVALIDARG;

  CString szHelpFilePath;
  HRESULT hr = GetHtmlHelpFilePath( szHelpFilePath );
  if ( FAILED(hr) )
    return hr;

  *lpCompiledHelpFile = reinterpret_cast <LPOLESTR> (
      CoTaskMemAlloc ((szHelpFilePath.GetLength () + 1) * sizeof (wchar_t)));
  if ( NULL == *lpCompiledHelpFile )
    return E_OUTOFMEMORY;
  USES_CONVERSION;
  wcscpy (*lpCompiledHelpFile, T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
  
  MFC_CATCH;
  return S_OK;
}

STDMETHODIMP CComponentData::GetLinkedTopics(LPOLESTR* /*lpCompiledHelpFiles*/)
{
    return E_NOTIMPL;
}

HRESULT CComponentData::GetHtmlHelpFilePath( CString& strref ) const
{
  if ( GetHtmlHelpFileName().IsEmpty () )
    return E_NOTIMPL;

  UINT nLen = ::GetSystemWindowsDirectory (strref.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
  strref.ReleaseBuffer();
  if (0 == nLen)
  {
    ASSERT(FALSE);
    return E_FAIL;
  }

  strref += L"\\help\\";
  strref += GetHtmlHelpFileName();
  
  return S_OK;
}

/* no taskpads
STDMETHODIMP CComponentData::ExpandAndGet(
  HSCOPEITEM hsiStartFrom,
  LPDATAOBJECT pDataObject,
  HSCOPEITEM* phScopeItem )
{
  ASSERT(FALSE);
  return E_NOTIMPL;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\framewrk\inc\stdabout.cpp ===
/////////////////////////////////////////////////////////////////////
//	StdAbout.cpp
//
//	Implementation of the ISnapinAbout interface
//
//	HISTORY
//	31-Jul-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

#include "stdutils.h" // HrLoadOleString()

CSnapinAbout::CSnapinAbout()
: m_hSmallImage (0),
m_hSmallImageOpen (0),
m_hLargeImage (0)
{
}

CSnapinAbout::~CSnapinAbout()
{
    if ( m_hSmallImage )
        ::DeleteObject (m_hSmallImage);
    
    if ( m_hSmallImageOpen )
        ::DeleteObject (m_hSmallImageOpen);
    
    if ( m_hLargeImage )
        ::DeleteObject (m_hLargeImage);
}

STDMETHODIMP CSnapinAbout::GetSnapinDescription(OUT LPOLESTR __RPC_FAR *lpDescription)
	{
	return HrLoadOleString(m_uIdStrDestription, OUT lpDescription);
	}

STDMETHODIMP CSnapinAbout::GetProvider(OUT LPOLESTR __RPC_FAR *lpName)
	{
	return HrLoadOleString(m_uIdStrProvider, OUT lpName);
	}

STDMETHODIMP CSnapinAbout::GetSnapinVersion(OUT LPOLESTR __RPC_FAR *lpVersion)
	{
	return HrLoadOleString(m_uIdStrVersion, OUT lpVersion);
	}

STDMETHODIMP CSnapinAbout::GetSnapinImage(OUT HICON __RPC_FAR *hAppIcon)
	{
	if (hAppIcon == NULL)
		return E_POINTER;
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetInstanceHandle()
    *hAppIcon = ::LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(m_uIdIconImage));
    if (*hAppIcon == NULL)
		{
		ASSERT(FALSE && "Unable to load icon");
		return E_FAIL;
		}
	return S_OK;
	}

STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
            OUT HBITMAP __RPC_FAR *hSmallImage,
            OUT HBITMAP __RPC_FAR *hSmallImageOpen,
            OUT HBITMAP __RPC_FAR *hLargeImage,
            OUT COLORREF __RPC_FAR *crMask)
{	
	ASSERT(hSmallImage != NULL);
	ASSERT(hSmallImageOpen != NULL);
	ASSERT(hLargeImage != NULL);
	ASSERT(crMask != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetInstanceHandle()
	HINSTANCE hInstance = AfxGetInstanceHandle();

    if ( !m_hSmallImage )
	    m_hSmallImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapSmallImage));
    if ( !m_hSmallImageOpen )
	    m_hSmallImageOpen = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapSmallImageOpen));
    if ( !m_hLargeImage )
	    m_hLargeImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapLargeImage));

	*hSmallImage = m_hSmallImage;
	*hSmallImageOpen = m_hSmallImageOpen;
	*hLargeImage = m_hLargeImage;
    
    *crMask = m_crImageMask;
	#ifdef _DEBUG
	if (NULL == *hSmallImage || NULL == *hSmallImageOpen || NULL == *hLargeImage)
	{
		TRACE0("WRN: CSnapinAbout::GetStaticFolderImage() - Unable to load all the bitmaps.\n");
		return E_FAIL;
	}
	#endif
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\framewrk\inc\stdcmpnt.h ===
// stdcmpnt.h : Declaration of CComponent

#ifndef __STDCMPNT_H_INCLUDED__
#define __STDCMPNT_H_INCLUDED__

#include "stdcooki.h"  // CCookie
#include "stdcdata.h"  // CComponentData

class CComponent :
  public CComObjectRoot,
	public IComponent
{
public:
	CComponent();
	virtual ~CComponent();

BEGIN_COM_MAP(CComponent)
	COM_INTERFACE_ENTRY(IComponent)
END_COM_MAP()

	// IComponent
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)(MMC_COOKIE cookie);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie, LPOLESTR* ppViewType, long* pViewOptions);
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM* pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

	// support methods for IComponent
	virtual HRESULT ReleaseAll();
	virtual HRESULT OnPropertyChange( LPARAM param );
	virtual HRESULT OnViewChange( LPDATAOBJECT lpDataObject, LPARAM data, LPARAM hint );
	virtual HRESULT OnNotifyRefresh( LPDATAOBJECT lpDataObject );
	virtual HRESULT OnNotifyDelete( LPDATAOBJECT lpDataObject );
	virtual HRESULT OnNotifyColumnClick( LPDATAOBJECT lpDataObject, LPARAM iColumn, LPARAM uFlags );
	virtual HRESULT OnNotifySelect( LPDATAOBJECT lpDataObject, BOOL fSelected );
	virtual HRESULT OnNotifyActivate( LPDATAOBJECT lpDataObject, BOOL fActivated );
	virtual HRESULT OnNotifyAddImages( LPDATAOBJECT lpDataObject, LPIMAGELIST lpImageList, HSCOPEITEM hSelectedItem );
	virtual HRESULT OnNotifyClick( LPDATAOBJECT lpDataObject );
	virtual HRESULT OnNotifyDblClick( LPDATAOBJECT lpDataObject );
	virtual HRESULT Show(CCookie* pcookie, LPARAM arg, HSCOPEITEM hScopeItem) = 0;
	virtual HRESULT OnNotifyContextHelp (LPDATAOBJECT pDataObject);
	virtual HRESULT OnNotifySnapinHelp (LPDATAOBJECT pDataObject);

  HRESULT ShowHelpTopic( LPCWSTR lpcwszHelpTopic );

	HRESULT InsertResultCookies( CCookie& refparentcookie );

    void SetComponentDataPtr(CComponentData* pComponentData);
	CComponentData& QueryBaseComponentDataRef()
	{
		ASSERT( NULL != m_pComponentData );
		return *m_pComponentData;
	}

	inline CCookie& QueryBaseRootCookie()
	{
		return QueryBaseComponentDataRef().QueryBaseRootCookie();
	}

	inline CCookie* ActiveBaseCookie( CCookie* pcookie )
	{
		return QueryBaseComponentDataRef().ActiveBaseCookie( pcookie );
	}

	inline INT DoPopup(	INT nResourceID,
						DWORD dwErrorNumber = 0,
						LPCTSTR pszInsertionString = NULL,
						UINT fuStyle = MB_OK | MB_ICONSTOP )
	{
		return QueryBaseComponentDataRef().DoPopup( nResourceID,
		                                            dwErrorNumber,
												    pszInsertionString,
												    fuStyle );
	}

	HRESULT LoadColumnsFromArrays( INT objecttype );

protected:
    LPCONSOLE       m_pConsole;
    LPCONSOLEVERB   m_pConsoleVerb;
    LPHEADERCTRL    m_pHeader;
    LPRESULTDATA    m_pResultData;
    LPCONSOLENAMESPACE m_pConsoleNameSpace;
    LPIMAGELIST		m_pRsltImageList;

private:
	CComponentData*	m_pComponentData;
};

#endif // ~__STDCMPNT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\framewrk\inc\stdcooki.cpp ===
// Stdcooki.cpp : Implementation of CCookie and related classes

#include "stdcooki.h"
#include "stdutils.h" // FCompareMachineNames

//
// CHasMachineName
//

// returns <0, 0 or >0
HRESULT CHasMachineName::CompareMachineNames( CHasMachineName& refHasMachineName, int* pnResult )
{
	/*
	// This code is intended to help debug a problem and can be removed later
	LPCWSTR pszTargetServer = QueryTargetServer();
	LPCWSTR pszTargetServer2 = refHasMachineName.QueryTargetServer();
	if (NULL != pszTargetServer && ::IsBadStringPtr(pszTargetServer,MAX_PATH))
	{
		ASSERT(FALSE);
		// repeat operation so that we can find problem
		pszTargetServer = QueryTargetServer();
	}
	if (NULL != pszTargetServer2 && ::IsBadStringPtr(pszTargetServer2,MAX_PATH))
	{
		ASSERT(FALSE);
		// repeat operation so that we can find problem
		pszTargetServer2 = refHasMachineName.QueryTargetServer();
	}
	// This code is intended to help debug a problem and can be removed later
	*/

	*pnResult = ::CompareMachineNames( QueryTargetServer(),
	                                  refHasMachineName.QueryTargetServer() );

	return S_OK;
}

//
// CCookie
//

CCookie::~CCookie()
{
	ReleaseScopeChildren();

	// The views of this cookie should already have been closed
	// ReleaseResultChildren();
	ASSERT( 0 == m_nResultCookiesRefcount );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\framewrk\inc\stdcooki.h ===
// stdcooki.h : Declaration of base cookie class and related classes

#ifndef __STDCOOKI_H_INCLUDED__
#define __STDCOOKI_H_INCLUDED__


// forward declarations
class CCookie;

class CRefcountedObject
{
public:
	inline CRefcountedObject()
		: m_nRefcount( 1 )
	{};
	virtual ~CRefcountedObject() {};

	inline void AddRef() {m_nRefcount++;}
	inline void Release()
	{
		if (0 >= --m_nRefcount)
			delete this;
	}
private:
	int m_nRefcount;
};


class CHasMachineName
{
public:
	virtual void SetMachineName( LPCTSTR lpcszMachineName ) = 0;
	virtual LPCTSTR QueryNonNULLMachineName() = 0;
	virtual LPCTSTR QueryTargetServer() = 0;

	// returns <0, 0 or >0
	HRESULT CompareMachineNames( CHasMachineName& refHasMachineName, int* pnResult );
};

//
// CBaseCookieBlock holds a block of cookies and the data
// to which the cookies point.  It starts off with a
// reference count of 1.  When a data object is created
// which references one of these cookies, AddRef() the cookie block; when such
// a data object is released, Release() the cookie block.  Similarly,
// when the parent cookie is finished with the cookie block, it should
// Release() the cookie block.  The cookie block will delete itself
// when the reference count reaches 0.  Do not attempt to explicitly
// delete the cookie block.
//
class CBaseCookieBlock : public CRefcountedObject
{
public:
	virtual CCookie* QueryBaseCookie(int i) = 0;
	virtual int QueryNumCookies() = 0;
};

template<class COOKIE_TYPE>
class CCookieBlock
: public CBaseCookieBlock
{
private:
	COOKIE_TYPE* m_aCookies;
	int m_cCookies;

public:
	CCookieBlock(COOKIE_TYPE* aCookies, // use vector ctor, we use vector dtor
		         int cCookies );
	virtual ~CCookieBlock();

	virtual CCookie* QueryBaseCookie(int i);
	virtual int QueryNumCookies();
};

#define DEFINE_COOKIE_BLOCK(COOKIE_TYPE)                \
CCookieBlock<COOKIE_TYPE>::CCookieBlock<COOKIE_TYPE>    \
	(COOKIE_TYPE* aCookies, int cCookies)               \
	: m_aCookies( aCookies )                            \
	, m_cCookies( cCookies )                            \
{                                                       \
	ASSERT(NULL != aCookies && 0 < cCookies);           \
}                                                       \
CCookieBlock<COOKIE_TYPE>::~CCookieBlock<COOKIE_TYPE>() \
{                                                       \
	delete[] m_aCookies;                                \
}                                                       \
CCookie* CCookieBlock<COOKIE_TYPE>::QueryBaseCookie(int i) \
{                                                       \
	return (CCookie*)&(m_aCookies[i]);                  \
}                                                       \
int CCookieBlock<COOKIE_TYPE>::QueryNumCookies()        \
{                                                       \
	return m_cCookies;                                  \
}

#define COMPARESIMILARCOOKIE_FULL                       -1

//
// I am trying to allow child classes to derive from CCookie using
// multiple inheritance, but this is tricky
//
class CCookie
{
public:
	CTypedPtrList<CPtrList, CBaseCookieBlock*>  m_listScopeCookieBlocks;
	CTypedPtrList<CPtrList, CBaseCookieBlock*>  m_listResultCookieBlocks;
	HSCOPEITEM									m_hScopeItem;

private:
	LONG m_nResultCookiesRefcount;

public:
	inline CCookie()
		: m_nResultCookiesRefcount( 0 ),
		m_hScopeItem (0)
	{
	}

	inline void ReleaseScopeChildren()
	{
		while ( !m_listScopeCookieBlocks.IsEmpty() )
		{
			(m_listScopeCookieBlocks.RemoveHead())->Release();
		}
	}

	// returns new refcount
	inline ULONG AddRefResultChildren()
	{
		return ++m_nResultCookiesRefcount;
	}

	inline void ReleaseResultChildren()
	{
		ASSERT( 0 < m_nResultCookiesRefcount );
		if ( 0 >= --m_nResultCookiesRefcount )
		{
			while ( !m_listResultCookieBlocks.IsEmpty() )
			{
				(m_listResultCookieBlocks.RemoveHead())->Release();
			}
		}
	}

	virtual ~CCookie();

	// On entry, if not COMPARESIMILARCOOKIE_FULL, *pnResult is the column on which to sort,
        // otherwise, try to do a full cookie comparison.
	// On exit, *pnResult should be <0, 0 or >0.
	// Note that this is a sorting function and should not be used to establish
	// object identity where better identity functions are available.
	virtual HRESULT CompareSimilarCookies( CCookie* pOtherCookie, int* pnResult ) = 0;
};

#define DECLARE_FORWARDS_MACHINE_NAME(targ)             \
virtual LPCTSTR QueryNonNULLMachineName();              \
virtual LPCTSTR QueryTargetServer();                    \
virtual void SetMachineName( LPCTSTR lpcszMachineName );

#define DEFINE_FORWARDS_MACHINE_NAME(thisclass,targ)    \
LPCTSTR thisclass::QueryNonNULLMachineName()            \
{                                                       \
	ASSERT( (targ) != NULL );                           \
	return ((CHasMachineName*)(targ))->QueryNonNULLMachineName(); \
}                                                       \
LPCTSTR thisclass::QueryTargetServer()                  \
{                                                       \
	ASSERT( (targ) != NULL );                           \
	return ((CHasMachineName*)(targ))->QueryTargetServer(); \
}                                                       \
void thisclass::SetMachineName( LPCTSTR lpcszMachineName ) \
{                                                       \
	ASSERT( (targ) != NULL );                           \
	((CHasMachineName*)(targ))->SetMachineName( lpcszMachineName ); \
}

#define STORES_MACHINE_NAME                             \
public:                                                 \
	CString m_strMachineName;                           \
virtual void SetMachineName( LPCTSTR lpcszMachineName ) \
{                                                       \
	m_strMachineName = lpcszMachineName;                \
}                                                       \
virtual LPCTSTR QueryNonNULLMachineName()               \
{                                                       \
	return (LPCTSTR)m_strMachineName;                   \
}                                                       \
virtual LPCTSTR QueryTargetServer()                     \
{                                                       \
	return (m_strMachineName.IsEmpty())                 \
		? NULL : (LPCTSTR)(m_strMachineName);           \
}


class CStoresMachineName : public CHasMachineName
{
public:
	CStoresMachineName( LPCTSTR lpcszMachineName )
		: m_strMachineName( lpcszMachineName )
	{}

    STORES_MACHINE_NAME;
};

#endif // ~__STDCOOKI_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\framewrk\inc\stddtobj.cpp ===
// StdDtObj.cpp : Implementation of DataObject base classe

#include "stddtobj.h"

CDataObject::~CDataObject()
{
}

// Register the clipboard formats
CLIPFORMAT CDataObject::m_CFNodeType =
	(CLIPFORMAT)RegisterClipboardFormat(CCF_NODETYPE);
CLIPFORMAT CDataObject::m_CFNodeTypeString =
	(CLIPFORMAT)RegisterClipboardFormat(CCF_SZNODETYPE);
CLIPFORMAT CDataObject::m_CFSnapInCLSID =
	(CLIPFORMAT)RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
CLIPFORMAT CDataObject::m_CFDataObjectType =
	(CLIPFORMAT)RegisterClipboardFormat(L"FRAMEWRK_DATA_OBJECT_TYPE");
CLIPFORMAT CDataObject::m_CFSnapinPreloads = 
	(CLIPFORMAT)RegisterClipboardFormat(CCF_SNAPIN_PRELOADS);

// m_cfRawCookie must be different for each snapin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\framewrk\inc\stdcdata.h ===
// stdcdata.h : Declaration of CComponentData

#ifndef __STDCDATA_H_INCLUDED__
#define __STDCDATA_H_INCLUDED__

#include "stdcooki.h"

class CComponentData :
	public IComponentData,
	public CComObjectRoot,
	public ISnapinHelp2
{
BEGIN_COM_MAP(CComponentData)
	COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(ISnapinHelp2)
// no taskpads	COM_INTERFACE_ENTRY(IComponentData2)
END_COM_MAP()
public:
	CComponentData();
	~CComponentData();

// IComponentData
//   Note: QueryDataObject and CreateComponent must be defined by subclass
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
	STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent) = 0;
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
	STDMETHOD(Destroy)();
	STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject) = 0;
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

/* no taskpads
// IComponentData2
	STDMETHOD(ExpandAndGet)(HSCOPEITEM hsiStartFrom,
	                        LPDATAOBJECT pDataObject,
							HSCOPEITEM* phScopeItem );
*/

// Other stuff
	// needed for Initialize()
	virtual HRESULT LoadIcons(LPIMAGELIST pImageList, BOOL fLoadLargeIcons) = 0;

	// needed for Notify()
	virtual HRESULT OnNotifyPreload(LPDATAOBJECT lpDataObject, HSCOPEITEM hRootScopeItem);
	virtual HRESULT OnNotifyExpand(LPDATAOBJECT lpDataObject, BOOL bExpanding, HSCOPEITEM hParent);
	virtual HRESULT OnNotifyRename(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
	virtual HRESULT OnNotifyDelete(LPDATAOBJECT lpDataObject); // user hit DEL key
	virtual HRESULT OnNotifyRelease(LPDATAOBJECT lpDataObject, HSCOPEITEM hItem); // parent node released
	virtual HRESULT OnPropertyChange( LPARAM param );

	// needed for GetDisplayInfo(), must be defined by subclass
	virtual BSTR QueryResultColumnText(CCookie& basecookieref, int nCol ) = 0;
	virtual int QueryImage(CCookie& basecookieref, BOOL fOpenImage) = 0;

	virtual CCookie& QueryBaseRootCookie() = 0;

	inline CCookie* ActiveBaseCookie( CCookie* pcookie )
	{
		return (NULL == pcookie) ? &QueryBaseRootCookie() : pcookie;
	}

	INT DoPopup(	INT nResourceID,
					DWORD dwErrorNumber = 0,
					LPCTSTR pszInsertionString = NULL,
					UINT fuStyle = MB_OK | MB_ICONSTOP );

	LPCONSOLE QueryConsole()
	{
		ASSERT( NULL != m_pConsole );
		return m_pConsole;
	}

	LPCONSOLENAMESPACE QueryConsoleNameSpace()
	{
		ASSERT( NULL != m_pConsoleNameSpace );
		return m_pConsoleNameSpace;
	}

	void SetHtmlHelpFileName (const CString &fileName)
	{
		m_szHtmlHelpFileName = fileName;
	}

	const CString GetHtmlHelpFileName () const
	{
		return m_szHtmlHelpFileName;
	}
	HRESULT GetHtmlHelpFilePath( CString& strref ) const;

	// ISnapinHelp2 interface members
	STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);
    STDMETHOD(GetLinkedTopics)(LPOLESTR* lpCompiledHelpFiles);

protected:
	CString		m_szHtmlHelpFileName;
	LPCONSOLE m_pConsole;
	LPCONSOLENAMESPACE m_pConsoleNameSpace; // My interface pointer to the namespace
};

#endif // ~__STDCDATA_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\framewrk\inc\stdrsrc.h ===
//	StdRsrc.h

#ifndef __STDRSRC_H_INCLUDED__
#define __STDRSRC_H_INCLUDED__

#define IDS_FRAMEWORK_TITLE_ERROR                 98
#define IDS_FRAMEWORK_TITLE_WARNING               99

#endif // ~__STDRSRC_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\framewrk\inc\stddtobj.h ===
// StdDtObj.h : Declaration of the data object base class

#ifndef __STDDTOBJ_H_INCLUDED__
#define __STDDTOBJ_H_INCLUDED__

class CDataObject : public IDataObject, public CComObjectRoot
{

	BEGIN_COM_MAP(CDataObject)
		COM_INTERFACE_ENTRY(IDataObject)
	END_COM_MAP()

public:

	CDataObject() {}
	virtual ~CDataObject();

    HRESULT STDMETHODCALLTYPE GetData(
		FORMATETC __RPC_FAR * pformatetcIn,
        STGMEDIUM __RPC_FAR * pmedium)
	{
        UNREFERENCED_PARAMETER (pformatetcIn);
        UNREFERENCED_PARAMETER (pmedium);
		return E_NOTIMPL;
	}

    HRESULT STDMETHODCALLTYPE GetDataHere(
        FORMATETC __RPC_FAR * pformatetc,
        STGMEDIUM __RPC_FAR * pmedium)
	{
        UNREFERENCED_PARAMETER (pformatetc);
        UNREFERENCED_PARAMETER (pmedium);
		return E_NOTIMPL;
	}

    HRESULT STDMETHODCALLTYPE QueryGetData(
        FORMATETC __RPC_FAR * pformatetc)
	{
        UNREFERENCED_PARAMETER (pformatetc);
		return E_NOTIMPL;
	}

    HRESULT STDMETHODCALLTYPE GetCanonicalFormatEtc(
        FORMATETC __RPC_FAR * pformatectIn,
        FORMATETC __RPC_FAR * pformatetcOut)
	{
        UNREFERENCED_PARAMETER (pformatectIn);
        UNREFERENCED_PARAMETER (pformatetcOut);
		return E_NOTIMPL;
	}

    HRESULT STDMETHODCALLTYPE SetData(
        FORMATETC __RPC_FAR *pformatetc,
        STGMEDIUM __RPC_FAR *pmedium,
        BOOL fRelease)
	{
        UNREFERENCED_PARAMETER (pformatetc);
        UNREFERENCED_PARAMETER (pmedium);
        UNREFERENCED_PARAMETER (fRelease);
		return E_NOTIMPL;
	}

    HRESULT STDMETHODCALLTYPE EnumFormatEtc(
        DWORD dwDirection,
        IEnumFORMATETC __RPC_FAR *__RPC_FAR * ppenumFormatEtc)
	{
        UNREFERENCED_PARAMETER (dwDirection);
        UNREFERENCED_PARAMETER (ppenumFormatEtc);
		return E_NOTIMPL;
	}

    HRESULT STDMETHODCALLTYPE DAdvise(
        FORMATETC __RPC_FAR * pformatetc,
        DWORD advf,
        IAdviseSink __RPC_FAR * pAdvSink,
        DWORD __RPC_FAR * pdwConnection)
	{
        UNREFERENCED_PARAMETER (pformatetc);
        UNREFERENCED_PARAMETER (advf);
        UNREFERENCED_PARAMETER (pAdvSink);
        UNREFERENCED_PARAMETER (pdwConnection);
		return E_NOTIMPL;
	}

    HRESULT STDMETHODCALLTYPE DUnadvise(
        DWORD dwConnection)
	{
        UNREFERENCED_PARAMETER (dwConnection);
		return E_NOTIMPL;
	}

    HRESULT STDMETHODCALLTYPE EnumDAdvise(
        IEnumSTATDATA __RPC_FAR *__RPC_FAR * ppenumAdvise)
	{
        UNREFERENCED_PARAMETER (ppenumAdvise);
		return E_NOTIMPL;
	}

public:
	// Clipboard formats
	static CLIPFORMAT m_CFNodeType;
	static CLIPFORMAT m_CFNodeTypeString;
	static CLIPFORMAT m_CFSnapInCLSID;
	static CLIPFORMAT m_CFDataObjectType;
	static CLIPFORMAT m_CFRawCookie;
	static CLIPFORMAT m_CFSnapinPreloads;

};

#endif // ~__STDDTOBJ_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\framewrk\inc\stdcmpnt.cpp ===
// stdcmpnt.cpp : Implementation of CComponent

#include "guidhelp.h" // ExtractData

// Note that m_pComponentData is still NULL during construction
CComponent::CComponent()
:	m_pConsole( NULL ),
	m_pConsoleVerb( NULL ),
	m_pHeader( NULL ),
	m_pResultData( NULL ),
	m_pConsoleNameSpace( NULL ),
	m_pRsltImageList( NULL ),
	m_pComponentData( NULL )
{
}

CComponent::~CComponent()
{
	VERIFY( SUCCEEDED(ReleaseAll()) );
}

/////////////////////////////////////////////////////////////////////
// CComponent::SetComponentDataPtr()
void CComponent::SetComponentDataPtr(
	CComponentData* pComponentData)
{
    ASSERT(NULL != pComponentData && NULL == m_pComponentData);
	(void) ((IComponentData*)pComponentData)->AddRef();
	m_pComponentData = pComponentData;
}

/////////////////////////////////////////////////////////////////////
// CComponent::IComponent::QueryDataObject()
STDMETHODIMP CComponent::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    HRESULT hr = S_OK;
    MFC_TRY;
    // Delegate it to the IComponentData
    hr = QueryBaseComponentDataRef().QueryDataObject(cookie, type, ppDataObject);
    MFC_CATCH;
    return hr;
}

/////////////////////////////////////////////////////////////////////
// CComponent::IComponent::CompareObjects()
STDMETHODIMP CComponent::CompareObjects(
	LPDATAOBJECT lpDataObjectA,
	LPDATAOBJECT lpDataObjectB)
{
	return QueryBaseComponentDataRef().CompareObjects( lpDataObjectA, lpDataObjectB );
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_PROPERTY_CHANGE)
// OnPropertyChange() is generated by MMCPropertyChangeNotify( param )
HRESULT CComponent::OnPropertyChange( LPARAM /*param*/)
{
	return S_OK;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_SELECT)
HRESULT CComponent::OnNotifySelect( LPDATAOBJECT /*lpDataObject*/, BOOL /*fSelected*/ )
{
	return S_OK;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_ACTIVATE)
HRESULT CComponent::OnNotifyActivate( LPDATAOBJECT /*lpDataObject*/, BOOL /*fActivated*/ )
{
	return S_OK;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_CLICK)
HRESULT CComponent::OnNotifyClick( LPDATAOBJECT /*lpDataObject*/ )
{
	TRACE0("CComponent::OnNotifyClick().\n");
	return S_OK;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_DBLCLICK)
HRESULT CComponent::OnNotifyDblClick( LPDATAOBJECT /*lpDataObject*/ )
{
	// Returning S_FALSE allows MMC to do the default verb.
	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_ADD_IMAGES)
HRESULT CComponent::OnNotifyAddImages( LPDATAOBJECT /*lpDataObject*/,
	                                   LPIMAGELIST /*lpImageList*/,
									   HSCOPEITEM /*hSelectedItem*/ )
{
	ASSERT(FALSE); // this should be redefined by all snapins
	return S_OK;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_VIEW_CHANGE)
// OnViewChange is generated by UpdateAllViews( lpDataObject, data, hint )
HRESULT CComponent::OnViewChange( LPDATAOBJECT /*lpDataObject*/, LPARAM /*data*/, LPARAM /*hint*/ )
{
	return S_OK;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_REFRESH)
// OnNotifyRefresh is generated by enabling the verb MMC_VERB_REFRESH.
// Typically this routine will be overriden.
HRESULT CComponent::OnNotifyRefresh( LPDATAOBJECT /*lpDataObject*/ )
{
	TRACE0("CComponent::OnNotifyRefresh() - You must implement your own refresh routine.\n");
	return S_OK;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_DELETE)
HRESULT CComponent::OnNotifyDelete( LPDATAOBJECT /*lpDataObject*/ )
{
	return S_OK;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_COLUMN_CLICK)
HRESULT CComponent::OnNotifyColumnClick( LPDATAOBJECT /*lpDataObject*/, LPARAM /*iColumn*/, LPARAM /*uFlags*/ )
{
	return S_OK;
}


/////////////////////////////////////////////////////////////////////
//	CComponent::ReleaseAll()
HRESULT CComponent::ReleaseAll()
{
    MFC_TRY;
	TRACE_METHOD(CComponent,Destructor);

	if (NULL != m_pHeader)
		m_pConsole->SetHeader(NULL);

    SAFE_RELEASE(m_pHeader);

    SAFE_RELEASE(m_pResultData);
    SAFE_RELEASE(m_pConsoleNameSpace);
    SAFE_RELEASE(m_pRsltImageList);
    SAFE_RELEASE(m_pConsole);
	SAFE_RELEASE(m_pConsoleVerb);

	if ( NULL != m_pComponentData )
	{
		((IComponentData*)m_pComponentData)->Release();
		m_pComponentData = NULL;
	}

    MFC_CATCH;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CComponent::IComponent::Initialize()
STDMETHODIMP CComponent::Initialize(LPCONSOLE lpConsole)
{
    MFC_TRY;
    TRACE_METHOD(CComponent,Create);
    TEST_NONNULL_PTR_PARAM(lpConsole);

    if (NULL == lpConsole)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

	ASSERT( NULL == m_pConsole );
	SAFE_RELEASE( m_pConsole ); // just in case

	lpConsole->AddRef();
    m_pConsole = lpConsole;

    HRESULT hr = m_pConsole->QueryInterface(IID_IHeaderCtrl, (void**)&m_pHeader);

    ASSERT(hr == S_OK);
    if (FAILED(hr))
        return E_FAIL;

    m_pConsole->SetHeader(m_pHeader);

    hr = m_pConsole->QueryConsoleVerb(OUT &m_pConsoleVerb);
    ASSERT(hr == S_OK);
	if (FAILED(hr))
        return hr;
	ASSERT(NULL != m_pConsoleVerb);

    hr = m_pConsole->QueryInterface(IID_IResultData, (void**)&m_pResultData);
    if (FAILED(hr))
        return hr;

    hr = m_pConsole->QueryInterface(IID_IConsoleNameSpace, (void**)&m_pConsoleNameSpace);
    if (FAILED(hr))
        return hr;

    hr = m_pConsole->QueryInterface(IID_IImageList, (void**)&m_pRsltImageList);
    if (FAILED(hr))
        return hr;

    // Load icons for the scope pane
    LPIMAGELIST pImageList;
    hr = m_pConsole->QueryScopeImageList(&pImageList);
    ASSERT(SUCCEEDED(hr));
//    LoadIconsIntoImageList(pImageList, FALSE);
    pImageList->Release();

    MFC_CATCH;
    return S_OK;
} // CComponent::Initialize()

/////////////////////////////////////////////////////////////////////////////
// CComponent::IComponent::Notify()
// Entry point for all the MMCN_ notification messages.
// The routine will then call virtual functions of the CComponent object.
STDMETHODIMP CComponent::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;
    MFC_TRY;
    TRACE_METHOD(CComponent,Notify);


    switch (event)
    {
    case MMCN_SHOW:
		// CODEWORK this is hacked together quickly
		{
			CCookie* pcookie = NULL;
			HRESULT hr = ExtractData( lpDataObject,
		                      CDataObject::m_CFRawCookie,
							  (PBYTE)&pcookie,
							  sizeof(pcookie) );
			ASSERT( SUCCEEDED(hr) );
			CCookie* pActiveCookie = ActiveBaseCookie (pcookie);
			// Save the scope item handle in the cookie
			pActiveCookie->m_hScopeItem = (HSCOPEITEM) param;
			hr = Show (pActiveCookie, arg, (HSCOPEITEM) param);
		}
        break;

    case MMCN_MINIMIZED:
        break;

	case MMCN_SELECT:
		hr = OnNotifySelect( lpDataObject, (BOOL)(HIWORD(arg)) );
		break;

	case MMCN_ACTIVATE:
		hr = OnNotifyActivate( lpDataObject, (BOOL)arg );
		break;

	case MMCN_ADD_IMAGES:
		hr = OnNotifyAddImages( lpDataObject,
		                        reinterpret_cast<IImageList*>(arg),
								(HSCOPEITEM)param );
		break;

	case MMCN_CLICK:
		hr = OnNotifyClick( lpDataObject );
		break;

	case MMCN_DBLCLICK:
		hr = OnNotifyDblClick( lpDataObject );
		break;

	case MMCN_PROPERTY_CHANGE:
		// CODEWORK arg is "fScopePane", should this be passed on?
		hr = OnPropertyChange( param );
		break;

	case MMCN_VIEW_CHANGE:
		hr = OnViewChange( lpDataObject, arg, param );
		break;

	case MMCN_REFRESH:
		hr = OnNotifyRefresh( lpDataObject );
		break;

	case MMCN_DELETE:
		hr = OnNotifyDelete( lpDataObject );
		break;

	case MMCN_COLUMN_CLICK:
		hr = OnNotifyColumnClick( lpDataObject, arg, param );
		break;

	case MMCN_CONTEXTHELP:
		hr = OnNotifyContextHelp( lpDataObject );
		break;

	case MMCN_SNAPINHELP:
		hr = OnNotifySnapinHelp( lpDataObject );
		break;

	default:
		TRACE1("INFO: CComponent::Notify() - Unknown Event %d.\n", event);
		break;
    }

    MFC_CATCH;
    return hr;
} // CComponent::Notify()


// parameter "MMC_COOKIE cookie" is reserved per MSDN
STDMETHODIMP CComponent::Destroy(MMC_COOKIE /*cookie*/)
{
    MFC_TRY;
	TRACE_METHOD(CComponent,Destroy);

	VERIFY( SUCCEEDED( ReleaseAll() ) );

    MFC_CATCH;
	return S_OK;
}


HRESULT CComponent::InsertResultCookies( CCookie& refparentcookie )
{
	ASSERT( NULL != m_pResultData );

    RESULTDATAITEM tRDItem;
	::ZeroMemory( &tRDItem, sizeof(tRDItem) );
	tRDItem.nCol = 0;
	tRDItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
	tRDItem.str = MMC_CALLBACK;
	// CODEWORK should use MMC_ICON_CALLBACK here

	HRESULT hr = S_OK;
	POSITION pos = refparentcookie.m_listResultCookieBlocks.GetHeadPosition();
	while (NULL != pos)
	{
		CBaseCookieBlock* pblock = refparentcookie.m_listResultCookieBlocks.GetNext( pos );
		ASSERT( NULL != pblock );
		for (INT i = 0; i < pblock->QueryNumCookies(); i++)
		{
			CCookie* pbasecookie = pblock->QueryBaseCookie(i);
			tRDItem.nImage = QueryBaseComponentDataRef().QueryImage( *pbasecookie, FALSE );
			// WARNING cookie cast
			tRDItem.lParam = reinterpret_cast<LPARAM>(pbasecookie);
	        hr = m_pResultData->InsertItem(&tRDItem);
			if ( FAILED(hr) )
			{
				ASSERT(FALSE);
				break;
			}
		}
	}
	return hr;
}


STDMETHODIMP CComponent::GetResultViewType(MMC_COOKIE /*cookie*/,
										   BSTR* ppViewType,
										   long* pViewOptions)
{
    *ppViewType = NULL;
    *pViewOptions = MMC_VIEW_OPTIONS_NONE;
    return S_FALSE;
}

STDMETHODIMP CComponent::GetDisplayInfo(RESULTDATAITEM* pResultDataItem)
{
    MFC_TRY;
	CCookie* pcookie = ActiveBaseCookie(
		reinterpret_cast<CCookie*>(pResultDataItem->lParam));
	ASSERT( NULL != pResultDataItem ); // result items never have NULL cookie
	if (RDI_STR & pResultDataItem->mask)
	{
		pResultDataItem->str = QueryBaseComponentDataRef().QueryResultColumnText(
			*pcookie,
			pResultDataItem->nCol );
		if ( NULL == pResultDataItem->str )
			pResultDataItem->str = L""; // just in case
	}
	if ( RDI_IMAGE & pResultDataItem->mask )
	{
		pResultDataItem->nImage = QueryBaseComponentDataRef().QueryImage(
			*pcookie, FALSE );
	}
    MFC_CATCH;
	return S_OK;
}

// CODEWORK These should be parameters rather than globals
// CODEWORK figure out correct const'ing
extern UINT** g_aColumns;
extern int** g_aColumnWidths;

HRESULT CComponent::LoadColumnsFromArrays(
	INT objecttype )
{
	ASSERT( NULL != m_pHeader );

	CString str;
	const UINT* pColumns = g_aColumns[objecttype];
	const int* pColumnWidths = g_aColumnWidths[objecttype];
	ASSERT( NULL != pColumns && NULL != pColumnWidths );
	for ( INT i = 0; 0 != pColumns[i]; i++)
	{
		VERIFY( str.LoadString( pColumns[i] ) );
		m_pHeader->InsertColumn(i, const_cast<LPTSTR>((LPCTSTR)str), LVCFMT_LEFT,
			pColumnWidths[i]);
	}

	return S_OK;
}

HRESULT CComponent::OnNotifySnapinHelp (LPDATAOBJECT /*pDataObject*/)
{
	return ShowHelpTopic( NULL ); // snapins should redefine this
}

HRESULT CComponent::OnNotifyContextHelp (LPDATAOBJECT pDataObject)
{
	return OnNotifySnapinHelp( pDataObject ); // snapins should redefine this
}

HRESULT CComponent::ShowHelpTopic( LPCWSTR lpcwszHelpTopic )
{
    HRESULT hr = S_OK;
    MFC_TRY;
	CComQIPtr<IDisplayHelp,&IID_IDisplayHelp>	spDisplayHelp = m_pConsole;
	if ( !spDisplayHelp )
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	CString strHelpTopic;
	hr = QueryBaseComponentDataRef().GetHtmlHelpFilePath( strHelpTopic );
	if ( FAILED(hr) )
		return hr;
	if (NULL != lpcwszHelpTopic && L'\0' != *lpcwszHelpTopic)
	{
		strHelpTopic += L"::/";
		strHelpTopic += lpcwszHelpTopic;
	}
	hr = spDisplayHelp->ShowTopic (T2OLE ((LPWSTR)(LPCWSTR) strHelpTopic));
	ASSERT (SUCCEEDED (hr));

    MFC_CATCH;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\framewrk\inc\stdutils.h ===
//	StdUtils.h

#ifndef __STDUTILS_H_INCLUDED__
#define __STDUTILS_H_INCLUDED__

// returns -1, 0, +1
int CompareMachineNames(LPCTSTR pszMachineName1, LPCTSTR pszMachineName2);
HRESULT HrLoadOleString(UINT uStringId, OUT LPOLESTR * ppaszOleString);


// Nodetype utility routines
int CheckObjectTypeGUID( const GUID* pguid );
int CheckObjectTypeGUID( const BSTR lpszGUID );
int FilemgmtCheckObjectTypeGUID(const GUID* pguid );
const GUID* GetObjectTypeGUID( int objecttype );
const BSTR GetObjectTypeString( int objecttype );


struct NODETYPE_GUID_ARRAYSTRUCT
{
GUID guid;
BSTR bstr;
};

// You must define this struct for the ObjectType utility routines
extern const
struct NODETYPE_GUID_ARRAYSTRUCT* g_aNodetypeGuids;
extern const int g_cNumNodetypeGuids;

/* not working yet
typedef VOID (*SynchronousProcessCompletionRoutine)(PVOID);
HRESULT SynchronousCreateProcess(LPCTSTR cpszCommandLine,
								 SynchronousProcessCompletionRoutine pfunc = NULL,
								 PVOID pvFuncParams = NULL);
*/
HRESULT SynchronousCreateProcess(
    HWND    hWnd,
    LPCTSTR pszAppName,
    LPCTSTR pszCommandLine,
    LPDWORD lpdwExitCode
);
// allocate copy using CoTaskMemAlloc
LPOLESTR CoTaskAllocString( LPCOLESTR psz );
// allocate copy loaded from resource
LPOLESTR CoTaskLoadString( UINT nResourceID );

BOOL
IsLocalComputername( IN LPCTSTR pszMachineName );

#endif // ~__STDUTILS_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\about.hpp ===
// Copyright (C) 1997 Microsoft Corporation, 1996 - 1997.
//
// Local Security MMC Snapin About provider
//
// 8-19-97 sburns



#ifndef ABOUT_HPP_INCLUDED
#define ABOUT_HPP_INCLUDED



class SnapinAbout : public ISnapinAbout
{
   // this is the only entity with access to the ctor of this class
   friend class ClassFactory<SnapinAbout>; 
   
   public:

   // IUnknown overrides

   virtual
   ULONG __stdcall
   AddRef();

   virtual
   ULONG __stdcall
   Release();

   virtual 
   HRESULT __stdcall
   QueryInterface(const IID& interfaceID, void** interfaceDesired);

   // ISnapinAbout overrides

   virtual
   HRESULT __stdcall
   GetSnapinDescription(LPOLESTR* description);

   virtual
   HRESULT __stdcall
   GetProvider(LPOLESTR* name);

   virtual
   HRESULT __stdcall
   GetSnapinVersion(LPOLESTR* version);

   virtual
   HRESULT __stdcall
   GetSnapinImage(HICON* icon);

   virtual
   HRESULT __stdcall
   GetStaticFolderImage(
      HBITMAP*    smallImage,	
      HBITMAP*    smallImageOpen,	
      HBITMAP*    largeImage,	
      COLORREF*   cMask);	

   private:

   // only the friend class factory can instantiate us
   SnapinAbout();

   // only Release can cause us to be deleted

   virtual
   ~SnapinAbout();

   // not implemented; no instance copying allowed.
   SnapinAbout(const SnapinAbout&);
   const SnapinAbout& operator=(const SnapinAbout&);

   HBITMAP              smallImage;
   HBITMAP              smallImageOpen;
   HBITMAP              largeImage;

   ComServerReference   dllref;
   long                 refcount;
};



#endif   // ABOUT_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\about.cpp ===
// Copyright (C) 1997 Microsoft Corporation, 1996 - 1997.
//
// Local Security MMC Snapin About provider
//
// 8-19-97 sburns



#include "headers.hxx"
#include "about.hpp"
#include "resource.h"



SnapinAbout::SnapinAbout()
   :
   refcount(1),    // implicit AddRef
   smallImage(0),
   smallImageOpen(0),
   largeImage(0)
{
   LOG_CTOR(SnapinAbout);

   // These are deleted in the dtor.
   
   HRESULT hr = Win::LoadBitmap(IDB_STATIC_FOLDER_SMALL, smallImage);
   ASSERT(SUCCEEDED(hr));

   hr = Win::LoadBitmap(IDB_STATIC_FOLDER_SMALL_OPEN, smallImageOpen);
   ASSERT(SUCCEEDED(hr));

   hr = Win::LoadBitmap(IDB_STATIC_FOLDER_LARGE, largeImage);
   ASSERT(SUCCEEDED(hr));
}



SnapinAbout::~SnapinAbout()
{
   LOG_DTOR(SnapinAbout);   
   ASSERT(refcount == 0);

   // Need to delete these after all.
   // NTRAID#NTBUG9-380753-2001/04/28-sburns

   Win::DeleteObject(smallImage);
   Win::DeleteObject(smallImageOpen);
   Win::DeleteObject(largeImage);
}



ULONG __stdcall
SnapinAbout::AddRef()
{
   LOG_ADDREF(SnapinAbout);   

   return Win::InterlockedIncrement(refcount);
}



ULONG __stdcall
SnapinAbout::Release()
{
   LOG_RELEASE(SnapinAbout);   

   if (Win::InterlockedDecrement(refcount) == 0)
   {
      delete this;
      return 0;
   }

   return refcount;
}



HRESULT __stdcall
SnapinAbout::QueryInterface(
   const IID&  interfaceID,
   void**      interfaceDesired)
{
   LOG_FUNCTION(SnapinAbout::QueryInterface);
   ASSERT(interfaceDesired);

   HRESULT hr = 0;

   if (!interfaceDesired)
   {
      hr = E_INVALIDARG;
      LOG_HRESULT(hr);
      return hr;
   }

   if (interfaceID == IID_IUnknown)
   {
      *interfaceDesired =
         static_cast<IUnknown*>(static_cast<ISnapinAbout*>(this));
   }
   else if (interfaceID == IID_ISnapinAbout)
   {
      *interfaceDesired = static_cast<ISnapinAbout*>(this);
   }
   else
   {
      *interfaceDesired = 0;
      hr = E_NOINTERFACE;
      LOG(
            L"interface not supported: "
         +  Win::StringFromGUID2(interfaceID));
      LOG_HRESULT(hr);
      return hr;
   }

   AddRef();
   return S_OK;
}



HRESULT __stdcall
SnapinAbout::GetSnapinDescription(LPOLESTR* description)
{
   LOG_FUNCTION(SnapinAbout::GetSnapinDescription);
   ASSERT(description);

   if (!description)
   {
      return E_POINTER;
   }

   String desc = String::load(IDS_SNAPIN_ABOUT_DESCRIPTION);
   return desc.as_OLESTR(*description);
}



HRESULT __stdcall
SnapinAbout::GetProvider(LPOLESTR* name)
{
   LOG_FUNCTION(SnapinAbout::GetProvider);
   ASSERT(name);

   if (!name)
   {
      return E_POINTER;
   }

   String desc = String::load(IDS_SNAPIN_ABOUT_PROVIDER_NAME);
   return desc.as_OLESTR(*name);
}



HRESULT __stdcall
SnapinAbout::GetSnapinVersion(LPOLESTR* version)
{
   LOG_FUNCTION(SnapinAbout::GetSnapinVersion);
   ASSERT(version);

   if (!version)
   {
      return E_POINTER;
   }

   String desc = String::load(IDS_SNAPIN_ABOUT_VERSION);
   return desc.as_OLESTR(*version);
}



HRESULT __stdcall
SnapinAbout::GetSnapinImage(HICON* icon)
{
   LOG_FUNCTION(SnapinAbout::GetSnapinImage);

   if (!icon)
   {
      return E_POINTER;
   }
      
   HRESULT hr = Win::LoadIcon(IDI_SNAPIN_ICON, *icon);
   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT __stdcall
SnapinAbout::GetStaticFolderImage(
   HBITMAP*    smallImage_,	
   HBITMAP*    smallImageOpen_,	
   HBITMAP*    largeImage_,	
   COLORREF*   mask)
{
   LOG_FUNCTION(SnapinAbout::GetStaticFolderImage);

   if (smallImage_)
   {
      *smallImage_ = smallImage;
   }
   if (smallImageOpen_)
   {
      *smallImageOpen_ = smallImageOpen;
   }
   if (largeImage_)
   {
      *largeImage_ = largeImage;
   }
   if (mask)
   {
      *mask = BITMAP_MASK_COLOR;
   }

   if (*smallImage_ && *smallImageOpen_ && *largeImage_)
   {
      return S_OK;
   }

   LOG(L"One or more bitmaps were not loaded");

   return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\adsinode.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// AdsiNode class
// 
// 9-22-97 sburns



#include "headers.hxx"
#include "adsinode.hpp"
#include "adsi.hpp"



AdsiNode::AdsiNode(
   const SmartInterface<ComponentData>&   owner,
   const NodeType&                        nodeType,
   const String&                          displayName,
   const String&                          ADSIPath)
   :
   ResultNode(owner, nodeType, displayName),
   path(ADSIPath)
{
   LOG_CTOR(AdsiNode);
   ASSERT(!path.empty());
}



AdsiNode::~AdsiNode()
{
   LOG_DTOR(AdsiNode);
}



String
AdsiNode::GetADSIPath() const
{
   return path;
}



bool
AdsiNode::IsSameAs(const Node* other) const
{
   LOG_FUNCTION(AdsiNode::IsSameAs);
   ASSERT(other);

   if (other)
   {
      const AdsiNode* adsi_other = dynamic_cast<const AdsiNode*>(other);
      if (adsi_other)
      {
         // same type.  Compare ADSI paths to see if they refer to the same
         // object.  This has the nice property that separate instances of the
         // snapin focused on the same machine will "recognize" each other's
         // prop sheets.
         if (path.icompare(adsi_other->path) == 0)
         {
            return true;
         }

         // not the same path.
         return false;
      }

      // not the same type.  Defer to the base class.
      return ResultNode::IsSameAs(other);
   }

   return false;
}



HRESULT
AdsiNode::rename(const String& newName)
{
   LOG_FUNCTION(AdsiNode::rename);

   String p = GetADSIPath();
   HRESULT hr =
      ADSI::RenameObject(
         ADSI::ComposeMachineContainerPath(
            GetOwner()->GetInternalComputerName()),
         p,
         newName);
   if (SUCCEEDED(hr))
   {
      SetDisplayName(newName);
      ADSI::PathCracker cracker(p);
      path = cracker.containerPath() + ADSI::PATH_SEP + newName;
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\adsi.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// ADSI wrapper
// 
// 9-22-97 sburns



#ifndef ADSI_HPP_INCLUDED
#define ADSI_HPP_INCLUDED



// Macro to define an inline static method of class ADSI that calls
// ADsGetObject for the supplied path, and binds the resulting interface to a
// smart interface pointer.
// 
// name - ADSI classname.  As this is used in token-pasted composition of the
// corresponding IADs interface and interface IID, this must appear exactly as
// in the ADSI IDL.  e.g. User, Group, Container, etc.
// 
// The resulting function has the signature:
// static HRESULT GetXXX(const String& path, SmartInterface<IADsXXX>& ptr)
// where 'XXX' is replaced with the name parameter of the macro.  Returns the
// result of ADsGetObject.
// 
// path - The ADSI path of the object to be bound.
// 
// ptr - A null smart pointer to be bound to the interface of the object.

#define DEFINE_GET(name)                                                \
static                                                                  \
HRESULT                                                                 \
Get##name(                                                              \
   const String&               path,                                    \
   SmartInterface<IADs##name>& ptr)                                     \
{                                                                       \
   LOG_FUNCTION2(ADSI::Get##name, path);                              \
   return TemplateGetObject<IADs##name>(path, ptr);                     \
}                                                                       \



// Template function that actually calls ADsGetObject for the DEFINE_GET
// macro.  While it should be possible to define this template as a member of
// the ADSI class, the VC++ 5 parser doesn't allow it.
// 
// Interface - The IADsXXX interface of the object to be bound.
// 
// path - The ADSI path of the object to be bound.
// 
// ptr - A null smart pointer to be bound to the interface of the object.

template <class Interface> 
static
HRESULT
TemplateGetObject(
   const String&               path,
   SmartInterface<Interface>&  ptr)
{
   ASSERT(!path.empty());
   ASSERT(ADSI::IsWinNTPath(path));

   Interface* p = 0;
   HRESULT hr = 
      ::ADsGetObject(
         path.c_str(),
         __uuidof(Interface), 
         reinterpret_cast<void**>(&p));
   if (!FAILED(hr))
   {
      ptr.Acquire(p);
   }

   return hr;
}



// Macro to define an inline static method of class ADSI that calls
// IADsContainer::Create for the supplied relative object naem, and binds the
// interface of the resulting new object to a smart interface pointer.
//
// className - ADSI classname.
// 
// interfaceName - ADSI IADsXxxx interface name. As this is used in
// token-pasted composition of the corresponding IADs interface and interface
// IID, this must appear exactly as in the ADSI IDL.  e.g. User, Group,
// Container, etc.
// 
// The resulting function has the signature:
// static HRESULT
// CreateXXX(
//    SmartInterface<IADsContainer>   container,
//    const String&                 relativeName,
//    SmartInterface<IADsXXX>&        ptr)
// where 'XXX' is replaced with the name parameter of the macro.  Returns the
// result of ADsGetObject.
// 
// container - smart pointer bound to the ADSI container object that is to
// contain the created object.
// 
// relativeName - The "leaf" name of the new object, relative to the name of
// the container.  I.e. *not* the full ADSI path of the new object.
// 
// ptr - A null smart pointer to be bound to the interface of the new object.

#define DEFINE_CREATE(className, interfaceName)                         \
static                                                                  \
HRESULT                                                                 \
Create##interfaceName(                                                  \
   const SmartInterface<IADsContainer>   container,                     \
   const String&                         relativeName,                  \
   SmartInterface<IADs##interfaceName>&  ptr)                           \
{                                                                       \
   LOG_FUNCTION2(ADSI::Create##className, relativeName);              \
   return                                                               \
      TemplateCreateObject<                                             \
         IADs##interfaceName,                                           \
         &ADSI::CLASS_##className,                                      \
         &IID_IADs##interfaceName>(container, relativeName, ptr);       \
}                                                                       \
         
   

// Template function that actually implements the DEFINE_CREATE
// macro.  While it should be possible to define this template as a member of
// the ADSI class, the VC++ 5 parser doesn't allow it.
// 
// Interface - The IADsXXX interface of the object to be bound.
// 
// classname - The ADSI class name of the object to be created.
// 
// interfaceID - The IID of the Interface parameter.
// 
// container - smart pointer bound to the ADSI container object that is to
// contain the created object.
// 
// relativeName - in, The "leaf" name of the new object, relative to the name
// of the container.  I.e. *not* the full ADSI path of the new object.
// 
// object - out, A null smart pointer to be bound to the interface of the new
// object.

template <class Interface, const String* classname, const IID* interfaceID>
HRESULT
TemplateCreateObject(
   const SmartInterface<IADsContainer> container,
   const String&                       relativeName,
   SmartInterface<Interface>&          object)
{
   ASSERT(classname);
   ASSERT(interfaceID);
   ASSERT(!relativeName.empty());

   IDispatch* p = 0;
   HRESULT hr =
      container->Create(AutoBstr(*classname), AutoBstr(relativeName), &p);
   if (!FAILED(hr))
   {
      ASSERT(p);
      hr = object.AcquireViaQueryInterface(*p, *interfaceID);
      ASSERT(SUCCEEDED(hr));
      p->Release();
   }

   return hr;
}



// Class ADSI bundles a bunch of useful functions and static data for dealing
// with ADSI.

class /* namespace, really */ ADSI
{
   public:

   static const String PROVIDER;
   static const String PROVIDER_ROOT;
   static const String CLASS_User;
   static const String CLASS_Group;
   static const String CLASS_Computer;
   static const String PATH_SEP;
   static const String PROPERTY_PasswordExpired;
   static const String PROPERTY_UserFlags;
   static const String PROPERTY_LocalDrive;
   static const String PROPERTY_UserParams;
   static const String PROPERTY_ObjectSID;
   static const String PROPERTY_GroupType;

   // InetOrgPerson needs to be supported as if it was a user.
   // The WINNT provider always returns inetOrgPerson objects
   // as users but the LDAP provider returns them as inetOrgPerson.
   // This string is used for the comparison
   // NTRAID#NTBUG9-436314-2001/07/16-jeffjon

   static const String CLASS_InetOrgPerson;


   // Given a computer name, compose the WinNT provider ADSI path for that
   // machine, return the result.  The computer object is not verified to
   // exist.  Path is of the form "WinNT://machine,Computer"
   //
   // computerName - name of the computer, without leading \\'s

   static
   String
   ComposeMachineContainerPath(const String& computerName);



   // Deletes an object.
   // 
   // containerADSIPath - fully-qualified ADSI path of the container of the
   // object to be deleted.  E.g. to delete "WinNT://foo/bar", this parameter
   // would have the value "WinNT://foo".
   // 
   // objectRelativeName - name of the object to be deleted, relative to the
   // name of the parent container.  E.g. to delete object "WinNT://foo/bar",
   // this paramter would have the value "bar".
   // 
   // objectClass - ADSI classname of the object to be deleted, in order to
   // disambiguate objects of different classes with the same name in the same
   // container.  E.g. "User", "Group".  See the ADSI::CLASS_XXX constants.

   static
   HRESULT
   DeleteObject(
      const String& containerADSIPath,
      const String& objectRelativeName,
      const String& objectClass);



   static
   String
   ExtractDomainObjectName(const String& ADSIPath);



   // Extracts the leaf name from a fully-qualified ADSI path name.  E.g. for
   // "WinNT://machine/Fred", returns "Fred"
   // 
   // path - fully-qualified ADSI path of the object.  The object need not
   // exist.

   static
   String
   ExtractObjectName(const String& ADSIPath);


   static   
   void
   FreeSid(SID* sid);


   
   // Determines the SID path of the supplied object.
   //   
   // iads - interface pointer to bound WinNT object, assumed to be one that
   // has a ObjectSid property.
   //
   // result - receives the result, a pointer to a chuck of memory that
   // contains the object's sid.  This result should be freed with
   // ADSI::FreeSid (not Win32 FreeSid)

   static   
   HRESULT
   GetSid(const SmartInterface<IADs>& iads, SID*& result);

   
   
   // Determines the SID path of the supplied object.
   //   
   // adsiPath - WinNT pathname of the object for which the sid-style path
   // is to be retrieved.  assumed to be the path of an object that has a
   // ObjectSid property.
   //
   // result - receives the result, a pointer to a chuck of memory that
   // contains the object's sid.  This result should be freed with
   // ADSI::FreeSid (not Win32 FreeSid)

   static
   HRESULT
   GetSid(const String& path, SID*& result);


   
   // Determines the SID-style path of the supplied object.  A SID-style path
   // is of the form WinNT://S-1-5...
   //
   // iads - interface pointer to bound WinNT object, assumed to be one that
   // has a ObjectSid property.
   //
   // result - receives the result

   static
   HRESULT
   GetSidPath(const SmartInterface<IADs>& iads, String& result);



   // Determines the SID-style path of the supplied object.  A SID-style path
   // is of the form WinNT://S-1-5...
   //
   // adsiPath - WinNT pathname of the object for which the sid-style path
   // is to be retrieved.  assumed to be the path of an object that has a
   // ObjectSid property.
   //
   // result - receives the result

   static
   HRESULT
   GetSidPath(const String& adsiPath, String& result);



   // Versions of the templates:

   DEFINE_GET(User);
   DEFINE_GET(Group);
   DEFINE_GET(Container);
   DEFINE_CREATE(User, User);
   DEFINE_CREATE(Group, Group);



   // static               
   // HRESULT              
   // GetObject(           
   //    const String&        path,
   //    SmartInterface<IADs>&  ptr) 
   // {                            
   //    return TemplateGetObject<IADs, &IID_IADs>(path, ptr); 
   // }                                                        



   // Returns S_OK if the computer object could be bound, an error code
   // otherwise.
   //
   // machine - the leaf name of the computer object, without leading \\'s   

   static
   HRESULT
   IsComputerAccessible(const String& machine);



   static
   bool
   IsWinNTPath(const String& path);



   // Rename or move an object.
   // 
   // destinationContainerADSIPath - fully-qualified ADSI path of the
   // container to receive the object named by objectADSIPath.
   //
   // objectADSIPath - the fully-qualified ADSI path of the object to be
   // renamed or moved.  If this parent of this path differs from that given
   // by containerADSIPath, the object is moved to containerADSIPath.  (I.e. a
   // rename is an in-place move).
   //    
   // newName - new leaf name of the object.

   static
   HRESULT
   RenameObject(
      const String& desitnationContainerADSIPath,
      const String& objectADSIPath,
      const String& newName);



   // Converts a VARIANT containing a safe array of bytes to a string-ized SID
   // of the form S-1-5-....
   //
   // var - variant initialized with the safe array.
   //
   // result - receives the result.

   static
   HRESULT
   VariantToSidPath(VARIANT* var, String& result);



   // Used with VisitXxxx functions, ObjectVistor is an abstract base class.
   // The Visit method is called for each object in an container or member
   // enumeration.

   class ObjectVisitor
   {
      public:

      virtual 
      void
      Visit(const SmartInterface<IADs>& object) = 0;
   };



   // Applies the given visitor to each child object of a particular class in
   // a given container.
   // 
   // containerPath - fully-qualified ADSI path of the container to enumerate.
   // 
   // objectADSIClass - ADSI classname of the class of child objects to visit.
   // See ADSI::CLASS_Xxxx constants.
   // 
   // visitor - ObjectVistor instance.  The Visit method of this object will
   // be invoked for every child object enumerated of the specified ADSI
   // class.

   static
   HRESULT
   VisitChildren(
      const String&        containerPath,
      const String&        objectADSIClass,
      ADSI::ObjectVisitor& visitor);



   // Applies a given vistor to each of the members of a Group.
   // 
   // group - smart pointer bound to an IADsGroup interface.
   // 
   // visitor - The Visit method of this object will be invoked for every
   // member of the group.

   static
   HRESULT
   VisitMembers(
      const SmartInterface<IADsGroup>& group,
      ADSI::ObjectVisitor&             visitor);



   // Applies a given visitor to each of the groups to which a user object
   // belongs.
   // 
   // user - smart pointer bound to an IADsUser interface.
   // 
   // visitor - The Visit method of this object will be invoked for every
   // member of the group.

   static
   HRESULT
   VisitGroups(
      const SmartInterface<IADsUser>&  user,
      ADSI::ObjectVisitor&             visitor);



   // Wrapper for that very sorry piece of garbage, IADsPathname

   class PathCracker
   {
      public:

      PathCracker(const String& adsiPath);

      ~PathCracker();

      String
      containerPath() const;

      int
      elementCount() const;

      String
      element(int index) const;

      String
      leaf() const;

      String
      serverName() const;

      private:

      void
      reset() const;

      SmartInterface<IADsPathname> ipath;
      String                       path;

      // not defined: no copying allowed

      PathCracker(const PathCracker&);
      const PathCracker& operator=(const PathCracker&);
   };

   private:



   // not implemented.  This class can't be instantiated.

   ADSI();
   ADSI(const ADSI&);
};



#endif   // ADSI_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\adsinode.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// AdsiNode class
// 
// 9-22-97 sburns



#ifndef ADSINODE_HPP_INCLUDED
#define ADSINODE_HPP_INCLUDED



#include "resnode.hpp"



// AdsiNode is an intermediate adstract base class for all Nodes which are
// built from ADSI APIs.  All ADSI entities use their ADSI path name as their
// unique identifier.  By forcing that path to be supplied upon contruction,
// this class enforces that notion of identity.

class AdsiNode : public ResultNode
{
   public:

   // Return the path with which this node was constructed.
      
   String
   GetADSIPath() const;

   // See base class.  Compares the pathnames.

   virtual
   bool
   IsSameAs(const Node* other) const;

   protected:

   // Constructs a new instance. Declared protected as this class may only
   // be used as a base class.
   // 
   // owner - See base class ctor.
   //
   // nodeType - See base class ctor.
   // 
   // displayName - See base class ctor.
   //
   // ADSIPath - The fully-qualified ADSI pathname of the object which this
   // node represents.

   AdsiNode(
      const SmartInterface<ComponentData>&   owner,
      const NodeType&                        nodeType,
      const String&                          displayName,
      const String&                          ADSIPath);

   virtual ~AdsiNode();

   // ResultNode::Rename helper function
      
   HRESULT
   rename(const String& newName);

   private:

   String path;

   // not implemented: no copying allowed

   AdsiNode(const AdsiNode&);
   const AdsiNode& operator=(const AdsiNode&);
};



#endif   // ADSINODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\adsipage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// ASDIPage base class class
// 
// 10-30-97 sburns



#include "headers.hxx"
#include "adsipage.hpp"
#include "adsi.hpp"



ADSIPage::ADSIPage(
   int                  dialogResID,
   const DWORD          helpMap[],
   NotificationState*   state,
   const String&        objectADSIPath)
   :
   MMCPropertyPage(dialogResID, helpMap, state),
   path(objectADSIPath)
{
   LOG_CTOR(ADSIPage);
   ASSERT(!path.empty());
}



String
ADSIPage::GetADSIPath() const
{
   LOG_FUNCTION2(ADSIPage::GetADSIPath, path);

   return path;
}



String
ADSIPage::GetObjectName() const
{
   LOG_FUNCTION2(ADSIPage::GetObjectName, ADSI::ExtractObjectName(path));

   return ADSI::ExtractObjectName(path);
}



String
ADSIPage::GetMachineName() const
{
   LOG_FUNCTION(ADSIPage::GetMachineName);

   return ADSI::PathCracker(path).serverName();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\adsi.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// ADSI wrapper
// 
// 9-22-97 sburns



#include "headers.hxx"
#include "adsi.hpp"


const String ADSI::PROVIDER(L"WinNT");
const String ADSI::PROVIDER_ROOT(L"WinNT://");
const String ADSI::CLASS_User(USER_CLASS_NAME);
const String ADSI::CLASS_Group(GROUP_CLASS_NAME);
const String ADSI::CLASS_Computer(COMPUTER_CLASS_NAME);
const String ADSI::PATH_SEP(L"/");
const String ADSI::PROPERTY_PasswordExpired(L"PasswordExpired");
const String ADSI::PROPERTY_UserFlags(L"UserFlags");
const String ADSI::PROPERTY_LocalDrive(L"HomeDirDrive");
const String ADSI::PROPERTY_UserParams(L"Parameters");
const String ADSI::PROPERTY_ObjectSID(L"ObjectSID");
const String ADSI::PROPERTY_GroupType(L"groupType");

// InetOrgPerson needs to be supported as if it was a user.
// The WINNT provider always returns inetOrgPerson objects
// as users but the LDAP provider returns them as inetOrgPerson.
// This string is used for the comparison
// NTRAID#NTBUG9-436314-2001/07/16-jeffjon

const String ADSI::CLASS_InetOrgPerson(L"inetOrgPerson");

static const String COMPUTER_SUFFIX(L"," COMPUTER_CLASS_NAME);



static
HRESULT
buildEnumerator(
   SmartInterface<IADsContainer>&   container,
   IEnumVARIANT*&                   enumVariant);

static
HRESULT
buildEnumerator(IADsMembers& members, IEnumVARIANT*& enumVariant);

static
HRESULT
enumerateNext(
   IEnumVARIANT&  enumVariant,
   int            numberElementsToRead,
   _variant_t     destinationBuf[],
   int&           elementsRead);

static
HRESULT
freeEnumerator(IEnumVARIANT& enumerator);



static
HRESULT
buildEnumerator(
   SmartInterface<IADsContainer>&   container,
   IEnumVARIANT*&                   enumVariant)
{
   LOG_FUNCTION(buildEnumerator);

   return ::ADsBuildEnumerator(container, &enumVariant);
}



HRESULT
buildEnumerator(IADsMembers& members, IEnumVARIANT*& enumVariant)
{
   LOG_FUNCTION(buildEnumerator);

   // this fast-and-loose cast is from ADSI sample code...
   return ::ADsBuildEnumerator((IADsContainer*) &members, &enumVariant);
}



HRESULT
freeEnumerator(IEnumVARIANT& enumerator)
{
   LOG_FUNCTION(freeEnumerator);

   return ::ADsFreeEnumerator(&enumerator);
}



HRESULT
enumerateNext(
   IEnumVARIANT&  enumVariant,
   int            numberElementsToRead,
   _variant_t     destinationBuf[],
   int&           elementsRead)
{
   LOG_FUNCTION(enumerateNext);
   ASSERT(numberElementsToRead);

   ULONG n = 0;
   HRESULT hr =
      ::ADsEnumerateNext(
         &enumVariant,
         numberElementsToRead,
         destinationBuf,
         &n);

   // this cast is safe, as we never ask for more elements than can be
   // counted with an int.            
   elementsRead = static_cast<int>(n);
   return hr;
}



HRESULT
walkArray(
   _variant_t           varray[],
   int                  arraySize,
   ADSI::ObjectVisitor& visitor)
{
   LOG_FUNCTION(walkArray);

   HRESULT hr = S_OK;
   for (int i = 0; i < arraySize; i++ )
   {
      IDispatch* dispatch = varray[i].pdispVal;
      ASSERT(dispatch);

      if (dispatch)
      {
         IADs* object = 0;
         hr = dispatch->QueryInterface(QI_PARAMS(IADs, &object));
         BREAK_ON_FAILED_HRESULT(hr);
         ASSERT(object);

         if (object)
         {
            SmartInterface<IADs> so(0);
            so.Acquire(object);
            visitor.Visit(so);
         }
      }

      // we do not release dispatch, as this is done when the array is
      // destroyed: _variant_t::~_variant_t calls VariantClear.   As each
      // element has type VT_DISPATCH, VariantClear releases the interface for
      // us.
   }

   return hr;
}



HRESULT
walkEnumeration(IEnumVARIANT& enumerator, ADSI::ObjectVisitor& visitor)
{
   LOG_FUNCTION(walkEnumeration);

   // read 100 values at a time.
   static const int MAX_ADS_ENUM = 100;

   HRESULT hr = S_OK;
   bool done = false;
   do
   {
      _variant_t varray[MAX_ADS_ENUM];
      int objects_fetched = 0;

      hr =
         enumerateNext(
            enumerator,
            MAX_ADS_ENUM,
            varray,
            objects_fetched);
      BREAK_ON_FAILED_HRESULT(hr);
      done = (hr == S_FALSE) ? true : false;

      hr = walkArray(varray, objects_fetched, visitor);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (!done);

   return hr;
}



buildVarArrayStr(
   const StringVector&  strings,
   _variant_t&          v)
{
   LOG_FUNCTION(buildVarArrayStr);
   ASSERT(strings.size());

   PWSTR* a = new PWSTR[strings.size()];
   for (int i = 0; i < strings.size(); i++)
   {
      a[i] = const_cast<wchar_t*>(strings[i].c_str());
   }

   HRESULT hr =
      ::ADsBuildVarArrayStr(a, static_cast<DWORD>(strings.size()), &v);
   delete[] a;

   return hr;
}



HRESULT
ADSI::VisitChildren(
   const String&        containerPath,
   const String&        objectADSIClass,
   ADSI::ObjectVisitor& visitor)
{
   LOG_FUNCTION2(
      ADSI::VisitChildren,
      String::format(
         L"container: %1 class: %2",
         containerPath.c_str(),
         objectADSIClass.c_str()));
   ASSERT(!containerPath.empty());
   ASSERT(!objectADSIClass.empty());

   HRESULT hr = S_OK;

   // This interface must be released
   IEnumVARIANT* enumerator = 0;

   do
   {
      hr = CoInitialize(0);
      BREAK_ON_FAILED_HRESULT(hr);

      SmartInterface<IADsContainer> container(0);
      hr = ADSI::GetContainer(containerPath, container);
      // failure => not a valid container
      BREAK_ON_FAILED_HRESULT(hr);

      _variant_t filter;
      PWSTR a = const_cast<wchar_t*>(objectADSIClass.c_str());
      hr = ::ADsBuildVarArrayStr(&a, 1, &filter);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = container->put_Filter(filter);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = buildEnumerator(container, enumerator);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = walkEnumeration(*enumerator, visitor);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (enumerator)
   {
      freeEnumerator(*enumerator);
   }

   return hr;
}



HRESULT
ADSI::VisitMembers(
   const SmartInterface<IADsGroup>& group,
   ADSI::ObjectVisitor&             visitor)
{
   LOG_FUNCTION(ADSI::VisitMembers);

   HRESULT hr = S_OK;

   // these must be released when we're done
   IADsMembers* members = 0;      
   IEnumVARIANT* enumerator = 0;

   do
   {
      hr = group->Members(&members);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = buildEnumerator(*members, enumerator);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = walkEnumeration(*enumerator, visitor);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (enumerator)
   {
      freeEnumerator(*enumerator);
   }

   if (members)
   {
      members->Release();
   }

   return hr;
}


  
String
ADSI::ExtractObjectName(const String& ADSIPath)
{
   LOG_FUNCTION2(ADSI::ExtractObjectName, ADSIPath);
   ASSERT(!ADSIPath.empty());

   PathCracker cracker(ADSIPath);
   return cracker.leaf();
}



String
ADSI::ComposeMachineContainerPath(const String& computerName)
{
   return
         PROVIDER_ROOT
      +  computerName
      +  COMPUTER_SUFFIX;
}



HRESULT
ADSI::RenameObject(
   const String& containerADSIPath,
   const String& objectADSIPath,
   const String& newName)
{
   LOG_FUNCTION2(
      ADSI::RenameObject,
      String::format(
         L"container: %1 object: %2, new name: %3",
         containerADSIPath.c_str(),
         objectADSIPath.c_str(),
         newName.c_str()));
   ASSERT(!containerADSIPath.empty());
   ASSERT(!objectADSIPath.empty());
   ASSERT(!newName.empty());

   HRESULT hr = S_OK;
   do
   {
      SmartInterface<IADsContainer> container(0);
      hr = ADSI::GetContainer(containerADSIPath, container);
      BREAK_ON_FAILED_HRESULT(hr);

      IDispatch* object = 0;
      hr =
         container->MoveHere(
            AutoBstr(objectADSIPath),
            AutoBstr(newName),
            &object);
      BREAK_ON_FAILED_HRESULT(hr);
      ASSERT(object);
   }
   while (0);

   return hr;
}



HRESULT
ADSI::DeleteObject(
   const String& containerADSIPath,
   const String& objectRelativeName,
   const String& objectClass)
{
   LOG_FUNCTION2(
      ADSI::DeleteObject,
      String::format(
         L"container: %1 object: %2 class: %3",
         containerADSIPath.c_str(),
         objectRelativeName.c_str(),
         objectClass.c_str()));
   ASSERT(!containerADSIPath.empty());
   ASSERT(!objectRelativeName.empty());
   ASSERT(!objectClass.empty());

   HRESULT hr = S_OK;
   do
   {
      SmartInterface<IADsContainer> container(0);
      hr = ADSI::GetContainer(containerADSIPath, container);
      BREAK_ON_FAILED_HRESULT(hr);

      hr =
         container->Delete(
            AutoBstr(objectClass),
            AutoBstr(objectRelativeName));
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



HRESULT
ADSI::IsComputerAccessible(const String& machine)
{
   LOG_FUNCTION2(ADSI::IsComputerAccessible, machine);
   ASSERT(!machine.empty());

   String path = ADSI::ComposeMachineContainerPath(machine);
   SmartInterface<IADsContainer> container(0);
   return ADSI::GetContainer(path, container);
}



HRESULT
ADSI::VisitGroups(
   const SmartInterface<IADsUser>&  user,
   ADSI::ObjectVisitor&             visitor)
{   
   LOG_FUNCTION(ADSI::VisitGroups);

   HRESULT hr = S_OK;

   // these must be released when we're done
   IADsMembers* members = 0;      
   IEnumVARIANT* enumerator = 0;

   do
   {
      hr = user->Groups(&members);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = buildEnumerator(*members, enumerator);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = walkEnumeration(*enumerator, visitor);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (enumerator)
   {
      freeEnumerator(*enumerator);
   }

   if (members)
   {
      members->Release();
   }

   return hr;
}



// e.g. DOMAIN\account

String
ADSI::ExtractDomainObjectName(const String& ADSIPath)
{
   LOG_FUNCTION2(ADSI::ExtractDomainObjectName, ADSIPath);
   ASSERT(!ADSIPath.empty());

   String result(ADSIPath);

   size_t pos = ADSIPath.find_last_of(ADSI::PATH_SEP);
   if (pos != String::npos)
   {
      // the last '/' marks the user name, just prior to that is the machine
      // name (or the domain name), so find the 2nd to last '/'

      pos = ADSIPath.find_last_of(ADSI::PATH_SEP, pos - 1);
      if (pos != String::npos)
      {
         String s = ADSIPath.substr(pos + 1);
         result = s.replace(ADSI::PATH_SEP, L"\\");
      }
   }
   else
   {
      // there's something weird about the path

      ASSERT(false);
   }

   LOG(result);

   return result;
}



void
ADSI::FreeSid(SID* sid)
{
   ASSERT(sid);
   delete[] reinterpret_cast<BYTE*>(sid);
}



// allocates memory (with ::operator new) to hold a copy of the SID inside the
// variant.  returns a pointer to that memory as a SID*, which the caller
// should free with ADSI::FreeSid.

HRESULT
VariantToSid(VARIANT* var, SID*& result)
{
   LOG_FUNCTION(VariantToSid);
   ASSERT(var);
   ASSERT(V_VT(var) == (VT_ARRAY | VT_UI1));

   result = 0;

   HRESULT hr = S_OK;
   SAFEARRAY* psa = V_ARRAY(var);
   bool safeArrayAccessed = false;

   do
   {
      ASSERT(psa);
      ASSERT(psa != (SAFEARRAY*)-1);

      if (!psa or psa == (SAFEARRAY*)-1)
      {
         LOG(L"variant not safe array");
         hr = E_INVALIDARG;
         break;
      }

      if (::SafeArrayGetDim(psa) != 1)
      {
         LOG(L"safe array: wrong number of dimensions");
         hr = E_INVALIDARG;
         break;
      }

      if (::SafeArrayGetElemsize(psa) != 1)
      {
         LOG(L"safe array: wrong element type");
         hr = E_INVALIDARG;
         break;
      }

      PSID sid = 0;
      hr = ::SafeArrayAccessData(psa, reinterpret_cast<void**>(&sid));
      BREAK_ON_FAILED_HRESULT(hr);

      safeArrayAccessed = true;

      if (!::IsValidSid(sid))
      {
         LOG(L"sid not valid");
         hr = E_INVALIDARG;
         break;
      }

      // caller frees the result with ADSI::FreeSid
         
      DWORD bufSize = ::GetLengthSid(sid);
      BYTE* buffer = new BYTE[bufSize];
      ::ZeroMemory(buffer, bufSize);

      result = reinterpret_cast<SID*>(buffer);
      
      hr = Win::CopySid(bufSize, result, sid);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);
   
   if (safeArrayAccessed)
   {
      HRESULT unused = ::SafeArrayUnaccessData(psa);

      ASSERT(SUCCEEDED(unused));
   }

   if (FAILED(hr))
   {
      ADSI::FreeSid(result);
      result = 0;
   }

   LOG_HRESULT(hr);
   
   return hr;
}
   


// Converts a VARIANT containing a safe array of bytes to a WinNT SID-style
// path (WinNT://S-x-x...)

HRESULT
ADSI::VariantToSidPath(VARIANT* var, String& result)
{
   LOG_FUNCTION(ADSI::VariantToSidPath);
   ASSERT(var);
   ASSERT(V_VT(var) == (VT_ARRAY | VT_UI1));

   result.erase();

   HRESULT hr = S_OK;
   SID* sid = 0;

   do
   {
      hr = VariantToSid(var, sid);
      BREAK_ON_FAILED_HRESULT(hr);

      String sidString;      
      hr = Win::ConvertSidToStringSid(sid, sidString);
      BREAK_ON_FAILED_HRESULT(hr);

      result = ADSI::PROVIDER_ROOT + sidString;
   }
   while (0);
   
   ADSI::FreeSid(sid);

   LOG_HRESULT(hr);
   LOG(result);
   
   return hr;
}



HRESULT
ADSI::GetSid(const String& adsiPath, SID*& result)
{
   LOG_FUNCTION2(ADSI::GetSid, adsiPath);
   
   ASSERT(!adsiPath.empty());
   ASSERT(IsWinNTPath(adsiPath));

   HRESULT hr = S_OK;
   result = 0;

   do
   {
      SmartInterface<IADs> iads(0);
      IADs* p = 0;
      hr = 
         ::ADsGetObject(
            adsiPath.c_str(),
            QI_PARAMS(IADs, &p));
      BREAK_ON_FAILED_HRESULT(hr);

      iads.Acquire(p);

      hr = ADSI::GetSid(iads, result);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



HRESULT
ADSI::GetSid(const SmartInterface<IADs>& iads, SID*& result)
{
   LOG_FUNCTION(ADSI::GetSid);
   ASSERT(iads);

   result = 0;

   HRESULT hr = S_OK;

   do
   {
      // get the account SID

      _variant_t variant;
      hr = iads->Get(AutoBstr(ADSI::PROPERTY_ObjectSID), &variant);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = VariantToSid(&variant, result);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}


   
HRESULT
ADSI::GetSidPath(const SmartInterface<IADs>& iads, String& result)
{
   LOG_FUNCTION(ADSI::GetSidPath);
   ASSERT(iads);

   result.erase();

   HRESULT hr = S_OK;

   do
   {
      // get the account SID

      _variant_t variant;
      hr = iads->Get(AutoBstr(ADSI::PROPERTY_ObjectSID), &variant);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = ADSI::VariantToSidPath(&variant, result);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}

   

HRESULT
ADSI::GetSidPath(const String& adsiPath, String& result)
{
   LOG_FUNCTION2(ADSI::GetSidPath, adsiPath);
   ASSERT(!adsiPath.empty());
   ASSERT(IsWinNTPath(adsiPath));

   result.erase();

   HRESULT hr = S_OK;

   do
   {
      SmartInterface<IADs> iads(0);
      IADs* p = 0;
      hr = 
         ::ADsGetObject(
            adsiPath.c_str(),
            QI_PARAMS(IADs, &p));
      BREAK_ON_FAILED_HRESULT(hr);

      iads.Acquire(p);

      hr = ADSI::GetSidPath(iads, result);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



bool
ADSI::IsWinNTPath(const String& path)
{
   LOG_FUNCTION2(ADSI::IsWinNTPath, path);

   bool result = false;

   if (path.find(ADSI::PROVIDER_ROOT) == 0)
   {
      result = true;
   }

   LOG(result ? L"true" : L"false");

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\adsipage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// ASDIPage base class class
// 
// 10-30-97 sburns



#ifndef ADSIPAGE_HPP_INCLUDED
#define ADSIPAGE_HPP_INCLUDED



#include "mmcprop.hpp"



// ADSIPage is a base class for property pages for that are editing the
// properties of an ADSI object.

class ADSIPage : public MMCPropertyPage
{
   protected:

   // Constructs a new instance. Declared protected as this class may only
   // serve as a base class.
   //
   // dialogResID - See base class ctor.
   //
   // helpMap - See base class ctor.
   //
   // state - See base class ctor.
   //
   // objectADSIPath - The fully-qualified ADSI pathname of the object which
   // this node represents.

   ADSIPage(
      int                  dialogResID,
      const DWORD          helpMap[],
      NotificationState*   state,
      const String&        objectADSIPath);

   // Returns the path with which the object was constructed.

   String
   GetADSIPath() const;

   // Returns the object name of the ADSI object.

   String
   GetObjectName() const;

   // Returns the machine where the ADSI object resides.

   String
   GetMachineName() const;

   private:

   // not implemented: no copying allowed
   ADSIPage(const ADSIPage&);
   const ADSIPage& operator=(const ADSIPage&);

   String path;
};



#endif   // ADSIPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\comp.hpp ===
// Copyright (C) 1997 Microsoft Corporation, 1996 - 1997.
//
// IComponent implementation
//
// 9-2-97 sburns



#ifndef COMP_HPP_INCLUDED
#define COMP_HPP_INCLUDED



#include "scopnode.hpp"
#include "mmcprop.hpp"
#include "NodePointerExtractor.hpp"



// Implements IComponent.  An instance of this class is created for each MDI
// child of a particular "load" of a Snapin.

class Component 
   :
   public IComponent,
   public IExtendContextMenu,
   public IExtendPropertySheet /* ,
   public IResultDataCompare */
{
   // Only instances of ComponentData can create instances of this
   // class.
   friend class ComponentData;

   public:

   // IUnknown overrides

   virtual
   ULONG __stdcall
   AddRef();

   virtual
   ULONG __stdcall
   Release();

   virtual 
   HRESULT __stdcall
   QueryInterface(const IID& interfaceID, void** interfaceDesired);

   // IComponent overrides

   virtual
   HRESULT __stdcall   
   Initialize(IConsole* console);

   virtual
   HRESULT __stdcall
   Notify(
      IDataObject*      dataObject,
      MMC_NOTIFY_TYPE   event,
      LPARAM            arg,
      LPARAM            param);

   virtual
   HRESULT __stdcall
   Destroy(MMC_COOKIE cookie);

   virtual
   HRESULT __stdcall
   QueryDataObject(
     MMC_COOKIE         cookie,
     DATA_OBJECT_TYPES  type,
     IDataObject**      ppDataObject); 

   virtual
   HRESULT __stdcall
   GetResultViewType(MMC_COOKIE cookie, LPOLESTR* viewType, long* options);

   virtual
   HRESULT __stdcall
   GetDisplayInfo(RESULTDATAITEM* item);

   virtual
   HRESULT __stdcall
   CompareObjects(IDataObject* objectA, IDataObject* objectB);

   // IExtendContextMenu overrides

   virtual
   HRESULT __stdcall
   AddMenuItems(
      IDataObject*            dataObject,
      IContextMenuCallback*   callback,
      long*                   insertionAllowed);
    
   virtual
   HRESULT __stdcall
   Command(long commandID, IDataObject* dataObject);

   // IExtendPropertySheet overrides

   virtual
   HRESULT __stdcall
   CreatePropertyPages(
      IPropertySheetCallback* callback,
      LONG_PTR                handle,
      IDataObject*            dataObject);

   virtual
   HRESULT __stdcall
   QueryPagesFor(IDataObject* dataObject);

   // IResultDataCompare overrides

   // virtual
   // HRESULT __stdcall
   // Compare(
   //    LPARAM     userParam,
   //    MMC_COOKIE cookieA,  
   //    MMC_COOKIE cookieB,  
   //    int*       result);

   private:

   // only our friend class ComponentData can instantiate us.
   //
   // parent - the instantiating parent ComponentData object.

   Component(ComponentData* parent);

   // only Release can cause us to be deleted

   virtual
   ~Component();

   // MMCN_SHOW handler

   HRESULT
   DoShow(
      IDataObject&   dataObject,
      bool           selected // ,
      /* HSCOPEITEM     scopeID */ );

   // MMCN_ADD_IMAGES handler

   HRESULT
   DoAddImages(IImageList& imageList);

   // MMCN_REFRESH handler
      
   HRESULT
   DoRefresh(IDataObject& dataObject);

   // MMCN_SELECT handler
         
   HRESULT
   DoSelect(
      IDataObject&   dataObject,
      bool           selected);

   // MMCN_VIEW_CHANGE handler

   HRESULT
   DoViewChange(IDataObject& dataObject, bool clear);

   // MMCN_PROPERY_CHANGE handler

   HRESULT
   DoResultPaneRefresh(ScopeNode& node);

   // MMCN_RENAME handler

   HRESULT
   DoRename(
      IDataObject&   dataObject,
      const String&  newName);

   // MMCN_DELETE handler

   HRESULT
   DoDelete(IDataObject& dataObject);

   // not implemented; no instance copying allowed.

   Component(const Component&);
   void operator=(const Component&);

   SmartInterface<IConsole2>       console;
   SmartInterface<IConsoleVerb>    consoleVerb;
   SmartInterface<IHeaderCtrl>     headerCtrl;
   SmartInterface<ComponentData>   parent;
   SmartInterface<IResultData>     resultData;
   SmartInterface<ScopeNode>       selectedScopeNode;
   SmartInterface<IDisplayHelp>    displayHelp;

   // We need a buffer that will persist beyond the life time of this call.
   // This is needed because the item->str needs to be valid when this call
   // returns.  (the need for this buffer is a design flaw in MMC, which
   // should have the snapin allocate an LPOLESTR and free it when it is not
   // needed.).
   // 
   // The MMC docs claim it is not safe to deallocate the buffer until the
   // cookie is destroyed, the Component is destroyed (with
   // IComponent::Destroy), or GetDisplayInfo is called again for the same
   // cookie.  We will cache the last result for each cookie in a map with the
   // cookie as the key and the result String as the value.
   //    
   // This map has the same lifetime as the Component instance.  Access is
   // threadsafe as the COM object in which it lives is apartment threaded.

   typedef
      std::map<
         MMC_COOKIE,
         String,
         std::less<MMC_COOKIE>,
         Burnslib::Heap::Allocator<String> >
      CookieToStringMap;

   CookieToStringMap    displayInfoCache;    
   ComServerReference   dllref;              
   long                 refcount;            
   NodePointerExtractor nodePointerExtractor;
};



#endif   // COMP_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\cracker.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// ADSI::PathCracker class: a wrapper around a pretty poor interface...
// 
// 4-14-98 sburns



#include "headers.hxx"
#include "adsi.hpp"



#define LOG_PATH()                                                   \
         BSTR __path = 0;                                              \
         ipath->Retrieve(ADS_FORMAT_WINDOWS, &__path);                 \
         if (__path)                                                   \
         {                                                             \
            LOG(String::format(L"ADS_FORMAT_WINDOWS=%1", __path));   \
            ::SysFreeString(__path);                                   \
         }                                                             \
         BSTR __path2 = 0;                                             \
         ipath->Retrieve(ADS_FORMAT_SERVER, &__path2);                 \
         if (__path2)                                                  \
         {                                                             \
            LOG(String::format(L"ADS_FORMAT_SERVER=%1", __path2));   \
            ::SysFreeString(__path2);                                  \
         }                                                             \


ADSI::PathCracker::PathCracker(const String& adsiPath)
   :
   ipath(0),
   path(adsiPath)
{
   LOG_CTOR(ADSI::PathCracker);
   ASSERT(!path.empty());

   // we only support WinNT provider paths...   
   ASSERT(path.find(ADSI::PROVIDER) == 0);

   if (!path.empty())
   {
      ::CoInitialize(0);

      HRESULT hr = S_OK;
      do
      {
         hr =
            ipath.AcquireViaCreateInstance(
               CLSID_Pathname,
               0,
               CLSCTX_INPROC_SERVER);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = ipath->Set(AutoBstr(path), ADS_SETTYPE_FULL);
         ASSERT(SUCCEEDED(hr));
      }
      while (0);
   }
}



ADSI::PathCracker::~PathCracker()
{
   LOG_DTOR(ADSI::PathCracker);
}



void
ADSI::PathCracker::reset() const
{
   ASSERT(ipath);

   if (ipath)
   {
      HRESULT hr = ipath->Set(AutoBstr(path), ADS_SETTYPE_FULL);
      ASSERT(SUCCEEDED(hr));
   }
}
   


int
ADSI::PathCracker::elementCount() const
{
   ASSERT(ipath);

   if (ipath)
   {
      LOG_PATH();

      long elements = 0;
      HRESULT hr = ipath->GetNumElements(&elements);
      ASSERT(SUCCEEDED(hr));
      ASSERT(elements);

      return elements;
   }

   return 0;
}



String
ADSI::PathCracker::element(int index) const
{
   ASSERT(ipath);

   String result;
   if (ipath)
   {
      LOG_PATH();

      BSTR element = 0;
      HRESULT hr = ipath->GetElement(index, &element);
      ASSERT(SUCCEEDED(hr));
      ASSERT(element);
      if (element)
      {
         result = element;
         ::SysFreeString(element);
      }
   }

   LOG(String::format(L"element %1!d! = %2", index, result.c_str()));
   return result;
}



String
ADSI::PathCracker::containerPath() const
{
   ASSERT(ipath);

   String result;
   if (ipath)
   {
      do
      {
         LOG_PATH();         
         HRESULT hr = ipath->RemoveLeafElement();
         BREAK_ON_FAILED_HRESULT(hr);

         BSTR container = 0;
         hr = ipath->Retrieve(ADS_FORMAT_WINDOWS, &container);
         BREAK_ON_FAILED_HRESULT(hr);

         ASSERT(container);
         if (container)
         {
            result = container;
            // if (result[result.length() - 1] == ADSI::PATH_SEP[0])
            // {
            //    // IADsPath: sometimes leaves trailing '/'
            //    result.resize(result.length() - 1);
            // }
            ::SysFreeString(container);
         }
      }
      while (0);

      reset();
      LOG_PATH();
   }

   LOG(String::format(L"container path=%1", result.c_str()));
   return result;
}



String
ADSI::PathCracker::leaf() const
{
   return element(0);
}



String
ADSI::PathCracker::serverName() const
{
   ASSERT(ipath);

   String result;
   if (ipath)
   {
      LOG_PATH();

      // If the ms network client is not installed, then paths have the
      // form (1) WinNT://servername/objectname.  If it is installed, then
      // they are of the form (2) WinNT://domainname/servername/objectname.
      //
      // Not astonishingly, given the all-around badness of
      // IADsPathname, the server format returns the domain name for form
      // (2) paths, and the server name for form (1) paths.  And the 1st
      // element of the path after the provider name is unreachable
      // except with Retrieve!

      if (elementCount() >= 2)
      {
         // form (2) name, so get the next-to-last element
         return element(1);
      }

      BSTR server = 0;
      HRESULT hr = ipath->Retrieve(ADS_FORMAT_SERVER, &server);
      ASSERT(SUCCEEDED(hr));
      ASSERT(server);
      if (server)
      {
         result = server;
         ::SysFreeString(server);
      }
   }

   LOG(String::format(L"server=%1", result.c_str()));

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\creategroupdialog.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// CreateGroupDialog class
// 
// 10-15-97 sburns



#include "headers.hxx"
#include "CreateGroupDialog.hpp"
#include "resource.h"
#include "lsm.h"
#include "adsi.hpp"
#include "dlgcomm.hpp"
#include "MembershipListView.hpp"



static const DWORD HELP_MAP[] =
{
   IDC_NAME,                     idh_creategroup_name,
   IDC_DESCRIPTION,              idh_creategroup_description,
   IDC_MEMBERS,                  idh_creategroup_members,
   IDC_ADD,                      idh_creategroup_addbutton,
   IDC_REMOVE,                   idh_creategroup_removebutton,
   IDC_CREATE,                   idh_creategroup_createbutton,
   IDCANCEL,                     idh_creategroup_closebutton,
   0, 0
};



CreateGroupDialog::CreateGroupDialog(const String& machine_)
   :
   Dialog(IDD_CREATE_GROUP, HELP_MAP),
   listview(0),
   machine(machine_),
   refresh_on_exit(false)
{
   LOG_CTOR(CreateGroupDialog);
   ASSERT(!machine.empty());      
}
      


CreateGroupDialog::~CreateGroupDialog()
{
   LOG_DTOR(CreateGroupDialog);
}



void
CreateGroupDialog::OnDestroy()
{
   LOG_FUNCTION(CreateGroupDialog::OnDestroy);
   
   delete listview;
   listview = 0;
}



void
CreateGroupDialog::Enable()
{
//    LOG_FUNCTION(CreateGroupDialog::Enable);

   bool enable_create_button =
      !Win::GetTrimmedDlgItemText(hwnd, IDC_NAME).empty();
   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_CREATE),
      enable_create_button);

   bool selected =
      Win::ListView_GetSelectedCount(
         Win::GetDlgItem(hwnd, IDC_MEMBERS)) > 0;

   HWND removeButton = Win::GetDlgItem(hwnd, IDC_REMOVE);
   
   if (!selected)
   {
      // If we're about to disable the remove button, check to see if it
      // has focus first.  If it does, we need to move focus to another
      // control.  Similarly for default pushbutton style.
      // NTRAID#NTBUG9-435045-2001/07/13-sburns

      if (removeButton == ::GetFocus())
      {
         HWND addButton = Win::GetDlgItem(hwnd, IDC_ADD);
         Win::SetFocus(addButton);
         Win::Button_SetStyle(addButton, BS_DEFPUSHBUTTON, true);
         Win::Button_SetStyle(removeButton, BS_PUSHBUTTON, true);
      }
   }

   Win::EnableWindow(removeButton, selected);

}



void
CreateGroupDialog::Reset()
{
   LOG_FUNCTION(CreateGroupDialog::Reset);

   static const String blank;
   Win::SetDlgItemText(hwnd, IDC_NAME, blank);
   Win::SetDlgItemText(hwnd, IDC_DESCRIPTION, blank);
   Win::SetFocus(Win::GetDlgItem(hwnd, IDC_NAME));

   listview->ClearContents();

   Enable();
}
 


void
CreateGroupDialog::OnInit()
{
   LOG_FUNCTION(CreateGroupDialog::OnInit());

   listview =
      new MembershipListView(
         Win::GetDlgItem(hwnd, IDC_MEMBERS),
         machine,
         MembershipListView::GROUP_MEMBERSHIP);
   
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_NAME), GNLEN);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_DESCRIPTION), MAXCOMMENTSZ);

   Reset();
}



bool
CreateGroupDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(CreateGroupDialog::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_NAME:
      {
         if (code == EN_CHANGE)
         {
            Enable();

            // In case the close button took the default style when the create
            // button was disabled. (e.g. tab to close button while create is
            // disabled, then type in the name field, which enables the
            // button, but does not restore the default style unless we do
            // it ourselves)

            Win::Button_SetStyle(
               Win::GetDlgItem(hwnd, IDC_CREATE),
               BS_DEFPUSHBUTTON,
               true);
         }
         break;
      }
      case IDC_CREATE:
      {
         if (code == BN_CLICKED)
         {
            if (CreateGroup())
            {
               refresh_on_exit = true;               
               Reset();
            }
            else
            {
               Win::SetFocus(Win::GetDlgItem(hwnd, IDC_NAME));
            }
         }
         break;
      }
      case IDCANCEL:
      {
         HRESULT unused = Win::EndDialog(hwnd, refresh_on_exit);

         ASSERT(SUCCEEDED(unused));

         break;
      }
      case IDC_ADD:
      {
         if (code == BN_CLICKED)
         {
            listview->OnAddButton();
         }
         break;
      }
      case IDC_REMOVE:
      {
         if (code == BN_CLICKED)
         {
            listview->OnRemoveButton();
         }
         break;
      }
      default:
      {
         break;
      }
   }

   return true;
}



static
HRESULT
SaveGroupProperties(
   const SmartInterface<IADsGroup>& group,
   const String*                    description,
   const MemberList*                membership)
{
   HRESULT hr = S_OK;
   do
   {
      if (description)
      {
         hr = group->put_Description(AutoBstr(*description));
         BREAK_ON_FAILED_HRESULT(hr);
      }
      if (membership)
      {
         for (
            MemberList::iterator i = membership->begin();
            i != membership->end();
            i++)
         {
            MemberInfo& info = *i;

            // not found.  Add the node as a member of the group

            hr = group->Add(AutoBstr(info.path));
            BREAK_ON_FAILED_HRESULT(hr);
         }
         if (FAILED(hr))
         {
            break;
         }
      }

      // commit the property changes

      hr = group->SetInfo();
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



bool
CreateGroupDialog::CreateGroup()
{
   LOG_FUNCTION(CreateGroupDialog::CreateGroup);

   Win::CursorSetting cursor(IDC_WAIT);

   HRESULT hr = S_OK;

   String name = Win::GetTrimmedDlgItemText(hwnd, IDC_NAME);
   String desc = Win::GetTrimmedDlgItemText(hwnd, IDC_DESCRIPTION);

   // shouldn't be able to poke the Create button if this is empty

   ASSERT(!name.empty());

   if (!ValidateSAMName(hwnd, name, IDC_NAME))
   {
      return false;
   }

   SmartInterface<IADsGroup> group(0);
   do
   {
      // get a pointer to the machine container

      String path = ADSI::ComposeMachineContainerPath(machine);
      SmartInterface<IADsContainer> container(0);
      hr = ADSI::GetContainer(path, container);
      BREAK_ON_FAILED_HRESULT(hr);

      // create a group object in that container

      hr = ADSI::CreateGroup(container, name, group);
      BREAK_ON_FAILED_HRESULT(hr);

      // commit the create

      hr = group->SetInfo();
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_CREATING_GROUP,
            name.c_str(),
            machine.c_str()));
      return false;      
   }

   do
   {
      // these must be written after the commit

      MemberList new_members;
      listview->GetContents(new_members);

      hr =
         SaveGroupProperties(
            group, 
            desc.empty() ? 0 : &desc,
            new_members.empty() ? 0 : &new_members);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_SETTING_GROUP_PROPERTIES,
            name.c_str(),
            machine.c_str()));
      return false;
   }

   return true;
}



bool
CreateGroupDialog::OnNotify(
   HWND     /* windowFrom */ ,
   UINT_PTR controlIDFrom,
   UINT     code,
   LPARAM   lparam)
{
   LOG_FUNCTION(CreateGroupDialog::OnNotify);

   switch (controlIDFrom)
   {
      case IDC_MEMBERS:
      {
         switch (code)
         {
            case LVN_ITEMCHANGED:
            {
               ASSERT(lparam);

               if (lparam)
               {
                  NMLISTVIEW* lv = reinterpret_cast<NMLISTVIEW*>(lparam);
                  if (lv->uChanged & LVIF_STATE)
                  {
                     // a list item changed state

                     Enable();
                  }
               }
               break;
            }
            case LVN_KEYDOWN:
            {
               ASSERT(lparam);

               if (lparam)
               {
                  NMLVKEYDOWN* kd = reinterpret_cast<NMLVKEYDOWN*>(lparam);
                  if (kd->wVKey == VK_INSERT)
                  {
                     listview->OnAddButton();
                  }
                  else if (kd->wVKey == VK_DELETE)
                  {
                     listview->OnRemoveButton();
                  }
               }
               break;
            }
            case LVN_INSERTITEM:
            case LVN_DELETEITEM:
            {
               break;
            }
            default:
            {
               break;
            }
         }
         break;
      }
      default:
      {
      }
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\compdata.hpp ===
// Copyright (C) 1997 Microsoft Corporation, 1996 - 1997.
//
// Local Security MMC Snapin
//
// 8-12-97 sburns



#ifndef COMPDATA_HPP_INCLUDED
#define COMPDATA_HPP_INCLUDED



class Node;
class RootNode;



#include "NodePointerExtractor.hpp"



// class ComponentData implements IComponentData: there is one instance of
// this class for each time the snapin is loaded in a console.

class ComponentData
   :
   public IComponentData,
   public IExtendContextMenu,
   public IExtendPropertySheet,
   public IPersistStream,
   public ISnapinHelp,
   public IRequiredExtensions
{
   // this is the only entity with access to the ctor of this class
   friend class ClassFactory<ComponentData>; 

   public:

   // IUnknown overrides

   virtual
   ULONG __stdcall
   AddRef();

   virtual
   ULONG __stdcall
   Release();

   virtual 
   HRESULT __stdcall
   QueryInterface(const IID& interfaceID, void** interfaceDesired);

   // IComponentData overrides

   virtual
   HRESULT __stdcall
   CreateComponent(IComponent** ppComponent);

   virtual
   HRESULT __stdcall 
   CompareObjects(IDataObject* dataObjectA, IDataObject* dataObjectB);

   virtual
   HRESULT __stdcall 
   Destroy();

   virtual
   HRESULT __stdcall 
   GetDisplayInfo(SCOPEDATAITEM* item);

   virtual
   HRESULT __stdcall
   Initialize(IUnknown* consoleIUnknown);

   virtual
   HRESULT __stdcall 
   Notify(
      IDataObject*      dataObject,  
      MMC_NOTIFY_TYPE   event, 
      LPARAM            arg,  
      LPARAM            param);

   virtual
   HRESULT __stdcall 
   QueryDataObject( 
      MMC_COOKIE        cookie,  
      DATA_OBJECT_TYPES type,
      IDataObject**     ppDataObject);

   // IExtendContextMenu overrides

   virtual
   HRESULT __stdcall
   AddMenuItems(
      IDataObject*            dataObject,
      IContextMenuCallback*   callback,
      long*                   insertionAllowed);
    
   virtual
   HRESULT __stdcall
   Command(long commandID, IDataObject* dataObject);

   // IExtendPropertySheet overrides

   virtual
   HRESULT __stdcall
   CreatePropertyPages(
      IPropertySheetCallback* callback,
      LONG_PTR                handle,
      IDataObject*            dataObject);

   virtual
   HRESULT __stdcall
   QueryPagesFor(IDataObject* dataObject);

   // IPersist overrides

   virtual
   HRESULT __stdcall
   GetClassID(CLSID* pClassID);

   // IPersistStream overrides

   virtual
   HRESULT __stdcall
   IsDirty();

   virtual
   HRESULT __stdcall
   Load(IStream* stream);

   virtual
   HRESULT __stdcall
   Save(IStream* stream, BOOL /* clearDirty */);

   virtual
   HRESULT __stdcall
   GetSizeMax(ULARGE_INTEGER* size);

   // ISnapinHelp overrides

   virtual
   HRESULT __stdcall
   GetHelpTopic(LPOLESTR* compiledHelpFilename);

   // IRequiredExtensions overrides

   virtual
   HRESULT __stdcall
   EnableAllExtensions();

   virtual
   HRESULT __stdcall
   GetFirstExtension(LPCLSID extensionCLSID);

   virtual
   HRESULT __stdcall
   GetNextExtension(LPCLSID extensionCLSID);

   // ComponentData methods
   
   bool
   CanOverrideComputer() const;

   HRESULT
   LoadImages(IImageList& imageList);

   String
   GetInternalComputerName() const;

   String
   GetDisplayComputerName() const;

   SmartInterface<IConsole2>
   GetConsole() const;

   // Maps a MMC cookie to a Node instance.  Handles the special 0 cookie by
   // returning an instance set to be the root Node.  As Nodes are cookies,
   // this is simply a cast.
   //
   // cookie - MMC cookie to be mapped.

   Node*
   GetInstanceFromCookie(MMC_COOKIE cookie);

   HWND
   GetMainWindow() const;

   // true if the snapin is operating as an extension to another snapin
   // (namely, Computer Management)
   bool
   IsExtension() const;

   // true if the snapin is not working because the target machine is a
   // DC, or is not reachable, etc.
   
   bool
   IsBroken() const;

   String
   GetBrokenErrorMessage() const;

   private:

   // only our friend class factory can instantiate us.
   ComponentData();

   // only Release can cause us to be deleted
   ~ComponentData();

   HRESULT
   DoExpand(IDataObject& dataObject, bool expanding, HSCOPEITEM scopeID);

   HRESULT
   DoPreload(IDataObject& dataObject, HSCOPEITEM rootNodeScopeID);

   HRESULT
   DoRemoveChildren(IDataObject& dataObject, HSCOPEITEM parentScopeID);
      
   void
   EvaluateBrokenness();

   void
   SetComputerNames(const String& newName);

   HRESULT
   SetRootErrorIcon(HSCOPEITEM scopeID);

   // not implemented; no instance copying allowed.
   ComponentData(const ComponentData&);
   const ComponentData& operator=(const ComponentData&);

   String                             brokenErrorMessage;
   bool                               canOverrideComputer;
   bool                               isExtension;         
   bool                               isBroken;
   bool                               isBrokenEvaluated;
   bool                               isDirty;
   bool                               isDomainController;
   bool                               isHomeEditionSku;
   mutable String                     displayComputerName;
   mutable String                     internalComputerName;
   SmartInterface<IConsole2>          console;              
   SmartInterface<IConsoleNameSpace2> nameSpace;           
   SmartInterface<RootNode>           rootNode;
   ComServerReference                 dllref;               
   long                               refcount;



   // class NodeTypeExtractor implements methods used to extract a node type
   // from the CCF_NODETYPE clipboard format.

   class NodeTypeExtractor : public Extractor
   {
      public:

      NodeTypeExtractor()
         :
         Extractor(
            Win::RegisterClipboardFormat(CCF_NODETYPE),
            sizeof(NodeType))
      {
      }

      virtual
      ~NodeTypeExtractor()            
      {
      }
      
      NodeType
      Extract(IDataObject& dataObject)
      {
         HGLOBAL buf = GetData(dataObject);
         if (buf)
         {
            NodeType* ntp = reinterpret_cast<NodeType*>(buf);
            return *ntp;
         }

         return NodeType();
      }

      private:

      // not defined: no copying allowed

      NodeTypeExtractor(const NodeTypeExtractor&);
      const NodeTypeExtractor& operator=(const NodeTypeExtractor&);
   }

   // our instance:

   nodeTypeExtractor;



   // class MachineNameExtractor implements methods used to extract a node type
   // from the CCF_NODETYPE clipboard format.

   class MachineNameExtractor : public Extractor
   {
      public:

      MachineNameExtractor()
         :
         Extractor(
            Win::RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME"),

            // lots of space here to support machine names in any number
            // of formats
            (MAX_PATH + 1) * sizeof(wchar_t))
      {
      }

      virtual
      ~MachineNameExtractor()
      {
      }
      
      String
      Extract(IDataObject& dataObject)
      {
         HGLOBAL buf = GetData(dataObject);
         if (buf)
         {
            TCHAR* p = reinterpret_cast<TCHAR*>(buf);

            // skip leading whacks
            while (*p == L'\\')
            {
               ++p;
            }

            String result(p);
            if (result.empty())
            {
               // use the local machine

               result = Win::GetComputerNameEx(ComputerNameNetBIOS);
            }

            return result;
         }

         return String();
      }

      private:

      // not defined: no copying allowed

      MachineNameExtractor(const MachineNameExtractor&);
      const MachineNameExtractor& operator=(const MachineNameExtractor&);
   }

   // our instance:

   machineNameExtractor;



   NodePointerExtractor nodePointerExtractor;
};



#endif   // COMPDATA_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\creategroupdialog.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// CreateGroupDialog class
// 
// 10-15-97 sburns



#ifndef CREATEGROUPDIALOG_HPP_INCLUDED
#define CREATEGROUPDIALOG_HPP_INCLUDED



#include "dialog.hpp"



class MembershipListView;



class CreateGroupDialog : public Dialog
{
   public:

   // Constructs a new instance.
   // 
   // machine - computer name of the machine on which groups will be
   // created.

   CreateGroupDialog(const String& machine);

   virtual ~CreateGroupDialog();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnDestroy();

   virtual
   void
   OnInit();

   virtual
   bool
   OnNotify(
      HWND     windowFrom,
      UINT_PTR controlIDFrom,
      UINT     code,
      LPARAM   lparam);

   private:

   bool
   CreateGroup();

   void
   Enable();

   void
   Reset();

   String               machine;
   bool                 refresh_on_exit;
   MembershipListView*  listview;

   CreateGroupDialog(const CreateGroupDialog&);
   const CreateGroupDialog& operator=(const CreateGroupDialog&);
};



#endif CREATEGROUPDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\comp.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// IComponent implementation
//
// 9-2-97 sburns



#include "headers.hxx"
#include "comp.hpp"
#include "compdata.hpp"
#include "images.hpp"
#include "resource.h"
#include "resnode.hpp"
#include "mseldo.hpp"



Component::Component(ComponentData* parent_)
   :
   console(0),
   consoleVerb(0),
   headerCtrl(0),
   parent(parent_),
   refcount(1),       // implicit AddRef
   resultData(0),
   selectedScopeNode(0),
   displayHelp(0),
   displayInfoCache()
{
   LOG_CTOR(Component);
   ASSERT(parent);
}



Component::~Component()
{
   LOG_DTOR(Component);

   // ensure that everything has been released (in the Destroy method)

   ASSERT(!console);
   ASSERT(!consoleVerb);
   ASSERT(!headerCtrl);
   ASSERT(!parent);
   ASSERT(!refcount);
   ASSERT(!resultData);
   ASSERT(!selectedScopeNode);
   ASSERT(!displayHelp);
}



ULONG __stdcall
Component::AddRef()
{
   LOG_ADDREF(Component);   

   return Win::InterlockedIncrement(refcount);
}



ULONG __stdcall
Component::Release()
{
   LOG_RELEASE(Component);   

   if (Win::InterlockedDecrement(refcount) == 0)
   {
      delete this;
      return 0;
   }

   return refcount;
}



HRESULT __stdcall
Component::QueryInterface(
   const IID&  interfaceID,
   void**      interfaceDesired)
{
//   LOG_FUNCTION(Component::QueryInterface);
   ASSERT(interfaceDesired);

   HRESULT hr = 0;

   if (!interfaceDesired)
   {
      hr = E_INVALIDARG;
      LOG_HRESULT(hr);
      return hr;
   }

   if (interfaceID == IID_IUnknown)
   {
//      LOG(L"Supplying IUnknown interface");
      *interfaceDesired = static_cast<IUnknown*>(
         static_cast<IComponent*>(this));
   }
   else if (interfaceID == IID_IComponent)
   {
//      LOG(L"Supplying IComponent interface");
      *interfaceDesired = static_cast<IComponent*>(this);
   }
   else if (interfaceID == IID_IExtendContextMenu)
   {
//      LOG(L"Supplying IExtendContextMenu interface");
      *interfaceDesired = static_cast<IExtendContextMenu*>(this);
   }
   else if (interfaceID == IID_IExtendPropertySheet)
   {
//      LOG(L"Supplying IExtendPropertSheet interface");
      *interfaceDesired = static_cast<IExtendPropertySheet*>(this);
   }
//    else if (interfaceID == IID_IResultDataCompare)
//    {
// //      LOG(L"Supplying IResultDataCompare interface");
//       *interfaceDesired = static_cast<IResultDataCompare*>(this);
//    }
   else
   {
      *interfaceDesired = 0;
      hr = E_NOINTERFACE;
      LOG(
            L"interface not supported: "
         +  Win::StringFromGUID2(interfaceID));
      LOG_HRESULT(hr);
      return hr;
   }

   AddRef();
   return S_OK;
}



HRESULT __stdcall   
Component::Initialize(IConsole* c)
{
   LOG_FUNCTION(Component::Initialize);   
   ASSERT(c);

   HRESULT hr = S_OK;
   do
   {
      hr = console.AcquireViaQueryInterface(*c);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = resultData.AcquireViaQueryInterface(*console); 
      BREAK_ON_FAILED_HRESULT(hr);

      hr = headerCtrl.AcquireViaQueryInterface(*console); 
      BREAK_ON_FAILED_HRESULT(hr);

      hr = displayHelp.AcquireViaQueryInterface(*console); 
      BREAK_ON_FAILED_HRESULT(hr);

      IConsoleVerb* verb = 0;
      hr = console->QueryConsoleVerb(&verb);
      ASSERT(verb);
      consoleVerb.Acquire(verb);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



HRESULT __stdcall
Component::Notify(
   IDataObject*      dataObject,
   MMC_NOTIFY_TYPE   event,
   LPARAM            arg,
   LPARAM            param)
{
   LOG_FUNCTION(Component::Notify);   

   if (dataObject && IS_SPECIAL_DATAOBJECT(dataObject))
   {
      return E_NOTIMPL;
   }
                     
   HRESULT hr = S_FALSE;
   switch (event)
   {
      case MMCN_ADD_IMAGES:
      {
//         LOG(L"MMCN_ADD_IMAGES");
         ASSERT(arg);

         hr = DoAddImages(*reinterpret_cast<IImageList*>(arg));
         break;
      }
      case MMCN_ACTIVATE:
      {
//         LOG(L"MMCN_ACTIVATE");
         break;
      }
      case MMCN_BTN_CLICK:
      {
//         LOG(L"MMCN_BTN_CLICK");
         break;
      }
      case MMCN_COLUMN_CLICK:
      {
//         LOG(L"MMCN_COLUMN_CLICK");
         break;
      }
      case MMCN_CLICK:
      {
//         LOG(L"MMCN_CLICK");
         break;
      }
      case MMCN_DBLCLICK:
      {
//         LOG(L"MMCN_DBLCLICK");

         // allow the default context menu action

         hr = S_FALSE;  
         break;
      }
      case MMCN_DELETE:
      {
//         LOG(L"MMCN_DELETE");

         hr = DoDelete(*dataObject);
         break;
      }
      case MMCN_MINIMIZED:
      {
//         LOG(L"MMCN_MINIMIZED");
         break;
      }
      case MMCN_PROPERTY_CHANGE:
      {
         LOG(L"MMCN_PROPERTY_CHANGE");

         if (!arg)
         {
            // change was for a result pane item, refresh the pane this node
            // was the selected node when the prop sheet was created.

            ScopeNode* node = reinterpret_cast<ScopeNode*>(param);
            ASSERT(node);
            if (node)
            {
               hr = DoResultPaneRefresh(*node);

               // Since the call to MMCPropertyChangeNotify in
               // MMCPropertyPage::NotificationState::~NotificationState
               // has AddRef'd node, then we must Release that reference.
               //
               // NTRAID#NTBUG9-431831-2001/07/06-sburns               

               node->Release();
            }
            else
            {
               hr = E_INVALIDARG;
            }
         }
         break;
      }
      case MMCN_REFRESH:
      {
//         LOG(L"MMCN_REFRESH");
         ASSERT(dataObject);

         hr = DoRefresh(*dataObject);
         break;
      }
      case MMCN_RENAME:
      {
//         LOG(L"MMCN_RENAME");

         hr =
            DoRename(
               *dataObject,
               String(reinterpret_cast<PWSTR>(param)));
         break;
      }
      case MMCN_SELECT:
      {
//         LOG(L"MMCN_SELECT");
         ASSERT(dataObject);

         hr =
            DoSelect(
               *dataObject,  
               /* LOWORD(arg) ? true : false, */ // scope or result? who cares?
               HIWORD(arg) ? true : false); 
         break;
      }
      case MMCN_SHOW:
      {
//         LOG(L"MMCN_SHOW");
         ASSERT(dataObject);
      
         hr = DoShow(
            *dataObject,
            arg ? true : false
            /* reinterpret_cast<HSCOPEITEM>(param) who cares? */ );
         break;
      }
      case MMCN_VIEW_CHANGE:
      {
//         LOG(L"MMCN_VIEW_CHANGE");
         ASSERT(dataObject);

         hr = DoViewChange(*dataObject, arg ? true : false);
         break;
      }
      case MMCN_CONTEXTHELP:
      {
         LOG(L"MMCN_CONTEXTHELP");

         // fall thru
      }
      case MMCN_SNAPINHELP:
      {
         LOG(L"MMCN_SNAPINHELP");

         static const String HELPFILE(String::load(IDS_HTMLHELP_NAME));
         static const String TOPIC(String::load(IDS_HTMLHELP_OVERVIEW_TOPIC));

         String param = HELPFILE + L"::" + TOPIC;
         hr =
            displayHelp->ShowTopic(
               const_cast<wchar_t*>(param.c_str()));
         break;
      }
      default:
      {
         LOG(String::format(L"unhandled event 0x%1!08X!", event));

         break;
      }
   }

   return hr;
}



HRESULT __stdcall
Component::Destroy(MMC_COOKIE /* cookie */ )
{
   LOG_FUNCTION(Component::Destroy);     

   // We have to release these now, rather than upon calling of our dtor,
   // in order to break a circular dependency with MMC.

   resultData.Relinquish();
   headerCtrl.Relinquish();
   consoleVerb.Relinquish();
   console.Relinquish();
   parent.Relinquish();
   selectedScopeNode.Relinquish();
   displayHelp.Relinquish();

   return S_OK;
}



HRESULT __stdcall
Component::QueryDataObject(
  MMC_COOKIE         cookie,
  DATA_OBJECT_TYPES  type,
  IDataObject**      ppDataObject)
{
   LOG_FUNCTION(Component::QueryDataObject);     

   switch (cookie)
   {
      case MMC_MULTI_SELECT_COOKIE:
      {
         return E_NOTIMPL;

//          // create a multi-select data object, AddRef'd once.
//          MultiSelectDataObject* data_object = new MultiSelectDataObject();
// 
//          // walk the result pane and note the nodes that are selected.
//          RESULTDATAITEM item;
//          memset(&item, 0, sizeof(item));
//          item.mask = RDI_STATE;
//          item.nIndex = -1;
//          item.nState = TVIS_SELECTED;
// 
//          HRESULT hr = S_OK;
//          do
//          {
//             item.lParam = 0;
//             hr = resultData->GetNextItem(&item);
//             if (hr != S_OK)
//             {
//                break;
//             }
// 
//             ResultNode* node =
//                dynamic_cast<ResultNode*>(
//                   parent->GetInstanceFromCookie(item.lParam));
//             if (node)
//             {
//                data_object->AddDependent(node);
//             }
//             else
//             {
//                hr = E_INVALIDARG;
//                break;
//             }
//          }
//          while (1);
// 
//          if (SUCCEEDED(hr))
//          {
//             *ppDataObject = data_object;
//             return S_OK;
//          }
// 
//          // failure: cause the data object to delete itself
//          data_object->Release();
//          return hr;
      }
      case MMC_WINDOW_COOKIE:
      {
         // only used if the result pane is an error message window.

         return E_NOTIMPL;
      }
      default:
      {
         return parent->QueryDataObject(cookie, type, ppDataObject);
      }
   }
}



HRESULT __stdcall
Component::GetResultViewType(
   MMC_COOKIE  cookie,
   LPOLESTR*   viewType,
   long*       options)
{
   LOG_FUNCTION(Component::GetResultViewType);   
   ASSERT(viewType);
   ASSERT(options);

   if (parent->IsBroken())
   {
      // stringize the special CLSID, and pass that back.

      String mvs = Win::GUIDToString(CLSID_MessageView);
      return mvs.as_OLESTR(*viewType);
   }
      
   *viewType = 0;

   Node* node = parent->GetInstanceFromCookie(cookie);
   if (node)
   {
      ScopeNode* sn = dynamic_cast<ScopeNode*>(node);
      if (sn)
      {
         *options = sn->GetViewOptions();
         return S_FALSE;
      }
   }

   // no special view options

   *options = MMC_VIEW_OPTIONS_LEXICAL_SORT; 

   // use the default list view
   return S_FALSE;
}



HRESULT __stdcall
Component::GetDisplayInfo(RESULTDATAITEM* item)
{
//    LOG_FUNCTION(Component::GetDisplayInfo);    
   ASSERT(item);

   if (item)
   {
      // Extract the node in question from the item.  (the cookie is the
      // lParam member.)  This cookie should always be ours.

      MMC_COOKIE cookie = item->lParam;
      Node* node = parent->GetInstanceFromCookie(cookie);

      if (node)
      {
         // LOG(
         //    String::format(
         //       L"supplying display info for %1, column %2!u!",
         //       node->GetDisplayName().c_str(),
         //       item->nCol) ); 
            
         // Walk thru the item mask and fill in the info requested

         if (item->mask & RDI_STR)
         {
            // According to the MMC docs, it is safe to de/reallocate the
            // item->str member when GetDisplayInfo is called again for the
            // same cookie.  By replacing the value in the cache, we are
            // freeing the old memory.

            displayInfoCache[cookie] = node->GetColumnText(item->nCol);

            // the str member is a pointer to the raw string data in our
            // cache, which we will not alter until the cache is updated
            // for the same cookie.

            item->str =
               const_cast<wchar_t*>(
                  displayInfoCache[cookie].c_str() );
         }

         if (item->mask & RDI_IMAGE)
         {
            item->nImage = node->GetNormalImageIndex();
         }

         return S_OK;
      }
   }

   // bad cookie.  Yeech.
   return E_FAIL;
}



// used by MMC to ensure that properties on a node (data object) are not
// launched twice for the same object.

HRESULT __stdcall
Component::CompareObjects(
   IDataObject* objectA,
   IDataObject* objectB)
{
   LOG_FUNCTION(Component::CompareObjects);

   if (IS_SPECIAL_DATAOBJECT(objectA) || IS_SPECIAL_DATAOBJECT(objectB))
   {
      return E_UNEXPECTED;
   }

   return parent->CompareObjects(objectA, objectB);
}



// Handles the MMCN_SHOW event.
// 
// dataObject - the IDataObject of the ScopeNode that is being shown/hidden.
// 
// show - true if the node is being shown (i.e. should populate it's result
// pane), false if the node is being hidden.

HRESULT
Component::DoShow(
   IDataObject&   dataObject,
   bool           show)
{
   LOG_FUNCTION(Component::DoShow);

   HRESULT hr = S_FALSE;   
   if (!show)
   {
      selectedScopeNode.Relinquish();
      return hr;
   }

   // The data object is really a ScopeNode.

   ScopeNode* node = nodePointerExtractor.GetNode<ScopeNode*>(dataObject);
   ASSERT(node);

   if (node)
   {
      selectedScopeNode = node;
      do                                                        
      {
         if (parent->IsBroken())
         {
            // the snapin bombed initialization for some reason.  Set the
            // entire result pane to a nasty message indicating this
            // fact.  337324

            ASSERT(console);

            SmartInterface<IUnknown> resultPane;
            IUnknown* unk = 0;
            hr = console->QueryResultView(&unk);
            BREAK_ON_FAILED_HRESULT(hr);
            resultPane.Acquire(unk);

            SmartInterface<IMessageView> messageView;
            hr = messageView.AcquireViaQueryInterface(resultPane);
            BREAK_ON_FAILED_HRESULT(hr);

            LPOLESTR olestr = 0;
            String s = String::load(IDS_APP_ERROR_TITLE);

            // console is responsible for calling CoTaskMemFree on olestr

            hr = s.as_OLESTR(olestr);
            BREAK_ON_FAILED_HRESULT(hr);

            hr = messageView->SetTitleText(olestr);
            BREAK_ON_FAILED_HRESULT(hr);

            // console is responsible for calling CoTaskMemFree on olestr

            hr = parent->GetBrokenErrorMessage().as_OLESTR(olestr);
            BREAK_ON_FAILED_HRESULT(hr);

            hr = messageView->SetBodyText(olestr);
            BREAK_ON_FAILED_HRESULT(hr);

            hr = messageView->SetIcon(Icon_Error);
            BREAK_ON_FAILED_HRESULT(hr);

            break;
         }

         // load the columns of the listview 
         hr = node->InsertResultColumns(*headerCtrl);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = node->InsertResultItems(*resultData);
         BREAK_ON_FAILED_HRESULT(hr);

         hr =
            resultData->SetDescBarText(
               const_cast<wchar_t*>(
                  node->GetDescriptionBarText().c_str()));
         BREAK_ON_FAILED_HRESULT(hr);
      }
      while (0);
   }

   return hr;
}



HRESULT
Component::DoViewChange(IDataObject& dataObject, bool clear)
{
   LOG_FUNCTION(Component::DoViewChange);

   HRESULT hr = S_FALSE;
   do
   {
      if (!selectedScopeNode)
      {
         break;
      }

      // only reload the result pane if the selected node is the one
      // that caused the refresh.

      hr = CompareObjects(&dataObject, selectedScopeNode);
      BREAK_ON_FAILED_HRESULT(hr);

      if (hr == S_OK)
      {
         if (clear)
         {
            hr = resultData->DeleteAllRsltItems();
            BREAK_ON_FAILED_HRESULT(hr);
         }
         else
         {
            hr = selectedScopeNode->InsertResultItems(*resultData);
            BREAK_ON_FAILED_HRESULT(hr);
         }
      }
   }
   while (0);

   return hr;
}



HRESULT
Component::DoAddImages(IImageList& imageList)
{
   LOG_FUNCTION(Component::DoAddImages);

   static const IconIDToIndexMap map[] =
   {
      { IDI_USER,          USER_INDEX          },
      { IDI_GROUP,         GROUP_INDEX         },
      { IDI_DISABLED_USER, DISABLED_USER_INDEX },
      { 0, 0 }
   };

   // register the IComponentData image list plus our own.  This means that
   // there is one big image list used by IComponent and IComponentData,
   // and that the indices are unique for that big list.
   HRESULT hr = parent->LoadImages(imageList);
   if (SUCCEEDED(hr))
   {
      return IconIDToIndexMap::Load(map, imageList);
   }

   return hr;
}
   


HRESULT __stdcall
Component::AddMenuItems(
   IDataObject*            dataObject,
   IContextMenuCallback*   callback,
   long*                   insertionAllowed)
{
   LOG_FUNCTION(Component::AddMenuItems);

   // CODEWORK: this may be a multi-select data object?  (see DoDelete)

   // only process this call if the data object is 0 (which is the root node)
   // or the data object is not one of the "special" ones used as hacks by
   // MMC.

   if ((dataObject == 0) || !IS_SPECIAL_DATAOBJECT(dataObject))
   {
      Node* node = nodePointerExtractor.GetNode<Node*>(*dataObject);
      ASSERT(node);

      if (node)
      {
         return node->AddMenuItems(*callback, *insertionAllowed);
      }
   }

   return S_FALSE;
}


 
HRESULT __stdcall
Component::Command(long commandID, IDataObject* dataObject)
{
   LOG_FUNCTION(Component::Command);

   // CODEWORK: this may be a multi-select data object? (see DoDelete)

   // only process this call if the data object is 0 (which is the root node)
   // or the data object is not one of the "special" ones used as hacks by
   // MMC.

   if ((dataObject == 0) || !IS_SPECIAL_DATAOBJECT(dataObject))
   {
      Node* node = nodePointerExtractor.GetNode<Node*>(*dataObject);
      ASSERT(node);

      if (node)
      {
         return node->MenuCommand(*this, commandID);
      }
   }

   return E_NOTIMPL;
}



HRESULT __stdcall
Component::CreatePropertyPages(
   IPropertySheetCallback* callback,
   LONG_PTR                handle,
   IDataObject*            dataObject)
{
   LOG_FUNCTION(Component::CreatePropertyPages);
   ASSERT(callback);
   ASSERT(dataObject);

   // only process this call if the data object is 0 (which is the root node)
   // or the data object is not one of the "special" ones used as hacks by
   // MMC.

   if ((dataObject == 0) || !IS_SPECIAL_DATAOBJECT(dataObject))
   {
      ResultNode* node = nodePointerExtractor.GetNode<ResultNode*>(*dataObject);
      ASSERT(node);

      if (node)
      {
         // build the notification state object
         MMCPropertyPage::NotificationState* state =
            new MMCPropertyPage::NotificationState(handle, selectedScopeNode);

         return node->CreatePropertyPages(*callback, state);
      }
   }

   return E_NOTIMPL;
}



HRESULT __stdcall
Component::QueryPagesFor(IDataObject* dataObject)
{
   LOG_FUNCTION(Component::QueryPagesFor);
   ASSERT(dataObject);

   // only process this call if the data object is 0 (which is the root node)
   // or the data object is not one of the "special" ones used as hack by MMC.
   if ((dataObject == 0) || !IS_SPECIAL_DATAOBJECT(dataObject))
   {
      ResultNode* node = nodePointerExtractor.GetNode<ResultNode*>(*dataObject);
      ASSERT(node);

      if (node)
      {
         return node->HasPropertyPages() ? S_OK : S_FALSE;
      }
   }

   return S_FALSE;
}



HRESULT
Component::DoSelect(IDataObject& dataObject, bool selected)
{
   LOG_FUNCTION(Component::DoSelect);

   HRESULT hr = S_FALSE;

   if (!selected)
   {
      return hr;
   }

   // CODEWORK: this may be a multi-select data object? (see DoDelete)

   Node* node = nodePointerExtractor.GetNode<Node*>(dataObject);
   ASSERT(node);

   if (node)
   {
      return node->UpdateVerbs(*consoleVerb);
   }

   return hr;
}



HRESULT
Component::DoRefresh(IDataObject& dataObject)
{
   LOG_FUNCTION(Component::DoRefresh);

   ScopeNode* node = nodePointerExtractor.GetNode<ScopeNode*>(dataObject);
   ASSERT(node);

   HRESULT hr = S_FALSE;      
   if (node)
   {
      do
      {
         // first call, with the '1' parameter, means "call
         // IResultData::DeleteAllRsltItems if you care that dataObject is
         // about to rebuild itself" 
         hr = console->UpdateAllViews(&dataObject, 1, 0);
         if (FAILED(hr))
         {
            LOG_HRESULT(hr);
            // don't break...we need to update the views
         }

         hr = node->RebuildResultItems();
         if (FAILED(hr))
         {
            LOG_HRESULT(hr);
            // don't break...we need to update the views
         }

         // second call, with the '0' parameter, means, "now that your
         // result pane is empty, repopulate it."
         hr = console->UpdateAllViews(&dataObject, 0, 0);
         if (FAILED(hr))
         {
            LOG_HRESULT(hr);
         }
      }
      while (0);

      return hr;
   }

   return hr;
}



HRESULT
Component::DoResultPaneRefresh(ScopeNode& changedScopeNode)
{
   LOG_FUNCTION(Component::DoResultPaneRefresh);

   HRESULT hr = S_FALSE;      
   do
   {
      // JonN 7/16/01 437337
      // AV when change User's or Group Properties and use "New Window from Here"
      // If this window has already been closed, skip the refresh
      if (!parent)
         break;

      // Get the data object for the scopeNode.
      IDataObject* dataObject = 0;
      hr =
         parent->QueryDataObject(
            reinterpret_cast<MMC_COOKIE>(&changedScopeNode),
            CCT_RESULT,
            &dataObject);
      BREAK_ON_FAILED_HRESULT(hr);

      // causes changedScopeNode to be rebuilt and any result panes displaying
      // the contents of the node to be repopulated.
      hr = DoRefresh(*dataObject);
      dataObject->Release();
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



HRESULT
Component::DoRename(
   IDataObject&   dataObject,
   const String&  newName)
{
   LOG_FUNCTION(Component::DoRename);

   // only result nodes should be renameable.

   ResultNode* node = nodePointerExtractor.GetNode<ResultNode*>(dataObject);

   if (node)
   {
      return node->Rename(newName);
   }

   return S_FALSE;
}



// static
// MultiSelectDataObject*
// extractMultiSelectDataObject(IDataObject& dataObject)
// {
//    class MultiSelectDataObjectPointerExtractor : public Extractor
//    {
//       public:
// 
//       MultiSelectDataObjectPointerExtractor()
//          :
//          Extractor(
//             Win::RegisterClipboardFormat(MultiSelectDataObject::CF_PTR),
//             sizeof(MultiSelectDataObject*))
//       {
//       }
// 
//       MultiSelectDataObject*
//       Extract(IDataObject& dataObject)
//       {
//          MultiSelectDataObject* result = 0;
//          HGLOBAL mem = GetData(dataObject);
//          if (mem)
//          {
//             result = *(reinterpret_cast<MultiSelectDataObject**>(mem));
//             ASSERT(result);
//          }
// 
// #ifdef DBG
// 
//          // here we are counting on the fact that MultiSelectDataObject
//          // implements IDataObject, and that the data object we were given is
//          // really a MultiSelectDataObject.
//          MultiSelectDataObject* msdo =
//             dynamic_cast<MultiSelectDataObject*>(&dataObject);
//          ASSERT(msdo == result);
// #endif
// 
//          return result;
//       }
//    };
// 
//    static MultiSelectDataObjectPointerExtractor extractor;
// 
//    return extractor.Extract(dataObject);
// }



HRESULT
Component::DoDelete(IDataObject& dataObject)
{
   LOG_FUNCTION(Component::DoDelete);

   HRESULT hr = S_FALSE;

// @@ this does not work.  The data object here is a composite of all data
// objects returned by snapins responding to the multi-select QueryDataObject.
// Need to open the composite, find my data object that I returned from my querydataobject
// then iterate thru that.

//    MultiSelectDataObject* ms = extractMultiSelectDataObject(dataObject);
//    if (ms)
//    {
//       HRESULT hr = S_OK;
//       for (
//          MultiSelectDataObject::iterator i = ms->begin();
//          i != ms->end();
//          i++)
//       {
//          hr = (*i)->Delete();
//          if (FAILED(hr))
//          {
//             LOG_HRESULT(hr);
//             // don't break...we need to visit every node
//          }
//       }
// 
//       // refresh once all deletes have been done.
//       hr = DoResultPaneRefresh(*selectedScopeNode);
//       if (FAILED(hr))
//       {
//          LOG_HRESULT(hr);
//       }
// 
//       return hr;
//    }
//    else
   {
      // only result nodes should be deleteable.

      ResultNode* node = nodePointerExtractor.GetNode<ResultNode*>(dataObject);

      if (node)
      {
         do
         {
            hr = node->Delete();
            BREAK_ON_FAILED_HRESULT(hr);

            hr = DoResultPaneRefresh(*selectedScopeNode);
            BREAK_ON_FAILED_HRESULT(hr);
         }
         while(0);
      }
   }

   return hr;
}



// HRESULT __stdcall
// Component::Compare(
//    LPARAM     userParam,
//    MMC_COOKIE cookieA,  
//    MMC_COOKIE cookieB,  
//    int*       result)
// {
//    LOG_FUINCTION(Component::Compare);
//    ASSERT(result);
// 
//    HRESULT hr = S_OK;
// 
//    do
//    {
//       if (!result)
//       {
//          hr = E_INVALIDARG;
//          break;
//       }
// 
//       // on input, result is the column being compared.
// 
//       int column = *result;
//       *result = 0;
// 
//       Node* nodeA = parent->GetInstanceFromCookie(cookieA);
//       Node* nodeB = parent->GetInstanceFromCookie(cookieB);
//       ASSERT(nodeA && nodeB);
// 
//       if (nodeA && nodeB)
//       {
//          String text1 = nodeA->GetColumnText(column);
//          String text2 = nodeB->GetColumnText(column);
// 
//          *result = text1.icompare(text2);
//       }
//    }
//    while (0);
// 
//    LOG(
//          result
//       ?  String::format(L"result = %1!d!", *result)
//       :  L"result not set");
//    LOG_HRESULT(hr);
//       
//    return hr;
// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\compdata.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// Local Security MMC Snapin
//
// 8-19-97 sburns



#include "headers.hxx"
#include "compdata.hpp"
#include "rootnode.hpp"
#include "comp.hpp"
#include "resource.h"
#include "images.hpp"
#include "machine.hpp"
#include "uuids.hpp"
#include <compuuid.h>   // for Computer Management nodetypes
#include "adsi.hpp"
#include "dlgcomm.hpp"



// version number: bump this if you change the file layout
const unsigned VERSION_TAG = 1;
const unsigned CAN_OVERRIDE_MACHINE_FLAG = 0x01;
static NodeType SYS_TOOLS_NODE_TYPE = structuuidNodetypeSystemTools;



ComponentData::ComponentData()
   :
   canOverrideComputer(false),
   isExtension(false),
   isBroken(false),
   isBrokenEvaluated(false),
   isHomeEditionSku(false),
   console(0),
   nameSpace(0),
   refcount(1),    // implicit AddRef
   rootNode(0),
   isDirty(false),
   isDomainController(false)
{
   LOG_CTOR(ComponentData);

   // create the node object for the root node, implictly AddRef'd

   SmartInterface<ComponentData> spThis(this);
   rootNode.Acquire(new RootNode(spThis));
}



ComponentData::~ComponentData()
{
   LOG_DTOR(ComponentData);
   ASSERT(refcount == 0);
}



ULONG __stdcall
ComponentData::AddRef()
{
   LOG_ADDREF(ComponentData);

   return Win::InterlockedIncrement(refcount);
}



ULONG __stdcall
ComponentData::Release()
{
   LOG_RELEASE(ComponentData);

   if (Win::InterlockedDecrement(refcount) == 0)
   {
      delete this;
      return 0;
   }

   return refcount;
}



HRESULT __stdcall
ComponentData::QueryInterface(
   const IID&  interfaceID,
   void**      interfaceDesired)
{
//   LOG_FUNCTION(ComponentData::QueryInterface);
   ASSERT(interfaceDesired);

   HRESULT hr = 0;

   if (!interfaceDesired)
   {
      hr = E_INVALIDARG;
      LOG_HRESULT(hr);
      return hr;
   }

   if (interfaceID == IID_IUnknown)
   {
//      LOG(L"Supplying IUnknown interface");

      *interfaceDesired = static_cast<IUnknown*>(
         static_cast<IComponentData*>(this));
   }
   else if (interfaceID == IID_IComponentData)
   {
//      LOG(L"Supplying IComponentData interface");

      *interfaceDesired = static_cast<IComponentData*>(this);
   }
   else if (interfaceID == IID_IExtendContextMenu)
   {
//      LOG(L"Supplying IExtendContextMenu interface");

      *interfaceDesired = static_cast<IExtendContextMenu*>(this);
   }
   else if (interfaceID == IID_IExtendPropertySheet && !isExtension)
   {
      LOG(L"Supplying IExtendPropertySheet interface");

      *interfaceDesired = static_cast<IExtendPropertySheet*>(this);
   }
   else if (interfaceID == IID_IPersist)
   {
//      LOG(L"Supplying IPersist interface");

      *interfaceDesired = static_cast<IPersist*>(this);
   }
   else if (interfaceID == IID_IPersistStream)
   {
//      LOG(L"Supplying IPersistStream interface");

      *interfaceDesired = static_cast<IPersistStream*>(this);
   }
   else if (interfaceID == IID_ISnapinHelp)
   {
//      LOG(L"Supplying ISnapinHelp interface");

      *interfaceDesired = static_cast<ISnapinHelp*>(this);
   }
   else if (interfaceID == IID_IRequiredExtensions)
   {
//      LOG(L"Supplying IRequiredExtensions interface");

      *interfaceDesired = static_cast<IRequiredExtensions*>(this);
   }
   else
   {
      *interfaceDesired = 0;
      hr = E_NOINTERFACE;

      LOG(
            L"interface not supported: "
         +  Win::StringFromGUID2(interfaceID));
      LOG_HRESULT(hr);

      return hr;
   }

   AddRef();
   return S_OK;
}



HRESULT __stdcall
ComponentData::CreateComponent(IComponent** ppComponent)
{
   LOG_FUNCTION(ComponentData::CreateComponent);
   ASSERT(ppComponent);

   // this instance is implicitly AddRef'd by its ctor

   *ppComponent = new Component(this);
   return S_OK;
}



HRESULT __stdcall
ComponentData::CompareObjects(
   IDataObject* objectA,
   IDataObject* objectB)
{
   LOG_FUNCTION(ComponentData::CompareObjects);
   ASSERT(objectA);
   ASSERT(objectB);

   Node* nodeA = nodePointerExtractor.GetNode<Node*>(*objectA);
   Node* nodeB = nodePointerExtractor.GetNode<Node*>(*objectB);

   if (nodeA && nodeB)
   {
      // This needs to be a deep compare, because stale cookies (those that
      // are still held by MMC, but released by ScopeNode containers upon
      // refresh, for instance, may be compared.  Therefore, the addresses
      // of the nodes might be different, but still refer to the same
      // logical object.

      if (nodeA == nodeB)
      {
         // identity => equality

         return S_OK;
      }

      if (typeid(*nodeA) == typeid(*nodeB))
      {
         // the nodes are the same type

         if (nodeA->IsSameAs(nodeB))
         {
            return S_OK;
         }
      }
      return S_FALSE;
   }

   return E_UNEXPECTED;
}



HRESULT __stdcall
ComponentData::Destroy()
{
   LOG_FUNCTION(ComponentData::Destroy);

   // We have to release these now, rather than upon calling of our dtor,
   // in order to break a circular dependency with MMC.

   console.Relinquish();
   nameSpace.Relinquish();

   // rootNode is pointing back to us, so break the circular dependency.

   rootNode.Relinquish();

   return S_OK;
}



HRESULT __stdcall
ComponentData::GetDisplayInfo(SCOPEDATAITEM* item)
{
//   LOG_FUNCTION(ComponentData::GetDisplayInfo);
   ASSERT(item);

   // extract the node in question from the item

   ScopeNode* node =
      dynamic_cast<ScopeNode*>(GetInstanceFromCookie(item->lParam));
   ASSERT(node);

   if (node)
   {
      // LOG(
      //    String::format(
      //       L"supplying display info for %1",
      //       node->GetDisplayName().c_str()) );

      // Walk thru the item mask and fill in the info requested

      if (item->mask & SDI_STR)
      {
         item->displayname =
            const_cast<wchar_t*>(node->GetDisplayName().c_str());
      }
      if (item->mask & SDI_IMAGE)
      {
         item->nImage = node->GetNormalImageIndex();
      }
      if (item->mask & SDI_OPENIMAGE)
      {
         item->nOpenImage = node->GetOpenImageIndex();
      }

      return S_OK;
   }

   return E_FAIL;
}



HRESULT __stdcall
ComponentData::Initialize(IUnknown* consoleIUnknown)
{
   LOG_FUNCTION(ComponentData::Initialize);
   ASSERT(consoleIUnknown);

   HRESULT hr = S_OK;
   do
   {
      // Save important interface pointers

      hr = console.AcquireViaQueryInterface(*consoleIUnknown); 
      BREAK_ON_FAILED_HRESULT(hr);

      hr = nameSpace.AcquireViaQueryInterface(*consoleIUnknown);
      BREAK_ON_FAILED_HRESULT(hr);

      // Load the image list

      IImageList* scopeImageList = 0;
      hr = console->QueryScopeImageList(&scopeImageList);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = LoadImages(*scopeImageList);
      scopeImageList->Release();
   }
   while (0);

   return hr;
}



HRESULT
ComponentData::LoadImages(IImageList& imageList)
{
   LOG_FUNCTION(ComponentData::LoadImages);

   static IconIDToIndexMap map[] =
   {
      { IDI_FOLDER_OPEN,   FOLDER_OPEN_INDEX   },
      { IDI_FOLDER_CLOSED, FOLDER_CLOSED_INDEX },
      { IDI_ROOT_OPEN,     ROOT_OPEN_INDEX     },
      { IDI_ROOT_CLOSED,   ROOT_CLOSED_INDEX   },
      { IDI_ROOT_ERROR,    ROOT_ERROR_INDEX    },
      { 0, 0 }
   };

   return IconIDToIndexMap::Load(map, imageList);
}



HRESULT __stdcall
ComponentData::Notify(
   IDataObject*      dataObject,
   MMC_NOTIFY_TYPE   event,
   LPARAM            arg,
   LPARAM            param)
{
   LOG_FUNCTION(ComponentData::Notify);
   ASSERT(dataObject);

   HRESULT hr = S_FALSE;
   switch (event)
   {
      case MMCN_EXPAND:
      {
//         LOG(L"MMCN_EXPAND");

         hr =
            DoExpand(
               *dataObject,
               arg ? true : false,
               static_cast<HSCOPEITEM>(param));
         break;
      }
      case MMCN_REMOVE_CHILDREN:
      {
         LOG(L"MMCN_REMOVE_CHILDREN");

         hr =
            DoRemoveChildren(
               *dataObject,
               static_cast<HSCOPEITEM>(arg));
         break;
      }
      case MMCN_PRELOAD:
      {
         LOG(L"MMCN_PRELOAD");

         hr = DoPreload(*dataObject, static_cast<HSCOPEITEM>(arg));
         break;
      }
      default:
      {
         break;
      }
   }

   return hr;
}



// This is not really a preload: it's a pre-expand.  This message is sent
// after the console has called the Load method.

HRESULT
ComponentData::DoPreload(
   IDataObject&   /* dataObject */ ,
   HSCOPEITEM     rootNodeScopeID)
{
   LOG_FUNCTION(ComponentData::DoPreload);
   ASSERT(nameSpace);
   ASSERT(canOverrideComputer);
   ASSERT(!GetInternalComputerName().empty());
   ASSERT(rootNode);

   // Rename the root node for the command-line override

   String displayName = rootNode->GetDisplayName();
   SCOPEDATAITEM item;
   memset(&item, 0, sizeof(item));

   item.mask        = SDI_STR;                                  
   item.displayname = const_cast<wchar_t*>(displayName.c_str());
   item.ID          = rootNodeScopeID;                          

   return nameSpace->SetItem(&item);
}




HRESULT __stdcall
ComponentData::QueryDataObject(
   MMC_COOKIE        cookie,
   DATA_OBJECT_TYPES /* type */ ,
   IDataObject**     ppDataObject)
{
   // LOG_FUNCTION2(
   //    ComponentData::QueryDataObject,
   //    String::format(L"cookie: %1!08X!, type: 0x%2!08X!", cookie, type));
   ASSERT(ppDataObject);

   Node* node = GetInstanceFromCookie(cookie);
   ASSERT(node);

   if (node)
   {
      return
         node->QueryInterface(QI_PARAMS(IDataObject, ppDataObject));
   }

   return E_FAIL;
}



HRESULT
ComponentData::DoExpand(
   IDataObject& dataObject,
   bool         expanding, 
   HSCOPEITEM   scopeID)   
{
   LOG_FUNCTION(ComponentData::DoExpand);

   HRESULT hr = S_FALSE;

   do
   {
      if (!expanding)
      {
         break;
      }

      NodeType nodeType = nodeTypeExtractor.Extract(dataObject);

      if (nodeType == SYS_TOOLS_NODE_TYPE)
      {
         LOG(L"expanding computer management");

         // we're extending the System Tools node of Computer Management

         isExtension = true;

         // determine the machine Computer Management is targeted at.

         String machine = machineNameExtractor.Extract(dataObject);

         // This may be the first time we've expanded our root node under
         // the computer management tree, in which case our computer names
         // have not been set.  If that is the case, then we need to set them
         // and test for brokenness.  So we compare the name returned by
         // comp mgmt against our internal variable, not the result of
         // GetDisplayComputerName.

         if (displayComputerName.icompare(machine) != 0)
         {
            // different machine.

            SetComputerNames(machine);
            EvaluateBrokenness();
            isDirty = true;
         }

         // don't insert our node in the tree on home edition

         // don't insert our node in the tree on a domain controller
         // NTRAID#NTBUG9-328287-2001/02/26-sburns

         if (!isHomeEditionSku && !isDomainController)
         {
            hr = rootNode->InsertIntoScopePane(*nameSpace, scopeID);
         }

         
         break;
      }

      // not expanding computer management...
      
      ScopeNode* node = nodePointerExtractor.GetNode<ScopeNode*>(dataObject);
      ASSERT(node);

      if (!isBrokenEvaluated)
      {
         ASSERT(node == rootNode);
         EvaluateBrokenness();

         // change the root node icon (unless we're an extension, in which
         // case the normal image index mechanism will do the job -- in fact,
         // attempting to update the icon if we're an extension will be
         // rejected by the console)

         if (isBroken && !isExtension)
         {
            HRESULT unused = SetRootErrorIcon(scopeID);
            ASSERT(SUCCEEDED(unused));
         }
      }

      if (node)
      {
         hr = node->InsertScopeChildren(*nameSpace, scopeID);
      }
   }
   while (0);

   LOG_HRESULT(hr);
   
   return hr;
}



HRESULT
ComponentData::DoRemoveChildren(
   IDataObject&   dataObject,
   HSCOPEITEM     parentScopeID)
{
   LOG_FUNCTION(ComponentData::DoRemoveChildren);

   HRESULT hr = S_FALSE;

   NodeType nodeType = nodeTypeExtractor.Extract(dataObject);
   if (nodeType == SYS_TOOLS_NODE_TYPE)
   {
      // we're extending the System Tools node of Computer Management

      ASSERT(isExtension);

      hr = rootNode->RemoveScopeChildren(*nameSpace, parentScopeID);
   }
   else
   {
      ScopeNode* node = nodePointerExtractor.GetNode<ScopeNode*>(dataObject);
      ASSERT(node);

      if (node)
      {
         hr = node->RemoveScopeChildren(*nameSpace, parentScopeID);
      }
   }

   return hr;
}



HRESULT __stdcall
ComponentData::AddMenuItems(
   IDataObject*            dataObject,
   IContextMenuCallback*   callback,
   long*                   insertionAllowed)
{
   LOG_FUNCTION(ComponentData::AddMenuItems);
   ASSERT(dataObject);
   ASSERT(callback);
   ASSERT(insertionAllowed);

   HRESULT hr = S_OK;

   ScopeNode* node = nodePointerExtractor.GetNode<ScopeNode*>(*dataObject);
   ASSERT(node);

   if (node)
   {
      hr = node->AddMenuItems(*callback, *insertionAllowed);
   }

   return hr;
}



HRESULT __stdcall
ComponentData::Command(long commandID, IDataObject* dataObject)
{
   LOG_FUNCTION(ComponentData::Command);

   HRESULT hr = S_OK;

   ScopeNode* node = nodePointerExtractor.GetNode<ScopeNode*>(*dataObject);
   ASSERT(node);

   if (node)
   {
      hr = node->MenuCommand(*this, commandID);
   }

   return hr;
}



HRESULT __stdcall
ComponentData::CreatePropertyPages(
   IPropertySheetCallback* callback,
   LONG_PTR                handle,
   IDataObject*            dataObject)
{
   LOG_FUNCTION(ComponentData::CreatePropertyPages);
   ASSERT(callback);
   ASSERT(dataObject);

   HRESULT hr = S_FALSE;
   do
   {
      if (isExtension)
      {
         // we should not have provided IExtendPropertySheet in QI

         ASSERT(false);

         break;
      }

      ScopeNode* node = nodePointerExtractor.GetNode<ScopeNode*>(*dataObject);

      if (!node)
      {
         ASSERT(false);

         hr = E_UNEXPECTED;
         break;
      }

      // the data object is ours, and should be the root node.  The page
      // we will provide is the computer chooser.

      ASSERT(dynamic_cast<RootNode*>(node));

      SmartInterface<ScopeNode> spn(node);
      MMCPropertyPage::NotificationState* state =
         new MMCPropertyPage::NotificationState(handle, spn);

      ComputerChooserPage* chooserPage =
         new ComputerChooserPage(
            state,
            displayComputerName,
            internalComputerName,
            canOverrideComputer);
      chooserPage->SetStateOwner();

      do
      {
         HPROPSHEETPAGE hpage = chooserPage->Create();
         if (!hpage)
         {
            hr = Win::GetLastErrorAsHresult();
            break;
         }

         hr = callback->AddPage(hpage);
         if (FAILED(hr))
         {
            ASSERT(false);

            // note that this is another hr, not the one from the enclosing
            // scope.
             
            HRESULT unused = Win::DestroyPropertySheetPage(hpage);

            ASSERT(SUCCEEDED(unused));

            break;
         }

         isDirty = true;
      }
      while (0);

      if (FAILED(hr))
      {
         delete chooserPage;
      }
   }
   while (0);

   return hr;
}



// this should be only called from the snapin manager.

HRESULT __stdcall
ComponentData::QueryPagesFor(IDataObject* dataObject)
{
   LOG_FUNCTION(ComponentData::QueryPagesFor);
   ASSERT(dataObject);

   HRESULT hr = S_OK;

   do
   {
      if (isExtension)
      {
         // we should not have provided IExtendPropertySheet in QI

         ASSERT(false);

         hr = E_UNEXPECTED;
         break;
      }

      ScopeNode* node = nodePointerExtractor.GetNode<ScopeNode*>(*dataObject);

      if (!node)
      {
         ASSERT(false);

         hr = E_UNEXPECTED;
         break;
      }

      // the data object is ours, and should be the root node.  The page
      // we will provide is the computer chooser.

      ASSERT(dynamic_cast<RootNode*>(node));
   }
   while (0);

   return hr;
}



HRESULT __stdcall
ComponentData::GetClassID(CLSID* pClassID)
{
   LOG_FUNCTION(ComponentData::GetClassID);
   ASSERT(pClassID);

   *pClassID = CLSID_ComponentData;
   return S_OK;
}



HRESULT __stdcall
ComponentData::IsDirty()
{
   LOG_FUNCTION(ComponentData::IsDirty);

   return isDirty ? S_OK : S_FALSE;
}



String
GetComputerOverride()
{
   LOG_FUNCTION(getComputerOverride);

   static const String COMMAND(L"/Computer");
   static const size_t COMMAND_LEN = COMMAND.length();
   static const String LOCAL(L"LocalMachine");

   StringList args;
   Win::GetCommandLineArgs(std::back_inserter(args));

   // locate the override command arg

   String override;
   for (
      StringList::iterator i = args.begin();
      i != args.end();
      i++)
   {
      String prefix = i->substr(0, COMMAND_LEN);
      if (prefix.icompare(COMMAND) == 0)
      {
         override = *i;
         break;
      }
   }

   if (!override.empty())
   {
      // the command is in the form "/Computer=<machine>", where "<machine>"
      // may be "LocalMachine" for the local machine, or the name of a
      // particular computer.

      // +1 to skip any delimiter between /computer and the machine name

      String machine = override.substr(COMMAND_LEN + 1);
      if (!machine.empty() && (machine.icompare(LOCAL) != 0))
      {
         return Computer::RemoveLeadingBackslashes(machine);
      }
   }

   return String();
}



HRESULT __stdcall
ComponentData::Load(IStream* stream)
{
   LOG_FUNCTION(ComponentData::Load);
   ASSERT(stream);

   HRESULT hr = S_OK;
   String computerName;

   do
   {
      // version tag

      unsigned version = 0;
      hr = stream->Read(&version, sizeof(VERSION_TAG), 0);
      BREAK_ON_FAILED_HRESULT(hr);

      if (version != VERSION_TAG)
      {
         // make a big fuss about mismatched versions

         hr =
            console->MessageBox(
               String::format(
                  IDS_VERSION_MISMATCH,
                  version,
                  VERSION_TAG).c_str(),
               String::load(IDS_VERSION_MISMATCH_TITLE).c_str(),
               MB_OK | MB_ICONERROR | MB_TASKMODAL,
               0);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // flags

      unsigned flags = 0;
      hr = stream->Read(&flags, sizeof(flags), 0);
      BREAK_ON_FAILED_HRESULT(hr);

      canOverrideComputer = flags & CAN_OVERRIDE_MACHINE_FLAG;

      // computer name; we read this regardless of the override flag to
      // ensure that we consume all of our stream data. (I don't know that
      // this is required, but it seems courteous.)

      size_t len = 0;
      hr = stream->Read(&len, sizeof(len), 0);
      BREAK_ON_FAILED_HRESULT(hr);

      if (len)
      {
         computerName.resize(len);
         hr =
            stream->Read(
               const_cast<wchar_t*>(computerName.c_str()),
               static_cast<ULONG>(len * sizeof(wchar_t)),
               0);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // null terminator

      wchar_t t = 0;
      hr = stream->Read(&t, sizeof(t), 0);
      BREAK_ON_FAILED_HRESULT(hr);
      ASSERT(t == 0);
   }
   while (0);

   if (canOverrideComputer)
   {
      computerName = GetComputerOverride();
      isDirty = true;
   }

   // not specified, LocalMachine, or fouled up in some fashion, results in
   // focus on the local machine.

   if (computerName.empty())
   {
      computerName = Win::GetComputerNameEx(ComputerNameNetBIOS);
   }

   SetComputerNames(computerName);

   // evaluate this in case the machine is now a DC.
   EvaluateBrokenness();

   return hr;
}



HRESULT __stdcall
ComponentData::Save(IStream* stream, BOOL clearDirty)
{
   LOG_FUNCTION(ComponentData::Save);
   ASSERT(stream);

   HRESULT hr = S_OK;
   do
   {
      // version tag

      hr = stream->Write(&VERSION_TAG, sizeof(VERSION_TAG), 0);
      BREAK_ON_FAILED_HRESULT(hr);

      // flags

      unsigned flags = 0;
      if (canOverrideComputer)
      {
         flags |= CAN_OVERRIDE_MACHINE_FLAG;
      }
      hr = stream->Write(&flags, sizeof(flags), 0);
      BREAK_ON_FAILED_HRESULT(hr);

      // computer name

      size_t len = GetDisplayComputerName().length();

      // CODEWORK: why not store a Computer object with the internal and
      // display names, and use the IsLocal method here?

      if (Win::IsLocalComputer(GetInternalComputerName()))
      {
         // the snapin is focused on the local machine, so don't write
         // the name to the file

         len = 0;
      }

      hr = stream->Write(&len, sizeof(len), 0);
      BREAK_ON_FAILED_HRESULT(hr);

      if (len)
      {
         hr = stream->Write(
            GetDisplayComputerName().c_str(),
            static_cast<ULONG>(len * sizeof(wchar_t)),
            0);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // null terminator

      wchar_t t = 0;
      hr = stream->Write(&t, sizeof(t), 0);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (clearDirty)
   {
      isDirty = false;
   }
   
   return hr;
}



HRESULT __stdcall
ComponentData::GetSizeMax(ULARGE_INTEGER* size)
{
   LOG_FUNCTION(ComponentData::GetSizeMax);

   size->HighPart = 0;
   size->LowPart =
         sizeof(unsigned)  // version number
      +  sizeof(unsigned)  // flags
      +  sizeof(size_t)    // computer name length, incl null terminator
      +  sizeof(wchar_t) * (MAX_COMPUTERNAME_LENGTH + 1);

   return S_OK;
}



String
ComponentData::GetInternalComputerName() const
{
   if (internalComputerName.empty())
   {
      return Win::GetComputerNameEx(ComputerNameNetBIOS);
   }

   return internalComputerName;
}



String
ComponentData::GetDisplayComputerName() const
{
   if (displayComputerName.empty())
   {
      // CODEWORK: should use fully-qualified DNS if tcp/ip present

      return Win::GetComputerNameEx(ComputerNameNetBIOS);
   }

   return displayComputerName;
}



bool
ComponentData::CanOverrideComputer() const
{
   return canOverrideComputer;
}



HWND
ComponentData::GetMainWindow() const
{
   LOG_FUNCTION(ComponentData::GetMainWindow);

   if (console)
   {
      HWND w = 0;
      HRESULT hr = console->GetMainWindow(&w);
      ASSERT(SUCCEEDED(hr));
      return w;
   }

   ASSERT(false);
   return 0;
}



SmartInterface<IConsole2>
ComponentData::GetConsole() const
{
   LOG_FUNCTION(ComponentData::GetConsole);

   return console;
}



Node*
ComponentData::GetInstanceFromCookie(MMC_COOKIE cookie)
{
//   LOG_FUNCTION(ComponentData::GetInstanceFromCookie);

   if (cookie == 0)
   {
      // null cookie => the root node of the owner, which had better be set
      // by now
      ASSERT(rootNode);
      return rootNode;
   }
   else if (IS_SPECIAL_COOKIE(cookie))
   {
      ASSERT(false);
      return 0;
   }

   return reinterpret_cast<Node*>(cookie);
}



bool
ComponentData::IsExtension() const
{
   // set in DoExpand
   return isExtension;
}



HRESULT __stdcall
ComponentData::GetHelpTopic(LPOLESTR* compiledHelpFilename)
{
   LOG_FUNCTION(ComponentData::GetHelpTopic);
   ASSERT(compiledHelpFilename);

   if (!compiledHelpFilename)
   {
      return E_POINTER;
   }

   String help =
      Win::GetSystemWindowsDirectory() + String::load(IDS_HTMLHELP_NAME);
   return help.as_OLESTR(*compiledHelpFilename);
}



HRESULT __stdcall
ComponentData::EnableAllExtensions()
{
   LOG_FUNCTION(ComponentData::EnableAllExtensions);

   // we don't want all extensions; just the RAS one.
   return S_FALSE;
}



HRESULT __stdcall
ComponentData::GetFirstExtension(LPCLSID extensionCLSID)
{
   LOG_FUNCTION(ComponentData::GetFirstExtension);

   // Now why do you suppose the MMC folks couldn't express this iteration
   // with just the GetNext function?

   static const CLSID RAS_EXTENSION_CLSID =
   { /* B52C1E50-1DD2-11D1-BC43-00C04FC31FD3 */
      0xB52C1E50,
      0x1DD2,
      0x11D1,
      {0xBC, 0x43, 0x00, 0xc0, 0x4F, 0xC3, 0x1F, 0xD3}
   };

   memcpy(extensionCLSID, &RAS_EXTENSION_CLSID, sizeof(CLSID));
   return S_OK;
}




HRESULT __stdcall
ComponentData::GetNextExtension(LPCLSID extensionCLSID)
{
   LOG_FUNCTION(ComponentData::GetNextExtension);

   // no additional required extensions beyond the first.
   memset(extensionCLSID, 0, sizeof(CLSID));
   return S_FALSE;
}



bool
ComponentData::IsBroken() const
{
   LOG_FUNCTION(ComponentData::IsBroken);

   return isBroken;
}



String
ComponentData::GetBrokenErrorMessage() const
{
   LOG_FUNCTION2(ComponentData::GetBrokenErrorMessage, brokenErrorMessage);
   ASSERT(IsBroken());

   return brokenErrorMessage;
}



void
ComponentData::EvaluateBrokenness()
{
   LOG_FUNCTION(ComponentData::EvaluateBrokenness);

   isBroken           = false;
   isHomeEditionSku   = false;
   isDomainController = false;

   // bind to the computer to verify its accessibility
   
   HRESULT hr = S_OK;

   String internalName = GetInternalComputerName();
   Computer c(internalName);
   do
   {
      // Check that the machine is Windows NT-based 24644
      // and not Windows Home Edition NTRAID#NTBUG9-145309 NTRAID#NTBUG9-145288

      unsigned errorResId = 0;
      hr = CheckComputerOsIsSupported(internalName, errorResId);
      BREAK_ON_FAILED_HRESULT(hr);

      if (hr == S_FALSE)
      {
         isBroken = true;
         brokenErrorMessage =
            String::format(
               errorResId,
               GetDisplayComputerName().c_str());
         isBrokenEvaluated = true;

         if (errorResId == IDS_MACHINE_IS_HOME_EDITION_LOCAL)
         {
            isHomeEditionSku = true;
         }
         
         return;
      }

      // CODEWORK?? should we hold on to the bound computer object
      // to make sure we can access the machine for the life of this
      // session?

      hr = ADSI::IsComputerAccessible(internalName);
      BREAK_ON_FAILED_HRESULT(hr);

      // 340379

      hr = c.Refresh();
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      isBroken = true;
      brokenErrorMessage =
         String::format(
            IDS_CANT_ACCESS_MACHINE,
            GetDisplayComputerName().c_str(),
            GetErrorMessage(hr).c_str());
   }
   else if (c.IsDomainController())
   {
      isBroken = true;
      isDomainController = true;
      brokenErrorMessage =
         String::format(
               IsExtension()
            ?  IDS_ERROR_DC_NOT_SUPPORTED_EXT
            :  IDS_ERROR_DC_NOT_SUPPORTED,
            GetDisplayComputerName().c_str());
   }

   isBrokenEvaluated = true;
}



HRESULT
ComponentData::SetRootErrorIcon(HSCOPEITEM scopeID)
{
   LOG_FUNCTION(ComponentData::SetRootErrorIcon);

   SCOPEDATAITEM item;
   memset(&item, 0, sizeof(item));

   item.mask =
         SDI_IMAGE
      |  SDI_OPENIMAGE;

   item.nImage     = ROOT_ERROR_INDEX;
   item.nOpenImage = ROOT_ERROR_INDEX;
   item.ID         = scopeID;         

   return nameSpace->SetItem(&item);
}



void
ComponentData::SetComputerNames(const String& newName)
{
   LOG_FUNCTION2(ComponentData::SetComputerNames, newName);

   ::SetComputerNames(newName, displayComputerName, internalComputerName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\dlgcomm.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Shared Dialog code
// 
// 10-24-97 sburns



#include "headers.hxx"
#include "dlgcomm.hpp"
#include "adsi.hpp"
#include "resource.h"



bool
IsValidPassword(
   HWND  dialog,
   int   passwordResID,
   int   confirmResID)
{
   LOG_FUNCTION(IsValidPassword);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(passwordResID);
   ASSERT(confirmResID);

   String password = Win::GetDlgItemText(dialog, passwordResID);
   String confirm = Win::GetDlgItemText(dialog, confirmResID);

   if (password != confirm)
   {
      Win::SetDlgItemText(dialog, passwordResID, String());
      Win::SetDlgItemText(dialog, confirmResID, String());
      popup.Gripe(dialog, passwordResID, IDS_PASSWORD_MISMATCH);
      return false;
   }

   return true;
}
   


void
DoUserButtonEnabling(
   HWND  dialog,
   int   mustChangeResID,
   int   cantChangeResID,
   int   neverExpiresResID)
{
   LOG_FUNCTION(DoUserButtonEnabling);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(mustChangeResID);
   ASSERT(cantChangeResID);
   ASSERT(neverExpiresResID);

   static const int MUST_ENABLED  = 0x4;
   static const int CANT_ENABLED  = 0x2;
   static const int NEVER_ENABLED = 0x1;
   
   static const int truthTable[] =
   {
      MUST_ENABLED | CANT_ENABLED | NEVER_ENABLED, // none checked
      0            | CANT_ENABLED | NEVER_ENABLED, // never checked
      0            | CANT_ENABLED | NEVER_ENABLED, // cant checked
      0            | CANT_ENABLED | NEVER_ENABLED, // cant and never 
      MUST_ENABLED | 0            | 0,             // must checked   
      MUST_ENABLED | 0            | 0,             // must and never
      MUST_ENABLED | CANT_ENABLED | 0,             // must and cant
      MUST_ENABLED | CANT_ENABLED | 0              // all checked
   };
      
   int truthTableIndex = 0;
   truthTableIndex |= (NEVER_ENABLED * Win::IsDlgButtonChecked(dialog, neverExpiresResID));
   truthTableIndex |= (CANT_ENABLED  * Win::IsDlgButtonChecked(dialog, cantChangeResID));      
   truthTableIndex |= (MUST_ENABLED  * Win::IsDlgButtonChecked(dialog, mustChangeResID));
   
   Win::EnableWindow(
      Win::GetDlgItem(dialog, mustChangeResID),
      (truthTable[truthTableIndex] & MUST_ENABLED) ? true : false);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, cantChangeResID),
      (truthTable[truthTableIndex] & CANT_ENABLED) ? true : false);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, neverExpiresResID),
      (truthTable[truthTableIndex] & NEVER_ENABLED) ? true : false);
}



  
// Sets or clears a bit, or set of bits.
// 
// bits - bit set where bits will be set.
// 
// mask - mask of bits to be effected.
// 
// state - true to set the mask bits, false to clear them.

void
tweakBits(long& bits, long mask, bool state)
{
   ASSERT(mask);

   if (state)
   {
      bits |= mask;
   }
   else
   {
      bits &= ~mask;
   }
}




HRESULT
SaveUserProperties(
   const SmartInterface<IADsUser>&  user,
   const String*                    fullName,
   const String*                    description,
   const bool*                      disable,
   const bool*                      mustChangePassword,
   const bool*                      cannotChangePassword,
   const bool*                      passwordNeverExpires,
   const bool*                      isLocked)
{
   HRESULT hr = S_OK;
   do
   {
      if (fullName)
      {
         hr = user->put_FullName(AutoBstr(*fullName));
         BREAK_ON_FAILED_HRESULT(hr);
      }
      if (description)
      {
         hr = user->put_Description(AutoBstr(*description));
         BREAK_ON_FAILED_HRESULT(hr);
      }
      if (mustChangePassword)
      {
         long value = *mustChangePassword ? 1 : 0;
         _variant_t variant(value);
         hr = user->Put(AutoBstr(ADSI::PROPERTY_PasswordExpired), variant);
         BREAK_ON_FAILED_HRESULT(hr);
      }
      if (disable)
      {
         VARIANT_BOOL value = *disable ? VARIANT_TRUE : VARIANT_FALSE;
         hr = user->put_AccountDisabled(value);
         BREAK_ON_FAILED_HRESULT(hr);
      }
      if (cannotChangePassword || passwordNeverExpires)
      {
         // read the existing flags
         _variant_t get_variant;
         hr = user->Get(AutoBstr(ADSI::PROPERTY_UserFlags), &get_variant);
         BREAK_ON_FAILED_HRESULT(hr);
         long flags = get_variant;
         
         if (cannotChangePassword)
         {
            tweakBits(flags, UF_PASSWD_CANT_CHANGE, *cannotChangePassword);
         }
         if (passwordNeverExpires)
         {
            tweakBits(flags, UF_DONT_EXPIRE_PASSWD, *passwordNeverExpires);
         }

         _variant_t put_variant(flags);
         hr = user->Put(AutoBstr(ADSI::PROPERTY_UserFlags), put_variant);
         BREAK_ON_FAILED_HRESULT(hr);
      }
      if (isLocked)
      {
         VARIANT_BOOL value = *isLocked ? VARIANT_TRUE : VARIANT_FALSE;
         hr = user->put_IsAccountLocked(value);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // commit the property changes
      hr = user->SetInfo();
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



bool
IsValidSAMName(const String& name)
{
   LOG_FUNCTION2(IsValidSAMName, name);

   static const String ILLEGAL_SAM_CHARS(ILLEGAL_FAT_CHARS L"@");
   
   if (name.find_first_of(ILLEGAL_SAM_CHARS) == String::npos)
   {
      // does not contain bad chars

      // remove all spaces and periods
      String n = name;
      n.replace(L" ", String());
      n.replace(L".", String());
      if (!n.empty())
      {
         // not just spaces & periods
         return true;
      }
   }

   return false;
}



bool
ValidateSAMName(HWND dialog, const String& name, int editResID)
{
   LOG_FUNCTION(ValidateSAMName);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(editResID > 0);

   if (!IsValidSAMName(name))
   {
      popup.Gripe(
         dialog,
         editResID,
         String::format(IDS_BAD_SAM_NAME, name.c_str()));
      return false;
   }

   return true;
}



void
SetComputerNames(
   const String&  newName,
   String&        displayComputerName,
   String&        internalComputerName)
{
   LOG_FUNCTION2(SetComputerNames, newName);

   // The idea here is to take the new name, and pass it thru
   // NetWkstaGetInfo, then compare the computer name returned (which is
   // the netbios name) to the newName.  If they are the same, then newName
   // is a netbios name.  If not, then it is a DNS name or IP address.

   // we want to make the internal computer name the netbios name, as that
   // is the name that the ADSI WinNT provider works best with.

   // display name is always the one supplied externally (from the user,
   // from a saved console file, from comp mgmt snapin)

   displayComputerName = newName;

   // initially, the internal name is also the display name.  If the new name
   // is not a netbios name, then we will replace it below.

   internalComputerName = newName;

   WKSTA_INFO_100* info = 0;
   HRESULT hr = MyNetWkstaGetInfo(newName, info);

   if (SUCCEEDED(hr) && info)
   {
      internalComputerName = info->wki100_computername;
      ::NetApiBufferFree(info);
   }

   LOG(
      String::format(
         L"%1 %2 a netbios name.",
         newName.c_str(),
         (newName.icompare(internalComputerName) == 0) ? L"is" : L"is not"));
}



bool
IsLocalComputer(const String& name)
{
   LOG_FUNCTION2(IsLocalComputer, name);
   ASSERT(!name.empty());

   bool result = false;

   do
   {
      String localNetbiosName = Win::GetComputerNameEx(ComputerNameNetBIOS);

      if (name.icompare(localNetbiosName) == 0)
      {
         result = true;
         break;
      }

      String localDnsName =
         Win::GetComputerNameEx(ComputerNameDnsFullyQualified);

      if (name.icompare(localDnsName) == 0)
      {
         // the given name is the same as the fully-qualified dns name
      
         result = true;
         break;
      }
   }
   while (0);

   LOG(result ? L"true" : L"false");

   return result;
}



HRESULT
CheckComputerOsIsSupported(const String& name, unsigned& errorResId)
{
   LOG_FUNCTION2(CheckComputerOsIsSupported, name);
   ASSERT(!name.empty());

   HRESULT hr = S_OK;
   errorResId = 0;

   do
   {
      if (IsLocalComputer(name))
      {
         // if this code is running, then by definition it's NT

         // check if machine is Windows Home Edition.  If it is, refer the
         // user to the account management control panel applet.
         
         OSVERSIONINFOEX verInfo;
         ::ZeroMemory(&verInfo, sizeof(verInfo));

         hr = Win::GetVersionEx(verInfo);
         BREAK_ON_FAILED_HRESULT(hr);

         if (verInfo.wSuiteMask & VER_SUITE_PERSONAL)
         {
            hr = S_FALSE;
            errorResId = IDS_MACHINE_IS_HOME_EDITION_LOCAL;
         }

         break;
      }

      // Use NetServerGetInfo to find the machine's os & version info.

      String s(name);
      if (s.length() >= 1)
      {
         if (s[0] != L'\\')
         {
            s = L"\\\\" + s;
         }
      }

      LOG(L"Calling NetServerGetInfo");
      LOG(String::format(L"servername : %1", s.c_str()));
      LOG(               L"level      : 101");

      SERVER_INFO_101* info = 0;
      hr =
         Win32ToHresult(
            ::NetServerGetInfo(
               const_cast<wchar_t*>(s.c_str()),
               101,
               reinterpret_cast<BYTE**>(&info)));

      LOG_HRESULT(hr);

      if (SUCCEEDED(hr) && info)
      {
         LOG(String::format(L"sv101_platform_id   : %1!d!",    info->sv101_platform_id));
         LOG(String::format(L"sv101_name          : %1",       info->sv101_name));
         LOG(String::format(L"sv101_version_major : %1!d!",    info->sv101_version_major));
         LOG(String::format(L"sv101_version_minor : %1!d!",    info->sv101_version_minor));
         LOG(String::format(L"sv101_type          : 0x%1!X!",  info->sv101_type));
         LOG(String::format(L"sv101_comment       : %1",       info->sv101_comment));

         if (info->sv101_platform_id != PLATFORM_ID_NT)
         {
            hr = S_FALSE;
            errorResId = IDS_MACHINE_NOT_NT;
         }

         ::NetApiBufferFree(info);

         // at this point, the machine has been verified to be running NT

         // We don't need to check for Windows Home Edition on the remote machine.
         // The call to NetServerGetInfo will always fail against Home
         // Edition machines with access denied.  From johnhaw (2000/08/08):
         // "This is as designed, remote Admin of personal machines is not
         // allowed.  Any attempt to access a personal machine (regardless of
         // the username supplied) is transparently forced to Guest."
      }
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\fpnw.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Random fpnw code
// 
// 10-28-98 sburns



#ifndef FPNW_HPP_INCLUDED
#define FPNW_HPP_INCLUDED



class WasteExtractor;



namespace FPNW
{
   // locate the the File & Print for NetWare LSA secret, return S_OK.
   //
   // machine - machine on which the FPNW service is installed
   //
   // result - the secret, if S_OK is returned.

   HRESULT
   GetLSASecret(const String& machine, String& result);

   HRESULT
   GetObjectIDs(
      const SmartInterface<IADsUser>&  user,
      const SafeDLL&                   clientDLL,
      DWORD&                           objectID,
      DWORD&                           swappedObjectID);

   HRESULT
   SetPassword(
      WasteExtractor&   dump,
      const SafeDLL&    clientDLL,
      const String&     newPassword,
      const String&     lsaSecretKey,
      DWORD             objectID);
};



#endif   // FPNW_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\foldnode.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Folder Node class
// 
// 9-29-97 sburns



#include "headers.hxx"
#include "foldnode.hpp"
#include "uuids.hpp"
#include "images.hpp"
#include "compdata.hpp"



FolderNode::FolderNode(
   const SmartInterface<ComponentData>&   owner,
   const NodeType&                        nodeType,
   int                                    displayNameResID,
   int                                    typeTitleResID,
   const ColumnList&                      columns_,
   const MenuItemList&                    menu_)
   :
   ScopeNode(owner, nodeType),
   name(String::load(displayNameResID)),
   type_title(String::load(typeTitleResID)),
   columns(columns_),
   menu(menu_)
{
   LOG_CTOR(FolderNode);
}



FolderNode::~FolderNode()
{
   LOG_DTOR(FolderNode);

   // items is destroyed, destroying all of it's nodes, which cause them
   // all to be released
}


int
FolderNode::GetNormalImageIndex()
{
   LOG_FUNCTION(FolderNode::GetNormalImageIndex);

   return FOLDER_CLOSED_INDEX;
}



int
FolderNode::GetOpenImageIndex()
{
   LOG_FUNCTION(FolderNode::GetOpenImageIndex);

   return FOLDER_OPEN_INDEX;
}



HRESULT
FolderNode::InsertResultColumns(IHeaderCtrl& headerCtrl)
{
   LOG_FUNCTION(FolderNode::InsertResultColumns);

   return BuildResultColumns(columns.begin(), columns.end(), headerCtrl);
}



HRESULT
FolderNode::UpdateVerbs(IConsoleVerb& consoleVerb)
{
   LOG_FUNCTION(FolderNode::UpdateVerbs);

   consoleVerb.SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

   // this must be the default in order for the folder to open upon
   // double click while in the result pane.
   consoleVerb.SetDefaultVerb(MMC_VERB_OPEN);

   return S_OK;
}



HRESULT
FolderNode::AddMenuItems(
   IContextMenuCallback&   callback,
   long&                   insertionAllowed)
{
   LOG_FUNCTION(FolderNode::AddMenuItems);

   return
      BuildContextMenu(
         menu.begin(),
         menu.end(),
         callback,
         insertionAllowed);
}



String
FolderNode::GetDisplayName() const
{
//   LOG_FUNCTION(FolderNode::GetDisplayName);

   return name;
}



String
FolderNode::GetColumnText(int column)
{
   LOG_FUNCTION(FolderNode::GetColumnText);

   switch (column)
   {
      case 0:
      {
         return GetDisplayName();
      }
      case 1:
      {
         return type_title;
      }
      default:
      {
         // This should never be called
         ASSERT(false);
      }
   }

   return String();
}



HRESULT
FolderNode::InsertResultItems(IResultData& resultData)
{
   LOG_FUNCTION(FolderNode::InsertResultItems);

   if (items.empty())
   {
      BuildResultItems(items);
   }

   HRESULT hr = S_OK;
   for (
      ResultNodeList::iterator i = items.begin();
      i != items.end();
      i++)
   {
      hr = (*i)->InsertIntoResultPane(resultData);
      BREAK_ON_FAILED_HRESULT(hr);
   }

   return hr;
}



HRESULT
FolderNode::RebuildResultItems()
{
   LOG_FUNCTION(FolderNode::RebuildResultItems);

   // Destroying the contents of the list causes the SmartInterfaces to be
   // destroyed, which releases their pointers.   

   items.clear();
   BuildResultItems(items);

   return S_OK;
}



void
FolderNode::RefreshView()
{
   do
   {
      SmartInterface<IConsole2> console(GetOwner()->GetConsole());

      // Create a data object for this node.

      HRESULT hr = S_OK;      
      IDataObject* data_object = 0;
      hr =
         GetOwner()->QueryDataObject(
            reinterpret_cast<MMC_COOKIE>(this),
            CCT_SCOPE,
            &data_object);
      BREAK_ON_FAILED_HRESULT(hr);
      ASSERT(data_object);

      if (data_object)
      {
         // first call, with the '1' parameter, means "call
         // IResultData::DeleteAllRsltItems if you care that dataObject is
         // about to rebuild itself"

         hr = console->UpdateAllViews(data_object, 1, 0);
         if (FAILED(hr))
         {
            LOG_HRESULT(hr);

            // don't break...we need to update the views
         }

         hr = RebuildResultItems();
         if (FAILED(hr))
         {
            LOG_HRESULT(hr);
            // don't break...we need to update the views
         }

         // second call, with the '0' parameter, means, "now that your
         // result pane is empty, repopulate it."
         hr = console->UpdateAllViews(data_object, 0, 0);
         if (FAILED(hr))
         {
            LOG_HRESULT(hr);
         }

         data_object->Release();
      }
   }
   while (0);
}



int
FolderNode::GetResultItemCount() const
{
   LOG_FUNCTION(FolderNode::GetResultItemCount);

   return static_cast<int>(items.size());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\foldnode.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Folder Node class
// 
// 9-29-97 sburns



#ifndef FOLDNODE_HPP_INCLUDED
#define FOLDNODE_HPP_INCLUDED



#include "scopnode.hpp"
#include "resnode.hpp"



class ComponentData;



// Class FolderNode is a ScopeNode that has folder icons, and enables the
// refresh verb.  It is an abstract base class.

class FolderNode : public ScopeNode
{
   public:

   // Node overrides

   String
   GetDisplayName() const;

   String
   GetColumnText(int column);

   // Default implementation returns FOLDER_CLOSED_INDEX.

   virtual 
   int
   GetNormalImageIndex();

   // default implementation enables refresh

   virtual 
   HRESULT
   UpdateVerbs(IConsoleVerb& consoleVerb);

   // ScopeNode overrides

   // Calls ScopeNode::BuildContextMenu with the MenuItemList supplied to the
   // ctor.

   virtual
   HRESULT
   AddMenuItems(
      IContextMenuCallback&   callback,
      long&                   insertionAllowed);

   // Default implementation returns FOLDER_OPEN_INDEX.

   virtual 
   int
   GetOpenImageIndex();

   // Calls ScopeNode;:BuildResultColumns with the ColumnList supplied to
   // the ctor.
   
   virtual
   HRESULT
   InsertResultColumns(IHeaderCtrl& headerCtrl);

   // Calls the (virtual) BuildResultItems, then inserts each of the items
   // (which are ResultNodes) into the result pane by calling each item's
   // InsertIntoResultPane method.

   virtual
   HRESULT
   InsertResultItems(IResultData& resultData);

   // Default implementation calls ReleaseAllResultItems,
   // then BuildResultItemList

   virtual
   HRESULT
   RebuildResultItems();

   // FolderNode methods

   typedef
      std::vector<ResultColumn, Burnslib::Heap::Allocator<ResultColumn> >
      ColumnList;

   typedef
      std::vector<ContextMenuItem, Burnslib::Heap::Allocator<ContextMenuItem> >
      MenuItemList;

   typedef
      std::list<
         SmartInterface<ResultNode>,
         Burnslib::Heap::Allocator<SmartInterface<ResultNode> > >
      ResultNodeList;

   int
   GetResultItemCount() const;

   // Derived Classes must implement this method, with populates the items
   // list with those ResultNodes which should appear in the the result pane
   // for this node.  As the list is a list of SmartInterface<ResultNode>, the
   // items will be AddRef'd and Released properly.
   //
   // items - the list to be populated.

   virtual
   void
   BuildResultItems(ResultNodeList& items) = 0;

   protected:

   // Constructs a new instance.  Declared protected to allow this class to
   // only be a base class.
   //
   // owner - supplied to base class constructor
   // 
   // nodeType - NodeType GUID supplied to the base class constructor.
   //
   // displayNameResID - resource ID of a string resource that contains the
   // name of this node to be shown in the scope pane.
   // 
   // typeTitleResID - resource ID of a string resource that contains the type
   // or title of this node to appear in the "Type" column of the details view
   // when this node appears in the result pane (of the parent node).
   // 
   // columns - the result column list for the columns that appear in the
   // details view of the result pane of this node.
   // 
   // menu - the context menu list for this node.

   FolderNode(
      const SmartInterface<ComponentData>&   owner,
      const NodeType&                        nodetype,
      int                                    displayNameResID,
      int                                    typeTitleResID,
      const ColumnList&                      columns,
      const MenuItemList&                    menu);

   virtual ~FolderNode();

   // Causes the console to update all views of this node's result items,
   // calls RebuildResultItems.  Call this method to rebuild the result pane
   // from scratch.

   void
   RefreshView();

   private:

   ResultNodeList items;
   ColumnList     columns;
   MenuItemList   menu;
   String         name;
   String         type_title;

   // not implemented: no copying allowed

   FolderNode(const FolderNode&);
   const FolderNode& operator=(const FolderNode&);
};



#endif   // FOLDNODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\dlgcomm.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Shared Dialog code
// 
// 10-24-97 sburns



#ifndef DLGCOMM_HPP_INCLUDED
#define DLGCOMM_HPP_INCLUDED



// Return S_OK if the machine is NT or an NT derivate that is not Windows
// Home Edition (e.g. is Professional, or one of the Server variants).  Returns
// S_FALSE if the machine was contacted and it is not running an NT-based OS
// (like Windows 9X), or it is running Home Edition.  Returns an error
// code code if the machine could not be contacted, or the evaluation failed.
// 
// name - IN name of the computer to check
// 
// errorResId - OUT error message resource identifier indicating what kind of
// machine the computer is (non-NT, home edition)

HRESULT
CheckComputerOsIsSupported(const String& name, unsigned& errorResId);



// Enable/disable the check boxes for the correct allowable combinations,
// based on the current state of theose boxes. Called from UserGeneralPage and
// CreateUserDialog.
// 
// dialog - HWND of the parent window of the controls.
// 
// mustChangeResID - resource ID of the "Must change password at next login"
// checkbox.
// 
// cantChangeResID - resource ID of the "Can't change password" checkbox.
// 
// neverExpiresResID - resource ID of the "password Never Expires" checkbox.

void
DoUserButtonEnabling(
   HWND  dialog,
   int   mustChangeResID,
   int   cantChangeResID,
   int   neverExpiresResID);



// Verifies that the contents of the two password edit boxes match, clearing
// them, griping, and setting input focuse to the first edit box if they
// don't.  Returns true if the passwords match, false if not.
// 
// dialog - parent window of the edit box controls.
// 
// passwordResID - resource ID of the "Password" edit box.
// 
// confirmResID - resource ID of the "Confirm Password" edit box.

bool
IsValidPassword(
   HWND  dialog,
   int   passwordResID,
   int   confirmResID);


// Puts new values for various user properties, then commits the result.  If
// any of the parameters is 0, then the corresponding property is unchanged.
// If any change fails, the commit is not performed and the function
// immediately returns.
// 
// user - smart pointer bound to the ADSI user to be changed.
// 
// fullName - ptr to the new value of the FullName property.
// 
// description - ptr to the new value of the Description property.
// 
// disable - ptr to flag whether the account is disabled or not.
// 
// mustChangePassword - ptr to flag indicating whether or not the user must
// change the password at next login.
// 
// cannotChangePassword - ptr to flag indicating the user cannot change the
// password.
// 
// passwordNeverExpires - ptr to flag indicating that the password never
// expires.
// 
// isLocked - ptr to flag indicating to clear the account lock, if it is
// locked.

HRESULT
SaveUserProperties(
   const SmartInterface<IADsUser>&  user,
   const String*                    fullName,
   const String*                    description,
   const bool*                      disable,
   const bool*                      mustChangePassword,
   const bool*                      cannotChangePassword,
   const bool*                      passwordNeverExpires,
   const bool*                      isLocked);



// Sets the display name and the internal name based on the supplied
// parameter, which may be a DNS or NetBIOS name.  (see ComponentData)

void
SetComputerNames(
   const String&  newName,
   String&        displayComputerName,
   String&        internalComputerName);



bool
IsValidSAMName(const String& name);



bool
ValidateSAMName(HWND dialog, const String& name, int editResID);




#endif   // DLGCOMM_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\dllmain.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Local Security Snapin DLL entry points
// 
// 8-14-97 sburns



#include "headers.hxx"
#include "resource.h"
#include "uuids.hpp"
#include "compdata.hpp"
#include "about.hpp"
#include <compuuid.h>



HINSTANCE hResourceModuleHandle = 0;
HINSTANCE hDLLModuleHandle = 0;
const wchar_t* HELPFILE_NAME = L"\\help\\localsec.hlp";
const wchar_t* RUNTIME_NAME = L"localsec";

// default debug options: none

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_MUTE;



Popup popup(IDS_APP_ERROR_TITLE);



BOOL
APIENTRY
DllMain(
   HINSTANCE   hInstance,
   DWORD       dwReason,
   PVOID       /* lpReserved */ )
{
   switch (dwReason)
   {
      case DLL_PROCESS_ATTACH:
      {
         hResourceModuleHandle = hInstance;
         hDLLModuleHandle = hInstance;

         LOG(L"DLL_PROCESS_ATTACH");

         break;
      }
      case DLL_PROCESS_DETACH:
      {
         LOG(L"DLL_PROCESS_DETACH");

#ifdef DBG         
         if (!ComServerLockState::CanUnloadNow())
         {
            LOG(
               L"server locks and/or outstanding object instances exit");
         }
         else
         {
            LOG(L"server can unload now.");
         }
#endif

         break;
      }
      case DLL_THREAD_ATTACH:
      case DLL_THREAD_DETACH:
      default:
      {
         break;
      }
   }

   return TRUE;
}



static
HKEY
CreateKey(HKEY rootHKEY, const String& key)
{
   LOG_FUNCTION2(CreateKey, key);
   ASSERT(!key.empty());

	HKEY hKey = 0;
	LONG result = 
	   Win::RegCreateKeyEx(
	      rootHKEY,
         key, 
         REG_OPTION_NON_VOLATILE,
         KEY_ALL_ACCESS,
         0, 
         hKey,
         0);
	if (result != ERROR_SUCCESS)
	{
      return 0;
	}

   return hKey;
}



static
bool
CreateKeyAndSetValue(
   HKEY           rootHKEY,
   const String&  key,
   const String&  valueName,
   const String&  value)
{
   LOG_FUNCTION2(
      CreateKeyAndSetValue,
      String::format(
         L"key=%1, value name=%2, value=%3",
         key.c_str(),
         valueName.c_str(),
         value.c_str()));
   ASSERT(!key.empty());
   ASSERT(!value.empty());

   HKEY hKey = CreateKey(rootHKEY, key);
	if (hKey == 0)
	{
      return false;
	}
   
	HRESULT hr =
	   Win::RegSetValueEx(
   	   hKey,
   	   valueName,
   	   REG_SZ, 
         (BYTE*) value.c_str(),
   	   (value.length() + 1) * sizeof(wchar_t));
	if (FAILED(hr))
	{
      return false;
	}

	Win::RegCloseKey(hKey);
	return true;
}



static
HRESULT
DoSnapinRegistration(const String& classIDString)
{
   LOG_FUNCTION2(DoSnapinRegistration, classIDString);
   static const String SNAPIN_REG_ROOT(L"Software\\Microsoft\\MMC");
  
   String key = SNAPIN_REG_ROOT + L"\\Snapins\\" + classIDString;
   String name = String::load(IDS_SNAPIN_REG_NAMESTRING);

   bool result =
      CreateKeyAndSetValue(
         HKEY_LOCAL_MACHINE,
         key,
         L"NameString",
         name);
   if (!result)
   {
      LOG(L"Failure setting snapin NameString");
      return E_FAIL;
   }

   String filename = Win::GetModuleFileName(hDLLModuleHandle);

   String indirectName =
      String::format(
         L"@%1,-%2!d!",
         filename.c_str(),
         IDS_SNAPIN_REG_NAMESTRING);

   result =
      CreateKeyAndSetValue(
         HKEY_LOCAL_MACHINE,
         key,
         L"NameStringIndirect",
         indirectName);
   if (!result)
   {
      LOG(L"Failure setting snapin NameStringIndirect");
      return E_FAIL;
   }

   // make the snapin standalone
   HKEY hkey =
      CreateKey(
         HKEY_LOCAL_MACHINE,
         key + L"\\Standalone");
   if (hkey == 0)
   {
      LOG(L"Failure creating snapin standalone key");
      return E_FAIL;
   }

   // indicate the CLSID SnapinAbout
   result =
      CreateKeyAndSetValue(
         HKEY_LOCAL_MACHINE,
         key,
         L"About",
         Win::StringFromCLSID(CLSID_SnapinAbout));
   if (!result)
   {
      LOG(L"Failure creating snapin about key");
      return E_FAIL;
   }

   // register all the myriad nodetypes
   String nodekey_base = key + L"\\NodeTypes";
   hkey = CreateKey(HKEY_LOCAL_MACHINE, nodekey_base);
   if (hkey == 0)
   {
      LOG(L"Failure creating snapin nodetypes key");
      return E_FAIL;
   }
   for (int i = 0; nodetypes[i]; i++)
   {
      hkey =
         CreateKey(
            HKEY_LOCAL_MACHINE,
               nodekey_base
            +  L"\\"
            +  Win::StringFromGUID2(*nodetypes[i]));
      if (hkey == 0)
      {
         LOG(L"Failure creating nodetype key");
         return E_FAIL;
      }
   }

   // register the snapin as an extension of Computer Management snapin
   result =
      CreateKeyAndSetValue(
         HKEY_LOCAL_MACHINE,
            SNAPIN_REG_ROOT
         +  L"\\NodeTypes\\"
         +  lstruuidNodetypeSystemTools
         +  L"\\Extensions\\NameSpace",
         classIDString,
         name);
   if (!result)
   {
      LOG(L"Failure creating snapin extension key");
      return E_FAIL;
   }

   return S_OK;
}



static
bool
registerClass(const CLSID& classID, int friendlyNameResID)
{
   LOG_FUNCTION(registerClass);
   ASSERT(friendlyNameResID);

	// Get server location.
   String module_location = Win::GetModuleFileName(hDLLModuleHandle);
   String classID_string = Win::StringFromCLSID(classID);
   String key1 = L"CLSID\\" + classID_string;
   String key2 = key1 + L"\\InprocServer32";

	// Add the CLSID to the registry.
	if (
	      CreateKeyAndSetValue(
            HKEY_CLASSES_ROOT,
            key1,
            "",
	         String::load(friendlyNameResID))
      && CreateKeyAndSetValue(
            HKEY_CLASSES_ROOT,
            key2,
            L"",
            module_location)
      && CreateKeyAndSetValue(
            HKEY_CLASSES_ROOT,
            key2,
            L"ThreadingModel",
            L"Apartment") )
   {
      return true;
   }

   LOG(L"Unable to register class " + classID_string);
   return false;
}



STDAPI
DllRegisterServer()
{
   LOG_FUNCTION(DllRegisterServer);

   if (
         registerClass(
            CLSID_ComponentData,
            IDS_SNAPIN_CLSID_FRIENDLY_NAME)
      && registerClass(
            CLSID_SnapinAbout,
            IDS_SNAPIN_ABOUT_CLSID_FRIENDLY_NAME) )
   {
      return
         DoSnapinRegistration(
            Win::StringFromCLSID(CLSID_ComponentData));
   }

   return E_FAIL;
}



// STDAPI
// DllUnregisterServer()
// {
//    return S_OK;
// }



STDAPI
DllCanUnloadNow()
{
   LOG_FUNCTION(DllCanUnloadNow);
   if (ComServerLockState::CanUnloadNow())
   {
      return S_OK;
   }

   return S_FALSE;
}



// Creates the snapin class factory object
//
// A class object is an instance of an object that implements IClassFactory
// for a given CLSID.  It is a meta-object, not to be confused with instances
// of the type the class factory creates.
// 
// In our case, this COM server supports two classes: The Local Users and
// Groups Snapin (ComponentData) and The Local Users and Groups About
// "Provider" (SnapinAbout).
// 
// The meta objects -- class objects in COM lingo -- are
// ClassFactory<ComponentData> and ClassFactory<SnapinAbout>.  COM calls this
// function to get instances of those meta objects.

STDAPI
DllGetClassObject(
   const CLSID&   classID,
   const IID&     interfaceID,
   void**         interfaceDesired)
{
   LOG_FUNCTION(DllGetClassObject);

   IClassFactory* factory = 0;

   // The class objects are instances of ClassFactory<>, which are ref-counted
   // in the usual fashion (i.e. they track their ref counts, and
   // self-destruct on final Release).  I could have used static instances of
   // a C++ class that ignored the refcounting (ala Don Box's examples in
   // Essential COM)

   if (classID == CLSID_ComponentData)
   {
      factory = new ClassFactory<ComponentData>; 
   }
   else if (classID == CLSID_SnapinAbout)
   {
      factory = new ClassFactory<SnapinAbout>; 
   }
   else
   {
      *interfaceDesired = 0;
      return CLASS_E_CLASSNOTAVAILABLE;
   }

   // the class factory instance starts with a ref count of 1.  If the QI
   // fails, then it self-destructs upon Release.
   HRESULT hr = factory->QueryInterface(interfaceID, interfaceDesired);
   factory->Release();
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\fpnwlog.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// FPNW login script editor dialog
// 
// 10-16-98 sburns



#include "headers.hxx"
#include "fpnwlog.hpp"
#include "resource.h"



static const DWORD HELP_MAP[] =
{
   IDC_SCRIPT,       NO_HELP,
   IDCANCEL,         NO_HELP,
   IDOK,             NO_HELP,
   0, 0
};



FPNWLoginScriptDialog::FPNWLoginScriptDialog(
   const String& userName,
   const String& loginScript)
   :
   Dialog(IDD_FPNW_LOGIN_SCRIPT, HELP_MAP),
   name(userName),
   script(loginScript),
   start_sel(0),
   end_sel(0)
{
   LOG_CTOR(FPNWLoginScriptDialog);
}



FPNWLoginScriptDialog::~FPNWLoginScriptDialog()
{
   LOG_DTOR(FPNWLoginScriptDialog);   
}



String
FPNWLoginScriptDialog::GetLoginScript() const
{
   LOG_FUNCTION(FPNWLoginScriptDialog::GetLoginScript);

   return script;
}



bool
FPNWLoginScriptDialog::OnCommand(
   HWND        windowFrom,
   unsigned    controlIDFrom,
   unsigned    code)
{
   switch (controlIDFrom)
   {
      case IDOK:
      {
         if (code == BN_CLICKED)
         {
            if (WasChanged(IDC_SCRIPT))
            {
               // save the changed script
               script = Win::GetDlgItemText(hwnd, IDC_SCRIPT);
            }

            HRESULT unused = Win::EndDialog(hwnd, IDOK);

            ASSERT(SUCCEEDED(unused));
         }
         break;
      }
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            HRESULT unused = Win::EndDialog(hwnd, IDCANCEL);

            ASSERT(SUCCEEDED(unused));
         }
         break;
      }
      case IDC_SCRIPT:
      {
         switch (code)
         {
            case EN_CHANGE:
            {
               SetChanged(controlIDFrom);
               break;
            }
            case EN_KILLFOCUS:
            {
               // save the selection state
               Win::Edit_GetSel(windowFrom, start_sel, end_sel);
               break;
            }
            case EN_SETFOCUS:
            {
               // restore the selection state
               Win::Edit_SetSel(windowFrom, start_sel, end_sel);
               break;
            }
            default:
            {
               // do nothing
            }
         }
         break;
      }
      default:
      {
         // do nothing
      }
   }

   return true;
}



void
FPNWLoginScriptDialog::OnInit()
{
   LOG_FUNCTION(FPNWLoginScriptDialog::OnInit);

   Win::SetWindowText(
      hwnd,
      String::format(IDS_LOGIN_SCRIPT_TITLE, name.c_str()));
   Win::SetDlgItemText(hwnd, IDC_SCRIPT, script);

   ClearChanges();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\fpnwlog.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// FPNW login script editor dialog
// 
// 10-16-98 sburns



#ifndef FPNWLOG_HPP_INCLUDED
#define FPNWLOG_HPP_INCLUDED



class FPNWLoginScriptDialog : public Dialog
{
   public:

   FPNWLoginScriptDialog(const String& userName, const String& loginScript);

   virtual
   ~FPNWLoginScriptDialog();

   String
   GetLoginScript() const;

   private:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // not implemented: no copying allowed
   FPNWLoginScriptDialog(const FPNWLoginScriptDialog&);
   const FPNWLoginScriptDialog& operator=(const FPNWLoginScriptDialog&);

   String   script;
   String   name;
   int      start_sel;
   int      end_sel;
};



#endif   // FPNWLOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\fpnw.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Random fpnw code
// 
// 10-28-98 sburns



#include "headers.hxx"
#include "adsi.hpp"
#include "waste.hpp"
#include "fpnw.hpp"



static const String RETURNNETWAREFORM(L"ReturnNetwareForm");
typedef NTSTATUS (*ReturnNetwareForm)(PCSTR, DWORD, PCWSTR, UCHAR*);

static const String MAPRIDTOOBJECTID(L"MapRidToObjectId");
typedef ULONG (*MapRidToObjectId)(DWORD, PWSTR, BOOL, BOOL);

static const String SWAPOBJECTID(L"SwapObjectId");
typedef ULONG (*SwapObjectId)(ULONG);



HRESULT
getObjectIDs(
   const SafeDLL& client_DLL,
   const String&  userSAMName,
   SAFEARRAY*     SIDArray,
   DWORD&         objectID,
   DWORD&         swappedObjectID)
{
   LOG_FUNCTION2(getObjectIDs, userSAMName);
   ASSERT(!userSAMName.empty());
   ASSERT(SIDArray);

   // the array is a one dimensional array of bytes
   ASSERT(::SafeArrayGetDim(SIDArray) == 1);
   ASSERT(::SafeArrayGetElemsize(SIDArray) == 1);

   objectID = 0;
   swappedObjectID = 0;

   HRESULT hr = S_OK;
   bool accessed = false;

   do
   {
      PSID sid = 0;
      hr = ::SafeArrayAccessData(SIDArray, &sid);
      BREAK_ON_FAILED_HRESULT(hr);
      accessed = true;

      UCHAR* sa_count = GetSidSubAuthorityCount(sid);
      if (!sa_count)
      {
         hr = Win::GetLastErrorAsHresult();
      }
      BREAK_ON_FAILED_HRESULT(hr);

      DWORD* rid = GetSidSubAuthority(sid, *sa_count - 1);
      if (!rid)
      {
         hr = Win::GetLastErrorAsHresult();
      }
      BREAK_ON_FAILED_HRESULT(hr);

      FARPROC f = 0; 
      hr = client_DLL.GetProcAddress(MAPRIDTOOBJECTID, f);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(f);
      objectID =
         ((MapRidToObjectId) f)(
            *rid,
            const_cast<wchar_t*>(userSAMName.c_str()),
            FALSE,
            FALSE);

      if (objectID == SUPERVISOR_USERID)
      {
         swappedObjectID = SUPERVISOR_USERID;
      }
      else
      {
         hr = client_DLL.GetProcAddress(SWAPOBJECTID, f);
         BREAK_ON_FAILED_HRESULT(hr);
         swappedObjectID = ((SwapObjectId) f)(objectID);
      }
   }
   while (0);

   if (accessed)
   {
      ::SafeArrayUnaccessData(SIDArray);
   }

   return hr;
}  



HRESULT
FPNW::GetObjectIDs(
   const SmartInterface<IADsUser>&  user,
   const SafeDLL&                   clientDLL,
   DWORD&                           objectID,
   DWORD&                           swappedObjectID)
{
   LOG_FUNCTION(FPNW::GetObjectIDs);

   objectID = 0;
   swappedObjectID = 0;

   HRESULT hr = S_OK;
   do
   {
      // first, get the SAM account name
      BSTR bstrname;
      hr = user->get_Name(&bstrname);
      BREAK_ON_FAILED_HRESULT(hr);
      String name(bstrname);
      ::SysFreeString(bstrname);

      // next, get the account SID
      _variant_t variant;
      hr = user->Get(AutoBstr(ADSI::PROPERTY_ObjectSID), &variant);
      BREAK_ON_FAILED_HRESULT(hr);

      // Object SID is returned as a safe array of bytes
      ASSERT(V_VT(&variant) & VT_ARRAY);
      ASSERT(V_VT(&variant) & VT_UI1);

      // object ID is determined by a mapping from the user's SAM account
      // name and SID.

      hr =
         getObjectIDs(
            clientDLL,
            name,
            V_ARRAY(&variant),
            objectID,
            swappedObjectID);
      variant.Clear();
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



   
HRESULT
FPNW::GetLSASecret(const String& machine, String& result)

{
   LOG_FUNCTION2(GetLSASecret, machine);
   ASSERT(!machine.empty());

   result.erase();

   UNICODE_STRING machine_name;
   UNICODE_STRING secret_name;
   ::RtlInitUnicodeString(&machine_name, machine.c_str());
   ::RtlInitUnicodeString(&secret_name, NCP_LSA_SECRET_KEY);

   SECURITY_QUALITY_OF_SERVICE sqos;
   ZeroMemory(&sqos, sizeof(sqos));
   sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
   sqos.ImpersonationLevel = SecurityImpersonation;
   sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
   sqos.EffectiveOnly = FALSE;

   OBJECT_ATTRIBUTES oa;
   InitializeObjectAttributes(&oa, 0, 0, 0, 0);
   oa.SecurityQualityOfService = &sqos;

   LSA_HANDLE hlsaPolicy = 0;
   LSA_HANDLE hlsaSecret = 0;
   HRESULT hr = S_OK;

   do
   {
      hr = 
         Win32ToHresult(
            RtlNtStatusToDosError(
               LsaOpenPolicy(
                  &machine_name,
                  &oa,
                  GENERIC_READ | GENERIC_EXECUTE,
                  &hlsaPolicy)));
      BREAK_ON_FAILED_HRESULT(hr);

      hr =
         Win32ToHresult(
            RtlNtStatusToDosError(
               LsaOpenSecret(
                  hlsaPolicy,
                  &secret_name,
                  SECRET_QUERY_VALUE,
                  &hlsaSecret)));
      BREAK_ON_FAILED_HRESULT(hr);

      UNICODE_STRING* puSecretValue = 0;

      // CODEWORK: what if I passed 0 for these parameters?

      LARGE_INTEGER lintCurrentSetTime;
      LARGE_INTEGER lintOldSetTime;

      hr =
         Win32ToHresult(
            RtlNtStatusToDosError(
               LsaQuerySecret(
                  hlsaSecret,
                  &puSecretValue,
                  &lintCurrentSetTime,
                  NULL,
                  &lintOldSetTime)));
      BREAK_ON_FAILED_HRESULT(hr);

      // paranoid null check: NTRAID#NTBUG9-333197-2001/03/02-sburns
      
      if (puSecretValue)
      {
         result =
            String(
               puSecretValue->Buffer,

               // the secret length is in bytes, so convert to wchar_t's

               NCP_LSA_SECRET_LENGTH / sizeof(wchar_t));

         ::LsaFreeMemory(puSecretValue);
      }
      else
      {
         // if the LsaQuerySecret call succeeds, it should return a valid
         // pointer. If it does not, LsaQuerySecret is broken.
         
         ASSERT(false);
         hr = E_FAIL;
      }
   }
   while (0);

   if (hlsaPolicy)
   {
      ::LsaClose(hlsaPolicy);
   }

   if (hlsaSecret)
   {
      ::LsaClose(hlsaSecret);
   }

   return hr;
}



HRESULT
FPNW::SetPassword(
   WasteExtractor&   dump,
   const SafeDLL&    clientDLL,
   const String&     newPassword,
   const String&     lsaSecretKey,
   DWORD             objectID)
{
   LOG_FUNCTION(FPNW::SetPassword);
   ASSERT(!lsaSecretKey.empty());
   ASSERT(objectID);

   HRESULT hr = S_OK;
   do
   {
      FARPROC f = 0;

      hr = clientDLL.GetProcAddress(RETURNNETWAREFORM, f);
      BREAK_ON_FAILED_HRESULT(hr);

      String encrypted(NWENCRYPTEDPASSWORDLENGTH, L' ');
      char secret_key[NCP_LSA_SECRET_LENGTH + 1];
      memset(secret_key, 0, NCP_LSA_SECRET_LENGTH + 1);
      memcpy(secret_key, lsaSecretKey.c_str(), NCP_LSA_SECRET_LENGTH);

      NTSTATUS status =
         ((ReturnNetwareForm) f)(
            secret_key,
            objectID,
            newPassword.c_str(),
            reinterpret_cast<UCHAR*>(
               const_cast<wchar_t*>(encrypted.c_str())));
      if (!NT_SUCCESS(status))
      {
         hr = Win32ToHresult(::NetpNtStatusToApiStatus(status));
         BREAK_ON_FAILED_HRESULT(hr);
      }

      hr = dump.Put(NWPASSWORD, encrypted);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\fpnwpass.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// FPNW password dialog
// 
// 10-20-98 sburns



#ifndef FPNWPASS_HPP_INCLUDED
#define FPNWPASS_HPP_INCLUDED



class FPNWPasswordDialog : public Dialog
{
   public:

   FPNWPasswordDialog(const String& userName);

   virtual
   ~FPNWPasswordDialog();

   String
   GetPassword() const;

   private:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // not implemented: no copying allowed
   FPNWPasswordDialog(const FPNWPasswordDialog&);
   const FPNWPasswordDialog& operator=(const FPNWPasswordDialog&);

   String   password;
   String   name;
};



#endif   // FPNWPASS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\gfnode.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Groups Folder Node class
// 
// 9-17-97 sburns



#ifndef GFNODE_HPP_INCLUDED
#define GFNODE_HPP_INCLUDED



#include "foldnode.hpp"



class GroupsFolderNode : public FolderNode
{
   friend class RootNode;

   public:

   // Node overrides

   virtual
   HRESULT
   MenuCommand(
      IExtendContextMenu&  extendContextMenu,
      long                 commandID);

   // ScopeNode overrides

   virtual
   String
   GetDescriptionBarText();

   private:

   // can only be instanciated by Root Node (when expanding)
   GroupsFolderNode(const SmartInterface<ComponentData>& owner);

   // only we can delete ourselves
   virtual ~GroupsFolderNode();

   void
   BuildResultItems(ResultNodeList& items);

   // not defined: no copying allowed

   GroupsFolderNode(const GroupsFolderNode&);
   const GroupsFolderNode& operator=(const GroupsFolderNode&);
};

   


#endif   // GFNODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\groupgeneralpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// GroupGeneralPage class
// 
// 9-17-97 sburns



#ifndef GROUPGENERALPAGE_HPP_INCLUDED
#define GROUPGENERALPAGE_HPP_INCLUDED



#include "adsipage.hpp"
#include "MembershipListView.hpp"



class GroupGeneralPage : public ADSIPage
{
   public:

   // Creates a new instance.
   // 
   // state - See base class ctor.
   // 
   // groupADSIPath - the fully-qualified ADSI pathname of the group object
   // that this page is editing.

   GroupGeneralPage(
      MMCPropertyPage::NotificationState* state,
      const String&                       groupADSIPath);

   virtual ~GroupGeneralPage();

   virtual
   bool
   OnApply(bool isClosing);

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnDestroy();

   virtual
   void
   OnInit();

   virtual
   bool
   OnNotify(
      HWND     windowFrom,
      UINT_PTR controlIDFrom,
      UINT     code,
      LPARAM   lparam);

   private:

   void
   Enable();

   MembershipListView* listview;        
   MemberList          originalMembers;
   HICON               groupIcon;       
                                      
   // not implemented: no copying allowed

   GroupGeneralPage(const GroupGeneralPage&);
   const GroupGeneralPage& operator=(const GroupGeneralPage&);
};



#endif   // GROUPGENERALPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\groupgeneralpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// GroupGeneralPage class
// 
// 9-17-97 sburns



#include "headers.hxx"
#include "GroupGeneralPage.hpp"
#include "resource.h"
#include "lsm.h"
#include "adsi.hpp"
#include "MemberVisitor.hpp"
#include "dlgcomm.hpp"



static const DWORD HELP_MAP[] =
{
   IDC_NAME,         idh_general121_name,
   IDC_DESCRIPTION,  idh_general121_description,
   IDC_MEMBERS,      idh_general121_members, 
   IDC_ADD,          idh_general121_add,
   IDC_REMOVE,       idh_general121_remove,
   IDC_GROUP_ICON,   NO_HELP,
   0, 0
};



GroupGeneralPage::GroupGeneralPage(
   MMCPropertyPage::NotificationState* state,
   const String&                       groupADSIPath)
   :
   ADSIPage(IDD_GROUP_GENERAL, HELP_MAP, state, groupADSIPath),
   listview(0),
   groupIcon(0)
{
   LOG_CTOR(GroupGeneralPage);
   LOG(groupADSIPath);
}



GroupGeneralPage::~GroupGeneralPage()
{
   LOG_DTOR(GroupGeneralPage);

   if (groupIcon)
   {
      Win::DestroyIcon(groupIcon);
   }
}



void
GroupGeneralPage::OnInit()
{
   LOG_FUNCTION(GroupGeneralPage::OnInit());

   // Setup the controls

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_DESCRIPTION), MAXCOMMENTSZ);

   HRESULT hr = Win::LoadImage(IDI_GROUP, groupIcon);

   // if the icon load fails, we're not going to tank the whole dialog, so
   // just assert here.

   ASSERT(SUCCEEDED(hr));

   Win::Static_SetIcon(Win::GetDlgItem(hwnd, IDC_GROUP_ICON), groupIcon);

   listview =
      new MembershipListView(
         Win::GetDlgItem(hwnd, IDC_MEMBERS),
         GetMachineName(),
         MembershipListView::GROUP_MEMBERSHIP);

   // load the group properties into the dialog.

   hr = S_OK;
   do
   {
      SmartInterface<IADsGroup> group(0);
      // @@ qualify this path with the class type, to improve performance
      // or change GetXxxx to append class type automatically.
      hr = ADSI::GetGroup(GetADSIPath(), group);
      BREAK_ON_FAILED_HRESULT(hr);

      BSTR name;
      hr = group->get_Name(&name);
      BREAK_ON_FAILED_HRESULT(hr);
      Win::SetDlgItemText(hwnd, IDC_NAME, name);

      BSTR description;
      hr = group->get_Description(&description);
      BREAK_ON_FAILED_HRESULT(hr);
      Win::SetDlgItemText(hwnd, IDC_DESCRIPTION, description);

      // populate the list with group membership

      MemberVisitor visitor(originalMembers, hwnd, name, GetMachineName());
      hr = ADSI::VisitMembers(group, visitor);
      BREAK_ON_FAILED_HRESULT(hr);
      listview->SetContents(originalMembers);

      ::SysFreeString(name);
      ::SysFreeString(description);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_READING_GROUP,
            GetObjectName().c_str()));
      Win::PostMessage(Win::GetParent(hwnd), WM_CLOSE, 0, 0);
   }

   ClearChanges();
   Enable();
}



void
GroupGeneralPage::Enable()
{
   bool selected =
      Win::ListView_GetSelectedCount(
         Win::GetDlgItem(hwnd, IDC_MEMBERS)) > 0;

   HWND removeButton = Win::GetDlgItem(hwnd, IDC_REMOVE);
   
   if (!selected)
   {
      // If we're about to disable the remove button, check to see if it
      // has focus first.  If it does, we need to move focus to another
      // control.  Similarly for default pushbutton style.
      // NTRAID#NTBUG9-435045-2001/07/13-sburns

      if (removeButton == ::GetFocus())
      {
         HWND addButton = Win::GetDlgItem(hwnd, IDC_ADD);
         Win::SetFocus(addButton);
         Win::Button_SetStyle(addButton, BS_DEFPUSHBUTTON, true);
         Win::Button_SetStyle(removeButton, BS_PUSHBUTTON, true);
      }
   }

   Win::EnableWindow(removeButton, selected);
}



bool
GroupGeneralPage::OnNotify(
   HWND     /* windowFrom */ ,
   UINT_PTR controlIDFrom,
   UINT     code,
   LPARAM   lparam)
{
//    LOG_FUNCTION(GroupGeneralPage::OnNotify);

   switch (controlIDFrom)
   {
      case IDC_MEMBERS:
      {
         switch (code)
         {
            case LVN_ITEMCHANGED:
            {
               ASSERT(lparam);

               if (lparam)
               {
                  NMLISTVIEW* lv = reinterpret_cast<NMLISTVIEW*>(lparam);
                  if (lv->uChanged & LVIF_STATE)
                  {
                     // a list item changed state

                     Enable();
                  }
               }
               break;
            }
            case LVN_KEYDOWN:
            {
               ASSERT(lparam);

               if (lparam)
               {
                  NMLVKEYDOWN* kd = reinterpret_cast<NMLVKEYDOWN*>(lparam);
                  if (kd->wVKey == VK_INSERT)
                  {
                     listview->OnAddButton();
                  }
                  else if (kd->wVKey == VK_DELETE)
                  {
                     listview->OnRemoveButton();
                  }
               }
               break;
            }
            case LVN_INSERTITEM:
            case LVN_DELETEITEM:
            {
               SetChanged(controlIDFrom);
               Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
               break;
            }
            default:
            {
               break;
            }
         }
         break;
      }
      default:
      {
      }
   }

   return true;
}



void
GroupGeneralPage::OnDestroy()
{
   LOG_FUNCTION(GroupGeneralPage::OnDestroy);
   
   delete listview;
   listview = 0;
}



bool
GroupGeneralPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(GroupGeneralPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_DESCRIPTION:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);
            Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
         }
         break;
      }
      case IDC_ADD:
      {
         if (code == BN_CLICKED)
         {
            listview->OnAddButton();
         }
         break;
      }
      case IDC_REMOVE:
      {
         if (code == BN_CLICKED)
         {
            listview->OnRemoveButton();
         }
         break;
      }
      default:
      {
         break;
      }
   }

   return true;
}



String
GetPathToUseInGroupAdd(const MemberInfo& info)
{
   LOG_FUNCTION2(GetPathToUseInGroupAdd, info.path);

   if (!info.sidPath.empty())
   {
      // use the sidPath to add the member to the group, as a workaround
      // to bug 333491.

      return info.sidPath;
   }

   // since all objects to be added were retreived from the object picker,
   // we would expect them all to have the sid.

   ASSERT(false);

   // form a "type-qualified" path, ostensibly for better performance, 
   // although my experience is that this does not appear to improve
   // performance perceptibly.

   String path = info.path;
   switch (info.type)
   {
      case MemberInfo::USER:
      case MemberInfo::DOMAIN_USER:
      {
         path += L",";
         path += ADSI::CLASS_User;
         break;
      }
      case MemberInfo::GROUP:
      case MemberInfo::DOMAIN_GROUP:
      {
         path += L",";
         path += ADSI::CLASS_Group;
         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return path;
}



String
GetPathToUseInGroupRemove(const MemberInfo& info)
{
   LOG_FUNCTION2(GetPathToUseInGroupRemove, info.path);

   if (!info.sidPath.empty())
   {
      // prefer the SID path.  This is because in some cases (like
      // group members that have been since cloned), the SID is the only
      // correct way to refer to the membership.

      return info.sidPath;
   }

   String path = info.path;

   // if info refers to a local user, then bind to it and retrieve its
   // sid, and use the sid path to remove the membership.  workaround to
   // 333491.

   if (info.type == MemberInfo::USER)
   {
      // only need to find sid for user objects, as local groups can't
      // have other local groups as members, and 333491 does not apply
      // to global objects.

      HRESULT hr = ADSI::GetSidPath(info.path, path);

      // in case of failure fall back to the normal path

      if (FAILED(hr))
      {
         path = info.path;
      }
   }

   return path;
}



HRESULT
ReconcileMembershipChanges(
   const SmartInterface<IADsGroup>& group,
   MemberList                       originalMembers,     // a local copy...
   const MemberList&                newMembers,
   HWND                             hwnd)
{
   HRESULT hr = S_OK;
   for (
      MemberList::iterator i = newMembers.begin();
      i != newMembers.end();
      i++)
   {
      MemberInfo& info = *i;

      MemberList::iterator f =
         std::find(originalMembers.begin(), originalMembers.end(), info);
      if (f != originalMembers.end())
      {
         // found.  remove the matching node in the original list

         originalMembers.erase(f);
      }
      else
      {
         // not found.  Add the node as a member of the group

         String path = GetPathToUseInGroupAdd(info);

         LOG(L"Adding to group " + path);

         hr = group->Add(AutoBstr(path));
         if (hr == Win32ToHresult(ERROR_MEMBER_IN_ALIAS))
         {
            // already a member: pop up a warning but don't consider this
            // a real error. 6791

            hr = S_OK;

            BSTR groupName;
            HRESULT anotherHr = group->get_Name(&groupName);
            if (SUCCEEDED(anotherHr))
            {
               popup.Info(
                  hwnd,
                  String::format(
                     IDS_ALREADY_MEMBER,
                     info.name.c_str(),
                     groupName));
               ::SysFreeString(groupName);
            }
         }

         BREAK_ON_FAILED_HRESULT(hr);
      }
   }

   if (SUCCEEDED(hr))
   {
      // at this point, the original list contains only those nodes which are
      // not in the new list.  Remove these from the group membership

      for (
         i = originalMembers.begin();
         i != originalMembers.end();
         i++)
      {
         String path = GetPathToUseInGroupRemove(*i);

         LOG(L"Removing from group " + path);

         hr = group->Remove(AutoBstr(path));
         BREAK_ON_FAILED_HRESULT(hr);

         // CODEWORK: what if the member is not part of the group?
      }
   }

   return hr;
}



bool
GroupGeneralPage::OnApply(bool isClosing)
{
   LOG_FUNCTION(GroupGeneralPage::OnApply);

   bool description_changed = WasChanged(IDC_DESCRIPTION);
   bool members_changed = WasChanged(IDC_MEMBERS);

   if (!description_changed && !members_changed)
   {
      // no changes to save
      return true;
   }

   // save the changes thru ADSI
   HRESULT hr = S_OK;
   do
   {
      SmartInterface<IADsGroup> group(0);
      hr = ADSI::GetGroup(GetADSIPath(), group);
      BREAK_ON_FAILED_HRESULT(hr);

      if (description_changed)
      {
         String description = Win::GetTrimmedDlgItemText(hwnd, IDC_DESCRIPTION);
         hr = group->put_Description(AutoBstr(description));
         BREAK_ON_FAILED_HRESULT(hr);
      }

      if (members_changed)
      {
         MemberList newMembers;
         listview->GetContents(newMembers);
         hr =
            ReconcileMembershipChanges(
               group,
               originalMembers,
               newMembers,
               hwnd);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // commit the property changes
      hr = group->SetInfo();
      BREAK_ON_FAILED_HRESULT(hr);

      // refresh the membership list
      if (!isClosing && members_changed)
      {
         BSTR name;
         hr = group->get_Name(&name);
         BREAK_ON_FAILED_HRESULT(hr);
         
         // refresh the listview
         originalMembers.clear();
         MemberVisitor
            visitor(originalMembers, hwnd, name, GetMachineName());
         hr = ADSI::VisitMembers(group, visitor);
         BREAK_ON_FAILED_HRESULT(hr);
         listview->SetContents(originalMembers);

         ::SysFreeString(name);
      }

      SetChangesApplied();
      ClearChanges();
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_SETTING_GROUP_PROPERTIES,
            GetObjectName().c_str(),
            GetMachineName().c_str()));
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\fpnwpass.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// FPNW password dialog
// 
// 10-20-98 sburns



#include "headers.hxx"
#include "fpnwpass.hpp"
#include "resource.h"
#include "dlgcomm.hpp"



static const DWORD HELP_MAP[] =
{
   IDC_PASSWORD,     NO_HELP,
   IDC_CONFIRM,      NO_HELP,
   IDCANCEL,         NO_HELP,
   IDOK,             NO_HELP,
   0, 0
};



FPNWPasswordDialog::FPNWPasswordDialog(const String& userName)
   :
   Dialog(IDD_FPNW_PASSWORD, HELP_MAP),
   name(userName)
{
   LOG_CTOR(FPNWPasswordDialog);
}



FPNWPasswordDialog::~FPNWPasswordDialog()
{
   LOG_DTOR(FPNWPasswordDialog);   
}



String
FPNWPasswordDialog::GetPassword() const
{
   LOG_FUNCTION(FPNWPasswordDialog::GetPassword);

   return password;
}



bool
FPNWPasswordDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
   switch (controlIDFrom)
   {
      case IDOK:
      {
         if (code == BN_CLICKED)
         {
            if (IsValidPassword(hwnd, IDC_PASSWORD, IDC_CONFIRM))
            {
               password = Win::GetDlgItemText(hwnd, IDC_PASSWORD);

               HRESULT unused = Win::EndDialog(hwnd, IDOK);

               ASSERT(SUCCEEDED(unused));
            }
         }
         break;
      }
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            if (
               popup.MessageBox(
                  hwnd,
                  IDS_FPNW_PASSWORD_CANCEL_WARNING,
                  MB_YESNO | MB_ICONWARNING) == IDYES)
            {
               HRESULT unused = Win::EndDialog(hwnd, IDCANCEL);

               ASSERT(SUCCEEDED(unused));
            }
         }
         break;
      }
      default:
      {
         // do nothing
      }
   }

   return true;
}



void
FPNWPasswordDialog::OnInit()
{
   LOG_FUNCTION(FPNWPasswordDialog::OnInit);

   Win::SetWindowText(
      hwnd,
      String::format(IDS_PASSWORD_TITLE, name.c_str()));

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_PASSWORD), PWLEN);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_CONFIRM), PWLEN);

   ClearChanges();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\grupnode.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// GroupNode class
// 
// 9-17-97 sburns



#include "headers.hxx"
#include "grupnode.hpp"
#include "resource.h"
#include "uuids.hpp"
#include "images.hpp"
#include "GroupGeneralPage.hpp"
#include "adsi.hpp"
#include "dlgcomm.hpp"



GroupNode::GroupNode(
   const SmartInterface<ComponentData>&   owner,
   const String&                          displayName,
   const String&                          ADSIPath,
   const String&                          description_)
   :
   AdsiNode(owner, NODETYPE_Group, displayName, ADSIPath),
   description(description_)
{
   LOG_CTOR2(GroupNode, GetDisplayName());
}



GroupNode::~GroupNode()
{
   LOG_DTOR2(GroupNode, GetDisplayName());
}
   

                 
String
GroupNode::GetColumnText(int column)
{
//    LOG_FUNCTION(GroupNode::GetColumnText);

   switch (column)
   {
      case 0:  // Name
      {
         return GetDisplayName();
      }
      case 1:  // Description
      {
         return description;
      }
      default:
      {
         // This should never be called
         ASSERT(false);
      }
   }

   return String();
}



int
GroupNode::GetNormalImageIndex()
{
   LOG_FUNCTION2(GroupNode::GetNormalImageIndex, GetDisplayName());

   return GROUP_INDEX;
}



bool
GroupNode::HasPropertyPages()
{
   LOG_FUNCTION2(GroupNode::HasPropertyPages, GetDisplayName());
      
   return true;
}



HRESULT
GroupNode::CreatePropertyPages(
   IPropertySheetCallback&             callback,
   MMCPropertyPage::NotificationState* state)
{
   LOG_FUNCTION2(GroupNode::CreatePropertySheet, GetDisplayName());

   // these pages delete themselves when the prop sheet is destroyed

   GroupGeneralPage* general_page =
      new GroupGeneralPage(state, GetADSIPath());

   // designate the general page as that which frees the notify state
   // (only one page in the prop sheet should do this)
   general_page->SetStateOwner();

   HRESULT hr = S_OK;
   do
   {
      hr = DoAddPage(*general_page, callback);
      if (FAILED(hr))
      {
         delete general_page;
         general_page = 0;
      }
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while(0);

   return hr;
}



HRESULT
GroupNode::UpdateVerbs(IConsoleVerb& consoleVerb)
{
   LOG_FUNCTION(GroupNode::UpdateVerbs);

   consoleVerb.SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
   consoleVerb.SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);

// CODEWORK: we should enable the refresh verb for result nodes too.
// NTRAID#NTBUG9-153012-2000/08/31-sburns
//   consoleVerb.SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

   consoleVerb.SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
   consoleVerb.SetDefaultVerb(MMC_VERB_PROPERTIES);

   return S_OK;
}



HRESULT
GroupNode::Rename(const String& newName)
{
   LOG_FUNCTION(GroupNode::Rename);

   String name(newName);

   // trim off whitespace.
   // NTRAID#NTBUG9-328306-2001/02/26-sburns
   
   name.strip(String::BOTH);
   
   if (!IsValidSAMName(name))
   {
      popup.Gripe(
         GetOwner()->GetMainWindow(),
         String::format(
            IDS_BAD_SAM_NAME,
            name.c_str()));
      return S_FALSE;
   }

   HRESULT hr = AdsiNode::rename(name);
   if (FAILED(hr))
   {
      String path = GetADSIPath();      
      popup.Error(
         GetOwner()->GetMainWindow(),
         hr,
         String::format(
            IDS_ERROR_RENAMING_GROUP,
            ADSI::ExtractObjectName(path).c_str()));
      return S_FALSE;
   }

   return S_OK;
}



HRESULT
GroupNode::Delete()
{
   LOG_FUNCTION(GroupNode::Delete);

   String name = ADSI::ExtractObjectName(GetADSIPath());

   if (
      popup.MessageBox(
         GetOwner()->GetMainWindow(),
         String::format(
            IDS_CONFIRM_GROUP_DELETE,
            name.c_str()),
         MB_ICONWARNING | MB_YESNO) == IDYES)
   {
      HRESULT hr =
         ADSI::DeleteObject(
            ADSI::ComposeMachineContainerPath(GetOwner()->GetInternalComputerName()),
            name,
            ADSI::CLASS_Group);

      if (SUCCEEDED(hr))
      {
         return S_OK;
      }

      popup.Error(
         GetOwner()->GetMainWindow(),
         hr,
         String::format(IDS_ERROR_DELETING_GROUP, name.c_str()));
   }

   return E_FAIL;
}



HRESULT
GroupNode::AddMenuItems(
   IContextMenuCallback&   callback,
   long&                   insertionAllowed)
{
   LOG_FUNCTION(GroupNode::AddMenuItems);

   static const ContextMenuItem items[] =
   {
      {
         CCM_INSERTIONPOINTID_PRIMARY_TOP,
         IDS_ADD_TO_GROUP_MEMBERSHIP,
         IDS_ADD_TO_GROUP_MEMBERSHIP_STATUS
      },
      {
         CCM_INSERTIONPOINTID_PRIMARY_TASK,
         IDS_ADD_TO_GROUP_MEMBERSHIP,
         IDS_ADD_TO_GROUP_MEMBERSHIP_STATUS
      }
   };

   return
      BuildContextMenu(
         items,
         items + sizeof(items) / sizeof(ContextMenuItem),
         callback,
         insertionAllowed);
}



HRESULT
GroupNode::MenuCommand(
   IExtendContextMenu&  extendContextMenu,
   long                 commandID)
{
   LOG_FUNCTION(GroupNode::MenuCommand);

   switch (commandID)
   {
      case IDS_ADD_TO_GROUP_MEMBERSHIP:
      {
         return showProperties(extendContextMenu);
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return S_OK;
}



HRESULT
GroupNode::showProperties(IExtendContextMenu& extendContextMenu)
{
   LOG_FUNCTION2(GroupNode::ShowProperties, GetDisplayName());

   SmartInterface<IPropertySheetProvider> prop_sheet_provider(0);
   HRESULT hr =
      prop_sheet_provider.AcquireViaQueryInterface(
         *(GetOwner()->GetConsole()) );
   if (SUCCEEDED(hr))
   {
      bool cleanup = false;
      do
      {
         hr =
            prop_sheet_provider->FindPropertySheet(
               reinterpret_cast<MMC_COOKIE>(this),
               0,
               this);
         if (hr == S_OK)
         {
            // sheet found, and brought to the foreground
            break;
         }

         hr =
            prop_sheet_provider->CreatePropertySheet(
               GetDisplayName().c_str(),
               TRUE,    // create a prop sheet, not a wizard
               reinterpret_cast<MMC_COOKIE>(this),
               this,
               0);
         BREAK_ON_FAILED_HRESULT(hr);

         // passing extendContextMenu here is ok, as ComponentData implements
         // IExtendContextMenu and IComponentData, and Component implements
         // IExtendContextMenu and IComponent.
         hr =
            prop_sheet_provider->AddPrimaryPages(
               &extendContextMenu,
               TRUE,
               GetOwner()->GetMainWindow(),
               FALSE);
         cleanup = FAILED(hr);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = prop_sheet_provider->AddExtensionPages();
         cleanup = FAILED(hr);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = prop_sheet_provider->Show(0, 0);
         cleanup = FAILED(hr);
         BREAK_ON_FAILED_HRESULT(hr);
      }
      while (0);

      if (cleanup)
      {
         prop_sheet_provider->Show(-1, 0);
      }
   }

   if (FAILED(hr))
   {
      popup.Error(
         GetOwner()->GetMainWindow(),
         hr,
         String::format(IDS_ERROR_SPAWNING_GROUP_PROPERTIES, GetDisplayName()));
   }
      
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\gfnode.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// GroupsFolder Node class
// 
// 9-17-97 sburns



#include "headers.hxx"
#include "gfnode.hpp"
#include "uuids.hpp"
#include "resource.h"
#include "grupnode.hpp"
#include "images.hpp"
#include "adsi.hpp"
#include "compdata.hpp"
#include "CreateGroupDialog.hpp"
#include "dlgcomm.hpp"



static
FolderNode::ColumnList
buildColumnList()
{
   FolderNode::ColumnList list;

   static const ResultColumn col1 =
   {   
      IDS_GROUP_NAME_COLUMN_TITLE,
      IDS_GROUP_NAME_COLUMN_WIDTH
   };
   static const ResultColumn col2 =
   {
      IDS_GROUP_DESCRIPTION_COLUMN_TITLE,
      IDS_GROUP_DESCRIPTION_COLUMN_WIDTH
   };

   list.push_back(col1);
   list.push_back(col2);

   return list;
};



static
FolderNode::MenuItemList
buildMenuItemList()
{
   FolderNode::MenuItemList list;

   static const ContextMenuItem item1 =
   {
      CCM_INSERTIONPOINTID_PRIMARY_TOP,
      IDS_GF_MENU_CREATE_GROUP,
      IDS_GF_MENU_NEW_GROUP_STATUS
   };
   // static const ContextMenuItem item2 =
   // {
   //    CCM_INSERTIONPOINTID_PRIMARY_NEW,
   //    IDS_GF_MENU_NEW_GROUP,
   //    IDS_GF_MENU_NEW_GROUP_STATUS         
   // };

   list.push_back(item1);
   // list.push_back(item2);

   return list;
}



GroupsFolderNode::GroupsFolderNode(
   const SmartInterface<ComponentData>& owner)
   :
   FolderNode(
      owner,
      NODETYPE_GroupsFolder,
      IDS_GROUPS_FOLDER_DISPLAY_NAME,
      IDS_GROUPS_FOLDER_TYPE_TITLE,
      buildColumnList(),
      buildMenuItemList())
{
   LOG_CTOR(GroupsFolderNode);
}



GroupsFolderNode::~GroupsFolderNode()
{
   LOG_DTOR(GroupsFolderNode);
}



HRESULT
GroupsFolderNode::MenuCommand(
   IExtendContextMenu&  /* extendContextMenu */,
   long                 commandID)
{
   LOG_FUNCTION(GroupsFolderNode::MenuCommand);

   switch (commandID)
   {
      case IDS_GF_MENU_NEW_GROUP:
      case IDS_GF_MENU_CREATE_GROUP:
      {
         CreateGroupDialog dlg(GetOwner()->GetInternalComputerName());
         if (dlg.ModalExecute(GetOwner()->GetMainWindow()))
         {
            RefreshView();
         }
         return S_OK;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return S_OK;
}



class GroupVisitor : public ADSI::ObjectVisitor
{
   public:

   GroupVisitor(
      FolderNode::ResultNodeList&            nodes_,
      const SmartInterface<ComponentData>&   owner_)
      :
      nodes(nodes_),
      owner(owner_)
   {
   }

   virtual
   ~GroupVisitor()
   {
   }
   
   virtual
   void
   Visit(const SmartInterface<IADs>& object)
   {
      LOG_FUNCTION(GroupVistor::visit);

      HRESULT hr = S_OK;
      do
      {
         
#ifdef DBG         
         BSTR cls = 0;
         hr = object->get_Class(&cls);
         BREAK_ON_FAILED_HRESULT(hr);
         LOG(String(cls));

         ASSERT(cls == ADSI::CLASS_Group);
         ::SysFreeString(cls);
#endif

         BSTR name = 0;
         hr = object->get_Name(&name);
         BREAK_ON_FAILED_HRESULT(hr);
         LOG(String(name));

         BSTR path = 0;
         hr = object->get_ADsPath(&path);
         BREAK_ON_FAILED_HRESULT(hr);
         LOG(L"Visiting " + String(path));

         SmartInterface<IADsGroup> group(0);
         hr = group.AcquireViaQueryInterface(*((IADs*)object)); 
         BREAK_ON_FAILED_HRESULT(hr);
         LOG(L"IADsGroup QI SUCCEEDED");

         BSTR desc = 0;
         hr = group->get_Description(&desc);
         BREAK_ON_FAILED_HRESULT(hr);
         LOG(String(desc));

         // created with a ref count == 1, so we own it here

         GroupNode* node = new GroupNode(owner, name, path, desc);
         ::SysFreeString(name);
         ::SysFreeString(path);
         ::SysFreeString(desc);

         // transfer ownership of the node pointer to a SmartInterface in
         // the list....

         nodes.push_back(SmartInterface<ResultNode>(node));

         // ... and relinquish our hold on it.

         node->Release();
      }
      while (0);

      if (FAILED(hr))
      {
         popup.Error(
            owner->GetMainWindow(),
            hr,
            String::load(IDS_ERROR_VISITING_GROUP));
      }
   }

   private:

   FolderNode::ResultNodeList& nodes;
   SmartInterface<ComponentData> owner;

   // not defined: no copying allowed

   GroupVisitor(const GroupVisitor&);
   const GroupVisitor& operator=(const GroupVisitor&);
};



void
GroupsFolderNode::BuildResultItems(ResultNodeList& items)
{
   LOG_FUNCTION(GroupsFolderNode::BuildResultItems);
   ASSERT(items.empty());

   GroupVisitor visitor(items, GetOwner());
   ADSI::VisitChildren(
      ADSI::ComposeMachineContainerPath(GetOwner()->GetInternalComputerName()),
      ADSI::CLASS_Group,
      visitor);
}



String
GroupsFolderNode::GetDescriptionBarText()
{
   LOG_FUNCTION(GroupsFolderNode::GetDescriptionBarText);

   return String::format(IDS_GROUPS_FOLDER_DESC, GetResultItemCount());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\images.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Image handling stuff
// 
// 9-24-97 sburns



#include "headers.hxx"
#include "images.hpp"


   
IconIDToIndexMap::Load(const IconIDToIndexMap map[], IImageList& imageList)
{
   LOG_FUNCTION(IconIDToIndexMap::Load);
   ASSERT(map);

   HRESULT hr = S_OK;
   for (int i = 0; map[i].resID != 0; i++)
   {
      HICON icon = 0;
      hr = Win::LoadIcon(map[i].resID, icon);

      ASSERT(SUCCEEDED(hr));
         
      // if the load fails, then skip this image index (@@I wonder what will
      // happen, then)

      if (SUCCEEDED(hr))
      {
         hr =
            imageList.ImageListSetIcon(
               reinterpret_cast<LONG_PTR*>(icon),
               map[i].index);

         // once the icon is added (copied) to the image list, we can
         // destroy the original.

         Win::DestroyIcon(icon);

         BREAK_ON_FAILED_HRESULT(hr);
      }
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\grupnode.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// GroupNode class
// 
// 9-17-97 sburns



#ifndef GRUPNODE_HPP_INCLUDED
#define GRUPNODE_HPP_INCLUDED



#include "adsinode.hpp"



class GroupNode : public AdsiNode
{
   friend class GroupsFolderNode;

   public:

   // Creates a new instance.
   //
   // owner - See base class ctor.
   // 
   // displayName - See base class ctor.
   //
   // ADSIPath - See base class ctor.
   //
   // description - text to appear as the node's description in the result
   // pane details view.

   GroupNode(
      const SmartInterface<ComponentData>&   owner,
      const String&                          displayName,
      const String&                          ADSIPath,
      const String&                          description);

   // Node overrides

   virtual
   HRESULT
   AddMenuItems(
      IContextMenuCallback&   callback,
      long&                   insertionAllowed);

   virtual
   String
   GetColumnText(int column);

   virtual 
   int
   GetNormalImageIndex();

   virtual
   HRESULT
   MenuCommand(
      IExtendContextMenu&  extendContextMenu,
      long                 commandID);
                                      
   virtual
   HRESULT
   UpdateVerbs(IConsoleVerb& consoleVerb);

   // ResultNode overrides

   virtual
   HRESULT
   CreatePropertyPages(
      IPropertySheetCallback&             callback,
      MMCPropertyPage::NotificationState* state);

   virtual
   HRESULT
   Delete();

   virtual
   bool
   HasPropertyPages();

   virtual
   HRESULT
   Rename(const String& newName);

   private:

   // only we can delete ourselves.
   virtual ~GroupNode();

   HRESULT
   showProperties(IExtendContextMenu& extendContextMenu);

   String description;

   // not defined: no copying allowed

   GroupNode(const GroupNode&);
   const GroupNode& operator=(const GroupNode&);
};



#endif   // GRUPNODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\images.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// Image handling stuff
//
// 9-24-97 sburns



#ifndef IMAGES_HPP_INCLUDED
#define IMAGES_HPP_INCLUDED



// Image indicies for scope and result panes.  These must be contiguous and
// unique

#define FOLDER_OPEN_INDEX   0
#define FOLDER_CLOSED_INDEX 1
#define USER_INDEX          2
#define GROUP_INDEX         3
#define POLICY_INDEX        4
#define DISABLED_USER_INDEX 5
#define ROOT_OPEN_INDEX     6
#define ROOT_CLOSED_INDEX   7
#define ROOT_ERROR_INDEX    8



struct IconIDToIndexMap
{
   int   resID;
   int   index;

   static
   Load(const IconIDToIndexMap map[], IImageList& imageList);
};



#endif   // IMAGES_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\lsm.h ===
// "User Rights" Dialog Box

#define idh_user_right_list		1000	// User Rights: "" (ListBox)
#define idh_user_right_granted_list	1010	// User Rights: "" (ListBox)
#define idh_user_right_add_button	1020	// User Rights: "A&dd..." (Button)
#define idh_user_right_remove_button	1030	// User Rights: "&Remove" (Button)

// "General" Dialog Box

#define idh_general_must_change		110	// General: "User &must change password at next 
#define idh_general_never_expires	130	// General: "Pass&word never expires" (Button)
#define idh_general_password		90	// General: "" (Edit)
#define idh_general_description		80	// General: "" (Edit)
#define idh_general_fullname		70	// General: "" (Edit)
#define idh_general_confirm		100	// General: "" (Edit)
#define idh_general_account_disabled	140	// General: "Account disa&bled" (Button)
#define idh_general_username		60	// General: "" (Edit)
#define	idh_general_account_lockedout	145
#define idh_general_cannot_change	120	// General: "U&ser cannot change password" 

// "Profile" Dialog Box

#define idh_profile_local_path_radio	170	// Profile: "Local path:" (Button)
#define idh_profile_connect_to_list	200	// Profile: "" (ComboBox)
#define idh_profile_path		150	// Profile: "" (Edit)
#define idh_profile_local_path_text	180	// Profile: "" (Edit)
#define idh_profile_logon_script	160	// Profile: "" (Edit)
#define idh_profile_to_text		210	// Profile: "" (Edit)
#define idh_profile_connect_to_radio	190	// Profile: "&Connect to:" (Button)
#define idh_general_account_disabled	140	// General: "Account disa&bled" (Button)

// "Dial-In" Dialog Box

#define idh_dialin_grant	220	// Dial-In: "&Grant dial-in permission to user" (Button)
#define idh_dialin_nocall	230	// Dial-In: "&No call back" (Button)
#define idh_dialin_setby	260	// Dial-In: "&Set by caller" (Button)
#define idh_dialin_preset	240	// Dial-In: "&Preset to:" (Button)
#define idh_dialin_preset_text	250	// Dial-In: "" (Edit)

// "Member Of" Dialog Box

#define idh_memberof_add	280	// Member Of: "A&dd..." (Button)
#define idh_memberof_list	270	// Member Of: "" (ListBox)
#define idh_memberof_remove	290	// Member Of: "&Remove" (Button)

// "Choose Target Machine" Dialog Box

#define idh_local_computer		340	// Choose Target Machine: "&Local computer:  
#define idh_another_computer		350	// Choose Target Machine: "&Another computer: 
#define idh_another_computer_text	360	// Choose Target Machine: "" (Edit)
#define idh_browse			370	// Choose Target Machine: "B&rowse..." (Button)
#define idh_allow_selected		380	// Choose Target Machine: "Allo&w the selected 

// "General" Dialog Box for Groups

#define idh_general121_name		305	// Name
#define idh_general121_members		310	// General: "" (ListBox)
#define idh_general121_add		320	// General: "A&dd..." (Button)
#define idh_general121_remove		330	// General: "&Remove" (Button)
#define idh_general121_description	300	// General: "" (Edit)

// "Password" Dialog Box

#define idh_password_never_expires		500	// Password: "&Password never expires" 
#define idh_expires_in				510	// Password: "&Expires in" (Button)
#define idh_expires_in_days			520	// Password: "0" (Edit)
#define idh_password_allow_changes_immediately	530	// Password: "Allo&w changes immediately" #define idh_password_allow_changes_in		540	// Password: "Allow &changes in" (Button)
#define idh_password_allow_changes_in_days	550	// Password: "0" (Edit)
#define idh_password_permit_blank		560	// Password: "Permit &blank passwords" 
#define idh_password_at_least			570	// Password: "A&t least" (Button)
#define idh_password_at_least_characters	580	// Password: "0" (Edit)
#define idh_password_do_not_keep_history	590	// Password: "&Do not keep password
#define idh_password_remember			600	// Password: "&Remember" (Button)
#define idh_password_remember_numberof		610	// Password: "0" (Edit)
#define idh_password_user_must_logon		620	// Password: "&Users must logon in order 
#define idh_passwords_must_be_strong		630	// Password: "Passwords must be &strong"
#define idh_passwords_store_cleartext		640	// Password: "Store passwords in #define
#define idh_password_allow_changes_in	540	// Password: "Allow &changes in" (Button)

// "Lockout" Dialog Box

#define idh_reset_lockout_after		730	// Lockout: "0" (Edit)
#define idh_lockout_until_admin_unlocks	770	// Lockout: "Lockout &until Administrator unlocks  #define idh_duration_minutes		760	// Lockout: "0" (Edit)
#define idh_duration			750	// Lockout: "&Duration:" (Button)
#define idh_no_lockout			700	// Lockout: "&No account lockout policy" (Button)
#define idh_enable_lockout		710	// Lockout: "&Enable account lockout policy" 
#define idh_lockout_after		720	// Lockout: "0" (Edit)
#define idh_duration_minutes	760	// Lockout: "0" (Edit)

// "Auditing" Dialog Box

#define idh_disable_auditing		800	// Lockout: "Disable auditing" (Button)
#define idh_enable_auditing		810	// Lockout: "Enable auditing" (Button)
#define idh_audit_ds_access_success	834	// Auditing: "" (Button)
#define idh_audit_ds_access_failure	835	// Auditing: "" (Button)
#define idh_audit_kerberos_success	836	// Auditing: "" (Button)
#define idh_audit_kerberos_failure	837	// Auditing: "" (Button)
#define idh_audit_login_success		820	// Auditing: "" (Button)
#define idh_audit_login_failure		821	// Auditing: "" (Button)
#define idh_audit_file_access_success	822	// Auditing: "" (Button)
#define idh_audit_file_access_failure	823	// Auditing: "" (Button)
#define idh_audit_user_right_success	824	// Auditing: "" (Button)
#define idh_audit_user_right_failure	825	// Auditing: "" (Button)
#define idh_audit_mgmt_events_success	826	// Auditing: "" (Button)
#define idh_audit_mgmt_events_failure	827	// Auditing: "" (Button)
#define idh_audit_security_policy_success	828	// Auditing: "" (Button)
#define idh_audit_security_policy_failure	829	// Auditing: "" (Button)
#define idh_audit_system_shutdown_success	830	// Auditing: "" (Button)
#define idh_audit_system_shutdown_failure	831	// Auditing: "" (Button)
#define idh_audit_process_creation_success	832	// Auditing: "" (Button)
#define idh_audit_process_creation_failure	833	// Auditing: "" (Button)
#define idh_audit_audit_categories	850
#define idh_audit_success		855
#define idh_audit_failure		860


// "Trusted C.A. List" Dialog Box

#define idh_ca_list	900	// Trusted C.A. List: "" (ListBox)
#define idh_ca_add	910	// Trusted C.A. List: "A&dd..." (Button)
#define idh_ca_remove	920	// Trusted C.A. List: "&Remove" (Button)
#define idh_ca_details	930	// Trusted C.A. List: "&Details" (Button)
#define idh_ca_edit	940	//Edit button

// "Encrypted Data Recovery" Dialog Box

#define idh_encrypted_deactivate	1110	// Encrypted Data Recovery: "&Deactivate" 
#define idh_encrypted_recovery_keys	1100	// Encrypted Data Recovery: "" (ListBox)
#define idh_encrypted_manage_keys	1120	// Encrypted Data Recovery: "&Manage Keys" 

// "Create User" Dialog Box

#define idh_createuser_confirm_password	1240	// Create User: "" (Edit)
#define idh_createuser_change_password	1250	// Create User: "User &must change password at 
#define idh_createuser_user_cannot_change	1260	// Create User: "U&ser cannot change 
#define idh_createuser_account_disabled	1280	// Create User: "Account disa&bled" (Button)
#define idh_createuser_full_name	1210	// Create User: "" (Edit)
#define idh_createuser_user_name	1200	// Create User: "" (Edit)
#define idh_createuser_create_button	1290	// Create User: "C&reate" (Button)
#define idh_createuser_password_never_expires	1270	// Create User: "Pass&word never expires" 
#define idh_createuser_description	1220	// Create User: "" (Edit)
#define idh_createuser_password		1230	// Create User: "" (Edit)
#define idh_createuser_close_button	1295

// "Create Group" Dialog Box

#define idh_creategroup_members		1320	// Create Group: "List2" (SysListView32)
#define idh_creategroup_addbutton	1330	// Create Group: "A&dd..." (Button)
#define idh_creategroup_removebutton	1340	// Create Group: "&Remove" (Button)
#define idh_creategroup_name		1300	// Create Group: "" (Edit)
#define idh_creategroup_createbutton	1350	// Create Group: "C&reate" (Button)
#define idh_creategroup_description	1310	// Create Group: "" (Edit)
#define idh_creategroup_closebutton	1360



#define idh_setpass_new_password	1400	// Set Password: "" (Edit)
#define idh_setpass_confirm_password	1405	// Set Password: "" (Edit)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\makefile.inc ===
# causes the regsvr stuff to work properly

!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\machine.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// ComputerChooserPage class
// 
// 9-11-97 sburns



#include "headers.hxx"
#include "machine.hpp"
#include "resource.h"
#include "lsm.h"
#include "adsi.hpp"
#include "dlgcomm.hpp"
#include "objpick.hpp"



static const DWORD HELP_MAP[] =
{
   IDC_LOCAL_MACHINE,      idh_local_computer,
   IDC_SPECIFIC_MACHINE,   idh_another_computer,
   IDC_MACHINE_NAME,       idh_another_computer_text, 
   IDC_BROWSE,             idh_browse, 
   IDC_OVERRIDE,           idh_allow_selected,
   0, 0
};



ComputerChooserPage::ComputerChooserPage(
   MMCPropertyPage::NotificationState* state,
   String&                             displayComputerName_,
   String&                             internalComputerName_,
   bool&                               canOverrideComputerName)
   :
   MMCPropertyPage(IDD_MACHINE_CHOOSER, HELP_MAP, state),
   displayComputerName(displayComputerName_),
   internalComputerName(internalComputerName_),
   can_override(canOverrideComputerName)
{
   LOG_CTOR(ComputerChooserPage);

   displayComputerName.erase();
   internalComputerName.erase();
   can_override = false;
}



ComputerChooserPage::~ComputerChooserPage()
{
   LOG_DTOR(ComputerChooserPage);
}



void
ComputerChooserPage::doEnabling()
{
   // enable the edit box and browse button only if the specific machine
   // radio button is pressed.
   bool enable = Win::IsDlgButtonChecked(hwnd, IDC_SPECIFIC_MACHINE);

   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_MACHINE_NAME), enable);
   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_BROWSE), enable);
}



class ComputerChooserObjectPickerResultCallback
   :
   public ObjectPicker::ResultsCallback
{
   public:

   ComputerChooserObjectPickerResultCallback(HWND machineNameEditBox)
      :
      hwnd(machineNameEditBox)
   {
      ASSERT(Win::IsWindow(hwnd));
   }

   int
   Execute(DS_SELECTION_LIST& selections)
   {
      // only single select
      ASSERT(selections.cItems == 1);

      DS_SELECTION& current = selections.aDsSelection[0];
      ASSERT(ADSI::CLASS_Computer.icompare(current.pwzClass) == 0);

      Win::SetWindowText(hwnd, current.pwzName);

      return 0;
   }

   private:

   HWND hwnd;
};



void
ComputerChooserPage::doBrowse()
{
   LOG_FUNCTION(ComputerChooserPage::doBrowse);

   static const int INFO_COUNT = 2;
   DSOP_SCOPE_INIT_INFO* infos = new DSOP_SCOPE_INIT_INFO[INFO_COUNT];
   memset(infos, 0, sizeof(DSOP_SCOPE_INIT_INFO) * INFO_COUNT);

   int scope = 0;   
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;

   infos[scope].flType =
         DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
      |  DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;

   infos[scope].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
   infos[scope].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

   scope++;
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flScope = 0;
   infos[scope].flType = 
         DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
      |  DSOP_SCOPE_TYPE_GLOBAL_CATALOG
      |  DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
      |  DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
      |  DSOP_SCOPE_TYPE_WORKGROUP
      |  DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
      |  DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;

   infos[scope].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
   infos[scope].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

   ASSERT(scope == INFO_COUNT - 1);

   DSOP_INIT_INFO init_info;
   memset(&init_info, 0, sizeof(init_info));

   init_info.cbSize = sizeof(init_info);
   init_info.flOptions = 0;
   init_info.pwzTargetComputer = 0;
   init_info.aDsScopeInfos = infos;
   init_info.cDsScopeInfos = INFO_COUNT;

   HRESULT hr =
      ObjectPicker::Invoke(
         hwnd,
         ComputerChooserObjectPickerResultCallback(
            Win::GetDlgItem(hwnd, IDC_MACHINE_NAME)),
         init_info);
   delete[] infos;

   if (FAILED(hr))
   {
      popup.Error(hwnd, hr, IDS_ERROR_LAUNCHING_PICKER);
   }
}



bool
ComputerChooserPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    ID,
   unsigned    code)
{
   if (code == BN_CLICKED)
   {
      switch (ID)
      {
         case IDC_LOCAL_MACHINE:
         case IDC_SPECIFIC_MACHINE:
         {
            doEnabling();
            return true;
         }
         case IDC_BROWSE:
         {
            doBrowse();
            return true;
         }
         default:
         {
            // do nothing
            break;
         }
      }
   }

   return false;
}



void
ComputerChooserPage::OnInit()
{
   LOG_FUNCTION(ComputerChooserPage::OnInit);

   Win::PropSheet_SetWizButtons(Win::GetParent(hwnd), PSWIZB_FINISH);

   // default to the local machine
   Win::CheckDlgButton(hwnd, IDC_LOCAL_MACHINE, BST_CHECKED);

   doEnabling();
}



bool
ComputerChooserPage::OnWizFinish()
{
   LOG_FUNCTION(ComputerChooserPage::OnWizFinish);

   Win::CursorSetting cursor(IDC_WAIT);

   String s;
   if (Win::IsDlgButtonChecked(hwnd, IDC_SPECIFIC_MACHINE))
   {
      s = Win::GetTrimmedDlgItemText(hwnd, IDC_MACHINE_NAME);
      if (s.empty())
      {
         popup.Gripe(hwnd, IDC_MACHINE_NAME, IDS_MUST_ENTER_MACHINE_NAME);
         Win::SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
         return true;
      }
   }

   HRESULT hr = S_OK;
   String message;
   do
   {
      if (!s.empty())
      {
         // we only need to check this if the snapin is not targeted at
         // the local machine.  (If the snapin is targeted at the local
         // machine, the very fact that this code is running on it is
         // proof that the machine is NT-based, and not Home Edition.
         // 145309 145288

         unsigned errorResId = 0;
         hr = CheckComputerOsIsSupported(s, errorResId);
         BREAK_ON_FAILED_HRESULT(hr);

         if (hr == S_FALSE)
         {
            hr = E_FAIL;
            message =
               String::format(
                  errorResId,
                  s.c_str());
            break;
         }
      }
      else
      {
         // we're focusing on the local computer.  Check for Home Edition.
         // NTRAID#NTBUG9-145309 NTRAID#NTBUG9-145288

         OSVERSIONINFOEX verInfo;
         memset(&verInfo, 0, sizeof(verInfo));

         hr = Win::GetVersionEx(verInfo);
         BREAK_ON_FAILED_HRESULT(hr);

         if (verInfo.wSuiteMask & VER_SUITE_PERSONAL)
         {
            hr = E_FAIL;
            message = String::load(IDS_MACHINE_IS_HOME_EDITION_LOCAL);

            break;
         }
      }

      Computer comp(s);

      hr = comp.Refresh();
      BREAK_ON_FAILED_HRESULT(hr);

      // bind to the computer to verify its accessibility (should work
      // if above worked, but just in case...

      String c = comp.GetNetbiosName();
      hr = ADSI::IsComputerAccessible(c);
      BREAK_ON_FAILED_HRESULT(hr);

      // determine if the machine is a DC
      if (comp.IsDomainController())
      {
         // can't use this on DCs
         hr = E_FAIL;
         message = String::format(IDS_ERROR_DC_NOT_SUPPORTED, c.c_str());
         break;
      }

      // use the name the user entered as the display name, not the
      // computer's netbios name (even thought it is the netbios name that
      // really matters).  454513
         
      SetComputerNames(s, displayComputerName, internalComputerName);
   }
   while (0);

   if (FAILED(hr))
   {
      if (message.empty())
      {
         String error = GetErrorMessage(hr);
         message =
            String::format(
               IDS_CANT_ACCESS_MACHINE,
               s.c_str(),
               error.c_str());
      }

      // at this point, an error occurred.  refuse to close
      popup.Gripe(hwnd, IDC_MACHINE_NAME, message);
      Win::SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
   }

   if (Win::IsDlgButtonChecked(hwnd, IDC_OVERRIDE))
   {
      can_override = true;
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\membershiplistview.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Group Membership/Object Picker handler class
// 
// 11-3-97 sburns



#include "headers.hxx"
#include "MembershipListView.hpp"
#include "resource.h"
#include "adsi.hpp"
#include "dlgcomm.hpp"
#include "objpick.hpp"



void
AddIconImage(HIMAGELIST imageList, int iconResID)
{
   LOG_FUNCTION(AddIconImage);
   ASSERT(imageList);
   ASSERT(iconResID);
   
   if (iconResID && imageList)
   {
      HICON icon = 0;
      HRESULT hr = Win::LoadImage(iconResID, icon);

      ASSERT(SUCCEEDED(hr));

      if (SUCCEEDED(hr))
      {
         Win::ImageList_AddIcon(imageList, icon);

         // once the icon is added (copied) to the image list, we can
         // destroy the original.

         Win::DestroyIcon(icon);
      }
   }
}
         


MembershipListView::MembershipListView(
   HWND           listview,
   const String&  machine,
   Options        opts)
   :
   view(listview),
   computer(machine),
   options(opts)
{
   LOG_CTOR(MembershipListView);
   ASSERT(Win::IsWindow(view));

   LVCOLUMN column;
   memset(&column, 0, sizeof(column));
   column.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
   column.fmt = LVCFMT_LEFT;

   int width = 0;
   String::load(IDS_MEMBER_LIST_NAME_COLUMN_WIDTH).convert(width);
   column.cx = width;

   String label = String::load(IDS_MEMBER_LIST_NAME_COLUMN);
   column.pszText = const_cast<wchar_t*>(label.c_str());

   Win::ListView_InsertColumn(view, 0, column);

//    // add a column to the list view for description.
//    String::load(IDS_MEMBER_LIST_DESC_COLUMN_WIDTH).convert(width);
//    column.cx = width;
//    label = String::load(IDS_MEMBER_LIST_DESC_COLUMN);
//    column.pszText = const_cast<wchar_t*>(label.c_str());
// 
//    Win::ListView_InsertColumn(view, 1, column);

   // create the image list for the group members consisting of images
   // for groups and users.

   HIMAGELIST images =
      Win::ImageList_Create(
         Win::GetSystemMetrics(SM_CXSMICON),
         Win::GetSystemMetrics(SM_CYSMICON),
         ILC_MASK,
         5,
         0);

   // the order in which these are added must be the same that the
   // MemberInfo::Type enum values are listed!

   AddIconImage(images, IDI_USER);
   AddIconImage(images, IDI_GROUP);
   AddIconImage(images, IDI_DOMAIN_USER);
   AddIconImage(images, IDI_DOMAIN_GROUP);
   AddIconImage(images, IDI_UNKNOWN_SID);

   Win::ListView_SetImageList(view, images, LVSIL_SMALL);

   // CODEWORK: instead of refreshing a new computer instance, can we
   // arrange to copy an existing one?  Or use a reference to an existing
   // one?

   computer.Refresh();
}



MembershipListView::~MembershipListView()
{
   LOG_DTOR(MembershipListView);

   ClearContents();
}



void
MembershipListView::ClearContents()
{
   // traverse the list and delete each item in reverse order (to minimize
   // redraw).

   for (int i = Win::ListView_GetItemCount(view) - 1; i >= 0; --i)
   {
      deleteItem(i);
   }
}



void
MembershipListView::GetContents(MemberList& results) const
{
   LOG_FUNCTION(MembershipListView::GetContents);

   LVITEM item;
   memset(&item, 0, sizeof(item));
   item.mask = LVIF_PARAM;

   for (int i = Win::ListView_GetItemCount(view) - 1; i >= 0; --i)
   {
      item.iItem = i;

      if (Win::ListView_GetItem(view, item))
      {
         ASSERT(item.lParam);

         results.push_back(*(reinterpret_cast<MemberInfo*>(item.lParam)));
      }
   }
}



void
MembershipListView::SetContents(const MemberList& newMembers)
{
   LOG_FUNCTION(MembershipListView::SetContents);

   ClearContents();

   for (
      MemberList::iterator i = newMembers.begin();
      i != newMembers.end();
      i++)
   {
      // copy the node info

      MemberInfo* info = new MemberInfo(*i);
      if (!itemPresent(info->path))
      {
         addItem(*info);
      }
   }
}



void
MembershipListView::addItem(const MemberInfo& info)
{
   LVITEM item;
   memset(&item, 0, sizeof(item));

   // add the "main" item to the list control

   String text;
   switch (info.type)
   {
      case MemberInfo::DOMAIN_USER:
      case MemberInfo::DOMAIN_GROUP:
      {
         if (!info.upn.empty())
         {
            text =
               String::format(
                  IDS_GLOBAL_ACCOUNT_DISPLAY_FORMAT,
                  ADSI::ExtractDomainObjectName(info.path).c_str(),
                  info.upn.c_str());
         }
         else
         {
            text = ADSI::ExtractDomainObjectName(info.path);
         }
         break;
      }
      default:
      {
         text = ADSI::ExtractObjectName(info.path);
         break;
      }
   }        

   item.mask     = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
   item.iItem    = 0;                                 
   item.iSubItem = 0;                                 
   item.pszText  = const_cast<wchar_t*>(text.c_str());
   item.lParam   = reinterpret_cast<LPARAM>(&info);   
   item.iImage   = static_cast<int>(info.type);       

   item.iItem = Win::ListView_InsertItem(view, item);

   // // add the description sub-item to the list control
   // item.mask = LVIF_TEXT; 
   // item.iSubItem = 1;
   // item.pszText = const_cast<wchar_t*>(info->desc.c_str());
   // Win::ListView_SetItem(view, item);
}



void
MembershipListView::OnRemoveButton()
{
   LOG_FUNCTION(MembershipListView::OnRemoveButton);

   int count = Win::ListView_GetSelectedCount(view);
   if (count)
   {
      // determine the indices of the selected items and delete them in
      // reverse order (so that the remaining indices are valid)

      int i = Win::ListView_GetItemCount(view) - 1;
      ASSERT(i >= 0);

      int j = 0;
      std::vector<int, Burnslib::Heap::Allocator<int> > indices(count);

      while (i >= 0)
      {
         if (Win::ListView_GetItemState(view, i, LVIS_SELECTED))
         {
            indices[j++] = i;
         }
         --i;
      }

      ASSERT(j == count);

      for (i = 0; i < count; ++i)
      {
         deleteItem(indices[i]);
      }
   }
}



void
MembershipListView::deleteItem(int target)
{
   LOG_FUNCTION(MembershipListView::deleteItem);
   ASSERT(target != -1);

   LVITEM item;
   memset(&item, 0, sizeof(item));
   item.mask = LVIF_PARAM;
   item.iItem = target;

   if (Win::ListView_GetItem(view, item))
   {
      ASSERT(item.lParam);

      delete reinterpret_cast<MemberInfo*>(item.lParam);
      Win::ListView_DeleteItem(view, target);
      return;
   }
}



void
getGroupMembershipPickerSettings(
   DSOP_SCOPE_INIT_INFO*&  infos,
   ULONG&                  infoCount)
{
   LOG_FUNCTION(getGroupMembershipPickerSettings);

   static const int INFO_COUNT = 5;
   infos = new DSOP_SCOPE_INIT_INFO[INFO_COUNT];
   infoCount = INFO_COUNT;
   memset(infos, 0, sizeof(DSOP_SCOPE_INIT_INFO) * INFO_COUNT);

   int scope = 0;

   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
   infos[scope].flScope =
            DSOP_SCOPE_FLAG_WANT_DOWNLEVEL_BUILTIN_PATH

         // check the users and groups checkbox in the look for dialog
         // by default. NTRAID#NTBUG9-300910-2001/01/31-sburns
         
         |  DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS
         |  DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS;
         
      // this is implied for machine only scope
      /* |  DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT */

   // allow only local users from the machine scope

   infos[scope].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
   infos[scope].FilterFlags.flDownlevel =
         DSOP_DOWNLEVEL_FILTER_USERS
      |  DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS;

   // 
   // for the domain this machine is joined to (native and mixed mode).
   // 

   scope++;
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flScope =

         // make the joined domain the starting scope so that the default
         // filter options are actually evaluated.  In the case that the
         // machine is not joined, then this scope is not included in the
         // look in, and the default filter option we set don't matter
         // anyway (since the only scope will be local machine).
         // NTRAID#NTBUG9-300910-2001/02/06-sburns
         
         DSOP_SCOPE_FLAG_STARTING_SCOPE
      |  DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT
      |  DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS
      |  DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS;

   infos[scope].flType =
         DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
      |  DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;

   infos[scope].FilterFlags.Uplevel.flNativeModeOnly =
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_UNIVERSAL_GROUPS_SE
      |  DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

   // here, we allow only domain global groups and domain users.  While
   // it is possible to add a domain local group to a machine local group,
   // I'm told such an operation is not really useful from an administraion
   // perspective.

   infos[scope].FilterFlags.Uplevel.flMixedModeOnly =   
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

   // same comment above re: domain local groups applies here too.

   infos[scope].FilterFlags.flDownlevel =
         DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS
      |  DSOP_DOWNLEVEL_FILTER_USERS;

   //       
   // for domains in the same tree (native and mixed mode)
   // 

   scope++;
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
   infos[scope].flScope =
         DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT
      |  DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS
      |  DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS;

   infos[scope].FilterFlags.Uplevel.flNativeModeOnly =
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_UNIVERSAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

   // above domain local group comment applies here, too.

   infos[scope].FilterFlags.Uplevel.flMixedModeOnly =   
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

   // 
   // for external trusted domains
   // 

   scope++;
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flScope =
         DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT
      |  DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS
      |  DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS;
   infos[scope].flType =
         DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
      |  DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;

   infos[scope].FilterFlags.Uplevel.flNativeModeOnly =
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_UNIVERSAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

   infos[scope].FilterFlags.Uplevel.flMixedModeOnly =   
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

   infos[scope].FilterFlags.flDownlevel =
         DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS
      |  DSOP_DOWNLEVEL_FILTER_USERS;

   // 
   // for the global catalog
   // 

   scope++;
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flScope =
         DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT
      |  DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS
      |  DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS;
   infos[scope].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;

   // only native mode applies to gc scope.

   infos[scope].FilterFlags.Uplevel.flNativeModeOnly =
         DSOP_FILTER_GLOBAL_GROUPS_SE
      |  DSOP_FILTER_UNIVERSAL_GROUPS_SE
      |  DSOP_FILTER_USERS;

// SPB:252126 the workgroup scope doesn't apply in this case
//    // for when the machine is not joined to a domain
//    scope++;
//    infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
//    infos[scope].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
//    infos[scope].flType = DSOP_SCOPE_TYPE_WORKGROUP;
// 
//    infos[scope].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
//    infos[scope].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;

   ASSERT(scope == INFO_COUNT - 1);
}



void
getUserMembershipPickerSettings(
   DSOP_SCOPE_INIT_INFO*&  infos,
   ULONG&                  infoCount)
{
   LOG_FUNCTION(getUserMembershipPickerSettings);
   static const int INFO_COUNT = 1;
   infos = new DSOP_SCOPE_INIT_INFO[INFO_COUNT];
   infoCount = INFO_COUNT;
   memset(infos, 0, sizeof(DSOP_SCOPE_INIT_INFO) * INFO_COUNT);

   int scope = 0;   
   infos[scope].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   infos[scope].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;

   infos[scope].flScope =
         DSOP_SCOPE_FLAG_STARTING_SCOPE; 
      // this is implied for machine only scope
      /* |  DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT */

   infos[scope].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS;

   ASSERT(scope == INFO_COUNT - 1);
}



class ResultsCallback : public ObjectPicker::ResultsCallback
{
   public:

   ResultsCallback(MembershipListView& mlview)
      :
      view(mlview)
   {
      LOG_CTOR(ResultsCallback);
   }

   virtual
   ~ResultsCallback()
   {
      LOG_DTOR(ResultsCallback);
   }
   
   virtual
   int
   Execute(DS_SELECTION_LIST& selections)
   {
      view.AddPickerItems(selections);
      return 0;
   }

   private:

   MembershipListView& view;

   // not defined: no copying allowed

   ResultsCallback(const ResultsCallback&);
   const ResultsCallback& operator=(const ResultsCallback&);
};



// caller needs to call delete[] on element to free the copied string.

void
CopyStringToNewWcharElement(PWSTR& element, const String& str)
{
   LOG_FUNCTION2(CopyStringToNewWcharElement, str);
   ASSERT(!element);
   ASSERT(!str.empty());

   size_t len = str.length();
   element = new WCHAR[len + 1];
   memset(element, 0, (len + 1) * sizeof(WCHAR));
   str.copy(element, len);
}



void
MembershipListView::OnAddButton()
{
   LOG_FUNCTION(MembershipListView::OnAddButton);

   String computerName = computer.GetNetbiosName();

   DSOP_INIT_INFO initInfo;
   memset(&initInfo, 0, sizeof(initInfo));

   initInfo.cbSize = sizeof(initInfo);
   initInfo.flOptions = DSOP_FLAG_MULTISELECT;

   // aliasing the computerName internal pointer here -- ok, as lifetime
   // of computerName > initInfo

   initInfo.pwzTargetComputer =
      computer.IsLocal() ? 0 : computerName.c_str();

   // have the object picker fetch the group type attribute for us.  If user
   // objects are picked (which don't have this attribute), this is not a
   // problem: the result will simply indicate that the attribute value is
   // empty -- the returned variant will be VT_EMPTY.

   // @@for the machine scope, we also need the sid of the user, as a workaround
   // to bug 333491.  Q: I must ask for the SID for all objects (not just for
   // those from a single scope), so, do I incur a perf hit to get that
   // attribute?

   initInfo.cAttributesToFetch = 2;
   PWSTR attrs[3] = {0, 0, 0};

   //
   // BUGBUG:  This is causing a compiler issue on axp64.  So, 
   //

#pragma warning(disable:4328)

   CopyStringToNewWcharElement(attrs[0], ADSI::PROPERTY_GroupType);
   CopyStringToNewWcharElement(attrs[1], ADSI::PROPERTY_ObjectSID);

   // obtuse notation required to cast *in* const and away the static len

   initInfo.apwzAttributeNames = const_cast<PCWSTR*>(&attrs[0]); 

   switch (options)
   {
      case GROUP_MEMBERSHIP:
      {
         getGroupMembershipPickerSettings(
            initInfo.aDsScopeInfos,
            initInfo.cDsScopeInfos);
         break;
      }
      case USER_MEMBERSHIP:
      {
         getUserMembershipPickerSettings(
            initInfo.aDsScopeInfos,
            initInfo.cDsScopeInfos);
         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   HRESULT hr =
      ObjectPicker::Invoke(
         view,
         ResultsCallback(*this),
         initInfo);
   delete[] initInfo.aDsScopeInfos;
   delete[] attrs[0];
   delete[] attrs[1];

   if (FAILED(hr))
   {
      popup.Error(view, hr, IDS_ERROR_LAUNCHING_PICKER);
   }
}



void
MembershipListView::AddPickerItems(DS_SELECTION_LIST& selections)
{
   LOG_FUNCTION(MembershipListView::AddPickerItems);

   DS_SELECTION* current = &(selections.aDsSelection[0]);

   for (int i = 0; i < selections.cItems; i++, current++)
   {
      String name;
      String path;
      String cls;
      String upn;
      switch (options)
      {
         case USER_MEMBERSHIP:
         {
            ASSERT(current->pwzClass == ADSI::CLASS_Group);

            if (current->pwzClass == ADSI::CLASS_Group)
            {
               path = current->pwzADsPath;
               name = current->pwzName;   
               cls  = current->pwzClass;  
               upn.erase();
            }
            break;
         }
         case GROUP_MEMBERSHIP:
         {
            path = current->pwzADsPath;
            name = current->pwzName;   
            cls  = current->pwzClass;  
            upn  = current->pwzUPN;    
            break;
         }
         default:
         {
            ASSERT(false);
            break;
         }
      }
      
      if (!path.empty() && !cls.empty() && !name.empty())
      {
         if (itemPresent(path))
         {
            popup.Info(
               view,
               String::format(
                  IDS_ITEM_ALREADY_PRESENT,
                  name.c_str()));
         }
         else
         {

            LOG(L"Adding object " + path);

   // #ifdef DBG
   //          do
   //          {
   //             HRESULT hr = S_OK;
   //             IADs* obj = 0;
   //             hr = ::ADsGetObject(
   //                const_cast<wchar_t*>(path.c_str()),
   //                IID_IADs,
   //                (void**) &obj);
   //             BREAK_ON_FAILED_HRESULT(hr);
   // 
   //             BSTR p;
   //             hr = obj->get_ADsPath(&p);
   //             BREAK_ON_FAILED_HRESULT(hr);
   //             ::SysFreeString(p);
   // 
   //             BSTR n;
   //             hr = obj->get_Name(&n);
   //             BREAK_ON_FAILED_HRESULT(hr);
   //             ::SysFreeString(n);
   // 
   //             BSTR pr;
   //             hr = obj->get_Parent(&pr);
   //             BREAK_ON_FAILED_HRESULT(hr);
   //             ::SysFreeString(pr);
   // 
   //             _variant_t variant;
   //             hr = obj->Get(AutoBstr(ADSI::PROPERTY_GroupType), &variant);
   //             BREAK_ON_FAILED_HRESULT(hr);
   //             long type = variant;
   // 
   //             obj->Release();
   //          }
   //          while (0);
   // #endif


            // the only reason for this to be null is out-of-memory, which if
            // it occurs causes the object picker to fail (so we should not
            // reach this path)   

            ASSERT(current->pvarFetchedAttributes);

            // extract the GroupType of the object, if applicable

            long groupType = 0;
            if (V_VT(&current->pvarFetchedAttributes[0]) != VT_EMPTY)
            {
               ASSERT(cls.icompare(ADSI::CLASS_Group) == 0);
               _variant_t variant(current->pvarFetchedAttributes[0]);
               groupType = variant;
            }

            // extract the ObjectSID of the object (this should always be
            // present, but sometimes the object picker can't get it, so
            // check for empty)

            if (V_VT(&current->pvarFetchedAttributes[1]) == VT_EMPTY)
            {
               popup.Error(
                  view,
                  String::format(IDS_ITEM_INCOMPLETE, name.c_str()));
               continue;
            }
                  
            String sidPath;
            HRESULT hr =
               ADSI::VariantToSidPath(
                  &current->pvarFetchedAttributes[1],
                  sidPath);

            // what do we do about a failure here?  ignore it, then in the
            // membership reconciliation code fall back to using the normal path.
            // That's making the best effort.

            MemberInfo* info = new MemberInfo;
            hr =
               info->Initialize(
                  name,
                  path,
                  upn,
                  sidPath,
                  cls,
                  groupType,
                  computer.GetNetbiosName());

            // we don't expect this version of Initialize to ever fail, as it
            // is pretty much member-wise copy.  Anyway, if it did, there's
            // nothing we can do: we'll show the item anyway, even though
            // the type may be inaccurate.

            ASSERT(SUCCEEDED(hr));
            
            addItem(*info);
         }
      }
   }
}



// Compare strings using the same flags used by the SAM on workstations.
// 365500

LONG
SamCompatibleStringCompare(const String& first, const String& second)
{
   LOG_FUNCTION(SamCompatibleStringCompare);

   // SAM creates local accounts by creating a key in the registry, and the
   // the name comparision semantics are exactly those of registry keys, and
   // RtlCompareUnicodeString is the API that implements those semantics.

   UNICODE_STRING s1;
   UNICODE_STRING s2;
   ::RtlInitUnicodeString(&s1, first.c_str());
   ::RtlInitUnicodeString(&s2, second.c_str());   

   return ::RtlCompareUnicodeString(&s1, &s2, TRUE);
}
   


bool
MembershipListView::itemPresent(const String& path)
{
   LOG_FUNCTION(MembershipListView::itemPresent);

   LVITEM item;
   memset(&item, 0, sizeof(item));
   item.mask = LVIF_PARAM;

   for (int i = Win::ListView_GetItemCount(view) - 1; i >= 0; i--)
   {
      item.iItem = i;

      if (Win::ListView_GetItem(view, item))
      {
         ASSERT(item.lParam);

         MemberInfo* info = reinterpret_cast<MemberInfo*>(item.lParam);
         if (SamCompatibleStringCompare(path, info->path) == 0)
         {
            return true;
         }
      }
   }

   return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\machine.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// ComputerChooserPage class
// 
// 9-11-97 sburns



#ifndef MACHINE_HPP_INCLUDED
#define MACHINE_HPP_INCLUDED



#include "mmcprop.hpp"



class ComputerChooserPage : public MMCPropertyPage
{
   public:

   // Creates a new instance.
   // 
   // state - see base class.
   // 
   // machineName - String to receive the machine name chosen.
   // 
   // canOverrideComputerName - bool to receive the override flag.

   ComputerChooserPage(
      MMCPropertyPage::NotificationState* state,
      String&                             displayComputerName,
      String&                             internalComputerName,
      bool&                               canOverrideComputerName);


      
   virtual
   ~ComputerChooserPage();


   
   protected:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    ID,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnWizFinish();

   private:

   // not implemented: no copying allowed
   ComputerChooserPage(const ComputerChooserPage&);
   const ComputerChooserPage& operator=(const ComputerChooserPage&);

   void
   doEnabling();

   void
   doBrowse();

   String&  displayComputerName;
   String&  internalComputerName;
   bool&    can_override;
};



#endif   // MACHINE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\memberinfo.cpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
// 
// MemberInfo class
// 
// 24 Jan 2000 sburns



#include "headers.hxx"
#include "MemberInfo.hpp"
#include "adsi.hpp"



// Return true if the paths refer to an object whose SID cannot be resolved,
// false otherwise.
// 
// adsPath - WinNT provider path to the object
// 
// sidPath - WinNT provider SID-style path to the object.

bool
IsUnresolvableSid(const String& adsPath, const String sidPath)
{
   LOG_FUNCTION2(IsUnresolvableSid, adsPath);

   bool result = false;

   if (sidPath == adsPath)
   {
      result = true;
   }

// // @@ here is a "temporary" workaround: no / found after the provider
// // prefix implies that the path is a SID-style path, paths of that
// // form are returned only by ADSI when the SID can't be resolved to a name.
// 
//    size_t prefixLen = ADSI::PROVIDER_ROOT.length();
//    if (
//          (adsPath.find(L'/', prefixLen) == String::npos)
//       && (adsPath.substr(prefixLen, 4) == L"S-1-") )
//    {
//       result = true;
//    }

   LOG(
      String::format(
         L"%1 %2 an unresolved SID",
         adsPath.c_str(),
         result ? L"is" : L"is NOT"));

   return result;
}
     


HRESULT
MemberInfo::Initialize(
   const String&           objectName,
   const String&           adsPath,
   const String&           upn_,
   const String&           sidPath_,
   const String&           adsClass,
   long                    groupTypeAttrVal,
   const String&           machine)
{
   LOG_FUNCTION(MemberInfo::Initialize);
   ASSERT(!objectName.empty());
   ASSERT(!adsPath.empty());
   ASSERT(!adsClass.empty());
   ASSERT(!machine.empty());

   // sidPath and upn may be empty

   name    = objectName;             
   path    = adsPath;                
   upn     = upn_;                   
   sidPath = sidPath_;                
   type    = MemberInfo::UNKNOWN_SID;

   HRESULT hr = S_OK;
   do
   {
      if (IsUnresolvableSid(path, sidPath))
      {
         ASSERT(type == MemberInfo::UNKNOWN_SID);

         break;
      }
         
      DetermineType(adsClass, machine, groupTypeAttrVal);
   }
   while (0);

   return hr;
}


   
HRESULT
MemberInfo::Initialize(
   const String&                 objectName,
   const String&                 machine,
   const SmartInterface<IADs>&   object)
{
   LOG_FUNCTION(MemberInfo::Initialize);
   ASSERT(object);
   ASSERT(!machine.empty());
   ASSERT(!objectName.empty());

   name.erase();
   path.erase();
   sidPath.erase();
   type = MemberInfo::UNKNOWN_SID;
   upn.erase();

   HRESULT hr = S_OK;
   do
   {
      name = objectName;

      BSTR p = 0;
      hr = object->get_ADsPath(&p);
      BREAK_ON_FAILED_HRESULT(hr);
      path = p;
      ::SysFreeString(p);

      hr = ADSI::GetSidPath(object, sidPath);

      // check if the object refers to an unresolvable SID

      if (IsUnresolvableSid(path, sidPath))
      {
         ASSERT(type == MemberInfo::UNKNOWN_SID);

         break;
      }

      BSTR cls = 0;
      hr = object->get_Class(&cls);
      BREAK_ON_FAILED_HRESULT(hr);

      String c(cls);
      ::SysFreeString(cls);

      // determine the object type

      long type = 0;
      if (c.icompare(ADSI::CLASS_Group) == 0)
      {
         _variant_t variant;
         hr = object->Get(AutoBstr(ADSI::PROPERTY_GroupType), &variant);
         BREAK_ON_FAILED_HRESULT(hr);
         type = variant;
      }

      DetermineType(c, machine, type);
   }
   while (0);

   return hr;
}   



// return true if the specified path refers to an account that is local to
// the given machine, false if not.

bool
IsLocalPrincipal(const String& adsiPath, const String& machine)
{
   LOG_FUNCTION2(IsLocalPrincipal, adsiPath);

   ADSI::PathCracker c1(adsiPath);
   ADSI::PathCracker c2(c1.containerPath());

   String cont = c2.leaf();
   bool isLocal = (cont.icompare(machine) == 0);

   LOG(
      String::format(
         L"%1 local to %2",
         isLocal ? L"is" : L"is NOT",
         machine.c_str()));

   return isLocal;
}


   
void
MemberInfo::DetermineType(
   const String& className,
   const String& machine,
   long          groupTypeAttrVal)
{
   LOG_FUNCTION2(
      MemberInfo::DetermineType,
      String::format(
         L"className=%1, machine=%2, groupTypeAttrVal=%3!X!",
         className.c_str(),
         machine.c_str(),
         groupTypeAttrVal));
   ASSERT(!className.empty());

   if (className.icompare(ADSI::CLASS_User) == 0 ||

       // InetOrgPerson needs to be supported as if it was a user.
       // The WINNT provider always returns inetOrgPerson objects
       // as users but the LDAP provider returns them as inetOrgPerson.
       // NTRAID#NTBUG9-436314-2001/07/16-jeffjon

       className.icompare(ADSI::CLASS_InetOrgPerson) == 0)
   {
      // determine the name of the container.  If the name of the container
      // is the same as the machine name, then the user is a local account.
      // We can make this assertion because it is illegal to have a machine
      // with the same name as a domain on the net at the same time.
      // 349104

      bool isLocal = IsLocalPrincipal(path, machine);
      
      type = isLocal ? MemberInfo::USER : MemberInfo::DOMAIN_USER;
   }
   else if (className.icompare(ADSI::CLASS_Group) == 0)
   {
      // examine the group type attribute's value

      // mask off all but the last byte of the value, in case this group
      // was read from the DS, which sets other bits not of interest to
      // us.

      groupTypeAttrVal = groupTypeAttrVal & 0x0000000F;

      if (groupTypeAttrVal == ADS_GROUP_TYPE_LOCAL_GROUP)
      {
         // it's possible that the group is a domain local group, not a
         // machine local group.

         LOG(L"Member is a local group, but local to what?");

         bool isLocal = IsLocalPrincipal(path, machine);
      
         type = isLocal ? MemberInfo::GROUP : MemberInfo::DOMAIN_GROUP;
      }
      else
      {
         // of the n flavors of groups, I'm not expecting anything else but
         // the global variety.

         LOG(L"Member is a global group");
         ASSERT(
               (groupTypeAttrVal == ADS_GROUP_TYPE_GLOBAL_GROUP)
            || (groupTypeAttrVal == ADS_GROUP_TYPE_UNIVERSAL_GROUP) );

         type = MemberInfo::DOMAIN_GROUP;
      }
   }
   else
   {
      type = MemberInfo::UNKNOWN_SID;

      ASSERT(false);
   }
}



bool
MemberInfo::operator==(const MemberInfo& rhs) const
{
   if (this != &rhs)
   {
      // comparing paths is sufficient as it is illegal to have a user and
      // group of the same name.

      return path == rhs.path;
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\membershiplistview.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Group Membership/Object Picker handler class
// 
// 11-3-97 sburns



#ifndef MEMBERSHIPLISTVIEW_HPP_INCLUDED
#define MEMBERSHIPLISTVIEW_HPP_INCLUDED



#include "MemberInfo.hpp"



typedef
   std::list<MemberInfo, Burnslib::Heap::Allocator<MemberInfo> >
   MemberList;



// MembershipListView wraps a listview control, adding support for tracking
// the contents of the list, launching the object picker, etc.  Can be "wired"
// into a dialog or property page.

class MembershipListView
{
   public:

   enum Options
   {
      // show objects to which a local user may belong = local groups
      USER_MEMBERSHIP,

      // show objects which may belong to a local group = global groups,
      // global users, local users    
      GROUP_MEMBERSHIP
   };

   // Creates a new instance, "wiring" it to an existing listview control
   // child window.
   // 
   // listview - a list view child window.
   //       
   // machine - the name of the machine to focus the object picker on.
   //
   // opts - Options enum value.

   MembershipListView(
      HWND           listview,
      const String&  machine,
      Options        opts);

   ~MembershipListView();

   // Remove all items in the listview.

   void
   ClearContents();

   // Retrieve the current contents of the list view.
   //
   // results - MemberList instance where the contents of the listview are to
   // be placed.

   void
   GetContents(MemberList& results) const;

   // Launches the object picker, adding all picked object to the list
   // view.

   void
   OnAddButton();

   // Removes the currently selected item in the list view.

   void
   OnRemoveButton();

   // Sets the contents of the list view to that of the supplied list.
   //
   // newMembers - list of MemberInfo objects used to populate the list
   // view.

   void
   SetContents(const MemberList& newMembers);

   private:

   friend class ResultsCallback;
        
   void
   addItem(const MemberInfo& info);

   void
   AddPickerItems(DS_SELECTION_LIST& selections);

   void
   deleteItem(int target);

   bool
   itemPresent(const String& path);

   HWND     view;

   // CODEWORK: it would be more efficient to have a single Computer instance
   // built when the snapin changes focus, to which references are passed
   // around -- like to here

   Computer computer;
   Options  options;

   // not defined: no copying allowed

   MembershipListView(const MembershipListView&);
   const MembershipListView& operator=(const MembershipListView&);
};

   

#endif   // MEMBERSHIPLISTVIEW_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\membervisitor.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// MemberVisitor class
// 
// 11-14-97 sburns



#include "headers.hxx"
#include "MembershipListView.hpp"
#include "MemberVisitor.hpp"
#include "resource.h"
#include "dlgcomm.hpp"



MemberVisitor::MemberVisitor(
   MemberList&    members_,
   HWND           parent_,
   const String&  containerName,
   const String&  machineName)
   :
   members(members_),
   parent(parent_),
   container_name(containerName),
   machine(machineName)
{
   LOG_CTOR(MemberVisitor);
   ASSERT(Win::IsWindow(parent));
   ASSERT(!container_name.empty());
}



MemberVisitor::~MemberVisitor()
{
   LOG_DTOR(MemberVisitor);
}



void
MemberVisitor::Visit(const SmartInterface<IADs>& object)
{
   LOG_FUNCTION(MemberVistor::Visit);

   HRESULT hr = S_OK;
   BSTR name = 0;
   do
   {
      MemberInfo info;

      hr = object->get_Name(&name);
      BREAK_ON_FAILED_HRESULT(hr);
      info.name = name;

      hr = info.Initialize(name, machine, object);
      BREAK_ON_FAILED_HRESULT(hr);

      members.push_back(info);
   }
   while (0);

   if (FAILED(hr))
   {
      int res_id =
            name
         ?  IDS_ERROR_READING_MEMBER_PROPERTIES1
         :  IDS_ERROR_READING_MEMBER_PROPERTIES2;

      popup.Error(
         parent,
         hr,
         String::format(res_id, container_name.c_str(), name));
   }

   ::SysFreeString(name);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\membervisitor.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// MemberVisitor class
// 
// 11-14-97 sburns



#ifndef MEMBERVISITOR_HPP_INCLUDED
#define MEMBERVISITOR_HPP_INCLUDED



#include "adsi.hpp"



// Binds to a MemberList, and populates it with it's visit method.

class MemberVisitor : public ADSI::ObjectVisitor
{
   public:

   // Creates a new instance.
   //
   // members - the list to receive the elements in the enumeration.
   //
   // parent - the parent window to be used for error reporting.
   //
   // containerName - the name of the container whose members are being
   // visited (a user or group).  Used for error reporting.
   //
   // machineName - the name of the machine that owns the container.

   MemberVisitor(
      MemberList&    members,
      HWND           parent,
      const String&  containerName,
      const String&  machineName);

   virtual
   ~MemberVisitor();

   virtual
   void
   Visit(const SmartInterface<IADs>& object);

   private:

   // not implemented: no copying allowed
   MemberVisitor(const MemberVisitor&);
   const MemberVisitor& operator=(const MemberVisitor&);

   MemberList& members;
   HWND        parent;
   String      container_name;
   String      machine;
};



#endif   // MEMBERVISITOR_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\memberinfo.hpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
// 
// MemberInfo class
// 
// 24 Jan 2000 sburns



#ifndef MEMBERINFO_HPP_INCLUDED
#define MEMBERINFO_HPP_INCLUDED

                   

// An instance of MemberInfo is associated with each item in the listview via
// the item's lparam.  As items are added and removed, MemberInfo objects are
// created and destroyed.
// 
// MemberInfo objects are also used in the public interface of
// MembershipListView to communicate the contents of the listview control.

class MemberInfo
{
   public:

   enum Type
   {
      // order is significant: it's also the image index

      USER         = 0,
      GROUP        = 1,
      DOMAIN_USER  = 2,
      DOMAIN_GROUP = 3,    // local, global, universal
      UNKNOWN_SID  = 4 
   };

   Type   type;
   String path;
   String name;
   String sidPath;
   String upn;

   // default ctor, copy ctor, dtor, op= all used



   // Set the members based on information gleaned from the parameters
   //
   // objectName - Display name of the object.  Copied into the name member.
   // 
   // machine - netbios machine from whence the object was read.
   // 
   // object - IADs pointer to the object.
   
   HRESULT
   Initialize(
      const String&                 objectName,
      const String&                 machine,
      const SmartInterface<IADs>&   object);



   // Set the members based on information gleaned from the parameters
   //
   // objectName - Display name of the object.  Copied into the name member.
   //
   // adsPath - ADSI WinNT provider path to the object.
   //
   // upn - Universal Principal Name property of the object.  May be empty.
   //
   // sidPath - ADSI SID-style WinNT provider path to the object.
   //
   // adsClass - ADSI WinNT object class string for the object.
   //
   // groupTypeAttrVal - ADSI group type flag.
   // 
   // machine - netbios machine from whence the object was read.

   HRESULT
   Initialize(
      const String&           objectName,
      const String&           adsPath,
      const String&           upn,
      const String&           sidPath,
      const String&           adsClass,
      long                    groupTypeAttrVal,
      const String&           machine);



   // returns true if the instances are logically equal (have the same name
   // path, etc.) false otherwise

   bool
   operator==(const MemberInfo&) const;



   private:

   void
   DetermineType(
      const String& className,
      const String& machine,
      long          groupTypeAttrVal);
};



#endif   // MEMBERINFO_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\mmcprop.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// MMCProperty Page base class 
// 
// 12-4-97 sburns



#include "headers.hxx"
#include "mmcprop.hpp"
#include "scopnode.hpp"



MMCPropertyPage::NotificationState::NotificationState(
   LONG_PTR                         MMCNotifyHandle,
   const SmartInterface<ScopeNode>& scopeNode_)
   :
   mmcNotifyHandle(MMCNotifyHandle),
   scopeNode(scopeNode_),
   sendNotify(false)
{
   LOG_CTOR(MMCPropertyPage::NotificationState);
   ASSERT(scopeNode);

   // MMCNotifyHandle may be 0
}

   

MMCPropertyPage::NotificationState::~NotificationState()
{
   LOG_DTOR(MMCPropertyPage::NotificationState);

   if (mmcNotifyHandle)
   {
      if (sendNotify)
      {
         // this causes MMCN_PROPERTY_CHANGE to be sent to the IComponent that
         // created the prop sheet.  Since that component may have changed
         // it's selected scope node while the sheet was up, we pass along a
         // pointer to the node that was selected when the sheet was created.

         // AddRef the scopeNode in case we hold the last reference to the
         // scopeNode. If that happens, then there is a race condition between
         // us Releasing the last reference (a side effect of the dtor for
         // scopeNode), and the use of the node in the MMCN_PROPERTY_CHANGE
         // handler in Component, which is in a different thread.  We will
         // have the last reference if the user opens a prop sheet, collapses
         // the scope tree (by retargeting Computer Management, say), then
         // changes the prop sheet.
         //
         // The MMCN_PROPERTY_CHANGE handler will Release this reference.
         // 
         // NTRAID#NTBUG9-431831-2001/07/06-sburns
         
         scopeNode->AddRef();
         
         MMCPropertyChangeNotify(
            mmcNotifyHandle,
            reinterpret_cast<MMC_COOKIE>((ScopeNode*) scopeNode));
      }
      MMCFreeNotifyHandle(mmcNotifyHandle);
   }
}



bool
MMCPropertyPage::NotificationState::ResultsRebuilt() const 
{
   LOG_FUNCTION(MMCPropertyPage::NotificationState::ResultsRebuilt);

   return resultsRebuilt;
}



void
MMCPropertyPage::NotificationState::SetResultsRebuilt()
{
   LOG_FUNCTION(MMCPropertyPage::NotificationState::SetResultsRebuilt);

   // should only be called once
   ASSERT(!resultsRebuilt);
   resultsRebuilt = true;
}



void
MMCPropertyPage::NotificationState::SetSendNotify()
{
   LOG_FUNCTION(MMCPropertyPage::NotificationState::SetSendNotify);

   sendNotify = true;
}



MMCPropertyPage::MMCPropertyPage(
   int                  dialogResID,
   const DWORD          helpMap[],
   NotificationState*   state_)
   :
   PropertyPage(dialogResID, helpMap),
   state(state_),
   owns_state(false)
{
   LOG_CTOR(MMCPropertyPage);
   ASSERT(state);
}



MMCPropertyPage::~MMCPropertyPage()
{
   LOG_DTOR(MMCPropertyPage);

   if (owns_state)
   {
      delete state;
   }
}



void
MMCPropertyPage::SetStateOwner()
{
   LOG_FUNCTION(MMCPropertyPage::SetStateOwner);

   // shouldn't set more than once
   ASSERT(!owns_state);
   owns_state = true;
}



void
MMCPropertyPage::SetChangesApplied()
{
   LOG_FUNCTION(MMCPropertyPage::SetChangesApplied);

   state->SetSendNotify();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\mseldo.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// MultiSelectDataObject class
// 
// 11-14-97 sburns



#ifndef MSELDO_HPP_INCLUDED
#define MSELDO_HPP_INCLUDED



#include "resnode.hpp"



class MultiSelectDataObject : public IDataObject
{
   public:

   static const String CF_PTR;

   typedef
      std::list<ResultNode*, Burnslib::Heap::Allocator<ResultNode*> >
      DependentList;

   typedef DependentList::iterator iterator;

   MultiSelectDataObject();

   // IUnknown overrides

   virtual
   ULONG __stdcall
   AddRef();

   virtual
   ULONG __stdcall
   Release();

   virtual 
   HRESULT __stdcall
   QueryInterface(const IID& interfaceID, void** interfaceDesired);

   // IDataObject overrides

   virtual
   HRESULT __stdcall
   GetData(FORMATETC* formatetcIn, STGMEDIUM* medium);

   virtual
   HRESULT __stdcall
   GetDataHere(FORMATETC* formatetc, STGMEDIUM* medium);

   virtual
   HRESULT __stdcall
   QueryGetData(FORMATETC* pformatetc);

   virtual
   HRESULT __stdcall
   GetCanonicalFormatEtc(FORMATETC* formatectIn, FORMATETC* formatetcOut);

   virtual
   HRESULT __stdcall  
   SetData(FORMATETC* formatetc, STGMEDIUM* medium, BOOL release);

   virtual
   HRESULT __stdcall
   EnumFormatEtc(DWORD direction, IEnumFORMATETC** ppenumFormatEtc);

   virtual
   HRESULT __stdcall
   DAdvise(
      FORMATETC*     formatetc,
      DWORD          advf,
      IAdviseSink*   advSink,
      DWORD*         connection);

   virtual
   HRESULT __stdcall
   DUnadvise(DWORD connection);

   virtual
   HRESULT __stdcall
   EnumDAdvise(IEnumSTATDATA** ppenumAdvise);

   // MultiSelectDataObject methods

   void
   AddDependent(ResultNode* node);

   iterator
   begin() const;

   iterator
   end() const;

   private:

   // only we can delete ourselves
   
   virtual
   ~MultiSelectDataObject();

   // not implemented: no copying allowed.
   MultiSelectDataObject(const MultiSelectDataObject&);
   const MultiSelectDataObject& operator=(const MultiSelectDataObject&);

   DependentList        dependents;
   ComServerReference   dllref;
   long                 refcount;
};



#endif   // MSELDO_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\mseldo.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// MultiSelectDataObject class
// 
// 11-14-97 sburns



#include "headers.hxx"
#include "mseldo.hpp"



const String MultiSelectDataObject::CF_PTR(L"MultiSelectDataObject Pointer");



MultiSelectDataObject::MultiSelectDataObject()
   :
   refcount(1)    // implicit AddRef
{
   LOG_CTOR(MultiSelectDataObject);
}



MultiSelectDataObject::~MultiSelectDataObject()
{
   LOG_DTOR(MultiSelectDataObject);

   for (iterator i = begin(); i != end(); i++)
   {
      (*i)->Release();
   }
}



ULONG __stdcall
MultiSelectDataObject::AddRef()
{
   LOG_ADDREF(MultiSelectDataObject);

   return Win::InterlockedIncrement(refcount);
}



ULONG __stdcall
MultiSelectDataObject::Release()
{
   LOG_RELEASE(MultiSelectDataObject);

   if (Win::InterlockedDecrement(refcount) == 0)
   {
      delete this;
      return 0;
   }

   return refcount;
}



HRESULT __stdcall
MultiSelectDataObject::QueryInterface(
   const IID&  interfaceID,
   void**      interfaceDesired)
{
   LOG_FUNCTION(MultiSelectDataObject::QueryInterface);
   ASSERT(interfaceDesired);

   HRESULT hr = 0;

   if (!interfaceDesired)
   {
      hr = E_INVALIDARG;
      LOG_HRESULT(hr);
      return hr;
   }

   if (interfaceID == IID_IUnknown)
   {
      *interfaceDesired = static_cast<IUnknown*>(this);
   }
   else if (interfaceID == IID_IDataObject)
   {
      *interfaceDesired = static_cast<IDataObject*>(this);
   }
   else
   {
      *interfaceDesired = 0;
      hr = E_NOINTERFACE;
      LOG(
            L"interface not supported: "
         +  Win::StringFromGUID2(interfaceID));
      LOG_HRESULT(hr);
      return hr;
   }

   AddRef();
   return S_OK;
}



static const UINT CFID_OBJECT_TYPES_IN_MULTI_SELECT =
   Win::RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);

// private clipboard format for identifying our data objects
static const UINT CFID_PTR =
   Win::RegisterClipboardFormat(MultiSelectDataObject::CF_PTR);



HRESULT __stdcall
MultiSelectDataObject::GetData(FORMATETC* formatetc, STGMEDIUM* medium)
{
   LOG_FUNCTION(MultiSelectDataObject::GetData);

   const CLIPFORMAT cf = formatetc->cfFormat;

   if (cf == CFID_OBJECT_TYPES_IN_MULTI_SELECT)
   {
//      LOG(CCF_OBJECT_TYPES_IN_MULTI_SELECT);

      // collect all the node types of the dependents
      list<GUID> types;
      for (iterator i = begin(); i != end(); i++)
      {
         NodeType type = (*i)->GetNodeType();
         list<GUID>::iterator f = find(types.begin(), types.end(), type);
         if (f == types.end())
         {
            // not found.  So add it.
            types.push_back(type);
         }
      }

      // at this point, types is a set of all the node types of the
      // dependent nodes.

      medium->tymed = TYMED_HGLOBAL;
      DWORD size = sizeof(SMMCObjectTypes) + (types.size() - 1) * sizeof(GUID);
      medium->hGlobal = Win::GlobalAlloc(GPTR, size);     
      if (!medium->hGlobal)
      {
         return E_OUTOFMEMORY;
      }

      SMMCObjectTypes* data =
         reinterpret_cast<SMMCObjectTypes*>(medium->hGlobal);
      data->count = types.size();
      int k = 0;
      for (list<GUID>::iterator j = types.begin(); j != types.end(); j++, k++)
      {
         data->guid[k] = *j;
      }

      return S_OK;
   }

   return DV_E_CLIPFORMAT;
}



HRESULT __stdcall
MultiSelectDataObject::GetDataHere(FORMATETC* formatetc, STGMEDIUM* medium)
{
   LOG_FUNCTION(MultiSelectDataObject::GetDataHere);
   ASSERT(formatetc);
   ASSERT(medium);

   if (medium->tymed != TYMED_HGLOBAL)
   {
      return DV_E_TYMED;
   }

   // this is required as per win32 docs:
   medium->pUnkForRelease = 0;

   const CLIPFORMAT cf = formatetc->cfFormat;
   IStream *stream = 0;
   HRESULT hr = DV_E_CLIPFORMAT;

   do
   {
      hr = Win::CreateStreamOnHGlobal(medium->hGlobal, false, stream);
      BREAK_ON_FAILED_HRESULT(hr);

      if (cf == CFID_PTR)
      {
//         LOG(CF_PTR);
         MultiSelectDataObject* ptr = this;   
         hr = stream->Write(&ptr, sizeof(ptr), 0);
      }
      else
      {
         LOG(
            String::format(
               L"Unsupported clip format %1",
               Win::GetClipboardFormatName(cf).c_str()) );
      }

      if (stream)
      {
         stream->Release();
      }
   }
   while (0);

   return hr;
}



HRESULT __stdcall
MultiSelectDataObject::QueryGetData(FORMATETC* pformatetc)
{
   LOG_FUNCTION(MultiSelectDataObject::QueryGetData);
   return E_NOTIMPL;
}



HRESULT __stdcall
MultiSelectDataObject::GetCanonicalFormatEtc(
   FORMATETC* formatectIn,
   FORMATETC* formatetcOut)
{
   LOG_FUNCTION(MultiSelectDataObject::GetCannonicalFormatEtc);
   return E_NOTIMPL;
}



HRESULT __stdcall  
MultiSelectDataObject::SetData(
   FORMATETC*  formatetc,
   STGMEDIUM*  medium,
   BOOL        release)
{
   LOG_FUNCTION(MultiSelectDataObject::SetData);
   return E_NOTIMPL;
}



HRESULT __stdcall
MultiSelectDataObject::EnumFormatEtc(
   DWORD             direction,
   IEnumFORMATETC**  ppenumFormatEtc)
{
   LOG_FUNCTION(MultiSelectDataObject::EnumFormatEtc);
   return E_NOTIMPL;
}



HRESULT __stdcall
MultiSelectDataObject::DAdvise(
   FORMATETC*     formatetc,
   DWORD          advf,
   IAdviseSink*   advSink,
   DWORD*         connection)
{
   LOG_FUNCTION(MultiSelectDataObject::DAdvise);
   return E_NOTIMPL;
}



HRESULT __stdcall
MultiSelectDataObject::DUnadvise(DWORD connection)
{
   LOG_FUNCTION(MultiSelectDataObject::DUnadvise);
   return E_NOTIMPL;
}



HRESULT __stdcall
MultiSelectDataObject::EnumDAdvise(IEnumSTATDATA** ppenumAdvise)
{
   LOG_FUNCTION(MultiSelectDataObject::EnumDAdvise);
   return E_NOTIMPL;
}



void
MultiSelectDataObject::AddDependent(ResultNode* node)
{
   LOG_FUNCTION(MultiSelectDataObject::AddDependent);
   ASSERT(node);

   if (node)
   {
      // add the node if not already present
      iterator f = find(begin(), end(), node);
      if (f == end())
      {
         node->AddRef();
         dependents.push_back(node);
      }
   }
}



MultiSelectDataObject::iterator
MultiSelectDataObject::begin() const
{
   return dependents.begin();
}



MultiSelectDataObject::iterator
MultiSelectDataObject::end() const
{
   return dependents.end();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\newuser.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// CreateUserDialog class
// 
// 10-15-97 sburns



#include "headers.hxx"
#include "newuser.hpp"
#include "resource.h"
#include "lsm.h"
#include "adsi.hpp"
#include "dlgcomm.hpp"



static const DWORD HELP_MAP[] =
{
   IDC_USER_NAME,                idh_createuser_user_name,
   IDC_FULL_NAME,                idh_createuser_full_name,
   IDC_DESCRIPTION,              idh_createuser_description,
   IDC_PASSWORD,                 idh_createuser_password,
   IDC_CONFIRM,                  idh_createuser_confirm_password,
   IDC_MUST_CHANGE_PASSWORD,     idh_createuser_change_password,
   IDC_CANNOT_CHANGE_PASSWORD,   idh_createuser_user_cannot_change,
   IDC_NEVER_EXPIRES,            idh_createuser_password_never_expires,
   IDC_DISABLED,                 idh_createuser_account_disabled,
   IDC_CREATE,                   idh_createuser_create_button,
   IDCANCEL,                     idh_createuser_close_button,
   0, 0
};



CreateUserDialog::CreateUserDialog(const String& machine_)
   :
   Dialog(IDD_CREATE_USER, HELP_MAP),
   machine(machine_),
   refreshOnExit(false)
{
   LOG_CTOR(CreateUserDialog);
      
   ASSERT(!machine.empty());      
}
      


CreateUserDialog::~CreateUserDialog()
{
   LOG_DTOR(CreateUserDialog);
}



static
void
enable(HWND dialog)
{
   LOG_FUNCTION(enable);
   ASSERT(Win::IsWindow(dialog));

   bool enable_create_button =
      !Win::GetTrimmedDlgItemText(dialog, IDC_USER_NAME).empty();
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_CREATE),
      enable_create_button);

   DoUserButtonEnabling(
      dialog,
      IDC_MUST_CHANGE_PASSWORD,
      IDC_CANNOT_CHANGE_PASSWORD,
      IDC_NEVER_EXPIRES);
}


     
static
void
reset(HWND dialog)
{
   LOG_FUNCTION(reset);
   ASSERT(Win::IsWindow(dialog));
   
   String blank;

   Win::SetDlgItemText(dialog, IDC_USER_NAME, blank);
   Win::SetDlgItemText(dialog, IDC_FULL_NAME, blank);
   Win::SetDlgItemText(dialog, IDC_DESCRIPTION, blank);
   Win::SetDlgItemText(dialog, IDC_PASSWORD, blank);
   Win::SetDlgItemText(dialog, IDC_CONFIRM, blank);
   Win::CheckDlgButton(dialog, IDC_MUST_CHANGE_PASSWORD, BST_CHECKED);
   Win::CheckDlgButton(dialog, IDC_CANNOT_CHANGE_PASSWORD, BST_UNCHECKED);
   Win::CheckDlgButton(dialog, IDC_NEVER_EXPIRES, BST_UNCHECKED);
   Win::CheckDlgButton(dialog, IDC_DISABLED, BST_UNCHECKED);

   Win::SetFocus(Win::GetDlgItem(dialog, IDC_USER_NAME));

   enable(dialog);
}



void
CreateUserDialog::OnInit()
{
   LOG_FUNCTION(CreateUserDialog::OnInit());

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_USER_NAME), LM20_UNLEN);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_FULL_NAME), MAXCOMMENTSZ);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_DESCRIPTION), MAXCOMMENTSZ);    // 420889
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_PASSWORD), PWLEN);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_CONFIRM), PWLEN);

   reset(hwnd);
}



bool
CreateUserDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//    LOG_FUNCTION(CreateUserDialog::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_MUST_CHANGE_PASSWORD:
      case IDC_CANNOT_CHANGE_PASSWORD:
      case IDC_NEVER_EXPIRES:
      {
         if (code == BN_CLICKED)
         {
            enable(hwnd);
         }
         break;
      }
      case IDC_USER_NAME:
      {
         if (code == EN_CHANGE)
         {
            enable(hwnd);

            // In case the close button took the default style when the create
            // button was disabled. (e.g. tab to close button while create is
            // disabled, then type in the name field, which enables the
            // button, but does not restore the default style unless we do
            // it ourselves)
            Win::Button_SetStyle(
               Win::GetDlgItem(hwnd, IDC_CREATE),
               BS_DEFPUSHBUTTON,
               true);
         }
         break;
      }
      case IDC_CREATE:
      {
         if (code == BN_CLICKED)
         {
            if (CreateUser())
            {
               refreshOnExit = true;               
               reset(hwnd);
            }
            else
            {
               Win::SetFocus(Win::GetDlgItem(hwnd, IDC_USER_NAME));
            }
         }
         break;
      }
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            HRESULT unused = Win::EndDialog(hwnd, refreshOnExit);

            ASSERT(SUCCEEDED(unused));
         }
         break;
      }
   }

   return true;
}



HRESULT
GetLocalUsersGroupName(const String& machine, String& result)
{
   LOG_FUNCTION2(GetLocalUsersGroupName, machine);
   ASSERT(!machine.empty());

   result.erase();

   HRESULT hr = S_OK;

   do
   {
      // build the SID for the well-known Users local group.

      PSID sid = 0;
      SID_IDENTIFIER_AUTHORITY authority = SECURITY_NT_AUTHORITY;

      hr =
         Win::AllocateAndInitializeSid(
            authority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_USERS,
            0,
            0,
            0,
            0,
            0,
            0,
            sid);
      BREAK_ON_FAILED_HRESULT(hr);

      String domain;
      hr = Win::LookupAccountSid(machine, sid, result, domain);

      Win::FreeSid(sid);
   }
   while (0);

   return hr;
}




// Verifies that the candidate new user account name is syntactically valid.
// If not, displays an error message to the user, and returns false.
// Otherwise, returns true.
// 
// dialog - in, parent window for the error message dialog, also the window
// containing the edit box for the user name, which is identified by
// editResId.
// 
// name - in, candidate new user account name.
// 
// machineName - in, internal computer name of the machine on which the
// account will be created.
// 
// editResId - in, the resource identifier of the edit box of the parent
// window (given by the dialog parameter) that contains the new user name.
// This control is given focus on error.

bool
ValidateNewUserName(
   HWND           dialog,
   const String&  name,
   const String&  machineName,
   int            editResId)
{
   LOG_FUNCTION(ValidateNewUserName);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(!machineName.empty());
   ASSERT(editResId > 0);

   if (!IsValidSAMName(name))
   {
      popup.Gripe(
         dialog,
         editResId,
         String::format(IDS_BAD_SAM_NAME, name.c_str()));
      return false;
   }

   // Disallow user account names with the same name as the netbios computer
   // name. This causes some apps to get confused the the <03> and <20>
   // registrations.
   // NTRAID#NTBUG9-324794-2001/02/26-sburns

   if (name.icompare(machineName) == 0)
   {
      popup.Gripe(
         dialog,
         editResId,
         String::format(
            IDS_USERNAME_CANT_BE_COMPUTER_NAME,
            machineName.c_str()));
      return false;
   }

   return true;
}



// returns true on successful creation of the user, false otherwise

bool
CreateUserDialog::CreateUser()
{
   LOG_FUNCTION(CreateUserDialog::CreateUser);

   Win::CursorSetting cursor(IDC_WAIT);

   HRESULT hr = S_OK;

   String name = Win::GetTrimmedDlgItemText(hwnd, IDC_USER_NAME);

   // shouldn't be able to poke the Create button if this is empty
   ASSERT(!name.empty());

   if (
         !ValidateNewUserName(hwnd, name, machine, IDC_USER_NAME)
      || !IsValidPassword(hwnd, IDC_PASSWORD, IDC_CONFIRM))
   {
      return false;
   }

   SmartInterface<IADsUser> user(0);
   do
   {
      // get a pointer to the machine container
      
      String container_path = ADSI::ComposeMachineContainerPath(machine);
      SmartInterface<IADsContainer> container(0);
      hr = ADSI::GetContainer(container_path, container);
      BREAK_ON_FAILED_HRESULT(hr);

      // create a user object in that container
      
      hr = ADSI::CreateUser(container, name, user);
      BREAK_ON_FAILED_HRESULT(hr);

      // must set full name before setting password in order for all
      // "bad password" checks to be made (some of which prevent passwords
      // that contain part of the the full name)
      // NTRAID#NTBUG9-221152-2000/11/14-sburns
      
      String fullName = Win::GetTrimmedDlgItemText(hwnd, IDC_FULL_NAME);
      if (!fullName.empty())
      {
         hr = user->put_FullName(AutoBstr(fullName));
         BREAK_ON_FAILED_HRESULT(hr);
      }
      
      // Don't trim the password field.
      // NTRAID#NTBUG9-434037-2001/07/11-sburns

      String pass = Win::GetDlgItemText(hwnd, IDC_PASSWORD);
      if (!pass.empty())
      {
         hr = user->SetPassword(AutoBstr(pass));
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // commit the create.  The account will be created as disabled until
      // it meets all policy restrictions
      
      hr = user->SetInfo();
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      Win::SetDlgItemText(hwnd, IDC_PASSWORD, String());
      Win::SetDlgItemText(hwnd, IDC_CONFIRM, String());

      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_CREATING_USER,
            name.c_str(),
            machine.c_str()));
      return false;      
   }

   // save the user's properties.
   
   do
   {
      String desc = Win::GetTrimmedDlgItemText(hwnd, IDC_DESCRIPTION);
      bool must_change = Win::IsDlgButtonChecked(hwnd, IDC_MUST_CHANGE_PASSWORD);
      bool disable = Win::IsDlgButtonChecked(hwnd, IDC_DISABLED);
      bool cant_change = Win::IsDlgButtonChecked(hwnd, IDC_CANNOT_CHANGE_PASSWORD);
      bool never_expires = Win::IsDlgButtonChecked(hwnd, IDC_NEVER_EXPIRES);

      hr = 
         SaveUserProperties(
            user,
            0,    // already saved full name
            desc.empty() ? 0 : &desc,
            &disable,
            &must_change,
            &cant_change,
            &never_expires,
            0); // locked is never set here
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_SETTING_USER_PROPERTIES,
            name.c_str(),
            machine.c_str()));
      return false;
   }

   // add the new user to the Users built-in group
   String usersGroupName;
   do
   {
      BSTR path = 0;
      hr = user->get_ADsPath(&path);
      BREAK_ON_FAILED_HRESULT(hr);

      String userPath = path;
      ::SysFreeString(path);
      
      // The name of the local built-in users group may have been changed
      // or be translated to a different locale that of the machine running
      // the snapin.  We need to determine the name of that group, then
      // use it to form the WinNT path for it.
         
      hr = GetLocalUsersGroupName(machine, usersGroupName);
      BREAK_ON_FAILED_HRESULT(hr);

      // use the user's path as the basis of the users group path, as this
      // will contain the domain and machine name as appropriate, thus helping
      // poor ADSI out in locating the object (resulting in a faster bind to
      // the group.

      ADSI::PathCracker cracker(userPath);

      String usersGroupPath =
            cracker.containerPath()
         +  ADSI::PATH_SEP
         +  usersGroupName
         +  L","
         +  ADSI::CLASS_Group;

      // Get the sid-style path of the user.  We'll use that form of the
      // path to work around 333491.

      SmartInterface<IADs> iads(0);
      hr = iads.AcquireViaQueryInterface(user);
      BREAK_ON_FAILED_HRESULT(hr);

      String sidPath;
      hr = ADSI::GetSidPath(iads, sidPath);
      BREAK_ON_FAILED_HRESULT(hr);

      SmartInterface<IADsGroup> group(0);

      hr = ADSI::GetGroup(usersGroupPath, group);
      if (SUCCEEDED(hr))
      {
         hr = group->Add(AutoBstr(sidPath));
      }
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_ASSIGNING_NEW_USER_TO_USERS_GROUP,
            name.c_str(),
            usersGroupName.c_str()));

      // return true to cause the create to be considered successful.
      return true;      
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\mmcprop.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// MMC-Aware Property Page base class
// 
// 12-4-97 sburns



#ifndef MMCPROP_HPP_INCLUDED
#define MMCPROP_HPP_INCLUDED



class ScopeNode;



// MMCPropertyPage extends PropertyPage, providing facilities for dealing with
// MMCNotifyHandles via a nested class NotificationState.

class MMCPropertyPage : public PropertyPage
{
   public:

   // Wraps up an MMCNotifyHandle, and manages triggering change notifications
   // to the console.  Each MMCPropertyPage in a sheet has a reference to the
   // same NotificationState object, but only one (usually the first) page is
   // designated as the owner of that state object.  When the owner page is
   // destroyed, it destroys the state object, upon which any change
   // notification is sent to the console.

   class NotificationState
   {
      friend class Component;
      friend class MMCPropertyPage;

      public:

      // MMCNotifyHandle - the MMC notification handle supplied to
      // IComponent::CreatePropertyPages.
      //
      // scopeNode - the selected ScopeNode when the prop sheet was built.
      // When change notification is sent to the IComponent that created the
      // sheet, this pointer is send as a parameter.

      NotificationState(
         LONG_PTR                         MMCNotifyHandle,
         const SmartInterface<ScopeNode>& scopeNode);

      private:

      // only MMCPropertyPage should delete us.
      ~NotificationState();

      // called by Component

      bool
      ResultsRebuilt() const;

      // called by Component

      void
      SetResultsRebuilt();

      // only ProperyPages should call this.

      void
      SetSendNotify();

      // not implemented: no copying allowed
      NotificationState(const NotificationState&);
      const NotificationState& operator=(const NotificationState&);

      LONG_PTR                  mmcNotifyHandle;
      bool                      sendNotify;      
      bool                      resultsRebuilt;  
      SmartInterface<ScopeNode> scopeNode;       
   };
            
   // Indicates that this page owns the notification state, and will destroy
   // that state when the page is destroyed.  Only one page in a prop sheet
   // should do this, or MMC will croak.  (Wonderful, huh?)

   void
   SetStateOwner();

   protected :

   // Derived classes should call this function when changes to the object
   // they edit have been made, and the console should be informed of the
   // change.  A good place to do this is in the OnApply function.

   void
   SetChangesApplied();

   // Constructs a new instance.  Declared protected so that this class
   // only functions as base class
   // 
   // dialogResID - see base class ctor.
   // 
   // helpMap - see base class ctor.
   //
   // state - notification state object that is shared among pages in a
   // sheet.  Only one page should be designated as the owner of the
   // notification state, which ownership is signalled by calling
   // SetStateOwner.

   MMCPropertyPage(
      int                  dialogResID,
      const DWORD          helpMap[],
      NotificationState*   state);

   virtual ~MMCPropertyPage();

   private:

   // not implemented: no copying allowed
   MMCPropertyPage(const MMCPropertyPage&);
   const MMCPropertyPage& operator=(const MMCPropertyPage&);

   NotificationState*   state;
   bool                 owns_state;
};



#endif   // MMCPROP_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\node.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Node class
// 
// 9-2-97 sburns



#include "headers.hxx"
#include "node.hpp"
#include "uuids.hpp"
#include <localsec.h>



#define LOG_NODE_TYPE                                                  \
   if (IsEqualGUID(type, NODETYPE_RootFolder))                           \
   {                                                                     \
      LOGT(Log::OUTPUT_LOGS, L"RootFolder");                         \
   }                                                                     \
   else if (IsEqualGUID(type, NODETYPE_UsersFolder))                     \
   {                                                                     \
      LOGT(Log::OUTPUT_LOGS, L"UsersFolder");                        \
   }                                                                     \
   else if (IsEqualGUID(type, NODETYPE_GroupsFolder))                    \
   {                                                                     \
      LOGT(Log::OUTPUT_LOGS, L"GroupsFolder");                       \
   }                                                                     \
   else if (IsEqualGUID(type, NODETYPE_User))                            \
   {                                                                     \
      LOGT(Log::OUTPUT_LOGS, L"User");                               \
   }                                                                     \
   else if (IsEqualGUID(type, NODETYPE_Group))                           \
   {                                                                     \
      LOGT(Log::OUTPUT_LOGS, L"Group");                              \
   }                                                                     \
   else                                                                  \
   {                                                                     \
      ASSERT(false);                                                     \
      LOGT(Log::OUTPUT_LOGS, L"unknown GUID!");                      \
   }                                                                     \



const String Node::CF_NODEPTR(L"Local User Manager Node Pointer");



Node::Node(
   const SmartInterface<ComponentData>&   owner_,
   const NodeType&                        nodeType)
   :
   owner(owner_),
   type(nodeType),
   refcount(1)          // implicit AddRef
{
   LOG_CTOR(Node);
}



Node::~Node()
{
   LOG_DTOR2(Node, String::format(L"0x%1!08X!", (MMC_COOKIE)this));
   ASSERT(refcount == 0);
}

      

ULONG __stdcall
Node::AddRef()
{
   LOG_ADDREF(Node);

#ifdef LOGGING_BUILD
   if (IsEqualGUID(type, NODETYPE_User))
   {
      LOG_NODE_TYPE;
   }
#endif

   return Win::InterlockedIncrement(refcount);
}



ULONG __stdcall
Node::Release()
{
   LOG_RELEASE(Node);

#ifdef LOGGING_BUILD
   if (IsEqualGUID(type, NODETYPE_User))
   {
      LOG_NODE_TYPE;
   }
#endif

   if (Win::InterlockedDecrement(refcount) == 0)
   {
      delete this;
      return 0;
   }

   return refcount;
}



HRESULT __stdcall
Node::QueryInterface(const IID& interfaceID, void** interfaceDesired)
{
//   LOG_FUNCTION(Node::QueryInterface);
   ASSERT(interfaceDesired);

   HRESULT hr = 0;

   if (!interfaceDesired)
   {
      hr = E_INVALIDARG;
      LOG_HRESULT(hr);
      return hr;
   }

   if (interfaceID == IID_IUnknown)
   {
      *interfaceDesired = static_cast<IUnknown*>(this);
   }
   else if (interfaceID == IID_IDataObject)
   {
//      LOG(L"Node: supplying IDataObject");
      *interfaceDesired = static_cast<IDataObject*>(this);
   }
   else
   {
      *interfaceDesired = 0;
      hr = E_NOINTERFACE;
      // LOG(
      //       L"interface not supported: "
      //    +  Win::StringFromGUID2(interfaceID));
      // LOG_HRESULT(hr);
      return hr;
   }

   AddRef();
   return S_OK;
}



HRESULT __stdcall
Node::GetData(FORMATETC* /* formatetcIn */ , STGMEDIUM* /* medium */ )
{
//   LOG_FUNCTION(Node::GetData);

   return E_NOTIMPL;
}



// determine the magic numbers associated with the clipboard formats we
// support

// these need to be at file scope so that it is executed only once (since they
// involve a function call, at function scope they would be called over and over
// again).

static const UINT CFID_NODETYPE =
   Win::RegisterClipboardFormat(CCF_NODETYPE);
static const UINT CFID_SZNODETYPE =
   Win::RegisterClipboardFormat(CCF_SZNODETYPE);
static const UINT CFID_DISPLAY_NAME =
   Win::RegisterClipboardFormat(CCF_DISPLAY_NAME);
static const UINT CFID_SNAPIN_CLASSID =
   Win::RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
static const UINT CFID_SNAPIN_PRELOADS =
   Win::RegisterClipboardFormat(CCF_SNAPIN_PRELOADS);

// private clipboard format for identifying our data objects
static const UINT CFID_LOCALSEC_NODEPTR =
   Win::RegisterClipboardFormat(Node::CF_NODEPTR);
static const UINT CFID_LOCALSEC_MACHINE_NAME =
   Win::RegisterClipboardFormat(CCF_LOCAL_USER_MANAGER_MACHINE_NAME);

// this appears to be the only IDataObject interface we need implement for MMC

HRESULT __stdcall
Node::GetDataHere(FORMATETC* formatetc, STGMEDIUM* medium)
{
//   LOG_FUNCTION(Node::GetDataHere);
   ASSERT(formatetc);
   ASSERT(medium);

   if (medium->tymed != TYMED_HGLOBAL)
   {
      return DV_E_TYMED;
   }

   // this is required as per win32 docs:
   medium->pUnkForRelease = 0;

   const CLIPFORMAT cf = formatetc->cfFormat;
   IStream *stream = 0;
   HRESULT hr = DV_E_CLIPFORMAT;

   do
   {
      // before we do anything, verify that we support the requested
      // clipboard format

      if (
            cf != CFID_NODETYPE
         && cf != CFID_SZNODETYPE
         && cf != CFID_DISPLAY_NAME
         && cf != CFID_SNAPIN_CLASSID
         && cf != CFID_SNAPIN_PRELOADS
         && cf != CFID_LOCALSEC_NODEPTR
         && cf != CFID_LOCALSEC_MACHINE_NAME)
      {
         LOG(
            String::format(
               L"Unsupported clip format %1",
               Win::GetClipboardFormatName(cf).c_str()) );
         hr = DV_E_CLIPFORMAT;
         break;
      }
      
      hr = Win::CreateStreamOnHGlobal(medium->hGlobal, false, stream);
      BREAK_ON_FAILED_HRESULT(hr);

      if (cf == CFID_NODETYPE)
      {
//         LOG(CCF_NODETYPE);

         hr = stream->Write(&type, sizeof(type), 0);
      }
      else if (cf == CFID_SZNODETYPE)
      {
//         LOG(CCF_SZNODETYPE);

         String s =  Win::StringFromGUID2(type);

         size_t bytes = (s.length() + 1) * sizeof(wchar_t);
         hr = stream->Write(s.c_str(), static_cast<ULONG>(bytes), 0);
      }
      else if (cf == CFID_DISPLAY_NAME)
      {
//         LOG(CCF_DISPLAY_NAME);

         String name = GetDisplayName();
         size_t bytes = (name.length() + 1) * sizeof(wchar_t);
         hr = stream->Write(name.c_str(), static_cast<ULONG>(bytes), 0);
      }
      else if (cf == CFID_SNAPIN_CLASSID)
      {
//         LOG(CCF_SNAPIN_CLASSID);
         hr = stream->Write(
            &CLSID_ComponentData,
            sizeof(CLSID_ComponentData),
            0);
      }
      else if (cf == CFID_SNAPIN_PRELOADS)
      {
         LOG(CCF_SNAPIN_CLASSID);

         // by implementing this clipboard format, we inform the console
         // that it should write a flag into the save console file so that
         // when loaded, the console will know to send MMCN_PRELOAD to
         // our IComponentData::Notify.

         // we use the preload function to update the name of the root
         // node when overrriden on the command-line load of a saved console.

         BOOL preload = GetOwner()->CanOverrideComputer() ? TRUE : FALSE;
         hr = stream->Write(&preload, sizeof(preload), 0);
      }
      else if (cf == CFID_LOCALSEC_NODEPTR)
      {
//         LOG(CF_NODEPTR);
         Node* ptr = this;   
         hr = stream->Write(&ptr, sizeof(ptr), 0);
      }
      else if (cf == CFID_LOCALSEC_MACHINE_NAME)
      {
//         LOG(CCF_LOCAL_USER_MANAGER_MACHINE_NAME);

         String name = GetOwner()->GetDisplayComputerName();
         size_t bytes = (name.length() + 1) * sizeof(wchar_t);
         hr = stream->Write(name.c_str(), static_cast<ULONG>(bytes), 0);
      }
      else
      {
         // we repeat the unsupported clip format check again just in case
         // whoever maintains this code forgets to update the list at the
         // top of the do .. while loop
         
         LOG(
            String::format(
               L"Unsupported clip format %1",
               Win::GetClipboardFormatName(cf).c_str()) );
         hr = DV_E_FORMATETC;
      }

      if (stream)
      {
         stream->Release();
      }
   }
   while (0);

   return hr;
}



HRESULT __stdcall
Node::QueryGetData(FORMATETC* /* pformatetc */ )
{
   LOG_FUNCTION(Node::QueryGetData);
   return E_NOTIMPL;
}



HRESULT __stdcall
Node::GetCanonicalFormatEtc(
   FORMATETC* /* formatectIn  */ ,
   FORMATETC* /* formatetcOut */ )
{
   LOG_FUNCTION(Node::GetCannonicalFormatEtc);
   return E_NOTIMPL;
}



HRESULT __stdcall  
Node::SetData(
   FORMATETC* /* formatetc */ ,
   STGMEDIUM* /* medium    */ ,
   BOOL       /* release   */ )
{
   LOG_FUNCTION(Node::SetData);
   return E_NOTIMPL;
}



HRESULT __stdcall
Node::EnumFormatEtc(
   DWORD            /* direction       */ ,
   IEnumFORMATETC** /* ppenumFormatEtc */ )
{
   LOG_FUNCTION(Node::EnumFormatEtc);
   return E_NOTIMPL;
}



HRESULT __stdcall
Node::DAdvise(
   FORMATETC*   /* formatetc  */ ,
   DWORD        /* advf       */ ,
   IAdviseSink* /* advSink    */ ,
   DWORD*       /* connection */ )
{
   LOG_FUNCTION(Node::DAdvise);
   return E_NOTIMPL;
}



HRESULT __stdcall
Node::DUnadvise(DWORD /* connection */ )
{
   LOG_FUNCTION(Node::DUnadvise);
   return E_NOTIMPL;
}



HRESULT __stdcall
Node::EnumDAdvise(IEnumSTATDATA** /* ppenumAdvise */ )
{
   LOG_FUNCTION(Node::EnumDAdvise);
   return E_NOTIMPL;
}



HRESULT
Node::AddMenuItems(
   IContextMenuCallback& /* callback         */ ,
   long&                 /* insertionAllowed */ )
{
   // the defualt is to do nothing
   LOG_FUNCTION(Node::AddMenuItems);

   return S_OK;
}


   
HRESULT
Node::MenuCommand(
   IExtendContextMenu& /* extendContextMenu */ ,
   long                /* commandID         */ )
{
   LOG_FUNCTION(Node::MenuCommand);

   // this may get called for console menu items, like view selection.

   return S_OK;
}



bool
Node::shouldInsertMenuItem(
   long  insertionAllowed,
   long  insertionPointID)
{
   LOG_FUNCTION(Node::shouldInsertMenuItem);

   long mask = 0;

   switch (insertionPointID)
   {
      case CCM_INSERTIONPOINTID_PRIMARY_TOP:
      {
         mask = CCM_INSERTIONALLOWED_TOP;
         break; 
      }
      case CCM_INSERTIONPOINTID_PRIMARY_NEW:
      {
         mask = CCM_INSERTIONALLOWED_NEW;
         break;
      }
      case CCM_INSERTIONPOINTID_PRIMARY_TASK:
      {
         mask = CCM_INSERTIONALLOWED_TASK;
         break;
      }
      case CCM_INSERTIONPOINTID_PRIMARY_VIEW:
      {
         mask = CCM_INSERTIONALLOWED_VIEW;
         break;
      }
      default:
      {
         ASSERT(false);
         mask = 0;
         break;
      }
   }

   return (insertionAllowed & mask) ? true : false;
}



HRESULT
Node::UpdateVerbs(IConsoleVerb& /* consoleVerb */ )
{
   LOG_FUNCTION(Node::UpdateVerbs);

   // default is to do nothing.

   return S_OK;
}



SmartInterface<ComponentData>
Node::GetOwner() const
{
//   LOG_FUNCTION(Node::GetOwner);

   return owner;
}



NodeType
Node::GetNodeType() const
{
   LOG_FUNCTION(Node::GetNodeType);

   return type;
}



bool
Node::IsSameAs(const Node* other) const 
{
   LOG_FUNCTION(Node::IsSameAs);
   ASSERT(other);

   if (other)
   {
      if (GetDisplayName() == other->GetDisplayName())
      {
         // nodes have the same name, names are unique within a given type
         // (i.e. Users are unique, groups are unique)
         return true;
      }
   }

   return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\newuser.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// CreateUserDialog class
// 
// 10-15-97 sburns



#ifndef NEWUSER_HPP_INCLUDED
#define NEWUSER_HPP_INCLUDED



#include "dialog.hpp"



class CreateUserDialog : public Dialog
{
   public:

   // Constructs a new instance.
   //
   // machine - in, internal (netbios) computer name of the machine on which
   // users will be created.

   CreateUserDialog(const String& machine);

   virtual ~CreateUserDialog();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   bool
   CreateUser();

   String machine;
   bool   refreshOnExit;

   // not defined: no copying allowed

   CreateUserDialog(const CreateUserDialog&);
   const CreateUserDialog& operator=(const CreateUserDialog&);
};



#endif   // NEWUSER_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\node.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Node class
// 
// 9-2-97 sburns



#ifndef NODE_HPP_INCLUDED
#define NODE_HPP_INCLUDED



#include "compdata.hpp"



// Struct used by BuildContextMenu.  Should be nested in Node, but vc++ templates
// seem to have trouble with nested classes as parameters.

struct ContextMenuItem
{
   long insertionPointID;  // MMC insertion point identifier
   int  menuResID;         // menu text string resource ID
   int  statusResID;       // status bar string resource ID
};



// Node is the abstract base class of all objects which appear as a single
// item in the scope or result panes of MMC.  It implements IDataObject so
// that MMC cookies = node instance pointers, i.e. cookies, IDataObject ptrs,
// and Node ptrs are all freely and cheaply convertible.
// 
// Since requesting data objects is something MMC does an awful lot, this
// scheme may provide better speed and space performance that having a
// separate class implementing IDataObject which wraps node instances.
//
// With this scheme, there is no overhead for creating/deleting IDataObject
// instances, mapping from IDataObject instance to node instance is simply a
// pointer cast, and no reference relationship between IDataObject instances
// and node instances need be maintained (which makes the system conceptually
// simpler, too.)
// 
// Nodes are reference-counted.

class Node : public IDataObject
{
   public:

   // Clipboard format for obtaining a pointer to a Node instance from
   // a IDataObject.  (If the call to GetDataHere responds without failure
   // to this format, one need not read the pointer from the stream -- a
   // simple cast of the IDataObject will work.)
   static const String CF_NODEPTR;

   // IUnknown overrides

   virtual
   ULONG __stdcall
   AddRef();

   virtual
   ULONG __stdcall
   Release();

   virtual 
   HRESULT __stdcall
   QueryInterface(const IID& interfaceID, void** interfaceDesired);

   // IDataObject overrides

   virtual
   HRESULT __stdcall
   GetData(FORMATETC* formatetcIn, STGMEDIUM* medium);

   virtual
   HRESULT __stdcall
   GetDataHere(FORMATETC* formatetc, STGMEDIUM* medium);

   virtual
   HRESULT __stdcall
   QueryGetData(FORMATETC* pformatetc);

   virtual
   HRESULT __stdcall
   GetCanonicalFormatEtc(FORMATETC* formatectIn, FORMATETC* formatetcOut);

   virtual
   HRESULT __stdcall  
   SetData(FORMATETC* formatetc, STGMEDIUM* medium, BOOL release);

   virtual
   HRESULT __stdcall
   EnumFormatEtc(DWORD direction, IEnumFORMATETC** ppenumFormatEtc);

   virtual
   HRESULT __stdcall
   DAdvise(
      FORMATETC*     formatetc,
      DWORD          advf,
      IAdviseSink*   advSink,
      DWORD*         connection);

   virtual
   HRESULT __stdcall
   DUnadvise(DWORD connection);

   virtual
   HRESULT __stdcall
   EnumDAdvise(IEnumSTATDATA** ppenumAdvise);

   // Node methods

   // Called from IComponent::AddMenuItems, and has the same semantics.  If a
   // derived node class supports a custom context menus for that node, that
   // class should override this function to insert menu items.
   // 
   // The default implementation does nothing and returns S_OK.
   // 
   // callback - The MMC interface with which menu items are added.  This is
   // the same instance passed to IComponent::AddMenuItems.
   // 
   // insertionAllowed - The flag parameter passed to
   // IComponent::AddMenuItems.

   virtual
   HRESULT
   AddMenuItems(
      IContextMenuCallback&   callback,
      long&                   insertionAllowed);

   // Returns the friendly name of the node that is displayed with the node's
   // icon.  This is pure virtual as some nodes may wish to manufacture a name
   // on-the-fly.

   virtual
   String
   GetDisplayName() const = 0;

   // Returns the text to be displayed in a particular column of the result
   // pane list view when the node is displayed in the result pane.  Called
   // by IComponent::GetDisplayInfo
   // 
   // column - The number of the column for which text should be supplied.

   virtual
   String
   GetColumnText(int column) = 0;

   // Returns the NodeType with which the instance was created.

   NodeType
   GetNodeType() const;

   // Returns the image index of the icon image for this node.  This is the
   // index of the image that was registered with MMC by IComponent in
   // response to the MMCN_ADD_IMAGES notification.  This should always return
   // the same index for all invocations.

   virtual 
   int
   GetNormalImageIndex() = 0;

   // Compares this node to other, returns true if they can be considered the
   // same (not necessarily the same Node instance, mind you).  The default
   // implementation compares the result of GetDisplayName().
   // 
   // other - Node to compare this to.  0 is illegal, and always returns false.

   virtual
   bool
   IsSameAs(const Node* other) const;

   // Called by IExtendContextMenu::Command when a context menu command has been
   // selected.  Since the default AddMenuItems implementation adds no menu
   // items, the default implementation of this function simply returns S_OK;
   //
   // extendContextMenu - the IExtendContextMenu instance that invokes this
   // method.
   // 
   // commandID - The ID of the command that was registered with the menu item
   // by AddMenuItems.  The range of possible IDs is the union of all IDs
   // registered by AddMenuItems.

   virtual
   HRESULT
   MenuCommand(IExtendContextMenu& extendContextMenu, long commandID);

   // Called from IComponent::Notify in response to the MMCN_SELECT
   // notification. Derived classes should use the provided IConsoleVerb
   // instance to enable the verbs applicable to their node type.
   // 
   // consoleVerb - Instance of IConsoleVerb used to do verb enabling.

   virtual
   HRESULT
   UpdateVerbs(IConsoleVerb& consoleVerb);

   protected:
   
   // Creates an instance with a given NodeType (a GUID).  Declared protected
   // to that this class may only be used as a base class.
   //
   // owner - the ComponentData object which "owns" this node
   //
   // nodeType - the NodeType GUID corresponding to this instance.  This must
   // be one of the node types registered in the MMC keys registry when the
   // snapin is registered, as it is used to produce the CCF_NODETYPE and
   // CCF_SZNODETYPE formats for IDataObject::GetDataHere.

   Node(
      const SmartInterface<ComponentData>&   owner,
      const NodeType&                        nodeType);

   // don't call directly: allow Release() to delete instances.  (declared
   // protected so as to be accessible to derived class' dtors)

   virtual ~Node();

   // Helper for derived classes for use in building a context menu as part of
   // the implementation of AddMenuItems.
   // 
   // begin - Iterator positioned at the beginning of the collection of
   // ContextMenuItem instances.
   // 
   // end - Iterator positioned just beyond the end of the collection of
   // ContextMenuItem instances.
   // 
   // callback - The IContextMenuCallback passed to AddMenuItems.
   // 
   // insertionAllowed - The insertion flag passed to AddMenuItems.

   template <class InputIterator>
   HRESULT
   BuildContextMenu(
      InputIterator           begin,
      InputIterator           end,
      IContextMenuCallback&   callback,
      long                    insertionAllowed)
   {
      HRESULT hr = S_OK;
      for (
         ;
         begin != end;
         ++begin)
      {
         CONTEXTMENUITEM item;
         memset(&item, 0, sizeof(item));
         String text = String::load((*begin).statusResID);

         item.strStatusBarText =
            const_cast<wchar_t*>(text.c_str());

         if (shouldInsertMenuItem(insertionAllowed, (*begin).insertionPointID))
         {
            String name = String::load((*begin).menuResID);
                     
            // Use the string res ID as the command ID.  Ensure that our command ID
            // is valid.
            ASSERT(!(CCM_COMMANDID_MASK_RESERVED & (*begin).menuResID));
            item.lCommandID = (*begin).menuResID;

            item.strName = const_cast<wchar_t*>(name.c_str());
            item.lInsertionPointID = (*begin).insertionPointID;
            hr = callback.AddItem(&item);
            BREAK_ON_FAILED_HRESULT(hr);
         }
      }

      return hr;
   }

   // Returns the ComponentData ptr with which the instance was constructed.

   SmartInterface<ComponentData>
   GetOwner() const;

   private:

   // not implemented: no copying allowed
   Node(const Node&);
   const Node& operator=(const Node&);

   static
   bool
   shouldInsertMenuItem(
      long  insertionAllowed,
      long  insertionPointID);

   SmartInterface<ComponentData> owner;
   NodeType                      type;
   ComServerReference            dllref;
   long                          refcount;
};



#endif   // NODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\nodepointerextractor.cpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
//
// clipboard Extractor for Node pointers
//
// 8-12-97 sburns



#include "headers.hxx"
#include "node.hpp"
#include "NodePointerExtractor.hpp"



NodePointerExtractor::NodePointerExtractor()
   :
   Extractor(
      Win::RegisterClipboardFormat(Node::CF_NODEPTR),
      sizeof(Node*))
{
}



Node*
NodePointerExtractor::Extract(IDataObject& dataObject)
{
   Node* result = 0;
   HGLOBAL mem = GetData(dataObject);
   if (mem)
   {
      result = *(reinterpret_cast<Node**>(mem));

      // This assertion may fail if we or any other snapin puts a null pointer
      // in the HGLOBAL, or more likely, returns S_OK from
      // IDataObject::GetDataHere without actually writing anything into the
      // HGLOBAL.  See NTRAID#NTBUG9-303984-2001/02/05-sburns for an example.
      // Either way, it's a bug, so we leave the assertion in.
      
      ASSERT(result);
   }

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\nodepointerextractor.hpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
//
// clipboard Extractor for Node pointers
//
// 8-12-97 sburns



#ifndef NODEPOINTEREXTRACTOR_HPP_INCLUDED
#define NODEPOINTEREXTRACTOR_HPP_INCLUDED



class NodePointerExtractor : public Extractor
{
   public:



   NodePointerExtractor();



   Node*
   Extract(IDataObject& dataObject);



   // Note: this can fail (return 0) if the dataObject is not one of our own (if
   // it is that of the snapin we're extending, for instance.)

   template <class C>
   C
   GetNode(IDataObject& dataObject)
   {
      Node* node = Extract(dataObject);
      C n = dynamic_cast<C>(node);
      ASSERT(n);

      return n;
   }



   // We do not specialize the above template method for C = class Node*.
   // While doing do we could avoid a dynamic_cast, but it turns out that the 
   // dynamic_cast is a nice way to double check that the clipboard data we
   // extract isn't some bogus data returned by another snapin's buggy
   // implementation of IDataObject::GetDataHere.  (If you think I'm being
   // paranoid, check out NTRAID#NTBUG9-303984-2001/02/02-sburns).
   // 
   // If we do get bogus data, then the dynamic_cast will almost certainly
   // fail, returning 0, and we will live happily ever after.
   

//    // This is a specialization of the above template that avoids the otherwise
//    // redundant dynamic_cast.
// 
//    Node*
//    GetNode /* <Node*> */ (IDataObject& dataObject)
//    {
//       Node* node = Extract(dataObject);
// 
//       ASSERT(node);
// 
//       return node;
//    }



   private:



   // not defined: no copying allowed

   NodePointerExtractor(const NodePointerExtractor&);
   const NodePointerExtractor& operator=(const NodePointerExtractor&);
};


#endif 	// NODEPOINTEREXTRACTOR_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\objpick.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// ObjectPicker wrapper class
//
// 10-13-98 sburns




#include "headers.hxx"
#include "objpick.hpp"



HRESULT
ObjectPicker::Invoke(
   HWND                             parentWindow,
   ObjectPicker::ResultsCallback&   callback,
   DSOP_INIT_INFO&                  initInfo)
{
   ASSERT(Win::IsWindow(parentWindow));

   HRESULT hr = S_OK;

   do
   {
      SmartInterface<IDsObjectPicker> object_picker;
      hr =
         object_picker.AcquireViaCreateInstance(
            CLSID_DsObjectPicker,
            0,
            CLSCTX_INPROC_SERVER,

            // CODEWORK: this interface needs to be declared w/ declspec uuid
            IID_IDsObjectPicker);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = object_picker->Initialize(&initInfo);
      BREAK_ON_FAILED_HRESULT(hr);

      IDataObject* pdo = 0;
      hr = object_picker->InvokeDialog(parentWindow, &pdo);
      BREAK_ON_FAILED_HRESULT(hr);

      // S_OK == selections made, S_FALSE == cancel hit

      if (hr == S_OK)
      {
         SmartInterface<IDataObject> ido(0);
         ido.Acquire(pdo);

         STGMEDIUM stgmedium =
         {
            TYMED_HGLOBAL,
            0
         };

         static const UINT cf =
            Win::RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

         FORMATETC formatetc =
         {
            (CLIPFORMAT)cf,
            0,
            DVASPECT_CONTENT,
            -1,
            TYMED_HGLOBAL
         };

         hr = ido->GetData(&formatetc, &stgmedium);
         BREAK_ON_FAILED_HRESULT(hr);

         PVOID lockedHGlobal = 0;
         hr = Win::GlobalLock(stgmedium.hGlobal, lockedHGlobal);
         BREAK_ON_FAILED_HRESULT(hr);
         
         DS_SELECTION_LIST* selections =
            reinterpret_cast<DS_SELECTION_LIST*>(lockedHGlobal);

         if (selections)
         {
            callback.Execute(*selections);
         }

         Win::GlobalUnlock(stgmedium.hGlobal);
         Win::ReleaseStgMedium(stgmedium);
      }
   }
   while (0);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\objpick.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// ObjectPicker wrapper class
// 
// 10-13-98 sburns



#ifndef OBJPICK_HPP_INCLUDED
#define OBJPICK_HPP_INCLUDED



// ObjectPicker is a variation on the Template Method pattern.  It allows the
// object picker to be invoked, and parameterizes the retreival of the
// results.

class ObjectPicker
{
   public:

   // the Execute method is invoked to return the results.  Subclass your
   // own ResultsCallback to change the behavior.

   class ResultsCallback : public Callback
   {
      public:

      // Callback override

      virtual
      int
      Execute(void* param)
      {
         ASSERT(param);

         return
            Execute(*reinterpret_cast<DS_SELECTION_LIST*>(param));
      }

      virtual
      int
      Execute(DS_SELECTION_LIST& selections) = 0;
   };

   static
   HRESULT
   Invoke(
      HWND              parentWindow,
      ResultsCallback&  callback,
      DSOP_INIT_INFO&   initInfo);

   private:

   // not implemented: can't construct instances
   ObjectPicker();
   ObjectPicker(const ObjectPicker&);
   const ObjectPicker& operator=(const ObjectPicker&);
};



#endif   // OBJPICK_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDI_WARN                        102
#define IDI_WARNINGBIG                  107
#define IDD_USER_GENERAL                115
#define IDD_USER_PROFILE                116
#define IDD_USER_MEMBER                 120
#define IDD_GROUP_GENERAL               121
#define IDC_MUST_CHANGE_PASSWORD        257
#define IDC_CANNOT_CHANGE_PASSWORD      258
#define IDC_DISABLED                    260
#define IDD_MACHINE_CHOOSER             970
#define IDC_GROUP                       971
#define IDC_LOCAL_MACHINE               972
#define IDC_SPECIFIC_MACHINE            973
#define IDC_MACHINE_NAME                974
#define IDC_BROWSE                      975
#define IDC_OVERRIDE                    976
#define IDS_MACHINE_IS_HOME_EDITION_LOCAL 978
#define IDS_USERNAME_CANT_BE_COMPUTER_NAME 979
#define IDC_DRIVE                       1001
#define IDC_USER_NAME                   1002
#define IDC_CONNECT                     1012
#define IDC_LOCAL                       1013
#define IDC_MEMBERS                     1022
#define IDC_FULL_NAME                   1030
#define IDC_PROFILE                     1031
#define IDC_PATH                        1032
#define IDC_SCRIPT                      1033
#define IDC_SHARE                       1034
#define IDC_NEVER_EXPIRES               1078
#define IDC_DISABLE                     1111
#define IDD_CREATE_USER                 1113
#define IDD_CREATE_GROUP                1114
#define IDC_LOCKED                      1165
#define IDC_ADD                         1168
#define IDC_REMOVE                      1169
#define IDC_CREATE                      1170
#define IDC_DESCRIPTION                 1171
#define IDC_PASSWORD                    1172
#define IDC_CONFIRM                     1173
#define IDC_NAME                        1174
#define IDC_USER_ICON                   1177
#define IDC_GROUP_ICON                  1178
#define IDC_GROUPS                      1189
#define IDI_DISABLED_USER               1190
#define IDC_HELP_BUTTON                 1197
#define IDC_WARNING_TEXT1               1198
#define IDC_WARNING_TEXT2               1199
#define IDC_MESSAGE                     1200
#define IDC_TO_STATIC                   1202
#define IDS_ERROR_LAUNCHING_PICKER      5017
#define IDS_BAD_SHARE_NAME              5018
#define IDS_BAD_HOME_DIR                5019
#define IDI_GROUP                       5020
#define IDI_SNAPIN_ICON                 5021
#define IDI_USER                        5022
#define IDI_FOLDER_OPEN                 5023
#define IDI_FOLDER_CLOSED               5024
#define IDS_SNAPIN_CLSID_FRIENDLY_NAME  5025
#define IDS_SNAPIN_REG_NAMESTRING       5026
#define IDS_SNAPIN_ABOUT_CLSID_FRIENDLY_NAME 5027
#define IDS_SNAPIN_ABOUT_DESCRIPTION    5028
#define IDS_SNAPIN_ABOUT_PROVIDER_NAME  5029
#define IDS_SNAPIN_ABOUT_VERSION        5030
#define IDS_STATIC_FOLDER_DISPLAY_NAME  5031
#define IDS_USERS_FOLDER_DISPLAY_NAME   5032
#define IDS_GROUPS_FOLDER_DISPLAY_NAME  5033
#define IDS_USER_NAME_COLUMN_TITLE      5034
#define IDS_USER_FULL_NAME_COLUMN_TITLE 5035
#define IDS_USER_DESCRIPTION_COLUMN_TITLE 5036
#define IDS_USERS_FOLDER_TYPE_TITLE     5037
#define IDS_UF_MENU_NEW_USER            5038
#define IDS_UF_MENU_NEW_USER_STATUS     5039
#define IDS_UF_MENU_CREATE_USER         5040
#define IDS_ERROR_DC_NOT_SUPPORTED      5041
#define IDS_ERROR_DC_NOT_SUPPORTED_EXT  5042
#define IDS_STATIC_FOLDER_SHORT_DISPLAY_NAME 5049
#define IDS_VERSION_MISMATCH            5050
#define IDS_VERSION_MISMATCH_TITLE      5051
#define IDS_GROUPS_FOLDER_TYPE_TITLE    5052
#define IDS_GF_MENU_CREATE_GROUP        5053
#define IDS_GF_MENU_NEW_GROUP_STATUS    5054
#define IDS_GF_MENU_NEW_GROUP           5055
#define IDS_ERROR_READING_MEMBER_PROPERTIES1 5056
#define IDS_ERROR_READING_MEMBER_PROPERTIES2 5057
#define IDS_USER_NAME_COLUMN_WIDTH      5064
#define IDS_USER_FULL_NAME_COLUMN_WIDTH 5065
#define IDS_USER_DESCRIPTION_COLUMN_WIDTH 5066
#define IDS_GROUP_NAME_COLUMN_TITLE     5067
#define IDS_GROUP_NAME_COLUMN_WIDTH     5068
#define IDS_GROUP_DESCRIPTION_COLUMN_TITLE 5069
#define IDS_GROUP_DESCRIPTION_COLUMN_WIDTH 5070
#define IDS_ERROR_READING_USER          5089
#define IDS_ERROR_READING_GROUP         5090
#define IDS_MEMBER_LIST_NAME_COLUMN_WIDTH 5091
#define IDS_MEMBER_LIST_NAME_COLUMN     5092
#define IDS_MEMBER_LIST_DESC_COLUMN_WIDTH 5093
#define IDS_MEMBER_LIST_DESC_COLUMN     5094
#define IDS_ERROR_CREATING_USER         5095
#define IDS_PASSWORD_MISMATCH           5096
#define IDS_ERROR_SETTING_USER_PROPERTIES 5098
#define IDB_STATIC_FOLDER_LARGE         5099
#define IDS_ERROR_CREATING_GROUP        5100
#define IDS_ERROR_SETTING_GROUP_PROPERTIES 5101
#define IDS_USER_MENU_CHANGE_PASSWORD   5102
#define IDB_STATIC_FOLDER_SMALL         5102
#define IDB_STATIC_FOLDER_SMALL_OPEN    5103
#define IDS_USER_MENU_CHANGE_PASSWORD_STATUS 5103
#define IDS_ERROR_RENAMING_USER         5104
#define IDS_ERROR_RENAMING_GROUP        5105
#define IDS_ERROR_DELETING_USER         5106
#define IDS_ERROR_DELETING_GROUP        5107
#define IDD_SET_PASSWORD                5109
#define IDI_DOMAIN_USER                 5110
#define IDI_DOMAIN_GROUP                5111
#define IDS_NEED_SHARE_NAME             5113
#define IDI_ROOT_CLOSED                 5114
#define IDD_SET_PASSWORD_WARNING_SELF   5115
#define IDI_ROOT_OPEN                   5115
#define IDD_SET_PASSWORD_WARNING_SELF_FRIENDLY 5115
#define IDI_ROOT_ERROR                  5116
#define IDI_UNKNOWN_SID                 5117
#define IDS_ROOT_NODE_DESCRIPTION       5118
#define IDI_BULLET                      5118
#define IDS_ROOT_NODE_TYPE              5119
#define IDS_ITEM_INCOMPLETE             5120
#define IDS_ERROR_CHANGING_MEMBERSHIP   5121
#define IDS_APP_ERROR_TITLE             5122
#define IDS_USER_MENU_ADD_TO_GROUP      5123
#define IDS_USER_MENU_ADD_TO_GROUP_STATUS 5124
#define IDS_STATIC_FOLDER_LOCAL_DISPLAY_NAME 5127
#define IDS_CONFIRM_USER_DELETE         5129
#define IDS_CONFIRM_GROUP_DELETE        5131
#define IDS_HTMLHELP_NAME               5132
#define IDS_ERROR_VISITING_GROUP        5133
#define IDS_ERROR_VISITING_USER         5134
#define IDS_PASSWORD_CHANGE_SUCCESSFUL  5135
#define IDS_GLOBAL_ACCOUNT_DISPLAY_FORMAT 5137
#define IDS_USERNAME                    5138
#define IDS_ADD_TO_GROUP_MEMBERSHIP     5139
#define IDS_ADD_TO_GROUP_MEMBERSHIP_STATUS 5140
#define IDS_ERROR_SPAWNING_GROUP_PROPERTIES 5142
#define IDS_ERROR_ASSIGNING_NEW_USER_TO_USERS_GROUP 5145
#define IDS_HTMLHELP_OVERVIEW_TOPIC     5146
#define IDD_USER_FPNW                   5147
#define IDC_NETWARE_ENABLE              5148
#define IDC_NWPWEXPIRED                 5149
#define IDC_OBJECTID_TEXT               5150
#define IDC_OBJECT_ID                   5151
#define IDC_GRACE_LOGINS                5152
#define IDC_UNLIMITED_GRACELOGINS       5153
#define IDC_LIMIT_GRACELOGINS           5154
#define IDC_GRACE_LIMIT                 5155
#define IDC_GRACE_SPIN                  5156
#define IDC_GRACE_REMAINING_TEXT        5157
#define IDC_GRACE_REMAINING             5158
#define IDC_GRACE_REMAINING_SPIN        5159
#define IDC_CONCURRENT_CONNECTIONS      5160
#define IDC_UNLIMITED_CONNECTIONS       5161
#define IDC_LIMIT_CONNECTIONS           5162
#define IDC_CONNECTION_LIMIT            5163
#define IDC_CONNECTION_SPIN             5164
#define IDC_SCRIPT_BUTTON               5166
#define IDC_NWHMDIR_RELPATH_TEXT        5167
#define IDC_NWHMDIR_RELPATH             5168
#define IDD_FPNW_LOGIN_SCRIPT           5170
#define IDD_FPNW_PASSWORD               5171
#define IDD_SET_PASSWORD_WARNING_OTHER  5172
#define IDD_SET_PASSWORD_WARNING_OTHER_HOSTILE 5172
#define IDD_SET_PASSWORD_WARNING_SELF_HOSTILE 5173
#define IDD_SET_PASSWORD_WARNING_OTHER_FRIENDLY 5174
#define IDS_BAD_SAM_NAME                5178
#define IDS_ERROR_FPNW_SERVICE_NOT_RUNNING 5179
#define IDS_ERROR_FPNW_SERVICE_NOT_ACCESSIBLE 5180
#define IDS_ERROR_SETTING_PASSWORD      5200
#define IDS_BAD_SCRIPT_PATH             5201
#define IDS_FPNW_CLIENT_DLL             5202
#define IDS_LOGIN_SCRIPT_TITLE          5203
#define IDS_PASSWORD_TITLE              5204
#define IDS_FPNW_PASSWORD_CANCEL_WARNING 5205
#define IDS_BAD_FPNW_HOMEDIR            5206
#define IDS_FPNW_ERROR_WRITING_SCRIPT   5207
#define IDS_FPNW_ERROR_READING_SCRIPT   5208
#define IDS_HOME_DIR_CREATE_FAILED      5209
#define IDS_USER_NAME_TOO_LONG          5210
#define IDS_USERS_FOLDER_DESC           5211
#define IDS_GROUPS_FOLDER_DESC          5212
#define IDS_MUST_ENTER_MACHINE_NAME     5213
#define IDS_CANT_ACCESS_MACHINE         5214
#define IDS_ALREADY_MEMBER              5215
#define IDS_ITEM_ALREADY_PRESENT        5216
#define IDS_CANT_ACCESS_SHARE           5217
#define IDS_CANT_CREATE_FOLDER          5218
#define IDS_MACHINE_NOT_NT              5219
#define IDS_SET_PASSWORD_TITLE          5220
#define IDS_SET_PASSWORD_WARNING_BULLET_OTHER1 5221
#define IDS_SET_PASSWORD_WARNING_BULLET_OTHER2 5222
#define IDS_SET_PASSWORD_WARNING_BULLET_SELF1 5223
#define IDS_SET_PASSWORD_WARNING_BULLET_SELF2 5224
#define IDS_SET_PASSWORD_WARNING_MESSAGE_SELF1 5225
#define IDS_CONFIRM_LOGGED_ON_USER_DELETE 5226

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        5119
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1202
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\resnode.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Result Node class
// 
// 9-4-97 sburns



#include "headers.hxx"
#include "resnode.hpp"



ResultNode::ResultNode(
   const SmartInterface<ComponentData>&   owner,
   const NodeType&                        nodeType,      
   const String&                          displayName)
   :
   Node(owner, nodeType),
   name(displayName)
{
   LOG_CTOR2(ResultNode, GetDisplayName());
}



ResultNode::~ResultNode()
{
   LOG_DTOR2(ResultNode, GetDisplayName());   
}



bool
ResultNode::HasPropertyPages()
{
   LOG_FUNCTION(ResultNode::HasPropertyPages);

   return false;
}



HRESULT
ResultNode::CreatePropertyPages(
   IPropertySheetCallback&             /* callback */ ,
   MMCPropertyPage::NotificationState* /* state    */ )
{
   LOG_FUNCTION(ResultNode::CreatePropertyPages);

   return S_OK;
}

   

HRESULT
ResultNode::InsertIntoResultPane(IResultData& resultData)
{
   LOG_FUNCTION2(ResultNode::InsertIntoResultPane, GetDisplayName());  

   HRESULT hr = S_OK;
   RESULTDATAITEM item;
   memset(&item, 0, sizeof(item));

   item.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
   item.str = MMC_CALLBACK;  
   item.nImage = GetNormalImageIndex();  
   item.lParam = reinterpret_cast<LPARAM>(this);

   do
   {
      hr = resultData.InsertItem(&item);
      BREAK_ON_FAILED_HRESULT(hr);
      // could save the item.ID in the node, but so far this is not
      // necessary information to retain.
   }
   while (0);

   return hr;
}



HRESULT
ResultNode::DoAddPage(
   MMCPropertyPage&           page,
   IPropertySheetCallback&    callback)
{
   LOG_FUNCTION2(ResultNode::DoAddPage, GetDisplayName());
      
   HRESULT hr = S_OK;
   do
   {
      HPROPSHEETPAGE hpage = page.Create();
      if (!hpage)
      {
         hr = Win::GetLastErrorAsHresult();
         break;
      }

      hr = callback.AddPage(hpage);
      if (FAILED(hr))
      {
         ASSERT(false);

         // note that this is another hr, not the one from the enclosing
         // scope.

         HRESULT unused = Win::DestroyPropertySheetPage(hpage);

         ASSERT(SUCCEEDED(unused));

         break;
      }
   }
   while (0);

   return hr;
}



String
ResultNode::GetDisplayName() const
{
//   LOG_FUNCTION(ResultNode::GetDisplayName);  

   return name;
}



HRESULT
ResultNode::Rename(const String& /* newName */ )
{
   LOG_FUNCTION(ResultNode::Rename);

   return S_FALSE;
}



void
ResultNode::SetDisplayName(const String& newName)
{
   LOG_FUNCTION2(ResultNode::SetDisplayName, newName);

   name = newName;
}



HRESULT
ResultNode::Delete()
{
   LOG_FUNCTION(ResultNode::Delete);

   return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\resnode.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Result Node class
// 
// 9-4-97 sburns



#ifndef RESNODE_HPP_INCLUDED
#define RESNODE_HPP_INCLUDED



#include "node.hpp"
#include "mmcprop.hpp"



// ResultNode is an abstract base class defining the interfaces for all Node
// classes that are normally hosted in the result pane.  (ScopeNodes may also
// appear in the result pane, but MMC takes care of this automatically.  That
// is one reason why ScopeNode does not derive from ResultNode.)
// 
// ResultNode instances are "owned" by ScopeNodes.  That is, a ScopeNode has a
// bunch of ResultNodes that it instantiates and uses to populate its result
// pane.

class ResultNode : public Node
{
   public:

   // Called by IComponent::CreatePropertyPages.  Derived classes should use
   // the given parameters to supply MMC with the property pages for their
   // node type.  The default implementation returns S_OK;
   // 
   // callback - the IPropertySheetCallback supplied to
   // IComponent::CreatePropertyPages.
   // 
   // state - the NotificationState instance created to contain property
   // change notification information for the console.

   virtual
   HRESULT
   CreatePropertyPages(
      IPropertySheetCallback&             callback,
      MMCPropertyPage::NotificationState* state);

   // Node overrides

   // Overrides the base class function to supply the name the node was
   // created with.  This implies that ResultNodes tend to have names fixed
   // throughout their lifetimes.

   virtual
   String
   GetDisplayName() const;

   // ResultNode methods

   // Called by IComponent::Notify upon receipt of a MMCN_DELETE message.  The
   // default implementation always returns E_NOTIMPL.  Derived classes should
   // return S_OK to indicate that the delete succeeded.  This function will
   // only be called if the node has enabled the MMC_VERB_DELETE verb in its
   // implementation of UpdateVerbs.

   virtual
   HRESULT
   Delete();

   // Called by IComponent::QueryPagesFor.  Derived classes should return true
   // if the Node has any pages to supply to the property sheet.  The class
   // should also implement CreatePropertyPages.  The default implementation
   // returns false.

   virtual
   bool
   HasPropertyPages();

   // Inserts self into the result pane, using the supplied IResultData
   // interface.  This is typically called from the owning ScopeNode's
   // implementation of InsertResultItems.
   //
   // resultData - the IResultData interface used to insert this node.

   HRESULT
   InsertIntoResultPane(IResultData& resultData);

   // Called by IComponent::Notify upon receipt of a MMCN_RENAME message.  The
   // default implementation always returns S_FALSE.  Derived classes should
   // return S_OK to indicate that the rename succeeded, or S_FALSE to
   // indicate otherwise.  This function will only be called if the node has
   // enabled the MMC_VERB_RENAME verb in its implementation of UpdateVerbs.
   // 
   // newName - The new name for the node entered by the user.

   virtual 
   HRESULT
   Rename(const String& newName);

   protected:

   // Contructs a new instance.  Declared protected so that this class may
   // only be a base class.
   //
   // owner - the ComponentData object which "owns" this node
   //
   // nodeType - the NodeType GUID corresponding to this instance.  This must
   // be one of the node types registered in the MMC keys registry when the
   // snapin is registered, as it is used to produce the CCF_NODETYPE and
   // CCF_SZNODETYPE formats for IDataObject::GetDataHere.
   // 
   // displayName - The text used to label the node in the result pane.

   ResultNode(
      const SmartInterface<ComponentData>&   owner,
      const NodeType&                        nodeType,      
      const String&                          displayName);

   virtual ~ResultNode();

   void
   SetDisplayName(const String& newName);

   // A helper function for classes that implement CreatePropertyPages.  The
   // function calls Create on the supplied page, then calls AddPage on the
   // callback with the result of the Create call.  If any errors occurr, the
   // page is properly destroyed.
   // 
   // page - page to be created and added.
   // 
   // callback - used to add the page.
      
   HRESULT
   DoAddPage(
      MMCPropertyPage&           page,
      IPropertySheetCallback&    callback);
      
   String name;

   private:

   // not implemented: no copying allowed

   ResultNode(const ResultNode&);
   const ResultNode& operator=(const ResultNode&);
};



#endif   // RESNODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\rootnode.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Root Node class
// 
// 9-2-97 sburns



#ifndef ROOTNODE_HPP_INCLUDED
#define ROOTNODE_HPP_INCLUDED



#include "scopnode.hpp"



class UsersFolderNode;
class GroupsFolderNode;
class AdminRolesFolderNode;
class PoliciesFolderNode;
class ComponentData;



// For the snapin in stand-alone mode, a "phantom" node (i.e. it is not
// actually inserted into the scope pane) representing the snapin root node.
// This maintains the consistency of the object hierarchy.
// 
// When the snapin is in extension mode, this node is inserted as a child of
// the extended snapin.

class RootNode : public ScopeNode
{
   friend class ComponentData;

   public:

   // Node overrides

   virtual
   String
   GetColumnText(int column);

   virtual
   String
   GetDisplayName() const;

   virtual 
   int
   GetNormalImageIndex();

   virtual
   HRESULT
   UpdateVerbs(IConsoleVerb& consoleVerb);

   // ScopeNode overrides

   virtual
   int
   GetNumberOfScopeChildren();

   virtual
   int
   GetOpenImageIndex();

   virtual
   HRESULT
   InsertResultColumns(IHeaderCtrl& headerCtrl);

   virtual
   HRESULT
   InsertResultItems(IResultData& resultData);

   virtual
   HRESULT
   InsertScopeChildren(
      IConsoleNameSpace2&  nameSpace,
      HSCOPEITEM           parentScopeID);

   virtual 
   HRESULT
   RemoveScopeChildren(
      IConsoleNameSpace2&  nameSpace,
      HSCOPEITEM           parentScopeID);

   private:

   // Creates a new instance.  Declared private so only the friend
   // ComponentData can create new instances.
   //
   // owner - the ComponentData that creates the object.  This is passed to
   // all subsequent nodes that are created by this node, both ScopeNodes and
   // ResultNodes.

   RootNode(const SmartInterface<ComponentData>& owner);

   // only we can delete ourselves via Release
   virtual ~RootNode();

   SmartInterface<UsersFolderNode>  users_folder_node; 
   SmartInterface<GroupsFolderNode> groups_folder_node;
   mutable String                   name;

   // not implemented: no copying allowed

   RootNode(const RootNode&);
   const RootNode& operator=(const RootNode&);
};



#endif   // ROOTNODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\scopnode.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Scope Node class
// 
// 9-4-97 sburns



#include "headers.hxx"
#include "scopnode.hpp"



ScopeNode::ScopeNode(
   const SmartInterface<ComponentData>&   owner,
   const NodeType&                        nodeType)
   :
   Node(owner, nodeType)
{
   LOG_CTOR(ScopeNode);
}



ScopeNode::~ScopeNode()
{
   LOG_DTOR(ScopeNode);
}



HRESULT
ScopeNode::InsertIntoScopePane(
   IConsoleNameSpace2&  nameSpace,
   HSCOPEITEM           parentScopeID)
{
   LOG_FUNCTION2(ScopeNode::InsertIntoScopePane, GetDisplayName());

   HRESULT hr = S_OK;
   SCOPEDATAITEM item;
   memset(&item, 0, sizeof(item));

   item.mask =
         SDI_STR
      |  SDI_IMAGE
      |  SDI_OPENIMAGE
      |  SDI_PARAM
      |  SDI_PARENT
      |  SDI_CHILDREN;
   item.displayname = MMC_CALLBACK;  
   item.relativeID = parentScopeID;

   do
   {
      item.lParam       = reinterpret_cast<LPARAM>(this);
      item.nImage       = GetNormalImageIndex();
      item.nOpenImage   = GetOpenImageIndex();
      item.cChildren    = GetNumberOfScopeChildren();

      hr = nameSpace.InsertItem(&item);
      BREAK_ON_FAILED_HRESULT(hr);

      // retained for RemoveFromScopePane
      item_id = item.ID;
   }
   while (0);

   return hr;
}



HRESULT
ScopeNode::RemoveFromScopePane(IConsoleNameSpace2& nameSpace)
{
   LOG_FUNCTION2(ScopeNode::RemoveFromScopePane, GetDisplayName());

   ASSERT(item_id);

   return nameSpace.DeleteItem(item_id, TRUE);
}
   


HRESULT
ScopeNode::InsertScopeChildren(
   IConsoleNameSpace2& /* nameSpace     */ ,
   HSCOPEITEM          /* parentScopeID */ )
{
   LOG_FUNCTION(ScopeNode::InsertScopeChildren);

   return S_OK;
}




HRESULT
ScopeNode::RemoveScopeChildren(
   IConsoleNameSpace2& /* nameSpace     */ ,
   HSCOPEITEM          /* parentScopeID */ )
{
   LOG_FUNCTION(ScopeNode::RemoveScopeChildren);

   return S_OK;
}



HRESULT
ScopeNode::RebuildResultItems()
{
   LOG_FUNCTION(ScopeNode::RebuildResultItems);

   // default is to do nothing.
   return S_OK;
}



long
ScopeNode::GetViewOptions()
{
   LOG_FUNCTION(ScopeNode::GetViewOptions);

   return MMC_VIEW_OPTIONS_LEXICAL_SORT; 
}



int
ScopeNode::GetNumberOfScopeChildren()
{
   LOG_FUNCTION(ScopeNode::GetNumberOfScopeChildren);

   return 0;
}



String
ScopeNode::GetDescriptionBarText()
{
   LOG_FUNCTION(ScopeNode::GetDescriptionBarText);

   return String();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\scopnode.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Scope Node class
// 
// 9-4-97 sburns



#ifndef SCOPNODE_HPP_INCLUDED
#define SCOPNODE_HPP_INCLUDED



#include "node.hpp"



// Struct used by BuildResultColumns.  Should be nested in ScopeNode, but vc++
// templates seem to have trouble with nested classes as parameters.

struct ResultColumn
{
   int colTextResID;    // header text string resource ID
   int colWidthResID;   // string with decimal integer pixel width
};



// ScopeNode instances represent items appearing in the scope pane.  An
// instance of ScopeNode "owns" the items (which are ResultNode instances) to
// be displayed in the result pane when that instance is expanded in the scope
// pane.

class ScopeNode : public Node
{
   public:

   // Returns the text to be displayed in the description bar of the result
   // pane when the node is shown.  The default implementation returns the
   // empty string.

   virtual
   String
   GetDescriptionBarText();

   // Returns the number of scope children that will be inserted by
   // InsertScopeChildren.  The default implementation returns 0.  If you
   // don't know how many children you will have, return 1.

   virtual
   int
   GetNumberOfScopeChildren();

   // Returns the image index of the icon image for this node to be used then
   // the node is shown in the "open" or expanded state.  This is the index of
   // the image that was registered with MMC by IComponent in response to the
   // MMCN_ADD_IMAGES notification.  This should always return the same index
   // for all invocations.
   
   virtual
   int
   GetOpenImageIndex() = 0;

   // The default implementation returns MMC_VIEW_OPTIONS_NONE;

   virtual
   long
   GetViewOptions();

   // Called from IComponentData::Notify upon receipt of a MMCN_EXPAND
   // notification.  Derived classes should override this function to insert
   // any subordinate ScopeNodes (*not* ResultNodes).  The default
   // implementation does nothing, and returns S_OK.
   // 
   // nameSpace - The console's IConsoleNameSpace2 interface, obtained upon
   // IComponentData::Initialize.
   // 
   // scopeID - The HSCOPEITEM passed as the param argument to the MMCN_EXPAND
   // notification.

   virtual 
   HRESULT
   InsertScopeChildren(
      IConsoleNameSpace2&  nameSpace,
      HSCOPEITEM           scopeID);

   // Called by IComponent::Notify upon receipt of a MMCN_SHOW notification.
   // Derived classes should provide an implementation which inserts columns
   // for each of the columns supported by the node's owned items; that is,
   // for each column for which the owned node's GetColumnText method will
   // support.
   // 
   // headerCtrl - The console's IHeaderCtrl interface, obtained upon
   // IComponentData::Initialize

   virtual
   HRESULT
   InsertResultColumns(IHeaderCtrl& headerCtrl) = 0;

   // Called by IComponent::Notify upon receipt of a MMCN_SHOW notification,
   // or MMCN_VIEW_CHANGE notification (where the arg indicates that the
   // result pane is to be re-populated).  Derived classes should iterate
   // through their dependent ResultNodes, calling InsertIntoResultPane for
   // each.
   //
   // resultData - The console's IResultData interface, obtained upon
   // IComponentData::Initialize.

   virtual
   HRESULT
   InsertResultItems(IResultData& resultData) = 0;

   // Inserts self into the scope pane.  Typically called from a parent
   // ScopeNode's implementation of InsertScopeChildren.
   //
   // nameSpace - The console's IConsoleNameSpace2 interface, obtained upon
   // IComponentData::Initialize.
   // 
   // parentScopeID - The HSCOPEITEM passed as the param argument to the
   // MMCN_EXPAND notification received by the parent ScopeNode, then passed
   // to the parent ScopeNode's InsertScopeChildren

   HRESULT
   InsertIntoScopePane(
      IConsoleNameSpace2&  nameSpace,
      HSCOPEITEM           parentScopeID);

   // Called by IComponent::Notify upon receipt of a MMCN_REFRESH
   // notification, if the node's implementation of UpdateVerbs has enabled
   // the MMC_VERB_REFERESH verb.
   // 
   // Derived classes should release any dependent data, then rebuild it.
   //
   // The refresh cycle works like this:
   // MMCN_REFRESH received for the ScopeNode
   //   - UpdateAllViews is called to clear the result pane of any view for
   //     which the current selected node is the same ScopeNode.  This is
   //     done by comparing nodes and using IResultData::DeleteAllRsltItems.
   //   - ScopeNode::RebuildResultItems is called for the ScopeNode.
   //   - UpdateAllViews is called to repopulate the result pane of any view
   //     for which the current selected node is the same ScopeNode.  This
   //     is done by comparing nodes and calling InsertResultItems for the
   //     ScopeNode.

   virtual
   HRESULT
   RebuildResultItems();

   // Removes self from the scope pane.  Typically called from a parent
   // ScopeNode's implementation of RemoveScopeChildren on it's children.
   // 
   // If this node has scope pane children, then this call will cause
   // MMCN_REMOVE_CHILDREN to be fired for this node, which will call
   // RemoveScopeChildren for this node.  
   //
   // nameSpace - the console's IConsoleNameSpace2 interface, obtained upon
   // IComponentData::Initialize.

   HRESULT
   RemoveFromScopePane(IConsoleNameSpace2& nameSpace);

   // Called from IComponentData::Notify upon receipt of a
   // MMCN_REMOVE_CHILDREN notification.  Derived classes should override this
   // function to remove any subordinate ScopeNodes (*not* ResultNodes).  The
   // default implementation does nothing, and returns S_OK.
   // 
   // nameSpace - The console's IConsoleNameSpace2 interface, obtained upon
   // IComponentData::Initialize.
   // 
   // parentScopeID - The HSCOPEITEM passed as the param argument to the
   // MMCN_REMOVE_CHILDREN notification.

   virtual 
   HRESULT
   RemoveScopeChildren(
      IConsoleNameSpace2&  nameSpace,
      HSCOPEITEM           parentScopeID);

   protected:

   // Constructs a new instance.  Declared protected to allow this class to
   // only be a base class.
   //
   // owner - supplied to base class contructor
   // 
   // nodeType - NodeType GUID supplied to the base class constructor.

   ScopeNode(
      const SmartInterface<ComponentData>&   owner,
      const NodeType&                        nodeType);

   virtual ~ScopeNode();

   // Helper function used to implement InsertResultColumns.
   // 
   // begin - Iterator positioned to the beginning ResultColumn instance.
   // 
   // end - Iterator positioned just beyond the last ResultColumn instance.
   //
   // headerCtrl - the IHeaderCtrl instance passed to InsertResultColumns.

   template <class InputIterator>
   HRESULT
   BuildResultColumns(
      InputIterator  begin,
      InputIterator  end,
      IHeaderCtrl&   headerCtrl)
   {
      int col = 0;
      HRESULT hr = S_OK;
      for (
         ;
         begin != end;
         ++begin)
      {
         int width = 0;
         String::load((*begin).colWidthResID).convert(width);

         // minimum width is 100 units.
         width = max(100, width);

         hr =
            headerCtrl.InsertColumn(
               col++,
               String::load((*begin).colTextResID).c_str(),
               LVCFMT_LEFT,
               width);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      return hr;
   }

   private:

   HSCOPEITEM item_id;

   // not implemented: no copying allowed

   ScopeNode(const ScopeNode&);
   const ScopeNode& operator=(const ScopeNode&);
};



#endif   // SCOPNODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\rootnode.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// Root Node class
//
// 9-2-97 sburns



#include "headers.hxx"
#include "rootnode.hpp"
#include "uuids.hpp"
#include "images.hpp"
#include "resource.h"
#include "UsersFolderNode.hpp"
#include "gfnode.hpp"
#include "compdata.hpp"
#include "dlgcomm.hpp"



RootNode::RootNode(const SmartInterface<ComponentData>& owner)
   :
   ScopeNode(owner, NODETYPE_RootFolder),
   users_folder_node(0),
   groups_folder_node(0)
{
   LOG_CTOR(RootNode);
}



RootNode::~RootNode()
{
   LOG_DTOR(RootNode);

   // users_folder_node is destroyed, releasing it's object
   // groups_folder_node is destroyed, releasing it's object
}



String
RootNode::GetDisplayName() const
{
//   LOG_FUNCTION(RootNode::GetDisplayName);

   SmartInterface<ComponentData> owner(GetOwner());
   String machine = owner->GetDisplayComputerName();
   if (owner->IsExtension())
   {
      // "Local User Manager"
      name = String::load(IDS_STATIC_FOLDER_SHORT_DISPLAY_NAME);
   }
   else if (Win::IsLocalComputer(machine))
   {
      // "Local User Manager (Local)"
      name = String::load(IDS_STATIC_FOLDER_LOCAL_DISPLAY_NAME);
   }
   else
   {
      // "Local User Manager (machine)"
      name =
         String::format(
            IDS_STATIC_FOLDER_DISPLAY_NAME,
            machine.c_str());
   }

   return name;
}



String
RootNode::GetColumnText(int column)
{
   LOG_FUNCTION(Node::GetColumnText);

   switch (column)
   {
      case 0:
      {
         return GetDisplayName();
      }
      case 1:  // type
      {
         // CODEWORK: this is inefficient -- should load once

         return String::load(IDS_ROOT_NODE_TYPE);
      }
      case 2:  // description
      {
         // CODEWORK: this is inefficient -- should load once

         return String::load(IDS_ROOT_NODE_DESCRIPTION);
      }
      default:
      {
         ASSERT(false);
      }
   }

   return L"";
}



int
RootNode::GetNormalImageIndex()
{
   SmartInterface<ComponentData> owner(GetOwner());
   if (owner->IsBroken())
   {
      return ROOT_ERROR_INDEX;
   }

   return ROOT_CLOSED_INDEX;
}



int
RootNode::GetOpenImageIndex()
{
   SmartInterface<ComponentData> owner(GetOwner());
   if (owner->IsBroken())
   {
      return ROOT_ERROR_INDEX;
   }

   return ROOT_OPEN_INDEX;
}



HRESULT
RootNode::InsertScopeChildren(
   IConsoleNameSpace2&  nameSpace,
   HSCOPEITEM           parentScopeID)
{
   LOG_FUNCTION(RootNode::InsertScopeChildren);

   HRESULT hr = S_OK;
   SmartInterface<ComponentData> owner(GetOwner());
   if (!owner->IsBroken())
   {
      // these will be implicitly AddRef'd
      users_folder_node.Acquire(new UsersFolderNode(owner));
      groups_folder_node.Acquire(new GroupsFolderNode(owner));

      do
      {
         hr = users_folder_node->InsertIntoScopePane(nameSpace, parentScopeID);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = groups_folder_node->InsertIntoScopePane(nameSpace, parentScopeID);
         BREAK_ON_FAILED_HRESULT(hr);
      }
      while (0);
   }

   return hr;
}



HRESULT
RootNode::RemoveScopeChildren(
   IConsoleNameSpace2&  nameSpace,
   HSCOPEITEM           /* parentScopeID */ )
{
   LOG_FUNCTION(RootNode::RemoveScopeChildren);

   HRESULT hr = S_OK;
   SmartInterface<ComponentData> owner(GetOwner());
   if (!owner->IsBroken())
   {
      do
      {
         // we test each pointer to our child nodes, as they may not
         // have been created yet when we are told to remove them.

         if (users_folder_node)
         {
            hr = users_folder_node->RemoveFromScopePane(nameSpace);
            BREAK_ON_FAILED_HRESULT(hr);
            users_folder_node.Relinquish();
         }

         if (groups_folder_node)
         {
            hr = groups_folder_node->RemoveFromScopePane(nameSpace);
            BREAK_ON_FAILED_HRESULT(hr);
            groups_folder_node.Relinquish();
         }
      }
      while (0);
   }

   return hr;
}



HRESULT
RootNode::InsertResultColumns(IHeaderCtrl& /* headerCtrl */ )
{
   LOG_FUNCTION(RootNode::InsertResultColumns);

   return S_OK;
}



HRESULT
RootNode::InsertResultItems(IResultData& /* resultData */ )
{
   LOG_FUNCTION(RootNode::InsertResultItems);

   // insert root-level leaves, but not subordinates (as mmc will place them
   // in the result pane for me)

   // no root-level result nodes.

   return S_OK;
}



int
RootNode::GetNumberOfScopeChildren()
{
   LOG_FUNCTION(RootNode::GetNumberOfScopeChildren);

   SmartInterface<ComponentData> owner(GetOwner());
   if (owner->IsBroken())
   {
      return 0;
   }

   // groups folder and users folder
   return 2;
}



// added to fix 213003

HRESULT
RootNode::UpdateVerbs(IConsoleVerb& consoleVerb)
{
   LOG_FUNCTION(RootNode::UpdateVerbs);

   SmartInterface<ComponentData> owner(GetOwner());
   if (!owner->IsBroken())
   {
      consoleVerb.SetDefaultVerb(MMC_VERB_OPEN);
   }

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\setpasswordwarningdialog.hpp ===
// Copyright (C) 2001 Microsoft Corporation
// 
// SetPasswordWarningDialog class
// 
// 21 Feb 2001 sburns



#ifndef SETPASSWORDWARNINGDIALOG_HPP_INCLUDED
#define SETPASSWORDWARNINGDIALOG_HPP_INCLUDED



#include "dialog.hpp"



// Dialog to accept a new password and confirmation, then change a user
// account password.

class SetPasswordWarningDialog : public Dialog
{
   public:

   // Creates a new instance.
   // 
   // userADSIPath - in, fully-qualified ADSI path of the user account for
   // which the password is to be set.
   //
   // displayName - in, display name of the account corresponding to
   // userADSIPath.
   //
   // isLoggedOnUser - in, true if the account is the currently logged on
   // user, false if not.

   SetPasswordWarningDialog(
      const String&  userAdsiPath,
      const String&  userDisplayName,
      bool           isLoggedOnUser);

   virtual ~SetPasswordWarningDialog();

   private:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   String path;
   String displayName;
   bool   isLoggedOnUser;
   bool   isFriendlyLogonMode;

   // not defined: no copying allowed

   SetPasswordWarningDialog(const SetPasswordWarningDialog&);
   const SetPasswordWarningDialog& operator=(const SetPasswordWarningDialog&);
};



#endif   // SETPASSWORDWARNINGDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\setpasswordwarningdialog.cpp ===
// Copyright (C) 2001 Microsoft Corporation
// 
// SetPasswordWarningDialog class
// 
// 21 Feb 2001 sburns



#include "headers.hxx"
#include "SetPasswordWarningDialog.hpp"
#include "resource.h"



static const DWORD HELP_MAP[] =
{
   IDCANCEL,         NO_HELP,
   IDOK,             NO_HELP,
   IDC_HELP_BUTTON,  NO_HELP,
   IDC_MESSAGE,      NO_HELP,   
   0, 0
};



// allow assignment in conditional in this rare case
      
#pragma warning(push)
#pragma warning(disable: 4706)

SetPasswordWarningDialog::SetPasswordWarningDialog(
   const String& userAdsiPath,
   const String& userDisplayName,
   bool          isLoggedOnUser_)
   :
   Dialog(
         (isFriendlyLogonMode = IsOS(OS_FRIENDLYLOGONUI) ? true : false)
      ?  (isLoggedOnUser_
         ?  IDD_SET_PASSWORD_WARNING_SELF_FRIENDLY
         :  IDD_SET_PASSWORD_WARNING_OTHER_FRIENDLY)
      :  (isLoggedOnUser_
         ?  IDD_SET_PASSWORD_WARNING_SELF_HOSTILE
         :  IDD_SET_PASSWORD_WARNING_OTHER_HOSTILE),   
      HELP_MAP),
   path(userAdsiPath),
   displayName(userDisplayName),
   isLoggedOnUser(isLoggedOnUser_)
{
   LOG_CTOR(SetPasswordWarningDialog);
   ASSERT(!path.empty());
   ASSERT(!displayName.empty());   
}

#pragma warning(pop)
      


SetPasswordWarningDialog::~SetPasswordWarningDialog()
{
   LOG_DTOR(SetPasswordWarningDialog);
}



void
SetPasswordWarningDialog::OnInit()
{
   LOG_FUNCTION(SetPasswordWarningDialog::OnInit());

   Win::SetWindowText(
      hwnd,
      String::format(IDS_SET_PASSWORD_TITLE, displayName.c_str()));
   
   // Load appropriate warning text based on whether the logged on user is
   // setting the password for his own account or another user.

   if (isLoggedOnUser)
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_MESSAGE,
         String::format(
            IDS_SET_PASSWORD_WARNING_MESSAGE_SELF1,
            displayName.c_str()));
   }
}



bool
SetPasswordWarningDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//    LOG_FUNCTION(SetPasswordWarningDialog::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_HELP_BUTTON:
      {
         Win::HtmlHelp(
            hwnd,
               isFriendlyLogonMode
            ?  L"password.chm::/datalos.htm"
            :  L"password.chm::/datalosW.htm",
            HH_DISPLAY_TOPIC,
            0);
         break;
      }
      case IDOK:
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            HRESULT unused = Win::EndDialog(hwnd, controlIDFrom);

            ASSERT(SUCCEEDED(unused));
         }
         break;
      }
      default:
      {
         // do nothing.
         
         break;
      }
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\setpass.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// SetPasswordDialog class
// 
// 10-29-97 sburns



#ifndef SETPASS_HPP_INCLUDED
#define SETPASS_HPP_INCLUDED



#include "dialog.hpp"



// Dialog to accept a new password and confirmation, then change a user
// account password.

class SetPasswordDialog : public Dialog
{
   public:

   // Creates a new instance.
   // 
   // userADSIPath - in, fully-qualified ADSI path of the user account for
   // which the password is to be set.
   //
   // displayName - in, display name of the account corresponding to
   // userADSIPath.
   //
   // isLoggedOnUser - in, true if the account is the currently logged on
   // user, false if not.

   SetPasswordDialog(
      const String&  ADSIPath,
      const String&  displayName,
      bool           isLoggedOnUser);

   virtual ~SetPasswordDialog();

   private:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   String path;
   String displayName;
   bool   isLoggedOnUser;

   // not defined: no copying allowed

   SetPasswordDialog(const SetPasswordDialog&);
   const SetPasswordDialog& operator=(const SetPasswordDialog&);
};



#endif   // SETPASS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\setpass.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// SetPasswordDialog class
// 
// 10-29-97 sburns



#include "headers.hxx"
#include "setpass.hpp"
#include "resource.h"
#include "dlgcomm.hpp"
#include "adsi.hpp"
#include "lsm.h"
#include "waste.hpp"
#include "fpnw.hpp"



static const DWORD HELP_MAP[] =
{
   IDC_PASSWORD,      idh_setpass_new_password,    
   IDC_CONFIRM,       idh_setpass_confirm_password,
   IDCANCEL,          NO_HELP,                     
   IDOK,              NO_HELP,                     
   IDC_WARNING_TEXT1, NO_HELP,                     
   IDC_WARNING_TEXT2, NO_HELP,                     
   0, 0
};



SetPasswordDialog::SetPasswordDialog(
   const String&  ADSIPath,
   const String&  displayName_,
   bool           isLoggedOnUser_)
   :
   Dialog(IDD_SET_PASSWORD, HELP_MAP),
   path(ADSIPath),
   displayName(displayName_),
   isLoggedOnUser(isLoggedOnUser_)   
{
   LOG_CTOR(SetPasswordDialog);
   ASSERT(!path.empty());
   ASSERT(!displayName.empty());
}
      


SetPasswordDialog::~SetPasswordDialog()
{
   LOG_DTOR(SetPasswordDialog);
}



void
SetPasswordDialog::OnInit()
{
   LOG_FUNCTION(SetPasswordDialog::OnInit());

   Win::SetWindowText(
      hwnd,
      String::format(IDS_SET_PASSWORD_TITLE, displayName.c_str()));
   
   // Load appropriate warning text based on whether the logged on user is
   // setting the password for his own account or another user.

   if (isLoggedOnUser)
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_WARNING_TEXT1,
         IDS_SET_PASSWORD_WARNING_BULLET_SELF1);
      Win::SetDlgItemText(
         hwnd,
         IDC_WARNING_TEXT2,
         IDS_SET_PASSWORD_WARNING_BULLET_SELF2);
   }
   else
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_WARNING_TEXT1,
         IDS_SET_PASSWORD_WARNING_BULLET_OTHER1);
      Win::SetDlgItemText(
         hwnd,
         IDC_WARNING_TEXT2,
         IDS_SET_PASSWORD_WARNING_BULLET_OTHER2);
   }

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_PASSWORD), PWLEN);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_CONFIRM), PWLEN);
}



// // HRESULT
// // setFPNWPassword(
// //    SmartInterface<IADsUser>& user,
// //    const String&           userADSIPath,
// //    const String&           password)
// // {
// //    LOG_FUNCTION2(setFPNWPassword, userADSIPath);
// //    ASSERT(user);
// //    ASSERT(!userADSIPath.empty());
// // 
// //    HRESULT hr = S_OK;
// //    do
// //    {
// //       // determine the secret key
// //       String secret;
// // 
// //       hr =
// //          FPNW::GetLSASecret(
// //             ADSI::PathCracker(userADSIPath).serverName(),
// //             secret);
// //       if (FAILED(hr))
// //       {
// //          // fpnw is not installed, so we're done
// //          LOG(L"fpnw not installed");
// //          hr = S_OK;
// //          break;
// //       }
// // 
// //       // get the user's toxic waste dump
// //       _variant_t variant;
// //       hr = user->Get(AutoBstr(ADSI::PROPERTY_UserParams), &variant);
// //       BREAK_ON_FAILED_HRESULT(hr);
// // 
// //       WasteExtractor dump(V_BSTR(&variant));
// //       variant.Clear();
// // 
// //       // check to see if there is a fpnw password on in the waste dump.
// //       // if present, this implies that the account is fpnw-enabled
// //       hr = dump.IsPropertyPresent(NWPASSWORD);
// //       BREAK_ON_FAILED_HRESULT(hr);
// // 
// //       if (hr == S_FALSE)
// //       {
// //          LOG(L"account not fpnw enabled");
// //          hr = S_OK;
// //          break;
// //       }
// // 
// //       // load up the fpnw client dll.
// //       SafeDLL client_DLL(String::load(IDS_FPNW_CLIENT_DLL));
// // 
// //       // get the object id
// //       DWORD object_id = 0;
// //       DWORD unused = 0;
// //       hr =
// //          FPNW::GetObjectIDs(
// //             user,
// //             client_DLL,
// //             object_id,
// //             unused);
// //       BREAK_ON_FAILED_HRESULT(hr);
// // 
// //       // now we have all the ingredients required.
// // 
// //       hr =
// //          FPNW::SetPassword(
// //             dump,
// //             client_DLL,
// //             password,
// //             secret,
// //             object_id);
// //       BREAK_ON_FAILED_HRESULT(hr);
// // 
// //       // reset the last password set time (which clears the expired flag)
// // 
// //       LARGE_INTEGER li = {0, 0};
// //       ::NtQuerySystemTime(&li);
// // 
// //       hr = dump.Put(NWTIMEPASSWORDSET, li);
// //       BREAK_ON_FAILED_HRESULT(hr);
// // 
// //    }
// //    while (0);
// // 
// //    return hr;
// // }



HRESULT
setPassword(const String& path, const String& password)
{
   LOG_FUNCTION(setPassword);
   ASSERT(!path.empty());

   HRESULT hr = S_OK;
   do
   {
      SmartInterface<IADsUser> user(0);
      hr = ADSI::GetUser(path, user);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = user->SetPassword(AutoBstr(password));
      BREAK_ON_FAILED_HRESULT(hr);

// It appears that IADsUser will set the password for us.

// //       hr = setFPNWPassword(user, path, password);
// //       BREAK_ON_FAILED_HRESULT(hr);
// // 
// //       hr = user->SetInfo();
// //       BREAK_ON_FAILED_HRESULT(hr);
   }
   while(0);

   return hr;
}



bool
SetPasswordDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//    LOG_FUNCTION(SetPasswordDialog::OnCommand);

   switch (controlIDFrom)
   {
      case IDOK:
      {
         if (code == BN_CLICKED)
         {
            if (IsValidPassword(hwnd, IDC_PASSWORD, IDC_CONFIRM))
            {
               String password = Win::GetDlgItemText(hwnd, IDC_PASSWORD);
               HRESULT hr = setPassword(path, password);
               if (SUCCEEDED(hr))
               {
                  popup.Info(
                     hwnd,
                     String::load(IDS_PASSWORD_CHANGE_SUCCESSFUL));

                  HRESULT unused = Win::EndDialog(hwnd, IDOK);

                  ASSERT(SUCCEEDED(unused));
               }
               else
               {
                  Win::SetDlgItemText(hwnd, IDC_PASSWORD, String());
                  Win::SetDlgItemText(hwnd, IDC_CONFIRM, String());
                 
                  popup.Error(
                     hwnd,
                     hr,
                     String::format(
                        IDS_ERROR_SETTING_PASSWORD,            
                        ADSI::ExtractObjectName(path).c_str()));
               }
            }
         }
         break;
      }
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            HRESULT unused = Win::EndDialog(hwnd, IDCANCEL);

            ASSERT(SUCCEEDED(unused));
         }
         break;
      }
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\usergeneralpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// UserGeneralPage class
// 
// 9-9-97 sburns



#ifndef USERGENERALPAGE_HPP_INCLUDED
#define USERGENERALPAGE_HPP_INCLUDED



#include "adsipage.hpp"



class UserGeneralPage : public ADSIPage
{
   public:

   // Constructs a new instance.
   //
   // state - See base class
   //
   // userADSIPath - fully-qualified ADSI pathname of the user account
   // for which properties will be editied.

   UserGeneralPage(
      MMCPropertyPage::NotificationState* state,
      const String&                       userADSIPath);

   virtual ~UserGeneralPage();

   // Dialog overrides

   virtual 
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnApply(bool isClosing);

   private:

   HICON userIcon;

   // not implemented: no copying allowed

   UserGeneralPage(const UserGeneralPage&);
   const UserGeneralPage& operator=(const UserGeneralPage&);
};



#endif   // USERGENERALPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\usermemberpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// UserMemberPage class
// 
// 9-11-97 sburns



#ifndef USERMEMBERPAGE_HPP_INCLUDED
#define USERMEMBERPAGE_HPP_INCLUDED



#include "adsipage.hpp"
#include "MembershipListView.hpp"



class UserMemberPage : public ADSIPage
{
   public:

   // Creates a new instance
   // 
   // state - See base class.
   //
   // userADSIPath - fully-qualified ADSI pathname of the user account
   // for which properties will be editied.

   UserMemberPage(
      MMCPropertyPage::NotificationState* state,
      const String&                       userADSIPath);

   virtual ~UserMemberPage();

   // Dialog overrides

   virtual 
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual 
   void
   OnDestroy();

   virtual
   void
   OnInit();

   virtual
   bool
   OnNotify(
      HWND     windowFrom,
      UINT_PTR controlIDFrom,
      UINT     code,
      LPARAM   lparam);

   // PropertyPage overrides

   virtual
   bool
   OnApply(bool isClosing);

   private:

   HRESULT
   ReconcileMembershipChanges(
      const String&     userADSIPath,
      MemberList        originalGroups,
      const MemberList& newGroups);

   void
   enable();

   MembershipListView*  listview;
   MemberList           original_groups;

   // not implemented: no copying allowed

   UserMemberPage(const UserMemberPage&);
   const UserMemberPage& operator=(const UserMemberPage&);
};



#endif   // USERMEMBERPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\usermemberpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// UserMemberPage class
// 
// 9-11-97 sburns



#include "headers.hxx"
#include "UserMemberPage.hpp"
#include "resource.h"
#include "lsm.h"
#include "adsi.hpp"
#include "MemberVisitor.hpp"
#include "dlgcomm.hpp"



static const DWORD HELP_MAP[] =
{
   IDC_GROUPS,    idh_memberof_list,
   IDC_ADD,       idh_memberof_add,
   IDC_REMOVE,    idh_memberof_remove,
   0, 0
};



UserMemberPage::UserMemberPage(
   MMCPropertyPage::NotificationState* state,
   const String&                       userADSIPath)
   :
   ADSIPage(
      IDD_USER_MEMBER,
      HELP_MAP,
      state,
      userADSIPath)
{
   LOG_CTOR2(UserMemberPage, userADSIPath);
}



UserMemberPage::~UserMemberPage()
{
   LOG_DTOR2(UserMemberPage, GetADSIPath());
}



void
UserMemberPage::OnInit()
{
   LOG_FUNCTION(UserMemberPage::OnInit);

   // Setup the controls

   listview =
      new MembershipListView(
         Win::GetDlgItem(hwnd, IDC_GROUPS),
         GetMachineName(),
         MembershipListView::USER_MEMBERSHIP);

   // load the group properties into the dialog.

   HRESULT hr = S_OK;
   do
   {
      SmartInterface<IADsUser> user(0);
      hr = ADSI::GetUser(GetADSIPath(), user);
      BREAK_ON_FAILED_HRESULT(hr);

      // populate the list with group membership

      MemberVisitor
         visitor(original_groups, hwnd, GetObjectName(), GetMachineName());
      hr = ADSI::VisitGroups(user, visitor);
      BREAK_ON_FAILED_HRESULT(hr);
      listview->SetContents(original_groups);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(IDS_ERROR_READING_USER, GetObjectName().c_str()));
      Win::PostMessage(Win::GetParent(hwnd), WM_CLOSE, 0, 0);
   }

   ClearChanges();
   enable();
}



void
UserMemberPage::enable()
{
   // LOG_FUNCTION(UserMemberPage::enable);

   bool selected =
      Win::ListView_GetSelectedCount(
         Win::GetDlgItem(hwnd, IDC_GROUPS)) > 0;

   HWND removeButton = Win::GetDlgItem(hwnd, IDC_REMOVE);
   
   if (!selected)
   {
      // If we're about to disable the remove button, check to see if it
      // has focus first.  If it does, we need to move focus to another
      // control.  Similarly for default pushbutton style.
      // NTRAID#NTBUG9-435045-2001/07/13-sburns

      if (removeButton == ::GetFocus())
      {
         HWND addButton = Win::GetDlgItem(hwnd, IDC_ADD);
         Win::SetFocus(addButton);
         Win::Button_SetStyle(addButton, BS_DEFPUSHBUTTON, true);
         Win::Button_SetStyle(removeButton, BS_PUSHBUTTON, true);
      }
   }

   Win::EnableWindow(removeButton, selected);
}


bool
UserMemberPage::OnNotify(
   HWND     /* windowFrom */ ,
   UINT_PTR controlIDFrom,
   UINT     code,
   LPARAM   lparam)
{
   LOG_FUNCTION(UserMemberPage::OnNotify);

   switch (controlIDFrom)
   {
      case IDC_GROUPS:
      {
         switch (code)
         {
            case LVN_ITEMCHANGED:
            {
               ASSERT(lparam);

               if (lparam)
               {
                  NMLISTVIEW* lv = reinterpret_cast<NMLISTVIEW*>(lparam);
                  if (lv->uChanged & LVIF_STATE)
                  {
                     // a list item changed state

                     enable();
                  }
               }
               break;
            }
            case LVN_KEYDOWN:
            {
               ASSERT(lparam);

               if (lparam)
               {
                  NMLVKEYDOWN* kd = reinterpret_cast<NMLVKEYDOWN*>(lparam);
                  if (kd->wVKey == VK_INSERT)
                  {
                     listview->OnAddButton();
                  }
                  else if (kd->wVKey == VK_DELETE)
                  {
                     listview->OnRemoveButton();
                  }
               }
               break;
            }
            case LVN_INSERTITEM:
            case LVN_DELETEITEM:
            {
               SetChanged(controlIDFrom);
               Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
               break;
            }
            default:
            {
               break;
            }
         }
         break;
      }
      default:
      {
      }
   }

   return true;
}



void
UserMemberPage::OnDestroy()
{
   LOG_FUNCTION(UserMemberPage::OnDestroy);
   
   delete listview;
   listview = 0;
}



bool
UserMemberPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//    LOG_FUNCTION(UserMemberPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_ADD:
      {
         if (code == BN_CLICKED)
         {
            listview->OnAddButton();
         }
         break;
      }
      case IDC_REMOVE:
      {
         if (code == BN_CLICKED)
         {
            listview->OnRemoveButton();
         }
         break;
      }
      default:
      {
         break;
      }
   }

   return true;
}



bool
UserMemberPage::OnApply(bool isClosing)
{
   LOG_FUNCTION(UserMemberPage::OnApply);

   if (WasChanged(IDC_GROUPS))
   {
      // save the changes thru ADSI

      HRESULT hr = S_OK;
      do
      {
         SmartInterface<IADsUser> user(0);
         hr = ADSI::GetUser(GetADSIPath(), user);
         BREAK_ON_FAILED_HRESULT(hr);

         SmartInterface<IADs> iads(0);
         hr = iads.AcquireViaQueryInterface(user);
         BREAK_ON_FAILED_HRESULT(hr);

         String sidPath;
         hr = ADSI::GetSidPath(iads, sidPath);
         BREAK_ON_FAILED_HRESULT(hr);

         MemberList new_groups;
         listview->GetContents(new_groups);
         hr =
            ReconcileMembershipChanges(
               sidPath,
               original_groups,
               new_groups);
         BREAK_ON_FAILED_HRESULT(hr);

         if (!isClosing)
         {
            // refresh the listview

            original_groups.clear();
            MemberVisitor
               visitor(
                  original_groups,
                  hwnd,
                  GetObjectName(),
                  GetMachineName());
            hr = ADSI::VisitGroups(user, visitor);
            BREAK_ON_FAILED_HRESULT(hr);
            listview->SetContents(original_groups);
         }

         SetChangesApplied();
         ClearChanges();
      }
      while (0);

      if (FAILED(hr))
      {
         popup.Error(
            hwnd,
            hr,
            String::format(
               IDS_ERROR_SETTING_USER_PROPERTIES,            
               GetObjectName().c_str(),
               GetMachineName().c_str()));
      }
   }

   return true;
}



HRESULT
UserMemberPage::ReconcileMembershipChanges(
   const String&     userADSIPath,
   MemberList        originalGroups,   // a copy
   const MemberList& newGroups)
{
   LOG_FUNCTION2(UserMemberPage::ReconcileMembershipChanges, userADSIPath);
   ASSERT(!userADSIPath.empty());

   bool successful = true; // be optimistic!
   HRESULT hr = S_OK;
   for (
      MemberList::iterator i = newGroups.begin();
      i != newGroups.end();
      i++)
   {
      MemberInfo& info = *i;

      MemberList::iterator f =
         std::find(originalGroups.begin(), originalGroups.end(), info);
      if (f != originalGroups.end())
      {
         // found.  remove the matching node in the original list

         originalGroups.erase(f);
      }
      else
      {
         // not found.  Add the user as a member of the group

         SmartInterface<IADsGroup> group(0);
         hr = ADSI::GetGroup(info.path, group);
         if (SUCCEEDED(hr))
         {
            hr = group->Add(AutoBstr(userADSIPath));

            if (hr == Win32ToHresult(ERROR_MEMBER_IN_ALIAS))
            {
               // already a member: pop up a warning but don't consider this
               // a real error. 6791

               hr = S_OK;

               String name = GetObjectName();
               BSTR groupName;
               HRESULT anotherHr = group->get_Name(&groupName);
               if (SUCCEEDED(anotherHr))
               {
                  popup.Info(
                     hwnd,
                     String::format(
                        IDS_ALREADY_MEMBER,
                        name.c_str(),
                        groupName));
                  ::SysFreeString(groupName);
               }
            }
         }
            
         if (FAILED(hr))
         {
            LOG_HRESULT(hr);
            successful = false;
         }
      }
   }

   // at this point, the original list contains only those nodes which are
   // not in the new list.  Remove these from the group membership

   for (
      i = originalGroups.begin();
      i != originalGroups.end();
      i++)
   {
      SmartInterface<IADsGroup> group(0);
      hr = ADSI::GetGroup(i->path, group);
      if (SUCCEEDED(hr))
      {
         hr = group->Remove(AutoBstr(userADSIPath));

         // CODEWORK: what if the member is not part of the group?
      }

      if (FAILED(hr))
      {
         LOG_HRESULT(hr);
         successful = false;
      }
   }

   if (!successful)
   {
      popup.Error(
         hwnd,
         0,
         String::format(
            IDS_ERROR_CHANGING_MEMBERSHIP,
            GetObjectName().c_str()));
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\userfpnwpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// UserFpnwPage class
// 
// 9-11-98 sburns
//
// This should have been implemented as an extension snapin, like the RAS
// page, but the FPNW managers didn't get around to finding dev resources
// until way, way too late.



#ifndef USERFPNWPAGE_HPP_INCLUDED
#define USERFPNWPAGE_HPP_INCLUDED



#include "adsipage.hpp"
#include "waste.hpp"



class UserFpnwPage : public ADSIPage
{
   public:

   // Constructs a new instance.
   //
   // state - See base class
   //
   // userADSIPath - fully-qualified ADSI pathname of the user account
   // for which properties will be editied.

   UserFpnwPage(
      MMCPropertyPage::NotificationState* state,
      const String&                       userADSIPath);


      
   virtual
   ~UserFpnwPage();
   

   
   // Dialog overrides

   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual 
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnApply(bool isClosing);

   virtual
   bool
   OnKillActive();

   private:

   String
   MassagePath(const String& path);

   HRESULT
   ReadLoginScript();

   HRESULT
   WriteLoginScript();

   HRESULT
   SavePassword(
      const SmartInterface<IADsUser>&  user,
      WasteExtractor&                  dump,
      const String&                    newPassword);

   bool
   Validate();

   DWORD    maxPasswordAge;
   DWORD    minPasswordLen;
   DWORD    objectId;
   SafeDLL  clientDll;
   String   loginScriptFilename;
   bool     scriptRead;
   String   loginScript;
   bool     fpnwEnabled;

   // not defined: no copying allowed

   UserFpnwPage(const UserFpnwPage&);
   const UserFpnwPage& operator=(const UserFpnwPage&);
};



#endif   // USERFPNWPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\userfpnwpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// UserFpnwPage class
//
// 9-11-98 sburns



#include "headers.hxx"
#include "UserFpnwPage.hpp"
#include "resource.h"
#include "dlgcomm.hpp"
#include "adsi.hpp"
#include "waste.hpp"
#include "fpnwlog.hpp"
#include "fpnwpass.hpp"
#include "fpnw.hpp"



static const String FPNWVOLUMEGETINFO(L"FpnwVolumeGetInfo");
typedef DWORD (*FPNWVolumeGetInfo)(PWSTR, PWSTR, DWORD, PBYTE*);

static const String FPNWAPIBUFFERFREE(L"FpnwApiBufferFree");
typedef DWORD (*FPNWApiBufferFree)(PVOID);

static const int MAX_GRACE_LOGINS = 200;
static const int MAX_CONNECTIONS = 1000;



static const int NO_GRACE_LOGIN_LIMIT=0xFF; // net\ui\admin\user\user\ncp.cxx
static const DWORD MAX_PASSWORD_AGE = static_cast<DWORD>(-1);


static const DWORD HELP_MAP[] =
{
   IDC_CONCURRENT_CONNECTIONS,   NO_HELP,
   IDC_CONNECTION_LIMIT,         NO_HELP,
   IDC_CONNECTION_SPIN,          NO_HELP,
   IDC_GRACE_LIMIT,              NO_HELP,
   IDC_GRACE_LIMIT,              NO_HELP,
   IDC_GRACE_LOGINS,             NO_HELP,
   IDC_GRACE_REMAINING,          NO_HELP,
   IDC_GRACE_REMAINING_SPIN,     NO_HELP,
   IDC_GRACE_REMAINING_TEXT,     NO_HELP,
   IDC_GRACE_SPIN,               NO_HELP,
   IDC_LIMIT_CONNECTIONS,        NO_HELP,
   IDC_LIMIT_CONNECTIONS,        NO_HELP,
   IDC_LIMIT_GRACELOGINS,        NO_HELP,
   IDC_LIMIT_GRACELOGINS,        NO_HELP,
   IDC_NETWARE_ENABLE,           NO_HELP,
   IDC_NWHMDIR_RELPATH,          NO_HELP,
   IDC_NWHMDIR_RELPATH_TEXT,     NO_HELP,
   IDC_NWPWEXPIRED,              NO_HELP,
   IDC_OBJECTID_TEXT,            NO_HELP,
   IDC_OBJECT_ID,                NO_HELP,
   IDC_SCRIPT_BUTTON,            NO_HELP,
   IDC_UNLIMITED_CONNECTIONS,    NO_HELP,
   IDC_UNLIMITED_GRACELOGINS,    NO_HELP,
   0, 0
};



UserFpnwPage::UserFpnwPage(
   MMCPropertyPage::NotificationState* state,
   const String&                       userADSIPath)
   :
   ADSIPage(
      IDD_USER_FPNW,
      HELP_MAP,
      state,
      userADSIPath),
   maxPasswordAge(MAX_PASSWORD_AGE),
   minPasswordLen(0),
   clientDll(String::load(IDS_FPNW_CLIENT_DLL)),
   scriptRead(false),
   fpnwEnabled(false),
   objectId(0)
{
   LOG_CTOR2(UserFpnwPage::ctor, userADSIPath);
}



UserFpnwPage::~UserFpnwPage()
{
   LOG_DTOR2(UserFpnwPage, GetADSIPath());
}



static
void
Enable(HWND dialog)
{
   LOG_FUNCTION(Enable);
   ASSERT(Win::IsWindow(dialog));

   // this checkbox determines if the rest of the controls on the page
   // are enabled or not.

   bool maintain_login =
      Win::IsDlgButtonChecked(dialog, IDC_NETWARE_ENABLE);

   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_NWPWEXPIRED),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_GRACE_LOGINS),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_UNLIMITED_GRACELOGINS),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_LIMIT_GRACELOGINS),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_CONCURRENT_CONNECTIONS),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_UNLIMITED_CONNECTIONS),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_LIMIT_CONNECTIONS),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_OBJECTID_TEXT),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_OBJECT_ID),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_NWHMDIR_RELPATH_TEXT),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_NWHMDIR_RELPATH),
      maintain_login);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_SCRIPT_BUTTON),
      maintain_login);

   bool limit_grace_logins =
      Win::IsDlgButtonChecked(dialog, IDC_LIMIT_GRACELOGINS);

   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_GRACE_LIMIT),
      maintain_login && limit_grace_logins);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_GRACE_SPIN),
      maintain_login && limit_grace_logins);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_GRACE_REMAINING),
      maintain_login && limit_grace_logins);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_GRACE_REMAINING_TEXT),
      maintain_login && limit_grace_logins);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_GRACE_LIMIT),
      maintain_login && limit_grace_logins);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_GRACE_REMAINING_SPIN),
      maintain_login && limit_grace_logins);

   bool limitConnections =
      Win::IsDlgButtonChecked(dialog, IDC_LIMIT_CONNECTIONS);

   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_CONNECTION_LIMIT),
      maintain_login && limitConnections);
   Win::EnableWindow(
      Win::GetDlgItem(dialog, IDC_CONNECTION_SPIN),
      maintain_login && limitConnections);
}



HRESULT
GetPasswordRestrictions(
   const String&  machine,
   DWORD&         minimumPasswordLength,
   DWORD&         maximumPasswordAge)
{
   LOG_FUNCTION(GetPasswordRestrictions);
   ASSERT(!machine.empty());

   HRESULT hr = S_OK;
   USER_MODALS_INFO_0 *info = 0;

   minimumPasswordLength = 0;
   maximumPasswordAge = MAX_PASSWORD_AGE;

   // the Net API's don't work when the
   // specified machine name is that of the local machine...

   PCWSTR m = Win::IsLocalComputer(machine) ? 0 : machine.c_str();

   LOG(L"Calling NetUserModalsGet");
   LOG(String::format(L"servername : %1", m ? m : L"(null)"));
   LOG(               L"level      : 0");

   NET_API_STATUS status =
      ::NetUserModalsGet(
         m,
         0,
         reinterpret_cast<BYTE**>(&info));

   if (status == NERR_Success)
   {
      minimumPasswordLength = info->usrmod0_min_passwd_len;
      maximumPasswordAge = info->usrmod0_max_passwd_age;
   }
   else
   {
      hr = Win32ToHresult(status);
   }

   if (info)
   {
      NetApiBufferFree(info);
   }

   LOG(String::format(L"Result 0x%1!X!", hr));

   return hr;
}



// compare the given time to the current system clock reading.  return true
// if the time is beyond the maximum, false otherwise

bool
IsPasswordExpired(const LARGE_INTEGER& lastTimeSet, DWORD maxPasswordAge)
{
   LOG_FUNCTION(IsPasswordExpired);
   ASSERT(lastTimeSet.LowPart);
   ASSERT(lastTimeSet.HighPart);
   ASSERT(maxPasswordAge);

   DWORD age = 0;

   if (
         (lastTimeSet.LowPart == 0xffffffff)
      && (lastTimeSet.HighPart == 0xffffffff) )
   {
      age = 0xffffffff;
   }
   else
   {
      LARGE_INTEGER now = {0, 0};
      LARGE_INTEGER delta = {0, 0};

      ::NtQuerySystemTime(&now);

      delta.QuadPart = now.QuadPart - lastTimeSet.QuadPart;
      delta.QuadPart /= 10000000;   // time resolution in seconds

      // @@ this truncation makes me queasy.

      age = delta.LowPart;
   }

   return (age >= maxPasswordAge);
}



HRESULT
determineLoginScriptFilename(
   const SafeDLL& clientDLL,
   const String&  machine,
   DWORD          swappedObjectID,
   String&        result)
{
   LOG_FUNCTION(DetermineLoginScriptFilename);
   ASSERT(swappedObjectID);
   ASSERT(!machine.empty());

   result.erase();

   HRESULT hr = S_OK;
   do
   {
      FARPROC f = 0;

      hr = clientDLL.GetProcAddress(FPNWVOLUMEGETINFO, f);
      BREAK_ON_FAILED_HRESULT(hr);

      FPNWVOLUMEINFO* info = 0;
      DWORD err =
         ((FPNWVolumeGetInfo) f)(
            const_cast<wchar_t*>(machine.c_str()),
            SYSVOL_NAME_STRING,
            1,
            reinterpret_cast<PBYTE*>(&info));
      if (err != NERR_Success)
      {
         hr = Win32ToHresult(err);
      }
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(info);
      String volume = info->lpPath;

      // one could argue that this isn't really fatal, but I'm in bad mood.
      hr = clientDLL.GetProcAddress(FPNWAPIBUFFERFREE, f);
      BREAK_ON_FAILED_HRESULT(hr);

      ((FPNWApiBufferFree) f)(info);

      result =
         String::format(
            L"%1\\MAIL\\%2!x!\\LOGIN",
            volume.c_str(),
            swappedObjectID);
   }
   while (0);

   return hr;
}



void
UserFpnwPage::OnInit()
{
   LOG_FUNCTION(UserFpnwPage::OnInit());

   // load the user properties into the dialog, setup the controls

   HRESULT hr = S_OK;
   do
   {
      SmartInterface<IADsUser> user(0);
      hr = ADSI::GetUser(GetADSIPath(), user);
      BREAK_ON_FAILED_HRESULT(hr);

      // retrieve the toxic waste dump

      _variant_t variant;
      hr = user->Get(AutoBstr(ADSI::PROPERTY_UserParams), &variant);
      BREAK_ON_FAILED_HRESULT(hr);

      WasteExtractor dump(V_BSTR(&variant));
      variant.Clear();

      //
      // object ID
      //

      DWORD swappedObjectId = 0;
      hr =
         FPNW::GetObjectIDs(
            user,
            clientDll,
            objectId,
            swappedObjectId);
      BREAK_ON_FAILED_HRESULT(hr);

      // the object ID we display is the "swapped" version, whatever that
      // means.

      Win::SetDlgItemText(
         hwnd,
         IDC_OBJECT_ID,
         String::format(L"%1!08X!", swappedObjectId));

      //
      // login script filename
      //

      hr =
         determineLoginScriptFilename(
            clientDll,
            GetMachineName(),
            swappedObjectId,
            loginScriptFilename);
      BREAK_ON_FAILED_HRESULT(hr);

      // the presence/absence of a NetWare password is the flag indicating
      // whether the acccount is FPNW-enabled

      hr = dump.IsPropertyPresent(NWPASSWORD);
      BREAK_ON_FAILED_HRESULT(hr);

      fpnwEnabled = (hr == S_OK);

      Win::CheckDlgButton(
         hwnd,
         IDC_NETWARE_ENABLE,
         fpnwEnabled ? BST_CHECKED : BST_UNCHECKED);

      USHORT graceLoginsAllowed   = DEFAULT_GRACELOGINALLOWED;  
      USHORT graceLoginsRemaining = DEFAULT_GRACELOGINREMAINING;
      USHORT maxConnections       = 1;                          
      bool   limitGraceLogins     = true;                       
      bool   limitConnections     = false;                      

      if (fpnwEnabled)
      {
         // the other fields are only valid if we're enabling the account
         // for fpnw access.

         //
         // password expired
         //

         hr =
            GetPasswordRestrictions(
               GetMachineName(),
               minPasswordLen,
               maxPasswordAge);
         BREAK_ON_FAILED_HRESULT(hr);

         LARGE_INTEGER lastTimeSet = {0, 0};
         hr = dump.Get(NWTIMEPASSWORDSET, lastTimeSet);
         BREAK_ON_FAILED_HRESULT(hr);

         // an S_FALSE result would indicate that no password last time set was
         // present, which would be an inconsistency

         ASSERT(hr == S_OK);

         bool passwordExpired = true;
         if (hr == S_OK)
         {
            passwordExpired = IsPasswordExpired(lastTimeSet, maxPasswordAge);
         }

         Win::CheckDlgButton(
            hwnd,
            IDC_NWPWEXPIRED,
            passwordExpired ? BST_CHECKED : BST_UNCHECKED);

         //
         // grace logins
         //

         hr = dump.Get(GRACELOGINALLOWED, graceLoginsAllowed);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = dump.Get(GRACELOGINREMAINING, graceLoginsRemaining);
         BREAK_ON_FAILED_HRESULT(hr);

         limitGraceLogins =
            (graceLoginsRemaining != NO_GRACE_LOGIN_LIMIT);

         //
         // concurrent connections
         //

         hr = dump.Get(MAXCONNECTIONS, maxConnections);
         BREAK_ON_FAILED_HRESULT(hr);

         // if the property is not present, then we consider the connections
         // unlimited.

         if (hr == S_FALSE)
         {
            maxConnections = NO_LIMIT;
         }

         limitConnections = (maxConnections != NO_LIMIT);

         //
         // home directory
         //

         String homeDir;
         hr = dump.Get(NWHOMEDIR, homeDir);
         BREAK_ON_FAILED_HRESULT(hr);

         Win::SetDlgItemText(hwnd, IDC_NWHMDIR_RELPATH, homeDir);
      }

      // update the UI to reflect the values set (or, in the case that
      // the account is not FPNW-enabled, the defaults)

      Win::CheckRadioButton(
         hwnd,
         IDC_UNLIMITED_GRACELOGINS,
         IDC_LIMIT_GRACELOGINS,
            limitGraceLogins
         ?  IDC_LIMIT_GRACELOGINS
         :  IDC_UNLIMITED_GRACELOGINS);

      HWND spin = Win::GetDlgItem(hwnd, IDC_GRACE_SPIN);
      Win::Spin_SetRange(spin, 1, MAX_GRACE_LOGINS);
      Win::Spin_SetPosition(spin, graceLoginsAllowed);

      spin = Win::GetDlgItem(hwnd, IDC_GRACE_REMAINING_SPIN);
      Win::Spin_SetRange(spin, 0, graceLoginsAllowed);
      Win::Spin_SetPosition(
         spin,
         min(graceLoginsRemaining, graceLoginsAllowed));

      Win::CheckRadioButton(
         hwnd,
         IDC_UNLIMITED_CONNECTIONS,
         IDC_LIMIT_CONNECTIONS,
            limitConnections
         ?  IDC_LIMIT_CONNECTIONS
         :  IDC_UNLIMITED_CONNECTIONS);

      spin = Win::GetDlgItem(hwnd, IDC_CONNECTION_SPIN);
      Win::Spin_SetRange(spin, 1, MAX_CONNECTIONS);
      Win::Spin_SetPosition(
         spin,
         limitConnections ? maxConnections : 1);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_READING_USER,
            GetObjectName().c_str()));
      Win::PostMessage(Win::GetParent(hwnd), WM_CLOSE, 0, 0);
   }

   ClearChanges();
   Enable(hwnd);
}



bool
UserFpnwPage::Validate()
{
   LOG_FUNCTION(UserFpnwPage::Validate);

   bool result = true;
   do
   {
      if (WasChanged(IDC_NWHMDIR_RELPATH))
      {
         // validate the home dir as a relative path

         String homedir = Win::GetTrimmedDlgItemText(hwnd, IDC_NWHMDIR_RELPATH);

         if (homedir.empty())
         {
            // no path is ok

            break;
         }

         if (FS::GetPathSyntax(homedir) != FS::SYNTAX_RELATIVE_NO_DRIVE)
         {
            popup.Gripe(
               hwnd,
               IDC_NWHMDIR_RELPATH,
               String::format(
                  IDS_BAD_FPNW_HOMEDIR,
                  homedir.c_str(),
                  GetObjectName().c_str()));
            result = false;
            break;
         }
      }
   }
   while (0);

   return result;
}



bool
UserFpnwPage::OnKillActive()
{
   LOG_FUNCTION(UserFpnwPage::OnKillActive);

   if (!Validate())
   {
      // refuse to relinquish focus
      Win::SetWindowLongPtr(hwnd, DWLP_MSGRESULT, TRUE);
   }

   return true;
}



HRESULT
SetUserFlag(
   const SmartInterface<IADsUser>&  user,
   DWORD                            flag,
   bool                             state)
{
   LOG_FUNCTION(SetUserFlag);

   HRESULT hr = S_OK;

   do
   {
      // read the existing flags

      _variant_t getVariant;

      hr = user->Get(AutoBstr(ADSI::PROPERTY_UserFlags), &getVariant);
      BREAK_ON_FAILED_HRESULT(hr);

      long flags = getVariant;

      // set the flag

      if (state)
      {
         flags |= flag;
      }
      else
      {
         flags &= ~flag;
      }

      _variant_t putVariant(flags);

      hr = user->Put(AutoBstr(ADSI::PROPERTY_UserFlags), putVariant);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



HRESULT
UserFpnwPage::SavePassword(
   const SmartInterface<IADsUser>&  user,
   WasteExtractor&                  dump,
   const String&                    newPassword)
{
   LOG_FUNCTION(UserFpnwPage::SavePassword);

   HRESULT hr = S_OK;
   do
   {
      // change the user's NT password also

      hr = user->SetPassword(AutoBstr(newPassword));
      BREAK_ON_FAILED_HRESULT(hr);

      String secret;
      hr =
         FPNW::GetLSASecret(
            ADSI::PathCracker(GetADSIPath()).serverName(),
            secret);
      BREAK_ON_FAILED_HRESULT(hr);

      hr =
         FPNW::SetPassword(
            dump,
            clientDll,
            newPassword,
            secret,
            objectId);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



bool
UserFpnwPage::OnApply(bool /* isClosing */)
{
   LOG_FUNCTION(UserFpnwPage::OnApply);

   if (!WasChanged())
   {
      return true;
   }

   // don't need to call validate; kill active is sent before apply

   HRESULT hr = S_OK;
   do
   {
      SmartInterface<IADsUser> user(0);
      hr = ADSI::GetUser(GetADSIPath(), user);
      BREAK_ON_FAILED_HRESULT(hr);

      // re-read the waste dump

      _variant_t variant;
      hr = user->Get(AutoBstr(ADSI::PROPERTY_UserParams), &variant);
      BREAK_ON_FAILED_HRESULT(hr);

      WasteExtractor dump(V_BSTR(&variant));
      variant.Clear();

      // save the changes, creating a new waste dump

      bool maintainLogin =
         Win::IsDlgButtonChecked(hwnd, IDC_NETWARE_ENABLE);

      String password;

      if (!maintainLogin)
      {
         // clear the waste dump
         hr = dump.Clear(NWPASSWORD);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = dump.Clear(NWTIMEPASSWORDSET);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = dump.Clear(GRACELOGINALLOWED);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = dump.Clear(GRACELOGINREMAINING);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = dump.Clear(MAXCONNECTIONS);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = dump.Clear(NWHOMEDIR);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = SetUserFlag(user, UF_MNS_LOGON_ACCOUNT, false);
         BREAK_ON_FAILED_HRESULT(hr);
      }
      else
      {
         if (maintainLogin != fpnwEnabled)
         {
            // we're enabling the account for FPNW, so get a password from
            // the user.  Writing the Netware password into the waste dump
            // is the flag that this account is fpnw-enabled.

            FPNWPasswordDialog dlg(GetObjectName());
            if (dlg.ModalExecute(hwnd) == IDCANCEL)
            {
               // bail out if the user hits cancel on the password dialog
               // 89677

               hr = S_FALSE;
               break;
            }

            hr = SetUserFlag(user, UF_MNS_LOGON_ACCOUNT, true);
            BREAK_ON_FAILED_HRESULT(hr);

            password = dlg.GetPassword();

            hr = SavePassword(user, dump, password);
            BREAK_ON_FAILED_HRESULT(hr);

            // Create login script folder, if necessary

            String parentFolder = FS::GetParentFolder(loginScriptFilename);
            if (!FS::PathExists(parentFolder))
            {
               HRESULT anotherHr = FS::CreateFolder(parentFolder);

               // don't break on failure: continue on

               LOG_HRESULT(anotherHr);
            }

            // ensure that the new time and default settings are recorded

            SetChanged(IDC_NWPWEXPIRED);
            SetChanged(IDC_LIMIT_GRACELOGINS);
            SetChanged(IDC_LIMIT_CONNECTIONS);
         }

         if (WasChanged(IDC_NWPWEXPIRED))
         {
            LARGE_INTEGER li = {0, 0};
            if (Win::IsDlgButtonChecked(hwnd, IDC_NWPWEXPIRED))
            {
               li.HighPart = -1;
               li.LowPart = static_cast<DWORD>(-1);
            }
            else
            {
               ::NtQuerySystemTime(&li);
            }

            hr = dump.Put(NWTIMEPASSWORDSET, li);
            BREAK_ON_FAILED_HRESULT(hr);
         }

         if (
               WasChanged(IDC_LIMIT_GRACELOGINS)
            || WasChanged(IDC_UNLIMITED_GRACELOGINS)
            || WasChanged(IDC_GRACE_LIMIT)
            || WasChanged(IDC_GRACE_REMAINING) )
         {
            bool limitGraceLogins =
               Win::IsDlgButtonChecked(hwnd, IDC_LIMIT_GRACELOGINS);

            USHORT graceLoginsAllowed = DEFAULT_GRACELOGINALLOWED;
            USHORT graceLoginsRemaining = NO_GRACE_LOGIN_LIMIT;
            if (limitGraceLogins)
            {
               String s = Win::GetTrimmedDlgItemText(hwnd, IDC_GRACE_LIMIT);
               s.convert(graceLoginsAllowed);

               s = Win::GetTrimmedDlgItemText(hwnd, IDC_GRACE_REMAINING);
               s.convert(graceLoginsRemaining);
            }

            hr = dump.Put(GRACELOGINALLOWED, graceLoginsAllowed);
            BREAK_ON_FAILED_HRESULT(hr);

            hr = dump.Put(GRACELOGINREMAINING, graceLoginsRemaining);
            BREAK_ON_FAILED_HRESULT(hr);
         }

         if (
               WasChanged(IDC_UNLIMITED_CONNECTIONS)
            || WasChanged(IDC_LIMIT_CONNECTIONS)
            || WasChanged(IDC_CONNECTION_LIMIT) )
         {
            bool limitConnections =
               Win::IsDlgButtonChecked(hwnd, IDC_LIMIT_CONNECTIONS);

            USHORT maxConnections = 0;
            if (!limitConnections)
            {
               maxConnections = NO_LIMIT;
            }
            else
            {
               String s =
                  Win::GetTrimmedDlgItemText(hwnd, IDC_CONNECTION_LIMIT);
               s.convert(maxConnections);
            }

            hr = dump.Put(MAXCONNECTIONS, maxConnections);
            BREAK_ON_FAILED_HRESULT(hr);
         }

         if (WasChanged(IDC_NWHMDIR_RELPATH))
         {
            hr =
               dump.Put(
                  NWHOMEDIR,
                  Win::GetTrimmedDlgItemText(hwnd, IDC_NWHMDIR_RELPATH));
            BREAK_ON_FAILED_HRESULT(hr);
         }

         if (WasChanged(IDC_SCRIPT_BUTTON))
         {
            WriteLoginScript();
         }
      }

      // update the user params with the new waste dump

      _variant_t v;
      v = dump.GetWasteDump().c_str();
      hr = user->Put(AutoBstr(ADSI::PROPERTY_UserParams), v);
      BREAK_ON_FAILED_HRESULT(hr);

      // commit the property changes

      hr = user->SetInfo();
      BREAK_ON_FAILED_HRESULT(hr);

// {
//       _variant_t variant;
//       hr = user->Get(AutoBstr(ADSI::PROPERTY_UserParams), &variant);
//       BREAK_ON_FAILED_HRESULT(hr);
// 
//       WasteExtractor dump(V_BSTR(&variant));
//       variant.Clear();
// }


      if (maintainLogin and maintainLogin != fpnwEnabled)
      {
         SmartInterface<IADsUser> user1(0);
         hr = ADSI::GetUser(GetADSIPath(), user1);
         BREAK_ON_FAILED_HRESULT(hr);

         // we're enabling the account for fpnw, and it wasn't enabled
         // before.

         // It would appear that one has to update the account flags and
         // scribble a password into the waste dump, then set the password
         // again once those changes are committed, in order for the
         // password setting to really stick.

         hr = user1->SetPassword(AutoBstr(password));
         BREAK_ON_FAILED_HRESULT(hr);

         // Setting the password resets the grace logins remaining, so
         // if that was changed, then we need to re-write that value
         // here.
         //
         // For reasons that are unfathomable to me (which I suspect are
         // due to ADSI bug(s)), if I don't reset this value on a separate
         // binding to the user account, then it causes the account to
         // change such that the user cannot login in with fpnw.
         // That's why we rebind to the account in this scope.

         _variant_t variant1;
         hr = user1->Get(AutoBstr(ADSI::PROPERTY_UserParams), &variant1);
         BREAK_ON_FAILED_HRESULT(hr);

         WasteExtractor dump1(V_BSTR(&variant1));
         variant1.Clear();

         USHORT graceLoginsRemaining = NO_GRACE_LOGIN_LIMIT;

         String s = Win::GetTrimmedDlgItemText(hwnd, IDC_GRACE_REMAINING);
         s.convert(graceLoginsRemaining);

         hr = dump1.Put(GRACELOGINREMAINING, graceLoginsRemaining);
         BREAK_ON_FAILED_HRESULT(hr);

         // We write this again, as setting the password appears to
         // clear it.

         LARGE_INTEGER li = {0, 0};
         if (Win::IsDlgButtonChecked(hwnd, IDC_NWPWEXPIRED))
         {
            li.HighPart = -1;
            li.LowPart = static_cast<DWORD>(-1);
         }
         else
         {
            ::NtQuerySystemTime(&li);
         }

         hr = dump1.Put(NWTIMEPASSWORDSET, li);
         BREAK_ON_FAILED_HRESULT(hr);

         _variant_t variant2;
         variant2 = dump1.GetWasteDump().c_str();
         hr = user1->Put(AutoBstr(ADSI::PROPERTY_UserParams), variant2);
         BREAK_ON_FAILED_HRESULT(hr);

         hr = user1->SetInfo();
         BREAK_ON_FAILED_HRESULT(hr);
      }

// {
//       SmartInterface<IADsUser> user(0);
//       hr = ADSI::GetUser(GetADSIPath(), user);
//       BREAK_ON_FAILED_HRESULT(hr);
// 
//       _variant_t variant;
//       hr = user->Get(AutoBstr(ADSI::PROPERTY_UserParams), &variant);
//       BREAK_ON_FAILED_HRESULT(hr);
// 
//       WasteExtractor dump(V_BSTR(&variant));
//       variant.Clear();
// }

      // set this so we don't ask for another password if the user keeps
      // the propsheet open and makes more changes

      fpnwEnabled = maintainLogin;

      SetChangesApplied();
      ClearChanges();
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_SETTING_USER_PROPERTIES,
            GetObjectName().c_str()));
   }

   return true;
}



HRESULT
UserFpnwPage::ReadLoginScript()
{
   LOG_FUNCTION(UserFpnwPage::ReadLoginScript);
   ASSERT(!scriptRead);
   ASSERT(!loginScriptFilename.empty());

   HRESULT hr = S_OK;
   HANDLE file = INVALID_HANDLE_VALUE;

   do
   {
      Win::CursorSetting cursor(IDC_WAIT);

      if (FS::PathExists(loginScriptFilename))
      {
         hr = FS::CreateFile(loginScriptFilename, file);
         BREAK_ON_FAILED_HRESULT(hr);

         AnsiString text;
         hr = FS::Read(file, -1, text);
         BREAK_ON_FAILED_HRESULT(hr);

         // this assign converts the ansi text to unicode

         loginScript = String(text);
         scriptRead = true;
      }
   }
   while (0);

   if (file != INVALID_HANDLE_VALUE)
   {
      Win::CloseHandle(file);
   }

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         IDS_FPNW_ERROR_READING_SCRIPT);
   }

   return hr;
}



HRESULT
UserFpnwPage::WriteLoginScript()
{
   LOG_FUNCTION(UserFpnwPage::WriteLoginScript);

   HRESULT hr = S_OK;
   HANDLE file = INVALID_HANDLE_VALUE;

   do
   {
      Win::CursorSetting cursor(IDC_WAIT);

      hr =
         FS::CreateFile(
            loginScriptFilename,
            file,
            GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,

            // erase the existing file, if any

            CREATE_ALWAYS);
      BREAK_ON_FAILED_HRESULT(hr);

      // convert the unicode text to ansi
      AnsiString ansi;
      loginScript.convert(ansi);

      if (ansi.length())
      {
         hr = FS::Write(file, ansi);
         BREAK_ON_FAILED_HRESULT(hr);
      }
   }
   while (0);

   Win::CloseHandle(file);      

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         IDS_FPNW_ERROR_WRITING_SCRIPT);
   }

   return hr;
}



bool
UserFpnwPage::OnCommand(
   HWND        windowFrom,
   unsigned    controlIDFrom,
   unsigned    code)
{
//    LOG_FUNCTION(UserFpnwPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_GRACE_LIMIT:
      {
         switch (code)
         {
            case EN_CHANGE:
            {
               SetChanged(controlIDFrom);
               Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);

               break;
            }
            case EN_KILLFOCUS:
            {
               // check the limits against the contents of the control,
               // change the contents to be within the limits.

               String allowed = Win::GetTrimmedWindowText(windowFrom);
               int a = 0;
               allowed.convert(a);
               if (a < 1 || a > MAX_GRACE_LOGINS)
               {
                  a = max(1, min(a, MAX_GRACE_LOGINS));
                  Win::SetWindowText(
                     windowFrom,
                     String::format(L"%1!d!", a));
               }

               // also change the upper limit on the remaining logins to
               // match the new allowed logins value.
               HWND spin = Win::GetDlgItem(hwnd, IDC_GRACE_REMAINING_SPIN);
               Win::Spin_SetRange(spin, 1, a);

               // (this removes the selection from the buddy edit box,
               // which I consider a bug in the up-down control)
               Win::Spin_SetPosition(spin, a);

               break;
            }
            default:
            {
               // do nothing
               break;
            }
         }

         break;
      }
      case IDC_GRACE_REMAINING:
      {
         switch (code)
         {
            case EN_CHANGE:
            {
               SetChanged(controlIDFrom);
               Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);

               break;
            }
            case EN_KILLFOCUS:
            {
               // check the contents of the control against the allowed field,
               // change the contents to be within the limits.

               String allowed = Win::GetTrimmedDlgItemText(hwnd, IDC_GRACE_LIMIT);
               String remaining = Win::GetTrimmedWindowText(windowFrom);

               int a = 0;
               int r = 0;
               allowed.convert(a);
               remaining.convert(r);

               if (a == 0)
               {
                  // the conversion failed somehow, so use the max value

                  a = MAX_GRACE_LOGINS;
               }
               if (r < 0 || r > a)
               {
                  r = max(0, min(r, a));
                  Win::SetWindowText(
                     windowFrom,
                     String::format(L"%1!d!", r));
               }
               break;
            }
            default:
            {
               // do nothing
               break;
            }
         }

         break;
      }
      case IDC_CONNECTION_LIMIT:
      {
         switch (code)
         {
            case EN_CHANGE:
            {
               // the max connections field has been altered.
               SetChanged(controlIDFrom);
               Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);

               break;
            }
            case EN_KILLFOCUS:
            {
               // check the limits against the contents of the control,
               // change the contents to be within the limits.

               String maxcon = Win::GetTrimmedWindowText(windowFrom);
               int a = 0;
               maxcon.convert(a);
               if (a < 1 || a > MAX_CONNECTIONS)
               {
                  Win::SetWindowText(
                     windowFrom,
                     String::format(
                        L"%1!d!",
                        max(1, min(a, MAX_CONNECTIONS))));
               }

               break;
            }
            default:
            {
               // do nothing
               break;
            }
         }

         break;
      }
      case IDC_SCRIPT_BUTTON:
      {
         if (code == BN_CLICKED)
         {
            NTService s(GetMachineName(), NW_SERVER_SERVICE);
            DWORD state = 0;
            HRESULT hr = s.GetCurrentState(state);

            if (SUCCEEDED(hr))
            {
               if (state == SERVICE_RUNNING)
               {
                  // edit the login script

                  if (!scriptRead)
                  {
                     ReadLoginScript();
                  }
                  FPNWLoginScriptDialog dlg(GetObjectName(), loginScript);
                  if (dlg.ModalExecute(hwnd) == IDOK)
                  {
                     // save the results
                     loginScript = dlg.GetLoginScript();
                     SetChanged(controlIDFrom);
                     Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
                  }

                  break;
               }

               // the service is not running, login scripts are not
               // editable

               popup.Error(
                  hwnd,
                  IDS_ERROR_FPNW_SERVICE_NOT_RUNNING);
               break;
            }

            // the service state could not be acertained.
            popup.Error(
               hwnd,
               hr,
               IDS_ERROR_FPNW_SERVICE_NOT_ACCESSIBLE);
         }
         break;
      }
      case IDC_UNLIMITED_CONNECTIONS:
      case IDC_LIMIT_CONNECTIONS:
      case IDC_UNLIMITED_GRACELOGINS:
      case IDC_LIMIT_GRACELOGINS:
      case IDC_NETWARE_ENABLE:
      case IDC_NWPWEXPIRED:
      {
         if (code == BN_CLICKED)
         {
            SetChanged(controlIDFrom);
            Enable(hwnd);
            Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
         }
         break;
      }
      case IDC_NWHMDIR_RELPATH:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);
            Enable(hwnd);
            Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
         }
         break;
      }
      default:
      {
         break;
      }
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\usergeneralpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// UserGeneralPage class
// 
// 9-9-97 sburns



#include "headers.hxx"
#include "UserGeneralPage.hpp"
#include "resource.h"
#include "lsm.h"
#include "adsi.hpp"
#include "dlgcomm.hpp"



static const DWORD HELP_MAP[] =
{
   IDC_FULL_NAME,                idh_general_fullname,
   IDC_DESCRIPTION,              idh_general_description,
   IDC_MUST_CHANGE_PASSWORD,     idh_general_must_change,
   IDC_CANNOT_CHANGE_PASSWORD,   idh_general_cannot_change,
   IDC_NEVER_EXPIRES,            idh_general_never_expires,
   IDC_DISABLED,                 idh_general_account_disabled,
   IDC_LOCKED,                   idh_general_account_lockedout,
   IDC_NAME,                     idh_general_username,
   IDC_USER_ICON,                NO_HELP,
   0, 0
};



UserGeneralPage::UserGeneralPage(
   MMCPropertyPage::NotificationState* state,
   const String&                       userADSIPath)
   :
   ADSIPage(IDD_USER_GENERAL, HELP_MAP, state, userADSIPath),
   userIcon(0)
{
   LOG_CTOR(UserGeneralPage);
   LOG(userADSIPath);
}



UserGeneralPage::~UserGeneralPage()
{
   LOG_DTOR(UserGeneralPage);

   if (userIcon)
   {
      Win::DestroyIcon(userIcon);
   }
}



static
void
enable(HWND dialog)
{
   LOG_FUNCTION(enable);
   ASSERT(Win::IsWindow(dialog));

   DoUserButtonEnabling(
      dialog,
      IDC_MUST_CHANGE_PASSWORD,
      IDC_CANNOT_CHANGE_PASSWORD,
      IDC_NEVER_EXPIRES);
}



void
UserGeneralPage::OnInit()
{
   LOG_FUNCTION(UserGeneralPage::OnInit());

   // Setup the controls

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_FULL_NAME), MAXCOMMENTSZ);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_DESCRIPTION), MAXCOMMENTSZ);

   HRESULT hr = Win::LoadImage(IDI_GROUP, userIcon);

   // if the icon load fails, we're not going to tank the whole dialog, so
   // just assert here.

   ASSERT(SUCCEEDED(hr));

   Win::Static_SetIcon(Win::GetDlgItem(hwnd, IDC_USER_ICON), userIcon);

   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_LOCKED), false);

   // load the user properties into the dialog.

   hr = S_OK;
   do
   {
      SmartInterface<IADsUser> user(0);
      hr = ADSI::GetUser(GetADSIPath(), user);
      BREAK_ON_FAILED_HRESULT(hr);

      BSTR name;
      hr = user->get_Name(&name);
      BREAK_ON_FAILED_HRESULT(hr);
      Win::SetDlgItemText(hwnd, IDC_NAME, name);
      ::SysFreeString(name);

      BSTR full_name;
      hr = user->get_FullName(&full_name);
      BREAK_ON_FAILED_HRESULT(hr);
      Win::SetDlgItemText(hwnd, IDC_FULL_NAME, full_name);
      ::SysFreeString(full_name);

      BSTR description;
      hr = user->get_Description(&description);
      BREAK_ON_FAILED_HRESULT(hr);
      Win::SetDlgItemText(hwnd, IDC_DESCRIPTION, description);
      ::SysFreeString(description);

      VARIANT_BOOL disabled = VARIANT_FALSE;
      hr = user->get_AccountDisabled(&disabled);
      BREAK_ON_FAILED_HRESULT(hr);
      Win::CheckDlgButton(
         hwnd,
         IDC_DISABLED,
         disabled ? BST_CHECKED : BST_UNCHECKED);

      VARIANT_BOOL locked = VARIANT_FALSE;
      hr = user->get_IsAccountLocked(&locked);
      BREAK_ON_FAILED_HRESULT(hr);
      Win::CheckDlgButton(
         hwnd,
         IDC_LOCKED,
         locked ? BST_CHECKED : BST_UNCHECKED);
      if (locked)
      {
         Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_LOCKED), true);
      }

      _variant_t variant;
      hr = user->Get(AutoBstr(ADSI::PROPERTY_PasswordExpired), &variant);
      BREAK_ON_FAILED_HRESULT(hr);
      long expired = variant;
      Win::CheckDlgButton(
         hwnd,
         IDC_MUST_CHANGE_PASSWORD,
         expired == 1 ? BST_CHECKED : BST_UNCHECKED);

      variant.Clear();
      hr = user->Get(AutoBstr(ADSI::PROPERTY_UserFlags), &variant);
      BREAK_ON_FAILED_HRESULT(hr);
      long flags = variant;
      Win::CheckDlgButton(
         hwnd,
         IDC_CANNOT_CHANGE_PASSWORD,
         flags & UF_PASSWD_CANT_CHANGE ? BST_CHECKED : BST_UNCHECKED);
      Win::CheckDlgButton(
         hwnd,
         IDC_NEVER_EXPIRES,
         flags & UF_DONT_EXPIRE_PASSWD ? BST_CHECKED : BST_UNCHECKED);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(IDS_ERROR_READING_USER, GetObjectName().c_str()));
      Win::PostMessage(Win::GetParent(hwnd), WM_CLOSE, 0, 0);
   }

   ClearChanges();
   enable(hwnd);
}



bool
UserGeneralPage::OnApply(bool /* isClosing */)
{
   LOG_FUNCTION(UserGeneralPage::OnApply);

   if (WasChanged())
   {
      String full_name = Win::GetTrimmedDlgItemText(hwnd, IDC_FULL_NAME);
      String description = Win::GetTrimmedDlgItemText(hwnd, IDC_DESCRIPTION);
      bool disabled = Win::IsDlgButtonChecked(hwnd, IDC_DISABLED);
      bool must_change = Win::IsDlgButtonChecked(hwnd, IDC_MUST_CHANGE_PASSWORD);
      bool cant_change = Win::IsDlgButtonChecked(hwnd, IDC_CANNOT_CHANGE_PASSWORD);
      bool never_expires = Win::IsDlgButtonChecked(hwnd, IDC_NEVER_EXPIRES);
      bool locked = Win::IsDlgButtonChecked(hwnd, IDC_LOCKED);

      // save the changes thru ADSI
      HRESULT hr = S_OK;
      do
      {
         SmartInterface<IADsUser> user(0);
         hr = ADSI::GetUser(GetADSIPath(), user);
         BREAK_ON_FAILED_HRESULT(hr);

         hr =
            SaveUserProperties(
               user,
               WasChanged(IDC_FULL_NAME) ? &full_name : 0,
               WasChanged(IDC_DESCRIPTION) ? &description : 0,
               WasChanged(IDC_DISABLED) ? &disabled : 0,
               WasChanged(IDC_MUST_CHANGE_PASSWORD) ? &must_change : 0,
               WasChanged(IDC_CANNOT_CHANGE_PASSWORD) ? &cant_change : 0,
               WasChanged(IDC_NEVER_EXPIRES) ? &never_expires : 0,
               WasChanged(IDC_LOCKED) ? &locked : 0);
         BREAK_ON_FAILED_HRESULT(hr);      

         SetChangesApplied();
         ClearChanges();
      }
      while (0);

      if (FAILED(hr))
      {
         popup.Error(
            hwnd,
            hr,
            String::format(
               IDS_ERROR_SETTING_USER_PROPERTIES,            
               GetObjectName().c_str()));
      }
   }

   return true;
}
      


bool
UserGeneralPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//    LOG_FUNCTION(UserGeneralPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_MUST_CHANGE_PASSWORD:
      case IDC_CANNOT_CHANGE_PASSWORD:
      case IDC_NEVER_EXPIRES:
      case IDC_DISABLED:
      case IDC_LOCKED:
      {
         if (code == BN_CLICKED)
         {
            SetChanged(controlIDFrom);
            enable(hwnd);
            Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
         }
         break;
      }
      case IDC_FULL_NAME:
      case IDC_DESCRIPTION:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);
            enable(hwnd);
            Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
         }
         break;
      }
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\usernode.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// UserNode class
// 
// 9-4-97 sburns



#include "headers.hxx"
#include "usernode.hpp"
#include "uuids.hpp"
#include "resource.h"
#include "images.hpp"
#include "UserGeneralPage.hpp"
#include "UserFpnwPage.hpp"
#include "UserMemberPage.hpp"
#include "UserProfilePage.hpp"
#include "adsi.hpp"
#include "setpass.hpp"
#include "dlgcomm.hpp"
#include "fpnw.hpp"
#include "SetPasswordWarningDialog.hpp"
#include "WinStation.hpp"



UserNode::UserNode(
   const SmartInterface<ComponentData>&   owner,
   const String&                          displayName,
   const String&                          ADSIPath,
   const String&                          fullName,
   const String&                          description_,
   bool                                   isDisabled)
   :
   AdsiNode(owner, NODETYPE_User, displayName, ADSIPath),
   full_name(fullName),
   description(description_),
   disabled(isDisabled)
{
   LOG_CTOR2(UserNode, GetDisplayName());
}



UserNode::~UserNode()
{
   LOG_DTOR2(UserNode, GetDisplayName());
}
   

                 
String
UserNode::GetColumnText(int column)
{
//    LOG_FUNCTION(UserNode::GetColumnText);

   switch (column)
   {
      case 0:  // Name
      {
         return GetDisplayName();
      }
      case 1:  // Full Name
      {
         return full_name;
      }
      case 2:  // Description
      {
         return description;
      }
      default:
      {
         // This should never be called
         ASSERT(false);
      }
   }

   return String();
}



int
UserNode::GetNormalImageIndex()
{
   LOG_FUNCTION2(UserNode::GetNormalImageIndex, GetDisplayName());

   if (disabled)
   {
      return DISABLED_USER_INDEX;
   }

   return USER_INDEX;
}



bool
UserNode::HasPropertyPages()
{
   LOG_FUNCTION2(UserNode::HasPropertyPages, GetDisplayName());
      
   return true;
}



bool
ShouldShowFpnwPage(const String& serverName)
{
   LOG_FUNCTION(ShouldShowFpnwPage);
   ASSERT(!serverName.empty());

   bool result = false;

   do
   {
      // Check that FPNW Service is running

      NTService fpnw(NW_SERVER_SERVICE);

      DWORD state = 0;
      HRESULT hr = fpnw.GetCurrentState(state);
      BREAK_ON_FAILED_HRESULT(hr);

      if (state != SERVICE_RUNNING)
      {
         break;
      }

      String secret;
      hr = FPNW::GetLSASecret(serverName, secret);
      BREAK_ON_FAILED_HRESULT(hr);

      result = true;      
   }
   while (0);

   LOG(result ? L"true" : L"false");

   return result;
}



HRESULT
UserNode::CreatePropertyPages(
   IPropertySheetCallback&             callback,
   MMCPropertyPage::NotificationState* state)
{
   LOG_FUNCTION2(UserNode::CreatePropertySheet, GetDisplayName());

   // these pages delete themselves when the prop sheet is destroyed

   String path = GetADSIPath();

   HRESULT hr = S_OK;
   do
   {
      // designate the general page as that which frees the notify state
      // (only one page in the prop sheet should do this)
      UserGeneralPage* general_page = new UserGeneralPage(state, path);
      general_page->SetStateOwner();
      hr = DoAddPage(*general_page, callback);
      if (FAILED(hr))
      {
         delete general_page;
         general_page = 0;
      }
      BREAK_ON_FAILED_HRESULT(hr);

      UserMemberPage* member_page = new UserMemberPage(state, path);
      hr = DoAddPage(*member_page, callback);
      if (FAILED(hr))
      {
         delete member_page;
         member_page = 0;
      }
      BREAK_ON_FAILED_HRESULT(hr);

      UserProfilePage* profile_page = new UserProfilePage(state, path);
      hr = DoAddPage(*profile_page, callback);
      if (FAILED(hr))
      {
         delete profile_page;
         profile_page = 0;
      }
      BREAK_ON_FAILED_HRESULT(hr);

      if (ShouldShowFpnwPage(ADSI::PathCracker(path).serverName()))
      {
         UserFpnwPage* fpnw_page = new UserFpnwPage(state, path);
         hr = DoAddPage(*fpnw_page, callback);
         if (FAILED(hr))
         {
            delete fpnw_page;
            fpnw_page = 0;
         }
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // if the secret is not present, or can't be read, then FPNW is not
      // installed, and the page does not apply.  However, that doesn't mean
      // that the creation of the prop pages failed, so we clear the error
      // here.

      hr = S_OK;
   }
   while(0);

   return hr;
}



HRESULT
UserNode::AddMenuItems(
   IContextMenuCallback&   callback,
   long&                   insertionAllowed)
{
   LOG_FUNCTION(UserNode::AddMenuItems);

   static const ContextMenuItem items[] =
   {
      // {
      //    CCM_INSERTIONPOINTID_PRIMARY_TOP,
      //    IDS_USER_MENU_ADD_TO_GROUP,
      //    IDS_USER_MENU_ADD_TO_GROUP_STATUS         
      // },
      {
         CCM_INSERTIONPOINTID_PRIMARY_TOP,
         IDS_USER_MENU_CHANGE_PASSWORD,
         IDS_USER_MENU_CHANGE_PASSWORD_STATUS      // 347894
      },
      // {
      //    CCM_INSERTIONPOINTID_PRIMARY_TASK,
      //    IDS_USER_MENU_ADD_TO_GROUP,
      //    IDS_USER_MENU_ADD_TO_GROUP_STATUS
      // },
      {
         CCM_INSERTIONPOINTID_PRIMARY_TASK,
         IDS_USER_MENU_CHANGE_PASSWORD,
         IDS_USER_MENU_CHANGE_PASSWORD_STATUS
      }
   };

   return
      BuildContextMenu(
         items,
         items + sizeof(items) / sizeof(ContextMenuItem),
         callback,
         insertionAllowed);
}



bool
UserIsCurrentLoggedOnUser(const String& path)
{
   LOG_FUNCTION2(UserIsCurrentLoggedOnUser, path);

   bool result = false;
   HRESULT hr = S_OK;

   SID* acctSid = 0;
   HANDLE hToken = INVALID_HANDLE_VALUE;
   TOKEN_USER* userTokenInfo = 0;
         
   do
   {
      // get the account SID

      hr = ADSI::GetSid(path, acctSid);
      BREAK_ON_FAILED_HRESULT(hr);

      // get the current logged on user's sid

      hr =
         Win::OpenProcessToken(
            Win::GetCurrentProcess(),
            TOKEN_QUERY,
            hToken);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = Win::GetTokenInformation(hToken, userTokenInfo);
      BREAK_ON_FAILED_HRESULT(hr);

      result = Win::EqualSid(acctSid, userTokenInfo->User.Sid);
   }
   while (0);

   if (acctSid)
   {
      ADSI::FreeSid(acctSid);
   }

   Win::CloseHandle(hToken);
   Win::FreeTokenInformation(userTokenInfo);
   
   LOG_HRESULT(hr);

   // if we've failed, then the result is false, and the caller will show
   // the password reset warning dialog, which is good. (i.e. failure of
   // this routine will not cause the user to unwittingly reset a password.)

   if (FAILED(hr))
   {
      ASSERT(!result);
   }

   return result;
}



HRESULT
UserNode::MenuCommand(
   IExtendContextMenu&  /* extendContextMenu */ ,
   long                 commandID)
{
   LOG_FUNCTION(UserNode::MenuCommand);

   switch (commandID)
   {
      case IDS_USER_MENU_CHANGE_PASSWORD:
      {
         // NTRAID#NTBUG9-314217-2001/02/21-sburns
         // NTRAID#NTBUG9-314230-2001/02/21-sburns

         String path = GetADSIPath();
         String displayName = GetDisplayName();
         
         bool isLoggedOn = UserIsCurrentLoggedOnUser(path);
         
         if (
            SetPasswordWarningDialog(
               path,
               displayName,
               isLoggedOn).ModalExecute(
                  GetOwner()->GetMainWindow()) == IDOK)
         {
            SetPasswordDialog dlg(path, displayName, isLoggedOn);
               dlg.ModalExecute(GetOwner()->GetMainWindow());
         }
         break;
      }
      // case IDS_USER_MENU_ADD_TO_GROUP:
      // {
      //    break;
      // }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return S_OK;
}



HRESULT
UserNode::UpdateVerbs(IConsoleVerb& consoleVerb)
{
   LOG_FUNCTION(UserNode::UpdateVerbs);

   consoleVerb.SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
   consoleVerb.SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);
   consoleVerb.SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

// CODEWORK: we should enable the refresh verb for result nodes too.
// NTRAID#NTBUG9-153012-2000/08/31-sburns
//   consoleVerb.SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

   consoleVerb.SetDefaultVerb(MMC_VERB_PROPERTIES);

   return S_OK;
}



HRESULT
UserNode::Rename(const String& newName)
{
   LOG_FUNCTION(UserNode::Rename);

   String name(newName);

   // trim off whitespace.
   // NTRAID#NTBUG9-328306-2001/02/26-sburns
   
   name.strip(String::BOTH);
   
   // truncate the name
   
   if (name.length() > LM20_UNLEN)
   {
      name.resize(LM20_UNLEN);      
      popup.Info(
         GetOwner()->GetMainWindow(),
         String::format(
            IDS_USER_NAME_TOO_LONG,
            newName.c_str(),
            name.c_str()));
   }

   if (!IsValidSAMName(name))
   {
      popup.Gripe(
         GetOwner()->GetMainWindow(),
         String::format(
            IDS_BAD_SAM_NAME,
            name.c_str()));
      return S_FALSE;
   }
      
   // Disallow user account names with the same name as the netbios computer
   // name. This causes some apps to get confused the the <03> and <20>
   // registrations.
   // NTRAID#NTBUG9-324794-2001/02/26-sburns

   String netbiosName = GetOwner()->GetInternalComputerName();
   if (name.icompare(netbiosName) == 0)
   {
      popup.Gripe(
         GetOwner()->GetMainWindow(),
         String::format(
            IDS_USERNAME_CANT_BE_COMPUTER_NAME,
            netbiosName.c_str()));
      return S_FALSE;
   }
      
   HRESULT hr = AdsiNode::rename(name);
   if (FAILED(hr))
   {
      String path = GetADSIPath();      
      popup.Error(
         GetOwner()->GetMainWindow(),
         hr,
         String::format(
            IDS_ERROR_RENAMING_USER,
            ADSI::ExtractObjectName(path).c_str()));
      return S_FALSE;
   }

   return S_OK;
}



// Determine if the user is logged on to a machine.  Returns:
// S_OK - the user is not logged on to the server
// S_FALSE - the user is logged on to the server
// other - could not determine if the user is logged on.
// 
// serverName - in, NetBIOS name of the remote machine.
// 
// userName - in, name of the user account to test for.

HRESULT
CheckUserLoggedOn(const String& serverName, const String& userName)
{
   LOG_FUNCTION2(
      EnumerateWinStations,
      L"server=" + serverName + L" user=" + userName);
   ASSERT(!serverName.empty());
   ASSERT(!userName.empty());   

   HRESULT hr = S_OK;
   HANDLE serverHandle = INVALID_HANDLE_VALUE;

   do
   {
      hr = WinStation::OpenServer(serverName, serverHandle);
      BREAK_ON_FAILED_HRESULT(hr);

      LOGONID* sessionList = 0;
      DWORD    sessionCount = 0;

      // Iterate the sessions looking for active and disconnected sessions
      // only. Then match the user name and domain (case INsensitive) for a
      // result.

      hr = WinStation::Enumerate(serverHandle, sessionList, sessionCount);
      BREAK_ON_FAILED_HRESULT(hr);

      PLOGONID session = sessionList;
      DWORD    i = 0;

      for (; session && i < sessionCount; ++i, ++session)
      {
         if (
               (session->State != State_Active)
            && (session->State != State_Disconnected))
         {
            continue;
         }

         WINSTATIONINFORMATION info;
         hr =
            WinStation::QueryInformation(
               serverHandle,
               session->SessionId,
               info);
         BREAK_ON_FAILED_HRESULT(hr);

         if (serverName.icompare(info.Domain) == 0)
         {
            // The account logged on to the session is a local account for
            // that machine.

            if (userName.icompare(info.UserName) == 0)
            {
               // the account name is the same, so the user is logged on.

               hr = S_FALSE;
               break;
            }
         }
      }

      WinStation::FreeMemory(sessionList);
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}



bool
IsUserLoggedOn(const String& serverName, const String& userName)
{
   HRESULT hr = CheckUserLoggedOn(serverName, userName);

   bool result = (hr == S_FALSE) ? true : false;

   LOG_BOOL(result);

   return result;
}



HRESULT
UserNode::Delete()
{
   LOG_FUNCTION(UserNode::Delete);

   HRESULT hr = E_FAIL;
   String name = ADSI::ExtractObjectName(GetADSIPath());
   
   do
   {
      if (
         popup.MessageBox(
            GetOwner()->GetMainWindow(),
            String::format(
               IDS_CONFIRM_USER_DELETE,
               name.c_str()),
            MB_ICONWARNING | MB_YESNO) != IDYES)
      {
         // user declined to roach the account.

         break;
      }

      // at this point, user wants to delete the account.  Make sure the
      // account is not logged on interactively (like with Fast User
      // Switching)
      // NTRAID#NTBUG9-370130-2001/04/25-sburns
      
      // IsOS(OS_FASTUSERSWITCHING) will tell us if the local machine is
      // running with FUS.  Unfortunately, that API is not remoteable.

      String serverName = GetOwner()->GetInternalComputerName();
      
      if (IsUserLoggedOn(serverName, name))
      {
         if (
            popup.MessageBox(
               GetOwner()->GetMainWindow(),
               String::format(
                  IDS_CONFIRM_LOGGED_ON_USER_DELETE,
                  name.c_str()),
               MB_ICONWARNING | MB_YESNO) != IDYES)
         {
            // user declined to roach logged on user.

            break;
         }
      }
               
      hr =
         ADSI::DeleteObject(
            ADSI::ComposeMachineContainerPath(serverName),         
            name,
            ADSI::CLASS_User);
      if (SUCCEEDED(hr))
      {
         break;
      }

      popup.Error(
         GetOwner()->GetMainWindow(),
         hr,
         String::format(
            IDS_ERROR_DELETING_USER,            
            name.c_str()));
   }
   while (0);
   
   LOG_HRESULT(hr);
   
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\usernode.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// UserNode class
// 
// 9-4-97 sburns



#ifndef USERNODE_HPP_INCLUDED
#define USERNODE_HPP_INCLUDED



#include "adsinode.hpp"



class UserNode : public AdsiNode
{
   friend class UsersFolderNode;

   public:

   // Creates a new instance.
   //
   // owner - See base class ctor.
   // 
   // displayName - See base class ctor.
   //
   // ADSIPath - See base class ctor.
   //
   // fullName - text to appear as the node's Full Name in the result
   // pane details view.
   //
   // description - text to appear as the node's description in the result
   // pane details view.
   //
   // disabled - true if the account is disabled, false if not.

   UserNode(
      const SmartInterface<ComponentData>&   owner,
      const String&                          displayName,
      const String&                          ADSIPath,
      const String&                          fullName,
      const String&                          description,
      bool                                   disabled);

   // Node overrides

   virtual
   HRESULT
   AddMenuItems(
      IContextMenuCallback&   callback,
      long&                   insertionAllowed);

   String
   GetColumnText(int column);

   virtual 
   int
   GetNormalImageIndex();

   virtual
   HRESULT
   MenuCommand(
      IExtendContextMenu&  extendContextMenu,
      long                 commandID);

   HRESULT
   UpdateVerbs(IConsoleVerb& consoleVerb);

   // ResultNode overrides

   virtual
   HRESULT
   CreatePropertyPages(
      IPropertySheetCallback&             callback,
      MMCPropertyPage::NotificationState* state);

   virtual
   HRESULT
   Delete();

   virtual
   bool
   HasPropertyPages();

   virtual
   HRESULT
   Rename(const String& newName);

   private:

   // only we can delete ourselves via Release
   virtual ~UserNode();

   String   full_name;
   String   description;
   bool     disabled;

   // not defined: no copying allowed

   UserNode(const UserNode&);
   const UserNode& operator=(const UserNode&);
};



#endif   // USERNODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\userprofilepage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// UserProfilePage class
// 
// 9-11-97 sburns



#include "headers.hxx"
#include "UserProfilePage.hpp"
#include "resource.h"
#include "lsm.h"
#include "adsi.hpp"
#include "dlgcomm.hpp"



static const DWORD HELP_MAP[] =
{
   IDC_PROFILE,   idh_profile_path,
   IDC_SCRIPT,    idh_profile_logon_script,
   IDC_LOCAL,     idh_profile_local_path_radio,
   IDC_CONNECT,   idh_profile_connect_to_radio,
   IDC_PATH,      idh_profile_local_path_text,
   IDC_DRIVE,     idh_profile_connect_to_list,
   IDC_SHARE,     idh_profile_to_text,
   0, 0
};


static const wchar_t FIRST_DRIVE_LETTER(L'C');
static const wchar_t LAST_DRIVE_LETTER(L'Z');


UserProfilePage::UserProfilePage(
   MMCPropertyPage::NotificationState* state,
   const String&                       userADSIPath)
   :
   ADSIPage(
      IDD_USER_PROFILE,
      HELP_MAP,
      state,
      userADSIPath)
{
   LOG_CTOR2(UserProfilePage::ctor, userADSIPath);
}



UserProfilePage::~UserProfilePage()
{
   LOG_DTOR2(UserProfilePage, GetADSIPath());
}



static
void
enable(HWND dialog)
{
   LOG_FUNCTION(enable);
   ASSERT(Win::IsWindow(dialog));

   bool enable_path = Win::IsDlgButtonChecked(dialog, IDC_LOCAL);

   Win::EnableWindow(Win::GetDlgItem(dialog, IDC_PATH), enable_path);
   Win::EnableWindow(Win::GetDlgItem(dialog, IDC_DRIVE), !enable_path);
   Win::EnableWindow(Win::GetDlgItem(dialog, IDC_SHARE), !enable_path);

   // NTRAID#NTBUG9-425891-2001/06/28-sburns
   
   Win::EnableWindow(Win::GetDlgItem(dialog, IDC_TO_STATIC), !enable_path);   
}


      
void
UserProfilePage::OnInit()
{
   LOG_FUNCTION(UserProfilePage::OnInit());

   // Setup the controls
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_PROFILE), MAX_PATH);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_SCRIPT), MAX_PATH);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_PATH), MAX_PATH);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_SHARE), MAX_PATH);

   // populate the drive list
   HWND combo = Win::GetDlgItem(hwnd, IDC_DRIVE);
   for (wchar_t d = FIRST_DRIVE_LETTER; d <= LAST_DRIVE_LETTER; d++)
   {
      Win::ComboBox_AddString(combo, String(1, d) + L":");
   }
   Win::ComboBox_SetCurSel(combo, LAST_DRIVE_LETTER - FIRST_DRIVE_LETTER);

   // load the user properties into the dialog.
   HRESULT hr = S_OK;
   do
   {
      SmartInterface<IADsUser> user(0);
      hr = ADSI::GetUser(GetADSIPath(), user);
      BREAK_ON_FAILED_HRESULT(hr);

      BSTR profile;
      hr = user->get_Profile(&profile);
      BREAK_ON_FAILED_HRESULT(hr);
      Win::SetDlgItemText(hwnd, IDC_PROFILE, profile);
      ::SysFreeString(profile);

      BSTR script;
      hr = user->get_LoginScript(&script);
      BREAK_ON_FAILED_HRESULT(hr);
      Win::SetDlgItemText(hwnd, IDC_SCRIPT, script);
      ::SysFreeString(script);

      BSTR home;
      hr = user->get_HomeDirectory(&home);
      BREAK_ON_FAILED_HRESULT(hr);

      _variant_t variant;
      hr = user->Get(AutoBstr(ADSI::PROPERTY_LocalDrive), &variant);
      BREAK_ON_FAILED_HRESULT(hr);

      String local = V_BSTR(&variant);
      if (!local.empty())
      {
         Win::CheckDlgButton(hwnd, IDC_CONNECT, BST_CHECKED);
         Win::SetDlgItemText(hwnd, IDC_SHARE, home);
         int index = max(0, local[0] - FIRST_DRIVE_LETTER);
         Win::ComboBox_SetCurSel(combo, index);
      }
      else
      {
         Win::CheckDlgButton(hwnd, IDC_LOCAL, BST_CHECKED);         
         Win::SetDlgItemText(hwnd, IDC_PATH, home);
      }

      ::SysFreeString(home);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_READING_USER,
            GetObjectName().c_str()));
      Win::PostMessage(Win::GetParent(hwnd), WM_CLOSE, 0, 0);
   }

   ClearChanges();
   enable(hwnd);
}



bool
UserProfilePage::Validate(HWND dialog)
{
   LOG_FUNCTION(UserProfilePage::Validate);
   ASSERT(Win::IsWindow(dialog));

   // profile path is a free-for-all, as it may contain expansion expressions

   String script = Win::GetTrimmedDlgItemText(dialog, IDC_SCRIPT);
   if (!script.empty())
   {
      if (FS::GetPathSyntax(script) != FS::SYNTAX_RELATIVE_NO_DRIVE)
      {
         popup.Gripe(
            dialog,
            IDC_SCRIPT,
            String::format(IDS_BAD_SCRIPT_PATH, script.c_str()) );
         return false;
      }
   }

   if (Win::IsDlgButtonChecked(dialog, IDC_LOCAL))
   {
      // we massage the path one final time here, as the edit box may receive
      // kill focus after the page receives kill focus.  This happens when
      // entering the path then pressing enter.

      String dir =
         MassagePath(Win::GetTrimmedDlgItemText(dialog, IDC_PATH));
      if (!dir.empty())
      {
         if (FS::GetPathSyntax(dir) != FS::SYNTAX_ABSOLUTE_DRIVE)
         {
            popup.Gripe(
               dialog,
               IDC_PATH,
               String::format(IDS_BAD_HOME_DIR, dir.c_str()));
            return false;
         }

         if (!FS::PathExists(dir))
         {
            // attempt to create the path

            HRESULT hr = FS::CreateFolder(dir);
            if (FAILED(hr))
            {
               popup.Error(
                  dialog,
                  hr,
                  String::format(IDS_HOME_DIR_CREATE_FAILED, dir.c_str()));
            }
         }
      }
   }
   else
   {
      // see massage note above...

      String share =
         MassagePath(Win::GetTrimmedDlgItemText(dialog, IDC_SHARE));
      if (share.empty())
      {
         popup.Gripe(dialog, IDC_SHARE, IDS_NEED_SHARE_NAME);
         return false;
      }
      else
      {
         if (FS::GetPathSyntax(share) != FS::SYNTAX_UNC)
         {
            popup.Gripe(
               dialog,
               IDC_SHARE,
               String::format(IDS_BAD_SHARE_NAME, share.c_str()));
            return false;
         }

         String s = FS::GetRootFolder(share);

         // remove the trailing backslash

         if (s[s.length() - 1] == L'\\')
         {
            s.resize(s.length() - 1);
         }

         Win::WaitCursor waitCur;

         DWORD attrs = 0;
         HRESULT hr = Win::GetFileAttributes(s, attrs);

         if (FAILED(hr))
         {
            popup.Gripe(
               dialog,
               IDC_SHARE,
               hr,
               String::format(IDS_CANT_ACCESS_SHARE, s.c_str()));
            return false;
         }
      }
   }

   return true;
}
      
   

bool
UserProfilePage::OnKillActive()
{
   LOG_FUNCTION(UserProfilePage::OnKillActive);

   if (!Validate(hwnd))
   {
      // refuse to relinquish focus

      Win::SetWindowLongPtr(hwnd, DWLP_MSGRESULT, TRUE);
   }

   return true;
}



// if %username% is at the end of the string, replace it with the current
// username.

String
UserProfilePage::MassagePath(const String& path)
{
   LOG_FUNCTION2(UserProfilePage::MassagePath, path);

   static const String USERNAME = String::load(IDS_USERNAME).to_upper();

   if (path.length() >= USERNAME.length())
   {
      String path_copy = path;
      path_copy.to_upper();
      size_t pos = path_copy.rfind(USERNAME);
      if (pos == path.length() - USERNAME.length())
      {
         return path.substr(0, pos) + GetObjectName();
      }
   }

   return path;
}


   
bool
UserProfilePage::OnApply(bool /* isClosing */)
{
   LOG_FUNCTION(UserProfilePage::OnApply);

   if (!WasChanged())
   {
      return true;
   }

   // don't need to call validate; kill active is sent before apply

   HRESULT hr = S_OK;
   do
   {
      SmartInterface<IADsUser> user(0);
      hr = ADSI::GetUser(GetADSIPath(), user);
      BREAK_ON_FAILED_HRESULT(hr);

      if (WasChanged(IDC_PROFILE))
      {
         String profile =
            MassagePath(Win::GetTrimmedDlgItemText(hwnd, IDC_PROFILE));
         hr = user->put_Profile(AutoBstr(profile));
         BREAK_ON_FAILED_HRESULT(hr);
      }
      if (WasChanged(IDC_SCRIPT))
      {
         String script = Win::GetTrimmedDlgItemText(hwnd, IDC_SCRIPT);                  
         hr = user->put_LoginScript(AutoBstr(script));
         BREAK_ON_FAILED_HRESULT(hr);
      }
      if (Win::IsDlgButtonChecked(hwnd, IDC_LOCAL))
      {
         if (WasChanged(IDC_LOCAL) || WasChanged(IDC_PATH))
         {
            // The local path button was checked, and the user clicked it.

            String dir =
               MassagePath(Win::GetTrimmedDlgItemText(hwnd, IDC_PATH));
            hr = user->put_HomeDirectory(AutoBstr(dir));;
            BREAK_ON_FAILED_HRESULT(hr);

            // write an empty string to the home drive

            String blank;
            _variant_t variant;
            variant = blank.c_str();
            hr = user->Put(AutoBstr(ADSI::PROPERTY_LocalDrive), variant);
            BREAK_ON_FAILED_HRESULT(hr);
         }
      }
      else
      {
         if (
               WasChanged(IDC_CONNECT)
            || WasChanged(IDC_SHARE)
            || WasChanged(IDC_DRIVE))
         {  
            // The connect to: button was checked, and the user clicked it.

            String share =
               MassagePath(Win::GetTrimmedDlgItemText(hwnd, IDC_SHARE));
            hr = user->put_HomeDirectory(AutoBstr(share));
            BREAK_ON_FAILED_HRESULT(hr);

            // Attempt to create the folder

            hr = FS::CreateFolder(share);
            if (FAILED(hr))
            {
               popup.Error(
                  hwnd,
                  hr,
                  String::format(IDS_CANT_CREATE_FOLDER, share.c_str()));
            }
                  
            int index =
               Win::ComboBox_GetCurSel(Win::GetDlgItem(hwnd, IDC_DRIVE));
            String drive =
                  String(1, (wchar_t)min(FIRST_DRIVE_LETTER + index, LAST_DRIVE_LETTER))
               +  L":";

            _variant_t variant;
            variant = drive.c_str();
            hr = user->Put(AutoBstr(ADSI::PROPERTY_LocalDrive), variant);
            BREAK_ON_FAILED_HRESULT(hr);
         }
      }

      // commit the property changes

      hr = user->SetInfo();
      BREAK_ON_FAILED_HRESULT(hr);

      SetChangesApplied();
      ClearChanges();
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         hwnd,
         hr,
         String::format(
            IDS_ERROR_SETTING_USER_PROPERTIES,            
            GetObjectName().c_str()));
   }
      
   return true;
}



bool
UserProfilePage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//    LOG_FUNCTION(UserProfilePage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_LOCAL:
      case IDC_CONNECT:
      {
         if (code == BN_CLICKED)
         {
            SetChanged(controlIDFrom);
            enable(hwnd);
            Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
         }
         break;
      }
      case IDC_PROFILE:
      case IDC_SCRIPT:
      case IDC_PATH:
      case IDC_SHARE:
      {
         switch (code)
         {
            case EN_CHANGE:
            {
               SetChanged(controlIDFrom);
               enable(hwnd);
               Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
               break;
            }
            case EN_KILLFOCUS:
            {
               Win::SetDlgItemText(
                  hwnd,
                  controlIDFrom,
                  MassagePath(
                     Win::GetTrimmedDlgItemText(hwnd, controlIDFrom)));
               break;
            }
            default:
            {
               // do nothing
               break;
            }
         }
         break;
      }
      case IDC_DRIVE:
      {
         if (code == CBN_SELCHANGE)
         {
            SetChanged(controlIDFrom);
            enable(hwnd);
            Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
         }
      }
      default:
      {
         break;
      }
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\userprofilepage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// UserProfilePage class
// 
// 9-11-97 sburns



#ifndef USERPROFILEPAGE_HPP_INCLUDED
#define USERPROFILEPAGE_HPP_INCLUDED



#include "adsipage.hpp"



class UserProfilePage : public ADSIPage
{
   public:

   // Constructs a new instance.
   //
   // state - See base class
   //
   // userADSIPath - fully-qualified ADSI pathname of the user account
   // for which properties will be editied.

   UserProfilePage(
      MMCPropertyPage::NotificationState* state,
      const String&                       userADSIPath);



   virtual
   ~UserProfilePage();


         
   // Dialog overrides

   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual 
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnApply(bool isClosing);

   virtual
   bool
   OnKillActive();

   private:

   String
   MassagePath(const String& path);

   bool
   Validate(HWND dialog);

   // not implemented: no copying allowed

   UserProfilePage(const UserProfilePage&);
   const UserProfilePage& operator=(const UserProfilePage&);
};



#endif   // USERPROFILEPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\usersfoldernode.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Users Folder Node class
// 
// 9-3-97 sburns



#ifndef USERSFOLDERNODE_HPP_INCLUDED
#define USERSFOLDERNODE_HPP_INCLUDED



#include "foldnode.hpp"



class UsersFolderNode : public FolderNode
{
   friend class RootNode;

   public:

   // Node overrides

   virtual
   HRESULT
   MenuCommand(
      IExtendContextMenu&  extendContextMenu,
      long                 commandID);

   // ScopeNode overrides

   virtual
   String
   GetDescriptionBarText();

   // FolderNode overrides

   void
   BuildResultItems(ResultNodeList& items);

   private:

   // Constructs a new instance.  Declared private as to be accessible only by
   // RootNode (which calls it when expanding)
   //
   // owner - See base class.

   UsersFolderNode(const SmartInterface<ComponentData>& owner);

   // only we can delete ourselves

   virtual ~UsersFolderNode();

   // not defined: no copying allowed

   UsersFolderNode(const UsersFolderNode&);
   const UsersFolderNode& operator=(const UsersFolderNode&);   
};

   


#endif   // USERSFOLDERNODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\usersfoldernode.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// UsersFolder Node class
// 
// 9-2-97 sburns



#include "headers.hxx"
#include "UsersFolderNode.hpp"
#include "resource.h"
#include "uuids.hpp"
#include "usernode.hpp"
#include "compdata.hpp"
#include "adsi.hpp"
#include "newuser.hpp"
#include "dlgcomm.hpp"



static
FolderNode::ColumnList
buildColumnList()
{
   FolderNode::ColumnList list;

   static const ResultColumn col1 =
   {   
      IDS_USER_NAME_COLUMN_TITLE,
      IDS_USER_NAME_COLUMN_WIDTH
   };
   static const ResultColumn col2 =
   {
      IDS_USER_FULL_NAME_COLUMN_TITLE,
      IDS_USER_FULL_NAME_COLUMN_WIDTH
   };
   static const ResultColumn col3 =
   {
      IDS_USER_DESCRIPTION_COLUMN_TITLE,
      IDS_USER_DESCRIPTION_COLUMN_WIDTH
   };

   list.push_back(col1);
   list.push_back(col2);
   list.push_back(col3);

   return list;
};



static
FolderNode::MenuItemList
buildMenuItemList()
{
   FolderNode::MenuItemList list;

   static const ContextMenuItem item1 =
   {
      CCM_INSERTIONPOINTID_PRIMARY_TOP,
      IDS_UF_MENU_CREATE_USER,
      IDS_UF_MENU_NEW_USER_STATUS
   };
   // static const ContextMenuItem item2 =
   // {
   //    CCM_INSERTIONPOINTID_PRIMARY_NEW,
   //    IDS_UF_MENU_NEW_USER,
   //    IDS_UF_MENU_NEW_USER_STATUS         
   // };

   list.push_back(item1);
   // list.push_back(item2);

   return list;
}



UsersFolderNode::UsersFolderNode(const SmartInterface<ComponentData>& owner)
   :
   FolderNode(
      owner,
      NODETYPE_UsersFolder,
      IDS_USERS_FOLDER_DISPLAY_NAME,
      IDS_USERS_FOLDER_TYPE_TITLE,
      buildColumnList(),
      buildMenuItemList())
{
   LOG_CTOR(UsersFolderNode);
}



UsersFolderNode::~UsersFolderNode()
{
   LOG_DTOR(UsersFolderNode);
}



HRESULT
UsersFolderNode::MenuCommand(
   IExtendContextMenu&  /* extendContextMenu */ ,
   long                 commandID)
{
   LOG_FUNCTION(UsersFolderNode::MenuCommand);

   switch (commandID)
   {
      case IDS_UF_MENU_NEW_USER:
      case IDS_UF_MENU_CREATE_USER:
      {
         CreateUserDialog dlg(GetOwner()->GetInternalComputerName());
         if (dlg.ModalExecute(GetOwner()->GetMainWindow()))
         {
            RefreshView();
         }
         return S_OK;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return S_OK;
}



class UserVisitor : public ADSI::ObjectVisitor
{
   public:

   UserVisitor(
      FolderNode::ResultNodeList&            nodes_,
      const SmartInterface<ComponentData>&   owner_)
      :
      nodes(nodes_),
      owner(owner_)
   {
   }


   
   virtual
   ~UserVisitor()
   {
   }


   
   virtual
   void
   Visit(const SmartInterface<IADs>& object)
   {
      LOG_FUNCTION(UserVistor::visit);

      HRESULT hr = S_OK;
      do
      {

#ifdef DBG
         BSTR cls = 0;
         hr = object->get_Class(&cls);
         BREAK_ON_FAILED_HRESULT2(hr, L"get_Class");

         ASSERT(cls == ADSI::CLASS_User);
         if (cls != ADSI::CLASS_User)
         {
            break;
         }
         ::SysFreeString(cls);
#endif          
            
         BSTR name = 0;            
         hr = object->get_Name(&name);
         BREAK_ON_FAILED_HRESULT2(hr, L"get_Name");

         BSTR path = 0;
         hr = object->get_ADsPath(&path);
         BREAK_ON_FAILED_HRESULT2(hr, L"get_ADsPath");
         LOG(TEXT("Visiting ") + String(path));

         SmartInterface<IADsUser> user(0);
         hr = user.AcquireViaQueryInterface(*((IADs*)object));
         BREAK_ON_FAILED_HRESULT2(hr, L"QI->IADsUser");

         BSTR desc = 0;
         hr = user->get_Description(&desc);
         BREAK_ON_FAILED_HRESULT2(hr, L"get_Description");

         BSTR full = 0;
         hr = user->get_FullName(&full);
         BREAK_ON_FAILED_HRESULT2(hr, L"get_FullName");

         VARIANT_BOOL disabled = VARIANT_FALSE;
         hr = user->get_AccountDisabled(&disabled);
         BREAK_ON_FAILED_HRESULT2(hr, L"get_AccountDisabled");
          
         UserNode* node =
            new UserNode(
               owner,
               name,
               path,
               full,
               desc,
               disabled == VARIANT_TRUE ? true : false);
         ::SysFreeString(name);
         ::SysFreeString(path);
         ::SysFreeString(desc);
         ::SysFreeString(full);

         // transfer ownership of the node pointer to a SmartInterface in
         // the list....

         nodes.push_back(SmartInterface<ResultNode>(node));

         // ... and relinquish our hold on it.

         node->Release();
      }
      while (0);

      if (FAILED(hr))
      {
         popup.Error(
            owner->GetMainWindow(),
            hr,
            String::load(IDS_ERROR_VISITING_USER));
      }
   }

   private:

   FolderNode::ResultNodeList&   nodes;
   SmartInterface<ComponentData> owner;

   // not defined: no copying allowed

   UserVisitor(const UserVisitor&);
   const UserVisitor& operator=(const UserVisitor&);
};



void
UsersFolderNode::BuildResultItems(ResultNodeList& items)
{
   LOG_FUNCTION(UsersFolderNode::BuildResultItems);
   ASSERT(items.empty());

   UserVisitor visitor(items, GetOwner());
   ADSI::VisitChildren(
      ADSI::ComposeMachineContainerPath(GetOwner()->GetInternalComputerName()),
      ADSI::CLASS_User,
      visitor);
}



String
UsersFolderNode::GetDescriptionBarText()
{
   LOG_FUNCTION(UsersFolderNode::GetDescriptionBarText);

   return String::format(IDS_USERS_FOLDER_DESC, GetResultItemCount());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\uuids.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// UUIDS used in the Local Security Snapin
// 
// 8-18-97 sburns



#include "headers.hxx"
#include "uuids.hpp"
#include <localsec.h>



// DON'T EVER CHANGE THESE, OR YOU WILL BREAK ANY AND ALL EXTENSIONS
// TO THIS SNAPIN!

/* extern */ const CLSID CLSID_ComponentData =
{  /* 5d6179c8-17ec-11d1-9aa9-00c04fd8fe93 */
   0x5d6179c8,
   0x17ec,
   0x11d1,
   {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};

/* extern */ const CLSID CLSID_SnapinAbout =
{ /* 5d6179d2-17ec-11d1-9aa9-00c04fd8fe93 */
   0x5d6179d2,
   0x17ec,
   0x11d1,
   {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};

/* extern */ const NodeType NODETYPE_RootFolder =
{  /* 5d6179d3-17ec-11d1-9aa9-00c04fd8fe93 */
   0x5d6179d3,
   0x17ec,
   0x11d1,
   {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};

/* extern */ const NodeType NODETYPE_UsersFolder =
{  /* 5d6179c9-17ec-11d1-9aa9-00c04fd8fe93 */
   0x5d6179c9,
   0x17ec,
   0x11d1,
   {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};

/* extern */ const NodeType NODETYPE_GroupsFolder =
{ /* 5d6179ca-17ec-11d1-9aa9-00c04fd8fe93 */
   0x5d6179ca,
   0x17ec,
   0x11d1,
   {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};

/* extern */ const NodeType NODETYPE_User = LUM_USER_NODETYPE_GUID;

/* extern */ const NodeType NODETYPE_Group =
{ /* 5d6179cd-17ec-11d1-9aa9-00c04fd8fe93 */
   0x5d6179cd,
   0x17ec,
   0x11d1,
   {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};


const NodeType* nodetypes[] =
{
   &NODETYPE_RootFolder,
   &NODETYPE_UsersFolder,
   &NODETYPE_GroupsFolder,
   &NODETYPE_User,
   &NODETYPE_Group,
   0
};






// /* extern */ const NodeType NODETYPE_AdminRolesFolder =
// { /* 5d6179cb-17ec-11d1-9aa9-00c04fd8fe93 */
//    0x5d6179cb,
//    0x17ec,
//    0x11d1,
//    {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
// };

// /* extern */ const NodeType NODETYPE_PasswordPolicy =
// { /* 5d6179ce-17ec-11d1-9aa9-00c04fd8fe93 */
//    0x5d6179ce,
//    0x17ec,
//    0x11d1,
//    {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
// };

// /* extern */ const NodeType NODETYPE_AuditingPolicy =
// { /* 5d6179cf-17ec-11d1-9aa9-00c04fd8fe93 */
//    0x5d6179cf,
//    0x17ec,
//    0x11d1,
//    {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
// };
// 
// /* extern */ const NodeType NODETYPE_UserRightsPolicy =
// { /* 5d6179d0-17ec-11d1-9aa9-00c04fd8fe93 */
//    0x5d6179d0,
//    0x17ec,
//    0x11d1,
//    {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
// };
// 
// /* extern */ const NodeType NODETYPE_DataRecoveryPolicy =
// { /* 5d6179d1-17ec-11d1-9aa9-00c04fd8fe93 */
//    0x5d6179d1,
//    0x17ec,
//    0x11d1,
//    {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
// };
// 
// /* extern */ const NodeType NODETYPE_AdminRole =
// { /* 5d6179d4-17ec-11d1-9aa9-00c04fd8fe93 */
//    0x5d6179d4,
//    0x17ec,
//    0x11d1,
//    {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
// };
// 
// /* extern */ const NodeType NODETYPE_PoliciesFolder =
// { /* 5d6179d5-17ec-11d1-9aa9-00c04fd8fe93 */
//    0x5d6179d5,
//    0x17ec,
//    0x11d1,
//    {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
// };
// 
// /* extern */ const NodeType NODETYPE_TrustedCAList =
// { /* 5d6179d6-17ec-11d1-9aa9-00c04fd8fe93 */
//    0x5d6179d6,
//    0x17ec,
//    0x11d1,
//    {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
// };

// INTERFACENAME = { /* 5d6179d7-17ec-11d1-9aa9-00c04fd8fe93 */
//     0x5d6179d7,
//     0x17ec,
//     0x11d1,
//     {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
//   };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\waste.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// WasteExtractor class.  Now that sounds pleasant, doesn't it?
//
// 10-8-98 sburns



#include "headers.hxx"
#include "waste.hpp"




WasteExtractor::WasteExtractor(const String& wasteDump)
   :
   waste_dump(wasteDump)
{
   LOG_CTOR(WasteExtractor);
}



HRESULT
WasteExtractor::Clear(const String& propertyName)
{
   if (waste_dump.empty())
   {
      ASSERT(false);
      return E_INVALIDARG;
   }

   return setProperty(waste_dump, propertyName, 0, 0);
}



String
WasteExtractor::GetWasteDump() const
{
   LOG_FUNCTION(WasteExtractor::GetWasteDump);

   return waste_dump;
}



// S_OK => value exists, S_FALSE => value does not exist

HRESULT
WasteExtractor::IsPropertyPresent(const String& propertyName)
{
   HRESULT hr = getProperty(waste_dump, propertyName, 0, 0);

   return hr;
}



// S_OK on success, otherwise an error occurred.
//
// wasteDump - string containing the toxic waste dump bytes.  This is changed
// when the property is written.
//
// propertyName - name of the property to extract.
//
// valueBuffer - address of data to be written into the property.  If 0, then
// the property's value is removed.
//
// bufferLength - length, in bytes, of the value buffer.  If valueBuffer is 0,
// then this parameter is ignored.

HRESULT
WasteExtractor::setProperty(
   String&        wasteDump,
   const String&  propertyName,
   BYTE*          valueBuffer,
   int            bufferLength)
{
   LOG_FUNCTION2(WasteExtractor::setProperty, propertyName);

#ifdef DBG
   ASSERT(!propertyName.empty());
   if (valueBuffer)
   {
      ASSERT(bufferLength > 0);
   }
#endif

   UNICODE_STRING value;
   value.Buffer = reinterpret_cast<USHORT*>(valueBuffer);
   value.Length = (USHORT)bufferLength;
   value.MaximumLength = (USHORT)bufferLength;
   PWSTR new_waste = 0;
   BOOL  waste_updated = FALSE;
   HRESULT hr = S_OK;

   NTSTATUS status =
      ::NetpParmsSetUserProperty(
         const_cast<wchar_t*>(wasteDump.c_str()),
         const_cast<wchar_t*>(propertyName.c_str()),
         value,
         USER_PROPERTY_TYPE_ITEM,
         &new_waste,
         &waste_updated);

   if (!NT_SUCCESS(status))
   {
      hr = Win32ToHresult(::NetpNtStatusToApiStatus(status));
   }
   else if (waste_updated && new_waste)
   {
      wasteDump = new_waste;
   }

   if (new_waste)
   {
      ::NetpParmsUserPropertyFree(new_waste);
   }

   LOG_HRESULT(hr);

   return hr;
}




// S_OK on success, S_FALSE if property not found, otherwise an error
// occurred.
//
// wasteDump - string containing the toxic waste dump bytes.
//
// propertyName - name of the property to extract.
//
// valueBuffer - address of pointer to receive the address of a
// newly-allocated buffer containing property value, or 0, if the value is
// not to be returned.  Invoker must free this buffer with delete[].
//
// bufferLength - address of int to receive the length, in bytes, of the
// value returned in valueBuffer, or 0, if the length is not to be
// returned.

HRESULT
WasteExtractor::getProperty(
   const String&  wasteDump,
   const String&  propertyName,
   BYTE**         valueBuffer,
   int*           bufferLength)
{
   LOG_FUNCTION2(WasteExtractor::getProperty, propertyName);
   ASSERT(!propertyName.empty());

   HRESULT hr = S_FALSE;
   if (valueBuffer)
   {
      *valueBuffer = 0;
   }
   if (bufferLength)
   {
      *bufferLength = 0;
   }

   WCHAR unused = 0;
   UNICODE_STRING value;

   value.Buffer = 0;
   value.Length = 0;
   value.MaximumLength = 0;

   NTSTATUS status =
      ::NetpParmsQueryUserProperty(
         const_cast<wchar_t*>(wasteDump.c_str()),
         const_cast<wchar_t*>(propertyName.c_str()),
         &unused,
         &value);

   if (!NT_SUCCESS(status))
   {
      hr = Win32ToHresult(::NetpNtStatusToApiStatus(status));
   }
   else if (value.Length)
   {
      hr = S_OK;
      if (valueBuffer)
      {
         *valueBuffer = new BYTE[value.Length];
         memcpy(*valueBuffer, value.Buffer, value.Length);
      }
      if (bufferLength)
      {
         *bufferLength = value.Length;
      }
   }

   LOG_HRESULT(hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\uuids.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// UUIDS used in the Local Security Snapin
// 
// 8-18-97 sburns



#ifndef UUIDS_HPP_INCLUDED
#define UUIDS_HPP_INCLUDED



#include "node.hpp"



extern const CLSID CLSID_ComponentData;
extern const CLSID CLSID_SnapinAbout;

extern const NodeType NODETYPE_RootFolder;
extern const NodeType NODETYPE_UsersFolder;
extern const NodeType NODETYPE_GroupsFolder;
extern const NodeType NODETYPE_User;
extern const NodeType NODETYPE_Group;
extern const NodeType* nodetypes[];



#endif   // UUIDS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\waste.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// WasteExtractor class.  Now that sounds pleasant, doesn't it?
// 
// 10-8-98 sburns



#ifndef WASTE_HPP_INCLUDED
#define WASTE_HPP_INCLUDED



// Extracts stuff from the toxic waste dump (the SAM user account user
// parameters field) as a variety of data types.

// EPA license required to operate this class...

class WasteExtractor
{
   public:



   // copies the waste dump

   WasteExtractor(const String& wasteDump);



   // default dtor used

   HRESULT
   Clear(const String& propertyName);



   // Returns S_FALSE if the property is not present, S_OK if it was
   // present and was extracted, or an error code.

   template<class T>
   HRESULT
   Get(const String& propertyName, T& result)
   {
      BYTE* buf = 0;
      int len = 0;
      HRESULT hr = getProperty(waste_dump, propertyName, &buf, &len);

      if (hr == S_OK and buf)    // 447771 prefix warning
      {
         // property was found
         ASSERT(len == sizeof(T));

         result = *(reinterpret_cast<T*>(buf));
         delete[] buf;
      }

      return hr;
   }



   // specialization for Strings
   // Returns S_FALSE if the property is not present, S_OK if it was
   // present and was extracted, or an error code.

   HRESULT
   Get(const String& propertyName, String& result)
   {
      BYTE* buf = 0;
      int len = 0;
      HRESULT hr = getProperty(waste_dump, propertyName, &buf, &len);

      if (hr == S_OK and buf)
      {
         // property was found

         // convert to wide char.
         result = reinterpret_cast<PCSTR>(buf);
         delete[] buf;
      }

      return hr;
   }

   String
   GetWasteDump() const;

   // S_OK => value exists, S_FALSE => value does not exist

   HRESULT
   IsPropertyPresent(const String& propertyName);

   template<class T>
   HRESULT
   Put(const String& propertyName, const T& newValue)
   {
      return
         setProperty(
            waste_dump,
            propertyName,
            reinterpret_cast<BYTE*>(const_cast<T*>(&newValue)),
            sizeof(T));
   }

   // specialization for Strings

   HRESULT
   Put(const String& propertyName, const String& newValue)
   {
      // convert the wide string to ansi

      AnsiString s;
      if (newValue.convert(s) == String::CONVERT_FAILED)
      {
         return E_FAIL;
      }

      char* buf = const_cast<char*>(s.c_str());

      // determine the length, in bytes, of the buffer. add 1 for the null
      // terminator

      size_t bytes = strlen(buf) + 1;

      return
         setProperty(
            waste_dump,
            propertyName, 
            reinterpret_cast<BYTE*>(buf),
            static_cast<int>(bytes));
   }
            
   private:

   // Returns S_FALSE if the property is not present, S_OK if it was
   // present and was extracted, or an error code.

   static 
   HRESULT
   getProperty(
      const String&  wasteDump,
      const String&  propertyName,
      BYTE**         valueBuffer,
      int*           bufferLength);

   static
   HRESULT
   setProperty(
      String&        wasteDump,
      const String&  propertyName,
      BYTE*          valueBuffer,
      int            bufferLength);

   // not implemented: no copying allowed.
   WasteExtractor(const WasteExtractor&);
   const WasteExtractor& operator=(const WasteExtractor&);

   String waste_dump;
};
  


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mtfrmwk\aclpage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       aclpage.h
//
//--------------------------------------------------------------------------


#ifndef _ACLPAGE_H
#define _ACLPAGE_H

// aclpage.h : header file
//

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CISecurityInformationWrapper;
class CPropertyPageHolderBase;

//////////////////////////////////////////////////////////////////////////
// CAclEditorPage

class CAclEditorPage
{
public:
	static CAclEditorPage* CreateInstance(LPCTSTR lpszLDAPPath,
									CPropertyPageHolderBase* pPageHolder);
	static CAclEditorPage* CreateInstanceEx(LPCTSTR lpszLDAPPath,
															LPCTSTR lpszServer,
															LPCTSTR lpszUsername,
															LPCTSTR lpszPassword,
															DWORD	dwFlags,
															CPropertyPageHolderBase* pPageHolder);
	~CAclEditorPage();
	HPROPSHEETPAGE CreatePage();

private:
	// methods
	CAclEditorPage();
	void SetHolder(CPropertyPageHolderBase* pPageHolder)
	{ 
		ASSERT((pPageHolder != NULL) && (m_pPageHolder == NULL)); 
		m_pPageHolder = pPageHolder;
	}

	HRESULT Initialize(LPCTSTR lpszLDAPPath);
	HRESULT InitializeEx(LPCTSTR lpszLDAPPath,
								LPCTSTR lpszServer,
								LPCTSTR lpszUsername,
								LPCTSTR lpszPassword,
								DWORD dwFlags);
	
	// data
	CISecurityInformationWrapper* m_pISecInfoWrap;
	CPropertyPageHolderBase*	 m_pPageHolder;		// back pointer

	friend class CISecurityInformationWrapper;
};





#endif //_ACLPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\winstation.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// winsta.h wrapper functions
//
// 25 April 2001 sburns



#include "headers.hxx"
#include "WinStation.hpp"



HRESULT
WinStation::OpenServer(const String& serverName, HANDLE& result)
{
   LOG_FUNCTION2(WinStation::OpenServer, serverName);
   ASSERT(result == INVALID_HANDLE_VALUE);

   HRESULT hr = S_OK;

   if (serverName.empty())
   {
      result = SERVERNAME_CURRENT;
   }
   else
   {
      ::SetLastError(0);

      result =
         WinStationOpenServer(const_cast<PWSTR>(serverName.c_str()));

      if (result == 0 || result == INVALID_HANDLE_VALUE)
      {
         hr = Win::GetLastErrorAsHresult();
      }
   }

   LOG_HRESULT(hr);

   return hr;
}



HRESULT
WinStation::Enumerate(
   HANDLE    serverHandle,
   LOGONID*& sessionList, 
   DWORD&    sessionCount)
{
   LOG_FUNCTION(WinStation::Enumerate);
   ASSERT(serverHandle != INVALID_HANDLE_VALUE);

   sessionList = 0;
   sessionCount = 0;
   HRESULT hr = S_OK;

   BOOLEAN succeeded =
      WinStationEnumerate(serverHandle, &sessionList, &sessionCount);

   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   LOG_HRESULT(hr);
   
   return hr;
}



HRESULT
WinStation::QueryInformation(
   HANDLE                 serverHandle,
   ULONG                  logonId,     
   WINSTATIONINFORMATION& result)      
{
   LOG_FUNCTION(WinStation::QueryInformation);
   ASSERT(serverHandle != INVALID_HANDLE_VALUE);

   HRESULT hr = S_OK;
   
   ::ZeroMemory(&result, sizeof result);

   DWORD unused = 0;
   
   BOOLEAN succeeded =
      WinStationQueryInformation(
         serverHandle,
         logonId,
         WinStationInformation,
         &result,
         sizeof result,
         &unused);
   
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   LOG_HRESULT(hr);
   
   return hr;
}



void
WinStation::FreeMemory(void* mem)
{
   LOG_FUNCTION(WinStation::FreeMemory);

   BOOLEAN succeeded = WinStationFreeMemory(mem);

   ASSERT(succeeded);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\localsec\src\winstation.hpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// winsta.h wrapper functions
//
// 25 April 2001 sburns



#ifndef WINSTATION_HPP_INCLUDED
#define WINSTATION_HPP_INCLUDED



// Wrappers of functions in the internal winsta.h header. These wrapped
// functions are remoteable over RPC to machines with terminal server
// installed. If it is not installed, they fail w/ RPC server unavailable.

namespace WinStation
{
   HRESULT
   OpenServer(const String& serverName, HANDLE& result);



   // If the machine is in safe mode, this will fail with
   // RPC_S_INVALID_BINDING.
   //
   // serverHandle - in, valid handle opened with WinStation::OpenServer
   //
   // sessionList - out, receives an array of logon session IDs. Caller must
   // deallocate this memory with WinStation::FreeMemory.
   //
   // sessionCount - out, receives the number of logon session IDs in the
   // sessionList result.

   HRESULT
   Enumerate(
      HANDLE    serverHandle,
      LOGONID*& sessionList, 
      DWORD&    sessionCount);



   HRESULT
   QueryInformation(
      HANDLE                 serverHandle,
      ULONG                  logonId,     
      WINSTATIONINFORMATION& result);



   void
   FreeMemory(void* mem);
     
}



#endif   // WINSTATION_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mtfrmwk\compbase.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       compbase.h
//
//--------------------------------------------------------------------------

#ifndef _COMPBASE_H
#define _COMPBASE_H


///////////////////////////////////////////////////////////////////////////////
// Base classes implementing the IComponent and IComponentData interfaces
///////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// IConsole::UpdateAllViews() : values for the Hint argument

#define ADD_RESULT_ITEM				( 0x00000001 )
#define DELETE_RESULT_ITEM			( 0x00000002 )
#define CHANGE_RESULT_ITEM_DATA		( 0x00000004 )
#define CHANGE_RESULT_ITEM_ICON		( 0x00000008 )
#define CHANGE_RESULT_ITEM			( CHANGE_RESULT_ITEM_DATA | CHANGE_RESULT_ITEM_ICON )
#define REPAINT_RESULT_PANE			( 0x00000010 )
#define DELETE_ALL_RESULT_ITEMS		( 0x00000011 )
#define UPDATE_VERB_STATE			( 0x00000012 )
#define SORT_RESULT_PANE			( 0x00000013 )
#define UPDATE_DESCRIPTION_BAR ( 0x00000100 )
#define UPDATE_RESULT_PANE_VIEW ( 0x00000200 )
#define DELETE_MULTIPLE_RESULT_ITEMS ( 0x00000400)

///////////////////////////////////////////////////////////////////////////////
// DATA STRUCTURES

extern DWORD _MainThreadId;
extern CString LOGFILE_NAME;

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CComponentDataObject;		
class CComponentObject;			
class CRootData;				
class CTreeNode;				
class CContainerNode;			
class CMTContainerNode;			
class CLeafNode;				
class CPropertyPageHolderTable;

///////////////////////////////////////////////////////////////////////////////
// global functions


struct _NODE_TYPE_INFO_ENTRY
{
	const GUID* m_pNodeGUID;
	LPCTSTR		m_lpszNodeDescription;
};


HRESULT RegisterSnapin(const GUID* pSnapinCLSID,
                       const GUID* pStaticNodeGUID,
                       const GUID* pAboutGUID,
					   LPCTSTR lpszNameString, LPCTSTR lpszVersion, LPCTSTR lpszProvider,
             BOOL bExtension, _NODE_TYPE_INFO_ENTRY* pNodeTypeInfoEntryArray,
             UINT nSnapinNameID = 0);

HRESULT UnregisterSnapin(const GUID* pSnapinCLSID);

HRESULT RegisterNodeType(const GUID* pGuid, LPCTSTR lpszNodeDescription);
HRESULT UnregisterNodeType(const GUID* pGuid);

HRESULT RegisterNodeExtension(const GUID* pNodeGuid, LPCTSTR lpszExtensionType,
							  const GUID* pExtensionSnapinCLSID, LPCTSTR lpszDescription, BOOL bDynamic);
HRESULT UnregisterNodeExtension(const GUID* pNodeGuid, LPCTSTR lpszExtensionType,
							  const GUID* pExtensionSnapinCLSID, BOOL bDynamic);

/////////////////////////////////////////////////////////////////////////////
// CTimerThread

class CTimerThread : public CWinThread
{
public:
	CTimerThread() { m_bAutoDelete = FALSE; m_hWnd = 0;}

	BOOL Start(HWND hWnd);
	virtual BOOL InitInstance() { return TRUE; }	// MFC override
	virtual int Run() { return -1;}					// MFC override

protected:
	BOOL PostMessageToWnd(WPARAM wParam, LPARAM lParam);
private:
	HWND					m_hWnd;

};


/////////////////////////////////////////////////////////////////////////////
// CWorkerThread

class CWorkerThread : public CWinThread
{
public:
	CWorkerThread();
	virtual ~CWorkerThread();

	BOOL Start(HWND hWnd);
	virtual BOOL InitInstance() { return TRUE; }	// MFC override
	virtual int Run() { return -1;}					// MFC override

	void Lock() { ::EnterCriticalSection(&m_cs); }
	void Unlock() { ::LeaveCriticalSection(&m_cs); }

	void Abandon();
	BOOL IsAbandoned();

	void AcknowledgeExiting() { VERIFY(0 != ::SetEvent(m_hEventHandle));}

protected:
	virtual void OnAbandon() {}

protected:
	BOOL PostMessageToWnd(UINT Msg, WPARAM wParam, LPARAM lParam);
	void WaitForExitAcknowledge();

private:
	CRITICAL_SECTION		m_cs;	
	HANDLE					m_hEventHandle;

	HWND					m_hWnd;
	BOOL					m_bAbandoned;
};



////////////////////////////////////////////////////////////////////
// CHiddenWnd : Hidden window to syncronize threads and CComponentData object

class CHiddenWnd : public CHiddenWndBase
{
public:
	CHiddenWnd(CComponentDataObject* pComponentDataObject);

	static const UINT s_NodeThreadHaveDataNotificationMessage;
	static const UINT s_NodeThreadErrorNotificationMessage;
	static const UINT s_NodeThreadExitingNotificationMessage;

	static const UINT s_NodePropertySheetCreateMessage;
	static const UINT s_NodePropertySheetDeleteMessage;	

	static const UINT s_ExecCommandMessage;		
	static const UINT s_ForceEnumerationMessage;			
	static const UINT s_TimerThreadMessage;			

	UINT_PTR m_nTimerID;
private:
	CComponentDataObject* m_pComponentDataObject; // back pointer
public:

	BEGIN_MSG_MAP(CHiddenWnd)
	  MESSAGE_HANDLER( CHiddenWnd::s_NodeThreadHaveDataNotificationMessage, OnNodeThreadHaveDataNotification )
	  MESSAGE_HANDLER( CHiddenWnd::s_NodeThreadErrorNotificationMessage, OnNodeThreadErrorNotification )
	  MESSAGE_HANDLER( CHiddenWnd::s_NodeThreadExitingNotificationMessage, OnNodeThreadExitingNotification )

	  MESSAGE_HANDLER( CHiddenWnd::s_NodePropertySheetCreateMessage, OnNodePropertySheetCreate )
	  MESSAGE_HANDLER( CHiddenWnd::s_NodePropertySheetDeleteMessage, OnNodePropertySheetDelete )
	  
	  MESSAGE_HANDLER( CHiddenWnd::s_ExecCommandMessage, OnExecCommand )
	  MESSAGE_HANDLER( CHiddenWnd::s_ForceEnumerationMessage, OnForceEnumeration )
	  MESSAGE_HANDLER( CHiddenWnd::s_TimerThreadMessage, OnTimerThread )

    MESSAGE_HANDLER( WM_TIMER, OnTimer )
	    
    CHAIN_MSG_MAP(CHiddenWndBase)
  END_MSG_MAP()

	LRESULT OnNodeThreadHaveDataNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnNodeThreadErrorNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnNodeThreadExitingNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnNodePropertySheetCreate(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnNodePropertySheetDelete(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnExecCommand(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnForceEnumeration(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnTimerThread(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

	LRESULT OnTimer(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};

////////////////////////////////////////////////////////////////////////////////////
// CRunningThreadTable
// all CMTContainerNode with running refresh/enumerate background threads will
// register/unregister in this table to allow proper thread abandoning at shutdown

class CRunningThreadTable
{
public:
	CRunningThreadTable(CComponentDataObject* pComponentData);
	~CRunningThreadTable();

	void Add(CMTContainerNode* pNode);
	void Remove(CMTContainerNode* pNode);
	void RemoveAll();
  BOOL IsPresent(CMTContainerNode* pNode);

private:
	CComponentDataObject* m_pComponentData; // back pointer

	CMTContainerNode** m_pEntries;
	int m_nSize;
};
	


////////////////////////////////////////////////////////////////////////////////////
// CExecContext

class CExecContext
{
public:
	CExecContext();
	~CExecContext();
	virtual void Execute(LPARAM arg) = 0; // code to be executed from main thread
	void Wait();	// secondary thread waits on this call
	void Done();	// called when main thread done executing
private:
	HANDLE	m_hEventHandle;
};


////////////////////////////////////////////////////////////////////////////////////
// CNotificationSinkBase

class CNotificationSinkBase
{
public:
	virtual void OnNotify(DWORD dwEvent, WPARAM dwArg1, LPARAM dwArg2) = 0;
};

////////////////////////////////////////////////////////////////////////////////////
// CNotificationSinkEvent

class CNotificationSinkEvent : public CNotificationSinkBase
{
public:
	CNotificationSinkEvent();
	~CNotificationSinkEvent();

public:
	void OnNotify(DWORD dwEvent, WPARAM dwArg1, LPARAM dwArg2);
	virtual void Wait();
private:
	HANDLE	m_hEventHandle;
};


////////////////////////////////////////////////////////////////////////////////////
// CNotificationSinkTable

class CNotificationSinkTable
{
public:
	CNotificationSinkTable();
	~CNotificationSinkTable();
	
	void Advise(CNotificationSinkBase* p);
	void Unadvise(CNotificationSinkBase* p);
	void Notify(DWORD dwEvent, WPARAM dwArg1, LPARAM dwArg2);

private:
	void Lock()
	{
		TRACE(_T("CNotificationSinkTable::Lock()\n"));
		::EnterCriticalSection(&m_cs);
	}
	void Unlock()
	{
		TRACE(_T("CNotificationSinkTable::Unlock()\n"));
		::LeaveCriticalSection(&m_cs);
	}

	CRITICAL_SECTION m_cs;
	CNotificationSinkBase**	m_pEntries;
	int m_nSize;
};



////////////////////////////////////////////////////////////////////////////////////
// CPersistStreamImpl

class CPersistStreamImpl : public IPersistStream
{
public:
	HRESULT STDMETHODCALLTYPE GetClassID(CLSID* pClassID) = 0;
  HRESULT STDMETHODCALLTYPE IsDirty() = 0;
  HRESULT STDMETHODCALLTYPE Load(IStream __RPC_FAR *pStm) = 0;
  HRESULT STDMETHODCALLTYPE Save(IStream __RPC_FAR *pStm, BOOL fClearDirty) = 0;
  HRESULT STDMETHODCALLTYPE GetSizeMax(ULARGE_INTEGER *pcbSize)
	{
		ASSERT(FALSE);

    //
		// arbitrary value, do we ever get called?
    //
		pcbSize->LowPart = 0xffff;
    pcbSize->HighPart= 0x0;
		return S_OK;
	}
};

///////////////////////////////////////////////////////////////////////////////
// CWatermarkInfo

class CWatermarkInfo
{
public:
	CWatermarkInfo()
	{
		m_nIDBanner = 0;
		m_nIDWatermark = 0;
		m_hPalette = NULL;
		m_bStretch = TRUE;
	}
	UINT		m_nIDBanner;
	UINT		m_nIDWatermark;
	HPALETTE	m_hPalette;
	BOOL		m_bStretch;
};



////////////////////////////////////////////////////////////////////////////////
// CColumn

class CColumn
{
public:
  CColumn(LPCWSTR lpszColumnHeader,
          int nFormat,
          int nWidth,
          UINT nColumnNum) 
  {
    m_lpszColumnHeader = NULL;
    SetHeader(lpszColumnHeader);
    m_nFormat = nFormat;
    m_nWidth = nWidth;
    m_nColumnNum = nColumnNum;
  }

  ~CColumn() 
  {
    free(m_lpszColumnHeader);
  }

  LPCWSTR GetHeader() { return (LPCWSTR)m_lpszColumnHeader; }
  void SetHeader(LPCWSTR lpszColumnHeader) 
  { 
    if (m_lpszColumnHeader != NULL)
    {
      free(m_lpszColumnHeader);
    }
    size_t iLen = wcslen(lpszColumnHeader);
    m_lpszColumnHeader = (LPWSTR)malloc(sizeof(WCHAR) * (iLen + 1));
    if (m_lpszColumnHeader != NULL)
    {
      wcscpy(m_lpszColumnHeader, lpszColumnHeader);
    }
  }

  int  GetFormat() { return m_nFormat; }
  void SetFormat(int nFormat) { m_nFormat = nFormat; }
  int  GetWidth() { return m_nWidth; }
  void SetWidth(int nWidth) { m_nWidth = nWidth; }
  UINT GetColumnNum() { return m_nColumnNum; }
  void SetColumnNum(UINT nColumnNum) { m_nColumnNum = nColumnNum; }

protected:
  LPWSTR m_lpszColumnHeader;
  int   m_nFormat;
  int   m_nWidth;
  UINT  m_nColumnNum;
};


////////////////////////////////////////////////////////////////////////////////
// CColumnSet

class CColumnSet : public CList<CColumn*, CColumn*>
{
public :          
	CColumnSet(LPCWSTR lpszColumnID) 
	{
		// Make a copy of the column set ID
    size_t iLen = wcslen(lpszColumnID);
    m_lpszColumnID = (LPWSTR)malloc(sizeof(WCHAR) * (iLen + 1));
    if (m_lpszColumnID != NULL)
    {
      wcscpy(m_lpszColumnID, lpszColumnID);
    }
  }

	CColumnSet(LPCWSTR lpszColumnID, CList<CColumn*, CColumn*>&)
	{
		// Make a copy of the column set ID
    size_t iLen = wcslen(lpszColumnID);
    m_lpszColumnID = (LPWSTR)malloc(sizeof(WCHAR) * (iLen + 1));
    wcscpy(m_lpszColumnID, lpszColumnID);
  }

	~CColumnSet() 
	{
    while(!IsEmpty())
    {
      CColumn* pColumn = RemoveTail();
      delete pColumn;
    }
		free(m_lpszColumnID);
	}

  void AddColumn(LPCWSTR lpszHeader, int nFormat, int nWidth, UINT nCol)
  {
    CColumn* pNewColumn = new CColumn(lpszHeader, nFormat, nWidth, nCol);
    AddTail(pNewColumn);
  }

	LPCWSTR GetColumnID() { return (LPCWSTR)m_lpszColumnID; }

	UINT GetNumCols() { return static_cast<UINT>(GetCount()); }

private :
	LPWSTR m_lpszColumnID;
};

////////////////////////////////////////////////////////////////////////////////
// CColumnSetList

class CColumnSetList : public CList<CColumnSet*, CColumnSet*>
{
public :
	// Find the column set given a column set ID
	CColumnSet* FindColumnSet(LPCWSTR lpszColumnID)
	{
		POSITION pos = GetHeadPosition();
		while (pos != NULL)
		{
			CColumnSet* pTempSet = GetNext(pos);
			ASSERT(pTempSet != NULL);

			LPCWSTR lpszTempNodeID = pTempSet->GetColumnID();

			if (wcscmp(lpszTempNodeID, lpszColumnID) == 0)
			{
				return pTempSet;
			}
		}
		return NULL;
	}

	void RemoveAndDeleteAllColumnSets()
	{
		while (!IsEmpty())
		{
			CColumnSet* pTempSet = RemoveTail();
			delete pTempSet;
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
// CComponentDataObject
// * this class contains the master tree data (i.e. the "document")
// * base class, have to derive from it


class CWatermarkInfoState; // fwd decl of private class

class CComponentDataObject:
  public IComponentData,
  public IExtendPropertySheet2,
	public IExtendContextMenu,
	public CPersistStreamImpl,
  public ISnapinHelp2,
  public IRequiredExtensions,
  public CComObjectRoot
{

BEGIN_COM_MAP(CComponentDataObject)
	COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet2)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IPersistStream)
  COM_INTERFACE_ENTRY(ISnapinHelp2)
  COM_INTERFACE_ENTRY(IRequiredExtensions)
END_COM_MAP()

#ifdef _DEBUG_REFCOUNT
	static unsigned int m_nOustandingObjects; // # of objects created
	int dbg_cRef;
    ULONG InternalAddRef()
    {
		++dbg_cRef;
		TRACE(_T("CComponentDataObject::InternalAddRef() refCount = %d\n"), dbg_cRef);
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
		--dbg_cRef;
		TRACE(_T("CComponentDataObject::InternalRelease() refCount = %d\n"), dbg_cRef);
        return CComObjectRoot::InternalRelease();
    }
#endif // _DEBUG_REFCOUNT

	CComponentDataObject();
	virtual ~CComponentDataObject();
	HRESULT FinalConstruct();
	void FinalRelease();

public:
// IComponentData interface members
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent) = 0; // must override
	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
	STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IExtendPropertySheet2 interface members
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        LONG_PTR handle,
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);
    STDMETHOD(GetWatermarks)(LPDATAOBJECT lpDataObject, HBITMAP* lphWatermark, HBITMAP* lphHeader,
                                    HPALETTE* lphPalette, BOOL* pbStretch);

    HRESULT CreatePropertySheet(CTreeNode* pNode, HWND hWndParent, LPCWSTR lpszTitle);

public:

  //
  // IExtendContextMenu interface members
  //
	STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
							LPCONTEXTMENUCALLBACK pCallbackUnknown,
							long *pInsertionAllowed);
	STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);
  
  //
  // IPersistStream interface members
  //
  STDMETHOD(IsDirty)();
	STDMETHOD(Load)(IStream __RPC_FAR *pStm);
  STDMETHOD(Save)(IStream __RPC_FAR *pStm, BOOL fClearDirty);

  //
  // ISnapinHelp2 interface members
  //
  STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);
  STDMETHOD(GetLinkedTopics)(LPOLESTR* lpCompiledHelpFile);

  //
  // IRequiredExtensions interface members
  //
  STDMETHOD(EnableAllExtensions)() { return S_OK;} // load all always
  STDMETHOD(GetFirstExtension)(LPCLSID) { return S_FALSE;} // should not be called
  STDMETHOD(GetNextExtension)(LPCLSID) { return S_FALSE;} // should not be called

// virtual functions
protected:
	virtual HRESULT OnSetImages(LPIMAGELIST lpScopeImage) = 0; // must override
	virtual HRESULT OnExtensionExpand(LPDATAOBJECT, LPARAM)
		{ return E_FAIL;}
  virtual HRESULT OnRemoveChildren(LPDATAOBJECT lpDataObject, LPARAM arg);

// Notify handler declarations
private:
  HRESULT OnAdd(CTreeNode* cookie, LPARAM arg, LPARAM param);
  HRESULT OnRename(CInternalFormatCracker& ifc, LPARAM arg, LPARAM param);
  HRESULT OnExpand(CInternalFormatCracker& ifc, 
                   LPARAM arg, 
                   LPARAM param, 
                   BOOL bAsync = TRUE);
  HRESULT OnSelect(CInternalFormatCracker& ifc, LPARAM arg, LPARAM param);
  HRESULT OnContextMenu(CTreeNode* cookie, LPARAM arg, LPARAM param);
  HRESULT OnPropertyChange(LPARAM param, long fScopePane);

// Scope item creation helpers
private:
    void EnumerateScopePane(CTreeNode* cookie, 
                            HSCOPEITEM pParent, 
                            BOOL bAsync = TRUE);
    BOOL IsScopePaneNode(LPDATAOBJECT lpDataObject);

// Helpers

public:
	LPCONSOLE GetConsole() { return m_pConsole;}

	HRESULT OnDeleteVerbHandler(CInternalFormatCracker& ifc, CComponentObject* pComponentObject);
	HRESULT OnRefreshVerbHandler(CInternalFormatCracker& ifc);
	HRESULT OnHelpHandler(CInternalFormatCracker& ifc, CComponentObject* pComponentObject);

	HRESULT AddNode(CTreeNode* pNodeToAdd);
  HRESULT AddNodeSorted(CTreeNode* pNodeToAdd);
	HRESULT DeleteNode(CTreeNode* pNodeToDelete);
  HRESULT DeleteMultipleNodes(CNodeList* pNodeList);
	HRESULT ChangeNode(CTreeNode* pNodeToChange, long changeMask);
	HRESULT UpdateVerbState(CTreeNode* pNodeToChange);
	HRESULT RemoveAllChildren(CContainerNode* pNode);
	HRESULT RepaintSelectedFolderInResultPane();
	HRESULT RepaintResultPane(CContainerNode* pNode);
	HRESULT DeleteAllResultPaneItems(CContainerNode* pNode);
	HRESULT SortResultPane(CContainerNode* pContainerNode);
  HRESULT UpdateResultPaneView(CContainerNode* pContainerNode);

	CPropertyPageHolderTable* GetPropertyPageHolderTable() { return &m_PPHTable; }
	CRunningThreadTable* GetRunningThreadTable() { return &m_RTTable; }
	CNotificationSinkTable* GetNotificationSinkTable() { return &m_NSTable; }

  void WaitForThreadExitMessage(CMTContainerNode* pNode);

	CWatermarkInfo* SetWatermarkInfo(CWatermarkInfo* pWatermarkInfo);

	BOOL IsExtensionSnapin() { return m_bExtensionSnapin; }

  void SetLogFileName(PCWSTR pszLogName) { LOGFILE_NAME = pszLogName; }

protected:
	void SetExtensionSnapin(BOOL bExtensionSnapin)
			{ m_bExtensionSnapin = bExtensionSnapin;}

private:
	HRESULT UpdateAllViewsHelper(LPARAM data, LONG_PTR hint);
	void HandleStandardVerbsHelper(CComponentObject* pComponentObj,
									LPCONSOLEVERB pConsoleVerb,
									BOOL bScope, BOOL bSelect,
									LPDATAOBJECT lpDataObject);
protected:
	virtual HRESULT SnapinManagerCreatePropertyPages(LPPROPERTYSHEETCALLBACK,
										LONG_PTR) {return S_FALSE; }
	virtual BOOL HasPropertyPages(DATA_OBJECT_TYPES) {return FALSE; }
	
	virtual void OnInitialize();
	virtual void OnDestroy();

	// help handling
  virtual LPCWSTR GetHTMLHelpFileName() { return NULL; }
	BOOL WinHelp(LPCTSTR lpszHelpFileName, UINT uCommand, DWORD dwData);
	virtual void OnNodeContextHelp(CTreeNode*){}
  virtual void OnNodeContextHelp(CNodeList*) {}

public:
	virtual void OnDialogContextHelp(UINT, HELPINFO*) {}

  virtual BOOL IsMultiSelect() { return FALSE; }

// Scope pane helpers
public:

protected:
	HRESULT AddContainerNode(CContainerNode* pNodeToInsert, HSCOPEITEM pParentScopeItem);
	HRESULT AddContainerNodeSorted(CContainerNode* pNodeToInsert, HSCOPEITEM pParentScopeItem);

private:
	HRESULT DeleteContainerNode(CContainerNode* pNodeToDelete);
	HRESULT ChangeContainerNode(CContainerNode* pNodeToChange, long changeMask);
	void InitializeScopeDataItem(LPSCOPEDATAITEM pScopeDataItem, HSCOPEITEM pParentScopeItem, LPARAM lParam,
									  int nImage, int nOpenImage, BOOL bHasChildren);

// Column Set helpers
public:
	CColumnSetList* GetColumnSetList() { return &m_ColList; }

private:
	CColumnSetList m_ColList;

// Result pane helpers
public:

protected:

private:
	HRESULT AddLeafNode(CLeafNode* pNodeToAdd);
	HRESULT DeleteLeafNode(CLeafNode* pNodeToDelete);
	HRESULT ChangeLeafNode(CLeafNode* pNodeToChange, long changeMask);

// Attributes
private:
	LPCONSOLE					      m_pConsole;				// IConsole interface pointer
  LPCONSOLENAMESPACE2			  m_pConsoleNameSpace;    // IConsoleNameSpace interface pointer

	CPropertyPageHolderTable	m_PPHTable;				// property page holder table
	CRunningThreadTable			  m_RTTable;				// table of running MT nodes
	CNotificationSinkTable		m_NSTable;				// notification sink table, for advise in events

	CWatermarkInfoState*      m_pWatermarkInfoState;		// internal watermark info for Wizards
	BOOL						m_bExtensionSnapin;		// is this an extension?

// critical section (Serialization of calls to console)
public:
	void Lock() { ::EnterCriticalSection(&m_cs); }
	void Unlock() { ::LeaveCriticalSection(&m_cs); }
private:
	CRITICAL_SECTION			m_cs;					// general purpose critical section

// RootData
protected:
	CRootData* m_pRootData; // root node for the cache
	virtual CRootData* OnCreateRootData() = 0; // must override
public:
	CRootData* GetRootData() { ASSERT(m_pRootData != NULL); return m_pRootData;}

// Hidden window
private:
	CHiddenWnd m_hiddenWnd;		//	syncronization with background threads
  CTimerThread* m_pTimerThreadObj; // timer thread object
	HWND m_hWnd;				// thread safe HWND (gotten from the MFC CWnd)
public:
	BOOL PostExecMessage(CExecContext* pExec, LPARAM arg); // call from secondary thread
	BOOL PostForceEnumeration(CMTContainerNode* pContainerNode); // call from secondary thread
	HWND GetHiddenWindow() { ASSERT(m_hWnd != NULL); return m_hWnd;}

	BOOL OnCreateSheet(CPropertyPageHolderBase* pPPHolder, HWND hWnd);
	BOOL OnDeleteSheet(CPropertyPageHolderBase* pPPHolder, CTreeNode* pNode);

  HRESULT SetDescriptionBarText(CTreeNode* pTreeNode);

// Timer and Background Thread
public:
	BOOL StartTimerThread();
	void ShutDownTimerThread();
	BOOL PostMessageToTimerThread(UINT Msg, WPARAM wparam, LPARAM lParam);
	DWORD GetTimerInterval() { return m_dwTimerInterval;}
	
protected:
	DWORD m_dwTimerTime;	// sec

	// overrides that MUST be implemented
	virtual void OnTimer() { ASSERT(FALSE); }
	virtual void OnTimerThread(WPARAM, LPARAM) { ASSERT(FALSE); }
	virtual CTimerThread* OnCreateTimerThread() { return NULL; }
private:
	BOOL SetTimer();
	void KillTimer();
	void WaitForTimerThreadStartAck();
	DWORD m_nTimerThreadID;
	BOOL m_bTimerThreadStarted;
	DWORD m_dwTimerInterval; // sec

// friend class declarations
	friend class CDataObject; // for the GetRootData() member
	friend class CComponentObject; // for the FindObject() and OnPropertyChange() members
	friend class CHiddenWnd;
};


	
///////////////////////////////////////////////////////////////////////////////
// CComponentObject
// * this class is the view on the data contained in the "document"
// * base class, have to derive from it

class CComponentObject :
  public IComponent,
  public IExtendPropertySheet2,
	public IExtendContextMenu,
  public IExtendControlbar,
	public IResultDataCompareEx,
	public CComObjectRoot
{
public:

#ifdef _DEBUG_REFCOUNT
	static unsigned int m_nOustandingObjects; // # of objects created
	int dbg_cRef;
  ULONG InternalAddRef()
  {
		++dbg_cRef;
    return CComObjectRoot::InternalAddRef();
  }
  ULONG InternalRelease()
  {
		--dbg_cRef;
    return CComObjectRoot::InternalRelease();
  }
#endif // _DEBUG_REFCOUNT

	CComponentObject();
	virtual ~CComponentObject();

BEGIN_COM_MAP(CComponentObject)
	COM_INTERFACE_ENTRY(IComponent)
  COM_INTERFACE_ENTRY(IExtendPropertySheet2)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
  COM_INTERFACE_ENTRY(IExtendControlbar)
  COM_INTERFACE_ENTRY(IResultDataCompareEx)
END_COM_MAP()

public:
  //
  // IComponent interface members
  //
  STDMETHOD(Initialize)(LPCONSOLE lpConsole);
  STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
  STDMETHOD(Destroy)(MMC_COOKIE cookie);
  STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions);
  STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                      LPDATAOBJECT* ppDataObject);
  STDMETHOD(GetDisplayInfo)(LPRESULTDATAITEM  pResultDataItem);
	STDMETHOD(CompareObjects)( LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

  //
  // IExtendPropertySheet2 interface members
  //
  STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                                 LONG_PTR handle,
                                 LPDATAOBJECT lpIDataObject);
  STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);
  STDMETHOD(GetWatermarks)(LPDATAOBJECT lpDataObject, HBITMAP* lphWatermark, HBITMAP* lphHeader,
                                  HPALETTE* lphPalette, BOOL* pbStretch);

  //
  // IExtendContextMenu interface members
  //
	STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
		            					LPCONTEXTMENUCALLBACK pCallbackUnknown,
							            long *pInsertionAllowed);
	STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

  //
  // IExtendControlbar interface memebers
  //
  STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
  STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE type, LPARAM arg, LPARAM param);

  //
  // IResultDataCompare
  //
  STDMETHOD(Compare)(RDCOMPARE* prdc, int* pnResult);

// Helpers for CComponentObject
public:
  void SetIComponentData(CComponentDataObject* pData);
	void SetSelectedNode(CTreeNode* pSelectedNode, DATA_OBJECT_TYPES selectedType)
	{ m_pSelectedNode = pSelectedNode; m_selectedType = selectedType; }

// Notify event handlers
protected:
  HRESULT OnFolder(CTreeNode* cookie, LPARAM arg, LPARAM param);
  HRESULT OnShow(CInternalFormatCracker& ifc, LPARAM arg, LPARAM param);
  HRESULT OnActivate(CTreeNode* cookie, LPARAM arg, LPARAM param);
	HRESULT OnResultItemClk(CInternalFormatCracker& ifc, BOOL fDblClick);
  HRESULT OnMinimize(CInternalFormatCracker& ifc, LPARAM arg, LPARAM param);
  HRESULT OnPropertyChange(LPARAM param, long fScopePane);
  HRESULT OnUpdateView(LPDATAOBJECT lpDataObject, LPARAM data, LONG_PTR hint);
	HRESULT OnAddImages(CInternalFormatCracker& ifc, LPARAM arg, LPARAM param);
  HRESULT SetDescriptionBarText(CTreeNode* pTreeNode);

	// Added by JEFFJON : response to MMCN_COLUMNS_CHANGED
	HRESULT OnColumnsChanged(CInternalFormatCracker& ifc, LPARAM arg, LPARAM param);
	HRESULT OnColumnSortChanged(LPARAM arg, LPARAM param);

// Helper functions
protected:
  BOOL IsEnumerating(LPDATAOBJECT lpDataObject);
  void Construct();
  void LoadResources();
  virtual HRESULT InitializeHeaders(CContainerNode* pContainerNode) = 0;
  virtual HRESULT InitializeToolbar(IToolbar*) { return E_NOTIMPL; }

public:
	HRESULT ForceSort(UINT iCol, DWORD dwDirection);

protected:
  void EnumerateResultPane(CContainerNode* pContainerNode);

// Result pane helpers
  virtual HRESULT InitializeBitmaps(CTreeNode* cookie) = 0;
	void HandleStandardVerbs(BOOL bScope, BOOL bSelect, LPDATAOBJECT lpDataObject);
	HRESULT AddResultPaneItem(CLeafNode* pNodeToInsert);
	HRESULT DeleteResultPaneItem(CLeafNode* pNodeToDelete);
	HRESULT ChangeResultPaneItem(CLeafNode* pNodeToChange, LONG_PTR changeMask);
	HRESULT FindResultPaneItemID(CLeafNode* pNode, HRESULTITEM* pItemID);

// Interface pointers
protected:
  LPCONSOLE          m_pConsole;			// IConsole interface pointer
  LPHEADERCTRL        m_pHeader;			// Result pane's header control interface
  LPRESULTDATA        m_pResult;          // My interface pointer to the result pane
  LPIMAGELIST         m_pImageResult;     // My interface pointer to the result pane image list
  LPTOOLBAR           m_pToolbar;         // Toolbar for view
  LPCONTROLBAR        m_pControlbar;      // control bar to hold my tool bars
  LPCONSOLEVERB       m_pConsoleVerb;		// pointer the console verb

	LPCOMPONENTDATA     m_pComponentData;   // Pointer to the IComponentData this object belongs to

// state variables for this window
	CContainerNode*		m_pSelectedContainerNode;	// scope item selection (MMCN_SHOW)
	CTreeNode*			m_pSelectedNode;			// item selection (MMC_SELECT)
	DATA_OBJECT_TYPES	m_selectedType;				// matching m_pSelectedNode
};

inline void CComponentObject::SetIComponentData(CComponentDataObject* pData)
{
	TRACE(_T("CComponentObject::SetIComponentData()\n"));
    ASSERT(pData);
    ASSERT(m_pComponentData == NULL);
    LPUNKNOWN pUnk = pData->GetUnknown(); // does not addref
    HRESULT hr;

    hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void**>(&m_pComponentData));

    ASSERT(hr == S_OK);
}


#define FREE_INTERNAL(pInternal) \
    ASSERT(pInternal != NULL); \
    do { if (pInternal != NULL) \
        GlobalFree(pInternal); } \
    while(0);

// This wrapper function required to make prefast shut up when we are 
// initializing a critical section in a constructor.

void ExceptionPropagatingInitializeCriticalSection(LPCRITICAL_SECTION critsec);

#endif //_COMPBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mtfrmwk\compbas_.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       compbas_.cpp
//
//--------------------------------------------------------------------------



// initialize to the thread ID of the thread that loads the snapin
// that is the main thread
extern DWORD _MainThreadId = ::GetCurrentThreadId();

const TCHAR NODE_TYPES_KEY[] = TEXT("Software\\Microsoft\\MMC\\NodeTypes");
const TCHAR SNAPINS_KEY[] = TEXT("Software\\Microsoft\\MMC\\SnapIns");
const TCHAR g_szNodeType[] = TEXT("NodeType");
const TCHAR g_szNameString[] = TEXT("NameString");
const TCHAR g_szNameStringIndirect[] = TEXT("NameStringIndirect");
const TCHAR g_szStandaloneSnap[] = TEXT("Standalone");
const TCHAR g_szExtensionSnap[] = TEXT("Extension");
const TCHAR g_szNodeTypes[] = TEXT("NodeTypes");
const TCHAR g_szExtensions[] = TEXT("Extensions");
const TCHAR g_szDynamicExtensions[] = TEXT("Dynamic Extensions");
const TCHAR g_szVersion[] = TEXT("Version");
const TCHAR g_szProvider[] = _T("Provider");
const TCHAR g_szAbout[] = _T("About");



HRESULT RegisterSnapin(const GUID* pSnapinCLSID,
                       const GUID* pStaticNodeGUID,
                       const GUID* pAboutGUID,
					   LPCTSTR lpszNameString, LPCTSTR lpszVersion, LPCTSTR lpszProvider,
             BOOL bExtension, _NODE_TYPE_INFO_ENTRY* pNodeTypeInfoEntryArray,
             UINT nSnapinNameID)
{
  OLECHAR szSnapinClassID[128] = {0}, szStaticNodeGuid[128] = {0}, szAboutGuid[128] = {0};
	::StringFromGUID2(*pSnapinCLSID,szSnapinClassID,128);
	::StringFromGUID2(*pStaticNodeGUID,szStaticNodeGuid,128);
  ::StringFromGUID2(*pAboutGUID,szAboutGuid,128);

	CRegKey regkeySnapins;
	LONG lRes = regkeySnapins.Open(HKEY_LOCAL_MACHINE, SNAPINS_KEY);
	ASSERT(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(lRes); // failed to open
	
	CRegKey regkeyThisSnapin;
	lRes = regkeyThisSnapin.Create(regkeySnapins, szSnapinClassID);
	ASSERT(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(lRes); // failed to create

	lRes = regkeyThisSnapin.SetValue(lpszNameString, g_szNameString);
	if (lRes != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(lRes);

  // JeffJon 6/12/00 100624: MUI: MMC: Shared Folders snap-in
  //                      stores its display information in the registry
  if (nSnapinNameID != 0)
  {
    CString str;
    WCHAR szModule[_MAX_PATH];
    ::GetModuleFileName(AfxGetInstanceHandle(), szModule, _MAX_PATH);
    str.Format( _T("@%s,-%d"), szModule, nSnapinNameID );
    lRes = regkeyThisSnapin.SetValue(str, g_szNameStringIndirect);
    if (lRes != ERROR_SUCCESS)
      return HRESULT_FROM_WIN32(lRes);
  }

  lRes = regkeyThisSnapin.SetValue(szAboutGuid, g_szAbout);
	if (lRes != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(lRes);
	lRes = regkeyThisSnapin.SetValue(szStaticNodeGuid, g_szNodeType);
	if (lRes != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(lRes);
	lRes = regkeyThisSnapin.SetValue(lpszProvider, g_szProvider);
	if (lRes != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(lRes);
	lRes = regkeyThisSnapin.SetValue(lpszVersion, g_szVersion);
	if (lRes != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(lRes);

	CRegKey regKeyStandaloneorExtension;
	lRes = regKeyStandaloneorExtension.Create(regkeyThisSnapin,
    bExtension ? g_szExtensionSnap : g_szStandaloneSnap);
	if (lRes != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(lRes);

	CRegKey regKeyNodeTypes;
	lRes = regKeyNodeTypes.Create(regkeyThisSnapin, g_szNodeTypes);
	if (lRes != ERROR_SUCCESS)
  {
		return HRESULT_FROM_WIN32(lRes);
  }

	OLECHAR szNodeGUID[128];
	for (_NODE_TYPE_INFO_ENTRY* pCurrEntry = pNodeTypeInfoEntryArray;
			pCurrEntry->m_pNodeGUID != NULL; pCurrEntry++)
	{
		::StringFromGUID2(*(pCurrEntry->m_pNodeGUID),szNodeGUID,128);
		CRegKey regKeyNode;
		lRes = regKeyNode.Create(regKeyNodeTypes, szNodeGUID);
		if (lRes != ERROR_SUCCESS)
    {
			return HRESULT_FROM_WIN32(lRes);
    }
	}

	return HRESULT_FROM_WIN32(lRes);
}


HRESULT UnregisterSnapin(const GUID* pSnapinCLSID)
{
	OLECHAR szSnapinClassID[128];
	::StringFromGUID2(*pSnapinCLSID,szSnapinClassID,128);

	CRegKey regkeySnapins;
	LONG lRes = regkeySnapins.Open(HKEY_LOCAL_MACHINE, SNAPINS_KEY);
	ASSERT(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
  {
		return HRESULT_FROM_WIN32(lRes); // failed to open
  }
	
	lRes = regkeySnapins.RecurseDeleteKey(szSnapinClassID);
	ASSERT(lRes == ERROR_SUCCESS);
	return HRESULT_FROM_WIN32(lRes);
}


HRESULT RegisterNodeType(const GUID* pGuid, LPCTSTR lpszNodeDescription)
{
	OLECHAR szNodeGuid[128];
	::StringFromGUID2(*pGuid,szNodeGuid,128);

	CRegKey regkeyNodeTypes;
	LONG lRes = regkeyNodeTypes.Open(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);
	ASSERT(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
  {
		return HRESULT_FROM_WIN32(lRes); // failed to open
  }

	CRegKey regkeyThisNodeType;
	lRes = regkeyThisNodeType.Create(regkeyNodeTypes, szNodeGuid);
	ASSERT(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
  {
		return HRESULT_FROM_WIN32(lRes); // failed to create
  }

	lRes = regkeyThisNodeType.SetValue(lpszNodeDescription);
	ASSERT(lRes == ERROR_SUCCESS);
	return HRESULT_FROM_WIN32(lRes);
}

HRESULT UnregisterNodeType(const GUID* pGuid)
{
	OLECHAR szNodeGuid[128];
	::StringFromGUID2(*pGuid,szNodeGuid,128);

	CRegKey regkeyNodeTypes;
	LONG lRes = regkeyNodeTypes.Open(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);
	ASSERT(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
  {
		return HRESULT_FROM_WIN32(lRes); // failed to open
  }

	lRes = regkeyNodeTypes.RecurseDeleteKey(szNodeGuid);
	ASSERT(lRes == ERROR_SUCCESS);
	return HRESULT_FROM_WIN32(lRes);
}

HRESULT RegisterNodeExtension(const GUID* pNodeGuid, LPCTSTR lpszExtensionType,
							  const GUID* pExtensionSnapinCLSID, LPCTSTR lpszDescription,
                BOOL bDynamic)
{
	OLECHAR szNodeGuid[128], szExtensionSnapinCLSID[128];
	::StringFromGUID2(*pNodeGuid, szNodeGuid,128);
	::StringFromGUID2(*pExtensionSnapinCLSID, szExtensionSnapinCLSID,128);

	// compose full path of key up to the node GUID
	WCHAR szKeyPath[2048];
	wsprintf(szKeyPath, L"%s\\%s", NODE_TYPES_KEY, szNodeGuid);
	
	CRegKey regkeyNodeTypesNode;
	LONG lRes = regkeyNodeTypesNode.Open(HKEY_LOCAL_MACHINE, szKeyPath);
	ASSERT(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
  {
		return HRESULT_FROM_WIN32(lRes); // failed to open
  }

	CRegKey regkeyExtensions;
	lRes = regkeyExtensions.Create(regkeyNodeTypesNode, g_szExtensions);
	ASSERT(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
  {
		return HRESULT_FROM_WIN32(lRes); // failed to create
  }

	CRegKey regkeyExtensionType;
	lRes = regkeyExtensionType.Create(regkeyExtensions, lpszExtensionType);
	ASSERT(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
  {
		return HRESULT_FROM_WIN32(lRes); // failed to create
  }

	lRes = regkeyExtensionType.SetValue(lpszDescription, szExtensionSnapinCLSID);
	ASSERT(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
  {
		return HRESULT_FROM_WIN32(lRes); // failed to set value
  }

  if (bDynamic)
  {
    // create a subkey under the node GUID
    CRegKey regkeyDynamicExtensions;
	  lRes = regkeyDynamicExtensions.Create(regkeyNodeTypesNode, g_szDynamicExtensions);
	  ASSERT(lRes == ERROR_SUCCESS);
	  if (lRes != ERROR_SUCCESS)
		  return HRESULT_FROM_WIN32(lRes); // failed to create

    // set value (same value as the extension type above)
    lRes = regkeyDynamicExtensions.SetValue(lpszDescription, szExtensionSnapinCLSID);
	  ASSERT(lRes == ERROR_SUCCESS);
	  if (lRes != ERROR_SUCCESS)
    {
		  return HRESULT_FROM_WIN32(lRes); // failed to set value
    }
  }
  return HRESULT_FROM_WIN32(lRes);
}


HRESULT UnregisterNodeExtension(const GUID* pNodeGuid, LPCTSTR lpszExtensionType,
							  const GUID* pExtensionSnapinCLSID, BOOL bDynamic)
{
	OLECHAR szNodeGuid[128], szExtensionSnapinCLSID[128];
	::StringFromGUID2(*pNodeGuid, szNodeGuid,128);
	::StringFromGUID2(*pExtensionSnapinCLSID, szExtensionSnapinCLSID,128);

	// compose full path of key up to the node GUID
	WCHAR szKeyPath[2048];
	wsprintf(szKeyPath, L"%s\\%s", NODE_TYPES_KEY, szNodeGuid);
	
	CRegKey regkeyNodeTypesNode;
	LONG lRes = regkeyNodeTypesNode.Open(HKEY_LOCAL_MACHINE, szKeyPath);
	ASSERT(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(lRes); // failed to open

  lRes = ERROR_SUCCESS;

  // open the key for the Dynamic extensions
  if (bDynamic)
  {
    CRegKey regkeyDynamicExtensions;
	  lRes = regkeyDynamicExtensions.Open(regkeyNodeTypesNode, g_szDynamicExtensions);
	  if (lRes == ERROR_SUCCESS)
    {
      lRes = regkeyDynamicExtensions.DeleteValue(szExtensionSnapinCLSID);
    }
  }
  else
  {
    //
    // Open the extensions key
    //
    CRegKey regkeyExtensions;
    lRes = regkeyExtensions.Open(regkeyNodeTypesNode, g_szExtensions);
    if (lRes == ERROR_SUCCESS)
    {
      CRegKey regkeyExtensionType;
      lRes = regkeyExtensionType.Open(regkeyExtensions, lpszExtensionType);
      if (lRes == ERROR_SUCCESS)
      {
        lRes = regkeyExtensionType.DeleteValue(szExtensionSnapinCLSID);
      }
    }
  }
  lRes = ERROR_SUCCESS;
  return HRESULT_FROM_WIN32(lRes);
}




/////////////////////////////////////////////////////////////////////////////
// CTimerThread

BOOL CTimerThread::Start(HWND hWnd)
{
	ASSERT(m_hWnd == NULL);
	ASSERT(::IsWindow(hWnd));
	m_hWnd = hWnd;
	return CreateThread();
}

BOOL CTimerThread::PostMessageToWnd(WPARAM wParam, LPARAM lParam)
{
	ASSERT(::IsWindow(m_hWnd));
	return ::PostMessage(m_hWnd, CHiddenWnd::s_TimerThreadMessage, wParam, lParam);
}


/////////////////////////////////////////////////////////////////////////////
// CWorkerThread

CWorkerThread::CWorkerThread()
{
	m_bAutoDelete = FALSE;
	m_bAbandoned = FALSE;
	m_hEventHandle = NULL;
	ExceptionPropagatingInitializeCriticalSection(&m_cs);
	m_hWnd = NULL;
}

CWorkerThread::~CWorkerThread()
{
	::DeleteCriticalSection(&m_cs);
	if (m_hEventHandle != NULL)
	{
		VERIFY(::CloseHandle(m_hEventHandle));
		m_hEventHandle = NULL;
	}
}

BOOL CWorkerThread::Start(HWND hWnd)
{
	ASSERT(m_hWnd == NULL);
	ASSERT(::IsWindow(hWnd));
	m_hWnd = hWnd;

	ASSERT(m_hEventHandle == NULL); // cannot call start twice or reuse the same C++ object
	m_hEventHandle = ::CreateEvent(NULL,TRUE /*bManualReset*/,FALSE /*signalled*/, NULL);
	if (m_hEventHandle == NULL)
  {
		return FALSE;
  }

	return CreateThread();
}

void CWorkerThread::Abandon()
{
	Lock();
	OnAbandon();
	m_bAutoDelete = TRUE;
	m_bAbandoned = TRUE;
	Unlock();
}


BOOL CWorkerThread::IsAbandoned()
{
	Lock();
	BOOL b = m_bAbandoned;
	Unlock();
	return b;
}

BOOL CWorkerThread::PostMessageToWnd(UINT Msg, WPARAM wParam, LPARAM lParam)
{
	BOOL b = IsAbandoned();
	if (b)
  {
		return TRUE; // no need to post
  }

	ASSERT(::IsWindow(m_hWnd));
	return ::PostMessage(m_hWnd, Msg, wParam, lParam);
}

void CWorkerThread::WaitForExitAcknowledge()
{
	BOOL b = IsAbandoned();
	if (b)
  {
		return;
  }

	VERIFY(WAIT_OBJECT_0 == ::WaitForSingleObject(m_hEventHandle,INFINITE));
}



/////////////////////////////////////////////////////////////////////////////
// CHiddenWnd


const UINT CHiddenWnd::s_NodeThreadHaveDataNotificationMessage =	WM_USER + 1;
const UINT CHiddenWnd::s_NodeThreadErrorNotificationMessage =		WM_USER + 2;
const UINT CHiddenWnd::s_NodeThreadExitingNotificationMessage =		WM_USER + 3;

const UINT CHiddenWnd::s_NodePropertySheetCreateMessage =			WM_USER + 4;
const UINT CHiddenWnd::s_NodePropertySheetDeleteMessage =			WM_USER + 5;

const UINT CHiddenWnd::s_ExecCommandMessage =						WM_USER + 6;
const UINT CHiddenWnd::s_ForceEnumerationMessage =					WM_USER + 7;
const UINT CHiddenWnd::s_TimerThreadMessage =						WM_USER + 8;


CHiddenWnd::CHiddenWnd(CComponentDataObject* pComponentDataObject)
{
	m_pComponentDataObject = pComponentDataObject;
	m_nTimerID = 0;
}


LRESULT CHiddenWnd::OnNodeThreadHaveDataNotification(UINT, WPARAM wParam, LPARAM, BOOL&)
{
	//TRACE(_T("CHiddenWnd::OnNodeThreadHaveDataNotification()\n"));
	ASSERT(m_pComponentDataObject != NULL);

	// call into the CTreeNode code
	CMTContainerNode* pNode = reinterpret_cast<CMTContainerNode*>(wParam);
	ASSERT(pNode);
	ASSERT(pNode->IsContainer());
	pNode->OnThreadHaveDataNotification(m_pComponentDataObject);
	return 1;
}



LRESULT CHiddenWnd::OnNodeThreadExitingNotification(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
	//TRACE(_T("CHiddenWnd::OnNodeThreadExitingNotification()\n"));
	ASSERT(m_pComponentDataObject != NULL);

	// call into the CTreeNode code
	CMTContainerNode* pNode = reinterpret_cast<CMTContainerNode*>(wParam);
	ASSERT(pNode);
	ASSERT(pNode->IsContainer());
	pNode->OnThreadExitingNotification(m_pComponentDataObject);

	// notify anybody interested in this event
	m_pComponentDataObject->GetNotificationSinkTable()->Notify(
			CHiddenWnd::s_NodeThreadExitingNotificationMessage ,wParam,lParam);
	return 1;
}

LRESULT CHiddenWnd::OnNodeThreadErrorNotification(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
	ASSERT(m_pComponentDataObject != NULL);

	// call into the CTreeNode code
	CMTContainerNode* pNode = reinterpret_cast<CMTContainerNode*>(wParam);
	DWORD dwErr = static_cast<DWORD>(lParam);
	ASSERT(pNode);
	ASSERT(pNode->IsContainer());
	pNode->OnThreadErrorNotification(dwErr, m_pComponentDataObject);
	return 1;
}


LRESULT CHiddenWnd::OnNodePropertySheetCreate(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
	//TRACE(_T("CHiddenWnd::OnNodePropertySheetCreate()\n"));
	ASSERT(m_pComponentDataObject != NULL);

	CPropertyPageHolderBase* pPPHolder = reinterpret_cast<CPropertyPageHolderBase*>(wParam);
	ASSERT(pPPHolder != NULL);
	HWND hWnd = reinterpret_cast<HWND>(lParam);
	ASSERT(::IsWindow(hWnd));

	m_pComponentDataObject->GetPropertyPageHolderTable()->AddWindow(pPPHolder, hWnd);

	return 1;
}



LRESULT CHiddenWnd::OnNodePropertySheetDelete(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
	//TRACE(_T("CHiddenWnd::OnNodePropertySheetDestroy()\n"));
	ASSERT(m_pComponentDataObject != NULL);

	CPropertyPageHolderBase* pPPHolder = reinterpret_cast<CPropertyPageHolderBase*>(wParam);
	ASSERT(pPPHolder != NULL);
	CTreeNode* pNode = reinterpret_cast<CTreeNode*>(lParam);
	ASSERT(pNode != NULL);

	m_pComponentDataObject->GetPropertyPageHolderTable()->Remove(pPPHolder);
	pNode->OnDeleteSheet();

	return 1;
}

LRESULT CHiddenWnd::OnExecCommand(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
	//TRACE(_T("CHiddenWnd::OnExecCommand()\n"));
	ASSERT(m_pComponentDataObject != NULL);

	CExecContext* pExec = reinterpret_cast<CExecContext*>(wParam);
	ASSERT(pExec != NULL);

	pExec->Execute((long)lParam); // execute code
	TRACE(_T("CHiddenWnd::BeforeDone()\n"));
	pExec->Done();		// let the secondary thread proceed
	return 1;
}

LRESULT CHiddenWnd::OnForceEnumeration(UINT, WPARAM wParam, LPARAM, BOOL&)
{
	TRACE(_T("CHiddenWnd::OnForceEnumeration()\n"));
	ASSERT(m_pComponentDataObject != NULL);
	// call into the CTreeNode code
	CMTContainerNode* pNode = reinterpret_cast<CMTContainerNode*>(wParam);
	ASSERT(pNode);
	ASSERT(pNode->GetContainer() != NULL); // not the root!!!
	ASSERT(pNode->IsContainer());
	pNode->ForceEnumeration(m_pComponentDataObject);
	return 1;
}

LRESULT CHiddenWnd::OnTimerThread(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
	//TRACE(_T("CHiddenWnd::OnTimerThread()\n"));
	ASSERT(m_pComponentDataObject != NULL);

	// NULL arguments means that the thread acknowledge it is running properly
	// only to be called once
	if ((wParam == 0) && (lParam == 0))
	{
		ASSERT(!m_pComponentDataObject->m_bTimerThreadStarted);
		m_pComponentDataObject->m_bTimerThreadStarted = TRUE;
	}
	else
	{
		// got some object specific message
		m_pComponentDataObject->OnTimerThread(wParam, lParam);
	}
	return 1;
}

LRESULT CHiddenWnd::OnTimer(UINT, WPARAM, LPARAM, BOOL&)
{
	ASSERT(m_pComponentDataObject != NULL);
	m_pComponentDataObject->OnTimer();
  return 1;
}



////////////////////////////////////////////////////////////////////////////////////
// CRunningThreadTable

#define RUNNING_THREAD_ARRAY_DEF_SIZE (4)


CRunningThreadTable::CRunningThreadTable(CComponentDataObject* pComponentData)
{
	m_pComponentData = pComponentData;
	m_pEntries = (CMTContainerNode**)malloc(sizeof(CMTContainerNode*) * RUNNING_THREAD_ARRAY_DEF_SIZE);

  if (m_pEntries != NULL)
  {
	  memset(m_pEntries,NULL, sizeof(CMTContainerNode*) * RUNNING_THREAD_ARRAY_DEF_SIZE);
  }
	m_nSize = RUNNING_THREAD_ARRAY_DEF_SIZE;
}

CRunningThreadTable::~CRunningThreadTable()
{
#ifdef _DEBUG
	for (int k=0; k < m_nSize; k++)
	{
		ASSERT(m_pEntries[k] == NULL);
	}
#endif		
	free(m_pEntries);
}

void CRunningThreadTable::Add(CMTContainerNode* pNode)
{
	ASSERT(pNode != NULL);
	for (int k=0; k < m_nSize; k++)
	{
		if (m_pEntries[k] == NULL) // get the first empty spot
		{
			pNode->IncrementThreadLockCount();
			m_pEntries[k] = pNode;
			return;
		}
	}

	// all full, need to grow the array
	int nAlloc = m_nSize*2;
	m_pEntries = (CMTContainerNode**)realloc(m_pEntries, sizeof(CMTContainerNode*)*nAlloc);
	memset(&m_pEntries[m_nSize], NULL, sizeof(CMTContainerNode*)*m_nSize);
	pNode->IncrementThreadLockCount();
	m_pEntries[m_nSize] = pNode;
	m_nSize = nAlloc;
}

BOOL CRunningThreadTable::IsPresent(CMTContainerNode* pNode)
{
  ASSERT(pNode != NULL);
  for (int k=0; k < m_nSize; k++)
  {
    if (m_pEntries[k] == pNode)
    {
      return TRUE;
    }
  }
  return FALSE;
}

void CRunningThreadTable::Remove(CMTContainerNode* pNode)
{
	ASSERT(pNode != NULL);
	for (int k=0; k < m_nSize; k++)
	{
		if (m_pEntries[k] == pNode)
		{
			m_pEntries[k] = NULL;
			pNode->DecrementThreadLockCount();
			return; // assume no more that one holder entry
		}
	}
}

void CRunningThreadTable::RemoveAll()
{
	for (int k=0; k < m_nSize; k++)
	{
		if (m_pEntries[k] != NULL)
		{
			m_pEntries[k]->AbandonThread(m_pComponentData);
			m_pEntries[k] = NULL;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////
// CExecContext

CExecContext::CExecContext()
{
	m_hEventHandle = ::CreateEvent(NULL,TRUE /*bManualReset*/,FALSE /*signalled*/, NULL);
	ASSERT(m_hEventHandle != NULL);
}

CExecContext::~CExecContext()
{
	ASSERT(m_hEventHandle != NULL);
	VERIFY(::CloseHandle(m_hEventHandle));
}

void CExecContext::Done()
{
	VERIFY(0 != ::SetEvent(m_hEventHandle));
}

void CExecContext::Wait()
{
	ASSERT(m_hEventHandle != NULL);
	VERIFY(WAIT_OBJECT_0 == ::WaitForSingleObject(m_hEventHandle,INFINITE));
}
	
////////////////////////////////////////////////////////////////////////////////////
// CNotificationSinkEvent

CNotificationSinkEvent::CNotificationSinkEvent()
{
	m_hEventHandle = ::CreateEvent(NULL,TRUE /*bManualReset*/,FALSE /*signalled*/, NULL);
	ASSERT(m_hEventHandle != NULL);
}

CNotificationSinkEvent::~CNotificationSinkEvent()
{
	ASSERT(m_hEventHandle != NULL);
	VERIFY(::CloseHandle(m_hEventHandle));
}

void CNotificationSinkEvent::OnNotify(DWORD, WPARAM, LPARAM)
{
	TRACE(_T("CNotificationSinkEvent::OnNotify()\n"));
	VERIFY(0 != ::SetEvent(m_hEventHandle));
}

void CNotificationSinkEvent::Wait()
{
	TRACE(_T("CNotificationSinkEvent::Wait()\n"));
	ASSERT(m_hEventHandle != NULL);
	VERIFY(WAIT_OBJECT_0 == ::WaitForSingleObject(m_hEventHandle,INFINITE));
}


////////////////////////////////////////////////////////////////////////////////////
// CNotificationSinkTable

#define NOTIFICATION_SINK_ARRAY_DEF_SIZE (4)

CNotificationSinkTable::CNotificationSinkTable()
{
	ExceptionPropagatingInitializeCriticalSection(&m_cs);
	m_pEntries = (CNotificationSinkBase**)malloc(sizeof(CNotificationSinkBase*) * NOTIFICATION_SINK_ARRAY_DEF_SIZE);

  if (m_pEntries != NULL)
  {
	  memset(m_pEntries,NULL, sizeof(CNotificationSinkBase*) * NOTIFICATION_SINK_ARRAY_DEF_SIZE);
  }
	m_nSize = NOTIFICATION_SINK_ARRAY_DEF_SIZE;

}

CNotificationSinkTable::~CNotificationSinkTable()
{
	free(m_pEntries);
	::DeleteCriticalSection(&m_cs);
}
	
void CNotificationSinkTable::Advise(CNotificationSinkBase* p)
{
	Lock();
	ASSERT(p != NULL);
	for (int k=0; k < m_nSize; k++)
	{
		if (m_pEntries[k] == NULL) // get the first empty spot
		{
			m_pEntries[k] = p;
			Unlock();
			return;
		}
	}
	// all full, need to grow the array
	int nAlloc = m_nSize*2;
	m_pEntries = (CNotificationSinkBase**)realloc(m_pEntries, sizeof(CNotificationSinkBase*)*nAlloc);
	memset(&m_pEntries[m_nSize], NULL, sizeof(CNotificationSinkBase*)*m_nSize);
	m_pEntries[m_nSize] = p;
	m_nSize = nAlloc;
	Unlock();
}

void CNotificationSinkTable::Unadvise(CNotificationSinkBase* p)
{
	Lock();
	ASSERT(p != NULL);
	for (int k=0; k < m_nSize; k++)
	{
		if (m_pEntries[k] == p)
		{
			m_pEntries[k] = NULL;
			Unlock();
			return; // assume no more that one holder entry
		}
	}
	Unlock();
}

void CNotificationSinkTable::Notify(DWORD dwEvent, WPARAM dwArg1, LPARAM dwArg2)
{
	Lock();
	for (int k=0; k < m_nSize; k++)
	{
		if (m_pEntries[k] != NULL)
		{
			m_pEntries[k]->OnNotify(dwEvent, dwArg1, dwArg2);
		}
	}
	Unlock();
}



///////////////////////////////////////////////////////////////////////////////
// CWatermarkInfoState (private class)

class CWatermarkInfoState
{
public:
  CWatermarkInfoState()
  {
    m_pWatermarkInfo = NULL;
    m_hBanner = m_hWatermark = NULL;
  }

  ~CWatermarkInfoState()
  {
    DeleteBitmaps();
    if (m_pWatermarkInfo != NULL)
    {
      delete m_pWatermarkInfo;
    }
  }
  void DeleteBitmaps()
  {
    if (m_hBanner != NULL)
    {
      ::DeleteObject(m_hBanner);
      m_hBanner = NULL;
    }
    if (m_hWatermark != NULL)
    {
      ::DeleteObject(m_hWatermark);
      m_hWatermark = NULL;
    }
  }
  void LoadBitmaps()
  {
    ASSERT(m_pWatermarkInfo != NULL);
    if (m_hBanner == NULL)
    {
      m_hBanner = ::LoadBitmap(AfxGetInstanceHandle(), MAKEINTRESOURCE(m_pWatermarkInfo->m_nIDBanner));
    }
    if (m_hWatermark == NULL)
    {
      m_hWatermark = ::LoadBitmap(AfxGetInstanceHandle(), MAKEINTRESOURCE(m_pWatermarkInfo->m_nIDWatermark));
    }
  }

  CWatermarkInfo* m_pWatermarkInfo;
  HBITMAP m_hBanner;
  HBITMAP m_hWatermark;
};

///////////////////////////////////////////////////////////////////////////////
// CComponentDataObject implementation: helpers

#ifdef _DEBUG_REFCOUNT
unsigned int CComponentDataObject::m_nOustandingObjects = 0;
#endif // _DEBUG_REFCOUNT

CComponentDataObject::CComponentDataObject() :
		  m_hiddenWnd((CComponentDataObject*)this), // initialize backpointer
      m_pTimerThreadObj(NULL),
		  m_PPHTable(this), m_RTTable(this),
		  m_pConsole(NULL), m_pConsoleNameSpace(NULL), m_pRootData(NULL), m_hWnd(NULL),
		  m_nTimerThreadID(0x0), m_bTimerThreadStarted(FALSE), m_dwTimerInterval(1),
		  m_dwTimerTime(0), m_pWatermarkInfoState(NULL), m_bExtensionSnapin(FALSE)
{
	ExceptionPropagatingInitializeCriticalSection(&m_cs);
#ifdef _DEBUG_REFCOUNT
	dbg_cRef = 0;
	++m_nOustandingObjects;
	TRACE(_T("CComponentDataObject(), count = %d\n"),m_nOustandingObjects);
#endif // _DEBUG_REFCOUNT

}

CComponentDataObject::~CComponentDataObject()
{
	::DeleteCriticalSection(&m_cs);
#ifdef _DEBUG_REFCOUNT
	--m_nOustandingObjects;
	TRACE(_T("~CComponentDataObject(), count = %d\n"),m_nOustandingObjects);
#endif // _DEBUG_REFCOUNT

	ASSERT(m_pConsole == NULL);
	ASSERT(m_pConsoleNameSpace == NULL);
	ASSERT(m_pRootData == NULL);
}

HRESULT CComponentDataObject::FinalConstruct()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if (!m_hiddenWnd.Create())
	{
		TRACE(_T("Failed to create hidden window\n"));
		return E_FAIL;
	}

	m_hWnd = m_hiddenWnd.m_hWnd;
	m_pRootData = OnCreateRootData();
	ASSERT(m_pRootData != NULL);

	return S_OK;
}

void CComponentDataObject::FinalRelease()
{
	if (m_hiddenWnd.m_hWnd != NULL)
	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
		VERIFY(m_hiddenWnd.DestroyWindow());
	}
	// delete data
	if(m_pRootData != NULL)
	{
		delete m_pRootData;
		m_pRootData = NULL;
	}

	if (m_pWatermarkInfoState != NULL)
  {
		delete m_pWatermarkInfoState;
  }

	m_ColList.RemoveAndDeleteAllColumnSets();

  if (log_instance != NULL)
  {
    log_instance->KillInstance();
  }
}


///////////////////////////////////////////////////////////////////////////////
// CComponentDataObject::IComponentData members


STDMETHODIMP CComponentDataObject::Initialize(LPUNKNOWN pUnknown)
{
	ASSERT(m_pRootData != NULL);
  ASSERT(pUnknown != NULL);
  HRESULT hr = E_FAIL;
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // MMC should only call ::Initialize once!
	ASSERT(m_pConsole == NULL);
  ASSERT(m_pConsoleNameSpace == NULL);

	// get the pointers we need to hold on to
  hr = pUnknown->QueryInterface(IID_IConsoleNameSpace2, reinterpret_cast<void**>(&m_pConsoleNameSpace));
	ASSERT(hr == S_OK);
	ASSERT(m_pConsoleNameSpace != NULL);
  hr = pUnknown->QueryInterface(IID_IConsole2, reinterpret_cast<void**>(&m_pConsole));
  ASSERT(hr == S_OK);
	ASSERT(m_pConsole != NULL);

  // add the images for the scope tree
  LPIMAGELIST lpScopeImage;

  hr = m_pConsole->QueryScopeImageList(&lpScopeImage);
  ASSERT(hr == S_OK);

    // Set the images
	hr = OnSetImages(lpScopeImage); // Load the bitmaps from the dll
	ASSERT(hr == S_OK);

  lpScopeImage->Release();

	OnInitialize();

    return S_OK;
}

STDMETHODIMP CComponentDataObject::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
  ASSERT(m_pConsoleNameSpace != NULL);
  HRESULT hr = S_OK;

  // Since it's my folder it has an internal format.
  // Design Note: for extension.  I can use the fact, that the data object doesn't have
  // my internal format and I should look at the node type and see how to extend it.

 	AFX_MANAGE_STATE(AfxGetStaticModuleState());

  if (event == MMCN_PROPERTY_CHANGE)
  {
	  ASSERT(lpDataObject == NULL);
    hr = OnPropertyChange(param, static_cast<long>(arg));
  }
  else
  {
    CInternalFormatCracker ifc;
    ifc.Extract(lpDataObject);

    if (ifc.GetCookieCount() == 0)
    {
			if ((event == MMCN_EXPAND) && (arg == TRUE) && IsExtensionSnapin())
			{
				return OnExtensionExpand(lpDataObject, param);
				// this is a namespace extension, need to add
				// the root of the snapin
				CContainerNode* pContNode = GetRootData();
				HSCOPEITEM pParent = param;
				pContNode->SetScopeID(pParent);
				pContNode->MarkExpanded();
				return AddContainerNode(pContNode, pParent);

			}
      else if ((event == MMCN_REMOVE_CHILDREN) && IsExtensionSnapin())
      {
        hr = OnRemoveChildren(lpDataObject, arg);
      }

      return S_OK; // Extensions not supported
    }

    switch(event)
    {
		  case MMCN_PASTE:
			  break;

      case MMCN_DELETE:
        hr = OnDeleteVerbHandler(ifc, NULL);
        break;

      case MMCN_REFRESH:
        hr = OnRefreshVerbHandler(ifc);
        break;

      case MMCN_RENAME:
        hr = OnRename(ifc, arg, param);
        break;

      case MMCN_EXPAND:
        hr = OnExpand(ifc, arg, param);
        break;

      case MMCN_EXPANDSYNC:
        hr = OnExpand(ifc, arg, param, FALSE);
        break;

      case MMCN_BTN_CLICK:
        break;

      case MMCN_SELECT:
        hr = OnSelect(ifc, arg, param);
        break;

      default:
        break;
    } // switch
  } // if

  return hr;
}

STDMETHODIMP CComponentDataObject::Destroy()
{
	InternalAddRef();
	TRACE(_T("CComponentDataObject::Destroy()\n"));
	
	OnDestroy();
  SAFE_RELEASE(m_pConsoleNameSpace);
	SAFE_RELEASE(m_pConsole);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	VERIFY(m_hiddenWnd.DestroyWindow()); 	
	InternalRelease();
    return S_OK;
}

BOOL CComponentDataObject::PostExecMessage(CExecContext* pExec, LPARAM arg)
{
	ASSERT(pExec != NULL);
	ASSERT(::IsWindow(m_hWnd));
	return ::PostMessage(m_hWnd, CHiddenWnd::s_ExecCommandMessage,
							(WPARAM)pExec, (LPARAM)arg);
}

BOOL CComponentDataObject::PostForceEnumeration(CMTContainerNode* pContainerNode)
{
	ASSERT(::IsWindow(m_hWnd));
	return ::PostMessage(m_hWnd, CHiddenWnd::s_ForceEnumerationMessage,
							(WPARAM)pContainerNode, (LPARAM)0);
}

BOOL CComponentDataObject::OnCreateSheet(CPropertyPageHolderBase* pPPHolder, HWND hWnd)
{
	ASSERT(pPPHolder != NULL);
	ASSERT(::IsWindow(hWnd));
	ASSERT(::IsWindow(m_hWnd));
	TRACE(_T("\nCComponentDataObject::OnCreateSheet()\n"));
	return ::PostMessage(m_hWnd, CHiddenWnd::s_NodePropertySheetCreateMessage,
							(WPARAM)pPPHolder, (LPARAM)hWnd);
}



BOOL CComponentDataObject::OnDeleteSheet(CPropertyPageHolderBase* pPPHolder, CTreeNode* pNode)
{
	ASSERT(pPPHolder != NULL);
	ASSERT(pNode != NULL);
	ASSERT(::IsWindow(m_hWnd));
	TRACE(_T("\nCComponentDataObject::OnDeleteSheet()\n"));
	return ::PostMessage(m_hWnd, CHiddenWnd::s_NodePropertySheetDeleteMessage,
							(WPARAM)pPPHolder, (LPARAM)pNode);
}

void CComponentDataObject::OnInitialize()
{
	VERIFY(StartTimerThread());
}

void CComponentDataObject::OnDestroy()
{
	// stop timer and worker thread
	ShutDownTimerThread();
	// detach all the threads that might be still running
	GetRunningThreadTable()->RemoveAll();
	// tell all the open property sheets to shut down

	// shut down property sheets, if any
	GetPropertyPageHolderTable()->WaitForAllToShutDown();
}

STDMETHODIMP CComponentDataObject::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
  ASSERT(ppDataObject != NULL);

  CComObject<CDataObject>* pObject;

  CComObject<CDataObject>::CreateInstance(&pObject);
  ASSERT(pObject != NULL);

  // Save cookie and type for delayed rendering
  pObject->SetType(type);

  CTreeNode* pNode;

  //
  // -1 is an uninitialized data object, just ignore
  //
  if (cookie != -1)
  {
    if (cookie == NULL)
    {
      pNode = GetRootData();
    }
    else
    {
      pNode = reinterpret_cast<CTreeNode*>(cookie);
    }
    ASSERT(pNode != NULL);
    pObject->AddCookie(pNode);
  }

  // save a pointer to "this"
  IUnknown* pUnkComponentData = GetUnknown(); // no addref
  ASSERT(pUnkComponentData != NULL);

  pObject->SetComponentData(pUnkComponentData); // will addref it

  return  pObject->QueryInterface(IID_IDataObject,
                  reinterpret_cast<void**>(ppDataObject));
}


STDMETHODIMP CComponentDataObject::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
	ASSERT(pScopeDataItem != NULL);
  CTreeNode* pNode = reinterpret_cast<CTreeNode*>(pScopeDataItem->lParam);
	ASSERT(pNode != NULL);
	ASSERT(pNode->IsContainer());

	ASSERT(pScopeDataItem->mask & SDI_STR);
  pScopeDataItem->displayname = const_cast<LPWSTR>(pNode->GetDisplayName());

  ASSERT(pScopeDataItem->displayname != NULL);
  return S_OK;
}

STDMETHODIMP CComponentDataObject::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
	ASSERT(lpDataObjectA != NULL);
	ASSERT(lpDataObjectB != NULL);

  CInternalFormatCracker ifcA, ifcB;
  VERIFY(SUCCEEDED(ifcA.Extract(lpDataObjectA)));
  VERIFY(SUCCEEDED(ifcB.Extract(lpDataObjectB)));

	CTreeNode* pNodeA = ifcA.GetCookieAt(0);
	CTreeNode* pNodeB = ifcB.GetCookieAt(0);

	ASSERT(pNodeA != NULL);
	ASSERT(pNodeB != NULL);

	if ( (pNodeA == NULL) || (pNodeB == NULL) )
  {
		return E_FAIL;
  }

	return (pNodeA == pNodeB) ? S_OK : S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// Message handlers for CComponentDataObject::IComponentData::Notify()

HRESULT CComponentDataObject::OnAdd(CTreeNode*, LPARAM, LPARAM)
{
  return E_UNEXPECTED;
}

HRESULT CComponentDataObject::OnRemoveChildren(LPDATAOBJECT lpDataObject, LPARAM)
{
  CInternalFormatCracker ifc;
  HRESULT hr = S_OK;
  hr = ifc.Extract(lpDataObject);
  if (SUCCEEDED(hr))
  {
    if (ifc.GetCookieCount() == 1)
    {
      CTreeNode* pNode = ifc.GetCookieAt(0);
      if (pNode != NULL)
      {
        if (pNode->IsContainer())
        {
          CContainerNode* pContainerNode = dynamic_cast<CContainerNode*>(pNode);
          if (pContainerNode != NULL)
          {
            pContainerNode->RemoveAllChildrenFromList();
          }
        }
      }
    }
    else
    {
      ASSERT(FALSE);
    }
  }
	return hr;
}


HRESULT CComponentDataObject::OnRename(CInternalFormatCracker& ifc, LPARAM, LPARAM param)
{
  HRESULT hr = S_FALSE;

  CTreeNode* pNode = ifc.GetCookieAt(0);
  ASSERT(pNode != NULL);
  hr = pNode->OnRename(this, (LPOLESTR)param);
  if (hr == S_OK)
  {
    UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pNode), CHANGE_RESULT_ITEM);
  }
  return hr;
}

HRESULT CComponentDataObject::OnExpand(CInternalFormatCracker& ifc, 
                                       LPARAM arg, 
                                       LPARAM param,
                                       BOOL bAsync)
{
  if (arg == TRUE)
  {
    // Did Initialize get called?
    ASSERT(m_pConsoleNameSpace != NULL);

    //
    // I shouldn't have to deal with multiple select here...
    //
    ASSERT(ifc.GetCookieCount() == 1);
    CTreeNode* pNode = ifc.GetCookieAt(0);
    if (pNode == NULL)
    {
      ASSERT(pNode != NULL);
      return S_FALSE;
    }

    EnumerateScopePane(pNode, param, bAsync);
  }
  else if (!bAsync)
  {
    ASSERT(m_pConsoleNameSpace != NULL);

    //
    // I shouldn't have to deal with multiple select here...
    //
    ASSERT(ifc.GetCookieCount() == 1);
    CTreeNode* pNode = ifc.GetCookieAt(0);
    ASSERT(pNode != NULL);

    if (pNode && pNode->CanExpandSync())
    {
      MMC_EXPANDSYNC_STRUCT* pExpandStruct = reinterpret_cast<MMC_EXPANDSYNC_STRUCT*>(param);
      if (pExpandStruct && pExpandStruct->bExpanding)
      {
        EnumerateScopePane(pNode, pExpandStruct->hItem, bAsync);
        pExpandStruct->bHandled = TRUE;
      }
    }
    else
    {
      return S_FALSE;
    }
  }

  return S_OK;
}



HRESULT CComponentDataObject::OnSelect(CInternalFormatCracker&, LPARAM, LPARAM)
{
  return E_UNEXPECTED;
}

HRESULT CComponentDataObject::OnContextMenu(CTreeNode*, LPARAM, LPARAM)
{
  return S_OK;
}

HRESULT CComponentDataObject::OnPropertyChange(LPARAM param, long fScopePane)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	TRACE(_T("CComponentDataObject::OnPropertyChange()\n"));
	ASSERT(param != NULL);
	CPropertyPageHolderBase* pPPHolder = reinterpret_cast<CPropertyPageHolderBase*>(param);
	ASSERT(pPPHolder != NULL);
	CTreeNode* pNode = pPPHolder->GetTreeNode();
	ASSERT(pNode != NULL);

	// allow both types in the result pane, but only scope items in the scope pane
	ASSERT(!fScopePane || (fScopePane && pNode->IsContainer()) );

	long changeMask = CHANGE_RESULT_ITEM; // default, the holder can change it
	BOOL bUpdate = pPPHolder->OnPropertyChange(fScopePane, &changeMask);
	// fire event to let the property page thread proceed
	pPPHolder->AcknowledgeNotify();

	if (bUpdate)
  {
		pNode->OnPropertyChange(this, fScopePane, changeMask);
  }
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDataObject::IExtendPropertySheet2 memebers

STDMETHODIMP CComponentDataObject::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    LONG_PTR handle,
                    LPDATAOBJECT lpIDataObject)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  CInternalFormatCracker ifc;
  HRESULT hr = ifc.Extract(lpIDataObject);
	if (FAILED(hr))
  {
		return hr;
  }
	
  //
	// this was an object created by the modal wizard, do nothing
  //
	if (ifc.GetCookieType() == CCT_UNINITIALIZED)
	{
		return hr;
	}

	if (ifc.GetCookieType() == CCT_SNAPIN_MANAGER)
  {
		return SnapinManagerCreatePropertyPages(lpProvider,handle);
  }

	CTreeNode* pNode = ifc.GetCookieAt(0);
  ASSERT(ifc.GetCookieType() == CCT_SCOPE || ifc.GetCookieType() == CCT_RESULT);

  CNodeList nodeList;
  ifc.GetCookieList(nodeList);

  if (nodeList.GetCount() > 1)   // multiple selection
  {
    //
    // Delegate to the container
    //
    ASSERT(pNode->GetContainer() != NULL);
    hr = pNode->GetContainer()->CreatePropertyPages(lpProvider, handle, &nodeList);
  }
  else if (nodeList.GetCount() == 1)  // single selection
  {
    //
	  // Delegate to the node
    //
	  ASSERT(pNode != NULL);
	  hr = pNode->CreatePropertyPages(lpProvider, handle, &nodeList);
  }
  else
  {
    hr = E_FAIL;
  }
  return hr;
}

STDMETHODIMP CComponentDataObject::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CTreeNode* pNode;
	DATA_OBJECT_TYPES type;

  CInternalFormatCracker ifc;
  HRESULT hr = ifc.Extract(lpDataObject);
	if (FAILED(hr))
  {
		return hr;
  }

  type = ifc.GetCookieType();
  pNode = ifc.GetCookieAt(0);

  //
  // Retrieve node list and count
  //
  CNodeList nodeList;
  ifc.GetCookieList(nodeList);

  //
	// this was an object created by the modal wizard, do nothing
  //
	if (type == CCT_UNINITIALIZED)
	{
		return hr;
	}

	if (type == CCT_SNAPIN_MANAGER)
  {
		return HasPropertyPages(type) ? S_OK : S_FALSE;
  }

  //
	// we have a node, so delegate to it
  //
	ASSERT(pNode != NULL);
  BOOL bDummy;

  if (nodeList.GetCount() == 1) // single selection
  {
	  ASSERT((type == CCT_SCOPE) || (type == CCT_RESULT));
 
    if (pNode->GetSheetCount() > 0)
    {
      pNode->ShowPageForNode(this);
      return S_FALSE;
    }
    else if (pNode->DelegatesPPToContainer() && pNode->GetContainer()->GetSheetCount() > 0)
    {
      //
      // Find the page and bring it to foreground
      //
      pNode->ShowPageForNode(this);
      return S_FALSE;
    }
    if (pNode->HasPropertyPages(type, &bDummy, &nodeList))
    {
      hr = S_OK;
    }
    else
    {
      hr = S_FALSE;
    }
  }
  else if (nodeList.GetCount() > 1) // multiple selection
  {
    ASSERT(pNode->GetContainer() != NULL);
    if (pNode->GetContainer()->HasPropertyPages(type, &bDummy, &nodeList))
    {
      hr = S_OK;
    }
    else
    {
      hr = S_FALSE;
    }
  }
  return hr;
}

HRESULT CComponentDataObject::CreatePropertySheet(CTreeNode* pNode, 
                                                  HWND hWndParent, 
                                                  LPCWSTR lpszTitle)
{
  HRESULT hr = S_OK;
  
  HWND hWnd = hWndParent;
  if (hWnd == NULL)
  {
    hr = m_pConsole->GetMainWindow(&hWnd);
    if (FAILED(hr))
    {
      ASSERT(FALSE);
      return hr;
    }
  }

	//
  // get an interface to a sheet provider
  //
	CComPtr<IPropertySheetProvider> spSheetProvider;
	hr = m_pConsole->QueryInterface(IID_IPropertySheetProvider,(void**)&spSheetProvider);
	ASSERT(SUCCEEDED(hr));
	ASSERT(spSheetProvider != NULL);

  //
	// get an interface to a sheet callback
  //
	CComPtr<IPropertySheetCallback> spSheetCallback;
	hr = m_pConsole->QueryInterface(IID_IPropertySheetCallback,(void**)&spSheetCallback);
	ASSERT(SUCCEEDED(hr));
	ASSERT(spSheetCallback != NULL);


  //
	// get a sheet
  //
  MMC_COOKIE cookie = reinterpret_cast<MMC_COOKIE>(pNode);
  DATA_OBJECT_TYPES type = (pNode->IsContainer()) ? CCT_SCOPE : CCT_RESULT;

  CComPtr<IDataObject> spDataObject;
  hr = QueryDataObject(cookie, type, &spDataObject);
  ASSERT(SUCCEEDED(hr));
  ASSERT(spDataObject != NULL);

	hr = spSheetProvider->CreatePropertySheet(lpszTitle, TRUE, cookie, 
                                            spDataObject, 0x0 /*dwOptions*/);
	ASSERT(SUCCEEDED(hr));

	hr = spSheetProvider->AddPrimaryPages(GetUnknown(),
											                  TRUE /*bCreateHandle*/,
											                  hWnd,
											                  pNode->IsContainer() /* bScopePane*/);

  hr = spSheetProvider->AddExtensionPages();

	ASSERT(SUCCEEDED(hr));

	hr = spSheetProvider->Show(reinterpret_cast<LONG_PTR>(hWnd), 0);
	ASSERT(SUCCEEDED(hr));

	return hr;
}

CWatermarkInfo* CComponentDataObject::SetWatermarkInfo(CWatermarkInfo* pWatermarkInfo)
{
  if (m_pWatermarkInfoState == NULL)
  {
    m_pWatermarkInfoState = new CWatermarkInfoState;
  }

  CWatermarkInfo* pOldWatermarkInfo = m_pWatermarkInfoState->m_pWatermarkInfo;
	m_pWatermarkInfoState->m_pWatermarkInfo = pWatermarkInfo;

  // we changed info, so dump the old bitmap handles
  m_pWatermarkInfoState->DeleteBitmaps();

	return pOldWatermarkInfo;
}

STDMETHODIMP CComponentDataObject::GetWatermarks(LPDATAOBJECT,
  										                           HBITMAP* lphWatermark,
											                           HBITMAP* lphHeader,
												                         HPALETTE* lphPalette,
												                         BOOL* pbStretch)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

	*lphHeader = NULL;
	*lphWatermark = NULL;
	*lphPalette = NULL;
	*pbStretch = TRUE;

	if ((m_pWatermarkInfoState == NULL) || (m_pWatermarkInfoState->m_pWatermarkInfo == NULL))
  {
		return E_FAIL;
  }

  *pbStretch = m_pWatermarkInfoState->m_pWatermarkInfo->m_bStretch;
	*lphPalette = m_pWatermarkInfoState->m_pWatermarkInfo->m_hPalette;

  // load bitmaps if not loaded yet
  m_pWatermarkInfoState->LoadBitmaps();

  *lphHeader = m_pWatermarkInfoState->m_hBanner;
	if (*lphHeader == NULL)
  {
		return E_FAIL;
  }

  *lphWatermark = m_pWatermarkInfoState->m_hWatermark;
	if (*lphWatermark == NULL)
  {
		return E_FAIL;
  }

  return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CComponentDataObject::IExtendContextMenu memebers

STDMETHODIMP CComponentDataObject::AddMenuItems(LPDATAOBJECT pDataObject,
									LPCONTEXTMENUCALLBACK pContextMenuCallback,
									long *pInsertionAllowed)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  HRESULT hr = S_OK;
	CTreeNode* pNode;
	DATA_OBJECT_TYPES type;

  CInternalFormatCracker ifc;
  hr = ifc.Extract(pDataObject);
  if (FAILED(hr))
  {
		return hr;
  }

  type = ifc.GetCookieType();

  pNode = ifc.GetCookieAt(0);
	ASSERT(pNode != NULL);
  if (pNode == NULL)
  {
    return hr;
  }

  CComPtr<IContextMenuCallback2> spContextMenuCallback2;
  hr = pContextMenuCallback->QueryInterface(IID_IContextMenuCallback2, (PVOID*)&spContextMenuCallback2);
  if (FAILED(hr))
  {
    return hr;
  }

  CNodeList nodeList;
  ifc.GetCookieList(nodeList);

  if (nodeList.GetCount() > 1) // multiple selection
  {
    ASSERT(pNode->GetContainer() != NULL);
    hr = pNode->GetContainer()->OnAddMenuItems(spContextMenuCallback2, 
                                               type, 
                                               pInsertionAllowed,
                                               &nodeList);
  }
  else if (nodeList.GetCount() == 1) // single selection
  {
	  hr = pNode->OnAddMenuItems(spContextMenuCallback2, 
                               type, 
                               pInsertionAllowed,
                               &nodeList);
  }
  else
  {
    hr = E_FAIL;
  }
  return hr;
}

STDMETHODIMP CComponentDataObject::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

  CInternalFormatCracker ifc;
  HRESULT hr = ifc.Extract(pDataObject);
  if (FAILED(hr))
  {
		return hr;
  }

	CTreeNode* pNode = ifc.GetCookieAt(0);
	ASSERT(pNode != NULL);
  
  //
  // Retrieve node list and count
  //
  CNodeList nodeList;
  ifc.GetCookieList(nodeList);

  if (nodeList.GetCount() > 1)  // multiple selection
  {
    //
    // Delegate the command to the container
    //
    ASSERT(pNode->GetContainer() != NULL);

    hr = pNode->GetContainer()->OnCommand(nCommandID, 
                                          ifc.GetCookieType(),
                                          this,
                                          &nodeList);
  }
  else if (nodeList.GetCount() == 1)  // single selection
  {
    //
    // Let the node take care of it
    //
    hr = pNode->OnCommand(nCommandID,
                          ifc.GetCookieType(), 
                          this,
                          &nodeList);
  }
  else
  {
    hr = E_FAIL;
  }
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CComponentDataObject::IPersistStream members

STDMETHODIMP CComponentDataObject::IsDirty()
{
	// forward to the root of the tree
	CRootData* pRootData = GetRootData();
	ASSERT(pRootData != NULL);
	return pRootData->IsDirty();
}

STDMETHODIMP CComponentDataObject::Load(IStream __RPC_FAR *pStm)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// forward to the root of the tree
	CRootData* pRootData = GetRootData();
	ASSERT(pRootData != NULL);
	return pRootData->Load(pStm);
}

STDMETHODIMP CComponentDataObject::Save(IStream __RPC_FAR *pStm, BOOL fClearDirty)
{
	// forward to the root of the tree
	CRootData* pRootData = GetRootData();
	ASSERT(pRootData != NULL);
	return pRootData->Save(pStm,fClearDirty);
}

/////////////////////////////////////////////////////////////////////////////
// CComponentDataObject::ISnapinHelp2 memebers


STDMETHODIMP CComponentDataObject::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
  if (lpCompiledHelpFile == NULL)
  {
    return E_INVALIDARG;
  }

  LPCWSTR lpszHelpFileName = GetHTMLHelpFileName();
  if (lpszHelpFileName == NULL)
  {
    *lpCompiledHelpFile = NULL;
    return E_NOTIMPL;
  }

	CString szHelpFilePath;
	LPTSTR lpszBuffer = szHelpFilePath.GetBuffer(2*MAX_PATH);
	UINT nLen = ::GetSystemWindowsDirectory(lpszBuffer, 2*MAX_PATH);
	if (nLen == 0)
  {
		return E_FAIL;
  }

	wcscpy(&lpszBuffer[nLen], lpszHelpFileName);
	szHelpFilePath.ReleaseBuffer();

  UINT nBytes = (szHelpFilePath.GetLength()+1) * sizeof(WCHAR);
  *lpCompiledHelpFile = (LPOLESTR)::CoTaskMemAlloc(nBytes);

  if (*lpCompiledHelpFile != NULL)
  {
    memcpy(*lpCompiledHelpFile, (LPCWSTR)szHelpFilePath, nBytes);
  }
  else
  {
    return E_OUTOFMEMORY;
  }

  return S_OK;
}

HRESULT CComponentDataObject::GetLinkedTopics(LPOLESTR*)
{
  return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// CComponentDataObject Helpers

HRESULT CComponentDataObject::UpdateAllViewsHelper(LPARAM data, LONG_PTR hint)
{
	ASSERT(m_pConsole != NULL);

  CComObject<CDummyDataObject>* pObject;
  CComObject<CDummyDataObject>::CreateInstance(&pObject);
  ASSERT(pObject != NULL);

	IDataObject* pDataObject;
  HRESULT hr = pObject->QueryInterface(IID_IDataObject, reinterpret_cast<void**>(&pDataObject));
	ASSERT(SUCCEEDED(hr));
	ASSERT(pDataObject != NULL);

	hr = m_pConsole->UpdateAllViews(pDataObject,data, hint);
	pDataObject->Release();
	return hr;
}


void CComponentDataObject::HandleStandardVerbsHelper(CComponentObject* pComponentObj,
									LPCONSOLEVERB pConsoleVerb,
									BOOL bScope, BOOL bSelect,
									LPDATAOBJECT lpDataObject)
{
  // You should crack the data object and enable/disable/hide standard
  // commands appropriately.  The standard commands are reset everytime you get
  // called. So you must reset them back.

	ASSERT(pConsoleVerb != NULL);
	ASSERT(pComponentObj != NULL);
	ASSERT(lpDataObject != NULL);

	// reset the selection
	pComponentObj->SetSelectedNode(NULL, CCT_UNINITIALIZED);

  CInternalFormatCracker ifc;
  VERIFY(SUCCEEDED(ifc.Extract(lpDataObject)));

	CTreeNode* pNode = ifc.GetCookieAt(0);
	if (pNode == NULL)
  {
		return;
  }

  //
  // Retrieve node list and count
  //
  CNodeList nodeList;
  ifc.GetCookieList(nodeList);

  if (nodeList.GetCount() > 1) // multiple selection
  {
    //
    // Delegate to the container
    //
    ASSERT(pNode->GetContainer() != NULL);

    pNode->GetContainer()->OnSetVerbState(pConsoleVerb, ifc.GetCookieType(), &nodeList);
  }
  else if (nodeList.GetCount() == 1)   // single selection
  {
    //
	  // set selection, if any
    //
	  if (bSelect)
    {
		  pComponentObj->SetSelectedNode(pNode, ifc.GetCookieType());
    }

	  ASSERT((ifc.GetCookieType() == CCT_SCOPE) || (ifc.GetCookieType() == CCT_RESULT));
	  TRACE(_T("HandleStandardVerbsHelper: Node <%s> bScope = %d bSelect = %d, type = %s\n"),
		  pNode->GetDisplayName(), bScope, bSelect,
		  (ifc.GetCookieType() == CCT_SCOPE) ? _T("CCT_SCOPE") : _T("CCT_RESULT"));

	  pConsoleVerb->SetDefaultVerb(pNode->GetDefaultVerb(ifc.GetCookieType(), &nodeList));
	  pNode->OnSetVerbState(pConsoleVerb, ifc.GetCookieType(), &nodeList);
  }
}



void CComponentDataObject::EnumerateScopePane(CTreeNode* cookie, 
                                              HSCOPEITEM pParent,
                                              BOOL bAsync)
{
  ASSERT(m_pConsoleNameSpace != NULL); // make sure we QI'ed for the interface

	// find the node corresponding to the cookie
	ASSERT(cookie != NULL);
	ASSERT(cookie->IsContainer());
	CContainerNode* pContNode = (CContainerNode*)cookie;
	pContNode->MarkExpanded();

	if (pContNode == GetRootData())
  {
		pContNode->SetScopeID(pParent);
  }

	// allow the node to enumerate its children, if not enumerated yet
	if (!pContNode->IsEnumerated())
	{
		BOOL bAddChildrenNow = pContNode->OnEnumerate(this, bAsync);
		pContNode->MarkEnumerated();
		if (!bAddChildrenNow)
    {
			return;
    }
	}

	// scan the list of children, looking for containers and add them
	ASSERT(pParent != NULL);
	CNodeList* pChildList = pContNode->GetContainerChildList();
	ASSERT(pChildList != NULL);

	POSITION pos;
	for( pos = pChildList->GetHeadPosition(); pos != NULL; )
	{
		CContainerNode* pCurrChildNode = (CContainerNode*)pChildList->GetNext(pos);
		ASSERT(pCurrChildNode != NULL);
		if (pCurrChildNode->IsVisible())
		{
			AddContainerNode(pCurrChildNode, pParent);
		}
	}
}

HRESULT CComponentDataObject::OnDeleteVerbHandler(CInternalFormatCracker& ifc, CComponentObject*)
{
  HRESULT hr = S_OK;
	CTreeNode* pNode = ifc.GetCookieAt(0);
  ASSERT(pNode != NULL);

  //
  // Retrieve the cookie list and count
  //
  CNodeList nodeList;
  ifc.GetCookieList(nodeList);

  if (nodeList.GetCount() > 1) // multiple selection
  {
    ASSERT(pNode->GetContainer() != NULL);
    pNode->GetContainer()->OnDelete(this, &nodeList);
  }
  else if (nodeList.GetCount() == 1) // single selection
  {
  	pNode->OnDelete(this, &nodeList);
  }
  else
  {
    hr = E_FAIL;
  }
	return hr;
}

HRESULT CComponentDataObject::OnRefreshVerbHandler(CInternalFormatCracker& ifc)
{
  HRESULT hr = S_OK;
	CTreeNode* pNode = ifc.GetCookieAt(0);
  ASSERT(pNode != NULL);

  //
  // Retrieve the node list and the count
  //
  CNodeList nodeList;
  ifc.GetCookieList(nodeList);

  if (nodeList.GetCount() > 1) // multiple selection
  {
    ASSERT(pNode->GetContainer() != NULL);

    pNode->GetContainer()->OnRefresh(this, &nodeList);
  }
  else if (nodeList.GetCount() == 1) // single selection
  {
  	pNode->OnRefresh(this, &nodeList);
  }
  else
  {
    hr = E_FAIL;
  }
	return hr;
}

HRESULT CComponentDataObject::OnHelpHandler(CInternalFormatCracker& ifc, CComponentObject* pComponentObject)
{
  //
	// responding to MMCN_CONTEXTHELP
  //
  ASSERT(pComponentObject != NULL);

  HRESULT hr = S_OK;
	CTreeNode* pNode = ifc.GetCookieAt(0);
  ASSERT(pNode != NULL);

  //
  // Retrieve the node list and count
  //
  CNodeList nodeList;
  ifc.GetCookieList(nodeList);

  if (nodeList.GetCount() > 1) // Multiple selection
  {
    ASSERT(pNode->GetContainer() != NULL);

    OnNodeContextHelp(&nodeList);
  }
  else if (nodeList.GetCount() == 1)  // Single selection
  {
  	OnNodeContextHelp(&nodeList);
  }
  else
  {
    hr = E_FAIL;
  }
	return hr;
}

BOOL CComponentDataObject::WinHelp(LPCTSTR lpszHelpFileName,	// file, no path
									UINT uCommand,	// type of Help
									DWORD dwData 	// additional data
									)
{
	HWND hWnd;
	GetConsole()->GetMainWindow(&hWnd);
	CString szHelpFilePath;
	LPTSTR lpszBuffer = szHelpFilePath.GetBuffer(2*MAX_PATH);
	UINT nLen = ::GetSystemWindowsDirectory(lpszBuffer, 2*MAX_PATH);
	if (nLen == 0)
  {
		return FALSE;
  }

	wcscpy(&lpszBuffer[nLen], lpszHelpFileName);
	szHelpFilePath.ReleaseBuffer();
	return ::WinHelp(hWnd, szHelpFilePath, uCommand, dwData);
}



HRESULT CComponentDataObject::AddNode(CTreeNode* pNodeToAdd)
{
	ASSERT(pNodeToAdd != NULL);
	// if the node is hidden, just ignore
	if (!pNodeToAdd->IsVisible())
		return S_OK;

	if (pNodeToAdd->IsContainer())
	{
		ASSERT(pNodeToAdd->GetContainer() != NULL);
		HSCOPEITEM pParentScopeItem = pNodeToAdd->GetContainer()->GetScopeID();
		ASSERT(pParentScopeItem != NULL);
		return AddContainerNode((CContainerNode*)pNodeToAdd, pParentScopeItem);
	}
	return AddLeafNode((CLeafNode*)pNodeToAdd);
}

HRESULT CComponentDataObject::AddNodeSorted(CTreeNode* pNodeToAdd)
{
	ASSERT(pNodeToAdd != NULL);
	// if the node is hidden, just ignore
	if (!pNodeToAdd->IsVisible())
  {
		return S_OK;
  }

	if (pNodeToAdd->IsContainer())
	{
		ASSERT(pNodeToAdd->GetContainer() != NULL);
		HSCOPEITEM pParentScopeItem = pNodeToAdd->GetContainer()->GetScopeID();
		ASSERT(pParentScopeItem != NULL);
		return AddContainerNodeSorted((CContainerNode*)pNodeToAdd, pParentScopeItem);
	}
	return AddLeafNode((CLeafNode*)pNodeToAdd);
}

HRESULT CComponentDataObject::DeleteNode(CTreeNode* pNodeToDelete)
{
	if (pNodeToDelete->IsContainer())
	{
		return DeleteContainerNode((CContainerNode*)pNodeToDelete);
	}
	return DeleteLeafNode((CLeafNode*)pNodeToDelete);
}

HRESULT CComponentDataObject::DeleteMultipleNodes(CNodeList* pNodeList)
{
  HRESULT hr = S_OK;

  POSITION pos = pNodeList->GetHeadPosition();
  while (pos != NULL)
  {
    CTreeNode* pNode = pNodeList->GetNext(pos);
    if (pNode->IsContainer())
    {
      DeleteContainerNode((CContainerNode*)pNode);
    }
  }
  hr = UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pNodeList), DELETE_MULTIPLE_RESULT_ITEMS);
  return hr;
}

HRESULT CComponentDataObject::ChangeNode(CTreeNode* pNodeToChange, long changeMask)
{
	if (!pNodeToChange->IsVisible())
  {
		return S_OK;	
  }

	if (pNodeToChange->IsContainer())
	{
		CContainerNode* pContNode = (CContainerNode*)pNodeToChange;
		//if (!pContNode->IsExpanded())
		//	return S_OK;
		return ChangeContainerNode(pContNode, changeMask);
	}
	return ChangeLeafNode((CLeafNode*)pNodeToChange, changeMask);
}

HRESULT CComponentDataObject::RemoveAllChildren(CContainerNode* pNode)
{
	// if the node is hidden or not expanded yet, just ignore
	if (!pNode->IsVisible() || !pNode->IsExpanded())
  {
		return S_OK;
  }

	ASSERT(pNode != NULL);
	HSCOPEITEM nID = pNode->GetScopeID();
	ASSERT(nID != 0);

	// remove the container itself
	HRESULT hr = m_pConsoleNameSpace->DeleteItem(nID, /*fDeleteThis*/ FALSE);
	ASSERT(SUCCEEDED(hr));
	DeleteAllResultPaneItems(pNode);
	// remove the result items from all the views (will do only if container selected)
	ASSERT(SUCCEEDED(hr));
	return hr;
}

HRESULT CComponentDataObject::RepaintSelectedFolderInResultPane()
{
	return UpdateAllViewsHelper((long)NULL, REPAINT_RESULT_PANE);
}


HRESULT CComponentDataObject::RepaintResultPane(CContainerNode* pNode)
{
	ASSERT(pNode != NULL);
	return UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pNode), REPAINT_RESULT_PANE);
}

HRESULT CComponentDataObject::DeleteAllResultPaneItems(CContainerNode* pNode)
{
	ASSERT(pNode != NULL);
	return UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pNode), DELETE_ALL_RESULT_ITEMS);
}


HRESULT CComponentDataObject::AddContainerNode(CContainerNode* pNodeToInsert, HSCOPEITEM pParentScopeItem)
{
	ASSERT(pNodeToInsert != NULL);

	if ((pNodeToInsert != GetRootData()) && (!pNodeToInsert->GetContainer()->IsExpanded()))
  {
		return S_OK;
  }

	//ASSERT(pNodeToInsert->GetScopeID() == 0);

	SCOPEDATAITEM scopeDataItem;
	InitializeScopeDataItem(&scopeDataItem,
							pParentScopeItem,
							reinterpret_cast<LPARAM>(pNodeToInsert), // lParam, use the node pointer as cookie
							pNodeToInsert->GetImageIndex(FALSE), // close image
							pNodeToInsert->GetImageIndex(TRUE),  // open image
							pNodeToInsert->HasChildren());

	HRESULT hr = m_pConsoleNameSpace->InsertItem(&scopeDataItem);
	ASSERT(SUCCEEDED(hr));
	if (FAILED(hr))
  {
		return hr;
  }

	// Note - On return, the ID member of 'scopeDataItem'
	// contains the handle to the newly inserted item, so we have to save
	ASSERT(scopeDataItem.ID != NULL);
	pNodeToInsert->SetScopeID(scopeDataItem.ID);
	return hr;
}

//
// Note : This should combined with the function above adding a third parameter that is a compare function,
//        which is NULL by default.  If it is NULL then we just skip the GetChildItem() and the while loop.
//
HRESULT CComponentDataObject::AddContainerNodeSorted(CContainerNode* pNodeToInsert, HSCOPEITEM pParentScopeItem)
{
	ASSERT(pNodeToInsert != NULL);

	if ((pNodeToInsert != GetRootData()) && (!pNodeToInsert->GetContainer()->IsExpanded()))
  {
		return S_OK;
  }

	SCOPEDATAITEM scopeDataItem;
	InitializeScopeDataItem(&scopeDataItem,
							pParentScopeItem,
							reinterpret_cast<LPARAM>(pNodeToInsert), // lParam, use the node pointer as cookie
							pNodeToInsert->GetImageIndex(FALSE), // close image
							pNodeToInsert->GetImageIndex(TRUE),  // open image
							pNodeToInsert->HasChildren());

  HSCOPEITEM pChildScopeItem;
  CTreeNode* pChildNode = NULL;

  // Enumerate through the scope node items and insert the new node in sorted order
  HRESULT hr = m_pConsoleNameSpace->GetChildItem(pParentScopeItem, &pChildScopeItem, (MMC_COOKIE*)&pChildNode);
  ASSERT(SUCCEEDED(hr));
  if (FAILED(hr))
  {
    return hr;
  }

  while (pChildNode != NULL)
  {
    // REVIEW_JEFFJON : we should probably have a compare function as a parameter and use that here.
    if (_wcsicoll(pNodeToInsert->GetDisplayName(), pChildNode->GetDisplayName()) < 0)
    {
      // Insert the node before the node pointed to by pChildScopeItem
      scopeDataItem.relativeID = pChildScopeItem;
      scopeDataItem.mask |= SDI_NEXT;
      break;
    }
    pChildNode = NULL;
    hr = m_pConsoleNameSpace->GetNextItem(pChildScopeItem, &pChildScopeItem, (MMC_COOKIE*)&pChildNode);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
    {
      return hr;
    }
  }
	hr = m_pConsoleNameSpace->InsertItem(&scopeDataItem);
	ASSERT(SUCCEEDED(hr));
	if (FAILED(hr))
  {
		return hr;
  }

	// Note - On return, the ID member of 'scopeDataItem'
	// contains the handle to the newly inserted item, so we have to save
	ASSERT(scopeDataItem.ID != NULL);
	pNodeToInsert->SetScopeID(scopeDataItem.ID);
	return hr;
}

HRESULT CComponentDataObject::DeleteContainerNode(CContainerNode* pNodeToDelete)
{
	ASSERT(pNodeToDelete != NULL);
	ASSERT(pNodeToDelete->GetContainer() != NULL);
	HSCOPEITEM nID = pNodeToDelete->GetScopeID();
	ASSERT(nID != 0);
	HRESULT hr = m_pConsoleNameSpace->DeleteItem(nID, /*fDeleteThis*/ TRUE);
	pNodeToDelete->SetScopeID(0);
	return hr;
}


HRESULT CComponentDataObject::ChangeContainerNode(CContainerNode* pNodeToChange, long changeMask)
{
	ASSERT(pNodeToChange != NULL);
	ASSERT(changeMask & CHANGE_RESULT_ITEM);
	ASSERT(m_pConsoleNameSpace != NULL);

	if (!pNodeToChange->AddedToScopePane())
  {
		return S_OK;
  }

	SCOPEDATAITEM scopeDataItem;
	memset(&scopeDataItem, 0, sizeof(SCOPEDATAITEM));
	scopeDataItem.ID = pNodeToChange->GetScopeID();
	ASSERT(scopeDataItem.ID != 0);

	if (changeMask & CHANGE_RESULT_ITEM_DATA)
	{
		scopeDataItem.mask |= SDI_STR;
		scopeDataItem.displayname = MMC_CALLBACK;
	}
	if (changeMask & CHANGE_RESULT_ITEM_ICON)
	{
    scopeDataItem.mask |= SDI_IMAGE;
    scopeDataItem.nImage = pNodeToChange->GetImageIndex(FALSE);
    scopeDataItem.mask |= SDI_OPENIMAGE;
    scopeDataItem.nOpenImage = pNodeToChange->GetImageIndex(TRUE);
	}
	return m_pConsoleNameSpace->SetItem(&scopeDataItem);
}

HRESULT CComponentDataObject::AddLeafNode(CLeafNode* pNodeToAdd)
{
	// will have to broadcast to all views
	ASSERT(pNodeToAdd != NULL);
	return UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pNodeToAdd), ADD_RESULT_ITEM);
}

HRESULT CComponentDataObject::DeleteLeafNode(CLeafNode* pNodeToDelete)
{
	// will have to broadcast to all views
	ASSERT(pNodeToDelete != NULL);
	return UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pNodeToDelete), DELETE_RESULT_ITEM);
}

HRESULT CComponentDataObject::ChangeLeafNode(CLeafNode* pNodeToChange, long changeMask)
{
	// will have to broadcast to all views
	ASSERT(pNodeToChange != NULL);
	return UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pNodeToChange), changeMask);
}

HRESULT CComponentDataObject::UpdateVerbState(CTreeNode* pNodeToChange)
{
	// will have to broadcast to all views
	ASSERT(pNodeToChange != NULL);
	return UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pNodeToChange), UPDATE_VERB_STATE);
}

HRESULT CComponentDataObject::SetDescriptionBarText(CTreeNode* pTreeNode)
{
  ASSERT(pTreeNode != NULL);
  return UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pTreeNode), UPDATE_DESCRIPTION_BAR);
}

HRESULT CComponentDataObject::SortResultPane(CContainerNode* pContainerNode)
{
	ASSERT(pContainerNode != NULL);
	return UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pContainerNode), SORT_RESULT_PANE);
}

HRESULT CComponentDataObject::UpdateResultPaneView(CContainerNode* pContainerNode)
{
  ASSERT(pContainerNode != NULL);
  return UpdateAllViewsHelper(reinterpret_cast<LONG_PTR>(pContainerNode), UPDATE_RESULT_PANE_VIEW);
}

void CComponentDataObject::InitializeScopeDataItem(LPSCOPEDATAITEM pScopeDataItem,
										HSCOPEITEM pParentScopeItem, LPARAM lParam,
										int nImage, int nOpenImage, BOOL bHasChildren)
{
	ASSERT(pScopeDataItem != NULL);
	memset(pScopeDataItem, 0, sizeof(SCOPEDATAITEM));

	// set parent scope item
	pScopeDataItem->mask |= SDI_PARENT;
	pScopeDataItem->relativeID = pParentScopeItem;

	// Add node name, we implement callback
	pScopeDataItem->mask |= SDI_STR;
	pScopeDataItem->displayname = MMC_CALLBACK;

	// Add the lParam
	pScopeDataItem->mask |= SDI_PARAM;
	pScopeDataItem->lParam = lParam;
	
	// Add close image
	if (nImage != -1)
	{
		pScopeDataItem->mask |= SDI_IMAGE;
		pScopeDataItem->nImage = nImage;
	}
	// Add open image
	if (nOpenImage != -1)
	{
		pScopeDataItem->mask |= SDI_OPENIMAGE;
		pScopeDataItem->nOpenImage = nOpenImage;
	}
	// Add button to node if the folder has children
	if (bHasChildren == TRUE)
	{
		pScopeDataItem->mask |= SDI_CHILDREN;
		pScopeDataItem->cChildren = 1;
	}
}

///////////////////////////////////////////////////////////////////////////////
// Timer and Background Thread

BOOL CComponentDataObject::StartTimerThread()
{
	ASSERT(::IsWindow(m_hWnd));
	m_pTimerThreadObj = OnCreateTimerThread();

	if (m_pTimerThreadObj == NULL)
  {
		return TRUE;
  }

	// start the the thread
	if (!m_pTimerThreadObj->Start(m_hWnd))
  {
		return FALSE;
  }

	ASSERT(m_pTimerThreadObj->m_nThreadID != 0);
	m_nTimerThreadID = m_pTimerThreadObj->m_nThreadID;

	WaitForTimerThreadStartAck();
	return SetTimer();
}

void CComponentDataObject::ShutDownTimerThread()
{
	KillTimer();
	PostMessageToTimerThread(WM_QUIT, 0,0);

  //
  // Wait for the thread to die or else we could AV since there may be more
  // messages in the queue than just the WM_QUIT
  //
  if (m_pTimerThreadObj != NULL)
  {
  	DWORD dwRetState = ::WaitForSingleObject(m_pTimerThreadObj->m_hThread,INFINITE);
    ASSERT(dwRetState != WAIT_FAILED);
  }

  //
  // Threads now gone, delete the thread object
  //
  delete m_pTimerThreadObj;
  m_pTimerThreadObj = NULL;
}


BOOL CComponentDataObject::PostMessageToTimerThread(UINT Msg, WPARAM wParam, LPARAM lParam)
{
	if (m_nTimerThreadID != 0)
  {
  	return ::PostThreadMessage(m_nTimerThreadID, Msg, wParam, lParam);
  }
  return TRUE;
}

BOOL CComponentDataObject::SetTimer()
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(m_hiddenWnd.m_nTimerID == 0);
	m_dwTimerTime = 0;
	DWORD dwTimerIntervalMillisec = m_dwTimerInterval*1000;
	m_hiddenWnd.m_nTimerID = m_hiddenWnd.SetTimer(1, dwTimerIntervalMillisec);
	return (m_hiddenWnd.m_nTimerID != 0);
}

void CComponentDataObject::KillTimer()
{
	ASSERT(::IsWindow(m_hWnd));
	if (m_hiddenWnd.m_nTimerID != 0)
	{
		VERIFY(m_hiddenWnd.KillTimer(static_cast<UINT>(m_hiddenWnd.m_nTimerID)));
		m_hiddenWnd.m_nTimerID = 0;
	}
}

void CComponentDataObject::WaitForTimerThreadStartAck()
{
	MSG tempMSG;
	ASSERT(!m_bTimerThreadStarted);
	while(!m_bTimerThreadStarted)
	{
		if (::PeekMessage(&tempMSG,m_hWnd,CHiddenWnd::s_TimerThreadMessage,
										CHiddenWnd::s_TimerThreadMessage,
										PM_REMOVE))
		{
			DispatchMessage(&tempMSG);
		}
	}
}

void CComponentDataObject::WaitForThreadExitMessage(CMTContainerNode* pNode)
{
  MSG tempMSG;
	while(GetRunningThreadTable()->IsPresent(pNode))
	{
		if (::PeekMessage(&tempMSG,
                      m_hiddenWnd.m_hWnd, 
                      CHiddenWnd::s_NodeThreadHaveDataNotificationMessage,
                      CHiddenWnd::s_NodeThreadExitingNotificationMessage, 
                      PM_REMOVE))
		{
		  DispatchMessage(&tempMSG);
		}
  } // while
}


///////////////////////////////////////////////////////////////////////////////
// CComponentObject implementation
///////////////////////////////////////////////////////////////////////////////

#ifdef  _DEBUG_REFCOUNT
unsigned int CComponentObject::m_nOustandingObjects = 0;
#endif // _DEBUG_REFCOUNT

CComponentObject::CComponentObject()
{
#ifdef _DEBUG_REFCOUNT
	dbg_cRef = 0;
	++m_nOustandingObjects;
	TRACE(_T("CComponentObject(), count = %d\n"),m_nOustandingObjects);
#endif // _DEBUG_REFCOUNT
	Construct();
}

CComponentObject::~CComponentObject()
{
#ifdef _DEBUG_REFCOUNT
	--m_nOustandingObjects;
	TRACE(_T("~CComponentObject(), count = %d\n"),m_nOustandingObjects);
#endif // _DEBUG_REFCOUNT

  // Make sure the interfaces have been released
  ASSERT(m_pConsole == NULL);
  ASSERT(m_pHeader == NULL);

	//SAFE_RELEASE(m_pComponentData); // QI'ed in IComponentDataImpl::CreateComponent
	if (m_pComponentData != NULL)
	{
		m_pComponentData->Release();
		m_pComponentData = NULL;
		TRACE(_T("~CComponentObject() released m_pCompomentData\n"));
	}
  Construct();
}


void CComponentObject::Construct()
{
  m_pConsole = NULL;
  m_pHeader = NULL;

  m_pResult = NULL;
  m_pImageResult = NULL;
  m_pComponentData = NULL;
  m_pToolbar = NULL;
  m_pControlbar = NULL;
	m_pConsoleVerb = NULL;

	m_pSelectedContainerNode = NULL;
	m_pSelectedNode = NULL;
	m_selectedType = CCT_UNINITIALIZED;
}


///////////////////////////////////////////////////////////////////////////////
// CComponentObject::IComponent members

STDMETHODIMP CComponentObject::Initialize(LPCONSOLE lpConsole)
{
  ASSERT(lpConsole != NULL);

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  // Save the IConsole pointer
  m_pConsole = lpConsole;
  m_pConsole->AddRef();

  // QI for a IHeaderCtrl
  HRESULT hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                      reinterpret_cast<void**>(&m_pHeader));

  // Give the console the header control interface pointer
  if (SUCCEEDED(hr))
  {
    m_pConsole->SetHeader(m_pHeader);
  }

  m_pConsole->QueryInterface(IID_IResultData,
                      reinterpret_cast<void**>(&m_pResult));

  hr = m_pConsole->QueryResultImageList(&m_pImageResult);
	ASSERT(hr == S_OK);

  hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);
  ASSERT(hr == S_OK);

  return S_OK;
}

STDMETHODIMP CComponentObject::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
  HRESULT hr = S_OK;


  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  if (event == MMCN_PROPERTY_CHANGE)
  {
	  ASSERT(lpDataObject == NULL);
    hr = OnPropertyChange(param, static_cast<ULONG>(arg));
  }
  else if (event == MMCN_VIEW_CHANGE)
  {
    hr = OnUpdateView(lpDataObject,arg,param);
  }
	else if (event == MMCN_DESELECT_ALL)
  {
		TRACE(_T("CComponentObject::Notify -> MMCN_DESELECT_ALL \n"));
  }
	else if (event == MMCN_COLUMN_CLICK)
	{
		OnColumnSortChanged(arg, param);
	}
  else if (event == MMCN_CUTORMOVE)
  {
    hr = S_FALSE;
  }
	else if (lpDataObject != NULL)
  {
    CInternalFormatCracker ifc;
    ifc.Extract(lpDataObject);

    if (ifc.GetCookieCount() < 1)
    {
			CComponentDataObject* pComponentDataObject = (CComponentDataObject*)m_pComponentData;
			if ( (event == MMCN_ADD_IMAGES) && pComponentDataObject->IsExtensionSnapin() )
			{
				CTreeNode* pTreeNode = pComponentDataObject->GetRootData();
				return InitializeBitmaps(pTreeNode); // cookie for the root
      }
      return S_OK;
    }

    switch(event)
    {
      case MMCN_ACTIVATE:
        break;

      case MMCN_CLICK:
        OnResultItemClk(ifc, FALSE);
        break;

      case MMCN_DBLCLICK:
        hr = S_FALSE;
        break;

      case MMCN_ADD_IMAGES:
        OnAddImages(ifc, arg, param);
        break;

      case MMCN_SHOW:
        hr = OnShow(ifc, arg, param);
        break;

		  case MMCN_COLUMNS_CHANGED:
  		  hr = OnColumnsChanged(ifc, arg, param);
			  break;

		  case MMCN_MINIMIZED:
        hr = OnMinimize(ifc, arg, param);
        break;

      case MMCN_SELECT:
        HandleStandardVerbs( (BOOL) LOWORD(arg)/*bScope*/,
					   (BOOL) HIWORD(arg)/*bSelect*/,lpDataObject);
        break;

		  case MMCN_QUERY_PASTE:
			  hr = S_FALSE;
			  break;

      case MMCN_PASTE:
        AfxMessageBox(_T("CComponentObject::MMCN_PASTE"));
        break;

      case MMCN_DELETE:
    	  // just delegate to the component data object
        hr = ((CComponentDataObject*)m_pComponentData)->OnDeleteVerbHandler(
														  ifc, this);
        break;
		  case MMCN_REFRESH:
			  // just delegate to the component data object
        hr = ((CComponentDataObject*)m_pComponentData)->OnRefreshVerbHandler(
										  ifc);

        //
        // Once the refresh has begun, update the verbs associated with the
        // object being refreshed.
        //
        HandleStandardVerbs( (BOOL) LOWORD(arg)/*bScope*/,
					   (BOOL) HIWORD(arg)/*bSelect*/,lpDataObject);

        break;

      case MMCN_RENAME:
        // just delegate to the component data object
        hr = ((CComponentDataObject*)m_pComponentData)->OnRename(ifc, arg, param);
        break;

		  case MMCN_CONTEXTHELP:
			  // just delegate to the component data object
        hr = ((CComponentDataObject*)m_pComponentData)->OnHelpHandler(ifc, this);
        break;
		  default:
        hr = E_UNEXPECTED;
        break;
    }

  }

  return hr;
}

STDMETHODIMP CComponentObject::Destroy(MMC_COOKIE)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  //
  // Release the interfaces that we QI'ed
  //
  if (m_pConsole != NULL)
  {
    //
    // Tell the console to release the header control interface
    //
    m_pConsole->SetHeader(NULL);
    SAFE_RELEASE(m_pHeader);
    SAFE_RELEASE(m_pToolbar);
    SAFE_RELEASE(m_pControlbar);

    SAFE_RELEASE(m_pResult);
    SAFE_RELEASE(m_pImageResult);
  	SAFE_RELEASE(m_pConsoleVerb);

    // Release the IConsole interface last
    SAFE_RELEASE(m_pConsole);
  }
  return S_OK;
}

STDMETHODIMP CComponentObject::GetResultViewType(MMC_COOKIE cookie,  LPOLESTR* ppViewType,
												 long* pViewOptions)
{
  CTreeNode* pNode;
  if (cookie == NULL)
  {
    pNode = ((CComponentDataObject*)m_pComponentData)->GetRootData();
  }
  else
  {
    pNode = reinterpret_cast<CTreeNode*>(cookie);
  }
  ASSERT(pNode != NULL);

  if (pNode != NULL)
  {
    return pNode->GetResultViewType((CComponentDataObject*)m_pComponentData, 
                                    ppViewType, 
                                    pViewOptions);
  }
  // Use default view
  if (((CComponentDataObject*)m_pComponentData)->IsMultiSelect())
  {
    *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
  }
  else
  {
	  *pViewOptions = MMC_VIEW_OPTIONS_NONE;
  }
	*ppViewType = NULL;
  return S_FALSE;
}

STDMETHODIMP CComponentObject::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject)
{
  HRESULT hr = S_OK;

  ASSERT(ppDataObject != NULL);

  CComObject<CDataObject>* pObject;
  CComObject<CDataObject>::CreateInstance(&pObject);
  ASSERT(pObject != NULL);

  if (pObject != NULL)
  {
    CTreeNode* pNode = NULL;
    if (cookie == MMC_MULTI_SELECT_COOKIE) 
    {
      TRACE(_T("CDSEvent::GetDataObject() - multi-select.\n"));
      RESULTDATAITEM rdi;
      ZeroMemory(&rdi, sizeof(rdi));
      rdi.mask = RDI_STATE;
      rdi.nIndex = -1;
      rdi.nState = LVIS_SELECTED;
    
      do
      {
        rdi.lParam = 0;
        ASSERT(rdi.mask == RDI_STATE);
        ASSERT(rdi.nState == LVIS_SELECTED);
        hr = m_pResult->GetNextItem(&rdi);
        if (hr != S_OK)
          break;
      
        pNode = reinterpret_cast<CTreeNode*>(rdi.lParam);
        pObject->AddCookie(pNode);
      } while (1);
      // addref() the new pointer and return it.
      pObject->AddRef();
      *ppDataObject = pObject;
    }
    else
    {
      // Delegate it to the IComponentData implementation
      ASSERT(m_pComponentData != NULL);
      hr = m_pComponentData->QueryDataObject(cookie, type, ppDataObject);
    }
  }
  return hr;
}

STDMETHODIMP CComponentObject::GetDisplayInfo(LPRESULTDATAITEM  pResultDataItem)
{
  ASSERT(pResultDataItem != NULL);
	
	CTreeNode* pNode = reinterpret_cast<CTreeNode*>(pResultDataItem->lParam);
	ASSERT(pNode != NULL);
	ASSERT(pResultDataItem->bScopeItem == pNode->IsContainer());

	if (pResultDataItem->mask & RDI_STR)
	{
		LPCWSTR lpszString = pNode->GetString(pResultDataItem->nCol);
		if (lpszString != NULL)
    {
			pResultDataItem->str = (LPWSTR)lpszString;
    }
	}
	if ((pResultDataItem->mask & RDI_IMAGE) && (pResultDataItem->nCol == 0))
	{
		pResultDataItem->nImage = pNode->GetImageIndex(FALSE);
	}
    return S_OK;
}

STDMETHODIMP CComponentObject::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
  // Delegate it to the IComponentData implementation
  ASSERT(m_pComponentData != NULL);
  return m_pComponentData->CompareObjects(lpDataObjectA, lpDataObjectB);
}


///////////////////////////////////////////////////////////////////////////////
// Message handlers for CComponentObject::IComponent::Notify()

HRESULT CComponentObject::OnFolder(CTreeNode*, LPARAM, LPARAM)
{
  ASSERT(FALSE);
  return S_OK;
}

HRESULT CComponentObject::OnShow(CInternalFormatCracker& ifc, LPARAM arg, LPARAM)
{
  HRESULT hr = S_OK;
	ASSERT(ifc.GetCookieCount() == 1);
  
  //
  // I shouldn't have to deal with multiple select here
  //
  CTreeNode* pNode = ifc.GetCookieAt(0);
  ASSERT(pNode != NULL);
	ASSERT(pNode->IsContainer());
	CContainerNode* pContainerNode = (CContainerNode*)pNode;

  // Note - arg is TRUE when it is time to enumerate
  if (arg == TRUE)
  {
    long lResultView;
    LPOLESTR lpoleResultView = NULL;
    pNode->GetResultViewType((CComponentDataObject*)m_pComponentData,
                              &lpoleResultView, 
                              &lResultView);
    if (lResultView == MMC_VIEW_OPTIONS_NONE || lResultView == MMC_VIEW_OPTIONS_MULTISELECT)
    {
       // Show the headers for this nodetype
      InitializeHeaders(pContainerNode);
      EnumerateResultPane(pContainerNode);
      m_pSelectedContainerNode = pContainerNode;
      SetDescriptionBarText(pContainerNode);
    }
    else
    {
      m_pSelectedContainerNode = pContainerNode;
      hr = pNode->OnShow(m_pConsole);
    }
  }
  else
  {
    // Removed by JEFFJON : new column header implementation
    // if we want we can notify ourselves that the focus is being lost
    //		SaveHeadersInfo(pContainerNode);
    m_pSelectedContainerNode = NULL;
    // Free data associated with the result pane items, because
    // your node is no longer being displayed.
    // Note: The console will remove the items from the result pane
  }
#ifdef _DEBUG
	if (m_pSelectedContainerNode == NULL)
		TRACE(_T("NULL selection\n"));
	else
		TRACE(_T("Node <%s> selected\n"), m_pSelectedContainerNode->GetDisplayName());
#endif
  return hr;
}

HRESULT CComponentObject::OnColumnsChanged(CInternalFormatCracker& ifc, LPARAM, LPARAM param)
{
  CTreeNode* pNode = ifc.GetCookieAt(0);
	ASSERT(pNode != NULL);
	ASSERT(pNode->IsContainer());
	CContainerNode* pContainerNode = (CContainerNode*)pNode;

	MMC_VISIBLE_COLUMNS* pVisibleCols = reinterpret_cast<MMC_VISIBLE_COLUMNS*>(param);
	pContainerNode->OnColumnsChanged(pVisibleCols->rgVisibleCols, pVisibleCols->nVisibleColumns);

	return S_OK;
}

HRESULT CComponentObject::OnColumnSortChanged(LPARAM, LPARAM)
{
	return S_OK;
}

HRESULT CComponentObject::ForceSort(UINT iCol, DWORD dwDirection)
{
	HRESULT hr = m_pResult->Sort(iCol, dwDirection,	NULL);
	return hr;
}

HRESULT CComponentObject::OnActivate(CTreeNode*, LPARAM, LPARAM)
{
	ASSERT(FALSE);
  return S_OK;
}

HRESULT CComponentObject::OnResultItemClk(CInternalFormatCracker&, BOOL)
{
  return S_OK;
}

HRESULT CComponentObject::OnMinimize(CInternalFormatCracker&, LPARAM, LPARAM)
{
  return S_OK;
}

HRESULT CComponentObject::OnPropertyChange(LPARAM param, long fScopePane)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT(param != NULL);
#ifdef _DEBUG
	TRACE(_T("CComponentObject::OnPropertyChange()\n"));
	CPropertyPageHolderBase* pPPHolder = reinterpret_cast<CPropertyPageHolderBase*>(param);
	ASSERT(pPPHolder != NULL);
	CTreeNode* pNode = pPPHolder->GetTreeNode();
	ASSERT(pNode != NULL);

	// the item must be a result item and in the result pane
	ASSERT(!fScopePane);
#endif
	// we delegate the call to the IComponentData implementation
	CComponentDataObject* pComponentDataObject = (CComponentDataObject*)m_pComponentData;
	ASSERT(pComponentDataObject != NULL);
	return pComponentDataObject->OnPropertyChange(param, fScopePane);
}

HRESULT CComponentObject::OnUpdateView(LPDATAOBJECT, LPARAM data, LONG_PTR hint)
{
	if (m_pSelectedContainerNode == NULL)
  {
		return S_OK; // no selection for our IComponentData
  }

	if (hint == DELETE_ALL_RESULT_ITEMS)
	{
		// data contains the container whose result pane has to be refreshed
		CContainerNode* pNode = reinterpret_cast<CContainerNode*>(data);
		ASSERT(pNode != NULL);

		// do it only if selected and we are using the standard list view,
    // if not, reselecting will do a delete/enumeration
    long lResultView;
    LPOLESTR lpoleResultView = NULL;
    pNode->GetResultViewType((CComponentDataObject*)m_pComponentData,
                             &lpoleResultView, 
                             &lResultView);
		if (m_pSelectedContainerNode == pNode && 
        (lResultView == MMC_VIEW_OPTIONS_NONE || lResultView == MMC_VIEW_OPTIONS_MULTISELECT))
		{
			ASSERT(m_pResult != NULL);
			VERIFY(SUCCEEDED(m_pResult->DeleteAllRsltItems()));
      SetDescriptionBarText(pNode);
		}
	}
  else if (hint == SORT_RESULT_PANE)
  {
    // data contains the container whose result pane has to be refreshed
    CContainerNode* pNode = reinterpret_cast<CContainerNode*>(data);
    ASSERT(pNode != NULL);
    // do it only if selected, if not, reselecting will do a delete/enumeration
    if (m_pSelectedContainerNode == pNode)
    {
      MMC_SORT_SET_DATA* pColumnSortData = NULL;

      // build the column id
      LPCWSTR lpszColumnID = pNode->GetColumnID();
      size_t iLen = wcslen(lpszColumnID);

      // allocate memory for the struct and add on enough to make the byte[1] into a string
      // for the column id
      SColumnSetID* pColumnID = (SColumnSetID*)malloc(sizeof(SColumnSetID) + (iLen * sizeof(WCHAR)));
      memset(pColumnID, 0, sizeof(SColumnSetID) + (iLen * sizeof(WCHAR)));
      pColumnID->cBytes = static_cast<DWORD>(iLen * sizeof(WCHAR));
      wcscpy((LPWSTR)pColumnID->id, lpszColumnID);

      // Get the sort column and direction
      IColumnData* pColumnData = NULL;
  	  HRESULT hr = m_pConsole->QueryInterface(IID_IColumnData, reinterpret_cast<void**>(&pColumnData));
      if (pColumnData != NULL)
        hr = pColumnData->GetColumnSortData(pColumnID, &pColumnSortData);
      if (SUCCEEDED(hr))
      {
        if (pColumnSortData != NULL)
        {
          UINT iCurrentSortColumn = pColumnSortData->pSortData->nColIndex;
          DWORD dwCurrentSortDirection = pColumnSortData->pSortData->dwSortOptions;

          VERIFY(SUCCEEDED(ForceSort(iCurrentSortColumn, dwCurrentSortDirection)));
          CoTaskMemFree(pColumnSortData);
        }
      }
      if (pColumnData != NULL)
        pColumnData->Release();
      free(pColumnID);
    }
  }
	else if (hint == REPAINT_RESULT_PANE)
	{
		// data contains the container whose result pane has to be refreshed
		CContainerNode* pNode = reinterpret_cast<CContainerNode*>(data);
		if (pNode == NULL)
			pNode = m_pSelectedContainerNode; // passing NULL means apply to the current selection

		// update all the leaf nodes in the result pane
		CNodeList* pChildList = ((CContainerNode*)pNode)->GetLeafChildList();
		for( POSITION pos = pChildList->GetHeadPosition(); pos != NULL; )
		{
			CLeafNode* pCurrentChild = (CLeafNode*)pChildList->GetNext(pos);
			ChangeResultPaneItem(pCurrentChild,CHANGE_RESULT_ITEM);
		}
	}
  else if ( hint == DELETE_MULTIPLE_RESULT_ITEMS)
  {
    CNodeList* pNodeList = reinterpret_cast<CNodeList*>(data);
    ASSERT(pNodeList != NULL);

    POSITION pos = pNodeList->GetHeadPosition();
    while (pos != NULL)
    {
      CTreeNode* pNode = pNodeList->GetNext(pos);
      ASSERT(pNode != NULL);
      if (!pNode->IsContainer())
      {
        DeleteResultPaneItem(static_cast<CLeafNode*>(pNode));
      }
    }
    SetDescriptionBarText(pNodeList->GetHead()->GetContainer());
  }
	else if ( (hint == ADD_RESULT_ITEM) || (hint == DELETE_RESULT_ITEM) || (hint & CHANGE_RESULT_ITEM))
	{
		// we deal with a leaf node
		CLeafNode* pNode = reinterpret_cast<CLeafNode*>(data);
		ASSERT(pNode != NULL);
		// consider only if the parent is selected, otherwise will enumerate later when selected
		if (m_pSelectedContainerNode == pNode->GetContainer())
		{
			if (hint & CHANGE_RESULT_ITEM)
			{
				ChangeResultPaneItem(pNode,hint);
			}
			else if ( hint ==  ADD_RESULT_ITEM)
			{
				AddResultPaneItem(pNode);
        SetDescriptionBarText(pNode);
			}
			else if ( hint ==  DELETE_RESULT_ITEM)
			{
				DeleteResultPaneItem(pNode);
        SetDescriptionBarText(pNode);
			}
		}
	}
	else if (hint == UPDATE_VERB_STATE)
	{
		CTreeNode* pTreeNode = reinterpret_cast<CTreeNode*>(data);
		ASSERT(pTreeNode != NULL);
		if (m_pSelectedNode == pTreeNode)
		{
			ASSERT(m_selectedType != CCT_UNINITIALIZED);
      CNodeList nodeList;
      nodeList.AddTail(pTreeNode);
			m_pConsoleVerb->SetDefaultVerb(pTreeNode->GetDefaultVerb(m_selectedType, &nodeList));
			pTreeNode->OnSetVerbState(m_pConsoleVerb, m_selectedType, &nodeList);
		}
	}
  else if (hint == UPDATE_DESCRIPTION_BAR)
  {
    CTreeNode* pTreeNode = reinterpret_cast<CTreeNode*>(data);
    ASSERT(pTreeNode != NULL);
    SetDescriptionBarText(pTreeNode);
  }
  else if (hint == UPDATE_RESULT_PANE_VIEW)
  {
    CContainerNode* pNode = reinterpret_cast<CContainerNode*>(data);
    ASSERT(pNode != NULL);
    HSCOPEITEM hScopeID = pNode->GetScopeID();
    if (hScopeID != 0)
    {
      m_pConsole->SelectScopeItem(hScopeID);
    }
  }
  return S_OK;
}

HRESULT CComponentObject::SetDescriptionBarText(CTreeNode* pTreeNode)
{
  ASSERT(pTreeNode != NULL);
  HRESULT hr = S_OK;
  if (m_pSelectedContainerNode == pTreeNode)
  {
    LPWSTR lpszText = pTreeNode->GetDescriptionBarText();
    hr = m_pResult->SetDescBarText(lpszText);
  }
  else if (m_pSelectedContainerNode == pTreeNode->GetContainer())
  {
    LPWSTR lpszText = pTreeNode->GetContainer()->GetDescriptionBarText();
    hr = m_pResult->SetDescBarText(lpszText);
  }

  return hr;
}

HRESULT CComponentObject::OnAddImages(CInternalFormatCracker& ifc, LPARAM, LPARAM)
{
  CTreeNode* pNode = ifc.GetCookieAt(0);
  ASSERT(pNode != NULL);
	return InitializeBitmaps(pNode);
}


void CComponentObject::HandleStandardVerbs(BOOL bScope, BOOL bSelect, LPDATAOBJECT lpDataObject)
{
  if (lpDataObject == NULL)
  {
    return;
  }
	((CComponentDataObject*)m_pComponentData)->HandleStandardVerbsHelper(
		this, m_pConsoleVerb, bScope, bSelect, lpDataObject);
}



void CComponentObject::EnumerateResultPane(CContainerNode* pContainerNode)
{
  ASSERT(m_pResult != NULL);		// make sure we QI'ed for the interfaces
  ASSERT(m_pComponentData != NULL);
	ASSERT(pContainerNode != NULL);

  //
	// get the list of children
	// subfolders already added by console, add only the leaf nodes
  //
  CNodeList* pChildList = pContainerNode->GetLeafChildList();
	ASSERT(pChildList != NULL);

	POSITION pos;
	for( pos = pChildList->GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pCurrChildNode = pChildList->GetNext(pos);
		ASSERT(pCurrChildNode != NULL);

    if(pCurrChildNode->IsVisible())
    {
			VERIFY(SUCCEEDED(AddResultPaneItem((CLeafNode*)pCurrChildNode)));
    }
	}
}

HRESULT CComponentObject::AddResultPaneItem(CLeafNode* pNodeToInsert)
{
	ASSERT(m_pResult != NULL);
	ASSERT(pNodeToInsert != NULL);
  RESULTDATAITEM resultItem;
  memset(&resultItem, 0, sizeof(RESULTDATAITEM));

  resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
  resultItem.str = MMC_CALLBACK;

	//use close image index on result pane
  resultItem.nImage = pNodeToInsert->GetImageIndex(FALSE);
  resultItem.lParam = reinterpret_cast<LPARAM>(pNodeToInsert);
  return m_pResult->InsertItem(&resultItem);
}

HRESULT CComponentObject::DeleteResultPaneItem(CLeafNode* pNodeToDelete)
{
	ASSERT(m_pResult != NULL);
	ASSERT(pNodeToDelete != NULL);
  RESULTDATAITEM resultItem;
  memset(&resultItem, 0, sizeof(RESULTDATAITEM));

	HRESULTITEM itemID;
	HRESULT hr = m_pResult->FindItemByLParam(reinterpret_cast<LPARAM>(pNodeToDelete), &itemID);
	ASSERT(SUCCEEDED(hr));
	if (FAILED(hr))
  {
		return hr;
  }
	return m_pResult->DeleteItem(itemID,0 /* all cols */);
}


HRESULT CComponentObject::ChangeResultPaneItem(CLeafNode* pNodeToChange, LONG_PTR changeMask)
{
	ASSERT(changeMask & CHANGE_RESULT_ITEM);
	ASSERT(m_pResult != NULL);
	ASSERT(pNodeToChange != NULL);
	HRESULTITEM itemID;

	HRESULT hr = m_pResult->FindItemByLParam(reinterpret_cast<LPARAM>(pNodeToChange), &itemID);
	ASSERT(SUCCEEDED(hr));
	if (FAILED(hr))
  {
		return hr;
  }

  RESULTDATAITEM resultItem;
  memset(&resultItem, 0, sizeof(RESULTDATAITEM));
	resultItem.itemID = itemID;
	if (changeMask & CHANGE_RESULT_ITEM_DATA)
	{
    //
		// UpdateItem() alone does not allow the
		// item string buffer to grow and you get "foo..." when
		// "foo" changes to "foobar" the first time (buffer grows)
    //
		resultItem.mask |= RDI_STR;
		resultItem.str = MMC_CALLBACK;
    //
		// this line asserts, use the one above ask Tony
    //
		//resultItem.str = (LPWSTR)pNodeToChange->GetDisplayName();
	}
	if (changeMask & CHANGE_RESULT_ITEM_ICON)
	{
		resultItem.mask |= RDI_IMAGE;
		resultItem.nImage = pNodeToChange->GetImageIndex(FALSE);
	}
	hr = m_pResult->SetItem(&resultItem);
	ASSERT(SUCCEEDED(hr));
	hr = m_pResult->UpdateItem(itemID);
	ASSERT(SUCCEEDED(hr));
	return hr;
}

HRESULT CComponentObject::FindResultPaneItemID(CLeafNode* pNode, HRESULTITEM*)
{
	ASSERT(FALSE);
	ASSERT(m_pResult != NULL);
  RESULTDATAITEM resultItem;
  memset(&resultItem, 0, sizeof(RESULTDATAITEM));

	resultItem.mask = SDI_PARAM;
	resultItem.lParam = reinterpret_cast<LPARAM>(pNode);
	HRESULT hr = m_pResult->GetItem(&resultItem);
	ASSERT(SUCCEEDED(hr));
	return E_FAIL;
}


///////////////////////////////////////////////////////////////////////////////
// CComponentObject::IExtendPropertySheet2 members

STDMETHODIMP CComponentObject::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    LONG_PTR handle,
                    LPDATAOBJECT lpIDataObject)
{
  // Delegate it to the IComponentData implementation
  ASSERT(m_pComponentData != NULL);
	IExtendPropertySheet2* pIExtendPropertySheet2;
	VERIFY(SUCCEEDED(m_pComponentData->QueryInterface(IID_IExtendPropertySheet2,
					reinterpret_cast<void**>(&pIExtendPropertySheet2))));
	ASSERT(pIExtendPropertySheet2 != NULL);
  HRESULT hr = pIExtendPropertySheet2->CreatePropertyPages(lpProvider, handle, lpIDataObject);
	pIExtendPropertySheet2->Release();
	return hr;
}

STDMETHODIMP CComponentObject::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
  // Delegate it to the IComponentData implementation
  ASSERT(m_pComponentData != NULL);
	IExtendPropertySheet2* pIExtendPropertySheet2;
	VERIFY(SUCCEEDED(m_pComponentData->QueryInterface(IID_IExtendPropertySheet2,
					reinterpret_cast<void**>(&pIExtendPropertySheet2))));
	ASSERT(pIExtendPropertySheet2 != NULL);
  HRESULT hr = pIExtendPropertySheet2->QueryPagesFor(lpDataObject);
	pIExtendPropertySheet2->Release();
	return hr;
}



STDMETHODIMP CComponentObject::GetWatermarks(LPDATAOBJECT lpDataObject,
												HBITMAP* lphWatermark,
												HBITMAP* lphHeader,
												HPALETTE* lphPalette,
												BOOL* pbStretch)
{
  // Delegate it to the IComponentData implementation
  ASSERT(m_pComponentData != NULL);
	IExtendPropertySheet2* pIExtendPropertySheet2;
	VERIFY(SUCCEEDED(m_pComponentData->QueryInterface(IID_IExtendPropertySheet2,
					reinterpret_cast<void**>(&pIExtendPropertySheet2))));
	ASSERT(pIExtendPropertySheet2 != NULL);
  HRESULT hr = pIExtendPropertySheet2->GetWatermarks(lpDataObject,
												lphWatermark,
												lphHeader,
												lphPalette,
												pbStretch);
	pIExtendPropertySheet2->Release();
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// CComponentObject::IExtendContextMenu members

STDMETHODIMP CComponentObject::AddMenuItems(LPDATAOBJECT pDataObject,
									LPCONTEXTMENUCALLBACK pContextMenuCallback,
									long *pInsertionAllowed)
{
  HRESULT hr = S_OK;

  CComPtr<IContextMenuCallback2> spContextMenuCallback2;
  hr = pContextMenuCallback->QueryInterface(IID_IContextMenuCallback2, (PVOID*)&spContextMenuCallback2);
  if (FAILED(hr))
  {
    return hr;
  }

  if (pDataObject == DOBJ_CUSTOMOCX)
  {
    //
    // A custom result pane is being used and we don't know what node it cooresponds to so we assume that it
    // is the previously selected container.
    //

    ASSERT(m_pSelectedContainerNode != NULL);
    CTreeNode* pNode = (CTreeNode*)m_pSelectedContainerNode;
    CNodeList nodeList;
    nodeList.AddTail(pNode);
    hr = m_pSelectedContainerNode->OnAddMenuItems(spContextMenuCallback2, 
                                                  CCT_UNINITIALIZED, 
                                                  pInsertionAllowed,
                                                  &nodeList);
  }
  else
  {
    //
    // Delegate it to the IComponentData implementation
    //
    ASSERT(m_pComponentData != NULL);
	  IExtendContextMenu* pIExtendContextMenu;
	  VERIFY(SUCCEEDED(m_pComponentData->QueryInterface(IID_IExtendContextMenu,
					  reinterpret_cast<void**>(&pIExtendContextMenu))));
	  ASSERT(pIExtendContextMenu != NULL);
    hr = pIExtendContextMenu->AddMenuItems(pDataObject,
													  pContextMenuCallback,
													  pInsertionAllowed);
	  pIExtendContextMenu->Release();
  }
	return hr;
}

STDMETHODIMP CComponentObject::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  HRESULT hr = S_OK;
  if (pDataObject == DOBJ_CUSTOMOCX)
  {
    //
    // A custom result pane is being used and we don't know what node it cooresponds to so we assume that it
    // is the previously selected container.
    //
    ASSERT(m_pSelectedContainerNode != NULL);
    CTreeNode* pNode = (CTreeNode*)m_pSelectedContainerNode;
    CNodeList nodeList;
    nodeList.AddTail(pNode);
    hr = m_pSelectedContainerNode->OnCommand(nCommandID, 
                                             CCT_UNINITIALIZED, 
                                             (CComponentDataObject*)m_pComponentData,
                                             &nodeList);
  }
  else
  {
    // Delegate it to the IComponentData implementation
    ASSERT(m_pComponentData != NULL);
	  IExtendContextMenu* pIExtendContextMenu;
	  VERIFY(SUCCEEDED(m_pComponentData->QueryInterface(IID_IExtendContextMenu,
					  reinterpret_cast<void**>(&pIExtendContextMenu))));
	  ASSERT(pIExtendContextMenu != NULL);
    hr = pIExtendContextMenu->Command(nCommandID, pDataObject);
	  pIExtendContextMenu->Release();
  }
	return hr;
}


///////////////////////////////////////////////////////////////////////////////
// CComponentObject::IExtendControlbar members

STDMETHODIMP CComponentObject::SetControlbar(LPCONTROLBAR pControlbar)
{
  HRESULT hr = S_OK;

  if (pControlbar == NULL)
  {
    //
    // Detach the controls here
    //
    if (m_pControlbar != NULL && m_pToolbar != NULL)
    {
      hr = m_pControlbar->Detach((IUnknown *) m_pToolbar);
      SAFE_RELEASE(m_pControlbar);
    }
  }
  else
  {
    //
    // Save the controlbar interface pointer
    //
    if (m_pControlbar == NULL)
    {
      m_pControlbar = pControlbar;
      m_pControlbar->AddRef();
    }

    //
    // Do something here that checks to see if we have toolbars
    // already created and use those.  If not then create one
    // and load everything necessary for it.
    //

    //
    // Create the toolbar
    //
    hr = m_pControlbar->Create (TOOLBAR,
                                this,
                                (IUnknown **) &m_pToolbar);
    if (SUCCEEDED(hr))
    {
      //
      // Load the toolbar
      //
      AFX_MANAGE_STATE(AfxGetStaticModuleState()); 
      hr = InitializeToolbar(m_pToolbar);
      if (FAILED(hr))
      {
        hr = m_pControlbar->Detach((IUnknown*) m_pToolbar);
        SAFE_RELEASE(m_pControlbar);
      }
    }
  }
  return hr;
}

STDMETHODIMP CComponentObject::ControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState()); 

  HRESULT hr = S_OK;

  if (m_pControlbar == NULL)
  {
    return hr;
  }

  //
  // MMC provides two events here MMCN_SELECT at the time a node is selected
  // and MMCN_BTN_CLICK when a toolbar button is pressed
  //
  switch (event) 
  {
    case MMCN_SELECT:
      {
        //
        // Attach the toolbar to the controlbar
        //
        hr = m_pControlbar->Attach(TOOLBAR, (IUnknown *) m_pToolbar);

        if (SUCCEEDED(hr))
        {
          ASSERT(m_pToolbar != NULL);

          //
          // bSelect is TRUE if the node was selected, FALSE if the node was deselected
          // bScope is TRUE if the a scope node is selected, FALSE if a result node was selected
          //
          BOOL bSelect = HIWORD(arg);

          if (bSelect) 
          {
            CInternalFormatCracker ifc;
            hr = ifc.Extract((LPDATAOBJECT)param);
            if (SUCCEEDED(hr))
            {

               CTreeNode* pNode = ifc.GetCookieAt(0);
               ASSERT(pNode != NULL);

               CNodeList nodeList;
               ifc.GetCookieList(nodeList);

               if (ifc.GetCookieCount() > 1)  // multiple selection
               {
                 ASSERT(pNode->GetContainer() != NULL);
                 hr = pNode->GetContainer()->OnSetToolbarVerbState(m_pToolbar, 
                                                                   &nodeList);
               }
               else if (ifc.GetCookieCount() == 1)  // single selection
               {
                 hr = pNode->OnSetToolbarVerbState(m_pToolbar, 
                                                   &nodeList);
               }
            }
          }
        }
        break;
      }
    case MMCN_BTN_CLICK:
      {
        //
        // The arg is -1 for custom views like MessageView
        //
        if (DOBJ_CUSTOMOCX == (LPDATAOBJECT)arg)
        {
          if (m_pSelectedContainerNode != NULL)
          {
            CNodeList nodeList;
            nodeList.AddTail(m_pSelectedContainerNode);

            hr = m_pSelectedContainerNode->ToolbarNotify(static_cast<int>(param),
                                                         (CComponentDataObject*)m_pComponentData,
                                                         &nodeList);
          }
          else
          {
            hr = S_FALSE;
          }
        }
        else
        {
          CInternalFormatCracker ifc;
          hr = ifc.Extract((LPDATAOBJECT)arg);

          CTreeNode* pNode = ifc.GetCookieAt(0);
          ASSERT(pNode != NULL);

          CNodeList nodeList;
          ifc.GetCookieList(nodeList);

          if (ifc.GetCookieCount() > 1) // multiple selection
          {
            ASSERT(pNode->GetContainer() != NULL);
            hr = pNode->GetContainer()->ToolbarNotify(static_cast<int>(param), 
                                                      (CComponentDataObject*)m_pComponentData,
                                                      &nodeList);
          }
          else if (ifc.GetCookieCount() == 1) // single selection
          {
            hr = pNode->ToolbarNotify(static_cast<int>(param), 
                                      (CComponentDataObject*)m_pComponentData,
                                      &nodeList);
          }
          else
          {
            hr = S_FALSE;
          }
        }
        break;
      }

    default:
      {
        break;
      }
  }

  return hr;
}

///////////////////////////////////////////////////////////////////////////////
// CComponentObject::IResultDataCompareEx members
// This compare is used to sort the item's in the listview
//
// Note: Assum sort is ascending when comparing.
STDMETHODIMP CComponentObject::Compare(RDCOMPARE* prdc, int* pnResult)
{
  if (pnResult == NULL)
  {
    ASSERT(FALSE);
    return E_POINTER;
  }

  if (prdc == NULL)
  {
    ASSERT(FALSE);
    return E_POINTER;
  }

	CTreeNode* pNodeA = reinterpret_cast<CTreeNode*>(prdc->prdch1->cookie);
	CTreeNode* pNodeB = reinterpret_cast<CTreeNode*>(prdc->prdch2->cookie);
	ASSERT(pNodeA != NULL);
	ASSERT(pNodeB != NULL);
	
	CContainerNode* pContNode = pNodeA->GetContainer();
	ASSERT(pContNode != NULL);

	// delegate the sorting to the container
	int nCol = prdc->nColumn;
	*pnResult = pContNode->Compare(pNodeA, pNodeB, nCol, prdc->lUserParam);

  return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// CComponentObject Helpers

// This wrapper function required to make prefast shut up when we are 
// initializing a critical section in a constructor.

void
ExceptionPropagatingInitializeCriticalSection(LPCRITICAL_SECTION critsec)
{
   __try
   {
      ::InitializeCriticalSection(critsec);
   }

   //
   // propagate the exception to our caller.  
   //
   __except (EXCEPTION_CONTINUE_SEARCH)
   {
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mtfrmwk\dataobj.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef _DATAOBJ_H
#define _DATAOBJ_H

///////////////////////////////////////////////////////////////////////////////
// MACROS

#define BYTE_MEM_LEN_W(s) ((wcslen(s)+1) * sizeof(wchar_t))

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CTreeNode;
class CRootData;
class CComponentDataObject;
class CNodeList;


///////////////////////////////////////////////////////////////////////////////
// DATA STRUCTURES

// New Clipboard format that has the Type and Cookie
extern const wchar_t* CCF_DNS_SNAPIN_INTERNAL;

struct INTERNAL 
{
  INTERNAL() 
  { 
    m_type = CCT_UNINITIALIZED; 
    m_p_cookies = NULL; 
    m_pString = NULL;
    m_cookie_count = 0;
  };

  ~INTERNAL() 
  { 
    free(m_p_cookies);
    delete m_pString;
  }

  DATA_OBJECT_TYPES   m_type;     // What context is the data object.
  CTreeNode**         m_p_cookies;   // What object the cookie represents
  LPTSTR              m_pString;  // internal pointer
  DWORD               m_cookie_count;

  INTERNAL & operator=(const INTERNAL& rhs) 
  { 
    m_type = rhs.m_type; 
    m_p_cookies = rhs.m_p_cookies; 
    m_cookie_count = rhs.m_cookie_count;
    return *this;
  } 
};

//////////////////////////////////////////////////////////////////////////////
// CInternalFormatCracker

class CInternalFormatCracker
{
public:
  CInternalFormatCracker() : m_pInternal(NULL) {}
  CInternalFormatCracker(INTERNAL* pInternal) : m_pInternal(pInternal) {}
  ~CInternalFormatCracker() 
  {
    _Free();
  }

  DWORD GetCookieCount() 
  { 
    if (m_pInternal == NULL)
    {
      return 0;
    }
    return m_pInternal->m_cookie_count; 
  }

  DATA_OBJECT_TYPES GetCookieType() 
  { 
    ASSERT(m_pInternal != NULL);
    return m_pInternal->m_type; 
  }

  CTreeNode* GetCookieAt(DWORD idx)
  {
    if(m_pInternal == NULL)
    {
      return NULL;
    }

    if (idx < m_pInternal->m_cookie_count)
    {
      return m_pInternal->m_p_cookies[idx];
    }
    return NULL;
  }

  HRESULT Extract(LPDATAOBJECT lpDataObject);

  void GetCookieList(CNodeList& list);

private:
  INTERNAL* m_pInternal;

  void _Free()
  {
    if (m_pInternal != NULL)
    {
      ::GlobalFree(m_pInternal);
      m_pInternal = NULL;
    }
  }
};


///////////////////////////////////////////////////////////////////////////////
// CDataObject

class CDataObject : public IDataObject, public CComObjectRoot 
{
// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)
BEGIN_COM_MAP(CDataObject)
	COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

// Construction/Destruction
	CDataObject() 
	{ 
#ifdef _DEBUG_REFCOUNT
		dbg_cRef = 0;
		++m_nOustandingObjects;
		TRACE(_T("CDataObject(), count = %d\n"),m_nOustandingObjects);
#endif // _DEBUG_REFCOUNT
		m_pUnkComponentData = NULL; 
	}

  ~CDataObject() 
	{
#ifdef _DEBUG_REFCOUNT
		--m_nOustandingObjects;
		TRACE(_T("~CDataObject(), count = %d\n"),m_nOustandingObjects);
#endif // _DEBUG_REFCOUNT
		if (m_pUnkComponentData != NULL)
		{
			m_pUnkComponentData->Release();
			m_pUnkComponentData = NULL;
#ifdef _DEBUG_REFCOUNT
			TRACE(_T("~CDataObject() released m_pUnkComponentData\n"));
#endif // _DEBUG_REFCOUNT
		}
	}
#ifdef _DEBUG_REFCOUNT
	static unsigned int m_nOustandingObjects; // # of objects created
	int dbg_cRef;

  ULONG InternalAddRef()
  {
		++dbg_cRef;
    return CComObjectRoot::InternalAddRef();
  }
  ULONG InternalRelease()
  {
  	--dbg_cRef;
    return CComObjectRoot::InternalRelease();
  }
#endif // _DEBUG_REFCOUNT

// Clipboard formats that are required by the console
public:
  static CLIPFORMAT    m_cfNodeType;		    // Required by the console
  static CLIPFORMAT    m_cfNodeTypeString;  // Required by the console
  static CLIPFORMAT    m_cfDisplayName;		  // Required by the console
  static CLIPFORMAT    m_cfCoClass;         // Required by the console
	static CLIPFORMAT		 m_cfColumnID;			  // Option for column identification

  static CLIPFORMAT    m_cfInternal; 
  static CLIPFORMAT    m_cfMultiSel;
  static CLIPFORMAT    m_cfMultiObjTypes;

// Standard IDataObject methods
public:
// Implemented
  STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
  STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
  STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);

// Not Implemented
private:
  STDMETHOD(QueryGetData)(LPFORMATETC) 
  { return E_NOTIMPL; };

  STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC, LPFORMATETC)
  { return E_NOTIMPL; };

  STDMETHOD(SetData)(LPFORMATETC, LPSTGMEDIUM, BOOL)
  { return E_NOTIMPL; };

  STDMETHOD(DAdvise)(LPFORMATETC, DWORD,
              LPADVISESINK, LPDWORD)
  { return E_NOTIMPL; };
  
  STDMETHOD(DUnadvise)(DWORD)
  { return E_NOTIMPL; };

  STDMETHOD(EnumDAdvise)(LPENUMSTATDATA*)
  { return E_NOTIMPL; };

// Implementation
public:
  void SetType(DATA_OBJECT_TYPES type) // Step 3
  { 
		ASSERT(m_internal.m_type == CCT_UNINITIALIZED); 
		m_internal.m_type = type; 
	}
	DATA_OBJECT_TYPES GetType()
	{
		ASSERT(m_internal.m_type != CCT_UNINITIALIZED); 
		return m_internal.m_type;
	}


  void AddCookie(CTreeNode* cookie);
  void SetString(LPTSTR lpString) { m_internal.m_pString = lpString; }

	HRESULT Create(const void* pBuffer, size_t len, LPSTGMEDIUM lpMedium);
private:
	HRESULT CreateColumnID(LPSTGMEDIUM lpMedium);			      // Optional for column identification
  HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);		    // Required by the console
  HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);	// Required by the console
  HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);		    // Required by the console
	HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);			    // Required by the console
  HRESULT CreateMultiSelectObject(LPSTGMEDIUM lpMedium);  
  HRESULT CreateInternal(LPSTGMEDIUM lpMedium);

  INTERNAL m_internal;

	// pointer to the ComponentDataObject
private:
	IUnknown* m_pUnkComponentData;
	
	HRESULT SetComponentData(IUnknown* pUnkComponentData)
	{ 
		if (m_pUnkComponentData != NULL)
    {
			m_pUnkComponentData->Release();
    }
		m_pUnkComponentData = pUnkComponentData;
		if (m_pUnkComponentData != NULL)
    {
			m_pUnkComponentData->AddRef();
    }
		return S_OK;
	}

	HRESULT GetComponentData(IUnknown** ppUnkComponentData)
	{ 
		ASSERT(FALSE); // never called??? find out!
		if (ppUnkComponentData == NULL)
    {
			return E_POINTER;
    }
		*ppUnkComponentData = m_pUnkComponentData; 
		if (m_pUnkComponentData != NULL)
    {
			m_pUnkComponentData->AddRef();
    }
		return S_OK; 
	}
	CRootData* GetDataFromComponentDataObject();
	CTreeNode* GetTreeNodeFromCookie();

	friend class CComponentDataObject;
};

///////////////////////////////////////////////////////////////////////////////
// CDummyDataObject

class CDummyDataObject : public IDataObject, public CComObjectRoot 
{
// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDummyDataObject)
BEGIN_COM_MAP(CDummyDataObject)
	COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

// Standard IDataObject methods
public:
    STDMETHOD(GetData)(LPFORMATETC, LPSTGMEDIUM)
	{ return E_NOTIMPL; };
    STDMETHOD(GetDataHere)(LPFORMATETC, LPSTGMEDIUM)
	{ return E_NOTIMPL; };
    STDMETHOD(EnumFormatEtc)(DWORD, LPENUMFORMATETC*)
	{ return E_NOTIMPL; };
    STDMETHOD(QueryGetData)(LPFORMATETC) 
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC, LPFORMATETC)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC, LPSTGMEDIUM, BOOL)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC, DWORD, LPADVISESINK, LPDWORD)
    { return E_NOTIMPL; };
    
    STDMETHOD(DUnadvise)(DWORD)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA*)
    { return E_NOTIMPL; };
};

#endif // _DATAOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mtfrmwk\dataobj_.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dataobj_.cpp
//
//--------------------------------------------------------------------------


///////////////////////////////////////////////////////////////////////////////
// Sample code to show how to Create DataObjects
// Minimal error checking for clarity

///////////////////////////////////////////////////////////////////////////////
// Snap-in NodeType in both GUID format and string format
// Note - Typically there is a node type for each different object, sample
// only uses one node type.

const wchar_t* CCF_DNS_SNAPIN_INTERNAL = L"DNS_SNAPIN_INTERNAL"; 

CLIPFORMAT CDataObject::m_cfNodeType        = (CLIPFORMAT)RegisterClipboardFormat(CCF_NODETYPE);
CLIPFORMAT CDataObject::m_cfNodeTypeString  = (CLIPFORMAT)RegisterClipboardFormat(CCF_SZNODETYPE);  
CLIPFORMAT CDataObject::m_cfDisplayName     = (CLIPFORMAT)RegisterClipboardFormat(CCF_DISPLAY_NAME); 
CLIPFORMAT CDataObject::m_cfCoClass         = (CLIPFORMAT)RegisterClipboardFormat(CCF_SNAPIN_CLASSID); 
CLIPFORMAT CDataObject::m_cfColumnID			  = (CLIPFORMAT)RegisterClipboardFormat(CCF_COLUMN_SET_ID);

CLIPFORMAT CDataObject::m_cfInternal        = (CLIPFORMAT)RegisterClipboardFormat(CCF_DNS_SNAPIN_INTERNAL); 
CLIPFORMAT CDataObject::m_cfMultiSel        = (CLIPFORMAT)RegisterClipboardFormat(CCF_MULTI_SELECT_SNAPINS);
CLIPFORMAT CDataObject::m_cfMultiObjTypes   = (CLIPFORMAT)RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);


#ifdef _DEBUG_REFCOUNT
unsigned int CDataObject::m_nOustandingObjects = 0;
#endif // _DEBUG_REFCOUNT

/////////////////////////////////////////////////////////////////////////////
// CInternalFormatCracker

HRESULT CInternalFormatCracker::Extract(LPDATAOBJECT lpDataObject)
{
  if (DOBJ_CUSTOMOCX == lpDataObject ||
      DOBJ_CUSTOMWEB == lpDataObject ||
      DOBJ_NULL      == lpDataObject)
  {
     return DV_E_CLIPFORMAT;
  }

  if (m_pInternal != NULL)
    _Free();

  SMMCDataObjects * pDO = NULL;
  
  STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
  FORMATETC formatetc = { CDataObject::m_cfInternal, NULL, 
                          DVASPECT_CONTENT, -1, TYMED_HGLOBAL 
  };
  FORMATETC formatetc2 = { CDataObject::m_cfMultiSel, NULL, 
                           DVASPECT_CONTENT, -1, TYMED_HGLOBAL 
  };

  HRESULT hr = lpDataObject->GetData(&formatetc2, &stgmedium);
  if (FAILED(hr)) 
  {
  
    hr = lpDataObject->GetDataHere(&formatetc, &stgmedium);
    if (FAILED(hr))
      return hr;
      
    m_pInternal = reinterpret_cast<INTERNAL*>(stgmedium.hGlobal);
  } 
  else 
  {
    pDO = reinterpret_cast<SMMCDataObjects*>(stgmedium.hGlobal);
    for (UINT i = 0; i < pDO->count; i++) 
    {
      hr = pDO->lpDataObject[i]->GetDataHere(&formatetc, &stgmedium);
      if (FAILED(hr))
        break;
      
      m_pInternal = reinterpret_cast<INTERNAL*>(stgmedium.hGlobal);
      
      if (m_pInternal != NULL)
        break;
    }
  }
  return hr;

}

void CInternalFormatCracker::GetCookieList(CNodeList& list)
{
  for (DWORD dwCount = 0; dwCount < m_pInternal->m_cookie_count; dwCount++)
  {
    list.AddTail(m_pInternal->m_p_cookies[dwCount]);
  }
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject implementations

STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
  HRESULT hr = DV_E_CLIPFORMAT;

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  // Based on the CLIPFORMAT write data to the stream
  const CLIPFORMAT cf = lpFormatetc->cfFormat;

  if(cf == m_cfNodeType)
  {
    hr = CreateNodeTypeData(lpMedium);
  }
  else if(cf == m_cfNodeTypeString) 
  {
    hr = CreateNodeTypeStringData(lpMedium);
  }
  else if (cf == m_cfDisplayName)
  {
    hr = CreateDisplayName(lpMedium);
  }
  else if (cf == m_cfCoClass)
  {
    hr = CreateCoClassID(lpMedium);
  }
  else if (cf == m_cfInternal)
  {
    hr = CreateInternal(lpMedium);
  }
  else if (cf == m_cfMultiObjTypes)
  {
    hr = CreateMultiSelectObject(lpMedium);
  }
	else
	{
		// if not successful, maybe there is a node specific clipboard format,
		// so ask the node itself to provide
		CTreeNode* pNode = GetTreeNodeFromCookie();
		ASSERT(pNode != NULL);
    if (pNode != NULL)
    {
		  hr = pNode->GetDataHere(cf, lpMedium, this);
    }
	}
	return hr;
}

// Note - Sample does not implement these
STDMETHODIMP CDataObject::GetData(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
{
	HRESULT hr = DV_E_CLIPFORMAT;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Based on the CLIPFORMAT write data to the stream
	const CLIPFORMAT cf = lpFormatetcIn->cfFormat;

	if (cf == m_cfColumnID)
	{
		hr = CreateColumnID(lpMedium);
	}
  else if (cf == m_cfMultiObjTypes)
  {
    hr = CreateMultiSelectObject(lpMedium);
  }
	else
	{
		// if not successful, maybe there is a node specific clipboard format,
		// so ask the node itself to provide
		CTreeNode* pNode = GetTreeNodeFromCookie();
    if (pNode != NULL)
    {
		  hr = pNode->GetData(cf, lpMedium, this);
    }
	}
	return hr;
}
    

STDMETHODIMP CDataObject::EnumFormatEtc(DWORD, LPENUMFORMATETC*)
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject creation members

HRESULT CDataObject::Create(const void* pBuffer, size_t len, LPSTGMEDIUM lpMedium)
{
  HRESULT hr = DV_E_TYMED;

  // Do some simple validation
  if (pBuffer == NULL || lpMedium == NULL)
      return E_POINTER;

  // Make sure the type medium is HGLOBAL
  if (lpMedium->tymed == TYMED_HGLOBAL)
  {
    // Create the stream on the hGlobal passed in
    LPSTREAM lpStream;
    hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

    if (SUCCEEDED(hr))
    {
      // Write to the stream the number of bytes
      unsigned long written;
		  hr = lpStream->Write(pBuffer, static_cast<ULONG>(len), &written);

      // Because we told CreateStreamOnHGlobal with 'FALSE', 
      // only the stream is released here.
      // Note - the caller (i.e. snap-in, object) will free the HGLOBAL 
      // at the correct time.  This is according to the IDataObject specification.
      lpStream->Release();
    }
  }

  return hr;
}

HRESULT CDataObject::CreateColumnID(LPSTGMEDIUM lpMedium)
{
	CTreeNode* pTreeNode = GetTreeNodeFromCookie();
  if (pTreeNode == NULL)
  {
    return E_FAIL;
  }

	ASSERT(pTreeNode->IsContainer());
	CContainerNode* pContainerNode = (CContainerNode*)pTreeNode;

  // build the column id
  LPCWSTR lpszColumnID = pContainerNode->GetColumnID();
  size_t iLen = wcslen(lpszColumnID);

  // allocate enough memory for the struct and the string for the column id
  SColumnSetID* pColumnID = (SColumnSetID*)malloc(sizeof(SColumnSetID) + (iLen * sizeof(WCHAR)));

  if (pColumnID != NULL)
  {
    memset(pColumnID, 0, sizeof(SColumnSetID) + (iLen * sizeof(WCHAR)));
    pColumnID->cBytes = static_cast<DWORD>(iLen * sizeof(WCHAR));
    wcscpy((LPWSTR)pColumnID->id, lpszColumnID);

    // copy the column id to global memory
    size_t cb = sizeof(SColumnSetID) + (iLen * sizeof(WCHAR));

    lpMedium->tymed = TYMED_HGLOBAL;
    lpMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, cb);

    if (lpMedium->hGlobal == NULL)
      return STG_E_MEDIUMFULL;

    BYTE* pb = reinterpret_cast<BYTE*>(::GlobalLock(lpMedium->hGlobal));
    memcpy(pb, pColumnID, cb);

    ::GlobalUnlock(lpMedium->hGlobal);

    free(pColumnID);
  }
	return S_OK;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID format
	// First ask the related node, if failed, get the default GUID
	// from the root node
  CTreeNode* pNode = GetTreeNodeFromCookie();
  if (pNode == NULL)
  {
    return E_FAIL;
  }

	const GUID* pNodeType = pNode->GetNodeType();
	if (pNodeType == NULL)
  {
		pNodeType = GetDataFromComponentDataObject()->GetNodeType();
  }
  HRESULT hr = Create(pNodeType, sizeof(GUID), lpMedium);
  return hr;
}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID string format
  OLECHAR szNodeType[128] = {0};
	// First ask the related node, if failed, get the default GUID
	// from the root node
  CTreeNode* pNode = GetTreeNodeFromCookie();
  if (pNode == NULL)
  {
    return E_FAIL;
  }

	const GUID* pNodeType = pNode->GetNodeType();
	if (pNodeType == NULL)
  {
		pNodeType = GetDataFromComponentDataObject()->GetNodeType();
  }

	::StringFromGUID2(*pNodeType,szNodeType,128);
  return Create(szNodeType, BYTE_MEM_LEN_W(szNodeType), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    // This is the display named used in the scope pane and snap-in manager
	// We get it from the root node.
	CString szDispName;
	szDispName = GetDataFromComponentDataObject()->GetDisplayName();
    return Create(szDispName, (szDispName.GetLength()+1) * sizeof(wchar_t), lpMedium);
}


HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
	// TODO
	ASSERT(m_pUnkComponentData != NULL);
	IPersistStream* pIPersistStream = NULL;
	HRESULT hr = m_pUnkComponentData->QueryInterface(IID_IPersistStream, (void**)&pIPersistStream);
	if (FAILED(hr))
		return hr;
	ASSERT(pIPersistStream != NULL);
    // Create the CoClass information
	CLSID clsid;
	VERIFY(SUCCEEDED(pIPersistStream->GetClassID(&clsid)));
    hr = Create(reinterpret_cast<const void*>(&clsid), sizeof(CLSID), lpMedium);
	ASSERT(SUCCEEDED(hr));
	pIPersistStream->Release();
	return hr;
}


HRESULT CDataObject::CreateInternal(LPSTGMEDIUM lpMedium)
{
  HRESULT hr = S_OK;
  INTERNAL * pInt = NULL;
  void * pBuf = NULL;

  UINT size = sizeof(INTERNAL);
  size += sizeof(CTreeNode*) * (m_internal.m_cookie_count);
  pBuf = GlobalAlloc (GPTR, size);
  if (pBuf != NULL)
  {
    pInt = (INTERNAL *) pBuf;
    lpMedium->hGlobal = pBuf;
  
    // copy the data
    pInt->m_type = m_internal.m_type;
    pInt->m_cookie_count = m_internal.m_cookie_count;
  
    pInt->m_p_cookies = (CTreeNode**) ((BYTE *)pInt + sizeof(INTERNAL));
    memcpy (pInt->m_p_cookies, m_internal.m_p_cookies,
            sizeof(CTreeNode*) * (m_internal.m_cookie_count));
    hr = Create(pBuf, size, lpMedium);
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }
  return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSDataObject::CreateMultiSelectObject
//
//  Synopsis:   this is to create the list of types selected
//
//-----------------------------------------------------------------------------

HRESULT CDataObject::CreateMultiSelectObject(LPSTGMEDIUM lpMedium)
{
  CTreeNode** cookieArray = NULL;
  cookieArray = (CTreeNode**) GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                          m_internal.m_cookie_count*sizeof(CTreeNode*));
  if (!cookieArray) 
  {
    return E_OUTOFMEMORY;
  }

  for (UINT k=0; k<m_internal.m_cookie_count; k++)
  {
    cookieArray[k] = m_internal.m_p_cookies[k];
  }

  BOOL* bDuplicateArr = NULL;
  bDuplicateArr = (BOOL*)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                     m_internal.m_cookie_count*sizeof(BOOL));
  if (!bDuplicateArr) 
  {
    if (cookieArray)
    {
      GlobalFree (cookieArray);
    }
    return E_OUTOFMEMORY;
  }
  //ZeroMemory(bDuplicateArr, m_internal.m_cookie_count*sizeof(BOOL));

  UINT cCount = 0;
  for (UINT index = 0; index < m_internal.m_cookie_count; index++)
  {
    for (UINT j = 0; j < index; j++)
    {
      GUID Guid1 = *(cookieArray[index]->GetNodeType());
      GUID Guid2 = *(cookieArray[j]->GetNodeType());
      if (IsEqualGUID (Guid1, Guid2)) 
      {
        bDuplicateArr[index] = TRUE;
        break; //repeated GUID
      }
    }
    if (!bDuplicateArr[index])
    {
      cCount++;
    }
  }      

   
  UINT size = sizeof(SMMCObjectTypes) + (cCount) * sizeof(GUID);
  void * pTmp = ::GlobalAlloc(GPTR, size);
  if (!pTmp) 
  {
    if (cookieArray) 
    {
      GlobalFree (cookieArray);
    }
    if (bDuplicateArr) 
    {
      GlobalFree (bDuplicateArr);
    }
    return E_OUTOFMEMORY;
  }
    
  SMMCObjectTypes* pdata = reinterpret_cast<SMMCObjectTypes*>(pTmp);
  pdata->count = cCount;
  UINT i = 0;
  for (index=0; index<m_internal.m_cookie_count; index++)
  {
    if (!bDuplicateArr[index])
    {
      pdata->guid[i++] = *(cookieArray[index]->GetNodeType());
    }
  }
  ASSERT(i == cCount);
  lpMedium->hGlobal = pTmp;

  GlobalFree (cookieArray);
  GlobalFree (bDuplicateArr);

  return S_OK;
}


CRootData* CDataObject::GetDataFromComponentDataObject()
{
	CComponentDataObject* pObject = 
		reinterpret_cast<CComponentDataObject*>(m_pUnkComponentData);
	CRootData* pRootData = pObject->GetRootData();
	ASSERT(pRootData != NULL);
	return pRootData;
}

CTreeNode* CDataObject::GetTreeNodeFromCookie()
{
	CComponentDataObject* pObject = 
		reinterpret_cast<CComponentDataObject*>(m_pUnkComponentData);

	CTreeNode* pNode = NULL;
  if (m_internal.m_cookie_count > 0)
  {
    pNode = m_internal.m_p_cookies[0];
	  if (pNode == NULL)
    {
      return pObject->GetRootData();
    }
  }
	return pNode;
}

void CDataObject::AddCookie(CTreeNode* cookie)
{
  const UINT MEM_CHUNK_SIZE = 10;
  void * pTMP = NULL;

  if ((m_internal.m_cookie_count) % MEM_CHUNK_SIZE == 0) 
  {
    if (m_internal.m_p_cookies != NULL) 
    {
      pTMP = realloc (m_internal.m_p_cookies,
                      (m_internal.m_cookie_count +
                       MEM_CHUNK_SIZE) * sizeof (CTreeNode*));
    } 
    else 
    {
      pTMP = malloc (MEM_CHUNK_SIZE * sizeof (CTreeNode*));
    }
    if (pTMP == NULL) 
    {
      TRACE(_T("CDataObject::AddCookie - malloc/realloc failed.."));
      ASSERT (pTMP != NULL);
    }
    m_internal.m_p_cookies = (CTreeNode**)pTMP;
  }
  m_internal.m_p_cookies[m_internal.m_cookie_count] = cookie;
  m_internal.m_cookie_count++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mtfrmwk\aclpag_.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       aclpag_.cpp
//
//--------------------------------------------------------------------------



#include <aclpage.h>
#include <dssec.h>



///////////////////////////////////////////////////////////////////////
// CDynamicLibraryBase

class CDynamicLibraryBase
{
public:
	CDynamicLibraryBase()
	{
		m_lpszLibraryName = NULL;
		m_lpszFunctionName = NULL;
		m_lpszFunctionNameEx = NULL;
		m_hLibrary = NULL;
		m_pfFunction = NULL;
		m_pfFunctionEx = NULL;
	}
	virtual ~CDynamicLibraryBase()
	{
		if (m_hLibrary != NULL)
		{
			::FreeLibrary(m_hLibrary);
			m_hLibrary = NULL;
		}
	}
	BOOL Load()
	{
		if (m_hLibrary != NULL)
			return TRUE; // already loaded

		ASSERT(m_lpszLibraryName != NULL);
		m_hLibrary = ::LoadLibrary(m_lpszLibraryName);
		if (NULL == m_hLibrary)
		{
			// The library is not present
			return FALSE;
		}
		ASSERT(m_lpszFunctionName != NULL);
		ASSERT(m_pfFunction == NULL);
		m_pfFunction = ::GetProcAddress(m_hLibrary, m_lpszFunctionName );
		if ( NULL == m_pfFunction )
		{
			// The library is present but does not have the entry point
			::FreeLibrary( m_hLibrary );
			m_hLibrary = NULL;
			return FALSE;
		}

		if (m_lpszFunctionNameEx != NULL)
		{
			ASSERT(m_pfFunctionEx == NULL);
			m_pfFunctionEx = ::GetProcAddress(m_hLibrary, m_lpszFunctionNameEx);
			if ( NULL == m_pfFunctionEx)
			{
				::FreeLibrary( m_hLibrary );
				m_hLibrary = NULL;
				return FALSE;
			}
		}

		ASSERT(m_hLibrary != NULL);
		ASSERT(m_pfFunction != NULL);
		return TRUE;
	}


protected:
	LPCSTR	m_lpszFunctionName;
	LPCSTR	m_lpszFunctionNameEx;
	LPCTSTR m_lpszLibraryName;
	FARPROC m_pfFunction;
	FARPROC m_pfFunctionEx;
	HMODULE m_hLibrary;
};

///////////////////////////////////////////////////////////////////////
// CDsSecDLL

class CDsSecDLL : public CDynamicLibraryBase
{
public:
	CDsSecDLL()
	{
		m_lpszLibraryName = _T("dssec.dll");
		m_lpszFunctionName = "DSCreateISecurityInfoObject";
		m_lpszFunctionNameEx = "DSCreateISecurityInfoObjectEx";
	}
	HRESULT DSCreateISecurityInfoObject(LPCWSTR pwszObjectPath,		// in
								   LPCWSTR pwszObjectClass,			// in
								   LPSECURITYINFO* ppISecurityInfo	// out
								   );

	HRESULT DSCreateISecurityInfoObjectEx(LPCWSTR pwszObjectPath,		// in
														LPCWSTR pwszObjectClass,	// in
														LPCWSTR pwszServer,			// in
														LPCWSTR pwszUsername,		// in
														LPCWSTR pwszPassword,		// in
														DWORD dwFlags,
														LPSECURITYINFO* ppISecurityInfo	// out
														);
};


HRESULT CDsSecDLL::DSCreateISecurityInfoObject(LPCWSTR pwszObjectPath,		// in
								   LPCWSTR pwszObjectClass,			// in
								   LPSECURITYINFO* ppISecurityInfo	// out
								   )
{
	ASSERT(m_hLibrary != NULL);
	ASSERT(m_pfFunction != NULL);
	return ((PFNDSCREATEISECINFO)m_pfFunction)
					(pwszObjectPath,pwszObjectClass, 0, ppISecurityInfo, NULL, NULL, 0);
}

HRESULT CDsSecDLL::DSCreateISecurityInfoObjectEx(LPCWSTR pwszObjectPath,		// in
								   LPCWSTR pwszObjectClass,			// in
									LPCWSTR pwszServer,			// in
									LPCWSTR pwszUsername,		// in
									LPCWSTR pwszPassword,		// in
									DWORD	dwFlags,
								   LPSECURITYINFO* ppISecurityInfo	// out
								   )
{
	ASSERT(m_hLibrary != NULL);
	ASSERT(m_pfFunctionEx != NULL);
	return ((PFNDSCREATEISECINFOEX)m_pfFunctionEx)
					(pwszObjectPath,pwszObjectClass, pwszServer,
					 pwszUsername, pwszPassword, dwFlags, ppISecurityInfo, NULL, NULL, 0);
}

///////////////////////////////////////////////////////////////////////
// CAclUiDLL

class CAclUiDLL : public CDynamicLibraryBase
{
public:
	CAclUiDLL()
	{
		m_lpszLibraryName = _T("aclui.dll");
		m_lpszFunctionName = "CreateSecurityPage";
		m_pfFunction = NULL;
		m_lpszFunctionNameEx = NULL;
		m_pfFunctionEx = NULL;
	}

	HPROPSHEETPAGE CreateSecurityPage( LPSECURITYINFO psi );
};


typedef HPROPSHEETPAGE (*ACLUICREATESECURITYPAGEPROC) (LPSECURITYINFO);

HPROPSHEETPAGE CAclUiDLL::CreateSecurityPage( LPSECURITYINFO psi )
{
	ASSERT(m_hLibrary != NULL);
	ASSERT(m_pfFunction != NULL);
	return ((ACLUICREATESECURITYPAGEPROC)m_pfFunction) (psi);
}


//////////////////////////////////////////////////////////////////////////
// CISecurityInformationWrapper

class CISecurityInformationWrapper : public ISecurityInformation
{
public:
	CISecurityInformationWrapper(CAclEditorPage* pAclEditorPage)
	{
		m_dwRefCount = 0;
		ASSERT(pAclEditorPage != NULL);
		m_pAclEditorPage = pAclEditorPage;
		m_pISecInfo = NULL;
	}
	~CISecurityInformationWrapper()
	{
		ASSERT(m_dwRefCount == 0);
    ISecurityInformation* pSecInfo = GetSecInfoPtr();
		if (pSecInfo != NULL)
			pSecInfo->Release();
	}
  void SetSecInfoPtr(ISecurityInformation* pSecInfo)
  {
    ASSERT(pSecInfo != NULL);
    m_pISecInfo = pSecInfo;
  }
  ISecurityInformation* GetSecInfoPtr()
  {
    return m_pISecInfo;
  }
public:
	// *** IUnknown methods ***
	STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj)
	{ 
		return GetSecInfoPtr()->QueryInterface(riid, ppvObj);
	}
	STDMETHOD_(ULONG,AddRef) ()
	{ 
		// trap the first addref to increment count on page holder
		if (m_dwRefCount == 0)
		{
			m_pAclEditorPage->m_pPageHolder->AddRef();
		}
		m_dwRefCount++;
		return GetSecInfoPtr()->AddRef();
	}
	STDMETHOD_(ULONG,Release) ()
	{
		m_dwRefCount--;
		// this might be the last release on the page holder
		// which would cause the holder to delete itself and
		// "this" in the process (i.e. "this" no more valid when
		// returning from the m_pPageHolder->Release() call
		ISecurityInformation* pISecInfo = GetSecInfoPtr();

		// trap the last release to decrement count on page holder
		if (m_dwRefCount == 0)
		{
			m_pAclEditorPage->m_pPageHolder->Release();
		}
		return pISecInfo->Release();
	}

	// *** ISecurityInformation methods ***
	STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo )
	{
		return GetSecInfoPtr()->GetObjectInformation(pObjectInfo);
	}
	STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
							PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
							BOOL fDefault)
	{ 
		return GetSecInfoPtr()->GetSecurity(RequestedInformation,
										ppSecurityDescriptor,
										fDefault);
	}
	STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
							PSECURITY_DESCRIPTOR pSecurityDescriptor )
	{ 
		return GetSecInfoPtr()->SetSecurity(SecurityInformation,
										pSecurityDescriptor);
	}
	STDMETHOD(GetAccessRights) (const GUID* pguidObjectType,
								DWORD dwFlags, // SI_EDIT_AUDITS, SI_EDIT_PROPERTIES
								PSI_ACCESS *ppAccess,
								ULONG *pcAccesses,
								ULONG *piDefaultAccess )
	{ 
		return GetSecInfoPtr()->GetAccessRights(pguidObjectType,
											dwFlags,
											ppAccess,
											pcAccesses,
											piDefaultAccess);
	}
	STDMETHOD(MapGeneric) (const GUID *pguidObjectType,
						   UCHAR *pAceFlags,
						   ACCESS_MASK *pMask)
	{ 
		return GetSecInfoPtr()->MapGeneric(pguidObjectType,
										pAceFlags,
										pMask);
	}
	STDMETHOD(GetInheritTypes) (PSI_INHERIT_TYPE *ppInheritTypes,
								ULONG *pcInheritTypes )
	{ 
		return GetSecInfoPtr()->GetInheritTypes(ppInheritTypes,
											pcInheritTypes);
	}
	STDMETHOD(PropertySheetPageCallback)(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage )
	{ 
		return GetSecInfoPtr()->PropertySheetPageCallback(hwnd, uMsg, uPage);
	}


private:
	DWORD m_dwRefCount;
	ISecurityInformation* m_pISecInfo;	// interface pointer to the wrapped interface
	CAclEditorPage* m_pAclEditorPage;	// back pointer

	//friend class CAclEditorPage;
};



//////////////////////////////////////////////////////////////////////////
// static instances of the dynamically loaded DLL's

CDsSecDLL g_DsSecDLL;
CAclUiDLL g_AclUiDLL;


//////////////////////////////////////////////////////////////////////////
// CAclEditorPage

CAclEditorPage* CAclEditorPage::CreateInstance(LPCTSTR lpszLDAPPath,
									CPropertyPageHolderBase* pPageHolder)
{
	CAclEditorPage* pAclEditorPage = new CAclEditorPage;
	if (pAclEditorPage != NULL)
	{
		pAclEditorPage->SetHolder(pPageHolder);
		if (FAILED(pAclEditorPage->Initialize(lpszLDAPPath)))
		{
			delete pAclEditorPage;
			pAclEditorPage = NULL;
		}
	}
	return pAclEditorPage;
}


CAclEditorPage* CAclEditorPage::CreateInstanceEx(LPCTSTR lpszLDAPPath,
																 LPCTSTR lpszServer,
																 LPCTSTR lpszUsername,
																 LPCTSTR lpszPassword,
																 DWORD dwFlags,
									CPropertyPageHolderBase* pPageHolder)
{
	CAclEditorPage* pAclEditorPage = new CAclEditorPage;
	if (pAclEditorPage != NULL)
	{
		pAclEditorPage->SetHolder(pPageHolder);
		if (FAILED(pAclEditorPage->InitializeEx(lpszLDAPPath,
																lpszServer,
																lpszUsername,
																lpszPassword,
																dwFlags)))
		{
			delete pAclEditorPage;
			pAclEditorPage = NULL;
		}
	}
	return pAclEditorPage;
}


CAclEditorPage::CAclEditorPage()
{
	m_pPageHolder = NULL;
	m_pISecInfoWrap = new CISecurityInformationWrapper(this);
}

CAclEditorPage::~CAclEditorPage()
{
	delete m_pISecInfoWrap;
}

HRESULT CAclEditorPage::Initialize(LPCTSTR lpszLDAPPath)
{
	// get ISecurityInfo* from DSSECL.DLL
	if (!g_DsSecDLL.Load())
		return E_INVALIDARG;
	
  ISecurityInformation* pSecInfo = NULL;
	HRESULT hr = g_DsSecDLL.DSCreateISecurityInfoObject(
										lpszLDAPPath,
										NULL, // pwszObjectClass
                    &pSecInfo);
  if (SUCCEEDED(hr))
    m_pISecInfoWrap->SetSecInfoPtr(pSecInfo);

  return hr;
}

HRESULT CAclEditorPage::InitializeEx(LPCTSTR lpszLDAPPath,
												 LPCTSTR lpszServer,
												 LPCTSTR lpszUsername,
												 LPCTSTR lpszPassword,
												 DWORD dwFlags)
{
	// get ISecurityInfo* from DSSECL.DLL
	if (!g_DsSecDLL.Load())
		return E_INVALIDARG;
	
  ISecurityInformation* pSecInfo = NULL;
	HRESULT hr = g_DsSecDLL.DSCreateISecurityInfoObjectEx(
										lpszLDAPPath,
										NULL, // pwszObjectClass
										lpszServer,
										lpszUsername,
										lpszPassword,
										dwFlags,
                    &pSecInfo);
  if (SUCCEEDED(hr))
    m_pISecInfoWrap->SetSecInfoPtr(pSecInfo);

  return hr;
}

HPROPSHEETPAGE CAclEditorPage::CreatePage()
{
	if (!g_AclUiDLL.Load())
		return NULL;

	// call into ACLUI.DLL to create the page
	// passing the wrapper interface
	return g_AclUiDLL.CreateSecurityPage(m_pISecInfoWrap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mtfrmwk\mtfrmwk.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mtfrmwk.rc
//
#define IDM_WHATS_THIS                  52000
#define IDR_WHATS_THIS_CONTEXT_MENU1    52001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        153
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1297
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mtfrmwk\dbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dbg.h
//
//--------------------------------------------------------------------------


/////////////////////////////////////////////////////////////////////
// debug helpers

#if defined(_USE_MTFRMWK_TRACE)
  #if defined(TRACE)
    #undef TRACE
      void MtFrmwkTrace(LPCWSTR, ...);
      #define TRACE MtFrmwkTrace
  #endif
#else
  #if defined(TRACE)
    #undef TRACE
    #define TRACE
  #endif
#endif

#if defined(DBG)

  void MtFrmwkLogFile(LPCTSTR lpszFormat, ...);
  void MtFrmwkLogFileIfLog(BOOL bLog, LPCTSTR lpszFormat, ...);

  //
  // Copied from burnslib on 12-07-1999
  //
  #define TRACET MtFrmwkLogFile                      

  #define TRACE_LOGFILE MtFrmwkLogFile

  #define TRACE_LOGFILE_IF_NO_UI MtFrmwkLogFileIfLog

  #define TRACE_SCOPET(bLog, msg)                               \
      CScopeTracer __tracer(bLog, msg);

  #define TRACE_FUNCTION(func) TRACE_SCOPET(TRUE, TEXT(#func))

  #define TRACE_FUNCTION_IF_NO_UI(bLog, func) TRACE_SCOPET(bLog, TEXT(#func))
#else

  #define TRACET
  #define TRACE_LOGFILE
  #define TRACE_LOGFILE_IF_NO_UI
  #define TRACE_SCOPET(bLog, msg)
  #define TRACE_FUNCTION(func)
  #define TRACE_FUNCTION_IF_NO_UI(bLog, func)

#endif // defined(DBG)

// A ScopeTracer object emits text to the log upon construction and
// destruction.  Place one at the beggining of a lexical scope, and it will
// log when the scope is entered and exited.
//
// See TRACE_SCOPE, TRACE_CTOR, TRACE_DTOR, TRACE_FUNCTION, TRACE_FUNCTION2

class CScopeTracer
{
public:
  CScopeTracer(BOOL bLog, PCWSTR pszMessage);
  ~CScopeTracer();

private:

  CString szMessage;
  BOOL    m_bLog;
};

//
// Log provides an interface to a singleton application logging facility.
//
class CLogFile
{
  friend class CScopeTracer;

public:

  //
  // Returns a pointer to the single CLogFile instance.
  //
  static CLogFile* GetInstance();

  //
  // Closes and deletes the single CLogFile instance.  If GetInstance is
  // called after this point, then a new instance will be created.
  //
  static void KillInstance();

  //
  // Returns true if the log file is open, false if not.
  //
  BOOL IsOpen() const;

  void writeln(PCWSTR pszText);
  void indent();
  void outdent();

private:

  CLogFile(PCWSTR logBaseName);
  ~CLogFile();

  CString  szBase_name;
  HANDLE   file_handle;
  unsigned trace_line_number;

  //
  // not implemented; no instance copying allowed.
  //
  CLogFile(const CLogFile&);
  const CLogFile& operator=(const CLogFile&);
};


#if defined(_USE_MTFRMWK_ASSERT)
  #undef ASSERT
  #undef VERIFY
  #undef THIS_FILE
  #define THIS_FILE          __FILE__

  BOOL  MtFrmwkAssertFailedLine(LPCSTR lpszFileName, int nLine);
  #define ASSERT(f) \
	  do \
	  { \
      BOOL bPrefast = (f && L"a hack so that prefast doesn't bark"); \
	    if (!(bPrefast) &&  MtFrmwkAssertFailedLine(THIS_FILE, __LINE__)) \
		    ::DebugBreak(); \
	  } while (0) \

  #define VERIFY(f)          ASSERT(f)

#endif // _USE_MTFRMWK_ASSERT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mtfrmwk\proppage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       proppage.h
//
//--------------------------------------------------------------------------


#ifndef _PROPPAGE_H
#define _PROPPAGE_H

// proppage.h : header file
//


///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CTreeNode; 
class CContainerNode;
class CComponentDataObject;

class CPropertyPageHolderBase;
class CPropertyPageBase; 
class CPropertyPageHolderTable; 
class CWatermarkInfo;
 
typedef CList< CPropertyPageBase*, CPropertyPageBase* > CPropertyPageBaseList;

////////////////////////////////////////////////////////////////////
// CHiddenWndBase : Utility Hidden Window

class CHiddenWndBase : public CWindowImpl<CHiddenWndBase>
{
public:
  DECLARE_WND_CLASS(L"DNSMgrHiddenWindow")

	BOOL Create(HWND hWndParent = NULL); 	
	
	BEGIN_MSG_MAP(CHiddenWndBase)
  END_MSG_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CSheetWnd

class CSheetWnd : public CHiddenWndBase
{
public:
	static const UINT s_SheetMessage;
	static const UINT s_SelectPageMessage;
	CSheetWnd(CPropertyPageHolderBase* pHolder) { m_pHolder = pHolder;}

  BEGIN_MSG_MAP(CSheetWnd)
    MESSAGE_HANDLER( WM_CLOSE, OnClose )
    MESSAGE_HANDLER( CSheetWnd::s_SheetMessage, OnSheetMessage )
    MESSAGE_HANDLER( CSheetWnd::s_SelectPageMessage, OnSelectPageMessage )
    CHAIN_MSG_MAP(CHiddenWndBase)
  END_MSG_MAP()

  LRESULT OnClose(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled); 
	LRESULT OnSheetMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled); 
	LRESULT OnSelectPageMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled); 

private:
	CPropertyPageHolderBase* m_pHolder;
};


/////////////////////////////////////////////////////////////////////////////
// CCloseDialogInfo

class CCloseDialogInfo
{
public:
	CCloseDialogInfo()
		{ m_hWnd = NULL; m_dwFlags = 0x0; }
	BOOL CloseDialog(BOOL bCheckForMsgBox);

	static BOOL CCloseDialogInfo::CloseMessageBox(HWND hWndParent);

	HWND m_hWnd;
	DWORD m_dwFlags;
};

/////////////////////////////////////////////////////////////////////////////
// CCloseDialogInfoStack

template <UINT nSize> class CCloseDialogInfoStack
{
public:
	CCloseDialogInfoStack()
	{ 
		m_nTop = 0; // first empty
		m_bForcedClose = FALSE;
	}
	BOOL IsEmpty()
	{
		return m_nTop <= 0;
	}
	BOOL Push(HWND hWnd, DWORD dwFlags)
	{
		ASSERT(hWnd  != NULL);
		ASSERT(::IsWindow(hWnd));
		if (m_nTop >= nSize)
			return FALSE;
		m_arr[m_nTop].m_hWnd = hWnd;
		m_arr[m_nTop].m_dwFlags = dwFlags;
		m_nTop++;
		return TRUE;
	}
	BOOL Pop()
	{
		if (m_bForcedClose)
			return TRUE; // going away
		if (m_nTop <= 0)
			return FALSE;
		m_nTop--;
		return TRUE;
	}
	void ForceClose(HWND hWndPage)
	{
		if (m_bForcedClose)
		{
			return; // avoid reentrancy
		}
		m_bForcedClose = TRUE;
		if (m_nTop > 0)
		{
			// have a stack to unwind
			BOOL bOutermost = TRUE;
			while (m_nTop > 0)
			{
				VERIFY(m_arr[m_nTop-1].CloseDialog(bOutermost));
				bOutermost = FALSE;
				m_nTop--;
			}
		}
		else
		{
			// empty stack, but might have a message box
			HWND hWndSheet = ::GetParent(hWndPage);
			ASSERT(hWndSheet != NULL);
			if (CCloseDialogInfo::CloseMessageBox(hWndSheet))
				VERIFY(::PostMessage(hWndSheet, WM_COMMAND, IDCANCEL, 0));
		}
	}
private:
	UINT m_nTop;
	CCloseDialogInfo m_arr[nSize];
	BOOL m_bForcedClose;
};


/////////////////////////////////////////////////////////////////////////////
// CPropertyPageHolderBase

class CPropertyPageHolderBase
{
public:
// construction
	CPropertyPageHolderBase(CContainerNode* pContNode, CTreeNode* pNode, 
		CComponentDataObject* pComponentData);
	virtual ~CPropertyPageHolderBase();

// initialization
	// common
	void Attach(CPropertyPageHolderBase* pContHolder);
	BOOL EnableSheetControl(UINT nCtrlID, BOOL bEnable);

	// property sheet only
	static HRESULT CreateModelessSheet(CTreeNode* pNode, CComponentDataObject* pComponentData);
	HRESULT CreateModelessSheet(CTreeNode* pCookieNode);
	HRESULT CreateModelessSheet(LPPROPERTYSHEETCALLBACK pSheetCallback, LONG_PTR hConsoleHandle); 
	void SetStartPageCode(int nStartPageCode) 
		{ m_nStartPageCode = nStartPageCode;}

	// wizard only
	HRESULT DoModalWizard();
	INT_PTR DoModalDialog(LPCTSTR pszCaption);

// helpers
	// common
	void SetSheetWindow(HWND hSheetWindow);
  void SetSheetTitle(LPCWSTR lpszSheetTitle);
  void SetSheetTitle(UINT nStringFmtID, CTreeNode* pNode);

	void AddRef();
	void Release();

	DWORD GetRefCount() { return m_nCreatedCount;}
	CComponentDataObject* GetComponentData() { ASSERT(m_pComponentData != NULL); return m_pComponentData;}
  HWND GetMainWindow() { return m_hMainWnd;}

	// get/set for the node we are working on
	CTreeNode* GetTreeNode() { return m_pNode;}
	void SetTreeNode(CTreeNode* pNode) { m_pNode = pNode; }
	// get/set for the container we refer to
	CContainerNode* GetContainerNode() 
	{ 
		return m_pContNode;
	}
	void SetContainerNode(CContainerNode* pContNode) { ASSERT(pContNode != NULL); m_pContNode = pContNode; }
	
	
	BOOL IsWizardMode();
	BOOL IsModalSheet();
	void ForceDestroy();	// forcefull shut down running sheet

	void AddPageToList(CPropertyPageBase* pPage);
	BOOL RemovePageFromList(CPropertyPageBase* pPage, BOOL bDeleteObject);

	// property sheet only
	BOOL PushDialogHWnd(HWND hWndModalDlg);
	BOOL PopDialogHWnd();
	void CloseModalDialogs(HWND hWndPage);

	DWORD NotifyConsole(CPropertyPageBase* pPage);		// notify console of property changes
	void AcknowledgeNotify();							// acknowledge from the console
	virtual BOOL OnPropertyChange(BOOL bScopePane, long* pChangeMask); // execute from main thread

	// wizard only
	BOOL SetWizardButtons(DWORD dwFlags);
	BOOL SetWizardButtonsFirst(BOOL bValid) 
	{ 
		return SetWizardButtons(bValid ? PSWIZB_NEXT : 0);
	}
	BOOL SetWizardButtonsMiddle(BOOL bValid) 
	{ 
		return SetWizardButtons(bValid ? (PSWIZB_BACK|PSWIZB_NEXT) : PSWIZB_BACK);
	}
	BOOL SetWizardButtonsLast(BOOL bValid) 
	{ 
		return SetWizardButtons(bValid ? (PSWIZB_BACK|PSWIZB_FINISH) : (PSWIZB_BACK|PSWIZB_DISABLEDFINISH));
	}

	HRESULT AddPageToSheet(CPropertyPageBase* pPage);
	HRESULT AddPageToSheetRaw(HPROPSHEETPAGE hPage);
	HRESULT RemovePageFromSheet(CPropertyPageBase* pPage);
	HRESULT AddAllPagesToSheet();

protected:
	// common
	virtual HRESULT OnAddPage(int, CPropertyPageBase*) { return S_OK; }

	// property sheet only
	virtual void OnSheetMessage(WPARAM, LPARAM) {}
	virtual int OnSelectPageMessage(long) { return -1;}

	// wizard only
	void SetWatermarkInfo(CWatermarkInfo* pWatermarkInfo);

private:
	void DeleteAllPages();
	void FinalDestruct();

// attributes
private:
	// common
	CString m_szSheetTitle;					// title for the sheet/wizard window
	CPropertyPageBaseList m_pageList;		// list of property page objects
	CPropertyPageHolderBase* m_pContHolder;	// prop page holder that migh contain this
	CComponentDataObject* m_pComponentData; // cached pointer to CComponentDataImplementation
  HWND m_hMainWnd;  // cached MMC frame window, if present

protected:
	BOOL m_bWizardMode;						// Wizard Mode (i.e. not modeless property sheet)
	BOOL m_bAutoDelete;						// delete itself when refcount goes to zero
	BOOL m_bAutoDeletePages;				// explicitely delete the property page C++ objects

  enum { useDefault, forceOn, forceOff } m_forceContextHelpButton; // setting for the [?] button

private:	
	DWORD	m_nCreatedCount;				// count of how many pages got actually created
	CTreeNode* m_pNode;						// node the pages (or the wizard) refer to
	CContainerNode* m_pContNode;			// container node the pages (or the wizard) refer to
	HWND m_hSheetWindow;					// window handle to the sheet (thread safe)

	// property sheet only
	LONG_PTR    m_hConsoleHandle;				// handle for notifications to console
	HANDLE m_hEventHandle;					// syncronization handle for property notifications
	CSheetWnd*	m_pSheetWnd;				// hidden window CWnd object for messages
	int			m_nStartPageCode;			// starting page code (not necessarily the page #)
	CCloseDialogInfoStack<5> m_dlgInfoStack;	// modal dialogs stack (to close them down)

	// wizard only
	IPropertySheetCallback* m_pSheetCallback; // cached pointer to add/remove pages
	CPropertySheet*			m_pDummySheet;	  // MFC surrogate property sheet for modal operations
	CWatermarkInfo*			m_pWatermarkInfo; // watermark info for Wiz 97 sheets

private:
	// property sheet only
	// variables to use across thread boundaries
	DWORD m_dwLastErr;						// generic error code
	CPropertyPageBase* m_pPropChangePage;	// page for which notification is valid
public:
	void SetError(DWORD dwErr) { m_dwLastErr = dwErr;}
	CPropertyPageBase* GetPropChangePage() 
			{ ASSERT(m_pPropChangePage != NULL); return m_pPropChangePage; }

	friend class CSheetWnd;
};

/////////////////////////////////////////////////////////////////////////////
// CPropertyPageBase

class CPropertyPageBase : public CPropertyPage
{
// Construction
private:
	CPropertyPageBase(){} // cannot use this constructor
public:
	CPropertyPageBase(UINT nIDTemplate, 
                    UINT nIDCaption = 0);
	virtual ~CPropertyPageBase();

// Overrides
public:
	virtual BOOL OnInitDialog()
	{
		CWinApp* pApp = AfxGetApp();
    ASSERT(pApp);
		return CPropertyPage::OnInitDialog();
	}
	virtual void OnCancel();
	virtual BOOL OnApply();

protected:
// Generated message map functions
	//{{AFX_MSG(CGeneralPage)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG

  afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnWhatsThis();
  afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	
	DECLARE_MESSAGE_MAP()

// attributes
public:
	// common
	PROPSHEETPAGE  m_psp97;
	HPROPSHEETPAGE m_hPage; 
	void SetHolder(CPropertyPageHolderBase* pPageHolder)
	{ ASSERT((pPageHolder != NULL) && (m_pPageHolder == NULL)); m_pPageHolder = pPageHolder;}
	CPropertyPageHolderBase* GetHolder() { return m_pPageHolder;};

	// property seet only
	virtual BOOL OnPropertyChange(BOOL, long*) // execute from main thread
						{ return FALSE; /* do not repaint UI */ } 

	// wizard only
	UINT m_nPrevPageID;	// to be used by OnWizardBack()
	void InitWiz97(BOOL bHideHeader, UINT nIDHeaderTitle, UINT nIDHeaderSubTitle);
private:
	CString m_szHeaderTitle;
	CString m_szHeaderSubTitle;

protected:
	virtual void SetUIData(){}
	virtual void GetUIData(){}
  virtual LONG GetUIDataEx() { return 0;}
	virtual void SetDirty(BOOL bDirty);
	BOOL IsDirty() { return m_bIsDirty; }

private:
	CPropertyPageHolderBase* m_pPageHolder; // backpointer to holder
	BOOL m_bIsDirty;							// dirty flag

  HWND  m_hWndWhatsThis;  // hwnd of right click "What's this" help
};




/////////////////////////////////////////////////////////////////////////////
// CPropertyPageHolderTable

class CPropertyPageHolderTable
{
public:
	CPropertyPageHolderTable(CComponentDataObject* pComponentData);
	~CPropertyPageHolderTable(); 

	void Add(CPropertyPageHolderBase* pPPHolder);
	void AddWindow(CPropertyPageHolderBase* pPPHolder, HWND hWnd);
	void Remove(CPropertyPageHolderBase* pPPHolder);

	void DeleteSheetsOfNode(CTreeNode* pNode);

	void WaitForAllToShutDown();

	// sheet notification mechanism
	void BroadcastMessageToSheets(CTreeNode* pNode, WPARAM wParam, LPARAM lParam);
	void BroadcastSelectPage(CTreeNode* pNode, long nPageCode);
	int  BroadcastCloseMessageToSheets(CTreeNode* pNode);

private:
	CComponentDataObject* m_pComponentData; // back pointer

	void WaitForSheetShutdown(int nCount, HWND* hWndArr = NULL);

	struct PPAGE_HOLDER_TABLE_ENTRY
	{
		CPropertyPageHolderBase* pPPHolder;
		CTreeNode* pNode;
		HWND hWnd;
	};

	PPAGE_HOLDER_TABLE_ENTRY* m_pEntries;
	int m_nSize;
};


////////////////////////////////////////////////////////////
// CHelpDialog

class CHelpDialog : public CDialog
{
// Construction
private:
	CHelpDialog(){}
public:
	CHelpDialog(UINT nIDTemplate, CComponentDataObject* pComponentData);
  CHelpDialog(UINT nIDTemplate, CWnd* pParentWnd, CComponentDataObject* pComponentData);
  virtual ~CHelpDialog() {};

  virtual void OnOK() { CDialog::OnOK(); }

protected:
  afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnWhatsThis();
  afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	
	DECLARE_MESSAGE_MAP()

private:
  HWND  m_hWndWhatsThis;  // hwnd of right click "What's this" help
  CComponentDataObject* m_pComponentData;
};

#endif // _PROPPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mtfrmwk\proppag_.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       proppag_.cpp
//
//--------------------------------------------------------------------------



//////////////////////////////////////////////////////////////////////////
// private helper functions

BOOL CALLBACK EnumThreadWndProc(HWND hwnd, /* enumerated HWND */
								LPARAM lParam /* pass a HWND* for return value*/ )
{
	ASSERT(hwnd);
	HWND hParentWnd = GetParent(hwnd);
	// the main window of the MMC console should staitsfy this condition
	if ( ((hParentWnd == GetDesktopWindow()) || (hParentWnd == NULL))  && IsWindowVisible(hwnd) )
	{
		HWND* pH = (HWND*)lParam;
		*pH = hwnd;
		return FALSE; // stop enumerating
	}
	return TRUE;
}



HWND FindMMCMainWindow()
{
	DWORD dwThreadID = ::GetCurrentThreadId();
	ASSERT(dwThreadID != 0);
	HWND hWnd = NULL;
	BOOL bEnum = EnumThreadWindows(dwThreadID, EnumThreadWndProc,(LPARAM)&hWnd);
  ASSERT(bEnum);
	ASSERT(hWnd != NULL);
	return hWnd;
}

////////////////////////////////////////////////////////////////////
// CHiddenWndBase : Utility Hidden Window


BOOL CHiddenWndBase::Create(HWND hWndParent)
{
  ASSERT(hWndParent == NULL || ::IsWindow(hWndParent));
  RECT rcPos;
  ZeroMemory(&rcPos, sizeof(RECT));
  HWND hWnd = CWindowImpl<CHiddenWndBase>::Create(hWndParent, 
                      rcPos, //RECT& rcPos, 
                      NULL,  //LPCTSTR szWindowName = NULL, 
                      (hWndParent) ? WS_CHILD : WS_POPUP,   //DWORD dwStyle = WS_CHILD | WS_VISIBLE, 
                      0x0,   //DWORD dwExStyle = 0, 
                      0      //UINT nID = 0 
                      );
  return hWnd != NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CSheetWnd

const UINT CSheetWnd::s_SheetMessage = WM_USER + 100;
const UINT CSheetWnd::s_SelectPageMessage = WM_USER + 101;

LRESULT CSheetWnd::OnSheetMessage(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
	ASSERT(m_pHolder != NULL);
	m_pHolder->OnSheetMessage(wParam,lParam);
	return 1;
}

LRESULT CSheetWnd::OnSelectPageMessage(UINT, WPARAM wParam, LPARAM, BOOL&)
{
	TRACE(_T("CSheetWnd::OnSelectPageMessage()\n"));
	ASSERT(m_pHolder != NULL);
	int nPage = m_pHolder->OnSelectPageMessage((long)wParam);
	if (nPage >= 0)
	{
		// can use SendMessage() because the sheet has been created already
		VERIFY(PropSheet_SetCurSel(m_pHolder->m_hSheetWindow, NULL, nPage));
	}
   ::SetForegroundWindow(::GetParent(m_hWnd));
	return 1;
}

LRESULT CSheetWnd::OnClose(UINT, WPARAM, LPARAM, BOOL&)
{
	return 1;
}

/////////////////////////////////////////////////////////////////////////////
// CCloseDialogInfo


struct FIND_MSG_BOX_INFO
{
	LPCTSTR lpszTitle;
	HWND hWnd;
	HWND hWndParent;
};

BOOL CALLBACK EnumMessageBoxProc(HWND hwnd,	LPARAM lParam)
{
	FIND_MSG_BOX_INFO* pInfo = (FIND_MSG_BOX_INFO*)lParam;
	if (::GetParent(hwnd) != pInfo->hWndParent)
		return TRUE;

  TCHAR szTitle[256] = {0};
	::GetWindowText(hwnd, szTitle, 256);
	TRACE(_T("Title <%s>\n"), szTitle);
	if (_wcsicmp(szTitle, pInfo->lpszTitle) == 0)
	{
		pInfo->hWnd = hwnd;
		return FALSE;
	}
	return TRUE;
}


HWND FindMessageBox(LPCTSTR lpszTitle, HWND hWndParent)
{
	FIND_MSG_BOX_INFO info;
	info.hWndParent = hWndParent;
	info.lpszTitle = lpszTitle;
	info.hWnd = NULL;
	EnumWindows(EnumMessageBoxProc, (LPARAM)&info);
	if (info.hWnd != NULL)
		return info.hWnd;
	return NULL;
}

BOOL CCloseDialogInfo::CloseMessageBox(HWND hWndParent)
{
	BOOL bClosed = FALSE;
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	LPCTSTR lpszMsgBoxTitle = AfxGetApp()->m_pszAppName;
	HWND hWndMessageBox = FindMessageBox(lpszMsgBoxTitle, hWndParent);
	if (hWndMessageBox != NULL)
	{
		// figure out if there is a cancel button or not
		HWND hWndCtrl = ::GetDlgItem(hWndMessageBox, IDCANCEL);
		if (hWndCtrl != NULL)
		{
			VERIFY(::SendMessage(hWndMessageBox, WM_CLOSE, 0, 0) == 0);
			bClosed = TRUE;
		}
		else
		{
			// does it have just the OK button?
			hWndCtrl = ::GetDlgItem(hWndMessageBox, IDOK);
			if (hWndCtrl != NULL)
			{
				VERIFY(::SendMessage(hWndMessageBox, WM_COMMAND, IDOK, 0) == 0);
				bClosed = TRUE;
			}
			else
			{
				// does it have a NO button?
				hWndCtrl = ::GetDlgItem(hWndMessageBox, IDNO);
				if (hWndCtrl != NULL)
				{
					VERIFY(::SendMessage(hWndMessageBox, WM_COMMAND, IDNO, 0) == 0);
					bClosed = TRUE;
				}
			}
		}
	}
	return bClosed;
}

BOOL CCloseDialogInfo::CloseDialog(BOOL bCheckForMsgBox)
{
	if (bCheckForMsgBox)
		CloseMessageBox(m_hWnd);
	return (::SendMessage(m_hWnd, WM_CLOSE, 0, 0) == 0);
}



/////////////////////////////////////////////////////////////////////////////
// CPropertyPageHolderBase

CPropertyPageHolderBase::CPropertyPageHolderBase(CContainerNode* pContNode, CTreeNode* pNode,
		CComponentDataObject* pComponentData)
{
	m_szSheetTitle = (LPCWSTR)NULL;
	m_pDummySheet = NULL;

	// default setting for a self deleting modeless property sheet,
	// automatically deleting all the pages
	m_bWizardMode = FALSE;
	m_bAutoDelete = TRUE;
	m_bAutoDeletePages = TRUE;

	m_forceContextHelpButton = useDefault;

	m_pContHolder = NULL;
	m_nCreatedCount = 0;
	m_hSheetWindow = NULL;
	m_pSheetWnd = NULL;
	m_nStartPageCode = -1; // not set
	m_hConsoleHandle = 0;
	m_hEventHandle = NULL;
	m_pSheetCallback = NULL;

	// setup from arguments
	// For tasks in can be null ASSERT(pContNode != NULL); // must always have a valid container node to refer to
	m_pContNode = pContNode;
	ASSERT((pNode == NULL) || (pNode->GetContainer() == m_pContNode) );
	m_pNode = pNode;
	ASSERT(pComponentData != NULL);
	m_pComponentData = pComponentData;

  m_hMainWnd = NULL;
  LPCONSOLE pConsole = m_pComponentData->GetConsole();
  if (pConsole != NULL)
  {
    pConsole->GetMainWindow(&m_hMainWnd);
  }

	m_dwLastErr = 0x0;
	m_pPropChangePage = NULL;
	m_pWatermarkInfo = NULL;
}

CPropertyPageHolderBase::~CPropertyPageHolderBase()
{
	FinalDestruct();
	ASSERT(m_pSheetWnd == NULL);
	SAFE_RELEASE(m_pSheetCallback);
	if (m_hEventHandle != NULL)
	{
		VERIFY(::CloseHandle(m_hEventHandle));
		m_hEventHandle = NULL;
	}
	if (m_pDummySheet != NULL)
		delete m_pDummySheet;
}

void CPropertyPageHolderBase::Attach(CPropertyPageHolderBase* pContHolder)
{
	ASSERT( (m_pContHolder == NULL) && (pContHolder != NULL) );
	m_pContHolder = pContHolder;
	m_bWizardMode = pContHolder->IsWizardMode();
}

BOOL CPropertyPageHolderBase::EnableSheetControl(UINT nCtrlID, BOOL bEnable)
{
	if (m_pContHolder != NULL)
	{
		return m_pContHolder->EnableSheetControl(nCtrlID, bEnable);
	}
	ASSERT(::IsWindow(m_hSheetWindow));
	HWND hWndCtrl = ::GetDlgItem(m_hSheetWindow, nCtrlID);
	if (hWndCtrl == NULL)
		return FALSE;
	return ::EnableWindow(hWndCtrl, bEnable);
}

HRESULT CPropertyPageHolderBase::CreateModelessSheet(CTreeNode* pNode, CComponentDataObject* pComponentData)
{
	ASSERT(pNode != NULL);
	ASSERT(pComponentData != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// get an interface to a sheet provider
	IPropertySheetProvider* pSheetProvider;
	HRESULT hr = pComponentData->GetConsole()->QueryInterface(IID_IPropertySheetProvider,(void**)&pSheetProvider);
	ASSERT(SUCCEEDED(hr));
	ASSERT(pSheetProvider != NULL);

	// get an interface to a sheet callback
	IPropertySheetCallback* pSheetCallback;
	hr = pComponentData->GetConsole()->QueryInterface(IID_IPropertySheetCallback,(void**)&pSheetCallback);
	ASSERT(SUCCEEDED(hr));
	ASSERT(pSheetCallback != NULL);

	// create a data object for this node
	IDataObject* pDataObject;
	hr = pComponentData->QueryDataObject((MMC_COOKIE)pNode, CCT_SCOPE, &pDataObject);
	ASSERT(SUCCEEDED(hr));
	ASSERT(pDataObject != NULL);

	// get a sheet
	hr = pSheetProvider->CreatePropertySheet(_T("SHEET TITLE"), TRUE, (MMC_COOKIE)pNode, pDataObject, 0x0 /*dwOptions*/);
	ASSERT(SUCCEEDED(hr));
	pDataObject->Release();

  HWND hWnd = NULL;
	hr = pComponentData->GetConsole()->GetMainWindow(&hWnd);
	ASSERT(SUCCEEDED(hr));
	ASSERT(hWnd == ::FindMMCMainWindow());

	IUnknown* pUnkComponentData = pComponentData->GetUnknown(); // no addref
	hr = pSheetProvider->AddPrimaryPages(pUnkComponentData,
											TRUE /*bCreateHandle*/,
											hWnd,
											TRUE /* bScopePane*/);
	ASSERT(SUCCEEDED(hr));

	hr = pSheetProvider->Show(reinterpret_cast<LONG_PTR>(hWnd), 0);
	ASSERT(SUCCEEDED(hr));

	// final interface release
	pSheetProvider->Release();
	pSheetCallback->Release();
	return hr;
}





HRESULT CPropertyPageHolderBase::CreateModelessSheet(CTreeNode* pCookieNode)
{
	ASSERT(!IsWizardMode());
	ASSERT(m_pContHolder == NULL);
	ASSERT(m_pComponentData != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// get an interface to a sheet provider
	IPropertySheetProvider* pSheetProvider;
	HRESULT hr = m_pComponentData->GetConsole()->QueryInterface(IID_IPropertySheetProvider,(void**)&pSheetProvider);
	ASSERT(SUCCEEDED(hr));
	ASSERT(pSheetProvider != NULL);

	// get an interface to a sheet callback
	IPropertySheetCallback* pSheetCallback;
	hr = m_pComponentData->GetConsole()->QueryInterface(IID_IPropertySheetCallback,(void**)&pSheetCallback);
	ASSERT(SUCCEEDED(hr));
	ASSERT(pSheetCallback != NULL);

	// create a data object for this node
	IDataObject* pDataObject;
	hr = m_pComponentData->QueryDataObject((MMC_COOKIE)pCookieNode, CCT_SCOPE, &pDataObject);
	ASSERT(SUCCEEDED(hr));
	ASSERT(pDataObject != NULL);

	// get a sheet
	hr = pSheetProvider->CreatePropertySheet(m_szSheetTitle, TRUE, (MMC_COOKIE)pCookieNode, pDataObject, 0x0 /*dwOptions*/);
	ASSERT(SUCCEEDED(hr));
	pDataObject->Release();

	HWND hWnd = GetMainWindow();
	ASSERT(hWnd == ::FindMMCMainWindow());

	IUnknown* pUnkComponentData = m_pComponentData->GetUnknown(); // no addref
	hr = pSheetProvider->AddPrimaryPages(pUnkComponentData,
											TRUE /*bCreateHandle*/,
											NULL /*hWnd*/,
											FALSE /* bScopePane*/);
	ASSERT(SUCCEEDED(hr));

	hr = pSheetProvider->Show(reinterpret_cast<LONG_PTR>(hWnd), 0);
	ASSERT(SUCCEEDED(hr));

	// final interface release
	pSheetProvider->Release();
	pSheetCallback->Release();
	return hr;
}



HRESULT CPropertyPageHolderBase::CreateModelessSheet(LPPROPERTYSHEETCALLBACK pSheetCallback, LONG_PTR hConsoleHandle)
{
	ASSERT(m_pContHolder == NULL);
	ASSERT(pSheetCallback != NULL);
	ASSERT(m_pSheetCallback == NULL);

  //
  // REVIEW_JEFFJON : seems to be NULL when called from CComponentDataObject::CreatePropertySheet()
  //
	m_hConsoleHandle = hConsoleHandle;

	m_bWizardMode = FALSE; // we go modeless
	ASSERT(m_pNode != NULL);
	CPropertyPageHolderTable* pPPHTable = m_pComponentData->GetPropertyPageHolderTable();
	ASSERT(pPPHTable != NULL);

	// add the property sheet holder to the holder table
	pPPHTable->Add(this);
	// notify the node it has a sheet up
	m_pNode->OnCreateSheet();

	// temporarily attach the sheet callback to this object to add pages
	// do not addref, we will not hold on to it;
	m_pSheetCallback = pSheetCallback;
	
	HRESULT hr = AddAllPagesToSheet();
	m_pSheetCallback = NULL; // detach
	return hr;
}

void CPropertyPageHolderBase::SetWatermarkInfo(CWatermarkInfo* pWatermarkInfo)
{
	ASSERT(m_pWatermarkInfo == NULL);
	ASSERT(pWatermarkInfo != NULL);
}

HRESULT CPropertyPageHolderBase::DoModalWizard()
{
	ASSERT(m_pContHolder == NULL);
	ASSERT(m_pComponentData != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_bWizardMode = TRUE;

	// get an interface to a sheet provider
	IPropertySheetProvider* pSheetProvider;
	HRESULT hr = m_pComponentData->GetConsole()->QueryInterface(IID_IPropertySheetProvider,(void**)&pSheetProvider);
	ASSERT(SUCCEEDED(hr));
	ASSERT(pSheetProvider != NULL);

	// get an interface to a sheet callback
	IPropertySheetCallback* pSheetCallback;
	hr = m_pComponentData->GetConsole()->QueryInterface(IID_IPropertySheetCallback,(void**)&pSheetCallback);
	ASSERT(SUCCEEDED(hr));
	ASSERT(pSheetCallback != NULL);
	m_pSheetCallback = pSheetCallback; // save to add/remove pages

	// Create a dummy data object. AddPrimaryPages will call
	// IextendPropertySheet2::QueryPagesFor() and
	// IextendPropertySheet2::CreatePropertyPages()
	// that will ignore the un-initialized data object
	MMC_COOKIE cookie = -1;
	DATA_OBJECT_TYPES type = CCT_UNINITIALIZED;
	IDataObject* pDataObject;
	hr = m_pComponentData->QueryDataObject(cookie, type, &pDataObject);
	ASSERT(SUCCEEDED(hr));
	ASSERT(pDataObject != NULL);


	// Switch Watermark information, AddPrimaryPages will call
	// IextendPropertySheet2::GetWatermarks()
	CWatermarkInfo* pOldWatermarkInfo = NULL;
	if (m_pWatermarkInfo != NULL)
		pOldWatermarkInfo = m_pComponentData->SetWatermarkInfo(m_pWatermarkInfo);

	// create sheet
	hr = pSheetProvider->CreatePropertySheet( m_szSheetTitle, FALSE /* wizard*/,
							(MMC_COOKIE)cookie, pDataObject, MMC_PSO_NEWWIZARDTYPE /*dwOptions*/);
	ASSERT(SUCCEEDED(hr));

	// add pages to sheet
	hr = AddAllPagesToSheet();
	ASSERT(SUCCEEDED(hr));

	// add pages
	hr = pSheetProvider->AddPrimaryPages((IExtendPropertySheet2*)m_pComponentData, FALSE, NULL,FALSE);
	ASSERT(SUCCEEDED(hr));

	// restore the old watermark info
	if (pOldWatermarkInfo != NULL)
		m_pComponentData->SetWatermarkInfo(pOldWatermarkInfo);

	// for further dynamic page manipulation, don't use the Console's sheet callback interface
	// but resurt to the Win32 API's
	m_pSheetCallback->Release();
	m_pSheetCallback = NULL;

	// show the modal wizard
	HWND hWnd = GetMainWindow();
	ASSERT(hWnd != NULL);
	hr = pSheetProvider->Show((LONG_PTR)hWnd, 0);
	ASSERT(SUCCEEDED(hr));

	pSheetProvider->Release();
	pDataObject->Release();

	return hr;
}


INT_PTR CPropertyPageHolderBase::DoModalDialog(LPCTSTR pszCaption)
{
	ASSERT(m_pDummySheet == NULL);
	m_bWizardMode = TRUE;
	m_bAutoDelete = FALSE; // use on the stack
	m_pDummySheet = new CPropertySheet();
	m_pDummySheet->m_psh.dwFlags |= PSH_NOAPPLYNOW;
	m_pDummySheet->m_psh.pszCaption = pszCaption;
	VERIFY(SUCCEEDED(AddAllPagesToSheet()));
	return m_pDummySheet->DoModal();
}

void CPropertyPageHolderBase::SetSheetWindow(HWND hSheetWindow)
{
	ASSERT(hSheetWindow != NULL);
	if (m_pContHolder != NULL)
	{
		// we will use the HWND of the parent holder
		m_pContHolder->SetSheetWindow(hSheetWindow);
		return;
	}
	ASSERT( (m_hSheetWindow == NULL) || ((m_hSheetWindow == hSheetWindow)) );
	m_hSheetWindow = hSheetWindow;

	if (IsWizardMode())
	{
    if (m_forceContextHelpButton != useDefault)
    {
      DWORD dwStyle = ::GetWindowLong(m_hSheetWindow, GWL_EXSTYLE);
      if (m_forceContextHelpButton == forceOn)
      {
        dwStyle |= WS_EX_CONTEXTHELP; // force the [?] button
      }
      else
      {
        ASSERT(m_forceContextHelpButton == forceOff);
        dwStyle &= ~WS_EX_CONTEXTHELP; // get rid of the [?] button
      }
      ::SetWindowLong(m_hSheetWindow, GWL_EXSTYLE, dwStyle);
    }

		if (m_pDummySheet != NULL)
		{
			VERIFY(PushDialogHWnd(m_hSheetWindow));
		}
		return;
	}
	// hook up hidden window only when in sheet mode
	if(m_pSheetWnd == NULL)
	{
		CWinApp* pApp = AfxGetApp();
    ASSERT(pApp);
		ASSERT(!IsWizardMode());
		m_pSheetWnd = new CSheetWnd(this);
		VERIFY(m_pSheetWnd->Create(hSheetWindow));

		ASSERT(::GetParent(m_pSheetWnd->m_hWnd) == hSheetWindow);
		GetComponentData()->OnCreateSheet(this, m_pSheetWnd->m_hWnd);
		if (m_nStartPageCode > -1)
		{
			// we do a PostMessage() because we are in to middle of a page creation
			// and MFC does not digest this
			::PostMessage(m_hSheetWindow, PSM_SETCURSEL, OnSelectPageMessage(m_nStartPageCode), NULL);
		}
		
    // if needed, set the wizard title
    if (!m_szSheetTitle.IsEmpty())
    {
      ::SetWindowText(m_hSheetWindow, (LPCWSTR)m_szSheetTitle);
    }
	}
}

void CPropertyPageHolderBase::SetSheetTitle(LPCWSTR lpszSheetTitle)
{
  ASSERT(!IsWizardMode());

	if (m_pContHolder != NULL)
	{
		// defer to parent holder
		m_pContHolder->SetSheetTitle(lpszSheetTitle);
		return;
	}
  m_szSheetTitle = lpszSheetTitle;

  // if the sheet has been created already, set right away
  if (m_hSheetWindow != NULL && !m_szSheetTitle.IsEmpty())
  {
    ::SetWindowText(m_hSheetWindow, (LPCWSTR)m_szSheetTitle);
  }
}

void CPropertyPageHolderBase::SetSheetTitle(UINT nStringFmtID, CTreeNode* pNode)
{
  ASSERT(!IsWizardMode());

	if (m_pContHolder != NULL)
	{
		// defer to parent holder
		m_pContHolder->SetSheetTitle(nStringFmtID, pNode);
		return;
	}

  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  CString szFmt;
  VERIFY(szFmt.LoadString(nStringFmtID));
  m_szSheetTitle.Format((LPCWSTR)szFmt, pNode->GetDisplayName());

  // if the sheet has been created already, set right away
  if (m_hSheetWindow != NULL && !m_szSheetTitle.IsEmpty())
  {
    ::SetWindowText(m_hSheetWindow, (LPCWSTR)m_szSheetTitle);
  }
}


void CPropertyPageHolderBase::AddRef()
{
	if(m_pContHolder != NULL)
	{
		m_pContHolder->AddRef();
		return;
	}
	m_nCreatedCount++;
}
void CPropertyPageHolderBase::Release()
{
	if(m_pContHolder != NULL)
	{
		m_pContHolder->Release();
		return;
	}
	m_nCreatedCount--;
	if (m_nCreatedCount > 0)
		return;

	if(IsWizardMode())
	{
		if (m_pDummySheet != NULL)
			VERIFY(PopDialogHWnd());
	}
	else
	{
		// hidden window created only in sheet mode
		if (m_pSheetWnd != NULL)
		{
      if (m_pSheetWnd->m_hWnd != NULL)
			  m_pSheetWnd->DestroyWindow();
		}
	}
	if (m_bAutoDelete)
		delete this;
}

BOOL CPropertyPageHolderBase::IsWizardMode()
{
	if(m_pContHolder != NULL)
	{
		return m_pContHolder->IsWizardMode();
	}
	return m_bWizardMode;
}

BOOL CPropertyPageHolderBase::IsModalSheet()
{
	if(m_pContHolder != NULL)
	{
		return m_pContHolder->IsModalSheet();
	}
	return m_pDummySheet != NULL;
}


void CPropertyPageHolderBase::ForceDestroy()
{
	ASSERT(!IsWizardMode()); // should never occur on modal wizard

	// contained by other holder
	if (m_pContHolder != NULL)
	{
		ASSERT(!m_bAutoDelete); // container responsible for deleting this holder
		m_pContHolder->ForceDestroy();
		return;
	}

	// this is the primary holder
	ASSERT(m_bAutoDelete); // should be self deleting sheet
	HWND hSheetWindow = m_hSheetWindow;
	if (hSheetWindow != NULL)
	{
		ASSERT(::IsWindow(hSheetWindow));
		// this message will cause the sheet to close all the pages,
		// and eventually the destruction of "this"
		VERIFY(::PostMessage(hSheetWindow, WM_COMMAND, IDCANCEL, 0L) != 0);
	}
	else
	{
		// explicitely delete "this", there is no sheet created
		delete this;
	}
}

DWORD CPropertyPageHolderBase::NotifyConsole(CPropertyPageBase* pPage)
{

	if(m_pContHolder != NULL)
	{
		return m_pContHolder->NotifyConsole(pPage);
	}

	ASSERT(m_pNode != NULL);
	if (IsWizardMode())
	{
		ASSERT(m_hConsoleHandle == NULL);
		return 0x0;
	}
	
	m_pPropChangePage = pPage; // to pass to the main thread
	m_dwLastErr = 0x0;

	if (m_hEventHandle == NULL)
	{
		m_hEventHandle = ::CreateEvent(NULL,TRUE /*bManualReset*/,FALSE /*signalled*/, NULL);
		ASSERT(m_hEventHandle != NULL);
	}

  if (m_hConsoleHandle != NULL)
  {
	  MMCPropertyChangeNotify(m_hConsoleHandle, reinterpret_cast<LPARAM>(this));

	  DWORD dwRet;
	  do
	  {
		  ASSERT(::IsWindow(m_hSheetWindow));
		  dwRet = MsgWaitForMultipleObjects(1,&m_hEventHandle,FALSE,INFINITE, QS_SENDMESSAGE);
		  if(dwRet == (WAIT_OBJECT_0+1))
		  {
			  MSG tempMSG;
			  PeekMessage(&tempMSG,m_hSheetWindow,0,0,PM_NOREMOVE);
		  }
	  }
	  while(dwRet == (WAIT_OBJECT_0+1));
  }

	VERIFY(0 != ::ResetEvent(m_hEventHandle));

	m_pPropChangePage = NULL; // reset
	return m_dwLastErr;
}

void CPropertyPageHolderBase::AcknowledgeNotify()
{
	if(m_pContHolder != NULL)
	{
		m_pContHolder->AcknowledgeNotify();
		return;
	}
	ASSERT(!IsWizardMode());
	ASSERT(m_hEventHandle != NULL);
	//TRACE(_T("before SetEvent\n"));
	VERIFY(0 != ::SetEvent(m_hEventHandle));
	//TRACE(_T("after SetEvent\n"));
}

BOOL CPropertyPageHolderBase::OnPropertyChange(BOOL bScopePane, long* pChangeMask)
{
	ASSERT(!IsWizardMode());
	CPropertyPageBase* pPage = GetPropChangePage();
	if (pPage == NULL)
		return FALSE;
	return pPage->OnPropertyChange(bScopePane, pChangeMask);
}


BOOL CPropertyPageHolderBase::SetWizardButtons(DWORD dwFlags)
{
	ASSERT(IsWizardMode());
	if (m_pContHolder != NULL)
	{
		ASSERT(m_hSheetWindow == NULL);
		return m_pContHolder->SetWizardButtons(dwFlags);
	}
	ASSERT(::IsWindow(m_hSheetWindow));
	return (BOOL)SendMessage(m_hSheetWindow, PSM_SETWIZBUTTONS, 0, dwFlags);
}

HRESULT CPropertyPageHolderBase::AddPageToSheet(CPropertyPageBase* pPage)
{
	if (m_pContHolder != NULL)
	{
		ASSERT(m_hSheetWindow == NULL);
		return m_pContHolder->AddPageToSheet(pPage);
	}

	CWinApp* pApp = AfxGetApp();
  ASSERT(pApp);
	if (m_pSheetCallback != NULL)
	{
		VERIFY(SUCCEEDED(MMCPropPageCallback((void*)(&pPage->m_psp97))));
	}

	HPROPSHEETPAGE hPage = ::CreatePropertySheetPage(&pPage->m_psp97);
	if (hPage == NULL)
		return E_UNEXPECTED;
	pPage->m_hPage = hPage;
	if (m_pSheetCallback != NULL)
		return m_pSheetCallback->AddPage(hPage);
	else if (m_pDummySheet != NULL)
	{
		m_pDummySheet->AddPage(pPage);
		return S_OK;
	}
	else
	{
		ASSERT(::IsWindow(m_hSheetWindow));
		return PropSheet_AddPage(m_hSheetWindow, hPage) ? S_OK : E_FAIL;
	}
}

HRESULT CPropertyPageHolderBase::AddPageToSheetRaw(HPROPSHEETPAGE hPage)
{
	ASSERT(m_pSheetCallback != NULL);
	if ((hPage == NULL) || (m_pSheetCallback == NULL))
		return E_INVALIDARG;

	if (m_pContHolder != NULL)
	{
		ASSERT(m_hSheetWindow == NULL);
		return m_pContHolder->AddPageToSheetRaw(hPage);
	}

	// assume this is not a n MFC property page
	return m_pSheetCallback->AddPage(hPage);
}




HRESULT CPropertyPageHolderBase::RemovePageFromSheet(CPropertyPageBase* pPage)
{
	if (m_pContHolder != NULL)
	{
		ASSERT(m_hSheetWindow == NULL);
		return m_pContHolder->RemovePageFromSheet(pPage);
	}

	ASSERT(pPage->m_hPage != NULL);
	if (m_pSheetCallback != NULL)
		return m_pSheetCallback->RemovePage(pPage->m_hPage);
	else
	{
		ASSERT(::IsWindow(m_hSheetWindow));
		PropSheet_RemovePage(m_hSheetWindow, 0, pPage->m_hPage); // returns void
		return S_OK;
	}
}

HRESULT CPropertyPageHolderBase::AddAllPagesToSheet()
{
	POSITION pos;
	int nPage = 0;
	HRESULT hr = OnAddPage(nPage, NULL); // zero means add before the first
	ASSERT(SUCCEEDED(hr));
	if (FAILED(hr))
		return hr;
		
	for( pos = m_pageList.GetHeadPosition(); pos != NULL; )
	{
		CPropertyPageBase* pPropPage = m_pageList.GetNext(pos);
		hr = AddPageToSheet(pPropPage);
		ASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
			return hr;
		nPage++;
		hr = OnAddPage(nPage, pPropPage); // get called on nPage == 1,2, n-1
		ASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
			return hr;
	}
	// add after the last
	return OnAddPage(-1, NULL); // -1 means
}


void CPropertyPageHolderBase::AddPageToList(CPropertyPageBase* pPage)
{
	ASSERT(pPage != NULL);
	pPage->SetHolder(this);
	m_pageList.AddTail(pPage);
}

BOOL CPropertyPageHolderBase::RemovePageFromList(CPropertyPageBase* pPage, BOOL bDeleteObject)
{
	ASSERT(pPage != NULL);
	POSITION pos = m_pageList.Find(pPage);
	if (pos == NULL)
		return FALSE;
	m_pageList.RemoveAt(pos);
	if (bDeleteObject)
		delete pPage;
	return TRUE;
}


void CPropertyPageHolderBase::DeleteAllPages()
{
	if (!m_bAutoDeletePages)
		return;
	// assume all pages out of the heap
	while (!m_pageList.IsEmpty())
	{
		delete m_pageList.RemoveTail();
	}
}

void CPropertyPageHolderBase::FinalDestruct()
{
	DeleteAllPages();
	if (IsWizardMode() || (m_pContHolder != NULL))
		return;

	if (m_hConsoleHandle != NULL)
  {
    MMCFreeNotifyHandle(m_hConsoleHandle);
  }

	// tell the component data object that the sheet is going away
	GetComponentData()->OnDeleteSheet(this,m_pNode);

	if (m_pSheetWnd != NULL)
	{
		delete m_pSheetWnd;
		m_pSheetWnd = NULL;
	}
	ASSERT(m_dlgInfoStack.IsEmpty());
}

BOOL CPropertyPageHolderBase::PushDialogHWnd(HWND hWndModalDlg)
{
	return m_dlgInfoStack.Push(hWndModalDlg, 0x0);
}

BOOL CPropertyPageHolderBase::PopDialogHWnd()
{
	return m_dlgInfoStack.Pop();
}


void CPropertyPageHolderBase::CloseModalDialogs(HWND hWndPage)
{
	m_dlgInfoStack.ForceClose(hWndPage);
}


/////////////////////////////////////////////////////////////////////////////
// CPropertyPageBase

BEGIN_MESSAGE_MAP(CPropertyPageBase, CPropertyPage)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_CONTEXTMENU()
  ON_MESSAGE(WM_HELP, OnHelp)
  ON_COMMAND(IDM_WHATS_THIS, OnWhatsThis)
END_MESSAGE_MAP()


CPropertyPageBase::CPropertyPageBase(UINT nIDTemplate, 
                                     UINT nIDCaption) :
						CPropertyPage(nIDTemplate, nIDCaption)
{
	m_hPage = NULL;
	m_pPageHolder = NULL;
	m_bIsDirty = FALSE;
	m_nPrevPageID = 0;

	// hack to have new struct size with old MFC and new NT 5.0 headers
	ZeroMemory(&m_psp97, sizeof(PROPSHEETPAGE));
	memcpy(&m_psp97, &m_psp, m_psp.dwSize);
	m_psp97.dwSize = sizeof(PROPSHEETPAGE);
}


CPropertyPageBase::~CPropertyPageBase()
{
}

int CPropertyPageBase::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	m_pPageHolder->AddRef();
	int res = CPropertyPage::OnCreate(lpCreateStruct);
	ASSERT(res == 0);
	ASSERT(m_hWnd != NULL);
	ASSERT(::IsWindow(m_hWnd));
	HWND hParent = ::GetParent(m_hWnd);
	ASSERT(hParent);
	m_pPageHolder->SetSheetWindow(hParent);
	return res;
}

void CPropertyPageBase::OnDestroy()
{
	ASSERT(m_hWnd != NULL);
    CPropertyPage::OnDestroy();
	m_pPageHolder->Release();
}

void CPropertyPageBase::OnWhatsThis()
{
  //
  // Display context help for a control
  //
  if ( m_hWndWhatsThis )
  {
    //
    // Build our own HELPINFO struct to pass to the underlying
    // CS help functions built into the framework
    //
    int iCtrlID = ::GetDlgCtrlID(m_hWndWhatsThis);
    HELPINFO helpInfo;
    ZeroMemory(&helpInfo, sizeof(HELPINFO));
    helpInfo.cbSize = sizeof(HELPINFO);
    helpInfo.hItemHandle = m_hWndWhatsThis;
    helpInfo.iCtrlId = iCtrlID;

	  m_pPageHolder->GetComponentData()->OnDialogContextHelp(m_nIDHelp, &helpInfo);
  }
}

BOOL CPropertyPageBase::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
  const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;

  if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
  {
    //
    // Display context help for a control
    //
	  m_pPageHolder->GetComponentData()->OnDialogContextHelp(m_nIDHelp, pHelpInfo);
  }

  return TRUE;
}

void CPropertyPageBase::OnContextMenu(CWnd* /*pWnd*/, CPoint point) 
{
  //
  // point is in screen coordinates
  //

  CMenu bar;
	if ( bar.LoadMenu(IDR_WHATS_THIS_CONTEXT_MENU1) )
	{
		CMenu& popup = *bar.GetSubMenu (0);
		ASSERT(popup.m_hMenu);

		if ( popup.TrackPopupMenu (TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
			   point.x,     // in screen coordinates
				 point.y,     // in screen coordinates
			   this) )      // route commands through main window
		{
			m_hWndWhatsThis = 0;
			ScreenToClient (&point);
			CWnd* pChild = ChildWindowFromPoint (point,  // in client coordinates
					                                 CWP_SKIPINVISIBLE | CWP_SKIPTRANSPARENT);
			if ( pChild )
      {
				m_hWndWhatsThis = pChild->m_hWnd;
      }
	  }
	}
}

void CPropertyPageBase::OnCancel()
{
	CString szTitle;
	GetWindowText(szTitle);
	TRACE(_T("CPropertyPageBase::OnCancel()called on <%s>\n"),(LPCTSTR)szTitle);
	CWinApp* pApp = AfxGetApp();
  ASSERT(pApp);
	ASSERT(::IsWindow(m_hWnd));
	m_pPageHolder->CloseModalDialogs(m_hWnd);
}

BOOL CPropertyPageBase::OnApply()
{
	if (IsDirty())
	{
		if (m_pPageHolder->NotifyConsole(this) == 0x0)
		{
			SetDirty(FALSE);
			return TRUE;
		}
		else
		{
#ifdef _DEBUG
			// test only
			AFX_MANAGE_STATE(AfxGetStaticModuleState());
			AfxMessageBox(_T("Apply Failed"));
#endif
			return FALSE;
		}
	}
	return TRUE;
}

void CPropertyPageBase::SetDirty(BOOL bDirty)
{
  if (!m_pPageHolder->IsWizardMode())
  {
	  SetModified(bDirty);
  }
	m_bIsDirty = bDirty;
}	


void CPropertyPageBase::InitWiz97(BOOL bHideHeader,
									   UINT nIDHeaderTitle,
									   UINT nIDHeaderSubTitle)
{
	if (bHideHeader)
	{
		// for first and last page of the wizard
		m_psp97.dwFlags |= PSP_HIDEHEADER;
	}
	else
	{
		// for intermediate pages
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
		m_szHeaderTitle.LoadString(nIDHeaderTitle);
		m_szHeaderSubTitle.LoadString(nIDHeaderSubTitle);

		m_psp97.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
		m_psp97.pszHeaderTitle = (LPCTSTR)m_szHeaderTitle;
		m_psp97.pszHeaderSubTitle = (LPCTSTR)m_szHeaderSubTitle;
	}
}



/////////////////////////////////////////////////////////////////////////////
// CPropertyPageHolderTable

#define PPAGE_HOLDER_ARRAY_DEF_SIZE (10)


CPropertyPageHolderTable::CPropertyPageHolderTable(CComponentDataObject* pComponentData)
{
	m_pComponentData = pComponentData;
	m_pEntries = (PPAGE_HOLDER_TABLE_ENTRY*)malloc(sizeof(PPAGE_HOLDER_TABLE_ENTRY) * PPAGE_HOLDER_ARRAY_DEF_SIZE);
  if (m_pEntries != NULL)
  {
	  memset(m_pEntries,0, sizeof(PPAGE_HOLDER_TABLE_ENTRY) * PPAGE_HOLDER_ARRAY_DEF_SIZE);
  }
	m_nSize = PPAGE_HOLDER_ARRAY_DEF_SIZE;

}
CPropertyPageHolderTable::~CPropertyPageHolderTable()
{
#ifdef _DEBUG
	for (int k=0; k < m_nSize; k++)
	{
		ASSERT(m_pEntries[k].pPPHolder == NULL);
		ASSERT(m_pEntries[k].pNode == NULL);
	}
#endif		
	free(m_pEntries);
}

void CPropertyPageHolderTable::Add(CPropertyPageHolderBase* pPPHolder)
{
	ASSERT(pPPHolder != NULL);
	ASSERT(pPPHolder->GetTreeNode() != NULL);
	for (int k=0; k < m_nSize; k++)
	{
		if (m_pEntries[k].pPPHolder == NULL) // get the first empty spot
		{
			m_pEntries[k].pPPHolder = pPPHolder;
			m_pEntries[k].pNode = pPPHolder->GetTreeNode();
			m_pEntries[k].hWnd = NULL;
			return;
		}
	}
	// all full, need to grow the array
	int nAlloc = m_nSize*2;
	m_pEntries = (PPAGE_HOLDER_TABLE_ENTRY*)realloc(m_pEntries, sizeof(PPAGE_HOLDER_TABLE_ENTRY)*nAlloc);
	memset(&m_pEntries[m_nSize], 0, sizeof(PPAGE_HOLDER_TABLE_ENTRY)*m_nSize);
	m_pEntries[m_nSize].pPPHolder = pPPHolder;
	m_pEntries[m_nSize].pNode = pPPHolder->GetTreeNode();
	m_pEntries[m_nSize].hWnd = NULL;
	m_nSize = nAlloc;
}


void CPropertyPageHolderTable::AddWindow(CPropertyPageHolderBase* pPPHolder, HWND hWnd)
{
	// By now, the PPHolder might have gone away, so use it as a cookie
	// but do not call any methods on it.
	// The node is still valid, because we do not delete nodes from secondary
	// threads
	ASSERT(pPPHolder != NULL);
	for (int k=0; k < m_nSize; k++)
	{
		if (m_pEntries[k].pPPHolder == pPPHolder)
		{
			ASSERT(m_pEntries[k].pNode != NULL);
			ASSERT(m_pEntries[k].pNode->GetSheetCount() > 0);
			m_pEntries[k].hWnd = hWnd;
			return; // assume no more that one holder entry
		}
	}
}



void CPropertyPageHolderTable::Remove(CPropertyPageHolderBase* pPPHolder)
{
	// By now, the PPHolder might have gone away, so use it as a cookie
	// but do not call any methods on it.
	// The node is still valid, because we do not delete nodes from secondary
	// threads
	ASSERT(pPPHolder != NULL);
	for (int k=0; k < m_nSize; k++)
	{
		if (m_pEntries[k].pPPHolder == pPPHolder)
		{
			ASSERT(m_pEntries[k].pNode != NULL);
			ASSERT(m_pEntries[k].pNode->GetSheetCount() > 0);
			m_pEntries[k].pPPHolder = NULL;
			m_pEntries[k].pNode = NULL;
			m_pEntries[k].hWnd = NULL;
			return; // assume no more that one holder entry
		}
	}
}


void CPropertyPageHolderTable::DeleteSheetsOfNode(CTreeNode* pNode)
{
	ASSERT(pNode != NULL);
	int nCount = BroadcastCloseMessageToSheets(pNode);
	WaitForSheetShutdown(nCount);
}


void CPropertyPageHolderTable::WaitForAllToShutDown()
{
	int nCount = 0;
	// allocate and array of HWND's for broadcast
	HWND* hWndArr = (HWND*)malloc(m_nSize*sizeof(m_nSize));
  if (hWndArr)
  {
	  memset(hWndArr, 0x0, m_nSize*sizeof(m_nSize));

	  for (int k=0; k < m_nSize; k++)
	  {
		  if (m_pEntries[k].pPPHolder != NULL)
		  {
			  m_pEntries[k].pPPHolder = NULL;
			  m_pEntries[k].pNode = NULL;
			  hWndArr[k] = ::GetParent(m_pEntries[k].hWnd);
			  m_pEntries[k].hWnd = NULL;
			  nCount++;
		  }
	  }

	  // wait for shutdown (wait for posted messages to come through
	  WaitForSheetShutdown(nCount, hWndArr);

    free(hWndArr);
  }
}

void CPropertyPageHolderTable::BroadcastSelectPage(CTreeNode* pNode, long nPageCode)
{
	for (int k=0; k < m_nSize; k++)
	{
		if ((m_pEntries[k].hWnd != NULL) && (m_pEntries[k].pNode == pNode))
		{
			::PostMessage(m_pEntries[k].hWnd, CSheetWnd::s_SelectPageMessage, (WPARAM)nPageCode, 0);
		}
	}
}

void CPropertyPageHolderTable::BroadcastMessageToSheets(CTreeNode* pNode, WPARAM wParam, LPARAM lParam)
{
	for (int k=0; k < m_nSize; k++)
	{
		if ((m_pEntries[k].hWnd != NULL) && (m_pEntries[k].pNode == pNode))
		{
			::PostMessage(m_pEntries[k].hWnd, CSheetWnd::s_SheetMessage, wParam, lParam);
		}
	}
}

int CPropertyPageHolderTable::BroadcastCloseMessageToSheets(CTreeNode* pNode)
{
	ASSERT(m_nSize > 0);
	int nCount = 0;
	// allocate and array of HWND's for broadcast
	HWND* hWndArr = (HWND*)malloc(m_nSize*sizeof(m_nSize));
  if (hWndArr)
  {
	  memset(hWndArr, 0x0, m_nSize*sizeof(m_nSize));

	  // find the HWND's that map to this node and its children
	  for (int k=0; k < m_nSize; k++)
	  {
		  if (m_pEntries[k].hWnd != NULL)
		  {
			  if (m_pEntries[k].pNode == pNode)
			  {
				  hWndArr[nCount++] = ::GetParent(m_pEntries[k].hWnd);
			  }
			  else if (pNode->IsContainer())
			  {
				  if (m_pEntries[k].pNode->HasContainer((CContainerNode*)pNode))
				  {
					  hWndArr[nCount++] = ::GetParent(m_pEntries[k].hWnd);
				  }
			  }
		  }
	  }
	  // shut down the sheets
	  for (int j=0; j < nCount; j++)
		  ::PostMessage(hWndArr[j], WM_COMMAND, IDCANCEL, 0);

    free(hWndArr);
  }
	return nCount;
}



void CPropertyPageHolderTable::WaitForSheetShutdown(int nCount, HWND* hWndArr)
{
	ASSERT(m_pComponentData != NULL);
	HWND hWnd = m_pComponentData->GetHiddenWindow();
	ASSERT(::IsWindow(hWnd));
	MSG tempMSG;
	DWORD dwTimeStart = ::GetTickCount();
	while(nCount > 0)
	{
		if ( hWndArr != NULL && (::GetTickCount() > dwTimeStart + 2000) )
		{
			// force sheets shut down
			for (int j=0; j < nCount; j++)
				::PostMessage(hWndArr[j], WM_COMMAND, IDCANCEL, 0);
			hWndArr = NULL;
		}

		if (::PeekMessage(&tempMSG,hWnd, CHiddenWnd::s_NodePropertySheetDeleteMessage,
										 CHiddenWnd::s_NodePropertySheetDeleteMessage,
										 PM_REMOVE))
		{
			TRACE(_T("-------------------->>>>enter while peek loop, nCount = %d\n"),nCount);
			DispatchMessage(&tempMSG);
			nCount--;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CHelpDialog

BEGIN_MESSAGE_MAP(CHelpDialog, CDialog)
	ON_WM_CONTEXTMENU()
  ON_MESSAGE(WM_HELP, OnHelp)
  ON_COMMAND(IDM_WHATS_THIS, OnWhatsThis)
END_MESSAGE_MAP()


CHelpDialog::CHelpDialog(UINT nIDTemplate, CComponentDataObject* pComponentData) :
						  m_hWndWhatsThis(0),
              m_pComponentData(pComponentData),
              CDialog(nIDTemplate)
{
}

CHelpDialog::CHelpDialog(UINT nIDTemplate, CWnd* pParentWnd, CComponentDataObject* pComponentData) :
						  m_hWndWhatsThis(0),
              m_pComponentData(pComponentData),
              CDialog(nIDTemplate, pParentWnd)
{
}

void CHelpDialog::OnWhatsThis()
{
  //
  // Display context help for a control
  //
  if ( m_hWndWhatsThis )
  {
    //
    // Build our own HELPINFO struct to pass to the underlying
    // CS help functions built into the framework
    //
    int iCtrlID = ::GetDlgCtrlID(m_hWndWhatsThis);
    HELPINFO helpInfo;
    ZeroMemory(&helpInfo, sizeof(HELPINFO));
    helpInfo.cbSize = sizeof(HELPINFO);
    helpInfo.hItemHandle = m_hWndWhatsThis;
    helpInfo.iCtrlId = iCtrlID;

	  m_pComponentData->OnDialogContextHelp(m_nIDHelp, &helpInfo);
  }
}

BOOL CHelpDialog::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
  const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;

  if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
  {
    //
    // Display context help for a control
    //
	  m_pComponentData->OnDialogContextHelp(m_nIDHelp, pHelpInfo);
  }

  return TRUE;
}

void CHelpDialog::OnContextMenu(CWnd* /*pWnd*/, CPoint point) 
{
  //
  // point is in screen coordinates
  //

  CMenu bar;
	if ( bar.LoadMenu(IDR_WHATS_THIS_CONTEXT_MENU1) )
	{
		CMenu& popup = *bar.GetSubMenu (0);
		ASSERT(popup.m_hMenu);

		if ( popup.TrackPopupMenu (TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
			   point.x,     // in screen coordinates
				 point.y,     // in screen coordinates
			   this) )      // route commands through main window
		{
			m_hWndWhatsThis = 0;
			ScreenToClient (&point);
			CWnd* pChild = ChildWindowFromPoint (point,  // in client coordinates
					                                 CWP_SKIPINVISIBLE | CWP_SKIPTRANSPARENT);
			if ( pChild )
      {
				m_hWndWhatsThis = pChild->m_hWnd;
      }
	  }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mtfrmwk\snapbase.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       snapbase.h
//
//--------------------------------------------------------------------------


#ifndef _SNAPBASE_H
#define _SNAPBASE_H

#include <mtfrmwk.h>
#include <dataobj.h>
#include <proppage.h>
#include <compbase.h>
#include <treedata.h>
#include <stdabout.h>

#endif // _SNAPBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mtfrmwk\stdabout.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       stdabout.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	StdAbout.h
//
//	HISTORY
//	31-Jul-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

#ifndef __STDABOUT_H_INCLUDED__
#define __STDABOUT_H_INCLUDED__


class CSnapinAbout :
	public ISnapinAbout,
	public CComObjectRoot
{
BEGIN_COM_MAP(CSnapinAbout)
	COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()
public:
	CSnapinAbout();

// ISnapinAbout
	STDMETHOD(GetSnapinDescription)(OUT LPOLESTR __RPC_FAR *lpDescription);
	STDMETHOD(GetProvider)(OUT LPOLESTR __RPC_FAR *lpName);
	STDMETHOD(GetSnapinVersion)(OUT LPOLESTR __RPC_FAR *lpVersion);
	STDMETHOD(GetSnapinImage)(OUT HICON __RPC_FAR *hAppIcon);
	STDMETHOD(GetStaticFolderImage)(
            OUT HBITMAP __RPC_FAR *hSmallImage,
            OUT HBITMAP __RPC_FAR *hSmallImageOpen,
            OUT HBITMAP __RPC_FAR *hLargeImage,
            OUT COLORREF __RPC_FAR *crMask);
protected:
	// The following data members MUST be initialized by the constructor
	// of the derived class.
	UINT m_uIdStrDestription;		// Resource Id of the description
	UINT m_uIdStrProvider;		// Resource Id of the provider (ie, Microsoft Corporation)
	UINT m_uIdStrVersion;			// Resource Id of the version of the snapin
	UINT m_uIdIconImage;			// Resource Id for the icon/image of the snapin
	UINT m_uIdBitmapSmallImage;
	UINT m_uIdBitmapSmallImageOpen;
	UINT m_uIdBitmapLargeImage;
   HBITMAP hBitmapSmallImage;
   HBITMAP hBitmapSmallImageOpen;
   HBITMAP hBitmapLargeImage;

	COLORREF m_crImageMask;

}; // CSnapinAbout()

#endif // ~__STDABOUT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mtfrmwk\dbg_.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dbg_.cpp
//
//--------------------------------------------------------------------------


/////////////////////////////////////////////////////////////////////
// debug helpers

#if defined(_USE_MTFRMWK_TRACE) || defined(_USE_MTFRMWK_ASSERT)

#ifndef _MTFRMWK_INI_FILE
#define _MTFRMWK_INI_FILE (L"\\system32\\mtfrmwk.ini")
#endif


UINT GetInfoFromIniFile(LPCWSTR lpszSection, LPCWSTR lpszKey, INT nDefault = 0)
{
  static LPCWSTR lpszFile = _MTFRMWK_INI_FILE;
  WCHAR szFilePath[2*MAX_PATH];
	UINT nLen = ::GetSystemWindowsDirectory(szFilePath, 2*MAX_PATH);
	if (nLen == 0)
		return nDefault;

  wcscat(szFilePath, lpszFile);
  return ::GetPrivateProfileInt(lpszSection, lpszKey, nDefault, szFilePath);
}
#endif // defined(_USE_MTFRMWK_TRACE) || defined(_USE_MTFRMWK_ASSERT)



#if defined(_USE_MTFRMWK_TRACE)

DWORD g_dwTrace = ::GetInfoFromIniFile(L"Debug", L"Trace");

void MtFrmwkTrace(LPCTSTR lpszFormat, ...)
{
  if (g_dwTrace == 0)
    return;

	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	WCHAR szBuffer[512];

	nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR), lpszFormat, args);

	// was there an error? was the expanded string too long?
	ASSERT(nBuf >= 0);
  ::OutputDebugString(szBuffer);

	va_end(args);
}

#endif

#if defined(DBG)

void MtFrmwkLogFile(LPCTSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	WCHAR szBuffer[512];

	nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR), lpszFormat, args);

  CLogFile* _dlog = CLogFile::GetInstance();            
  if (_dlog)                                            
  {                                                     
     _dlog->writeln(szBuffer);                               
  }                                                     

	va_end(args);
}

void MtFrmwkLogFileIfLog(BOOL bLog, LPCTSTR lpszFormat, ...)
{
  if (bLog)
  {
	  va_list args;
	  va_start(args, lpszFormat);

	  int nBuf;
	  WCHAR szBuffer[512];

	  nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR), lpszFormat, args);

    CLogFile* _dlog = CLogFile::GetInstance();            
    if (_dlog)                                            
    {                                                     
       _dlog->writeln(szBuffer);                               
    }                                                     

	  va_end(args);
  }
}

#endif

//
// Copied and modified from burnslib on 12-07-1999 by JeffJon
//  Needed file logging on DnsSetup call from DCPromo.
//  I wanted it to behave like the DCPromo log but including all of
//  burnslib required too many alterations in the debugging behavior
//  already in place.
//
extern CString LOGFILE_NAME = _T("");
static CLogFile* log_instance = 0;

//
// # of spaces per indentation level
//
static const int TAB = 2;
static int margin = 0;

//
// index to Thread Local Storage slot where the per-thread debug state is
// kept.  Initialized in Startup
//
static DWORD tls_index = 0;

CLogFile* CLogFile::GetInstance()
{
  if (!log_instance && !LOGFILE_NAME.IsEmpty())
  {
    log_instance = new CLogFile(LOGFILE_NAME);
  }
  return log_instance;
}

void CLogFile::KillInstance()
{
  delete log_instance;
  log_instance = 0;
}

BOOL PathExists(PCWSTR pszPath)
{
  DWORD attrs = GetFileAttributes(pszPath);
  if (attrs != 0xFFFFFFFF)
  {
    return TRUE;
  }
  return FALSE;
}

HANDLE OpenFile(PCWSTR pszPath)
{
  //
  // remove the last element of the path to form the parent directory
  //
  HANDLE handle = ::CreateFile(pszPath,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               0,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               0);
  return handle;
}

PCWSTR GetSystemRootDirectory()
{
  static CString SYSTEMROOT;

  WCHAR buf[MAX_PATH + 1];

  DWORD result = ::GetWindowsDirectory(buf, MAX_PATH + 1);

  ASSERT(result != 0 && result <= MAX_PATH);
  if (result == 0 || result > MAX_PATH)
  {
    return NULL;
  }
  
  SYSTEMROOT = buf;
  return (PCWSTR)SYSTEMROOT;
}

// locate the log file with the highest-numbered extension, then add 1 and
// return the result.

int DetermineNextLogNumber(PCWSTR logDir, PCWSTR logBaseName)
{
  ASSERT(logDir != NULL);
  ASSERT(logBaseName != NULL);

  int largest = 0;

  CString filespec = CString(logDir) + L"\\" + CString(logBaseName) + L".*.log";

  WIN32_FIND_DATA findData;
  HANDLE ff = ::FindFirstFile(filespec, &findData);

  if (ff != INVALID_HANDLE_VALUE)
  {
    for (;;)
    {
      CString current = findData.cFileName;

      // grab the text between the dots: "nnn" in foo.nnn.ext

      // first dot

      int pos = current.Find(L".");
      if (pos == -1)
      {
        continue;
      }

      CString extension = current.Right(current.GetLength() - pos - 1);

      // second dot

      pos = extension.Find(L".");
      if (pos == -1)
      {
        continue;
      }

      extension = extension.Left(pos);

      long i = 0;
      i = wcstol(extension, L'\0', 10);
      largest = max(i, largest);

      if (!::FindNextFile(ff, &findData))
      {
        ::FindClose(ff);
        break;
      }
    }
  }

  // roll over after 255 
  return (++largest & 0xFF);
}

// Determine the name of the log file.  If a log file of that name already
// exists, rename the existing file to a numbered backup.  Create the new
// log file, return a handle to it.
// 
HANDLE OpenNewLogFile(PCWSTR pszLogBaseName, CString& logName)
{
  CString logDir = CString(GetSystemRootDirectory()) + L"\\debug";
  int i = DetermineNextLogNumber(logDir, pszLogBaseName);

  CString szCount;
  szCount.Format(L"%d", i);
  logName = logDir + L"\\" + pszLogBaseName + L"." + szCount + L".log";

  HANDLE result = OpenFile(logName);
  return result;
}

   

// Create a new log.
//
// logBaseName - base name of the log.  If logging-to-file is active, then a
// file in the %windir%\debug folder will be created/used.  The name of the
// file is of the form %windir%\debug\logBaseName.log.  If a file by that name
// already exists, then the existing file will be renamed
// %windir%\debug\logBaseName.xxx.log, where xxx is an integer 1 greater than
// the last so-numbered file in that directory.

CLogFile::CLogFile(PCWSTR pszLogBaseName)
   :
   szBase_name(pszLogBaseName),
   file_handle(INVALID_HANDLE_VALUE),
   trace_line_number(0)
{
  ASSERT(pszLogBaseName != NULL);

  if (pszLogBaseName != NULL)
  {
    CString logName;
    file_handle = OpenNewLogFile(pszLogBaseName, logName);

    if (file_handle != INVALID_HANDLE_VALUE)
    {
      CString szOpeningFile;
      szOpeningFile.Format(L"opening log file %ws", logName);
      writeln(szOpeningFile);
    }
  }

  SYSTEMTIME localtime;
  ::GetLocalTime(&localtime);
  CString szTime;
  szTime.Format(L"%d/%d/%d %d:%d:%d.%d",
                 localtime.wMonth,
                 localtime.wDay,
                 localtime.wYear,
                 localtime.wHour,
                 localtime.wMinute,
                 localtime.wSecond,
                 localtime.wMilliseconds);

  writeln(szTime);
}



CLogFile::~CLogFile()
{
  if (IsOpen())
  {
    writeln(L"closing log file");
    ::CloseHandle(file_handle);
    file_handle = INVALID_HANDLE_VALUE;
  }
}

// guarded by caller

void CLogFile::indent()
{
  //
  // indent by adding to the margin
  //
  margin += TAB;
}

BOOL CLogFile::IsOpen() const
{
  return file_handle != INVALID_HANDLE_VALUE;
}



// guarded by caller

void CLogFile::outdent()
{
  //
  // outdent by subtracting from the margin
  //
  ASSERT(margin >= TAB);
  margin = max(0, margin - TAB);
}

void ConvertStringToANSI(PCWSTR pszWide, PSTR* ppAnsi)
{
  //
  // determine the size of the buffer required to hold the ANSI string
  //
  int bufsize = ::WideCharToMultiByte(CP_ACP, 0, pszWide, static_cast<int>(wcslen(pszWide)), 0, 0, 0, 0);
  if (bufsize > 0)
  {
    *ppAnsi = new CHAR[bufsize + 1];
    if (*ppAnsi == NULL)
    {
      return;
    }
    memset(*ppAnsi, 0, bufsize + 1);
    
    size_t result = ::WideCharToMultiByte(CP_ACP, 
                                          0, 
                                          pszWide, 
                                          static_cast<int>(wcslen(pszWide)),
                                          *ppAnsi, 
                                          bufsize + 1,
                                          0,
                                          0);
    ASSERT(result);

    if (!result)
    {
      *ppAnsi = NULL;
    }
  }
}

//
// Spews output to the log according to the current logging type and
// output options in effect.
//
// type - log output type of this output spewage.
//
// text - the spewage.  This is prefaced with the log name, thread id, spewage
// line number, and current indentation.
//
void CLogFile::writeln(PCWSTR pszText)
{
  CString white(L' ',margin);

  CString t;
  t.Format(L"%ws t:0x%x %3d %ws%ws\r\n",
            LOGFILE_NAME,
            ::GetCurrentThreadId(),
            trace_line_number,
            white,
            pszText);
  if (IsOpen())
  {
    ASSERT(file_handle != INVALID_HANDLE_VALUE);
    ASSERT(!t.IsEmpty());

    PSTR pAnsi;
    ConvertStringToANSI(t, &pAnsi);

    size_t bytesToWrite = sizeof(CHAR) * strlen(pAnsi);

    DWORD bytes_written = 0;
    BOOL  success =::WriteFile(file_handle,
                               pAnsi,
                               static_cast<ULONG>(bytesToWrite),
                               &bytes_written,
                               0);
    ASSERT(success);
    ASSERT(bytes_written == bytesToWrite);
    delete[] pAnsi;
  }
  trace_line_number++;
}

CScopeTracer::CScopeTracer(BOOL bLog, PCWSTR pszMessage_)
  :
  szMessage(pszMessage_),
  m_bLog(bLog)
{
  // build this string once, instead of using the string literal in the
  // below expression (which would implicitly build the string on each
  // evaluation of that expression) as a slight performance gain.
  static const CString ENTER(L"Enter ");

  if (m_bLog)
  {
    CLogFile* li = CLogFile::GetInstance();
    li->writeln(ENTER + szMessage);
    li->indent();
  }
}

CScopeTracer::~CScopeTracer()
{
  // build this string once, instead of using the string literal in the
  // below expression (which would implicitly build the string on each
  // evaluation of that expression) as a slight performance gain.
  static const CString EXIT(L"Exit  ");

  if (m_bLog)
  {
    CLogFile* li = CLogFile::GetInstance();
    li->outdent();
    li->writeln(EXIT + szMessage);
  }
}



#if defined(_USE_MTFRMWK_ASSERT)

DWORD g_dwAssert = ::GetInfoFromIniFile(L"Debug", L"Assert");

BOOL MtFrmwkAssertFailedLine(LPCSTR lpszFileName, int nLine)
{
  if (g_dwAssert == 0)
    return FALSE;

  WCHAR szMessage[_MAX_PATH*2];

	// assume the debugger or auxiliary port
	wsprintf(szMessage, _T("Assertion Failed: File %hs, Line %d\n"),
		lpszFileName, nLine);
	OutputDebugString(szMessage);

	// display the assert
	int nCode = ::MessageBox(NULL, szMessage, _T("Assertion Failed!"),
		MB_TASKMODAL|MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SETFOREGROUND);

  OutputDebugString(L"after message box\n");
	if (nCode == IDIGNORE)
  {
		return FALSE;   // ignore
  }

	if (nCode == IDRETRY)
  {
		return TRUE;    // will cause DebugBreak
  }

	abort();     // should not return 
	return TRUE;

}
#endif // _USE_MTFRMWK_ASSERT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mtfrmwk\stdabou_.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       stdabou_.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	StdAbout.cpp
//
//	Implementation of the ISnapinAbout interface
//
//	HISTORY
//	31-Jul-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

//#include "stdutils.h" // HrLoadOleString()

HRESULT
HrLoadOleString(
	UINT uStringId,					// IN: String Id to load from the resource
	OUT LPOLESTR * ppaszOleString)	// OUT: Pointer to pointer to allocated OLE string
	{
	if (ppaszOleString == NULL)
		{
		TRACE0("HrLoadOleString() - ppaszOleString is NULL.\n");
		return E_POINTER;
		}
	CString strT;		// Temporary string
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Needed for LoadString()
	VERIFY( strT.LoadString(uStringId) );
    *ppaszOleString = reinterpret_cast<LPOLESTR>
            (CoTaskMemAlloc((strT.GetLength() + 1)* sizeof(wchar_t)));
	if (*ppaszOleString == NULL)
		return E_OUTOFMEMORY;
	USES_CONVERSION;
    wcscpy(OUT *ppaszOleString, T2OLE((LPTSTR)(LPCTSTR)strT));
	return S_OK;
	} // HrLoadOleString()













CSnapinAbout::CSnapinAbout() :
   hBitmapSmallImage(0),
   hBitmapSmallImageOpen(0),
   hBitmapLargeImage(0)
{
}

CSnapinAbout::~CSnapinAbout()
{
   if (hBitmapSmallImage)
   {
      DeleteObject(hBitmapSmallImage);
      hBitmapSmallImage = 0;
   }

   if (hBitmapSmallImageOpen)
   {
      DeleteObject(hBitmapSmallImageOpen);
      hBitmapSmallImageOpen = 0;
   }

   if (hBitmapLargeImage)
   {
      DeleteObject(hBitmapLargeImage);
      hBitmapLargeImage = 0;
   }
}

STDMETHODIMP CSnapinAbout::GetSnapinDescription(OUT LPOLESTR __RPC_FAR *lpDescription)
	{
	return HrLoadOleString(m_uIdStrDestription, OUT lpDescription);
	}

STDMETHODIMP CSnapinAbout::GetProvider(OUT LPOLESTR __RPC_FAR *lpName)
	{
	return HrLoadOleString(m_uIdStrProvider, OUT lpName);
	}

STDMETHODIMP CSnapinAbout::GetSnapinVersion(OUT LPOLESTR __RPC_FAR *lpVersion)
	{
	return HrLoadOleString(m_uIdStrVersion, OUT lpVersion);
	}

STDMETHODIMP CSnapinAbout::GetSnapinImage(OUT HICON __RPC_FAR *hAppIcon)
	{
	if (hAppIcon == NULL)
		return E_POINTER;
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetInstanceHandle()
    *hAppIcon = ::LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(m_uIdIconImage));
    if (*hAppIcon == NULL)
		{
		ASSERT(FALSE && "Unable to load icon");
		return E_FAIL;
		}
	return S_OK;
	}

STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
            OUT HBITMAP __RPC_FAR *hSmallImage,
            OUT HBITMAP __RPC_FAR *hSmallImageOpen,
            OUT HBITMAP __RPC_FAR *hLargeImage,
            OUT COLORREF __RPC_FAR *crMask)
{	
	ASSERT(hSmallImage != NULL);
	ASSERT(hSmallImageOpen != NULL);
	ASSERT(hLargeImage != NULL);
	ASSERT(crMask != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetInstanceHandle()
	HINSTANCE hInstance = AfxGetInstanceHandle();

   if (!hBitmapSmallImage)
   {
      hBitmapSmallImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapSmallImage));
   }
   ASSERT(hBitmapSmallImage);
   *hSmallImage = hBitmapSmallImage;

   if (!hBitmapSmallImageOpen)
   {
      hBitmapSmallImageOpen = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapSmallImageOpen));
   }
   ASSERT(hBitmapSmallImageOpen);
	*hSmallImageOpen = hBitmapSmallImageOpen;

   if (!hBitmapLargeImage)
   {
      hBitmapLargeImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapLargeImage));
   }
   ASSERT(hBitmapLargeImage);
	*hLargeImage = hBitmapLargeImage;

	*crMask = m_crImageMask;
	#ifdef _DEBUG
	if (NULL == *hSmallImage || NULL == *hSmallImageOpen || NULL == *hLargeImage)
	{
		TRACE0("WRN: CSnapinAbout::GetStaticFolderImage() - Unable to load all the bitmaps.\n");
		return E_FAIL;
	}
	#endif
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mtfrmwk\treedata.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef _TREEDATA_H
#define _TREEDATA_H

/////////////////////////////////////////////////////////////////////////////
// Miscellanea 
extern LPCWSTR g_lpszNullString;


/////////////////////////////////////////////////////////////////////////////
// Generic Helper functions

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL) 
    { 
        pObj->Release(); 
        pObj = NULL; 
    } 
    else 
    { 
        TRACE(_T("Release called on NULL interface ptr")); 
    }
}

///////////////////////////////////////////////////////////////////
// Context Menu data structures and macros

#define MAX_CONTEXT_MENU_STRLEN 128

struct MENUDATARES
{
	WCHAR szBuffer[MAX_CONTEXT_MENU_STRLEN*2];
	UINT uResID;
};

struct MENUMAP
{
	MENUDATARES* dataRes;
	CONTEXTMENUITEM2* ctxMenu;
};

#define DECLARE_MENU(theClass) \
class theClass \
{ \
public: \
	static LPCONTEXTMENUITEM2 GetContextMenuItem() { return GetMenuMap()->ctxMenu; }; \
	static MENUMAP* GetMenuMap(); \
}; 

#define BEGIN_MENU(theClass) \
	 MENUMAP* theClass::GetMenuMap() { 

#define BEGIN_CTX static CONTEXTMENUITEM2 ctx[] = {

#define CTX_ENTRY_TOP(cmdID, languageIndependantStringID) { L"",L"", cmdID, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, 0, languageIndependantStringID},
#define CTX_ENTRY_NEW(cmdID, languageIndependantStringID) { L"",L"", cmdID, CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, 0, languageIndependantStringID},
#define CTX_ENTRY_TASK(cmdID, languageIndependantStringID) { L"",L"", cmdID, CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, 0, languageIndependantStringID},
#define CTX_ENTRY_VIEW(cmdID, languageIndependantStringID) { L"",L"", cmdID, CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0, languageIndependantStringID},

#define END_CTX { NULL, NULL, 0, 0, 0, 0} };

#define BEGIN_RES  static MENUDATARES dataRes[] = {

#define RES_ENTRY(resID) {L"", resID },

#define END_RES   { NULL, 0 }	};


#define END_MENU \
		static MENUMAP menuMap = { dataRes, ctx }; \
		return &menuMap; } 


BOOL LoadContextMenuResources(MENUMAP* pMenuMap);

//
// Toolbar macros
//
#define DECLARE_TOOLBAR_MAP() \
public: \
  virtual HRESULT ToolbarNotify(int event, \
                                CComponentDataObject* pComponentData, \
                                CNodeList* pNodeList);

#define BEGIN_TOOLBAR_MAP(theClass) \
HRESULT theClass::ToolbarNotify(int event, \
                                CComponentDataObject* pComponentData, \
                                CNodeList* pNodeList) \
{ \
  HRESULT hr = S_OK; \
  event; \
  pComponentData; \
  pNodeList;


#define TOOLBAR_EVENT(toolbar_event, function) \
  if (event == toolbar_event) \
  { \
    hr = function(pComponentData, pNodeList); \
  }

#define END_TOOLBAR_MAP() \
  return hr; \
}

#define DECLARE_TOOLBAR_EVENT(toolbar_event, value) \
  static const int toolbar_event = value;

  
////////////////////////////////////////////////////////////
// header control resources data structures
#define MAX_RESULT_HEADER_STRLEN 128

struct RESULT_HEADERMAP
{
	WCHAR szBuffer[MAX_RESULT_HEADER_STRLEN];
	UINT uResID;
	int nFormat;
	int nWidth;
};

BOOL LoadResultHeaderResources(RESULT_HEADERMAP* pHeaderMap, int nCols);

////////////////////////////////////////////////////////////
// bitmap strips resources data structures
template <UINT nResID> class CBitmapHolder : public CBitmap
{
public:
	BOOL LoadBitmap() { return CBitmap::LoadBitmap(nResID);}
};

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CComponentDataObject;  
class CContainerNode;
class CMTContainerNode;
class CLeafNode;
class CPropertyPageHolderBase;
class CBackgroundThread;
class CQueryObj;

/////////////////////////////////////////////////////////////////////
// CObjBase
// base class for all objects relying on RTTI and class type info
class CObjBase
{
public:
	CObjBase() {}
	virtual ~CObjBase() {}
};

/////////////////////////////////////////////////////////////////////
// CTreeNode
// cannot construct objects of this class, have to derive from it

#define DECLARE_NODE_GUID() \
	static const GUID NodeTypeGUID; \
	virtual const GUID* GetNodeType() { return &NodeTypeGUID;}



// use the HIWORD for generic flags and leave the LOWORD for application specific data
#define TN_FLAG_HIDDEN				(0x00010000) // does not appear in the UI
#define TN_FLAG_NO_WRITE			(0x00020000) // cannot edit or create
#define TN_FLAG_NO_DELETE			(0x00040000) // cannot delete
#define TN_FLAG_HAS_SHEET			(0x00080000) // this node or a child has a property sheet up

#define TN_FLAG_CONTAINER			(0x00100000) // container (i.e. not leaf)
#define TN_FLAG_CONTAINER_ENUM		(0x00200000) // container node has been enumerated (back end)
#define TN_FLAG_CONTAINER_EXP		(0x00400000) // container node has been expanded (UI node)

class CTreeNode : public CObjBase
{
public:
	virtual ~CTreeNode() {}
	CContainerNode* GetContainer() { return m_pContainer; }
	void SetContainer(CContainerNode* pContainer) { m_pContainer = pContainer; }
	BOOL HasContainer(CContainerNode* pContainerNode);
	virtual LPCWSTR GetDisplayName() { return m_szDisplayName; }
	virtual void SetDisplayName(LPCWSTR lpszDisplayName) { m_szDisplayName = lpszDisplayName;}

  //
	// Data Object related data
  //
	virtual const GUID* GetNodeType() { return NULL;}
	virtual HRESULT GetDataHere(CLIPFORMAT, 
                              LPSTGMEDIUM, 
			                        CDataObject*) { return DV_E_CLIPFORMAT;}
	virtual HRESULT GetData(CLIPFORMAT, 
                              LPSTGMEDIUM, 
			                        CDataObject*) { return DV_E_CLIPFORMAT;}

  virtual HRESULT GetResultViewType(CComponentDataObject* pComponentData,
                                    LPOLESTR* ppViewType, 
                                    long* pViewOptions);
  virtual HRESULT OnShow(LPCONSOLE) { return S_OK; }

  //
	// flag manipulation API's
  //
	BOOL IsContainer() { return (m_dwNodeFlags & TN_FLAG_CONTAINER) ? TRUE : FALSE;}
	BOOL IsVisible() { return (m_dwNodeFlags & TN_FLAG_HIDDEN) ? FALSE : TRUE;}
	BOOL CanDelete() { return (m_dwNodeFlags & TN_FLAG_NO_DELETE) ? FALSE : TRUE;}
	virtual void SetFlagsDown(DWORD dwNodeFlags, BOOL bSet);
	void SetFlagsUp(DWORD dwNodeFlags, BOOL bSet);
	DWORD GetFlags() { return m_dwNodeFlags;}
  virtual BOOL CanExpandSync() { return FALSE; }

	virtual void Show(BOOL bShow, CComponentDataObject* pComponentData);
	
	

  //
  // Verb handlers
  //
  virtual HRESULT OnRename(CComponentDataObject*,
                           LPWSTR) { return S_FALSE; }
	virtual void OnDelete(CComponentDataObject* pComponentData, 
                        CNodeList* pNodeList) = 0;
	virtual BOOL OnRefresh(CComponentDataObject*,
                         CNodeList*)	{ return FALSE; }
	virtual HRESULT OnCommand(long, 
                            DATA_OBJECT_TYPES, 
                            CComponentDataObject*,
                            CNodeList*) { return S_OK; };

	virtual HRESULT OnAddMenuItems(IContextMenuCallback2* pContextMenuCallback2, 
									               DATA_OBJECT_TYPES type,
									               long *pInsertionAllowed,
                                 CNodeList* pNodeList);
  virtual HRESULT OnAddMenuItemsMultipleSelect(IContextMenuCallback2*, 
									                             DATA_OBJECT_TYPES,
									                             long*,
                                               CNodeList*) { return S_OK; }

	virtual MMC_CONSOLE_VERB GetDefaultVerb(DATA_OBJECT_TYPES type, 
                                          CNodeList* pNodeList);
	virtual void OnSetVerbState(LPCONSOLEVERB pConsoleVerb, 
                              DATA_OBJECT_TYPES type,
                              CNodeList* pNodeList);
  virtual HRESULT OnSetToolbarVerbState(IToolbar* pToolbar, 
                                        CNodeList* pNodeList);

	virtual BOOL OnSetRenameVerbState(DATA_OBJECT_TYPES type, 
                                    BOOL* pbHide, 
                                    CNodeList* pNodeList);
	virtual BOOL OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                                    BOOL* pbHide, 
                                    CNodeList* pNodeList);
	virtual BOOL OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                     BOOL* pbHide, 
                                     CNodeList* pNodeList);
	virtual BOOL OnSetCutVerbState(DATA_OBJECT_TYPES type, 
                                 BOOL* pbHide, 
                                 CNodeList* pNodeList);
	virtual BOOL OnSetCopyVerbState(DATA_OBJECT_TYPES type, 
                                  BOOL* pbHide, 
                                  CNodeList* pNodeList);
	virtual BOOL OnSetPasteVerbState(DATA_OBJECT_TYPES type, 
                                   BOOL* pbHide, 
                                   CNodeList* pNodeList);
	virtual BOOL OnSetPrintVerbState(DATA_OBJECT_TYPES type, 
                                   BOOL* pbHide, 
                                   CNodeList* pNodeList);

  //
  // Property Page methods
  //
  virtual BOOL DelegatesPPToContainer() { return FALSE; }
  virtual void ShowPageForNode(CComponentDataObject* pComponentDataObject); 
	virtual BOOL HasPropertyPages(DATA_OBJECT_TYPES type, 
                                BOOL* pbHideVerb, 
                                CNodeList* pNodeList); 
	virtual HRESULT CreatePropertyPages(LPPROPERTYSHEETCALLBACK,
                                      LONG_PTR,
                                      CNodeList*) { return E_FAIL; }
	virtual void OnPropertyChange(CComponentDataObject* pComponentData, 
									 BOOL bScopePane,long changeMask);
  virtual BOOL CanCloseSheets() { return TRUE;}
	void OnCreateSheet();
	void OnDeleteSheet();
	BOOL HasSheet() { return (m_dwNodeFlags & TN_FLAG_HAS_SHEET) ? TRUE : FALSE;}
	BOOL GetSheetCount() { return m_nSheetCount;}
	virtual void IncrementSheetLockCount();
	virtual void DecrementSheetLockCount();
	BOOL IsSheetLocked() { return m_nSheetLockCount > 0;}

  //
  // Misc.
  //
  virtual LPWSTR  GetDescriptionBarText() { return L""; }
	virtual LPCWSTR GetString(int nCol) = 0;
	virtual int     GetImageIndex(BOOL bOpenImage) = 0;
	virtual void    Trace() { TRACE(_T("Name %s "), (LPCTSTR)m_szDisplayName);}

	void DeleteHelper(CComponentDataObject* pComponentData);

protected:
	CString m_szDisplayName;		// name of the item
	CContainerNode* m_pContainer;	// back pointer to the container the node is in
	DWORD m_dwNodeFlags;
	LONG m_nSheetLockCount;			// keeps track if a node has been locked by a property sheet
	LONG m_nSheetCount;				// keeps track of the # of sheets the node has up

	CTreeNode() 
	{ 
		m_pContainer = NULL; 
		m_nSheetLockCount = 0; 
		m_dwNodeFlags = 0x0; //m_dwNodeFlags |= TN_FLAG_HIDDEN; 
		m_nSheetCount = 0; 
	}
	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable() { return NULL;}
	virtual BOOL OnAddMenuItem(LPCONTEXTMENUITEM2,
								             long*) { return TRUE;}

	friend class CContainerNode; // to get access to the m_pContainer member

  //
  // Provides a default implementation for toolbar support
  //
  DECLARE_TOOLBAR_MAP()
};

///////////////////////////////////////////////////////////////////////
// CNodeList 
// collection of nodes
typedef CList<CTreeNode*,CTreeNode*> CNodeListBase;

class CNodeList : public CNodeListBase
{
public:
	BOOL RemoveNode(CTreeNode* p)
	{
		POSITION pos = Find(p);
		if (pos == NULL)
			return FALSE;
		RemoveAt(pos);
		return TRUE;
	}
	void RemoveAllNodes() 
	{	
		while (!IsEmpty()) 
			delete RemoveTail();	
	}
	BOOL HasNode(CTreeNode* p)
	{
		return NULL != Find(p);
	}
};


////////////////////////////////////////////////////////////////////////
// CContainerNode
// node that can be a container of other nodes

class CContainerNode : public CTreeNode
{
public:
	CContainerNode() 
	{ 
		m_ID = 0; 
		m_dwNodeFlags |= TN_FLAG_CONTAINER; 
		m_nState = -1; 
		m_dwErr = 0x0;
		m_nThreadLockCount = 0;
	}
	virtual ~CContainerNode()  { ASSERT(m_nSheetLockCount == 0); RemoveAllChildrenFromList(); }
	CContainerNode* GetRootContainer()
		{ return (m_pContainer != NULL) ? m_pContainer->GetRootContainer() : this; }

  //
  // Thread Helpers
  //
	void IncrementThreadLockCount();
	void DecrementThreadLockCount();
	BOOL IsThreadLocked() { return m_nThreadLockCount > 0;}

	virtual BOOL OnEnumerate(CComponentDataObject*, BOOL bAsync = TRUE)
	{ bAsync; return TRUE;} // TRUE = add children in the list to UI

  //
  // Node state helpers
  //
	BOOL HasChildren() { return !m_containerChildList.IsEmpty() || !m_leafChildList.IsEmpty(); }
	void ForceEnumeration(CComponentDataObject* pComponentData);
  void MarkEnumerated(BOOL bEnum = TRUE);
	BOOL IsEnumerated() { ASSERT(IsContainer()); return (m_dwNodeFlags & TN_FLAG_CONTAINER_ENUM) ? TRUE : FALSE;}
	void MarkExpanded() {	ASSERT(IsContainer()); m_dwNodeFlags |= TN_FLAG_CONTAINER_EXP; }
	BOOL IsExpanded() { ASSERT(IsContainer()); return (m_dwNodeFlags & TN_FLAG_CONTAINER_EXP) ? TRUE : FALSE;}
	void MarkEnumeratedAndLoaded(CComponentDataObject* pComponentData);

	void SetScopeID(HSCOPEITEM ID) { m_ID = ID;}
	HSCOPEITEM GetScopeID() { return m_ID;}
	BOOL AddedToScopePane() { return GetScopeID() != 0;}

	virtual CColumnSet* GetColumnSet() = 0;
	virtual LPCWSTR GetColumnID() = 0;

	virtual void SetFlagsDown(DWORD dwNodeFlags, BOOL bSet);
	void SetFlagsOnNonContainers(DWORD dwNodeFlags,BOOL bSet);

  //
	// child list mainpulation API's
  //
	CNodeList* GetContainerChildList() { return &m_containerChildList; }
  CNodeList* GetLeafChildList() { return &m_leafChildList; }
	BOOL AddChildToList(CTreeNode* p);
  BOOL AddChildToListSorted(CTreeNode* p, CComponentDataObject* pComponentData); 
  BOOL RemoveChildFromList(CTreeNode* p);
	void RemoveAllChildrenFromList();
  void RemoveAllContainersFromList() { m_containerChildList.RemoveAllNodes(); }
  void RemoveAllLeavesFromList() { m_leafChildList.RemoveAllNodes(); }

  //
	// given a node, it searches for it recursively and if successful it returns the 
	// container the node is in
  //
	BOOL FindChild(CTreeNode* pNode, CTreeNode** ppContainer);
	
	BOOL AddChildToListAndUI(CTreeNode* pChildToAdd, CComponentDataObject* pComponentData);
  BOOL AddChildToListAndUISorted(CTreeNode* pChildToAdd, CComponentDataObject* pComponentData);

	virtual int Compare(CTreeNode* pNodeA, CTreeNode* pNodeB, int nCol, LPARAM lUserParam);

	virtual HRESULT CreatePropertyPagesHelper(LPPROPERTYSHEETCALLBACK, 
		                                        LONG_PTR, 
                                            long) { return E_FAIL;}
	virtual BOOL OnRefresh(CComponentDataObject* pComponentData,
                         CNodeList* pNodeList);
	virtual void OnColumnsChanged(int*, int) {}
	void RemoveAllChildrenHelper(CComponentDataObject* pComponentData);

protected:
	virtual void OnChangeState(CComponentDataObject*) {}
	void AddCurrentChildrenToUI(CComponentDataObject* pComponentData);

	LONG m_nThreadLockCount;
	CNodeList m_leafChildList; // leaf contents of the node
  CNodeList m_containerChildList; // container contents of the node
	HSCOPEITEM m_ID;	// ID when the item is inserted in the master tree
	int m_nState;	// for general purpose finite state machine implementation
	DWORD m_dwErr;	// for general purpose error handling
};

////////////////////////////////////////////////////////////////////////
// CLeafNode
// node that is not a container of other nodes

class CLeafNode : public CTreeNode
{
public:

};


///////////////////////////////////////////////////////////////////
// data nodes

// the root, with folders in it
class CRootData : public CContainerNode
{
public:
	CRootData(CComponentDataObject* pComponentData) 
	{ 
		ASSERT(pComponentData != NULL);
		m_pComponentData = pComponentData; 
		m_bDirty = FALSE; 
	}
	virtual LPCWSTR GetString(int nCol) 
	{
		if (nCol == 0)
			return GetDisplayName();
		return g_lpszNullString; 
	}
	CComponentDataObject* GetComponentDataObject(){ return m_pComponentData;}

	CTreeNode* GetNodeFromCookie(MMC_COOKIE cookie)
	{
		// cookie == 0 means root to enumerate
		if (cookie == NULL)
		{
			return (CTreeNode*)this;
		}
		else
		{
			CTreeNode* pNode = (CTreeNode*)cookie;
			CTreeNode* pContainer;
			if (FindChild(pNode,&pContainer))
			{
				return pNode;
			}
		}
		return NULL;
	}
	// IStream manipulation helpers
	virtual HRESULT IsDirty() { return m_bDirty ? S_OK : S_FALSE; }
	virtual HRESULT Load(IStream*) { return S_OK; }
	virtual HRESULT Save(IStream*, BOOL) { return S_OK; }

	void SetDirtyFlag(BOOL bDirty) { m_bDirty = bDirty ;}

private:
	CComponentDataObject* m_pComponentData;
	BOOL m_bDirty;
	CString m_szSnapinType;		// constant part of the name loaded from resources
};


//////////////////////////////////////////////////////////////////////
// CBackgroundThread


class CBackgroundThread : public CWinThread
{
public:
	CBackgroundThread();
	virtual ~CBackgroundThread();
	
	void SetQueryObj(CQueryObj* pQueryObj);
	BOOL Start(CMTContainerNode* pNode, CComponentDataObject* pComponentData);
	virtual BOOL InitInstance() { return TRUE; }	// MFC override
	virtual int Run();								// MFC override

	void Lock() { ::EnterCriticalSection(&m_cs); }
	void Unlock() { ::LeaveCriticalSection(&m_cs); }

	void Abandon();
	BOOL IsAbandoned();

	BOOL OnAddToQueue(INT_PTR nCount);
	CObjBase* RemoveFromQueue();
	BOOL IsQueueEmpty();
	BOOL PostHaveData();
	BOOL PostError(DWORD dwErr);
	BOOL PostExiting();
	void AcknowledgeExiting() { VERIFY(0 != ::SetEvent(m_hEventHandle));}

private:
	// communication with ComponentData object 
	BOOL PostMessageToComponentDataRaw(UINT Msg, WPARAM wParam, LPARAM lParam);
	void WaitForExitAcknowledge();

	CRITICAL_SECTION		m_cs;					// critical section to sync access to data
	HANDLE					m_hEventHandle;			// syncronization handle for shutdown notification

	CMTContainerNode*		m_pContNode;			// back pointer to node the thread is executing for
	CQueryObj*				m_pQueryObj;			// query object the thread is executing

	INT_PTR				m_nQueueCountMax;		// max size of the queue

	HWND					m_hHiddenWnd;			// handle to window to post messages
	BOOL					m_bAbandoned;
};



//////////////////////////////////////////////////////////////////////
// CQueryObj 

typedef CList<CObjBase*,CObjBase*> CObjBaseList;

class CQueryObj
{
public:
	CQueryObj() { m_dwErr = 0; m_pThread = NULL;}
	virtual ~CQueryObj()
	{
		while (!m_objQueue.IsEmpty()) 
			delete m_objQueue.RemoveTail();
	};

	void SetThread(CBackgroundThread* pThread)
	{
		ASSERT(pThread != NULL);
		m_pThread = pThread;
	}
	CBackgroundThread* GetThread() {return m_pThread;}
	virtual BOOL Enumerate() { return FALSE;}
	virtual BOOL AddQueryResult(CObjBase* pObj)
	{
		BOOL bRes = FALSE;
		if (m_pThread != NULL)
		{
      BOOL bPostedHaveDataMessage = FALSE;
			m_pThread->Lock();
			bRes = NULL != m_objQueue.AddTail(pObj);
			bPostedHaveDataMessage = m_pThread->OnAddToQueue(m_objQueue.GetCount());
			m_pThread->Unlock();

      // wait for the queue length to go down to zero
      if (bPostedHaveDataMessage)
      {
        INT_PTR nQueueCount = 0;
        do 
        {
          m_pThread->Lock();
          nQueueCount = m_objQueue.GetCount();
          m_pThread->Unlock();
          if (m_pThread->IsAbandoned())
          {
            break;
          }
          if (nQueueCount > 0)
          {
            ::Sleep(100);
          }
        }
        while (nQueueCount > 0);
      } // if
		}
		else
		{
			bRes = NULL != m_objQueue.AddTail(pObj);
		}
		ASSERT(bRes);
		return bRes;
	}
	virtual void OnError(DWORD dwErr)
	{
		if (m_pThread != NULL)
		{
			m_pThread->Lock();
			m_dwErr = dwErr;
			m_pThread->Unlock();
			m_pThread->PostError(dwErr);
		}
		else
		{
			m_dwErr = dwErr;
		}
	}

	CObjBaseList* GetQueue() { return &m_objQueue;}
	DWORD GetError() 
	{
		if (m_pThread != NULL)
		{
			m_pThread->Lock();
			DWORD dwErr = m_dwErr;
			m_pThread->Unlock();
			return dwErr;
		}
		else
		{
			return m_dwErr;
		}
	}
private:
	CBackgroundThread*	m_pThread;	// back pointer, if in the context of a thread
	CObjBaseList		m_objQueue;	// queue for results
	DWORD				m_dwErr;	// error code, if any
};

////////////////////////////////////////////////////////////////////////
// CMTContainerNode
// container that can do operations from a secondary thread

class CMTContainerNode : public CContainerNode
{
public:
	CMTContainerNode() 
	{ 
		m_pThread = NULL;
	}
	virtual ~CMTContainerNode();

	virtual BOOL OnEnumerate(CComponentDataObject* pComponentData, BOOL bAsync = TRUE);
	virtual BOOL OnRefresh(CComponentDataObject* pComponentData,
                         CNodeList* pNodeList);

protected:
		
	// thread creation
	virtual CBackgroundThread* CreateThreadObject() 
	{ 
		return new CBackgroundThread; // override if need derived tipe of object
	} 

	// query creation
	virtual CQueryObj* OnCreateQuery()  // override to create a user defined query object
	{	
		return new CQueryObj(); // return a do-nothing query
	}

	// main message handler for thread messages
	virtual void OnThreadHaveDataNotification(CComponentDataObject* pComponentDataObject);
	virtual void OnThreadErrorNotification(DWORD dwErr, CComponentDataObject* pComponentDataObject);
	virtual void OnThreadExitingNotification(CComponentDataObject* pComponentDataObject);


	virtual void OnHaveData(CObjBase*, CComponentDataObject*) {}
	virtual void OnError(DWORD dwErr) { m_dwErr = dwErr; }

	BOOL StartBackgroundThread(CComponentDataObject* pComponentData, BOOL bAsync = TRUE);
	CBackgroundThread* GetThread() { ASSERT(m_pThread != NULL); return m_pThread;}

	void AbandonThread(CComponentDataObject* pComponentData);

private:
	CBackgroundThread* m_pThread;	// pointer to thread object executing the code

	friend class CHiddenWnd;			// to get OnThreadNotification()
	friend class CRunningThreadTable;	// to get AbandonThread()
};


#endif // _TREEDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\about.h ===
//	About.h

#ifndef __ABOUT_H_INCLUDED__
#define __ABOUT_H_INCLUDED__

#include "stdabout.h"

//	About for "Computer Management" snapin
class CComputerMgmtAbout :
	public CSnapinAbout,
	public CComCoClass<CComputerMgmtAbout, &CLSID_ComputerManagementAbout>

{
public:
DECLARE_REGISTRY(CComputerMgmtAbout, _T("MYCOMPUT.ComputerMgmtAboutObject.1"), _T("MYCOMPUT.ComputerMgmtAboutObject.1"), IDS_MYCOMPUT_DESC, THREADFLAGS_BOTH)
	CComputerMgmtAbout();
};


#endif // ~__ABOUT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mtfrmwk\treedat_.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       treedat_.cpp
//
//--------------------------------------------------------------------------



/////////////////////////////////////////////////////////////////////////////
// Miscellanea 
LPCWSTR g_lpszNullString = L"\0";


///////////////////////////////////////////////////////////////////////
// Global Helper functions

BOOL LoadContextMenuResources(MENUMAP* pMenuMap)
{
	HINSTANCE hInstance = _Module.GetModuleInstance();
	for (int i = 0; pMenuMap->ctxMenu[i].strName; i++)
	{
		if (0 == ::LoadString(hInstance, pMenuMap->dataRes[i].uResID, pMenuMap->dataRes[i].szBuffer, MAX_CONTEXT_MENU_STRLEN*2))
			return FALSE;
		pMenuMap->ctxMenu[i].strName = pMenuMap->dataRes[i].szBuffer;
		for (WCHAR* pCh = pMenuMap->dataRes[i].szBuffer; (*pCh) != NULL; pCh++)
		{
			if ( (*pCh) == L'\n')
			{
				pMenuMap->ctxMenu[i].strStatusBarText = (pCh+1);
				(*pCh) = NULL;
				break;
			}
		}
	}
	return TRUE;
}

BOOL LoadResultHeaderResources(RESULT_HEADERMAP* pHeaderMap, int nCols)
{
	HINSTANCE hInstance = _Module.GetModuleInstance();
	for ( int i = 0; i < nCols ; i++)
	{
		if ( 0 == ::LoadString(hInstance, pHeaderMap[i].uResID, pHeaderMap[i].szBuffer, MAX_RESULT_HEADER_STRLEN))
			return TRUE;
	}
	return TRUE;
}


////////////////////////////////////////////////////////////////////////
// CTreeNode

BEGIN_TOOLBAR_MAP(CTreeNode)
END_TOOLBAR_MAP()

BOOL CTreeNode::HasContainer(CContainerNode* pContainerNode)
{
	if (m_pContainer == NULL)
		return FALSE; // root
	if (m_pContainer == pContainerNode)
		return TRUE; // got it
	return m_pContainer->HasContainer(pContainerNode);
}

HRESULT CTreeNode::GetResultViewType(CComponentDataObject* pComponentData,
                                     LPOLESTR* ppViewType, 
                                     long* pViewOptions)
{
  if (pComponentData->IsMultiSelect())
  {
    *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
  }
  else
  {
	  *pViewOptions = MMC_VIEW_OPTIONS_NONE;
  }
	*ppViewType = NULL;
  return S_FALSE;
}

void CTreeNode::Show(BOOL bShow, CComponentDataObject* pComponentData)
{
	if (bShow)
	{
		ASSERT(m_dwNodeFlags & TN_FLAG_HIDDEN); // must be currently hidden
		SetFlagsDown(TN_FLAG_HIDDEN,FALSE); // mark it visible
		VERIFY(SUCCEEDED(pComponentData->AddNode(this)));
	}
	else
	{
		ASSERT(!(m_dwNodeFlags & TN_FLAG_HIDDEN)); // must be currently visible
		SetFlagsDown(TN_FLAG_HIDDEN,TRUE); // mark it hidden
		VERIFY(SUCCEEDED(pComponentData->DeleteNode(this)));
		if (IsContainer())
		{
			((CContainerNode*)this)->RemoveAllChildrenFromList();
			((CContainerNode*)this)->MarkEnumerated(FALSE);
		}
	}
}


void CTreeNode::SetFlagsDown(DWORD dwNodeFlags, BOOL bSet)
{
	if (bSet)
		m_dwNodeFlags |= dwNodeFlags; 
	else
		m_dwNodeFlags &= ~dwNodeFlags;		
}

void CTreeNode::SetFlagsUp(DWORD dwNodeFlags, BOOL bSet)
{
	if (bSet)
		m_dwNodeFlags |= dwNodeFlags; 
	else
		m_dwNodeFlags &= ~dwNodeFlags;		
	if (m_pContainer != NULL)
	{
		ASSERT(m_pContainer != this);
		m_pContainer->SetFlagsUp(dwNodeFlags, bSet);
	}
}

//
// Property Page methods
//
void CTreeNode::ShowPageForNode(CComponentDataObject* pComponentDataObject) 
{
	ASSERT(pComponentDataObject != NULL);
	pComponentDataObject->GetPropertyPageHolderTable()->BroadcastSelectPage(this, -1);
}

BOOL CTreeNode::HasPropertyPages(DATA_OBJECT_TYPES, 
                                 BOOL* pbHideVerb, 
                                 CNodeList*) 
{ 
  *pbHideVerb = TRUE; 
  return FALSE; 
}

//
// Menu Item methods
//
HRESULT CTreeNode::OnAddMenuItems(IContextMenuCallback2* pContextMenuCallback2, 
									                DATA_OBJECT_TYPES type,
									                long *pInsertionAllowed,
                                  CNodeList* pNodeList)
{
	HRESULT hr = S_OK;
	LPCONTEXTMENUITEM2 pContextMenuItem = NULL;
  
  if (pNodeList->GetCount() == 1) // single selection
  {
    pContextMenuItem = OnGetContextMenuItemTable();
	  if (pContextMenuItem == NULL)
		  return hr;

    //
	  // Loop through and add each of the menu items
    //
	  for (LPCONTEXTMENUITEM2 m = pContextMenuItem; m->strName; m++)
	  {
		  if (
				  ( (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) &&
					  (m->lInsertionPointID == CCM_INSERTIONPOINTID_PRIMARY_NEW) ) ||
				  ( (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) &&
					  (m->lInsertionPointID == CCM_INSERTIONPOINTID_PRIMARY_TASK) ) ||
				  ( (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) &&
					  (m->lInsertionPointID == CCM_INSERTIONPOINTID_PRIMARY_VIEW) ) ||
				  ( (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) &&
					  (m->lInsertionPointID == CCM_INSERTIONPOINTID_PRIMARY_TOP) )
		     )
		  {
			  // make a temporary copy that can be modified
			  CONTEXTMENUITEM2 tempItem;
			  ::memcpy(&tempItem, m, sizeof(CONTEXTMENUITEM2));
			  if (OnAddMenuItem(&tempItem, pInsertionAllowed))
			  {
				  hr = pContextMenuCallback2->AddItem(&tempItem);
				  if (FAILED(hr))
					  break;
			  }
		  }
	  }
  }
  else if (pNodeList->GetCount() > 1) // multiple selection
  {
    hr = OnAddMenuItemsMultipleSelect(pContextMenuCallback2, 
									                    type,
									                    pInsertionAllowed,
                                      pNodeList);
  }
	return hr;
}

BOOL CTreeNode::OnSetRenameVerbState(DATA_OBJECT_TYPES, 
                                     BOOL* pbHide, 
                                     CNodeList*) 
{ 
  *pbHide = TRUE; 
  return FALSE; 
}

BOOL CTreeNode::OnSetDeleteVerbState(DATA_OBJECT_TYPES, 
                                     BOOL* pbHide, 
                                     CNodeList*) 
{ 
  *pbHide = TRUE; 
  return FALSE; 
}

BOOL CTreeNode::OnSetRefreshVerbState(DATA_OBJECT_TYPES, 
                                      BOOL* pbHide, 
                                      CNodeList*) 
{ 
  *pbHide = TRUE; 
  return FALSE; 
}

BOOL CTreeNode::OnSetCutVerbState(DATA_OBJECT_TYPES, 
                                  BOOL* pbHide, 
                                  CNodeList*) 
{ 
  *pbHide = TRUE; 
  return FALSE; 
}

BOOL CTreeNode::OnSetCopyVerbState(DATA_OBJECT_TYPES, 
                                   BOOL* pbHide, 
                                   CNodeList*) 
{ 
  *pbHide = TRUE; 
  return FALSE; 
}

BOOL CTreeNode::OnSetPasteVerbState(DATA_OBJECT_TYPES, 
                                    BOOL* pbHide, 
                                    CNodeList*) 
{ 
  *pbHide = TRUE; 
  return FALSE; 
}

BOOL CTreeNode::OnSetPrintVerbState(DATA_OBJECT_TYPES, 
                                    BOOL* pbHide, 
                                    CNodeList*) 
{ 
  *pbHide = TRUE; 
  return FALSE; 
}

MMC_CONSOLE_VERB CTreeNode::GetDefaultVerb(DATA_OBJECT_TYPES type, 
                                           CNodeList* pNodeList)
{ 
	ASSERT((type == CCT_SCOPE) || (type == CCT_RESULT));
	if (type == CCT_SCOPE)
		return MMC_VERB_OPEN; 
	BOOL bHideVerbDummy;
	if (HasPropertyPages(type, &bHideVerbDummy, pNodeList))
		return MMC_VERB_PROPERTIES;
	return MMC_VERB_NONE;
}


void CTreeNode::OnSetVerbState(LPCONSOLEVERB pConsoleVerb, 
                               DATA_OBJECT_TYPES type,
                               CNodeList* pNodeList)
{
  //
  // Use the virtual functions to get the verb state
  //
  BOOL bHideCut;
  BOOL bCanCut = OnSetCutVerbState(type, &bHideCut, pNodeList);
  pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, bHideCut);
  pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, bCanCut);


  BOOL bHideCopy;
  BOOL bCanCopy = OnSetCopyVerbState(type, &bHideCopy, pNodeList);
  pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, bHideCopy);
	pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, bCanCopy);


  BOOL bHidePaste;
  BOOL bCanPaste = OnSetPasteVerbState(type, &bHidePaste, pNodeList);
  pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, bHidePaste);
	pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, bCanPaste);


  BOOL bHidePrint;
  BOOL bCanPrint = OnSetPrintVerbState(type, &bHidePrint, pNodeList);
	pConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, bHidePrint);
	pConsoleVerb->SetVerbState(MMC_VERB_PRINT, ENABLED, bCanPrint);

  BOOL bHideRename;
  BOOL bCanRename = OnSetRenameVerbState(type, &bHideRename, pNodeList);
	pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, bHideRename);
	pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, bCanRename);

	// MMC_VERB_PROPERTIES
	BOOL bHideProperties;
	BOOL bHasProperties = HasPropertyPages(type, &bHideProperties, pNodeList);
	pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, bHasProperties);
	pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, bHideProperties);

	// MMC_VERB_DELETE
	BOOL bHideDelete;
	BOOL bCanDelete = OnSetDeleteVerbState(type, &bHideDelete, pNodeList);
	pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, bCanDelete);
	pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, bHideDelete);

	// MMC_VERB_REFRESH
	BOOL bHideRefresh;
	BOOL bCanRefresh = OnSetRefreshVerbState(type, &bHideRefresh, pNodeList);
	pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, bCanRefresh);
	pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, bHideRefresh);
}

HRESULT CTreeNode::OnSetToolbarVerbState(IToolbar*, 
                                         CNodeList*)
{
  HRESULT hr = S_OK;

  //
  // Set the button state for each button on the toolbar using
  // hr = pToolbar->SetButtonState(event, MMC_BUTTON_STATE, bState);
  //
  return hr;
}   

void CTreeNode::DeleteHelper(CComponentDataObject* pComponentData)
{
	ASSERT(pComponentData != NULL);
	ASSERT(m_pContainer != NULL);
	ASSERT((CTreeNode*)m_pContainer != this);
	CContainerNode* pCont = m_pContainer;
	VERIFY(m_pContainer->RemoveChildFromList(this));
	ASSERT(m_pContainer == NULL);
	m_pContainer = pCont; // not in the container's list of children, but still needed
	
	// remove from UI only if the container is visible
	if (pCont->IsVisible())
		VERIFY(SUCCEEDED(pComponentData->DeleteNode(this))); // remove from the UI
}

void CTreeNode::IncrementSheetLockCount() 
{ 
	++m_nSheetLockCount; 
	if (m_pContainer != NULL) 
		m_pContainer->IncrementSheetLockCount(); 
}

void CTreeNode::DecrementSheetLockCount() 
{ 
	--m_nSheetLockCount; 
	if (m_pContainer != NULL) 
		m_pContainer->DecrementSheetLockCount();
}

void CTreeNode::OnPropertyChange(CComponentDataObject* pComponentData, 
									BOOL, long changeMask)
{
	// function called when the PPHolder successfully updated the node
	ASSERT(pComponentData != NULL);
	VERIFY(SUCCEEDED(pComponentData->ChangeNode(this, changeMask)));
}

void CTreeNode::OnCreateSheet() 
{
	++m_nSheetCount; 
	IncrementSheetLockCount();
	SetFlagsUp(TN_FLAG_HAS_SHEET, TRUE);
}

void CTreeNode::OnDeleteSheet() 
{ 
	DecrementSheetLockCount();
	--m_nSheetCount; 
	SetFlagsUp(TN_FLAG_HAS_SHEET,FALSE);
}

////////////////////////////////////////////////////////////////////////
// CContainerNode

void CContainerNode::IncrementThreadLockCount() 
{ 
	++m_nThreadLockCount; 
	if (m_pContainer != NULL) 
		m_pContainer->IncrementThreadLockCount(); 
}

void CContainerNode::DecrementThreadLockCount() 
{ 
	--m_nThreadLockCount; 
	if (m_pContainer != NULL) 
		m_pContainer->DecrementThreadLockCount();
}

BOOL CContainerNode::OnRefresh(CComponentDataObject* pComponentData,
                               CNodeList* pNodeList)
{
  BOOL bRet = TRUE;
  if (pNodeList->GetCount() == 1) // single selection
  {
	  if (IsSheetLocked())
	  {
		  if (!CanCloseSheets())
			  return FALSE;
		  pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
	  }
	  ASSERT(!IsSheetLocked());

	  RemoveAllChildrenHelper(pComponentData);
	  ASSERT(!HasChildren());
	  OnEnumerate(pComponentData);
	  AddCurrentChildrenToUI(pComponentData);
	  MarkEnumerated();
  }
  else // multiple selection
  {
    POSITION pos = pNodeList->GetHeadPosition();
    while (pos != NULL)
    {
      CTreeNode* pNode = pNodeList->GetNext(pos);
      ASSERT(pNode != NULL);

      //
      // Have each node refresh itself
      //
      CNodeList nodeList;
      nodeList.AddTail(pNode);

      if (!pNode->OnRefresh(pComponentData, &nodeList))
      {
        bRet = FALSE;
      }
    }
  }
	return bRet;
}

BOOL CContainerNode::RemoveChildFromList(CTreeNode* p) 
{ 
  if (p->IsContainer())
  {
		if (m_containerChildList.RemoveNode(p))
		{
			p->m_pContainer = NULL; 
			return TRUE;
		}
  }
  else
  {
    if (m_leafChildList.RemoveNode(p))
    {
      p->m_pContainer = NULL;
      return TRUE;
    }
  }
	return FALSE;
}

void CContainerNode::RemoveAllChildrenHelper(CComponentDataObject* pComponentData)
{
	ASSERT(pComponentData != NULL);
	// remove from the UI
	VERIFY(SUCCEEDED(pComponentData->RemoveAllChildren(this)));
	// remove from memory, recursively from the bottom
	RemoveAllChildrenFromList();
}

void CContainerNode::AddCurrentChildrenToUI(CComponentDataObject* pComponentData)
{
	POSITION pos;

  //
  // Add leaves
  //
	for( pos = m_leafChildList.GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pCurrentChild = m_leafChildList.GetNext(pos);
		VERIFY(SUCCEEDED(pComponentData->AddNode(pCurrentChild)));
	}

  //
  // Add Containers
  //
	for( pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pCurrentChild = m_containerChildList.GetNext(pos);
		VERIFY(SUCCEEDED(pComponentData->AddNode(pCurrentChild)));
	}
}

void CContainerNode::SetFlagsDown(DWORD dwNodeFlags, BOOL bSet)
{
	CTreeNode::SetFlagsDown(dwNodeFlags,bSet);
	// scan the list of children
	POSITION pos;
	for( pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pCurrentChild = m_containerChildList.GetNext(pos);
		pCurrentChild->SetFlagsDown(dwNodeFlags,bSet);
	}
	for( pos = m_leafChildList.GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pCurrentChild = m_leafChildList.GetNext(pos);
		pCurrentChild->SetFlagsDown(dwNodeFlags,bSet);
	}
}

void CContainerNode::SetFlagsOnNonContainers(DWORD dwNodeFlags, BOOL bSet)
{
	// do not set on urselves, we are a container
	// scan the list of children
	POSITION pos;
	for( pos = m_leafChildList.GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pCurrentChild = m_leafChildList.GetNext(pos);
  	pCurrentChild->SetFlagsDown(dwNodeFlags,bSet);
	}

  for (pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
  {
    CTreeNode* pCurrentChild = m_containerChildList.GetNext(pos);
  	((CContainerNode*)pCurrentChild)->SetFlagsOnNonContainers(dwNodeFlags,bSet);
  }
}

BOOL CContainerNode::AddChildToList(CTreeNode* p) 
{ 
  BOOL bRet = FALSE;
	p->m_pContainer = this;
  if (p->IsContainer())
  {
    bRet = NULL != m_containerChildList.AddTail(p);
  }
  else
  {
    bRet = NULL != m_leafChildList.AddTail(p);
  }
	return bRet; 
}

BOOL CContainerNode::FindChild(CTreeNode* pNode, CTreeNode** ppContainer)
{
	*ppContainer = NULL;
	if (pNode == NULL)
		return FALSE; // no sense in continuing
	if (pNode == this)
	{
		*ppContainer = m_pContainer; 
		return TRUE; // the node is ourselves
	}

  //
  // If we are looking for a leaf node search the list of leaves first
  //
  if (!pNode->IsContainer())
  {
    POSITION pos;
    for (pos = m_leafChildList.GetHeadPosition(); pos != NULL; )
    {
      CLeafNode* pCurrentLeafNode = (CLeafNode*)m_leafChildList.GetNext(pos);
      ASSERT(pCurrentLeafNode != NULL);

      if (pCurrentLeafNode == pNode)
      {
        *ppContainer = this;
        return TRUE;
      }
    }
  }

  //
	// scan and recurse the containers if necessary
  //
	POSITION contPos;
	for( contPos = m_containerChildList.GetHeadPosition(); contPos != NULL; )
	{
		CContainerNode* pCurrentChild = (CContainerNode*)m_containerChildList.GetNext(contPos);
		ASSERT(pCurrentChild != NULL);

		if (pCurrentChild == pNode)
		{
			*ppContainer = this;
			return TRUE;  // we directly contain the node
		}

    //
		// if the current node is a container, look inside it
    //
		if (pCurrentChild->FindChild(pNode,ppContainer))
    {
			return TRUE; // got it in the recursion
    }
	}
	return FALSE; // not found
}

BOOL CContainerNode::AddChildToListAndUI(CTreeNode* pChildToAdd, CComponentDataObject* pComponentData)
{
	ASSERT(pComponentData != NULL);
	VERIFY(AddChildToList(pChildToAdd)); // at the end of the list of children
	ASSERT(pChildToAdd->GetContainer() == this); // inserted underneath

	// add to UI only if currently visible and already expanded
	if (!IsVisible() || !IsExpanded())
		return TRUE;
	return SUCCEEDED(pComponentData->AddNode(pChildToAdd)); // add to the UI
}

BOOL CContainerNode::AddChildToListAndUISorted(CTreeNode* pChildToAdd, CComponentDataObject* pComponentData)
{
	ASSERT(pComponentData != NULL);
	VERIFY(AddChildToListSorted(pChildToAdd, pComponentData));
	ASSERT(pChildToAdd->GetContainer() == this); // inserted underneath

	// add to UI only if currently visible and already expanded
	if (!IsVisible() || !IsExpanded())
		return TRUE;
	return SUCCEEDED(pComponentData->AddNodeSorted(pChildToAdd)); // add to the UI
}

BOOL CContainerNode::AddChildToListSorted(CTreeNode* p, CComponentDataObject*)
{
  //
  // Containers will be sorted with respect to containers and leaves will be
  // sorted with respect to leaves but they won't be intermingled.
  //
	p->m_pContainer = this;
  
  CNodeList* pChildNodeList = NULL;
  if (p->IsContainer())
  {
    pChildNodeList = &m_containerChildList;
  }
  else
  {
    pChildNodeList = &m_leafChildList;
  }

  //
  // Find the position to insert the node in the list in sorted order
  //
  POSITION pos = pChildNodeList->GetHeadPosition();
  while (pos != NULL)
  {
    CTreeNode* pNodeInList = pChildNodeList->GetAt(pos);
    if (_wcsicoll(p->GetDisplayName(), pNodeInList->GetDisplayName()) < 0)
    {
      break;
    }
    pChildNodeList->GetNext(pos);
  }
  if (pos == NULL)
  {
	  return NULL != pChildNodeList->AddTail(p); 
  }
  return NULL != pChildNodeList->InsertBefore(pos, p);
}

void CContainerNode::RemoveAllChildrenFromList() 
{
  RemoveAllContainersFromList();
  RemoveAllLeavesFromList();
}

int CContainerNode::Compare(CTreeNode* pNodeA, CTreeNode* pNodeB, int nCol, LPARAM)
{
	// default sorting behavior
	LPCTSTR lpszA = pNodeA->GetString(nCol);
	LPCTSTR lpszB = pNodeB->GetString(nCol);
	// cannot process NULL strings, have to use ""
	ASSERT(lpszA != NULL);
	ASSERT(lpszB != NULL);
	return _tcsicoll( (lpszA != NULL) ? lpszA : g_lpszNullString, (lpszB != NULL) ? lpszB : g_lpszNullString);
}

void CContainerNode::ForceEnumeration(CComponentDataObject* pComponentData)
{
	if (IsEnumerated())
		return;
	OnEnumerate(pComponentData);
	MarkEnumerated();
}

void CContainerNode::MarkEnumerated(BOOL bEnum) 
{ 
	ASSERT(IsContainer()); 
	if (bEnum)
		m_dwNodeFlags |= TN_FLAG_CONTAINER_ENUM;
	else
		m_dwNodeFlags &= ~TN_FLAG_CONTAINER_ENUM;
}

void CContainerNode::MarkEnumeratedAndLoaded(CComponentDataObject* pComponentData)
{
	MarkEnumerated();
	OnChangeState(pComponentData); // move to loading
	OnChangeState(pComponentData); // move to loaded
}


/////////////////////////////////////////////////////////////////////////////
// CBackgroundThread

CBackgroundThread::CBackgroundThread()
{
	m_pQueryObj = NULL;
	m_bAutoDelete = FALSE;
	m_bAbandoned = FALSE;
	m_pContNode = NULL;
	m_hEventHandle = NULL;
	ExceptionPropagatingInitializeCriticalSection(&m_cs);
	m_nQueueCountMax = 10; 
}

CBackgroundThread::~CBackgroundThread()
{
	TRACE(_T("CBackgroundThread::~CBackgroundThread()\n"));
	ASSERT(IsAbandoned() || IsQueueEmpty());
	::DeleteCriticalSection(&m_cs);
	if (m_hEventHandle != NULL)
	{
		VERIFY(::CloseHandle(m_hEventHandle));
		m_hEventHandle = NULL;
	}
	if (m_pQueryObj != NULL)
	{
		delete m_pQueryObj;
		m_pQueryObj = NULL;
	}
}

void CBackgroundThread::SetQueryObj(CQueryObj* pQueryObj) 
{ 
	ASSERT(pQueryObj != NULL);
	m_pQueryObj = pQueryObj;
	m_pQueryObj->SetThread(this);
}

BOOL CBackgroundThread::Start(CMTContainerNode* pNode, CComponentDataObject* pComponentData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT(m_pContNode == NULL);
	m_pContNode = pNode;

	m_hHiddenWnd = pComponentData->GetHiddenWindow();

	ASSERT(m_hEventHandle == NULL); // cannot call start twice or reuse the same C++ object
	m_hEventHandle = ::CreateEvent(NULL,TRUE /*bManualReset*/,FALSE /*signalled*/, NULL);
	if (m_hEventHandle == NULL)
		return FALSE;
	return CreateThread();
}

int CBackgroundThread::Run()
{
	ASSERT(m_pContNode != NULL);
	ASSERT(m_pQueryObj != NULL);
	TRACE(_T("CBackgroundThread::Run() started\n"));

	while (m_pQueryObj->Enumerate());

	// before exiting, have to make sure there are no items in the queue
	if (!IsQueueEmpty())
		VERIFY(PostHaveData());

	VERIFY(PostExiting());

	// wait for the main thread to acknowledge the exiting message
	WaitForExitAcknowledge();

	ASSERT(IsAbandoned() || IsQueueEmpty()); // we cannot lose items in the queue
	TRACE(_T("CBackgroundThread::Run() terminated\n"));
	return 0;
}


void CBackgroundThread::Abandon()
{
	Lock();
	TRACE(_T("CBackgroundThread::Abandon()\n"));
	m_bAutoDelete = TRUE;
	m_bAbandoned = TRUE;
	Unlock();
  VERIFY(0 != ::SetEvent(m_hEventHandle));
}

BOOL CBackgroundThread::IsAbandoned()
{
	Lock();
	BOOL b = m_bAbandoned;
	Unlock();
	return b;
}

BOOL CBackgroundThread::OnAddToQueue(INT_PTR nCount) 
{
  BOOL bPostedMessage = FALSE;
	if (nCount >= m_nQueueCountMax)
  {
		VERIFY(PostHaveData());
    bPostedMessage = TRUE;
  }
  return bPostedMessage;
}


CObjBase* CBackgroundThread::RemoveFromQueue()
{
	Lock();
	ASSERT(m_pQueryObj != NULL);
	CObjBaseList* pQueue = m_pQueryObj->GetQueue();
	CObjBase* p =  pQueue->IsEmpty() ? NULL : pQueue->RemoveHead(); 
	Unlock();
	return p;
}

BOOL CBackgroundThread::IsQueueEmpty()
{
	Lock();
	ASSERT(m_pQueryObj != NULL);
	CObjBaseList* pQueue = m_pQueryObj->GetQueue();
	BOOL bRes = pQueue->IsEmpty(); 
	Unlock();
	return bRes;
}


BOOL CBackgroundThread::PostHaveData()
{
	return PostMessageToComponentDataRaw(CHiddenWnd::s_NodeThreadHaveDataNotificationMessage,
							(WPARAM)m_pContNode, (LPARAM)0);
}

BOOL CBackgroundThread::PostError(DWORD dwErr) 
{ 
	return PostMessageToComponentDataRaw(CHiddenWnd::s_NodeThreadErrorNotificationMessage,
							(WPARAM)m_pContNode, (LPARAM)dwErr);
}

BOOL CBackgroundThread::PostExiting()
{
	return PostMessageToComponentDataRaw(CHiddenWnd::s_NodeThreadExitingNotificationMessage,
							(WPARAM)m_pContNode, (LPARAM)0);
}


BOOL CBackgroundThread::PostMessageToComponentDataRaw(UINT Msg, WPARAM wParam, LPARAM lParam)
{
	BOOL b = IsAbandoned();
	if (b)
  {
		return TRUE; // no need to post
  }

	ASSERT(m_pContNode != NULL);

	ASSERT(m_hHiddenWnd != NULL);
	ASSERT(::IsWindow(m_hHiddenWnd));
	return ::PostMessage(m_hHiddenWnd, Msg, wParam, lParam);
}


void CBackgroundThread::WaitForExitAcknowledge() 
{
	VERIFY(WAIT_OBJECT_0 == ::WaitForSingleObject(m_hEventHandle,INFINITE)); 
}

////////////////////////////////////////////////////////////////////////
// CMTContainerNode


CMTContainerNode::~CMTContainerNode()
{
	ASSERT(m_pThread == NULL);
}


BOOL CMTContainerNode::OnEnumerate(CComponentDataObject* pComponentData, BOOL bAsync)
{
	OnChangeState(pComponentData);
	VERIFY(StartBackgroundThread(pComponentData, bAsync));
	return FALSE; // children not added, the thread will add them later
}


BOOL CMTContainerNode::OnRefresh(CComponentDataObject* pComponentData,
                                 CNodeList* pNodeList)
{
  BOOL bRet = TRUE;

  if (pNodeList->GetCount() == 1)  // single selection
  {
	  BOOL bLocked = IsThreadLocked();
	  ASSERT(!bLocked); // cannot do refresh on locked node, the UI should prevent this
	  if (bLocked)
		  return FALSE; 
	  if (IsSheetLocked())
	  {
		  if (!CanCloseSheets())
        {
           pComponentData->GetPropertyPageHolderTable()->BroadcastSelectPage(this, -1);
			  return FALSE;
        }
		  pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
	  }
	  ASSERT(!IsSheetLocked());

	  RemoveAllChildrenHelper(pComponentData);
	  ASSERT(!HasChildren());
	  OnEnumerate(pComponentData); // will spawn a thread to do enumeration
	  MarkEnumerated();
  }
  else // multiple selection
  {
    POSITION pos = pNodeList->GetHeadPosition();
    while (pos != NULL)
    {
      CTreeNode* pNode = pNodeList->GetNext(pos);
      ASSERT(pNode != NULL);

      CNodeList nodeList;
      nodeList.AddTail(pNode);

      if (!pNode->OnRefresh(pComponentData, &nodeList))
      {
        bRet = FALSE;
      }
    }
  }
	return TRUE;
}

void CMTContainerNode::AbandonThread(CComponentDataObject* pComponentData)
{
	if(m_pThread == NULL) // nothing running
		return;
	m_pThread->Abandon();
	m_pThread = NULL;
	pComponentData->GetRunningThreadTable()->Remove(this);
}



BOOL CMTContainerNode::StartBackgroundThread(CComponentDataObject* pComponentData, BOOL bAsync)
{
	ASSERT(m_pThread == NULL); // nothing running

	// notify the UI to change icon, if needed
	VERIFY(SUCCEEDED(pComponentData->ChangeNode(this, CHANGE_RESULT_ITEM_ICON)));
	m_pThread = CreateThreadObject();
	ASSERT(m_pThread != NULL);
	m_pThread->SetQueryObj(OnCreateQuery());
	BOOL bRes =  m_pThread->Start(this, pComponentData);
	if (bRes)
	{
		pComponentData->GetRunningThreadTable()->Add(this);
		// we need to call UpdateVerbState() because the lock count changed
		// by adding the node from the running thread table
		VERIFY(SUCCEEDED(pComponentData->UpdateVerbState(this)));
	}

  //
  // If we don't want this call to be asynchronous then we have to wait for
  // the thread to finish
  //
  if (!bAsync)
  {
    pComponentData->WaitForThreadExitMessage(this);
  }
	return bRes;
}

void CMTContainerNode::OnThreadHaveDataNotification(CComponentDataObject* pComponentDataObject)
{
	ASSERT(m_pThread != NULL);
	ASSERT(IsThreadLocked());
	// do data transfer from thread queue
	CObjBase* p = m_pThread->RemoveFromQueue();
	while (p)
	{
		// add new node to the list of children and propagate to the UI
		OnHaveData(p,pComponentDataObject);
    p = m_pThread->RemoveFromQueue();
	}
}

void CMTContainerNode::OnThreadErrorNotification(DWORD dwErr, CComponentDataObject*)
{
	ASSERT(m_pThread != NULL);
	ASSERT(IsThreadLocked());
	OnError(dwErr);
}

void CMTContainerNode::OnThreadExitingNotification(CComponentDataObject* pComponentDataObject)
{
	ASSERT(m_pThread != NULL);
	ASSERT(IsThreadLocked());
#if (TRUE)
	// let the thread know it can shut down
	m_pThread->AcknowledgeExiting();
	VERIFY(WAIT_OBJECT_0 == ::WaitForSingleObject(m_pThread->m_hThread,INFINITE));
	OnChangeState(pComponentDataObject);
	delete m_pThread;
	m_pThread = NULL;
	pComponentDataObject->GetRunningThreadTable()->Remove(this);
	// we need to call UpdateVerbState() because the lock count changed
	// by removing the node from the running thread table
	VERIFY(SUCCEEDED(pComponentDataObject->UpdateVerbState(this)));

  TRACE(_T("OnThreadExitingNotification()\n"));

#else // maybe better way of doing it???
	// we are going to detach from the thread, so make copies of variables
	HANDLE hThread = m_pThread->m_hThread;
	CBackgroundThread* pThread = m_pThread;
	AbandonThread(pComponentDataObject); // sets m_pThread = NULL
	// acknowledge to thread
	pThread->AcknowledgeExiting();
	VERIFY(WAIT_OBJECT_0 == ::WaitForSingleObject(hThread,INFINITE));
	OnChangeState(pComponentDataObject);
#endif

	VERIFY(SUCCEEDED(pComponentDataObject->SortResultPane(this)));
}




///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\about.cpp ===
/////////////////////////////////////////////////////////////////////
//	About.cpp
//
//	Provide constructor for the CSnapinAbout implementation.
//
//	HISTORY
//	01-Aug-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "about.h"

#include "stdabout.cpp" 


/////////////////////////////////////////////////////////////////////
CComputerMgmtAbout::CComputerMgmtAbout()
	{
	m_uIdStrProvider = IDS_SNAPINABOUT_PROVIDER;
	m_uIdStrVersion = IDS_SNAPINABOUT_VERSION;
	m_uIdStrDestription = IDS_SNAPINABOUT_DESCRIPTION;
	m_uIdIconImage = IDI_COMPUTER;
	m_uIdBitmapSmallImage = IDB_COMPUTER_SMALL;
	m_uIdBitmapSmallImageOpen = IDB_COMPUTER_SMALL;
	m_uIdBitmapLargeImage = IDB_COMPUTER_LARGE;
	m_crImageMask = RGB(255, 0, 255);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\cmponent.cpp ===
// cmponent.cpp : Implementation of CMyComputerComponent

#include "stdafx.h"

#include "macros.h"
USE_HANDLE_MACROS("MYCOMPUT(cmponent.cpp)")

#include "dataobj.h"
#include "cmponent.h" // CMyComputerComponent
#include "compdata.h" // CMyComputerComponentData

#include "guidhelp.h" // ExtractData

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "stdcmpnt.cpp" // CComponent

UINT g_aColumns0[4] =
	{IDS_COLUMN_NAME,IDS_COLUMN_TYPE,IDS_COLUMN_DESCRIPTION,0}; // SYSTEMTOOLS, SERVERAPPS, STORAGE
UINT g_aColumns1[2] =
	{IDS_COLUMN_NAME,0}; // MYCOMPUT_COMPUTER

UINT* g_Columns[MYCOMPUT_NUMTYPES] =
	{	g_aColumns1, // MYCOMPUT_COMPUTER
		g_aColumns0, // MYCOMPUT_SYSTEMTOOLS
		g_aColumns0, // MYCOMPUT_SERVERAPPS
		g_aColumns0  // MYCOMPUT_STORAGE
	};

UINT** g_aColumns = g_Columns;
//
// CODEWORK this should be in a resource, for example code on loading data resources see
//   D:\nt\private\net\ui\common\src\applib\applib\lbcolw.cxx ReloadColumnWidths()
//   JonN 10/11/96
//
int g_aColumnWidths0[3] = {150,150,150};
int g_aColumnWidths1[1] = {450};
int* g_ColumnWidths[MYCOMPUT_NUMTYPES] =
	{	g_aColumnWidths1, // MYCOMPUT_COMPUTER
		g_aColumnWidths0, // MYCOMPUT_SYSTEMTOOLS
		g_aColumnWidths0, // MYCOMPUT_SERVERAPPS
		g_aColumnWidths0  // MYCOMPUT_STORAGE
	};
int** g_aColumnWidths = g_ColumnWidths;

CMyComputerComponent::CMyComputerComponent()
:	m_pSvcMgmtToolbar( NULL ),
	m_pMyComputerToolbar( NULL ),
	m_pControlbar( NULL ),
	m_dwFlagsPersist( 0 ), 
	m_bForcingGetResultType (false)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pViewedCookie = NULL;
}

CMyComputerComponent::~CMyComputerComponent()
{
	TRACE_METHOD(CMyComputerComponent,Destructor);
	VERIFY( SUCCEEDED(ReleaseAll()) );
}

HRESULT CMyComputerComponent::ReleaseAll()
{
	MFC_TRY;

	TRACE_METHOD(CMyComputerComponent,ReleaseAll);

    SAFE_RELEASE(m_pSvcMgmtToolbar);
    SAFE_RELEASE(m_pMyComputerToolbar);
	SAFE_RELEASE(m_pControlbar);

	return CComponent::ReleaseAll();

	MFC_CATCH;
}


/////////////////////////////////////////////////////////////////////////////
// IComponent Implementation

HRESULT CMyComputerComponent::LoadStrings()
{
	return S_OK;
}

HRESULT CMyComputerComponent::LoadColumns( CMyComputerCookie* pcookie )
{
    TEST_NONNULL_PTR_PARAM(pcookie);

	return LoadColumnsFromArrays( (INT)(pcookie->m_objecttype) );
}


HRESULT CMyComputerComponent::Show( CCookie* pcookie, LPARAM arg, HSCOPEITEM /*hScopeItem*/ )
{
    TEST_NONNULL_PTR_PARAM(pcookie);

	if ( QueryComponentDataRef ().m_bMessageView )
	{
		CComPtr<IUnknown> spUnknown;
		CComPtr<IMessageView> spMessageView;

		HRESULT hr = m_pConsole->QueryResultView(&spUnknown);
		if (SUCCEEDED(hr))
		{        
			hr = spUnknown->QueryInterface(IID_IMessageView, (PVOID*)&spMessageView);
			if (SUCCEEDED(hr))
			{
				CString title;

				VERIFY (title.LoadString (IDS_TASKPADTITLE_COMPUTER));
				spMessageView->SetTitleText(title);
				spMessageView->SetBodyText(QueryComponentDataRef ().m_strMessageViewMsg);
				spMessageView->SetIcon(Icon_Information);
			}
			if ( E_NOINTERFACE == hr )
			{
				// The interface "IMessageView" was not found so call 
				// UpdateAllViews to force a call to GetResultType () which
				// will install it.  Since UpdateAllViews call MMCN_SHOW before
				// calling GetResultType, this flag will prevent an endless
				// loop
				// Note: This call is made here because it OnViewChange with 
				// this hint will call SelectScopeItem () which cannot be 
				// called during MMCN_EXPAND
				if ( !m_bForcingGetResultType )  
				{
					m_bForcingGetResultType = true;
					hr = m_pConsole->UpdateAllViews (0, 0, HINT_SELECT_ROOT_NODE);
				}
			}
		}
		return S_OK;
	}
    
	if ( 0 == arg )
	{
		if ( NULL == m_pResultData )
		{
			ASSERT( FALSE );
			return E_UNEXPECTED;
		}

// not needed		pcookie->ReleaseResultChildren();

		m_pViewedCookie = NULL;

		return S_OK;
	}

	m_pViewedCookie = (CMyComputerCookie*)pcookie;

	if (   MYCOMPUT_COMPUTER == m_pViewedCookie->m_objecttype
	    && !(m_pViewedCookie->m_fRootCookieExpanded) )
	{
		m_pViewedCookie->m_fRootCookieExpanded = true;
		CComQIPtr<IConsole2, &IID_IConsole2> pIConsole2 = m_pConsole;
		ASSERT( pIConsole2 );
		if ( pIConsole2 )
		{
			// JonN 5/27/99 Some dead code in this directory contains bad templates for
			// looping on scopecookies, this is a better template
			POSITION pos = pcookie->m_listScopeCookieBlocks.GetHeadPosition();
			while (NULL != pos)
			{
				CBaseCookieBlock* pcookieblock = pcookie->m_listScopeCookieBlocks.GetNext( pos );
				ASSERT( NULL != pcookieblock );
				CMyComputerCookie* pChildCookie = (CMyComputerCookie*)pcookieblock;
                // JonN 03/07/00: PREFIX 56323
                switch ((NULL == pChildCookie) ? MYCOMPUT_COMPUTER
                                               : pChildCookie->m_objecttype)
				{
				case MYCOMPUT_SYSTEMTOOLS:
				case MYCOMPUT_STORAGE:
					{
						HRESULT hr = pIConsole2->Expand(pChildCookie->m_hScopeItem, TRUE);
						ASSERT(SUCCEEDED(hr));
					}
					break;
				default:
					break;
				}
			}
		}
  }

	LoadColumns( m_pViewedCookie );

	return PopulateListbox( m_pViewedCookie );
}

HRESULT CMyComputerComponent::OnNotifyAddImages( LPDATAOBJECT /*lpDataObject*/,
	                                             LPIMAGELIST lpImageList,
	                                             HSCOPEITEM /*hSelectedItem*/ )
{
	if ( QueryComponentDataRef ().m_bMessageView )
		return S_OK;
	else
		return QueryComponentDataRef().LoadIcons(lpImageList,TRUE);
}

HRESULT CMyComputerComponent::OnNotifySnapinHelp (LPDATAOBJECT pDataObject)
{
	CCookie* pBaseParentCookie = NULL;
	HRESULT hr = ExtractData( pDataObject,
	                          CMyComputerDataObject::m_CFRawCookie,
	                          reinterpret_cast<PBYTE>(&pBaseParentCookie),
	                          sizeof(pBaseParentCookie) );
	if ( FAILED(hr) )
	{
		ASSERT(FALSE);
		return S_OK;
	}
	CMyComputerCookie* pCookie = QueryComponentDataRef().ActiveCookie(pBaseParentCookie);
	if (NULL == pCookie)
	{
		ASSERT(FALSE);
		return S_OK;
	}
	LPCTSTR lpcszHelpTopic = L"compmgmt_topnode.htm";
	switch (pCookie->m_objecttype)
	{
	case MYCOMPUT_SYSTEMTOOLS:
		lpcszHelpTopic = L"system_tools_overview.htm";
		break;
	case MYCOMPUT_SERVERAPPS:
		lpcszHelpTopic = L"server_services_applications_overview.htm";
		break;
	case MYCOMPUT_STORAGE:
		lpcszHelpTopic = L"storage_devices_overview.htm";
		break;
	default:
		ASSERT(FALSE); // fall through
	case MYCOMPUT_COMPUTER:
		break;
	}

	return ShowHelpTopic( lpcszHelpTopic );
}

HRESULT CMyComputerComponent::PopulateListbox(CMyComputerCookie* /*pcookie*/)
{
// not needed	(void) pcookie->AddRefResultChildren();

	return S_OK; // no resultitems in this snapin
}

///////////////////////////////////////////////////////////////////////////////
/// IExtendContextMenu

STDMETHODIMP CMyComputerComponent::AddMenuItems(
                    IDataObject*          piDataObject,
                    IContextMenuCallback* piCallback,
					long*                 pInsertionAllowed)
{
    MFC_TRY;

    TRACE_METHOD(CMyComputerComponent,AddMenuItems);
    TEST_NONNULL_PTR_PARAM(piDataObject);
    TEST_NONNULL_PTR_PARAM(piCallback);
    TEST_NONNULL_PTR_PARAM(pInsertionAllowed);
    TRACE( "CMyComputerComponent: extending menu\n" );

	if ( 0 == (CCM_INSERTIONALLOWED_VIEW & (*pInsertionAllowed)) )
		return S_OK; // no View menu

	//
	// CODEWORK This code will not work if My Computer becomes an extension,
	// since the RawCookie format will not be available.
	// WARNING cookie cast
	//
	CCookie* pBaseParentCookie = NULL;
	HRESULT hr = ExtractData( piDataObject,
		                      CMyComputerDataObject::m_CFRawCookie,
							  reinterpret_cast<PBYTE>(&pBaseParentCookie),
							  sizeof(pBaseParentCookie) );
	if ( FAILED(hr) )
	{
		ASSERT(FALSE);
		return S_OK;
	}
	CMyComputerCookie* pCookie = QueryComponentDataRef().ActiveCookie(pBaseParentCookie);
	if (NULL == pCookie)
	{
		ASSERT(FALSE);
		return S_OK;
	}
	switch (pCookie->m_objecttype)
	{
	case MYCOMPUT_COMPUTER:
	case MYCOMPUT_SYSTEMTOOLS:
	case MYCOMPUT_SERVERAPPS:
		break;
	default:
		ASSERT(FALSE); // fall through
	case MYCOMPUT_STORAGE:
		return S_OK;
	}

	return hr;

    MFC_CATCH;
} // CMyComputerComponent::AddMenuItems()


STDMETHODIMP CMyComputerComponent::Command(
                    LONG            lCommandID,
                    IDataObject*    piDataObject )
{
    MFC_TRY;

    TRACE_METHOD(CMyComputerComponent,Command);
    TEST_NONNULL_PTR_PARAM(piDataObject);
    TRACE( "CMyComputerComponent::Command: command %ld selected\n", lCommandID );

	switch (lCommandID)
	{
	case -1:
		break;
	default:
		ASSERT(FALSE);
		break;
	}

    return S_OK;

    MFC_CATCH;

} // CMyComputerComponent::Command()

HRESULT CMyComputerComponent::OnNotifySelect( LPDATAOBJECT lpDataObject, BOOL /*fSelected*/ )
{
	MFC_TRY;

	TRACE_METHOD(CMyComputerComponent,OnNotifySelect);
	TEST_NONNULL_PTR_PARAM(lpDataObject);

	CCookie* pBaseParentCookie = NULL;
	HRESULT hr = ExtractData( lpDataObject,
	                          CMyComputerDataObject::m_CFRawCookie,
	                          reinterpret_cast<PBYTE>(&pBaseParentCookie),
	                          sizeof(pBaseParentCookie) );
	if ( FAILED(hr) )
	{
		ASSERT(FALSE);
		return S_OK;
	}
	CMyComputerCookie* pCookie = QueryComponentDataRef().ActiveCookie(pBaseParentCookie);
	if (NULL == pCookie)
	{
		ASSERT(FALSE);
		return S_OK;
	}

	// Set the default verb to display the properties of the selected object
	// We do this so that extensions can add properties, we don't have any
	m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES,
	                             ENABLED,
	                             (MYCOMPUT_COMPUTER == pCookie->m_objecttype) );

	m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);

	return S_OK;
	MFC_CATCH;
}

STDMETHODIMP CMyComputerComponent::GetResultViewType(
                                           MMC_COOKIE cookie,
                                           LPOLESTR* ppViewType,
                                           long* pViewOptions)
{
	MFC_TRY;
	if ( QueryComponentDataRef ().m_bMessageView )
	{
		m_bForcingGetResultType = false;
		*pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

		LPOLESTR psz = NULL;
		StringFromCLSID(CLSID_MessageView, &psz);

		USES_CONVERSION;

		if (psz != NULL)
		{
			*ppViewType = psz;
			return S_OK;
		}
		else
			return S_FALSE;
	}
	else
		return CComponent::GetResultViewType( cookie, ppViewType, pViewOptions );
	MFC_CATCH;
}

HRESULT CMyComputerComponent::OnViewChange (LPDATAOBJECT /*pDataObject*/, LPARAM /*data*/, LPARAM hint)
{
	HRESULT hr = S_OK;
	if ( (HINT_SELECT_ROOT_NODE & hint) )
	{
		hr = m_pConsole->SelectScopeItem (QueryComponentDataRef().QueryRootCookie().m_hScopeItem);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\compdata.cpp ===
// compdata.cpp : Implementation of CMyComputerComponentData

#include "stdafx.h"
#include <lmerr.h>			// For Lan Manager API error codes and return value types.
#include <lmcons.h>		// For Lan Manager API constants.
#include <lmapibuf.h>		// For NetApiBufferFree.
#include <lmdfs.h>			// For DFS APIs.
#include <lmserver.h>		// For getting a domain of a server.

#include "macros.h"
USE_HANDLE_MACROS("MMCFMGMT(compdata.cpp)")

#include "dataobj.h"
#include "compdata.h"
#include "cookie.h"
#include "snapmgr.h"
#include "stdutils.h" // IsLocalComputername
#include "chooser2.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#include "stdcdata.cpp" // CComponentData implementation
#include "chooser2.cpp" // CHOOSER2_PickTargetComputer implementation

// Helper function to convert message in NETMSG.DLL
int DisplayNetMsgError (
        HWND hWndParent, 
		const CString& computerName, 
        NET_API_STATUS dwErr, 
        CString& displayedMessage);

//
// CMyComputerComponentData
//

CMyComputerComponentData::CMyComputerComponentData()
: m_pRootCookie( NULL )
, m_dwFlagsPersist( 0 )
, m_fAllowOverrideMachineName( FALSE )
, m_bCannotConnect (false)
, m_bMessageView (false)
{
    //
    // We must refcount the root cookie, since a dataobject for it
    // might outlive the IComponentData.  JonN 9/2/97
    //
    m_pRootCookie = new CMyComputerCookie( MYCOMPUT_COMPUTER );
    ASSERT(NULL != m_pRootCookie);
// JonN 10/27/98 All CRefcountedObject's start with refcount==1
//    m_pRootCookie->AddRef();
    SetHtmlHelpFileName (L"compmgmt.chm");
}

CMyComputerComponentData::~CMyComputerComponentData()
{
    m_pRootCookie->Release();
    m_pRootCookie = NULL;
}

DEFINE_FORWARDS_MACHINE_NAME( CMyComputerComponentData, m_pRootCookie )

CCookie& CMyComputerComponentData::QueryBaseRootCookie()
{
    ASSERT(NULL != m_pRootCookie);
	return (CCookie&)*m_pRootCookie;
}


STDMETHODIMP CMyComputerComponentData::CreateComponent(LPCOMPONENT* ppComponent)
{
	MFC_TRY;

    ASSERT(ppComponent != NULL);

    CComObject<CMyComputerComponent>* pObject;
    CComObject<CMyComputerComponent>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);
	pObject->SetComponentDataPtr( (CMyComputerComponentData*)this );

    return pObject->QueryInterface(IID_IComponent,
                    reinterpret_cast<void**>(ppComponent));

	MFC_CATCH;
}

HRESULT CMyComputerComponentData::LoadIcons(LPIMAGELIST pImageList, BOOL /*fLoadLargeIcons*/)
{
	HINSTANCE hInstance = AfxGetInstanceHandle();
	ASSERT(hInstance != NULL);

	// Structure to map a Resource ID to an index of icon
	struct RESID2IICON
		{
		UINT uIconId;	// Icon resource ID
		int iIcon;		// Index of the icon in the image list
		};
	const static RESID2IICON rgzLoadIconList[] =
		{
		// Misc icons
		{ IDI_COMPUTER, iIconComputer },
		{ IDI_COMPFAIL, iIconComputerFail },
		{ IDI_SYSTEMTOOLS, iIconSystemTools },
		{ IDI_STORAGE, iIconStorage },
		{ IDI_SERVERAPPS, iIconServerApps },

		{ 0, 0} // Must be last
		};


	for (int i = 0; rgzLoadIconList[i].uIconId != 0; i++)
		{
	    HICON hIcon = LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(rgzLoadIconList[i].uIconId));
		ASSERT(NULL != hIcon && "Icon ID not found in resources");
		HRESULT hr = pImageList->ImageListSetIcon((PLONG_PTR)hIcon, rgzLoadIconList[i].iIcon);
		ASSERT(SUCCEEDED(hr) && "Unable to add icon to ImageList");
		}

    return S_OK;
}


CString g_strMyComputer;
CString g_strSystemTools;
CString g_strServerApps;
CString g_strStorage;

BOOL g_fScopeStringsLoaded = FALSE;

void LoadGlobalCookieStrings()
{
	if (!g_fScopeStringsLoaded )
	{
		g_fScopeStringsLoaded = TRUE;
		VERIFY( g_strMyComputer.LoadString(IDS_SCOPE_MYCOMPUTER) );
		VERIFY( g_strSystemTools.LoadString(IDS_SCOPE_SYSTEMTOOLS) );
		VERIFY( g_strServerApps.LoadString(IDS_SCOPE_SERVERAPPS) );
		VERIFY( g_strStorage.LoadString(IDS_SCOPE_STORAGE) );
	}
}

// returns TRUE iff the child nodes should be added
// CODEWORK this is probably no longer necessary, we always return true
bool CMyComputerComponentData::ValidateMachine(const CString &sName, bool bDisplayErr)
{
	CWaitCursor			waitCursor;
	int					iRetVal = IDYES;
	SERVER_INFO_101*	psvInfo101 = 0;
	DWORD				dwr = ERROR_SUCCESS;
	DWORD				dwServerType = SV_TYPE_NT;

	m_bMessageView = false;

	// passed-in name is not the same as local machine
	if ( !IsLocalComputername(sName) )
	{
		dwr = ::NetServerGetInfo((LPTSTR)(LPCTSTR)sName,
				101, (LPBYTE*)&psvInfo101);
		if (dwr == ERROR_SUCCESS)
		{
			ASSERT( NULL != psvInfo101 );
			dwServerType = psvInfo101->sv101_type;
			::NetApiBufferFree (psvInfo101);
		}
		if (bDisplayErr && (dwr != ERROR_SUCCESS || !(SV_TYPE_NT & dwServerType)) )
		{
			CString	computerName (sName);

			if ( computerName.IsEmpty () )
			{
				DWORD	dwSize = MAX_COMPUTERNAME_LENGTH + 1 ;
				VERIFY (::GetComputerName (
						computerName.GetBufferSetLength (dwSize),
						&dwSize));
				computerName.ReleaseBuffer ();
			}
			else
			{
				// Strip off the leading whack-whack
				if ( computerName.Find (L"\\\\") == 0 )
				{
					computerName = computerName.GetBuffer (computerName.GetLength ()) + 2;
					computerName.ReleaseBuffer ();
				}
			}

			CString	text;
			CString	caption;
			bool	bMessageDisplayed = false;

			switch (dwr)
			{
			case ERROR_NETWORK_UNREACHABLE:
				text.FormatMessage (IDS_CANT_CONNECT_TO_MACHINE_NETWORK_UNREACHABLE,
						computerName);
				break;

			case ERROR_NETNAME_DELETED:
				text.FormatMessage (IDS_CANT_CONNECT_TO_MACHINE_NETNAME_DELETED,
						computerName);
				break;

			case ERROR_SUCCESS:
				ASSERT( !(SV_TYPE_NT & dwServerType) );
				text.FormatMessage (IDS_CANT_CONNECT_TO_NON_NT_COMPUTER,
						computerName);
				dwr = ERROR_BAD_NETPATH;
				break;

			case ERROR_ACCESS_DENIED:
				// We will interpret this as success.
				return true;

			case ERROR_BAD_NETPATH:
			default:
				{
					HWND	hWndParent = 0;
					m_pConsole->GetMainWindow (&hWndParent);
					iRetVal = DisplayNetMsgError (hWndParent, computerName, 
							dwr, m_strMessageViewMsg);
					bMessageDisplayed = true;
					m_bMessageView = true;
					return false;
				}
				break;
			}


			if ( !bMessageDisplayed )
			{
				VERIFY (caption.LoadString (IDS_TASKPADTITLE_COMPUTER));
				m_pConsole->MessageBox (text, caption,
						MB_ICONINFORMATION | MB_YESNO, &iRetVal);
			}
		}
	}

	if (IDYES != iRetVal)
	{
		// revert to local computer focus
		QueryRootCookie().SetMachineName (L"");

		// Set the persistent name.  If we are managing the local computer
		// this name should be empty.
		m_strMachineNamePersist = L"";

		VERIFY (SUCCEEDED (ChangeRootNodeName (L"")) );
		iRetVal = IDYES;
		dwr = ERROR_SUCCESS;
	}


	m_bCannotConnect = (ERROR_SUCCESS != dwr);

	// Change root node icon
	SCOPEDATAITEM item;
	::ZeroMemory (&item, sizeof (SCOPEDATAITEM));
	item.mask = SDI_IMAGE | SDI_OPENIMAGE;
	item.nImage = (m_bCannotConnect) ? iIconComputerFail : iIconComputer;
	item.nOpenImage = item.nImage;
	item.ID = QueryBaseRootCookie ().m_hScopeItem;
	VERIFY (SUCCEEDED (m_pConsoleNameSpace->SetItem (&item)));

	return true;
}

HRESULT CMyComputerComponentData::OnNotifyExpand(LPDATAOBJECT lpDataObject, BOOL bExpanding, HSCOPEITEM hParent)
{
	ASSERT( NULL != lpDataObject &&
	        NULL != hParent &&
			NULL != m_pConsoleNameSpace );

	if (!bExpanding)
		return S_OK;

	//
	// CODEWORK This code will not work if My Computer becomes an extension,
	// since the RawCookie format will not be available.
	// WARNING cookie cast
	//
	CCookie* pBaseParentCookie = NULL;
	HRESULT hr = ExtractData( lpDataObject,
		                      CMyComputerDataObject::m_CFRawCookie,
							  reinterpret_cast<PBYTE>(&pBaseParentCookie),
							  sizeof(pBaseParentCookie) );
	ASSERT( SUCCEEDED(hr) );
	CMyComputerCookie* pParentCookie = ActiveCookie(pBaseParentCookie);
	ASSERT( NULL != pParentCookie );

	// save the HSCOPEITEM of the root node
	if ( NULL == pParentCookie->m_hScopeItem )
	{
		pParentCookie->m_hScopeItem = hParent;

		// Ensure root node name is formatted correctly.
		CString	machineName	= pParentCookie->QueryNonNULLMachineName ();

		hr = ChangeRootNodeName (machineName);
	}
	else
	{
		ASSERT( pParentCookie->m_hScopeItem == hParent );
	}

	switch ( pParentCookie->m_objecttype )
	{
		// This node type has a child
		case MYCOMPUT_COMPUTER:
			break;

		// This node type has no children in this snapin but may have dynamic extensions
		case MYCOMPUT_SERVERAPPS:
			return ExpandServerApps( hParent, pParentCookie );

		// These node types have no children
		case MYCOMPUT_SYSTEMTOOLS:
		case MYCOMPUT_STORAGE:
			return S_OK;

		default:
			TRACE( "CMyComputerComponentData::EnumerateScopeChildren bad parent type\n" );
			ASSERT( FALSE );
			return S_OK;
	}

	if ( NULL == hParent ||
		 !((pParentCookie->m_listScopeCookieBlocks).IsEmpty()) )
	{
		ASSERT(FALSE);
		return S_OK;
	}

	LoadGlobalCookieStrings();

	hr = AddScopeNodes (hParent, *pParentCookie);

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
//	AddScopeNodes
//
//	Purpose: Add the nodes that appear immediately below the root node
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMyComputerComponentData::AddScopeNodes (HSCOPEITEM hParent, CMyComputerCookie& rParentCookie)
{
	if ( !(rParentCookie.m_listScopeCookieBlocks.IsEmpty()) )
	{
		return S_OK; // scope cookies already present
	}

	HRESULT	hr = S_OK;
	LPCWSTR lpcszMachineName = rParentCookie.QueryNonNULLMachineName();

	if ( ValidateMachine (lpcszMachineName, true) )
	{
		SCOPEDATAITEM tSDItem;
		::ZeroMemory(&tSDItem,sizeof(tSDItem));
		tSDItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_STATE | SDI_PARAM | SDI_PARENT;
		tSDItem.displayname = MMC_CALLBACK;
		tSDItem.relativeID = hParent;
		tSDItem.nState = 0;


		// Create new cookies


		CMyComputerCookie* pNewCookie = new CMyComputerCookie(
			MYCOMPUT_SYSTEMTOOLS,
			lpcszMachineName );
		rParentCookie.m_listScopeCookieBlocks.AddHead(
			(CBaseCookieBlock*)pNewCookie );
		// WARNING cookie cast
		tSDItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pNewCookie);
		tSDItem.nImage = QueryImage( *pNewCookie, FALSE );
		tSDItem.nOpenImage = QueryImage( *pNewCookie, TRUE );
		hr = m_pConsoleNameSpace->InsertItem(&tSDItem);
		ASSERT(SUCCEEDED(hr));
		pNewCookie->m_hScopeItem = tSDItem.ID;
		ASSERT( NULL != pNewCookie->m_hScopeItem );

		pNewCookie = new CMyComputerCookie(
			MYCOMPUT_STORAGE,
			lpcszMachineName );
		rParentCookie.m_listScopeCookieBlocks.AddHead(
			(CBaseCookieBlock*)pNewCookie );
		// WARNING cookie cast
		tSDItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pNewCookie);
		tSDItem.nImage = QueryImage( *pNewCookie, FALSE );
		tSDItem.nOpenImage = QueryImage( *pNewCookie, TRUE );
		hr = m_pConsoleNameSpace->InsertItem(&tSDItem);
		ASSERT(SUCCEEDED(hr));
		pNewCookie->m_hScopeItem = tSDItem.ID;
		ASSERT( NULL != pNewCookie->m_hScopeItem );

		pNewCookie = new CMyComputerCookie(
			MYCOMPUT_SERVERAPPS,
			lpcszMachineName );
		rParentCookie.m_listScopeCookieBlocks.AddHead(
			(CBaseCookieBlock*)pNewCookie );
		// WARNING cookie cast
		tSDItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pNewCookie);
		tSDItem.nImage = QueryImage( *pNewCookie, FALSE );
		tSDItem.nOpenImage = QueryImage( *pNewCookie, TRUE );
		hr = m_pConsoleNameSpace->InsertItem(&tSDItem);
		ASSERT(SUCCEEDED(hr));
		pNewCookie->m_hScopeItem = tSDItem.ID;
		ASSERT( NULL != pNewCookie->m_hScopeItem );
	}
	else
		hr = S_FALSE;

	return hr;
}


HRESULT CMyComputerComponentData::OnNotifyDelete(LPDATAOBJECT /*lpDataObject*/)
{
	// CODEWORK The user hit the Delete key, I should deal with this
	return S_OK;
}


HRESULT CMyComputerComponentData::OnNotifyRelease(LPDATAOBJECT /*lpDataObject*/, HSCOPEITEM /*hItem*/)
{
	// JonN 01/26/00: COMPMGMT is never an extension
	return S_OK;
}


HRESULT CMyComputerComponentData::OnNotifyPreload(LPDATAOBJECT /*lpDataObject*/, HSCOPEITEM hRootScopeItem)
{
	ASSERT (m_fAllowOverrideMachineName);

	QueryBaseRootCookie ().m_hScopeItem = hRootScopeItem;
	CString		machineName = QueryRootCookie ().QueryNonNULLMachineName();

	return ChangeRootNodeName (machineName);
}

// global space to store the string handed back to GetDisplayInfo()
// CODEWORK should use "bstr" for ANSI-ization
CString g_strResultColumnText;

BSTR CMyComputerComponentData::QueryResultColumnText(
	CCookie& basecookieref,
	int nCol )
{
	CMyComputerCookie& cookieref = (CMyComputerCookie&)basecookieref;
#ifndef UNICODE
#error not ANSI-enabled
#endif
	switch ( cookieref.m_objecttype )
	{
		case MYCOMPUT_COMPUTER:
			if (COLNUM_COMPUTER_NAME == nCol)
				return const_cast<BSTR>(((LPCTSTR)g_strMyComputer));
			break;
		case MYCOMPUT_SYSTEMTOOLS:
			if (COLNUM_COMPUTER_NAME == nCol)
				return const_cast<BSTR>(((LPCTSTR)g_strSystemTools));
			break;
		case MYCOMPUT_SERVERAPPS:
			if (COLNUM_COMPUTER_NAME == nCol)
				return const_cast<BSTR>(((LPCTSTR)g_strServerApps));
			break;
		case MYCOMPUT_STORAGE:
			if (COLNUM_COMPUTER_NAME == nCol)
				return const_cast<BSTR>(((LPCTSTR)g_strStorage));
			break;

		default:
			TRACE( "CMyComputerComponentData::EnumerateScopeChildren bad parent type\n" );
			ASSERT( FALSE );
			break;
	}

	return L"";
}

int CMyComputerComponentData::QueryImage(CCookie& basecookieref, BOOL /*fOpenImage*/)
{
	CMyComputerCookie& cookieref = (CMyComputerCookie&)basecookieref;
	switch ( cookieref.m_objecttype )
	{
		case MYCOMPUT_COMPUTER:
			if ( m_bCannotConnect )
				return iIconComputerFail;
			else
				return iIconComputer;

		case MYCOMPUT_SYSTEMTOOLS:
			return iIconSystemTools;

		case MYCOMPUT_SERVERAPPS:
			return iIconServerApps;

		case MYCOMPUT_STORAGE:
			return iIconStorage;

		default:
			TRACE( "CMyComputerComponentData::QueryImage bad parent type\n" );
			ASSERT( FALSE );
			break;
	}
	return iIconComputer;
}


///////////////////////////////////////////////////////////////////////////////
/// IExtendPropertySheet

STDMETHODIMP CMyComputerComponentData::QueryPagesFor(LPDATAOBJECT pDataObject)
{
	MFC_TRY;

	if (NULL == pDataObject)
	{
		ASSERT(FALSE);
		return E_POINTER;
	}

	DATA_OBJECT_TYPES dataobjecttype = CCT_SCOPE;
	HRESULT hr = ExtractData( pDataObject, CMyComputerDataObject::m_CFDataObjectType, (PBYTE)&dataobjecttype, sizeof(dataobjecttype) );
	if ( FAILED(hr) )
		return hr;
	if (CCT_SNAPIN_MANAGER == dataobjecttype)
		return S_OK; // Snapin Manager dialog

	CCookie* pBaseParentCookie = NULL;
	hr = ExtractData( pDataObject,
	                  CMyComputerDataObject::m_CFRawCookie,
	                  reinterpret_cast<PBYTE>(&pBaseParentCookie),
	                  sizeof(pBaseParentCookie) );
	ASSERT( SUCCEEDED(hr) );
	CMyComputerCookie* pParentCookie = ActiveCookie(pBaseParentCookie);
	ASSERT( NULL != pParentCookie );
	if ( MYCOMPUT_COMPUTER == pParentCookie->m_objecttype )
		return S_OK; // allow extensibility

	return S_FALSE;

	MFC_CATCH;
}

STDMETHODIMP CMyComputerComponentData::CreatePropertyPages(
	LPPROPERTYSHEETCALLBACK pCallBack,
	LONG_PTR /*handle*/,		// This handle must be saved in the property page object to notify the parent when modified
	LPDATAOBJECT pDataObject)
{
	MFC_TRY;

	if (NULL == pCallBack || NULL == pDataObject)
	{
		ASSERT(FALSE);
		return E_POINTER;
	}

	DATA_OBJECT_TYPES dataobjecttype = CCT_SCOPE;
	HRESULT hr = ExtractData( pDataObject, CMyComputerDataObject::m_CFDataObjectType, (PBYTE)&dataobjecttype, sizeof(dataobjecttype) );
	if (CCT_SNAPIN_MANAGER != dataobjecttype)
	{
		CCookie* pBaseParentCookie = NULL;
		hr = ExtractData( pDataObject,
		                  CMyComputerDataObject::m_CFRawCookie,
		                  reinterpret_cast<PBYTE>(&pBaseParentCookie),
		                  sizeof(pBaseParentCookie) );
		ASSERT( SUCCEEDED(hr) );
		CMyComputerCookie* pParentCookie = ActiveCookie(pBaseParentCookie);
		ASSERT( NULL != pParentCookie );
		if ( MYCOMPUT_COMPUTER == pParentCookie->m_objecttype )
			return S_OK; // allow extensibility
		return S_FALSE;
	}

	//
	// Note that once we have established that this is a CCT_SNAPIN_MANAGER cookie,
	// we don't care about its other properties.  A CCT_SNAPIN_MANAGER cookie is
	// equivalent to a BOOL flag asking for the Node Properties page instead of a
	// managed object property page.  JonN 10/9/96
	//

	CMyComputerGeneral * pPage = new CMyComputerGeneral();
	pPage->SetCaption(IDS_SCOPE_MYCOMPUTER);

	// Initialize state of object
	ASSERT(NULL != m_pRootCookie);
	pPage->InitMachineName(m_pRootCookie->QueryTargetServer());
	pPage->SetOutputBuffers(
		OUT &m_strMachineNamePersist,
		OUT &m_fAllowOverrideMachineName,
		OUT &m_pRootCookie->m_strMachineName);	// Effective machine name

	HPROPSHEETPAGE hPage=CreatePropertySheetPage(&pPage->m_psp);
	hr = pCallBack->AddPage(hPage);
	ASSERT( SUCCEEDED(hr) );

	return S_OK;

	MFC_CATCH;
}

STDMETHODIMP CMyComputerComponentData::AddMenuItems(
                    IDataObject*          piDataObject,
                    IContextMenuCallback* piCallback,
                    long*                 pInsertionAllowed)
{
	MFC_TRY;
	TRACE_METHOD(CMyComputerComponent,AddMenuItems);
	TEST_NONNULL_PTR_PARAM(piDataObject);
	TEST_NONNULL_PTR_PARAM(piCallback);
	TEST_NONNULL_PTR_PARAM(pInsertionAllowed);
	TRACE( "CMyComputerComponentData: extending menu\n" );

	CCookie* pBaseParentCookie = NULL;
	HRESULT hr = ExtractData (piDataObject,
	                          CMyComputerDataObject::m_CFRawCookie,
	                          reinterpret_cast<PBYTE>(&pBaseParentCookie),
	                          sizeof(pBaseParentCookie) );
	if ( FAILED (hr) )
	{
		ASSERT (FALSE);
		return S_OK;
	}
	CMyComputerCookie* pCookie = ActiveCookie (pBaseParentCookie);
	if ( !pCookie )
	{
		ASSERT (FALSE);
		return S_OK;
	}

	if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_TOP )
	{
		if ( MYCOMPUT_COMPUTER == pCookie->m_objecttype &&
				QueryBaseRootCookie ().m_hScopeItem)
		{
			hr = ::LoadAndAddMenuItem (piCallback,
					IDM_CHANGE_COMPUTER_TOP, IDM_CHANGE_COMPUTER_TOP,
					CCM_INSERTIONPOINTID_PRIMARY_TOP,
					0,
					AfxGetInstanceHandle ());
		}
	}

	if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_TASK )
	{
		if ( MYCOMPUT_COMPUTER == pCookie->m_objecttype &&
				QueryBaseRootCookie ().m_hScopeItem)
		{
			hr = ::LoadAndAddMenuItem (piCallback,
					IDM_CHANGE_COMPUTER_TASK, IDM_CHANGE_COMPUTER_TASK,
					CCM_INSERTIONPOINTID_PRIMARY_TASK,
					0,
					AfxGetInstanceHandle ());
		}
	}
	return hr;
	
    MFC_CATCH;
} // CMyComputerComponentData::AddMenuItems()

STDMETHODIMP CMyComputerComponentData::Command(
                    LONG            lCommandID,
                    IDataObject*    piDataObject )
{
    MFC_TRY;

    TRACE_METHOD(CMyComputerComponentData,Command);
    TEST_NONNULL_PTR_PARAM(piDataObject);
    TRACE( "CMyComputerComponentData::Command: command %ld selected\n", lCommandID );

	switch (lCommandID)
	{
	case IDM_CHANGE_COMPUTER_TASK:
	case IDM_CHANGE_COMPUTER_TOP:
		{
			ASSERT (QueryBaseRootCookie ().m_hScopeItem);
			return OnChangeComputer (piDataObject);
		}
		break;

	default:
		ASSERT(FALSE);
		break;
	}

    return S_OK;

    MFC_CATCH;

} // CMyComputerComponentData::Command()


///////////////////////////////////////////////////////////////////////////////
//
//	OnChangeComputer ()
//
//  Purpose:	Change the machine managed by the snapin
//
//	Input:		piDataObject - the selected node.  This should be the root node
//								the snapin.
//  Output:		Returns S_OK on success
//
///////////////////////////////////////////////////////////////////////////////

//      1. Launch object picker and get new computer name
//      2. Change root node text
//      3. Save new computer name to persistent name
//      4. Delete subordinate nodes
//      5. Re-add subordinate nodes
HRESULT CMyComputerComponentData::OnChangeComputer(IDataObject * piDataObject)
{
	MFC_TRY;
	HWND    hWndParent = NULL;
	HRESULT	hr = m_pConsole->GetMainWindow (&hWndParent);
	CComBSTR sbstrTargetComputer;
	//
	// JonN 12/7/99 using CHOOSER2
	//
	if ( CHOOSER2_PickTargetComputer( AfxGetInstanceHandle(),
	                                  hWndParent,
	                                  &sbstrTargetComputer ) )
	{
		CString strTargetComputer = sbstrTargetComputer;
		strTargetComputer.MakeUpper ();

		// added IsLocalComputername 1/27/99 JonN
		// If the user chooses the local computer, treat that as if they had chosen
		// "Local Computer" in Snapin Manager.  This means that there is no way to
		// reset the snapin to target explicitly at this computer without either
		// reloading the snapin from Snapin Manager, or going to a different computer.
		// When the Choose Target Computer UI is revised, we can make this more
		// consistent with Snapin Manager.
		if ( IsLocalComputername( strTargetComputer ) )
			strTargetComputer = L"";

		QueryRootCookie().SetMachineName (strTargetComputer);

		// Set the persistent name.  If we are managing the local computer
		// this name should be empty.
		m_strMachineNamePersist = strTargetComputer;

		hr = ChangeRootNodeName (strTargetComputer);
		if ( SUCCEEDED(hr) )
		{
			// Delete subordinates and re-add
			HSCOPEITEM	hRootScopeItem = QueryBaseRootCookie ().m_hScopeItem;
			MMC_COOKIE	lCookie = 0;
			HSCOPEITEM	hChild = 0;
							
			do {
				hr = m_pConsoleNameSpace->GetChildItem (hRootScopeItem,
						&hChild, &lCookie);
				if ( S_OK != hr )
					break;

				hr = m_pConsoleNameSpace->DeleteItem (hChild, TRUE);
				ASSERT (SUCCEEDED (hr));
				if ( !SUCCEEDED(hr) )
					break;

				CMyComputerCookie* pCookie =
						reinterpret_cast <CMyComputerCookie*> (lCookie);
				if ( !pCookie )
					continue;

				CMyComputerCookie&	rootCookie = QueryRootCookie();
				POSITION			pos1 = 0;
				POSITION			pos2 = 0;
				CBaseCookieBlock*	pScopeCookie = 0;

				for ( pos1 = rootCookie.m_listScopeCookieBlocks.GetHeadPosition ();
					  ( pos2 = pos1) != NULL;
											   )
				{
					pScopeCookie = rootCookie.m_listScopeCookieBlocks.GetNext (pos1);
					ASSERT (pScopeCookie);
					if ( pScopeCookie == pCookie )
					{
						rootCookie.m_listScopeCookieBlocks.RemoveAt (pos2);
						pScopeCookie->Release ();
					}
				}
			} while (S_OK == hr);

			hr = AddScopeNodes (hRootScopeItem, QueryRootCookie ());
			hr = m_pConsole->UpdateAllViews (piDataObject, 0, HINT_SELECT_ROOT_NODE);
		}
	}

	return hr;
	MFC_CATCH;
}

///////////////////////////////////////////////////////////////////////////////
//
//	ChangeRootNodeName ()
//
//  Purpose:	Change the text of the root node
//
//	Input:		newName - the new machine name that the snapin manages
//  Output:		Returns S_OK on success
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CMyComputerComponentData::ChangeRootNodeName(const CString & newName)
{
	MFC_TRY;
	ASSERT (QueryBaseRootCookie ().m_hScopeItem);
	if ( !QueryBaseRootCookie ().m_hScopeItem )
		return E_UNEXPECTED;

	CString		machineName (newName);
	CString		formattedName = FormatDisplayName (machineName);


	SCOPEDATAITEM	item;
	::ZeroMemory (&item, sizeof (SCOPEDATAITEM));
	item.mask = SDI_STR;
	item.displayname = (LPTSTR) (LPCTSTR) formattedName;
	item.ID = QueryBaseRootCookie ().m_hScopeItem;

	return m_pConsoleNameSpace->SetItem (&item);
	MFC_CATCH;
}


CString FormatDisplayName(CString machineName)
{
	CString	formattedName;

	// If strDisplayName is empty, then this manages the local machine.  Get
	// the local machine name.  Then format the computer name with the snapin
	// name
	if (machineName.IsEmpty())
	{
		VERIFY (formattedName.LoadString (IDS_SCOPE_MYCOMPUTER_LOCAL_MACHINE));
	}
	else
	{
		// strip off the leading whackWhack
		if ( machineName.Find (L"\\\\") == 0 )
		{
			machineName = machineName.GetBuffer (machineName.GetLength ()) + 2;
			machineName.ReleaseBuffer ();
		}
		machineName.MakeUpper ();
		formattedName.FormatMessage (IDS_SCOPE_MYCOMPUTER_ON_MACHINE, machineName);
	}


	return formattedName;
}


int DisplayNetMsgError (HWND hWndParent, const CString& computerName, NET_API_STATUS dwErr, CString& displayedMessage)
{
	int	retVal = IDNO;

	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	LPVOID	lpMsgBuf = 0;
	HMODULE hNetMsgDLL = ::LoadLibrary (L"netmsg.dll");
	if ( hNetMsgDLL )
	{
		::FormatMessage (
				FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
				hNetMsgDLL,
				dwErr,
				MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
				(LPTSTR) &lpMsgBuf, 0, NULL);
			
		// Display the string.
		CString	text;
		CString	caption;
	
		text.FormatMessage (IDS_CANT_CONNECT_TO_MACHINE, (LPCWSTR) computerName, (LPTSTR) lpMsgBuf);
		VERIFY (caption.LoadString (IDS_TASKPADTITLE_COMPUTER));

		retVal = ::MessageBox (hWndParent, text, caption, MB_ICONWARNING | MB_OK);

		displayedMessage = text;

		// Free the buffer.
		::LocalFree (lpMsgBuf);

		::FreeLibrary (hNetMsgDLL);
	}

	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\cookie.cpp ===
// Cookie.cpp : Implementation of CMyComputerCookie and related classes

#include "stdafx.h"
#include "cookie.h"

#include "atlimpl.cpp"

DECLARE_INFOLEVEL(MyComputerSnapin)

#include "macros.h"
USE_HANDLE_MACROS("MYCOMPUT(cookie.cpp)")

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "stdcooki.cpp"
#include <compuuid.h> // defines nodetypes for the My Computer snapin

//
// This is used by the nodetype utility routines in stdutils.cpp
//

const struct NODETYPE_GUID_ARRAYSTRUCT g_NodetypeGuids[MYCOMPUT_NUMTYPES] =
{
	{ // MYCOMPUT_COMPUTER
		structuuidNodetypeComputer,
		lstruuidNodetypeComputer    },
	{ // MYCOMPUT_SYSTEMTOOLS
		structuuidNodetypeSystemTools,
		lstruuidNodetypeSystemTools },
	{ // MYCOMPUT_SERVERAPPS
		structuuidNodetypeServerApps,
		lstruuidNodetypeServerApps  },
	{ // MYCOMPUT_STORAGE
		structuuidNodetypeStorage,
		lstruuidNodetypeStorage     }
};

const struct NODETYPE_GUID_ARRAYSTRUCT* g_aNodetypeGuids = g_NodetypeGuids;

const int g_cNumNodetypeGuids = MYCOMPUT_NUMTYPES;


//
// CMyComputerCookie
//

// returns <0, 0 or >0
HRESULT CMyComputerCookie::CompareSimilarCookies( CCookie* pOtherCookie, int* pnResult )
{
	ASSERT( NULL != pOtherCookie );

	CMyComputerCookie* pcookie = ((CMyComputerCookie*)pOtherCookie);
	if (m_objecttype != pcookie->m_objecttype)
	{
		*pnResult = ((int)m_objecttype) - ((int)pcookie->m_objecttype); // arbitrary ordering
		return S_OK;
	}

	return CHasMachineName::CompareMachineNames( *pcookie, pnResult );
}

CCookie* CMyComputerCookie::QueryBaseCookie(int i)
{
    UNREFERENCED_PARAMETER (i);
	ASSERT( i == 0 );
	return (CCookie*)this;
}

int CMyComputerCookie::QueryNumCookies()
{
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\compdata.h ===
/////////////////////////////////////////////////////////////////////
// compdata.h : Declaration of CMyComputerComponentData
//
// HISTORY
// 01-Jan-1996		???			Creation
// 03-Jun-1997		t-danm		Added Command Line override.  Copied
//								from ..\mmcfmgmt\compdata.h.
//
/////////////////////////////////////////////////////////////////////

#ifndef __COMPDATA_H_INCLUDED__
#define __COMPDATA_H_INCLUDED__

#include <lmcons.h>		// For Lan Manager API constants.
#include "stdcdata.h"	// CComponentData
#include "persist.h"	// PersistStream
#include "cookie.h"		// CMyComputerCookie
#include "resource.h"	// IDS_MYCOMPUT_DESC
#include "cmponent.h"	// LoadIconsIntoImageList

// Helper function to correctly format the node name
CString FormatDisplayName (CString machineName);

// For UpdateAllViews/OnViewChange
#define HINT_SELECT_ROOT_NODE	0x00000001

class CMyComputerComponentData:
   	public CComponentData,
   	public IExtendPropertySheet,
	public PersistStream,
    public CHasMachineName,
   	public IExtendContextMenu,
	public CComCoClass<CMyComputerComponentData, &CLSID_MyComputer>
{
public:

// Use DECLARE_NOT_AGGREGATABLE(CMyComputerComponentData)
// if you don't want your object to support aggregation
DECLARE_AGGREGATABLE(CMyComputerComponentData)
DECLARE_REGISTRY(CMyComputerComponentData, _T("MYCOMPUT.ComputerObject.1"), _T("MYCOMPUT.ComputerObject.1"), IDS_MYCOMPUT_DESC, THREADFLAGS_BOTH)

	CMyComputerComponentData();
	~CMyComputerComponentData();
BEGIN_COM_MAP(CMyComputerComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY_CHAIN(CComponentData)
END_COM_MAP()

#if DBG==1
	ULONG InternalAddRef()
	{
        return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
        return CComObjectRoot::InternalRelease();
	}
    int dbg_InstID;
#endif // DBG==1

// IComponentData
	STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
	STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);

// IExtendPropertySheet
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK pCall, LONG_PTR handle, LPDATAOBJECT pDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject);

// IPersistStream
	HRESULT STDMETHODCALLTYPE GetClassID(CLSID __RPC_FAR *pClassID)
	{
		*pClassID=CLSID_MyComputer;
		return S_OK;
	}
    HRESULT STDMETHODCALLTYPE Load(IStream __RPC_FAR *pStg);
    HRESULT STDMETHODCALLTYPE Save(IStream __RPC_FAR *pStgSave, BOOL fSameAsLoad);

	// needed for Initialize()
	virtual HRESULT LoadIcons(LPIMAGELIST pImageList, BOOL fLoadLargeIcons);

	// needed for Notify()
	virtual HRESULT OnNotifyExpand(LPDATAOBJECT lpDataObject, BOOL bExpanding, HSCOPEITEM hParent);
	HRESULT ExpandServerApps( HSCOPEITEM hParent, CMyComputerCookie* pcookie );

	// needed for GetDisplayInfo(), must be defined by subclass
	virtual BSTR QueryResultColumnText(CCookie& basecookieref, int nCol );
	virtual int QueryImage(CCookie& basecookieref, BOOL fOpenImage);

	virtual CCookie& QueryBaseRootCookie();

	inline CMyComputerCookie* ActiveCookie( CCookie* pBaseCookie )
	{
		return (CMyComputerCookie*)ActiveBaseCookie( pBaseCookie );
	}

	inline CMyComputerCookie& QueryRootCookie() { return *m_pRootCookie; }

	virtual HRESULT OnNotifyDelete(LPDATAOBJECT lpDataObject);
	virtual HRESULT OnNotifyRelease(LPDATAOBJECT lpDataObject, HSCOPEITEM hItem);
	virtual HRESULT OnNotifyPreload(LPDATAOBJECT lpDataObject, HSCOPEITEM hRootScopeItem);

// CHasMachineName
	DECLARE_FORWARDS_MACHINE_NAME( m_pRootCookie )
	bool m_bCannotConnect;
	bool m_bMessageView;
	CString m_strMessageViewMsg;

protected:
	bool ValidateMachine(const CString &sName, bool bDisplayErr);
	HRESULT AddScopeNodes (HSCOPEITEM hParent, CMyComputerCookie& rParentCookie);
	HRESULT ChangeRootNodeName (const CString& newName);
	HRESULT OnChangeComputer (IDataObject* piDataObject);
	// The following members are used to support Command Line override.
	// This code was copied from ..\mmcfmgmt\compdata.h.

	enum	// Bit fields for m_dwFlagsPersist
		{
		mskfAllowOverrideMachineName = 0x0001
		};
	DWORD m_dwFlagsPersist;				// General-purpose flags to be persisted into .msc file
	CString m_strMachineNamePersist;	// Machine name to persist into .msc file
	BOOL m_fAllowOverrideMachineName;	// TRUE => Allow the machine name to be overriden by the command line
	
	void SetPersistentFlags(DWORD dwFlags)
		{
		m_dwFlagsPersist = dwFlags;
		m_fAllowOverrideMachineName = !!(m_dwFlagsPersist & mskfAllowOverrideMachineName);
		}

	DWORD GetPersistentFlags()
		{
		if (m_fAllowOverrideMachineName)
			m_dwFlagsPersist |= mskfAllowOverrideMachineName;
		else
			m_dwFlagsPersist &= ~mskfAllowOverrideMachineName;
		return m_dwFlagsPersist;
		}

// IExtendContextMenu
	STDMETHOD(AddMenuItems)(
                    IDataObject*          piDataObject,
					IContextMenuCallback* piCallback,
					long*                 pInsertionAllowed);
	STDMETHOD(Command)(
					LONG	        lCommandID,
                    IDataObject*    piDataObject );

private:
	CMyComputerCookie*	m_pRootCookie;

}; // CMyComputerComponentData

#endif // ~__COMPDATA_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\cookie.h ===
// cookie.h : Declaration of CMyComputerCookie and related classes

#ifndef __COOKIE_H_INCLUDED__
#define __COOKIE_H_INCLUDED__

extern HINSTANCE g_hInstanceSave;  // Instance handle of the DLL (initialized during CMyComputerComponent::Initialize)

#include "nodetype.h"

/////////////////////////////////////////////////////////////////////////////
// cookie

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

#include "stdcooki.h"

class CMyComputerCookie : public CCookie
                        , public CStoresMachineName
                        , public CBaseCookieBlock
{
public:
	CMyComputerCookie( MyComputerObjectType objecttype,
	                   LPCTSTR lpcszMachineName = NULL )
		: CStoresMachineName( lpcszMachineName )
		, m_objecttype( objecttype )
		, m_fRootCookieExpanded( false )
	{
	}

	// returns <0, 0 or >0
	virtual HRESULT CompareSimilarCookies( CCookie* pOtherCookie, int* pnResult );

// CBaseCookieBlock
	virtual CCookie* QueryBaseCookie(int i);
	virtual int QueryNumCookies();

public:
	MyComputerObjectType m_objecttype;

	// JonN 5/27/99: The System Tools and Storage nodes are automatically expanded
	// the first time the Computer node is shown (see IComponent::Show())
	bool m_fRootCookieExpanded;
};


#endif // ~__COOKIE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\cmponent.h ===
// cmponent.h : Declaration of CMyComputerComponent

#ifndef __CMPONENT_H_INCLUDED__
#define __CMPONENT_H_INCLUDED__

#include "stdcmpnt.h" // CComponent
#include "cookie.h"  // CMyComputerCookie
#include "persist.h" // PersistStream

// forward declarations
class CMyComputerComponentData;

class CMyComputerComponent :
	  public CComponent
	, public IMyComputer
	, public IExtendContextMenu
	, public PersistStream
{
public:
	CMyComputerComponent();
	virtual ~CMyComputerComponent();
BEGIN_COM_MAP(CMyComputerComponent)
	COM_INTERFACE_ENTRY(IMyComputer)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY_CHAIN(CComponent)
END_COM_MAP()

#if DBG==1
	ULONG InternalAddRef()
	{
        return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
        return CComObjectRoot::InternalRelease();
	}
    int dbg_InstID;
#endif // DBG==1

// IFileServiceMgmt

// IComponent implemented in CComponent
    HRESULT OnViewChange (LPDATAOBJECT pDataObject, LPARAM data, LPARAM hint);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie, LPOLESTR* ppViewType, long* pViewOptions);

// IExtendContextMenu
	STDMETHOD(AddMenuItems)(
                    IDataObject*          piDataObject,
					IContextMenuCallback* piCallback,
					long*                 pInsertionAllowed);
	STDMETHOD(Command)(
					LONG	        lCommandID,
                    IDataObject*    piDataObject );

	void ExpandAndSelect( MyComputerObjectType objecttype );
	void LaunchWelcomeApp();

// IPersistStream
	HRESULT STDMETHODCALLTYPE GetClassID(CLSID __RPC_FAR *pClassID)
	{
		*pClassID=CLSID_MyComputer;
		return S_OK;
	}
    HRESULT STDMETHODCALLTYPE Load(IStream __RPC_FAR *pStg);
    HRESULT STDMETHODCALLTYPE Save(IStream __RPC_FAR *pStgSave, BOOL fSameAsLoad);


	// support methods for IComponent
	virtual HRESULT OnNotifySelect( LPDATAOBJECT lpDataObject, BOOL fSelected );
	virtual HRESULT ReleaseAll();
	virtual HRESULT Show(CCookie* pcookie, LPARAM arg, HSCOPEITEM hScopeItem);
	virtual HRESULT OnNotifyAddImages( LPDATAOBJECT lpDataObject,
	                                   LPIMAGELIST lpImageList,
	                                   HSCOPEITEM hSelectedItem );
	virtual HRESULT OnNotifySnapinHelp (LPDATAOBJECT pDataObject);

	HRESULT PopulateListbox(CMyComputerCookie* pcookie);
//	HRESULT PopulateServices(CMyComputerCookie* pcookie);

//	HRESULT AddServiceItems(CMyComputerCookie* pParentCookie, ENUM_SERVICE_STATUS * rgESS, DWORD nDataItems);

//	HRESULT EnumerateScopeChildren(CMyComputerCookie* pParentCookie, HSCOPEITEM hParent);

//	HRESULT LoadIcons();
	static HRESULT LoadStrings();
    HRESULT LoadColumns( CMyComputerCookie* pcookie );

	// support methods for IPersistStream
	enum	// Bit fields for m_dwFlagsPersist
		{
		// mskfFirst = 0x0001
		};
	DWORD m_dwFlagsPersist;				// General-purpose flags to be persisted into .msc file
	void SetPersistentFlags(DWORD dwFlags)
		{
		m_dwFlagsPersist = dwFlags;
		}

	DWORD GetPersistentFlags()
		{
		return m_dwFlagsPersist;
		}

	CMyComputerComponentData& QueryComponentDataRef()
	{
		return (CMyComputerComponentData&)QueryBaseComponentDataRef();
	}

public:
	LPCONTROLBAR	m_pControlbar; // CODEWORK should use smartpointer
	LPTOOLBAR		m_pSvcMgmtToolbar; // CODEWORK should use smartpointer
	LPTOOLBAR		m_pMyComputerToolbar; // CODEWORK should use smartpointer
	CMyComputerCookie* m_pViewedCookie; // CODEWORK I hate to have to do this...
	static const GUID m_ObjectTypeGUIDs[MYCOMPUT_NUMTYPES];
	static const BSTR m_ObjectTypeStrings[MYCOMPUT_NUMTYPES];

private:
	bool m_bForcingGetResultType;
}; // class CMyComputerComponent


// Enumeration for the icons used
enum
	{
	iIconComputer = 0,			// Root of the snapin
	iIconComputerFail,			// Root of the snapin when we cannot connect to the computer
	iIconSystemTools,			// System Tools
	iIconStorage,				// Storage
	iIconServerApps,			// Server Applications

	iIconLast		// Must be last
	};

typedef enum _COLNUM_COMPUTER {
	COLNUM_COMPUTER_NAME = 0
} COLNUM_ROOT;

HRESULT LoadIconsIntoImageList(LPIMAGELIST pImageList, BOOL fLoadLargeIcons);

#endif // ~__CMPONENT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\dataobj.h ===
// DataObj.h : Declaration of the data object classes

#ifndef __DATAOBJ_H_INCLUDED__
#define __DATAOBJ_H_INCLUDED__

#include "cookie.h" // CMyComputerCookie
#include "stddtobj.h" // class DataObject

class CMyComputerDataObject : public CDataObject
{
	DECLARE_NOT_AGGREGATABLE(CMyComputerDataObject)

public:

// debug refcount
#if DBG==1
	ULONG InternalAddRef()
	{
        return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
        return CComObjectRoot::InternalRelease();
	}
    int dbg_InstID;
#endif // DBG==1

	CMyComputerDataObject()
		: m_pcookie( NULL )
		, m_objecttype( MYCOMPUT_COMPUTER )
		, m_dataobjecttype( CCT_UNINITIALIZED )
	{
	}

	~CMyComputerDataObject();

	virtual HRESULT Initialize( CMyComputerCookie* pcookie, DATA_OBJECT_TYPES type, BOOL fAllowOverrideMachineName );

	// IDataObject interface implementation
    HRESULT STDMETHODCALLTYPE GetDataHere(
		FORMATETC __RPC_FAR *pFormatEtcIn,
        STGMEDIUM __RPC_FAR *pMedium);
	
	//#define __DAN_MORIN_HARDCODED_CONTEXT_MENU_EXTENSION__
    HRESULT STDMETHODCALLTYPE GetData(
		FORMATETC __RPC_FAR *pFormatEtcIn,
        STGMEDIUM __RPC_FAR *pMedium);

    HRESULT PutDisplayName(STGMEDIUM* pMedium);
	HRESULT PutServiceName(STGMEDIUM* pMedium);

protected:
	CMyComputerCookie* m_pcookie; // the CCookieBlock is AddRef'ed for the life of the DataObject
	MyComputerObjectType m_objecttype;
	DATA_OBJECT_TYPES m_dataobjecttype;
	BOOL m_fAllowOverrideMachineName;	// From CMyComputerComponentData

public:
	// Clipboard formats
	static CLIPFORMAT m_CFDisplayName;
	static CLIPFORMAT m_CFMachineName;
//	static CLIPFORMAT m_cfSendConsoleMessageText;
	static CLIPFORMAT m_cfSendConsoleMessageRecipients;

}; // CMyComputerDataObject

#endif // ~__DATAOBJ_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\dataobj.cpp ===
// DataObj.cpp : Implementation of data object classes

#include "stdafx.h"
#include "stdutils.h" // GetObjectType() utility routines

#include "macros.h"
USE_HANDLE_MACROS("MYCOMPUT(dataobj.cpp)")

#include "dataobj.h"
#include "compdata.h"
#include "resource.h" // IDS_SCOPE_MYCOMPUTER

#include <comstrm.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#include "stddtobj.cpp"

#ifdef __DAN_MORIN_HARDCODED_CONTEXT_MENU_EXTENSION__
//	Additional clipboard formats for the Service context menu extension
CLIPFORMAT g_cfServiceName = (CLIPFORMAT)::RegisterClipboardFormat(L"FILEMGMT_SNAPIN_SERVICE_NAME");
CLIPFORMAT g_cfServiceDisplayName = (CLIPFORMAT)::RegisterClipboardFormat(L"FILEMGMT_SNAPIN_SERVICE_DISPLAYNAME");
#endif // __DAN_MORIN_HARDCODED_CONTEXT_MENU_EXTENSION__

//	Additional clipboard formats for the Send Console Message snapin
//CLIPFORMAT CMyComputerDataObject::m_cfSendConsoleMessageText = (CLIPFORMAT)::RegisterClipboardFormat(_T("mmc.sendcmsg.MessageText"));
CLIPFORMAT CMyComputerDataObject::m_cfSendConsoleMessageRecipients = (CLIPFORMAT)::RegisterClipboardFormat(_T("mmc.sendcmsg.MessageRecipients"));


/////////////////////////////////////////////////////////////////////
//	CMyComputerDataObject::IDataObject::GetDataHere()
HRESULT CMyComputerDataObject::GetDataHere(
	FORMATETC __RPC_FAR *pFormatEtcIn,
	STGMEDIUM __RPC_FAR *pMedium)
{
	MFC_TRY;

	const CLIPFORMAT cf=pFormatEtcIn->cfFormat;
	if (cf == m_CFNodeType)
	{
		const GUID* pguid = GetObjectTypeGUID( m_pcookie->m_objecttype );
		stream_ptr s(pMedium);
		return s.Write(pguid, sizeof(GUID));
	}
	else if (cf == m_CFSnapInCLSID)
	{
		const GUID* pguid = &CLSID_MyComputer;
		stream_ptr s(pMedium);
		return s.Write(pguid, sizeof(GUID));
	}
	else if (cf == m_CFNodeTypeString)
	{
		const BSTR strGUID = GetObjectTypeString( m_pcookie->m_objecttype );
		stream_ptr s(pMedium);
		return s.Write(strGUID);
	}
	else if (cf == m_CFDisplayName)
	{
		return PutDisplayName(pMedium);
	}
	else if (cf == m_CFDataObjectType)
	{
		stream_ptr s(pMedium);
		return s.Write(&m_dataobjecttype, sizeof(m_dataobjecttype));
	}
	else if (cf == m_CFMachineName)
	{
		stream_ptr s(pMedium);
		LPCWSTR pszMachineName = m_pcookie->QueryNonNULLMachineName();

		if ( !wcsncmp (pszMachineName, L"\\\\", 2) )
			pszMachineName += 2;	// skip whackwhack
		return s.Write(pszMachineName);
	}
	else if (cf == m_CFRawCookie)
	{
		stream_ptr s(pMedium);
		// CODEWORK This cast ensures that the data format is
		// always a CCookie*, even for derived subclasses
		CCookie* pcookie = (CCookie*)m_pcookie;
		return s.Write(reinterpret_cast<PBYTE>(&pcookie), sizeof(m_pcookie));
	}
	else if (cf == m_CFSnapinPreloads)
	{
		stream_ptr s(pMedium);
		// If this is TRUE, then the next time this snapin is loaded, it will
		// be preloaded to give us the opportunity to change the root node
		// name before the user sees it.
		return s.Write (reinterpret_cast<PBYTE>(&m_fAllowOverrideMachineName), sizeof (BOOL));
	}
		
	#ifdef __DAN_MORIN_HARDCODED_CONTEXT_MENU_EXTENSION__
	else if (cf == g_cfServiceName)
	{
		CString str = _T("alerter");
		stream_ptr s(pMedium);
		return s.Write(str);
	}
	else if (cf == g_cfServiceDisplayName)
	{
		CString str = _T("Alerter!");
		stream_ptr s(pMedium);
		return s.Write(str);
	}
	#endif // __DAN_MORIN_HARDCODED_CONTEXT_MENU_EXTENSION__

	return DV_E_FORMATETC;

	MFC_CATCH;
} // CMyComputerDataObject::GetDataHere()

//#ifdef __DAN_MORIN_HARDCODED_CONTEXT_MENU_EXTENSION__


/////////////////////////////////////////////////////////////////////
//	CMyComputerDataObject::IDataObject::GetData()
//
//	Write data into the storage medium.
//	The data will be retrieved by the Send Console Message snapin.
//
//	HISTORY
//	12-Aug-97	t-danm		Creation.
//
HRESULT
CMyComputerDataObject::GetData(
	FORMATETC __RPC_FAR * pFormatEtcIn,
	STGMEDIUM __RPC_FAR * pMedium)
{
	ASSERT(pFormatEtcIn != NULL);
	ASSERT(pMedium != NULL);
	const CLIPFORMAT cf = pFormatEtcIn->cfFormat;
/*
	if (cf == g_cfSendConsoleMessageText)
	{
		//
		// Write the message text into the storage medium.
		// - The text must be in UINCODE.
		// - The text must terminate by a null character.
		// - Multiple lines can be made using the CRLF ("\n\r") pair.
		// - Allocated memory must include null character.
		//
		const WCHAR szMessage[] =
			L"The domain controller \\\\DANMORIN will crash in about 5 minutes.\r\nPlease disconnect now!";
		HGLOBAL hGlobal = GlobalAlloc(GMEM_FIXED, sizeof(szMessage));
		if (hGlobal == NULL)
			return E_OUTOFMEMORY;
		memcpy(OUT hGlobal, IN szMessage, sizeof(szMessage));
		pMedium->hGlobal = hGlobal;
		return S_OK;
	}
*/
	if (cf == m_cfSendConsoleMessageRecipients)
	{
		//
		// Write the list of recipients to the storage medium.
		// - The list of recipients is a group of UNICODE strings
		//	 terminated by TWO null characters.c
		// - Allocated memory must include BOTH null characters.
		//
		ASSERT (m_pcookie);
		if ( m_pcookie )
		{
			CString	computerName = m_pcookie->QueryNonNULLMachineName ();
			if ( computerName.IsEmpty () )
			{
				DWORD	dwSize = MAX_COMPUTERNAME_LENGTH + 1 ;
				VERIFY (::GetComputerName (
						computerName.GetBufferSetLength (dwSize),
						&dwSize));
				computerName.ReleaseBuffer ();
			}
			size_t	len = computerName.GetLength () + 2;
			WCHAR* pgrszRecipients = new WCHAR[len];
			if ( pgrszRecipients )
			{
				::ZeroMemory (pgrszRecipients, len * sizeof (WCHAR));
				wcscpy (pgrszRecipients, (LPCTSTR) computerName);	// this should leave two NULLS
				HGLOBAL hGlobal = ::GlobalAlloc (GMEM_FIXED, len * sizeof (WCHAR));
				if ( hGlobal )
				{
					memcpy (OUT hGlobal, pgrszRecipients, len * sizeof (WCHAR));
					pMedium->hGlobal = hGlobal;
					return S_OK;
				}
				else
					return E_OUTOFMEMORY;
				delete [] pgrszRecipients;
			}
			else
				return E_OUTOFMEMORY;
		}
		else
			return E_UNEXPECTED;
/*
		const WCHAR grszRecipients[] = L"FooBar\0t-danm\0t-danm-2\0ZooBar\0";
		HGLOBAL hGlobal = GlobalAlloc(GMEM_FIXED, sizeof(grszRecipients));
		if (hGlobal == NULL)
			return E_OUTOFMEMORY;
		memcpy(OUT hGlobal, IN grszRecipients, sizeof(grszRecipients));
		pMedium->hGlobal = hGlobal;
		return S_OK;
*/
	}
	return DV_E_FORMATETC;	// Invalid/unknown clipboard format
} // CMyComputerDataObject::GetData()

//#endif // __DAN_MORIN_HARDCODED_CONTEXT_MENU_EXTENSION__


HRESULT CMyComputerDataObject::Initialize(
	CMyComputerCookie* pcookie,
	DATA_OBJECT_TYPES type,
	BOOL fAllowOverrideMachineName)
{
	if (NULL == pcookie || NULL != m_pcookie)
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}
	m_dataobjecttype = type;
	m_pcookie = pcookie;
	m_fAllowOverrideMachineName = fAllowOverrideMachineName;
	((CRefcountedObject*)m_pcookie)->AddRef();
	return S_OK;
}


CMyComputerDataObject::~CMyComputerDataObject()
{
	if (NULL != m_pcookie)
	{
		((CRefcountedObject*)m_pcookie)->Release();
	}
	else
	{
		ASSERT(FALSE);
	}
}


HRESULT CMyComputerDataObject::PutDisplayName(STGMEDIUM* pMedium)
	// Writes the "friendly name" to the provided storage medium
	// Returns the result of the write operation
{
	CString strDisplayName = m_pcookie->QueryTargetServer();
	CString formattedName = FormatDisplayName (strDisplayName);


	stream_ptr s(pMedium);
	return s.Write(formattedName);
}

// Register the clipboard formats
CLIPFORMAT CMyComputerDataObject::m_CFDisplayName =
	(CLIPFORMAT)RegisterClipboardFormat(CCF_DISPLAY_NAME);
CLIPFORMAT CMyComputerDataObject::m_CFMachineName =
	(CLIPFORMAT)RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");
CLIPFORMAT CDataObject::m_CFRawCookie =
	(CLIPFORMAT)RegisterClipboardFormat(L"MYCOMPUT_SNAPIN_RAW_COOKIE");


STDMETHODIMP CMyComputerComponentData::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
	MFC_TRY;

	CMyComputerCookie* pUseThisCookie = (CMyComputerCookie*)ActiveBaseCookie(reinterpret_cast<CCookie*>(cookie));

	CComObject<CMyComputerDataObject>* pDataObject = NULL;
	HRESULT hRes = CComObject<CMyComputerDataObject>::CreateInstance(&pDataObject);
	if ( FAILED(hRes) )
		return hRes;

	HRESULT hr = pDataObject->Initialize( pUseThisCookie, type, m_fAllowOverrideMachineName);
	if ( SUCCEEDED(hr) )
	{
		hr = pDataObject->QueryInterface(IID_IDataObject,
		                                 reinterpret_cast<void**>(ppDataObject));
	}
	if ( FAILED(hr) )
	{
		delete pDataObject;
		return hr;
	}

	return hr;

	MFC_CATCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\dbg.h ===
#include "StdDbg.h"

#if DBG==1
    DECLARE_DEBUG(MyComputerSnapin)
    #define DBG_COMP    MyComputerSnapinInfoLevel
#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\makefile.inc ===
!include ..\..\makefile.inc

$(O)\MYCOMPUT.res: resource.h mycomput.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\mycomput.cpp ===
// MyComput.cpp : Implementation of DLL Exports.


#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "MyComput.h"
#include "regkey.h" // AMC::CRegKey
#include "strings.h" // SNAPINS_KEY
#include "guidhelp.h" // GuidToCString
#include "macros.h" // MFC_TRY/MFC_CATCH
#include "stdutils.h" // g_aNodetypeGuids
#include "MyComput_i.c"
#include "about.h"		// CComputerMgmtAbout

#include "compdata.h" // CMyComputerComponentData
#include "snapreg.h" // RegisterSnapin

USE_HANDLE_MACROS("MYCOMPUT(MyComput.cpp)")                                        \

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_MyComputer, CMyComputerComponentData)
	OBJECT_ENTRY(CLSID_ComputerManagementAbout, CComputerMgmtAbout)
END_OBJECT_MAP()

class CMyComputApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CMyComputApp theApp;

BOOL CMyComputApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	return CWinApp::InitInstance();
}

int CMyComputApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	MFC_TRY;

	HRESULT hr = S_OK;
	// registers object, typelib and all interfaces in typelib
	hr = _Module.RegisterServer(TRUE);

	CString strMyComputerCLSID, strMyComputerAboutCLSID;
	if (   FAILED(hr = GuidToCString( &strMyComputerCLSID, CLSID_MyComputer ))
	    || FAILED(hr = GuidToCString( &strMyComputerAboutCLSID, CLSID_ComputerManagementAbout ))
	   )
	{
		ASSERT(FALSE && "GuidToCString() failure");
		return SELFREG_E_CLASS;
	}

	try
	{
		AMC::CRegKey regkeySnapins;
		BOOL fFound = regkeySnapins.OpenKeyEx( HKEY_LOCAL_MACHINE, SNAPINS_KEY );
		if ( !fFound )
		{
			ASSERT(FALSE && "DllRegisterServer() - Unable to open key from registry.");
			return SELFREG_E_CLASS;
		}

		static int mycomput_types[4] = 
			{ MYCOMPUT_COMPUTER,
			  MYCOMPUT_SYSTEMTOOLS,
			  MYCOMPUT_SERVERAPPS,
			  MYCOMPUT_STORAGE };
		hr = RegisterSnapin( regkeySnapins,
		                     strMyComputerCLSID,
		                     g_aNodetypeGuids[MYCOMPUT_COMPUTER].bstr,
		                     IDS_REGISTER_MYCOMPUT,
		                     IDS_SNAPINABOUT_PROVIDER,
		                     IDS_SNAPINABOUT_VERSION,
		                     true,
		                     strMyComputerAboutCLSID,
		                     mycomput_types,
		                     4 );
		if ( FAILED(hr) )
		{
			ASSERT(FALSE);
			return SELFREG_E_CLASS;
		}

		AMC::CRegKey regkeyNodeTypes;
		fFound = regkeyNodeTypes.OpenKeyEx( HKEY_LOCAL_MACHINE, NODE_TYPES_KEY );
		if ( !fFound )
		{
			ASSERT(FALSE);
			return SELFREG_E_CLASS;
		}
		AMC::CRegKey regkeyNodeType;
		for (int i = MYCOMPUT_COMPUTER; i < MYCOMPUT_NUMTYPES; i++)
		{
			regkeyNodeType.CreateKeyEx( regkeyNodeTypes, g_aNodetypeGuids[i].bstr );
			regkeyNodeType.CloseKey();
		}
	}
    catch (COleException* e)
    {
		ASSERT(FALSE);
        e->Delete();
		return SELFREG_E_CLASS;
    }

	return hr;

	MFC_CATCH;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\dynexten.cpp ===
/////////////////////////////////////////////////////////////////////
// DynExten.cpp : enumerates installed services on (possibly remote) computer
//
// HISTORY
// 30-Oct-97	JonN		Creation.
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "macros.h"
USE_HANDLE_MACROS("MMCFMGMT(dynexten.cpp)")

#include "compdata.h"
#include "cookie.h"
#include "regkey.h" // AMC::CRegKey

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const TCHAR SERVICES_KEY[] = TEXT("System\\CurrentControlSet\\Control\\Server Applications");
const TCHAR CLSID_KEY[] = TEXT("Clsid\\");


HRESULT DynextenCheckInstall( const GUID& guidExtension, const TCHAR* pszExtension )
{
    HRESULT hr = S_OK;
#ifdef USE_CLASS_STORE
    IClassAccess* pIClassAccess = NULL;
#endif
    try
    {
        TCHAR achRegPath[ MAX_PATH ];
        _tcscpy( achRegPath, CLSID_KEY );
        _tcsncat( achRegPath, pszExtension, MAX_PATH - _tcslen(achRegPath) );
        achRegPath[MAX_PATH-1] = TEXT('\0'); // JonN 11/21/00 PREFIX 226785/226786

        AMC::CRegKey regkeyInstalled;
        BOOL fFound = regkeyInstalled.OpenKeyEx( HKEY_CLASSES_ROOT, achRegPath, KEY_READ );
        if ( fFound )
        {
            return S_OK; // it is already installed
        }

// CODEWORK It would be more efficient to access the Class Store directly
// by calling CoGetClassAccess, then IClassAccess->GetAppInfo(), then CoInstall().
#ifdef USE_CLASS_STORE
        // now we have to get the Class Store to install it
        do { // false loop
            hr = CoGetClassAccess( &pIClassAccess );
            if ( FAILED(hr) )
                break;

            // now what???

        } while (FALSE); // false loop
#else
		IUnknown* pIUnknown = NULL;
		hr = ::CoCreateInstance( guidExtension,
		                         NULL,
                                         CLSCTX_INPROC,
                                         IID_IComponentData,
                                         (PVOID*)&pIUnknown );
		if (NULL != pIUnknown)
			pIUnknown->Release();
		// allow hr to fall through
#endif
    }
    catch (COleException* e)
    {
        e->Delete();
        return E_FAIL;
    }

#ifdef USE_CLASS_STORE
	if (NULL != pIClassAccess)
		pIClassAccess->Release();
#endif

    return hr;
}


//
// CMyComputerComponentData
//

static CLSID CLSID_DnsSnapin =
{ 0x80105023, 0x50B1, 0x11d1, { 0xB9, 0x30, 0x00, 0xA0, 0xC9, 0xA0, 0x6D, 0x2D } };

static CLSID CLSID_FileServiceManagementExt =	{0x58221C69,0xEA27,0x11CF,{0xAD,0xCF,0x00,0xAA,0x00,0xA8,0x00,0x33}};

HRESULT CMyComputerComponentData::ExpandServerApps(
	HSCOPEITEM hParent,
	CMyComputerCookie* pcookie )

{
	try
	{
		AMC::CRegKey regkeyServices;
		BOOL fFound = TRUE;
		if (NULL == pcookie->QueryTargetServer())
		{
			fFound = regkeyServices.OpenKeyEx( HKEY_LOCAL_MACHINE, SERVICES_KEY, KEY_READ );
		}
		else
		{
			AMC::CRegKey regkeyRemoteComputer;
			regkeyRemoteComputer.ConnectRegistry(
			  const_cast<LPTSTR>(pcookie->QueryTargetServer()) );
			fFound = regkeyServices.OpenKeyEx( regkeyRemoteComputer, SERVICES_KEY, KEY_READ );
		}
		if ( !fFound )
		{
			return S_OK; // CODEWORK what return code?
		}
		CComQIPtr<IConsoleNameSpace2, &IID_IConsoleNameSpace2> pIConsoleNameSpace2
			= m_pConsole;
		if ( !pIConsoleNameSpace2 )
		{
			ASSERT(FALSE);
			return E_UNEXPECTED;
		}
		TCHAR achValue[ MAX_PATH ];
		DWORD iSubkey;
		DWORD cchValue;
		for ( iSubkey = 0;
			  cchValue = sizeof(achValue)/sizeof(TCHAR),
			  regkeyServices.EnumValue(
				iSubkey,
				achValue,
				&cchValue );
			  iSubkey++ )
		{
            GUID guidExtension;
			HRESULT hr = ::CLSIDFromString( achValue, &guidExtension );
			if ( !SUCCEEDED(hr) )
				continue;
            hr = DynextenCheckInstall( guidExtension, achValue );
			if ( !SUCCEEDED(hr) )
				continue;
			hr = pIConsoleNameSpace2->AddExtension( hParent, &guidExtension );
			// ignore the return value
		}
	}
    catch (COleException* e)
    {
        e->Delete();
		return S_OK; // CODEWORK what return code?
    }
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mycomput.rc
//
#define IDS_PROJNAME                    100
#define IDS_MYCOMPUT_DESC               101
#define IDS_TITLE_ERROR                 103
#define IDS_TITLE_WARNING               104
#define IDS_COLUMN_NAME                 105
#define IDS_COLUMN_TYPE                 109
#define IDS_COLUMN_DESCRIPTION          110
#define IDS_ERROR_INVALID_COMPUTERNAME  111
#define IDS_SNAPINABOUT_PROVIDER        180
#define IDS_SNAPINABOUT_VERSION         181
#define IDS_SNAPINABOUT_DESCRIPTION     182
#define IDS_SCOPE_SYSTEMTOOLS           190
#define IDS_SCOPE_SERVERAPPS            191
#define IDS_SCOPE_STORAGE               192
#define IDS_SCOPE_MYCOMPUTER            193
#define IDS_SCOPE_MYCOMPUTER_ON_MACHINE 194
#define IDS_TASKPADTITLE_COMPUTER       203
#define IDI_SYSTEMTOOLS                 201
#define IDI_SERVERAPPS                  203
#define IDI_COMPUTER                    204
#define IDI_COMPFAIL                    205
#define IDB_COMPUTER_LARGE              218
#define IDB_COMPUTER_SMALL              219
#define IDI_STORAGE                     222
#define IDM_CHANGE_COMPUTER_TOP         251
#define IDS_SCOPE_MYCOMPUTER_LOCAL_MACHINE 252
#define IDS_CANT_CONNECT_TO_MACHINE     253
#define IDS_CANT_CONNECT_TO_MACHINE_NETWORK_UNREACHABLE 254
#define IDS_CANT_CONNECT_TO_MACHINE_NETNAME_DELETED 255
#define IDM_CHANGE_COMPUTER_TASK        256
#define IDS_CANT_CONNECT_TO_NON_NT_COMPUTER 257
#define IDS_REGISTER_MYCOMPUT           300
#define IDS_SHELL_MANAGE_VERB           400
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        223
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\snapmgr.cpp ===
// SnapMgr.cpp : implementation file for Snapin Manager property page
//

#include "stdafx.h"

#include "chooser.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\persist.cpp ===
// Persist.cpp : Implementation of persistence
//
// HISTORY
// 01-Jan-1996	???			Creation
// 03-Jun-1997	t-danm		Added a version number to storage and
//							Command Line override.
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "compdata.h"
#include "safetemp.h"
#include "stdutils.h" // IsLocalComputername

#include "macros.h"
USE_HANDLE_MACROS("MYCOMPUT(persist.cpp)")

#include <comstrm.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

LPCTSTR PchGetMachineNameOverride();	// Defined in chooser.cpp

/////////////////////////////////////////////////
//	The _dwMagicword is the internal version number.
//	Increment this number if you makea file format change.
#define _dwMagicword	10001


// IComponentData persistence (remember persistent flags and target computername

/////////////////////////////////////////////////////////////////////
STDMETHODIMP CMyComputerComponentData::Load(IStream __RPC_FAR *pIStream)
{
	MFC_TRY;
	HRESULT hr;

#ifndef DONT_PERSIST_COMPONENT_DATA
	ASSERT( NULL != pIStream );
	XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

	// Read the magic word from the stream
	DWORD dwMagicword;
	hr = pIStream->Read( OUT &dwMagicword, sizeof(dwMagicword), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	if (dwMagicword != _dwMagicword)
	{
		// We have a version mismatch
		TRACE0("INFO: CMyComputerComponentData::Load() - Wrong Magicword.  You need to re-save your .msc file.\n");
		return E_FAIL;
	}

	// read flags from stream
	DWORD dwFlags;
	hr = pIStream->Read( OUT &dwFlags, sizeof(dwFlags), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	SetPersistentFlags(dwFlags);

	// read server name from stream
	DWORD dwLen = 0;
	hr = pIStream->Read( &dwLen, 4, NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	ASSERT( dwLen <= MAX_PATH*sizeof(WCHAR) );
	LPCWSTR lpwcszMachineName = (LPCWSTR)alloca( dwLen );
	// allocated from stack, we don't need to free
	if (NULL == lpwcszMachineName)
	{
		AfxThrowMemoryException();
		return E_OUTOFMEMORY;
	}
	hr = pIStream->Read( (PVOID)lpwcszMachineName, dwLen, NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}

	m_strMachineNamePersist = lpwcszMachineName;
	LPCTSTR pszMachineNameT = PchGetMachineNameOverride();
	if (m_fAllowOverrideMachineName && pszMachineNameT != NULL)
	{
		// Allow machine name override
	}
	else
	{
		pszMachineNameT = lpwcszMachineName;
	}

	// JonN 1/27/99: If the persisted name is the local computername,
	// leave the persisted name alone but make the effective name (Local).
	if ( IsLocalComputername(pszMachineNameT) )
		pszMachineNameT = L"";

	QueryRootCookie().SetMachineName(pszMachineNameT);
#endif

	return S_OK;

	MFC_CATCH;
}


/////////////////////////////////////////////////////////////////////
STDMETHODIMP CMyComputerComponentData::Save(IStream __RPC_FAR *pIStream, BOOL /*fSameAsLoad*/)
{
	MFC_TRY;
	HRESULT hr;

#ifndef DONT_PERSIST_COMPONENT_DATA
	ASSERT( NULL != pIStream );
	XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

	// Store the magic word to the stream
	DWORD dwMagicword = _dwMagicword;
	hr = pIStream->Write( IN &dwMagicword, sizeof(dwMagicword), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}

	DWORD dwFlags = GetPersistentFlags();
	hr = pIStream->Write( IN &dwFlags, sizeof(dwFlags), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}

	LPCWSTR lpwcszMachineName = m_strMachineNamePersist;
	DWORD dwLen = (DWORD) (::wcslen(lpwcszMachineName)+1)*sizeof(WCHAR);
	ASSERT( 4 == sizeof(DWORD) );
	hr = pIStream->Write( &dwLen, sizeof (DWORD), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	hr = pIStream->Write( lpwcszMachineName, dwLen, NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
#endif

	return S_OK;

	MFC_CATCH;
}


// IComponent persistence

/////////////////////////////////////////////////////////////////////
STDMETHODIMP CMyComputerComponent::Load(IStream __RPC_FAR *pIStream)
{
	MFC_TRY;
	HRESULT hr;

#ifndef DONT_PERSIST_COMPONENT
	ASSERT( NULL != pIStream );
	XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

	// Read the magic word from the stream
	DWORD dwMagicword;
	hr = pIStream->Read( OUT &dwMagicword, sizeof(dwMagicword), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	if (dwMagicword != _dwMagicword)
	{
		// We have a version mismatch
		TRACE0("INFO: CMyComputerComponentData::Load() - Wrong Magicword.  You need to re-save your .msc file.\n");
		return E_FAIL;
	}

	// read flags from stream
	DWORD dwFlags;
	hr = pIStream->Read( OUT &dwFlags, sizeof(dwFlags), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	SetPersistentFlags(dwFlags);
#endif

	return S_OK;

	MFC_CATCH;
}


/////////////////////////////////////////////////////////////////////
STDMETHODIMP CMyComputerComponent::Save(IStream __RPC_FAR *pIStream, BOOL /*fSameAsLoad*/)
{
	MFC_TRY;
	HRESULT hr;

#ifndef DONT_PERSIST_COMPONENT
	ASSERT( NULL != pIStream );
	XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

	// Store the magic word to the stream
	DWORD dwMagicword = _dwMagicword;
	hr = pIStream->Write( IN &dwMagicword, sizeof(dwMagicword), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}

	DWORD dwFlags = GetPersistentFlags();
	hr = pIStream->Write( IN &dwFlags, sizeof(dwFlags), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
#endif

	return S_OK;

	MFC_CATCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\nodetype.h ===
// nodetype.h : Declaration of MyComputerObjectType

#ifndef __NODETYPE_H_INCLUDED__
#define __NODETYPE_H_INCLUDED__

// Also note that the IDS_DISPLAYNAME_* and IDS_DISPLAYNAME_*_LOCAL string resources
// must be kept in sync with these values, and in the appropriate order.
// Also global variable cookie.cpp aColumns[][] must be kept in sync.
//
typedef enum _MyComputerObjectType {
	MYCOMPUT_COMPUTER = 0,
	MYCOMPUT_SYSTEMTOOLS,
	MYCOMPUT_SERVERAPPS,
	MYCOMPUT_STORAGE,
	MYCOMPUT_NUMTYPES // must be last
} MyComputerObjectType, *PMyComputerObjectType;
inline BOOL IsValidObjectType( MyComputerObjectType objecttype )
	{ return (objecttype >= MYCOMPUT_COMPUTER && objecttype < MYCOMPUT_NUMTYPES); }

#endif // ~__NODETYPE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\snapmgr.h ===
// SnapMgr.h : header file for Snapin Manager property page
//

#ifndef __SNAPMGR_H__
#define __SNAPMGR_H__

#include "chooser.h"

typedef CChooseMachinePropPage CMyComputerGeneral;

#endif // ~__SNAPMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\mycomput\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED_)
#define AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>
#include <afxtempl.h> // CTypedPtrList
#include <afxdlgs.h>  // CPropertyPage

// #define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include "dbg.h"
#include "mmc.h"
#include "mycomput.h"

EXTERN_C const CLSID CLSID_MyComputer;

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\about.cpp ===
/////////////////////////////////////////////////////////////////////
//	About.cpp
//
//	Provide constructor for the CSnapinAbout implementation.
//
//	HISTORY
//	01-Aug-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "about.h"

#include "stdabout.cpp" 


/////////////////////////////////////////////////////////////////////
CSchemaMgmtAbout::CSchemaMgmtAbout()
{
	m_uIdStrProvider = IDS_SNAPINABOUT_PROVIDER;
	m_uIdStrVersion = IDS_SNAPINABOUT_VERSION;
	m_uIdStrDestription = IDS_SNAPINABOUT_DESCRIPTION;
	m_uIdIconImage = IDI_CLASS;
	m_uIdBitmapSmallImage = IDB_CLASS_SMALL;
	m_uIdBitmapSmallImageOpen = IDB_CLASS_SMALL;
	m_uIdBitmapLargeImage = IDB_CLASS;
	m_crImageMask = RGB(0, 255, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\aclpage.h ===
#ifndef _ACLPAGE_H
#define _ACLPAGE_H


//
// aclpage.h : header file
// This was originally appropriated from the dnsmgr snap in.
//

class CISecurityInformationWrapper;

class CAclEditorPage
{
public:

    ~CAclEditorPage();

    static
    HRESULT CreateInstance( CAclEditorPage ** ppAclPage, LPCTSTR lpszLDAPPath,
							LPCTSTR lpszObjectClass );

    HPROPSHEETPAGE CreatePage();

private:

    CAclEditorPage();

    HRESULT Initialize( LPCTSTR lpszLDAPPath, LPCTSTR lpszObjectClass );

    static BOOL IsReadOnly( LPCTSTR lpszLDAPPath );

    //
    // data
    //

    CISecurityInformationWrapper* m_pISecInfoWrap;

    friend class CISecurityInformationWrapper;
};


typedef HPROPSHEETPAGE (WINAPI *ACLUICREATESECURITYPAGEPROC) (LPSECURITYINFO);


#endif //_ACLPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\advui.h ===
/****

AdvUi.h
CoryWest@Microsoft.Com

The UI code for the Advanced dialog box and its associated dialogs.

Copyright September 1997, Microsoft Corporation

****/

#ifndef __ADVUI_H_INCLUDED__
#define __ADVUI_H_INCLUDED__



///////////////////////////////////////////////////////////////////////
// CChangeDCDialog

class CChangeDCDialog : public CDialog
{
public:
  CChangeDCDialog(MyBasePathsInfo* pInfo, HWND hWndParent);

  LPCWSTR GetNewDCName() { return m_szNewDCName;}
private:

        virtual BOOL OnInitDialog();
        virtual void OnOK();

        afx_msg void OnChangeRadio();

        BOOL    OnHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, FALSE ); };
        BOOL    OnContextHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, TRUE ); };


  static const DWORD help_map[];

  CString m_szNewDCName;
  MyBasePathsInfo* m_pInfo;

  DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////
// CEditFsmoDialog

class CEditFsmoDialog : public CDialog
{
public:
  CEditFsmoDialog(MyBasePathsInfo* pInfo, HWND hWndParent, IDisplayHelp* pIDisplayHelp, BOOL fAllowFSMOChange );

private:

  virtual BOOL OnInitDialog();
  virtual void OnClose();

  afx_msg void OnChange();

  void _SetFsmoServerStatus(BOOL bOnLine);

  MyBasePathsInfo* m_pInfo;        // info about the current focus
  CComPtr<IDisplayHelp> m_spIDisplayHelp;
  CString m_szFsmoOwnerServerName;
  CToggleTextControlHelper m_fsmoServerState;

  BOOL m_fFSMOChangeAllowed;

  static const DWORD help_map[];


  BOOL OnHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, FALSE ); };
  BOOL OnContextHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, TRUE ); };


  DECLARE_MESSAGE_MAP()
};



#endif // __ADVUI_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\about.h ===
//	About.h

#ifndef __ABOUT_H_INCLUDED__
#define __ABOUT_H_INCLUDED__

#include "stdabout.h"

//	About for "Schema Manager" snapin
class CSchemaMgmtAbout :
	public CSnapinAbout,
	public CComCoClass<CSchemaMgmtAbout, &CLSID_SchemaManagementAbout>

{
public:
DECLARE_REGISTRY(CSchemaMgmtAbout, _T("SCHMMGMT.SchemaMgmtAboutObject.1"), _T("SCHMMGMT.SchemaMgmtAboutObject.1"), IDS_SCHMMGMT_DESC, THREADFLAGS_BOTH)
	CSchemaMgmtAbout();
};

#endif // ~__ABOUT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\advui.cpp ===
/****

AdvUi.Cpp
CoryWest@Microsoft.Com

The UI code for the Advanced dialog box and its associated dialogs.

Copyright September 1997, Microsoft Corporation

****/



#include "stdafx.h"

//#include "macros.h"
//USE_HANDLE_MACROS("SCHMMGMT(advui.cpp)")

#include "schmutil.h"
#include "resource.h"
#include "advui.h"

//////////////////////////////////////////////////////////////////
// CMoreInfoMessageBox

class CMoreInfoMessageBox : public CDialog
{
public:
  CMoreInfoMessageBox(HWND hWndParent, IDisplayHelp* pIDisplayHelp) 
    : CDialog(IDD_MSGBOX_OK_MOREINFO, CWnd::FromHandle(hWndParent)),
    m_spIDisplayHelp(pIDisplayHelp)
  {
  }

  void SetURL(LPCWSTR lpszURL) { m_szURL = lpszURL;}
  void SetMessage(LPCWSTR lpsz)
  {
    m_szMessage = lpsz;
  }

	// message handlers and MFC overrides
	virtual BOOL OnInitDialog()
  {
    SetDlgItemText(IDC_STATIC_MESSAGE, m_szMessage);
    return TRUE;
  }

	afx_msg void OnMoreInfo()
  {
    TRACE(L"ShowTopic(%s)\n", (LPCWSTR)m_szURL);
    m_spIDisplayHelp->ShowTopic((LPWSTR)(LPCWSTR)m_szURL);
  }

  DECLARE_MESSAGE_MAP()
private:
  CComPtr<IDisplayHelp> m_spIDisplayHelp;
  CString m_szMessage;
  CString m_szURL;
};

BEGIN_MESSAGE_MAP(CMoreInfoMessageBox, CDialog)
	ON_BN_CLICKED(ID_BUTTON_MORE_INFO, OnMoreInfo)
END_MESSAGE_MAP()



///////////////////////////////////////////////////////////////////////
// CChangeDCDialog

BEGIN_MESSAGE_MAP(CChangeDCDialog, CDialog)
   ON_BN_CLICKED(IDC_RADIO_ANY, OnChangeRadio)
   ON_BN_CLICKED(IDC_RADIO_SPECIFY, OnChangeRadio)
   ON_MESSAGE(WM_HELP, OnHelp)
   ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
END_MESSAGE_MAP()


const DWORD CChangeDCDialog::help_map[] =
{
  IDC_EDIT_CURRENT_DC, IDH_EDIT_CURRENT_DC2,
  IDC_RADIO_ANY,       IDH_RADIO_ANY,       
  IDC_RADIO_SPECIFY,   IDH_RADIO_SPECIFY,   
  IDC_EDIT_DC,         IDH_EDIT_DC,         
  0,0                 
};


CChangeDCDialog::CChangeDCDialog(MyBasePathsInfo* pInfo, HWND hWndParent) :
  CDialog(IDD_CHANGE_DC, CWnd::FromHandle(hWndParent)) 
{
  m_pInfo = pInfo;
}


BOOL CChangeDCDialog::OnInitDialog() 
{
	CDialog::OnInitDialog();

  SetDlgItemText(IDC_EDIT_CURRENT_DC, m_pInfo->GetServerName());

  // set the default radiobutton
  CButton* pCheck = (CButton*)GetDlgItem(IDC_RADIO_ANY);
  pCheck->SetCheck(TRUE);
  pCheck->SetFocus();
  OnChangeRadio();

  return FALSE; // we are setting the focus
}

void CChangeDCDialog::OnChangeRadio()
{
  CWnd* pEdit = GetDlgItem(IDC_EDIT_DC);

  BOOL bAny = IsDlgButtonChecked(IDC_RADIO_ANY);
  pEdit->EnableWindow(!bAny);
  if (bAny)
  {
    SetDlgItemText(IDC_EDIT_DC, NULL);
  }
  else
  {
    SetDlgItemText(IDC_EDIT_DC, m_pInfo->GetServerName());
  }
}


void CChangeDCDialog::OnOK()
{
  GetDlgItemText(IDC_EDIT_DC, m_szNewDCName);
  m_szNewDCName.TrimLeft();
  m_szNewDCName.TrimRight();

  CDialog::OnOK();
}



///////////////////////////////////////////////////////////////////////
// CEditFsmoDialog


BEGIN_MESSAGE_MAP(CEditFsmoDialog, CDialog)
   ON_BN_CLICKED(IDC_CHANGE_FSMO, OnChange)
   ON_BN_CLICKED(IDCLOSE, OnClose)
   ON_MESSAGE(WM_HELP, OnHelp)
   ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
END_MESSAGE_MAP()

CEditFsmoDialog::CEditFsmoDialog(MyBasePathsInfo* pInfo, 
                                 HWND hWndParent, 
                                 IDisplayHelp* pIDisplayHelp,
                                 BOOL fAllowFSMOChange ) :
  CDialog(IDD_EDIT_FSMO, CWnd::FromHandle(hWndParent)) 
{
  m_pInfo = pInfo;
  m_spIDisplayHelp = pIDisplayHelp;
  m_fFSMOChangeAllowed = fAllowFSMOChange;
}


const DWORD CEditFsmoDialog::help_map[] =
{
  IDC_EDIT_CURRENT_DC,      IDH_EDIT_CURRENT_DC3,
  IDC_STATIC_FSMO_NOTE,     NO_HELP,
  IDC_STATIC_FSMO_STATUS,   NO_HELP,
  IDC_EDIT_CURRENT_FSMO_DC, IDH_EDIT_CURRENT_FSMO_DC2,
  IDC_CHANGE_FSMO,          IDH_CHANGE_FSMO2,
  0,0
};



BOOL CEditFsmoDialog::OnInitDialog() 
{
    CDialog::OnInitDialog();
    
    ASSERT( GetDlgItem(IDC_CHANGE_FSMO) );
    ASSERT( ::GetDlgItem(m_hWnd, IDC_STATIC_FSMO_STATUS) );
    
    // init the status (online/offline) control)
    m_fsmoServerState.Init(::GetDlgItem(m_hWnd, IDC_STATIC_FSMO_STATUS));
    
    SetDlgItemText(IDC_EDIT_CURRENT_DC, m_pInfo->GetServerName());
    
    MyBasePathsInfo fsmoOwnerInfo;
    PWSTR pszFsmoOwner = 0;
    HRESULT hr = FindFsmoOwner(m_pInfo, SCHEMA_FSMO, &fsmoOwnerInfo, &pszFsmoOwner);
    
    if(pszFsmoOwner)
    {
      m_szFsmoOwnerServerName = pszFsmoOwner;
      delete[] pszFsmoOwner;
      pszFsmoOwner = 0;
    }
    _SetFsmoServerStatus(SUCCEEDED(hr));
    
    if( m_fFSMOChangeAllowed )
    {
        // set the focus on change button
        GetDlgItem(IDC_CHANGE_FSMO)->SetFocus();
    }
    else
    {
        GetDlgItem(IDC_CHANGE_FSMO)->EnableWindow( FALSE );
    }
    
    return FALSE; 
}

void CEditFsmoDialog::OnClose()
{
  EndDialog(IDCLOSE);
}

void CEditFsmoDialog::OnChange()
{
  // verify we have different servers
  if (m_szFsmoOwnerServerName.CompareNoCase(m_pInfo->GetServerName()) == 0)
  {
    AfxMessageBox(IDS_WARNING_CHANGE_FOCUS, MB_OK);
    return;
  }

  // make sure the user wants to do it
  if (AfxMessageBox(IDS_CHANGE_FSMO_CONFIRMATION, MB_OKCANCEL) != IDOK)
    return;

  HRESULT hr = GracefulFsmoOwnerTransfer(m_pInfo, SCHEMA_FSMO);
  if (FAILED(hr))
  {
    CString szFmt, szMsg;
    PWSTR pszError = 0;
    StringErrorFromHr(hr, &pszError);

    szFmt.LoadString(IDS_ERROR_CHANGE_FSMO_OWNER);
    szMsg.Format(szFmt, pszError);

    delete[] pszError;
    pszError = 0;

    CMoreInfoMessageBox dlg(m_hWnd, m_spIDisplayHelp);
    dlg.SetMessage(szMsg);
    dlg.SetURL(L"ADconcepts.chm::/FSMO_SCHEMA_ForcefulSeizure.htm");
    dlg.DoModal();
  }
  else
  {
    m_szFsmoOwnerServerName = m_pInfo->GetServerName();
    _SetFsmoServerStatus(TRUE);
    AfxMessageBox(IDS_CHANGE_FSMO_SUCCESS, MB_OK);
  }
}


void CEditFsmoDialog::_SetFsmoServerStatus(BOOL bOnLine)
{
  // set the FSMO owner server name
  if (m_szFsmoOwnerServerName.IsEmpty())
  {
    CString szError;
    szError.LoadString(IDS_FSMO_SERVER_ERROR);
    SetDlgItemText(IDC_EDIT_CURRENT_FSMO_DC, szError);
  }
  else
  {
    SetDlgItemText(IDC_EDIT_CURRENT_FSMO_DC, m_szFsmoOwnerServerName);
  }

  // set the status of the FSMO owner server
  m_fsmoServerState.SetToggleState(bOnLine);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\attrgen.hpp ===
#ifndef ATTRGEN_HPP_INCLUDED
#define ATTRGEN_HPP_INCLUDED


//
// Index Field bits
//
const DWORD INDEX_BIT_ATTINDEX			= 0;
const DWORD INDEX_BIT_PDNTATTINDEX		= 1;
// NOTE, to get ANR behaviour, set both
// INDEX_BIT_ANR and INDEX_BIT_ATTINDEX.
const DWORD INDEX_BIT_ANR				= 2;
const DWORD INDEX_BIT_PRESERVEONDELETE	= 3;
const DWORD INDEX_BIT_COPYONDUPLICATE	= 4;

// CN of the class "User"
extern const TCHAR szUserClass[];

// disable User Copy for the following list of attributes 
extern const TCHAR * rgszExclClass[];


class AttributeGeneralPage : public CPropertyPage
{
   public:

   AttributeGeneralPage( Component *pResultControl,
                              LPDATAOBJECT lpDataObject );

   ~AttributeGeneralPage();

   //
   // The schema object that this property page is for.
   //

   void Load( Cookie& CookieRef );
   Cookie *pCookie;

   //
   // The things we need for UpdateAllViews().
   //

   LPDATAOBJECT lpResultDataObject;
   Component *pComponent;

   //
   // Data members for property fields.
   //

   IADs *pIADsObject;
   SchemaObject *pObject;
   BOOL fDataLoaded;

   CString ObjectName;

   CString Description;
   CString DDXDescription;

   CString DisplayName;

   CString SysClassString;

   CString MultiValued;
   CString SyntaxString;

   CString RangeUpper;
   CString DDXRangeUpper;

   CString RangeLower;
   CString DDXRangeLower;

   CString OidString;

   DWORD search_flags; // low order bit => indexed
   BOOL DDXIndexed;
   BOOL	DDXANR;
   BOOL	DDXCopyOnDuplicate;
   BOOL DDXContainerIndexed;

   BOOL Displayable;
   BOOL DDXDisplayable;

   BOOL Defunct;
   BOOL DDXDefunct;

   BOOL ReplicatedToGC;
   BOOL DDXReplicatedToGC;

private:
    CParsedEdit m_editLowerRange;
    CParsedEdit m_editUpperRange;

protected:
    // Helper functions

    //    Search User class & aux classes for the specified attribute
    BOOL IsAttributeInUserClass( const CString & strAttribDN );

    //    Search the user class & subclasses
    BOOL RecursiveIsAttributeInUserClass( const CString & strAttribDN,
                                          SchemaObject  * pObject );

    // Linear search of the linked list for the string strAttribDN
    BOOL SearchResultList( const CString  & strAttribDN,
                           ListEntry      * pList );

    // Traverse each auxiliary class by recursivly
    // calling RecursiveIsAttributeInUserClass()
    BOOL TraverseAuxiliaryClassList( const CString   & strAttribDN,
                                     ListEntry       * pList );

    HRESULT ChangeDefunctState( BOOL               DDXDefunct,
                                BOOL             & Defunct,
                                IADsPropertyList * pPropertyList,
                                BOOL             & fApplyAbort,
                                BOOL             & fApplyFailed );


public:
   
   //
   // Required property sheet routines.
   //

   virtual BOOL OnApply();
   virtual BOOL OnInitDialog();
   virtual BOOL OnSetActive();
   virtual void DoDataExchange( CDataExchange *pDX );


   static const DWORD help_map[];

   BOOL    OnHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, FALSE ); };
   BOOL    OnContextHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, TRUE ); };

   void	   OnIndexClick();
   void	   OnDeactivateClick();

   DECLARE_MESSAGE_MAP()
};



#endif   // ATTRGEN_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\attrgen.cpp ===
#include "stdafx.h"
#include "compdata.h"
#include "cmponent.h"
#include "attrgen.hpp"
#include "resource.h"
#include "dataobj.h"




const TCHAR szUserClass[]               = USER_CLASS_NAME ;

// disable User Copy for the following list of attributes 
const TCHAR * rgszExclClass[]           = { _T("cn"),				_T("displayName"),
                                            _T("sAMAccountName"),	_T("userAccountControl"),
                                            _T("userParameters"),	_T("userPrincipalName"),    
                                            NULL };

//
// The following table is copied from dirsync\ldifds\ldifldap\samrestrict.h
//
// CLASS_USER, SampUserObjectType (ldapdisplayname: user)
//
PCWSTR rgszExclClass2[] = { // user[] = {
    L"memberOf",                // SAMP_USER_GROUPS, ATT_MEMBER
    L"dBCSPwd",                 // SAMP_USER_DBCS_PWD, ATT_DBCS_PWD
    L"ntPwdHistory",            // SAMP_USER_NT_PWD_HISTORY, ATT_NT_PWD_HISTORY
    L"lmPwdHistory",            // SAMP_USER_LM_PWD_HISTORY, ATT_LM_PWD_HISTORY
    L"lastLogon",               // SAMP_FIXED_USER_LAST_LOGON, ATT_LAST_LOGON
    L"lastLogoff",              // SAMP_FIXED_USER_LAST_LOGOFF, ATT_LAST_LOGOFF
    L"badPasswordTime",         // SAMP_FIXED_USER_LAST_BAD_PASSWORD_TIME, 
                                // ATT_BAD_PASSWORD_TIME
    L"rid",                     // SAMP_FIXED_USER_USERID, ATT_RID
    L"badPwdCount",             // SAMP_FIXED_USER_BAD_PWD_COUNT, 
                                // ATT_BAD_PWD_COUNT
    L"logonCount",              // SAMP_FIXED_USER_LOGON_COUNT, ATT_LOGON_COUNT
    L"sAMAccountType",          // SAMP_USER_ACCOUNT_TYPE, ATT_SAM_ACCOUNT_TYPE
    L"supplementalCredentials", // SAMP_FIXED_USER_SUPPLEMENTAL_CREDENTIALS,
                                // ATT_SUPPLEMENTAL_CREDENTIALS
    L"objectSid",               // not in mappings.c, but still required!, 
                                // ATT_OBJECT_SID
    L"pwdLastSet",
    NULL
};



const TCHAR szTopClass[]				= _T("Top");


const CDialogControlsInfo ctrls[] =
{
    { IDC_ATTRIB_GENERAL_DESCRIPTION_EDIT,  g_Description,       TRUE },
    { IDC_ATTRIB_GENERAL_MIN_EDIT,          g_RangeLower,        TRUE }, 
    { IDC_ATTRIB_GENERAL_MAX_EDIT,          g_RangeUpper,        TRUE }, 
    { IDC_ATTRIB_GENERAL_DISPLAYABLE_CHECK, g_ShowInAdvViewOnly, FALSE },
    { IDC_ATTRIB_GENERAL_DEACTIVATE,        g_isDefunct,           FALSE },
    { IDC_ATTRIB_GENERAL_INDEX_CHECK,       g_IndexFlag,         FALSE },
    { IDC_ATTRIB_GENERAL_REPLICATED,        g_GCReplicated,      FALSE },
    { IDC_ATTRIB_GENERAL_CPYATTR_CHECK,     g_IndexFlag,         FALSE },
    { IDC_ATTRIB_GENERAL_ANR_CHECK,         g_IndexFlag,         FALSE },
    { IDC_ATTRIB_GENERAL_CONTAINERIZED_INDEX_CHECK, g_IndexFlag, FALSE},
} ;


const DWORD AttributeGeneralPage::help_map[] =
{
  IDI_ATTRIBUTE,                        NO_HELP,
  IDC_ATTRIB_GENERAL_NAME_STATIC,       NO_HELP,
  IDC_ATTRIB_GENERAL_DESCRIPTION_EDIT,  IDH_ATTRIB_GENERAL_DESCRIPTION_EDIT, 
  IDC_ATTRIB_GENERAL_LDN,               IDH_ATTRIB_GENERAL_LDN,               
  IDC_ATTRIB_GENERAL_OID_EDIT,          IDH_ATTRIB_GENERAL_OID_EDIT,         
  IDC_ATTRIB_GENERAL_VALUE_STATIC,      NO_HELP,
  IDC_ATTRIB_GENERAL_SYNTAX_EDIT,       IDH_ATTRIB_GENERAL_SYNTAX_EDIT,      
  IDC_ATTRIB_GENERAL_MIN_EDIT,          IDH_ATTRIB_GENERAL_MIN_EDIT,         
  IDC_ATTRIB_GENERAL_MAX_EDIT,          IDH_ATTRIB_GENERAL_MAX_EDIT,         
  IDC_ATTRIB_GENERAL_DISPLAYABLE_CHECK, IDH_ATTRIB_GENERAL_DISPLAYABLE_CHECK,
  IDC_ATTRIB_GENERAL_DEACTIVATE,        IDH_ATTRIB_DEACTIVATE,               
  IDC_ATTRIB_GENERAL_INDEX_CHECK,       IDH_ATTRIB_GENERAL_INDEX_CHECK,   
  IDC_ATTRIB_GENERAL_CONTAINERIZED_INDEX_CHECK, IDH_ATTRIB_GENERAL_CONTAINERIZED_INDEX_CHECK,
  IDC_ATTRIB_GENERAL_ANR_CHECK,         IDH_ATTRIB_GENERAL_ANR_CHECK,
  IDC_ATTRIB_GENERAL_REPLICATED,        IDH_REPLICATED,                      
  IDC_ATTRIB_GENERAL_CPYATTR_CHECK,     IDH_ATTRIB_GENERAL_CPYATTR_CHECK,
  IDC_ATTRIB_GENERAL_SYSCLASS_STATIC,   NO_HELP,
  0,                                    0                                    
};



// returns state of bit n

inline
bool
getbit(const DWORD& bits, int n)
{
   return (bits & (1 << n)) ? true : false;
}


// sets bit n to 1

inline
void
setbit(DWORD& bits, int n)
{
   bits |= (1 << n);
}



// sets bit n to 0

inline
void
clearbit(DWORD& bits, int n)
{
   bits &= ~(1 << n);
}



//
// Attribute property sheet routines.
//



BEGIN_MESSAGE_MAP( AttributeGeneralPage, CDialog )
   ON_MESSAGE(WM_HELP, OnHelp)
   ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
   ON_BN_CLICKED(IDC_ATTRIB_GENERAL_INDEX_CHECK, OnIndexClick)
   ON_BN_CLICKED(IDC_ATTRIB_GENERAL_DEACTIVATE, OnDeactivateClick)
END_MESSAGE_MAP()



AttributeGeneralPage::AttributeGeneralPage(
   Component*  pResultControl,
   LPDATAOBJECT         lpDataObject)
   :
   CPropertyPage( IDD_ATTRIB_GENERAL ),
   pCookie( NULL ),
   pIADsObject( NULL ),
   pObject( NULL),
   lpResultDataObject( lpDataObject ),
   pComponent( pResultControl ),
   fDataLoaded( FALSE ),
   Displayable( TRUE ),
   DDXDisplayable( TRUE ),
   search_flags(0),
   DDXIndexed( FALSE ),
   DDXANR( FALSE ),
   DDXCopyOnDuplicate( FALSE ),
   Defunct( FALSE ),
   DDXDefunct( FALSE ),
   ReplicatedToGC( FALSE ),
   DDXReplicatedToGC( FALSE ),
   DDXContainerIndexed( FALSE ),   
   m_editLowerRange( CParsedEdit::EDIT_TYPE_UINT32 ),
   m_editUpperRange( CParsedEdit::EDIT_TYPE_UINT32 )
{
}



BOOL
AttributeGeneralPage::OnSetActive()
{
      // If pIADsObject is NULL, close dialog box
   if( CPropertyPage::OnSetActive() )
   {
      if ( !pIADsObject )
      {
         return FALSE;
      }
      else
      {
         // always enable the Apply button 
         SetModified(TRUE);

         return TRUE;
      }
   }
   else
      return FALSE;
}


AttributeGeneralPage::~AttributeGeneralPage(
)
{

    ComponentData& Scope = pComponent->QueryComponentDataRef();

    //
    // Always make sure we free the IADs object.
    //

    if ( pIADsObject ) {
        pIADsObject->Release();
        pIADsObject = NULL;
    }

    //
    // And release the cache.
    //

    if ( pObject ) {
        Scope.g_SchemaCache.ReleaseRef( pObject );
    }
}



BOOL
AttributeGeneralPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    ASSERT( GetDlgItem(IDC_ATTRIB_GENERAL_DESCRIPTION_EDIT) );

    ( static_cast<CEdit *>( GetDlgItem(IDC_ATTRIB_GENERAL_DESCRIPTION_EDIT) ) )
        -> LimitText( 1024 ) ;

    m_editLowerRange.SubclassEdit(IDC_ATTRIB_GENERAL_MIN_EDIT, this, cchMinMaxRange);
    m_editUpperRange.SubclassEdit(IDC_ATTRIB_GENERAL_MAX_EDIT, this, cchMinMaxRange);

    return TRUE;
}



void
AttributeGeneralPage::Load(
    Cookie& CookieRef
) {

    //
    // Store the cookie object pointer.  Everything
    // else gets loaded when the page is displayed.
    //

    pCookie = &CookieRef;
    return;
}



BOOL
AttributeGeneralPage::OnApply(
    VOID
) {

    HRESULT hr;

    VARIANT AdsValue;
    BOOL fChangesMade = FALSE;
    BOOL fRangeChange = FALSE;
    BOOL fApplyAbort  = FALSE;  // stop later saves
    BOOL fApplyFailed = FALSE;  // should not close the box

    DWORD dwRange;
    
    // Enable hourglass
    CWaitCursor wait;
   
    //
    // We have to flush the IADS property cache if we
    // have a failure so later operations won't fail because
    // of a bad cached attribute.
    //

    IADsPropertyList *pPropertyList;

    hr = pIADsObject->QueryInterface( IID_IADsPropertyList,
                                      reinterpret_cast<void**>(&pPropertyList) );
    if ( FAILED( hr ) ) {
        pPropertyList = NULL;
        fApplyAbort   = TRUE;
    }

    //
    // Check to see if something we cared about changed.
    // We care about Description, Min, Max, Indexed,
    // Defunct, ReplicatedToGC, and Displayable.
    //

    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    VariantInit( &AdsValue );

    //
    // Defunct -- in case it was deactivated, activate the object first
    //
    if( !fApplyAbort && !DDXDefunct && DDXDefunct != Defunct )
    {
        hr = ChangeDefunctState( DDXDefunct, Defunct, pPropertyList, fApplyAbort, fApplyFailed );
    }

    
    //
    // Description
    //

    if ( !fApplyAbort && DDXDescription != Description ) {

        V_VT(&AdsValue) = VT_BSTR;
        V_BSTR(&AdsValue) = const_cast<BSTR>((LPCTSTR)DDXDescription);

        if ( DDXDescription.IsEmpty() ) {

            hr = pIADsObject->PutEx( ADS_PROPERTY_CLEAR,
                                     const_cast<BSTR>((LPCTSTR)g_Description),
                                     AdsValue );

        } else {

            hr = pIADsObject->Put( const_cast<BSTR>((LPCTSTR)g_Description),
                                   AdsValue );
        }

        ASSERT( SUCCEEDED( hr ) );

        hr = pIADsObject->SetInfo();

        if ( SUCCEEDED( hr ) ) {

            pObject->description = DDXDescription;
            fChangesMade = TRUE;
			Description = DDXDescription;

        } else {

            pPropertyList->PurgePropertyList();
            if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
            {
                fApplyFailed = TRUE;
                DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_EDIT_DESC );
            }
            else
            {
                fApplyAbort = TRUE; 
                DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
            }

        }

        VariantInit( &AdsValue );
    }

    //
    // Displayable
    //

    if ( !fApplyAbort && DDXDisplayable != Displayable ) {

        V_VT(&AdsValue) = VT_BOOL;

        if ( DDXDisplayable ) {
            V_BOOL(&AdsValue) = 0;
        } else {
            V_BOOL(&AdsValue) = -1;
        }

        hr = pIADsObject->Put(g_ShowInAdvViewOnly, AdsValue);
        ASSERT( SUCCEEDED( hr ) );

        hr = pIADsObject->SetInfo();

        if ( FAILED( hr ) ) {
            pPropertyList->PurgePropertyList();

            if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
            {
                fApplyFailed = TRUE;
                DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_EDIT_DISPLAYABLE );
            }
            else
            {
                fApplyAbort = TRUE; 
                DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
            }
        }
		else
		{
			Displayable = DDXDisplayable;
		}

        VariantInit( &AdsValue );
    }

    //
    // ReplicatedToGC
    //

    if ( !fApplyAbort && DDXReplicatedToGC != ReplicatedToGC ) {

        V_VT(&AdsValue) = VT_BOOL;

        if ( DDXReplicatedToGC ) {
            V_BOOL(&AdsValue) = -1;
        } else {
            V_BOOL(&AdsValue) = 0;
        }

        hr = pIADsObject->Put( const_cast<BSTR>((LPCTSTR)g_GCReplicated),
                               AdsValue );
        ASSERT( SUCCEEDED( hr ) );

        hr = pIADsObject->SetInfo();

        if ( FAILED( hr ) ) {
            pPropertyList->PurgePropertyList();
            if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
            {
                fApplyFailed = TRUE;
                DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_EDIT_GC );
            }
            else
            {
                fApplyAbort = TRUE; 
                DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
            }
        }
		else
		{
			ReplicatedToGC = DDXReplicatedToGC;
		}

        VariantInit( &AdsValue );
    }

    //
    // Indexed
    //

   // make sure ANR is not set when Indexed is unchecked
   if( !DDXIndexed )
	   DDXANR = FALSE;

   if( !fApplyAbort && 
       (getbit(search_flags, INDEX_BIT_ATTINDEX) != (DDXIndexed ? 1 : 0)
      || getbit(search_flags, INDEX_BIT_ANR) != (DDXANR ? 1 : 0)
      || getbit(search_flags, INDEX_BIT_COPYONDUPLICATE) != (DDXCopyOnDuplicate ? 1 : 0)
      || getbit(search_flags, INDEX_BIT_PDNTATTINDEX) != (DDXContainerIndexed ? 1 : 0)) )
   {
      DWORD DDXsearch_flags = search_flags;

      V_VT(&AdsValue) = VT_I4;

      if (DDXIndexed)
         setbit(DDXsearch_flags, INDEX_BIT_ATTINDEX);
      else
         clearbit(DDXsearch_flags, INDEX_BIT_ATTINDEX);

      ASSERT( DDXIndexed || !DDXANR );
      if (DDXANR)
         setbit(DDXsearch_flags, INDEX_BIT_ANR);
      else
         clearbit(DDXsearch_flags, INDEX_BIT_ANR);

      if (DDXCopyOnDuplicate)
         setbit(DDXsearch_flags, INDEX_BIT_COPYONDUPLICATE);
      else
         clearbit(DDXsearch_flags, INDEX_BIT_COPYONDUPLICATE);

      if (DDXContainerIndexed)
        setbit(DDXsearch_flags, INDEX_BIT_PDNTATTINDEX);
      else
        clearbit(DDXsearch_flags, INDEX_BIT_PDNTATTINDEX);

      V_I4(&AdsValue) = DDXsearch_flags;
      hr = pIADsObject->Put( const_cast<BSTR>((LPCTSTR)g_IndexFlag),
                            AdsValue );
      ASSERT( SUCCEEDED( hr ) );

      hr = pIADsObject->SetInfo();

      if ( FAILED( hr ) ) {
         pPropertyList->PurgePropertyList();
         if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
         {
             fApplyFailed = TRUE;
             DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_EDIT_INDEXED );
         }
         else
         {
             fApplyAbort = TRUE; 
             DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
         }
      }
      else
      {
          search_flags = DDXsearch_flags;
      }

      VariantInit( &AdsValue );
   }

    //
    // RangeUpper and RangeLower
    // These have to be set together so the server
    // range validation works correctly.
    //

    if ( !fApplyAbort && RangeUpper != DDXRangeUpper ) {

        if ( DDXRangeUpper.IsEmpty() ) {

            //
            // Clear the value.
            //

            hr = pIADsObject->PutEx( ADS_PROPERTY_CLEAR,
                                     const_cast<BSTR>((LPCTSTR)g_RangeUpper),
                                     AdsValue );
            ASSERT( SUCCEEDED( hr ) );

        } else {

            //
            // Store the new value.
            //
	        ASSERT(pObject);

			hr = GetSafeSignedDWORDFromString( this, dwRange, DDXRangeUpper,
					g_Syntax[ pObject->SyntaxOrdinal ].m_fIsSigned );

			ASSERT( S_OK == hr );	// validation should have taken care of min/max stuff

            V_VT( &AdsValue ) = VT_I4;
            V_I4( &AdsValue ) = dwRange;

            hr = pIADsObject->Put( const_cast<BSTR>((LPCTSTR)g_RangeUpper),
                                   AdsValue );
            ASSERT( SUCCEEDED( hr ) );
        }

		fRangeChange = TRUE;
        VariantInit( &AdsValue );
    }

    if ( !fApplyAbort && RangeLower != DDXRangeLower ) {

        if ( DDXRangeLower.IsEmpty() ) {

            //
            // Clear the value.
            //

            hr = pIADsObject->PutEx( ADS_PROPERTY_CLEAR,
                                     const_cast<BSTR>((LPCTSTR)g_RangeLower),
                                     AdsValue );
            ASSERT( SUCCEEDED( hr ) );

        } else {

            //
            // Store the new value.
            //

	        ASSERT(pObject);

			hr = GetSafeSignedDWORDFromString( this, dwRange, DDXRangeLower,
					g_Syntax[ pObject->SyntaxOrdinal ].m_fIsSigned );

			ASSERT( S_OK == hr );	// validation should have taken care of min/max stuff

            V_VT( &AdsValue ) = VT_I4;
            V_I4( &AdsValue ) = dwRange;

            hr = pIADsObject->Put( const_cast<BSTR>((LPCTSTR)g_RangeLower),
                                   AdsValue );
            ASSERT( SUCCEEDED( hr ) );
        }

        fRangeChange = TRUE;
        VariantInit( &AdsValue );
    }

    //
    // Actually commit the changes.
    //

    if ( !fApplyAbort && fRangeChange ) {

        hr = pIADsObject->SetInfo();

        if ( FAILED( hr ) ) {
            pPropertyList->PurgePropertyList();
            if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
            {
                fApplyFailed = TRUE;
                DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_CREATE_MINMAX );
            }
            else
            {
                fApplyAbort = TRUE; 
                DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
            }
        }
        else
        {
            RangeLower = DDXRangeLower;
            RangeUpper = DDXRangeUpper;
        }
    }


    //
    // Defunct -- in case it was active, deactivate the object after we are done update
    //
    if( !fApplyAbort && DDXDefunct && DDXDefunct != Defunct )
    {
        hr = ChangeDefunctState( DDXDefunct, Defunct, pPropertyList, fApplyAbort, fApplyFailed );
    }

    
    //
    // If there are visible changes, update the views.
    //

    if ( ( fChangesMade ) &&
         ( pComponent )     &&
         ( lpResultDataObject ) ) {

        CCookie* pBaseCookie;
        Cookie* pCookie;

        hr = ExtractData( lpResultDataObject,
                          CSchmMgmtDataObject::m_CFRawCookie,
                          OUT reinterpret_cast<PBYTE>(&pBaseCookie),
                          sizeof(pBaseCookie) );
        ASSERT( SUCCEEDED(hr) );

        pCookie = pComponent->ActiveCookie(pBaseCookie);
        ASSERT( NULL != pCookie );

        hr = pComponent->m_pResultData->UpdateItem( pCookie->hResultId );
        ASSERT( SUCCEEDED(hr) );
    }

    if ( pPropertyList ) {
        pPropertyList->Release();
    }

    return !fApplyAbort && !fApplyFailed ;      // return TRUE if nothing happened
}



void
AttributeGeneralPage::DoDataExchange(
    CDataExchange *pDX
) {

    HRESULT	hr;
    CString	szAdsPath;
    VARIANT	AdsResult;
    UINT	SyntaxOrdinal		= SCHEMA_SYNTAX_UNKNOWN;

    ComponentData& Scope = pComponent->QueryComponentDataRef();

    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    // Enable hourglass
    CWaitCursor wait;
    
    CPropertyPage::DoDataExchange( pDX );

    VariantInit( &AdsResult );

    // We still want to do the DDX exchange at the bottom
    // even if the data is already loaded so make it part
    // of this if statement instead of short circuiting 
    // from within

    if ( !pDX->m_bSaveAndValidate &&
         !fDataLoaded) {

        //
        // Get the schema cache object and the actual ADS object.
        // Keep the ADS object around while the page is loaded.
        //

        ASSERT( !pObject );		// Must be NULL initially

        pObject = Scope.g_SchemaCache.LookupSchemaObjectByCN(
                      pCookie->strSchemaObject,
                      SCHMMGMT_ATTRIBUTE );

        if ( pObject ) {

          Scope.GetSchemaObjectPath( pObject->commonName, szAdsPath );

          if ( !szAdsPath.IsEmpty() ) {

              hr = ADsGetObject( (LPWSTR)(LPCWSTR)szAdsPath,
                                 IID_IADs,
                                 (void **)&pIADsObject );

              if( SUCCEEDED(hr) )
			  {
			      BOOL fIsConstructed = FALSE;

			      // Igrnore error code
			      IsConstructedObject( pIADsObject, fIsConstructed );
			      
				  // Enable check box if ths attribute is not in the excluded
				  // list and available for the User Class
				  GetDlgItem(IDC_ATTRIB_GENERAL_CPYATTR_CHECK)->EnableWindow(
								!fIsConstructed &&
								!IsInList( rgszExclClass, pObject->ldapDisplayName )  &&
								!IsInList( rgszExclClass2, pObject->ldapDisplayName )  &&
								IsAttributeInUserClass( pObject->ldapDisplayName ) );
			  }
          }
        }

        //
        // If we have no ADS object, we should error out!
        //

        if ( !pIADsObject )
        {
          DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_SCHEMA_OBJECT );

          // Because there is no pIADsObject, OnSetActive() will close dialog box

          return;
        }

        //
        // ObjectName - Use the ldapDisplayName to be consistent
        // with the other admin components.
        //

        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_DisplayName),
                              &AdsResult );

        if ( SUCCEEDED( hr ) ) {

          ASSERT( AdsResult.vt == VT_BSTR );
          ObjectName = AdsResult.bstrVal;
          VariantClear( &AdsResult );
        }

        //
        // Description
        //

        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_Description),
                              &AdsResult );

        if ( SUCCEEDED( hr ) ) {

          ASSERT( AdsResult.vt == VT_BSTR );
          Description = AdsResult.bstrVal;
          DDXDescription = AdsResult.bstrVal;
          VariantClear( &AdsResult );
        }

        //
        // CommonName
        //

        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_CN),
                              &AdsResult );

        if ( SUCCEEDED( hr ) ) {

          ASSERT( AdsResult.vt == VT_BSTR );
          DisplayName = AdsResult.bstrVal;
          VariantClear( &AdsResult );
        }

        //
        // SysClass
        //

        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_SystemOnly),
                              &AdsResult );

        if ( SUCCEEDED( hr ) ) {

          ASSERT( AdsResult.vt == VT_BOOL );

          if ( AdsResult.boolVal ) {
              SysClassString = g_SysAttrString;
          } else {
              SysClassString = L"";
          }

          VariantClear( &AdsResult );

        } else {

           SysClassString = L"";
        }

        //
        // Syntax
        //
		// No need to reload from schema -- syntax never changes
		//
        ASSERT(pObject);
        if( pObject )
            SyntaxOrdinal = pObject->SyntaxOrdinal;
        
        SyntaxString = g_Syntax[ SyntaxOrdinal ].m_strSyntaxName;


        //
        // Syntax min and max values.
        //

        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_RangeLower),
                               &AdsResult );

        if ( SUCCEEDED( hr ) ) {

            ASSERT( V_VT( &AdsResult ) == VT_I4 );

            RangeLower.Format( g_Syntax[ SyntaxOrdinal ].m_fIsSigned ?
									g_INT32_FORMAT : g_UINT32_FORMAT,
                               V_I4( &AdsResult ) );

			ASSERT( RangeLower.GetLength() <= cchMinMaxRange );
            DDXRangeLower = RangeLower;

            VariantClear( &AdsResult );
        }

        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_RangeUpper),
                               &AdsResult );

        if ( SUCCEEDED( hr ) ) {

            ASSERT( V_VT( &AdsResult ) == VT_I4 );

            RangeUpper.Format( g_Syntax[ SyntaxOrdinal ].m_fIsSigned ?
									g_INT32_FORMAT : g_UINT32_FORMAT,
                               V_I4( &AdsResult ) );

			ASSERT( RangeUpper.GetLength() <= cchMinMaxRange );
            DDXRangeUpper = RangeUpper;

            VariantClear( &AdsResult );
        }

        //
        // Multi-Valued
        //


        MultiValued.LoadString( IDS_ATTRIBUTE_MULTI );

        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_IsSingleValued),
                               &AdsResult );

        if ( SUCCEEDED( hr ) ) {

           ASSERT( AdsResult.vt == VT_BOOL );

           if ( AdsResult.boolVal == -1 ) {
               MultiValued.Empty();
               MultiValued.LoadString( IDS_ATTRIBUTE_SINGLE );
           }

           VariantClear( &AdsResult );

        }

        //
        // Displayable
        //

        hr = pIADsObject->Get(g_ShowInAdvViewOnly, &AdsResult);

        if ( SUCCEEDED( hr ) ) {

           ASSERT( AdsResult.vt == VT_BOOL );

           if ( AdsResult.boolVal == -1 ) {
               Displayable = FALSE;
               DDXDisplayable = FALSE;
           }

           VariantClear( &AdsResult );

        }

        //
        // Defunct
        //

        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_isDefunct),
                               &AdsResult );

        if ( SUCCEEDED( hr ) ) {

           ASSERT( AdsResult.vt == VT_BOOL );

           if ( AdsResult.boolVal == -1 ) {
               Defunct = TRUE;
               DDXDefunct = TRUE;
           }

           VariantClear( &AdsResult );

        }

        //
        // ReplicatedToGC
        //

        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_GCReplicated),
                               &AdsResult );

        if ( SUCCEEDED( hr ) ) {

           ASSERT( AdsResult.vt == VT_BOOL );

           if ( AdsResult.boolVal == -1 ) {
               ReplicatedToGC = TRUE;
               DDXReplicatedToGC = TRUE;
           }

           VariantClear( &AdsResult );

        }

        //
        // OID
        //

        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_GlobalAttributeID),
                               &AdsResult );

        if ( SUCCEEDED( hr ) ) {

           ASSERT( AdsResult.vt == VT_BSTR );
           OidString = AdsResult.bstrVal;
           VariantClear( &AdsResult );
        }

        //
        // Indexed, ANR, & Copy on duplicate
        //

      hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_IndexFlag),
                            &AdsResult );

      if (SUCCEEDED(hr))
      {
         ASSERT(AdsResult.vt == VT_I4);

         search_flags = V_I4(&AdsResult);
         
		 // Index this attribute in the Active Directory
		 DDXIndexed = getbit( search_flags, INDEX_BIT_ATTINDEX );
		 
		 // Ambiguous Name Resolution (ANR)
		 // checkbox must exist
		 ASSERT( GetDlgItem(IDC_ATTRIB_GENERAL_ANR_CHECK) );

		 // if not indexed, or not allowed, disable the checkbox
		 GetDlgItem(IDC_ATTRIB_GENERAL_ANR_CHECK)->EnableWindow(
					g_Syntax[ SyntaxOrdinal ].m_fIsANRCapable ? DDXIndexed : FALSE );

		 if( DDXIndexed )
			 DDXANR = getbit( search_flags, INDEX_BIT_ANR );
		 else
		 {
			 DDXANR = FALSE;

			 // if not indexed, ANR in DS should not be set
			 ASSERT( !getbit( search_flags, INDEX_BIT_ANR ) );
		 }

		 // Attribute is copied when duplicating a user
		 DDXCopyOnDuplicate = getbit( search_flags, INDEX_BIT_COPYONDUPLICATE );

         VariantClear( &AdsResult );
      }

      // Containerized index
      DDXContainerIndexed = getbit( search_flags, INDEX_BIT_PDNTATTINDEX );

      // Determine if this is a category 1 object & disable read-only fields
      BOOL  fIsSystemObject = FALSE;

      hr = IsCategory1Object( pIADsObject, fIsSystemObject );
      if( SUCCEEDED(hr) && fIsSystemObject )
      {
         ASSERT( GetDlgItem(IDC_ATTRIB_GENERAL_MIN_EDIT) );
         ASSERT( GetDlgItem(IDC_ATTRIB_GENERAL_MAX_EDIT) );
         ASSERT( GetDlgItem(IDC_ATTRIB_GENERAL_DEACTIVATE) );
         
         reinterpret_cast<CEdit *>( GetDlgItem(IDC_ATTRIB_GENERAL_MIN_EDIT) )->SetReadOnly();
         reinterpret_cast<CEdit *>( GetDlgItem(IDC_ATTRIB_GENERAL_MAX_EDIT) )->SetReadOnly();
         GetDlgItem(IDC_ATTRIB_GENERAL_DEACTIVATE)->EnableWindow( FALSE );
      }

      hr = DissableReadOnlyAttributes( this, pIADsObject, ctrls, sizeof(ctrls)/sizeof(ctrls[0]) );
      ASSERT( SUCCEEDED(hr) );     // shouldn't fail, but unimportant, so ignore error


      // warn the user if this is a read/write defunct object
      ASSERT( GetDlgItem(IDC_ATTRIB_GENERAL_DEACTIVATE) );
      
      if( DDXDefunct &&
          GetDlgItem(IDC_ATTRIB_GENERAL_DEACTIVATE)->IsWindowEnabled() )
      {
          AfxMessageBox( IDS_WARNING_DEFUNCT, MB_OK | MB_ICONINFORMATION );
      }


      //
      // Remember that the data is loaded.
      //

      fDataLoaded = TRUE;

      m_editLowerRange.SetSigned( g_Syntax[ SyntaxOrdinal ].m_fIsSigned );
      m_editUpperRange.SetSigned( g_Syntax[ SyntaxOrdinal ].m_fIsSigned );
    }


    //
    // Set up the dialog data exchange.
    //

    DDX_Text( pDX, IDC_ATTRIB_GENERAL_NAME_STATIC, ObjectName );
    DDX_Text( pDX, IDC_ATTRIB_GENERAL_SYSCLASS_STATIC, SysClassString );
    DDX_Text( pDX, IDC_ATTRIB_GENERAL_SYNTAX_EDIT, SyntaxString );
    DDX_Text( pDX, IDC_ATTRIB_GENERAL_OID_EDIT, OidString );
    DDX_Text( pDX, IDC_ATTRIB_GENERAL_VALUE_STATIC, MultiValued );
    DDX_Text( pDX, IDC_ATTRIB_GENERAL_LDN, DisplayName );
	DDX_Text( pDX, IDC_ATTRIB_GENERAL_DESCRIPTION_EDIT, DDXDescription );

    DDXV_VerifyAttribRange( pDX, g_Syntax[ pObject->SyntaxOrdinal ].m_fIsSigned,
							IDC_ATTRIB_GENERAL_MIN_EDIT, DDXRangeLower,
							IDC_ATTRIB_GENERAL_MAX_EDIT, DDXRangeUpper );
		
    DDX_Check( pDX, IDC_ATTRIB_GENERAL_DISPLAYABLE_CHECK, DDXDisplayable );
    DDX_Check( pDX, IDC_ATTRIB_GENERAL_INDEX_CHECK, DDXIndexed );
    DDX_Check( pDX, IDC_ATTRIB_GENERAL_ANR_CHECK, DDXANR );
    DDX_Check( pDX, IDC_ATTRIB_GENERAL_CPYATTR_CHECK, DDXCopyOnDuplicate );
    DDX_Check( pDX, IDC_ATTRIB_GENERAL_REPLICATED, DDXReplicatedToGC );
    DDX_Check( pDX, IDC_ATTRIB_GENERAL_CONTAINERIZED_INDEX_CHECK, DDXContainerIndexed );

    // Since we want the checkbox label to be positive
    // the value is actually the opposite of defunct

    int checkValue = !Defunct;
    DDX_Check( pDX, IDC_ATTRIB_GENERAL_DEACTIVATE, checkValue );
    DDXDefunct = !checkValue;

    return;
}


void
AttributeGeneralPage::OnIndexClick()
{
	ASSERT( pObject );
	if( pObject && g_Syntax[ pObject->SyntaxOrdinal ].m_fIsANRCapable )
	{
		GetDlgItem(IDC_ATTRIB_GENERAL_ANR_CHECK)->
			EnableWindow(  IsDlgButtonChecked(IDC_ATTRIB_GENERAL_INDEX_CHECK)  );
	}
}


void
AttributeGeneralPage::OnDeactivateClick()
{
	if( !IsDlgButtonChecked(IDC_ATTRIB_GENERAL_DEACTIVATE) )
    {
        if( IDOK != AfxMessageBox( IDS_WARNING_DEFUNCT_SET, MB_OKCANCEL | MB_ICONWARNING ) )
        {
            CheckDlgButton( IDC_ATTRIB_GENERAL_DEACTIVATE, BST_UNCHECKED );
        }
	}
}


//  Search User class & aux classes for the specified attribute
BOOL
AttributeGeneralPage::IsAttributeInUserClass( const CString & strAttribDN )
{
    BOOL            fFound  = FALSE;
    ComponentData & Scope   = pComponent->QueryComponentDataRef();

    SchemaObject  * pObject = Scope.g_SchemaCache.LookupSchemaObject(
                                CString( szUserClass ),
                                SCHMMGMT_CLASS );
    //
    // Call the attribute check routine.  This routine
    // will call itself recursively to search the
    // inheritance structure of the class User.
    //
    if ( pObject ) {

		fFound = RecursiveIsAttributeInUserClass( strAttribDN, pObject );
        Scope.g_SchemaCache.ReleaseRef( pObject );
    }

    return fFound ;
}


//    Search the user class & subclasses
BOOL
AttributeGeneralPage::RecursiveIsAttributeInUserClass(
   const CString &  strAttribDN,
   SchemaObject *   pObject )
{
    BOOL     fFound  = FALSE;
    
    //
    // Don't process "top" here since everyone inherits from it.
    //
    
    // i don't think we ever get "top" here?
    ASSERT( pObject->ldapDisplayName.CompareNoCase( szTopClass ) );

    if ( !pObject->ldapDisplayName.CompareNoCase(szTopClass) )
        return fFound;

    DebugTrace( L"RecursiveIsAttributeInUserClass: %ls\n",
                const_cast<LPWSTR>((LPCTSTR)pObject->ldapDisplayName) );

    // Check every list
    if( !SearchResultList( strAttribDN, pObject->systemMayContain)  &&
        !SearchResultList( strAttribDN, pObject->mayContain)        &&
        !SearchResultList( strAttribDN, pObject->systemMustContain) &&
        !SearchResultList( strAttribDN, pObject->mustContain) )
    {
        //
        //  The attribute was not found in the given class, diging deeper...
        //  Check each auxiliary class...
        //

        fFound = TraverseAuxiliaryClassList( strAttribDN,
                                             pObject->systemAuxiliaryClass );

        if( !fFound )
        {
            fFound = TraverseAuxiliaryClassList( strAttribDN,
                                                 pObject->auxiliaryClass );
        }
    }
    else
    {
        fFound = TRUE;
    }

    return fFound ;
}


// Linear search of the linked list for the string strAttribDN

BOOL
AttributeGeneralPage::SearchResultList(
    const CString   & strAttribDN,
    ListEntry       * pList )
{
    // Traverse the list
    while ( pList )
    {
        // Searching for the existance of the attribute
        if( !pList->Attribute.CompareNoCase( strAttribDN ) )
            return TRUE;

        pList = pList->pNext;
	}

    return FALSE;
}


// Traverse each auxiliary class by recursivly
// calling RecursiveIsAttributeInUserClass()
BOOL
AttributeGeneralPage::TraverseAuxiliaryClassList(
                const CString   & strAttribDN,
                ListEntry       * pList )
{
    SchemaObject  * pInheritFrom    = NULL;
    ComponentData & Scope           = pComponent->QueryComponentDataRef();
    BOOL            fFound          = FALSE;

    while ( !fFound && pList ) {

        pInheritFrom = Scope.g_SchemaCache.LookupSchemaObject( pList->Attribute,
                                                               SCHMMGMT_CLASS );
        if ( pInheritFrom )
        {
            // recursive call
            fFound = RecursiveIsAttributeInUserClass( strAttribDN, pInheritFrom );

            Scope.g_SchemaCache.ReleaseRef( pInheritFrom );
        }

        pList = pList->pNext;
    }

    return fFound ;
}


HRESULT
AttributeGeneralPage::ChangeDefunctState( BOOL               DDXDefunct,
                                          BOOL             & Defunct,
                                          IADsPropertyList * pPropertyList,
                                          BOOL             & fApplyAbort,
                                          BOOL             & fApplyFailed )
{
    ASSERT( !fApplyAbort && DDXDefunct != Defunct );

    VARIANT AdsValue;
    HRESULT hr = S_OK;
    
    VariantInit( &AdsValue );
    V_VT(&AdsValue) = VT_BOOL;

    if ( DDXDefunct ) {
        V_BOOL(&AdsValue) = -1;
    } else {
        V_BOOL(&AdsValue) = 0;
    }

    hr = pIADsObject->Put( const_cast<BSTR>((LPCTSTR)g_isDefunct),
                           AdsValue );
    ASSERT( SUCCEEDED( hr ) );

    hr = pIADsObject->SetInfo();

    if ( FAILED( hr ) ) {

        pPropertyList->PurgePropertyList();

        if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
        {
            fApplyFailed = TRUE;
            DoErrMsgBox( ::GetActiveWindow(),
                         TRUE,
                         DDXDefunct ? IDS_ERR_EDIT_DEFUNCT_SET : IDS_ERR_EDIT_DEFUNCT_REMOVE );
        }
        else
        {
            fApplyAbort = TRUE; 
            DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
        }

    } else {

        pObject->isDefunct = DDXDefunct;
		Defunct = DDXDefunct;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\aclpage.cpp ===
#include "stdafx.h"

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(aclpage.cpp)")
#include "dataobj.h"
#include "compdata.h"
#include "cookie.h"
#include "snapmgr.h"
#include "schmutil.h"
#include "cache.h"
#include "relation.h"
#include "attrpage.h"
#include "advui.h"
#include "aclpage.h"
#include "ntsecapi.h"  
#include "sddlp.h"

HRESULT
GetDomainSid(LPCWSTR pszLdapPath, PSID *ppSid);

//
// CDynamicLibraryBase
// This is the base class for CDSSecDll and CAclUiDll.
// This was taken from the dnsmgr snap in.
//

class CDynamicLibraryBase {

public:

    CDynamicLibraryBase() {
        m_lpszLibraryName = NULL;
        m_lpszFunctionName = NULL;
        m_hLibrary = NULL;
        m_pfFunction = NULL;
    }

    virtual ~CDynamicLibraryBase() {

        if ( m_hLibrary != NULL ) {
            ::FreeLibrary(m_hLibrary);
            m_hLibrary = NULL;
        }
    }

    //
    // Load a DLL and get a single entry point.
    //

    BOOL Load() {

        if (m_hLibrary != NULL)
            return TRUE; // already loaded

         ASSERT(m_lpszLibraryName != NULL);
         m_hLibrary = ::LoadLibrary(m_lpszLibraryName);

         if (NULL == m_hLibrary) {
             // The library is not present
             return FALSE;
         }

         ASSERT(m_lpszFunctionName != NULL);
         ASSERT(m_pfFunction == NULL);

         m_pfFunction = ::GetProcAddress(m_hLibrary, m_lpszFunctionName );
         if ( NULL == m_pfFunction ) {
             // The library is present but does not have the entry point
             ::FreeLibrary( m_hLibrary );
             m_hLibrary = NULL;
             return FALSE;
         }

         ASSERT(m_hLibrary != NULL);
         ASSERT(m_pfFunction != NULL);
         return TRUE;
    }


protected:

    LPCSTR  m_lpszFunctionName;
    LPCTSTR m_lpszLibraryName;
    FARPROC m_pfFunction;
    HMODULE m_hLibrary;
};

//
// CDsSecDLL - Holds the wrapper for the ACL editor wrapper.
//

class CDsSecDLL : public CDynamicLibraryBase {

public:

    CDsSecDLL() {
        m_lpszLibraryName = _T("dssec.dll");
        m_lpszFunctionName = "DSCreateISecurityInfoObject";
    }

    HRESULT DSCreateISecurityInfoObject( LPCWSTR pwszObjectPath,              // in
                                         LPCWSTR pwszObjectClass,             // in
                                         DWORD   dwFlags,                     // in
                                         LPSECURITYINFO* ppISecurityInfo,     // out
                                         PFNREADOBJECTSECURITY pfnReadSd,     // in
                                         PFNWRITEOBJECTSECURITY pfnWriteSd,   // in
                                         LPARAM lpContext );                  // in
};

HRESULT
CDsSecDLL::DSCreateISecurityInfoObject( LPCWSTR pwszObjectPath,           // in
                                        LPCWSTR pwszObjectClass,          // in
                                        DWORD   dwFlags,                  // in
                                        LPSECURITYINFO* ppISecurityInfo,  // out
                                        PFNREADOBJECTSECURITY pfnReadSd,  // in
                                        PFNWRITEOBJECTSECURITY pfnWriteSd,// in
                                        LPARAM lpContext                  // in
) {

    //
    // Call the function of the same name.
    //

    ASSERT(m_hLibrary != NULL);
    ASSERT(m_pfFunction != NULL);
    return ((PFNDSCREATEISECINFO)m_pfFunction)(
                                                 pwszObjectPath,
                                                 pwszObjectClass,
                                                 dwFlags,
                                                 ppISecurityInfo,
                                                 pfnReadSd,
                                                 pfnWriteSd,
                                                 lpContext );
}

//
// CAclUiDLL - Where the UI Actually Lives.
//

class CAclUiDLL : public CDynamicLibraryBase {

public:

    CAclUiDLL() {
        m_lpszLibraryName = _T("aclui.dll");
        m_lpszFunctionName = "CreateSecurityPage";
    }

    HPROPSHEETPAGE CreateSecurityPage( LPSECURITYINFO psi );
};

HPROPSHEETPAGE CAclUiDLL::CreateSecurityPage( LPSECURITYINFO psi ) {
    ASSERT(m_hLibrary != NULL);
    ASSERT(m_pfFunction != NULL);
    return ((ACLUICREATESECURITYPAGEPROC)m_pfFunction) (psi);
}

//
// CISecurityInformationWrapper - The wrapper for the routine that gets
// sent to CreateSecurityPage().
//

class CISecurityInformationWrapper : public ISecurityInformation {

public:

    CISecurityInformationWrapper( CAclEditorPage* pAclEditorPage ) {
        m_dwRefCount = 0;
        ASSERT(pAclEditorPage != NULL);
        m_pAclEditorPage = pAclEditorPage;
        m_pISecInfo = NULL;
    }

    ~CISecurityInformationWrapper() {
        ASSERT(m_dwRefCount == 0);
        if (m_pISecInfo != NULL)
            m_pISecInfo->Release();
    }

public:

    //
    // *** IUnknown methods ***
    // Call through to the to actual SecurityInformation interface.
    //

    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj) {
        return m_pISecInfo->QueryInterface(riid, ppvObj);
    }

    STDMETHOD_(ULONG,AddRef) () {
        m_dwRefCount++;
        return m_pISecInfo->AddRef();
    }

    STDMETHOD_(ULONG,Release) () {

        m_dwRefCount--;

        ISecurityInformation* pISecInfo = m_pISecInfo;

        return pISecInfo->Release();
    }

    //
    // *** ISecurityInformation methods ***
    // These are also call through.
    //

    STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo ) {
		HRESULT hr = m_pISecInfo->GetObjectInformation(pObjectInfo);
		if (m_szPageTitle.IsEmpty())
		{
			m_szPageTitle.LoadString(IDS_DEFAULT_SECURITY);
		}
		pObjectInfo->dwFlags |= SI_PAGE_TITLE;
		pObjectInfo->pszPageTitle = (PWSTR)(PCWSTR)m_szPageTitle;
        return hr;
    }

    STDMETHOD(GetAccessRights) (const GUID* pguidObjectType,
                                DWORD dwFlags, // SI_EDIT_AUDITS, SI_EDIT_PROPERTIES
                                PSI_ACCESS *ppAccess,
                                ULONG *pcAccesses,
                                ULONG *piDefaultAccess ) {
        return m_pISecInfo->GetAccessRights(pguidObjectType,
                                            dwFlags,
                                            ppAccess,
                                            pcAccesses,
                                            piDefaultAccess);
    }

    STDMETHOD(MapGeneric) (const GUID *pguidObjectType,
                           UCHAR *pAceFlags,
                           ACCESS_MASK *pMask) {
        return m_pISecInfo->MapGeneric(pguidObjectType,
                                       pAceFlags,
                                       pMask);
    }

    STDMETHOD(GetInheritTypes) (PSI_INHERIT_TYPE *ppInheritTypes,
                                ULONG *pcInheritTypes ) {
        return m_pISecInfo->GetInheritTypes(ppInheritTypes,
                                            pcInheritTypes);
    }

    STDMETHOD(PropertySheetPageCallback)(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage ) {
        return m_pISecInfo->PropertySheetPageCallback(hwnd, uMsg, uPage);
    }

    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault) {
        return m_pISecInfo->GetSecurity( RequestedInformation,
                                         ppSecurityDescriptor,
                                         fDefault );
    }

    STDMETHOD(SetSecurity) (SECURITY_INFORMATION securityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor ) {

        return m_pISecInfo->SetSecurity( securityInformation,
                                         pSecurityDescriptor );
    }

private:

    DWORD m_dwRefCount;
    ISecurityInformation* m_pISecInfo;      // interface pointer to the wrapped interface
    CAclEditorPage* m_pAclEditorPage;       // back pointer
	CString m_szPageTitle;
    friend class CAclEditorPage;
};


//
// Static instances of the dynamically loaded DLLs.
//

CDsSecDLL g_DsSecDLL;
CAclUiDLL g_AclUiDLL;

//
// CAclEditorPage Routines.
//

HRESULT
CAclEditorPage::CreateInstance(
    CAclEditorPage ** ppAclPage,
    LPCTSTR lpszLDAPPath,
    LPCTSTR lpszObjectClass
) {

    HRESULT         hr  = S_OK;

    CAclEditorPage* pAclEditorPage = new CAclEditorPage;

    if (pAclEditorPage != NULL) {
        
        hr = pAclEditorPage->Initialize( lpszLDAPPath, lpszObjectClass );
        
        if ( SUCCEEDED(hr) )
        {
            *ppAclPage = pAclEditorPage;
        }
        else
        {
            delete pAclEditorPage;
            pAclEditorPage = NULL;
        }
    }
    else
        hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );

    return hr;
}

CAclEditorPage::CAclEditorPage() {
    m_pISecInfoWrap = new CISecurityInformationWrapper(this);
}

CAclEditorPage::~CAclEditorPage() {
    delete m_pISecInfoWrap;
}

HRESULT
ReadSecurity( LPCWSTR lpszLdapPath,
              SECURITY_INFORMATION RequestedInformation,
              PSECURITY_DESCRIPTOR *ppSecDesc,
              LPARAM lpContext );

HRESULT
WriteSecurity( LPCWSTR lpszLdapPath,
               SECURITY_INFORMATION securityInformation,
               PSECURITY_DESCRIPTOR pSecDesc,
               LPARAM lpContext );

HRESULT
GetObjectSecurityDescriptor( LPCWSTR                 lpszLdapPath,
                             PSECURITY_DESCRIPTOR  * ppSecDesc,
                             IADs                 ** ppIADsObject = NULL );


    
HRESULT
CAclEditorPage::Initialize(
    LPCTSTR lpszLDAPPath,
    LPCTSTR lpszObjectClass
) {

    //
    // Get ISecurityInfo* for this object from DSSEC.DLL
    //

    if (!g_DsSecDLL.Load())
        return E_INVALIDARG;

    ASSERT(m_pISecInfoWrap->m_pISecInfo == NULL);

    return g_DsSecDLL.DSCreateISecurityInfoObject( lpszLDAPPath,
                                                   lpszObjectClass,
                                                   DSSI_NO_ACCESS_CHECK | DSSI_NO_EDIT_OWNER |
                                                     ( IsReadOnly(lpszLDAPPath) ? DSSI_READ_ONLY : 0 ),
                                                   &(m_pISecInfoWrap->m_pISecInfo),
                                                   ReadSecurity,
                                                   WriteSecurity,
                                                   0 );
}

HPROPSHEETPAGE CAclEditorPage::CreatePage() {

    ASSERT(m_pISecInfoWrap->m_pISecInfo != NULL);

    if (!g_AclUiDLL.Load())
        return NULL;

    //
    // Call into ACLUI.DLL to create the page
    // passing the wrapper interface.
    //

    return g_AclUiDLL.CreateSecurityPage(m_pISecInfoWrap);
}



HRESULT
ReadSecurity(
   LPCWSTR                 lpszLdapPath,
   SECURITY_INFORMATION    /*RequestedInformation*/,    // ignoring...
   PSECURITY_DESCRIPTOR*   ppSecDesc,
   LPARAM                  /*lpContext*/)
{
    return GetObjectSecurityDescriptor( lpszLdapPath,
                                        ppSecDesc );
}



#define BREAK_ON_FAILED_BOOL(fResult)                             \
   if ( !fResult )                                                \
   {                                                              \
      ASSERT( FALSE );                                            \
      break;                                                      \
   }


const SECURITY_INFORMATION ALL_SECURITY_INFORMATION  =  OWNER_SECURITY_INFORMATION |
                                                        GROUP_SECURITY_INFORMATION |
                                                        DACL_SECURITY_INFORMATION |
                                                        SACL_SECURITY_INFORMATION;

HRESULT
WriteSecurity(
              LPCWSTR              lpszLdapPath,
              SECURITY_INFORMATION securityInformation,
              PSECURITY_DESCRIPTOR pModificationDescriptor,
              LPARAM               /*lpContext*/)
{
    HRESULT                 hr          = S_OK;
    BOOL                    fResult     = TRUE;
    IADs                  * pIADsObject = NULL;
    PSECURITY_DESCRIPTOR    pSecDesc    = NULL;
    LPWSTR                  pstrSecDesc = NULL;

    
    const UINT cAbsoluteSecDescSize = 5;
    
    struct
    {
        PVOID   pData;
        DWORD   dwDataSize;

    } absSecDesc[cAbsoluteSecDescSize];

    const PSECURITY_DESCRIPTOR  & pAbsSecDesc = (PSECURITY_DESCRIPTOR) absSecDesc[0].pData;

    ZeroMemory( absSecDesc, sizeof(absSecDesc) );

    // we only support changes in DACL & SACL
    ASSERT( securityInformation & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION) );
    ASSERT( IsValidSecurityDescriptor(pModificationDescriptor) );

    do
    {
        hr = GetObjectSecurityDescriptor( lpszLdapPath,
                                          &pSecDesc,
                                          &pIADsObject );
        BREAK_ON_FAILED_HRESULT(hr);
        ASSERT(pIADsObject);

        
        fResult = MakeAbsoluteSD( pSecDesc,
                    (PSECURITY_DESCRIPTOR) absSecDesc[0].pData, &absSecDesc[0].dwDataSize,
                    (PACL) absSecDesc[1].pData, &absSecDesc[1].dwDataSize,
                    (PACL) absSecDesc[2].pData, &absSecDesc[2].dwDataSize,
                    (PSID) absSecDesc[3].pData, &absSecDesc[3].dwDataSize,
                    (PSID) absSecDesc[4].pData, &absSecDesc[4].dwDataSize );

        ASSERT( !fResult );     // the call must fail the first time
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if( ERROR_INSUFFICIENT_BUFFER != HRESULT_CODE(hr) )
            BREAK_ON_FAILED_HRESULT(hr);

        fResult = TRUE;
        hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );

        // allocate memory for the security descriptor
        for( UINT i = 0;  i < cAbsoluteSecDescSize;  i++ )
            if( absSecDesc[i].dwDataSize > 0 )
                if( NULL == (absSecDesc[i].pData = new BYTE[ absSecDesc[i].dwDataSize ]) )
                    break;
        hr = S_OK;

        fResult = MakeAbsoluteSD( pSecDesc,
                    (PSECURITY_DESCRIPTOR) absSecDesc[0].pData, &absSecDesc[0].dwDataSize,
                    (PACL) absSecDesc[1].pData, &absSecDesc[1].dwDataSize,
                    (PACL) absSecDesc[2].pData, &absSecDesc[2].dwDataSize,
                    (PSID) absSecDesc[3].pData, &absSecDesc[3].dwDataSize,
                    (PSID) absSecDesc[4].pData, &absSecDesc[4].dwDataSize );

        BREAK_ON_FAILED_BOOL( fResult );


        // for convinience, have another reference.
        ASSERT( absSecDesc[0].pData == pAbsSecDesc );
        ASSERT( IsValidSecurityDescriptor(pAbsSecDesc) );
       

        // Apply DACL changes
        if( securityInformation & DACL_SECURITY_INFORMATION )
        {
            BOOL                        bDaclPresent    = FALSE;
            PACL                        pDacl           = NULL;
            BOOL                        bDaclDefaulted  = FALSE;
            SECURITY_DESCRIPTOR_CONTROL control         = 0;
            DWORD                       dwRevision      = 0;

            fResult = GetSecurityDescriptorDacl( pModificationDescriptor, &bDaclPresent, &pDacl, &bDaclDefaulted );
            BREAK_ON_FAILED_BOOL( fResult );

            fResult = SetSecurityDescriptorDacl( pAbsSecDesc, bDaclPresent, pDacl, bDaclDefaulted );
            BREAK_ON_FAILED_BOOL( fResult );

            fResult = GetSecurityDescriptorControl( pModificationDescriptor, &control, &dwRevision );
            BREAK_ON_FAILED_BOOL( fResult );

            fResult = SetSecurityDescriptorControl( pAbsSecDesc, SE_DACL_PROTECTED, control & SE_DACL_PROTECTED );
            BREAK_ON_FAILED_BOOL( fResult );
        }
        

        // Apply SACL changes
        if( securityInformation & SACL_SECURITY_INFORMATION )
        {
            BOOL                        bSaclPresent    = FALSE;
            PACL                        pSacl           = NULL;
            BOOL                        bSaclDefaulted  = FALSE;
            SECURITY_DESCRIPTOR_CONTROL control         = 0;
            DWORD                       dwRevision      = 0;

            fResult = GetSecurityDescriptorSacl( pModificationDescriptor, &bSaclPresent, &pSacl, &bSaclDefaulted );
            BREAK_ON_FAILED_BOOL( fResult );

            fResult = SetSecurityDescriptorSacl( pAbsSecDesc, bSaclPresent, pSacl, bSaclDefaulted );
            BREAK_ON_FAILED_BOOL( fResult );

            fResult = GetSecurityDescriptorControl( pModificationDescriptor, &control, &dwRevision );
            BREAK_ON_FAILED_BOOL( fResult );

            fResult = SetSecurityDescriptorControl( pAbsSecDesc, SE_SACL_PROTECTED, control & SE_SACL_PROTECTED );
            BREAK_ON_FAILED_BOOL( fResult );
        }
        
        
        // Convert Security Descriptor to string format
        fResult = ConvertSecurityDescriptorToStringSecurityDescriptor(
            pAbsSecDesc,
            SDDL_REVISION,
            ALL_SECURITY_INFORMATION,
            &pstrSecDesc,
            NULL );
        BREAK_ON_FAILED_BOOL( fResult );
        ASSERT(pstrSecDesc);

        CComVariant v(pstrSecDesc);
        hr = pIADsObject->Put( const_cast<LPTSTR>((LPCTSTR)g_DefaultAcl), v);
        BREAK_ON_FAILED_HRESULT(hr);
        
        hr = pIADsObject->SetInfo( );
    }
    while (0);
    
    if( !fResult )
        hr = HRESULT_FROM_WIN32(::GetLastError());

    if( pIADsObject )
        pIADsObject->Release();

    if( pstrSecDesc )
        LocalFree( pstrSecDesc );
    
    for( UINT i = 0;  i < cAbsoluteSecDescSize;  i++ )
        if( absSecDesc[i].pData )
            delete absSecDesc[i].pData;

    return hr;
}



HRESULT
GetObjectSecurityDescriptor(
    LPCWSTR                 lpszLdapPath,
    PSECURITY_DESCRIPTOR  * ppSecDesc,
    IADs                 ** ppIADsObject /* = NULL */)  // returns pIADsObject for future use.
{
    HRESULT      hr          = S_OK;
    IADs       * pIADsObject = NULL;
    CComVariant  AdsResult;
    PSID pDomainSid = NULL;

    
    *ppSecDesc   = NULL;
    
    do
    {
        hr = ::ADsGetObject( const_cast<LPWSTR>((LPCWSTR) lpszLdapPath),
                             IID_IADs,
                             (void **) &pIADsObject );
        BREAK_ON_FAILED_HRESULT(hr);
        ASSERT(pIADsObject);
        
        hr = pIADsObject->Get( const_cast<LPTSTR>((LPCTSTR) g_DefaultAcl),
            &AdsResult);
        BREAK_ON_FAILED_HRESULT(hr);

        pDomainSid = NULL;
        GetDomainSid(lpszLdapPath, &pDomainSid);
        if(pDomainSid)
        {
            if(!ConvertStringSDToSDDomain(pDomainSid,
                                          NULL,
                                          V_BSTR(&AdsResult),
                                          SDDL_REVISION,
                                          ppSecDesc,
                                          NULL )) 
            {
                ASSERT( FALSE );
                hr = HRESULT_FROM_WIN32(::GetLastError());
                break;
            }
        }
        else if( !ConvertStringSecurityDescriptorToSecurityDescriptor(
            V_BSTR(&AdsResult),
            SDDL_REVISION,
            ppSecDesc,
            NULL ) )
        {
            ASSERT( FALSE );
            hr = HRESULT_FROM_WIN32(::GetLastError());
            break;
        }

        ASSERT( IsValidSecurityDescriptor(*ppSecDesc) );
    }
    while (0);
    
    if( pIADsObject )
    {
        ASSERT( SUCCEEDED(hr) );
        
        if( !ppIADsObject )     // if caller doesn't need pIADsObject
        {
            pIADsObject->Release();         // release it
        }
        else
        {
            *ppIADsObject = pIADsObject;    // otherwise, return it
        }
    }            
         
    if(pDomainSid)
        LocalFree(pDomainSid);            
    return hr;
}


BOOL CAclEditorPage::IsReadOnly( LPCTSTR lpszLDAPPath )
{
    ASSERT( lpszLDAPPath );

    HRESULT         hr      = S_OK;
    BOOL            fFound  = FALSE;
    CComPtr<IADs>   ipADs;
    CStringList     strlist;

    do
    {
       //
        // Open the schema container.
        //
        hr = ADsGetObject( (LPWSTR)(LPCWSTR)lpszLDAPPath,
                           IID_IADs,
                           (void **)&ipADs );
        BREAK_ON_FAILED_HRESULT(hr);

        // extract the list of allowed classes
        hr = GetStringListElement( ipADs, &g_allowedAttributesEffective, strlist );
        BREAK_ON_FAILED_HRESULT(hr);

        // search for needed attributes
        for( POSITION pos = strlist.GetHeadPosition(); !fFound && pos != NULL; )
        {
            CString * pstr = &strlist.GetNext( pos );
            
            fFound = !pstr->CompareNoCase( g_DefaultAcl );
        }

    } while( FALSE );

    return !fFound;     // in case something fails, make read-only.
}


LSA_HANDLE
GetLSAConnection(LPCTSTR pszServer, DWORD dwAccessDesired)
{
    LSA_HANDLE hPolicy = NULL;
    LSA_UNICODE_STRING uszServer = {0};
    LSA_UNICODE_STRING *puszServer = NULL;
    LSA_OBJECT_ATTRIBUTES oa;
    SECURITY_QUALITY_OF_SERVICE sqos;

    sqos.Length = sizeof(sqos);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = FALSE;

    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    oa.SecurityQualityOfService = &sqos;

    if (pszServer &&
        *pszServer &&
        RtlCreateUnicodeString(&uszServer, pszServer))
    {
        puszServer = &uszServer;
    }

    LsaOpenPolicy(puszServer, &oa, dwAccessDesired, &hPolicy);

    if (puszServer)
        RtlFreeUnicodeString(puszServer);

    return hPolicy;
}

HRESULT
GetDomainSid(LPCWSTR pszLdapPath, PSID *ppSid)
{
    HRESULT hr = S_OK;
    NTSTATUS nts = STATUS_SUCCESS;
    PPOLICY_ACCOUNT_DOMAIN_INFO pDomainInfo = NULL;
    LSA_HANDLE hLSA = 0;
    if(!pszLdapPath || !ppSid)
        return E_INVALIDARG;

    *ppSid = NULL;

    IADsPathname *pPath = NULL;
    BSTR bstrServer = NULL;

    CoCreateInstance(CLSID_Pathname,
                     NULL,
                     CLSCTX_INPROC_SERVER,
                     IID_IADsPathname,
                     (LPVOID*)&pPath);

    if(pPath)
    {
        if(SUCCEEDED(pPath->Set((BSTR)pszLdapPath,ADS_SETTYPE_FULL)))
        {
            if(SUCCEEDED(pPath->Retrieve(ADS_FORMAT_SERVER, &bstrServer)))
            {
                hLSA = GetLSAConnection(bstrServer, POLICY_VIEW_LOCAL_INFORMATION);
                if (!hLSA)
                {
                    hr = E_FAIL;
                    goto exit_gracefully;
                }

    
                nts = LsaQueryInformationPolicy(hLSA,
                                                PolicyAccountDomainInformation,
                                                (PVOID*)&pDomainInfo);
                if(nts != STATUS_SUCCESS)
                {
                    hr = E_FAIL;
                    goto exit_gracefully;
                }

                if (pDomainInfo && pDomainInfo->DomainSid)
                {
                    ULONG cbSid = GetLengthSid(pDomainInfo->DomainSid);

                    *ppSid = (PSID) LocalAlloc(LPTR, cbSid);

                    if (!*ppSid)
                    {
                        hr = E_OUTOFMEMORY;
                        goto exit_gracefully;
                    }

                    CopyMemory(*ppSid, pDomainInfo->DomainSid, cbSid);
                }
            }
        }
    }

exit_gracefully:
    if(pDomainInfo)
        LsaFreeMemory(pDomainInfo);          
    if(hLSA)
        LsaClose(hLSA);
    if(bstrServer)
        SysFreeString(bstrServer);
    if(pPath)
        pPath->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\cache.h ===
/****

Cache.h
CoryWest@Microsoft.Com

The schema caching routines to improve browsing performance.

Copyright July 1997, Microsoft Corporation

****/

#include "nodetype.h"

#ifndef __CACHE_H_INCLUDED__
#define __CACHE_H_INCLUDED__

//
// The schema class objects.
//

#define HASH_TABLE_SIZE 1000

class SchemaObject;
class ListEntry;

class SchemaObjectCache {

    //
    // We let certain routines walk the hash table
    // to populate the list views.
    //

    friend class Component;
    friend class ComponentData;
    friend class CSchmMgmtSelect;
    friend class ClassGeneralPage;

    friend HRESULT StringListToColumnList(
                       ComponentData* pScopeControl,
                       CStringList& refstringlist,
                       ListEntry **ppNewList );

private:

    //
    // A rudimentary hash table with no resizing.
    //

    BOOLEAN fInitialized;
    UINT buckets;
    SchemaObject** hash_table;

    UINT CalculateHashKey( CString HashKey );

    //
    // The server sorted lists of elements.
    //

    SchemaObject* pSortedClasses;
    SchemaObject* pSortedAttribs;

public:

    //
    // Initialize and cleanup the cache.
    //

    SchemaObjectCache();
    ~SchemaObjectCache();

    //
    // Access routines.  ReleaseRef() must be called after every
    // LookupSchemaObject when the caller is done with the the
    // SchemaObject pointer.
    //
    // LookupSchemaObject takes an object type because there
    // may be a class and an attribute with the same ldapDisplayName.
    //

    HRESULT InsertSchemaObject( SchemaObject* Object );
    HRESULT InsertSortedSchemaObject( SchemaObject *Object );

    SchemaObject* LookupSchemaObject( CString ldapDisplayName,
                                      SchmMgmtObjectType ObjectType );
    SchemaObject* LookupSchemaObjectByCN( LPCTSTR pszCN,
                                          SchmMgmtObjectType objectType );

    VOID ReleaseRef( SchemaObject* pObject );

    //
    // Load and reload.
    //

    HRESULT LoadCache( VOID );

    HRESULT ProcessSearchResults( IDirectorySearch *pDSSearch,
                                  ADS_SEARCH_HANDLE hSearchHandle,
                                  SchmMgmtObjectType ObjectType );
    VOID InsertSortedTail( SchemaObject* pObject );

    ListEntry* MakeColumnList( PADS_SEARCH_COLUMN pColumn );
    VOID FreeColumnList( ListEntry *pListHead );

    VOID FreeAll( );

    //
    // The scope control that this is the cache for.
    //

    VOID SetScopeControl( ComponentData *pScope ) {
        pScopeControl = pScope;
    }

    //
    // Has the schema been loaded
    //
    BOOLEAN IsSchemaLoaded() { return fInitialized; }

    ComponentData *pScopeControl;
};



class SchemaObject {

private:
public:

    //
    // The hash chain variable.
    //

    SchemaObject* pNext;

    SchemaObject* pSortedListFlink;
    SchemaObject* pSortedListBlink;

    //
    // Constructors.
    //

    SchemaObject();
    ~SchemaObject();

    //
    // The common object information.
    // The ldap display name is the hash key.
    //

    CString ldapDisplayName;
    CString commonName;
    CString description;

    //
    // If this is an object that we have added, it
    // will have an oid here and we should refer to
    // the object by its oid since that is the only
    // way we can guarantee that the ds will know
    // the object.
    //

    CString oid;

    //
    // If this object is defunct, do not show it in the
    // classes or attributes select box!
    //

    BOOL isDefunct;

    SchmMgmtObjectType schemaObjectType;

    //
    // Class object specific data for the cache.
    //

    DWORD dwClassType;

    ListEntry *systemMayContain;
    ListEntry *mayContain;

    ListEntry *systemMustContain;
    ListEntry *mustContain;

    ListEntry *systemAuxiliaryClass;
    ListEntry *auxiliaryClass;

    CString subClassOf;

    //
    // Attribute object specific data for the cache.
    //

    UINT SyntaxOrdinal;

};

class ListEntry {

private:
public:

    ListEntry *pNext;
    CString Attribute;

    ListEntry() { pNext = NULL; }
    ~ListEntry() { ; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\attrpage.cpp ===
//
// attrpage.cpp : Implementation of ClassAttributePage
//
// Jon Newman <jonn@microsoft.com>
// Copyright (c) Microsoft Corporation 1997
//
// templated from relation.cpp JonN 8/8/97
//

#include "stdafx.h"

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(attrpage.cpp)")

#include "compdata.h"
#include "schmutil.h"
#include "select.h"
#include "attrpage.h"


const CDialogControlsInfo ctrls[] =
{
//    { IDC_CLASS_MMB_MANDATORY_ATTRIBUTES,   g_MustContain,  FALSE },
//    { IDC_CLASS_MMB_OPTIONAL_ATTRIBUTES,    g_MayContain,   FALSE },
    { IDC_CLASS_MMB_OPTIONAL_ADD,           g_MayContain,   FALSE },
    { IDC_CLASS_MMB_OPTIONAL_REMOVE,        g_MayContain,   FALSE },
} ;


const DWORD ClassAttributePage::help_map[] =
{
    IDI_CLASS,                          NO_HELP,
    IDC_CLASS_MMB_NAME_STATIC,          NO_HELP,
    IDC_CLASS_MMB_MANDATORY_ATTRIBUTES, IDH_CLASS_MMB_MANDATORY_ATTRIBUTES,
    IDC_CLASS_MMB_OPTIONAL_ATTRIBUTES,  IDH_CLASS_MMB_OPTIONAL_ATTRIBUTES,
    IDC_CLASS_MMB_SYSCLASS_STATIC,      NO_HELP,
    IDC_CLASS_MMB_OPTIONAL_ADD,         IDH_CLASS_MMB_OPTIONAL_ADD,
    IDC_CLASS_MMB_OPTIONAL_REMOVE,      IDH_CLASS_MMB_OPTIONAL_REMOVE,
    0,0
};


ClassAttributePage::ClassAttributePage(
   ComponentData *pScope,
   LPDATAOBJECT lpDataObject )
   :
   CPropertyPage(ClassAttributePage::IDD),
   m_pIADsObject( NULL ),
   fSystemClass( FALSE ),
   m_pSchemaObject( NULL ),
   pScopeControl( pScope ),
   lpScopeDataObj( lpDataObject )
{
   ASSERT(pScopeControl);
   ASSERT(lpDataObject);
}



ClassAttributePage::~ClassAttributePage()
{
   if (NULL != m_pIADsObject)
   {
      m_pIADsObject->Release();
   }

   if (NULL != m_pSchemaObject)
   {
      pScopeControl->g_SchemaCache.ReleaseRef( m_pSchemaObject );
   }
}



void
ClassAttributePage::Load(
    Cookie& CookieRef
) {

    //
    // Store the cookie object pointer.
    //

    m_pCookie = &CookieRef;
    return;

}

BOOL
ClassAttributePage::OnSetActive()
{
   // always enable the Apply button
   SetModified(TRUE);

   return TRUE;
}



BOOL
ClassAttributePage::OnInitDialog()
{
    HRESULT hr = S_OK;
    ASSERT( NULL == m_pIADsObject && m_szAdsPath.IsEmpty() );

    //
    // Get the schema cache object and the actual ADS object.
    //

    m_pSchemaObject = pScopeControl->g_SchemaCache.LookupSchemaObjectByCN(
                      (PCWSTR)m_pCookie->strSchemaObject,
                      SCHMMGMT_CLASS );

    if ( m_pSchemaObject ) {

        pScopeControl->GetSchemaObjectPath( m_pSchemaObject->commonName, m_szAdsPath );

        if ( !m_szAdsPath.IsEmpty() ) {

           hr = ADsGetObject( (LPWSTR)(LPCWSTR)m_szAdsPath,
                              IID_IADs,
                              (void **)&m_pIADsObject );

           ASSERT( SUCCEEDED(hr) );
        }

    }

    //
    // If we have no ADS object, we should error out!
    //

    if ( !m_pIADsObject ) {
        DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_SCHEMA_OBJECT );

        ASSERT(FALSE);
        return TRUE;
    }

    //
    // get the current values.
    //

    VARIANT AdsResult;
    VariantInit( &AdsResult );

    //
    // ObjectName
    //

    hr = m_pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_DisplayName),
                          &AdsResult );
   if ( SUCCEEDED( hr ) ) {
      ASSERT( AdsResult.vt == VT_BSTR );
      ObjectName = AdsResult.bstrVal;
      VariantClear( &AdsResult );
    }

    //
    // SysClass
    //

    hr = m_pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_SystemOnly),
                           &AdsResult );

    if ( SUCCEEDED( hr ) ) {

        ASSERT( AdsResult.vt == VT_BOOL );
                fSystemClass = AdsResult.boolVal;

        if ( fSystemClass ) {
            SysClassString = g_SysClassString;
        } else {
            SysClassString = L"";
        }

        VariantClear( &AdsResult );

    } else {
        SysClassString = L"";
    }

    //
    // Determine the mandatory attributes
    //

    VARIANT varAttributes;
    VariantInit( &varAttributes );

    hr = m_pIADsObject->GetEx( g_MustContain, &varAttributes );
    ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );

    if( SUCCEEDED(hr) )
    {
        hr = VariantToStringList( varAttributes, strlistMandatory );
        ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    }
    VariantClear( &varAttributes );

    hr = m_pIADsObject->GetEx( g_SystemMustContain, &varAttributes );
    ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );

    if( SUCCEEDED(hr) )
    {
        hr = VariantToStringList( varAttributes, strlistSystemMandatory );
        ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    }
    VariantClear( &varAttributes );

    //
    // Determine the optional attributes
    //

    hr = m_pIADsObject->GetEx( g_MayContain, &varAttributes );
    ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );

    if( SUCCEEDED(hr) )
    {
        hr = VariantToStringList( varAttributes, strlistOptional );
        ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    }
    VariantClear( &varAttributes );

    hr = m_pIADsObject->GetEx( g_SystemMayContain, &varAttributes );
    ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );

    if( SUCCEEDED(hr) )
    {
        hr = VariantToStringList( varAttributes, strlistSystemOptional );
        ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    }
    VariantClear( &varAttributes );

    
    hr = DissableReadOnlyAttributes( this, m_pIADsObject, ctrls, sizeof(ctrls)/sizeof(ctrls[0]) );
    ASSERT( SUCCEEDED(hr) );     // shouldn't fail, but unimportant, so ignore error


    // This call must be done before DDX binding
    m_listboxOptional.InitType( pScopeControl,
                                SELECT_ATTRIBUTES,
                                IDC_CLASS_MMB_OPTIONAL_REMOVE,
                                &strlistSystemOptional
                              );
    
    CPropertyPage::OnInitDialog();

    return TRUE;
}



void
ClassAttributePage::DoDataExchange(
    CDataExchange *pDX
) {

    HRESULT hr = S_OK;

    CPropertyPage::DoDataExchange( pDX );

    //{{AFX_DATA_MAP(ClassAttributePage)
    DDX_Control(pDX, IDC_CLASS_MMB_MANDATORY_ATTRIBUTES, m_listboxMandatory);
    DDX_Control(pDX, IDC_CLASS_MMB_OPTIONAL_ATTRIBUTES, m_listboxOptional);
    DDX_Text( pDX, IDC_CLASS_MMB_NAME_STATIC, ObjectName );
    DDX_Text( pDX, IDC_CLASS_MMB_SYSCLASS_STATIC, SysClassString );
    //}}AFX_DATA_MAP

    if ( !pDX->m_bSaveAndValidate )
    {
        //
        // Fill the mandatory attributes list box.
        //

        m_listboxMandatory.ResetContent();
        hr = InsertEditItems( m_listboxMandatory, strlistMandatory );
        ASSERT( SUCCEEDED(hr) );

        hr = InsertEditItems( m_listboxMandatory, strlistSystemMandatory );
        ASSERT( SUCCEEDED(hr) );

        //
        // Fill the possible optionals list box.
        //

        m_listboxOptional.ResetContent();
        hr = InsertEditItems( m_listboxOptional, strlistOptional );
        ASSERT( SUCCEEDED(hr) );

        hr = InsertEditItems( m_listboxOptional, strlistSystemOptional );
        ASSERT( SUCCEEDED(hr) );

        m_listboxOptional.OnSelChange();
    }
    else
    {
        //
        // All changes that we save are tied to button control routines.
        //

        strlistMandatory.RemoveAll();
        hr = RetrieveEditItemsWithExclusions(
                m_listboxMandatory,
                strlistMandatory,
                &strlistSystemMandatory
                );
        ASSERT( SUCCEEDED(hr) );

        strlistOptional.RemoveAll();
        hr = RetrieveEditItemsWithExclusions(
                m_listboxOptional,
                strlistOptional,
                &strlistSystemOptional
                );
        ASSERT( SUCCEEDED(hr) );
    }
}



BEGIN_MESSAGE_MAP(ClassAttributePage, CPropertyPage)
   ON_BN_CLICKED(IDC_CLASS_MMB_OPTIONAL_ADD,           OnButtonOptionalAttributeAdd)   
   ON_BN_CLICKED(IDC_CLASS_MMB_OPTIONAL_REMOVE,        OnButtonOptionalAttributeRemove)
   ON_LBN_SELCHANGE(IDC_CLASS_MMB_OPTIONAL_ATTRIBUTES, OnOptionalSelChange)            
   ON_MESSAGE(WM_HELP,                                 OnHelp)                         
   ON_MESSAGE(WM_CONTEXTMENU,                          OnContextHelp)
END_MESSAGE_MAP()



BOOL
ClassAttributePage::OnApply()
{

    ASSERT( NULL != m_pIADsObject);
    ASSERT( NULL != m_pSchemaObject);

    HRESULT hr = S_OK;
    BOOL    fApplyAbort    = FALSE;  // stop later saves
    BOOL    fApplyFailed   = FALSE;  // should not close the box

    ListEntry *pNewList;

    if ( m_listboxOptional.IsModified() )
    {
        //
        // Update the optional attributes
        //

        VARIANT AdsValue;
        VariantInit( &AdsValue );

        hr = StringListToVariant( AdsValue, strlistOptional );
        ASSERT( SUCCEEDED(hr) );

        hr = m_pIADsObject->PutEx( ADS_PROPERTY_UPDATE, g_MayContain, AdsValue );
        ASSERT( SUCCEEDED(hr)  );

        VariantClear( &AdsValue );

        hr = m_pIADsObject->SetInfo();

        if ( SUCCEEDED( hr )) {

            //
            // Update the cached data.
            //

            hr = StringListToColumnList( pScopeControl,
                                         strlistOptional,
                                         &pNewList );

            if ( SUCCEEDED( hr )) {

                pScopeControl->g_SchemaCache.FreeColumnList( m_pSchemaObject->mayContain );
                m_pSchemaObject->mayContain = pNewList;

            }

            //
            // Continue with the directory operation even if
            // we couldn't update the cache.
            //

            hr = S_OK;

        }
    }

    if ( hr == ADS_EXTENDED_ERROR ) {
        DoExtErrMsgBox();
    }
    else if ( FAILED(hr) )
    {
        if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
        {
            fApplyFailed = TRUE;
            DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_CHANGE_REJECT );
        }
        else
        {
            fApplyAbort = TRUE; 
            DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
        }
    }
    else
    {
        m_listboxOptional.SetModified( FALSE );

        SetModified( FALSE );

        //
        // Refresh the display!
        //

        pScopeControl->QueryConsole()->UpdateAllViews(
            lpScopeDataObj, SCHMMGMT_CLASS, SCHMMGMT_UPDATEVIEW_REFRESH );

    }

    return !fApplyAbort && !fApplyFailed ;      // return TRUE if nothing happened
}



void ClassAttributePage::OnOptionalSelChange()
{
    m_listboxOptional.OnSelChange();
}



void ClassAttributePage::OnButtonOptionalAttributeRemove()
{
    if( m_listboxOptional.RemoveListBoxItem() )
        SetModified( TRUE );
}



void
ClassAttributePage::OnButtonOptionalAttributeAdd()
{
    if( m_listboxOptional.AddNewObjectToList() )
        SetModified( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\classgen.cpp ===
#include "stdafx.h"
#include "compdata.h"
#include "select.h"
#include "classgen.hpp"




/////////////////////////////////////////////////////////////////
// ClassGeneralPage


const CDialogControlsInfo ctrls[] =    
{
    { IDC_CLASS_GENERAL_DESCRIPTION_EDIT,   g_Description,       TRUE },
    { IDC_CATEGORY_CHANGE,                  g_DefaultCategory,   FALSE },
    { IDC_CLASS_GENERAL_DISPLAYABLE_CHECK,  g_ShowInAdvViewOnly, FALSE },
    { IDC_CLASS_DEACTIVATE,                 g_isDefunct,           FALSE }
};

const DWORD ClassGeneralPage::help_map[] =
{
    IDI_CLASS,                           NO_HELP,
    IDC_CLASS_GENERAL_NAME_STATIC,       NO_HELP,
    IDC_CLASS_GENERAL_DESCRIPTION_EDIT,  IDH_CLASS_GENERAL_DESCRIPTION_EDIT,
    IDC_CLASS_GENERAL_LDN,               IDH_CLASS_GENERAL_LDN,
    IDC_CLASS_GENERAL_OID_EDIT,          IDH_CLASS_GENERAL_OID_EDIT,
    IDC_CLASS_GENERAL_CATEGORY_COMBO,    IDH_CLASS_GENERAL_CATEGORY_COMBO,
    IDC_CATEGORY_EDIT,                   IDH_CATEGORY_EDIT,
    IDC_CATEGORY_CHANGE,                 IDH_CATEGORY_CHANGE,
    IDC_CLASS_GENERAL_DISPLAYABLE_CHECK, IDH_CLASS_GENERAL_DISPLAYABLE_CHECK,
    IDC_CLASS_DEACTIVATE,                IDH_CLASS_DEACTIVATE,
    IDC_CLASS_GENERAL_SYSCLASS_STATIC,   NO_HELP,
    0,                                   0
};

//
// The MFC Message Map.
//

BEGIN_MESSAGE_MAP( ClassGeneralPage, CDialog )
    ON_BN_CLICKED( IDC_CATEGORY_CHANGE,  OnButtonCategoryChange  )
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
    ON_BN_CLICKED(IDC_CLASS_DEACTIVATE, OnDeactivateClick)
END_MESSAGE_MAP()

//
// Class dialog box routines.
//



ClassGeneralPage::ClassGeneralPage( ComponentData *pScope ) :
    CPropertyPage( IDD_CLASS_GENERAL ),
    fDataLoaded( FALSE ),
    pIADsObject( NULL ),
    pObject( NULL ),
    pScopeControl( pScope )
{ ; }

ClassGeneralPage::~ClassGeneralPage() {

    //
    // Always make sure we free the IADs object.
    //

    if ( pIADsObject ) {
        pIADsObject->Release();
        pIADsObject = NULL;
    }

    //
    // And release the cache!
    //

    if ( pObject ) {
        pScopeControl->g_SchemaCache.ReleaseRef( pObject );
    }

}



BOOL
ClassGeneralPage::OnInitDialog()
{
   CPropertyPage::OnInitDialog();

   CWnd* wnd = GetDlgItem(IDC_CLASS_GENERAL_DESCRIPTION_EDIT);
   ASSERT(wnd);
   if (wnd)
   {
      wnd->SendMessage(EM_SETLIMITTEXT, (WPARAM) 1024, 0);
   }

   return TRUE;
}




BOOL
ClassGeneralPage::OnSetActive()
{
   // If pIADsObject is NULL, close dialog box
   if( CPropertyPage::OnSetActive() )
   {
      if ( !pIADsObject )
      {
         return FALSE;
      }
      else
      {
         // always enable the Apply button 
         SetModified(TRUE);

         return TRUE;
      }
   }
   else
      return FALSE;
}


void
ClassGeneralPage::Load(
    Cookie& CookieRef
) {

    //
    // Store the cookie object pointer.  Everything
    // else gets loaded when the page is displayed.
    //

    pCookie = &CookieRef;
    return;

}

void
ClassGeneralPage::DoDataExchange(
    CDataExchange *pDX
)
/***

    This routine picks up the object name out of the
    cookie and then looks up the ADSI path name out of
    the schema object cache.  It then drives the dialog
    box directly from the ADS object.

***/
{

    HRESULT hr;
    CString szAdsPath;
    VARIANT AdsResult;
    DWORD dwClassType;

    CPropertyPage::DoDataExchange( pDX );

    VariantInit( &AdsResult );

    if ( !pDX->m_bSaveAndValidate ) {


        //
        // If this is not the initial load and is not
        // the save, just use the data that we've loaded.
        //

        if ( !fDataLoaded ) {

            CWaitCursor wait;

            //
            // Get the schema cache object and the actual ADS object.
            // Keep both around while the page is loaded.
            //
        
            pObject = pScopeControl->g_SchemaCache.LookupSchemaObjectByCN(
                          pCookie->strSchemaObject,
                          SCHMMGMT_CLASS );

            if ( pObject ) {

                pScopeControl->GetSchemaObjectPath( pObject->commonName, szAdsPath );

                if ( !szAdsPath.IsEmpty() ) {

                    hr = ADsGetObject( (LPWSTR)(LPCWSTR)szAdsPath,
                                       IID_IADs,
                                       (void **)&pIADsObject );
                }
            }

            //
            // If we have no ADS object, we should error out!
            //

            if ( !pIADsObject ) {
                DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_SCHEMA_OBJECT );

				// Because there is no pIADsObject, OnSetActive() will close dialog box
                return;
            }

            //
            // ObjectName - Use the ldapDisplayName to be consistent with
            // the other admin components.
            //

            hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_DisplayName),
                                   &AdsResult );

            if ( SUCCEEDED( hr ) ) {

                ASSERT( AdsResult.vt == VT_BSTR );
                ObjectName = AdsResult.bstrVal;
                VariantClear( &AdsResult );
            }

            //
            //
            // CommonName
            //

            hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_CN),
                                   &AdsResult );

            if ( SUCCEEDED( hr ) ) {

                ASSERT( AdsResult.vt == VT_BSTR );
                DisplayName = AdsResult.bstrVal;
                VariantClear( &AdsResult );
            }

            //
            // Description
            //

            hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_Description),
                                   &AdsResult );

            if ( SUCCEEDED( hr ) ) {

                ASSERT( AdsResult.vt == VT_BSTR );
                Description = AdsResult.bstrVal;
                DDXDescription = AdsResult.bstrVal;
                VariantClear( &AdsResult );
            }

            //
            // OID
            //

            hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_GlobalClassID),
                                   &AdsResult );

            if ( SUCCEEDED( hr ) ) {

                ASSERT( AdsResult.vt == VT_BSTR );
                OidString = AdsResult.bstrVal;
                VariantClear( &AdsResult );
            }

            //
            // Displayable
            //

            Displayable = TRUE;
            DDXDisplayable = TRUE;

            hr = pIADsObject->Get(g_ShowInAdvViewOnly, &AdsResult);

            if ( SUCCEEDED( hr ) ) {

                ASSERT( AdsResult.vt == VT_BOOL );

                if ( AdsResult.boolVal == -1 ) {
                    Displayable = FALSE;
                    DDXDisplayable = FALSE;
                }

                VariantClear( &AdsResult );

            }

            //
            // Defunct
            //

            Defunct = FALSE;
            DDXDefunct = FALSE;

            hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_isDefunct),
                                   &AdsResult );

            if ( SUCCEEDED( hr ) ) {

                ASSERT( AdsResult.vt == VT_BOOL );

                if ( AdsResult.boolVal == -1 ) {
                    Defunct = TRUE;
                    DDXDefunct = TRUE;
                }

                VariantClear( &AdsResult );

            }

            //
            // SysClass
            //

            hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_SystemOnly),
                                   &AdsResult );

            if ( SUCCEEDED( hr ) ) {

                ASSERT( AdsResult.vt == VT_BOOL );

                if ( AdsResult.boolVal ) {
                    SysClassString = g_SysClassString;
                } else {
                    SysClassString = L"";
                }

                VariantClear( &AdsResult );

            } else {

                SysClassString = L"";
            }

            //
            // ClassType
            //

            hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_ObjectClassCategory),
                                   &AdsResult );

            if ( SUCCEEDED( hr ) ) {

                ASSERT( AdsResult.vt == VT_I4 );
                dwClassType = V_I4( &AdsResult );
                VariantClear( &AdsResult );

                switch ( dwClassType ) {
                case 0:

                    ClassType = g_88Class;
                    break;

                case 1:

                    ClassType = g_StructuralClass;
                    break;

                case 2:

                    ClassType = g_AbstractClass;
                    break;

                case 3:

                    ClassType = g_AuxClass;
                    break;

                default:

                    ClassType = g_Unknown;
                    break;

                }
            }

            //
            // Category
            //

            hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_DefaultCategory),
                                   &AdsResult );

            if ( SUCCEEDED( hr ) ) {

                ASSERT( V_VT(&AdsResult) == VT_BSTR );

                CString strCN;

                if( SUCCEEDED( pScopeControl->GetLeafObjectFromDN( V_BSTR(&AdsResult), strCN ) ))
                {
                    //
                    // Look up the ldapDisplayName.
                    //
                    SchemaObject * pCategory =
                        pScopeControl->g_SchemaCache.LookupSchemaObjectByCN( strCN, SCHMMGMT_CLASS );

                    if ( pCategory )
                    {
                        Category = DDXCategory = pCategory->ldapDisplayName;
                        pScopeControl->g_SchemaCache.ReleaseRef( pCategory );
                    }
                    else
                    {
                        Category = DDXCategory = strCN;
                    }
                }

                VariantClear( &AdsResult );
            }

            
            // Determine if this is a category 1 object & disable read-only fields
            BOOL  fIsSystemObject = FALSE;

            hr = IsCategory1Object( pIADsObject, fIsSystemObject );
            if( SUCCEEDED(hr) && fIsSystemObject )
            {
                ASSERT( GetDlgItem(IDC_CATEGORY_CHANGE) );
                ASSERT( GetDlgItem(IDC_CLASS_DEACTIVATE) );

                GetDlgItem(IDC_CATEGORY_CHANGE)->EnableWindow( FALSE );
                GetDlgItem(IDC_CLASS_DEACTIVATE)->EnableWindow( FALSE );
            }

            hr = DissableReadOnlyAttributes( this, pIADsObject, ctrls, sizeof(ctrls)/sizeof(ctrls[0]) );
            ASSERT( SUCCEEDED(hr) );     // shouldn't fail, but unimportant, so ignore error
            

            // warn the user if this is a read/write defunct object
            ASSERT( GetDlgItem(IDC_CLASS_DEACTIVATE) );
            
            if( DDXDefunct &&
                GetDlgItem(IDC_CLASS_DEACTIVATE)->IsWindowEnabled() )
            {
                AfxMessageBox( IDS_WARNING_DEFUNCT, MB_OK | MB_ICONINFORMATION );
            }

            //
            // Remember that the data is loaded.
            //

            fDataLoaded = TRUE;

        }
    }

    //
    // Set up the dialog data exchange.
    //

    DDX_Text( pDX, IDC_CLASS_GENERAL_NAME_STATIC, ObjectName );
    DDX_Text( pDX, IDC_CLASS_GENERAL_CATEGORY_COMBO, ClassType );
    DDX_Text( pDX, IDC_CLASS_GENERAL_SYSCLASS_STATIC, SysClassString );
    DDX_Text( pDX, IDC_CLASS_GENERAL_DESCRIPTION_EDIT, DDXDescription );
    DDX_Text( pDX, IDC_CLASS_GENERAL_LDN, DisplayName );
    DDX_Text( pDX, IDC_CLASS_GENERAL_OID_EDIT, OidString );
    DDX_Text( pDX, IDC_CATEGORY_EDIT, DDXCategory );
    DDX_Check( pDX, IDC_CLASS_GENERAL_DISPLAYABLE_CHECK, DDXDisplayable );

    // Since we want the checkbox label to be positive
    // the value is actually the opposite of defunct

    int checkValue = !Defunct;
    DDX_Check( pDX, IDC_CLASS_DEACTIVATE, checkValue );
    DDXDefunct = !checkValue;

    return;
}

BOOL
ClassGeneralPage::OnApply(
    VOID
) {

    HRESULT hr;
    VARIANT AdsValue;
    BOOL fChangesMade = FALSE;
    BOOL fApplyAbort  = FALSE;  // stop later saves
    BOOL fApplyFailed = FALSE;  // should not close the box

    if ( !UpdateData(TRUE) ) {
        return FALSE;
    }

    //
    // We have to flush the IADS property cache if we
    // have a failure so later operations won't fail because
    // of a bad cached attribute.
    //

    IADsPropertyList *pPropertyList;

    hr = pIADsObject->QueryInterface( IID_IADsPropertyList,
                                      reinterpret_cast<void**>(&pPropertyList) );
    if ( FAILED( hr ) ) {
        pPropertyList = NULL;
        fApplyAbort = TRUE;
    }

    //
    // We only care if the description, class type, or
    // displayable attributes changed.
    //

    VariantInit( &AdsValue );

    //
    // Defunct -- in case it was deactivated, activate the object first
    //
    if( !fApplyAbort && !DDXDefunct && DDXDefunct != Defunct )
    {
        hr = ChangeDefunctState( DDXDefunct, Defunct, pPropertyList, fApplyAbort, fApplyFailed );
    }

    
    if ( !fApplyAbort && DDXDescription != Description ) {

        V_VT(&AdsValue) = VT_BSTR;
        V_BSTR(&AdsValue) = const_cast<BSTR>((LPCTSTR)DDXDescription);

        if ( DDXDescription.IsEmpty() ) {

            hr = pIADsObject->PutEx( ADS_PROPERTY_CLEAR,
                                     const_cast<BSTR>((LPCTSTR)g_Description),
                                     AdsValue );
        } else {

            hr = pIADsObject->Put( const_cast<BSTR>((LPCTSTR)g_Description),
                                   AdsValue );
        }

        ASSERT( SUCCEEDED( hr ) );

        hr = pIADsObject->SetInfo();

        if ( SUCCEEDED( hr ) ) {

            pObject->description = DDXDescription;
            fChangesMade = TRUE;
			Description = DDXDescription;

        } else {

            pPropertyList->PurgePropertyList();
            if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
            {
                fApplyFailed = TRUE;
                DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_EDIT_DESC );
            }
            else
            {
                fApplyAbort = TRUE; 
                DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
            }
        }

        VariantInit( &AdsValue );
    }


    if ( !fApplyAbort && DDXDisplayable != Displayable ) {

        V_VT(&AdsValue) = VT_BOOL;

        if ( DDXDisplayable ) {
            V_BOOL(&AdsValue) = 0;
        } else {
            V_BOOL(&AdsValue) = -1;
        }

        hr = pIADsObject->Put(g_ShowInAdvViewOnly, AdsValue);

        ASSERT( SUCCEEDED( hr ) );

        hr = pIADsObject->SetInfo();

        if ( FAILED( hr ) ) {
            pPropertyList->PurgePropertyList();
            if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
            {
                fApplyFailed = TRUE;
                DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_EDIT_DISPLAYABLE );
            }
            else
            {
                fApplyAbort = TRUE; 
                DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
            }
        }
		else
		{
			Displayable = DDXDisplayable;
		}

        VariantInit( &AdsValue );
    }

    if ( !fApplyAbort && DDXCategory != Category ) {

        SchemaObject *pCategoryObject;
        CString DistName;

        hr = E_FAIL;

        V_VT(&AdsValue) = VT_BSTR;

        //
        // Map the commonName to the distinguished name.
        //

        pCategoryObject = pScopeControl->g_SchemaCache.LookupSchemaObjectByCN(
                              DisplayName,
                              SCHMMGMT_CLASS );

        if ( pCategoryObject ) {

            pScopeControl->GetSchemaObjectPath( pCategoryObject->commonName, DistName, ADS_FORMAT_X500_DN );

            V_BSTR(&AdsValue) = const_cast<BSTR>((LPCTSTR)DistName);

            hr = pIADsObject->Put( const_cast<BSTR>((LPCTSTR)g_DefaultCategory),
                                   AdsValue );
            ASSERT( SUCCEEDED( hr ) );

            hr = pIADsObject->SetInfo();
        }

        if ( FAILED( hr ) ) {
            pPropertyList->PurgePropertyList();
            if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
            {
                fApplyFailed = TRUE;
                DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_EDIT_CATEGORY );
            }
            else
            {
                fApplyAbort = TRUE; 
                DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
            }
        }
		else
		{
			Category = DDXCategory;
		}

        VariantInit( &AdsValue );
    }

    //
    // Defunct -- in case it was active, deactivate the object after we are done update
    //
    if( !fApplyAbort && DDXDefunct && DDXDefunct != Defunct )
    {
        hr = ChangeDefunctState( DDXDefunct, Defunct, pPropertyList, fApplyAbort, fApplyFailed );
    }

    
    if ( !fApplyAbort && fChangesMade ) {

        //
        // Call SetItem() so this gets refreshed.
        //

        SCOPEDATAITEM ScopeItem;
        CCookieListEntry *pEntry;
        BOOLEAN fFoundId = FALSE;

        if ( pScopeControl->g_ClassCookieList.pHead ) {

           pEntry = pScopeControl->g_ClassCookieList.pHead;

           if ( (pScopeControl->g_ClassCookieList.pHead)->pCookie == pCookie ) {

               fFoundId = TRUE;

           } else {

               while ( pEntry->pNext != pScopeControl->g_ClassCookieList.pHead ) {

                   if ( pEntry->pCookie == pCookie ) {
                       fFoundId = TRUE;
                       break;
                   }

                   pEntry = pEntry->pNext;
               }

           }

           if ( fFoundId ) {

              ::ZeroMemory( &ScopeItem, sizeof(ScopeItem) );
              ScopeItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_PARENT;
              ScopeItem.displayname = MMC_CALLBACK;
              ScopeItem.relativeID = pScopeControl->g_ClassCookieList.hParentScopeItem;
              ScopeItem.nState = 0;
              ScopeItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pCookie);
              ScopeItem.nImage = pScopeControl->QueryImage( *pCookie, FALSE );
              ScopeItem.nOpenImage = pScopeControl->QueryImage( *pCookie, TRUE );
              ScopeItem.ID = pEntry->hScopeItem;

              hr = pScopeControl->m_pConsoleNameSpace->SetItem( &ScopeItem );
              ASSERT( SUCCEEDED( hr ));
           }

        }

    }

    if ( pPropertyList ) {
        pPropertyList->Release();
    }

    return !fApplyAbort && !fApplyFailed ;      // return TRUE if nothing happened
}

VOID
ClassGeneralPage::OnButtonCategoryChange(
) {

    SchemaObject *pClass = NULL;
    INT_PTR DlgResult;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Update any changes the user has made.
    //

    UpdateData( TRUE );

    //
    // Start the common select dialog box.
    //

    CSchmMgmtSelect dlgSelect( pScopeControl,
                                   SELECT_CLASSES,
                                   &pClass );

	DlgResult = dlgSelect.DoModal();

	//
	// When this returns, the class schema object
	// pointer will be filled into pClass.
	//

	if ( ( DlgResult == IDOK ) &&
		 ( pClass != NULL ) ) {

		DDXCategory = pClass->ldapDisplayName;

		//
		// Push this back out to the UI.
		//

		UpdateData( FALSE );

	}

    return;
}


void
ClassGeneralPage::OnDeactivateClick()
{
	if( !IsDlgButtonChecked(IDC_CLASS_DEACTIVATE) )
    {
        if( IDOK != AfxMessageBox( IDS_WARNING_DEFUNCT_SET, MB_OKCANCEL | MB_ICONWARNING ) )
        {
            CheckDlgButton( IDC_CLASS_DEACTIVATE, BST_UNCHECKED );
        }
	}
}


HRESULT
ClassGeneralPage::ChangeDefunctState( BOOL               DDXDefunct,
                                      BOOL             & Defunct,
                                      IADsPropertyList * pPropertyList,
                                      BOOL             & fApplyAbort,
                                      BOOL             & fApplyFailed )
{
    ASSERT( !fApplyAbort && DDXDefunct != Defunct );

    VARIANT AdsValue;
    HRESULT hr = S_OK;

    VariantInit( &AdsValue );
    V_VT(&AdsValue) = VT_BOOL;

    if ( DDXDefunct ) {
        V_BOOL(&AdsValue) = -1;
    } else {
        V_BOOL(&AdsValue) = 0;
    }

    hr = pIADsObject->Put( const_cast<BSTR>((LPCTSTR)g_isDefunct),
                           AdsValue );
    ASSERT( SUCCEEDED( hr ) );

    hr = pIADsObject->SetInfo();

    if ( FAILED( hr ) ) {

        pPropertyList->PurgePropertyList();

        if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
        {
            fApplyFailed = TRUE;
            DoErrMsgBox( ::GetActiveWindow(),
                         TRUE,
                         DDXDefunct ? IDS_ERR_EDIT_DEFUNCT_SET : IDS_ERR_EDIT_DEFUNCT_REMOVE );
        }
        else
        {
            fApplyAbort = TRUE; 
            DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
        }

    } else {

        pObject->isDefunct = DDXDefunct;
		Defunct = DDXDefunct;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\cache.cpp ===
/****

Cache.cpp

The schema caching routines to improve browsing performance.

Locking Note:

This schema cache design allows for rudimentary multi-thread
protection via the lookup routines and the ReleaseRef routines.
To date, we have not needed this type of protection, so it is
not implemented.  All locking rules should be obeyed, however,
in case this protection is later needed.

****/

#include "stdafx.h"

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(cache.cpp)")

#include "resource.h"
#include "cache.h"
#include "schmutil.h"
#include "compdata.h"

//
// The Schema Object.
//

SchemaObject::SchemaObject() {

    //
    // Initialize the list heads to NULL.
    //

    pNext                = NULL;
    pSortedListFlink     = NULL;
    pSortedListBlink     = NULL;

    isDefunct            = FALSE;
    dwClassType          = (DWORD) -1;  // invalid number

    systemMayContain     = NULL;
    mayContain           = NULL;

    systemMustContain    = NULL;
    mustContain          = NULL;

    systemAuxiliaryClass = NULL;
    auxiliaryClass       = NULL;

    SyntaxOrdinal        = UINT_MAX;    // invalid number
}

SchemaObject::~SchemaObject() {

    ListEntry *pEntry, *pNextEntry;

    //
    // Empty any non-zero lists.
    //

    pEntry = systemMayContain;
    while ( pEntry ) {
        pNextEntry = pEntry->pNext;
        delete pEntry;
        pEntry = pNextEntry;
    }

    pEntry = mayContain;
    while ( pEntry ) {
        pNextEntry = pEntry->pNext;
        delete pEntry;
        pEntry = pNextEntry;
    }
    pEntry = systemMustContain;
    while ( pEntry ) {
        pNextEntry = pEntry->pNext;
        delete pEntry;
        pEntry = pNextEntry;
    }
    pEntry = mustContain;
    while ( pEntry ) {
        pNextEntry = pEntry->pNext;
        delete pEntry;
        pEntry = pNextEntry;
    }
    pEntry = systemAuxiliaryClass;
    while ( pEntry ) {
        pNextEntry = pEntry->pNext;
        delete pEntry;
        pEntry = pNextEntry;
    }
    pEntry = auxiliaryClass;
    while ( pEntry ) {
        pNextEntry = pEntry->pNext;
        delete pEntry;
        pEntry = pNextEntry;
    }

    //
    // Done (the CStrings will clean themselves up).
    //

    return;
}

//
// The Schema Object cache.
//

SchemaObjectCache::SchemaObjectCache() {

    pScopeControl = NULL;

    //
    // Initialize the hash table.
    //

    buckets = HASH_TABLE_SIZE;
    hash_table = (SchemaObject**) LocalAlloc( LMEM_ZEROINIT,
                                              sizeof( SchemaObject* ) * buckets );

    if (hash_table != NULL)
    {
      memset(
          hash_table,
          0,
          sizeof( SchemaObject* ) * buckets );
    }
    pSortedClasses = NULL;
    pSortedAttribs = NULL;

    fInitialized = FALSE;

}

SchemaObjectCache::~SchemaObjectCache() {

    //
    // Clear the hash table.
    //

    FreeAll();
    LocalFree( hash_table );
    hash_table = NULL;
}

VOID
SchemaObjectCache::FreeAll() {

    SchemaObject *current, *next;

    DebugTrace( L"SchemaObjectCache::FreeAll()\n" );

    for ( UINT i = 0 ; i < buckets ; i++ ) {

        current = hash_table[i];

        while ( current ) {
            next = current->pNext;
            delete current;
            current = next;
        }
    }

    memset(
        &(hash_table[0]),
        0,
        sizeof( SchemaObject* ) * buckets );

    pSortedClasses = NULL;
    pSortedAttribs = NULL;

    fInitialized = FALSE;

    return;
}

UINT
SchemaObjectCache::CalculateHashKey(
    CString HashKey
) {

    int len = HashKey.GetLength();
    LPCTSTR current = (LPCTSTR)HashKey;
    int hash = 0;

    for ( int i = 0 ; i < len ; i++ ) {
        hash += (i+1) * ( (TCHAR) CharLower((LPTSTR) current[i]) );
    }

    hash %= buckets;

    DebugTrace( L"SchemaObjectCache::CalculateHashKey %ls (len %li) == %li\n",
                const_cast<LPWSTR>((LPCTSTR)HashKey),
                len,
                hash );

    return hash;
}

HRESULT
SchemaObjectCache::InsertSchemaObject(
    SchemaObject* Object
) {

    SchemaObject* chain;
    int bucket = CalculateHashKey( Object->commonName );

    chain = hash_table[bucket];
    hash_table[bucket] = Object;
    Object->pNext = chain;

    DebugTrace( L"Insert: %ls, %ls, %ls, --> %li\n",
                const_cast<LPWSTR>((LPCTSTR)Object->ldapDisplayName),
                const_cast<LPWSTR>((LPCTSTR)Object->commonName),
                const_cast<LPWSTR>((LPCTSTR)Object->description),
                bucket );

    return S_OK;
}

HRESULT
SchemaObjectCache::InsertSortedSchemaObject(
    SchemaObject* Object
) {

    SchemaObject *pCurrent = NULL;
    SchemaObject *pHead = NULL;
    BOOLEAN ChangeHead = TRUE;

    if ( Object->schemaObjectType == SCHMMGMT_CLASS ) {
        pCurrent = pSortedClasses;
    } else {
        ASSERT( Object->schemaObjectType == SCHMMGMT_ATTRIBUTE );
        pCurrent = pSortedAttribs;
    }

    //
    // If we haven't built the sorted list yet, then we
    // don't need to insert this element into it.
    //

    if ( !pCurrent ) {
        return S_OK;
    }

    //
    // The sorted list is circular.
    //

    while ( ( 0 < ( Object->commonName.CompareNoCase(
                        pCurrent->commonName ) ) ) &&
            ( pCurrent != pHead ) ) {

        if ( ChangeHead ) {
            pHead = pCurrent;
            ChangeHead = FALSE;
        }

        pCurrent = pCurrent->pSortedListFlink;

    }

    pCurrent->pSortedListBlink->pSortedListFlink = Object;
    Object->pSortedListBlink = pCurrent->pSortedListBlink;
    Object->pSortedListFlink = pCurrent;
    pCurrent->pSortedListBlink = Object;

    if ( ChangeHead ) {

        if ( Object->schemaObjectType == SCHMMGMT_CLASS ) {
            pSortedClasses = Object;
        } else {
            pSortedAttribs = Object;
        }
    }

    return S_OK;
}


// This functions behavior has been modified to support schema delete.
// Previously this function would return the first match to the ldapDisplayName,
// Now it will return the first match to the ldapDisplayName that is not defunct

SchemaObject*
SchemaObjectCache::LookupSchemaObject(
    CString ldapDisplayName,
    SchmMgmtObjectType ObjectType
) {
    if ( !fInitialized ) {
        LoadCache();
    }

    SchemaObject  * pHead       = 0;
    if ( ObjectType == SCHMMGMT_ATTRIBUTE)
    {
       pHead = pSortedAttribs;
    }
    else
    {
       pHead = pSortedClasses;
    }

    SchemaObject  * pObject     = pHead;
    BOOL            fFound      = FALSE;

    ASSERT( pObject );

    do {
        if( ObjectType == pObject->schemaObjectType  &&
            !pObject->isDefunct && 
            !pObject->ldapDisplayName.CompareNoCase(ldapDisplayName) )
        {
            fFound = TRUE;
            break;
        }
        
        pObject = pObject->pSortedListFlink;
        
    } while ( pObject != pHead );

    if (!fFound)
    {
       pObject = 0;
    }

    return pObject;

/*
    int length = 0;
    int bucket = CalculateHashKey( ldapDisplayName );
    SchemaObject* chain = hash_table[bucket];

    if ( !fInitialized ) {
        LoadCache();
    }

    while ( chain ) {

        if ( ( ObjectType == chain->schemaObjectType ) &&
               !chain->isDefunct &&
            !ldapDisplayName.CompareNoCase( chain->ldapDisplayName ) ) {

            DebugTrace( L"SchemaObjectCache::LookupSchemaObject %ls, chain depth %li.\n",
                        const_cast<LPWSTR>((LPCTSTR)ldapDisplayName),
                        length );

            return chain;

        } else {

            chain = chain->pNext;
            length++;
        }
    }

    DebugTrace( L"SchemaObjectCache::LookupSchemaObject %ls (NO HIT), chain depth %li.\n",
                const_cast<LPWSTR>((LPCTSTR)ldapDisplayName),
                length );

    //
    // LOCKING NOTE: The simple ref counting and locking is not
    // currently implemented.  See note at the head of the file.
    //
    return NULL;
*/
}


//
// sequential search of the entire cache for an object with the given CN
//
// objectType is given to slightly speed-up the process.
//
SchemaObject*
SchemaObjectCache::LookupSchemaObjectByCN( LPCTSTR             pszCN,
                                           SchmMgmtObjectType  objectType )
{
    if ( !fInitialized ) {
        LoadCache();
    }

    SchemaObject  * pHead       = 0;
    if ( objectType == SCHMMGMT_ATTRIBUTE)
    {
       pHead = pSortedAttribs;
    }
    else
    {
       pHead = pSortedClasses;
    }

    SchemaObject  * pObject     = pHead;
    BOOL            fFound      = FALSE;

    ASSERT( pObject );

    do {
        if( objectType == pObject->schemaObjectType  &&
            !pObject->commonName.CompareNoCase(pszCN) )
        {
            fFound = TRUE;
            break;
        }
        
        pObject = pObject->pSortedListFlink;
        
    } while ( pObject != pHead );
    
    //
    // LOCKING NOTE: The simple ref counting and locking is not
    // currently implemented.  See note at the head of the file.
    //

    return fFound ? pObject : NULL;
}


VOID
SchemaObjectCache::ReleaseRef(
    SchemaObject*
) {

    //
    // E_NOTIMPL
    // See the note at the head of the file.
    //

}

HRESULT
SchemaObjectCache::LoadCache(
    VOID
)
/***

    This routine executes a couple of DS searches to read the
    relevant items out of the schema along with some attributes
    of those items.

    This information is cached.

***/
{
    if ( fInitialized ) {
        return S_OK;
    }

    LPWSTR Attributes[] = {
               g_DisplayName,
               g_CN,
               g_Description,
               g_MayContain,
               g_MustContain,
               g_SystemMayContain,
               g_SystemMustContain,
               g_AuxiliaryClass,
               g_SystemAuxiliaryClass,
               g_SubclassOf,
               g_ObjectClassCategory,
               g_AttributeSyntax,
               g_omSyntax,
               g_omObjectClass,
               g_isDefunct,
               g_GlobalClassID,  // must be last
    };
    const DWORD         AttributeCount = sizeof(Attributes) / sizeof(Attributes[0]);

    ADS_SEARCH_HANDLE   hSearchHandle   = NULL;
    HRESULT             hr              = S_OK;
    CComPtr<IADs>       ipADs;

    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    //
    // Put up a wait cursor since
    // this could take a little while.  The cursor will
    // revert when the the CWaitCursor goes out of scope.
    //
    CWaitCursor wait;


    //
    // Get the schema container path.
    //

    if ( NULL == pScopeControl ) 
    {
        ASSERT(FALSE);
        return E_FAIL;
    }

    hr = pScopeControl->CheckSchemaPermissions( &ipADs );
    if ( !ipADs )
    {
        ASSERT( FAILED(hr) );
        
        if( E_FAIL == hr )
            DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_SCHEMA_PATH );
        else
            DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );

        return hr;
    }
    else if( FAILED(hr) )
        hr = S_OK;          // ignore the error.  In case of an error, minimal permissions are assumed


    //
    // Open the schema container.
    //
    
    IDirectorySearch *pDSSearch = 0;
    hr = ipADs->QueryInterface( IID_IDirectorySearch,
                                (void **)&pDSSearch );

    if ( FAILED(hr) ) 
    {
        ASSERT(FALSE);
        DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_SCHEMA_PATH );
        return hr;
    }

   //
   // Set up the search preferences
   //

   static const int SEARCH_PREF_COUNT = 3;
   ADS_SEARCHPREF_INFO prefs[SEARCH_PREF_COUNT];

   // server side sort preferences
   ADS_SORTKEY SortKey;
   SortKey.pszAttrType = g_DisplayName;
   SortKey.pszReserved = NULL;
   SortKey.fReverseorder = 0;

   prefs[0].dwSearchPref = ADS_SEARCHPREF_SORT_ON;
   prefs[0].vValue.dwType = ADSTYPE_PROV_SPECIFIC;
   prefs[0].vValue.ProviderSpecific.dwLength = sizeof(ADS_SORTKEY);
   prefs[0].vValue.ProviderSpecific.lpValue = (LPBYTE) &SortKey;

   // result page size
   prefs[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
   prefs[1].vValue.dwType = ADSTYPE_INTEGER;
   prefs[1].vValue.Integer = 300; // get a bunch in one hit

   // scope
   prefs[2].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
   prefs[2].vValue.dwType = ADSTYPE_INTEGER;
   prefs[2].vValue.Integer = ADS_SCOPE_ONELEVEL;  // one level

    //
    // Build the class search request.
    //

   hr = pDSSearch->SetSearchPreference(prefs, SEARCH_PREF_COUNT);
   ASSERT( SUCCEEDED( hr ) );

   hr =
      pDSSearch->ExecuteSearch(
         L"(objectCategory=classSchema)",
         Attributes,
         AttributeCount,
            &hSearchHandle );

    if ( FAILED(hr) ) 
    {
        ASSERT(FALSE);
        pDSSearch->Release();
        return hr;
    }

    //
    // Cache these entries.  We ignore error codes and try to
    // process the attributes regardless.
    //

    hr = ProcessSearchResults( pDSSearch, hSearchHandle, SCHMMGMT_CLASS);

    pDSSearch->CloseSearchHandle( hSearchHandle );

    hr = pDSSearch->SetSearchPreference(prefs, SEARCH_PREF_COUNT);
    ASSERT( SUCCEEDED( hr ) );

    //
    // This array index must match the array declared above!
    //

    Attributes[AttributeCount - 1] = g_GlobalAttributeID;

    hr =
      pDSSearch->ExecuteSearch(
         L"(objectCategory=attributeSchema)",
         Attributes,
         AttributeCount,
         &hSearchHandle );

    if ( FAILED(hr) ) 
    {
        ASSERT(FALSE);
        pDSSearch->Release();
        return hr;
    }

    //
    // Cache these entries.  Again, ignore the error code.
    //

    hr = ProcessSearchResults( pDSSearch, hSearchHandle, SCHMMGMT_ATTRIBUTE );

    pDSSearch->CloseSearchHandle( hSearchHandle );

    //
    // Release the schema container.
    //

    pDSSearch->Release();

    //
    // Mark the cache as open for business.
    //

    fInitialized = TRUE;

    return S_OK;
}


HRESULT
SchemaObjectCache::ProcessSearchResults(
    IDirectorySearch *pDSSearch,
    ADS_SEARCH_HANDLE hSearchHandle,
    SchmMgmtObjectType ObjectType
) {

    HRESULT hr = S_OK;
    SchemaObject *schemaObject;
    ADS_SEARCH_COLUMN Column;

    while ( TRUE ) {

        //
        // Get the next row set.  If there are no more rows, break.
        // If there was some other error, try to skip over the
        // troubled row.
        //

        hr = pDSSearch->GetNextRow( hSearchHandle );

        if ( hr == S_ADS_NOMORE_ROWS ) {
            break;
        }

        if ( hr != S_OK ) {
            ASSERT( FALSE );
            continue;
        }

        //
        // Allocate a new schema object.  If one could not be
        // allocated, stop loading the schema since we're in a
        // low memory condition.
        //

        schemaObject = new SchemaObject;
        if ( !schemaObject ) {
            AfxMessageBox(IDS_SCHEMA_NOT_FULLY_LOADED, MB_OK);
            ASSERT( FALSE );
            return E_OUTOFMEMORY;
        }

        //
        // Set the object type.
        //

        schemaObject->schemaObjectType = ObjectType;

        //
        // Get the common name column.
        //

        hr = pDSSearch->GetColumn( hSearchHandle, g_CN, &Column );

        if ( SUCCEEDED(hr) ) {
            schemaObject->commonName = (Column.pADsValues)->CaseIgnoreString;
            pDSSearch->FreeColumn( &Column );
        }

        //
        // Get the ldap display name.
        //

        hr = pDSSearch->GetColumn( hSearchHandle, g_DisplayName, &Column );

        if ( SUCCEEDED(hr) ) {
            schemaObject->ldapDisplayName = (Column.pADsValues)->CaseIgnoreString;
            pDSSearch->FreeColumn( &Column );
        }

        //
        // Get the description.
        //

        hr = pDSSearch->GetColumn( hSearchHandle, g_Description, &Column );

        if ( SUCCEEDED(hr) ) {
            schemaObject->description = (Column.pADsValues)->CaseIgnoreString;
            pDSSearch->FreeColumn( &Column );
        }

        //
        // Is this object current active?
        //

        schemaObject->isDefunct = FALSE;

        hr = pDSSearch->GetColumn( hSearchHandle, g_isDefunct, &Column );

        if ( SUCCEEDED(hr) ) {

            if ( (Column.pADsValues)->Boolean ) {
                schemaObject->isDefunct = TRUE;
            }

            pDSSearch->FreeColumn( &Column );
        }

        //
        // Get the class specific data.
        //

        if ( ObjectType == SCHMMGMT_CLASS ) {

            //
            // Get the attributes and auxiliary classes for this class.
            //

            hr = pDSSearch->GetColumn( hSearchHandle, g_SystemMustContain, &Column );

            if ( SUCCEEDED(hr) ) {
                schemaObject->systemMustContain = MakeColumnList( &Column );
                pDSSearch->FreeColumn( &Column );
            }

            hr = pDSSearch->GetColumn( hSearchHandle, g_SystemMayContain, &Column );

            if ( SUCCEEDED(hr) ) {
                schemaObject->systemMayContain = MakeColumnList( &Column );
                pDSSearch->FreeColumn( &Column );
            }

            hr = pDSSearch->GetColumn( hSearchHandle, g_MustContain, &Column );

            if ( SUCCEEDED(hr) ) {
                schemaObject->mustContain = MakeColumnList( &Column );
                pDSSearch->FreeColumn( &Column );
            }

            hr = pDSSearch->GetColumn( hSearchHandle, g_MayContain, &Column );

            if ( SUCCEEDED(hr) ) {
                schemaObject->mayContain = MakeColumnList( &Column );
                pDSSearch->FreeColumn( &Column );
            }

            hr = pDSSearch->GetColumn( hSearchHandle, g_SystemAuxiliaryClass, &Column );

            if ( SUCCEEDED(hr) ) {
                schemaObject->systemAuxiliaryClass = MakeColumnList( &Column );
                pDSSearch->FreeColumn( &Column );
            }

            hr = pDSSearch->GetColumn( hSearchHandle, g_AuxiliaryClass, &Column );

            if ( SUCCEEDED(hr) ) {
                schemaObject->auxiliaryClass = MakeColumnList( &Column );
                pDSSearch->FreeColumn( &Column );
            }

            hr = pDSSearch->GetColumn( hSearchHandle, g_ObjectClassCategory, &Column );

            if ( SUCCEEDED(hr) ) {
                schemaObject->dwClassType = (Column.pADsValues)->Integer;
                pDSSearch->FreeColumn( &Column );
            }

            hr = pDSSearch->GetColumn( hSearchHandle, g_SubclassOf, &Column );

            if ( SUCCEEDED(hr) ) {
                schemaObject->subClassOf = (Column.pADsValues)->CaseIgnoreString;
                pDSSearch->FreeColumn( &Column );
            }

            //
            // Get the oid.
            //

            hr = pDSSearch->GetColumn( hSearchHandle, g_GlobalClassID, &Column );

            if ( SUCCEEDED(hr) ) {
                schemaObject->oid = (Column.pADsValues)->CaseIgnoreString;
                pDSSearch->FreeColumn( &Column );
            }

        }

        //
        // Get the attribute specific data.
        //

        if ( ObjectType == SCHMMGMT_ATTRIBUTE ) {

           //
           // Select a syntax string for the attribute.
           //

           CString            strAttributeSyntax;
           ADS_OCTET_STRING   OmObjectClass;
           UINT               omSyntax = 0;

           schemaObject->SyntaxOrdinal = SCHEMA_SYNTAX_UNKNOWN;
           OmObjectClass.dwLength      = 0;
           OmObjectClass.lpValue       = NULL;
 
           hr = pDSSearch->GetColumn( hSearchHandle, g_AttributeSyntax, &Column );
 
           if ( SUCCEEDED(hr) ) {
 
               strAttributeSyntax = (Column.pADsValues)->CaseIgnoreString;
               pDSSearch->FreeColumn( &Column );
 
               hr = pDSSearch->GetColumn( hSearchHandle, g_omSyntax, &Column );
 
               if ( SUCCEEDED(hr) ) {
                  omSyntax = (Column.pADsValues)->Integer;
                  pDSSearch->FreeColumn( &Column );
               }
 
               hr = pDSSearch->GetColumn( hSearchHandle, g_omObjectClass, &Column );
 
               if ( SUCCEEDED(hr) ) {
                  OmObjectClass = (Column.pADsValues)->OctetString;
               }
         
               schemaObject->SyntaxOrdinal = GetSyntaxOrdinal(
                                    strAttributeSyntax, omSyntax, &OmObjectClass );
 
               // OmObjectClass has a pointer which becomes invalid after FreeColumn()
               if ( SUCCEEDED(hr) ) {
                  pDSSearch->FreeColumn( &Column );
                  OmObjectClass.dwLength = 0;
                  OmObjectClass.lpValue  = NULL;
               }
		   }
		   else
			   ASSERT( FALSE );

           //
           // Get the oid.
           //

           hr = pDSSearch->GetColumn( hSearchHandle, g_GlobalAttributeID, &Column );

           if ( SUCCEEDED(hr) ) {
               schemaObject->oid = (Column.pADsValues)->CaseIgnoreString;
               pDSSearch->FreeColumn( &Column );
           }

        }

        //
        // Insert this into the sorted item list.
        //

        InsertSortedTail( schemaObject );

        //
        // Insert this schema object into the cache.
        //

        InsertSchemaObject( schemaObject );
        schemaObject = NULL;

    }

    return S_OK;

}

VOID
SchemaObjectCache::InsertSortedTail(
    SchemaObject* pObject
) {

    SchemaObject **sorted_list;
    SchemaObject *pHead;

    //
    // Find the correct list.
    //

    if ( pObject->schemaObjectType == SCHMMGMT_CLASS ) {
        sorted_list = &pSortedClasses;
    } else {
        sorted_list = &pSortedAttribs;
    }

    //
    // Actually insert the element.
    //

    if ( *sorted_list == NULL ) {

        //
        // This is the first element.
        //

        *sorted_list = pObject;
        pObject->pSortedListFlink = pObject;
        pObject->pSortedListBlink = pObject;

    } else {

        //
        // This is not the first element;
        //

        pHead = *sorted_list;

        pObject->pSortedListBlink = pHead->pSortedListBlink;
        pHead->pSortedListBlink->pSortedListFlink = pObject;
        pHead->pSortedListBlink = pObject;
        pObject->pSortedListFlink = pHead;

    }

}

ListEntry*
SchemaObjectCache::MakeColumnList(
    PADS_SEARCH_COLUMN pColumn
) {

    ListEntry *pHead = NULL, *pLast = NULL, *pCurrent = NULL;

    for ( DWORD i = 0 ; i < pColumn->dwNumValues ; i++ ) {

        pCurrent = new ListEntry;

        //
        // If we run out of memory, return what we made so far.
        //

        if ( !pCurrent ) {
            break;
        }

        //
        // If there's no head, remember this as the first.
        // Otherwise, stick this on the end of the list
        // and update the last pointer.
        //

        if ( !pHead ) {
            pHead = pCurrent;
            pLast = pCurrent;
        } else {
            pLast->pNext = pCurrent;
            pLast = pCurrent;
        }

        //
        // Record the value.
        //

        pCurrent->Attribute = pColumn->pADsValues[i].CaseIgnoreString;
        DebugTrace( L"MakeColumnList recorded %ls.\n",
                    pColumn->pADsValues[i].CaseIgnoreString );

        //
        // That's it.
        //
    }

    return pHead;
}

VOID
SchemaObjectCache::FreeColumnList(
    ListEntry *pListHead
) {

    //
    // Delete the linked list.
    //

    ListEntry *pNext, *pCurrent;

    if ( !pListHead ) {
        return;
    }

    pCurrent = pListHead;

    do {

        pNext = pCurrent->pNext;
        delete pCurrent;

        pCurrent = pNext;

    } while ( pCurrent );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\attrpage.h ===
//
// attrpage.h : Declaration of ClassAttributePage
//
// Jon Newman <jonn@microsoft.com>
// Copyright (c) Microsoft Corporation 1997
//
// templated from relation.h JonN 8/8/97
//

#ifndef __ATTRPAGE_H_INCLUDED__
#define __ATTRPAGE_H_INCLUDED__

#include "cookie.h"     // Cookie
#include "resource.h"   // IDD_CLASS_MEMBERSHIP



class ClassAttributePage : public CPropertyPage
{
   public:

   ClassAttributePage(ComponentData *pScope, LPDATAOBJECT lpDataObject);

   ~ClassAttributePage();

   void Load( Cookie& CookieRef );

   //
   // The schema object that this property page is for.
   //

   CStringList strlistMandatory;
   CStringList strlistSystemMandatory;
   CStringList strlistOptional;
   CStringList strlistSystemOptional;

   Cookie *m_pCookie;
   CString m_szAdsPath;

   ComponentData *pScopeControl;
   LPDATAOBJECT lpScopeDataObj;

   //
   // The ADSI object that this property page is for
   //

   IADs*         m_pIADsObject;
   SchemaObject* m_pSchemaObject;

   CString SysClassString;

   // Dialog Data

   enum { IDD = IDD_CLASS_ATTRIBUTES};

   CListBox              m_listboxMandatory;            
   CSchemaObjectsListBox m_listboxOptional;             

   CString  ObjectName;                    
   BOOL     fSystemClass;                  

   virtual BOOL OnApply();


   protected:

   virtual BOOL OnInitDialog();
   virtual BOOL OnSetActive();
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support


   static const DWORD help_map[];

   BOOL     OnHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, FALSE ); };
   BOOL     OnContextHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, TRUE ); };


   afx_msg void OnButtonOptionalAttributeAdd();
   afx_msg void OnButtonOptionalAttributeRemove();
   afx_msg void OnOptionalSelChange();

   DECLARE_MESSAGE_MAP()
};



#endif // __ATTRPAGE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\classgen.hpp ===
#ifndef CLASSGEN_HPP_INCLUDED
#define CLASSGEN_HPP_INCLUDED



class ClassGeneralPage : public CPropertyPage
{
public:

   ClassGeneralPage( ComponentData *pScope );

   ~ClassGeneralPage();

   void Load( Cookie& CookieRef );

   //
   // The schema object that this property page is for.
   //

   ComponentData *pScopeControl;

   Cookie *pCookie;
   SchemaObject *pObject;
   IADs *pIADsObject;
   BOOL fDataLoaded;

   //
   // Data members for property fields.
   //

   CString ObjectName;
   CString DisplayName;
   CString Description;
   CString SysClassString;
   CString OidString;
   CString ClassType;
   CString Category;
   BOOL    Displayable;
   BOOL    Defunct;

   //
   // DDX Associated variables that we care about.
   //

   CString DDXDescription;
   CString DDXCategory;
   BOOL    DDXDisplayable;
   BOOL    DDXDefunct;

   virtual BOOL OnApply();
   virtual BOOL OnInitDialog();
   virtual void DoDataExchange( CDataExchange *pDX );
   virtual BOOL OnSetActive();


   BOOL    OnHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, FALSE ); };
   BOOL    OnContextHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, TRUE ); };

   void	   OnDeactivateClick();

protected:

   static const DWORD help_map[];

   afx_msg void OnButtonCategoryChange();

   HRESULT ChangeDefunctState( BOOL               DDXDefunct,
                               BOOL             & Defunct,
                               IADsPropertyList * pPropertyList,
                               BOOL             & fApplyAbort,
                               BOOL             & fApplyFailed );


private:

   DECLARE_MESSAGE_MAP()
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\cookie.cpp ===
//
// Cookie.cpp : Implementation of Cookie and related classes.
// Cory West
//

#include "stdafx.h"
#include "cookie.h"

#include "atlimpl.cpp"

DECLARE_INFOLEVEL(SchmMgmtSnapin)

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(cookie.cpp)")
#include "stdcooki.cpp"
#include ".\uuids.h"

//
// This is used by the nodetype utility routines in
// stdutils.cpp, which matches the enum type node
// types to their guids.  This table must match the
// layout of guids in uuids.h.
//

const struct NODETYPE_GUID_ARRAYSTRUCT g_NodetypeGuids[SCHMMGMT_NUMTYPES] =
{

    //
    // The root node.
    //

    { // SCHMMGMT_SCHMMGMT
      structUuidNodetypeSchmMgmt,
      lstrUuidNodetypeSchmMgmt          },
    
    //
    // Static node types.
    //

    { // SCHMMGMT_CLASSES
      structUuidNodetypeClasses,
      lstrUuidNodetypeClasses           },
    { // SCHMGMT_ATTRIBUTES,
      structUuidNodetypeAttributes,
      lstrUuidNodetypeAttributes        },

    //
    // Dynamic node types.
    //

    { // SCHMMGMT_CLASS
      structUuidNodetypeClass,
      lstrUuidNodetypeClass             },
    { // SCHMMGMT_ATTRIBUTE
      structUuidNodetypeAttribute,
      lstrUuidNodetypeAttribute         },

};

const struct NODETYPE_GUID_ARRAYSTRUCT* g_aNodetypeGuids = g_NodetypeGuids;

const int g_cNumNodetypeGuids = SCHMMGMT_NUMTYPES;

//
// Cookie
//

HRESULT
Cookie::CompareSimilarCookies(CCookie* pOtherCookie, int* pnResult)
{
   ASSERT(pOtherCookie);
   ASSERT(pnResult);

   Cookie* pcookie = (dynamic_cast<Cookie*>(pOtherCookie));
   ASSERT(pcookie);

   if (pcookie)
   {
      //
      // Arbitrary ordering...
      //

      if ( m_objecttype != pcookie->m_objecttype )
      {
         *pnResult = ((int)m_objecttype) - ((int)pcookie->m_objecttype);
         return S_OK;
      }

      *pnResult = strSchemaObject.CompareNoCase(pcookie->strSchemaObject);
      return S_OK;
   }

   return E_FAIL;
}



CCookie*
Cookie::QueryBaseCookie(
    int i ) {

    ASSERT( i == 0 );
    return (CCookie*)this;
}

int 
Cookie::QueryNumCookies() {
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\cmponent.cpp ===
//
// cmponent.cpp : Declaration of Component.
//
// This COM object is primarily concerned with
// the result pane items.
//
// Cory West <corywest@microsoft.com>
// Copyright (c) Microsoft Corporation 1997
//

#include "stdafx.h"

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(cmponent.cpp)")

#include "dataobj.h"
#include "cmponent.h" // Component
#include "compdata.h" // ComponentData
#include "schmutil.h"
#include "attrgen.hpp"


#include "stdcmpnt.cpp" // CComponent



//
// These arrays describe the result pane layout for when
// any particular object is selected.
//

UINT
g_aColumns0[5] = {

    IDS_COLUMN_NAME,
    IDS_COLUMN_TYPE,
    IDS_COLUMN_STATUS,
    IDS_COLUMN_DESCRIPTION,
    0
};

UINT
g_aColumns1[5] = {

    IDS_COLUMN_NAME,
    IDS_COLUMN_SYNTAX,
    IDS_COLUMN_STATUS,
    IDS_COLUMN_DESCRIPTION,
    0
};

UINT
g_aColumns2[6] = {

    IDS_COLUMN_NAME,
    IDS_COLUMN_TYPE,
    IDS_COLUMN_SYSTEM,
    IDS_COLUMN_DESCRIPTION,
    IDS_COLUMN_PARENT,
    0
};

UINT
g_aColumns3[2] =
{
   IDS_COLUMN_NAME,
   0
};
      
UINT*
g_Columns[SCHMMGMT_NUMTYPES] = {

    g_aColumns3,         // SCHMMGMT_SCHMMGMT
    g_aColumns0,         // SCHMMGMT_CLASSES
    g_aColumns1,         // SCHMMGMT_ATTRIBUTES
    g_aColumns2,         // SCHMMGMT_CLASS
    g_aColumns0,         // SCHMMGMT_ATTRIBUTE     // @@ Is this used?
};

UINT** g_aColumns = g_Columns;

//
// These control the column widths, which I will not change.
//

int g_aColumnWidths0[4] = {150,150,75,150};
int g_aColumnWidths1[5] = {150,75,75,150,150};
int g_aColumnWidths2[1] = {150};

int* g_ColumnWidths[SCHMMGMT_NUMTYPES] = {

    g_aColumnWidths2,       // SCHMMGMT_SCHMMGMT
    g_aColumnWidths0,       // SCHMMGMT_CLASSES
    g_aColumnWidths0,       // SCHMMGMT_ATTRIBUTES
    g_aColumnWidths1,       // SCHMMGMT_CLASS
    g_aColumnWidths0,       // SCHMMGMT_ATTRIBUTE
};

int** g_aColumnWidths = g_ColumnWidths;

//
// Constructors and destructors.
//

Component::Component()
:       m_pSvcMgmtToolbar( NULL ),
        m_pSchmMgmtToolbar( NULL ),
        m_pControlbar( NULL )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    m_pViewedCookie = NULL;
}

Component::~Component()
{
    TRACE_METHOD(Component,Destructor);
    VERIFY( SUCCEEDED(ReleaseAll()) );
}

HRESULT Component::ReleaseAll()
{
    MFC_TRY;

    TRACE_METHOD(Component,ReleaseAll);

    SAFE_RELEASE(m_pSvcMgmtToolbar);
    SAFE_RELEASE(m_pSchmMgmtToolbar);
    SAFE_RELEASE(m_pControlbar);

    return CComponent::ReleaseAll();

    MFC_CATCH;
}

//
// Support routines in ISchmMgmtComponent.
//


HRESULT
Component::LoadColumns(
    Cookie* pcookie
) {

    TEST_NONNULL_PTR_PARAM(pcookie);
    return LoadColumnsFromArrays( (INT)(pcookie->m_objecttype) );
}

HRESULT
Component::OnViewChange(
    LPDATAOBJECT,
    LPARAM data,
    LPARAM function
)
/***

    This is called when IConsole->UpdateAllViews() is called.
    The data is a schema object type as follows:


    if function == 0 (SCHMMGMT_UPDATEVIEW_REFRESH)

        SCHMMGMT_ATTIBUTES - We need to refresh the attributes
            folder displays.
        SCHMMGMT_CLASS - We need to refresh _ALL_ class attribute
            displays.  We don't try and trace the inheritance
            graphs and do a selective refresh, that's too complicated.
        SCHMMGMT_SCHMMGMT - Refresh EVERYTHING because we reloaded
            the schema cache.

    else if function == 1 (SCHMMGMT_UPDATEVIEW_DELETE_RESULT_ITEM)

        data is the Cookie pointer
***/
{
    //
    // Refresh this result view.
    //
    if ( function == SCHMMGMT_UPDATEVIEW_REFRESH )
    {
       if ( m_pViewedCookie ) {

           if ( ( data == m_pViewedCookie->m_objecttype ) ||
                ( data == SCHMMGMT_SCHMMGMT ) ) {

               m_pResultData->DeleteAllRsltItems();
               PopulateListbox( m_pViewedCookie );

           }
       }
    }
    else if ( function == SCHMMGMT_UPDATEVIEW_DELETE_RESULT_ITEM )
    {
       HRESULTITEM item;
       ZeroMemory( &item, sizeof(HRESULTITEM) );

       HRESULT hr = m_pResultData->FindItemByLParam( data, &item );
       if ( SUCCEEDED(hr) )
       {
          hr = m_pResultData->DeleteItem( item, 0 );
          ASSERT( SUCCEEDED(hr) );

       }
    }

    return S_OK;
}


HRESULT
Component::OnNotifySelect( LPDATAOBJECT lpDataObject, BOOL )
/***

        This called in response to MMCN_SELECT.
        This routine will set the default verb and enable the toolbar buttons.

***/
{
    CCookie* pBaseParentCookie = NULL;
    HRESULT hr = ExtractData( lpDataObject,
                              CSchmMgmtDataObject::m_CFRawCookie,
                              OUT reinterpret_cast<PBYTE>(&pBaseParentCookie),
                              sizeof(pBaseParentCookie) );

    ASSERT( SUCCEEDED(hr) );
    Cookie* pParentCookie = ActiveCookie(pBaseParentCookie);
    ASSERT( NULL != pParentCookie );

    switch ( pParentCookie->m_objecttype ) {

    case SCHMMGMT_CLASSES:
    case SCHMMGMT_ATTRIBUTES:

        break;

    case SCHMMGMT_CLASS:
       {
           //
           // Set the default verb to display the properties of the selected object.
           //

           m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
           m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

           // if the schema class is defunct and the forest version is Whistler or higher
           // then allow delete
/* Feature was removed for Whistler
           ComponentData& Scope = QueryComponentDataRef();
           if ( Scope.GetBasePathsInfo()->GetForestBehaviorVersion() >= 2)
           {
              SchemaObject *pSchemaObject = Scope.g_SchemaCache.LookupSchemaObjectByCN(
                                              pParentCookie->strSchemaObject,
                                              SCHMMGMT_CLASS );

              if ( pSchemaObject &&
                   pSchemaObject->isDefunct )
              {
                  m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
              }
           }
           */
       }
       break;

    case SCHMMGMT_ATTRIBUTE:

        if ( ( pParentCookie->m_objecttype == SCHMMGMT_ATTRIBUTE ) &&
             ( pParentCookie->pParentCookie ) &&
             ( pParentCookie->pParentCookie->m_objecttype == SCHMMGMT_ATTRIBUTES ) ) {

            //
            // Set the default verb to display the properties of the selected object.
            //

            m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

            // if the schema class is defunct and the forest version is Whistler or higher
            // then allow delete
/* Feature was removed for Whistler

            ComponentData& Scope = QueryComponentDataRef();
            if ( Scope.GetBasePathsInfo()->GetForestBehaviorVersion() >= 2)
            {
               SchemaObject *pSchemaObject = Scope.g_SchemaCache.LookupSchemaObjectByCN(
                                                pParentCookie->strSchemaObject,
                                                SCHMMGMT_ATTRIBUTE );

               if ( pSchemaObject &&
                    pSchemaObject->isDefunct )
               {
                   m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
               }
            }
*/
        } else {

            m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
        }

        break;

    default:

        //
        // Otherwise set the default verb to open/expand the folder.
        //

        m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
        break;
    }

    return S_OK;
}


HRESULT
Component::Show(
    CCookie* pcookie,
    LPARAM arg,
	HSCOPEITEM hScopeItem
)
/***

    This is called in response to MMCN_SHOW.

***/
{
    TEST_NONNULL_PTR_PARAM(pcookie);
    
    HRESULT hr = S_OK;

    do
    {
        if ( TRUE == arg )      // showing...
        {
            if( QueryComponentDataRef().IsSetDelayedRefreshOnShow() )
            {
                HSCOPEITEM  hItem = QueryComponentDataRef().GetDelayedRefreshOnShowItem();
                ASSERT( hItem == hScopeItem ); 

                QueryComponentDataRef().SetDelayedRefreshOnShow( NULL );

                hr = m_pConsole->SelectScopeItem( hItem );      // will call GetResultViewType & Show
                ASSERT_BREAK_ON_FAILED_HRESULT(hr);
            }
            else if( QueryComponentDataRef().IsErrorSet() )
            {
                CComPtr<IUnknown>     pUnknown;
                CComPtr<IMessageView> pMessageView;
    
                hr = m_pConsole->QueryResultView(&pUnknown);
                ASSERT_BREAK_ON_FAILED_HRESULT(hr);

                hr = pUnknown->QueryInterface(IID_IMessageView, (PVOID*)&pMessageView);
                ASSERT_BREAK_ON_FAILED_HRESULT(hr);

                pMessageView->SetTitleText( CComBSTR( QueryComponentDataRef().GetErrorTitle() ) );
                pMessageView->SetBodyText( CComBSTR( QueryComponentDataRef().GetErrorText() ) );
                pMessageView->SetIcon(Icon_Error);
            }
            else
            {
                m_pViewedCookie = (Cookie*)pcookie;
                LoadColumns( m_pViewedCookie );
            
                hr = PopulateListbox( m_pViewedCookie );
            }
        }
        else    // hiding...
        {
            if( !QueryComponentDataRef().IsErrorSet() )
            {
                if ( NULL == m_pResultData )
                {
                    ASSERT( FALSE );
                    hr = E_UNEXPECTED;
                    break;
                }

                m_pViewedCookie = NULL;
            }
        }

    } while( FALSE );

    return hr;
}

HRESULT
Component::OnNotifyAddImages(
    LPDATAOBJECT,
    LPIMAGELIST lpImageList,
    HSCOPEITEM
)
/***

    This routine is called in response to MMCN_ADD_IMAGES.  Here's
    what mmc.idl says about this:

    Sent to IComponent to add images for the result pane. The
    primary snapin should add images for both folders and leaf items.

    arg = ptr to result panes IImageList.
    param = HSCOPEITEM of selected/deselected item

***/
{
    return QueryComponentDataRef().LoadIcons(lpImageList,TRUE);
}


HRESULT 
Component::OnNotifyDelete(
    LPDATAOBJECT lpDataObject)
{
    CCookie* pBaseParentCookie = NULL;

    HRESULT hr = ExtractData( lpDataObject,
                              CSchmMgmtDataObject::m_CFRawCookie,
                              reinterpret_cast<PBYTE>(&pBaseParentCookie),
                              sizeof(pBaseParentCookie) );
    ASSERT( SUCCEEDED(hr) );

    Cookie* pParentCookie = ActiveCookie(pBaseParentCookie);
    ASSERT( NULL != pParentCookie );

    UINT promptID = 0;
    LPARAM updateType = SCHMMGMT_CLASS;

    if (pParentCookie->m_objecttype == SCHMMGMT_CLASS)
    {
        promptID = IDS_DELETE_CLASS_PROMPT;
        updateType = SCHMMGMT_CLASS;
    }
    else if (pParentCookie->m_objecttype == SCHMMGMT_ATTRIBUTE)
    {
        promptID = IDS_DELETE_ATTR_PROMPT;
        updateType = SCHMMGMT_ATTRIBUTES;
    }
    else
    {
        // We should never get called to delete anything but
        // class and attribute nodes

        ASSERT(FALSE);
        return E_FAIL;
    }

    if( IDYES == AfxMessageBox( promptID, MB_YESNO | MB_ICONWARNING ))
    {
       hr = DeleteAttribute(pParentCookie);
       if ( SUCCEEDED(hr) )
       {
         // Remove the node from the UI

         hr = m_pConsole->UpdateAllViews( lpDataObject,
                                          (LPARAM)pParentCookie,
                                          SCHMMGMT_UPDATEVIEW_DELETE_RESULT_ITEM );
         ASSERT( SUCCEEDED(hr) );
       }
       else
       {
          CString szDeleteError;
          szDeleteError.Format(IDS_ERRMSG_DELETE_FAILED_ATTRIBUTE, GetErrorMessage(hr, TRUE));
          
          DoErrMsgBox( ::GetActiveWindow(), TRUE, szDeleteError );
       }
    }

    return hr;
}

HRESULT
Component::DeleteAttribute(
    Cookie* pcookie
)
/***

    This deletes an attribute from the schema

***/
{
   HRESULT hr = S_OK;

   do
   {
      if ( !pcookie )
      {
         hr = E_INVALIDARG;
         break;
      }

      ComponentData& Scope = QueryComponentDataRef();

      SchemaObject* pObject = Scope.g_SchemaCache.LookupSchemaObjectByCN(
                                pcookie->strSchemaObject,
                                SCHMMGMT_ATTRIBUTE );

      if ( !pObject )
      {
         hr = E_FAIL;
         break;
      }

      CString szAdsPath;
      Scope.GetSchemaObjectPath( pObject->commonName, szAdsPath );

      hr = DeleteObject( szAdsPath, pcookie, g_AttributeFilter );
   } while (false);

   return hr;
}

HRESULT
Component::PopulateListbox(
    Cookie* pcookie
)
/***

    This populates the result pane when the result pane
    contains data that is not directly derived from the
    data in the scope pane.

***/
{
    switch ( pcookie->m_objecttype ) {

    case SCHMMGMT_SCHMMGMT:
    case SCHMMGMT_CLASSES:

        //
        // We don't care about these - the result
        // pane contains only scope items.
        //

        break;

    case SCHMMGMT_ATTRIBUTES:

        //
        // List the specified items in the result pane
        // with some informational data.
        //

        return FastInsertAttributeResultCookies(
                   pcookie );

        break;

    case SCHMMGMT_CLASS:

        //
        // This results in the attributes used in this
        // class and other class data being displayed.
        //

        return FastInsertClassAttributesResults( pcookie );
        break;


    case SCHMMGMT_ATTRIBUTE:

        //
        // This is not a scope pane item and can have no
        // corresponding result pane data!!
        //

        ASSERT(FALSE);
        break;

    }

    return S_OK;
}

HRESULT
Component::FastInsertAttributeResultCookies(
    Cookie* pParentCookie
)
/***

    When the "Attributes" folder is selected, this puts
    the attributes in the result pane.

    pParentCookie is the cookie for the parent object.

    This routine is similar to
    ComponentData::FastInsertClassScopeCookies.

****/
{

    HRESULT hr;
    SchemaObject *pObject, *pHead;
    Cookie *pNewCookie;
    RESULTDATAITEM ResultItem;
    LPCWSTR lpcszMachineName = pParentCookie->QueryNonNULLMachineName();
    ComponentData& Scope = QueryComponentDataRef();

    //
    // Initialize the result item.
    //

    ::ZeroMemory( &ResultItem, sizeof( ResultItem ) );
    ResultItem.nCol = 0;
    ResultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
    ResultItem.str = MMC_CALLBACK;
    ResultItem.nImage = iIconAttribute;

    //
    // Rather than having a clean class interface to the cache, we
    // walk the cache data structures ourselves.  This isn't super
    // clean, but it's simple.
    //
    // Since we do this, we have to make sure that the cache is loaded.
    //

    Scope.g_SchemaCache.LoadCache();

    pObject = Scope.g_SchemaCache.pSortedAttribs;

    //
    // If there's no sorted list, we can't insert anything!!!!
    //

    if ( !pObject ) {
        ASSERT( FALSE );
        DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_SCHEMA_PATH );
        return S_OK;
    }

    //
    // Delete whatever was in the view before
    // and do the insert.
    //

    pHead = pObject;

    do {

       //
       // Insert this result.
       //

       pNewCookie= new Cookie( SCHMMGMT_ATTRIBUTE,
                                        lpcszMachineName );

       if ( pNewCookie ) {

           pNewCookie->pParentCookie = pParentCookie;
           pNewCookie->strSchemaObject = pObject->commonName;

           pParentCookie->m_listScopeCookieBlocks.AddHead(
               (CBaseCookieBlock*)pNewCookie
           );

           ResultItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pNewCookie);
           hr = m_pResultData->InsertItem( &ResultItem );

           if ( SUCCEEDED(hr) ) {

               pNewCookie->SetResultHandle( ResultItem.itemID );

           } else {

               delete pNewCookie;
           }

       }

       pObject = pObject->pSortedListFlink;

    } while ( pObject != pHead );

    return S_OK;
}

HRESULT
Component::FastInsertClassAttributesResults(
    Cookie* pClassCookie
)
/***

    This routine displays all the attributes for a class.

***/
{

    HRESULT hr = S_OK;
    SchemaObject *pObject, *pTop;
    CString top = L"top";
    ComponentData& Scope = QueryComponentDataRef();

    //
    // Call the attribute display routine.  This routine
    // will call itself recursively to display the
    // inheritance structure of the class.
    //

    pObject = Scope.g_SchemaCache.LookupSchemaObjectByCN(
                  pClassCookie->strSchemaObject,
                  SCHMMGMT_CLASS );

    if ( pObject ) {

        CStringList szProcessedList;
        hr = RecursiveDisplayClassAttributesResults(
                 pClassCookie,
                 pObject,
                 szProcessedList);

        Scope.g_SchemaCache.ReleaseRef( pObject );
    }

    //
    // Process "top" just once.
    //

    pTop = Scope.g_SchemaCache.LookupSchemaObject( top, SCHMMGMT_CLASS );

    if ( pTop ) {

        ProcessResultList( pClassCookie, pTop->systemMayContain, TRUE, TRUE, pTop );
        ProcessResultList( pClassCookie, pTop->mayContain, TRUE, FALSE, pTop );
        ProcessResultList( pClassCookie, pTop->systemMustContain, FALSE, TRUE, pTop );
        ProcessResultList( pClassCookie, pTop->mustContain, FALSE, FALSE, pTop );

        Scope.g_SchemaCache.ReleaseRef( pTop );
    }

    return hr;

}

HRESULT
Component::RecursiveDisplayClassAttributesResults(
    Cookie *pParentCookie,
    SchemaObject* pObject,
    CStringList& szProcessedList
)
/***

    Display all the attributes for this class.

***/
{

    ListEntry *pList;
    SchemaObject *pInheritFrom;
    ComponentData& Scope = QueryComponentDataRef();

    //
    // Don't process "top" here since everyone inherits from it.
    //

    if ( pObject->ldapDisplayName == L"top" ) {
        return S_OK;
    }

    DebugTrace( L"RecursiveDisplayClassAttributesResults: %ls\n",
                const_cast<LPWSTR>((LPCTSTR)pObject->ldapDisplayName) );

    //
    // Insert all the attributes for this class.
    // The second parameter dictates whether these
    // are optional or not.  The third parameter
    // is the source of the attribute.
    //

    ProcessResultList( pParentCookie, pObject->systemMayContain, TRUE, TRUE, pObject );
    ProcessResultList( pParentCookie, pObject->mayContain, TRUE, FALSE, pObject );
    ProcessResultList( pParentCookie, pObject->systemMustContain, FALSE, TRUE, pObject );
    ProcessResultList( pParentCookie, pObject->mustContain, FALSE, FALSE, pObject );

    //
    // For each auxiliary class, insert those attributes.
    //

    pList = pObject->systemAuxiliaryClass;

    while ( pList ) {

        pInheritFrom = Scope.g_SchemaCache.LookupSchemaObject( pList->Attribute,
                                                               SCHMMGMT_CLASS );
        //
        // Don't recursively process the item if we already processed it
        //
        if ( pInheritFrom && szProcessedList.Find(pList->Attribute) == NULL) {
            RecursiveDisplayClassAttributesResults( pParentCookie, pInheritFrom, szProcessedList );
            szProcessedList.AddTail(pList->Attribute);
            Scope.g_SchemaCache.ReleaseRef( pInheritFrom );
        }

        pList = pList->pNext;
    }

    pList = pObject->auxiliaryClass;

    while ( pList ) {

        pInheritFrom = Scope.g_SchemaCache.LookupSchemaObject( pList->Attribute,
                                                               SCHMMGMT_CLASS );
        //
        // Don't recursively process the item if we already processed it
        //
        if ( pInheritFrom && szProcessedList.Find(pList->Attribute) == NULL ) {
            RecursiveDisplayClassAttributesResults( pParentCookie, pInheritFrom, szProcessedList );
            szProcessedList.AddTail(pList->Attribute);
            Scope.g_SchemaCache.ReleaseRef( pInheritFrom );
        }

        pList = pList->pNext;
    }

    //
    // If this is an inherited class, insert those attributes.
    //

    pInheritFrom = Scope.g_SchemaCache.LookupSchemaObject( pObject->subClassOf,
                                                           SCHMMGMT_CLASS );
    if ( pInheritFrom ) {
        RecursiveDisplayClassAttributesResults( pParentCookie, pInheritFrom, szProcessedList );
        Scope.g_SchemaCache.ReleaseRef( pInheritFrom );
    }

    return S_OK;

}

HRESULT
Component::ProcessResultList(
    Cookie *pParentCookie,
    ListEntry *pList,
    BOOLEAN fOptional,
    BOOLEAN fSystem,
    SchemaObject* pSrcObject
) {

    HRESULT hr;
    Cookie *pNewCookie;
    RESULTDATAITEM ResultItem;
    LPCWSTR lpcszMachineName = pParentCookie->QueryNonNULLMachineName();
    ListEntry *pCurrent = pList;
    SchemaObject *pAttribute;

    ComponentData& Scope = QueryComponentDataRef();

    //
    // Initialize the result item.
    //

    ::ZeroMemory( &ResultItem, sizeof( ResultItem ) );
    ResultItem.nCol = 0;
    ResultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
    ResultItem.str = MMC_CALLBACK;
    ResultItem.nImage = iIconAttribute;

    while ( pCurrent ) {

        //
        // Make a new cookie.
        //

        pNewCookie = new Cookie( SCHMMGMT_ATTRIBUTE,
                                          lpcszMachineName );

        if ( pNewCookie ) {

            //
            // Record the optional status and the source.
            //

            if ( fOptional ) {
                pNewCookie->Mandatory = FALSE;
            } else {
                pNewCookie->Mandatory = TRUE;
            }

            if ( fSystem ) {
                pNewCookie->System = TRUE;
            } else {
                pNewCookie->System = FALSE;
            }

            pNewCookie->strSrcSchemaObject = pSrcObject->commonName;
            pNewCookie->pParentCookie = pParentCookie;

            //
            // Point to the actual attribute.
            //

            pAttribute = Scope.g_SchemaCache.LookupSchemaObject(
                             pCurrent->Attribute,
                             SCHMMGMT_ATTRIBUTE );

            if ( pAttribute ) {

                pNewCookie->strSchemaObject = pAttribute->commonName;
                Scope.g_SchemaCache.ReleaseRef( pAttribute );
            }

            //
            // Insert the result pane item.
            //

            pParentCookie->m_listScopeCookieBlocks.AddHead(
                (CBaseCookieBlock*)pNewCookie
            );

            ResultItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pNewCookie);
            hr = m_pResultData->InsertItem( &ResultItem );

            if ( SUCCEEDED(hr) ) {

                pNewCookie->SetResultHandle( ResultItem.itemID );

            } else {

                delete pNewCookie;
            }

        }

        pCurrent = pCurrent->pNext;
    }

    return S_OK;

}

STDMETHODIMP
Component::AddMenuItems(
    LPDATAOBJECT,
    LPCONTEXTMENUCALLBACK,
    long*
) {

    return S_OK;
}

STDMETHODIMP
Component::Command(
    long,
    LPDATAOBJECT
) {

    return S_OK;

}

  

HRESULT Component::OnNotifySnapinHelp (LPDATAOBJECT)
{
//	return ShowHelpTopic( L"sag_adschema.htm" );

   CComQIPtr<IDisplayHelp,&IID_IDisplayHelp> spDisplayHelp = m_pConsole;
   if ( !spDisplayHelp )
   {
      ASSERT(FALSE);
      return E_UNEXPECTED;
   }

   CString strHelpTopic = L"ADConcepts.chm::/sag_adschema.htm";
   HRESULT hr = spDisplayHelp->ShowTopic (T2OLE ((LPWSTR)(LPCWSTR) strHelpTopic));
   ASSERT (SUCCEEDED (hr));

   return hr;
}



HRESULT Component::OnNotifyContextHelp (LPDATAOBJECT)
{
//	return ShowHelpTopic( L"schmmgmt_top.htm" );

   CComQIPtr<IDisplayHelp,&IID_IDisplayHelp> spDisplayHelp = m_pConsole;
   if ( !spDisplayHelp )
   {
      ASSERT(FALSE);
      return E_UNEXPECTED;
   }

   CString strHelpTopic = L"ADConcepts.chm::/schmmgmt_top.htm";
   HRESULT hr = spDisplayHelp->ShowTopic (T2OLE ((LPWSTR)(LPCWSTR) strHelpTopic));
   ASSERT (SUCCEEDED (hr));

   return hr;
}



STDMETHODIMP
Component::QueryPagesFor(
    LPDATAOBJECT pDataObject )
{

    MFC_TRY;

    if ( NULL == pDataObject ) {
        ASSERT(FALSE);
        return E_POINTER;
    }

    HRESULT hr;

    CCookie* pBaseParentCookie = NULL;

    hr = ExtractData( pDataObject,
                     CSchmMgmtDataObject::m_CFRawCookie,
                     reinterpret_cast<PBYTE>(&pBaseParentCookie),
                     sizeof(pBaseParentCookie) );

    ASSERT( SUCCEEDED(hr) );

    Cookie* pParentCookie = ActiveCookie(pBaseParentCookie);
    ASSERT( NULL != pParentCookie );

    if ( ( pParentCookie->m_objecttype == SCHMMGMT_ATTRIBUTE ) &&
         ( pParentCookie->pParentCookie ) &&
         ( pParentCookie->pParentCookie->m_objecttype == SCHMMGMT_ATTRIBUTES ) ) {
        return S_OK;
    }

    return S_FALSE;

    MFC_CATCH;
}

//
// This adds pages to the property sheet if appropriate.
// The handle parameter must be saved in the property page
// object to notify the parent when modified.
//

STDMETHODIMP
Component::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK pCallBack,
    LONG_PTR,
    LPDATAOBJECT pDataObject )
{

    MFC_TRY;
    CWaitCursor wait;

    //
    // Validate the parameters.
    //

    if ( ( NULL == pCallBack ) ||
        ( NULL == pDataObject ) ) {

        ASSERT(FALSE);
        return E_POINTER;
    }

    //
    // Make sure this is a class object that we are calling up.
    //

    CCookie* pBaseParentCookie = NULL;

    HRESULT hr = ExtractData( pDataObject,
                             CSchmMgmtDataObject::m_CFRawCookie,
                             reinterpret_cast<PBYTE>(&pBaseParentCookie),
                             sizeof(pBaseParentCookie) );
    ASSERT( SUCCEEDED(hr) );

    Cookie* pParentCookie = ActiveCookie(pBaseParentCookie);
    ASSERT( NULL != pParentCookie );
    ASSERT( pParentCookie->m_objecttype == SCHMMGMT_ATTRIBUTE );

    //
    // Create the page.
    //

    HPROPSHEETPAGE hPage;
    AttributeGeneralPage *pGeneralPage =
        new AttributeGeneralPage( this, pDataObject );

    if ( pGeneralPage )
    {
        pGeneralPage->Load( *pParentCookie );
                MMCPropPageCallback( &pGeneralPage->m_psp );
        hPage= CreatePropertySheetPage( &pGeneralPage->m_psp );
        hr = pCallBack->AddPage( hPage );
    }

    return S_OK;

    MFC_CATCH;
}



HRESULT __stdcall
Component::Compare(
   LPARAM,
   MMC_COOKIE cookieA,  
   MMC_COOKIE cookieB,  
   int*       result)
{
   if (!result)
   {
      return E_INVALIDARG;
   }

   if (!m_pViewedCookie)
   {
      ASSERT(false);
      *result = 0;
      return S_OK;
   }

   Cookie* c1 =
      (Cookie*) ActiveBaseCookie(reinterpret_cast<CCookie*>(cookieA));

   Cookie* c2 =
      (Cookie*) ActiveBaseCookie(reinterpret_cast<CCookie*>(cookieB));

   PWSTR t1 = QueryBaseComponentDataRef().QueryResultColumnText(*c1, *result);
   PWSTR t2 = QueryBaseComponentDataRef().QueryResultColumnText(*c2, *result);

   // All columns use a case-insensitive comparison, as many columns contain
   // display names from the directory (which are case-insensitive).  That we
   // also use a case insensitive compare for the other columns is harmless.

   // another trick:  we are inverting the results from the compare.  This is
   // because we initially insert the items in the list in sorted order.  So
   // the first sort request from the user really is intended to reverse-sort
   // the list.

   *result = -(_wcsicmp(t1, t2));

   return S_OK;
}


STDMETHODIMP Component::GetResultViewType(MMC_COOKIE cookie,
										   BSTR* ppViewType,
										   long* pViewOptions)
{
	MFC_TRY;
    if( QueryComponentDataRef().IsErrorSet() )
    {
		*pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

		LPOLESTR psz = NULL;
		StringFromCLSID(CLSID_MessageView, &psz);

		USES_CONVERSION;

		if (psz != NULL)
		{
			*ppViewType = psz;
			return S_OK;
		}
		else
        {
			return S_FALSE;
        }
    }
    else
    {
		return CComponent::GetResultViewType( cookie, ppViewType, pViewOptions );
    }

	MFC_CATCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\cmponent.h ===
//
// cmponent.h : Declaration of Component.
//
// This COM object is primarily concerned with
// the result pane items.
//
// Cory West <corywest@microsoft.com>
// Copyright (c) Microsoft Corporation 1997
//

#ifndef __CMPONENT_H_INCLUDED__
#define __CMPONENT_H_INCLUDED__

#include "stdcmpnt.h" // CComponent
#include "cookie.h"   // Cookie


class ComponentData;
class AttributeGeneralPage;

class Component
   :
   public CComponent,
   public IExtendPropertySheet,
   public IExtendContextMenu,
   public IResultDataCompare
{

public:

    friend class AttributeGeneralPage;

    Component();
    virtual ~Component();

    BEGIN_COM_MAP(Component)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(IResultDataCompare)
        COM_INTERFACE_ENTRY_CHAIN(CComponent)
    END_COM_MAP()

#if DBG==1

    ULONG InternalAddRef( ) {
        return CComObjectRoot::InternalAddRef();
    }

    ULONG InternalRelease( ) {
        return CComObjectRoot::InternalRelease();
    }

    int dbg_InstID;

#endif

    inline
    Cookie* ActiveCookie( CCookie* pBaseCookie ) {
        return ( Cookie*)ActiveBaseCookie( pBaseCookie );
    }

    //
    // Support methods for IComponent.
    //

	// For Error handling, overide GetResultViewType()
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie, LPOLESTR* ppViewType, long* pViewOptions);

    virtual HRESULT ReleaseAll();
    virtual HRESULT OnViewChange( LPDATAOBJECT lpDataObject, LPARAM data, LPARAM hint );
    virtual HRESULT OnNotifySelect( LPDATAOBJECT lpDataObject, BOOL fSelected );
    virtual HRESULT Show( CCookie* pcookie,
                          LPARAM arg,
						  HSCOPEITEM hScopeItem);
    virtual HRESULT OnNotifyAddImages( LPDATAOBJECT lpDataObject,
                                       LPIMAGELIST lpImageList,
                                       HSCOPEITEM hSelectedItem );
    virtual HRESULT OnNotifyDelete(LPDATAOBJECT lpDataObject);

    HRESULT PopulateListbox( Cookie* pcookie );
    HRESULT EnumerateScopeChildren( Cookie* pParentCookie,
                                    HSCOPEITEM hParent );


    HRESULT LoadColumns( Cookie* pcookie );

    ComponentData& QueryComponentDataRef( ) {
        return ( ComponentData& )QueryBaseComponentDataRef();
    }

    //
    // IExtendPropertySheet
    //

    STDMETHOD(CreatePropertyPages)( LPPROPERTYSHEETCALLBACK pCall,
                                    LONG_PTR handle,
                                    LPDATAOBJECT pDataObject );

    STDMETHOD(QueryPagesFor)( LPDATAOBJECT pDataObject );

    //
    // IExtendContextMenu
    //

    STDMETHOD(AddMenuItems)( LPDATAOBJECT piDataObject,
                             LPCONTEXTMENUCALLBACK piCallback,
                             long *pInsertionAllowed );

    STDMETHOD(Command)( long lCommandID,
                        LPDATAOBJECT piDataObject );

   //
   // IResultDataCompare
   //

   virtual
   HRESULT __stdcall
   Compare(
      LPARAM     userParam,
      MMC_COOKIE cookieA,  
      MMC_COOKIE cookieB,  
      int*       result);

    //
    // Creates result items for the Attributes folder.
    //

    HRESULT
    FastInsertAttributeResultCookies(
        Cookie* pParentCookie
    );

    //
    // Creates result items for a particular class.
    //

    HRESULT
    Component::FastInsertClassAttributesResults(
        Cookie* pClassCookie
    );

    HRESULT
    Component::RecursiveDisplayClassAttributesResults(
        Cookie *pParentCookie,
        SchemaObject* pObject,
        CStringList& szProcessedList
    );

    HRESULT
    Component::ProcessResultList(
        Cookie *pParentCookie,
        ListEntry *pList,
        BOOLEAN fOptional,
        BOOLEAN fSystem,
        SchemaObject* pSrcObject
    );

	virtual HRESULT OnNotifySnapinHelp (LPDATAOBJECT pDataObject);
   virtual HRESULT OnNotifyContextHelp (LPDATAOBJECT pDataObject);

private:

   HRESULT DeleteAttribute(Cookie* pcookie);

    //
    // These should use smart pointers.
    //

    LPCONTROLBAR        m_pControlbar;
    LPTOOLBAR           m_pSvcMgmtToolbar;
    LPTOOLBAR           m_pSchmMgmtToolbar;
    Cookie*    m_pViewedCookie;
    static const GUID   m_ObjectTypeGUIDs[SCHMMGMT_NUMTYPES];
    static const BSTR   m_ObjectTypeStrings[SCHMMGMT_NUMTYPES];

};

//
// Enumeration for the icons used.  The icons are loaded into
// MMC via ComponentData::LoadIcons.
//

enum {
    iIconGeneric = 0,
    iIconFolder,
    iIconClass,
    iIconAttribute,
    iIconDisplaySpecifier,
    iIconLast
};

//
// These enums give us readable names for the column ordinals
// of the columns in various result views.
//

typedef enum _COLNUM_CLASS {
    COLNUM_CLASS_NAME=0,
    COLNUM_CLASS_TYPE,
    COLNUM_CLASS_STATUS,
    COLNUM_CLASS_DESCRIPTION
} COLNUM_CLASS;

typedef enum _COLNUM_ATTRIBUTE {
    COLNUM_ATTRIBUTE_NAME=0,
    COLNUM_ATTRIBUTE_TYPE,
    COLNUM_ATTRIBUTE_STATUS,
    COLNUM_ATTRIBUTE_SYSTEM,
    COLNUM_ATTRIBUTE_DESCRIPTION,
    COLNUM_ATTRIBUTE_PARENT
} COLNUM_ATTRIBUTE;

typedef enum _COLNUM_ROOT {
        COLNUM_SCHEMA_NAME = 0
} COLNUM_ROOT;

HRESULT LoadIconsIntoImageList(LPIMAGELIST pImageList, BOOL fLoadLargeIcons);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\cookie.h ===
//
// cookie.h : Declaration of Cookie and related classes.
// Cory West
//

#ifndef __COOKIE_H_INCLUDED__
#define __COOKIE_H_INCLUDED__

//
// Instance handle of the DLL (initialized during
// Component::Initialize).
//

extern HINSTANCE g_hInstanceSave;

#include "nodetype.h"
#include "cache.h"
#include "stdcooki.h"



class Cookie:

    public CCookie,
    public CStoresMachineName,
    public CBaseCookieBlock

{

public:

    Cookie( SchmMgmtObjectType objecttype,
                     LPCTSTR lpcszMachineName = NULL )
        : CStoresMachineName( lpcszMachineName ),
          m_objecttype( objecttype ),
          hResultId( 0 )
    { ; }

    ~Cookie() { ; }

    //
    // Returns < 0, 0 or > 0.
    //

    virtual HRESULT CompareSimilarCookies( CCookie* pOtherCookie,
                                           int* pnResult );

    //
    // CBaseCookieBlock.
    //

    virtual CCookie* QueryBaseCookie(int i);
    virtual int QueryNumCookies();

    SchmMgmtObjectType m_objecttype;
    Cookie *pParentCookie;

    //
    // If this is a result item, here's the handle to it.
    //

    HRESULTITEM hResultId;
    inline void SetResultHandle( HRESULTITEM hri ) {
        hResultId = hri;
    };

    //
    // The name of the schema object that this
    // cookie refers to.  We have to refer to the
    // cache object by name so that if the cache
    // reloads, we won't be left holding a dangling
    // pointer.
    //

    CString strSchemaObject;

    //
    // If this is an attribute of a class
    // (pParentCookie->m_objecttype == SCHMMGMT_CLASS),
    // these variables give us display info.
    //

    VARIANT_BOOL Mandatory;
    BOOL System;

    //
    // If this is an attribute of a class, this is the
    // name of the class that the attribute is a member
    // of.
    //

    CString strSrcSchemaObject;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\compdata.h ===
//
// compdata.h : Declaration of ComponentData
//
// This COM object is primarily concerned with
// the scope pane items.
//
// Cory West <corywest@microsoft.com>
// Copyright (c) Microsoft Corporation 1997
//

#ifndef __COMPDATA_H_INCLUDED__
#define __COMPDATA_H_INCLUDED__

#include "stdcdata.h"   // CComponentData
#include "persist.h"    // PersistStream
#include "cookie.h"     // Cookie
#include "resource.h"   // IDS_SCHMMGMT_DESC
#include "cmponent.h"   // LoadIconsIntoImageList
#include "schmutil.h"

// Messages used in UpdateAllViews
enum
{
   SCHMMGMT_UPDATEVIEW_REFRESH = 0,          // This MUST be zero
   SCHMMGMT_UPDATEVIEW_DELETE_RESULT_ITEM
};


///////////////////////////////////////////////////////////////////////////////
// ComponentData

class ComponentData
   :
   public CComponentData,
   public IExtendPropertySheet,
   public IExtendContextMenu,
   public PersistStream,
   public CHasMachineName,
   public CComCoClass< ComponentData, &CLSID_SchmMgmt >
{

public:

    friend class ClassGeneralPage;
    friend class CreateAttributeDialog;
    friend class CSchmMgmtAdvanced;
    friend class CSchmMgmtAttributeMembership;
    friend class CSchmMgmtClassRelationship;
    friend class CCookieList;

    //
    // Use DECLARE_AGGREGATABLE(ComponentData)
    // if you want your object to support aggregation,
    // though I don't know why you'd do this.
    //

    DECLARE_NOT_AGGREGATABLE( ComponentData )

    //
    // What is this?
    //

    DECLARE_REGISTRY( ComponentData,
                      _T("SCHMMGMT.SchemaObject.1"),
                      _T("SCHMMGMT.SchemaObject.1"),
                      IDS_SCHMMGMT_DESC,
                      THREADFLAGS_BOTH )

    ComponentData();
    ~ComponentData();

    BEGIN_COM_MAP( ComponentData )
        COM_INTERFACE_ENTRY( IExtendPropertySheet )
        COM_INTERFACE_ENTRY( IPersistStream )
        COM_INTERFACE_ENTRY( IExtendContextMenu )
        COM_INTERFACE_ENTRY_CHAIN( CComponentData )
    END_COM_MAP()

#if DBG==1

        ULONG InternalAddRef() {
            return CComObjectRoot::InternalAddRef();
        }

        ULONG InternalRelease() {
            return CComObjectRoot::InternalRelease();
        }

        int dbg_InstID;

#endif

    //
    // IComponentData
    //

    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);

    STDMETHOD(CreateComponent)( LPCOMPONENT* ppComponent );

    STDMETHOD(QueryDataObject)( MMC_COOKIE cookie,
                                DATA_OBJECT_TYPES type,
                                LPDATAOBJECT* ppDataObject );

    //
    // IExtendPropertySheet
    //

    STDMETHOD(CreatePropertyPages)( LPPROPERTYSHEETCALLBACK pCall,
                                    LONG_PTR handle,
                                    LPDATAOBJECT pDataObject );

    STDMETHOD(QueryPagesFor)( LPDATAOBJECT pDataObject );

    //
    // IPersistStream
    //

    HRESULT
    STDMETHODCALLTYPE GetClassID( CLSID __RPC_FAR *pClassID ) {
        *pClassID=CLSID_SchmMgmt;
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE Load( IStream __RPC_FAR *pStg );
    HRESULT STDMETHODCALLTYPE Save( IStream __RPC_FAR *pStgSave,
                                    BOOL fSameAsLoad );

    //
    // IExtendContextMenu
    //

    STDMETHOD(AddMenuItems)( LPDATAOBJECT piDataObject,
                             LPCONTEXTMENUCALLBACK piCallback,
                             long *pInsertionAllowed );

    STDMETHOD(Command)( long lCommandID,
                        LPDATAOBJECT piDataObject );

   //
   // ISnapinHelp2
   //

    STDMETHOD(GetLinkedTopics)(LPOLESTR* lpCompiledHelpFile);

    //
    // Needed for Initialize().
    //

    virtual HRESULT LoadIcons( LPIMAGELIST pImageList,
                               BOOL fLoadLargeIcons );

    //
    // Needed for Notify().
    //

    virtual HRESULT OnNotifyExpand( LPDATAOBJECT lpDataObject,
                                    BOOL bExpanding,
                                    HSCOPEITEM hParent );

    virtual HRESULT OnNotifyRelease(
                        LPDATAOBJECT lpDataObject,
                        HSCOPEITEM hItem );

    virtual HRESULT OnNotifyDelete(
                        LPDATAOBJECT lpDataObject);

    //
    // Needed for GetDisplayInfo(), must be defined by subclass.
    //

    virtual BSTR QueryResultColumnText( CCookie& basecookieref,
                                        int nCol );

    virtual int QueryImage( CCookie& basecookieref,
                            BOOL fOpenImage );

    virtual CCookie& QueryBaseRootCookie( );

    inline
    Cookie* ActiveCookie( CCookie* pBaseCookie ) {
        return ( Cookie*)ActiveBaseCookie( pBaseCookie );
    }

    inline Cookie& QueryRootCookie() { return *m_pRootCookie; }

    //
    // CHasMachineName.  Used by the snapin framework to store, retrieve
    //                   and compare machine names
    //

    DECLARE_FORWARDS_MACHINE_NAME( m_pRootCookie )

    //
    // Ads handling routines for inserting dynamic nodes.
    //

    HRESULT
    FastInsertClassScopeCookies(
        Cookie* pParentCookie,
        HSCOPEITEM hParentScopeItem
    );

    VOID
    RefreshScopeView(
        VOID
    );

    VOID
    InitializeRootTree( HSCOPEITEM hParent, Cookie * pParentCookie );


private:
    // context manu item helpers
    HRESULT _OnRefresh(LPDATAOBJECT lpDataObject);
    void _OnRetarget(LPDATAOBJECT lpDataObject);
    void _OnEditFSMO();
    void _OnSecurity();

    // generic helpers
    HRESULT _InitBasePaths();

public:

    //
    // This is the per snap-in instance data.
    //
    
    //
    // This cookie lists contains the currently
    // visible scope data items.
    //
    
    CCookieList g_ClassCookieList;
    
    HRESULT DeleteClass( Cookie* pcookie );

    //
    // Error/Status Handling
    //
private:
    // both should be empty if everything is ok.
    CString		m_sErrorTitle;
    CString		m_sErrorText;
    CString     m_sStatusText;

    HSCOPEITEM  m_hItem;

public:
    // Set's error title & body text.  Call it with NULL, NULL to remove
    void SetError( UINT idsErrorTitle, UINT idsErrorText );

    const CString & GetErrorTitle() const    { return m_sErrorTitle; }
    const CString & GetErrorText() const     { return m_sErrorText; }

    BOOL IsErrorSet( void ) const            { return !GetErrorTitle().IsEmpty() || !GetErrorText().IsEmpty(); }

    void SetDelayedRefreshOnShow( HSCOPEITEM hItem )
                                             { m_hItem = hItem; }

    BOOL IsSetDelayedRefreshOnShow()         { return NULL != m_hItem; }
    HSCOPEITEM GetDelayedRefreshOnShowItem() { ASSERT(IsSetDelayedRefreshOnShow()); return m_hItem; }

    // Set/Clear Status Text
//    void SetStatusText( UINT idsStatusText = 0 );
//    void ClearStatusText( )                  { SetStatusText(); }


    //
    // Access permissions
    //
private:

    BOOL    m_fCanChangeOperationsMaster;
    BOOL    m_fCanCreateClass;
    BOOL    m_fCanCreateAttribute;

public:
    
    BOOL    CanChangeOperationsMaster()     { return m_fCanChangeOperationsMaster; }
    BOOL    CanCreateClass()                { return m_fCanCreateClass; }
    BOOL    CanCreateAttribute()            { return m_fCanCreateAttribute; }
    
    void    SetCanChangeOperationsMaster( BOOL fCanChangeOperationsMaster = FALSE )
                                            { m_fCanChangeOperationsMaster = fCanChangeOperationsMaster; }
    void    SetCanCreateClass( BOOL fCanCreateClass = FALSE )
                                            { m_fCanCreateClass            = fCanCreateClass; }
    void    SetCanCreateAttribute( BOOL fCanCreateAttribute = FALSE )
                                            { m_fCanCreateAttribute        = fCanCreateAttribute; }
    
    //
    // The schema cache.
    //
    
    SchemaObjectCache g_SchemaCache;

    BOOLEAN IsSchemaLoaded() { return g_SchemaCache.IsSchemaLoaded(); }
    
    HRESULT ForceDsSchemaCacheUpdate( VOID );
    BOOLEAN AsynchForceDsSchemaCacheUpdate( VOID );
    
    MyBasePathsInfo* GetBasePathsInfo() { return &m_basePathsInfo;}
    
    
    //
    // Function to add escape char to the special chars in CN
    //
    HRESULT GetSchemaObjectPath( const CString & strCN,
                                 CString       & strPath,
                                 ADS_FORMAT_ENUM formatType = ADS_FORMAT_X500 );

    HRESULT GetLeafObjectFromDN( const BSTR bstrDN, CString & strCN );

    // Determine what operations are allowed.  Optionally returns IADs * to Schema Container
    HRESULT CheckSchemaPermissions( IADs ** ppADs = NULL  );


private:

    MyBasePathsInfo    m_basePathsInfo;
    Cookie*             m_pRootCookie;
    IADsPathname      * m_pPathname;
};



#endif // __COMPDATA_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\compdata.cpp ===
//
// compdata.cpp : Implementation of ComponentData
//
// This COM object is primarily concerned with
// the scope pane items.
//
// Cory West <corywest@microsoft.com>
// Copyright (c) Microsoft Corporation 1997
//

#include "stdafx.h"

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(compdata.cpp)")

#include "dataobj.h"
#include "compdata.h"
#include "cookie.h"
#include "snapmgr.h"
#include "schmutil.h"
#include "cache.h"
#include "relation.h"
#include "attrpage.h"
#include "advui.h"
#include "aclpage.h"
#include "select.h"
#include "classgen.hpp"
#include "newclass.hpp"
#include "newattr.hpp"


//
// CComponentData implementation.
//

#include "stdcdata.cpp"

//
// ComponentData
//

ComponentData::ComponentData()
   :
   m_pRootCookie( NULL ),
   m_pPathname( NULL ),
   m_hItem( NULL )
{
    //
    // We must refcount the root cookie, since a dataobject for it
    // might outlive the IComponentData.  JonN 9/2/97
    //
    m_pRootCookie = new Cookie( SCHMMGMT_SCHMMGMT );
    ASSERT(NULL != m_pRootCookie);

    m_pRootCookie->AddRef();

    g_SchemaCache.SetScopeControl( this );
    SetHtmlHelpFileName (L"schmmgmt.chm");

    SetCanChangeOperationsMaster( );
    SetCanCreateClass( );
    SetCanCreateAttribute( );
}



ComponentData::~ComponentData()
{
    SAFE_RELEASE(m_pRootCookie);
    SAFE_RELEASE(m_pPathname);
}



DEFINE_FORWARDS_MACHINE_NAME( ComponentData, m_pRootCookie )



CCookie&
ComponentData::QueryBaseRootCookie()
{
    ASSERT(NULL != m_pRootCookie);
    return (CCookie&)*m_pRootCookie;
}



STDMETHODIMP
ComponentData::Initialize( LPUNKNOWN pUnknown )
{
    HRESULT hr = CComponentData::Initialize( pUnknown );

    if( SUCCEEDED(hr) )
    {
        ASSERT( !m_pPathname );

        // create Pathname Object
        if( FAILED( CoCreateInstance(CLSID_Pathname,
                                      NULL,
                                      CLSCTX_INPROC_SERVER,
                                      IID_IADsPathname,
                                      (void**)&m_pPathname) ) )
        {
            // in case of an error, ignore and later provide no escaping.
            ASSERT( FALSE );
            SAFE_RELEASE( m_pPathname );
        }
    }

    return hr;
}


STDMETHODIMP
ComponentData::CreateComponent( LPCOMPONENT* ppComponent )
{

    MFC_TRY;

    ASSERT(ppComponent != NULL);

    
    CComObject<Component>* pObject;
    CComObject<Component>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    pObject->SetComponentDataPtr( (ComponentData*)this );

    return pObject->QueryInterface( IID_IComponent,
                                    reinterpret_cast<void**>(ppComponent) );

    MFC_CATCH;
}



HRESULT
ComponentData::LoadIcons(
    LPIMAGELIST pImageList,
    BOOL
)
/***

     This routine loads the icon resources that MMC will use.
     We use the image list member ImageListSetIcon to make these
     resources available to MMC.

 ***/
{

    HICON hIcon;
    HRESULT hr = S_OK;

    if( !IsErrorSet() )
    {
        //
        // Set the generic and the last icon in case they are used.
        //

        hIcon = LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDI_GENERIC));
        ASSERT(hIcon != NULL);
        hr = pImageList->ImageListSetIcon((PLONG_PTR)hIcon,iIconGeneric);
        ASSERT(SUCCEEDED(hr));
        hr = pImageList->ImageListSetIcon((PLONG_PTR)hIcon,iIconLast);
        ASSERT(SUCCEEDED(hr));

        //
        // Set the closed folder icon.
        //

        hIcon = LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDI_FOLDER_CLOSED));
        ASSERT(hIcon != NULL);
        hr = pImageList->ImageListSetIcon((PLONG_PTR)hIcon,iIconFolder);
        ASSERT(SUCCEEDED(hr));

        //
        // Set the class, attribute, and display specifier icon.
        //

        hIcon = LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDI_CLASS));
        ASSERT(hIcon != NULL);
        hr = pImageList->ImageListSetIcon((PLONG_PTR)hIcon,iIconClass);
        ASSERT(SUCCEEDED(hr));

        hIcon = LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDI_ATTRIBUTE));
        ASSERT(hIcon != NULL);
        hr = pImageList->ImageListSetIcon((PLONG_PTR)hIcon,iIconAttribute);
        ASSERT(SUCCEEDED(hr));
    }

    return S_OK;
}

HRESULT
ComponentData::OnNotifyExpand(
    LPDATAOBJECT lpDataObject,
    BOOL bExpanding,
    HSCOPEITEM hParent
)
/***

    This routine is called in response to IComponentData:Notify with
    the MMCN_EXPAND notification.  The argument bExpanding tells us
    whether the node is expanding or contracting.

***/
{

    ASSERT( NULL != lpDataObject &&
            NULL != hParent &&
            NULL != m_pConsoleNameSpace );

    //
    // Do nothing on a contraction - we will get notifications to
    // destroy the disappearing nodes.
    //

    if ( !bExpanding )
        return S_OK;

    //
    // This code will not work if SchmMgmt becomes an extension
    // since the RawCookie format will not be available.
    //

    CCookie* pBaseParentCookie = NULL;

    HRESULT hr = ExtractData( lpDataObject,
                              CSchmMgmtDataObject::m_CFRawCookie,
                              reinterpret_cast<PBYTE>(&pBaseParentCookie),
                              sizeof(pBaseParentCookie) );
    ASSERT( SUCCEEDED(hr) );

    Cookie* pParentCookie = ActiveCookie(pBaseParentCookie);
    ASSERT( NULL != pParentCookie );

    //
    // If this node already has children then this expansion is a
    // re-expansion.  We should complain, but not do anything.
    //

    if ( !((pParentCookie->m_listScopeCookieBlocks).IsEmpty()) ) {
        ASSERT(FALSE);
        return S_OK;
    }

    switch ( pParentCookie->m_objecttype ) {

    case SCHMMGMT_SCHMMGMT:
      // expanding the root, need to bind
      hr = _InitBasePaths();
      if( SUCCEEDED(hr) )
      {
            CheckSchemaPermissions( );      // ignoring errors
      }
      else
      {
            SetError( IDS_ERR_ERROR, IDS_ERR_NO_SCHEMA_PATH );

            SetDelayedRefreshOnShow( hParent );

            return S_OK;
      }

      InitializeRootTree( hParent, pParentCookie );

      break;

    case SCHMMGMT_CLASSES:

        return FastInsertClassScopeCookies(
                   pParentCookie,
                   hParent );

        break;

    //
    // These node types have no scope children.
    //

    case SCHMMGMT_CLASS:
    case SCHMMGMT_ATTRIBUTE:
    case SCHMMGMT_ATTRIBUTES:
        return S_OK;

    //
    // We received an unknown node type.
    //

    default:

        TRACE( "ComponentData::EnumerateScopeChildren bad parent type.\n" );
        ASSERT( FALSE );
        return S_OK;

    }

    return S_OK;
}

HRESULT
ComponentData::OnNotifyRelease(
    LPDATAOBJECT,
    HSCOPEITEM
) {

    //
    // Since we are not a valid extension snap in,
    // we don't need to do anything here.
    //

    return S_OK;
}


HRESULT 
ComponentData::OnNotifyDelete(
    LPDATAOBJECT lpDataObject)
{
    CCookie* pBaseParentCookie = NULL;

    HRESULT hr = ExtractData( lpDataObject,
                              CSchmMgmtDataObject::m_CFRawCookie,
                              reinterpret_cast<PBYTE>(&pBaseParentCookie),
                              sizeof(pBaseParentCookie) );
    ASSERT( SUCCEEDED(hr) );

    Cookie* pParentCookie = ActiveCookie(pBaseParentCookie);
    ASSERT( NULL != pParentCookie );

    UINT promptID = 0;
    LPARAM updateType = SCHMMGMT_CLASS;

    if (pParentCookie->m_objecttype == SCHMMGMT_CLASS)
    {
        promptID = IDS_DELETE_CLASS_PROMPT;
        updateType = SCHMMGMT_CLASS;
    }
    else if (pParentCookie->m_objecttype == SCHMMGMT_ATTRIBUTE)
    {
        promptID = IDS_DELETE_ATTR_PROMPT;
        updateType = SCHMMGMT_ATTRIBUTES;
    }
    else
    {
        // We should never get called to delete anything but
        // class and attribute nodes

        ASSERT(FALSE);
        return E_FAIL;
    }

    if( IDYES == AfxMessageBox( promptID, MB_YESNO | MB_ICONWARNING ))
    {

        hr = DeleteClass( pParentCookie );
        if ( SUCCEEDED(hr) )
        {
           // Remove the node from the UI

           m_pConsoleNameSpace->DeleteItem( pParentCookie->m_hScopeItem, TRUE );

           // Remove the node from the list

           bool result = g_ClassCookieList.DeleteCookie(pParentCookie);
           ASSERT(result);
        }
        else
        {
           CString szDeleteError;
           szDeleteError.Format(IDS_ERRMSG_DELETE_FAILED_CLASS, GetErrorMessage(hr, TRUE));
          
           DoErrMsgBox( ::GetActiveWindow(), TRUE, szDeleteError );
        }
    }

    return hr;
}

HRESULT
ComponentData::DeleteClass(
    Cookie* pcookie
)
/***

    This deletes an attribute from the schema

***/
{
   HRESULT hr = S_OK;

   do
   {
      if ( !pcookie )
      {
         hr = E_INVALIDARG;
         break;
      }

      SchemaObject* pObject = g_SchemaCache.LookupSchemaObjectByCN(
                                pcookie->strSchemaObject,
                                SCHMMGMT_CLASS );

      if ( !pObject )
      {
         hr = E_FAIL;
         break;
      }

      CString szAdsPath;
      GetSchemaObjectPath( pObject->commonName, szAdsPath );

      hr = DeleteObject( szAdsPath, pcookie, g_ClassFilter );
   } while (false);

   return hr;
}

//
// This is where we store the string handed back to GetDisplayInfo().
//

CString g_strResultColumnText;

BSTR
ComponentData::QueryResultColumnText(
    CCookie& basecookieref,
    int nCol
) {

#ifndef UNICODE
#error not ANSI-enabled
#endif

    BSTR strDisplayText = NULL;
    Cookie& cookieref = (Cookie&)basecookieref;
    SchemaObject *pSchemaObject = NULL;
    SchemaObject *pSrcSchemaObject = NULL;

    switch ( cookieref.m_objecttype ) {

    //
    // These only have first column textual data.
    //

    case SCHMMGMT_SCHMMGMT:

        if ( COLNUM_SCHEMA_NAME == nCol )
            strDisplayText = const_cast<BSTR>(((LPCTSTR)g_strSchmMgmt));
        break;

    case SCHMMGMT_CLASSES:

        if ( COLNUM_SCHEMA_NAME == nCol )
            strDisplayText = const_cast<BSTR>(((LPCTSTR)g_strClasses));
        break;

    case SCHMMGMT_ATTRIBUTES:

        if ( COLNUM_SCHEMA_NAME == nCol )
            strDisplayText = const_cast<BSTR>(((LPCTSTR)g_strAttributes));
        break;

    case SCHMMGMT_CLASS:

        //
        // These display names come out of the schema cache objects.
        //

        pSchemaObject = g_SchemaCache.LookupSchemaObjectByCN(
                            cookieref.strSchemaObject,
                            SCHMMGMT_CLASS );

        //
        // If there is no cache object, we just have to return UNKNOWN.
        //

        if ( !pSchemaObject ) {
            ASSERT(FALSE);
            strDisplayText = const_cast<BSTR>( (LPCTSTR)g_Unknown );
            break;
        }

        //
        // Otherwise, return the appropriate text for the column.
        //

        if ( COLNUM_CLASS_NAME == nCol ) {

            strDisplayText = const_cast<BSTR>((LPCTSTR)pSchemaObject->ldapDisplayName);

        } else if ( COLNUM_CLASS_TYPE == nCol ) {

            switch ( pSchemaObject->dwClassType ) {

            case 0:
               strDisplayText = const_cast<BSTR>(((LPCTSTR)g_88Class));
               break;
            case 1:
               strDisplayText = const_cast<BSTR>(((LPCTSTR)g_StructuralClass));
               break;
            case 2:
               strDisplayText = const_cast<BSTR>(((LPCTSTR)g_AbstractClass));
               break;
            case 3:
               strDisplayText = const_cast<BSTR>(((LPCTSTR)g_AuxClass));
               break;
            default:
               strDisplayText = const_cast<BSTR>(((LPCTSTR)g_Unknown));
               break;
            }

        } else if ( COLNUM_CLASS_STATUS == nCol ) {
            if ( pSchemaObject->isDefunct ) {
               strDisplayText = const_cast<BSTR>( (LPCTSTR)g_Defunct );
            } else {
               strDisplayText = const_cast<BSTR>( (LPCTSTR)g_Active );
            }
        } else if ( COLNUM_CLASS_DESCRIPTION == nCol ) {

            strDisplayText = const_cast<BSTR>((LPCTSTR)pSchemaObject->description);
        }

        break;

    case SCHMMGMT_ATTRIBUTE:

        pSchemaObject = g_SchemaCache.LookupSchemaObjectByCN(
                           cookieref.strSchemaObject,
                           SCHMMGMT_ATTRIBUTE );

        //
        // If there is no cache object, we just have to return UNKNOWN.
        //

        if ( !pSchemaObject ) {
            ASSERT(FALSE);
            strDisplayText = const_cast<BSTR>( (LPCTSTR)g_Unknown );
            break;
        }

        //
        // Otherwise, return the appropriate text for the column.
        //

        if ( COLNUM_ATTRIBUTE_NAME == nCol ) {

            strDisplayText = const_cast<BSTR>((LPCTSTR)pSchemaObject->ldapDisplayName);

        } else if ( COLNUM_ATTRIBUTE_TYPE == nCol ) {

            //
            // If the parent cookie is the attributes folder, then
            // this column is the syntax.  Otherwise, this column
            // is the optional/mandatory status of the attribute.
            //

            if ( (cookieref.pParentCookie)->m_objecttype == SCHMMGMT_ATTRIBUTES ) {

                strDisplayText = const_cast<BSTR>(
                                     (LPCTSTR)g_Syntax[pSchemaObject->SyntaxOrdinal].m_strSyntaxName
                                 );

            } else {

                if ( cookieref.Mandatory ) {
                    strDisplayText = const_cast<BSTR>(((LPCTSTR)g_MandatoryAttribute));
                } else {
                    strDisplayText = const_cast<BSTR>(((LPCTSTR)g_OptionalAttribute));
                }

            }

        } else if ( COLNUM_ATTRIBUTE_STATUS == nCol) {
            if ( pSchemaObject->isDefunct ) {
               strDisplayText = const_cast<BSTR>( (LPCTSTR)g_Defunct );
            } else {
               strDisplayText = const_cast<BSTR>( (LPCTSTR)g_Active );
            }
        } else if ( COLNUM_ATTRIBUTE_SYSTEM == nCol ) {

            //
            // If the parent is the attributes folder, this is the description.
            // Otherwise, it's the system status.
            //

            if ( (cookieref.pParentCookie)->m_objecttype == SCHMMGMT_ATTRIBUTES ) {

                strDisplayText = const_cast<BSTR>((LPCTSTR)pSchemaObject->description);

           } else {

               if ( cookieref.System ) {
                   strDisplayText = const_cast<BSTR>(((LPCTSTR)g_Yes));
               } else {
                   strDisplayText = const_cast<BSTR>(((LPCTSTR)g_No));
               }

           }

        } else if ( COLNUM_ATTRIBUTE_DESCRIPTION == nCol ) {

            strDisplayText = const_cast<BSTR>((LPCTSTR)pSchemaObject->description);

        } else if ( COLNUM_ATTRIBUTE_PARENT == nCol ) {

            pSrcSchemaObject = g_SchemaCache.LookupSchemaObjectByCN(
                                   cookieref.strSrcSchemaObject,
                                   SCHMMGMT_CLASS );

            //
            // If there is no cache object, we just have to return UNKNOWN.
            //

            if ( !pSchemaObject ) {
                ASSERT(FALSE);
                strDisplayText = const_cast<BSTR>( (LPCTSTR)g_Unknown );
                break;
            }

            //
            // Otherwise, return the appropriate text for the column.
            //

            strDisplayText = const_cast<BSTR>((LPCTSTR)pSrcSchemaObject->ldapDisplayName);
        }

        break;

    default:

        TRACE( "ComponentData::QueryResultColumnText bad cookie.\n" );
        ASSERT( FALSE );
        break;

    }

    //
    // Release the schema cache references.
    //

    if ( pSchemaObject ) {
        g_SchemaCache.ReleaseRef( pSchemaObject );
    }

    if ( pSrcSchemaObject ) {
        g_SchemaCache.ReleaseRef( pSrcSchemaObject );
    }

    //
    // Return the appropriate display string.
    //

    if ( strDisplayText ) {
        return strDisplayText;
    }

    return L"";

}

//
// Given a cookie, this returns the icon to display for that cookie.
//

int
ComponentData::QueryImage(
    CCookie& basecookieref,
    BOOL )
{

    Cookie& cookieref = (Cookie&)basecookieref;

    switch ( cookieref.m_objecttype ) {

    case SCHMMGMT_SCHMMGMT:
    case SCHMMGMT_CLASSES:
    case SCHMMGMT_ATTRIBUTES:
        return iIconFolder;
        break;

    case SCHMMGMT_CLASS:
        return iIconClass;
        break;

    case SCHMMGMT_ATTRIBUTE:
        return iIconAttribute;
        break;

    default:

        TRACE( "ComponentData::QueryImage bad parent type.\n" );
        ASSERT( FALSE );
        break;
    }

    return iIconGeneric;

}

//
// This routines tells MMC whether or not there are
// property pages and menus for this item.
//

HRESULT
_InsertMenuHelper(
   LPCONTEXTMENUCALLBACK piCallback,       
   long                  lInsertionPointID,
   int                   index,
   BOOL                  fEnabled = TRUE );


HRESULT
_InsertMenuHelper(
   LPCONTEXTMENUCALLBACK piCallback,       
   long                  lInsertionPointID,
   int                   index,
   BOOL                  fEnabled /* = TRUE */ )
{
   CONTEXTMENUITEM MenuItem;
   MenuItem.lInsertionPointID   = lInsertionPointID;
   MenuItem.fFlags              = fEnabled ? 0 : MF_GRAYED ;
   MenuItem.fSpecialFlags       = 0;

   MenuItem.strName = const_cast<BSTR>(
     (LPCTSTR)g_MenuStrings[index] );
   MenuItem.strStatusBarText = const_cast<BSTR>(
     (LPCTSTR)g_StatusStrings[index] );
   MenuItem.lCommandID = index;

   return piCallback->AddItem( &MenuItem );
}



STDMETHODIMP
ComponentData::AddMenuItems(
    LPDATAOBJECT piDataObject,
    LPCONTEXTMENUCALLBACK piCallback,
    long* )
{
   CCookie* pBaseParentCookie = NULL;

   HRESULT hr = ExtractData( piDataObject,
                           CSchmMgmtDataObject::m_CFRawCookie,
                           reinterpret_cast<PBYTE>(&pBaseParentCookie),
                           sizeof(pBaseParentCookie) );
   ASSERT( SUCCEEDED(hr) );

   Cookie* pParentCookie = ActiveCookie(pBaseParentCookie);
   ASSERT( NULL != pParentCookie );

   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   LoadGlobalCookieStrings();

   switch (pParentCookie->m_objecttype)
   {
      case SCHMMGMT_SCHMMGMT: // Root Folder
      {
         VERIFY(
            SUCCEEDED(
               _InsertMenuHelper(
                  piCallback,
                  CCM_INSERTIONPOINTID_PRIMARY_TOP,
                  SCHEMA_RETARGET)));
         VERIFY(
            SUCCEEDED(
               _InsertMenuHelper(
                  piCallback,
                  CCM_INSERTIONPOINTID_PRIMARY_TOP,
                  SCHEMA_EDIT_FSMO,
                  !IsErrorSet() && IsSchemaLoaded())));
         VERIFY(
            SUCCEEDED(
               _InsertMenuHelper(
                  piCallback,
                  CCM_INSERTIONPOINTID_PRIMARY_TOP,
                  SCHEMA_SECURITY,
                  !IsErrorSet() && IsSchemaLoaded())));
         VERIFY(
            SUCCEEDED(
               _InsertMenuHelper(
                  piCallback,
                  CCM_INSERTIONPOINTID_PRIMARY_TOP,
                  SCHEMA_REFRESH,
                  !IsErrorSet() && IsSchemaLoaded())));
         break;
      }
      case SCHMMGMT_CLASSES: // classes folder
      {
         // 285448, 293449

         VERIFY(
            SUCCEEDED(
               _InsertMenuHelper(
                  piCallback,
                  CCM_INSERTIONPOINTID_PRIMARY_TOP,
                  NEW_CLASS,
                  !IsErrorSet() && CanCreateClass())));

         if( !IsErrorSet() && CanCreateClass() )     // add only if enabsed
             VERIFY(
                SUCCEEDED(
                   _InsertMenuHelper(
                      piCallback,
                      CCM_INSERTIONPOINTID_PRIMARY_NEW,
                      CLASSES_CREATE_CLASS)));
         break;
      }
      case SCHMMGMT_ATTRIBUTES: // attributes folder
      {
         VERIFY(
            SUCCEEDED(
               _InsertMenuHelper(
                  piCallback,
                  CCM_INSERTIONPOINTID_PRIMARY_TOP,
                  NEW_ATTRIBUTE,
                  !IsErrorSet() && CanCreateAttribute())));

         if( !IsErrorSet() && CanCreateAttribute() )     // add only if enabsed
             VERIFY(
                SUCCEEDED(
                   _InsertMenuHelper(
                      piCallback,
                      CCM_INSERTIONPOINTID_PRIMARY_NEW,
                      ATTRIBUTES_CREATE_ATTRIBUTE)));
         break;
      }
      default:
      {
         // could be class or attribute item
      }

   } // switch

   return S_OK;
}



STDMETHODIMP
ComponentData::Command(long lCommandID, LPDATAOBJECT piDataObject)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   switch ( lCommandID )
   {
      case NEW_ATTRIBUTE:
      case ATTRIBUTES_CREATE_ATTRIBUTE:
      {
         CDialog warn(IDD_CREATE_WARN);
         if (IDOK == warn.DoModal())
         {
            CreateAttributeDialog(this, piDataObject).DoModal();
         }
         break;
      }
      case NEW_CLASS:
      case CLASSES_CREATE_CLASS:
      {
         CDialog warn(IDD_CREATE_WARN);
         if (IDOK == warn.DoModal())
         {
            DoNewClassDialog(*this);
         }
         break;
      }

      case SCHEMA_RETARGET:
        _OnRetarget(piDataObject);
        break;

      case SCHEMA_EDIT_FSMO:
        _OnEditFSMO();
        break;

      case SCHEMA_REFRESH:
        if( FAILED(_OnRefresh(piDataObject)) )
            DoErrMsgBox(::GetActiveWindow(), TRUE, IDS_ERR_NO_UPDATE);
        break;

      case SCHEMA_SECURITY:
        _OnSecurity();
        break;

      default:

        break;
   }

   return S_OK;
}



STDMETHODIMP
ComponentData::QueryPagesFor(
    LPDATAOBJECT pDataObject )
{

    MFC_TRY;

    if ( NULL == pDataObject ) {
        ASSERT(FALSE);
        return E_POINTER;
    }

    HRESULT hr;

    CCookie* pBaseParentCookie = NULL;

    hr = ExtractData( pDataObject,
                      CSchmMgmtDataObject::m_CFRawCookie,
                      reinterpret_cast<PBYTE>(&pBaseParentCookie),
                      sizeof(pBaseParentCookie) );

    ASSERT( SUCCEEDED(hr) );

    Cookie* pParentCookie = ActiveCookie(pBaseParentCookie);
    ASSERT( NULL != pParentCookie );

    if ( pParentCookie->m_objecttype == SCHMMGMT_CLASS ) {
        return S_OK;
    }

    return S_FALSE;

    MFC_CATCH;
}

//
// This adds pages to the property sheet if appropriate.
// The handle parameter must be saved in the property page
// object to notify the parent when modified.
//

STDMETHODIMP
ComponentData::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK pCallBack,
    LONG_PTR,
    LPDATAOBJECT pDataObject )
{
    MFC_TRY;

    CWaitCursor wait;

    //
    // Validate the parameters.
    //

    if ( ( NULL == pCallBack ) ||
         ( NULL == pDataObject ) ) {

        ASSERT(FALSE);
        return E_POINTER;
    }

    //
    // Make sure this is a class object that we are calling up.
    //

    CCookie* pBaseParentCookie = NULL;

    HRESULT hr = ExtractData( pDataObject,
                              CSchmMgmtDataObject::m_CFRawCookie,
                              reinterpret_cast<PBYTE>(&pBaseParentCookie),
                              sizeof(pBaseParentCookie) );
    ASSERT( SUCCEEDED(hr) );
    hr = S_OK;

    Cookie* pParentCookie = ActiveCookie(pBaseParentCookie);
    ASSERT( NULL != pParentCookie );
    ASSERT( pParentCookie->m_objecttype == SCHMMGMT_CLASS );

    //
    // Create the page.
    //

    HPROPSHEETPAGE hPage;

    ClassGeneralPage *pGeneralPage = new ClassGeneralPage( this );
    ClassRelationshipPage *pRelationshipPage =
        new ClassRelationshipPage( this, pDataObject );
    ClassAttributePage *pAttributesPage =
        new ClassAttributePage( this, pDataObject );

    if ( pGeneralPage ) {

        pGeneralPage->Load( *pParentCookie );
        MMCPropPageCallback( &pGeneralPage->m_psp );
        hPage = CreatePropertySheetPage( &pGeneralPage->m_psp );
        pCallBack->AddPage(hPage);
    }

    if ( pRelationshipPage ) {

       pRelationshipPage->Load( *pParentCookie );
       MMCPropPageCallback( &pRelationshipPage->m_psp );
       hPage = CreatePropertySheetPage( &pRelationshipPage->m_psp );
       pCallBack->AddPage(hPage);
    }

    if ( pAttributesPage ) {

       pAttributesPage->Load( *pParentCookie );
       MMCPropPageCallback( &pAttributesPage->m_psp );
       hPage = CreatePropertySheetPage( &pAttributesPage->m_psp );
       pCallBack->AddPage(hPage);
    }

    //
    // Add the ACL editor page.
    //

    SchemaObject    * pObject   = NULL;
    CAclEditorPage  * pAclPage  = NULL;
    CString szAdsPath;

    pObject = g_SchemaCache.LookupSchemaObjectByCN(
                 pParentCookie->strSchemaObject,
                 SCHMMGMT_CLASS );

    if ( pObject ) {

       GetSchemaObjectPath( pObject->commonName, szAdsPath );

       if ( !szAdsPath.IsEmpty() ) {

           hr = CAclEditorPage::CreateInstance( &pAclPage, szAdsPath,
                                                pParentCookie->strSchemaObject );

           if ( SUCCEEDED(hr) )
           {
               ASSERT( pAclPage );
               pCallBack->AddPage( pAclPage->CreatePage() );
           }
           else
           {
               DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr) );
               hr = S_FALSE;    // tell mmc to cancel "show prop pages"
           }
       }
    }

    return hr;

    MFC_CATCH;
}

HRESULT
ComponentData::FastInsertClassScopeCookies(
    Cookie* pParentCookie,
    HSCOPEITEM hParentScopeItem
)
/***

    On an expand for the "Classes" node, this inserts the
    class scope items from the cache.

    pParentCookie is the cookie for the parent object.
    hParentScopeItem is the HSCOPEITEM for the parent.

****/
{

    HRESULT hr;
    SCOPEDATAITEM ScopeItem;
    Cookie* pNewCookie;
    LPCWSTR lpcszMachineName = pParentCookie->QueryNonNULLMachineName();
    SchemaObject *pObject, *pHead;

    //
    // Initialize the scope item.
    //

   ::ZeroMemory( &ScopeItem, sizeof(ScopeItem) );
   ScopeItem.mask =
         SDI_STR
      |  SDI_IMAGE
      |  SDI_OPENIMAGE
      |  SDI_STATE
      |  SDI_PARAM
      |  SDI_PARENT
      |  SDI_CHILDREN;
   ScopeItem.displayname = MMC_CALLBACK;
   ScopeItem.relativeID = hParentScopeItem;
   ScopeItem.nState = TVIS_EXPANDED;
   ScopeItem.cChildren = 0;

    //
    // Remember the parent cookie and scope item; we
    // may need to insert later as a refresh.
    //

    g_ClassCookieList.pParentCookie = pParentCookie;
    g_ClassCookieList.hParentScopeItem = hParentScopeItem;

    //
    // Rather than having a clean class interface to the cache, we
    // walk the cache data structures ourselves.  This isn't super
    // clean, but it's simple.
    //
    // Since we do this, we have to make sure that the cache is loaded.
    //
    // This is just like in
    // Component::FastInsertAttributeResultCookies
    //

    g_SchemaCache.LoadCache();

    pObject = g_SchemaCache.pSortedClasses;

    //
    // If there's no sorted list, we can't insert anything!!!!
    // We must return an error or else the console will never
    // ask us again for scope items.
    //

    if ( !pObject ) {
        ASSERT( FALSE );

         // @@ spb: bad message, this could occur if the schema
         // queries were empty...
        DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_SCHEMA_PATH );
        return E_FAIL;
    }

    //
    // Do the insert.
    //

    pHead = pObject;

    do {

       //
       // Insert this result.
       //

       pNewCookie= new Cookie( SCHMMGMT_CLASS,
                                        lpcszMachineName );

       if ( pNewCookie ) {

           pNewCookie->pParentCookie = pParentCookie;
           pNewCookie->strSchemaObject = pObject->commonName;

           pParentCookie->m_listScopeCookieBlocks.AddHead(
               (CBaseCookieBlock*)pNewCookie
           );

           ScopeItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pNewCookie);
           ScopeItem.nImage = QueryImage( *pNewCookie, FALSE );
                   ScopeItem.nOpenImage = QueryImage( *pNewCookie, TRUE );
           hr = m_pConsoleNameSpace->InsertItem(&ScopeItem);

           if ( SUCCEEDED(hr) ) {

               pNewCookie->m_hScopeItem = ScopeItem.ID;
               g_ClassCookieList.AddCookie( pNewCookie, ScopeItem.ID );

           } else {

               delete pNewCookie;
           }

       }

       pObject = pObject->pSortedListFlink;

    } while ( pObject != pHead );

    return S_OK;
}

//
// Refreshing the scope pane view.
//

VOID
ComponentData::RefreshScopeView(
    VOID
)
/***

    When we reload the schema cache and the "Classes"
    folder has been opened, this routine deletes all
    the scope items from view and re-inserts them.
    This makes new classes visible to the user.

***/
{

    HRESULT hr;

    CCookieListEntry *pHead = g_ClassCookieList.pHead;
    CCookieListEntry *pCurrent;

    if ( pHead != NULL ) {

        //
        // Remove all the scope pane items.
        //

        pCurrent = pHead;

        while ( pCurrent->pNext != pHead ) {

            hr = m_pConsoleNameSpace->DeleteItem( pCurrent->pNext->hScopeItem, TRUE );
            ASSERT( SUCCEEDED( hr ));

            //
            // This should cause the cookie to be deleted.
            //

            pCurrent->pNext->pCookie->Release();

            pCurrent = pCurrent->pNext;
        }

        //
        // Remove the head of the list.
        //

        hr = m_pConsoleNameSpace->DeleteItem( pHead->hScopeItem, TRUE );
        ASSERT( SUCCEEDED( hr ));

        pHead->pCookie->Release();

        //
        // Delete the class cookie list.
        //

        g_ClassCookieList.DeleteAll();
    }

    //
    // Re-insert them from the cache if this node has
    // been expanded at some point.  We have to do this
    // because the console doesn't ever seem to ask
    // again.
    //

    if ( g_ClassCookieList.pParentCookie ) {

        FastInsertClassScopeCookies(
            g_ClassCookieList.pParentCookie,
            g_ClassCookieList.hParentScopeItem
        );

    }

    return;
}


void ComponentData::_OnRetarget(LPDATAOBJECT lpDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    MyBasePathsInfo    oldBasePathsInfo;
    MyBasePathsInfo    newBasePathsInfo;
    HRESULT             hr              = S_OK;
    HWND                hWndParent      = NULL;
    BOOL                fWasErrorSet    = IsErrorSet();


    m_pConsole->GetMainWindow(&hWndParent);
    
    CChangeDCDialog dlg(GetBasePathsInfo(), hWndParent);

    do
    {
        if (IDOK != dlg.DoModal())
            break;

        CWaitCursor wait;

        // save the old path just in case
        oldBasePathsInfo.InitFromInfo( GetBasePathsInfo() );

        // attempt to bind
        hr = newBasePathsInfo.InitFromName(dlg.GetNewDCName());
        BREAK_ON_FAILED_HRESULT(hr);

        // switch focus
        GetBasePathsInfo()->InitFromInfo(&newBasePathsInfo);
        
        // invalidate the whole tree
        hr = _OnRefresh(lpDataObject);
        BREAK_ON_FAILED_HRESULT(hr);

        SetError( 0, 0 );

        // Reset the ResultViewType
        if( IsErrorSet() != fWasErrorSet )
        {
            ASSERT( SCHMMGMT_SCHMMGMT == QueryRootCookie().m_objecttype );
            
            hr = m_pConsole->SelectScopeItem( QueryRootCookie().m_hScopeItem );
            ASSERT_BREAK_ON_FAILED_HRESULT(hr);
            
            //
            // Add children nodes if needed
            //
            if ( (QueryRootCookie().m_listScopeCookieBlocks).IsEmpty() )
            {
                InitializeRootTree( QueryRootCookie().m_hScopeItem, &QueryRootCookie() );
            }
        }

        // Update the root display name

        if (GetBasePathsInfo()->GetServerName())
        {
            CString strDisplayName;
            strDisplayName.LoadString(IDS_SCOPE_SCHMMGMT);
            strDisplayName += L" [";
            strDisplayName += GetBasePathsInfo()->GetServerName();
            strDisplayName += L"]";

            SCOPEDATAITEM RootItem;
            ::ZeroMemory( &RootItem, sizeof(RootItem));
            RootItem.mask = SDI_STR | SDI_PARAM;
            RootItem.displayname = const_cast<PWSTR>((PCWSTR)strDisplayName);
            RootItem.ID = QueryRootCookie().m_hScopeItem;

            hr = m_pConsoleNameSpace->SetItem(&RootItem);
            ASSERT(SUCCEEDED(hr));
        }


    } while( FALSE );


    if( FAILED(hr) )
    {
        DoErrMsgBox(::GetActiveWindow(), TRUE, IDS_ERR_CANT_RETARGET);

        // restoring...
        GetBasePathsInfo()->InitFromInfo(&oldBasePathsInfo);
    }
}


void ComponentData::_OnEditFSMO()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  HWND hWndParent;

  // Enable hourglass
  CWaitCursor wait;

  m_pConsole->GetMainWindow(&hWndParent);

  CComPtr<IDisplayHelp> spIDisplayHelp;
  m_pConsole->QueryInterface (IID_IDisplayHelp, (void **)&spIDisplayHelp);
  ASSERT(spIDisplayHelp != NULL);

  CEditFsmoDialog dlg(GetBasePathsInfo(), hWndParent, spIDisplayHelp, CanChangeOperationsMaster() );
  dlg.DoModal();
}

HRESULT ComponentData::_OnRefresh(LPDATAOBJECT lpDataObject)
{
    CWaitCursor wait;
    HRESULT     hr = S_OK;
    
    do
    {
        //
        // Force the ds to update the schema cache.
        //
        
        hr = ForceDsSchemaCacheUpdate();
        // error here means Schema is read-only, cannot force refresh.  Ignoring...

        hr = S_OK;

        // nothing shuld fail after this point
        g_SchemaCache.FreeAll();
        g_SchemaCache.LoadCache();
        
        RefreshScopeView();
        m_pConsole->UpdateAllViews(
            lpDataObject,
            SCHMMGMT_SCHMMGMT,
            SCHMMGMT_UPDATEVIEW_REFRESH);

    } while( FALSE );

    return hr;
}


void ComponentData::_OnSecurity()
{
   HRESULT  hr          = S_OK;
   HWND     hWndParent  = NULL;
   CString	szSchemaPath;

   do
   {
      // Enable hourglass
      CWaitCursor wait;

      CComPtr<IADs> spSchemaContainer;

      GetBasePathsInfo()->GetSchemaPath(szSchemaPath);

      hr = ADsGetObject( (LPWSTR)(LPCWSTR)szSchemaPath,
              IID_IADs,
              (void**) &spSchemaContainer);
      BREAK_ON_FAILED_HRESULT(hr);

      CComBSTR path;
      hr = spSchemaContainer->get_ADsPath(&path);
      BREAK_ON_FAILED_HRESULT(hr);

      CComBSTR classname;
      hr = spSchemaContainer->get_Class(&classname);
      BREAK_ON_FAILED_HRESULT(hr);

      m_pConsole->GetMainWindow(&hWndParent);
      
      
      // Determine if the registry is accessible & schema modifications are allowed
      PWSTR          pszFsmoOwnerServerName = 0;
      MyBasePathsInfo fsmoOwnerInfo;
      
      HRESULT hr = FindFsmoOwner(GetBasePathsInfo(), SCHEMA_FSMO, &fsmoOwnerInfo, &pszFsmoOwnerServerName);
      
      // If we have the server name, try to read the registry
      BOOL fMarkReadOnly = ( FAILED(hr) || pszFsmoOwnerServerName == 0 || pszFsmoOwnerServerName[0] == 0);

      // Ignore hr code.

      hr =
         DSEditSecurity(
            hWndParent,
            path,
            classname,
            fMarkReadOnly ? DSSI_READ_ONLY : 0,
            NULL,
            NULL,
            NULL,
            0);
   }
   while (0);

   if (FAILED(hr))
   {
		m_pConsole->GetMainWindow(&hWndParent);

		if( szSchemaPath.IsEmpty() )
			DoErrMsgBox( hWndParent, TRUE, IDS_ERR_NO_SCHEMA_PATH );
		else
			DoErrMsgBox( hWndParent, TRUE, GetErrorMessage(hr,TRUE) );
   }
}


HRESULT ComponentData::_InitBasePaths()
{
  CWaitCursor wait;

  // try to get a bind to a generic DC
  HRESULT hr = GetBasePathsInfo()->InitFromName(NULL);
  if (FAILED(hr))
    return hr; // ADSI failed, cannot get any server

  // from the current server, try to bind to the schema FSMO owner
  MyBasePathsInfo fsmoBasePathsInfo;
  PWSTR pszFsmoOwnerServerName = 0;
  hr = FindFsmoOwner(GetBasePathsInfo(), SCHEMA_FSMO, &fsmoBasePathsInfo,
                            &pszFsmoOwnerServerName);

  delete[] pszFsmoOwnerServerName;
  pszFsmoOwnerServerName = 0;

  if (FAILED(hr))
    return S_OK; // still good keep what we have (even though not the FSMO owner)

  // got it, we switch focus
  return GetBasePathsInfo()->InitFromInfo(&fsmoBasePathsInfo);
}



STDMETHODIMP ComponentData::GetLinkedTopics(LPOLESTR* lpCompiledHelpFile)
{
  if (lpCompiledHelpFile == NULL)
      return E_INVALIDARG;

  CString szHelpFilePath;


  LPTSTR lpszBuffer = szHelpFilePath.GetBuffer(2*MAX_PATH);
  UINT nLen = ::GetSystemWindowsDirectory(lpszBuffer, 2*MAX_PATH);
  if (nLen == 0)
    return E_FAIL;

  szHelpFilePath.ReleaseBuffer();
  szHelpFilePath += L"\\help\\ADconcepts.chm";

  UINT nBytes = (szHelpFilePath.GetLength()+1) * sizeof(WCHAR);
  *lpCompiledHelpFile = (LPOLESTR)::CoTaskMemAlloc(nBytes);
  if (*lpCompiledHelpFile != NULL)
  {
    memcpy(*lpCompiledHelpFile, (LPCWSTR)szHelpFilePath, nBytes);
  }

  return S_OK;
}



const WCHAR CN_EQUALS[]     = L"CN=";


HRESULT ComponentData::GetSchemaObjectPath( const CString & strCN,
                                            CString       & strPath,
                                            ADS_FORMAT_ENUM formatType /* = ADS_FORMAT_X500 */ )
{
    HRESULT hr = E_FAIL;
    
    do
    {
        if( !m_pPathname )
            break;

        CComBSTR    bstr;

        // Escape it
        hr = m_pPathname->GetEscapedElement( 0,
                                             CComBSTR( CString(CN_EQUALS) + strCN ),
                                             &bstr );
        BREAK_ON_FAILED_HRESULT(hr);


        // set the dn without the leaf node.
        hr = m_pPathname->Set(
                CComBSTR(
                    CString( GetBasePathsInfo()->GetProviderAndServerName())
                             + GetBasePathsInfo()->GetSchemaNamingContext() ),
                ADS_SETTYPE_FULL );
        BREAK_ON_FAILED_HRESULT(hr);
        

        // add new leaf element
        hr = m_pPathname->AddLeafElement( bstr );
        BREAK_ON_FAILED_HRESULT(hr);
        
        // the result should be property escaped
        hr = m_pPathname->put_EscapedMode( ADS_ESCAPEDMODE_DEFAULT );
        BREAK_ON_FAILED_HRESULT(hr);

        // the full thing is needed
        hr = m_pPathname->SetDisplayType( ADS_DISPLAY_FULL );
        BREAK_ON_FAILED_HRESULT(hr);

        // get the final result.
        hr = m_pPathname->Retrieve( formatType, &bstr );
        BREAK_ON_FAILED_HRESULT(hr);

        
        strPath = bstr;

    } while( FALSE );

    ASSERT( SUCCEEDED(hr) );

    return hr;
}


HRESULT ComponentData::GetLeafObjectFromDN( const BSTR  bstrDN,
                                            CString   & strCN )
{
    HRESULT hr = E_FAIL;
    
    do
    {
        if( !m_pPathname )
            break;
        
        // set the full DN.
        hr = m_pPathname->Set( bstrDN, ADS_SETTYPE_DN );
        BREAK_ON_FAILED_HRESULT(hr);
        
        // the result should not be escaped
        hr = m_pPathname->put_EscapedMode( ADS_ESCAPEDMODE_OFF_EX );
        BREAK_ON_FAILED_HRESULT(hr);
        
        // just the value please
        hr = m_pPathname->SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
        BREAK_ON_FAILED_HRESULT(hr);

        
        CComBSTR    bstrCN;

        // extract the leaf node
        hr = m_pPathname->Retrieve( ADS_FORMAT_LEAF, &bstrCN );
        BREAK_ON_FAILED_HRESULT(hr);

        strCN = bstrCN;

    } while( FALSE );

    ASSERT( SUCCEEDED(hr) );    // this function should never fail (in theory)

    return hr;
}


//
// Determine what operations are allowed.  Optionally returns IADs * to Schema Container
//   if the path is not present, the returned value is E_FAIL
//
HRESULT ComponentData::CheckSchemaPermissions( IADs ** ppADs /* = NULL */ )
{
    HRESULT         hr      = S_OK;
    CComPtr<IADs>   ipADs;
    CString         szSchemaContainerPath;
    CStringList     strlist;

    ASSERT( !ppADs || !(*ppADs) );   // if present, must point to NULL

    do
    {
        //
        // Disable new attrib/class menu items
        //
        SetCanCreateClass( FALSE );
        SetCanCreateAttribute( FALSE );
        SetCanChangeOperationsMaster( FALSE );

        //
        // Get the schema container path.
        //
        GetBasePathsInfo()->GetSchemaPath( szSchemaContainerPath );
        if( szSchemaContainerPath.IsEmpty() )
        {
            hr = E_FAIL;
            break;
        }

        //
        // Open the schema container.
        //
        hr = ADsGetObject( (LPWSTR)(LPCWSTR)szSchemaContainerPath,
                           IID_IADs,
                           (void **)&ipADs );
        BREAK_ON_FAILED_HRESULT(hr);


        // extract the list of allowed attributes
        hr = GetStringListElement( ipADs, &g_allowedAttributesEffective, strlist );
        if( SUCCEEDED(hr) )
        {
            // search for needed attributes
            for( POSITION pos = strlist.GetHeadPosition(); pos != NULL; )
            {
                CString * pstr = &strlist.GetNext( pos );
            
                if( !pstr->CompareNoCase( g_fsmoRoleOwner ) )
                {
                    SetCanChangeOperationsMaster( TRUE );
                    break;
                }
            }
        }

        
        // extract the list of allowed classes
        hr = GetStringListElement( ipADs, &g_allowedChildClassesEffective, strlist );
        if( SUCCEEDED(hr) )
        {
            // search for needed attributes
            for( POSITION pos = strlist.GetHeadPosition(); pos != NULL; )
            {
                CString * pstr = &strlist.GetNext( pos );
            
                if( !pstr->CompareNoCase( g_AttributeFilter ) )
                {
                    SetCanCreateAttribute( TRUE );
                    if( CanCreateClass() )
                        break;
                }
                else if( !pstr->CompareNoCase( g_ClassFilter ) )
                {
                    SetCanCreateClass( TRUE );
                    if( CanCreateAttribute() )
                        break;
                }
            }
        }

    } while( FALSE );
    
    if( ppADs )
    {
        *ppADs = ipADs;
        if( *ppADs )
            (*ppADs)->AddRef();
    }

    return hr;
}


////////////////////////////////////////////////////////////////////
//
//  Error handling
//

// Set's error title & body text.  Call it with 0, 0 to remove
void ComponentData::SetError( UINT idsErrorTitle, UINT idsErrorText )
{
    if( idsErrorTitle )
        m_sErrorTitle.LoadString( idsErrorTitle );
    else
        m_sErrorTitle.Empty();

    if( idsErrorText )
        m_sErrorText.LoadString( idsErrorText );
    else
        m_sErrorText.Empty();
}


VOID ComponentData::InitializeRootTree( HSCOPEITEM hParent, Cookie * pParentCookie )
{
    //
    // This node has the two static nodes
    // for Classes and Attributes.
    //
    
    HRESULT hr               = S_OK;
    LPCWSTR lpcszMachineName = pParentCookie->QueryNonNULLMachineName();

    // Update the name of the root to contain the servername we are bound to

    if (GetBasePathsInfo()->GetServerName())
    {
       CString strDisplayName;
       strDisplayName.LoadString(IDS_SCOPE_SCHMMGMT);
       strDisplayName += L" [";
       strDisplayName += GetBasePathsInfo()->GetServerName();
       strDisplayName += L"]";

       SCOPEDATAITEM RootItem;
       ::ZeroMemory( &RootItem, sizeof(RootItem));
       RootItem.mask = SDI_STR | SDI_PARAM;
       RootItem.displayname = const_cast<PWSTR>((PCWSTR)strDisplayName);
       RootItem.ID = hParent;

       hr = m_pConsoleNameSpace->SetItem(&RootItem);
       ASSERT(SUCCEEDED(hr));
    }

    SCOPEDATAITEM ScopeItem;
    ::ZeroMemory( &ScopeItem, sizeof(ScopeItem) );
    ScopeItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_STATE | SDI_PARAM | SDI_PARENT;
    ScopeItem.displayname = MMC_CALLBACK;
    ScopeItem.relativeID = hParent;
    ScopeItem.nState = 0;
    
    LoadGlobalCookieStrings();
    
    //
    // Create new cookies for the static scope items.
    // We're doing something funky with the cookie cast.
    //
    
    Cookie* pNewCookie;
    
    pNewCookie= new Cookie( SCHMMGMT_CLASSES,
        lpcszMachineName );
    pParentCookie->m_listScopeCookieBlocks.AddHead(
        (CBaseCookieBlock*)pNewCookie );
    ScopeItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pNewCookie);
    ScopeItem.nImage = QueryImage( *pNewCookie, FALSE );
    ScopeItem.nOpenImage = QueryImage( *pNewCookie, TRUE );
    hr = m_pConsoleNameSpace->InsertItem(&ScopeItem);
    ASSERT(SUCCEEDED(hr));
    pNewCookie->m_hScopeItem = ScopeItem.ID;

    pNewCookie = new Cookie( SCHMMGMT_ATTRIBUTES,
        lpcszMachineName );
    pParentCookie->m_listScopeCookieBlocks.AddHead(
        (CBaseCookieBlock*)pNewCookie );
    ScopeItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pNewCookie);
    ScopeItem.nImage = QueryImage( *pNewCookie, FALSE );
    ScopeItem.nOpenImage = QueryImage( *pNewCookie, TRUE );
    
    // turn of the + on the Attributes node
    ScopeItem.mask |= SDI_CHILDREN;
    ScopeItem.cChildren = 0;
    
    hr = m_pConsoleNameSpace->InsertItem(&ScopeItem);
    ASSERT(SUCCEEDED(hr));
    pNewCookie->m_hScopeItem = ScopeItem.ID;


    //
    // Force Cache load (if not done already)
    //
    g_SchemaCache.LoadCache();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\dataobj.cpp ===
// DataObj.cpp : Implementation of data object classes

#include "stdafx.h"
#include "stdutils.h"

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(dataobj.cpp)")

#include "dataobj.h"
#include "compdata.h"
#include "resource.h"

#include "stddtobj.cpp"

//
// IDataObject interface implementation.
//

HRESULT
CSchmMgmtDataObject::GetDataHere(
    FORMATETC __RPC_FAR *pFormatEtcIn,
    STGMEDIUM __RPC_FAR *pMedium
)
{
        MFC_TRY;

        const CLIPFORMAT cf=pFormatEtcIn->cfFormat;
        if (cf == m_CFNodeType)
        {
                const GUID* pguid = GetObjectTypeGUID( m_pcookie->m_objecttype );
                stream_ptr s(pMedium);
                return s.Write(pguid, sizeof(GUID));
        }
        else if (cf == m_CFSnapInCLSID)
        {
                const GUID* pguid = &CLSID_SchmMgmt;
                stream_ptr s(pMedium);
                return s.Write(pguid, sizeof(GUID));
        }
        else if (cf == m_CFNodeTypeString)
        {
                const BSTR strGUID = GetObjectTypeString( m_pcookie->m_objecttype );
                stream_ptr s(pMedium);
                return s.Write(strGUID);
        }
        else if (cf == m_CFDisplayName)
        {
                return PutDisplayName(pMedium);
        }
        else if (cf == m_CFDataObjectType)
        {
                stream_ptr s(pMedium);
                return s.Write(&m_dataobjecttype, sizeof(m_dataobjecttype));
        }
        else if (cf == m_CFMachineName)
        {
                stream_ptr s(pMedium);
                return s.Write(m_pcookie->QueryNonNULLMachineName());
        }
        else if (cf == m_CFRawCookie)
        {
                stream_ptr s(pMedium);
                // CODEWORK This cast ensures that the data format is
                // always a CCookie*, even for derived subclasses
                CCookie* pcookie = (CCookie*)m_pcookie;
                return s.Write(reinterpret_cast<PBYTE>(&pcookie), sizeof(m_pcookie));
        }

        return DV_E_FORMATETC;

        MFC_CATCH;
}

HRESULT CSchmMgmtDataObject::Initialize( Cookie* pcookie, DATA_OBJECT_TYPES type )
{
        if (NULL == pcookie || NULL != m_pcookie)
        {
                ASSERT(FALSE);
                return E_UNEXPECTED;
        }
        m_dataobjecttype = type;
        m_pcookie = pcookie;
        ((CRefcountedObject*)m_pcookie)->AddRef();
        return S_OK;
}


CSchmMgmtDataObject::~CSchmMgmtDataObject()
{
        if (NULL != m_pcookie)
        {
                ((CRefcountedObject*)m_pcookie)->Release();
        }
        else
        {
                ASSERT(FALSE);
        }
}


HRESULT CSchmMgmtDataObject::PutDisplayName(STGMEDIUM* pMedium)
        // Writes the "friendly name" to the provided storage medium
        // Returns the result of the write operation
{
        CString strDisplayName;
        LPCTSTR pszTarget = m_pcookie->QueryTargetServer();
        if ( NULL != pszTarget )
        {
                if ( pszTarget[0] == _T('\\') && pszTarget[1] == _T('\\') )
                        pszTarget += 2;
                strDisplayName = pszTarget;
        }
        else
        {
                VERIFY( strDisplayName.LoadString(IDS_SCOPE_SCHMMGMT) );
        }
        stream_ptr s(pMedium);
        return s.Write(strDisplayName);
}

// Register the clipboard formats
CLIPFORMAT CSchmMgmtDataObject::m_CFDisplayName =
        (CLIPFORMAT)RegisterClipboardFormat(CCF_DISPLAY_NAME);
CLIPFORMAT CSchmMgmtDataObject::m_CFMachineName =
        (CLIPFORMAT)RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");
CLIPFORMAT CDataObject::m_CFRawCookie =
        (CLIPFORMAT)RegisterClipboardFormat(L"MYCOMPUT_SNAPIN_RAW_COOKIE");


STDMETHODIMP ComponentData::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
   MFC_TRY;

   Cookie* pUseThisCookie =
      (Cookie*) ActiveBaseCookie(reinterpret_cast<CCookie*>(cookie));

   CComObject<CSchmMgmtDataObject>* pDataObject = NULL;
   HRESULT hRes = CComObject<CSchmMgmtDataObject>::CreateInstance(&pDataObject);
   if ( FAILED(hRes) )
          return hRes;

   HRESULT hr = pDataObject->Initialize( pUseThisCookie, type );
   if ( SUCCEEDED(hr) )
   {
      hr = pDataObject->QueryInterface(IID_IDataObject,
                                       reinterpret_cast<void**>(ppDataObject));
   }

   if ( FAILED(hr) )
   {
      delete pDataObject;
      return hr;
   }

   return hr;

   MFC_CATCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\dataobj.h ===
//
// DataObj.h : Declaration of the data object classes
// Cory West
//

#ifndef __DATAOBJ_H_INCLUDED__
#define __DATAOBJ_H_INCLUDED__

#include "cookie.h"     // Cookie
#include "stddtobj.h"   // class DataObject

class CSchmMgmtDataObject : public CDataObject
{

    DECLARE_NOT_AGGREGATABLE(CSchmMgmtDataObject)

public:

#if DBG==1

    ULONG InternalAddRef() {
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease() {
        return CComObjectRoot::InternalRelease();
    }
    int dbg_InstID;

#endif

    CSchmMgmtDataObject()
        : m_pcookie( NULL ),
          m_objecttype( SCHMMGMT_SCHMMGMT ),
          m_dataobjecttype( CCT_UNINITIALIZED )
    { ; }

    ~CSchmMgmtDataObject();

    virtual HRESULT Initialize( Cookie* pcookie, DATA_OBJECT_TYPES type );

    HRESULT STDMETHODCALLTYPE GetDataHere(
        FORMATETC __RPC_FAR *pFormatEtcIn,
        STGMEDIUM __RPC_FAR *pMedium
    );

    HRESULT PutDisplayName( STGMEDIUM* pMedium );
    HRESULT PutServiceName( STGMEDIUM* pMedium );

protected:

    //
    // The CCookieBlock is AddRef'ed for the life of the DataObject.
    //

    Cookie* m_pcookie;
    SchmMgmtObjectType m_objecttype;
    DATA_OBJECT_TYPES m_dataobjecttype;

public:

    static CLIPFORMAT m_CFDisplayName;
    static CLIPFORMAT m_CFMachineName;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\mybasepathsinfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      MyBasePathsInfo.h
//
//  Contents:  Thin wrapper around dsadminlib CDSBasePathsInfo class
//             to deal with memory management of strings
//
//  History:   04/02/2001 jeffjon    Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"


void MyBasePathsInfo::ComposeADsIPath(CString& szPath, IN LPCWSTR lpszNamingContext)
{
  int result = 0;
  szPath.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::ComposeADsIPath(&pszPath, lpszNamingContext);
  
  if (pszPath && result)
  {
     szPath = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetSchemaPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetSchemaPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetConfigPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetConfigPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetDefaultRootPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetDefaultRootPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetRootDSEPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetRootDSEPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetAbstractSchemaPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetAbstractSchemaPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetPartitionsPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetPartitionsPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetSchemaObjectPath(IN LPCWSTR lpszObjClass, CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetSchemaObjectPath(lpszObjClass, &pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetInfrastructureObjectPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetInfrastructureObjectPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

HRESULT GetADSIServerName(CString& szServer, IN IUnknown* pUnk)
{
  PWSTR pszServer = 0;
  HRESULT hr = GetADSIServerName(&pszServer, pUnk);
  if (SUCCEEDED(hr) && pszServer)
  {
    szServer = pszServer;

    delete[] pszServer;
    pszServer = 0;
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\mybasepathsinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      MyBasePathsInfo.h
//
//  Contents:  Thin wrapper around dsadminlib CDSBasePathsInfo class
//             to deal with memory management of strings
//
//  History:   04/02/2001 jeffjon    Created
//
//--------------------------------------------------------------------------

class MyBasePathsInfo : public CDSBasePathsInfo
{
public:
  // Functions from the base class that are wrapped to take references to 
  // CStrings

  void ComposeADsIPath(CString& szPath, IN LPCWSTR lpszNamingContext);

  void GetSchemaPath(CString& s);
  void GetConfigPath(CString& s);
  void GetDefaultRootPath(CString& s);
  void GetRootDSEPath(CString& s);
  void GetAbstractSchemaPath(CString& s);
  void GetPartitionsPath(CString& s);
  void GetSchemaObjectPath(IN LPCWSTR lpszObjClass, CString& s);
  void GetInfrastructureObjectPath(CString& s);
};

HRESULT GetADSIServerName(CString& szServer, IN IUnknown* pUnk);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\makefile.inc ===
!include ..\..\makefile.inc

$(O)\SCHMMGMT.res: resource.h schmmgmt.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\ncattr.hpp ===
#ifndef NCATTR_HPP_INCLUDED
#define NCATTR_HPP_INCLUDED



class NewClassAttributesPage : public CPropertyPage
{
   public:

   NewClassAttributesPage(
      CreateClassWizardInfo* wi,
      ComponentData*         cd);

//   ~NewClassAttributesPage();

   protected:

   virtual
   void
   DoDataExchange(CDataExchange *pDX);

   virtual
   BOOL
   OnInitDialog();


   static const DWORD help_map[];

   BOOL OnHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, FALSE ); };
   BOOL OnContextHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, TRUE ); };


   virtual
   BOOL
   OnKillActive();

   virtual
   void
   OnOK();

   virtual
   BOOL
   OnSetActive();

   virtual
   BOOL
   OnWizardFinish();

   DECLARE_MESSAGE_MAP()

   afx_msg void OnButtonOptionalAdd();
   afx_msg void OnButtonOptionalRemove();
   afx_msg void OnButtonMandatoryAdd();
   afx_msg void OnButtonMandatoryRemove();
   afx_msg void OnMandatorySelChange();
   afx_msg void OnOptionalSelChange();

   private:

   bool
   saveAndValidate();

   CreateClassWizardInfo& wiz_info;            
   ComponentData&         parent_ComponentData;
   CSchemaObjectsListBox  listbox_mandatory;   
   CSchemaObjectsListBox  listbox_optional;    
};



#endif   // NCATTR_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\helpids.h ===
#define IDH_ATTRIB_DEACTIVATE                100001016
#define IDH_ATTRIB_GENERAL_DESCRIPTION_EDIT  100001002
#define IDH_ATTRIB_GENERAL_DISPLAYABLE_CHECK 100001015
#define IDH_ATTRIB_GENERAL_INDEX_CHECK       100001017
#define IDH_ATTRIB_GENERAL_CONTAINERIZED_INDEX_CHECK 100001019
#define IDH_ATTRIB_GENERAL_LDN               100001004
#define IDH_ATTRIB_GENERAL_MAX_EDIT          100001013
#define IDH_ATTRIB_GENERAL_MIN_EDIT          100001011
#define IDH_ATTRIB_GENERAL_OID_EDIT          100001006
#define IDH_ATTRIB_GENERAL_SYNTAX_EDIT       100001009
#define IDH_CATEGORY_CHANGE                  100001311
#define IDH_CATEGORY_EDIT                    100001310
#define IDH_CHANGE_FSMO2                     100001707
#define IDH_CLASS_DEACTIVATE                 100001313
#define IDH_CLASS_GENERAL_CATEGORY_COMBO     100001308
#define IDH_CLASS_GENERAL_DESCRIPTION_EDIT   100001302
#define IDH_CLASS_GENERAL_DISPLAYABLE_CHECK  100001312
#define IDH_CLASS_GENERAL_LDN                100001304
#define IDH_CLASS_GENERAL_OID_EDIT           100001306
#define IDH_CLASS_MMB_MANDATORY_ADD          100001103
#define IDH_CLASS_MMB_MANDATORY_ATTRIBUTES   100001102
#define IDH_CLASS_MMB_MANDATORY_REMOVE       100001104
#define IDH_CLASS_MMB_OPTIONAL_ADD           100001108
#define IDH_CLASS_MMB_OPTIONAL_ATTRIBUTES    100001107
#define IDH_CLASS_MMB_OPTIONAL_REMOVE        100001109
#define IDH_CLASS_REL_AUX_ADD                100001405
#define IDH_CLASS_REL_AUX_CLASSES            100001404
#define IDH_CLASS_REL_AUX_REMOVE             100001406
#define IDH_CLASS_REL_PARENT_EDIT            100001402
#define IDH_CLASS_REL_SUPER_ADD              100001410
#define IDH_CLASS_REL_SUPER_CLASSES          100001409
#define IDH_CLASS_REL_SUPER_REMOVE           100001411
#define IDH_CREATE_ATTRIB_CN                 100001503
#define IDH_CREATE_ATTRIB_LDN                100001505
#define IDH_CREATE_ATTRIB_MAX                100001513
#define IDH_CREATE_ATTRIB_MIN                100001511
#define IDH_CREATE_ATTRIB_OID                100001506
#define IDH_CREATE_ATTRIB_SYNTAX             100001509
#define IDH_CREATE_ATTRIB_VALUED             100001514
#define IDH_CREATE_CLASS_CN                  100001603
#define IDH_CREATE_CLASS_LDN                 100001605
#define IDH_CREATE_CLASS_OID                 100001606
#define IDH_CREATE_CLASS_PARENT              100001609
#define IDH_CREATE_CLASS_TYPE                100001611
#define IDH_EDIT_CURRENT_DC2                 100001201
#define IDH_EDIT_CURRENT_DC3                 100001701
#define IDH_EDIT_CURRENT_FSMO_DC2            100001706
#define IDH_EDIT_DC                          100001205
#define IDH_RADIO_ANY                        100001203
#define IDH_RADIO_SPECIFY                    100001204
#define IDH_REPLICATED                       100001018
#define IDH_SCHEMA_LIST                      100001801
#define IDH_SERVER_MODIFY_CHECK              100001708
#define	IDH_ATTRIB_GENERAL_ANR_CHECK		 100001805
#define	IDH_ATTRIB_GENERAL_CPYATTR_CHECK	 100001810
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\dbg.h ===
#include "StdDbg.h"

#if DBG==1
    DECLARE_DEBUG(SchmMgmtSnapin)
    #define DBG_COMP    SchmMgmtSnapinInfoLevel
#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\newattr.cpp ===
#include "stdafx.h"
#include "compdata.h"
#include "newattr.hpp"



// The default syntax for new attributes
const UINT  uDefaultSyntax = 0;



//
// The create new attribute dialog box.
//

CreateAttributeDialog::CreateAttributeDialog(
    ComponentData *pScope,
    LPDATAOBJECT lpDataObject
) :
    CDialog(IDD_CREATE_ATTRIBUTE, NULL),
    fDialogLoaded( FALSE ),
    MultiValued( FALSE ),
    pScopeControl( pScope ),
    lpScopeDataObj( lpDataObject ),
	  SyntaxOrdinal( uDefaultSyntax ),
    m_editOID( CParsedEdit::EDIT_TYPE_OID ),
    m_editLowerRange( CParsedEdit::EDIT_TYPE_UINT32 ),
    m_editUpperRange( CParsedEdit::EDIT_TYPE_UINT32 )


{
	ASSERT( uDefaultSyntax < SCHEMA_SYNTAX_UNKNOWN );
}



CreateAttributeDialog::~CreateAttributeDialog()
{ ; }


BOOL
CreateAttributeDialog::OnInitDialog()
{
    CComboBox * pwndSyntaxCombo	= NULL;
    
    CDialog::OnInitDialog();
    
    //
    // Set Limits on Range controls
    //
    
    ASSERT( GetDlgItem(IDC_CREATE_ATTRIB_MIN) );
    ASSERT( GetDlgItem(IDC_CREATE_ATTRIB_MAX) );
    
    m_editOID.SubclassEdit( IDC_CREATE_ATTRIB_OID, this, cchMaxOID );
    m_editLowerRange.SubclassEdit(IDC_CREATE_ATTRIB_MIN, this, cchMinMaxRange);
    m_editUpperRange.SubclassEdit(IDC_CREATE_ATTRIB_MAX, this, cchMinMaxRange);
    
    //
    // Turn off IME support on the min/max edit boxes
    //
    ImmAssociateContext(m_editLowerRange.GetSafeHwnd(), NULL);
    ImmAssociateContext(m_editUpperRange.GetSafeHwnd(), NULL);

    //
    // Load the syntax combo box.
    //
    
    ASSERT( GetDlgItem( IDC_CREATE_ATTRIB_SYNTAX ) );
    pwndSyntaxCombo = static_cast<CComboBox *>(GetDlgItem(IDC_CREATE_ATTRIB_SYNTAX));
    VERIFY( pwndSyntaxCombo );
    
    pwndSyntaxCombo->ResetContent() ;
    
    for ( UINT iSyntaxOrdinal = 0 ;
    	  iSyntaxOrdinal < SCHEMA_SYNTAX_UNKNOWN ;
          iSyntaxOrdinal++ )
    {
        pwndSyntaxCombo->AddString( g_Syntax[iSyntaxOrdinal].m_strSyntaxName );
    }

    pwndSyntaxCombo->SetCurSel( SyntaxOrdinal );
    OnSelchangeSyntax();

    return TRUE;
}


void
CreateAttributeDialog::DoDataExchange(
    CDataExchange *pDX
) {

    CDialog::DoDataExchange( pDX );

    DDX_Text( pDX, IDC_CREATE_ATTRIB_CN, CommonName );
    DDV_MaxChars( pDX, CommonName, 64 );

    DDX_Text( pDX, IDC_CREATE_ATTRIB_LDN, LdapDisplayName );
    DDV_MaxChars( pDX, LdapDisplayName, 256 );

    DDX_Text( pDX, IDC_CREATE_ATTRIB_OID, OID );

    DDX_Text( pDX, IDC_DESCRIPTION_EDIT, Description );

    DDX_Check( pDX, IDC_CREATE_ATTRIB_VALUED, MultiValued );

    ASSERT( !pDX->m_bSaveAndValidate || SyntaxOrdinal == (UINT)
			static_cast<CComboBox *>(GetDlgItem(IDC_CREATE_ATTRIB_SYNTAX))->GetCurSel() );

    DDXV_VerifyAttribRange( pDX, g_Syntax[ SyntaxOrdinal ].m_fIsSigned,
							IDC_CREATE_ATTRIB_MIN, Min,
							IDC_CREATE_ATTRIB_MAX, Max );
    return;

}

inline void RemoveAttributeInfoLine( ADS_ATTR_INFO * attrInfo, DWORD dwLine, DWORD & dwArraySize )
{
	dwArraySize--;

	for( ; dwLine < dwArraySize; dwLine++ )
		attrInfo[ dwLine ] = attrInfo[ dwLine + 1 ];
}


void
CreateAttributeDialog::OnOK(
    void
) {

	HRESULT				hr					= S_OK;
    SchemaObject *		pNewSchemaObject	= NULL;
	DWORD				dwValue				= 0;

	IDirectoryObject *	pDirObject			= NULL;
	IDispatch *			pDisp				= NULL;
    
	CString				strSchemaPath;
    CString				strDecoratedName;

	ADSVALUE			adsvClassValue,
						adsvLDAPDisplayName,
            adsvDescription,
						adsvAttributeID,
						adsvAttributeSyntax,
						adsvOmSyntax,
						adsvOmObjectClass,
						adsvIsSingleValued,
						adsvLowerRange,
						adsvUpperRange;


    //
    // Update parameters from the Dialog
    //

    if ( !UpdateData(TRUE) ) {
        return;
    }

    CWaitCursor wait;

    //
    // Validate the parameters.
    //

    //
    // Check for valid OID
    //
    int errorTypeStrID = 0;
    if (!OIDHasValidFormat(OID, errorTypeStrID))
    {
      CString errorType;
      CString text;

      VERIFY (errorType.LoadString(errorTypeStrID));
      text.FormatMessage(IDS_OID_FORMAT_INVALID, OID, errorType);

      DoErrMsgBox( ::GetActiveWindow(), TRUE, text );
      return;
    }

    if ( ( CommonName.IsEmpty() )       ||
         ( SyntaxOrdinal >= SCHEMA_SYNTAX_UNKNOWN ) ) {

        DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_CREATE_INVALID_PARAM );
        return;
    }

    //
    // Allocate a new schema cache object for this object.
    //

    pNewSchemaObject = new SchemaObject();

    if ( !pNewSchemaObject ) {
       DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_MEM );
       return;
    }

    pNewSchemaObject->schemaObjectType	= SCHMMGMT_ATTRIBUTE;
    pNewSchemaObject->commonName		= CommonName;
    pNewSchemaObject->description = Description;

    //
    // Get the schema container.
    //

    pScopeControl->GetBasePathsInfo()->GetSchemaPath(strSchemaPath);

    hr = ADsGetObject(
             (LPWSTR)(LPCWSTR)strSchemaPath,
             IID_IDirectoryObject,
             (void **)&pDirObject );

    if ( FAILED(hr) )
	{
		if ( hr == ADS_EXTENDED_ERROR )
			DoExtErrMsgBox();
		else
			DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_SCHEMA_PATH );
    }
	else
	{
		// During the attrib creation, some of the lines may need to be skipped.  Use RemoveAttributeInfoLine()
		// for this.  Removal should be done top to bottom of this array, because all the consts are relative to
		// the end of the array.
		ADS_ATTR_INFO  attrInfo[] =
		{
			{g_ObjectClass,			ADS_ATTR_UPDATE,	ADSTYPE_CASE_IGNORE_STRING, &adsvClassValue,		1},
			{g_GlobalAttributeID,	ADS_ATTR_UPDATE,	ADSTYPE_CASE_IGNORE_STRING,	&adsvAttributeID,		1},
			{g_IsSingleValued,		ADS_ATTR_UPDATE,	ADSTYPE_BOOLEAN,			&adsvIsSingleValued,	1},
			{g_AttributeSyntax,		ADS_ATTR_UPDATE,	ADSTYPE_CASE_IGNORE_STRING,	&adsvAttributeSyntax,	1},
			{g_omSyntax,			ADS_ATTR_UPDATE,	ADSTYPE_INTEGER,			&adsvOmSyntax,			1},

				// make sure the following five attribute's indexes match with constants!!!
      {g_Description,     ADS_ATTR_UPDATE,  ADSTYPE_CASE_IGNORE_STRING, &adsvDescription, 1},
			{g_DisplayName,			ADS_ATTR_UPDATE,	ADSTYPE_CASE_IGNORE_STRING,	&adsvLDAPDisplayName,	1},
			{g_omObjectClass,		ADS_ATTR_UPDATE,	ADSTYPE_OCTET_STRING,		&adsvOmObjectClass,		1},
			{g_RangeLower,			ADS_ATTR_UPDATE,	ADSTYPE_INTEGER,			&adsvLowerRange,		1},
			{g_RangeUpper,			ADS_ATTR_UPDATE,	ADSTYPE_INTEGER,			&adsvUpperRange,		1},
		};
		
		DWORD dwAttrs				= sizeof(attrInfo) / sizeof(attrInfo[0]);

		// relative constants.  Describe the location of the attributes relative to the end of the list
    const DWORD dwAttrsDescription = 4; // fifth to last in the array
		const DWORD dwAttrsLdapName     = 3;	// fourth to last in the array
		const DWORD dwAttrsObjectClass	= 2;	// third to last in the array
		const DWORD dwAttrsRangeLower	= 1;	// second to last in the array
		const DWORD dwAttrsRangeUpper	= 0;	// last in the array

	
		// Object's Class -- "attributeSchema"
		adsvClassValue.dwType					= ADSTYPE_CASE_IGNORE_STRING;
		adsvClassValue.CaseIgnoreString			= const_cast<LPWSTR>( g_AttributeFilter );

		// OID
		adsvAttributeID.dwType					= ADSTYPE_CASE_IGNORE_STRING;
		adsvAttributeID.CaseIgnoreString		= const_cast<LPWSTR>( (LPCWSTR) OID );
		pNewSchemaObject->oid					= OID;

		// Is this a single valued attribute?
		adsvIsSingleValued.dwType				= ADSTYPE_BOOLEAN;
		adsvIsSingleValued.Boolean				= !MultiValued;
		
		// Attribute Syntax (3 parts)
		ASSERT( g_Syntax[SyntaxOrdinal].m_pszAttributeSyntax );
		adsvAttributeSyntax.dwType				= ADSTYPE_CASE_IGNORE_STRING;
		adsvAttributeSyntax.CaseIgnoreString	= const_cast<LPWSTR>( g_Syntax[SyntaxOrdinal].m_pszAttributeSyntax );

		ASSERT( g_Syntax[SyntaxOrdinal].m_nOmSyntax );
		adsvOmSyntax.dwType						= ADSTYPE_INTEGER;
		adsvOmSyntax.Integer					= g_Syntax[SyntaxOrdinal].m_nOmSyntax;

    //
    // Skip the Description if not needed
    //
    if (Description.IsEmpty())
    {
      RemoveAttributeInfoLine(attrInfo, dwAttrs - dwAttrsDescription - 1, dwAttrs);
    }
    else
    {
      adsvDescription.dwType = ADSTYPE_CASE_IGNORE_STRING;
      adsvDescription.CaseIgnoreString = const_cast<LPWSTR>( (LPCWSTR) Description );
    }

    //		skip Ldap Name if not needed
		if( LdapDisplayName.IsEmpty() )
		{
			RemoveAttributeInfoLine( attrInfo, dwAttrs - dwAttrsLdapName - 1, dwAttrs );
		}
		else
		{
            adsvLDAPDisplayName.dwType				= ADSTYPE_CASE_IGNORE_STRING;
            adsvLDAPDisplayName.CaseIgnoreString	= const_cast<LPWSTR>( (LPCWSTR) LdapDisplayName );
            pNewSchemaObject->ldapDisplayName		= LdapDisplayName;
		}
        
        
        //		skip OM-Object-Class if not needed
		if( 0 == g_Syntax[SyntaxOrdinal].m_octstrOmObjectClass.dwLength )
		{
			RemoveAttributeInfoLine( attrInfo, dwAttrs - dwAttrsObjectClass - 1, dwAttrs );
		}
		else
		{
			adsvOmObjectClass.dwType			= ADSTYPE_OCTET_STRING;
			adsvOmObjectClass.OctetString		= g_Syntax[SyntaxOrdinal].m_octstrOmObjectClass;
		}

		pNewSchemaObject->SyntaxOrdinal			= SyntaxOrdinal;
		
		hr = S_OK;

		// Lower Range
		if( Min.IsEmpty() )
		{
			RemoveAttributeInfoLine( attrInfo, dwAttrs - dwAttrsRangeLower - 1, dwAttrs );
		}
		else
		{
			// if the function call fails, no attrib creation is performed
			hr						= GetSafeSignedDWORDFromString( this, dwValue, Min,
										g_Syntax[SyntaxOrdinal].m_fIsSigned, GETSAFEINT_ALLOW_CANCEL );

			adsvLowerRange.dwType	= ADSTYPE_INTEGER;
			adsvLowerRange.Integer	= dwValue;
		}
		
		// Upper Range
		if( SUCCEEDED(hr) )
		{
			if( Max.IsEmpty() )
			{
				RemoveAttributeInfoLine( attrInfo, dwAttrs - dwAttrsRangeUpper - 1, dwAttrs );
			}
			else
			{
				// if function call fails, no attrib creation is performed
				hr						= GetSafeSignedDWORDFromString( this, dwValue, Max,
											g_Syntax[SyntaxOrdinal].m_fIsSigned, GETSAFEINT_ALLOW_CANCEL );

				adsvUpperRange.dwType	= ADSTYPE_INTEGER;
				adsvUpperRange.Integer	= dwValue;
			}
		}
		

		//
		// Create the schema object.
		//

		if( SUCCEEDED(hr) )
		{
            pScopeControl->GetSchemaObjectPath( CommonName, strDecoratedName, ADS_FORMAT_LEAF );

			hr = pDirObject->CreateDSObject( const_cast<LPWSTR>( (LPCWSTR) strDecoratedName ),
												attrInfo, dwAttrs, &pDisp );

			if ( SUCCEEDED( hr ) )
      {
        // if there was no ldap name, and it worked, cn was used as ldap name
        if( LdapDisplayName.IsEmpty() )
        {
          ASSERT( pDisp );

          CComVariant                 value;
          CComQIPtr<IADs, &IID_IADs>  iads(pDisp);

          if( !iads )
          {
            ASSERT( FALSE );
          }
          else
          {
            hr = iads->Get(CComBSTR(g_DisplayName), &value);
            ASSERT( SUCCEEDED(hr) );   // should be there!!!
        
            if( SUCCEEDED(hr) )
            {
              ASSERT( value.vt == VT_BSTR );
              pNewSchemaObject->ldapDisplayName = value.bstrVal;
            }
          }
        }

				//
				// Insert this object into the display cache.
				//

				hr = pScopeControl->g_SchemaCache.InsertSchemaObject( pNewSchemaObject );
				ASSERT( SUCCEEDED( hr ) );

				hr = pScopeControl->g_SchemaCache.InsertSortedSchemaObject( pNewSchemaObject );
				ASSERT( SUCCEEDED( hr ) );

				hr = pScopeControl->m_pConsole->UpdateAllViews( lpScopeDataObj,
																SCHMMGMT_ATTRIBUTES,
																SCHMMGMT_UPDATEVIEW_REFRESH );
				ASSERT( SUCCEEDED( hr ) );

				EndDialog( IDOK );
			}
			else	// attribute creation failed
			{
				if ( hr == ADS_EXTENDED_ERROR )
        {
          DoExtErrMsgBox();
        }
				else
        {
           CString error_text;
           CString name;

           HRESULT last_ads_hr = GetLastADsError(hr, error_text, name);
           if (HRESULT_CODE(last_ads_hr) == ERROR_DS_INVALID_LDAP_DISPLAY_NAME)
           {
             error_text.LoadString(IDS_LDAPDISPLAYNAME_FORMAT_ERROR);
           }
           else
           {
              error_text = GetErrorMessage(hr,TRUE);
           }

 					 DoErrMsgBox( ::GetActiveWindow(), TRUE, error_text );
        }
			}

			if( pDisp )
				pDisp->Release();
		}
	}
	
	if( pDirObject )
		pDirObject->Release();
}


BEGIN_MESSAGE_MAP( CreateAttributeDialog, CDialog )
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
	ON_CBN_SELCHANGE(IDC_CREATE_ATTRIB_SYNTAX, OnSelchangeSyntax)
END_MESSAGE_MAP()


const DWORD CreateAttributeDialog::help_map[] =
{
    IDI_ATTRIBUTE,                      NO_HELP,
    IDC_CREATE_ATTRIBUTE_PROMPT_STATIC, NO_HELP,
    IDC_CREATE_ATTRIB_CN,               IDH_CREATE_ATTRIB_CN,
    IDC_CREATE_ATTRIB_LDN,              IDH_CREATE_ATTRIB_LDN,
    IDC_CREATE_ATTRIB_OID,              IDH_CREATE_ATTRIB_OID,
    IDC_DESCRIPTION_EDIT,               IDH_ATTRIB_GENERAL_DESCRIPTION_EDIT,
    IDC_CREATE_ATTRIB_SYNTAX,           IDH_CREATE_ATTRIB_SYNTAX,
    IDC_CREATE_ATTRIB_MIN,              IDH_CREATE_ATTRIB_MIN,
    IDC_CREATE_ATTRIB_MAX,              IDH_CREATE_ATTRIB_MAX,
    IDC_CREATE_ATTRIB_VALUED,           IDH_CREATE_ATTRIB_VALUED,
    0,0
};


void CreateAttributeDialog::OnSelchangeSyntax() 
{
	DWORD		dw				= 0;		// temporary variable
	BOOL		fIsSigned		= FALSE;
	CComboBox * pwndSyntaxCombo	= NULL;
	UINT		nOldSyntax		= SyntaxOrdinal;
	HRESULT		hr				= S_OK;

	ASSERT( GetDlgItem( IDC_CREATE_ATTRIB_SYNTAX ) );
  pwndSyntaxCombo = static_cast<CComboBox *>(GetDlgItem(IDC_CREATE_ATTRIB_SYNTAX));
  VERIFY( pwndSyntaxCombo );

	ASSERT( CB_ERR != pwndSyntaxCombo->GetCurSel() );

	SyntaxOrdinal = (UINT) pwndSyntaxCombo->GetCurSel();
	if( SyntaxOrdinal >= SCHEMA_SYNTAX_UNKNOWN )
	{
		ASSERT( FALSE );
		pwndSyntaxCombo->SetCurSel( SyntaxOrdinal = uDefaultSyntax );
	}

	fIsSigned	= g_Syntax[ SyntaxOrdinal ].m_fIsSigned;

	if( GetDlgItemText( IDC_CREATE_ATTRIB_MIN, Min ) )
	{
		hr = GetSafeSignedDWORDFromString( this, dw, Min, fIsSigned, GETSAFEINT_ALLOW_CANCEL ) ;
		if( S_VALUE_MODIFIED == hr )
			SetDlgItemText( IDC_CREATE_ATTRIB_MIN, Min );
	}

	if( SUCCEEDED( hr ) && GetDlgItemText( IDC_CREATE_ATTRIB_MAX, Max ) )
	{
		hr = GetSafeSignedDWORDFromString( this, dw, Max, fIsSigned, GETSAFEINT_ALLOW_CANCEL );
		if( S_VALUE_MODIFIED == hr )
			SetDlgItemText( IDC_CREATE_ATTRIB_MAX, Max );
	}

	if( SUCCEEDED( hr ) )
	{
		m_editLowerRange.SetSigned( fIsSigned );
		m_editUpperRange.SetSigned( fIsSigned );
	}
	else
	{
		SyntaxOrdinal	= nOldSyntax;
		pwndSyntaxCombo->SetCurSel( SyntaxOrdinal );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\ncattr.cpp ===
#include "stdafx.h"
#include "compdata.h"
#include "wizinfo.hpp"
#include "ncattr.hpp"
#include "select.h"



//
// defaultObjectCategory of the classes derived from the following should be set
// to defaultObjectCategory of the parent class.
//
// the first column contains class ldap names,
// the second contains their corresponding OIDs (in case the user specifies them)

const TCHAR * rgszSpecialClassesLdapNames[] =   {
                USER_CLASS_NAME,    
                GROUP_CLASS_NAME,   
                COMPUTER_CLASS_NAME,
                PRINTER_CLASS_NAME, 
                TEXT("volume"),     
                TEXT("contact"),    
                NULL
                                                };

// must match rgszSpecialClassesLdapNames[].
const TCHAR * rgszSpecialClassesOIDs[] =        {
                TEXT("1.2.840.113556.1.5.9"),  // USER_CLASS_NAME
                TEXT("1.2.840.113556.1.5.8"),  // GROUP_CLASS_NAME
                TEXT("1.2.840.113556.1.3.30"), // COMPUTER_CLASS_NAME
                TEXT("1.2.840.113556.1.5.23"), // PRINTER_CLASS_NAME
                TEXT("1.2.840.113556.1.5.36"), // TEXT("volume")
                TEXT("1.2.840.113556.1.5.15"), // TEXT("contact")
                NULL
                                                };


const DWORD NewClassAttributesPage::help_map[] =
{
    IDC_MANDATORY_LIST,     IDH_CLASS_MMB_MANDATORY_ATTRIBUTES,
    IDC_MANDATORY_ADD,      IDH_CLASS_MMB_MANDATORY_ADD,
    IDC_MANDATORY_REMOVE,   IDH_CLASS_MMB_MANDATORY_REMOVE,

    IDC_OPTIONAL_LIST,      IDH_CLASS_MMB_OPTIONAL_ATTRIBUTES,
    IDC_OPTIONAL_ADD,       IDH_CLASS_MMB_OPTIONAL_ADD,
    IDC_OPTIONAL_REMOVE,    IDH_CLASS_MMB_OPTIONAL_REMOVE,

    0,                      0
};


BEGIN_MESSAGE_MAP(NewClassAttributesPage, CPropertyPage)
   ON_BN_CLICKED(IDC_OPTIONAL_ADD,     OnButtonOptionalAdd)
   ON_BN_CLICKED(IDC_OPTIONAL_REMOVE,  OnButtonOptionalRemove)
   ON_BN_CLICKED(IDC_MANDATORY_ADD,    OnButtonMandatoryAdd)
   ON_BN_CLICKED(IDC_MANDATORY_REMOVE, OnButtonMandatoryRemove)
   ON_LBN_SELCHANGE(IDC_MANDATORY_LIST,OnMandatorySelChange)            
   ON_LBN_SELCHANGE(IDC_OPTIONAL_LIST, OnOptionalSelChange)            
   ON_MESSAGE(WM_HELP,                 OnHelp)                      
   ON_MESSAGE(WM_CONTEXTMENU,          OnContextHelp)
END_MESSAGE_MAP()



NewClassAttributesPage::NewClassAttributesPage(
   CreateClassWizardInfo* wi,
   ComponentData*         cd)
   :
   CPropertyPage(IDD_CREATE_CLASS_ATTRIBUTES),
   wiz_info(*wi),
   parent_ComponentData(*cd)
{
}


BOOL
NewClassAttributesPage::OnInitDialog() 
{
    // This calls must be done before DDX binding
    listbox_mandatory.InitType( &parent_ComponentData,
                                SELECT_ATTRIBUTES,
                                IDC_MANDATORY_REMOVE
                              );

    listbox_optional.InitType(  &parent_ComponentData,
                                SELECT_ATTRIBUTES,
                                IDC_OPTIONAL_REMOVE
                              );
 
    CPropertyPage::OnInitDialog();

    return FALSE;   // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}




void
NewClassAttributesPage::OnOK()
{
   CPropertyPage::OnOK();
}



BOOL
NewClassAttributesPage::OnKillActive()
{
   if (saveAndValidate())
   {
      // allow loss of focus
      return TRUE;
   }

   return FALSE;
}



bool
NewClassAttributesPage::saveAndValidate()
{
   // save settings 
   wiz_info.strlistMandatory.RemoveAll();
   HRESULT hr =
      RetrieveEditItemsWithExclusions(
         listbox_mandatory,
         wiz_info.strlistMandatory,
         0);
   ASSERT(SUCCEEDED(hr));

   wiz_info.strlistOptional.RemoveAll();
   hr =
      RetrieveEditItemsWithExclusions(
         listbox_optional,
         wiz_info.strlistOptional,
         0);
   ASSERT(SUCCEEDED(hr));
   
   // nothing to validate...

   return true;
}



BOOL
NewClassAttributesPage::OnSetActive()
{
   OnMandatorySelChange();
   OnOptionalSelChange();

   CPropertySheet* parent = (CPropertySheet*) GetParent();   
   parent->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);

   return TRUE;
}



BOOL
NewClassAttributesPage::OnWizardFinish()
{
   if (!saveAndValidate())
   {
      return FALSE;
   }

   // Create the class object.  We do the create here (instead of at the point
   // where DoModal is invoked) because we want the wizard to remain if the
   // create fails for some reason.

   CWaitCursor wait;

   HRESULT       hr         = S_OK;
   SchemaObject* new_object = 0;   

   do
   {
      // bind to the schema container

      CString schema_path;
      parent_ComponentData.GetBasePathsInfo()->GetSchemaPath(schema_path);

      CComPtr<IADsContainer> schema_container;
      hr =
         ::ADsGetObject(
            
            // ADSI guys don't grok const. 
            const_cast<PWSTR>(static_cast<PCWSTR>(schema_path)),
            IID_IADsContainer,
            reinterpret_cast<void**>(&schema_container));
      BREAK_ON_FAILED_HRESULT(hr);

      // Get Relative Name
      CString strRelativeName;
      parent_ComponentData.GetSchemaObjectPath( wiz_info.cn, strRelativeName, ADS_FORMAT_LEAF );
      
      // create the class object
      CComPtr<IDispatch> dispatch;
      hr =
         schema_container->Create(
            CComBSTR(g_ClassFilter),
            CComBSTR(strRelativeName),
            &dispatch);
      BREAK_ON_FAILED_HRESULT(hr);

      CComPtr<IADs> iads;
      hr =
         dispatch->QueryInterface(IID_IADs, reinterpret_cast<void**>(&iads));
      BREAK_ON_FAILED_HRESULT(hr);

      //
      // populate the class object's properties
      //

      // OID
      {
         CComVariant value(CComBSTR(wiz_info.oid));
         hr = iads->Put(CComBSTR(g_GlobalClassID), value);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // class type
      {
         CComVariant value(wiz_info.type + 1);
         hr = iads->Put(CComBSTR(g_ObjectClassCategory), value);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // description
      if (!wiz_info.description.IsEmpty())
      {
        CComVariant value(CComBSTR(wiz_info.description));
        hr = iads->Put(CComBSTR(g_Description), value);
        BREAK_ON_FAILED_HRESULT(hr);
      }

      // default security descriptor
      {
         // authenticated users - full access
         // system - full control
         // domain admins - full control
         static const PWSTR defsd =
            L"D:(A;;RPWPCRCCDCLCLOLORCWOWDSDDTDTSW;;;DA)"
            L"(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;SY)(A;;RPLCLORC;;;AU)";
         CComVariant value(defsd);
         hr = iads->Put(CComBSTR(g_DefaultAcl), value);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // LDAP display name 
      if (!wiz_info.ldapDisplayName.IsEmpty())
      {
         CComVariant value(wiz_info.ldapDisplayName);
         hr = iads->Put(CComBSTR(g_DisplayName), value);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // parent class
      if (!wiz_info.parentClass.IsEmpty())
      {
         PCWSTR         pstr            = NULL;
         SchemaObject * parent_class    =
            parent_ComponentData.g_SchemaCache.LookupSchemaObject(
               wiz_info.parentClass,
               SCHMMGMT_CLASS);


         if( parent_class )
         {
            pstr = parent_class->oid;
         }
         else
         {
            pstr = wiz_info.parentClass;
         }
         
         CComVariant value(pstr);
         hr = iads->Put(CComBSTR(g_SubclassOf), value);
         if( FAILED(hr) )
         {
            parent_ComponentData.g_SchemaCache.ReleaseRef(parent_class);
            break;
         }

         
         // check if parent is one of the magic classes whose defaultObjectCategory
         // should be the same as the parent.
         BOOL fIsSpecialParent = FALSE;
         ASSERT( sizeof(rgszSpecialClassesOIDs) == sizeof(rgszSpecialClassesLdapNames) );

         if( parent_class )
         {
            fIsSpecialParent = IsInList( rgszSpecialClassesLdapNames,
                                         parent_class->ldapDisplayName );
         }
         else
         {
            UINT uIndex = 0;

             // lookup by LDAP failed.  check if parent is specified by OID
            fIsSpecialParent = IsInList( rgszSpecialClassesOIDs,
                                         wiz_info.parentClass,
                                         &uIndex );
            if( fIsSpecialParent )
            {
                parent_class = parent_ComponentData.g_SchemaCache.LookupSchemaObject(
                                         rgszSpecialClassesLdapNames[uIndex],
                                         SCHMMGMT_CLASS);
                ASSERT( parent_class ); // the schema cache must contain well known classes.
            }
         }

         // if this is a special class, get parent's defaultObjectCategory.
         if( fIsSpecialParent && parent_class )
         {
             CString szParentPath;
             IADs *  pIADsParentObject   = NULL;
             VARIANT adsValue;
             
             VariantInit( &adsValue );

             do {    // one pass do-while loop to help with error handling
                     // if any errors occure, ignore them.

                 // Find out the defaultObjectCategory of the parent class & use it
                 parent_ComponentData.GetSchemaObjectPath( parent_class->commonName, szParentPath );

                 if( szParentPath.IsEmpty() )
                     break;

                 hr = ADsGetObject( const_cast<LPWSTR>((LPCWSTR)szParentPath),
                                            IID_IADs,
                                            (void **)&pIADsParentObject );
                 if ( !pIADsParentObject || FAILED(hr) )
                 {
                     DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr) );
                     hr = NULL;
                     break;
                 }

                 hr = pIADsParentObject->Get( const_cast<BSTR>((LPCTSTR)g_DefaultCategory),
                       &adsValue );

                 if( FAILED(hr) )
                 {
                     DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
                     hr = NULL;
                     break;
                 }

                 ASSERT( adsValue.vt == VT_BSTR );

                 // preserve hr so that save fails after this loop
                 hr = iads->Put( const_cast<BSTR>((LPCTSTR)g_DefaultCategory),
                        adsValue );

             } while (FALSE);

             VariantClear( &adsValue );
 
             parent_ComponentData.g_SchemaCache.ReleaseRef(parent_class);

             if( pIADsParentObject )
                 pIADsParentObject->Release();

             BREAK_ON_FAILED_HRESULT(hr);
         }
         else
         {
             parent_ComponentData.g_SchemaCache.ReleaseRef(parent_class);
         }
      }

      // optional attributes
      if (!wiz_info.strlistOptional.IsEmpty())
      {
         VARIANT value;
         ::VariantInit(&value);

         hr = StringListToVariant(value, wiz_info.strlistOptional);

         // don't break: plod onward.
         ASSERT(SUCCEEDED(hr));

         hr = iads->PutEx(ADS_PROPERTY_UPDATE, g_MayContain, value);
         ::VariantClear(&value);

         BREAK_ON_FAILED_HRESULT(hr);
      }

      // mandatory attributes
      if (!wiz_info.strlistMandatory.IsEmpty())
      {
         VARIANT value;
         ::VariantInit(&value);

         hr = StringListToVariant(value, wiz_info.strlistMandatory);

         // don't break: plod onward.
         ASSERT(SUCCEEDED(hr));

         hr = iads->PutEx(ADS_PROPERTY_UPDATE, g_MustContain, value);
         ::VariantClear(&value);

         BREAK_ON_FAILED_HRESULT(hr);
      }


      // commit the create
      hr = iads->SetInfo();
      BREAK_ON_FAILED_HRESULT(hr);

      
      // if there was no ldap name, and it worked, cn was used as ldap name
      if( wiz_info.ldapDisplayName.IsEmpty() )
      {
         CComVariant value;
         hr = iads->Get(CComBSTR(g_DisplayName), &value);
         ASSERT( SUCCEEDED(hr) );   // should be there!!!

         if( SUCCEEDED(hr) )
         {
             ASSERT( value.vt == VT_BSTR );
             wiz_info.ldapDisplayName = value.bstrVal;
         }
      }

      // create a cache entry for the new class object
      new_object = new SchemaObject;
      new_object->schemaObjectType = SCHMMGMT_CLASS;
      new_object->commonName = wiz_info.cn;
      new_object->ldapDisplayName = wiz_info.ldapDisplayName;
      new_object->oid = wiz_info.oid;
      new_object->dwClassType = wiz_info.type + 1;
      new_object->subClassOf = wiz_info.parentClass;

      ListEntry* new_list = 0;
      hr =
         StringListToColumnList(
            &parent_ComponentData,
            wiz_info.strlistOptional,
            &new_list);
      BREAK_ON_FAILED_HRESULT(hr);

      new_object->mayContain = new_list;

      new_list = 0;
      hr =
         StringListToColumnList(
            &parent_ComponentData,
            wiz_info.strlistMandatory,
            &new_list);
      BREAK_ON_FAILED_HRESULT(hr);

      new_object->mustContain = new_list;

      // stuff the new cache entry into the cache
      hr =
         parent_ComponentData.g_SchemaCache.InsertSchemaObject(new_object);
      BREAK_ON_FAILED_HRESULT(hr);
      hr =
         parent_ComponentData.g_SchemaCache.InsertSortedSchemaObject(new_object);
      BREAK_ON_FAILED_HRESULT(hr);

      // insert the new cache object into the snapin ui   
      parent_ComponentData.g_ClassCookieList.InsertSortedDisplay(
         &parent_ComponentData,
         new_object);
   }
   while (0);

   if (FAILED(hr))
   {
      delete new_object;

      if (hr == ADS_EXTENDED_ERROR)
      {
         DoExtErrMsgBox();
      }
      else
      {
         CString title;
         title.LoadString(AFX_IDS_APP_TITLE);
         CString error_text;
         CString name;

         HRESULT last_ads_hr = GetLastADsError(hr, error_text, name);
         if (HRESULT_CODE(last_ads_hr) == ERROR_DS_INVALID_LDAP_DISPLAY_NAME)
         {
           error_text.LoadString(IDS_LDAPDISPLAYNAME_FORMAT_ERROR);
         }
         else
         {
            error_text = GetErrorMessage(hr,TRUE);
         }

         ::MessageBox(
            m_hWnd,
            error_text,
            title,
            MB_OK | MB_ICONSTOP);
      }

      return FALSE;
   }
         
   // end the wizard
   // @@ call base::OnWizardFinish()?
   return TRUE;
}



void
NewClassAttributesPage::OnButtonOptionalAdd()
{
    listbox_optional.AddNewObjectToList();
}



void
NewClassAttributesPage::OnButtonMandatoryAdd()
{
    listbox_mandatory.AddNewObjectToList();
}



void
NewClassAttributesPage::OnButtonOptionalRemove()
{
    listbox_optional.RemoveListBoxItem();
}



void
NewClassAttributesPage::OnButtonMandatoryRemove()
{
    listbox_mandatory.RemoveListBoxItem();
}



void
NewClassAttributesPage::OnMandatorySelChange()
{
    listbox_mandatory.OnSelChange();
}    



void
NewClassAttributesPage::OnOptionalSelChange()
{
    listbox_optional.OnSelChange();
}    



void
NewClassAttributesPage::DoDataExchange(CDataExchange *pDX)
{
   CPropertyPage::DoDataExchange(pDX);

   DDX_Control(pDX, IDC_MANDATORY_LIST, listbox_mandatory);
   DDX_Control(pDX, IDC_OPTIONAL_LIST, listbox_optional);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\ncgen.cpp ===
#include "stdafx.h"
#include "compdata.h"
#include "wizinfo.hpp"
#include "ncgen.hpp"



const DWORD NewClassGeneralPage::help_map[] =
{
  IDC_CREATE_CLASS_CN,     IDH_CREATE_CLASS_CN,
  IDC_CREATE_CLASS_LDN,    IDH_CREATE_CLASS_LDN,
  IDC_CREATE_CLASS_OID,    IDH_CREATE_CLASS_OID,
  IDC_DESCRIPTION_EDIT,    IDH_CLASS_GENERAL_DESCRIPTION_EDIT,
  IDC_CREATE_CLASS_PARENT, IDH_CREATE_CLASS_PARENT,
  IDC_CREATE_CLASS_TYPE,   IDH_CREATE_CLASS_TYPE,
  0,0
};



BEGIN_MESSAGE_MAP(NewClassGeneralPage, CPropertyPage)
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
END_MESSAGE_MAP()



NewClassGeneralPage::NewClassGeneralPage(CreateClassWizardInfo* pWi)
   :
   CPropertyPage(IDD_CREATE_CLASS_GENERAL),
   m_editOID( CParsedEdit::EDIT_TYPE_OID )
{
    ASSERT( pWi );
    pWiz_info   = pWi;
}



BOOL
NewClassGeneralPage::OnInitDialog() 
{
   CPropertyPage::OnInitDialog();
   
   // load the combo box

   HWND combo = ::GetDlgItem(m_hWnd, IDC_CREATE_CLASS_TYPE);
   ASSERT( combo );

   ComboBox_AddString(combo, g_StructuralClass);
   ComboBox_AddString(combo, g_AbstractClass);
   ComboBox_AddString(combo, g_AuxClass);
   ComboBox_SetCurSel(combo, 0);

   // set boundaries

   Edit_LimitText(::GetDlgItem(m_hWnd, IDC_CREATE_CLASS_CN),     64); 
   Edit_LimitText(::GetDlgItem(m_hWnd, IDC_CREATE_CLASS_LDN),    256);
   Edit_LimitText(::GetDlgItem(m_hWnd, IDC_CREATE_CLASS_PARENT), 256);
   Edit_LimitText(::GetDlgItem(m_hWnd, IDC_DESCRIPTION_EDIT),    256);
   
   m_editOID.SubclassEdit( IDC_CREATE_CLASS_OID, this, cchMaxOID );

   return FALSE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL
NewClassGeneralPage::OnSetActive()
{
   CPropertySheet* parent = (CPropertySheet*) GetParent();   
   parent->SetWizardButtons(PSWIZB_NEXT);

   return TRUE;
}



void
Gripe(HWND parent, CEdit* edit, unsigned messageResID)
{
   ASSERT(edit);

   DoErrMsgBox(parent, TRUE, messageResID);
   edit->SetFocus();
   edit->SetSel(0, -1);
}



BOOL
NewClassGeneralPage::OnKillActive()
{
  // save the settings
  GetDlgItemText(IDC_CREATE_CLASS_CN,     pWiz_info->cn);             
  GetDlgItemText(IDC_CREATE_CLASS_LDN,    pWiz_info->ldapDisplayName);
  GetDlgItemText(IDC_CREATE_CLASS_OID,    pWiz_info->oid);  
  GetDlgItemText(IDC_DESCRIPTION_EDIT,    pWiz_info->description);
  GetDlgItemText(IDC_CREATE_CLASS_PARENT, pWiz_info->parentClass);    
  pWiz_info->type = ComboBox_GetCurSel(::GetDlgItem(m_hWnd, IDC_CREATE_CLASS_TYPE));

  // validate

  // do cn first, as it appears at the top of the page
  if (pWiz_info->cn.IsEmpty())
  {
    Gripe(m_hWnd, (CEdit*) GetDlgItem(IDC_CREATE_CLASS_CN), IDS_MUST_ENTER_CN);
    return FALSE;
  }
  if (pWiz_info->oid.IsEmpty())
  {
    Gripe(m_hWnd, (CEdit*) GetDlgItem(IDC_CREATE_CLASS_OID), IDS_MUST_ENTER_OID);
    return FALSE;
  }

  //
  // Check for valid OID
  //
  if (pWiz_info->oid.Left(1)  == L"."  ||
      pWiz_info->oid.Right(1) == L"."  ||
      pWiz_info->oid.Find(L"..") != -1)
  {
    Gripe( m_hWnd, (CEdit*) GetDlgItem(IDC_CREATE_CLASS_OID), IDS_ERR_CREATE_INVALID_OID );
    return FALSE;
  }

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\ncgen.hpp ===
#ifndef NCGEN_HPP_INCLUDED
#define NCGEN_HPP_INCLUDED



class NewClassGeneralPage : public CPropertyPage
{
   public:

   NewClassGeneralPage(CreateClassWizardInfo* wi);

//   ~NewClassGeneralPage();

   protected:

   static const DWORD help_map[];

   BOOL    OnHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, FALSE ); };
   BOOL    OnContextHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, TRUE ); };

   virtual
   BOOL
   OnInitDialog();

   virtual
   BOOL
   OnKillActive();

   virtual
   BOOL
   OnSetActive();

   DECLARE_MESSAGE_MAP()

   private:

   CParsedEdit	           m_editOID;
   CreateClassWizardInfo * pWiz_info;
};



#endif   // NCGEN_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\newclass.hpp ===
#ifndef NEWCLASS_HPP_INCLUDED
#define NEWCLASS_HPP_INCLUDED



void
DoNewClassDialog(ComponentData& cd);



#endif   // NEWCLASS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\newclass.cpp ===
#include "stdafx.h"
#include "compdata.h"
#include "newclass.hpp"
#include "wizinfo.hpp"
#include "ncgen.hpp"
#include "ncattr.hpp"



void
DoNewClassDialog(ComponentData& cd)
{
   CPropertySheet         prop_sheet(IDS_NEW_CLASS_PROP_SHEET_TITLE);
   CreateClassWizardInfo  info;                                      
   NewClassGeneralPage    general_page(&info);                       
   NewClassAttributesPage attr_page(&info, &cd);                          

   prop_sheet.AddPage(&general_page);
   prop_sheet.AddPage(&attr_page);

   prop_sheet.SetWizardMode();
   prop_sheet.DoModal();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\nodetype.h ===
// nodetype.h : Declaration of SchmMgmtObjectType

#ifndef __NODETYPE_H_INCLUDED__
#define __NODETYPE_H_INCLUDED__

//
// These are the enum types for node types that we use in cookies.
// These types are mapped to guids that are in uuids.h.
//
// Also note that the IDS_DISPLAYNAME_* and IDS_DISPLAYNAME_*_LOCAL
// string resources must be kept in sync with these values, and in
// the appropriate order.
//
// The global variable in cookie.cpp aColumns[][] must be kept in sync.
//

typedef enum _SchmMgmtObjectType {

        //
        // The root node.
        //

        SCHMMGMT_SCHMMGMT = 0,

        //
        // The two top level nodes.
        //

        SCHMMGMT_CLASSES,
        SCHMMGMT_ATTRIBUTES,

        //
        // Class may be a leaf node beneath
        // the classes node only.
        //

        SCHMMGMT_CLASS,

        //
        // Attribute is a result item beneath
        // the Attributes folder scope item.
        //

        SCHMMGMT_ATTRIBUTE,

        //
        // This must come last.
        //

        SCHMMGMT_NUMTYPES

} SchmMgmtObjectType, *PSchmMgmtObjectType;

inline BOOL IsValidObjectType( SchmMgmtObjectType objecttype )
        { return (objecttype >= SCHMMGMT_SCHMMGMT && objecttype < SCHMMGMT_NUMTYPES); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\persist.cpp ===
// Persist.cpp : Implementation of persistence

#include "stdafx.h"
#include "compdata.h"
#include "safetemp.h"

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(persist.cpp)")

STDMETHODIMP ComponentData::Load(IStream __RPC_FAR *pIStream)
{
        MFC_TRY;

#ifndef DONT_PERSIST
        ASSERT( NULL != pIStream );
        XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

        // read server name from stream
        DWORD dwLen = 0;
        HRESULT hr = pIStream->Read( &dwLen, 4, NULL );
        if ( FAILED(hr) )
        {
                ASSERT( FALSE );
                return hr;
        }
        ASSERT( dwLen <= MAX_PATH*sizeof(WCHAR) );
        LPCWSTR lpwcszMachineName = (LPCWSTR)alloca( dwLen );
        // allocated from stack, we don't need to free
        if (NULL == lpwcszMachineName)
        {
                AfxThrowMemoryException();
                return E_OUTOFMEMORY;
        }
        hr = pIStream->Read( (PVOID)lpwcszMachineName, dwLen, NULL );
        if ( FAILED(hr) )
        {
                ASSERT( FALSE );
                return hr;
        }
        QueryRootCookie().SetMachineName( lpwcszMachineName );

#endif
        return S_OK;

        MFC_CATCH;
}

STDMETHODIMP ComponentData::Save(IStream __RPC_FAR *pIStream, BOOL)
{
        MFC_TRY;

#ifndef DONT_PERSIST
        ASSERT( NULL != pIStream );
        XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

        LPCWSTR lpwcszMachineName = QueryRootCookie().QueryNonNULLMachineName();

        DWORD dwLen = static_cast<DWORD>((::wcslen(lpwcszMachineName)+1)*sizeof(WCHAR));
        ASSERT( 4 == sizeof(DWORD) );
        HRESULT hr = pIStream->Write( &dwLen, 4, NULL );
        if ( FAILED(hr) )
        {
                ASSERT( FALSE );
                return hr;
        }
        hr = pIStream->Write( lpwcszMachineName, dwLen, NULL );
        if ( FAILED(hr) )
        {
                ASSERT( FALSE );
                return hr;
        }
#endif
        return S_OK;

        MFC_CATCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\newattr.hpp ===
#ifndef NEWATTR_HPP_INCLUDED
#define NEWATTR_HPP_INCLUDED


class CreateAttributeDialog : public CDialog
{
   public:

   CreateAttributeDialog( ComponentData *pScope,
                           LPDATAOBJECT lpDataObject );

   ~CreateAttributeDialog();

   BOOL fDialogLoaded;

   BOOL MultiValued;
   UINT SyntaxOrdinal;
   CString CommonName;
   CString OID;
   CString LdapDisplayName;
   CString Description;

   CString Min;
   CString Max;

   ComponentData *pScopeControl;
   LPDATAOBJECT lpScopeDataObj;

   CParsedEdit	m_editOID;
   CParsedEdit	m_editLowerRange;
   CParsedEdit	m_editUpperRange;

   virtual void OnOK();
   virtual void DoDataExchange( CDataExchange *pDX );
   virtual BOOL OnInitDialog();

   BOOL OnHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, FALSE ); };
   BOOL OnContextHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, TRUE ); };

   void	OnSelchangeSyntax();

   DECLARE_MESSAGE_MAP()

private:

   static const DWORD help_map[];
};




#endif   // NEWATTR_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\relation.cpp ===
//
// relation.cpp : Implementation of ClassRelationshipPage
//
// Jon Newman <jonn@microsoft.com>
// Copyright (c) Microsoft Corporation 1997
//

#include "stdafx.h"

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(relation.cpp)")

#include "compdata.h"
#include "schmutil.h"

#include "relation.h"
#include "select.h"



const CDialogControlsInfo ctrls[] =
{
    { IDC_CLASS_REL_AUX_CLASSES,    g_AuxiliaryClass,   FALSE },
    { IDC_CLASS_REL_AUX_ADD,        g_AuxiliaryClass,   FALSE },
    { IDC_CLASS_REL_SUPER_CLASSES,  g_Superiors,        FALSE },
    { IDC_CLASS_REL_SUPER_ADD,      g_Superiors,        FALSE },
} ;


const DWORD ClassRelationshipPage::help_map[] =
{
    IDI_CLASS,                          NO_HELP,
    IDC_CLASS_REL_NAME_STATIC,          NO_HELP,
    IDC_CLASS_REL_PARENT_EDIT,          IDH_CLASS_REL_PARENT_EDIT,
    IDC_CLASS_REL_AUX_CLASSES,          IDH_CLASS_REL_AUX_CLASSES,
    IDC_STATIC_SYSTEMONLY_AUXILIARY,    NO_HELP,
    IDC_CLASS_REL_AUX_ADD,              IDH_CLASS_REL_AUX_ADD,
    IDC_CLASS_REL_AUX_REMOVE,           IDH_CLASS_REL_AUX_REMOVE,
    IDC_CLASS_REL_SUPER_CLASSES,        IDH_CLASS_REL_SUPER_CLASSES,
    IDC_STATIC_SYSTEMONLY_SUPERIOR,     NO_HELP,
    IDC_CLASS_REL_SUPER_ADD,            IDH_CLASS_REL_SUPER_ADD,
    IDC_CLASS_REL_SUPER_REMOVE,         IDH_CLASS_REL_SUPER_REMOVE,
    IDC_CLASS_REL_SYSCLASS_STATIC,      NO_HELP,
    0,0
};


ClassRelationshipPage::ClassRelationshipPage(
    ComponentData *pScope,
    LPDATAOBJECT lpDataObject ) :
        CPropertyPage(ClassRelationshipPage::IDD)
        , m_pIADsObject( NULL )
        , fSystemClass( FALSE )
        , m_pSchemaObject( NULL )
        , m_pScopeControl( pScope )
        , m_lpScopeDataObj( lpDataObject )
{
    ASSERT( NULL != m_pScopeControl );
    ASSERT( NULL != lpDataObject );
}

ClassRelationshipPage::~ClassRelationshipPage()
{
    if (NULL != m_pIADsObject)
            m_pIADsObject->Release();
    if (NULL != m_pSchemaObject) {
        m_pScopeControl->g_SchemaCache.ReleaseRef( m_pSchemaObject );
    }
}

void
ClassRelationshipPage::Load(
    Cookie& CookieRef
) {

    //
    // Store the cookie object pointer.
    //

    m_pCookie = &CookieRef;
    return;

}

BOOL
ClassRelationshipPage::OnInitDialog()
{
    HRESULT hr = S_OK;
    ASSERT( NULL == m_pIADsObject && m_szAdsPath.IsEmpty() );

    //
    // Get the schema cache object and the actual ADS object.
    //

    m_pSchemaObject = m_pScopeControl->g_SchemaCache.LookupSchemaObjectByCN(
                        m_pCookie->strSchemaObject,
                        SCHMMGMT_CLASS );

    if ( m_pSchemaObject ) {

        m_pScopeControl->GetSchemaObjectPath( m_pSchemaObject->commonName, m_szAdsPath );

        if ( !m_szAdsPath.IsEmpty() ) {

           hr = ADsGetObject( (LPWSTR)(LPCWSTR)m_szAdsPath,
                              IID_IADs,
                              (void **)&m_pIADsObject );

           ASSERT( SUCCEEDED(hr) );
        }

    }

    //
    // If we have no ADS object, we should error out!
    //

    if ( !m_pIADsObject ) {
        DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_NO_SCHEMA_OBJECT );
                ASSERT(FALSE);
        return TRUE;
    }

    //
    // get the current values.
    //

    VARIANT AdsResult;
    VariantInit( &AdsResult );

    //
    // ObjectName
    //

    hr = m_pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_DisplayName),
                          &AdsResult );

    if ( SUCCEEDED( hr ) ) {
      ASSERT( AdsResult.vt == VT_BSTR );
      ObjectName = AdsResult.bstrVal;
      VariantClear( &AdsResult );
    }

    //
    // Parent Class.
    //

    hr = m_pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_SubclassOf),
                          &AdsResult );

    if ( SUCCEEDED( hr ) ) {

      ASSERT( AdsResult.vt == VT_BSTR );
      ParentClass = AdsResult.bstrVal;
      VariantClear( &AdsResult );
    }

    //
    // SysClass
    //

    hr = m_pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_SystemOnly),
                           &AdsResult );

    if ( SUCCEEDED( hr ) ) 
    {
      ASSERT( AdsResult.vt == VT_BOOL );
      fSystemClass = AdsResult.boolVal;

      if ( fSystemClass ) 
      {
        SysClassString = g_SysClassString;
      } 
      else 
      {
        SysClassString = L"";
      }

      VariantClear( &AdsResult );

    } 
    else 
    {
      SysClassString = L"";
    }

    //
    // Determine the auxiliary classes
    //

    VARIANT varClasses;
    VariantInit( &varClasses );

    hr = m_pIADsObject->GetEx( g_AuxiliaryClass, &varClasses );
    ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    if( SUCCEEDED(hr) )
    {
      hr = VariantToStringList( varClasses, strlistAuxiliary );
      ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    }
    VariantClear( &varClasses );

    hr = m_pIADsObject->GetEx( g_SystemAuxiliaryClass, &varClasses );
    ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    if( SUCCEEDED(hr) )
    {
      hr = VariantToStringList( varClasses, strlistSystemAuxiliary );
      ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    }
    VariantClear( &varClasses );

    //
    // Determine the superior classes
    //

    hr = m_pIADsObject->GetEx( g_Superiors, &varClasses );
    ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    
    if( SUCCEEDED(hr) )
    {
        hr = VariantToStringList( varClasses, strlistSuperior );
        ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    }
    VariantClear( &varClasses );
    
    hr = m_pIADsObject->GetEx( g_SystemSuperiors, &varClasses );
    ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    
    if( SUCCEEDED(hr) )
    {
        hr = VariantToStringList( varClasses, strlistSystemSuperior );
        ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
    }
    VariantClear( &varClasses );


    hr = DissableReadOnlyAttributes( this, m_pIADsObject, ctrls, sizeof(ctrls)/sizeof(ctrls[0]) );
    ASSERT( SUCCEEDED(hr) );     // shouldn't fail, but unimportant, so ignore error


    // This calls must be done before DDX binding
    m_listboxAuxiliary.InitType( m_pScopeControl,
                                 SELECT_AUX_CLASSES,
                                 IDC_CLASS_REL_AUX_REMOVE,
                                 &strlistSystemAuxiliary,
                                 IDC_STATIC_SYSTEMONLY_AUXILIARY
                               );

    m_listboxSuperior.InitType(  m_pScopeControl,
                                 SELECT_CLASSES,
                                 IDC_CLASS_REL_SUPER_REMOVE,
                                 &strlistSystemSuperior,
                                 IDC_STATIC_SYSTEMONLY_SUPERIOR
                              );

    CPropertyPage::OnInitDialog();

    return TRUE;
}



BOOL
ClassRelationshipPage::OnSetActive()
{
   // always enable the Apply button
   SetModified(TRUE);

   return TRUE;
}



void
ClassRelationshipPage::DoDataExchange(
    CDataExchange *pDX
) {

        HRESULT hr = S_OK;

    CPropertyPage::DoDataExchange( pDX );

        //{{AFX_DATA_MAP(ClassRelationshipPage)
        DDX_Control(pDX, IDC_CLASS_REL_PARENT_EDIT, m_staticParent );
        DDX_Control(pDX, IDC_CLASS_REL_AUX_CLASSES, m_listboxAuxiliary);
        DDX_Control(pDX, IDC_CLASS_REL_SUPER_CLASSES, m_listboxSuperior);
    DDX_Text( pDX, IDC_CLASS_REL_NAME_STATIC, ObjectName );
    DDX_Text( pDX, IDC_CLASS_REL_PARENT_EDIT, ParentClass );
    DDX_Text( pDX, IDC_CLASS_REL_SYSCLASS_STATIC, SysClassString );
        //}}AFX_DATA_MAP


    if ( !pDX->m_bSaveAndValidate ) {

        //
        // Fill the auxiliary classes list box.
        //

                m_listboxAuxiliary.ResetContent();
        hr = InsertEditItems( m_listboxAuxiliary, strlistAuxiliary );
                ASSERT( SUCCEEDED(hr) );
        hr = InsertEditItems( m_listboxAuxiliary, strlistSystemAuxiliary );
                ASSERT( SUCCEEDED(hr) );

        //
        // Fill the possible superiors list box.
        //

                m_listboxSuperior.ResetContent();
        hr = InsertEditItems( m_listboxSuperior, strlistSuperior );
                ASSERT( SUCCEEDED(hr) );
        hr = InsertEditItems( m_listboxSuperior, strlistSystemSuperior );
                ASSERT( SUCCEEDED(hr) );

        m_listboxAuxiliary.OnSelChange();
        m_listboxSuperior.OnSelChange();

    } else {

        //
        // All changes that we save are tied to button control routines.
        //

                strlistAuxiliary.RemoveAll();
                hr = RetrieveEditItemsWithExclusions(
                        m_listboxAuxiliary,
                        strlistAuxiliary,
                        &strlistSystemAuxiliary
                        );
                ASSERT( SUCCEEDED(hr) );

                strlistSuperior.RemoveAll();
                hr = RetrieveEditItemsWithExclusions(
                        m_listboxSuperior,
                        strlistSuperior,
                        &strlistSystemSuperior
                        );
                ASSERT( SUCCEEDED(hr) );
    }
}

BEGIN_MESSAGE_MAP(ClassRelationshipPage, CPropertyPage)
        ON_BN_CLICKED(IDC_CLASS_REL_AUX_ADD,       OnButtonAuxiliaryClassAdd)
        ON_BN_CLICKED(IDC_CLASS_REL_AUX_REMOVE,    OnButtonAuxiliaryClassRemove)
        ON_BN_CLICKED(IDC_CLASS_REL_SUPER_ADD,     OnButtonSuperiorClassAdd)
        ON_BN_CLICKED(IDC_CLASS_REL_SUPER_REMOVE,  OnButtonSuperiorClassRemove)
        ON_LBN_SELCHANGE(IDC_CLASS_REL_AUX_CLASSES, OnAuxiliarySelChange)
        ON_LBN_SELCHANGE(IDC_CLASS_REL_SUPER_CLASSES, OnSuperiorSelChange)
        ON_MESSAGE(WM_HELP,                        OnHelp)
        ON_MESSAGE(WM_CONTEXTMENU,                 OnContextHelp)
END_MESSAGE_MAP()


BOOL
ClassRelationshipPage::OnApply(
)
//
// Revisions:
// CoryWest - 10/1/97 - Changes new additions to be listed by oid.
//                      Add cache freshening to improve performance.
//
{
    ASSERT( NULL != m_pIADsObject);

    HRESULT hr = S_OK;
    HRESULT flush_result;
    ListEntry *pNewList = NULL;
    BOOL fApplyAbort    = FALSE;  // stop later saves
    BOOL fApplyFailed   = FALSE;  // should not close the box

    if ( m_listboxAuxiliary.IsModified() )
    {
        //
        // Update the auxiliary classes
        //

        VARIANT AdsValue;
        VariantInit( &AdsValue );

        hr = StringListToVariant( AdsValue, strlistAuxiliary );
        ASSERT( SUCCEEDED(hr) );

        hr = m_pIADsObject->PutEx( ADS_PROPERTY_UPDATE, g_AuxiliaryClass, AdsValue );
        ASSERT( SUCCEEDED(hr)  );

        VariantClear( &AdsValue );

        hr = m_pIADsObject->SetInfo();

        if ( SUCCEEDED( hr )) {

            //
            // Update the aux class list in the cache.
            //

            hr = StringListToColumnList( m_pScopeControl,
                                         strlistAuxiliary,
                                         &pNewList );

            if ( SUCCEEDED( hr )) {

                m_pScopeControl->g_SchemaCache.FreeColumnList(
                    m_pSchemaObject->auxiliaryClass );
                m_pSchemaObject->auxiliaryClass = pNewList;

                //
                // Refresh the display!
                //

                m_pScopeControl->QueryConsole()->UpdateAllViews(
                    m_lpScopeDataObj, SCHMMGMT_CLASS, SCHMMGMT_UPDATEVIEW_REFRESH );
            }

            //
            // Continue with the directory operation even if
            // we couldn't update the display.
            //

            hr = S_OK;

        } else {

            //
            // Flush the IADS property cache so future
            // operations won't fail because of this one.
            //

            IADsPropertyList *pPropertyList;

            flush_result = m_pIADsObject->QueryInterface(
                             IID_IADsPropertyList,
                             reinterpret_cast<void**>(&pPropertyList) );

            if ( SUCCEEDED( flush_result ) ) {
                pPropertyList->PurgePropertyList();
                pPropertyList->Release();
            }
        }

    }

    if ( SUCCEEDED(hr) && m_listboxSuperior.IsModified() )
    {
        //
        // Update the superior classes
        //

        VARIANT AdsValue;
        VariantInit( &AdsValue );

        hr = StringListToVariant( AdsValue, strlistSuperior );
        ASSERT( SUCCEEDED(hr) );

        hr = m_pIADsObject->PutEx( ADS_PROPERTY_UPDATE, g_Superiors, AdsValue );
        ASSERT( SUCCEEDED(hr)  );
        VariantClear( &AdsValue );

        hr = m_pIADsObject->SetInfo();
    }

    if ( hr == ADS_EXTENDED_ERROR )
    {
        DoExtErrMsgBox();
    }
    else if ( FAILED(hr) )
    {
        if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
        {
            fApplyFailed = TRUE;
            DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_CHANGE_REJECT );
        }
        else
        {
            fApplyAbort = TRUE; 
            DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
        }
    }
    else
    {

        // page is no longer "dirty"
        m_listboxAuxiliary.SetModified( FALSE );
        m_listboxSuperior.SetModified( FALSE );

		// Update comboBox status
		OnAuxiliarySelChange();
		OnSuperiorSelChange();
        
		SetModified( FALSE );
    }

    return !fApplyAbort && !fApplyFailed ;      // return TRUE if nothing happened
}



void ClassRelationshipPage::OnAuxiliarySelChange()
{
    m_listboxAuxiliary.OnSelChange();
}



void ClassRelationshipPage::OnSuperiorSelChange()
{
    m_listboxSuperior.OnSelChange();
}


void ClassRelationshipPage::OnButtonAuxiliaryClassRemove()
{
    if( m_listboxAuxiliary.RemoveListBoxItem() )
        SetModified( TRUE );
}


void ClassRelationshipPage::OnButtonSuperiorClassRemove()
{
    if( m_listboxSuperior.RemoveListBoxItem() )
        SetModified( TRUE );
}


void
ClassRelationshipPage::OnButtonAuxiliaryClassAdd()
{
    if( m_listboxAuxiliary.AddNewObjectToList() )
        SetModified( TRUE );
}


void
ClassRelationshipPage::OnButtonSuperiorClassAdd()
{
    if( m_listboxSuperior.AddNewObjectToList() )
        SetModified( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\schmmgmt.cpp ===
//
// SchmMgmt.cpp : Implementation of DLL Exports.
// Cory West


#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "schmmgmt.h"
#include "regkey.h" // AMC::CRegKey
#include "strings.h" // SNAPINS_KEY
#include "macros.h" // MFC_TRY/MFC_CATCH
#include "stdutils.h" // g_aNodetypeGuids

#include "cookie.h"
#include "compdata.h" // ComponentData
#include "about.h"        // CSchemaMgmtAbout

USE_HANDLE_MACROS("SchmMgmt(SchmMgmt.cpp)")



// Snapin CLSID - {632cccf4-cbed-11d0-9c16-00c04fd8d86e}
const CLSID CLSID_SchmMgmt =
 {0x632cccf4, 0xcbed, 0x11d0, {0x9c, 0x16, 0x00, 0xc0, 0x4f, 0xd8, 0xd8, 0x6e}};

// Snapin about CLSID - {333fe3fb-0a9d-11d1-bb10-00c04fc9a3a3}
const CLSID CLSID_SchemaManagementAbout =
 {0x333fe3fb, 0x0a9d, 0x11d1, {0xbb, 0x10, 0x00, 0xc0, 0x4f, 0xc9, 0xa3, 0xa3}};



CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_SchmMgmt, ComponentData)
                OBJECT_ENTRY(CLSID_SchemaManagementAbout, CSchemaMgmtAbout)
END_OBJECT_MAP()

class CSchmMgmtApp : public CWinApp
{
public:
        virtual BOOL InitInstance();
        virtual int ExitInstance();
};

CSchmMgmtApp theApp;

BOOL CSchmMgmtApp::InitInstance()
{
        _Module.Init(ObjectMap, m_hInstance);
        return CWinApp::InitInstance();
}

int CSchmMgmtApp::ExitInstance()
{
        _Module.Term();
        return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
        return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer( void ) {

    MFC_TRY;

    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hRes = S_OK;
    CString Name, Microsoft, About, Provider, Version, VerString;

    Name.LoadString(IDS_REGSERV_NAME);
    Microsoft.LoadString(IDS_REGSERV_MICROSOFT);
    About.LoadString(IDS_REGSERV_ABOUT);
    Provider.LoadString(IDS_REGSERV_PROVIDER);
    Version.LoadString(IDS_REGSERV_VERSION);
    VerString.LoadString(IDS_SNAPINABOUT_VERSION);

    //
    // registers object, typelib and all interfaces in typelib
    //

    hRes = _Module.RegisterServer(FALSE);

    try {

        AMC::CRegKey regkeySnapins;
        BOOL fFound = regkeySnapins.OpenKeyEx( HKEY_LOCAL_MACHINE, SNAPINS_KEY );

        if ( !fFound ) {
        
            ASSERT(FALSE);
            return SELFREG_E_CLASS;
        }

        {
            AMC::CRegKey regkeySchmMgmtSnapin;
            CString strGUID;

            HRESULT hr = GuidToCString(OUT &strGUID, CLSID_SchmMgmt );

            if ( FAILED(hr) ) {
        
                ASSERT(FALSE);
                return SELFREG_E_CLASS;
             }

             regkeySchmMgmtSnapin.CreateKeyEx( regkeySnapins, strGUID );
             regkeySchmMgmtSnapin.SetString( g_szNodeType, g_aNodetypeGuids[SCHMMGMT_SCHMMGMT].bstr );
             regkeySchmMgmtSnapin.SetString( g_szNameString, Name );

             hr = GuidToCString(OUT &strGUID, CLSID_SchemaManagementAbout );
        
             if ( FAILED(hr) ) {
                 ASSERT(FALSE);
                 return SELFREG_E_CLASS;
             }

             regkeySchmMgmtSnapin.SetString( About, strGUID );
             regkeySchmMgmtSnapin.SetString( Provider, Microsoft );
             regkeySchmMgmtSnapin.SetString( Version, VerString );
             AMC::CRegKey regkeySchmMgmtStandalone;
             regkeySchmMgmtStandalone.CreateKeyEx( regkeySchmMgmtSnapin, g_szStandAlone );
             AMC::CRegKey regkeyMyNodeTypes;
             regkeyMyNodeTypes.CreateKeyEx( regkeySchmMgmtSnapin, g_szNodeTypes );
             AMC::CRegKey regkeyMyNodeType;

                 for (int i = SCHMMGMT_SCHMMGMT; i < SCHMMGMT_NUMTYPES; i++)
                 {
                         regkeyMyNodeType.CreateKeyEx( regkeyMyNodeTypes, g_aNodetypeGuids[i].bstr );
                         regkeyMyNodeType.CloseKey();
                 }
                }

                AMC::CRegKey regkeyNodeTypes;
                fFound = regkeyNodeTypes.OpenKeyEx( HKEY_LOCAL_MACHINE, NODE_TYPES_KEY );
                if ( !fFound )
                {
                        ASSERT(FALSE);
                        return SELFREG_E_CLASS;
                }
                AMC::CRegKey regkeyNodeType;
                for (int i = SCHMMGMT_SCHMMGMT; i < SCHMMGMT_NUMTYPES; i++)
                {
                        regkeyNodeType.CreateKeyEx( regkeyNodeTypes, g_aNodetypeGuids[i].bstr );
                        regkeyNodeType.CloseKey();
                }
        }
    catch (COleException* e)
    {
                ASSERT(FALSE);
        e->Delete();
                return SELFREG_E_CLASS;
    }

        return hRes;

        MFC_CATCH;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
        _Module.UnregisterServer();
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\relation.h ===
//
// relation.h : Declaration of ClassRelationshipPage
//
// Jon Newman <jonn@microsoft.com>
// Copyright (c) Microsoft Corporation 1997
//

#ifndef __RELATION_H_INCLUDED__
#define __RELATION_H_INCLUDED__

#include "cookie.h"     // Cookie
#include "resource.h"   // IDD_CLASS_RELATIONSHIP

class ClassRelationshipPage : public CPropertyPage
{
   public:

    ClassRelationshipPage( ComponentData *pScope,
                                LPDATAOBJECT lpDataObject );

    ~ClassRelationshipPage();

    void Load( Cookie& CookieRef );

    //
    // The schema object that this property page is for.
    //

    Cookie *m_pCookie;
    CString m_szAdsPath;

    ComponentData* m_pScopeControl;
    LPDATAOBJECT m_lpScopeDataObj;

        //
        // The ADSI object that this property page is for
        //

        IADs *m_pIADsObject;
        SchemaObject* m_pSchemaObject;

    CString SysClassString;

    // Dialog Data
    enum { IDD = IDD_CLASS_RELATIONSHIP};
    CStatic               m_staticParent;
    CSchemaObjectsListBox m_listboxAuxiliary;
    CSchemaObjectsListBox m_listboxSuperior;
    CString               ObjectName;
    CString               ParentClass;
    BOOL                  fSystemClass;

    
// Overrides
        // ClassWizard generate virtual function overrides

        public:
        virtual BOOL OnApply();

        protected:
        virtual BOOL OnInitDialog();
        virtual BOOL OnSetActive();
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
        // Generated message map functions
        afx_msg void OnButtonAuxiliaryClassAdd();
        afx_msg void OnButtonAuxiliaryClassRemove();
        afx_msg void OnButtonSuperiorClassRemove();
        afx_msg void OnButtonSuperiorClassAdd();
        afx_msg void OnAuxiliarySelChange();
        afx_msg void OnSuperiorSelChange();


        static const DWORD help_map[];

        BOOL         OnHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, FALSE ); };
        BOOL         OnContextHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, TRUE ); };


        DECLARE_MESSAGE_MAP()

public:
// User defined variables

        CStringList strlistAuxiliary;
        CStringList strlistSystemAuxiliary;
        CStringList strlistSuperior;
        CStringList strlistSystemSuperior;
};

#endif // __RELATION_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\schmmgmt.h ===
#ifndef _SCHMMGMT_H
#define _SCHMMGMT_H

extern const GUID CLSID_SchmMgmt;
extern const GUID CLSID_SchemaManagementAbout;


#endif // _SCHMMGMT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\schmutil.h ===
/****

SchmUtil.h

Various common utility routines for the Schema Editor Snap-In.

****/


#include "cache.h"
#include "cookie.h"
#include "select.h"

#ifndef __SCHMUTIL_H_INCLUDED__
#define __SCHMUTIL_H_INCLUDED__



//
//	uncomment to enable the negative numbers support
//
#define ENABLE_NEGATIVE_INT



// Returns the full pathname of the .hlp file for this snapin

CString
GetHelpFilename();


//
// The global list of class scope cookies.
//

class CCookieListEntry {

public:

    CCookieListEntry() :
        pCookie( NULL ),
        pNext( this ),
        pBack( this ) { ; }

    ~CCookieListEntry() { ; }

    Cookie *pCookie;
    HSCOPEITEM hScopeItem;

    CCookieListEntry *pNext;
    CCookieListEntry *pBack;
};



class CCookieList
{
   public:

   CCookieList() :
     pHead( NULL ),
     pParentCookie( NULL ) { ; }

   ~CCookieList() { DeleteAll(); }

   VOID AddCookie( Cookie *pCookie,
                 HSCOPEITEM hScope );

   VOID InsertSortedDisplay( ComponentData *pScopeControl,
                           SchemaObject *pNewClass );

   bool DeleteCookie(Cookie* pCookie);

   void
   DeleteAll();

   //
   // Data members.
   //

   Cookie *pParentCookie;
   HSCOPEITEM hParentScopeItem;

   CCookieListEntry *pHead;

   //
   // We provide no functions to walk this list.  The
   // user of this list has to walk it manually.
   //
};


//
// Some schema magic numbers.
//

#define CLASS_TYPE_88           0
#define CLASS_TYPE_STRUCTURAL   1
#define CLASS_TYPE_ABSTRACT     2
#define CLASS_TYPE_AUXILIARY    3

#define ATTRIBUTE_OPTIONAL      1
#define ATTRIBUTE_MANDATORY     2

//
// Global DS class and attribute strings.
//

extern LPWSTR g_DisplayName;
extern LPWSTR g_ClassFilter;
extern LPWSTR g_AttributeFilter;
extern LPWSTR g_Description;
extern LPWSTR g_MayContain;
extern LPWSTR g_MustContain;
extern LPWSTR g_SystemMayContain;
extern LPWSTR g_SystemMustContain;
extern LPWSTR g_AuxiliaryClass;
extern LPWSTR g_SystemAuxiliaryClass;
extern LPWSTR g_SubclassOf;
extern LPWSTR g_ObjectClassCategory;
extern LPWSTR g_ObjectClass;
extern LPWSTR g_CN;
extern LPWSTR g_ClassSearchRequest;
extern LPWSTR g_AttribSearchRequest;
extern LPWSTR g_omSyntax;
extern LPWSTR g_AttributeSyntax;
extern LPWSTR g_omObjectClass;
extern LPWSTR g_SystemOnly;
extern LPWSTR g_Superiors;
extern LPWSTR g_SystemSuperiors;
extern LPWSTR g_GlobalClassID;
extern LPWSTR g_GlobalAttributeID;
extern LPWSTR g_RangeUpper;
extern LPWSTR g_RangeLower;
extern LPWSTR g_ShowInAdvViewOnly;
extern LPWSTR g_IsSingleValued;
extern LPWSTR g_IndexFlag;
extern LPWSTR g_UpdateSchema;
extern LPWSTR g_isDefunct;
extern LPWSTR g_GCReplicated;
extern LPWSTR g_DefaultAcl;
extern LPWSTR g_DefaultCategory;
extern LPWSTR g_systemFlags;
extern LPWSTR g_fsmoRoleOwner;
extern LPWSTR g_allowedChildClassesEffective;
extern LPWSTR g_allowedAttributesEffective;

//
// *******************************************************************
// These are loaded from the resources as they need to be localizable.
// *******************************************************************
//

//
// Global strings for our static nodes.
//

extern CString g_strSchmMgmt;
extern CString g_strClasses;
extern CString g_strAttributes;

//
// Strings for various object types.
//

extern CString g_88Class;
extern CString g_StructuralClass;
extern CString g_AuxClass;
extern CString g_AbstractClass;
extern CString g_MandatoryAttribute;
extern CString g_OptionalAttribute;
extern CString g_Yes;
extern CString g_No;
extern CString g_Unknown;
extern CString g_Defunct;
extern CString g_Active;

//
// Message strings.
//

extern CString g_NoDescription;
extern CString g_NoName;
extern CString g_MsgBoxErr;
extern CString g_MsgBoxWarn;
extern CString g_SysClassString;
extern CString g_SysAttrString;

//
// Utility function declarations.
//

void
LoadGlobalCookieStrings(
);

VOID
DebugTrace(
    LPWSTR Format,
    ...
);

INT
DoErrMsgBox(
    HWND hwndParent,
    BOOL fError,
    UINT wIdString
);

INT
DoErrMsgBox(
    HWND hwndParent,
    BOOL fError,
    PCWSTR pszError
);

VOID
DoExtErrMsgBox(
    VOID
);


// INVALID_POINTER is returned by CListBox::GetItemDataPtr() in case of an error.
extern const VOID * INVALID_POINTER;


// add items from the VT_ARRAY|VT_BSTR variant to the listbox
HRESULT
InsertEditItems(
    HWND hwnd,
    VARIANT *AdsResult
);

// as above but takes a CListBox&
inline HRESULT
InsertVariantEditItems(
    CListBox& refListBox,
    VARIANT *AdsResult
)
{
        return InsertEditItems( refListBox.m_hWnd, AdsResult );
}

// add items from stringlist to the listbox
HRESULT
InsertEditItems(
    CListBox& refListBox,
    CStringList& refstringlist
);

// Add items from the listbox to the stringlist, skipping those
//  from the exclusion stringlist if one is present
HRESULT
RetrieveEditItemsWithExclusions(
    CListBox& refListBox,
    CStringList& refstringlist,
        CStringList* pstringlistExclusions = NULL
);

// Helper function for octet string comparisson
BOOL
IsEqual( ADS_OCTET_STRING * ostr1, ADS_OCTET_STRING * ostr2 );

UINT
GetSyntaxOrdinal(
    PCTSTR attributeSyntax, UINT omSyntax, ADS_OCTET_STRING * omObjectClass
);

// add items from the VT_ARRAY|VT_BSTR variant to the stringlist
HRESULT
VariantToStringList(
    VARIANT& refvar,
        CStringList& refstringlist
);

// Creates a new VT_ARRAY|VT_BSTR variant from the stringlist
HRESULT
StringListToVariant(
    VARIANT& refvar,
        CStringList& refstringlist
);

HRESULT
StringListToColumnList(
    ComponentData* pScopeControl,
    CStringList& refstringlist,
    ListEntry **ppNewList
);

//
// The menu command ids.
//

enum MENU_COMMAND
{
   CLASSES_CREATE_CLASS = 0,
   ATTRIBUTES_CREATE_ATTRIBUTE,
   SCHEMA_RETARGET,
   SCHEMA_EDIT_FSMO,
   SCHEMA_REFRESH,
   SCHEMA_SECURITY,
   NEW_CLASS,
   NEW_ATTRIBUTE,
   MENU_LAST_COMMAND
};

//
// The menu strings.
//

extern CString g_MenuStrings[MENU_LAST_COMMAND];
extern CString g_StatusStrings[MENU_LAST_COMMAND];



//
// Schema Object Syntax Descriptor class
//

class CSyntaxDescriptor
{
public:
	CSyntaxDescriptor(	UINT	nResourceID,
						BOOL	fIsSigned,				// Should the range be signed or unsigned number?
						BOOL	fIsANRCapable,
						PCTSTR	pszAttributeSyntax,
						UINT	nOmSyntax,
						DWORD	dwOmObjectClass,
						LPBYTE	pOmObjectClass ) :
				m_nResourceID(nResourceID),
				m_fIsSigned(fIsSigned),
				m_fIsANRCapable(fIsANRCapable),
				m_pszAttributeSyntax(pszAttributeSyntax),
				m_nOmSyntax(nOmSyntax)
	{
		ASSERT( nResourceID );
		ASSERT( (!pszAttributeSyntax && !nOmSyntax) ||		// either both are given
				(pszAttributeSyntax && nOmSyntax) );		// or both are 0

		ASSERT( (!dwOmObjectClass && !pOmObjectClass) ||	// either both are given
				(dwOmObjectClass && pOmObjectClass) );		// or both are 0

		m_octstrOmObjectClass.dwLength = dwOmObjectClass;
		m_octstrOmObjectClass.lpValue = pOmObjectClass;
	};     

   UINT              m_nResourceID;
   BOOL              m_fIsSigned;
   BOOL              m_fIsANRCapable;
   PCTSTR            m_pszAttributeSyntax;
   UINT              m_nOmSyntax;
   ADS_OCTET_STRING  m_octstrOmObjectClass;
   CString           m_strSyntaxName;
};

extern CSyntaxDescriptor g_Syntax[];
extern const UINT SCHEMA_SYNTAX_UNKNOWN;

extern const LPWSTR g_UINT32_FORMAT;
extern const LPWSTR g_INT32_FORMAT;

//
// ADS Provider Specific Extended Error
//

const HRESULT ADS_EXTENDED_ERROR = HRESULT_FROM_WIN32(ERROR_EXTENDED_ERROR);


CString
GetErrorMessage( HRESULT hr, BOOL fTryADSIExtError = FALSE );

HRESULT
GetLastADsError( HRESULT hr, CString& refErrorMsg, CString& refName );

//
// string to dword conversion utils, verification, etc.
//

const DWORD cchMinMaxRange = 11;   // the largest numbers possible in the Range settings
const DWORD cchMaxOID      = 1024;

const BOOL		GETSAFEINT_ALLOW_CANCEL	= TRUE;
const HRESULT	S_VALUE_MODIFIED		= S_FALSE;
const WCHAR		g_chSpace				= TEXT(' ');
const WCHAR		g_chNegativeSign		= TEXT('-');
const WCHAR		g_chPeriod      		= TEXT('.');


void DDXV_VerifyAttribRange( CDataExchange *pDX, BOOL fIsSigned,
								UINT idcLower, CString & strLower,
								UINT idcUpper, CString & strUpper );

INT64 DDXV_SigUnsigINT32Value( CDataExchange *pDX, BOOL fIsSigned,
						UINT idc, CString & str );

HRESULT GetSafeSignedDWORDFromString( CWnd * pwndParent, DWORD & lDst, CString & strSrc,
										BOOL fIsSigned, BOOL fAllowCancel = FALSE);

HRESULT GetSafeINT32FromString( CWnd * pwndParent, INT64 & llDst, CString & strSrc,
								BOOL fIsSigned, BOOL fAllowCancel);


BOOL IsValidNumber32( INT64 & llVal, BOOL fIsSigned );
BOOL IsValidNumberString( CString & str );

inline BOOL IsCharNumeric( WCHAR ch )
{
	return IsCharAlphaNumeric( ch ) && !IsCharAlpha( ch );
}


/////////////////////////////////////////////////////////////////////////////
// CParsedEdit is a specialized CEdit control that only allows characters
//  of the number type ( signed/unsigned can be set dynamically )
//  originally from the MFC samples

class CParsedEdit : public CEdit
{
public:
    enum EditType
    {
        EDIT_TYPE_INVALID = 0,  // should never be used, must be the first type
        EDIT_TYPE_GENERIC,
        EDIT_TYPE_INT32,
        EDIT_TYPE_UINT32,
        EDIT_TYPE_OID,
        EDIT_TYPE_LAST          // should never be used, must be the last type
    };

private:
    EditType    m_editType;

public:
	// Construction
	CParsedEdit( EditType et )                  { SetEditType( et ); }



    // subclassed construction
	BOOL        SubclassEdit(   UINT nID,
                                CWnd* pParent,
                                int cchMaxTextSize );     // 0 == unlimited


    // Edit box type
protected:
    static BOOL IsNumericType( EditType et )    { return EDIT_TYPE_INT32 == et || EDIT_TYPE_UINT32 == et; }
    static BOOL IsValidEditType( EditType et )  { return EDIT_TYPE_INVALID < et && et < EDIT_TYPE_LAST; }
    BOOL        IsInitialized() const           { return IsValidEditType( m_editType ); }

    // can the current type be changed to et?
    BOOL        IsCompatibleType( EditType et ) { ASSERT( IsValidEditType( et ) );
                                                  return !IsInitialized()       ||          // everything is ok
                                                         et == GetEditType()    ||          // no change
                                                          ( IsNumericType(GetEditType()) && // allow sign/unsign
                                                            IsNumericType(et)) ; }          // switch

    void        SetEditType( EditType et )      { ASSERT( IsValidEditType(et) );
                                                  ASSERT( IsCompatibleType(et) );
                                                  m_editType = et; }

public:
    EditType    GetEditType() const             { ASSERT( IsInitialized() );                // initialized?
                                                  return m_editType; }

	// IsSigned access functions
    BOOL        FIsSigned() const               { ASSERT( IsNumericType(GetEditType()) );
                                                  return EDIT_TYPE_INT32 == GetEditType(); }

    void        SetSigned( BOOL fIsSigned )     { ASSERT( IsInitialized() );
                                                  SetEditType( fIsSigned ? EDIT_TYPE_INT32 : EDIT_TYPE_UINT32 ); }


// Implementation
protected:
	//{{AFX_MSG(CParsedEdit)
	afx_msg void OnChar(UINT, UINT, UINT); // for character validation
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


///////////////////////////////////////////////////////////////////////////////
//  Search a list of PCTSTR for a strValue, returns TRUE if found
//      rgszList[] last element must be NULL
//
//  puIndex - optional pointer, will be set to the position of the value if found.
//
BOOL IsInList( PCTSTR rgszList[], const CString & strValue, UINT * puIndex = NULL );

//
//  Determine if the object pointed to by pIADsObject is category 1 object.
//
HRESULT IsCategory1Object( IADs *pIADsObject, BOOL & fIsCategory1 );

//
//  Determine if the object pointed to by pIADsObject is a constructed object.
//
HRESULT IsConstructedObject( IADs *pIADsObject, BOOL & fIsConstructed );

//
//  Read object's System Attribute
//
HRESULT GetSystemAttributes( IADs *pIADsObject, LONG &fSysAttribs );


//
//
//
class CDialogControlsInfo
{
public:
    UINT    m_nID;
    LPCTSTR m_pszAttributeName;
    BOOL    m_fIsEditBox;
};


HRESULT DissableReadOnlyAttributes( CWnd * pwnd, IADs *pIADsObject, const CDialogControlsInfo * pCtrls, UINT cCtrls );

HRESULT GetStringListElement( IADs *pIADsObject, LPWSTR *lppPathNames, CStringList &strlist );

//
// Validate an OID string format
//
bool OIDHasValidFormat (PCWSTR pszOidValue, int& rErrorTypeStrID);


HRESULT DeleteObject( const CString& path, Cookie* pcookie, PCWSTR pszClass);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\select.h ===
#ifndef _SELECT_H_INCLUDED
#define _SELECT_H_INCLUDED


//
// The common select dialog.
//

#include "cookie.h"
#include "cache.h"
#include "compdata.h"

typedef enum _SELECT_TYPE {
    SELECT_CLASSES=0,
    SELECT_ATTRIBUTES,
    SELECT_AUX_CLASSES
} SELECT_TYPE;

class CSchmMgmtSelect : public CDialog
{
   public:

   CSchmMgmtSelect( ComponentData *pScope,
                  SELECT_TYPE st=SELECT_CLASSES,
                  SchemaObject **pSchemaObject=NULL );

   ~CSchmMgmtSelect();

   BOOL fDialogLoaded;
   SELECT_TYPE SelectType;
   SchemaObject **pSchemaTarget;

   ComponentData *pScopeControl;

   virtual void DoDataExchange( CDataExchange *pDX );


   static const DWORD help_map[];

   BOOL         OnHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, FALSE ); };
   BOOL         OnContextHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, TRUE ); };

   afx_msg void OnDblclk();

   DECLARE_MESSAGE_MAP()
};


class CSchemaObjectsListBox : public CListBox
{
private:
    ComponentData * m_pScope;
    SELECT_TYPE     m_stType;
    int             m_nRemoveBtnID;
    CStringList   * m_pstrlistUnremovable;
    int             m_nUnableToDeleteID;

    BOOL            m_fModified;

    CPtrList        m_stringList;

public:

    CSchemaObjectsListBox();
    virtual ~CSchemaObjectsListBox();

    void InitType( ComponentData * pScope,
                   SELECT_TYPE     stType               = SELECT_CLASSES,
                   int             nRemoveBtnID         = 0,
                   CStringList   * pstrlistUnremovable  = NULL,
                   int             nUnableToDeleteID    = 0 );

    BOOL AddNewObjectToList( void );
    BOOL RemoveListBoxItem( void );

    void OnSelChange( void );

    BOOL IsModified( void )                     { ASSERT(m_pScope); return m_fModified; }
    void SetModified( BOOL fModified = TRUE )   { ASSERT(m_pScope); m_fModified = fModified; }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define ID_BUTTON_MORE_INFO             3
#define IDS_FSMO_ONLINE                 12
#define IDS_FSMO_OFFLINE                13
#define IDS_FSMO_SERVER_ERROR           14
#define IDS_SNAPINABOUT_PROVIDER        90
#define IDS_SNAPINABOUT_VERSION         91
#define IDS_SNAPINABOUT_DESCRIPTION     92
#define IDS_DEFUNCT                     93
#define IDS_ACTIVE                      94
#define IDS_ERRMSG_DELETE_FAILED_ATTRIBUTE 95
#define IDS_ERRMSG_DELETE_FAILED_CLASS  96
#define IDS_SCHMMGMT_DESC               101
#define IDS_SCOPE_CLASSES               105
#define IDS_SCOPE_ATTRIBUTES            106
#define IDD_CLASS_GENERAL               107
#define IDS_COLUMN_NAME                 108
#define IDS_COLUMN_TYPE                 109
#define IDS_COLUMN_DESCRIPTION          110
#define IDS_SCOPE_SCHMMGMT              111
#define IDS_COLUMN_PARENT               112
#define IDS_CLASS_STRUCTURAL            113
#define IDS_CLASS_ABSTRACT              114
#define IDS_CLASS_AUXILIARY             115
#define IDS_ATTRIBUTE_MANDATORY         116
#define IDS_ATTRIBUTE_OPTIONAL          117
#define IDS_COLUMN_STATUS               118
#define IDS_ERR_NO_NAME                 120
#define IDS_ERR_NO_DESCRIPTION          122
#define IDS_ERR_ERROR                   123
#define IDS_ERR_WARNING                 124
#define IDS_ERR_NO_SCHEMA_PATH          125
#define IDS_COLUMN_SYNTAX               126
#define IDS_ERR_NO_SCHEMA_OBJECT        127
#define IDS_CLASS_SYSTEM                128
#define IDS_SYNTAX_I5_STR               129
#define IDS_SYNTAX_DN                   130
#define IDS_SYNTAX_OID                  131
#define IDS_SYNTAX_INTERVAL             132
#define IDS_SYNTAX_NOCASE_STR           133
#define IDS_SYNTAX_PRCS_STR             134
#define IDS_SYNTAX_NUMSTR               135
#define IDS_SYNTAX_OR_NAME              136
#define IDS_SYNTAX_BOOLEAN              137
#define IDS_SYNTAX_INTEGER              138
#define IDS_SYNTAX_OCTET                139
#define IDS_SYNTAX_UTC                  140
#define IDS_SYNTAX_UNICODE              141
#define IDS_SYNTAX_ADDRESS              142
#define IDS_SYNTAX_DNSTRING             143
#define IDS_SYNTAX_SEC_DESC             144
#define IDS_SYNTAX_LINT                 145
#define IDS_SYNTAX_SID                  146
#define IDS_SYNTAX_UNKNOWN              147
#define IDS_ATTRIBUTE_MULTI             148
#define IDS_ATTRIBUTE_SINGLE            149
#define IDS_ERR_EDIT_DESC               150
#define IDS_ERR_INT_OVERFLOW            151
#define IDS_ERR_NUM_IS_ILLIGAL          152
#define IDS_ERR_EDIT_DISPLAYABLE        153
#define IDS_ERR_EDIT_INDEXED            154
#define IDS_SYNTAX_DN_BINARY            155
#define IDS_MENU_CLASS                  156
#define IDS_ATTR_SYSTEM                 157
#define IDS_MENU_ATTRIBUTE              160
#define IDS_STATUS_CREATE_CLASS         163
#define IDS_STATUS_CREATE_ATTRIBUTE     167
#define IDS_COLUMN_SYSTEM               172
#define IDS_YES                         173
#define IDS_NO                          174
#define IDS_SYNTAX_ENUMERATION          175
#define IDS_ERR_CREATE_INVALID_PARAM    182
#define IDS_ERR_CREATE_INVALID_OID      183
#define IDS_UNKNOWN                     187
#define IDS_MENU_REFRESH                188
#define IDS_STATUS_REFRESH              189
#define IDS_ERR_NO_UPDATE               190
#define IDS_ERR_NO_MEM                  191
#define IDS_SYNTAX_REPLICA_LINK         192
#define IDS_SYNTAX_GEN_TIME             193
#define IDS_ERR_CHANGE_REJECT           194
#define IDS_CLASS_88                    195
#define IDS_REGSERV_NAME                196
#define IDS_REGSERV_MICROSOFT           197
#define IDS_REGSERV_ABOUT               198
#define IDS_REGSERV_PROVIDER            199
#define IDS_REGSERV_VERSION             200
#define IDC_CLASS_GENERAL_DESCRIPTION_EDIT 201
#define IDS_SYNTAX_ACCESS_POINT         201
#define IDC_CLASS_GENERAL_NAME_STATIC   202
#define IDS_ERR_EDIT_MINMAX             202
#define IDC_CLASS_GENERAL_CATEGORY_COMBO 203
#define IDC_EDIT_CURRENT_DC             203
#define IDS_WARNING_DEFUNCT_SET         203
#define IDC_CLASS_GENERAL_DISPLAYABLE_CHECK 204
#define IDS_ERR_EDIT_GC                 204
#define IDC_RADIO_ANY                   204
#define IDC_CLASS_GENERAL_SYSCLASS_STATIC 205
#define IDS_ERR_CREATE_MINMAX           205
#define IDC_RADIO_SPECIFY               205
#define IDC_CLASS_REL_NAME_STATIC       206
#define IDS_ERR_EDIT_CATEGORY           206
#define IDC_EDIT_DC                     206
#define IDC_CLASS_REL_SYSCLASS_STATIC   207
#define IDS_MENU_RETARGET               207
#define IDC_EDIT_CURRENT_FSMO_DC        207
#define IDS_STATUS_RETARGET             208
#define IDC_CHANGE_FSMO                 208
#define IDC_ATTRIB_GENERAL_NAME_STATIC  209
#define IDS_MENU_EDIT_FSMO              209
#define IDC_ATTRIB_GENERAL_DESCRIPTION_EDIT 210
#define IDS_STATUS_EDIT_FSMO            210
#define IDC_STATIC_FSMO_STATUS          210
#define IDS_WARNING_CHANGE_FOCUS        211
#define IDS_CHANGE_FSMO_CONFIRMATION    212
#define IDS_CHANGE_FSMO_CONFIRMATION_FORCED 213
#define IDS_CHANGE_FSMO_SUCCESS         214
#define IDC_ATTRIB_GENERAL_SYSCLASS_STATIC 215
#define IDS_ERROR_CHANGE_FSMO_OWNER     215
#define IDD_CHANGE_DC                   216
#define IDS_MENU_SECURITY               216
#define IDD_EDIT_FSMO                   217
#define IDS_STATUS_SECURITY             217
#define IDC_ATTRIB_GENERAL_VALUE_STATIC 218
#define IDS_ERROR_CHANGE_FSMO_SCHEMA_REGISTRY 218
#define IDS_ERR_EDIT_DEFUNCT_SET        219
#define IDS_ERR_EDIT_DEFUNCT_REMOVE     220
#define IDI_ATTRIBUTE                   221
#define IDS_WARNING_DEFUNCT             221
#define IDC_ATTRIB_GENERAL_SYNTAX_EDIT  222
#define IDS_DEFAULT_SECURITY            222
#define IDC_ATTRIB_GENERAL_MIN_EDIT     223
#define IDS_DELETE_CLASS_PROMPT         223
#define IDI_CLASS                       224
#define IDS_DELETE_ATTR_PROMPT          224
#define IDC_ATTRIB_GENERAL_MAX_EDIT     225
#define IDI_GENERIC                     226
#define IDC_ATTRIB_GENERAL_OID_EDIT     226
#define IDC_CLASS_GENERAL_OID_EDIT      227
#define IDI_FOLDER_CLOSED               228
#define IDC_CREATE_ATTRIB_OID           228
#define IDC_CREATE_ATTRIB_CN            229
#define IDC_CREATE_ATTRIB_SYNTAX        230
#define IDB_CLASS                       231
#define IDD_CLASS_RELATIONSHIP          232
#define IDC_CREATE_ATTRIB_LDN           232
#define IDD_ATTRIB_GENERAL              233
#define IDC_CLASS_REL_PARENT_EDIT       233
#define IDC_CLASS_GENERAL_LDN           234
#define IDC_ATTRIB_GENERAL_LDN          235
#define IDD_CREATE_ATTRIBUTE            236
#define IDC_CREATE_ATTRIB_MIN           236
#define IDC_CREATE_ATTRIB_MAX           237
#define IDD_CREATE_CLASS_GENERAL        237
#define IDC_CREATE_CLASS_CN             238
#define IDC_CREATE_CLASS_LDN            239
#define IDC_CREATE_CLASS_OID            240
#define IDC_CREATE_CLASS_PARENT         241
#define IDC_CREATE_CLASS_TYPE           242
#define IDD_CLASS_ATTRIBUTES            243
#define IDB_CLASS_SMALL                 243
#define IDD_SCHEMA_SELECT               244
#define IDC_SCHEMA_LIST                 246
#define IDC_CATEGORY_EDIT               247
#define IDD_CREATE_WARN                 248
#define IDC_ATTRIB_GENERAL_REPLICATED   254
#define IDC_ATTRIB_GENERAL_ANR_CHECK    255
#define IDC_CATEGORY_CHANGE             256
#define IDC_ATTRIB_GENERAL_CPYATTR_CHECK 256
#define IDC_STATIC_MESSAGE              258
#define IDC_OPTIONAL_ADD                258
#define IDC_MANDATORY_LIST              259
#define IDC_OPTIONAL_LIST               260
#define IDC_MANDATORY_REMOVE            261
#define IDC_OPTIONAL_REMOVE             262
#define IDC_CREATE_ATTRIBUTE_PROMPT_STATIC 264
#define IDC_STATIC_FSMO_NOTE            265
#define IDC_DESCRIPTION_EDIT            266
#define IDC_ATTRIB_GENERAL_CONTAINERIZED_INDEX_CHECK 272
#define IDD_MSGBOX_OK_MOREINFO          426
#define IDD_CREATE_CLASS_ATTRIBUTES     427
#define IDC_CLASS_REL_AUX_ADD           1009
#define IDC_CLASS_REL_AUX_REMOVE        1010
#define IDC_CLASS_REL_SUPER_ADD         1011
#define IDC_CLASS_REL_SUPER_REMOVE      1012
#define IDC_ATTRIB_GENERAL_DISPLAYABLE_CHECK 1012
#define IDC_CLASS_REL_SUPER_CLASSES     1024
#define IDC_CLASS_REL_AUX_CLASSES       1025
#define IDC_CREATE_ATTRIB_VALUED        1026
#define IDC_ATTRIB_GENERAL_DEACTIVATE   1026
#define IDC_CLASS_DEACTIVATE            1026
#define IDC_ATTRIB_GENERAL_INDEX_CHECK  1027
#define IDC_STATIC_SYSTEMONLY_AUXILIARY 1028
#define IDC_STATIC_SYSTEMONLY_SUPERIOR  1029
#define IDC_CLASS_MMB_OPTIONAL_ADD      1030
#define IDC_CLASS_MMB_OPTIONAL_REMOVE   1031
#define IDC_MANDATORY_ADD               1031
#define IDC_CLASS_MMB_OPTIONAL_ATTRIBUTES 1034
#define IDC_CLASS_MMB_MANDATORY_ATTRIBUTES 1035
#define IDC_CLASS_MMB_SYSCLASS_STATIC   1038
#define IDC_CLASS_MMB_NAME_STATIC       1039
#define IDS_HTMLHELP_NAME               1040
#define IDS_MENU_NEW_CLASS              1041
#define IDS_MENU_NEW_ATTRIBUTE          1042
#define IDS_ERR_CANT_RETARGET           1043
#define IDS_ERR_CREATE_DEF_SD           1059
#define IDS_NEW_CLASS_PROP_SHEET_TITLE  1060
#define IDS_CREATE_CLASS_FINISH_BUTTON_TEXT 1061
#define IDS_MUST_ENTER_OID              1062
#define IDS_MUST_ENTER_CN               1063
#define IDS_UNKNOWN_ERROR_MESSAGE       1064
#define IDS_SCHEMA_NOT_FULLY_LOADED     1100
#define IDS_OID_FORMAT_INVALID          2000
#define IDS_OID_CONTAINS_NON_DIGITS     2001
#define IDS_OID_CONTAINS_CONSECUTIVE_DOTS 2002
#define IDS_OID_MUST_START_WITH_0_1_2   2003
#define IDS_OID_0_1_MUST_BE_0_TO_39     2004
#define IDS_OID_MUST_HAVE_TWO_NUMBERS   2005
#define IDS_OID_CANNOT_END_WITH_DOT     2006
#define IDS_LDAPDISPLAYNAME_FORMAT_ERROR 2007
#define IDI_CREATE_WARN                 32515

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        252
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         273
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\select.cpp ===
//
// select.cpp : Implementation of the common select dialog.
//
// Cory West <corywest@microsoft.com>
// Copyright (c) Microsoft Corporation 1997
//

#include "stdafx.h"

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(compdata.cpp)")

#include "schmutil.h"
#include "cache.h"
#include "select.h"
#include "resource.h"



const DWORD CSchmMgmtSelect::help_map[] =
{
    IDC_SCHEMA_LIST, IDH_SCHEMA_LIST,
    0,0
};



BEGIN_MESSAGE_MAP(CSchmMgmtSelect, CDialog)
   ON_MESSAGE(WM_HELP, OnHelp)
   ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
   ON_LBN_DBLCLK(IDC_SCHEMA_LIST, OnDblclk)
END_MESSAGE_MAP()



CSchmMgmtSelect::CSchmMgmtSelect(
    ComponentData *pScope,
    SELECT_TYPE st,
    SchemaObject **pSchemaObject
) :
    CDialog(IDD_SCHEMA_SELECT, NULL),
    fDialogLoaded( FALSE ),
    SelectType( st ),
    pSchemaTarget( pSchemaObject ),
    pScopeControl( pScope )
{
    ASSERT( NULL != pScopeControl );
}



CSchmMgmtSelect::~CSchmMgmtSelect()
{ ; }



void
CSchmMgmtSelect::DoDataExchange(
    CDataExchange *pDX
) {

    HWND hSelect;
    SchemaObject *pObject, *pHead;
    LRESULT strIndex;
    WPARAM wStrIndex;

    CDialog::DoDataExchange( pDX );

    hSelect = ::GetDlgItem( m_hWnd, IDC_SCHEMA_LIST );

    if ( !pDX->m_bSaveAndValidate &&
         !fDialogLoaded ) {

        //
        // Load the select box.
        //

        if ( hSelect != NULL ) {

            ::SendMessage( hSelect, LB_RESETCONTENT, 0, 0 );

            if ( SelectType == SELECT_CLASSES || 
                SelectType == SELECT_AUX_CLASSES) {

                //
                // Insert the sorted classes.
                //

                pObject = pScopeControl->g_SchemaCache.pSortedClasses;
                ASSERT( pObject != NULL );

                pHead = pObject;

                if( pHead )
                {
                    do {
                        // if not defunct & if selecting only Aux, is this an aux class.
                        if ( pObject->isDefunct == FALSE &&
                              ( SelectType != SELECT_AUX_CLASSES ||
                                pObject->dwClassType == 0        ||
                                pObject->dwClassType == 3  )
                            ) {

                            strIndex = ::SendMessage( hSelect, LB_ADDSTRING, 0,
                                reinterpret_cast<LPARAM>( (LPCTSTR)pObject->ldapDisplayName) );

                            if ( ( strIndex != LB_ERR ) &&
                                 ( strIndex != LB_ERRSPACE ) ) {

                                //
                                // The insert was successful.  Associate the pointer.
                                //

                                wStrIndex = strIndex;

                                ::SendMessage( hSelect, LB_SETITEMDATA, wStrIndex,
                                    reinterpret_cast<LPARAM>( pObject ) );

                            }
                        }

                        pObject = pObject->pSortedListFlink;

                    } while ( pObject != pHead );
                }

            } else {

                //
                // Insert the sorted attributes.
                //

                pObject = pScopeControl->g_SchemaCache.pSortedAttribs;
                ASSERT( pObject != NULL );

                pHead = pObject;

                do {

                    if ( pObject->isDefunct == FALSE ) {

                        strIndex = ::SendMessage( hSelect, LB_ADDSTRING, 0,
                            reinterpret_cast<LPARAM>( (LPCTSTR)pObject->ldapDisplayName ) );

                        if ( ( strIndex != LB_ERR ) &&
                             ( strIndex != LB_ERRSPACE ) ) {

                            //
                            // The insert was successful.  Associate the pointer.
                            //

                            wStrIndex = strIndex;

                            ::SendMessage( hSelect, LB_SETITEMDATA, wStrIndex,
                                reinterpret_cast<LPARAM>( pObject ) );

                        }
                    }

                    pObject = pObject->pSortedListFlink;

                } while ( pObject != pHead );

            }

            ::SendMessage( hSelect, LB_SETCURSEL, 0, 0 );
        }

        fDialogLoaded = TRUE;
    }

    //
    // Figure out which one was selected.
    //

    if ( pSchemaTarget ) {
        strIndex = ::SendMessage( hSelect, LB_GETCURSEL, 0, 0 );
        *pSchemaTarget = reinterpret_cast<SchemaObject*>(
            ::SendMessage( hSelect, LB_GETITEMDATA, strIndex, 0 ) );
    }

    return;
}



void CSchmMgmtSelect::OnDblclk() 
{
    OnOK();
}



CSchemaObjectsListBox::CSchemaObjectsListBox() :
    m_pScope                ( NULL           ),
    m_stType                ( SELECT_CLASSES ),
    m_nRemoveBtnID          ( 0              ),
    m_pstrlistUnremovable   ( NULL           ),
    m_nUnableToDeleteID     ( 0              ),
    m_fModified             ( FALSE          )

{
}


CSchemaObjectsListBox::~CSchemaObjectsListBox()
{
    POSITION pos = m_stringList.GetHeadPosition();

    while( pos != NULL )
    {
        delete m_stringList.GetNext( pos );
    }

    m_stringList.RemoveAll();
}


void CSchemaObjectsListBox::InitType(
                              ComponentData * pScope,
                              SELECT_TYPE     stType,               /* = SELECT_CLASSES*/
                              int             nRemoveBtnID,         /* = 0*/
                              CStringList   * pstrlistUnremovable,  /* = NULL*/
                              int             nUnableToDeleteID)    /* = 0*/
{
    ASSERT( pScope );
    
    // if nUnableToDeleteID is present, pstrlistUnremovable cannot be NULL
    ASSERT( nUnableToDeleteID ? NULL != pstrlistUnremovable : TRUE  );
    
    m_pScope                = pScope;
    m_stType                = stType;
    m_nRemoveBtnID          = nRemoveBtnID;
    m_pstrlistUnremovable   = pstrlistUnremovable;
    m_nUnableToDeleteID     = nUnableToDeleteID;
}



//
// Add a new object to the listbox.
//

BOOL CSchemaObjectsListBox::AddNewObjectToList( void )
{
    ASSERT( m_pScope );     // initialized??

    SchemaObject  * pClass      = NULL;
    BOOL            fModified   = FALSE;

    //
    // Start the common select dialog box.
    //

    CSchmMgmtSelect dlgSelectDialog( m_pScope, m_stType, &pClass );

    //
    // When this returns, the class schema object pointer
    // will be filled into pClass.
    //
    
    if ( IDOK == dlgSelectDialog.DoModal() && pClass != NULL )
    {
        //
        // If it is not already present, add and select it.
        // If it is already present, just select it.
        //
        
        int iItem = FindStringExact( -1, pClass->ldapDisplayName );
        
        if (LB_ERR == iItem)
        {
            
            iItem = FindStringExact( -1, pClass->oid );
            
            if ( LB_ERR == iItem )
            {
                iItem = AddString( pClass->ldapDisplayName );
                ASSERT( LB_ERR != iItem );
                
                CString * pstr = new CString( pClass->oid );
                ASSERT( pstr );
                
                m_stringList.AddTail( pstr );
                VERIFY( LB_ERR != SetItemDataPtr( iItem, static_cast<void *>(pstr) ) );

                SetModified();
                fModified = TRUE;
            }
        }
        
        iItem = SetCurSel( iItem );
        ASSERT( LB_ERR != iItem );
        OnSelChange();
    }

    return fModified;
}



BOOL CSchemaObjectsListBox::RemoveListBoxItem( void )
{
    ASSERT(m_pScope); 

    int i = GetCurSel();
    ASSERT( LB_ERR != i );
    
    if( LB_ERR != i )
    {
        // if there is an oid string allocated, delete it.
        CString * pstr = reinterpret_cast<CString *>( GetItemDataPtr( i ) );
        ASSERT( INVALID_POINTER != pstr );

        if( pstr && INVALID_POINTER != pstr )
        {
            ASSERT( m_stringList.Find( pstr ) );
            m_stringList.RemoveAt( m_stringList.Find(pstr) );
            delete pstr;
        }

        VERIFY( LB_ERR != DeleteString( i ) );

        
        int nElems = GetCount();
        ASSERT( LB_ERR != nElems );

        if( nElems > 0 )
        {                   // if not last item, move forward, otherwise, go to last.
            VERIFY( LB_ERR != SetCurSel( i < nElems ? i : nElems - 1 ) );
        }

        SetModified();
        OnSelChange();
        return TRUE;
    }
    else
    {
        ASSERT( FALSE );    // remove btn should've been disabled
        OnSelChange();
        return FALSE;
    }
}



void CSchemaObjectsListBox::OnSelChange( void )
{
    ASSERT(m_pScope);
    ASSERT( GetParent() );

    int iItemSelected   = GetCurSel();
    BOOL fEnableRemove  = (LB_ERR != iItemSelected);
    
    if (fEnableRemove && m_pstrlistUnremovable)
    {
        // determine if object is in the exception list
        CString strItemSelected;
        GetText( iItemSelected, strItemSelected );
        
        // here the case sensitive search is enough
        // only items from the DS are added, no user input
        if ( m_pstrlistUnremovable->Find( strItemSelected ) )
        {
            fEnableRemove = FALSE;
        }

        // if we have a warning control, show/hide it.
        if( m_nUnableToDeleteID )
        {
            ASSERT( GetParent()->GetDlgItem( m_nUnableToDeleteID ) );
            GetParent()->GetDlgItem( m_nUnableToDeleteID )->ShowWindow( !fEnableRemove );
        }
    }

    if( m_nRemoveBtnID )
    {
        ASSERT( GetParent()->GetDlgItem( m_nRemoveBtnID ) );
        GetParent()->GetDlgItem( m_nRemoveBtnID )->EnableWindow( fEnableRemove );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\schmutil.cpp ===
/****

SchmUtil.cpp

Various common utility routines for the Schema Editor Snap-In.

****/

#include "stdafx.h"

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(schmutil.cpp)")

#include "resource.h"
#include "cache.h"
#include "schmutil.h"
#include "compdata.h"

#include <wincrypt.h>  // CryptEncodeObject() and CryptDecodeObject()

//
// Removed from public headers by DS guys
// See bug 454342	XOM will not survive the transition to Win64
//
//#include <xom.h>

//
// Global strings for classes and attributes in the DS.
// These are NOT subject to localization.
//

LPWSTR g_DisplayName =          L"ldapDisplayName";
LPWSTR g_ClassFilter =          L"classSchema";
LPWSTR g_AttributeFilter =      L"attributeSchema";
LPWSTR g_Description =          L"adminDescription";
LPWSTR g_MayContain =           L"mayContain";
LPWSTR g_MustContain =          L"mustContain";
LPWSTR g_SystemMayContain =     L"systemMayContain";
LPWSTR g_SystemMustContain =    L"systemMustContain";
LPWSTR g_AuxiliaryClass =       L"auxiliaryClass";
LPWSTR g_SystemAuxiliaryClass = L"systemAuxiliaryClass";
LPWSTR g_SubclassOf =           L"subclassOf";
LPWSTR g_ObjectClassCategory =  L"objectClassCategory";
LPWSTR g_ObjectClass =			L"objectClass";
LPWSTR g_omObjectClass =        L"oMObjectClass";
LPWSTR g_CN =                   L"CN";
LPWSTR g_omSyntax =             L"oMSyntax";
LPWSTR g_AttributeSyntax =      L"attributeSyntax";
LPWSTR g_SystemOnly =           L"systemOnly";
LPWSTR g_Superiors =            L"possSuperiors";
LPWSTR g_SystemSuperiors =      L"systemPossSuperiors";
LPWSTR g_GlobalClassID =        L"governsID";
LPWSTR g_GlobalAttributeID =    L"attributeID";
LPWSTR g_RangeUpper =           L"rangeUpper";
LPWSTR g_RangeLower =           L"rangeLower";
LPWSTR g_IsSingleValued =       L"isSingleValued";
LPWSTR g_IndexFlag =            L"searchFlags";
LPWSTR g_ShowInAdvViewOnly =    L"showInAdvancedViewOnly";
LPWSTR g_UpdateSchema =         LDAP_OPATT_SCHEMA_UPDATE_NOW_W;
LPWSTR g_BecomeFsmo =           LDAP_OPATT_BECOME_SCHEMA_MASTER_W;
LPWSTR g_isDefunct =              L"isDefunct";
LPWSTR g_GCReplicated =         L"isMemberOfPartialAttributeSet";
LPWSTR g_DefaultAcl =           L"defaultSecurityDescriptor";
LPWSTR g_DefaultCategory =      L"defaultObjectCategory";
LPWSTR g_systemFlags =          L"systemFlags";
LPWSTR g_fsmoRoleOwner =        L"fsmoRoleOwner";

LPWSTR g_allowedChildClassesEffective = L"allowedChildClassesEffective";
LPWSTR g_allowedAttributesEffective =   L"allowedAttributesEffective";


LPWSTR g_ClassSearchRequest =   L"objectClass=classSchema";
LPWSTR g_AttribSearchRequest =  L"objectClass=attributeSchema";

//
// Syntax values.  Not subject to localization.
//

class CSyntaxDescriptor g_Syntax[] =
{
 /*SYNTAX_DISTNAME_TYPE                       */ CSyntaxDescriptor( IDS_SYNTAX_DN,          FALSE, FALSE, _T("2.5.5.1") , /*OM_S_OBJECT                    */  127, 9, (LPBYTE)"\x2B\x0C\x02\x87\x73\x1C\x00\x85\x4A" ),
 /*SYNTAX_OBJECT_ID_TYPE                      */ CSyntaxDescriptor( IDS_SYNTAX_OID,         FALSE, FALSE, _T("2.5.5.2") , /*OM_S_OBJECT_IDENTIFIER_STRING  */  6  , 0, NULL ),
 /*SYNTAX_NOCASE_STRING_TYPE                  */ CSyntaxDescriptor( IDS_SYNTAX_NOCASE_STR,  FALSE, TRUE,  _T("2.5.5.4") , /*OM_S_TELETEX_STRING            */  20 , 0, NULL ),
 /*SYNTAX_PRINT_CASE_STRING_TYPE              */ CSyntaxDescriptor( IDS_SYNTAX_PRCS_STR,    FALSE, TRUE,  _T("2.5.5.5") , /*OM_S_PRINTABLE_STRING          */  19 , 0, NULL ),
 /*SYNTAX_PRINT_CASE_STRING_TYPE              */ CSyntaxDescriptor( IDS_SYNTAX_I5_STR,      FALSE, TRUE,  _T("2.5.5.5") , /*OM_S_IA5_STRING                */  22 , 0, NULL ),
 /*SYNTAX_NUMERIC_STRING_TYPE                 */ CSyntaxDescriptor( IDS_SYNTAX_NUMSTR,      FALSE, FALSE, _T("2.5.5.6") , /*OM_S_NUMERIC_STRING            */  18 , 0, NULL ),
 /*SYNTAX_DISTNAME_BINARY_TYPE (OR-Name)      */ CSyntaxDescriptor( IDS_SYNTAX_OR_NAME,     FALSE, FALSE, _T("2.5.5.7") , /*OM_S_OBJECT                    */  127, 7, (LPBYTE)"\x56\x06\x01\x02\x05\x0B\x1D" ),
 /*SYNTAX_DISTNAME_BINARY_TYPE (DN-Binary)    */ CSyntaxDescriptor( IDS_SYNTAX_DN_BINARY,   FALSE, FALSE, _T("2.5.5.7") , /*OM_S_OBJECT                    */  127, 10,(LPBYTE)"\x2A\x86\x48\x86\xF7\x14\x01\x01\x01\x0B" ),
 /*SYNTAX_BOOLEAN_TYPE                        */ CSyntaxDescriptor( IDS_SYNTAX_BOOLEAN,     FALSE, FALSE, _T("2.5.5.8") , /*OM_S_BOOLEAN                   */  1  , 0, NULL ),
 /*SYNTAX_INTEGER_TYPE                        */ CSyntaxDescriptor( IDS_SYNTAX_INTEGER,      TRUE, FALSE, _T("2.5.5.9") , /*OM_S_INTEGER                   */  2  , 0, NULL ),
 /*SYNTAX_INTEGER_TYPE                        */ CSyntaxDescriptor( IDS_SYNTAX_ENUMERATION,  TRUE, FALSE, _T("2.5.5.9") , /*OM_S_ENUMERATION               */  10 , 0, NULL ),
 /*SYNTAX_OCTET_STRING_TYPE                   */ CSyntaxDescriptor( IDS_SYNTAX_OCTET,       FALSE, FALSE, _T("2.5.5.10"), /*OM_S_OCTET_STRING              */  4  , 0, NULL ),
 /*SYNTAX_OCTET_STRING_TYPE                   */ CSyntaxDescriptor( IDS_SYNTAX_REPLICA_LINK,FALSE, FALSE, _T("2.5.5.10"), /*OM_S_OBJECT                    */  127, 10,(LPBYTE)"\x2A\x86\x48\x86\xF7\x14\x01\x01\x01\x06" ),
 /*SYNTAX_TIME_TYPE                           */ CSyntaxDescriptor( IDS_SYNTAX_UTC,         FALSE, FALSE, _T("2.5.5.11"), /*OM_S_UTC_TIME_STRING           */  23 , 0, NULL ),
 /*SYNTAX_TIME_TYPE                           */ CSyntaxDescriptor( IDS_SYNTAX_GEN_TIME,    FALSE, FALSE, _T("2.5.5.11"), /*OM_S_GENERALISED_TIME_STRING   */  24 , 0, NULL ),
 /*SYNTAX_UNICODE_TYPE                        */ CSyntaxDescriptor( IDS_SYNTAX_UNICODE,     FALSE, TRUE,  _T("2.5.5.12"), /*OM_S_UNICODE_STRING            */  64 , 0, NULL ),
 /*SYNTAX_ADDRESS_TYPE                        */ CSyntaxDescriptor( IDS_SYNTAX_ADDRESS,     FALSE, FALSE, _T("2.5.5.13"), /*OM_S_OBJECT                    */  127, 9, (LPBYTE)"\x2B\x0C\x02\x87\x73\x1C\x00\x85\x5C" ),
 /*SYNTAX_DISTNAME_STRING_TYPE (Access-Point) */ CSyntaxDescriptor( IDS_SYNTAX_ACCESS_POINT,FALSE, FALSE, _T("2.5.5.14"), /*OM_S_OBJECT                    */  127, 9, (LPBYTE)"\x2B\x0C\x02\x87\x73\x1C\x00\x85\x3E" ),
 /*SYNTAX_DISTNAME_STRING_TYPE (DN-String)    */ CSyntaxDescriptor( IDS_SYNTAX_DNSTRING,    FALSE, FALSE, _T("2.5.5.14"), /*OM_S_OBJECT                    */  127, 10,(LPBYTE)"\x2A\x86\x48\x86\xF7\x14\x01\x01\x01\x0C" ),
 /*SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE         */ CSyntaxDescriptor( IDS_SYNTAX_SEC_DESC,    FALSE, FALSE, _T("2.5.5.15"), /*OM_S_OBJECT_SECURITY_DESCRIPTOR*/  66 , 0, NULL ),
 /*SYNTAX_I8_TYPE                             */ CSyntaxDescriptor( IDS_SYNTAX_LINT,        FALSE, FALSE, _T("2.5.5.16"), /*OM_S_I8                        */  65 , 0, NULL ),
 /*SYNTAX_SID_TYPE                            */ CSyntaxDescriptor( IDS_SYNTAX_SID,         FALSE, FALSE, _T("2.5.5.17"), /*OM_S_OCTET_STRING              */  4  , 0, NULL ),
 /*   *** unknown -- must be last ***         */ CSyntaxDescriptor( IDS_SYNTAX_UNKNOWN,     FALSE, TRUE,  NULL,                                                0  , 0, NULL ),
};

const UINT SCHEMA_SYNTAX_UNKNOWN = sizeof( g_Syntax ) / sizeof( g_Syntax[0] ) - 1;


// Number formating printf strings
const LPWSTR g_UINT32_FORMAT	= L"%u";

#ifdef ENABLE_NEGATIVE_INT
    const LPWSTR g_INT32_FORMAT		= L"%d";
#else
	// if there is no negative numbers support, format as unsigned
    const LPWSTR g_INT32_FORMAT		= g_UINT32_FORMAT;
#endif





//
// *******************************************************************
// These are loaded from the resources as they need to be localizable.
// *******************************************************************
//

//
// Global strings for our static nodes.
//

CString g_strSchmMgmt;
CString g_strClasses;
CString g_strAttributes;

//
// Strings for various object types.
//

CString g_88Class;
CString g_StructuralClass;
CString g_AuxClass;
CString g_AbstractClass;
CString g_MandatoryAttribute;
CString g_OptionalAttribute;
CString g_Yes;
CString g_No;
CString g_Unknown;
CString g_Defunct;
CString g_Active;

//
// Message strings.
//

CString g_NoDescription;
CString g_NoName;
CString g_MsgBoxErr;
CString g_MsgBoxWarn;
CString g_SysClassString;
CString g_SysAttrString;

//
// Menu strings.
//

CString g_MenuStrings[MENU_LAST_COMMAND];
CString g_StatusStrings[MENU_LAST_COMMAND];

BOOL g_fScopeStringsLoaded = FALSE;

//
// Utility functions.
//

void
LoadGlobalCookieStrings(
)
/***

Load the global strings out of our resource table.

***/
{
   if ( !g_fScopeStringsLoaded )
   {
      //
      // Static node strings.
      //

      VERIFY( g_strSchmMgmt.LoadString(IDS_SCOPE_SCHMMGMT) );
      VERIFY( g_strClasses.LoadString(IDS_SCOPE_CLASSES) );
      VERIFY( g_strAttributes.LoadString(IDS_SCOPE_ATTRIBUTES) );

      //
      // Object name strings.
      //

      VERIFY( g_88Class.LoadString(IDS_CLASS_88) );
      VERIFY( g_StructuralClass.LoadString(IDS_CLASS_STRUCTURAL) );
      VERIFY( g_AuxClass.LoadString(IDS_CLASS_AUXILIARY) );
      VERIFY( g_AbstractClass.LoadString(IDS_CLASS_ABSTRACT) );
      VERIFY( g_MandatoryAttribute.LoadString(IDS_ATTRIBUTE_MANDATORY) );
      VERIFY( g_OptionalAttribute.LoadString(IDS_ATTRIBUTE_OPTIONAL) );
      VERIFY( g_Yes.LoadString(IDS_YES) );
      VERIFY( g_No.LoadString(IDS_NO) );
      VERIFY( g_Unknown.LoadString(IDS_UNKNOWN) );
      VERIFY( g_Defunct.LoadString(IDS_DEFUNCT) );
      VERIFY( g_Active.LoadString(IDS_ACTIVE) );

      //
      // Message strings.
      //

      VERIFY( g_NoDescription.LoadString(IDS_ERR_NO_DESCRIPTION) );
      VERIFY( g_NoName.LoadString(IDS_ERR_NO_NAME) );
      VERIFY( g_MsgBoxErr.LoadString(IDS_ERR_ERROR) );
      VERIFY( g_MsgBoxWarn.LoadString(IDS_ERR_WARNING) );
      VERIFY( g_SysClassString.LoadString(IDS_CLASS_SYSTEM) );
      VERIFY( g_SysAttrString.LoadString(IDS_ATTR_SYSTEM) );

      //
      // Syntax strings.
      //

      for( UINT i = 0;  i <= SCHEMA_SYNTAX_UNKNOWN;  i++ )
      {
         ASSERT( g_Syntax[i].m_nResourceID );
         VERIFY( g_Syntax[i].m_strSyntaxName.LoadString( g_Syntax[i].m_nResourceID ) );
      }
      

      //
      // Menu Strings
      //

      VERIFY( g_MenuStrings[CLASSES_CREATE_CLASS].LoadString(IDS_MENU_CLASS) );
      VERIFY( g_MenuStrings[NEW_CLASS].LoadString(IDS_MENU_NEW_CLASS) );
      VERIFY( g_MenuStrings[ATTRIBUTES_CREATE_ATTRIBUTE].LoadString(
        IDS_MENU_ATTRIBUTE) );
      VERIFY(g_MenuStrings[NEW_ATTRIBUTE].LoadString(IDS_MENU_NEW_ATTRIBUTE));

      VERIFY( g_MenuStrings[SCHEMA_RETARGET].LoadString(IDS_MENU_RETARGET) );
      VERIFY( g_MenuStrings[SCHEMA_EDIT_FSMO].LoadString(IDS_MENU_EDIT_FSMO) );
      VERIFY( g_MenuStrings[SCHEMA_REFRESH].LoadString(IDS_MENU_REFRESH) );
      VERIFY( g_MenuStrings[SCHEMA_SECURITY].LoadString(IDS_MENU_SECURITY) );


      VERIFY( g_StatusStrings[CLASSES_CREATE_CLASS].LoadString(
                 IDS_STATUS_CREATE_CLASS) );
      VERIFY( g_StatusStrings[ATTRIBUTES_CREATE_ATTRIBUTE].LoadString(
                 IDS_STATUS_CREATE_ATTRIBUTE) );
      VERIFY( g_StatusStrings[NEW_CLASS].LoadString(
                 IDS_STATUS_CREATE_CLASS) );
      VERIFY( g_StatusStrings[NEW_ATTRIBUTE].LoadString(
                 IDS_STATUS_CREATE_ATTRIBUTE) );
      VERIFY( g_StatusStrings[SCHEMA_RETARGET].LoadString(IDS_STATUS_RETARGET) );
      VERIFY( g_StatusStrings[SCHEMA_EDIT_FSMO].LoadString(IDS_STATUS_EDIT_FSMO) );
      VERIFY( g_StatusStrings[SCHEMA_REFRESH].LoadString(IDS_STATUS_REFRESH) );
      VERIFY( g_StatusStrings[SCHEMA_SECURITY].LoadString(IDS_STATUS_SECURITY) );

      g_fScopeStringsLoaded = TRUE;
   }
}

INT
DoErrMsgBox(
    HWND hwndParent,    // IN: Parent of the dialog box
    BOOL fError,        // IN: Is this a warning or an error?
    UINT wIdString      // IN: String resource Id of the error.
)
/***

    Display a message box with the error.

***/
{
    CString Error;

    VERIFY( Error.LoadString( wIdString ) );

	return DoErrMsgBox( hwndParent, fError, Error );
}


INT
DoErrMsgBox(
    HWND hwndParent,    // IN: Parent of the dialog box
    BOOL fError,        // IN: Is this a warning or an error?
    PCWSTR pszError     // IN: String to display.
)
/***

    Display a message box with the error.

***/
{
	return MessageBox(
                    hwndParent,
                    pszError,
                    (fError ? g_MsgBoxErr : g_MsgBoxWarn),
                    (fError ? MB_ICONSTOP : MB_ICONEXCLAMATION) | MB_OK
                     );
}


HRESULT
ComponentData::ForceDsSchemaCacheUpdate(
    VOID
)
/***

    Force the schema container to reload its interal cache.
    If this succeeds, it returns TRUE.  Otherwise, it returns
    FALSE.

***/
{

    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    CWaitCursor wait;
    CString RootDsePath;
    IADs *pSchemaRootDse = NULL;

    SAFEARRAYBOUND RootDseBoundary[1];
    SAFEARRAY* pSafeArray = NULL;
    VARIANT AdsArray, AdsValue;
    long ArrayLen = 1;
    long ArrayPos = 0;
    HRESULT hr = S_OK;


    do
    {
        //
        // Open the root DSE on the current focus server.
        //

        GetBasePathsInfo()->GetRootDSEPath(RootDsePath);

        hr = ADsGetObject(
                 ( const_cast<BSTR>((LPCTSTR) RootDsePath ) ),
                 IID_IADs,
                 (void **)&pSchemaRootDse );

        BREAK_ON_FAILED_HRESULT(hr);

        //
        // Create the safe array for the PutEx call.
        //

        RootDseBoundary[0].lLbound = 0;
        RootDseBoundary[0].cElements = ArrayLen;

        pSafeArray = SafeArrayCreate( VT_VARIANT, ArrayLen, RootDseBoundary );
        BREAK_ON_FAILED_HRESULT(hr);

        VariantInit( &AdsArray );
        V_VT( &AdsArray ) = VT_ARRAY | VT_VARIANT;
        V_ARRAY( &AdsArray ) = pSafeArray;

        VariantInit( &AdsValue );

        V_VT(&AdsValue) = VT_I4;
        V_I4(&AdsValue) = 1;

        hr = SafeArrayPutElement( pSafeArray, &ArrayPos, &AdsValue );
        BREAK_ON_FAILED_HRESULT(hr);

        //
        // Write the update parameter.  This is synchronous
        // and when it returns, the cache is up to date.
        //

        hr = pSchemaRootDse->PutEx( ADS_PROPERTY_APPEND,
                                    const_cast<BSTR>((LPCTSTR)g_UpdateSchema),
                                    AdsArray );
        BREAK_ON_FAILED_HRESULT(hr);

        hr = pSchemaRootDse->SetInfo();
        BREAK_ON_FAILED_HRESULT(hr);

    } while( FALSE );

   
    SafeArrayDestroy( pSafeArray );

    if( pSchemaRootDse )
        pSchemaRootDse->Release();

    return hr;
}

BOOLEAN
ComponentData::AsynchForceDsSchemaCacheUpdate(
    VOID
) {

    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    CWaitCursor wait;
    CString szSchemaContainerPath;
    IADs *pSchemaContainer;
    VARIANT AdsValue;
    HRESULT hr;
    SYSTEMTIME CurrentTime;
    double variant_time;

    //
    // Get the schema container path.
    //

    GetBasePathsInfo()->GetSchemaPath(szSchemaContainerPath);

    if (szSchemaContainerPath.IsEmpty() ) {
        return FALSE;
    }

    //
    // Open the schema container.
    //

    hr = ADsGetObject(
             (LPWSTR)(LPCWSTR)szSchemaContainerPath,
             IID_IADs,
             (void **)&pSchemaContainer );

    if ( FAILED(hr) ) {
        return FALSE;
    }

    //
    // Write the update parameter.
    //

    GetSystemTime( &CurrentTime );
    BOOL result = SystemTimeToVariantTime( &CurrentTime, &variant_time );

    ASSERT( result );

    VariantInit( &AdsValue );

    V_VT(&AdsValue) = VT_DATE;
    V_DATE(&AdsValue) = variant_time;

    hr = pSchemaContainer->Put( const_cast<BSTR>((LPCTSTR)g_UpdateSchema),
                                AdsValue );
    ASSERT( SUCCEEDED( hr ) );

    hr = pSchemaContainer->SetInfo();

    pSchemaContainer->Release();

    if ( FAILED( hr ) ) {
        return FALSE;
    }

    return TRUE;
}


HRESULT
InsertEditItems(
    HWND hwnd,
    VARIANT *AdsResult
) {

    HRESULT hr;
    SAFEARRAY *saAttributes;
    long start, end, current;
    VARIANT SingleResult;

    //
    // Check the VARIANT to make sure we have
    // an array of variants.
    //

    ASSERT( V_VT(AdsResult) == ( VT_ARRAY | VT_VARIANT ) );
    saAttributes = V_ARRAY( AdsResult );

    //
    // Figure out the dimensions of the array.
    //

    hr = SafeArrayGetLBound( saAttributes, 1, &start );

    if ( FAILED(hr) ) {
        return S_FALSE;
    }

    hr = SafeArrayGetUBound( saAttributes, 1, &end );

    if ( FAILED(hr) ) {
        return S_FALSE;
    }

    VariantInit( &SingleResult );

    //
    // Process the array elements.
    //

    for ( current = start       ;
          current <= end        ;
          current++   ) {

        hr = SafeArrayGetElement( saAttributes, &current, &SingleResult );

        if ( SUCCEEDED( hr ) ) {

            ASSERT( V_VT(&SingleResult) == VT_BSTR );

            ::SendMessage( hwnd, LB_ADDSTRING, 0,
                           reinterpret_cast<LPARAM>(V_BSTR(&SingleResult)) );

            ::SendMessage( hwnd, LB_SETITEMDATA, 0, NULL );
             
            VariantClear( &SingleResult );
        }
    }

    return S_OK;

}

HRESULT
InsertEditItems(
    CListBox& refListBox,
    CStringList& refstringlist
)
{
    POSITION pos = refstringlist.GetHeadPosition();
    while (pos != NULL)
    {
        int iItem = refListBox.AddString( refstringlist.GetNext(pos) );
        if (0 > iItem)
        {
            ASSERT(FALSE);
            return E_OUTOFMEMORY;
        }
        else
        {
            VERIFY( LB_ERR != refListBox.SetItemDataPtr( iItem, NULL ) );
        }
    }
    return S_OK;
}


inline BOOL
IsEqual( ADS_OCTET_STRING * ostr1, ADS_OCTET_STRING * ostr2 )
{
   ASSERT(ostr1);
   ASSERT(ostr2);

   if( ostr1->dwLength == ostr2->dwLength )
   {
      if( 0 == ostr1->dwLength )
         return TRUE;
      else
         return !memcmp( ostr1->lpValue, ostr2->lpValue, ostr1->dwLength );
   }
   else
      return FALSE;
}


UINT
GetSyntaxOrdinal( PCTSTR attributeSyntax, UINT omSyntax, ADS_OCTET_STRING * pOmObjectClass )
{
      ASSERT( attributeSyntax );
      ASSERT( omSyntax );
      ASSERT( pOmObjectClass );

    //
    // Return the syntax ordinal, or the unknown syntax ordinal.
    //

    UINT Ordinal = 0;

    while ( Ordinal < SCHEMA_SYNTAX_UNKNOWN) {

        if ( !_tcscmp(g_Syntax[Ordinal].m_pszAttributeSyntax, attributeSyntax))
        {
           if( omSyntax && g_Syntax[Ordinal].m_nOmSyntax == omSyntax &&
                  IsEqual( &g_Syntax[Ordinal].m_octstrOmObjectClass, pOmObjectClass ) )
              break;
        }

        Ordinal++;
    }

    return Ordinal;
}


// Coded to fail on anything suspicious
HRESULT
VariantToStringList(
    VARIANT& refvar,
        CStringList& refstringlist
)
{
    HRESULT hr = S_OK;
    long start, end, current;

    //
    // Check the VARIANT to make sure we have
    // an array of variants.
    //

    if ( V_VT(&refvar) != ( VT_ARRAY | VT_VARIANT ) )
        {
                ASSERT(FALSE);
                return E_UNEXPECTED;
        }
    SAFEARRAY *saAttributes = V_ARRAY( &refvar );

    //
    // Figure out the dimensions of the array.
    //

    hr = SafeArrayGetLBound( saAttributes, 1, &start );
        if( FAILED(hr) )
                return hr;

    hr = SafeArrayGetUBound( saAttributes, 1, &end );
        if( FAILED(hr) )
                return hr;

    VARIANT SingleResult;
    VariantInit( &SingleResult );

    //
    // Process the array elements.
    //

    for ( current = start       ;
          current <= end        ;
          current++   ) {

        hr = SafeArrayGetElement( saAttributes, &current, &SingleResult );
        if( FAILED(hr) )
            return hr;
        if ( V_VT(&SingleResult) != VT_BSTR )
                        return E_UNEXPECTED;

                refstringlist.AddHead( V_BSTR(&SingleResult) );
        VariantClear( &SingleResult );
    }

    return S_OK;
}

HRESULT
StringListToVariant(
    VARIANT& refvar,
    CStringList& refstringlist
)
{
    HRESULT hr = S_OK;
    int cCount = (int) refstringlist.GetCount();

    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = cCount;

    SAFEARRAY* psa = SafeArrayCreate(VT_VARIANT, 1, rgsabound);
    if (NULL == psa)
        return E_OUTOFMEMORY;

    VariantClear( &refvar );
    V_VT(&refvar) = VT_VARIANT|VT_ARRAY;
    V_ARRAY(&refvar) = psa;

    VARIANT SingleResult;
    VariantInit( &SingleResult );
    V_VT(&SingleResult) = VT_BSTR;
    POSITION pos = refstringlist.GetHeadPosition();
    long i;
    for (i = 0; i < cCount, pos != NULL; i++)
    {
        V_BSTR(&SingleResult) = T2BSTR((LPCTSTR)refstringlist.GetNext(pos));
        hr = SafeArrayPutElement(psa, &i, &SingleResult);
        if( FAILED(hr) )
            return hr;
    }
    if (i != cCount || pos != NULL)
        return E_UNEXPECTED;

    return hr;
}

HRESULT
StringListToColumnList(
    ComponentData* pScopeControl,
    CStringList& refstringlist,
    ListEntry **ppNewList
) {

    //
    // Make a column list from a string list.  We use
    // this to update the cached attributes lists.
    //

    int cCount = (int) refstringlist.GetCount();
    ListEntry *pHead = NULL;
    ListEntry *pCurrent = NULL, *pPrevious = NULL;
    POSITION pos = refstringlist.GetHeadPosition();
    CString Name;
    SchemaObject *pSchemaObject, *pSchemaHead;
    BOOLEAN fNameFound;

    for ( long i = 0; i < cCount, pos != NULL; i++ ) {

        pCurrent = new ListEntry;
        if ( !pCurrent ) {
            pScopeControl->g_SchemaCache.FreeColumnList( pHead );
            return E_OUTOFMEMORY;
        }

        if ( !pHead ) {

            pHead = pPrevious = pCurrent;

        } else {

            pPrevious->pNext = pCurrent;
            pPrevious = pCurrent;
        }

        //
        // We need to list all of these by their ldapDisplayNames,
        // so we have to reverse lookup the oid entries.
        //

        Name = ((LPCTSTR)refstringlist.GetNext(pos));
        pSchemaObject = pScopeControl->g_SchemaCache.LookupSchemaObject(
                                                         Name,
                                                         SCHMMGMT_CLASS );

        if ( !pSchemaObject ) {

            pSchemaObject = pScopeControl->g_SchemaCache.LookupSchemaObject(
                                                             Name,
                                                             SCHMMGMT_ATTRIBUTE );

            if ( !pSchemaObject) {

                //
                // We have to look up this oid.
                // First try the list of classes.
                //

                pSchemaHead = pScopeControl->g_SchemaCache.pSortedClasses;
                pSchemaObject = pSchemaHead;
                fNameFound = FALSE;

                do {

                    if ( pSchemaObject->oid == Name ) {

                        Name = pSchemaObject->ldapDisplayName;
                        fNameFound = TRUE;
                        break;
                    }

                    pSchemaObject = pSchemaObject->pSortedListFlink;

                } while ( pSchemaObject != pSchemaHead );

                //
                // Then try the list of attributes.
                //

                if ( !fNameFound ) {

                    pSchemaHead = pScopeControl->g_SchemaCache.pSortedAttribs;
                    pSchemaObject = pSchemaHead;

                    do {

                        if ( pSchemaObject->oid == Name ) {

                            Name = pSchemaObject->ldapDisplayName;
                            fNameFound = TRUE;
                            break;
                        }

                        pSchemaObject = pSchemaObject->pSortedListFlink;

                    } while ( pSchemaObject != pSchemaHead );
                }

                ASSERT( fNameFound );

            } else {

                pScopeControl->g_SchemaCache.ReleaseRef( pSchemaObject );
            }

        } else {

            pScopeControl->g_SchemaCache.ReleaseRef( pSchemaObject );
        }

        //
        // This is the ldapDisplayName!!
        //

        pCurrent->Attribute = Name;
    }

    ASSERT( cCount == i );
    ASSERT( pos == NULL );

    *ppNewList = pHead;
    return S_OK;
}


const UINT	MAX_ERROR_BUF = 2048;


VOID
DoExtErrMsgBox(
    VOID
)
{
    DWORD dwLastError;
    WCHAR szErrorBuf[MAX_ERROR_BUF + 1];
    WCHAR szNameBuf[MAX_ERROR_BUF + 1];

    // get extended error value
    HRESULT hr_return = ADsGetLastError( &dwLastError,
										   szErrorBuf,
										   MAX_ERROR_BUF,
											szNameBuf,
										   MAX_ERROR_BUF);
    if (SUCCEEDED(hr_return))
    {
		MessageBox( ::GetActiveWindow(),
					szErrorBuf,
					szNameBuf,
					MB_OK | MB_ICONSTOP );
    }
	else
		ASSERT( FALSE );
}


// INVALID_POINTER is returned by CListBox::GetItemDataPtr() in case of an error.
const VOID * INVALID_POINTER = reinterpret_cast<void *>( LB_ERR );


HRESULT
RetrieveEditItemsWithExclusions(
    CListBox& refListBox,
    CStringList& refstringlist,
    CStringList* pstringlistExclusions)
{
    CString     str;
    CString   * pstr    = NULL;
    int         nCount  = refListBox.GetCount();

    if (LB_ERR == nCount)
    {
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }

    for (INT i = 0; i < nCount; i++)
    {
        pstr = static_cast<CString *>( refListBox.GetItemDataPtr(i) );
        ASSERT( INVALID_POINTER != pstr );

        // don't need to search for pstr because pstr can only be a new item,
        // and they are never excluded.

        if( pstr && INVALID_POINTER != pstr )
        {
            refstringlist.AddHead( *pstr );
        }
        else
        {
            refListBox.GetText( i, str );
            if (NULL != pstringlistExclusions)
            {
                POSITION pos = pstringlistExclusions->Find( str );
                if (NULL != pos)
                    continue;
            }

            refstringlist.AddHead( str );
        }

    }
    
    return S_OK;
}


//
// The global cookie lists for scope and result pane items.
//

VOID
CCookieList::AddCookie(
    Cookie *pCookie,
    HSCOPEITEM hScope
) {

    CCookieListEntry *pNewEntry = new CCookieListEntry;

    //
    // If there's no memory, we can't remember this and hence
    // our display may get a little out of whack.
    //

    if ( !pNewEntry ) {
        return;
    }

    pNewEntry->pCookie = pCookie;
    pNewEntry->hScopeItem = hScope;

    if ( !pHead ) {

        //
        // If this is the first one, just set the
        // head pointer.  The constructor for the
        // list entry has already set the next and
        // back pointers.
        //

        pHead = pNewEntry;

    } else {

        //
        // Insert this at the end of the circular
        // doubly-linked list.
        //

        pNewEntry->pBack = pHead->pBack;
        pNewEntry->pNext = pHead;
        pHead->pBack->pNext = pNewEntry;
        pHead->pBack = pNewEntry;
    }

    return;
}


VOID
CCookieList::InsertSortedDisplay(
    ComponentData *pScopeControl,
    SchemaObject *pNewObject
)
/***

Notes:

    This function inserts the object into the
    sorted display list.

    If the object is a class and the ComponentData
    interface pointer is provided, this routine will
    also create a cookie for this object and insert
    the scope item into the view.

***/
{

    HRESULT hr;
    CCookieListEntry *pNewEntry = NULL, *pCurrent = NULL;
    SCOPEDATAITEM ScopeItem;
    Cookie *pNewCookie= NULL;
    int compare;

    //
    // If this cookie list is empty, there's nothing
    // in the display and we don't need to do anything.
    //

    if ( !pHead ) {
        return;
    }

    //
    // Allocate a new cookie list entry.  If we can't
    // do nothing.  The display will be out of sync
    // until the user refreshes.
    //

    pNewEntry = new CCookieListEntry;

    if ( !pNewEntry ) {
        return;
    }

    //
    // Prepare the required mmc structures.
    //

    if ( pNewObject->schemaObjectType == SCHMMGMT_CLASS ) {

        if ( !pScopeControl ) {

            //
            // If there's no scope control, we can't insert anything.
            //

            delete pNewEntry;
            return;
        }

        // prefix believes that this allocation (or construction) may throw
        // an exception, and if an exception is thrown, pNewEntry is
        // leaked.  After a lot of digging, it's possible that a
        // CMemoryException instance may be thrown by one of the base
        // classes of one the members of CBaseCookieBlock, which is a base
        // clase of Cookie.        
        // NTRAID#NTBUG9-294879-2001/01/26-sburns
        
        try
        {
           pNewCookie = new Cookie( SCHMMGMT_CLASS,
                         pParentCookie->QueryNonNULLMachineName() );
        }
        catch (...)
        {
           delete pNewEntry;
           return;
        }

        if ( !pNewCookie ) {

            //
            // If we can't allocate a cookie, do nothing.
            //

            delete pNewEntry;
            return;
        }

        pNewCookie->pParentCookie = pParentCookie;
        pNewCookie->strSchemaObject = pNewObject->commonName;

        pParentCookie->m_listScopeCookieBlocks.AddHead(
            (CBaseCookieBlock*)pNewCookie );

        pNewEntry->pCookie = pNewCookie;

        ::ZeroMemory( &ScopeItem, sizeof(ScopeItem) );
        ScopeItem.displayname = MMC_CALLBACK;
        ScopeItem.nState = 0;

        ScopeItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pNewCookie);
        ScopeItem.nImage = pScopeControl->QueryImage( *pNewCookie, FALSE );
        ScopeItem.nOpenImage = pScopeControl->QueryImage( *pNewCookie, TRUE );

    }

    //
    // Should this be the new head of the list?
    //

    compare = pNewObject->ldapDisplayName.CompareNoCase(
                  pHead->pCookie->strSchemaObject );

    if ( compare < 0 ) {

        if ( pNewObject->schemaObjectType == SCHMMGMT_CLASS ) {

            //
            // Insert this into the scope pane.
            //

            ScopeItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_STATE |
                             SDI_PARAM | SDI_NEXT | SDI_CHILDREN;
            ScopeItem.cChildren = 0;

            ScopeItem.relativeID = pHead->hScopeItem;

            hr = pScopeControl->m_pConsoleNameSpace->InsertItem( &ScopeItem );

            pNewEntry->hScopeItem = ScopeItem.ID;
            pNewEntry->pCookie->m_hScopeItem = ScopeItem.ID;

        } else {

            hr = S_OK;
        }

        if ( SUCCEEDED(hr) ) {

            pNewEntry->pNext = pHead;
            pNewEntry->pBack = pHead->pBack;
            pHead->pBack->pNext = pNewEntry;
            pHead->pBack = pNewEntry;

            pHead = pNewEntry;

        } else {

            delete pNewEntry;
            delete pNewCookie;
        }

        return;
    }

    //
    // Determine the sorted insertion point.  The sorted list is circular.
    //

    pCurrent = pHead;

    while ( pCurrent->pNext != pHead ) {

        compare = pNewObject->ldapDisplayName.CompareNoCase(
                      pCurrent->pNext->pCookie->strSchemaObject );

        if ( compare < 0 ) {
            break;
        }

        pCurrent = pCurrent->pNext;
    }

    //
    // We want to insert the new object after pCurrent.
    //

    if ( pNewObject->schemaObjectType == SCHMMGMT_CLASS ) {

        ScopeItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_STATE |
                         SDI_PARAM | SDI_PREVIOUS | SDI_CHILDREN;
        ScopeItem.cChildren = 0;

        ScopeItem.relativeID = pCurrent->hScopeItem;

        hr = pScopeControl->m_pConsoleNameSpace->InsertItem( &ScopeItem );

        pNewEntry->hScopeItem = ScopeItem.ID;
        pNewEntry->pCookie->m_hScopeItem = ScopeItem.ID;

    } else {

        hr = S_OK;
    }

    if ( SUCCEEDED( hr )) {

       pNewEntry->pNext = pCurrent->pNext;
       pNewEntry->pBack = pCurrent;
       pCurrent->pNext->pBack = pNewEntry;
       pCurrent->pNext = pNewEntry;

    } else {

        delete pNewEntry;
        delete pNewCookie;
    }

    return;
}

bool
CCookieList::DeleteCookie(Cookie* pCookie)
{
   bool result = false;

   if (!pHead)
   {
      return result;
   }

   // walk the links and stop when the scope item matches.
   // Since the list is circular,
   // we use pHead as the sentinal value instead of null.

   CCookieListEntry* pCurrent = pHead;
   do
   {
       ASSERT(pCurrent);

       if (pCurrent->pCookie == pCookie)
       {
          // Remove the node from the list

          pCurrent->pBack->pNext = pCurrent->pNext;
          pCurrent->pNext->pBack = pCurrent->pBack;

          if (pCurrent == pHead)
          {
             pHead = pCurrent->pNext;
          }

          result = true;

          delete pCurrent;
          break;
       }

       pCurrent = pCurrent->pNext;

   } while (pCurrent != pHead);

   return result;
}

void
CCookieList::DeleteAll()
{
   if (!pHead)
   {
      return;
   }


   CCookieListEntry* pCurrent = pHead;
   do
   {
      CCookieListEntry* next = pCurrent->pNext;
      delete pCurrent;
      pCurrent = next;
   }
   while (pCurrent != pHead);

   pHead = 0;
}



CString
GetHelpFilename()
{
   TCHAR buf[MAX_PATH + 1];

   UINT result = ::GetSystemWindowsDirectory(buf, MAX_PATH);
   ASSERT(result != 0 && result <= MAX_PATH);

   CString f(buf);
   f += TEXT("\\help\\schmmgmt.hlp");

   return f;
}


BOOL
ShowHelp( HWND hParent, WPARAM wParam, LPARAM lParam, const DWORD ids[], BOOL fContextMenuHelp )
{
   HWND hWndMain = NULL;
   UINT uCommand = 0;

   if( !fContextMenuHelp )
   {
       // The user has clicked ? and the control, or just F1 (if enabled)
       const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
       if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
       {
            hWndMain = (HWND) pHelpInfo->hItemHandle;
            uCommand = HELP_WM_HELP;
       }
   }
   else
   {
       hWndMain = (HWND) wParam;
       uCommand = HELP_CONTEXTMENU;

       // Optimization for non-static enabled windows.
       // This way users don't have to do an extra menu click

       // $$ don't know why this call returns NULL all the time
       // HWND hWnd = ChildWindowFromPoint( hParent, CPoint(lParam) );
       // if( hWnd )
       //   hWndMain = hWnd;

       if( -1 != GET_X_LPARAM(lParam) &&
           -1 != GET_Y_LPARAM(lParam) &&
           hParent                    &&
           hWndMain != hParent )
       {
           uCommand = HELP_WM_HELP;
       }
   }
   

   if( hWndMain && uCommand )
   {
       // Display context help for a control
       ::WinHelp( hWndMain,
                  GetHelpFilename(),
                  uCommand,
                  (DWORD_PTR) ids );
   }

   return TRUE;
}


#if 0

VOID
DebugTrace(
    LPWSTR Format,
    ...
) {

    WCHAR DbgString[1024];
    va_list arglist;
    int Length;

    //
    // Format the output into a buffer and then print it.
    //

    va_start(arglist, Format);

    Length = wvsprintf( DbgString, Format, arglist );

    va_end(arglist);

    ASSERT( Length <= 1024 );
    ASSERT( Length != 0 );

    OutputDebugString( DbgString );

    return;

}

#else


VOID
DebugTrace(
    LPWSTR,
    ...
) {
 ;
}

#endif




// Attempt to locate a message in a given module.  Return the message string
// if found, the empty string if not.
// 
// flags - FormatMessage flags to use
// 
// module - module handle of message dll to look in, or 0 to use the system
// message table.
// 
// code - message code to look for

CString
getMessageHelper(DWORD flags, HMODULE module, HRESULT code)
{
   ASSERT(code);
   ASSERT(flags & FORMAT_MESSAGE_ALLOCATE_BUFFER);

   CString message;

   TCHAR* sys_message = 0;
   DWORD result =
      ::FormatMessage(
         flags,
         module,
         static_cast<DWORD>(code),
         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
         reinterpret_cast<LPTSTR>(&sys_message),
         0,
         0);
   if (result)
   {
      ASSERT(sys_message);
      if (sys_message)
      {
         message = sys_message;
         ::LocalFree(sys_message);
      }
   }

   return message;
}


#define MAX_ERROR_BUF   2048

HRESULT
GetLastADsError( HRESULT hr, CString& refErrorMsg, CString& refName )
{
  ASSERT(FAILED(hr));

  refErrorMsg.Empty();
  refName.Empty();

  if (!FAILED(hr))
  {
       return hr;
  }

   if( FACILITY_WIN32 == HRESULT_FACILITY(hr) )
   {
       DWORD dwLastError = 0;
       WCHAR szErrorBuf[ MAX_ERROR_BUF + 1 ];
       WCHAR szNameBuf[ MAX_ERROR_BUF + 1 ];

       //Get extended error value.
       HRESULT hr_return = ADsGetLastError( &dwLastError,
                                            szErrorBuf,
                                            MAX_ERROR_BUF,
                                            szNameBuf,
                                            MAX_ERROR_BUF );
       
       ASSERT( SUCCEEDED(hr_return) );
       if( SUCCEEDED(hr_return) && dwLastError )
       {
            refErrorMsg = szErrorBuf;
            refName     = szNameBuf;
            return HRESULT_FROM_WIN32( dwLastError );
       }
   }

   return hr;
}

// Attempts to locate message strings for various facility codes in the
// HRESULT.  If fTryADSIExtError is true, check ADsGetLastError() first


CString
GetErrorMessage( HRESULT hr, BOOL fTryADSIExtError /* = FALSE */ )
{
   ASSERT(FAILED(hr));

   if (!FAILED(hr))
   {
      // no messages for success!
      return CString();
   }

   
   CString  strExtMsg;
   
   if( fTryADSIExtError &&
       FACILITY_WIN32 == HRESULT_FACILITY(hr) )
   {
       DWORD dwLastError = 0;
       WCHAR szErrorBuf[ MAX_ERROR_BUF + 1 ];
       WCHAR szNameBuf[ MAX_ERROR_BUF + 1 ];

       //Get extended error value.
       HRESULT hr_return = ADsGetLastError( &dwLastError,
                                            szErrorBuf,
                                            MAX_ERROR_BUF,
                                            szNameBuf,
                                            MAX_ERROR_BUF );
       
       ASSERT( SUCCEEDED(hr_return) );
       if( SUCCEEDED(hr_return) && dwLastError )
       {
            hr = HRESULT_FROM_WIN32( dwLastError );

            strExtMsg = szErrorBuf;
       }
   }

   HRESULT code = HRESULT_CODE(hr);

   CString message;

   // default is the system error message table
   HMODULE module = 0;

   DWORD flags =
         FORMAT_MESSAGE_ALLOCATE_BUFFER
      |  FORMAT_MESSAGE_IGNORE_INSERTS
      |  FORMAT_MESSAGE_FROM_SYSTEM;

   int facility = HRESULT_FACILITY(hr);
   switch (facility)
   {
      case FACILITY_WIN32:    // 0x7
      {
         // included here:
         // lanman error codes (in it's own dll)
         // dns
         // winsock

         static HMODULE lm_err_res_dll = 0;
         if (code >= NERR_BASE && code <= MAX_NERR)
         {
            // use the net error message resource dll
            if (lm_err_res_dll == 0)
            {
               lm_err_res_dll =
                  ::LoadLibraryEx(
                     L"netmsg.dll",
                     0,
                     LOAD_LIBRARY_AS_DATAFILE);
            }

            module = lm_err_res_dll;
            flags |= FORMAT_MESSAGE_FROM_HMODULE;
         }
         break;
      }
      case 0x0:
      {
         if (code >= 0x5000 && code <= 0x50FF)
         {
            // It's an ADSI error.  They put the facility code (5) in the
            // wrong place!
            static HMODULE adsi_err_res_dll = 0;
            // use the net error message resource dll
            if (adsi_err_res_dll == 0)
            {
               adsi_err_res_dll =
                  ::LoadLibraryEx(
                     L"activeds.dll",
                     0,
                     LOAD_LIBRARY_AS_DATAFILE);
            }

            module = adsi_err_res_dll;
            flags |= FORMAT_MESSAGE_FROM_HMODULE;

            // the message dll expects the entire error code
            code = hr;
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   message = getMessageHelper(flags, module, code);


#ifdef SHOW_EXT_LDAP_MSG

   if( !strExtMsg.IsEmpty() )
       message += L"\n" + strExtMsg;

#endif //SHOW_EXT_LDAP_MSG


   if (message.IsEmpty())
   {
      message.LoadString(IDS_UNKNOWN_ERROR_MESSAGE);
   }

   return message;
}



//
// Get range from edit controls, Verify the range, attempt to correct, make sure lower <= upper.
//
//	an exception will be thrown in case of an error.
//
void DDXV_VerifyAttribRange( CDataExchange *pDX, BOOL fIsSigned,
								UINT idcLower, CString & strLower,
								UINT idcUpper, CString & strUpper )
{
	INT64		llLower	= 0;
	INT64		llUpper	= 0;

	ASSERT( pDX );
	ASSERT( pDX->m_pDlgWnd );


	// Update the values.
	llLower = DDXV_SigUnsigINT32Value( pDX, fIsSigned, idcLower, strLower );
	llUpper = DDXV_SigUnsigINT32Value( pDX, fIsSigned, idcUpper, strUpper );


#ifdef ENABLE_NEGATIVE_INT
    // verify that lower <= upper  --  only if supporting ENABLE_NEGATIVE_INT
    if ( pDX->m_bSaveAndValidate && !strLower.IsEmpty() && !strUpper.IsEmpty() )
	{
		if( llLower > llUpper )
		{
			DoErrMsgBox( pDX->m_pDlgWnd->m_hWnd, TRUE, IDS_ERR_EDIT_MINMAX );
			pDX->Fail();		// we are still at the second edit control.
		}
	}
#endif //ENABLE_NEGATIVE_INT
}


//
// Get string from an edit control, verify it attempting to correct
//
//	an exception will be thrown in case of an error.
//
// Returns corrected value
//
INT64 DDXV_SigUnsigINT32Value( CDataExchange *pDX, BOOL fIsSigned,
						UINT idc, CString & str )
{
	INT64	llVal	= 0;
	HRESULT	hr		= S_OK;
	
	ASSERT( pDX );
	ASSERT( pDX->m_pDlgWnd );

	// Get/Put the string
	DDX_Text( pDX, idc, str );

    if ( pDX->m_bSaveAndValidate )
	{
		if( !str.IsEmpty() )
		{
			hr = GetSafeINT32FromString( pDX->m_pDlgWnd, llVal, str,
										fIsSigned, GETSAFEINT_ALLOW_CANCEL );

			if( FAILED(hr) )
			{
				pDX->Fail();
			}
			else if( S_VALUE_MODIFIED == hr )
			{
				// update the string in case of some conversion things ('010' --> '10')
				// or if the value was changed
				pDX->m_pDlgWnd->SetDlgItemText( idc, str );
			}
		}
	}

	return llVal;
}



//
// Converts a string to a DWORD, asks to correct to be within the range.
// returns HRESULT:
//	S_OK				llDst is the value from string
//	S_VALUE_MODIFIED	llDst is the truncated value, strSrc is updated
//	E_ABORT				llDst is unchanged; E_ABORT may be returned only if fAllowCancel is TRUE
//
HRESULT GetSafeSignedDWORDFromString( CWnd * pwndParent, DWORD & dwDst, CString & strSrc,
										BOOL fIsSigned, BOOL fAllowCancel /* =FALSE */)
{
	INT64	llDst	= 0;
	HRESULT	hr		= GetSafeINT32FromString( pwndParent, llDst, strSrc, fIsSigned, fAllowCancel );

	if( SUCCEEDED( hr ) )
		dwDst = (DWORD) llDst;

	return hr;
}


//
//		*** internal use ***
// Converts a string to a INT64, asks to correct to be within the range.
// returns HRESULT:
//	S_OK				llDst is the value from string
//	S_VALUE_MODIFIED	llDst is the truncated value, strSrc is updated
//	E_ABORT				llDst is the truncated value
//							E_ABORT only happens if fAllowCancel is TRUE
//
HRESULT GetSafeINT32FromString( CWnd * pwndParent, INT64 & llDst, CString & strSrc,
								BOOL fIsSigned, BOOL fAllowCancel)
{
	HRESULT		hr				= S_OK;
	UINT		nMessageBoxType	= 0;
	CString		szMsg;
	CString		szSugestedNumber;
	BOOL		fIsValidNumber	= TRUE;
	BOOL		fIsValidString	= TRUE;
	

	ASSERT( pwndParent );

	// the string must be limited in length & not empty
	ASSERT( !strSrc.IsEmpty() );
	ASSERT( strSrc.GetLength() <= cchMinMaxRange );

	fIsValidString	= IsValidNumberString( strSrc );

	llDst			= _wtoi64( (LPCWSTR) strSrc );
	fIsValidNumber	= IsValidNumber32( llDst, fIsSigned );
	szSugestedNumber.Format( fIsSigned ? g_INT32_FORMAT : g_UINT32_FORMAT, (DWORD) llDst );

	if( !fIsValidString || !fIsValidNumber )
	{
		szMsg.FormatMessage( !fIsValidString ? IDS_ERR_NUM_IS_ILLIGAL : IDS_ERR_INT_OVERFLOW,
								(LPCWSTR) strSrc, (LPCWSTR) szSugestedNumber );

		// make sure the user wants to do it
        nMessageBoxType = (fAllowCancel ? MB_OKCANCEL : MB_OK) | MB_ICONEXCLAMATION ;

        if( IDOK == pwndParent->MessageBox( szMsg, g_MsgBoxErr, nMessageBoxType ) )
		{
			strSrc	= szSugestedNumber;
			hr		= S_VALUE_MODIFIED;
		}
		else
		{
			hr		= E_ABORT;
		}
	}
	else if( strSrc != szSugestedNumber )
	{
		// fixing number formating
		strSrc	= szSugestedNumber;
		hr		= S_VALUE_MODIFIED;
	}

	return hr;
}


//
// Verify & correct Min/Max for a signed/unsigned INT64 value
//
BOOL IsValidNumber32( INT64 & llVal, BOOL fIsSigned )
{

#ifdef ENABLE_NEGATIVE_INT
	const INT64	llMinVal	= fIsSigned ? (INT64) _I32_MIN : (INT64) 0 ;
	const INT64	llMaxVal	= fIsSigned ? (INT64) _I32_MAX : (INT64) _UI32_MAX ;
#else
	// if there is no negative numbers support, always use unsigned numbers
	const INT64	llMinVal	= (INT64) 0;
	const INT64	llMaxVal	= (INT64) _UI32_MAX;
#endif

	BOOL		fIsValid	= FALSE;

	// if larger than 32bit number (signed/unsigned), truncate...
	if( llVal < llMinVal )
	{
		llVal		= llMinVal;
	}
	else if( llVal > llMaxVal )
	{
		llVal		= llMaxVal;
	}
	else
	{
		fIsValid	= TRUE;
	}

	return fIsValid;
}


//
// Search number string for illigal characters.
//
BOOL IsValidNumberString( CString & str )
{
	int i = 0;

#ifdef ENABLE_NEGATIVE_INT
	if( str.GetLength() > 0 &&					// allow negative sign in front of the number
		g_chNegativeSign == str[ i ] )
	{
		i++;	// skip first character
	}
#endif //ENABLE_NEGATIVE_INT

	for( ;  i < str.GetLength();  i++ )
	{
		if( !IsCharNumeric( str[i] ) )
			return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// ParsedEdit

BEGIN_MESSAGE_MAP(CParsedEdit, CEdit)
	//{{AFX_MSG_MAP(CParsedEdit)
	ON_WM_CHAR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize subclassing

BOOL CParsedEdit::SubclassEdit( UINT nID,
                                CWnd* pParent,
                                int cchMaxTextSize )   // 0 == unlimited
{
    ASSERT( IsInitialized() );
	ASSERT( nID );
	ASSERT( pParent );
	ASSERT( pParent->GetDlgItem(nID) );
    ASSERT( cchMaxTextSize >= 0 );

    ( static_cast<CEdit *>( pParent->GetDlgItem(nID) ) ) -> LimitText( cchMaxTextSize ) ;

    if( EDIT_TYPE_GENERIC == GetEditType() )
    {
        return TRUE;        // no need to subclass - everything is allowed.
    }
    else
    {
        return SubclassDlgItem(nID, pParent);
    }
}

/////////////////////////////////////////////////////////////////////////////
// Input character filter

void CParsedEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    ASSERT( IsInitialized() ); // initialized?
	
	BOOL	fIsSpecialChar	= ( nChar < 0x20 );

    BOOL    fAllowChar      = FALSE;


    if( fIsSpecialChar )
    {
        fAllowChar = TRUE;      // always allow control chars
    }
    else
    {
        // is this a digit?
        BOOL	fIsDigit		= IsCharNumeric( (TCHAR)nChar );

        switch( GetEditType() )
        {
            default:
                ASSERT( FALSE );
                break;

            case EDIT_TYPE_GENERIC:         // everything is allowed
                fAllowChar = TRUE;
                break;

            case EDIT_TYPE_INT32:
            case EDIT_TYPE_UINT32:
                {
                    #ifdef ENABLE_NEGATIVE_INT
    	              const BOOL    fAllowNegativeNumbers   = TRUE;
                    #else
	                  const BOOL    fAllowNegativeNumbers   = FALSE;
                    #endif

                    DWORD	dwSel			= GetSel();

	                //	is the caret in the begining of the box
	                BOOL	fLineFront		= ! LOWORD( dwSel );

	                //	is the first character selected? (thus, typing anything will overide it)
	                BOOL	fIsSelFirstChar	= fLineFront && HIWORD( dwSel );

	                BOOL	fIsNegSign		= ( (TCHAR)nChar == g_chNegativeSign );

                  WCHAR	szBuf[ 2 ] = {0};		// we only need the first character to check for '-'

	                // if the first character is selected, no matter what we type it will be overwritten
	                // an empty value is a positive value.
	                // rellies on left to right execution.
	                BOOL	fIsAlreadyNeg	= (	!fIsSelFirstChar &&
							                GetWindowText( szBuf, 2 ) &&
							                g_chNegativeSign == szBuf[0] );

	                ASSERT( !fIsDigit || !fIsNegSign ); // cannot be both!


                    if (
                        (	fIsDigit &&                         // allow numeric if ...
                              ( !fAllowNegativeNumbers ||       //      ignore error checking if false
                                !fLineFront ||                  //    	not first position
                                (fLineFront && !fIsAlreadyNeg)) //    	first pos & no '-' sign
                        )
                  
                        ||

                        (	fIsNegSign &&                       // allow '-' if
                              fAllowNegativeNumbers &&          //  negatives are allowed
                              FIsSigned() &&                    //	signed numbers are allowed
                              !fIsAlreadyNeg &&                 //	the number was positive
                              fLineFront                        //	entering as the first character
                        )
                       )
                    {
                        fAllowChar = TRUE;
                    }
                }
                break;

            case EDIT_TYPE_OID:     // do a light checking -- allow digits & periods
                {
                    if( fIsDigit ||
                        g_chPeriod == (TCHAR)nChar )
                    {
                        fAllowChar = TRUE;
                    }
                }
                break;
        }
    }
    
	
    if( fAllowChar )
    {
		CEdit::OnChar(nChar, nRepCnt, nFlags);  // permitted
	}
	else
	{											// not permitted
		MessageBeep((UINT)-1);					// Standard beep
	}
}



/////////////////////////////////////////////////////////////////////////////
//
//  Search a list of PCTSTR for a strValue, returns TRUE if found
//      rgszList[] last element must be NULL
//
//  puIndex - optional pointer, will be set to the position of the value if found.
//
BOOL
IsInList( PCTSTR rgszList[], const CString & strValue, UINT * puIndex /* = NULL */ )
{
    UINT   uIndex = 0;

    while( rgszList[ uIndex ] )
    {
        if( !strValue.CompareNoCase( rgszList[uIndex] ) )
        {
            if( puIndex )
                *puIndex = uIndex;
            return TRUE;
        }
        else
            uIndex++;
    }

    return FALSE;
}


#define ADS_SYSTEMFLAG_SCHEMA_CONSTRUCTED 0x04
#define ADS_SYSTEMFLAG_SCHEMA_BASE_OBJECT 0x10


//
//  Determine if the object pointed to by pIADsObject is a constructed object.
//
HRESULT
IsConstructedObject( IADs *pIADsObject, BOOL & fIsConstructed )
{
    LONG    fSysAttribs = 0;
    HRESULT hr          = GetSystemAttributes( pIADsObject, fSysAttribs );

    if( SUCCEEDED(hr) )
        fIsConstructed = ADS_SYSTEMFLAG_SCHEMA_CONSTRUCTED & fSysAttribs;

    return hr;
}



//
//  Determine if the object pointed to by pIADsObject is category 1 object.
//
HRESULT
IsCategory1Object( IADs *pIADsObject, BOOL & fIsCategory1 )
{
    LONG    fSysAttribs = 0;
    HRESULT hr          = GetSystemAttributes( pIADsObject, fSysAttribs );

    if( SUCCEEDED(hr) )
        fIsCategory1 = ADS_SYSTEMFLAG_SCHEMA_BASE_OBJECT & fSysAttribs;

    return hr;
}



//
//  Read object's System Attribute
//
HRESULT
GetSystemAttributes( IADs *pIADsObject, LONG &fSysAttribs )
{
    HRESULT hr = E_FAIL;
    VARIANT	AdsResult;

    if( !pIADsObject )
        ASSERT( FALSE );
    else
    {
        VariantInit( &AdsResult );

        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_systemFlags), &AdsResult );
        
        if ( SUCCEEDED( hr ) )
        {
            ASSERT(AdsResult.vt == VT_I4);
            fSysAttribs = V_I4(&AdsResult);
        }
        else if( E_ADS_PROPERTY_NOT_FOUND == hr )
        {
            fSysAttribs = 0;
            hr = S_OK;
        }

        VariantClear( &AdsResult );
    }

    return hr;
}


HRESULT
DissableReadOnlyAttributes( CWnd * pwnd, IADs *pIADsObject, const CDialogControlsInfo * pCtrls, UINT cCtrls )
{
    ASSERT( pwnd );
    ASSERT( pIADsObject );
    ASSERT( pCtrls );
    ASSERT( cCtrls );

    HRESULT         hr      = S_OK;
    CStringList     strlist;

    do
    {
        // extract the list of allowed attributes
        hr = GetStringListElement( pIADsObject, &g_allowedAttributesEffective, strlist );
        BREAK_ON_FAILED_HRESULT(hr);

        for( UINT ind = 0; ind < cCtrls; ind++ )
        {
            BOOL    fFound = FALSE;

            // search for needed attributes
            for( POSITION pos = strlist.GetHeadPosition(); !fFound && pos != NULL; )
            {
                CString * pstr = &strlist.GetNext( pos );
            
                if( !pstr->CompareNoCase( pCtrls[ind].m_pszAttributeName ) )
                {
                    fFound = TRUE;
                }
            }

            if( !fFound )
            {
                ASSERT( pwnd->GetDlgItem( pCtrls[ind].m_nID ) );

                if( pCtrls[ind].m_fIsEditBox )
                    reinterpret_cast<CEdit *>( pwnd->GetDlgItem(pCtrls[ind].m_nID) )->SetReadOnly();
                else
                    pwnd->GetDlgItem(pCtrls[ind].m_nID)->EnableWindow( FALSE );
            }
        }

    } while( FALSE );

    return hr;
}


HRESULT GetStringListElement( IADs *pIADsObject, LPWSTR *lppPathNames, CStringList &strlist )
{
    ASSERT( pIADsObject );
    ASSERT( lppPathNames );
    ASSERT( *lppPathNames );

    HRESULT         hr      = S_OK;
    VARIANT         varAttributes;

    VariantInit( &varAttributes );

    strlist.RemoveAll();
    
    do
    {
        // build an array of one element
        hr = ADsBuildVarArrayStr( lppPathNames, 1, &varAttributes );
        ASSERT_BREAK_ON_FAILED_HRESULT(hr);

        hr = pIADsObject->GetInfoEx( varAttributes, 0 );
        BREAK_ON_FAILED_HRESULT(hr);

        hr = VariantClear( &varAttributes );
        ASSERT_BREAK_ON_FAILED_HRESULT(hr);


        // Get all allowed attributes
        hr = pIADsObject->GetEx( *lppPathNames, &varAttributes );
        BREAK_ON_FAILED_HRESULT(hr);

        // Convert result to a string list
        hr = VariantToStringList( varAttributes, strlist );
        ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
        BREAK_ON_FAILED_HRESULT(hr);

    } while( FALSE );

    VariantClear( &varAttributes );

    return hr;
}


bool OIDHasValidFormat (PCWSTR pszOidValue, int& rErrorTypeStrID)
{
    rErrorTypeStrID = 0;

    bool bFormatIsValid = false;
    int  nLen = WideCharToMultiByte(
          CP_ACP,                   // code page
          0,                        // performance and mapping flags
          pszOidValue,              // wide-character string
          (int) wcslen (pszOidValue),  // number of chars in string
          0,                        // buffer for new string
          0,                        // size of buffer
          0,                        // default for unmappable chars
          0);                       // set when default char used
    if ( nLen > 0 )
    {
        nLen++; // account for Null terminator
        PSTR    pszAnsiBuf = new CHAR[nLen];
        if ( pszAnsiBuf )
        {
            ZeroMemory (pszAnsiBuf, nLen*sizeof(CHAR));
            nLen = WideCharToMultiByte(
                    CP_ACP,                 // code page
                    0,                      // performance and mapping flags
                    pszOidValue,            // wide-character string
                    (int) wcslen (pszOidValue),   // number of chars in string
                    pszAnsiBuf,             // buffer for new string
                    nLen,                   // size of buffer
                    0,                      // default for unmappable chars
                    0);                     // set when default char used
            if ( nLen )
            {
                // According to PhilH:
                // The first number is limited to 
                // 0,1 or 2. The second number is 
                // limited to 0 - 39 when the first 
                // number is 0 or 1. Otherwise, any 
                // number.
                // Also, according to X.208, there 
                // must be at least 2 numbers.
                bFormatIsValid = true;
                size_t cbAnsiBufLen = strlen (pszAnsiBuf);

                // check for only digits and "."
                size_t nIdx = strspn (pszAnsiBuf, "0123456789.\0");
                if ( nIdx > 0 && nIdx < cbAnsiBufLen )
                {
                    bFormatIsValid = false;
                    rErrorTypeStrID = IDS_OID_CONTAINS_NON_DIGITS;
                }

                // check for consecutive "."s - string not valid if present
                if ( bFormatIsValid && strstr (pszAnsiBuf, "..") )
                {
                    bFormatIsValid = false;
                    rErrorTypeStrID = IDS_OID_CONTAINS_CONSECUTIVE_DOTS;
                }
                

                // must begin with "0." or "1." or "2."
                bool bFirstNumberIs0 = false;
                bool bFirstNumberIs1 = false;
                bool bFirstNumberIs2 = false;
                if ( bFormatIsValid )
                {
                    if ( !strncmp (pszAnsiBuf, "0.", 2) )
                        bFirstNumberIs0 = true;
                    else if ( !strncmp (pszAnsiBuf, "1.", 2) )
                        bFirstNumberIs1 = true;
                    else if ( !strncmp (pszAnsiBuf, "2.", 2) )
                        bFirstNumberIs2 = true;
                    
                    if ( !bFirstNumberIs0 && !bFirstNumberIs1 && !bFirstNumberIs2 )
                    {
                        bFormatIsValid = false;
                        rErrorTypeStrID = IDS_OID_MUST_START_WITH_0_1_2;
                    }
                }

                if ( bFormatIsValid && ( bFirstNumberIs0 || bFirstNumberIs1 ) )
                {
                    PSTR pszBuf = pszAnsiBuf;
                    pszBuf += 2;

                    // there must be a number after the dot
                    if ( strlen (pszBuf) )
                    {
                        // truncate the string at the next dot, if any
                        PSTR pszDot = strstr (pszBuf, ".");
                        if ( pszDot )
                            pszDot[0] = 0;

                        // convert the string to a number and check for range 0-39
                        int nValue = atoi (pszBuf);
                        if ( nValue < 0 || nValue > 39 )
                        {
                            bFormatIsValid = false;
                            rErrorTypeStrID = IDS_OID_0_1_MUST_BE_0_TO_39;
                        }
                    }
                    else
                    {
                        bFormatIsValid = false;
                        rErrorTypeStrID = IDS_OID_MUST_HAVE_TWO_NUMBERS;
                    }
                }

                // ensure no trailing "."
                if ( bFormatIsValid )
                {
                    if ( '.' == pszAnsiBuf[cbAnsiBufLen - 1] )
                    {
                        bFormatIsValid = false;
                        rErrorTypeStrID = IDS_OID_CANNOT_END_WITH_DOT;
                    }
                }

                if ( bFormatIsValid )
                {
                    bFormatIsValid = false;
                    CRYPT_ATTRIBUTE cryptAttr;
                    ::ZeroMemory (&cryptAttr, sizeof (CRYPT_ATTRIBUTE));

                    cryptAttr.cValue = 0;
                    cryptAttr.pszObjId = pszAnsiBuf;
                    cryptAttr.rgValue = 0;

                    DWORD   cbEncoded = 0;
                    BOOL bResult = CryptEncodeObject (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                            PKCS_ATTRIBUTE,
                            &cryptAttr,
                            NULL,
                            &cbEncoded);
                    if ( cbEncoded > 0 )
                    {
                        BYTE* pBuffer = new BYTE[cbEncoded];
                        if ( pBuffer )
                        {
                            bResult = CryptEncodeObject (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    PKCS_ATTRIBUTE,
                                    &cryptAttr,
                                    pBuffer,
                                    &cbEncoded);
                            if ( bResult )
                            {   
                                DWORD   cbStructInfo = 0;
                                bResult = CryptDecodeObject (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        PKCS_ATTRIBUTE,
                                        pBuffer,
                                        cbEncoded,
                                        0,
                                        0,
                                        &cbStructInfo);
                                if ( cbStructInfo > 0 )
                                {
                                    BYTE* pStructBuf = new BYTE[cbStructInfo];
                                    if ( pStructBuf )
                                    {
                                        bResult = CryptDecodeObject (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                                PKCS_ATTRIBUTE,
                                                pBuffer,
                                                cbEncoded,
                                                0,
                                                pStructBuf,
                                                &cbStructInfo);
                                        if ( bResult )
                                        {
                                            CRYPT_ATTRIBUTE* pCryptAttr = (CRYPT_ATTRIBUTE*) pStructBuf;
                                            if ( !strcmp (pszAnsiBuf, pCryptAttr->pszObjId) )
                                            {
                                                bFormatIsValid = true;
                                            }
                                        }
                                        delete [] pStructBuf;
                                    }
                                }
                            }
                            delete [] pBuffer;
                        }
                    }
                }
            }
            else
            {
                DebugTrace(L"WideCharToMultiByte (%s) failed: 0x%x\n", pszOidValue, 
                        GetLastError ());
            }

            delete [] pszAnsiBuf;
        }
    }
    else
    {
        DebugTrace(L"WideCharToMultiByte (%s) failed: 0x%x\n", pszOidValue, 
                GetLastError ());
    }

    return bFormatIsValid;
}

HRESULT
DeleteObject(
    const CString& path,
    Cookie* pcookie,
    PCWSTR pszClass
)
/***

    This deletes an attribute from the schema

***/
{
   HRESULT hr = S_OK;

   do
   {
      if ( !pcookie )
      {
         hr = E_INVALIDARG;
         break;
      }

      CComPtr<IADsPathname> spIADsPathname;

      hr = ::CoCreateInstance( CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                              IID_IADsPathname, (void**)&spIADsPathname);
      if ( FAILED(hr) )
      {
         break;
      }

      hr = spIADsPathname->Set( (PWSTR)(PCWSTR)path, ADS_SETTYPE_FULL );
      if ( FAILED(hr) )
      {
         break;
      }

      // Get the RDN so that we have it for deleting

      CComBSTR sbstrRDN;
      hr = spIADsPathname->Retrieve( ADS_FORMAT_LEAF, &sbstrRDN );
      if ( FAILED(hr) )
      {
         break;
      }

      // Get the path to the parent container

      hr = spIADsPathname->RemoveLeafElement();
      if ( FAILED(hr) )
      {
         break;
      }

      CComBSTR sbstrParentPath;
      hr = spIADsPathname->Retrieve( ADS_FORMAT_X500, &sbstrParentPath );
      if ( FAILED(hr) )
      {
         break;
      }

      // Now open the parent object

      CComPtr<IADsContainer> spContainer;
      hr = ::ADsOpenObject( sbstrParentPath, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                            IID_IADsContainer, (void**)&spContainer);
      if ( FAILED(hr) )
      {
         break;
      }

      hr = spContainer->Delete( (PWSTR)pszClass, sbstrRDN );
      if ( FAILED(hr) )
      {
         break;
      }

   } while (false);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\uuids.h ===
//
// Nodetypes for the Schema Management snap in.
// Created by UUIDGEN 5/13/97 CoryWest.
//

//
// These are the guids for the node types in the schema management
// snap in.  These node types have to correspond to the node enum
// types that are used in the cookies.  The mapping table between
// the enum types and the guids is in cookie.cpp and cookie.h.
//

#ifndef _UUIDS_SCHEMA_MANAGEMENT_
#define _UUIDS_SCHEMA_MANAGEMENT_

#define strUuidNodetypeSchmMgmt                 "{3d7b8f72-cd87-11d0-9c19-00c04fd8d86e}"
#define strUuidNodetypeClasses                  "{c880afb6-cbd5-11d0-9c15-00c04fd8d86e}"
#define strUuidNodetypeAttributes               "{0d5fbd84-cbd6-11d0-9c15-00c04fd8d86e}"
#define strUuidNodetypeDisplaySpecifiers        "{18669dc4-cbd6-11d0-9c15-00c04fd8d86e}"
#define strUuidNodetypeClass                    "{23a6b674-cbd6-11d0-9c15-00c04fd8d86e}"
#define strUuidNodetypeAttribute                "{2d7c69b4-cbd6-11d0-9c15-00c04fd8d86e}"
#define strUuidNodetypeDisplaySpecifier         "{37cbb4e2-cbd6-11d0-9c15-00c04fd8d86e}"

#define lstrUuidNodetypeSchmMgmt                L"{3d7b8f72-cd87-11d0-9c19-00c04fd8d86e}"
#define lstrUuidNodetypeClasses                 L"{c880afb6-cbd5-11d0-9c15-00c04fd8d86e}"
#define lstrUuidNodetypeAttributes              L"{0d5fbd84-cbd6-11d0-9c15-00c04fd8d86e}"
#define lstrUuidNodetypeDisplaySpecifiers       L"{18669dc4-cbd6-11d0-9c15-00c04fd8d86e}"
#define lstrUuidNodetypeClass                   L"{23a6b674-cbd6-11d0-9c15-00c04fd8d86e}"
#define lstrUuidNodetypeAttribute               L"{2d7c69b4-cbd6-11d0-9c15-00c04fd8d86e}"
#define lstrUuidNodetypeDisplaySpecifier        L"{37cbb4e2-cbd6-11d0-9c15-00c04fd8d86e}"

#define structUuidNodetypeSchmMgmt              \
    { 0x3d7b8f72, 0xcd87, 0x11d0, { 0x9c, 0x15, 0x0, 0xc0, 0x4f, 0xd8, 0xd8, 0x6e } }

#define structUuidNodetypeClasses               \
    { 0xc880afb6, 0xcbd5, 0x11d0, { 0x9c, 0x15, 0x0, 0xc0, 0x4f, 0xd8, 0xd8, 0x6e } }
#define structUuidNodetypeAttributes            \
    { 0x0d5fbd84, 0xcbd6, 0x11d0, { 0x9c, 0x15, 0x0, 0xc0, 0x4f, 0xd8, 0xd8, 0x6e } }
#define structUuidNodetypeDisplaySpecifiers     \
    { 0x18669dc4, 0xcbd6, 0x11d0, { 0x9c, 0x15, 0x0, 0xc0, 0x4f, 0xd8, 0xd8, 0x6e } }

#define structUuidNodetypeClass                 \
    { 0x23a6b674, 0xcbd6, 0x11d0, { 0x9c, 0x15, 0x0, 0xc0, 0x4f, 0xd8, 0xd8, 0x6e } }
#define structUuidNodetypeAttribute             \
    { 0x2d7c69b4, 0xcbd6, 0x11d0, { 0x9c, 0x15, 0x0, 0xc0, 0x4f, 0xd8, 0xd8, 0x6e } }
#define structUuidNodetypeDisplaySpecifier      \
    { 0x37cbb4e2, 0xcbd6, 0x11d0, { 0x9c, 0x15, 0x0, 0xc0, 0x4f, 0xd8, 0xd8, 0x6e } }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\wizinfo.hpp ===
#ifndef WIZINFO_HPP_INCLUDED
#define WIZINFO_HPP_INCLUDED



class CreateClassWizardInfo
{
   public:

   CreateClassWizardInfo();

   // use default dtor   

   CString  cn;
   CString  ldapDisplayName;
   CString  oid;
   CString  description;
   CString  parentClass;
   int      type;

   CStringList strlistMandatory;
   CStringList strlistOptional;
};



#endif   // WIZINFO_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\wizinfo.cpp ===
#include "stdafx.h"
#include "wizinfo.hpp"



CreateClassWizardInfo::CreateClassWizardInfo()
   :
   cn(),
   ldapDisplayName(),
   oid(),
   description(),
   parentClass(),
   type(),
   strlistMandatory(),
   strlistOptional()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\snapmgr.h ===
// SnapMgr.h : header file for Snapin Manager property page
//

#ifndef __SNAPMGR_H__
#define __SNAPMGR_H__

#include "cookie.h"

// forward declarations
class ComponentData;

/////////////////////////////////////////////////////////////////////////////
// CSchmMgmtGeneral dialog

class CSchmMgmtGeneral : public CPropertyPage
{
        // DECLARE_DYNCREATE(CSchmMgmtGeneral)

// Construction
public:
        CSchmMgmtGeneral();
        ~CSchmMgmtGeneral();

        // load initial state into CSchmMgmtGeneral
        void Load( Cookie& refcookie );

// Dialog Data
        //{{AFX_DATA(CSchmMgmtGeneral)
        CString m_strMachineName;
        int m_iRadioObjectType;
        int     m_iRadioIsLocal;
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CSchmMgmtGeneral)
        public:
        virtual BOOL OnWizardFinish();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CSchmMgmtGeneral)
        virtual BOOL OnInitDialog();
        afx_msg void OnRadioLocalMachine();
        afx_msg void OnRadioSpecificMachine();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

public:
        // User defined member variables        
        class ComponentData * m_pSchmMgmtData;
        BOOL m_fServiceDialog;

        // This mechanism deletes the CSchmMgmtGeneral when the property sheet is finished
        LPFNPSPCALLBACK m_pfnOriginalPropSheetPageProc;
        INT m_refcount;
        static UINT CALLBACK PropSheetPageProc(
                HWND hwnd,      
                UINT uMsg,      
                LPPROPSHEETPAGE ppsp );
};

#endif // ~__SNAPMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\sendcmsg\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       Debug.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
//	Debug.cpp

#include "stdafx.h"
#include "debug.h"
#include "util.h"

#ifdef DEBUG


#define DoBreakpoint()	DebugBreak()

void DoDebugAssert(LPCTSTR pszFile, int nLine, LPCTSTR pszExpr)
	{
	TCHAR szBufferT[2048];

	wsprintf(OUT szBufferT, _T("Assertion: (%s)\nFile %s, line %d."), pszExpr, pszFile, nLine);
	int nRet = MessageBox(::GetActiveWindow(), szBufferT, _T("Send Console Message - Assertion Failed"),
		MB_ABORTRETRYIGNORE | MB_ICONERROR);
	switch (nRet)
		{
	case IDABORT:
		DoBreakpoint();
		exit(-1);
	case IDRETRY:
		DoBreakpoint();
		}
	} // DoDebugAssert()

/////////////////////////////////////////////////////////////////////////////
void DebugTracePrintf(
	const TCHAR * szFormat,
	...)
	{
	va_list arglist;
	TCHAR sz[1024];

	Assert(szFormat != NULL);
	va_start(arglist, szFormat);	
	wvsprintf(OUT sz, szFormat, arglist);
	Assert(lstrlen(sz) < LENGTH(sz));
	sz[LENGTH(sz) - 1] = 0;  // Just in case we overflowed into sz
	::OutputDebugString(sz);
	} // DebugTracePrintf()

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\schmmgmt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED_)
#define AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//
// Disable warnings that will fail in retail mode
//
#ifndef DBG

#pragma warning (disable: 4189 4100)

#endif // DBG

#define STRICT

extern "C"
{
    #include <nt.h>         // SE_TAKE_OWNERSHIP_PRIVILEGE, etc
    #include <ntrtl.h>
    #include <nturtl.h>
}
#undef ASSERT
#undef ASSERTMSG

#include <afxwin.h>
#include <afxdisp.h>
#include <afxtempl.h> // CTypedPtrList
#include <afxdlgs.h>  // CPropertyPage
#include <activeds.h>   // ADS Stuff
#include <iadsp.h>
#include <dsgetdc.h>
#include <lm.h>
#include <sddl.h>
#include <ntdsapi.h>
#include <ntldap.h>
#include <aclui.h>
#include <windowsx.h>

#include <dssec.h> // private\inc
#include <comstrm.h>

// #define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include "dbg.h"
#include "mmc.h"
#include "schmmgmt.h"
#include "helpids.h"
#include "guidhelp.h" // ExtractData

EXTERN_C const CLSID CLSID_SchmMgmt;

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <dscmn.h>
#include <shlobj.h>
#include <dsclient.h>
#include <dsadminp.h> // DS Admin utilities

#include "MyBasePathsInfo.h"
//
// Display context sensitive help
//
// This function is implemented in SchmUtil.cpp.  Declared here due to the wide usage
//
BOOL
ShowHelp( HWND hParent, WPARAM wParam, LPARAM lParam, const DWORD ids[], BOOL fContextMenuHelp );


#ifdef _DEBUG
  #define SHOW_EXT_LDAP_MSG
#endif //_DEBUG


#ifndef BREAK_ON_FAILED_HRESULT
#define BREAK_ON_FAILED_HRESULT(hr)                               \
   if (FAILED(hr))                                                \
   {                                                              \
      break;                                                      \
   }
#endif  // BREAK_ON_FAILED_HRESULT


#ifndef ASSERT_BREAK_ON_FAILED_HRESULT
#define ASSERT_BREAK_ON_FAILED_HRESULT(hr)                        \
   if (FAILED(hr))                                                \
   {                                                              \
      ASSERT( FALSE );                                            \
      break;                                                      \
   }
#endif  // ASSERT_BREAK_ON_FAILED_HRESULT


#ifndef BREAK_ON_FAILED_HRESULT_AND_SET
#define BREAK_ON_FAILED_HRESULT_AND_SET(hr,newHr)                 \
   if (FAILED(hr))                                                \
   {                                                              \
      hr = (newHr);                                               \
      break;                                                      \
   }
#endif  // BREAK_ON_FAILED_HRESULT_AND_SET


#ifndef NO_HELP
  #define NO_HELP (static_cast<DWORD>(-1))
#endif //NO_HELP


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\sendcmsg\app.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       App.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
// App.h: Definition of the CSendConsoleMessageApp class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_APP_H__B1AFF7D1_0C49_11D1_BB12_00C04FC9A3A3__INCLUDED_)
#define AFX_APP_H__B1AFF7D1_0C49_11D1_BB12_00C04FC9A3A3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CSendConsoleMessageApp

class CSendConsoleMessageApp : 
	public ISendConsoleMessageApp,
	public IExtendContextMenu,
	public CComObjectRoot,
	public CComCoClass<CSendConsoleMessageApp,&CLSID_SendConsoleMessageApp>
{
public:
	CSendConsoleMessageApp() {}
BEGIN_COM_MAP(CSendConsoleMessageApp)
	COM_INTERFACE_ENTRY(ISendConsoleMessageApp)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CSendConsoleMessageApp) 

DECLARE_REGISTRY( CSendConsoleMessageApp,
                  _T("SENDCMSG.SendConsoleMessageApp.1"),
                  _T("SENDCMSG.SendConsoleMessageApp.1"),
                  IDS_SENDCONSOLEMESSAGEAPP_DESC,
                  THREADFLAGS_BOTH )

public:
// IExtendContextMenu
	STDMETHOD(AddMenuItems)(
		IN IDataObject * pDataObject,
		OUT	IContextMenuCallback * pContextMenuCallback,
		INOUT long * pInsertionAllowed);
	STDMETHOD(Command)(LONG lCommandID, IDataObject * pDataObject);

public:

}; // CSendConsoleMessageApp

#endif // !defined(AFX_APP_H__B1AFF7D1_0C49_11D1_BB12_00C04FC9A3A3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\sendcmsg\app.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       App.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
// App.cpp : Implementation of CSendConsoleMessageApp snapin

#include "stdafx.h"
#include "debug.h"
#include "util.h"
#include "resource.h"
#include "SendCMsg.h"
#include "dialogs.h"
#include "App.h"

// Menu IDs
#define	cmSendConsoleMessage	100		// Menu Command Id to invoke the dialog


/////////////////////////////////////////////////////////////////////
//	CSendConsoleMessageApp::IExtendContextMenu::AddMenuItems()
STDMETHODIMP 
CSendConsoleMessageApp::AddMenuItems(
	IN IDataObject * /*pDataObject*/,
	OUT	IContextMenuCallback * pContextMenuCallback,
	INOUT long * /*pInsertionAllowed*/)
	{
	HRESULT hr;
	CONTEXTMENUITEM cmiSeparator = { 0 };
	cmiSeparator.lInsertionPointID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
	cmiSeparator.fSpecialFlags = CCM_SPECIAL_SEPARATOR;
	hr = pContextMenuCallback->AddItem(IN &cmiSeparator);
	Assert(SUCCEEDED(hr));
	
	TCHAR szMenuItem[128];
	TCHAR szStatusBarText[256];
	CchLoadString(IDS_MENU_SEND_MESSAGE, OUT szMenuItem, LENGTH(szMenuItem));
	CchLoadString(IDS_STATUS_SEND_MESSAGE, OUT szStatusBarText, LENGTH(szStatusBarText));
	CONTEXTMENUITEM cmi = { 0 };
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
	cmi.lCommandID = cmSendConsoleMessage;
	cmi.strName = szMenuItem;
	cmi.strStatusBarText = szStatusBarText;
	hr = pContextMenuCallback->AddItem(IN &cmi);
	Assert(SUCCEEDED(hr));

	hr = pContextMenuCallback->AddItem(IN &cmiSeparator);
	Assert(SUCCEEDED(hr));
	return S_OK;
	}

/////////////////////////////////////////////////////////////////////
//	CSendConsoleMessageApp::IExtendContextMenu::Command()
STDMETHODIMP
CSendConsoleMessageApp::Command(LONG lCommandID, IDataObject * pDataObject)
	{
	if (lCommandID == cmSendConsoleMessage)
		{
		(void)DoDialogBox(
			IDD_SEND_CONSOLE_MESSAGE,
			::GetActiveWindow(),
			(DLGPROC)CSendConsoleMessageDlg::DlgProc,
			(LPARAM)pDataObject);
		}
	return S_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\sendcmsg\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       debug.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
//	Debug.h
//
#ifdef _DEBUG
	#define DEBUG
#endif

#ifdef DEBUG
	//
	// Debug code
	//
	#define DebugCode(x)	x
	#define GarbageInit(pv, cb)	memset(pv, 'a', cb)
	int CchLoadString(UINT uIdString, TCHAR szBuffer[], int cchBuffer);
#else
	//
	// Retail code
	//
	#define DebugCode(x)
	#define GarbageInit(pv, cb)
	#define CchLoadString(uIdString, szBuffer, cchBuffer)	\
			::LoadString(g_hInstance, uIdString, szBuffer, cchBuffer)
#endif


#ifdef DEBUG
	/////////////////////////////////////////////
	void DoDebugAssert(LPCTSTR pszFile, int nLine, LPCTSTR pszExpr);
	#define Assert(f)	if (!(f)) { DoDebugAssert(_T(__FILE__), __LINE__, _T(#f)); } else { }
	#define Report(f)	Assert(f)
	#define Endorse(f)	if (f) { } else { }
	#define VERIFY(f)	Assert(f)

	/////////////////////////////////////////////
	void DebugTracePrintf(const TCHAR * szFormat, ...);
	#define Trace0(sz)				DebugTracePrintf(_T("%s"), _T(sz));
	#define Trace1(sz, p1)			DebugTracePrintf(_T(sz), p1);
	#define Trace2(sz, p1, p2)		DebugTracePrintf(_T(sz), p1, p2);
	#define Trace3(sz, p1, p2, p3)	DebugTracePrintf(_T(sz), p1, p2, p3);
	
#else
	#define Assert(f)
	#define Report(f)
	#define Endorse(f)
	#define VERIFY(f)	f

	#define Trace0(sz)
	#define Trace1(sz, p1)
	#define Trace2(sz, p1, p2)
	#define Trace3(sz, p1, p2, p3)

#endif // ~DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\sendcmsg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sendcmsg.rc
//
#define IDS_CAPTION                     100
#define IDS_SENDCONSOLEMESSAGEAPP_DESC  101
#define IDB_BITMAP_COMPUTER             102
#define IDD_DISPATCH_MESSAGES           103
#define IDS_MENU_SEND_MESSAGE           105
#define IDS_STATUS_SEND_MESSAGE         106
#define IDD_SEND_CONSOLE_MESSAGE        130
#define IDD_ADVANCED_MESSAGE_OPTIONS    132
#define IDS_RECIPIENT_ALREADY_EXISTS    200
#define IDS_ERR_CANNOT_SEND_TO_ALL_RECIPIENTS 201
#define IDS_MESSAGE_COULD_NOT_BE_SENT   202
#define IDS_1_RECIPIENT_NOT_CONTACTED   203
#define IDC_EDIT_MESSAGE_TEXT           900
#define IDC_LIST_RECIPIENTS             901
#define IDC_BUTTON_ADVANCED             902
#define IDC_BUTTON_ADD_RECIPIENT        903
#define IDC_BUTTON_REMOVE_RECIPIENT     904
#define IDC_STATIC_RESOURCE_NAME        1000
#define IDC_STATIC_SHUTDOWN_OCCURS      1001
#define IDC_STATIC_SHUTDOWN_OCCURS_UNIT 1002
#define IDC_STATIC_RESEND               1003
#define IDC_EDIT_RESOURCE_NAME          1004
#define IDC_EDIT_SHUTDOWN_OCCURS        1005
#define IDC_EDIT_RESEND                 1006
#define IDC_CHECK_SEND_AUTOMATED_MESSAGE 1007
#define IDC_EDIT_RESOURCE_BACK_ONLINE   1008
#define IDC_SPIN_SHUTDOWN_OCCURS        1009
#define IDC_SPIN_RESEND                 1010
#define IDC_STATIC_RESEND_UNIT          1011
#define IDC_STATIC_RESOURCE_BACK_ONLINE 1012
#define IDC_PROGRESS_MESSAGES           1013
#define IDC_STATIC_RECIPIENT            1014
#define IDC_STATIC_MESSAGE_OF           1015
#define IDC_STATIC_ERRORS_ENCOUNTERED   1016

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1019
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\sendcmsg\stdafx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       stdafx.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B1AFF7C6_0C49_11D1_BB12_00C04FC9A3A3__INCLUDED_)
#define AFX_STDAFX_H__B1AFF7C6_0C49_11D1_BB12_00C04FC9A3A3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <commctrl.h>

extern "C"
{
#include <lmcons.h>
#include <lmmsg.h>
}

#include <mmc.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B1AFF7C6_0C49_11D1_BB12_00C04FC9A3A3__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\sendcmsg\dialogs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       dialogs.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
//	Dialogs.h



/////////////////////////////////////////////////////////////////////
class CSendConsoleMessageDlg
{
  protected:
	HWND m_hdlg;					// Handle of the dialog
	HWND m_hwndEditMessageText;		// Handle of edit control for the message text
	HWND m_hwndListviewRecipients;	// Handle of the listview of the recipients
	HIMAGELIST m_hImageList;		// Image list for the listview control
	volatile int m_cRefCount;		// Reference count of object

  public:
	CSendConsoleMessageDlg();
	~CSendConsoleMessageDlg();
	static INT_PTR DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

  protected:
	void AddRef();
	void Release();
	
	void OnInitDialog(HWND hdlg, IDataObject * pDataObject);
	void OnOK();
	LRESULT OnNotify(NMHDR * pNmHdr);
	BOOL OnHelp(LPARAM lParam, int nDlgIDD);
    void DoContextHelp (HWND hWndControl, int nDlgIDD);
    void DoSendConsoleMessageContextHelp (HWND hWndControl);

  protected:
	int AddRecipient(LPCTSTR pszRecipient, BOOL fSelectItem = FALSE);

	void UpdateUI();
	void EnableDlgItem(INT nIdDlgItem, BOOL fEnable);

  protected:
	// Dispatch info
	enum PROGRES_STATUS_ENUM
	{
		e_statusDlgInit = 1,	// Dialog is initializing
		e_statusDlgDispatching,	// Dialog is dispatching message to recipients
		e_statusDlgCompleted,	// The dialog completed the operation (with or without errors)
		e_statusUserCancel,		// The user clicked on the "Cancel" button
	};
	struct
	{
		PROGRES_STATUS_ENUM status;
		BYTE * pargbItemStatus;		// Array of boolean indicating the status of each recipient
		int cErrors;				// Number of errors while sending messages
		CRITICAL_SECTION cs;		// Synchronization object for the "status" variable
		volatile HWND hdlg;					// Handle of the "Progress Dialog"
		volatile HWND hctlStaticRecipient;
		volatile HWND hctlStaticMessageOf;
		volatile HWND hctlStaticErrors;
		volatile HWND hctlProgressBar;
	} m_DispatchInfo;
	void DispatchMessageToRecipients();
	static INT_PTR DlgProcDispatchMessageToRecipients(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
	static DWORD WINAPI ThreadProcDispatchMessageToRecipients(CSendConsoleMessageDlg * pThis);
}; // CSendConsoleMessageDlg


/////////////////////////////////////////////////////////////////////
class CSendMessageAdvancedOptionsDlg
{
  protected:
	HWND m_hdlg;
	BOOL m_fSendAutomatedMessage;

  public:
	static INT_PTR DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

  protected:
	void OnInitDialog(HWND hdlg);	
	void UpdateUI();
	BOOL OnHelp(LPARAM lParam);
}; // CSendMessageAdvancedOptionsDlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\sendcmsg\sendcmsg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       SendCMsg.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
// SendCMsg.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f SendCMsgps.mk in the project directory.

#include "stdafx.h"
#include "initguid.h"
#include "SendCMsg.h"
#include "SendCMsg_i.c"
#include "debug.h"
#include "util.h"
#include "resource.h"
#include "App.h"

#include <atlimpl.cpp>

HINSTANCE g_hInstance;
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_SendConsoleMessageApp, CSendConsoleMessageApp)
END_OBJECT_MAP()

// GUID for the CSendConsoleMessageApp class
#define d_szGuidSendConsoleMessageApp	_T("{B1AFF7D0-0C49-11D1-BB12-00C04FC9A3A3}")

#if 0
// To have sendcmsg.dll to extend your context menu, add the following
// key into the registry
//
[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\MMC\NodeTypes\
	{476e6448-aaff-11d0-b944-00c04fd8d5b0}\Extensions\ContextMenu]
		"{B1AFF7D0-0C49-11D1-BB12-00C04FC9A3A3}"="Send Console Message"

// where {476e6448-aaff-11d0-b944-00c04fd8d5b0} is
// the GUID for the nodetype which you want to be extended.
#endif

// The following is an array of GUIDs of snapins that wants to be
// automatically extended by the Send Console Message Snapin.
// When the snapin registers itself, it will extend those nodetypes.
const LPCTSTR rgzpszGuidNodetypeContextMenuExtensions[] =
	{
	_T("{476e6446-aaff-11d0-b944-00c04fd8d5b0}"),	// Computer Management
	_T("{4e410f0e-abc1-11d0-b944-00c04fd8d5b0}"),	// Root of File Service Management subtree	
	_T("{4e410f0f-abc1-11d0-b944-00c04fd8d5b0}"),	// FSM - Shares
	_T("{4e410f12-abc1-11d0-b944-00c04fd8d5b0}"),	// System Service Management
	};

// The following is an array of GUIDs of snapins that no longer want
// to be automatically extended by the Send Console Message Snapin.
const LPCTSTR rgzpszRemoveContextMenuExtensions[] =
	{
	_T("{476e6448-aaff-11d0-b944-00c04fd8d5b0}"),	// Computer Management -> SystemTools
	_T("{0eeeeeee-d390-11cf-b607-00c04fd8d565}"), // invalid
	_T("{1eeeeeee-d390-11cf-b607-00c04fd8d565}"),	// invalid
	_T("{7eeeeeee-d390-11cf-b607-00c04fd8d565}"), // invalid
	};

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	g_hInstance = hInstance;
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	HRESULT hr = _Module.RegisterServer(TRUE);

	HKEY hkey = RegOpenOrCreateKey(
		HKEY_LOCAL_MACHINE,
		_T("Software\\Microsoft\\MMC\\SnapIns\\") d_szGuidSendConsoleMessageApp);
	if (hkey == NULL)
	{
		Assert(FALSE && "DllRegisterServer() - Unable to create key from registry.");
		return SELFREG_E_CLASS;
	}
	RegWriteString(hkey, _T("NameString"), IDS_CAPTION);
	RegCloseKey(hkey);

	for (int i = 0; i < LENGTH(rgzpszGuidNodetypeContextMenuExtensions); i++)
	{
		TCHAR szRegistryKey[256];
		Assert(rgzpszGuidNodetypeContextMenuExtensions[i] != NULL);
		wsprintf(OUT szRegistryKey,
		         _T("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\ContextMenu"),
		         rgzpszGuidNodetypeContextMenuExtensions[i]);
		Assert(lstrlen(szRegistryKey) < LENGTH(szRegistryKey));
		hkey = RegOpenOrCreateKey(HKEY_LOCAL_MACHINE, szRegistryKey);
		if (hkey == NULL)
		{
			Assert(FALSE && "DllRegisterServer() - Unable to create key from registry.");
			continue;
		}
		RegWriteString(hkey, d_szGuidSendConsoleMessageApp, IDS_CAPTION);
		RegCloseKey(hkey);
	} // for

	for (i = 0; i < LENGTH(rgzpszRemoveContextMenuExtensions); i++)
	{
		TCHAR szRegistryKey[256];
		Assert(rgzpszRemoveContextMenuExtensions[i] != NULL);
		wsprintf(OUT szRegistryKey,
		         _T("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\ContextMenu"),
		        rgzpszRemoveContextMenuExtensions[i]);
		Assert(lstrlen(szRegistryKey) < LENGTH(szRegistryKey));
		(void) RegOpenKey(HKEY_LOCAL_MACHINE, szRegistryKey, &hkey);
		if (hkey == NULL)
		{
			// not a problem
			continue;
		}
		(void) RegDeleteValue(hkey, d_szGuidSendConsoleMessageApp);
		// ignore error code, the only likely code is ERROR_FILE_NOT_FOUND
		RegCloseKey(hkey);
		hkey = NULL;
	} // for
	return hr;
} // DllRegisterServer()


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\sendcmsg\stdafx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       stdafx.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\sendcmsg\dialogs.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       Dialogs.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////
//      Dialogs.cpp
//
//      DlgProc for Send Console Message Snapin.
//
//      HISTORY
//      4-Aug-97    t-danm      Creation.
//      13 Feb 2001 bryanwal    Use object picker instead of add recipients 
//                              dialog
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <objsel.h>
#include "debug.h"
#include "util.h"
#include "dialogs.h"
#include "resource.h"
#include <htmlhelp.h> //<mmc.h>

#if 1
    #define ThreadTrace0(sz)        Trace0(sz)
    #define ThreadTrace1(sz, p1)    Trace1(sz, p1)
#else
    #define ThreadTrace0(sz)
    #define ThreadTrace1(sz, p1)
#endif

const PCWSTR CONTEXT_HELP_FILE = L"sendcmsg.hlp";
const PCWSTR HTML_HELP_FILE = L"sendcmsg.chm";

// Register clipboard formats used by the Send Console Message
UINT g_cfSendConsoleMessageText = ::RegisterClipboardFormat(_T("mmc.sendcmsg.MessageText"));
UINT g_cfSendConsoleMessageRecipients = ::RegisterClipboardFormat(_T("mmc.sendcmsg.MessageRecipients"));

enum
{
    iImageComputer = 0,         // Generic image of a computer
    iImageComputerOK,
    iImageComputerError
};

// Maximum length of a recipient (machine name)
const int cchRecipientNameMax = MAX_PATH;

enum
{
    COL_NAME = 0,
    COL_RESULT,
    NUM_COLS        // must be last
};

#define IID_PPV_ARG(Type, Expr) IID_##Type, \
    reinterpret_cast<void**>(static_cast<Type **>(Expr))
/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Generic Computer Picker
///////////////////////////////////////////////////////////////////////////////

//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForComputers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick a single computer object.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT InitObjectPickerForComputers(IDsObjectPicker *pDsObjectPicker)
{
	if ( !pDsObjectPicker )
		return E_POINTER;

	//
	// Prepare to initialize the object picker.
	// Set up the array of scope initializer structures.
	//

	static const int SCOPE_INIT_COUNT = 2;
	DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

	ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

	//
	// 127399: JonN 10/30/00 JOINED_DOMAIN should be starting scope
	//

	aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
	aScopeInit[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
	                     | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
	aScopeInit[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
	aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
	aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

	aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
	aScopeInit[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
	                     | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
	                     | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
	                     | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
	                     | DSOP_SCOPE_TYPE_WORKGROUP
	                     | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
	                     | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
	aScopeInit[1].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
	aScopeInit[1].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

	//
	// Put the scope init array into the object picker init array
	//

	DSOP_INIT_INFO  initInfo;
	ZeroMemory(&initInfo, sizeof(initInfo));

	initInfo.cbSize = sizeof(initInfo);
	initInfo.pwzTargetComputer = NULL;  // NULL == local machine
	initInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
	initInfo.aDsScopeInfos = aScopeInit;
	initInfo.cAttributesToFetch = 1;
	static PCWSTR pwszDnsHostName = L"dNSHostName";
	initInfo.apwzAttributeNames = &pwszDnsHostName;

	//
	// Note object picker makes its own copy of initInfo.  Also note
	// that Initialize may be called multiple times, last call wins.
	//

	return pDsObjectPicker->Initialize(&initInfo);
}

//+--------------------------------------------------------------------------
//
//  Function:   ProcessSelectedObjects
//
//  Synopsis:   Retrieve the list of selected items from the data object
//              created by the object picker and print out each one.
//
//  Arguments:  [pdo] - data object returned by object picker
//
//  History:    10-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT ProcessSelectedObjects(IDataObject *pdo, PWSTR computerName, int cbLen)
{
	if ( !pdo )
		return E_POINTER;

	HRESULT hr = S_OK;
	static UINT g_cfDsObjectPicker =
		RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

	STGMEDIUM stgmedium =
	{
		TYMED_HGLOBAL,
		NULL,
		NULL
	};

	FORMATETC formatetc =
	{
		(CLIPFORMAT)g_cfDsObjectPicker,
		NULL,
		DVASPECT_CONTENT,
		-1,
		TYMED_HGLOBAL
	};

	bool fGotStgMedium = false;

	do
	{
		hr = pdo->GetData(&formatetc, &stgmedium);
		if ( SUCCEEDED (hr) )
		{
			fGotStgMedium = true;

			PDS_SELECTION_LIST pDsSelList =
				(PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

			if (!pDsSelList)
			{
				hr = HRESULT_FROM_WIN32 (GetLastError());
				break;
			}

			Assert (1 == pDsSelList->cItems);
			if ( 1 == pDsSelList->cItems )
			{
				PDS_SELECTION psel = &(pDsSelList->aDsSelection[0]);
				VARIANT* pvarDnsName = &(psel->pvarFetchedAttributes[0]);
				if (   NULL == pvarDnsName
				    || VT_BSTR != pvarDnsName->vt
				    || NULL == pvarDnsName->bstrVal
				    || L'\0' == (pvarDnsName->bstrVal)[0] )
				{
					wcsncpy (computerName, psel->pwzName, cbLen);
				} 
                else 
                {
					wcsncpy (computerName, pvarDnsName->bstrVal, cbLen);
				}
			}
			else
				hr = E_UNEXPECTED;
			

			GlobalUnlock(stgmedium.hGlobal);
		}
	} while (0);

	if (fGotStgMedium)
	{
		ReleaseStgMedium(&stgmedium);
	}

	return hr;
}



///////////////////////////////////////////////////////////////////////////////
// Generic method for launching a single-select computer picker
//
//	Paremeters:
//		hwndParent (IN)	- window handle of parent window
//		computerName (OUT) - computer name returned
//
//	Returns S_OK if everything succeeded, S_FALSE if user pressed "Cancel"
//		
//////////////////////////////////////////////////////////////////////////////
HRESULT	ComputerNameFromObjectPicker (HWND hwndParent, PWSTR computerName, int cbLen)
{
	//
	// Create an instance of the object picker.  The implementation in
	// objsel.dll is apartment model.
	//
	CComPtr<IDsObjectPicker> spDsObjectPicker;
	HRESULT hr = CoCreateInstance(CLSID_DsObjectPicker,
	                              NULL,
	                              CLSCTX_INPROC_SERVER,
	                              IID_IDsObjectPicker,
	                              (void **) &spDsObjectPicker);
	if ( SUCCEEDED (hr) )
	{
		Assert(!!spDsObjectPicker);
		//
		// Initialize the object picker to choose computers
		//

		hr = InitObjectPickerForComputers(spDsObjectPicker);
		if ( SUCCEEDED (hr) )
		{
			//
			// Now pick a computer
			//
			CComPtr<IDataObject> spDataObject;

			hr = spDsObjectPicker->InvokeDialog(hwndParent, &spDataObject);
			if ( S_OK == hr )
			{
				Assert(!!spDataObject);
				hr = ProcessSelectedObjects(spDataObject, computerName, cbLen);
			}
		}
	}

	return hr;
}




/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
CSendConsoleMessageDlg::CSendConsoleMessageDlg()
: m_cRefCount (0),
    m_hImageList (0),
    m_hdlg (0),
    m_hwndEditMessageText (0),
    m_hwndListviewRecipients (0)
{
    m_DispatchInfo.pargbItemStatus = NULL;
    InitializeCriticalSection(OUT &m_DispatchInfo.cs);
}

CSendConsoleMessageDlg::~CSendConsoleMessageDlg()
{
    ThreadTrace0("Destroying CSendConsoleMessageDlg object.\n");
    Assert(m_hdlg == NULL);
    delete m_DispatchInfo.pargbItemStatus;
    DeleteCriticalSection(IN &m_DispatchInfo.cs);
}

/////////////////////////////////////////////////////////////////////
void CSendConsoleMessageDlg::AddRef()
{
    EnterCriticalSection(INOUT &m_DispatchInfo.cs);
    Assert(m_cRefCount >= 0);
    Assert(HIWORD(m_cRefCount) == 0);
    m_cRefCount++;
    LeaveCriticalSection(INOUT &m_DispatchInfo.cs);
}

/////////////////////////////////////////////////////////////////////
void CSendConsoleMessageDlg::Release()
{
    EnterCriticalSection(INOUT &m_DispatchInfo.cs);
    Assert(HIWORD(m_cRefCount) == 0);
    m_cRefCount--;
    BOOL fDeleteObject = (m_cRefCount <= 0);
    if (m_hdlg != NULL)
    {
        Assert(IsWindow(m_hdlg));
        // Cause the UI to refresh
        PostMessage(m_hdlg, WM_COMMAND, MAKEWPARAM(IDC_EDIT_MESSAGE_TEXT, EN_CHANGE), 0);
    }
    LeaveCriticalSection(INOUT &m_DispatchInfo.cs);
    if (fDeleteObject)
        delete this;
}

/////////////////////////////////////////////////////////////////////
void CSendConsoleMessageDlg::OnInitDialog(HWND hdlg, IDataObject * pDataObject)
{
    Assert(IsWindow(hdlg));
    Assert(pDataObject != NULL);
    if ( !IsWindow (hdlg) || ! pDataObject )
        return;

    m_hdlg = hdlg;
    m_hwndEditMessageText = GetDlgItem(m_hdlg, IDC_EDIT_MESSAGE_TEXT);
    m_hwndListviewRecipients = GetDlgItem(m_hdlg, IDC_LIST_RECIPIENTS);
    Assert(::IsWindow(m_hwndEditMessageText));
    Assert(::IsWindow(m_hwndListviewRecipients));

    WCHAR * pawszMessage = NULL;
    (void) HrExtractDataAlloc(IN pDataObject, g_cfSendConsoleMessageText, OUT (PVOID *)&pawszMessage);

    // Set the initial message text
	if ( pawszMessage )
	{
		SetWindowTextW(m_hwndEditMessageText, pawszMessage);
	    GlobalFree(pawszMessage);
	}
    SendMessage(m_hwndEditMessageText, EM_SETSEL, 0, 0);
    SetFocus(m_hwndEditMessageText);

    Assert(m_hImageList == NULL);
    m_hImageList = ImageList_LoadImage(
        g_hInstance,
        MAKEINTRESOURCE(IDB_BITMAP_COMPUTER),
        16, 3, RGB(255, 0, 255),
        IMAGE_BITMAP, 0);
    Report(m_hImageList != NULL);
    ListView_SetImageList(m_hwndListviewRecipients, m_hImageList, LVSIL_SMALL);

    // Set up columns in list view
    int             colWidths[NUM_COLS] = {150, 200};
    LVCOLUMN    lvColumn;
    ::ZeroMemory (&lvColumn, sizeof (LVCOLUMN));

    lvColumn.mask = LVCF_WIDTH;
    lvColumn.cx = colWidths[COL_NAME];
    int nCol = ListView_InsertColumn (m_hwndListviewRecipients, COL_NAME, &lvColumn);
    Assert (-1 != nCol);

    lvColumn.cx = colWidths[COL_RESULT];
    nCol = ListView_InsertColumn (m_hwndListviewRecipients, COL_RESULT, &lvColumn);
    Assert (-1 != nCol);

	// Get the list of recipients
	WCHAR * pagrwszRecipients = NULL;
	(void)HrExtractDataAlloc(IN pDataObject, g_cfSendConsoleMessageRecipients, OUT (PVOID *)&pagrwszRecipients);
	if (pagrwszRecipients == NULL)
	{
		UpdateUI();
		return;
	}
	// Add the recipients to the listview
	const WCHAR * pszRecipient = pagrwszRecipients;
	while (*pszRecipient != '\0')
	{
        // Strip off leading "\\" if present.
        if ( !_wcsnicmp (pszRecipient, L"\\\\", 2) )
        {
            pszRecipient+= 2;
        }
		AddRecipient(pszRecipient);
		while(*pszRecipient++ != '\0')
			;	// Skip until the next string
	} // while

    // NTRAID# 213370 [SENDCMSG] Accessibility - Main dialog tab stop on 
    // Recipients listview has no visible focus indicator until object is 
    // selected
    int nIndex = ListView_GetTopIndex (m_hwndListviewRecipients);
    ListView_SetItemState (m_hwndListviewRecipients, nIndex, LVIS_FOCUSED, 
            LVIS_FOCUSED);

	GlobalFree(pagrwszRecipients);
	UpdateUI();
} // CSendConsoleMessageDlg::OnInitDialog()


/////////////////////////////////////////////////////////////////////
void CSendConsoleMessageDlg::OnOK()
{
    Assert(m_cRefCount == 1 && "There is already another thread running.");
    m_DispatchInfo.status = e_statusDlgInit;
    m_DispatchInfo.cErrors = 0;
    delete m_DispatchInfo.pargbItemStatus;
    m_DispatchInfo.pargbItemStatus = NULL;
    (void)DoDialogBox(IDD_DISPATCH_MESSAGES, m_hdlg,
        (DLGPROC)DlgProcDispatchMessageToRecipients, (LPARAM)this);
    if (m_DispatchInfo.cErrors == 0 && m_DispatchInfo.status == e_statusDlgCompleted)
    {
        // No problems dispatching the message to recipients
        EndDialog(m_hdlg, TRUE);    // Close the dialog
        return;
    }
    Assert(IsWindow(m_hwndListviewRecipients));
    ListView_UnselectAllItems(m_hwndListviewRecipients);
    if (m_DispatchInfo.cErrors > 0)
    {
        DoMessageBox(IDS_ERR_CANNOT_SEND_TO_ALL_RECIPIENTS);
    }
    // We did not finished the job, so display the status to the UI
    if (m_DispatchInfo.pargbItemStatus == NULL)
    {
        // The progress was unable to allocate memory for the status
        Trace0("CSendConsoleMessageDlg::OnOK() - Out of memory.\n");
        return;
    }

    // Remove all the successful items, leaving only the failed targets and
    // the unsent targets (in the event the user pressed Cancel).
    int     iItem = ListView_GetItemCount (m_hwndListviewRecipients);
    iItem--;
    const BYTE * pb = m_DispatchInfo.pargbItemStatus + iItem;

    for (; iItem >= 0 && pb >= m_DispatchInfo.pargbItemStatus;
            pb--, iItem--)
    {
        if ( *pb == iImageComputerOK )
            VERIFY (ListView_DeleteItem (m_hwndListviewRecipients, iItem));
    }
} // CSendConsoleMessageDlg::OnOK()


/////////////////////////////////////////////////////////////////////
void CSendConsoleMessageDlg::DispatchMessageToRecipients()
{
    const int cRecipients = ListView_GetItemCount(m_hwndListviewRecipients);
    TCHAR szT[100 + cchRecipientNameMax];
    TCHAR szFmtStaticRecipient[128];    // "Sending console message to %s..."
    TCHAR szFmtStaticMessageOf[128];    // "Sending message %d of %d."
    TCHAR szFmtStaticTotalErrors[128];      // "Total errors encountered\t%d."
    GetWindowText(m_DispatchInfo.hctlStaticRecipient, OUT szFmtStaticRecipient, LENGTH(szFmtStaticRecipient));
    GetWindowText(m_DispatchInfo.hctlStaticMessageOf, szFmtStaticMessageOf, LENGTH(szFmtStaticMessageOf));
    GetWindowText(m_DispatchInfo.hctlStaticErrors, OUT szFmtStaticTotalErrors, LENGTH(szFmtStaticTotalErrors));
    SendMessage(m_DispatchInfo.hctlProgressBar, PBM_SETRANGE, 0, MAKELPARAM(0, cRecipients));

    //
    // Set the image of each recipient to normal computer
    //
    ListView_UnselectAllItems(m_hwndListviewRecipients);
    for (int i = 0; i < cRecipients; i++)
    {
        ListView_SetItemImage(m_hwndListviewRecipients, i, iImageComputer);
        ListView_SetItemText(m_hwndListviewRecipients, i, COL_RESULT, L"");
    }
    UpdateUI();         // Update the other UI controls (especially OK button)

    //
    // Get the text from the edit control
    //
    int cchMessage = GetWindowTextLength(m_hwndEditMessageText) + 1;
    WCHAR * pawszMessage = new WCHAR[cchMessage];
    if (pawszMessage != NULL)
    {
        GetWindowTextW(m_hwndEditMessageText, OUT pawszMessage, cchMessage);
    }
    else
    {
        cchMessage = 0;
        Trace0("Unable to allocate memory for message.\n");
    }

    WCHAR wszRecipient[cchRecipientNameMax];
    LV_ITEMW lvItem;
    GarbageInit(OUT &lvItem, sizeof(lvItem));
    lvItem.iItem = 0;
    lvItem.iSubItem = 0;
    lvItem.pszText = wszRecipient;
    lvItem.cchTextMax = LENGTH(wszRecipient);

    Assert(m_DispatchInfo.pargbItemStatus == NULL && "Memory Leak");
    m_DispatchInfo.pargbItemStatus = new BYTE[cRecipients+1];
    if (m_DispatchInfo.pargbItemStatus != NULL)
    {
        memset(OUT m_DispatchInfo.pargbItemStatus, iImageComputer, cRecipients+1);
    }
    else
    {
        Trace0("Unable to allocate memory for listview item status.\n");
    }

    Assert(m_DispatchInfo.status == e_statusDlgInit);
    m_DispatchInfo.status = e_statusDlgDispatching; // Allow the user to cancel the dialog

    TCHAR szFailure[128];
    CchLoadString(IDS_MESSAGE_COULD_NOT_BE_SENT, OUT szFailure,
            LENGTH(szFailure));

    for (i = 0; i < cRecipients; i++)
    {
        ThreadTrace1("Sending message to recipient %d.\n", i + 1);
        EnterCriticalSection(INOUT &m_DispatchInfo.cs);
        if (m_DispatchInfo.status == e_statusUserCancel)
        {
            ThreadTrace0("DispatchMessageToRecipients() - Aborting loop @1...\n");
            LeaveCriticalSection(INOUT &m_DispatchInfo.cs);
            break;
        }
        ListView_SelectItem(m_hwndListviewRecipients, i);
        ListView_EnsureVisible(m_hwndListviewRecipients, i, FALSE);
        lvItem.iItem = i;
        wszRecipient[0] = '\0';
        // Get the recipient name
        SendMessage(m_hwndListviewRecipients, LVM_GETITEMTEXTW, i, OUT (LPARAM)&lvItem);
        if (m_DispatchInfo.pargbItemStatus != NULL)
            m_DispatchInfo.pargbItemStatus[i] = iImageComputerError;
        wsprintf(OUT szT, szFmtStaticRecipient, wszRecipient);
        SetWindowTextW(m_DispatchInfo.hctlStaticRecipient, szT);
        wsprintf(OUT szT, szFmtStaticMessageOf, i + 1, cRecipients);
        SetWindowText(m_DispatchInfo.hctlStaticMessageOf, szT);

        switch ( m_DispatchInfo.cErrors )
        {
        case 0:
            break;

        case 1:
            ::ShowWindow (m_DispatchInfo.hctlStaticErrors, SW_SHOW);
            {
                TCHAR sz1NotSet[128];
                CchLoadString(IDS_1_RECIPIENT_NOT_CONTACTED, OUT sz1NotSet,
                        LENGTH(sz1NotSet));

                SetWindowText(m_DispatchInfo.hctlStaticErrors, sz1NotSet);
            }
            break;

        default:
            wsprintf(OUT szT, szFmtStaticTotalErrors, m_DispatchInfo.cErrors);
            SetWindowText(m_DispatchInfo.hctlStaticErrors, szT);
            break;
        }
        LeaveCriticalSection(INOUT &m_DispatchInfo.cs);

        // Send the message to the recipient (ie, computer)
        NET_API_STATUS err;
        err = ::NetMessageBufferSend(
            NULL,
            wszRecipient,
            NULL,
            (BYTE *)pawszMessage,
            cchMessage * sizeof(WCHAR));
        int iImage = iImageComputerOK;
        if (err != ERROR_SUCCESS)
        {
            Trace3("Error sending message to recipient %ws. err=%d (0x%X).\n", wszRecipient, err, err);
            m_DispatchInfo.cErrors++;
            iImage = iImageComputerError;
        }
        if (m_DispatchInfo.pargbItemStatus != NULL)
            m_DispatchInfo.pargbItemStatus[i] = (BYTE)iImage;

        EnterCriticalSection(INOUT &m_DispatchInfo.cs);
        if (m_DispatchInfo.status == e_statusUserCancel)
        {
            ThreadTrace0("DispatchMessageToRecipients() - Aborting loop @2...\n");
            LeaveCriticalSection(INOUT &m_DispatchInfo.cs);
            break;
        }
        //
        // Update the listview
        //
        ListView_UnselectItem(m_hwndListviewRecipients, i);
        ListView_SetItemImage(m_hwndListviewRecipients, i, iImage);
        if ( iImage == iImageComputerError )
            ListView_SetItemText(m_hwndListviewRecipients, i, COL_RESULT,
                    szFailure);

        //
        // Update the progress dialog
        //
        SendMessage(m_DispatchInfo.hctlProgressBar, PBM_SETPOS, i + 1, 0);
        LeaveCriticalSection(INOUT &m_DispatchInfo.cs);
    } // for
    delete pawszMessage;
    Sleep(500);
    EnterCriticalSection(INOUT &m_DispatchInfo.cs);
    if (m_DispatchInfo.status != e_statusUserCancel)
    {
        // We are done dispatching the message to all the recipients
        // and the user did not canceled the operation.
        m_DispatchInfo.status = e_statusDlgCompleted;
        Assert(IsWindow(m_DispatchInfo.hdlg));
        EndDialog(m_DispatchInfo.hdlg, TRUE);   // Gracefully close the dialog
    }
    LeaveCriticalSection(INOUT &m_DispatchInfo.cs);
} // CSendConsoleMessageDlg::DispatchMessageToRecipients()


/////////////////////////////////////////////////////////////////////
//      Add a recipient to the listview control
//
//      Return the index of the inserted item.
//
int CSendConsoleMessageDlg::AddRecipient(
    LPCTSTR pszRecipient,   // IN: Machine name
    BOOL fSelectItem)           // TRUE => Select the item that is inserted
{
    Assert(pszRecipient != NULL);

    LV_ITEM lvItem;
    GarbageInit(OUT &lvItem, sizeof(lvItem));
    lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
    lvItem.iSubItem = 0;
    lvItem.iImage = iImageComputer;
    lvItem.pszText = const_cast<TCHAR *>(pszRecipient);
    if (fSelectItem)
    {
        lvItem.mask = LVIF_TEXT | LVIF_IMAGE |LVIF_STATE;
        lvItem.state = LVIS_SELECTED;
    }
    return ListView_InsertItem(m_hwndListviewRecipients, IN &lvItem);
} // CSendConsoleMessageDlg::AddRecipient()


/////////////////////////////////////////////////////////////////////
LRESULT CSendConsoleMessageDlg::OnNotify(NMHDR * pNmHdr)
{
    Assert(pNmHdr != NULL);

    switch (pNmHdr->code)
    {
    case LVN_ENDLABELEDIT:
    {
        TCHAR * pszText = ((LV_DISPINFO *)pNmHdr)->item.pszText;
        if (pszText == NULL)
            break; // User canceled editing
        // HACK: Modifying a string which I'm not sure where it is allocated
        (void)FTrimString(INOUT pszText);
        // Check out if there is already another recipient
        int iItem = ListView_FindString(m_hwndListviewRecipients, pszText);
        if (iItem >= 0)
        {
            ListView_SelectItem(m_hwndListviewRecipients, iItem);
            DoMessageBox(IDS_RECIPIENT_ALREADY_EXISTS);
            break;
        }
        // Otherwise accept the changes
        SetWindowLongPtr(m_hdlg, DWLP_MSGRESULT, TRUE);
        return TRUE;
    }
    case LVN_ITEMCHANGED:   // Selection changed
        UpdateUI();
        break;
    case LVN_KEYDOWN:
        switch (((LV_KEYDOWN *)pNmHdr)->wVKey)
            {
        case VK_INSERT:
            SendMessage(m_hdlg, WM_COMMAND, IDC_BUTTON_ADD_RECIPIENT, 0);
            break;
        case VK_DELETE:
            SendMessage(m_hdlg, WM_COMMAND, IDC_BUTTON_REMOVE_RECIPIENT, 0);
            break;
        } // switch
        break;
    case NM_CLICK:
        UpdateUI();
        break;
    case NM_DBLCLK:
        UpdateUI();
        break;
    } // switch
    return 0;
} // CSendConsoleMessageDlg::OnNotify()


/////////////////////////////////////////////////////////////////////
void CSendConsoleMessageDlg::EnableDlgItem(INT nIdDlgItem, BOOL fEnable)
{
    Assert(::IsWindow(::GetDlgItem(m_hdlg, nIdDlgItem)));
    ::EnableWindow(::GetDlgItem(m_hdlg, nIdDlgItem), fEnable);
}


/////////////////////////////////////////////////////////////////////
void CSendConsoleMessageDlg::UpdateUI()
{
    Assert(m_cRefCount > 0);
    int cchMessage = GetWindowTextLength(m_hwndEditMessageText);
    int cItems = ListView_GetItemCount(m_hwndListviewRecipients);
    EnableDlgItem(IDOK, (cchMessage > 0) && (cItems > 0) && (m_cRefCount == 1));
    int iItemSelected = ListView_GetSelectedItem(m_hwndListviewRecipients);
    EnableDlgItem(IDC_BUTTON_REMOVE_RECIPIENT, iItemSelected >= 0);
    UpdateWindow(m_hwndListviewRecipients);
} // CSendConsoleMessageDlg::UpdateUI()


/////////////////////////////////////////////////////////////////////
//      Dialog proc for the Send Console Message snapin.
//
//      USAGE
//      DoDialogBox(IDD_SEND_CONSOLE_MESSAGE, ::GetActiveWindow(), CSendConsoleMessageDlg::DlgProc);
//
INT_PTR CSendConsoleMessageDlg::DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CSendConsoleMessageDlg * pThis;
    pThis = (CSendConsoleMessageDlg *)::GetWindowLongPtr(hdlg, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        Assert(pThis == NULL);
        if (pThis != NULL)
            return FALSE; 
        pThis = new CSendConsoleMessageDlg;
        if (pThis == NULL)
        {
            Trace0("Unable to allocate CSendConsoleMessageDlg object.\n");
            return -1;
        }
        SetWindowLongPtr(hdlg, GWLP_USERDATA, (LONG_PTR)pThis);
        pThis->AddRef();
        pThis->OnInitDialog(hdlg, (IDataObject *)lParam);
        SendDlgItemMessage (hdlg, IDC_EDIT_MESSAGE_TEXT, EM_LIMITTEXT, 885, 0);
        return FALSE;

    case WM_NCDESTROY:
        ThreadTrace0("CSendConsoleMessageDlg::DlgProc() - WM_NCDESTROY.\n");
        EnterCriticalSection(INOUT &pThis->m_DispatchInfo.cs);
        pThis->m_hdlg = NULL;
        LeaveCriticalSection(INOUT &pThis->m_DispatchInfo.cs);
        pThis->Release();
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                Assert((HWND)lParam == GetDlgItem(hdlg, IDOK));
                pThis->OnOK();
            }
            break;

        case IDCANCEL:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                Assert((HWND)lParam == GetDlgItem(hdlg, IDCANCEL));
                EndDialog(hdlg, FALSE);
            }
            break;

        case IDC_EDIT_MESSAGE_TEXT:
            if (HIWORD(wParam) == EN_CHANGE)
                pThis->UpdateUI();
            break;

        case IDC_BUTTON_ADD_RECIPIENT:
            {
                const int cbLen = MAX_PATH;
	            PWSTR   pszComputerName = new WCHAR[MAX_PATH];
                if ( pszComputerName )
                {
                    // S_FALSE means user pressed "Cancel"
	                if ( S_OK == ComputerNameFromObjectPicker (hdlg, 
                            pszComputerName, cbLen) )
    	            {
                        pThis->AddRecipient (pszComputerName, TRUE);
	                }
                    delete [] pszComputerName;
                }

                pThis->UpdateUI();
            }
            break;

        case IDC_BUTTON_REMOVE_RECIPIENT:
            while (TRUE)
            {
                // Remove all the selected recipients
                int iItem = ListView_GetSelectedItem(pThis->m_hwndListviewRecipients);
                if (iItem < 0)
                    break;
                ListView_DeleteItem(pThis->m_hwndListviewRecipients, iItem);
            }
            ::SetFocus(pThis->m_hwndListviewRecipients);
            pThis->UpdateUI();
            break;

        case IDC_BUTTON_ADVANCED:
            (void)DoDialogBox(IDD_ADVANCED_MESSAGE_OPTIONS, hdlg, (DLGPROC)CSendMessageAdvancedOptionsDlg::DlgProc);
            break;
        } // switch
        break;

    case WM_NOTIFY:
        Assert(wParam == IDC_LIST_RECIPIENTS);
        return pThis->OnNotify((NMHDR *)lParam);

    case WM_HELP:
        return pThis->OnHelp (lParam, IDD_SEND_CONSOLE_MESSAGE);

    default:
        return FALSE;
    } // switch
    return TRUE;
} // CSendConsoleMessageDlg::DlgProc()



/////////////////////////////////////////////////////////////////////
//      DlgProcDispatchMessageToRecipients()
//
//      Private dialog to indicate the progress while a background
//      thread dispatches a message to each recipient.
//
INT_PTR CSendConsoleMessageDlg::DlgProcDispatchMessageToRecipients(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CSendConsoleMessageDlg * pThis = (CSendConsoleMessageDlg *)::GetWindowLongPtr(hdlg, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        Assert(pThis == NULL);
        if (pThis != NULL)
            return FALSE;   
        pThis = (CSendConsoleMessageDlg *)lParam;
        SetWindowLongPtr(hdlg, GWLP_USERDATA, (LONG_PTR)pThis);
        Assert(pThis != NULL);
        Assert(pThis->m_DispatchInfo.status == e_statusDlgInit);
        pThis->m_DispatchInfo.hdlg = hdlg;
        pThis->m_DispatchInfo.hctlStaticRecipient = GetDlgItem(hdlg, IDC_STATIC_RECIPIENT);
        pThis->m_DispatchInfo.hctlStaticMessageOf = GetDlgItem(hdlg, IDC_STATIC_MESSAGE_OF);
        pThis->m_DispatchInfo.hctlStaticErrors = GetDlgItem(hdlg, IDC_STATIC_ERRORS_ENCOUNTERED);
        pThis->m_DispatchInfo.hctlProgressBar = GetDlgItem(hdlg, IDC_PROGRESS_MESSAGES);
        {
            DWORD dwThreadId;
            HANDLE hThread = ::CreateThread(NULL, 0,
                (LPTHREAD_START_ROUTINE)ThreadProcDispatchMessageToRecipients, pThis, 0, OUT &dwThreadId);
            Report(hThread != NULL && "Unable to create thread");
            if (hThread != NULL)
            {
                VERIFY( ::CloseHandle(hThread) );
            }
            else
            {
                Trace0("Unable to create thread.\n");
                // Prevent a potential deadlock
                pThis->m_DispatchInfo.status = e_statusUserCancel;      // Pretend the user clicked on cancel
                EndDialog(hdlg, FALSE);
            }
        }
        break;

    case WM_DESTROY:
        // Those variables are set to NULL just in case
        pThis->m_DispatchInfo.hdlg = NULL;
        pThis->m_DispatchInfo.hctlStaticRecipient = NULL;
        pThis->m_DispatchInfo.hctlStaticMessageOf = NULL;
        pThis->m_DispatchInfo.hctlStaticErrors = NULL;
        pThis->m_DispatchInfo.hctlProgressBar = NULL;
        break;

    case WM_COMMAND:
        if (wParam == IDCANCEL)
        {
            Trace0("INFO: WM_COMMAND: IDCANCEL: User canceled operation.\n");
            BOOL fEndDialog = FALSE;
            if (TryEnterCriticalSection(INOUT &pThis->m_DispatchInfo.cs))
            {
                if (pThis->m_DispatchInfo.status != e_statusDlgInit)
                {
                    pThis->m_DispatchInfo.status = e_statusUserCancel;
                    fEndDialog = TRUE;
                }
                LeaveCriticalSection(INOUT &pThis->m_DispatchInfo.cs);
            }
            if (fEndDialog)
            {
                EndDialog(hdlg, FALSE);
            }
            else
            {
                ThreadTrace0("Critical section already in use.  Try again...\n");
                PostMessage(hdlg, WM_COMMAND, IDCANCEL, 0);
                Sleep(100);
            } // if...else
        } // if
        break;

    case WM_HELP:
        return pThis->OnHelp (lParam, IDD_DISPATCH_MESSAGES);

    default:
        return FALSE;
    } // switch
    return TRUE;
} // CSendConsoleMessageDlg::DlgProcDispatchMessageToRecipients()


/////////////////////////////////////////////////////////////////////
DWORD CSendConsoleMessageDlg::ThreadProcDispatchMessageToRecipients(CSendConsoleMessageDlg * pThis)
{
    Assert(pThis != NULL);
    pThis->AddRef();
    Assert(pThis->m_cRefCount > 1);
    pThis->DispatchMessageToRecipients();
    pThis->Release();
    return 0;
} // CSendConsoleMessageDlg::ThreadProcDispatchMessageToRecipients()


#define IDH_EDIT_MESSAGE_TEXT 900
#define IDH_LIST_RECIPIENTS 901
#define IDH_BUTTON_ADD_RECIPIENT 903
#define IDH_BUTTON_REMOVE_RECIPIENT 904

const DWORD g_aHelpIDs_IDD_SEND_CONSOLE_MESSAGE[]=
{
    IDC_EDIT_MESSAGE_TEXT, IDH_EDIT_MESSAGE_TEXT,
    IDOK, IDOK,
    IDC_LIST_RECIPIENTS, IDH_LIST_RECIPIENTS,
    IDC_BUTTON_ADD_RECIPIENT, IDH_BUTTON_ADD_RECIPIENT,
    IDC_BUTTON_REMOVE_RECIPIENT, IDH_BUTTON_REMOVE_RECIPIENT,
    0, 0
};


BOOL CSendConsoleMessageDlg::OnHelp(LPARAM lParam, int nDlgIDD)
{
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        switch (nDlgIDD)
        {
        case IDD_SEND_CONSOLE_MESSAGE:
            DoSendConsoleMessageContextHelp ((HWND) pHelpInfo->hItemHandle);
            break;
        }
    }
    else
        HtmlHelpW (NULL, HTML_HELP_FILE, HH_DISPLAY_TOPIC, 0);
    return TRUE;
}

void CSendConsoleMessageDlg::DoSendConsoleMessageContextHelp (HWND hWndControl)
{
    switch (::GetDlgCtrlID (hWndControl))
	{
	case IDCANCEL:
    case IDC_BUTTON_ADVANCED:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				CONTEXT_HELP_FILE,
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_SEND_CONSOLE_MESSAGE) )
		{
			Trace1 ("WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
void CSendMessageAdvancedOptionsDlg::OnInitDialog(HWND hdlg)
{
    m_hdlg = hdlg;
    m_fSendAutomatedMessage = FALSE;
    CheckDlgButton(m_hdlg, IDC_CHECK_SEND_AUTOMATED_MESSAGE, m_fSendAutomatedMessage);
    UpdateUI();
}

/////////////////////////////////////////////////////////////////////
void CSendMessageAdvancedOptionsDlg::UpdateUI()
{
    static const UINT rgid[] =
    {
        IDC_STATIC_RESOURCE_NAME,
        IDC_EDIT_RESOURCE_NAME,

        IDC_STATIC_SHUTDOWN_OCCURS,
        IDC_EDIT_SHUTDOWN_OCCURS,
        //IDC_SPIN_SHUTDOWN_OCCURS,
        IDC_STATIC_SHUTDOWN_OCCURS_UNIT,

        IDC_STATIC_RESEND,
        IDC_EDIT_RESEND,
        //IDC_SPIN_RESEND,
        IDC_STATIC_RESEND_UNIT,

        IDC_STATIC_RESOURCE_BACK_ONLINE,
        IDC_EDIT_RESOURCE_BACK_ONLINE,
    };

    for (int i = 0; i < LENGTH(rgid); i++)
    {
        EnableWindow(GetDlgItem(m_hdlg, rgid[i]), m_fSendAutomatedMessage);
    }
} // CSendMessageAdvancedOptionsDlg::UpdateUI()

/////////////////////////////////////////////////////////////////////
INT_PTR CSendMessageAdvancedOptionsDlg::DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM /*lParam*/)
{
    CSendMessageAdvancedOptionsDlg * pThis;
    pThis = (CSendMessageAdvancedOptionsDlg *)GetWindowLongPtr(hdlg, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        Assert(pThis == NULL);
        pThis = new CSendMessageAdvancedOptionsDlg;
        if (pThis == NULL)
            return -1;
        SetWindowLongPtr(hdlg, GWLP_USERDATA, (LONG_PTR)pThis);
        pThis->OnInitDialog(hdlg);
        break;
    case WM_COMMAND:
        switch (wParam)
            {
        case IDOK:
            EndDialog(hdlg, TRUE);
            break;
        case IDCANCEL:
            EndDialog(hdlg, FALSE);
            break;
        case IDC_CHECK_SEND_AUTOMATED_MESSAGE:
            pThis->m_fSendAutomatedMessage = IsDlgButtonChecked(hdlg, IDC_CHECK_SEND_AUTOMATED_MESSAGE);
            pThis->UpdateUI();
            break;
        } // switch
        break;
    default:
        return FALSE;
    } // switch

    return TRUE;
} // CSendMessageAdvancedOptionsDlg::DlgProc()

BOOL CSendMessageAdvancedOptionsDlg::OnHelp(LPARAM /*lParam*/)
{
    HtmlHelpW (NULL, HTML_HELP_FILE, HH_DISPLAY_TOPIC, 0);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\sendcmsg\util.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       Util.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////
//	Util.cpp
//
//	Utility routines.
//
//	HISTORY
//	4-Aug-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "debug.h"
#include "util.h"
#include "resource.h"


/////////////////////////////////////////////////////////////////////
//	ListView_FindString()
//
//	Searches the listview items and return the index of the item
//	matching the string. Return -1 if no matches.
//
//	INTERFACE NOTES
//	Although not documented, the search is performed without case.
//
int
ListView_FindString(
	HWND hwndListview,
	LPCTSTR pszTextSearch)
{
	Assert(IsWindow(hwndListview));
	Assert(pszTextSearch != NULL);

	LV_FINDINFO lvFindInfo;
	GarbageInit(&lvFindInfo, sizeof(lvFindInfo));
	lvFindInfo.flags = LVFI_STRING;
	lvFindInfo.psz = pszTextSearch;
	return ListView_FindItem(hwndListview, -1, &lvFindInfo);
} // ListView_FindString()


/////////////////////////////////////////////////////////////////////
//	ListView_GetSelectedItem()
//
//	Return the index of the selected item.
//	If no items are selected, return -1.
//
int
ListView_GetSelectedItem(HWND hwndListview)
{
	Assert(IsWindow(hwndListview));
	return ListView_GetNextItem(hwndListview, -1, LVNI_SELECTED);
}


/////////////////////////////////////////////////////////////////////
//	ListView_SelectItem()
//
//	Set the selection of a specific listview item.
//
void
ListView_SelectItem(
	HWND hwndListview,
	int iItem)
{
	Assert(IsWindow(hwndListview));
	Assert(iItem >= 0);
	ListView_SetItemState(hwndListview, iItem, LVIS_SELECTED, LVIS_SELECTED);
} // ListView_SelectItem()


/////////////////////////////////////////////////////////////////////
//	ListView_UnselectItem()
//
//	Clear the selection of a specific listview item.
//
void
ListView_UnselectItem(
	HWND hwndListview,
	int iItem)
{
	Assert(IsWindow(hwndListview));
	Assert(iItem >= 0);
	ListView_SetItemState(hwndListview, iItem, 0, LVIS_SELECTED);
} // ListView_UnselectItem()


/////////////////////////////////////////////////////////////////////
//	ListView_UnselectAllItems()
//	
//	Remove the selection of any selected item.
//
void
ListView_UnselectAllItems(HWND hwndListview)
{
	Assert(IsWindow(hwndListview));
	
	int iItem = -1;
	while (TRUE)
	{
		// Search the listview for any selected items
		iItem = ListView_GetNextItem(hwndListview, iItem, LVNI_SELECTED);
		if (iItem < 0)
			break;
		// Clear the selection
		ListView_SetItemState(hwndListview, iItem, 0, LVIS_SELECTED);
	}
} // ListView_UnselectAllItems()


/////////////////////////////////////////////////////////////////////
//	ListView_SetItemImage()
//
//	Change the image of a listview item.
//
void
ListView_SetItemImage(HWND hwndListview, int iItem, int iImage)
{
	Assert(IsWindow(hwndListview));
	Assert(iItem >= 0);

	LV_ITEM lvItem;
	GarbageInit(OUT &lvItem, sizeof(lvItem));
	lvItem.mask = LVIF_IMAGE;
	lvItem.iItem = iItem;
	lvItem.iSubItem = 0;
	lvItem.iImage = iImage;
	ListView_SetItem(hwndListview, IN &lvItem);
} // ListView_SetItemImage()


/////////////////////////////////////////////////////////////////////////////
//	FTrimString()
//
//	Trim leading and trailing spaces of the string.
//	Return TRUE if one or more spaces has been removed, otherwise FALSE.
//
BOOL FTrimString(INOUT TCHAR szString[])
{
	TCHAR * pchSrc;
	TCHAR * pchDst;

	Assert(szString != NULL);
	if (szString[0] == 0)
		return FALSE;
	pchSrc = szString;
	if (*pchSrc == ' ')
	{
		while (*pchSrc == ' ')
			pchSrc++;
		pchDst = szString;
		do
		{
			*pchDst++ = *pchSrc++;
		}
		while (*pchSrc != '\0');

		while (pchDst > szString && *(pchDst - 1) == ' ')
			pchDst--;
		*pchDst = '\0';
		return TRUE;
	}
	pchDst = szString;
	while (*pchDst != '\0')
		pchDst++;
	Assert(pchDst > szString);
	if (*(pchDst - 1) != ' ')
		return FALSE;
	while (pchDst > szString && *(pchDst - 1) == ' ')
		pchDst--;
	*pchDst = '\0';
	return TRUE;
} // FTrimString()


/////////////////////////////////////////////////////////////////////
INT_PTR DoDialogBox(
	UINT wIdDialog,
	HWND hwndParent,
	DLGPROC dlgproc,
	LPARAM lParam)
{
	Assert(wIdDialog != 0);
	Endorse(hwndParent == NULL);
	Assert(dlgproc != NULL);
	Endorse(lParam == NULL);

	INT_PTR nResult = ::DialogBoxParam(
		g_hInstance,
		MAKEINTRESOURCE(wIdDialog),
		hwndParent, (DLGPROC)dlgproc,
		lParam);
	Report(nResult != -1 && "Failure to display dialog");
	return nResult;
} // DoDialogBox()


/////////////////////////////////////////////////////////////////////
int DoMessageBox(
	UINT uStringId,
	UINT uFlags)
{
	TCHAR szCaption[128];
	TCHAR szMessage[512];

	CchLoadString(IDS_CAPTION, OUT szCaption, LENGTH(szCaption));
	CchLoadString(uStringId, OUT szMessage, LENGTH(szMessage));
	return ::MessageBox(::GetActiveWindow(), szMessage, szCaption, uFlags);
} // DoMessageBox()
		
#ifdef DEBUG
/////////////////////////////////////////////////////////////////////////////
//	CchLoadString()
//
//	Same as ::LoadString() but with extra error checking.
//	CchLoadString is #defined to ::LoadString in the retail build.
//
int CchLoadString(
	UINT uIdString,		// IN: String Id
	TCHAR szBuffer[],	// OUT: Buffer to receive the string
	int cchBuffer)		// IN: Length of the buffer (in characters; not in bytes)
{
	int cch;

	Assert(szBuffer != NULL);
	cch = ::LoadString(g_hInstance, uIdString, OUT szBuffer, cchBuffer);
	Report(cch > 0 && "String not found");
	Report(cch < cchBuffer - 2 && "Output buffer too small");
	return cch;
} // CchLoadString()

#endif // DEBUG

/////////////////////////////////////////////////////////////////////
//	RegOpenOrCreateKey()
//
//	Open an existing key or create it if does not exists
//
HKEY
RegOpenOrCreateKey(
	HKEY hkeyRoot,			// IN: Root of an existing key
	const TCHAR szSubkey[])	// IN: Subkey to create
{
	Assert(hkeyRoot != NULL);
	Assert(szSubkey != NULL);
	HKEY hkey;				// Primary Registry key
	DWORD dwDisposition;	// Disposition (REG_OPENED_EXISTING_KEY or REG_CREATED_NEW_KEY)
	LONG lRetCode;			// Code returned by the Registry functions
	lRetCode = RegCreateKeyEx(
		hkeyRoot, szSubkey,
		0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
		NULL,					// SecurityAttributes
		&hkey,					// OUT: Returned registry key handle
		&dwDisposition);		// OUT: Returned disposition
	if (lRetCode != ERROR_SUCCESS)
	{
		Assert(hkey == NULL);
		return NULL;
	}
	return hkey;
} // RegOpenOrCreateKey()


/////////////////////////////////////////////////////////////////////
//	RegWriteString()
//
//	Write a tring to the Registry.
//
BOOL
RegWriteString(
	HKEY hkey,					// IN: Key to append to
	const TCHAR szKey[],		// IN: Key to save
	const TCHAR szValue[])		// IN: Value of the key
{
	Assert(hkey != NULL);	// Verify Registry has been opened
	Assert(szKey != NULL);
	Assert(szValue != NULL);
	LONG lRetCode = RegSetValueEx(hkey, szKey, 0, REG_SZ,
		(LPBYTE)szValue, lstrlen(szValue) * sizeof(TCHAR));
	// There should be no error writing to the Registry
	Report((lRetCode == ERROR_SUCCESS) && "RegWriteString() - Error writing to Registry");
	return (lRetCode == ERROR_SUCCESS);
} // RegWriteString()


/////////////////////////////////////////////////////////////////////
BOOL
RegWriteString(
	HKEY hkey,					// IN: Key to append to
	const TCHAR szKey[],		// IN: Key to save
	UINT uStringId)				// IN: Value of the key
{
    if ( szKey )
    {
	    TCHAR szValue[512];
	    CchLoadString(uStringId, OUT szValue, LENGTH(szValue));
	    return RegWriteString(hkey, szKey, szValue);
    }
    else
        return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
//	HrExtractDataAlloc()
//
//	Extract data from a source DataObject for a particular clipboard format.
//
//	RETURNS
//	Return S_OK if data was successfully retrieved and placed into allocated buffer.
//
//	INTERFACE NOTES
//	The routine will allocate memory, copy the data from the source to
//	the allocated buffer and return a pointer to the allocated buffer.
//	The caller is responsible to free the allocated memory using GlobalFree()
//	when no longer needed.
//
//	IMPLEMENTATION NOTES
//	The memory block is allocated by pDataObject->GetData() rather
//	than by the routine itself.
//
//	HISTORY
//	12-Aug-97	t-danm		Creation.
//
HRESULT
HrExtractDataAlloc(
	IDataObject * pDataObject,	// IN: Data source to extract data from
	UINT cfClipboardFormat,		// IN: Clipboard format to extract data
	PVOID * ppavData,			// OUT: Pointer to allocated memory
	UINT * pcbData)				// OUT: OPTIONAL: Number of bytes stored in memory buffer
{
	Assert(pDataObject != NULL);
	Assert(cfClipboardFormat != NULL);
	Assert(ppavData != NULL);
	Assert(*ppavData == NULL && "Memory Leak");
	Endorse(pcbData == NULL);	// TRUE => Don't care about the size of the allocated buffer

	FORMATETC formatetc = { (CLIPFORMAT)cfClipboardFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
	Assert(stgmedium.hGlobal == NULL);
	HRESULT hr = pDataObject->GetData(IN &formatetc, OUT &stgmedium);
	if (FAILED(hr))
	{
		Trace1("HrExtractDataAlloc() - Call to pDataObject->GetData() failed. hr=0x%X.\n", hr);
		return hr;
	}
	if (stgmedium.hGlobal == NULL)
	{
		// This is because the producer did not set the hGlobal handle
		Trace0("HrExtractDataAlloc() - Memory handle hGlobal is NULL.\n");
		return S_FALSE;
	}
	UINT cbData = (UINT)GlobalSize(stgmedium.hGlobal);
	if (cbData == 0)
	{
		Trace1("HrExtractDataAlloc() - Corrupted hGlobal handle. err=%d.\n", GetLastError());
		return E_UNEXPECTED;
	}
	*ppavData = stgmedium.hGlobal;
	if (pcbData != NULL)
		*pcbData = cbData;
	return S_OK;
} // HrExtractDataAlloc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\alrtcmdd.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    alrtcmdd.cpp

Abstract:

    Implementation of the alerts action command arguments dialog.

--*/

#include "stdafx.h"
#include "alrtactp.h"
#include "alrtcmdd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static ULONG
s_aulHelpIds[] =
{
IDC_CMD_ARG_SINGLE_CHK,	IDH_CMD_ARG_SINGLE_CHK,
IDC_CMD_ARG_ALERT_CHK,	IDH_CMD_ARG_ALERT_CHK,
IDC_CMD_ARG_NAME_CHK,	IDH_CMD_ARG_NAME_CHK,
IDC_CMD_ARG_DATE_CHK,	IDH_CMD_ARG_DATE_CHK,
IDC_CMD_ARG_LIMIT_CHK,	IDH_CMD_ARG_LIMIT_CHK,
IDC_CMD_ARG_VALUE_CHK,	IDH_CMD_ARG_VALUE_CHK,
IDC_CMD_USER_TEXT_CHK,	IDH_CMD_USER_TEXT_CHK,
IDC_CMD_USER_TEXT_EDIT,	IDH_CMD_USER_TEXT_EDIT,
IDC_CMD_ARG_SAMPLE_DISPLAY,	IDH_CMD_ARG_SAMPLE_DISPLAY,
0,0
};

/////////////////////////////////////////////////////////////////////////////
// CAlertCommandArgsDlg dialog


CAlertCommandArgsDlg::CAlertCommandArgsDlg(CWnd* pParent)
 : CDialog(CAlertCommandArgsDlg::IDD, pParent),
    m_pAlertActionPage( NULL ),
    m_strSampleArgList ( _T("") ),
    m_strAlertName ( _T("") ),
    m_CmdArg_bAlertName ( FALSE ),
    m_CmdArg_bDateTime ( FALSE ),
    m_CmdArg_bLimitValue ( FALSE ),
    m_CmdArg_bCounterPath ( FALSE ),
    m_CmdArg_bSingleArg ( FALSE ),
    m_CmdArg_bMeasuredValue ( FALSE ),
    m_CmdArg_bUserText ( FALSE ),
    m_CmdArg_strUserText ( _T("") )
{
//    EnableAutomation();

    //{{AFX_DATA_INIT(CAlertCommandArgsDlg)
    //}}AFX_DATA_INIT
}

CAlertCommandArgsDlg::~CAlertCommandArgsDlg()
{
}

void CAlertCommandArgsDlg::OnFinalRelease()
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CDialog::OnFinalRelease();
}

void CAlertCommandArgsDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAlertCommandArgsDlg)
    DDX_Check(pDX, IDC_CMD_ARG_ALERT_CHK, m_CmdArg_bAlertName);
    DDX_Check(pDX, IDC_CMD_ARG_DATE_CHK, m_CmdArg_bDateTime);
    DDX_Check(pDX, IDC_CMD_ARG_LIMIT_CHK, m_CmdArg_bLimitValue);
    DDX_Check(pDX, IDC_CMD_ARG_NAME_CHK, m_CmdArg_bCounterPath);
    DDX_Check(pDX, IDC_CMD_ARG_SINGLE_CHK, m_CmdArg_bSingleArg);
    DDX_Check(pDX, IDC_CMD_ARG_VALUE_CHK, m_CmdArg_bMeasuredValue);
    DDX_Check(pDX, IDC_CMD_USER_TEXT_CHK, m_CmdArg_bUserText);
    DDX_Text(pDX, IDC_CMD_USER_TEXT_EDIT, m_CmdArg_strUserText);
    DDV_MaxChars(pDX, m_CmdArg_strUserText, MAX_PATH);
    DDX_Text(pDX, IDC_CMD_ARG_SAMPLE_DISPLAY, m_strSampleArgList);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAlertCommandArgsDlg, CDialog)
    //{{AFX_MSG_MAP(CAlertCommandArgsDlg)
    ON_BN_CLICKED(IDC_CMD_ARG_SINGLE_CHK, OnCmdArgSingleChk)
    ON_BN_CLICKED(IDC_CMD_ARG_ALERT_CHK, OnCmdArgAlertChk)
    ON_BN_CLICKED(IDC_CMD_ARG_NAME_CHK, OnCmdArgNameChk)
    ON_BN_CLICKED(IDC_CMD_ARG_DATE_CHK, OnCmdArgDateChk)
    ON_BN_CLICKED(IDC_CMD_ARG_LIMIT_CHK, OnCmdArgLimitChk)
    ON_BN_CLICKED(IDC_CMD_ARG_VALUE_CHK, OnCmdArgValueChk)
    ON_BN_CLICKED(IDC_CMD_USER_TEXT_CHK, OnCmdUserTextChk)
    ON_EN_CHANGE(IDC_CMD_USER_TEXT_EDIT, OnCmdArgUserTextEditChange)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAlertCommandArgsDlg message handlers

BOOL CAlertCommandArgsDlg::OnInitDialog() 
{
    ResourceStateManager rsm;
    
    ASSERT ( NULL != m_pAlertActionPage );

    m_pAlertActionPage->MakeSampleArgList (
                            m_strSampleArgList,
                            m_CmdArg_bSingleArg,
                            m_CmdArg_bAlertName,
                            m_CmdArg_bDateTime,
                            m_CmdArg_bCounterPath,
                            m_CmdArg_bMeasuredValue,
                            m_CmdArg_bLimitValue,
                            m_CmdArg_bUserText,
                            m_CmdArg_strUserText );

    CDialog::OnInitDialog();

    UpdateCmdActionBox();

    return FALSE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CAlertCommandArgsDlg::OnOK() 
{
    UpdateData (TRUE);
    
    CDialog::OnOK();
}

void CAlertCommandArgsDlg::OnCmdArgSingleChk() 
{
    UpdateCmdActionBox ();
}

void CAlertCommandArgsDlg::OnCmdArgAlertChk() 
{
    UpdateCmdActionBox ();
}

void CAlertCommandArgsDlg::OnCmdArgNameChk() 
{
    UpdateCmdActionBox ();
}

void CAlertCommandArgsDlg::OnCmdArgDateChk() 
{
    UpdateCmdActionBox ();
}

void CAlertCommandArgsDlg::OnCmdArgLimitChk() 
{
    UpdateCmdActionBox ();
}

void CAlertCommandArgsDlg::OnCmdArgValueChk() 
{
    UpdateCmdActionBox ();
}

void CAlertCommandArgsDlg::OnCmdUserTextChk() 
{
    UpdateCmdActionBox ();
}

void CAlertCommandArgsDlg::OnCmdArgUserTextEditChange()
{
    UpdateCmdActionBox ();
}

BOOL 
CAlertCommandArgsDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    ASSERT( NULL != m_pAlertActionPage );

    if ( pHelpInfo->iCtrlId >= IDC_CMD_ARG_FIRST_HELP_CTRL ||
         pHelpInfo->iCtrlId == IDOK ||
         pHelpInfo->iCtrlId == IDCANCEL) {
        InvokeWinHelp(WM_HELP, NULL, (LPARAM)pHelpInfo, m_pAlertActionPage->GetContextHelpFilePath(), s_aulHelpIds);
    }

    return TRUE;
}

void 
CAlertCommandArgsDlg::OnContextMenu(CWnd* pWnd, CPoint /* point */) 
{
    ASSERT( NULL != m_pAlertActionPage );

    InvokeWinHelp(WM_CONTEXTMENU, (WPARAM)(pWnd->m_hWnd), NULL, m_pAlertActionPage->GetContextHelpFilePath(), s_aulHelpIds);

    return;
}

// Helper functions

void    
CAlertCommandArgsDlg::SetAlertActionPage( CAlertActionProp* pPage ) 
{ 
    // The alert action page is not always the parent, so store a separate pointer
    m_pAlertActionPage = pPage; 
}

void CAlertCommandArgsDlg::UpdateCmdActionBox ()
{
    UpdateData(TRUE);

    ASSERT ( NULL != m_pAlertActionPage );

    m_pAlertActionPage->MakeSampleArgList (
                            m_strSampleArgList,
                            m_CmdArg_bSingleArg,
                            m_CmdArg_bAlertName,
                            m_CmdArg_bDateTime,
                            m_CmdArg_bCounterPath,
                            m_CmdArg_bMeasuredValue,
                            m_CmdArg_bLimitValue,
                            m_CmdArg_bUserText,
                            m_CmdArg_strUserText );
    UpdateData(FALSE);
    SetControlState();  
}


BOOL    
CAlertCommandArgsDlg::SetControlState()
{
    (GetDlgItem(IDC_CMD_USER_TEXT_EDIT))->EnableWindow(m_CmdArg_bUserText);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\sendcmsg\util.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       util.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
//	Util.h

extern HINSTANCE g_hInstance;

#ifndef APIERR
	typedef DWORD APIERR;		// Error code typically returned by ::GetLastError()
#endif

/////////////////////////////////////////////////////////////////////
//
// Dummy macros
//
#define INOUT		// Parameter is both input and output
#define IGNORED		// Output parameter is ignored

/////////////////////////////////////////////////////////////////////
//
// Handy macros
//
#define LENGTH(x)			(sizeof(x)/sizeof(x[0]))
#define ZeroInit(pv, cb)	memset(pv, 0, cb)


/////////////////////////////////////////////////////////////////////
int ListView_FindString(HWND hwndListview, LPCTSTR pszTextSearch);
int ListView_GetSelectedItem(HWND hwndListview);
void ListView_SelectItem(HWND hwndListview, int iItem);
void ListView_UnselectItem(HWND hwndListview, int iItem);
void ListView_UnselectAllItems(HWND hwndListview);
void ListView_SetItemImage(HWND hwndListview, int iItem, int iImage);

BOOL FTrimString(INOUT TCHAR szString[]);

/////////////////////////////////////////////////////////////////////
INT_PTR DoDialogBox(
	UINT wIdDialog,
	HWND hwndParent,
	DLGPROC dlgproc,
	LPARAM lParam = 0);

int DoMessageBox(UINT uStringId, UINT uFlags = MB_OK | MB_ICONINFORMATION);

/////////////////////////////////////////////////////////////////////
HKEY RegOpenOrCreateKey(HKEY hkeyRoot, const TCHAR szSubkey[]);
BOOL RegWriteString(HKEY hkey, const TCHAR szKey[], const TCHAR szValue[]);
BOOL RegWriteString(HKEY hkey, const TCHAR szKey[], UINT uStringId);

/////////////////////////////////////////////////////////////////////
HRESULT HrExtractDataAlloc(
	IN IDataObject * pDataObject,
	IN UINT cfClipboardFormat,
	OUT PVOID * ppavData,
	OUT UINT * pcbData = NULL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\common\common.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    common.h

Abstract:

    SMONLOG common definitions

--*/

#ifndef _SMONLOG_COMMON_H_
#define _SMONLOG_COMMON_H_

#include <wtypes.h>

#define _CONFIG_DLL_NAME_W_     L"SmLogCfg.dll"
#define _SERVICE_EXE_NAME_W_    L"SmLogSvc.exe"   

// Communication between smlogcfg and smlogsvc

#define SERVICE_CONTROL_SYNCHRONIZE 128
#define SLQ_QUERY_STOPPED       ((DWORD)0x00000000)              
#define SLQ_QUERY_RUNNING       ((DWORD)0x00000001)
#define SLQ_QUERY_START_PENDING ((DWORD)0x00000002)

#define SLQ_NEW_LOG         ((DWORD)0xFFFFFFFF)
#define SLQ_FIRST_LOG_TYPE  ((DWORD)0x00000000)
#define SLQ_COUNTER_LOG     ((DWORD)0x00000000)
#define SLQ_TRACE_LOG       ((DWORD)0x00000001)
#define SLQ_ALERT           ((DWORD)0x00000002)
#define SLQ_LAST_LOG_TYPE   ((DWORD)0x00000002)
#define SLQ_NUM_LOG_TYPES   ((DWORD)0x00000003)

#define SLQ_DEFAULT_SYS_QUERY   ((DWORD)(0x00000001))      

// Sysmon log output file configuration definitions

#define SLF_FIRST_FILE_TYPE ((DWORD)0x00000000)
#define SLF_CSV_FILE        ((DWORD)0x00000000)
#define SLF_TSV_FILE        ((DWORD)0x00000001)
#define SLF_BIN_FILE        ((DWORD)0x00000002)
#define SLF_BIN_CIRC_FILE   ((DWORD)0x00000003)
#define SLF_CIRC_TRACE_FILE ((DWORD)0x00000004)
#define SLF_SEQ_TRACE_FILE  ((DWORD)0x00000005)
#define SLF_SQL_LOG         ((DWORD)0x00000006)
#define SLF_NUM_FILE_TYPES  ((DWORD)0x00000007)
#define SLF_FILE_OVERWRITE  ((DWORD)0x00010000)     // Obsolete after Whistler Beta 2
#define SLF_FILE_APPEND     ((DWORD)0x00020000)     // Obsolete after Whistler Beta 2

#define SLF_NAME_NONE           ((DWORD)0xFFFFFFFF)
#define SLF_NAME_FIRST_AUTO     ((DWORD)0x00000000)
#define SLF_NAME_MMDDHH         ((DWORD)0x00000000)
#define SLF_NAME_NNNNNN         ((DWORD)0x00000001)
#define SLF_NAME_YYYYDDD        ((DWORD)0x00000002)
#define SLF_NAME_YYYYMM         ((DWORD)0x00000003)
#define SLF_NAME_YYYYMMDD       ((DWORD)0x00000004)
#define SLF_NAME_YYYYMMDDHH     ((DWORD)0x00000005)
#define SLF_NAME_MMDDHHMM       ((DWORD)0x00000006)
#define SLF_NUM_AUTO_NAME_TYPES ((DWORD)0x00000007)

#define SLQ_MAX_AUTO_NAME_LEN   ((DWORD)0x0000000B)
#define SLQ_MAX_BASE_NAME_LEN   ((DWORD)(_MAX_FNAME - SLQ_MAX_AUTO_NAME_LEN - 1))
#define SLQ_MAX_LOG_NAME_LEN    SLQ_MAX_BASE_NAME_LEN
#define SLQ_MAX_LOG_SET_NAME_LEN ((DWORD)0x000000FF)

#define SLF_DATA_STORE_APPEND_MASK  ((DWORD)0x000000F)     
#define SLF_DATA_STORE_OVERWRITE    ((DWORD)0x0000001)     
#define SLF_DATA_STORE_APPEND       ((DWORD)0x0000002)     

#define SLF_DATA_STORE_SIZE_MASK         ((DWORD)0x00000F0)     
#define SLF_DATA_STORE_SIZE_ONE_RECORD   ((DWORD)0x0000010)     
#define SLF_DATA_STORE_SIZE_ONE_KB       ((DWORD)0x0000020)     
#define SLF_DATA_STORE_SIZE_ONE_MB       ((DWORD)0x0000040)     

#define  ONE_MB     ((DWORD)0x00100000) 
#define  ONE_KB     ((DWORD)0x00000400) 
#define  ONE_RECORD ((DWORD)0x00000001) 

// Constants
#define SLQ_DISK_MAX_SIZE   ((DWORD)-1)

#define SLQ_TLI_ENABLE_BUFFER_FLUSH         ((DWORD)0x00000001)
#define SLQ_TLI_ENABLE_KERNEL_TRACE         ((DWORD)0x00000002)
#define SLQ_TLI_ENABLE_MEMMAN_TRACE         ((DWORD)0x00000004)
#define SLQ_TLI_ENABLE_FILEIO_TRACE         ((DWORD)0x00000008)
#define SLQ_TLI_ENABLE_PROCESS_TRACE        ((DWORD)0x00000010)
#define SLQ_TLI_ENABLE_THREAD_TRACE         ((DWORD)0x00000020)
#define SLQ_TLI_ENABLE_DISKIO_TRACE         ((DWORD)0x00000040)
#define SLQ_TLI_ENABLE_NETWORK_TCPIP_TRACE  ((DWORD)0x00000080)

#define SLQ_TLI_ENABLE_MASK                 ((DWORD)0x000000FF)
#define SLQ_TLI_ENABLE_KERNEL_MASK          ((DWORD)0x000000FE)

// dwMode values
#define SLQ_AUTO_MODE_NONE      ((DWORD)0x00000000)       // Manual
#define SLQ_AUTO_MODE_SIZE      ((DWORD)0x00000001)       // Size
#define SLQ_AUTO_MODE_AT        ((DWORD)0x00000002)       // Time
#define SLQ_AUTO_MODE_AFTER     ((DWORD)0x00000003)       // Value & unit type
#define SLQ_AUTO_MODE_CALENDAR  ((DWORD)0x00000004)       // Value & unit type

// wDataType values
#define SLQ_TT_DTYPE_DATETIME   ((WORD)0x0001)
#define SLQ_TT_DTYPE_UNITS      ((WORD)0x0002)

// wTimeType values
#define SLQ_TT_TTYPE_START              ((WORD)0x0001)
#define SLQ_TT_TTYPE_STOP               ((WORD)0x0002)
#define SLQ_TT_TTYPE_RESTART            ((WORD)0x0003)
#define SLQ_TT_TTYPE_SAMPLE             ((WORD)0x0004)
#define SLQ_TT_TTYPE_LAST_MODIFIED      ((WORD)0x0005)
#define SLQ_TT_TTYPE_CREATE_NEW_FILE    ((WORD)0x0006)
#define SLQ_TT_TTYPE_REPEAT_SCHEDULE    ((WORD)0x0007)
#define SLQ_TT_TTYPE_REPEAT_START       ((WORD)0x0008)
#define SLQ_TT_TTYPE_REPEAT_STOP        ((WORD)0x0009)

// dwUnitType values
#define SLQ_TT_UTYPE_SECONDS        ((DWORD)0x00000001)    
#define SLQ_TT_UTYPE_MINUTES        ((DWORD)0x00000002)   
#define SLQ_TT_UTYPE_HOURS          ((DWORD)0x00000003)   
#define SLQ_TT_UTYPE_DAYS           ((DWORD)0x00000004)   
#define SLQ_TT_UTYPE_DAYS_OF_WEEK   ((DWORD)0x00000005)   

#pragma warning ( disable : 4201 )

typedef struct _SLQ_TIME_INFO {
    WORD    wDataType;
    WORD    wTimeType;
    DWORD   dwAutoMode;
    union {
        LONGLONG    llDateTime; // filetime stored as a LONGLONG
        struct {
            DWORD   dwValue;
            DWORD   dwUnitType;
        };
    };
} SLQ_TIME_INFO, *PSLQ_TIME_INFO;

#pragma warning ( default : 4201 )

// alert action flags
#define ALRT_ACTION_LOG_EVENT   ((DWORD)0x00000001)
#define ALRT_ACTION_SEND_MSG    ((DWORD)0x00000002)
#define ALRT_ACTION_EXEC_CMD    ((DWORD)0x00000004)
#define ALRT_ACTION_START_LOG   ((DWORD)0x00000008)
#define ALRT_ACTION_MASK        ((DWORD)0x0000000F)

#define ALRT_CMD_LINE_SINGLE    ((DWORD)0x00000100)
#define ALRT_CMD_LINE_A_NAME    ((DWORD)0x00000200)
#define ALRT_CMD_LINE_C_NAME    ((DWORD)0x00000400)
#define ALRT_CMD_LINE_D_TIME    ((DWORD)0x00000800)
#define ALRT_CMD_LINE_L_VAL     ((DWORD)0x00001000)
#define ALRT_CMD_LINE_M_VAL     ((DWORD)0x00002000)
#define ALRT_CMD_LINE_U_TEXT    ((DWORD)0x00004000)
#define ALRT_CMD_LINE_MASK      ((DWORD)0x00007F00)

#define ALRT_DEFAULT_ACTION     ((DWORD)0x00000001) // log event is default

#define AIBF_UNDER  0L
#define AIBF_OVER   ((DWORD)0x00000001) // true when "over" limit is selected
#define AIBF_SEEN   ((DWORD)0x00000002) // set when the user has seen this value
#define AIBF_SAVED  ((DWORD)0x00000004) // true when user has saved this entry in an edit box

#ifdef __cplusplus
extern "C" {
#endif
 
typedef struct _ALERT_INFO_BLOCK {
    DWORD   dwSize;
    LPTSTR  szCounterPath;
    DWORD   dwFlags;
    double  dLimit;
} ALERT_INFO_BLOCK, *PALERT_INFO_BLOCK;

// Common constants
#define FILETIME_TICS_PER_MILLISECOND   ((DWORD)(10000))
#define FILETIME_TICS_PER_SECOND        ((DWORD)(FILETIME_TICS_PER_MILLISECOND*1000))

#define  ONE_MB     ((DWORD)0x00100000) 
#define  ONE_KB     ((DWORD)0x00000400) 
#define  ONE_RECORD ((DWORD)0x00000001) 

// Memory allocation for smlogsvc, pdhpla methods
#define G_ALLOC(size)           HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, size)
#define G_REALLOC(ptr, size)    HeapReAlloc (GetProcessHeap(), (HEAP_ZERO_MEMORY), ptr, size)
#define G_ZERO(ptr, size)       ZeroMemory (ptr, size)
#define G_FREE(ptr)             if (ptr != NULL) HeapFree (GetProcessHeap(), 0, ptr)

// functions found in utils.c
void __stdcall ReplaceBlanksWithUnderscores ( LPWSTR szString);
BOOL __stdcall MakeInfoFromString (LPCTSTR szBuffer, PALERT_INFO_BLOCK pInfo, LPDWORD pdwBufferSize);
BOOL __stdcall MakeStringFromInfo (PALERT_INFO_BLOCK pInfo, LPTSTR szBuffer, LPDWORD pcchBufferLength);
BOOL __stdcall GetLocalFileTime (LONGLONG    *pFileTime );

void __stdcall TimeInfoToMilliseconds ( SLQ_TIME_INFO* pTimeInfo, LONGLONG* pllmsecs );
void __stdcall TimeInfoToTics ( SLQ_TIME_INFO* pTimeInfo, LONGLONG* plltics );

DWORD __stdcall SmReadRegistryIndirectStringValue (
                    HKEY hKey, 
                    LPCWSTR szValue,
                    LPCWSTR szDefault, 
                    LPWSTR* pszBuffer, 
                    UINT*   puiLength );

#ifdef __cplusplus
}
#endif

#endif //_SMONLOG_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\alrtactp.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    alrtactp.cpp

Abstract:

    Implementation of the alerts action property page.

--*/

#include "stdafx.h"
#include <assert.h>
#include <common.h>
#include "smcfgmsg.h"
#include "globals.h"
#include "smlogs.h"
#include "smalrtq.h"
#include "alrtcmdd.h"
#include "AlrtActP.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("SMLOGCFG(alrtactp.cpp)");

static ULONG
s_aulHelpIds[] =
{
    IDC_ACTION_APPLOG_CHK,                  IDH_ACTION_APPLOG_CHK,
    IDC_ACTION_NETMSG_CHK,                  IDH_ACTION_NETMSG_CHK,
    IDC_ACTION_NETMSG_NAME_EDIT,            IDH_ACTION_NETMSG_NAME_EDIT,
    IDC_ACTION_EXECUTE_CHK,                 IDH_ACTION_EXECUTE_CHK,
    IDC_ACTION_EXECUTE_EDIT,                IDH_ACTION_EXECUTE_EDIT,
    IDC_ACTION_EXECUTE_BROWSE_BTN,          IDH_ACTION_EXECUTE_BROWSE_BTN,
    IDC_ACTION_CMD_ARGS_BTN,                IDH_ACTION_CMD_ARGS_BTN,
    IDC_ACTION_START_LOG_CHK,               IDH_ACTION_START_LOG_CHK,
    IDC_ACTION_START_LOG_COMBO,             IDH_ACTION_START_LOG_COMBO,
    IDC_ACTION_CMD_ARGS_DISPLAY,            IDH_ACTION_CMD_ARGS_DISPLAY,
    0,0
};

/////////////////////////////////////////////////////////////////////////////
// CAlertActionProp property page

IMPLEMENT_DYNCREATE(CAlertActionProp, CSmPropertyPage)

CAlertActionProp::CAlertActionProp(MMC_COOKIE mmcCookie, LONG_PTR hConsole) 
:   CSmPropertyPage(CAlertActionProp::IDD, hConsole)
{
    //::OutputDebugStringA("\nCAlertActionProp::CAlertActionProp");

    // init variables from arg list
    m_pAlertQuery = reinterpret_cast <CSmAlertQuery *>(mmcCookie);

    // init AFX data
    InitAfxDataItems();

    // init other member variables
    m_pAlertInfo = NULL;
}

CAlertActionProp::CAlertActionProp() : CSmPropertyPage(CAlertActionProp::IDD)
{
    ASSERT (FALSE); // the constructor w/ args should be used instead

    // init variables from arg list
    m_pAlertQuery = NULL;

    // init AFX data
    InitAfxDataItems();

    // init other member variables
    m_pAlertInfo = NULL;
}

CAlertActionProp::~CAlertActionProp()
{
    if (m_pAlertInfo != NULL) delete m_pAlertInfo;
}

void CAlertActionProp::InitAfxDataItems ()
{
    //{{AFX_DATA_INIT(CAlertActionProp)
    m_Action_bLogEvent = TRUE;
    m_Action_bExecCmd = FALSE;
    m_Action_bSendNetMsg = FALSE;
    m_Action_bStartLog = FALSE;
    m_Action_strCmdPath = _T("");
    m_Action_strNetName = _T("");
    m_CmdArg_bAlertName = FALSE;
    m_CmdArg_bDateTime = FALSE;
    m_CmdArg_bLimitValue = FALSE;
    m_CmdArg_bCounterPath = FALSE;
    m_CmdArg_bSingleArg = FALSE;
    m_CmdArg_bMeasuredValue = FALSE;
    m_CmdArg_bUserText = FALSE;
    m_CmdArg_strUserText = _T("");
    m_nCurLogSel = LB_ERR;
    //}}AFX_DATA_INIT
}

void CAlertActionProp::DoDataExchange(CDataExchange* pDX)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAlertActionProp)
    DDX_Control(pDX, IDC_ACTION_START_LOG_COMBO, m_pLogCombo);
    DDX_Check(pDX, IDC_ACTION_APPLOG_CHK, m_Action_bLogEvent);
    DDX_Check(pDX, IDC_ACTION_EXECUTE_CHK, m_Action_bExecCmd);
    DDX_Check(pDX, IDC_ACTION_NETMSG_CHK, m_Action_bSendNetMsg);
    DDX_Check(pDX, IDC_ACTION_START_LOG_CHK, m_Action_bStartLog);
    DDX_CBIndex(pDX, IDC_ACTION_START_LOG_COMBO, m_nCurLogSel);
    DDX_Text(pDX, IDC_ACTION_EXECUTE_EDIT, m_Action_strCmdPath);
    DDV_MaxChars(pDX, m_Action_strCmdPath, MAX_PATH );
    DDX_Text(pDX, IDC_ACTION_NETMSG_NAME_EDIT, m_Action_strNetName);
    DDV_MaxChars(pDX, m_Action_strNetName, MAX_PATH );
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAlertActionProp, CSmPropertyPage)
    //{{AFX_MSG_MAP(CAlertActionProp)
    ON_WM_DESTROY()
    ON_BN_CLICKED(IDC_ACTION_EXECUTE_BROWSE_BTN, OnActionExecuteBrowseBtn)
    ON_BN_CLICKED(IDC_ACTION_APPLOG_CHK, OnActionApplogChk)
    ON_BN_CLICKED(IDC_ACTION_NETMSG_CHK, OnActionNetmsgChk)
    ON_BN_CLICKED(IDC_ACTION_EXECUTE_CHK, OnActionExecuteChk)
    ON_BN_CLICKED(IDC_ACTION_CMD_ARGS_BTN, OnActionCmdArgsBtn)
    ON_BN_CLICKED(IDC_ACTION_START_LOG_CHK, OnActionStartLogChk)
    ON_EN_CHANGE(IDC_ACTION_NETMSG_NAME_EDIT, OnNetNameTextEditChange)
    ON_EN_CHANGE(IDC_ACTION_EXECUTE_EDIT, OnCmdPathTextEditChange)
    ON_CBN_SELENDOK(IDC_ACTION_START_LOG_COMBO, OnSelendokStartLogCombo)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



BOOL    
CAlertActionProp::SetControlState()
{
    // Net Message items
    (GetDlgItem(IDC_ACTION_NETMSG_NAME_EDIT))->EnableWindow(m_Action_bSendNetMsg);

    // command line items
    (GetDlgItem(IDC_ACTION_EXECUTE_EDIT))->EnableWindow(m_Action_bExecCmd);
    (GetDlgItem(IDC_ACTION_EXECUTE_BROWSE_BTN))->EnableWindow(m_Action_bExecCmd);
    (GetDlgItem(IDC_ACTION_CMD_ARGS_BTN))->EnableWindow(m_Action_bExecCmd);
    (GetDlgItem(IDC_ACTION_CMD_ARGS_CAPTION))->EnableWindow(m_Action_bExecCmd);
    (GetDlgItem(IDC_ACTION_CMD_ARGS_DISPLAY))->EnableWindow(m_Action_bExecCmd);

    // perf data Log entries
    (GetDlgItem(IDC_ACTION_START_LOG_COMBO))->EnableWindow(m_Action_bStartLog);

    return TRUE;
}

BOOL 
CAlertActionProp::LoadLogQueries ( DWORD dwLogType )
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD   dwQueryIndex = 0;
    LONG    lEnumStatus = ERROR_SUCCESS;
    WCHAR   szQueryName[MAX_PATH];
    DWORD   dwQueryNameSize = MAX_PATH;
    LPTSTR  szCollectionName = NULL;
    UINT    uiCollectionNameLen = 0;
    FILETIME    ftLastWritten;
    HKEY    hKeyQuery;
    HKEY    hKeyLogService;
    
    dwStatus = RegOpenKeyExW (
        HKEY_LOCAL_MACHINE,         // handle of open key
        L"System\\CurrentControlSet\\Services\\Sysmonlog\\Log Queries",  // address of name of subkey to open
        0L, 
        KEY_READ,   // reserved  REGSAM samDesired, // security access mask
        &hKeyLogService);

    if (dwStatus != ERROR_SUCCESS) return FALSE;
    // Load all queries for the specified registry key.
    // Enumerate the log names and create a new log object
    // for each one found.

    while ((lEnumStatus = RegEnumKeyEx (hKeyLogService,
        dwQueryIndex, szQueryName, &dwQueryNameSize,
        NULL, NULL, NULL, &ftLastWritten)) == ERROR_SUCCESS) {

        // open the query specified
        dwStatus = RegOpenKeyExW (
            hKeyLogService,
            szQueryName,
            0,
            KEY_READ,
            &hKeyQuery);
        if ( ERROR_SUCCESS == dwStatus ) {

            // create a new object and add it to the query list
            
            // Determine the log type.                
            DWORD       dwType = 0;
            DWORD       dwBufferSize = sizeof(DWORD);
            DWORD       dwRegValue;
        
            dwType = 0;
            dwStatus = RegQueryValueExW (
                hKeyQuery,
                L"Log Type",
                NULL,
                &dwType,
                (LPBYTE)&dwRegValue,
                &dwBufferSize );
        
            if ( ( ERROR_SUCCESS == dwStatus ) 
                && ( dwLogType == dwRegValue ) ) 
            {
                // Query key is Guid if written by post Win2000 snapin.
                // Query key is name if written by Win2000 snapin.

                dwStatus = SmReadRegistryIndirectStringValue (
                            hKeyQuery,
                            L"Collection Name",
                            NULL,
                            &szCollectionName,
                            &uiCollectionNameLen );
            
                ASSERT ( MAX_PATH >= uiCollectionNameLen );
                if ( ERROR_SUCCESS == dwStatus 
                        && NULL != szCollectionName ) 
                {
                    if (  0 < lstrlen ( szCollectionName ) 
                        && ( MAX_PATH > lstrlen ( szCollectionName ) ) )
                    {
                        lstrcpy ( szQueryName, szCollectionName );
                    }
                    G_FREE ( szCollectionName );
                    szCollectionName = NULL;
                }
            
                // add this to the combo box
                m_pLogCombo.AddString  (szQueryName);
            }
            RegCloseKey (hKeyQuery);
        }
        // set up for the next item in the list
        dwQueryNameSize = sizeof (szQueryName) / sizeof (szQueryName[0]);
        dwQueryIndex++;
        memset (szQueryName, 0, sizeof (szQueryName));
    }

    RegCloseKey (hKeyLogService);

    return TRUE;
}

BOOL 
CAlertActionProp::IsValidLocalData()
{
    BOOL    bActionSet = FALSE;
    INT     iPrevLength = 0;
    BOOL    bUpdateNetNameUI = FALSE;

    ResourceStateManager rsm;

    if (m_Action_bLogEvent) {
        bActionSet = TRUE;
    }

    // assumes UpdateData has been called
    
    // Trim text fields before validating.
    iPrevLength = m_Action_strCmdPath.GetLength();
    m_Action_strCmdPath.TrimLeft();
    m_Action_strCmdPath.TrimRight();

    if ( iPrevLength != m_Action_strCmdPath.GetLength() ) {
        SetDlgItemText ( IDC_ACTION_EXECUTE_EDIT, m_Action_strCmdPath );  
    }

    iPrevLength = m_Action_strNetName.GetLength();
    m_Action_strNetName.TrimLeft();
    m_Action_strNetName.TrimRight();

    if ( iPrevLength != m_Action_strNetName.GetLength() ) {
        bUpdateNetNameUI = TRUE;
    }

    if (m_Action_bSendNetMsg) {

        // make sure a net name has been entered

        while ( _T('\\') == m_Action_strNetName[0] ) {
            // NetMessageBufferSend does not understand machine names preceded by "\\"
            m_Action_strNetName = m_Action_strNetName.Right( m_Action_strNetName.GetLength() - 1 );  
            bUpdateNetNameUI = TRUE;
        }


        if (m_Action_strNetName.GetLength() == 0) {
            CString strMessage;

            strMessage.LoadString ( IDS_ACTION_ERR_NONETNAME );
            MessageBox ( strMessage, m_pAlertQuery->GetLogName(), MB_OK  | MB_ICONERROR);
            (GetDlgItem(IDC_ACTION_NETMSG_NAME_EDIT))->SetFocus();
            return FALSE;
        }

        bActionSet = TRUE;
    }

    if ( bUpdateNetNameUI ) {
        SetDlgItemText ( IDC_ACTION_NETMSG_NAME_EDIT, m_Action_strNetName );  
    }

    if (m_Action_bExecCmd) {
        // make sure a command file has been entered
        if (m_Action_strCmdPath.GetLength() == 0) {
            CString strMessage;
            strMessage.LoadString ( IDS_ACTION_ERR_NOCMDFILE );
            MessageBox ( strMessage, m_pAlertQuery->GetLogName(), MB_OK  | MB_ICONERROR);
            (GetDlgItem(IDC_ACTION_EXECUTE_EDIT))->SetFocus();
            return FALSE;
        }

        // If on local machine, make sure the command file exists.
        if ( m_pAlertQuery->GetLogService()->IsLocalMachine() ) {

            DWORD dwStatus;
        
            dwStatus = IsCommandFilePathValid ( m_Action_strCmdPath );

            if ( ERROR_SUCCESS != dwStatus ) {
                CString strMessage;

                FormatSmLogCfgMessage ( 
                    strMessage,
                    m_hModule, 
                    dwStatus );
                    
                MessageBox ( strMessage, m_pAlertQuery->GetLogName(), MB_OK  | MB_ICONERROR);
                GetDlgItem ( IDC_ACTION_EXECUTE_EDIT )->SetFocus();                
                return FALSE;
            }
        }

        bActionSet = TRUE;
    }
    
    if (m_Action_bStartLog ) {
        // make sure a log has been selected
        if (m_pLogCombo.GetCurSel() == CB_ERR) {
            CString strMessage;
            strMessage.LoadString ( IDS_ACTION_ERR_NOLOGNAME );
            MessageBox ( strMessage, m_pAlertQuery->GetLogName(), MB_OK  | MB_ICONERROR);
            m_pLogCombo.SetFocus();
            return FALSE;
        }
        bActionSet = TRUE;
    }

    if (!bActionSet ) {
        // make sure some action has been selected
        CString strMessage;
        strMessage.LoadString ( IDS_ACTION_ERR_NOACTION );
        MessageBox ( strMessage, m_pAlertQuery->GetLogName(), MB_OK  | MB_ICONERROR);
        return FALSE;
    }
    
    return bActionSet;
}

void 
CAlertActionProp::UpdateCmdActionBox ()
{
    UpdateData(TRUE);
    SetControlState();  
    SetModifiedPage(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// CAlertActionProp message handlers

BOOL 
CAlertActionProp::OnSetActive()
{
    BOOL        bReturn = TRUE;

    bReturn = CSmPropertyPage::OnSetActive();
    if ( bReturn ) {
        m_pAlertQuery->GetPropPageSharedData ( &m_SharedData );
    }
    return bReturn;
}

BOOL 
CAlertActionProp::OnKillActive() 
{
    BOOL bContinue = TRUE;
    ResourceStateManager    rsm;

    // Parent class OnKillActive calls UpdateData(TRUE)
    bContinue = CPropertyPage::OnKillActive();

    if ( bContinue ) {
        bContinue = IsValidData(m_pAlertQuery, VALIDATE_FOCUS );
        if ( bContinue ) {
            // Save property page shared data.
            m_pAlertQuery->SetPropPageSharedData ( &m_SharedData );
        }
    }

    if ( bContinue ) {
        SetIsActive ( FALSE );
    }

    return bContinue;
}

BOOL 
CAlertActionProp::OnApply() 
{
    DWORD   dwFlags = 0;
    DWORD   dwBufferSize = sizeof(ALERT_ACTION_INFO);
    LPTSTR  szNextString;
    INT     nCurLogSel = CB_ERR;
    BOOL    bContinue = TRUE;
    
    ResourceStateManager rsm;

    // get current settings
    bContinue = UpdateData(TRUE);

    if ( bContinue ) {
        bContinue = IsValidData( m_pAlertQuery, VALIDATE_APPLY ); 
    }

    if ( bContinue ) {
        bContinue = SampleTimeIsLessThanSessionTime ( m_pAlertQuery );
    }

    // Write the data to the query.
    if ( bContinue ) {
        dwFlags |= (m_Action_bLogEvent ? ALRT_ACTION_LOG_EVENT : 0);
        dwFlags |= (m_Action_bExecCmd ? ALRT_ACTION_EXEC_CMD : 0);
        dwFlags |= (m_Action_bSendNetMsg ? ALRT_ACTION_SEND_MSG : 0);
        dwFlags |= (m_Action_bStartLog ? ALRT_ACTION_START_LOG : 0);

        if (m_Action_bSendNetMsg) {
            dwBufferSize += (m_Action_strNetName.GetLength() + 1) * sizeof (WCHAR);
        }
    
        if (m_Action_bExecCmd) {

            dwBufferSize += (m_Action_strCmdPath.GetLength() + 1) * sizeof (WCHAR);
            dwBufferSize += (m_CmdArg_strUserText .GetLength() + 1) * sizeof (WCHAR);
            dwFlags |= (m_CmdArg_bAlertName ? ALRT_CMD_LINE_A_NAME : 0);
            dwFlags |= (m_CmdArg_bDateTime ? ALRT_CMD_LINE_D_TIME : 0);
            dwFlags |= (m_CmdArg_bLimitValue ? ALRT_CMD_LINE_L_VAL : 0);
            dwFlags |= (m_CmdArg_bCounterPath ? ALRT_CMD_LINE_C_NAME : 0);
            dwFlags |= (m_CmdArg_bSingleArg ? ALRT_CMD_LINE_SINGLE : 0);
            dwFlags |= (m_CmdArg_bMeasuredValue ? ALRT_CMD_LINE_M_VAL : 0);
            dwFlags |= (m_CmdArg_bUserText ? ALRT_CMD_LINE_U_TEXT : 0);
        }

        if (m_Action_bStartLog) {
            nCurLogSel = m_pLogCombo.GetCurSel();
            if (nCurLogSel != CB_ERR) {
                dwBufferSize += (m_pLogCombo.GetLBTextLen(nCurLogSel) + 1) * sizeof(WCHAR);
            }
        }

        if (m_pAlertInfo != NULL) delete (m_pAlertInfo);
        MFC_TRY
            m_pAlertInfo = (PALERT_ACTION_INFO) new CHAR[dwBufferSize];
        MFC_CATCH_MINIMUM
        if (m_pAlertInfo != NULL) {
            m_pAlertInfo->dwSize = dwBufferSize;
            m_pAlertInfo->dwActionFlags = dwFlags;
            szNextString = (LPTSTR)&m_pAlertInfo[1];
            if ((m_Action_bSendNetMsg) && (m_Action_strNetName.GetLength() > 0)) {
                m_pAlertInfo->szNetName = szNextString;
                lstrcpyW(m_pAlertInfo->szNetName, (LPCWSTR)m_Action_strNetName);
                szNextString += m_Action_strNetName.GetLength() + 1;
            } else {
                m_pAlertInfo->szNetName = NULL;
            }
            if (m_Action_bExecCmd) {
                if (m_Action_strCmdPath.GetLength() > 0) {
                    m_pAlertInfo->szCmdFilePath = szNextString;
                    lstrcpyW (m_pAlertInfo->szCmdFilePath, (LPCWSTR)m_Action_strCmdPath);
                    szNextString += m_Action_strCmdPath.GetLength() + 1;
                } else {
                    m_pAlertInfo->szCmdFilePath = NULL;
                }

                if (m_CmdArg_strUserText.GetLength() > 0) {
                    m_pAlertInfo->szUserText = szNextString;
                    lstrcpyW (m_pAlertInfo->szUserText, (LPCWSTR)m_CmdArg_strUserText);
                    szNextString += m_CmdArg_strUserText.GetLength() + 1;
                } else {
                    m_pAlertInfo->szUserText = NULL;
                }
            } else {
                m_pAlertInfo->szCmdFilePath = NULL;
                m_pAlertInfo->szUserText = NULL;
            }

            if ((m_Action_bStartLog) && (nCurLogSel != CB_ERR)) {
                // get log name 
                m_pAlertInfo->szLogName = szNextString; // for now
                m_pLogCombo.GetLBText(nCurLogSel, szNextString);
            } else {
                m_pAlertInfo->szLogName = NULL;
            }
        }

        if ( bContinue ) {
            bContinue = Apply(m_pAlertQuery); 
        }

        bContinue = CPropertyPage::OnApply();

        if ( bContinue ) {
            bContinue = ( ERROR_SUCCESS == m_pAlertQuery->SetActionInfo ( m_pAlertInfo ) );
        }

        if ( bContinue ) {
            // Save property page shared data.
            m_pAlertQuery->UpdatePropPageSharedData();

            bContinue = UpdateService( m_pAlertQuery, FALSE );
        }
    }

    return bContinue;
}

void 
CAlertActionProp::OnCancel() 
{
    CPropertyPage::OnCancel();
}

void 
CAlertActionProp::OnActionCmdArgsBtn() 
{
    DWORD dwStatus = ERROR_SUCCESS;
    CAlertCommandArgsDlg dlgCmdArgs;
    INT_PTR iResult;
    
    dlgCmdArgs.SetAlertActionPage( this );
    dwStatus = m_pAlertQuery->GetLogName ( dlgCmdArgs.m_strAlertName );

    if ( ERROR_SUCCESS == dwStatus ) {
        MFC_TRY    

            dlgCmdArgs.m_CmdArg_bAlertName = m_CmdArg_bAlertName;
            dlgCmdArgs.m_CmdArg_bDateTime = m_CmdArg_bDateTime;
            dlgCmdArgs.m_CmdArg_bLimitValue = m_CmdArg_bLimitValue;
            dlgCmdArgs.m_CmdArg_bCounterPath = m_CmdArg_bCounterPath;
            dlgCmdArgs.m_CmdArg_bSingleArg = m_CmdArg_bSingleArg;
            dlgCmdArgs.m_CmdArg_bMeasuredValue = m_CmdArg_bMeasuredValue;
            dlgCmdArgs.m_CmdArg_bUserText = m_CmdArg_bUserText;
            dlgCmdArgs.m_CmdArg_strUserText = m_CmdArg_strUserText;

            iResult = dlgCmdArgs.DoModal();

            if ( IDOK == iResult ) {
                if (dlgCmdArgs.m_CmdArg_bAlertName != m_CmdArg_bAlertName ) {
                    m_CmdArg_bAlertName = dlgCmdArgs.m_CmdArg_bAlertName;
                    SetModifiedPage ( TRUE );
                }
                if (dlgCmdArgs.m_CmdArg_bDateTime != m_CmdArg_bDateTime ) {
                    m_CmdArg_bDateTime = dlgCmdArgs.m_CmdArg_bDateTime;
                    SetModifiedPage ( TRUE );
                }
                if (dlgCmdArgs.m_CmdArg_bLimitValue != m_CmdArg_bLimitValue ) {
                    m_CmdArg_bLimitValue = dlgCmdArgs.m_CmdArg_bLimitValue;
                    SetModifiedPage ( TRUE );
                }
                if (dlgCmdArgs.m_CmdArg_bCounterPath != m_CmdArg_bCounterPath ) {
                    m_CmdArg_bCounterPath = dlgCmdArgs.m_CmdArg_bCounterPath;
                    SetModifiedPage ( TRUE );
                }
                if (dlgCmdArgs.m_CmdArg_bSingleArg != m_CmdArg_bSingleArg ) {
                    m_CmdArg_bSingleArg = dlgCmdArgs.m_CmdArg_bSingleArg;
                    SetModifiedPage ( TRUE );
                }
                if (dlgCmdArgs.m_CmdArg_bMeasuredValue != m_CmdArg_bMeasuredValue ) {
                    m_CmdArg_bMeasuredValue = dlgCmdArgs.m_CmdArg_bMeasuredValue;
                    SetModifiedPage ( TRUE );
                }
                if (dlgCmdArgs.m_CmdArg_bUserText != m_CmdArg_bUserText ) {
                    m_CmdArg_bUserText = dlgCmdArgs.m_CmdArg_bUserText;
                    SetModifiedPage ( TRUE );
                }
                if ( 0 != dlgCmdArgs.m_CmdArg_strUserText.CompareNoCase( m_CmdArg_strUserText ) ) {
                    m_CmdArg_strUserText = dlgCmdArgs.m_CmdArg_strUserText;
                    SetModifiedPage ( TRUE );
                }
                m_strCmdArgsExample = dlgCmdArgs.m_strSampleArgList;

                SetDlgItemText (IDC_ACTION_CMD_ARGS_DISPLAY, m_strCmdArgsExample);
                // Clear the selection
                ((CEdit*)GetDlgItem( IDC_ACTION_CMD_ARGS_DISPLAY ))->SetSel ( -1, FALSE );
            }
        MFC_CATCH_DWSTATUS
    }

    if ( ERROR_SUCCESS != dwStatus ) {
        CString strSysMessage;
        CString strMessage;
        
        MFC_TRY
            // TODO:  Use static string for message in order to display in low memory situations.
            strMessage.LoadString ( IDS_ERRMSG_GENERAL );
            FormatSystemMessage ( dwStatus, strSysMessage );

            strMessage += strSysMessage;
            MessageBox ( strMessage, m_pAlertQuery->GetLogName(), MB_OK  | MB_ICONERROR);
        MFC_CATCH_MINIMUM
        
            (GetDlgItem(IDC_ACTION_CMD_ARGS_BTN))->SetFocus();
    }
    return;
}

void 
CAlertActionProp::OnSelendokStartLogCombo() 
{
    INT nSel;
    
    nSel = m_pLogCombo.GetCurSel();
    
    if ( nSel != m_nCurLogSel && LB_ERR != nSel ) {
        UpdateData ( TRUE );
        SetModifiedPage ( TRUE );
    }
}

void CAlertActionProp::OnActionExecuteBrowseBtn() 
{
    CString strCmdPath;
    
    UpdateData (TRUE);  // to get the current filename
    
    strCmdPath = m_Action_strCmdPath;

    if ( IDOK == BrowseCommandFilename ( this, strCmdPath )) {
        // Update the fields with the new information
        if ( strCmdPath != m_Action_strCmdPath ) {
            m_Action_strCmdPath = strCmdPath;
            SetModifiedPage();
            UpdateData(FALSE);
        }
    } // else ignore if they canceled out
}

BOOL CAlertActionProp::OnInitDialog() 
{
    INT             nSelLog;
    DWORD           dwInfoBufSize = 0;

    ResourceStateManager    rsm;

    // Parent OnInitDialog calls UpdateData to initialize combo members.
    CSmPropertyPage::OnInitDialog();
        SetHelpIds ( (DWORD*)&s_aulHelpIds );

    // load service name combo box
    LoadLogQueries (SLQ_COUNTER_LOG);
    LoadLogQueries (SLQ_TRACE_LOG);

    if (m_pAlertInfo == NULL) {
        // get alert query info from alert class
        // get initial size by passing asking to fill a 0 len buffer
        m_pAlertQuery->GetActionInfo (m_pAlertInfo, &dwInfoBufSize);
        ASSERT (dwInfoBufSize > 0); // or something is wierd
        MFC_TRY;
        m_pAlertInfo = (PALERT_ACTION_INFO) new UCHAR [dwInfoBufSize];
        MFC_CATCH_MINIMUM;
        ASSERT (m_pAlertInfo != NULL);
        if ( NULL != m_pAlertInfo ) {
            memset (m_pAlertInfo, 0, dwInfoBufSize);    // init new buffer
            if (!m_pAlertQuery->GetActionInfo (m_pAlertInfo, &dwInfoBufSize)) {
                // then free the info block and use the defaults
                delete m_pAlertInfo;
                m_pAlertInfo = NULL;
            }
        }
    }        

    if (m_pAlertInfo != NULL) {
        // then initialize using the settings passed in
        m_Action_bLogEvent = ((m_pAlertInfo->dwActionFlags & ALRT_ACTION_LOG_EVENT) != 0);

        m_Action_bSendNetMsg = ((m_pAlertInfo->dwActionFlags & ALRT_ACTION_SEND_MSG) != 0);
        if (m_pAlertInfo->szNetName != NULL) {
            m_Action_strNetName = m_pAlertInfo->szNetName;
        } else {
            m_Action_strNetName.Empty();
        }

        m_Action_bExecCmd = ((m_pAlertInfo->dwActionFlags & ALRT_ACTION_EXEC_CMD) != 0);
        
        if (m_pAlertInfo->szCmdFilePath != NULL) {
            m_Action_strCmdPath = m_pAlertInfo->szCmdFilePath;
        } else {
            m_Action_strCmdPath.Empty();
        }

        if ( m_Action_bExecCmd ) {
            m_CmdArg_bAlertName = ((m_pAlertInfo->dwActionFlags & ALRT_CMD_LINE_A_NAME) != 0);
            m_CmdArg_bDateTime = ((m_pAlertInfo->dwActionFlags & ALRT_CMD_LINE_D_TIME) != 0);
            m_CmdArg_bLimitValue = ((m_pAlertInfo->dwActionFlags & ALRT_CMD_LINE_L_VAL) != 0);
            m_CmdArg_bCounterPath = ((m_pAlertInfo->dwActionFlags & ALRT_CMD_LINE_C_NAME) != 0);
            m_CmdArg_bSingleArg = ((m_pAlertInfo->dwActionFlags & ALRT_CMD_LINE_SINGLE) != 0);
            m_CmdArg_bMeasuredValue = ((m_pAlertInfo->dwActionFlags & ALRT_CMD_LINE_M_VAL) != 0);
            m_CmdArg_bUserText = ((m_pAlertInfo->dwActionFlags & ALRT_CMD_LINE_U_TEXT) != 0);

        } else {        
            m_CmdArg_bAlertName = TRUE;
            m_CmdArg_bDateTime = TRUE;
            m_CmdArg_bLimitValue = TRUE;     
            m_CmdArg_bCounterPath = TRUE;    
            m_CmdArg_bSingleArg = TRUE;      
            m_CmdArg_bMeasuredValue = TRUE;         
            m_CmdArg_bUserText = FALSE;
        } 

        if (m_pAlertInfo->szUserText != NULL) {
            m_CmdArg_strUserText = m_pAlertInfo->szUserText;
        }

        m_Action_bStartLog = ((m_pAlertInfo->dwActionFlags & ALRT_ACTION_START_LOG) != 0);

        if (m_pAlertInfo->szLogName != NULL) {
            nSelLog = m_pLogCombo.FindString (-1, m_pAlertInfo->szLogName);
            if (nSelLog != CB_ERR) {
                m_pLogCombo.SetCurSel (nSelLog);
                m_nCurLogSel = nSelLog;
            }
        }

    } else {
        // initialize using the default values as defined
        // in the constructor
    }
    
    MakeSampleArgList (
        m_strCmdArgsExample,
        m_CmdArg_bSingleArg,
        m_CmdArg_bAlertName,
        m_CmdArg_bDateTime,
        m_CmdArg_bCounterPath,
        m_CmdArg_bMeasuredValue,
        m_CmdArg_bLimitValue,
        m_CmdArg_bUserText,
        m_CmdArg_strUserText );

    SetDlgItemText (IDC_ACTION_CMD_ARGS_DISPLAY, m_strCmdArgsExample);
    // Clear the selection
    ((CEdit*)GetDlgItem( IDC_ACTION_CMD_ARGS_DISPLAY ))->SetSel ( -1, FALSE );
    
    // Call UpdateData again, after loading data.
    UpdateData ( FALSE );

    SetControlState();
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CAlertActionProp::OnActionApplogChk() 
{
    UpdateData(TRUE);
    SetControlState();
    SetModifiedPage(TRUE);
}

void CAlertActionProp::OnActionNetmsgChk() 
{
    UpdateData(TRUE);
    SetControlState();
    SetModifiedPage(TRUE);
}

void CAlertActionProp::OnActionExecuteChk() 
{
    UpdateData(TRUE);
    SetControlState();  
    SetModifiedPage(TRUE);
}

void CAlertActionProp::OnActionStartLogChk() 
{
    UpdateCmdActionBox ();
}


void CAlertActionProp::OnCmdPathTextEditChange() 
{
    CString strOldText;

    // When the user hits OK in the folder browse dialog, 
    // the folder name might not have changed.
    strOldText = m_Action_strCmdPath;
    UpdateData( TRUE );
    if ( 0 != strOldText.Compare ( m_Action_strCmdPath ) ) {
        SetModifiedPage(TRUE);
    }
}

void CAlertActionProp::OnNetNameTextEditChange() 
{
    CString strOldText;

    // When the user hits OK in the folder browse dialog, 
    // the folder name might not have changed.
    strOldText = m_Action_strNetName;
    UpdateData( TRUE );
    if ( 0 != strOldText.Compare ( m_Action_strNetName ) ) {
        SetModifiedPage(TRUE);
    }
}

DWORD 
CAlertActionProp::MakeSampleArgList (
    CString&    rstrResult,
    const BOOL  bSingleArg,
    const BOOL  bAlertName,
    const BOOL  bDateTime,
    const BOOL  bCounterPath,
    const BOOL  bMeasuredValue,
    const BOOL  bLimitValue,
    const BOOL  bUserText,
    const CString& rstrUserText )
{
    DWORD       dwStatus = ERROR_SUCCESS;
    CString     strDelim1;
    CString     strDelim2;
    BOOL        bFirstArgDone = FALSE;
    CString     strSampleString;
    CString     strTimeString;
    CString     strTemp;

    ResourceStateManager rsm;

    rstrResult.Empty(); // clear the old path

    MFC_TRY
        if ( bSingleArg ) {
            // then args are comma delimited
            strDelim1 = L",";
            strDelim2.Empty();
        } else {
            // for multiple args, they are enclosed in double quotes
            // and space delimited
            strDelim1 = L" \"";
            strDelim2 = L"\"";
        }

        if ( bAlertName ) {
            if (bFirstArgDone) {
                strSampleString += strDelim1; // add leading delimiter
            } else {
                strSampleString += L"\""; // add leading quote
                bFirstArgDone = TRUE;
            }
            strSampleString += m_pAlertQuery->GetLogName();
            strSampleString += strDelim2;
        }

        if ( bDateTime ) {
            if (bFirstArgDone) {
                strSampleString += strDelim1; // add leading delimiter
            } else {
                strSampleString += L"\""; // add leading quote
                bFirstArgDone = TRUE;
            }
            MakeTimeString(&strTimeString);
            strSampleString += strTimeString;
            strSampleString += strDelim2;
        }

        if ( bCounterPath ) {
            strTemp.LoadString ( IDS_SAMPLE_CMD_PATH );
            if (bFirstArgDone) {
                strSampleString += strDelim1; // add leading delimiter
            } else {
                strSampleString += L"\""; // add leading quote
                bFirstArgDone = TRUE;
            }
            strSampleString += strTemp;
            strSampleString += strDelim2;
        }

        if ( bMeasuredValue ) {

            strTemp.LoadString ( IDS_SAMPLE_CMD_MEAS_VAL );
            if (bFirstArgDone) {
                strSampleString += strDelim1; // add leading delimiter
            } else {
                strSampleString += L"\""; // add leading quote
                bFirstArgDone = TRUE;
            }
            strSampleString += strTemp;
            strSampleString += strDelim2;
        }

        if ( bLimitValue ) {
            strTemp.LoadString ( IDS_SAMPLE_CMD_LIMIT_VAL );
            if (bFirstArgDone) {
                strSampleString += strDelim1; // add leading delimiter
            } else {
                strSampleString += L"\""; // add leading quote
                bFirstArgDone = TRUE;
            }
            strSampleString += strTemp;
            strSampleString += strDelim2;
        }

        if ( bUserText ) {
            if (bFirstArgDone) {
                strSampleString += strDelim1; // add leading delimiter
            } else {
                strSampleString += L"\""; // add leading quote
                bFirstArgDone = TRUE;
            }
            strSampleString += rstrUserText;
            strSampleString += strDelim2;
        }

        if ( bFirstArgDone && bSingleArg ) {
            // add closing quote if there's at least 1 arg in the command line
            strSampleString += L"\"";
        }

        rstrResult = strSampleString;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

void CAlertActionProp::MakeTimeString(CString *pTimeString)
{
    SYSTEMTIME  st;
    pTimeString->Empty();

    GetLocalTime(&st);

    // Build string
    pTimeString->Format (L"%2.2d/%2.2d/%2.2d-%2.2d:%2.2d:%2.2d.%3.3d",
        st.wYear, st.wMonth, st.wDay, st.wHour, 
        st.wMinute, st.wSecond, st.wMilliseconds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\alrtactp.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    alrtactp.h

Abstract:

    Header file for the alert actions property page.

--*/

#if !defined(_AFX_ALRTACTP_H__INCLUDED_)
#define _AFX_ALRTACTP_H__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "smalrtq.h"    // For PALERT_ACTION_INFO
#include "smproppg.h"   // Base class
#include "smcfghlp.h"
// Dialog controls
#define IDD_ALERT_ACTION_PROP           1600

#define IDC_ACTION_CAPTION              1601
#define IDC_ACTION_CMD_ARGS_CAPTION     1602
#define IDC_ACTION_FIRST_HELP_CTRL_ID   1603
#define IDC_ACTION_APPLOG_CHK           1603
#define IDC_ACTION_NETMSG_CHK           1604
#define IDC_ACTION_NETMSG_NAME_EDIT     1605
#define IDC_ACTION_EXECUTE_CHK          1606
#define IDC_ACTION_EXECUTE_EDIT         1607
#define IDC_ACTION_EXECUTE_BROWSE_BTN   1608
#define IDC_ACTION_CMD_ARGS_BTN         1609    
#define IDC_ACTION_START_LOG_CHK        1610
#define IDC_ACTION_START_LOG_COMBO      1611
#define IDC_ACTION_CMD_ARGS_DISPLAY     1612

class CSmAlertQuery;
class CAlertCommandArgsDlg;

/////////////////////////////////////////////////////////////////////////////
// CAlertActionProp dialog

class CAlertActionProp : public CSmPropertyPage
{
    DECLARE_DYNCREATE(CAlertActionProp)

friend class CAlertCommandArgsDlg;

// Construction
public:
            CAlertActionProp();
            CAlertActionProp(MMC_COOKIE mmcCookie, LONG_PTR hConsole);
    virtual ~CAlertActionProp();

// Dialog Data
    //{{AFX_DATA(CAlertActionProp)
    enum { IDD = IDD_ALERT_ACTION_PROP };
    CComboBox   m_pLogCombo;
    BOOL    m_Action_bLogEvent;
    BOOL    m_Action_bExecCmd;
    BOOL    m_Action_bSendNetMsg;
    BOOL    m_Action_bStartLog;
    CString m_Action_strCmdPath;
    CString m_Action_strNetName;
    INT     m_nCurLogSel;
    BOOL    m_CmdArg_bAlertName;
    BOOL    m_CmdArg_bDateTime;
    BOOL    m_CmdArg_bLimitValue;
    BOOL    m_CmdArg_bCounterPath;
    BOOL    m_CmdArg_bSingleArg;
    BOOL    m_CmdArg_bMeasuredValue;
    BOOL    m_CmdArg_bUserText;
    CString m_CmdArg_strUserText;
    CString m_strCmdArgsExample;
    //}}AFX_DATA

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CAlertActionProp)
    public:
    protected:
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
public:
    void    MakeTimeString(CString *pTimeString);

    PALERT_ACTION_INFO m_pAlertInfo;

protected:

    virtual INT GetFirstHelpCtrlId ( void ) { return IDC_ACTION_FIRST_HELP_CTRL_ID; };  // Subclass must override.
    virtual BOOL    IsValidLocalData();

    // Generated message map functions
    //{{AFX_MSG(CAlertActionProp)
    afx_msg void OnActionExecuteBrowseBtn();
    afx_msg void OnActionApplogChk();
    afx_msg void OnActionNetmsgChk();
    afx_msg void OnActionExecuteChk();
    afx_msg void OnActionCmdArgsBtn();
    afx_msg void OnActionStartLogChk();
    afx_msg void OnNetNameTextEditChange();
    afx_msg void OnCmdPathTextEditChange();
    afx_msg void OnSelendokStartLogCombo();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    BOOL    LoadLogQueries ( DWORD dwLogType );
    BOOL    SetControlState(void);

private:
    DWORD   MakeSampleArgList (
                CString&    rstrResult,
                const BOOL  bSingleArg,
                const BOOL  bAlertName,
                const BOOL  bDateTime,
                const BOOL  bCounterPath,
                const BOOL  bMeasuredValue,
                const BOOL  bLimitValue,
                const BOOL  bUserText,
                const CString& rstrUserText );
    void    InitAfxDataItems (void);
    void    UpdateCmdActionBox (void);
    

    CSmAlertQuery       *m_pAlertQuery;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(_AFX_ALRTACTP_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\alrtcmdd.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    alrtcmdd.h

Abstract:

    Header file for the alert action command arguments dialog.

--*/

#ifndef _ALRTCMDD_H_
#define _ALRTCMDD_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// Dialog controls
#define IDD_ALERT_CMD_ARGS          1700

#define IDC_CMD_ARG_SAMPLE_CAPTION  1701
#define IDC_CMD_ARG_FIRST_HELP_CTRL 1702
#define IDC_CMD_ARG_SINGLE_CHK      1702
#define IDC_CMD_ARG_ALERT_CHK       1703
#define IDC_CMD_ARG_NAME_CHK        1704
#define IDC_CMD_ARG_DATE_CHK        1705
#define IDC_CMD_ARG_LIMIT_CHK       1706
#define IDC_CMD_ARG_VALUE_CHK       1707
#define IDC_CMD_USER_TEXT_CHK       1708
#define IDC_CMD_USER_TEXT_EDIT      1709
#define IDC_CMD_ARG_SAMPLE_DISPLAY  1710

class CAlertActionProp;

/////////////////////////////////////////////////////////////////////////////
// CAlertCommandArgsDlg dialog

class CAlertCommandArgsDlg : public CDialog
{
// Construction
public:
            CAlertCommandArgsDlg(CWnd* pParent=NULL);
    virtual ~CAlertCommandArgsDlg();

    void    SetAlertActionPage( CAlertActionProp* pPage );
    // Dialog Data
    //{{AFX_DATA(CProvidersProperty)
    enum { IDD = IDD_ALERT_CMD_ARGS };
    CString m_strAlertName;
    CString m_strSampleArgList;
    BOOL    m_CmdArg_bAlertName;
    BOOL    m_CmdArg_bDateTime;
    BOOL    m_CmdArg_bLimitValue;
    BOOL    m_CmdArg_bCounterPath;
    BOOL    m_CmdArg_bSingleArg;
    BOOL    m_CmdArg_bMeasuredValue;
    BOOL    m_CmdArg_bUserText;
    CString m_CmdArg_strUserText;
    // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CAlertCommandArgsDlg)
    public:
    virtual void OnFinalRelease();
    protected:
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CAlertCommandArgsDlg)
    afx_msg void OnCmdArgSingleChk();
    afx_msg void OnCmdArgAlertChk();
    afx_msg void OnCmdArgNameChk();
    afx_msg void OnCmdArgDateChk();
    afx_msg void OnCmdArgLimitChk();
    afx_msg void OnCmdArgValueChk();
    afx_msg void OnCmdUserTextChk();
    afx_msg void OnCmdArgUserTextEditChange();
    afx_msg BOOL OnHelpInfo( HELPINFO* );
    afx_msg void OnContextMenu( CWnd*, CPoint );
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CProvidersProperty)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH

private:
    void    UpdateCmdActionBox (void);
    BOOL    SetControlState(void);

    CAlertActionProp*   m_pAlertActionPage;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif //  _ALRTCMDD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\alrtgenp.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    alrtgenp.h

Abstract:

    Header file for the alerts general property page.

--*/

#if !defined(_AFX_ALRTGENP_H__INCLUDED_)
#define _AFX_ALRTGENP_H__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "smalrtq.h"    // For PALERT_ACTION_INFO
#include "smproppg.h"   // Base class
#include "smcfghlp.h"

// define entries in the Over/Under combo box here
#define OU_OVER 0
#define OU_UNDER 1

// resource definitions
#define IDD_ALERT_GENERAL_PROP          1500

#define IDC_ALRTS_START_STRING          1501
#define IDC_ALRTS_SAMPLE_CAPTION        1502
#define IDC_ALRTS_SAMPLE_INTERVAL_CAPTION 1503
#define IDC_ALRTS_SAMPLE_UNITS_CAPTION  1504
#define IDC_ALRTS_TRIGGER_CAPTION       1505
#define IDC_ALRTS_TRIGGER_VALUE_CAPTION 1506
#define IDC_ALRTS_FIRST_HELP_CTRL_ID    1507
#define IDC_ALRTS_COUNTER_LIST          1507
#define IDC_ALRTS_ADD_BTN               1508
#define IDC_ALRTS_REMOVE_BTN            1509
#define IDC_ALRTS_OVER_UNDER            1510
#define IDC_ALRTS_VALUE_EDIT            1511
#define IDC_ALRTS_COMMENT_EDIT          1512
#define IDC_ALRTS_SAMPLE_EDIT           1513
#define IDC_ALRTS_SAMPLE_SPIN           1514
#define IDC_ALRTS_SAMPLE_UNITS_COMBO    1515

/////////////////////////////////////////////////////////////////////////////
// CAlertGenProp dialog

class CAlertGenProp : public CSmPropertyPage
{
    DECLARE_DYNCREATE(CAlertGenProp)

// Construction
public:
            CAlertGenProp();
            CAlertGenProp(MMC_COOKIE mmcCookie, LONG_PTR hConsole);
    virtual ~CAlertGenProp();

    enum eConstants {
        eInvalidLimit = -1
    };

// Dialog Data
    //{{AFX_DATA(CAlertGenProp)
    enum { IDD = IDD_ALERT_GENERAL_PROP };
    int         m_nSampleUnits;
    CComboBox   m_SampleUnitsCombo;
    CComboBox   m_OverUnderCombo;
    CListBox    m_CounterList;
    double      m_dLimitValue;
    CString     m_strComment;
    CString     m_strStartDisplay;
    //}}AFX_DATA
    

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CAlertGenProp)
    public:
    protected:
    virtual BOOL OnApply();
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

// Implementation
public:
    void PublicOnSelchangeCounterList(void);

    // All of these members are Public to be accessed by the callback routine.
    LPTSTR  m_szCounterListBuffer;
    DWORD   m_dwCounterListBufferSize;
    DWORD   m_dwMaxHorizListExtent;
    PDH_BROWSE_DLG_CONFIG   m_dlgConfig;
    CSmAlertQuery       *m_pAlertQuery; // Public for callback function

    // buffers used to pass data to/from property page
    LPTSTR  m_szAlertCounterList;   // MSZ list of alert items
    DWORD   m_cchAlertCounterListSize;   // size of buffer in characters

protected:

    virtual INT GetFirstHelpCtrlId ( void ) { return IDC_ALRTS_FIRST_HELP_CTRL_ID; };
    virtual BOOL IsValidLocalData();

    // Generated message map functions
    //{{AFX_MSG(CAlertGenProp)
    afx_msg void OnDeltaposSampleSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnAddBtn();
    afx_msg void OnRemoveBtn();
    afx_msg void OnDblclkAlrtsCounterList();
    afx_msg void OnChangeAlertValueEdit();
    afx_msg void OnSelchangeCounterList();
    afx_msg void OnClose();
    afx_msg void OnCommentEditChange();
    afx_msg void OnSampleTimeChanged();
    afx_msg void OnKillFocusUpdateAlertData();
    afx_msg void OnCommentEditKillFocus();
    afx_msg void OnSelendokSampleUnitsCombo();
   	afx_msg void OnPwdBtn();
    afx_msg void OnChangeUser();

    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    INT                 m_ndxCurrentItem;

    BOOL SaveAlertItemData (void);
    BOOL LoadAlertItemData (INT nIndex);
    BOOL SetButtonState    (void);

    BOOL LoadDlgFromList ( void );
    BOOL LoadListFromDlg ( INT *piInvalidIndex, BOOL bValidateOnly = FALSE );

private:

    enum eValueRange {
        eMinSampleInterval = 1,
        eMaxSampleInterval = 999999,
        eHashTableSize = 257
    };

    // Counter Name Multi-SZ Hash Table

    typedef struct _HASH_ENTRY {
        struct _HASH_ENTRY         * pNext;
        PPDH_COUNTER_PATH_ELEMENTS   pCounter;
        DWORD   dwFlags;
        double  dLimit;
    } HASH_ENTRY, *PHASH_ENTRY;

    void    InitAlertHashTable ( void );
    void    ClearAlertHashTable ( void );
    ULONG   HashCounter ( LPTSTR szCounterName, ULONG  lHashSize );
    BOOL    InsertAlertToHashTable ( PALERT_INFO_BLOCK paibInfo );

    void ImplementAdd ( void );
    void InitAfxDataItems (void);
    void UpdateAlertStartString ( void );

    PHASH_ENTRY  m_HashTable[257];
    
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(_AFX_ALRTGENP_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\cmponent.cpp ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation

Module Name:

    cmponent.cpp

Abstract:

    Implementation of the CComponent class.

--*/

#include "StdAfx.h"
#include <shfolder.h>
#include "smcfgmsg.h"
#include "smproppg.h"
//
#include "ctrsprop.h"
#include "fileprop.h"
#include "provprop.h"
#include "schdprop.h"
#include "tracprop.h"
#include "AlrtGenP.h"
#include "AlrtActP.h"
//
#include "newqdlg.h"
#include "ipropbag.h"
#include "smrootnd.h"
#include "smlogs.h"
#include "smtracsv.h"
#include "cmponent.h"


USE_HANDLE_MACROS("SMLOGCFG(cmponent.cpp)")

// These globals are used for dialogs and property sheets
//


#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

static MMCBUTTON ToolbarResultBtnsLog[] =
{
   { 0, IDM_NEW_QUERY,      TBSTATE_ENABLED,    TBSTYLE_BUTTON, 0, 0 },
   { 0, 0,                  TBSTATE_ENABLED,    TBSTYLE_SEP,    0, 0 },
   { 1, IDM_START_QUERY,    TBSTATE_ENABLED,    TBSTYLE_BUTTON, 0, 0 },
   { 2, IDM_STOP_QUERY,     TBSTATE_ENABLED,    TBSTYLE_BUTTON, 0, 0 }
};

static MMCBUTTON ToolbarResultBtnsAlert[] =
{
   { 0, IDM_NEW_QUERY,      TBSTATE_ENABLED,    TBSTYLE_BUTTON, 0, 0 },
   { 0, 0,                  TBSTATE_ENABLED,    TBSTYLE_SEP,    0, 0 },
   { 1, IDM_START_QUERY,    TBSTATE_ENABLED,    TBSTYLE_BUTTON, 0, 0 },
   { 2, IDM_STOP_QUERY,     TBSTATE_ENABLED,    TBSTYLE_BUTTON, 0, 0 }
};

class CButtonStringsHolder
{
public:
  CButtonStringsHolder()
  {
    m_astr = NULL;
  }
  ~CButtonStringsHolder()
  {
    if (m_astr != NULL)
      delete[] m_astr;
  }
  CString* m_astr; // dynamic array of CStrings
};

CButtonStringsHolder g_astrButtonStringsLog;
CButtonStringsHolder g_astrButtonStringsAlert;

CONST INT cResultBtnsLog = sizeof ( ToolbarResultBtnsLog ) / sizeof ( MMCBUTTON );
CONST INT cResultBtnsAlert = sizeof ( ToolbarResultBtnsAlert ) / sizeof ( MMCBUTTON );

/////////////////////////////////////////////////////////////////////////////
// CComponent

HRESULT 
CComponent::LoadLogToolbarStrings ( MMCBUTTON * Buttons )
{
    UINT i;
    HRESULT hr = S_OK;
    ResourceStateManager rsm;

    if ( NULL != Buttons ) {

        if ( NULL == g_astrButtonStringsLog.m_astr ) {
            // Load strings
            g_astrButtonStringsLog.m_astr = new CString[2*cResultBtnsLog];

            if ( NULL != g_astrButtonStringsLog.m_astr ) {
                for ( i = 0; i < cResultBtnsLog; i++) {
                    // Skip separator buttons
                    if ( 0 != Buttons[i].idCommand ) {
                        UINT iButtonTextId = 0, iTooltipTextId = 0;
    
                        switch (Buttons[i].idCommand)
                        {
                            case IDM_NEW_QUERY:
                                iButtonTextId = IDS_BUTTON_NEW_LOG;
                                iTooltipTextId = IDS_TOOLTIP_NEW_LOG;
                                break;
                            case IDM_START_QUERY:
                                iButtonTextId = IDS_BUTTON_START_LOG;
                                iTooltipTextId = IDS_TOOLTIP_START_LOG;
                                break;
                            case IDM_STOP_QUERY:
                                iButtonTextId = IDS_BUTTON_STOP_LOG;
                                iTooltipTextId = IDS_TOOLTIP_STOP_LOG;
                                break;
                            default:
                                ASSERT(FALSE);
                                break;
                        }

                        g_astrButtonStringsLog.m_astr[i*2].LoadString(iButtonTextId);
                        Buttons[i].lpButtonText =
                        const_cast<BSTR>((LPCTSTR)(g_astrButtonStringsLog.m_astr[i*2]));

                        g_astrButtonStringsLog.m_astr[(i*2)+1].LoadString(iTooltipTextId);
                        Buttons[i].lpTooltipText =
                        const_cast<BSTR>((LPCTSTR)(g_astrButtonStringsLog.m_astr[(i*2)+1]));        
                    }   
                }
            }
        } else {
            hr = E_OUTOFMEMORY;
        }
    } else {
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT 
CComponent::LoadAlertToolbarStrings ( MMCBUTTON * Buttons )
{
    HRESULT hr = S_OK;
    UINT i;
    ResourceStateManager rsm;

    if ( NULL == g_astrButtonStringsAlert.m_astr ) {
        // Load strings
        g_astrButtonStringsAlert.m_astr = new CString[2*cResultBtnsAlert];

        if ( NULL != g_astrButtonStringsAlert.m_astr ) {
        
            for ( i = 0; i < cResultBtnsAlert; i++) {
                // Skip separator buttons
                if ( 0 != Buttons[i].idCommand ) {

                  UINT iButtonTextId = 0, iTooltipTextId = 0;
                  switch (Buttons[i].idCommand)
                  {
                  case IDM_NEW_QUERY:
                    iButtonTextId = IDS_BUTTON_NEW_ALERT;
                    iTooltipTextId = IDS_TOOLTIP_NEW_ALERT;
                    break;
                  case IDM_START_QUERY:
                    iButtonTextId = IDS_BUTTON_START_ALERT;
                    iTooltipTextId = IDS_TOOLTIP_START_ALERT;
                    break;
                  case IDM_STOP_QUERY:
                    iButtonTextId = IDS_BUTTON_STOP_ALERT;
                    iTooltipTextId = IDS_TOOLTIP_STOP_ALERT;
                    break;
                  default:
                    ASSERT(FALSE);
                    break;
                  }

                  g_astrButtonStringsAlert.m_astr[i*2].LoadString(iButtonTextId);
                  Buttons[i].lpButtonText =
                    const_cast<BSTR>((LPCTSTR)(g_astrButtonStringsAlert.m_astr[i*2]));

                  g_astrButtonStringsAlert.m_astr[(i*2)+1].LoadString(iTooltipTextId);
                  Buttons[i].lpTooltipText =
                    const_cast<BSTR>((LPCTSTR)(g_astrButtonStringsAlert.m_astr[(i*2)+1]));
                }
            }
        } else {
            hr = E_OUTOFMEMORY;
        }
    } else {
        hr = E_INVALIDARG;
    }
    return hr;
}

CComponent::CComponent()
:   m_ipConsole     ( NULL ),
    m_ipHeaderCtrl  ( NULL ),
    m_ipResultData  ( NULL ),
    m_ipConsoleVerb ( NULL ),
    m_ipImageResult ( NULL ),
    m_ipCompData    ( NULL ),
    m_ipControlbar  ( NULL ),
    m_ipToolbarLogger  ( NULL ),
    m_ipToolbarAlerts  ( NULL ),
    m_ipToolbarAttached  ( NULL ),

    m_pViewedNode   ( NULL )
{
    m_hModule = (HINSTANCE)GetModuleHandleW (_CONFIG_DLL_NAME_W_);

} // end Constructor()

//---------------------------------------------------------------------------
//
CComponent::~CComponent()
{
} // end Destructor()

/////////////////////////////////////////////////////////////////////////////
// IComponent implementation
//

//---------------------------------------------------------------------------
// IComponent::Initialize is called when a snap-in is being created and
// has items in the result pane to enumerate. The pointer to IConsole that
// is passed in is used to make QueryInterface calls to the console for
// interfaces such as IResultData.
//
STDMETHODIMP
CComponent::Initialize (
    LPCONSOLE lpConsole )       // [in] Pointer to IConsole's IUnknown interface
{
    HRESULT hr = E_POINTER;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT( NULL != lpConsole );

    if ( NULL != lpConsole ) {
        // Save away all the interfaces we'll need.
        // Fail if we can't QI the required interfaces.

        m_ipConsole = lpConsole;
        m_ipConsole->AddRef();
        
        hr = m_ipConsole->QueryInterface( 
                            IID_IResultData,
                            (VOID**)&m_ipResultData );
        if ( SUCCEEDED ( hr ) ) {
            hr = m_ipConsole->QueryInterface( 
                                IID_IHeaderCtrl,
                                (VOID**)&m_ipHeaderCtrl );
            if( SUCCEEDED ( hr ) ) {
                m_ipConsole->SetHeader( m_ipHeaderCtrl );
            }

            if ( SUCCEEDED ( hr ) ) {
                hr = m_ipConsole->QueryResultImageList( &m_ipImageResult);
            }

            if ( SUCCEEDED ( hr ) ) {
                hr = m_ipConsole->QueryConsoleVerb( &m_ipConsoleVerb );
            }
        }
    }

    return hr;

} // end Initialize()


//---------------------------------------------------------------------------
//  Handle the most important notifications.
//
STDMETHODIMP
CComponent::Notify (
    LPDATAOBJECT     pDataObject,  // [in] Points to data object
    MMC_NOTIFY_TYPE  event,        // [in] Identifies action taken by user
    LPARAM           arg,          // [in] Depends on the notification type
    LPARAM           Param         // [in] Depends on the notification type
    )
{
    HRESULT hr = S_OK;
    CDataObject* pDO = NULL;
    CSmLogQuery* pQuery = NULL;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT( NULL != m_ipCompData );  

    switch( event ) {
    case MMCN_ADD_IMAGES:
        hr = OnAddImages( pDataObject, arg, Param );
        break;

    case MMCN_DELETE:
        hr = OnDelete ( pDataObject, arg, Param );
        break;

    case MMCN_PASTE:
        LOCALTRACE( _T("CComponent::Notify: MMCN_PASTE unimplemented\n") );
        /*
        hr = OnPaste( pDataObject, arg, Param );
        */
        break;

    case MMCN_QUERY_PASTE:
        LOCALTRACE( _T("CComponent::Notify: MMCN_QUERY_PASTE unimplemented\n") );
        /*
        hr = OnQueryPaste( pDataObject, arg, Param );
        */
        break;

    case MMCN_REFRESH:
        hr = OnRefresh( pDataObject );
        break;

    case MMCN_SELECT:
        hr = OnSelect( pDataObject, arg, Param );
        break;

    case MMCN_SHOW:
        hr = OnShow( pDataObject, arg, Param );
        break;

    case MMCN_VIEW_CHANGE:
        hr = OnViewChange( pDataObject, arg, Param );
        break;

    case MMCN_PROPERTY_CHANGE:

        if ( NULL != Param ) {
            // Data object is passed as parameter
            hr = OnViewChange( (LPDATAOBJECT)Param, arg, CComponentData::eSmHintModifyQuery );
        } else {
            hr = S_FALSE;
        }
        break;

    case MMCN_CLICK:
        LOCALTRACE( _T("CComponent::Notify: MMCN_CLICK unimplemented\n") );
        break;

    case MMCN_DBLCLICK:
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL != pDO ) {
            hr = (HRESULT) OnDoubleClick ((ULONG) pDO->GetCookie(),pDataObject);
        } else { 
            hr = S_FALSE;
        }
        break;

    case MMCN_ACTIVATE:
        LOCALTRACE( _T("CComponent::Notify: MMCN_ACTIVATE unimplemented\n") );
        break;

    case MMCN_MINIMIZED:
        LOCALTRACE( _T("CComponent::Notify: MMCN_MINIMIZED unimplemented\n") );
        break;

    case MMCN_BTN_CLICK:
        LOCALTRACE( _T("CComponent::Notify: MMCN_BTN_CLICK unimplemented\n") );
        break;

    case MMCN_CONTEXTHELP:
        hr = OnDisplayHelp( pDataObject );
        break;

    default:
        LOCALTRACE( _T("CComponent::Notify: unimplemented event %x\n"), event );
        hr = S_FALSE;
        break;
    }
    return hr;

} // end Notify()


//---------------------------------------------------------------------------
// Releases all references to the console.
// Only the console should call this method.
//
STDMETHODIMP
CComponent::Destroy (
    MMC_COOKIE     /* mmcCookie */         // Reserved, not in use at this time
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Release the interfaces that we QI'ed
    m_ipConsole->SetHeader(NULL);

    SAFE_RELEASE( m_ipHeaderCtrl  );
    SAFE_RELEASE( m_ipResultData  );
    SAFE_RELEASE( m_ipImageResult );
    SAFE_RELEASE( m_ipConsoleVerb );
    SAFE_RELEASE( m_ipConsole     );
    SAFE_RELEASE( m_ipControlbar  );
    SAFE_RELEASE( m_ipToolbarLogger );
    SAFE_RELEASE( m_ipToolbarAlerts );

    return S_OK;

} // end Destroy()


//---------------------------------------------------------------------------
// Returns a data object that can be used to retrieve context information
// for the specified mmcCookie.
//
STDMETHODIMP
CComponent::QueryDataObject (
    MMC_COOKIE         mmcCookie,   // [in]  Specifies the unique identifier
    DATA_OBJECT_TYPES  context,     // [in]  Type of data object
    LPDATAOBJECT*      ppDataObject // [out] Points to address of returned data
    )
{
    HRESULT hr = S_OK;
    BOOL bIsQuery = FALSE;
    CComObject<CDataObject>* pDataObj = NULL;
    CSmLogQuery* pQuery = NULL;
    INT iResult;
    CString strMessage;
    ResourceStateManager    rsm;
    
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    ASSERT( CCT_SCOPE == context                // Must have a context
            || CCT_RESULT == context            // we understand
            || CCT_SNAPIN_MANAGER == context );

    ASSERT( NULL != m_ipCompData );  

    if ( NULL != ppDataObject 
        && ( CCT_SCOPE == context                // Must have a context
                || CCT_RESULT == context            // we understand
                || CCT_SNAPIN_MANAGER == context ) ) {

        if( CCT_RESULT == context && NULL != mmcCookie ) {
            CComObject<CDataObject>::CreateInstance( &pDataObj );
            if( NULL == pDataObj ) {             // DataObject was not created
                MFC_TRY
                    strMessage.LoadString( IDS_ERRMSG_OUTOFMEMORY );
                MFC_CATCH_HR
                hr = m_ipConsole->MessageBox( strMessage,
                    _T("CComponent::QueryDataObject"), // not localized
                    MB_OK | MB_ICONERROR,
                    &iResult
                    );
                hr = E_OUTOFMEMORY;
            } else {
                // Now we have a data object, init the mmcCookie, context and type
                bIsQuery = m_ipCompData->IsLogQuery (mmcCookie);

                if ( bIsQuery ) {
                    pQuery = (CSmLogQuery*)mmcCookie;
                    ASSERT ( NULL != pQuery );
                    if ( NULL != pQuery ) {
                        if ( CComponentData::eCounterLog == pQuery->GetLogType() ) {
                            pDataObj->SetData( mmcCookie, CCT_RESULT, COOKIE_IS_COUNTERMAINNODE );
                        } else if ( CComponentData::eTraceLog == pQuery->GetLogType() ) {
                            pDataObj->SetData( mmcCookie, CCT_RESULT, COOKIE_IS_TRACEMAINNODE );
                        } else if ( CComponentData::eAlert == pQuery->GetLogType() ) {
                            pDataObj->SetData( mmcCookie, CCT_RESULT, COOKIE_IS_ALERTMAINNODE );
                        } else {
                            ::MessageBox( NULL,
                                _T("Bad Cookie"),
                                _T("CComponentData::QueryDataObject"),
                                MB_OK | MB_ICONERROR
                                );
                            hr = E_OUTOFMEMORY;
                        }
                    }                 
                } else {
                    if  ( m_ipCompData->IsScopeNode( mmcCookie ) ) {
                        if ( NULL != (reinterpret_cast<PSMNODE>(mmcCookie))->CastToRootNode() ) {
                            pDataObj->SetData(mmcCookie, CCT_RESULT, COOKIE_IS_ROOTNODE);
                        } else {
                            ::MessageBox( NULL,
                                _T("Bad Cookie"),
                                _T("CComponentData::QueryDataObject"),
                                MB_OK | MB_ICONERROR
                                );
                            hr = E_OUTOFMEMORY;
                        }
                    }
                }
            }
        } else if ((CCT_SNAPIN_MANAGER == context) && (NULL != mmcCookie)) {
            // this is received by the snap in when it is added
            // as an extension snap ine
            CComObject<CDataObject>::CreateInstance( &pDataObj );
            if( NULL == pDataObj ) {            // DataObject was not created
                MFC_TRY
                    strMessage.LoadString( IDS_ERRMSG_OUTOFMEMORY );
                MFC_CATCH_HR
                hr = m_ipConsole->MessageBox( strMessage,
                    _T("CComponent::QueryDataObject"),  // not localized
                    MB_OK | MB_ICONERROR,
                    &iResult
                    );
                hr = E_OUTOFMEMORY;
            } else {
                // Now we have a data object, init the mmcCookie, context and type
                pDataObj->SetData( mmcCookie, CCT_SNAPIN_MANAGER, COOKIE_IS_MYCOMPUTER );
            }
        } else {                                // Request must have been from an
                                                // unknown source.  Should never see
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }

        if ( SUCCEEDED ( hr ) ) {
            hr = pDataObj->QueryInterface( IID_IDataObject,
                reinterpret_cast<void**>(ppDataObject) );
        } else {
            if ( NULL != pDataObj ) {
                delete pDataObj;
            }
            *ppDataObject = NULL;
        }
    } else {
        hr = E_POINTER;
    }

    return hr;
} // end QueryDataObject()


//---------------------------------------------------------------------------
// This is where we provide strings for items we added to the the result
// pane.  We get asked for a string for each column.
// Note that we still need to provide strings for items that are actually
// scope pane items. Notice that when the scope pane item was asked for a
// string for the scope pane we gave it. Here we actually have two columns
// of strings - "Name" and "Type".
// We also get asked for the icons for items in both panes.
//

STDMETHODIMP
CComponent::GetDisplayInfo (
    LPRESULTDATAITEM pResultItem )  // [in,out] Type of info required
{
    HRESULT     hr = S_OK;
    PSLQUERY    pQuery;
    CSmNode*    pNode;
    PSROOT      pRoot;
    PSLSVC      pSvc;
    WCHAR       szErrorText[MAX_PATH];
    ResourceStateManager    rsm;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if ( NULL == pResultItem ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        if( FALSE == pResultItem->bScopeItem ) {  // Doing result items...
            if( pResultItem->mask & RDI_STR ) {   // Now we have a object
                // Note:  Text buffer allocated for each information type, so that
                // the buffer pointer is persistent for a single item (line in the result pane).

                MFC_TRY

                switch (pResultItem->nCol) {
                case ROOT_COL_QUERY_NAME:
                    pQuery = reinterpret_cast<PSLQUERY>(pResultItem->lParam);
                    m_strDisplayInfoName = pQuery->GetLogName ( );
                    pResultItem->str = T2OLE ( m_strDisplayInfoName.GetBuffer( 0 ) );
                    m_strDisplayInfoName.ReleaseBuffer( );
                    break;

                case ROOT_COL_COMMENT:
                    pQuery= reinterpret_cast<PSLQUERY>(pResultItem->lParam);
                    m_strDisplayInfoComment = pQuery->GetLogComment ( );
                    pResultItem->str = T2OLE ( m_strDisplayInfoComment.GetBuffer( 0 ) );
                    m_strDisplayInfoComment.ReleaseBuffer( );
                    break;

                case ROOT_COL_LOG_TYPE:
                    pQuery= reinterpret_cast<PSLQUERY>(pResultItem->lParam);
                    // Query type should not be Alert
                    ASSERT ( SLQ_ALERT != pQuery->GetLogType() );
                    m_strDisplayInfoLogFileType =  pQuery->GetLogFileType ( );
                    pResultItem->str = T2OLE ( m_strDisplayInfoLogFileType.GetBuffer( 0 ) );
                    m_strDisplayInfoLogFileType.ReleaseBuffer( );
                    break;

                case ROOT_COL_LOG_NAME:
                    pQuery= reinterpret_cast<PSLQUERY>(pResultItem->lParam);
                    // Query type should not be Alert
                    ASSERT ( SLQ_ALERT != pQuery->GetLogType() );
                    m_strDisplayInfoLogFileName = pQuery->GetLogFileName ();
                    pResultItem->str = T2OLE ( m_strDisplayInfoLogFileName.GetBuffer( 0 ) );
                    m_strDisplayInfoLogFileName.ReleaseBuffer( );
                    break;

                default:
                    swprintf (szErrorText, _T("Error: Column %d Selected for Result Item\n"),
                              pResultItem->nCol);
                    ASSERT ( FALSE );
                    LOCALTRACE( szErrorText );
                    hr = E_UNEXPECTED;
                }

                MFC_CATCH_HR 
            }

            if (pResultItem->mask & RDI_IMAGE) {
                pQuery= reinterpret_cast<PSLQUERY>(pResultItem->lParam);
                if ( NULL != pQuery ) {
                    pResultItem->nImage = (pQuery->IsRunning() ? 0 : 1);
                } else {
                    ASSERT ( FALSE );
                    hr = E_UNEXPECTED;
                }
            }
        }
        else  // TRUE == pResultItem->bScopeItem
        {
            pNode = reinterpret_cast<CSmNode*>(pResultItem->lParam);

            if( pResultItem->mask & RDI_STR ) {
                if ( pNode->CastToRootNode() ) {

                    MFC_TRY

                    pRoot = reinterpret_cast<PSROOT>(pResultItem->lParam);

                    switch ( pResultItem->nCol ) {
                    case EXTENSION_COL_NAME:
                        m_strDisplayInfoName = pRoot->GetDisplayName();
                        pResultItem->str = T2OLE ( m_strDisplayInfoName.GetBuffer( 0 ) );
                        m_strDisplayInfoName.ReleaseBuffer( );
                        break;

                    case EXTENSION_COL_TYPE:
                        m_strDisplayInfoQueryType = pRoot->GetType();
                        pResultItem->str = T2OLE ( m_strDisplayInfoQueryType.GetBuffer( 0 ) );
                        m_strDisplayInfoQueryType.ReleaseBuffer( );
                        break;

                    case EXTENSION_COL_DESC:
                        m_strDisplayInfoDesc = pRoot->GetDescription();
                        pResultItem->str = T2OLE ( m_strDisplayInfoDesc.GetBuffer( 0 ) );
                        m_strDisplayInfoDesc.ReleaseBuffer( );
                        break;

                    default:
                        swprintf (szErrorText, _T("Error: Column %d Selected for Scope item\n"),
                            pResultItem->nCol);
                        ASSERT ( FALSE );
                        LOCALTRACE( szErrorText );
                        hr = E_UNEXPECTED;
                    }
                    
                    MFC_CATCH_HR
                } else {

                    ASSERT ( pNode->CastToLogService() );

                    MFC_TRY

                    if( pResultItem->nCol == MAIN_COL_NAME ) {
                        pSvc = reinterpret_cast<PSLSVC>(pResultItem->lParam);
                        m_strDisplayInfoName = pSvc->GetDisplayName();
                        pResultItem->str = T2OLE ( m_strDisplayInfoName.GetBuffer( 0 ) );
                        m_strDisplayInfoName.ReleaseBuffer( );
                    } else if( pResultItem->nCol == MAIN_COL_DESC ) {
                        pSvc = reinterpret_cast<PSLSVC>(pResultItem->lParam);
                        m_strDisplayInfoDesc = pSvc->GetDescription();
                        pResultItem->str = T2OLE ( m_strDisplayInfoDesc.GetBuffer( 0 ) );
                        m_strDisplayInfoDesc.ReleaseBuffer( );
                    } else {
                        swprintf (szErrorText, _T("Error: Column %d Selected for Scope item\n"),
                            pResultItem->nCol);
                        ASSERT ( FALSE );
                        LOCALTRACE( szErrorText );
                        hr = E_UNEXPECTED;
                    }

                    MFC_CATCH_HR
                }
            }

            if (pResultItem->mask & RDI_IMAGE)
            {
                CSmNode* pNode = reinterpret_cast<PSMNODE>(pResultItem->lParam);

                if ( NULL != pNode->CastToRootNode() ) {
                    pResultItem->nImage = CComponentData::eBmpRootIcon;
                } else if ( NULL != pNode->CastToAlertService() ) {
                    pResultItem->nImage = CComponentData::eBmpAlertType;
                } else {
                    pResultItem->nImage = CComponentData::eBmpLogType;
                }
            }
        }
    }

    return hr;

} // end GetDisplayInfo()


//---------------------------------------------------------------------------
// Determines what the result pane view should be
//
STDMETHODIMP
CComponent::GetResultViewType (
    MMC_COOKIE  /* mmcCookie */,        // [in]  Specifies the unique identifier
    BSTR  * /* ppViewType */,   // [out] Points to address of the returned view type
    long  *pViewOptions  // [out] Pointer to the MMC_VIEW_OPTIONS enumeration
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Ask for default listview.
    *pViewOptions = MMC_VIEW_OPTIONS_NONE;
    return S_FALSE;

} // end GetResultViewType()


//---------------------------------------------------------------------------
// Not used
//
HRESULT
CComponent::CompareObjects (
    LPDATAOBJECT /* lpDataObjectA */,  // [in] First data object to compare
    LPDATAOBJECT /* lpDataObjectB */  // [in] Second data object to compare
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return S_FALSE;

} // end CompareObjects()


/////////////////////////////////////////////////////////////////////////////
//  Support methods
//

//---------------------------------------------------------------------------
// Here is where we handle the MMCN_SHOW message.  Insert the column
// headers, and then the rows of data into the result pane.
//
HRESULT
CComponent::OnShow (
    LPDATAOBJECT pDataObject,    // [in] Points to data object
    LPARAM       Arg,            // [in]
    LPARAM       /* Param */ )   // [in] not used
{
    HRESULT         hr = S_OK;
    CDataObject*    pDO = NULL;
    CString         strColHeader;
    INT             iCommentSize;

    ResourceStateManager rsm;

    ASSERT( NULL != m_ipResultData );

    if ( TRUE == Arg ) {
    
        if ( NULL == pDataObject ) {
            ASSERT ( FALSE );
            hr = E_POINTER;
        } else {
            pDO = ExtractOwnDataObject(pDataObject);
            if ( NULL == pDO ) {
                ASSERT ( FALSE );
                hr = E_UNEXPECTED;
            }
        }
        if ( SUCCEEDED ( hr ) ) {
            m_pViewedNode = (CSmNode*)pDO->GetCookie();

            if( !(COOKIE_IS_ROOTNODE == pDO->GetCookieType() ) ) {

                // Query name
                MFC_TRY
                    strColHeader.LoadString ( IDS_ROOT_COL_QUERY_NAME );
                MFC_CATCH_HR

                hr = m_ipHeaderCtrl->InsertColumn(  
                        ROOT_COL_QUERY_NAME,
                        strColHeader,
                        LVCFMT_LEFT,
                        ROOT_COL_QUERY_NAME_SIZE );
                ASSERT( S_OK == hr );

                // Comment
                STANDARD_TRY
                    strColHeader.LoadString ( IDS_ROOT_COL_COMMENT );
                MFC_CATCH_HR

                iCommentSize = ROOT_COL_COMMENT_SIZE;
            
                if ( COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() ) {
                     iCommentSize += ROOT_COL_ALERT_COMMENT_XTRA;
                }

                hr = m_ipHeaderCtrl->InsertColumn(  
                        ROOT_COL_COMMENT,
                        strColHeader,
                        LVCFMT_LEFT,
                        iCommentSize);
                ASSERT( S_OK == hr );

                // Log type
                if ( COOKIE_IS_COUNTERMAINNODE == pDO->GetCookieType()
                    || COOKIE_IS_TRACEMAINNODE == pDO->GetCookieType() ) {

                    STANDARD_TRY
                        strColHeader.LoadString ( IDS_ROOT_COL_LOG_TYPE );
                    MFC_CATCH_HR

                    hr = m_ipHeaderCtrl->InsertColumn(  
                            ROOT_COL_LOG_TYPE,
                            strColHeader,
                            LVCFMT_LEFT,
                            ROOT_COL_LOG_TYPE_SIZE);
                    ASSERT( S_OK == hr );

                    STANDARD_TRY
                        strColHeader.LoadString ( IDS_ROOT_COL_LOG_FILE_NAME );
                    MFC_CATCH_HR

                    hr = m_ipHeaderCtrl->InsertColumn(  
                            ROOT_COL_LOG_NAME,
                            strColHeader,
                            LVCFMT_LEFT,
                            ROOT_COL_LOG_NAME_SIZE);
                    ASSERT( S_OK == hr );
                }

                // Set the items in the results pane rows
                ASSERT( CCT_SCOPE == pDO->GetContext() );
                ASSERT( COOKIE_IS_COUNTERMAINNODE == pDO->GetCookieType()
                        || COOKIE_IS_TRACEMAINNODE == pDO->GetCookieType()
                        || COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() );


                // The lParam is what we see in QueryDataObject as the mmcCookie.
                // Now we have an object representing row data, so that the
                // mmcCookie knows what to display in the results pane, when we
                // get into GetDisplayInfo we cast the mmcCookie to our object,
                // and then we can get the data to display.
                //
                hr = PopulateResultPane( pDO->GetCookie() );
            } else {

                MFC_TRY
                    strColHeader.LoadString ( IDS_MAIN_COL_NODE_NAME );
                MFC_CATCH_HR

                // Set the column headers in the results pane
                hr = m_ipHeaderCtrl->InsertColumn(  
                        MAIN_COL_NAME,
                        strColHeader,
                        LVCFMT_LEFT,
                        MAIN_COL_NAME_SIZE);
                ASSERT( S_OK == hr );

                STANDARD_TRY
                    strColHeader.LoadString ( IDS_MAIN_COL_NODE_DESCRIPTION );
                MFC_CATCH_HR

                hr = m_ipHeaderCtrl->InsertColumn(  
                        MAIN_COL_DESC,
                        strColHeader,
                        LVCFMT_LEFT,
                        MAIN_COL_DESC_SIZE);
                ASSERT( S_OK == hr );
            }
        }
    } else {
        m_pViewedNode = NULL;
    }
    return hr;

} // end OnShow()

//---------------------------------------------------------------------------
//
HRESULT
CComponent::OnAddImages (
    LPDATAOBJECT /* pDataObject */,  // [in] Points to the data object
    LPARAM /* arg */,                  // [in] Not used
    LPARAM /* param */                // [in] Not used
    )
{
    HRESULT hr = S_FALSE;
    ASSERT( NULL != m_ipImageResult );

    HBITMAP hbmp16x16 = NULL;
    HBITMAP hbmp32x32 = NULL;

    if ( NULL != g_hinst && NULL != m_ipImageResult ) {
        hbmp16x16 = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_NODES_16x16));
        hbmp32x32 = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_NODES_32x32));

        hr = m_ipImageResult->ImageListSetStrip(
            (LONG_PTR *)hbmp16x16,
            (LONG_PTR *)hbmp32x32,
            0,
            RGB(0,255,0)
            );

        ASSERT( S_OK == hr );

        if ( NULL != hbmp16x16 ) 
        {
            DeleteObject (hbmp16x16);
        }

        if ( NULL != hbmp32x32 ) 
        {
            DeleteObject (hbmp32x32);
        }
    }
    return hr;

} // end OnAddImages()

//---------------------------------------------------------------------------
//  This is a handler for the MMCN_PASTE notification. The user
//  copied a node to the clipboard.  Paste the counters from the data object
//  into the currently selected node.
//
HRESULT
CComponent::OnPaste (
    LPDATAOBJECT   pDataObject,  // [in] Points to the data object
    LPARAM         arg,          // [in] Points to source data object
    LPARAM     /*  param  */     // [in] Not used
    )
{
    HRESULT hr = S_FALSE;
    CDataObject* pDO = NULL;
    CDataObject* pDOSource = NULL;
    BOOL bIsQuery = FALSE;

    ASSERT( NULL != m_ipCompData );  

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
    }

    if ( SUCCEEDED ( hr ) ) {
        // Bail if we couldn't get the console verb interface, or if the
        // selected item is the root;
        if ( NULL == (LPDATAOBJECT)arg ) {
            ASSERT ( FALSE );
            hr = E_INVALIDARG;
        } else {
            pDOSource = ExtractOwnDataObject((LPDATAOBJECT)arg);
        }
    }

    if ( SUCCEEDED ( hr ) && NULL != pDO && NULL != pDOSource ) {
        bIsQuery = m_ipCompData->IsLogQuery (pDO->GetCookie())
                    && m_ipCompData->IsLogQuery (pDOSource->GetCookie());
        // Note: Can't check with compdata to determine if query, because
        // can be from another compdata

        if ( bIsQuery )
            hr = S_OK;
    }
    return hr;
} // end OnPaste()

//---------------------------------------------------------------------------
//  This is a handler for the MMCN_QUERY_PASTE notification. The user
//  copied a node to the clipboard.  Determine if that data object
//  can be pasted into the currently selected node.
//
HRESULT
CComponent::OnQueryPaste (
    LPDATAOBJECT   pDataObject,  // [in] Points to the data object
    LPARAM         arg,          // [in] Points to source data object
    LPARAM     /*  param  */ )   // [in] Not used
{
    HRESULT hr = S_FALSE;
    CDataObject* pDO = NULL;
    CDataObject* pDOSource = NULL;
    BOOL bIsQuery = FALSE;
    BOOL bState;

    ASSERT( NULL != m_ipCompData );  

    // Bail if we couldn't get the console verb interface, or if the
    // selected item is the root;
    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
    }

    if ( SUCCEEDED ( hr ) ) {
        if ( NULL == (LPDATAOBJECT)arg ) {
            ASSERT ( FALSE );
            hr = E_INVALIDARG;
        } else {
            pDOSource = ExtractOwnDataObject((LPDATAOBJECT)arg);
        }
    }

    if ( SUCCEEDED ( hr) && NULL != pDO && NULL != pDOSource ) {
        bIsQuery = m_ipCompData->IsLogQuery (pDO->GetCookie());

        if ( bIsQuery ) {
            hr = m_ipConsoleVerb->GetVerbState ( MMC_VERB_PASTE, ENABLED, &bState );
            hr = m_ipConsoleVerb->SetVerbState( MMC_VERB_PASTE, ENABLED, TRUE );
            hr = m_ipConsoleVerb->GetVerbState ( MMC_VERB_PASTE, ENABLED, &bState );
            ASSERT( S_OK == hr );

            hr = S_OK;
        }
    }
    return hr;
} // end OnQueryPaste()

//---------------------------------------------------------------------------
//  This is a handler for the MMCN_SELECT notification. The user
//  selected the node that populated the result pane. We have a
//  chance to enable verbs.
//
HRESULT
CComponent::OnSelect (
    LPDATAOBJECT   pDataObject,  // [in] Points to the data object
    LPARAM         arg,          // [in] Contains flags about the selected item
    LPARAM     /*  param  */ )   // [in] Not used
{
    HRESULT     hr = S_OK;
    BOOL        fScopePane;
    BOOL        fSelected;
    CDataObject* pDO = NULL;
    MMC_COOKIE  mmcCookie = 0;
    BOOL    bIsQuery = FALSE;
    CSmNode* pNode = NULL;
    PSLQUERY pQuery = NULL;

    ASSERT( NULL != m_ipCompData );  

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    if ( SUCCEEDED ( hr ) ) {
        // Bail if we couldn't get the console verb interface, or if the
        // selected item is the root;
        if( NULL == m_ipConsoleVerb || COOKIE_IS_ROOTNODE == pDO->GetCookieType() ) {
            hr = S_OK;
        } else {

            // Use selections and set which verbs are allowed

            fScopePane = LOWORD(arg);
            fSelected  = HIWORD(arg);

            if( fScopePane ) {                    // Selection in the scope pane
                // Enabled refresh for main node type, only if that node type is currently
                // being viewed in the result pane.
                if ( fSelected ) {
                    if ( COOKIE_IS_COUNTERMAINNODE == pDO->GetCookieType()
                                || COOKIE_IS_TRACEMAINNODE == pDO->GetCookieType()
                                || COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() ) {
                        if ( NULL != m_pViewedNode ) {
                            if ( m_pViewedNode == (CSmNode*)pDO->GetCookie() ) {
                                hr = m_ipConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );
                                ASSERT( S_OK == hr );
                            }
                        }
                    }
                }
            } else {                                 
                // Selection in the result pane
                // Properties is default verb

                if ( COOKIE_IS_COUNTERMAINNODE == pDO->GetCookieType()
                            || COOKIE_IS_TRACEMAINNODE == pDO->GetCookieType()
                            || COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() ) {
                    if ( NULL != m_pViewedNode ) {
                        mmcCookie = (MMC_COOKIE)pDO->GetCookie();

                        bIsQuery = m_ipCompData->IsLogQuery (mmcCookie);

                        if ( bIsQuery ) {
                            pQuery = (PSLQUERY)pDO->GetCookie();
                            if ( NULL != pQuery ) {
                                pNode = (CSmNode*)pQuery->GetLogService();
                            }
                        } else {
                            pNode = (CSmNode*)pDO->GetCookie();
                        }

                        if ( NULL != m_pViewedNode && m_pViewedNode == pNode ) {
                            hr = m_ipConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );
                            ASSERT( S_OK == hr );
                        }
                    }
                }

                if ( fSelected ) {
                    hr = m_ipConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES );
                    ASSERT( S_OK == hr );

                    // Enable properties and delete verbs
                    hr = m_ipConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );
                    ASSERT( S_OK == hr );
                    hr = m_ipConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, TRUE );
                    ASSERT( S_OK == hr );
/*
                    // Enable copying and pasting the object
                    hr = m_ipConsoleVerb->SetVerbState( MMC_VERB_COPY, ENABLED, TRUE );
                    ASSERT( S_OK == hr );
                    hr = m_ipConsoleVerb->SetVerbState( MMC_VERB_PASTE, HIDDEN, FALSE );
                    hr = m_ipConsoleVerb->SetVerbState( MMC_VERB_PASTE, ENABLED, FALSE );
                    ASSERT( S_OK == hr );
                } else {
                    hr = m_ipConsoleVerb->SetVerbState( MMC_VERB_PASTE, HIDDEN, FALSE );
                    hr = m_ipConsoleVerb->SetVerbState( MMC_VERB_PASTE, ENABLED, FALSE );
                    ASSERT( S_OK == hr );
*/
                }
            }
            hr = S_OK;
        }
    }

    return hr;

} // end OnSelect()


//---------------------------------------------------------------------------
//  Respond to the MMCN_REFRESH notification and refresh the rows.
//
HRESULT
CComponent::OnRefresh (
    LPDATAOBJECT pDataObject )  // [in] Points to the data object
{
    HRESULT hr = S_OK;
    CDataObject* pDO = NULL;
    
    ASSERT( NULL != m_ipResultData );
    
    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    if ( SUCCEEDED ( hr ) ) {
        // If this is the root node, don't need to do anything
        if( COOKIE_IS_ROOTNODE == pDO->GetCookieType() ) {
            hr = S_FALSE;
        } else {
            // Refresh the data model and update the result pane.
            // Use the stored pointer to the known viewed node, to handle the
            // case where the result pane contains scope nodes, and to handle
            // the case where the cookie is a query.
            if ( NULL != m_pViewedNode ) {
                hr = RefreshResultPane( (MMC_COOKIE) m_pViewedNode);
            }
            // RefreshResultPane cancels any selection.
            hr = HandleExtToolbars( TRUE, (LPARAM)0, (LPARAM)pDataObject );
        }
    }
    return hr;
} // end OnRefresh()

//---------------------------------------------------------------------------
//  Respond to the MMCN_VIEW_CHANGE notification and refresh as specified.
//
HRESULT
CComponent::OnViewChange (
    LPDATAOBJECT   pDataObject,  // [in] Points to the data object
    LPARAM         /* arg */,    // [in] Not used
    LPARAM         param )       // [in] Contains view change hint
{
    HRESULT hr = S_OK;
    CDataObject* pDO = NULL;

    ASSERT( NULL != m_ipCompData );  

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    if ( SUCCEEDED ( hr ) ) {
        if ( m_ipCompData->IsLogService ( pDO->GetCookie() ) 
            && CComponentData::eSmHintNewQuery == param ) {
            hr = OnRefresh( pDataObject );
        } else {
            hr = S_FALSE;
            if ( CCT_RESULT == pDO->GetContext() ) {
                HRESULTITEM hItemID = NULL;
                PSLQUERY    pSlQuery = reinterpret_cast<PSLQUERY>(pDO->GetCookie());

                ASSERT ( NULL != m_ipResultData );
                if ( NULL != pSlQuery ) {
                    // Redraw the item.
                    hr = m_ipResultData->FindItemByLParam ( (LPARAM)pSlQuery, &hItemID );
                    if ( SUCCEEDED(hr) ) {
                        hr = m_ipResultData->UpdateItem  ( hItemID );
                    }
                }

                // Sync the toolbar start/stop buttons.
                // 0 second arg indicates result scope.
                hr = HandleExtToolbars( FALSE, (LPARAM)0, (LPARAM)pDataObject );
            }
        }
    }
    return hr;
}

//---------------------------------------------------------------------------
//          Implementing a handler for MMCN_PROPERTY_CHANGE.
//          Param is the address of the PROPCHANGE struct that originally
//          came from the PropertySheet via MMCPropertyChangeNotify()
//
HRESULT
CComponent::OnPropertyChange (
    LPARAM     /*  param  */   // [in] PROPCHANGE_DATA struct with new data
    )
{

    return S_OK;
} // end OnPropertyChange()

//---------------------------------------------------------------------------
//  Store the parent IComponetData object.
//
HRESULT
CComponent::SetIComponentData (
    CComponentData*  pData )    // [in] Parent CComponentData object
{
    HRESULT hr = E_POINTER;
    LPUNKNOWN pUnk = NULL;

    ASSERT( NULL == m_ipCompData );        // Can't do this twice

    if ( NULL != pData ) {
        pUnk = pData->GetUnknown();  // Get the object IUnknown

        if ( NULL != pUnk ) {
            hr = pUnk->QueryInterface( IID_IComponentData,
                    reinterpret_cast<void**>(&m_ipCompData) );
        } else {
            hr = E_UNEXPECTED;
        }
    }
    return hr;
} // end SetIComponentData()

//---------------------------------------------------------------------------
//  Respond to the MMCN_CONTEXTHELP notification.
//
HRESULT
CComponent::OnDisplayHelp (
    LPDATAOBJECT /* pDataObject */ )  // [in] Points to the data object
{
    HRESULT hr = E_FAIL;
    IDisplayHelp* pDisplayHelp;
    CString strTopicPath;
    LPOLESTR pCompiledHelpFile = NULL;
    UINT    nBytes;
    
    USES_CONVERSION;

    ASSERT( NULL != m_ipCompData );  

    hr = m_ipConsole->QueryInterface(IID_IDisplayHelp, reinterpret_cast<void**>(&pDisplayHelp));
    
    if ( SUCCEEDED(hr) ) {
        MFC_TRY
            // construct help topic path = (help file::topic string)
            strTopicPath = m_ipCompData->GetConceptsHTMLHelpFileName(); 

            strTopicPath += _T("::/");
            strTopicPath += m_ipCompData->GetHTMLHelpTopic();           // sample.chm::/helptopic.htm

            nBytes = (strTopicPath.GetLength()+1) * sizeof(WCHAR);
            pCompiledHelpFile = (LPOLESTR)::CoTaskMemAlloc(nBytes);

            if ( NULL == pCompiledHelpFile ) {
                hr = E_OUTOFMEMORY;
            } else {
                memcpy(pCompiledHelpFile, (LPCTSTR)strTopicPath, nBytes);

                hr = pDisplayHelp->ShowTopic(T2W(pCompiledHelpFile));
                
                ::CoTaskMemFree ( pCompiledHelpFile );

                pDisplayHelp->Release();
            }
        MFC_CATCH_HR
    }
    return hr;
} // end OnDisplayHelp()

/////////////////////////////////////////////////////////////////////////////
//  IExtendContextMenu methods
//

//---------------------------------------------------------------------------
//  Implement some context menu items
//
STDMETHODIMP
CComponent::AddMenuItems (
    LPDATAOBJECT           pDataObject,         // [in] Points to data object
    LPCONTEXTMENUCALLBACK  pCallbackUnknown,    // [in] Points to callback function
    long*                  pInsertionAllowed )  // [in,out] Insertion flags
{
    HRESULT hr = S_OK;
    static CONTEXTMENUITEM ctxMenu[3];
    CDataObject* pDO = NULL;
    CString strTemp1, strTemp2, strTemp3, strTemp4, strTemp5, strTemp6;
    CSmLogQuery* pQuery;
    ResourceStateManager    rsm;
    
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT( NULL != m_ipCompData );  

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject( pDataObject );
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    if ( SUCCEEDED ( hr ) ) {
        // Only add menu items when we are allowed to.
        if ( ( COOKIE_IS_COUNTERMAINNODE == pDO->GetCookieType() )
                || ( COOKIE_IS_TRACEMAINNODE == pDO->GetCookieType() )
                || ( COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() ) )
        {
            if( CCM_INSERTIONALLOWED_NEW & *pInsertionAllowed ) {
                // Add "New Query..." context menu item
                hr = m_ipCompData->AddMenuItems ( pDataObject, pCallbackUnknown, pInsertionAllowed );
            
            } else if( CCM_INSERTIONALLOWED_TASK & *pInsertionAllowed ) {
                if ( m_ipCompData->IsLogQuery ( pDO->GetCookie() ) ) {
                    pQuery = (CSmLogQuery*)pDO->GetCookie();

                    if ( NULL != pQuery ) {

                        ZeroMemory ( &ctxMenu, sizeof ctxMenu );

                        // Add "Start" context menu item
                        strTemp1.LoadString ( IDS_MMC_MENU_START );
                        strTemp2.LoadString ( IDS_MMC_STATUS_START );
                        ctxMenu[0].strName = T2OLE(const_cast<LPTSTR>((LPCTSTR)strTemp1));
                        ctxMenu[0].strStatusBarText = T2OLE(const_cast<LPTSTR>((LPCTSTR)strTemp2));
                        ctxMenu[0].lCommandID        = IDM_START_QUERY;
                        ctxMenu[0].lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                        ctxMenu[0].fFlags            = MF_ENABLED;
                        ctxMenu[0].fSpecialFlags     = 0;

                        // Add "Stop" context menu item
                        strTemp3.LoadString ( IDS_MMC_MENU_STOP );
                        strTemp4.LoadString ( IDS_MMC_STATUS_STOP );
                        ctxMenu[1].strName = T2OLE(const_cast<LPTSTR>((LPCTSTR)strTemp3));
                        ctxMenu[1].strStatusBarText = T2OLE(const_cast<LPTSTR>((LPCTSTR)strTemp4));
                        ctxMenu[1].lCommandID        = IDM_STOP_QUERY;
                        ctxMenu[1].lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                        ctxMenu[1].fFlags            = MF_ENABLED;
                        ctxMenu[1].fSpecialFlags     = 0;

                        // Add "Save As..." context menu item
                        strTemp5.LoadString ( IDS_MMC_MENU_SAVE_AS );
                        strTemp6.LoadString ( IDS_MMC_STATUS_SAVE_AS );
                        ctxMenu[2].strName = T2OLE(const_cast<LPTSTR>((LPCTSTR)strTemp5));
                        ctxMenu[2].strStatusBarText = T2OLE(const_cast<LPTSTR>((LPCTSTR)strTemp6));
                        ctxMenu[2].lCommandID        = IDM_SAVE_QUERY_AS;
                        ctxMenu[2].lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                        ctxMenu[2].fFlags            = MF_ENABLED;
                        ctxMenu[2].fSpecialFlags     = 0;

                        if ( pQuery->IsRunning() ) {
                            ctxMenu[0].fFlags = MF_GRAYED;
                        } else {
                            ctxMenu[1].fFlags = MF_GRAYED;
                        }

                        hr = pCallbackUnknown->AddItem( &ctxMenu[0] );

                        if ( SUCCEEDED( hr ) ) {
                            hr = pCallbackUnknown->AddItem( &ctxMenu[1] );
                        }
                        if ( SUCCEEDED( hr ) ) {
                            hr = pCallbackUnknown->AddItem( &ctxMenu[2] );
                        }
                    } else {
                        ASSERT ( FALSE );
                        hr = E_UNEXPECTED;
                    }
                }
            } else {
                hr = S_OK;
            }
        }
    }
    
    return hr;
} // end AddMenuItems()

//---------------------------------------------------------------------------
//  Implement the command method so we can handle notifications
//  from our Context menu extensions.
//
STDMETHODIMP
CComponent::Command (
    long nCommandID,                // [in] Command to handle
    LPDATAOBJECT pDataObject )      // [in] Points to data object, pass through
{
    HRESULT hr = S_OK;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT( NULL != m_ipCompData );  

    switch( nCommandID ) {

    case IDM_NEW_QUERY:
        m_ipCompData->CreateNewLogQuery( pDataObject );
        break;

    case IDM_NEW_QUERY_FROM:
        m_ipCompData->CreateLogQueryFrom( pDataObject );
        break;

    case IDM_START_QUERY:
        StartLogQuery( pDataObject );
        break;

    case IDM_STOP_QUERY:
        StopLogQuery( pDataObject );
        break;

    case IDM_SAVE_QUERY_AS:
        SaveLogQueryAs( pDataObject );
        break;

    default:
        hr = S_FALSE;
    }

    return hr;

} // end Command()

/////////////////////////////////////////////////////////////////////////////
// IExtendControlBar implementation

//---------------------------------------------------------------------------
// Now the toolbar has three buttons
// We don't attach the toolbar to a window yet, that is handled
// after we get a notification.
//
STDMETHODIMP
CComponent::SetControlbar (
    LPCONTROLBAR  pControlbar )  // [in] Points to IControlBar
{
    HRESULT hr = S_OK;
    HBITMAP hbmpToolbarRes = NULL;
    HWND    hwndMain = NULL;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if( NULL != pControlbar ) {           // Make sure the Controlbar is OK

        if( NULL != m_ipControlbar ) {       // Don't orphan it if we already
                                             // had a pointer to it
            m_ipControlbar->Release();
        }

        m_ipControlbar = pControlbar;      // Cache the pointer
        m_ipControlbar->AddRef();

        if( NULL == m_ipToolbarLogger ) {        // Toolbar not created yet...

            hr = m_ipControlbar->Create(
                                    TOOLBAR,
                                    this,
                                    reinterpret_cast<LPUNKNOWN*>(&m_ipToolbarLogger) );
            if ( SUCCEEDED ( hr ) ) {
                hr = m_ipConsole->GetMainWindow( &hwndMain );
            }
            if ( SUCCEEDED ( hr ) ) {

                LoadLogToolbarStrings ( ToolbarResultBtnsLog );
                
                // Add the toolbar bitmap

                // Load special start button bitmap if RTL layout is enabled.
                if ( ! ( CWnd::FromHandle(hwndMain)->GetExStyle() & WS_EX_LAYOUTRTL ) ) {
                    hbmpToolbarRes = LoadBitmap( g_hinst, MAKEINTRESOURCE(IDB_TOOLBAR_RES));
                } else {
                    hbmpToolbarRes = LoadBitmap( g_hinst, MAKEINTRESOURCE(IDB_TOOLBAR_RES_RTL ));
                }
                
                hr = m_ipToolbarLogger->AddBitmap( 3, hbmpToolbarRes, 16, 16, RGB(255,0,255) );
                
                ASSERT( SUCCEEDED(hr) );
                // Add a few buttons
                hr = m_ipToolbarLogger->AddButtons(cResultBtnsLog, ToolbarResultBtnsLog);
            }
        }
        if( NULL == m_ipToolbarAlerts ) {        // Toolbar not created yet...

            hr = m_ipControlbar->Create(
                                    TOOLBAR,
                                    this,
                                    reinterpret_cast<LPUNKNOWN*>(&m_ipToolbarAlerts) );

            if ( SUCCEEDED ( hr ) ) {
                hr = m_ipConsole->GetMainWindow( &hwndMain );
            }

            if ( SUCCEEDED ( hr ) ) {

                LoadAlertToolbarStrings ( ToolbarResultBtnsAlert );

                // Add the toolbar bitmap
                // Load special start button bitmap if RTL layout is enabled.
                if ( ! ( CWnd::FromHandle(hwndMain)->GetExStyle() & WS_EX_LAYOUTRTL ) ) {
                    hbmpToolbarRes = LoadBitmap( g_hinst, MAKEINTRESOURCE(IDB_TOOLBAR_RES));
                } else {
                    hbmpToolbarRes = LoadBitmap( g_hinst, MAKEINTRESOURCE(IDB_TOOLBAR_RES_RTL ));
                }
                hr = m_ipToolbarAlerts->AddBitmap( 3, hbmpToolbarRes, 16, 16, RGB(255,0,255) );
                // Add a few buttons
                hr = m_ipToolbarAlerts->AddButtons(cResultBtnsAlert, ToolbarResultBtnsAlert);
            }
        }

        if( NULL != hbmpToolbarRes ) {
            DeleteObject(hbmpToolbarRes);
        }
        
        // Finished creating the toolbars
        hr = S_OK;
    } else {                    
        hr = S_FALSE;                    // No ControlBar available
    }

    return hr;

} // end SetControlBar()


//---------------------------------------------------------------------------
//  Handle ControlBar notifications to our toolbar
//  Now we can delete an object
//
STDMETHODIMP
CComponent::ControlbarNotify (
    MMC_NOTIFY_TYPE    event,    // [in] Type of notification
    LPARAM             arg,      // [in] Depends on notification
    LPARAM             param )    // [in] Depends on notification
{
    HRESULT hr = S_OK;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT( NULL != m_ipCompData );  

    switch( event ){
        case MMCN_BTN_CLICK:                    // For a Controlbar click, the
            switch( param ) {                   // param is the MenuItemID
                case IDM_NEW_QUERY:
                    m_ipCompData->CreateNewLogQuery( reinterpret_cast<LPDATAOBJECT>(arg) );
                    break;

                case IDM_START_QUERY:
                    StartLogQuery ( reinterpret_cast<LPDATAOBJECT>(arg) );
                    break;

                case IDM_STOP_QUERY:
                    StopLogQuery ( reinterpret_cast<LPDATAOBJECT>(arg) );
                    break;

                default:
                    LOCALTRACE( _T("ControlbarNotify: Unknown message") );
                }
            break;

        case MMCN_DESELECT_ALL:            // How to display the Toolbar
        case MMCN_SELECT:
            hr = HandleExtToolbars( (event == MMCN_DESELECT_ALL), arg, param );
            break;

        case MMCN_MENU_BTNCLICK:           // Not handling menus here
              DebugMsg( _T("MMCN_MENU_BTNCLICK"), _T("CComponent::ControlbarNotify") );
              // Drop through...
        default:
              hr = S_FALSE;
              break;
    }

    return hr;

} // end ControlbarNotify()

//---------------------------------------------------------------------------
//  Handle how the toolbars are displayed
//
HRESULT
CComponent::HandleExtToolbars (
    bool    bDeselectAll,       // [in] Notification
    LPARAM     /* arg */,       // [in] Depends on notification
    LPARAM  param               // [in] Depends on notification
    )          
{
    HRESULT hr = S_OK;
    BOOL bStartEnable = FALSE;
    BOOL bStopEnable = FALSE;
    BOOL bNewEnable = FALSE;
    CDataObject* pDO = NULL;
    LPDATAOBJECT pDataObject;
    CSmLogQuery* pQuery = NULL;
    
    ASSERT( NULL != m_ipCompData );  

    pDataObject = reinterpret_cast<LPDATAOBJECT>(param);

    if( NULL == pDataObject ) {
        hr = S_FALSE;
    } else {
        pDO = ExtractOwnDataObject( pDataObject );
        if ( NULL == pDO ) {
            hr = E_UNEXPECTED;
        }

        if ( SUCCEEDED ( hr ) ) {
            hr = S_FALSE;
            if( CCT_SCOPE == pDO->GetContext() ) {
                // Scope item selected, in either the scope or result pane.
                if( COOKIE_IS_ROOTNODE == pDO->GetCookieType() ) {
                    if ( NULL != m_ipToolbarAttached ) {
                        hr = m_ipControlbar->Detach( (LPUNKNOWN)m_ipToolbarAttached );
                        m_ipToolbarAttached = NULL;
                    }
                    ASSERT( SUCCEEDED(hr) );
                } else if( COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() ) {
                    // Attach the Alerts toolbar
                    if ( m_ipToolbarAttached != NULL && m_ipToolbarAttached != m_ipToolbarAlerts ) {
                        hr = m_ipControlbar->Detach( (LPUNKNOWN)m_ipToolbarAttached );
                        m_ipToolbarAttached = NULL;
                    }

                    hr = m_ipControlbar->Attach(TOOLBAR, (LPUNKNOWN)m_ipToolbarAlerts);
                    ASSERT( SUCCEEDED(hr) );
                    m_ipToolbarAttached = m_ipToolbarAlerts;

                    bNewEnable = TRUE;
                } else {
                    // Attach the Logger toolbar
                    if ( m_ipToolbarAttached != NULL && m_ipToolbarAttached != m_ipToolbarLogger ) {
                        hr = m_ipControlbar->Detach( (LPUNKNOWN)m_ipToolbarAttached );
                        m_ipToolbarAttached = NULL;
                    }

                    hr = m_ipControlbar->Attach(TOOLBAR, (LPUNKNOWN)m_ipToolbarLogger);
                    ASSERT( SUCCEEDED(hr) );
                    m_ipToolbarAttached = m_ipToolbarLogger;

                    bNewEnable = TRUE;
                }
            } else {

                if ( !bDeselectAll ) {

                    // Result pane context.
                    if( CCT_RESULT == pDO->GetContext() ) {
                        bStartEnable = m_ipCompData->IsLogQuery (pDO->GetCookie()) ? TRUE : FALSE;
                        if (bStartEnable) {
                            // then this is a log query, so see if the item is running or not
                            pQuery = (CSmLogQuery*)pDO->GetCookie();
                            if ( NULL != pQuery ) {
                                if (pQuery->IsRunning()) {
                                    // enable only the stop button
                                    bStartEnable = FALSE;
                                } else {
                                    // enable only the start button
                                }
                            } else {
                                ASSERT ( FALSE );
                            }
                            bStopEnable = !bStartEnable;
                        }
                    }
                } else {
                    bNewEnable = TRUE;
                }
            }

            if ( NULL != m_ipToolbarAttached ) {
                hr = m_ipToolbarAttached->SetButtonState( IDM_NEW_QUERY, ENABLED , bNewEnable );
                ASSERT( SUCCEEDED(hr) );

                hr = m_ipToolbarAttached->SetButtonState( IDM_START_QUERY, ENABLED , bStartEnable );
                ASSERT( SUCCEEDED(hr) );

                hr = m_ipToolbarAttached->SetButtonState( IDM_STOP_QUERY, ENABLED , bStopEnable );
                ASSERT( SUCCEEDED(hr) );
            }
        }
    }
    return hr;

} // end HandleExtToolbars()


/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet implementation
//

HRESULT 
CComponent::AddPropertyPage ( 
    LPPROPERTYSHEETCALLBACK lpProvider, 
    CSmPropertyPage*& rpPage 
    )
{
    HRESULT hr = S_OK;
    PROPSHEETPAGE_V3 sp_v3 = {0};
    HPROPSHEETPAGE   hPage = NULL;

    ASSERT( NULL != m_ipCompData );  

    if ( NULL == rpPage ) {
        ASSERT ( FALSE );
        hr = E_UNEXPECTED;
    } else {

        rpPage->SetContextHelpFilePath( m_ipCompData->GetContextHelpFilePath() );
    
        rpPage->m_psp.lParam = (INT_PTR)rpPage;
        rpPage->m_psp.pfnCallback = &CSmPropertyPage::PropSheetPageProc;

        CopyMemory (&sp_v3, &rpPage->m_psp, rpPage->m_psp.dwSize);
        sp_v3.dwSize = sizeof(sp_v3);

        hPage = CreatePropertySheetPage (&sp_v3);

        if ( NULL != hPage ) {
            hr = lpProvider->AddPage(hPage);
            if ( FAILED(hr) ) {
                ASSERT ( FALSE );
                delete rpPage;
                rpPage = NULL;
            }
        } else {
            delete rpPage;
            rpPage = NULL;
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }
    return hr;

}


HRESULT
CComponent::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,    // Pointer to the callback interface
    LONG_PTR                handle,        // Handle for routing notification
    LPDATAOBJECT            pDataObject    // Pointer to the data object
    )
{
    HRESULT         hr = S_OK;
    CDataObject*    pDO = NULL;
    MMC_COOKIE      Cookie;
    CSmLogQuery*    pQuery = NULL;
    DWORD           dwLogType;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT( NULL != m_ipCompData );  

    if ( NULL == pDataObject 
                || NULL == lpProvider ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    //         We cheat a little here and pass what we need to a custom
    //         constructor for our derived property page class

    if ( SUCCEEDED ( hr ) ) {
        Cookie = pDO->GetCookie();
        if ( NULL != Cookie ) {
            CWnd* pPropSheet = NULL;
            
            pQuery = (CSmLogQuery *)Cookie;

            if ( NULL != pQuery ) {
                // If the property sheet for this query is already active, just bring it to the foreground.

                pPropSheet = pQuery->GetActivePropertySheet();

                if ( NULL != pPropSheet ) {

                    pPropSheet->SetForegroundWindow();
                    MMCFreeNotifyHandle(handle);
                    hr = S_FALSE;
            
                } else {

                    dwLogType = pQuery->GetLogType();

                    if (SLQ_ALERT != dwLogType) { 
        
                        if ( SLQ_TRACE_LOG == dwLogType) {
                            CSmPropertyPage*    pPage1 = NULL;  
                            CWaitCursor         WaitCursor;
                    
                            // Connect to the server before creating the dialog 
                            // so that the wait cursor can be used consistently.

                            // Sync the providers here so that the WMI calls are consistently
                            // from a single thread.
                            ASSERT ( NULL != pQuery->CastToTraceLogQuery() );
                            hr = (pQuery->CastToTraceLogQuery())->SyncGenProviders();

                            if ( SUCCEEDED ( hr ) ) {
                                MFC_TRY
                                    pPage1 = new CProvidersProperty (Cookie, handle);
                                    if ( NULL != pPage1 ) {
                                        hr = AddPropertyPage ( lpProvider, pPage1 );
                                    }
                                MFC_CATCH_HR
                            } else {
                                CString strMachineName;
                                CString strLogName;

                                pQuery->GetMachineDisplayName( strMachineName );
                                strLogName = pQuery->GetLogName();
                        
                                m_ipCompData->HandleTraceConnectError ( 
                                    hr, 
                                    strLogName,
                                    strMachineName );
                            }

                        } else {
                            CSmPropertyPage *pPage1 = NULL;

                            MFC_TRY
                                pPage1 = new CCountersProperty (Cookie, handle );
                                if ( NULL != pPage1 ) {
                                    hr = AddPropertyPage ( lpProvider, pPage1 );
                                } 
                            MFC_CATCH_HR
                        }

                        if ( SUCCEEDED(hr) ) {
                            CSmPropertyPage* pPage2 = NULL;
                            CSmPropertyPage* pPage3 = NULL;
        
                            MFC_TRY
                                pPage2 = new CFilesProperty(Cookie, handle);
                                if ( NULL != pPage2 ) {
                                    hr = AddPropertyPage ( lpProvider, pPage2 );
                                } 

                                if ( SUCCEEDED(hr) ) {
                                    pPage3 = new CScheduleProperty (Cookie, handle, pDataObject );
                                    if ( NULL != pPage3 ) {
                                        hr = AddPropertyPage ( lpProvider, pPage3 );
                                    } 
                                }
                            MFC_CATCH_HR

                            if ( FAILED(hr) ) {
                                if ( NULL != pPage3 ) {
                                    delete pPage3;
                                }
                                if ( NULL != pPage2 ) {
                                    delete pPage2;
                                }
                            }
                        }

                        if ( SUCCEEDED(hr) ) {

                            if ( SLQ_TRACE_LOG == pQuery->GetLogType() ) {
                                CSmPropertyPage*    pPage4 = NULL;
                        
                                MFC_TRY
                                    pPage4 = new CTraceProperty(Cookie, handle);
                                    if ( NULL != pPage4 ) {
                                        hr = AddPropertyPage ( lpProvider, pPage4 );
                                    } 
                                MFC_CATCH_HR
                            }
                        }
                    } else {
                        ASSERT ( SLQ_ALERT == dwLogType );

                        CSmPropertyPage*    pPage1 = NULL;
                        CSmPropertyPage*    pPage2 = NULL;
                        CSmPropertyPage*    pPage3 = NULL;
        
                        MFC_TRY
                            pPage1 = new CAlertGenProp (Cookie, handle);
                            if ( NULL != pPage1 ) {
                                hr = AddPropertyPage ( lpProvider, pPage1 );
                            } 

                            if ( SUCCEEDED(hr) ) {
                                pPage2 = new CAlertActionProp (Cookie, handle);
                                if ( NULL != pPage2 ) {
                                    hr = AddPropertyPage ( lpProvider, pPage2 );
                                } 
                            }

                            if ( SUCCEEDED(hr) ) {
                                pPage3 = new CScheduleProperty (Cookie, handle, pDataObject);
                                if ( NULL != pPage3 ) {
                                    hr = AddPropertyPage ( lpProvider, pPage3 );
                                } 
                            }
                        MFC_CATCH_HR

                        if ( FAILED(hr) ) {
                            if ( NULL != pPage3 ) {
                                delete pPage3;
                            }
                            if ( NULL != pPage2 ) {
                                delete pPage2;
                            }
                            if ( NULL != pPage1 ) {
                                delete pPage1;
                            }
                        }
                    }
                }
            } else {
                ASSERT ( FALSE );
                hr = E_UNEXPECTED;
            }
        } else {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }
    return hr;

} // end CreatePropertyPages()


//---------------------------------------------------------------------------
// The console calls this method to determine whether the Properties menu
// item should be added to the context menu.  We added the Properties item
// by enabling the verb.  So long as we have a vaild DataObject we
// can return OK.
//
HRESULT
CComponent::QueryPagesFor (
    LPDATAOBJECT pDataObject ) // [in] Points to IDataObject for selected node
{
    HRESULT hr = S_OK;
    CDataObject* pDO = NULL;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    if ( SUCCEEDED ( hr ) ) {
        if ( COOKIE_IS_COUNTERMAINNODE == pDO->GetCookieType()
                || COOKIE_IS_TRACEMAINNODE == pDO->GetCookieType()
                || COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() )
        {
            hr = S_OK;
        } else {
            hr = S_FALSE;
        }
    }
    return hr;

} // end QueryPagesFor()

HRESULT
CComponent::PopulateResultPane (
    MMC_COOKIE  mmcCookie )
{
    HRESULT     hr = S_OK;
    PSLSVC      pSLSVC = NULL;
    PSLQUERY    pSlQuery = NULL;
    POSITION    Pos;
    RESULTDATAITEM rdi;

    ASSERT ( NULL != m_ipResultData );

    if ( NULL == mmcCookie ) {
        ASSERT ( FALSE );
        hr = E_INVALIDARG;
    } else {
        pSLSVC = reinterpret_cast<PSLSVC>(mmcCookie);       
        ASSERT ( NULL != pSLSVC->CastToLogService() ); 

        hr = m_ipResultData->DeleteAllRsltItems();

        if( SUCCEEDED(hr) ) {

            memset(&rdi, 0, sizeof(RESULTDATAITEM));
            rdi.mask =   RDI_STR     |         // Displayname is valid
                         // RDI_IMAGE   |         // nImage is valid
                         RDI_PARAM;            // lParam is valid

            rdi.str    = MMC_CALLBACK;
            rdi.nImage = 2;

            Pos = pSLSVC->m_QueryList.GetHeadPosition();

            // load the query object pointers into the results page
            while ( Pos != NULL) {
                pSlQuery = pSLSVC->m_QueryList.GetNext( Pos );
                rdi.lParam = reinterpret_cast<LPARAM>(pSlQuery);
                hr = m_ipResultData->InsertItem( &rdi );
                if( FAILED(hr) )
                    DisplayError( hr, _T("PopulateResultPane") );
            }
        }
    }

    return hr;
} // end PopulateResultPane()

HRESULT
CComponent::RefreshResultPane (
    MMC_COOKIE mmcCookie )
{
    HRESULT hr = S_OK;
    DWORD dwStatus = ERROR_SUCCESS;
    PSLSVC    pSLSVC = reinterpret_cast<PSLSVC>(mmcCookie);

    ASSERT( NULL != m_ipResultData );    
    
    // Cookie is null if refresh is activated when right pane is not
    // populated with queries.
    if ( NULL != pSLSVC ) {

        dwStatus = pSLSVC->SyncWithRegistry();

        // Todo:  Server Beta 3 - display error message if any property pages are open. 

        if ( ERROR_SUCCESS == dwStatus ) {
            hr = PopulateResultPane( mmcCookie );
        } else {
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT
CComponent::OnDelete (
    LPDATAOBJECT pDataObject,      // [in] Points to data object
    LPARAM     /* arg */   ,       // Not used     
    LPARAM     /* param */         // Not used
    )
{
    HRESULT     hr = S_OK;
    DWORD       dwStatus = ERROR_SUCCESS;
    CDataObject *pDO = NULL;
    PSLQUERY    pQuery = NULL;
    CSmLogService* pSvc = NULL;
    int         iResult;
    CString     strMessage;
    CString     csTitle;
    CString     strMachineName;
    MMC_COOKIE  mmcCookie = 0;
    BOOL        bIsQuery = FALSE;
    BOOL        bContinue = TRUE;
    ResourceStateManager    rsm;
    HRESULTITEM hItemID = NULL;
    RESULTDATAITEM  rdi;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT( NULL != m_ipCompData );  

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject( pDataObject );

        if( NULL == pDO ) {
            // Unknown data object
            strMessage.LoadString ( IDS_ERRMSG_UNKDATAOBJ );
            hr = m_ipConsole->MessageBox( (LPCWSTR)strMessage,
                _T("CComponentData::OnDelete"),
                MB_OK | MB_ICONERROR,
                &iResult
                );
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        } else {
            // If this is the root node, don't need to do anything
            if( COOKIE_IS_ROOTNODE == pDO->GetCookieType() ) {
                hr = S_FALSE;
            } else {
                // Just make sure we are where we think we are
                ASSERT( CCT_RESULT == pDO->GetContext() );
                ASSERT( COOKIE_IS_COUNTERMAINNODE == pDO->GetCookieType()
                        || COOKIE_IS_TRACEMAINNODE == pDO->GetCookieType()
                        || COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() );

                mmcCookie = (MMC_COOKIE)pDO->GetCookie();

                bIsQuery = m_ipCompData->IsLogQuery (mmcCookie);

                if (bIsQuery) {
                    pQuery = (PSLQUERY)mmcCookie;

                    if ( NULL != pQuery ) {
                        pSvc = ( pQuery->GetLogService() );
                        if ( !pQuery->IsExecuteOnly() ) {
                            if ( pQuery->IsModifiable() ) {
                                if ( m_ipCompData->IsRunningQuery( pQuery ) ) {
                                    iResult = IDOK;

                                    // Don't delete running queries.  Stop the query if requested
                                    // by the user.
                                    strMessage.LoadString ( IDS_ERRMSG_DELETE_RUNNING_QUERY );
                                    csTitle.LoadString ( IDS_PROJNAME );
                                    hr = m_ipConsole->MessageBox(
                                            (LPCWSTR)strMessage,
                                            (LPCWSTR)csTitle,
                                            MB_OKCANCEL | MB_ICONWARNING,
                                            &iResult
                                            );

                                    if ( IDOK == iResult ) {
                                        // If property page is open, StopLogQuery 
                                        // shows error message
                                        hr = StopLogQuery ( pDataObject, FALSE );
                                        if ( FAILED ( hr ) ) {
                                            bContinue = TRUE;
                                            hr = S_FALSE;
                                        }
                                    } else {
                                        bContinue = FALSE;
                                        hr = S_FALSE;
                                    }
                                } else if ( NULL != pQuery->GetActivePropertySheet() ){
                                    // Don't delete queries with open property pages.
                                    strMessage.LoadString ( IDS_ERRMSG_DELETE_OPEN_QUERY );
                                    csTitle.LoadString ( IDS_PROJNAME );
                                    hr = m_ipConsole->MessageBox(
                                            (LPCWSTR)strMessage,
                                            (LPCWSTR)csTitle,
                                            MB_OK | MB_ICONWARNING,
                                            &iResult );
                        
                                    ((CWnd*)pQuery->GetActivePropertySheet())->SetForegroundWindow();

                                    bContinue = FALSE;
                                    hr = S_FALSE;

                                } 
                                            
                                if ( bContinue ) {
                                    if ( NULL != pSvc ) {
                                        hr = m_ipResultData->FindItemByLParam ( (LPARAM)mmcCookie, &hItemID );
                                        if ( SUCCEEDED(hr) ) {

                                            hr = m_ipResultData->DeleteItem ( hItemID, 0 );

                                            if ( SUCCEEDED(hr) ) {

                                                dwStatus = pSvc->DeleteQuery(pQuery);

                                                // Mark as deleted, because already deleted 
                                                // from the UI.  
                                                hr = S_OK;
                                            } else {
                                                hr = S_FALSE;
                                            }
                                        }
                                    } else {
                                        ASSERT ( FALSE );
                                        hr = E_UNEXPECTED;
                                    }
                                }
                            } else {
                                if ( NULL != pSvc ) {
                                    strMachineName = pSvc->GetMachineDisplayName();
                                } else {
                                    strMachineName.Empty();
                                }

                                FormatSmLogCfgMessage (
                                    strMessage,
                                    m_hModule,
                                    SMCFG_NO_MODIFY_ACCESS,
                                    (LPCTSTR)strMachineName);

                                csTitle.LoadString ( IDS_PROJNAME );
                                hr = m_ipConsole->MessageBox(
                                                    (LPCWSTR)strMessage,
                                                    (LPCWSTR)csTitle,
                                                    MB_OK | MB_ICONERROR,
                                                    &iResult );
                                hr = S_FALSE; 
                            }
                        } else {

                            // Don't delete template queries.
                            strMessage.LoadString ( IDS_ERRMSG_DELETE_TEMPLATE_QRY );
                            csTitle.LoadString ( IDS_PROJNAME );
                            hr = m_ipConsole->MessageBox(
                                    (LPCWSTR)strMessage,
                                    (LPCWSTR)csTitle,
                                    MB_OK | MB_ICONERROR,
                                    &iResult
                                    );
                            hr = S_FALSE;
                        }
                    } else {
                        ASSERT ( FALSE );
                        hr = E_UNEXPECTED;
                    }
                } else {
                    hr = S_FALSE;
                }
            }
        }
    }

    return hr;
}

HRESULT
CComponent::OnDoubleClick (
    ULONG ulRecNo,
    LPDATAOBJECT pDataObject )  // [in] Points to the data object
{
    HRESULT     hr = S_OK;
    CDataObject* pDO = NULL;
    MMC_COOKIE  mmcCookie;
    BOOL bIsQuery = FALSE;
    PSLQUERY    pQuery = NULL;
    LONG_PTR    handle = NULL;
    CWnd*       pPropSheet = NULL;

    ASSERT( NULL != m_ipResultData );
    ASSERT( NULL != m_ipCompData );  

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL == pDO ) {
            hr = S_OK;
        } else {

            // If this is the root node, don't need to do anything
            if( COOKIE_IS_ROOTNODE == pDO->GetCookieType() ) {
                hr = S_FALSE;
            } else if ( CCT_RESULT != pDO->GetContext() ) {
                // Just make sure we are where we think we are
                hr = S_FALSE;
            }

            if ( S_OK == hr ) {
                mmcCookie = (MMC_COOKIE)pDO->GetCookie();
                bIsQuery = m_ipCompData->IsLogQuery (mmcCookie);

                if (!bIsQuery) {
                    // Pass the notification to the scope pane to expand.
                    hr = S_FALSE;
                } else {
                    pQuery = (PSLQUERY)mmcCookie;
 
                    if ( NULL != pQuery ) {
                        // If the property sheet for this query is already active, just bring it to the foreground.                
                        pPropSheet = pQuery->GetActivePropertySheet();

                        if ( NULL != pPropSheet ) {

                            pPropSheet->SetForegroundWindow();
                            MMCFreeNotifyHandle(handle);
                            hr = S_OK;
            
                        } else {
                            hr = _InvokePropertySheet(ulRecNo, pDataObject);
                        }
                    } else {
                        ASSERT ( FALSE );
                        hr = E_UNEXPECTED;
                    }
                }
            }
        }
    }

    return hr;

} // end OnDoubleClick()


HRESULT
CComponent::StartLogQuery (
    LPDATAOBJECT pDataObject ) // [in] Points to the data object
{
    HRESULT                 hr = S_OK;
    CDataObject*            pDO = NULL;
    CSmLogQuery*            pQuery = NULL;
    CString                 strMessage;
    CString                 strSysMessage;
    CString                 strTitle;
    CString                 strMachineName;
    int                     iResult;
    DWORD                   dwStatus = ERROR_SUCCESS;
    ResourceStateManager    rsm;

    ASSERT( NULL != m_ipCompData );  

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    if ( SUCCEEDED ( hr ) ) {
        if ( m_ipCompData->IsLogQuery ( pDO->GetCookie() ) ) {
                
            pQuery = (CSmLogQuery*)pDO->GetCookie();

            if ( NULL != pQuery ) {

                if ( NULL != pQuery->GetActivePropertySheet() ) {

                    // Don't start queries with open property pages.
                    strMessage.LoadString ( IDS_ERRMSG_START_OPEN_QUERY );
                    hr = m_ipConsole->MessageBox(
                            (LPCWSTR)strMessage,
                            pQuery->GetLogName(),
                            MB_OK | MB_ICONWARNING,
                            &iResult );
            
                    ((CWnd*)pQuery->GetActivePropertySheet())->SetForegroundWindow();

                    hr = S_FALSE;

                } else {        

                    {
                        CWaitCursor WaitCursor;
                        dwStatus = pQuery->ManualStart();
                    }
            
                    // Ignore errors related to autostart setting.
                    if ( ERROR_SUCCESS == dwStatus  ) {
                        // Update all views generates view change notification.
                        m_ipConsole->UpdateAllViews (pDO, 0, CComponentData::eSmHintStartQuery );
                    } else {

                        strTitle.LoadString ( IDS_PROJNAME );

                        if ( ERROR_ACCESS_DENIED == dwStatus ) {

                            pQuery->GetMachineDisplayName ( strMachineName );

                            FormatSmLogCfgMessage (
                                strMessage,
                                m_hModule,
                                SMCFG_NO_MODIFY_ACCESS,
                                (LPCTSTR)strMachineName);

                        } else if ( SMCFG_START_TIMED_OUT == dwStatus ) {
                            FormatSmLogCfgMessage (
                                strMessage,
                                m_hModule,
                                SMCFG_START_TIMED_OUT,
                                (LPCTSTR)pQuery->GetLogName());

                        } else {
                    
                            FormatSmLogCfgMessage (
                                strMessage,
                                m_hModule,
                                SMCFG_SYSTEM_MESSAGE,
                                (LPCTSTR)pQuery->GetLogName());

                            FormatMessage ( 
                                FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL, 
                                dwStatus,
                                0,
                                strSysMessage.GetBufferSetLength( MAX_PATH ),
                                MAX_PATH,
                                NULL );
    
                            strSysMessage.ReleaseBuffer();

                            if ( strSysMessage.IsEmpty() ) {
                                strSysMessage.Format ( _T("0x%08lX"), dwStatus );   
                            }

                            strMessage += strSysMessage;
                        }

                        hr = m_ipConsole->MessageBox(
                            strMessage,
                            strTitle,
                            MB_OK | MB_ICONERROR,
                            &iResult );

                        hr = E_FAIL;
                    }
                }
            } else {
                ASSERT ( FALSE );
                hr = E_UNEXPECTED;
            }
        }
    }
    return hr;
} // end StartLogQuery()

HRESULT
CComponent::StopLogQuery (
    LPDATAOBJECT pDataObject,  // [in] Points to the data object
    BOOL bWarnOnRestartCancel )  
{
        HRESULT         hr = S_OK;
        CDataObject*    pDO = NULL;
        CSmLogQuery*    pQuery = NULL;
        DWORD           dwStatus = ERROR_SUCCESS;
        INT             iResult = IDOK;
        CString         strMessage;
        CString         strSysMessage;
        CString         strTitle;
        CString         strMachineName;
        ResourceStateManager    rsm;
 
    ASSERT( NULL != m_ipCompData );  

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    if ( SUCCEEDED ( hr ) ) {
        if ( m_ipCompData->IsLogQuery ( pDO->GetCookie() ) ) {
            pQuery = (CSmLogQuery*)pDO->GetCookie();

            if ( NULL != pQuery ) {
                if ( NULL != pQuery->GetActivePropertySheet() ) {

                    // Don't stop queries with open property pages.
                    strMessage.LoadString ( IDS_ERRMSG_STOP_OPEN_QUERY );
                    hr = m_ipConsole->MessageBox(
                            (LPCWSTR)strMessage,
                            pQuery->GetLogName(),
                            MB_OK | MB_ICONWARNING,
                            &iResult );
            
                    ((CWnd*)pQuery->GetActivePropertySheet())->SetForegroundWindow();

                    hr = S_FALSE;

                } else {

                    if ( pQuery->IsAutoRestart() && bWarnOnRestartCancel ) {
                        CString strMessage;

                        strMessage.LoadString( IDS_CANCEL_AUTO_RESTART );

                        hr = m_ipConsole->MessageBox(
                            strMessage,
                            pQuery->GetLogName(),
                            MB_OKCANCEL | MB_ICONINFORMATION,
                            &iResult );
                    }

                    if ( IDOK == iResult ) {
                        {
                            CWaitCursor WaitCursor;
                            dwStatus = pQuery->ManualStop ();
                        }
    
                        // Ignore errors related to autostart setting.
                        if ( ERROR_SUCCESS == dwStatus  ) {
                            // Update all views generates view change notification.
                            m_ipConsole->UpdateAllViews (pDO, 0, CComponentData::eSmHintStopQuery );
                        } else {
                            strTitle.LoadString ( IDS_PROJNAME );

                            if ( ERROR_ACCESS_DENIED == dwStatus ) {

                                pQuery->GetMachineDisplayName ( strMachineName );

                                FormatSmLogCfgMessage (
                                    strMessage,
                                    m_hModule,
                                    SMCFG_NO_MODIFY_ACCESS,
                                    (LPCTSTR)strMachineName);

                            } else if ( SMCFG_STOP_TIMED_OUT == dwStatus ) {
                                FormatSmLogCfgMessage (
                                    strMessage,
                                    m_hModule,
                                    SMCFG_STOP_TIMED_OUT,
                                    (LPCTSTR)pQuery->GetLogName());

                            } else {
                    
                                FormatSmLogCfgMessage (
                                    strMessage,
                                    m_hModule,
                                    SMCFG_SYSTEM_MESSAGE,
                                    (LPCTSTR)pQuery->GetLogName());

                                FormatMessage ( 
                                    FORMAT_MESSAGE_FROM_SYSTEM,
                                    NULL, 
                                    dwStatus,
                                    0,
                                    strSysMessage.GetBufferSetLength( MAX_PATH ),
                                    MAX_PATH,
                                    NULL );

                                strSysMessage.ReleaseBuffer();

                                if ( strSysMessage.IsEmpty() ) {
                                    strSysMessage.Format ( _T("0x%08lX"), dwStatus );   
                                }

                                strMessage += strSysMessage;
                            } 

                            hr = m_ipConsole->MessageBox(
                                strMessage,
                                strTitle,
                                MB_OK | MB_ICONERROR,
                                &iResult );

                            hr = E_FAIL;
                        }
                    }
                }
            } else {
                ASSERT ( FALSE );
                hr = E_UNEXPECTED;
            }
        }
    }
    return hr;
} // end StopLogQuery()

HRESULT
CComponent::SaveLogQueryAs (
    LPDATAOBJECT pDataObject )  // [in] Points to the data object
{
    HRESULT hr = S_OK;
    DWORD   dwStatus = ERROR_SUCCESS;
    CDataObject* pDO = NULL;
    CSmLogQuery* pQuery = NULL;
    CString strFileExtension;
    CString strFileFilter;
    TCHAR   szDefaultFileName[MAX_PATH];

    INT_PTR iPtrResult = IDCANCEL;
    HWND    hwndMain;
    TCHAR   szInitialDir[MAX_PATH];
    ResourceStateManager    rsm;

    ASSERT( NULL != m_ipCompData );  

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    if ( SUCCEEDED ( hr ) ) {
        if ( m_ipCompData->IsLogQuery ( pDO->GetCookie() ) ) {

            pQuery = (CSmLogQuery*)pDO->GetCookie();

            if ( NULL != pQuery ) {

                MFC_TRY
                    strFileExtension.LoadString ( IDS_HTML_EXTENSION );
                    strFileFilter.LoadString ( IDS_HTML_FILE );
                MFC_CATCH_HR

                strFileFilter.Replace ( _T('|'), _T('\0') );

                lstrcpyW ( ( LPWSTR)szDefaultFileName, pQuery->GetLogName() );

                ReplaceBlanksWithUnderscores( szDefaultFileName );

                hr = m_ipConsole->GetMainWindow( &hwndMain );

                if ( SUCCEEDED(hr) ) {
                    
                    OPENFILENAME ofn;
                    BOOL bResult;
                    
                    ZeroMemory( &ofn, sizeof( OPENFILENAME ) );

                    ofn.lStructSize = sizeof(OPENFILENAME);
                    ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
                    ofn.lpstrDefExt = (LPCTSTR)strFileExtension;
                    ofn.lpstrFile = szDefaultFileName;
                    ofn.lpstrFilter = strFileFilter;
                    ofn.nMaxFile = MAX_PATH;
                    ofn.hwndOwner = hwndMain;
                    ofn.hInstance = m_hModule;

                    if ( SUCCEEDED ( SHGetFolderPathW ( NULL, CSIDL_PERSONAL, NULL, 0, szInitialDir ) ) ) {
                        ofn.lpstrInitialDir = szInitialDir;
                    }

                    bResult = GetSaveFileName( &ofn );

                    if ( bResult ) {

                        dwStatus = pQuery->SaveAs( ofn.lpstrFile );

                        if ( ERROR_SUCCESS != dwStatus ) {
                            hr = E_FAIL;
                        }
                    }
                }
            } else {
                ASSERT ( FALSE );
                hr = E_UNEXPECTED;
            }
        }
    }
    return hr;
} // end SaveLogQueryAs()

//+--------------------------------------------------------------------------
//
//  Member:     CComponent::_InvokePropertySheet
//
//  Synopsis:   Open or bring to foreground an event record details
//              property sheet focused on record [ulRecNo].
//
//  Arguments:  [ulRecNo]     - number of rec to display in prop sheet
//              [pDataObject] - data object containing rec [ulRecNo]
//
//  Returns:    HRESULT
//
//  History:    5-28-1999   a-akamal
//
//---------------------------------------------------------------------------

HRESULT
CComponent::_InvokePropertySheet(
    ULONG ulRecNo,
    LPDATAOBJECT pDataObject)
{
    //TRACE_METHOD(CComponent, _InvokePropertySheet);
    HRESULT     hr = S_OK;
    MMC_COOKIE  Cookie;
    PSLQUERY    pQuery = NULL;
    WCHAR       wszDetailsCaption[MAX_PATH];
    CDataObject* pDO = NULL;

    ASSERT( NULL != m_ipCompData );  
       
    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    if ( SUCCEEDED ( hr ) ) {
        
        Cookie = (MMC_COOKIE)pDO->GetCookie();;
        pQuery = (PSLQUERY)Cookie;
    
        if ( NULL != pQuery ) {
            wsprintf(wszDetailsCaption,pQuery->GetLogName());

            hr = InvokePropertySheet (
                    m_ipCompData->GetPropSheetProvider(),
                    wszDetailsCaption,
                    (LONG) ulRecNo,
                    pDataObject,
                    (IExtendPropertySheet*) this,
                    0 );
        } else {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   InvokePropertySheet
//
//  Synopsis:   Bring to top an existing or create a new property sheet
//              using the parameters provided.
//
//  Arguments:  [pPrshtProvider] - used to search for or create sheet
//              [wszTitle]       - sheet caption
//              [lCookie]        - a loginfo* or an event record number
//              [pDataObject]    - DO on object sheet's being opened on
//                                  (cookie in DO should == cookie)
//              [pPrimary]       - IExtendPropertySheet interface on
//                                  calling CSnapin or CComponentData
//              [usStartingPage] - which page number should be active when
//                                  sheet opens
//
//  Returns:    HRESULT
//
//  History:    5-28-1999   a-akamal
//
//  Notes:      Call this routine when you want a property sheet to appear
//              as if the user had just selected "Properties" on it.
//
//---------------------------------------------------------------------------

HRESULT
CComponent::
InvokePropertySheet(
    IPropertySheetProvider *pPrshtProvider,
    LPCWSTR wszTitle,
    LONG lCookie,
    LPDATAOBJECT pDataObject,
    IExtendPropertySheet *pPrimary,
    USHORT usStartingPage)
{
    HRESULT hr = S_OK;

    //
    // Because we pass NULL for the second arg, the first is not allowed
    // to be null.
    //
    if ( 0 == lCookie ) {
        ASSERT ( FALSE );
        hr = E_INVALIDARG;
    } else {

        do {
            hr = pPrshtProvider->FindPropertySheet(lCookie, NULL, pDataObject);
        
            if ( S_OK == hr ) {
                break;
            }
        
            hr = pPrshtProvider->CreatePropertySheet(wszTitle,
                                                      TRUE,
                                                      lCookie,
                                                      pDataObject,
                                                      0);
            if ( S_OK != hr ) {
                break;
            }
        
            hr = pPrshtProvider->AddPrimaryPages(pPrimary, TRUE, NULL, FALSE);

            if ( S_OK != hr ) {
                break;
            }
        
            hr = pPrshtProvider->Show(NULL, usStartingPage);
        
        } while (0);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\alrtgenp.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    alrtgenp.cpp

Abstract:

    Implementation of the alerts general property page.

--*/

#include "stdafx.h"
#include <assert.h>
#include <math.h>
#include <limits.h>
#include <float.h>
#include <pdh.h>
#include <pdhmsg.h>
#include <common.h>
#include "smcfgmsg.h"
#include "dialogs.h"
#include "smlogs.h"
#include "smalrtq.h"
#include "AlrtGenP.h"
#include <pdhp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("SMLOGCFG(alrtgenp.cpp)");

static const COMBO_BOX_DATA_MAP OverUnderCombo[] = 
{
    {OU_OVER,       IDS_OVER},
    {OU_UNDER,      IDS_UNDER}
};
static const DWORD dwOverUnderComboEntries = sizeof(OverUnderCombo)/sizeof(OverUnderCombo[0]);

static ULONG
s_aulHelpIds[] =
{
    IDC_ALRTS_COUNTER_LIST,         IDH_ALRTS_COUNTER_LIST,
    IDC_ALRTS_ADD_BTN,              IDH_ALRTS_ADD_BTN,
    IDC_ALRTS_REMOVE_BTN,           IDH_ALRTS_REMOVE_BTN,
    IDC_ALRTS_OVER_UNDER,           IDH_ALRTS_OVER_UNDER,
    IDC_ALRTS_VALUE_EDIT,           IDH_ALRTS_VALUE_EDIT,
    IDC_ALRTS_COMMENT_EDIT,         IDH_ALRTS_COMMENT_EDIT,
    IDC_ALRTS_SAMPLE_EDIT,          IDH_ALRTS_SAMPLE_EDIT,
    IDC_ALRTS_SAMPLE_SPIN,          IDH_ALRTS_SAMPLE_EDIT,
    IDC_ALRTS_SAMPLE_UNITS_COMBO,   IDH_ALRTS_SAMPLE_UNITS_COMBO,
    IDC_RUNAS_EDIT,                 IDH_RUNAS_EDIT,
    0,0
};


ULONG 
CAlertGenProp::HashCounter(
    LPTSTR szCounterName,
    ULONG  lHashSize)
{
    ULONG       h = 0;
    ULONG       a = 31415;  //a, b, k are primes
    const ULONG k = 16381;
    const ULONG b = 27183;
    LPTSTR szThisChar;
    TCHAR Char;

    if (szCounterName) {
        for (szThisChar = szCounterName; * szThisChar; szThisChar ++) {
            Char = * szThisChar;
            if (_istupper(Char) ) {
                Char = _tolower(Char);
            }

            h = (a * h + ((ULONG) Char)) % k;
            a = a * b % (k - 1);
        }
    }
    return (h % lHashSize);
}

BOOL
CAlertGenProp::InsertAlertToHashTable(
    PALERT_INFO_BLOCK paibInfo )
{
    ULONG       lHashValue;
    PHASH_ENTRY pEntry;
    PHASH_ENTRY pNewEntry  = NULL;
    BOOLEAN     bInsert    = TRUE;
    PPDH_COUNTER_PATH_ELEMENTS pCounter = NULL;

    PDH_STATUS pdhStatus;

    // Todo:  validate pointers
    lHashValue = HashCounter(paibInfo->szCounterPath, eHashTableSize);

    pEntry = m_HashTable[lHashValue];

    pdhStatus = AllocInitCounterPath ( paibInfo->szCounterPath, &pCounter );

    if (pdhStatus == ERROR_SUCCESS) {
        while (pEntry) {
            if ( ( AIBF_OVER & pEntry->dwFlags ) == ( AIBF_OVER & paibInfo->dwFlags )
                && pEntry->dLimit == paibInfo->dLimit  
                && ERROR_SUCCESS != CheckDuplicateCounterPaths(pCounter, pEntry->pCounter ) ) 
            {
                bInsert = FALSE;
                break;
            }
            pEntry = pEntry->pNext;
            
        }
        if (bInsert) {
            // Insert at head of bucket list
            pNewEntry = (PHASH_ENTRY) G_ALLOC(sizeof(HASH_ENTRY));
            if (pNewEntry) {
                pNewEntry->pCounter = pCounter;
                pNewEntry->dwFlags = paibInfo->dwFlags;
                pNewEntry->dLimit = paibInfo->dLimit;
                pNewEntry->pNext    = m_HashTable[lHashValue];
                m_HashTable[lHashValue]  = pNewEntry;
            } else {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                bInsert = FALSE;
            }
        }        
    } else {
        if ( NULL != pCounter ) {
            delete pCounter;
        }
        bInsert = FALSE;
    }

    if ( !bInsert ) {
        // Set status on error        // Todo:  Only set status if pdhStatus != 0.
        // Will need to pass pdhStatus as a parameter in order to do this.
        SetLastError(pdhStatus);
    }
    return (bInsert);
}


void 
CAlertGenProp::InitAlertHashTable( void )
{
    memset(&m_HashTable, 0, sizeof(m_HashTable));
}

void 
CAlertGenProp::ClearAlertHashTable( void )
{
    ULONG       i;
    PHASH_ENTRY pEntry;
    PHASH_ENTRY pNext;

    for (i = 0; i < eHashTableSize; i ++) {
        pNext = m_HashTable[i];
        while (pNext != NULL) {
            pEntry = pNext;
            pNext  = pEntry->pNext;

            G_FREE(pEntry->pCounter);
            G_FREE(pEntry);
        }
    }
}

//
//  browse counters callback function
//
static 
PDH_FUNCTION 
DialogCallBack(CAlertGenProp *pDlg)
{
    // add strings in buffer to list box
    LPTSTR          NewCounterName;
    INT             iListIndex;
    LONG            lFirstNewIndex = LB_ERR;
    DWORD           dwItemExtent;
    CListBox        *pCounterList;
    PALERT_INFO_BLOCK   paibInfo = NULL;
    DWORD           dwIbSize;
    DWORD           dwReturnStatus = ERROR_SUCCESS;
    CDC*            pCDC = NULL;
    ResourceStateManager    rsm;

#define CTRBUFLIMIT (0x7fffffff)
    if ( PDH_MORE_DATA == pDlg->m_dlgConfig.CallBackStatus ) {
        if ( pDlg->m_dlgConfig.cchReturnPathLength < CTRBUFLIMIT ) {

            pDlg->m_dwCounterListBufferSize *= 2;
            delete pDlg->m_szCounterListBuffer;
            pDlg->m_szCounterListBuffer = NULL;

            try {
                pDlg->m_szCounterListBuffer = new WCHAR[pDlg->m_dwCounterListBufferSize];
        
            } catch ( ... ) {
                pDlg->m_dwCounterListBufferSize = 0;
                pDlg->m_dlgConfig.CallBackStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                dwReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }

            if ( ERROR_SUCCESS == dwReturnStatus ) {
                // clear buffer
                memset (pDlg->m_szCounterListBuffer, 0, pDlg->m_dwCounterListBufferSize);

                pDlg->m_dlgConfig.szReturnPathBuffer = pDlg->m_szCounterListBuffer;
                pDlg->m_dlgConfig.cchReturnPathLength = pDlg->m_dwCounterListBufferSize;
                pDlg->m_dlgConfig.CallBackStatus = PDH_RETRY;
                dwReturnStatus = PDH_RETRY;
            }
        } else {
            pDlg->m_dlgConfig.CallBackStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            dwReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }

    } else if ( ERROR_SUCCESS == pDlg->m_dlgConfig.CallBackStatus ) {

        pCounterList = (CListBox *)pDlg->GetDlgItem(IDC_ALRTS_COUNTER_LIST);
        pCDC = pCounterList->GetDC();
    
        for (NewCounterName = pDlg->m_szCounterListBuffer;
            *NewCounterName != 0;
            NewCounterName += (lstrlen(NewCounterName) + 1)) {

            // Allocate a buffer to hold the alert info and
            // add to list box
            dwIbSize = sizeof(ALERT_INFO_BLOCK) + 
                ((lstrlen(NewCounterName) + 1) * sizeof(WCHAR));

            MFC_TRY
                paibInfo = (PALERT_INFO_BLOCK) new UCHAR[dwIbSize];
            MFC_CATCH_MINIMUM;

            if (paibInfo != NULL) {
                // load the fields
                paibInfo->dwSize = dwIbSize;
                paibInfo->szCounterPath = (LPTSTR)&paibInfo[1];
                paibInfo->dwFlags = AIBF_OVER;       // clear all the flags, setting default to "Over"
                paibInfo->dLimit = CAlertGenProp::eInvalidLimit;
                lstrcpyW (paibInfo->szCounterPath, NewCounterName);

                // Insert the new string at the end of the list box.
                iListIndex = pCounterList->InsertString (-1, NewCounterName );    
                if (iListIndex != LB_ERR) {
                    pCounterList->SetItemDataPtr (iListIndex, (LPVOID)paibInfo);
                    if ( LB_ERR == lFirstNewIndex ) 
                        lFirstNewIndex = iListIndex;
                    // update list box extent
                    if ( NULL != pCDC ) {
                        dwItemExtent = (DWORD)(pCDC->GetTextExtent(NewCounterName)).cx;
                        if (dwItemExtent > pDlg->m_dwMaxHorizListExtent) {
                            pDlg->m_dwMaxHorizListExtent = dwItemExtent;
                            pCounterList->SetHorizontalExtent(dwItemExtent);
                        }
                    }
                } else {
                    dwReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    delete paibInfo;
                }
            } else {
                dwReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }        
        if ( NULL != pCDC ) {
            pDlg->m_CounterList.ReleaseDC(pCDC);
            pCDC = NULL;
        }
    
        // select the first new entry in the list box.
        if (lFirstNewIndex != LB_ERR) {
            pCounterList->SetCurSel (lFirstNewIndex);
            pDlg->PublicOnSelchangeCounterList();
            pDlg->SetModifiedPage();  // to indicate a change
        }

        // clear buffer
        memset (pDlg->m_szCounterListBuffer, 0, pDlg->m_dwCounterListBufferSize);
        dwReturnStatus = ERROR_SUCCESS;
    } else {
        // Not successful
        dwReturnStatus = pDlg->m_dlgConfig.CallBackStatus; 
    }
    return dwReturnStatus;
}

/////////////////////////////////////////////////////////////////////////////
// CAlertGenProp property page

IMPLEMENT_DYNCREATE(CAlertGenProp, CSmPropertyPage)

CAlertGenProp::CAlertGenProp(MMC_COOKIE mmcCookie, LONG_PTR hConsole) 
:   CSmPropertyPage ( CAlertGenProp::IDD, hConsole )
{
    // save variables from arg list
    m_pAlertQuery = reinterpret_cast <CSmAlertQuery *>(mmcCookie);
    ASSERT ( m_pAlertQuery->CastToAlertQuery() );

    // init AFX variables
    InitAfxDataItems();

    // init other member variables
    ZeroMemory ( &m_dlgConfig, sizeof(m_dlgConfig) );
    m_szCounterListBuffer = NULL;
    m_dwCounterListBufferSize = 0L;
    m_ndxCurrentItem = LB_ERR;  // nothing selected
    m_szAlertCounterList = NULL;
    m_cchAlertCounterListSize = 0;
    m_dwMaxHorizListExtent = 0;
}

CAlertGenProp::CAlertGenProp() : CSmPropertyPage(CAlertGenProp::IDD)
{
    ASSERT (FALSE); // the constructor w/ args should be used instead
    // init variables that should be from arg list
    m_pAlertQuery = NULL;

    // init AFX variables
    InitAfxDataItems();

    // init other member variables
    m_szCounterListBuffer = NULL;
    m_dwCounterListBufferSize = 0L;
    m_ndxCurrentItem = LB_ERR;  // nothing selected
    m_szAlertCounterList = NULL;
    m_cchAlertCounterListSize = 0;
    m_dwMaxHorizListExtent = 0;
}

CAlertGenProp::~CAlertGenProp()
{
    if (m_szAlertCounterList != NULL) delete (m_szAlertCounterList);
    if (m_szCounterListBuffer != NULL) delete (m_szCounterListBuffer);
}

void CAlertGenProp::InitAfxDataItems()
{
    //{{AFX_DATA_INIT(CAlertGenProp)
    m_dLimitValue = eInvalidLimit;
    m_nSampleUnits = 0;
    //}}AFX_DATA_INIT
}

void CAlertGenProp::DoDataExchange(CDataExchange* pDX)
{
    HWND    hWndCtrl = NULL;
    CString strTemp;
    TCHAR   szT[MAXSTR];
    LPTSTR  szStop;
    DOUBLE  dTemp;
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAlertGenProp)
    DDX_Control(pDX, IDC_ALRTS_SAMPLE_UNITS_COMBO, m_SampleUnitsCombo);
    DDX_Control(pDX, IDC_ALRTS_OVER_UNDER, m_OverUnderCombo);
    DDX_Control(pDX, IDC_ALRTS_COUNTER_LIST, m_CounterList);
    ValidateTextEdit(pDX, IDC_ALRTS_SAMPLE_EDIT, 6, &m_SharedData.stiSampleTime.dwValue, eMinSampleInterval, eMaxSampleInterval);
    DDX_CBIndex(pDX, IDC_ALRTS_SAMPLE_UNITS_COMBO, m_nSampleUnits);
    DDX_Text(pDX, IDC_ALRTS_COMMENT_EDIT, m_strComment);
    DDV_MaxChars(pDX, m_strComment, 255);
    DDX_Text(pDX, IDC_ALRTS_START_STRING, m_strStartDisplay);
    DDX_Text(pDX, IDC_RUNAS_EDIT, m_strUserDisplay );
    //}}AFX_DATA_MAP

    //
    // User defined DDX
    //
    if ( pDX->m_bSaveAndValidate ) {
        m_SharedData.stiSampleTime.dwUnitType = 
            (DWORD)((CComboBox *)GetDlgItem(IDC_ALRTS_SAMPLE_UNITS_COMBO))->
                    GetItemData(m_nSampleUnits);    
    }
    // Alert limit value
    {
        hWndCtrl = pDX->PrepareEditCtrl(IDC_ALRTS_VALUE_EDIT);

        if (pDX->m_bSaveAndValidate) {
            ::GetWindowText(hWndCtrl, szT, MAXSTR);

            strTemp = szT;
            DDV_MaxChars(pDX, strTemp, 23);

            if (szT[0] == _T('.') || (szT[0] >= _T('0') && szT[0] <= _T('9'))) {
                dTemp = _tcstod(szT, & szStop);
                if ( HUGE_VAL != dTemp ) {
                    m_dLimitValue = dTemp;
                } else {
                    _stprintf(szT, _T("%.*g"), DBL_DIG, m_dLimitValue);
                    strTemp.Format (IDS_ALERT_CHECK_LIMIT_VALUE, DBL_MAX );
                    MessageBox (strTemp, m_pAlertQuery->GetLogName(), MB_OK | MB_ICONERROR);
                    GetDlgItem(IDC_ALRTS_VALUE_EDIT)->SetWindowText(szT);
                    GetDlgItem(IDC_ALRTS_VALUE_EDIT)->SetFocus();
                }
            } else {
                m_dLimitValue = eInvalidLimit;
            }
        } else {
            if ( eInvalidLimit != m_dLimitValue ) {
                _stprintf(szT, _T("%.*g"), DBL_DIG, m_dLimitValue);
            } else {
                // Display NULL string for invalid limit value.
                szT[0] = _T('\0');
            }
            GetDlgItem(IDC_ALRTS_VALUE_EDIT)->SetWindowText(szT);
        }
    }
}

void CAlertGenProp::ImplementAdd() 
{
    LONG    lBeforeCount;
    LONG    lAfterCount;
    CString strText;
    CString strBrowseTitle;
    CString strDefaultPath;
    CString strObjCounter;

    ResourceStateManager    rsm;

    if (m_szCounterListBuffer == NULL) {

        MFC_TRY
            strObjCounter.LoadString ( IDS_DEFAULT_PATH_OBJ_CTR );
            m_dwCounterListBufferSize = 0x4000;
            m_szCounterListBuffer = new WCHAR[m_dwCounterListBufferSize];
            if ( ((CSmLogService*)m_pAlertQuery->GetLogService())->IsLocalMachine() ) {
                strDefaultPath = _T("\\");
            } else {
                strDefaultPath = _T("\\\\");
                strDefaultPath += ((CSmLogService*)m_pAlertQuery->GetLogService())->GetMachineName();
            }
            strDefaultPath += strObjCounter;
            lstrcpy ( m_szCounterListBuffer, strDefaultPath);
        MFC_CATCH_MINIMUM;

        if ( NULL != m_szCounterListBuffer && !strDefaultPath.IsEmpty() ) {
            lstrcpy ( m_szCounterListBuffer, strDefaultPath);
        } else {
            m_dwCounterListBufferSize = 0;
            return;
        }
    }

    m_dlgConfig.bIncludeInstanceIndex = 1;
    m_dlgConfig.bLocalCountersOnly = 0;

    m_dlgConfig.bSingleCounterPerAdd = 0;
    m_dlgConfig.bSingleCounterPerDialog = 0;

    // disallow wild cards. 
    m_dlgConfig.bWildCardInstances = 0; 

    m_dlgConfig.bHideDetailBox = 1;
    m_dlgConfig.bInitializePath = 1;
    m_dlgConfig.bDisableMachineSelection = 0;
    m_dlgConfig.bIncludeCostlyObjects = 0;
    m_dlgConfig.bReserved = 0;

    m_dlgConfig.hWndOwner = this->m_hWnd;
    m_dlgConfig.szDataSource = NULL;

    m_dlgConfig.szReturnPathBuffer = m_szCounterListBuffer;
    m_dlgConfig.cchReturnPathLength = m_dwCounterListBufferSize;
    m_dlgConfig.pCallBack = (CounterPathCallBack)DialogCallBack;
    m_dlgConfig.dwDefaultDetailLevel = PERF_DETAIL_WIZARD;
    m_dlgConfig.dwCallBackArg = (UINT_PTR)this;

    strBrowseTitle.LoadString ( IDS_ADD_COUNTERS );
    m_dlgConfig.szDialogBoxCaption = strBrowseTitle.GetBuffer( strBrowseTitle.GetLength() );

    // get count of items in the list box before calling the browser
    lBeforeCount = m_CounterList.GetCount();

    PdhBrowseCountersW (&m_dlgConfig);

    strBrowseTitle.ReleaseBuffer();

    // get count of items in the list box After calling the browser
    // to see if the Apply button should enabled
    lAfterCount = m_CounterList.GetCount();

    if (lAfterCount > lBeforeCount) 
        SetModifiedPage(TRUE);

    // see if the remove button should be enabled
    GetDlgItem (IDC_ALRTS_REMOVE_BTN)->EnableWindow(
        lAfterCount > 0 ? TRUE : FALSE);

    delete m_szCounterListBuffer;
    m_szCounterListBuffer = NULL;
    m_dwCounterListBufferSize = 0;
    GetDlgItem(IDC_ALRTS_VALUE_EDIT)->SetFocus();
    
    SetButtonState ();
}


BEGIN_MESSAGE_MAP(CAlertGenProp, CSmPropertyPage)
    //{{AFX_MSG_MAP(CAlertGenProp)
    ON_BN_CLICKED(IDC_ALRTS_ADD_BTN, OnAddBtn)
    ON_LBN_DBLCLK(IDC_ALRTS_COUNTER_LIST, OnDblclkAlrtsCounterList)
    ON_BN_CLICKED(IDC_ALRTS_REMOVE_BTN, OnRemoveBtn)
    ON_LBN_SELCHANGE(IDC_ALRTS_COUNTER_LIST, OnSelchangeCounterList)
    ON_EN_CHANGE(IDC_ALRTS_COMMENT_EDIT, OnCommentEditChange)
    ON_EN_KILLFOCUS(IDC_ALRTS_COMMENT_EDIT, OnCommentEditKillFocus)
    ON_NOTIFY(UDN_DELTAPOS, IDC_ALRTS_SAMPLE_SPIN, OnDeltaposSampleSpin)
    ON_CBN_SELENDOK(IDC_ALRTS_SAMPLE_UNITS_COMBO, OnSelendokSampleUnitsCombo)
    ON_EN_CHANGE( IDC_RUNAS_EDIT, OnChangeUser )
    ON_EN_CHANGE(IDC_ALRTS_SAMPLE_EDIT, OnSampleTimeChanged)
    ON_EN_KILLFOCUS(IDC_ALRTS_SAMPLE_EDIT, OnSampleTimeChanged)
    ON_CBN_SELENDOK(IDC_ALRTS_OVER_UNDER, OnKillFocusUpdateAlertData)
    ON_CBN_KILLFOCUS (IDC_ALRTS_OVER_UNDER, OnKillFocusUpdateAlertData)
    ON_EN_CHANGE(IDC_ALRTS_VALUE_EDIT, OnChangeAlertValueEdit)
    ON_EN_KILLFOCUS (IDC_ALRTS_VALUE_EDIT, OnKillFocusUpdateAlertData)
    ON_BN_CLICKED(IDC_SETPWD_BTN, OnPwdBtn)
    ON_WM_CLOSE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAlertGenProp message handlers

void 
CAlertGenProp::OnChangeUser()
{
    //
    // If you can not access remote WBEM, you can not modify RunAs info,
    // changing the user name is not allowed.
    //
    if (m_bCanAccessRemoteWbem) {
        // When the user hits OK in the password dialog,
        // the user name might not have changed.
        UpdateData ( TRUE );

        m_strUserDisplay.TrimLeft();
        m_strUserDisplay.TrimRight();

        if ( 0 != m_strUserSaved.Compare ( m_strUserDisplay ) ) {
            m_pAlertQuery->m_fDirtyPassword = PASSWORD_DIRTY;
            SetModifiedPage(TRUE);
        }
        else {
            m_pAlertQuery->m_fDirtyPassword &= ~PASSWORD_DIRTY;
        }
        //
        // If default user is typed, never need to set password
        //
        if (m_strUserDisplay.IsEmpty() || m_strUserDisplay.GetAt(0) == L'<') {
            if (m_bPwdButtonEnabled) {
                GetDlgItem(IDC_SETPWD_BTN)->EnableWindow(FALSE);
                m_bPwdButtonEnabled = FALSE;
            }
        }
        else {
            if (!m_bPwdButtonEnabled) {
                GetDlgItem(IDC_SETPWD_BTN)->EnableWindow(TRUE);
                m_bPwdButtonEnabled = TRUE;
            }
        }
    }
    else {
        //
        // We can not modify the RunAs info, then display
        // an error message and retore the original user name in RunAs
        //
        UpdateData(TRUE);
        if (ConnectRemoteWbemFail(m_pAlertQuery, FALSE)) {
            GetDlgItem(IDC_RUNAS_EDIT)->SetWindowText(m_strUserSaved);
        }
    }
}

void CAlertGenProp::OnPwdBtn()
{
    CString strTempUser;

    UpdateData();

    if (!m_bCanAccessRemoteWbem) {
        ConnectRemoteWbemFail(m_pAlertQuery, TRUE);
        return;
    }

    MFC_TRY
        strTempUser = m_strUserDisplay;

        m_strUserDisplay.TrimLeft();
        m_strUserDisplay.TrimRight();

        m_pAlertQuery->m_strUser = m_strUserDisplay;

        SetRunAs(m_pAlertQuery);

        m_strUserDisplay = m_pAlertQuery->m_strUser;

        if ( 0 != strTempUser.CompareNoCase ( m_strUserDisplay ) ) {
            SetDlgItemText ( IDC_RUNAS_EDIT, m_strUserDisplay );
        }
    MFC_CATCH_MINIMUM;
}

void CAlertGenProp::OnAddBtn() 
{
    ImplementAdd();

    return;
}

void CAlertGenProp::OnDblclkAlrtsCounterList() 
{
    ImplementAdd();

    return;
}
void CAlertGenProp::OnRemoveBtn() 
{
    PALERT_INFO_BLOCK   paibInfo;
    INT                 nCurSel;
    INT                 nLbItemCount;
    BOOL                bChanged = FALSE;
    DWORD               dwItemExtent;
    INT                 iIndex;
    TCHAR               szPath[MAX_PATH+1];

    nLbItemCount = m_CounterList.GetCount();
    nCurSel = m_CounterList.GetCurSel();
    if (nCurSel != LB_ERR) {
        paibInfo = (PALERT_INFO_BLOCK)m_CounterList.GetItemDataPtr(nCurSel);
        if ( paibInfo != NULL ) 
            delete(paibInfo);
        if ( LB_ERR != m_CounterList.DeleteString(nCurSel) ) {
            
            // clear the max extent
            m_dwMaxHorizListExtent = 0;

            for ( iIndex = 0; iIndex < m_CounterList.GetCount(); iIndex++ ) {
                if ( 0 < m_CounterList.GetText( iIndex, szPath ) ) {
                    dwItemExtent = (DWORD)((m_CounterList.GetDC())->GetTextExtent (szPath)).cx;
                    if (dwItemExtent > m_dwMaxHorizListExtent) {
                        m_dwMaxHorizListExtent = dwItemExtent;
                        m_CounterList.SetHorizontalExtent(dwItemExtent);
                    }
                }
            }

            if (nCurSel == (nLbItemCount - 1)) {
                // then the last item was deleted so select the new "last"
                if ( 0 == nCurSel ) {
                    nCurSel = LB_ERR;
                } else {
                    nCurSel--;
                }
            } //else the current selection should still be in the list box
            m_CounterList.SetCurSel (nCurSel);
            m_ndxCurrentItem = nCurSel;
            LoadAlertItemData (nCurSel);
            bChanged = TRUE;
        }
    }
    SetButtonState();
    SetModifiedPage(bChanged);
}

void CAlertGenProp::OnDeltaposSampleSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
    OnDeltaposSpin(pNMHDR, pResult, &m_SharedData.stiSampleTime.dwValue, eMinSampleInterval, eMaxSampleInterval);
}

void 
CAlertGenProp::OnSelendokSampleUnitsCombo() 
{
    int nSel;
    
    nSel = ((CComboBox *)GetDlgItem(IDC_ALRTS_SAMPLE_UNITS_COMBO))->GetCurSel();
    
    if ((nSel != LB_ERR) && (nSel != m_nSampleUnits)) {
        UpdateData ( TRUE );
        SetModifiedPage ( TRUE );
    }
}

void CAlertGenProp::OnSampleTimeChanged()
{
    DWORD   dwOldValue;
    dwOldValue = m_SharedData.stiSampleTime.dwValue;
    UpdateData ( TRUE );
    if (dwOldValue != m_SharedData.stiSampleTime.dwValue) {
        SetModifiedPage(TRUE);
    }
}

void CAlertGenProp::OnChangeAlertValueEdit() 
{
    SaveAlertItemData();
}

void CAlertGenProp::PublicOnSelchangeCounterList() 
{
    OnSelchangeCounterList();
}

void CAlertGenProp::OnKillFocusUpdateAlertData()
{
    SaveAlertItemData();
}

void CAlertGenProp::OnSelchangeCounterList() 
{
    INT                 nCurSel;

    nCurSel = m_CounterList.GetCurSel();
    if (nCurSel != LB_ERR) {
        // Save the data from the previous item.
        SaveAlertItemData();
        // Load the data from the new item.
        LoadAlertItemData(nCurSel);
    } else {
        // clear the fields
        m_dLimitValue=eInvalidLimit;
        UpdateData(FALSE);
    }
}

void 
CAlertGenProp::UpdateAlertStartString ()
{
    eStartType  eCurrentStartType;
    int         nResId = 0;
    ResourceStateManager    rsm;

    eCurrentStartType = DetermineCurrentStartType();

    if ( eStartManually == eCurrentStartType ) {
        nResId = IDS_ALERT_START_MANUALLY;
    } else if ( eStartImmediately == eCurrentStartType ) {
        nResId = IDS_ALERT_START_IMMED;
    } else if ( eStartSched == eCurrentStartType ) {
        nResId = IDS_ALERT_START_SCHED;
    }
    
    if ( 0 != nResId ) {
        m_strStartDisplay.LoadString(nResId);
    } else {
        m_strStartDisplay.Empty();
    }

    return;
}

BOOL CAlertGenProp::IsValidLocalData() 
{
    BOOL bIsValid = FALSE;
    INT nInvalidIndex = -1;
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    PALERT_INFO_BLOCK   paibInfo;
    int iListCount;
    int iIndex;
    BOOL bInsert;
    BOOL bAtLeastOneDuplicateCounter = FALSE;
    BOOL bSelectionDeleted = FALSE;
    CString strText;
   
    // test to see if there are any counters in the list box
    if (m_CounterList.GetCount() > 0) {
        if ( GetDlgItem(IDC_ALRTS_VALUE_EDIT) == GetFocus() ) {
            SaveAlertItemData();    // Set the Is Saved flag for this value.
        }
        bIsValid = LoadListFromDlg(&nInvalidIndex, TRUE);
        if (   ((!bIsValid) && (nInvalidIndex != -1))
            || ((m_dLimitValue < 0.0) || (m_dLimitValue > DBL_MAX)))
        {
            // then one of the list items has not been reviewed
            // by the user so remind them
            strText.Format (IDS_ALERT_CHECK_LIMITS, DBL_MAX );
            MessageBox (strText, m_pAlertQuery->GetLogName(), MB_OK | MB_ICONERROR);
            m_CounterList.SetCurSel(nInvalidIndex);
            OnSelchangeCounterList();
            m_CounterList.SetFocus();
            GetDlgItem(IDC_ALRTS_VALUE_EDIT)->SetFocus();
            bIsValid = FALSE;                   
        } else {
            
            // Eliminate duplicate alert paths, then reload the list

            iListCount = m_CounterList.GetCount();
            if ( LB_ERR != iListCount ) {
                InitAlertHashTable ( );
                // Walk the list backwards to delete duplicate items.
                for ( iIndex = iListCount - 1; iIndex >= 0; iIndex-- ) {
                    paibInfo = (PALERT_INFO_BLOCK)m_CounterList.GetItemDataPtr(iIndex);
                    if ( NULL != paibInfo ) {
                        bInsert   = InsertAlertToHashTable ( paibInfo );
                        pdhStatus = bInsert ? ERROR_SUCCESS : GetLastError();
                    } else {
                        bInsert = FALSE;
                    }
                    if (! bInsert &&  pdhStatus == ERROR_SUCCESS) {
                        bAtLeastOneDuplicateCounter = TRUE;
						// Set item data pointer to NULL because 
						// SaveAlertItemData can be called after this.
                        // Clear the selection if >= current index.
                        if ( m_ndxCurrentItem >= iIndex ) {
                            m_ndxCurrentItem = LB_ERR;
                            bSelectionDeleted = TRUE;
                        }
                        m_CounterList.SetItemDataPtr(iIndex, NULL);
                        m_CounterList.DeleteString(iIndex);
                        delete paibInfo;
                    }

                    if ( ERROR_SUCCESS != pdhStatus ) {
                        // Message box Pdh error message, go on to next 
                        CString strMsg;
                        CString strPdhMessage;

                        FormatSystemMessage ( pdhStatus, strPdhMessage );

                        MFC_TRY
                            strMsg.Format ( IDS_CTRS_PDH_ERROR, paibInfo->szCounterPath );
                            strMsg += strPdhMessage;
                        MFC_CATCH_MINIMUM

                        MessageBox ( strMsg, m_pAlertQuery->GetLogName(), MB_OK  | MB_ICONERROR);
                    }
                }

                ClearAlertHashTable ( );

                if ( bAtLeastOneDuplicateCounter ) {
                    CString strMsg;

                    strMsg.LoadString ( IDS_ALERT_DUPL_PATH );
                    MessageBox ( strMsg, m_pAlertQuery->GetLogName(), MB_OK  | MB_ICONWARNING);

                    // Only deleting duplicates, so no need to recalculate the max extent

                    // Reset the selection if necessary
                    if ( bSelectionDeleted && LB_ERR == m_ndxCurrentItem ) {
                        if (m_CounterList.GetCount() > 0) {
                            m_CounterList.SetCurSel (0);
                            m_ndxCurrentItem = 0;
                            m_CounterList.SetFocus();
                            LoadAlertItemData (0);
                        }
                    }

                }
                bIsValid = LoadListFromDlg ( &nInvalidIndex );
                assert ( bIsValid );
            }
        }
    } else {
        // the counter list is empty
        strText.LoadString (IDS_NO_COUNTERS);
        MessageBox (strText, m_pAlertQuery->GetLogName(), MB_OK | MB_ICONERROR);
        GetDlgItem(IDC_ALRTS_ADD_BTN)->SetFocus();
        bIsValid = FALSE;
    }

    if (bIsValid)
    {
        bIsValid = ValidateDWordInterval(IDC_ALRTS_SAMPLE_EDIT,
                                         m_pAlertQuery->GetLogName(),
                                         (long) m_SharedData.stiSampleTime.dwValue,
                                         eMinSampleInterval,
                                         eMaxSampleInterval);
    }

    if (bIsValid) {
        // Validate sample interval value and unit type
        bIsValid = SampleIntervalIsInRange(
                        m_SharedData.stiSampleTime,
                        m_pAlertQuery->GetLogName() );

        if ( !bIsValid ) {
            GetDlgItem ( IDC_ALRTS_SAMPLE_EDIT )->SetFocus();    
        }
    }

    return bIsValid;
}

BOOL CAlertGenProp::OnSetActive()
{
    BOOL        bReturn;

    bReturn = CSmPropertyPage::OnSetActive();
    if (!bReturn) return FALSE;

    ResourceStateManager    rsm;

    m_pAlertQuery->GetPropPageSharedData ( &m_SharedData );

    UpdateAlertStartString();
    m_strUserDisplay = m_pAlertQuery->m_strUser;
    UpdateData(FALSE); //to load the static string.

    return TRUE;
}

BOOL CAlertGenProp::OnKillActive() 
{
    BOOL bContinue = TRUE;
    ResourceStateManager    rsm;

    // Parent class OnKillActive calls UpdateData(TRUE)
    bContinue = CPropertyPage::OnKillActive();

    if ( bContinue ) {
        m_pAlertQuery->m_strUser = m_strUserDisplay;
        bContinue = IsValidData(m_pAlertQuery, VALIDATE_FOCUS);
        if ( bContinue ) {
            // Save property page shared data.
            m_pAlertQuery->SetPropPageSharedData ( &m_SharedData );
        }
    }

    if ( bContinue ) {
        SetIsActive ( FALSE );
    }

    return bContinue;
}

BOOL CAlertGenProp::OnApply() 
{
    BOOL    bContinue = TRUE;
    CString strText;

    ResourceStateManager    rsm;

    bContinue = UpdateData(TRUE);

    if ( bContinue ) {
        bContinue = IsValidData(m_pAlertQuery, VALIDATE_APPLY );
    }

    if ( bContinue ) {
        bContinue = SampleTimeIsLessThanSessionTime( m_pAlertQuery );
        if ( !bContinue ) {
            GetDlgItem ( IDC_ALRTS_SAMPLE_EDIT )->SetFocus();    
        }
    }

    // Write the data to the query.

    if ( bContinue ) {
        // send the list to the parent query
        // update counter list
        m_pAlertQuery->SetCounterList( m_szAlertCounterList, m_cchAlertCounterListSize );

        m_pAlertQuery->SetLogComment ( m_strComment );

        // Sample interval
        ASSERT ( SLQ_TT_TTYPE_SAMPLE == m_SharedData.stiSampleTime.wTimeType );
        ASSERT ( SLQ_TT_DTYPE_UNITS == m_SharedData.stiSampleTime.wDataType );

        // update counter sample interval
        bContinue = m_pAlertQuery->SetLogTime (&m_SharedData.stiSampleTime, (DWORD)m_SharedData.stiSampleTime.wTimeType);
    }

    if ( bContinue ) {
        bContinue = Apply(m_pAlertQuery); 
    }

    if (bContinue) {
        bContinue = CPropertyPage::OnApply();
    }

    if (bContinue) {
        // Save property page shared data.
        m_pAlertQuery->UpdatePropPageSharedData();
        bContinue = UpdateService ( m_pAlertQuery, FALSE );
    }

    return bContinue;
}

void CAlertGenProp::OnCancel() 
{
    m_pAlertQuery->SyncPropPageSharedData();  // clear memory shared between property pages.
}

void CAlertGenProp::OnClose() 
{
    // free the item data pointers from the list box
    INT                 nNumItems;
    INT                 nCurSel;
    PALERT_INFO_BLOCK   paibInfo;

    nNumItems = m_CounterList.GetCount();
    if (nNumItems != LB_ERR) {
        for (nCurSel = 0; nCurSel < nNumItems; nCurSel++) {
            paibInfo = (PALERT_INFO_BLOCK)m_CounterList.GetItemDataPtr(nCurSel);
            if (paibInfo != NULL) {
                delete (paibInfo);
                m_CounterList.SetItemDataPtr(nCurSel, NULL);
            }
        }
    }
    
    CPropertyPage::OnClose();
}

void CAlertGenProp::PostNcDestroy() 
{
//  delete this;      

    if ( NULL != m_pAlertQuery ) {
        m_pAlertQuery->SetActivePropertyPage( NULL );
    }

    CPropertyPage::PostNcDestroy();
}

BOOL CAlertGenProp::SaveAlertItemData ()
{
    // update the info block to reflect the current values
    PALERT_INFO_BLOCK   paibInfo;
    BOOL                bReturn = FALSE;
    CComboBox*          pOverUnder;
    INT                 nCurSel;
    DWORD               dwFlags;

    pOverUnder = (CComboBox *)GetDlgItem(IDC_ALRTS_OVER_UNDER);
    if ((pOverUnder != NULL) && (m_ndxCurrentItem != LB_ERR)) {
        nCurSel = m_ndxCurrentItem;
        if (nCurSel != LB_ERR) {
            paibInfo = (PALERT_INFO_BLOCK)m_CounterList.GetItemDataPtr(nCurSel);
            if (paibInfo != NULL) {
                DWORD dwOldFlags;
                double dOldLimit;
                dwOldFlags = paibInfo->dwFlags;
                dOldLimit = paibInfo->dLimit;

                if (UpdateData(TRUE)) {
                    paibInfo->dLimit = m_dLimitValue;
                    dwFlags = (pOverUnder->GetCurSel() == OU_OVER) ? AIBF_OVER : 0;
                    if ( eInvalidLimit < paibInfo->dLimit ) {
                        dwFlags |= AIBF_SAVED;
                    }
                    paibInfo->dwFlags = dwFlags;

                    if ( ( dOldLimit != m_dLimitValue ) 
                            || ( dwOldFlags & AIBF_OVER ) != ( dwFlags & AIBF_OVER ) ) { 
                        SetModifiedPage();  // to indicate a change
                    }
                    bReturn = TRUE;
                }
            }
        }
    }

    return bReturn;
}

BOOL CAlertGenProp::LoadAlertItemData (INT nIndex)
{
    // update the info block to reflect the current values
    PALERT_INFO_BLOCK   paibInfo;
    BOOL                bReturn = FALSE;
    CComboBox*          pOverUnder;
    INT                 nCurSel;

    pOverUnder = (CComboBox *)GetDlgItem(IDC_ALRTS_OVER_UNDER);

    if ( pOverUnder != NULL ) {
        nCurSel = m_CounterList.GetCurSel();
        if (nCurSel != LB_ERR) {
            paibInfo = (PALERT_INFO_BLOCK)m_CounterList.GetItemDataPtr(nCurSel);
            if (paibInfo != NULL) {
                pOverUnder->SetCurSel(
                    ((paibInfo->dwFlags & AIBF_OVER) == AIBF_OVER) ? OU_OVER : OU_UNDER);
                m_dLimitValue = paibInfo->dLimit;
                m_ndxCurrentItem = nIndex;
                // If the data is loaded from a property bag, the limit might not have been seen.
                if ( eInvalidLimit < m_dLimitValue ) {
                    paibInfo->dwFlags |= AIBF_SEEN;
                }
                UpdateData(FALSE);
                bReturn = TRUE;
            }
        }
    }

    return bReturn;
}

BOOL CAlertGenProp::SetButtonState ()
{
    BOOL    bState;
    // enable the windows base on whether or not the list box 
    // has any contents
    bState = (m_CounterList.GetCount() > 0);
    GetDlgItem(IDC_ALRTS_TRIGGER_CAPTION)->EnableWindow(bState);
    GetDlgItem(IDC_ALRTS_TRIGGER_VALUE_CAPTION)->EnableWindow(bState);
    GetDlgItem(IDC_ALRTS_OVER_UNDER)->EnableWindow(bState);
    GetDlgItem(IDC_ALRTS_VALUE_EDIT)->EnableWindow(bState);
    GetDlgItem(IDC_ALRTS_REMOVE_BTN)->EnableWindow(bState);
    GetDlgItem(IDC_ALRTS_SAMPLE_EDIT)->EnableWindow(bState);
    GetDlgItem(IDC_ALRTS_SAMPLE_CAPTION)->EnableWindow(bState);
    GetDlgItem(IDC_ALRTS_SAMPLE_INTERVAL_CAPTION)->EnableWindow(bState);
    GetDlgItem(IDC_ALRTS_SAMPLE_SPIN)->EnableWindow(bState);
    GetDlgItem(IDC_ALRTS_SAMPLE_UNITS_CAPTION)->EnableWindow(bState);
    GetDlgItem(IDC_ALRTS_SAMPLE_UNITS_COMBO)->EnableWindow(bState);

    if (m_pAlertQuery->GetLogService()->IsWindows2000Server()) {
        CWnd* pRunAsStatic;

        //
        // Get the static "Run As" window, you can only call this function
        // when "Run As" really exists
        //
        pRunAsStatic = GetRunAsWindow();
        if (pRunAsStatic) {
            pRunAsStatic->EnableWindow(FALSE);
        }
        GetDlgItem(IDC_RUNAS_EDIT)->EnableWindow(FALSE);
    }

    if (m_pAlertQuery->GetLogService()->IsWindows2000Server() ||
        m_strUserDisplay.IsEmpty() ||
        m_strUserDisplay.GetAt(0) == L'<') {

        GetDlgItem(IDC_SETPWD_BTN)->EnableWindow(FALSE);
        m_bPwdButtonEnabled = FALSE;
    }
    return bState;
}

BOOL CAlertGenProp::LoadDlgFromList ()
{
    BOOL    bReturn = TRUE;
    LPTSTR  szThisString = NULL;
    DWORD   dwBufSize;
    DWORD   dwThisStringLen;
    UINT    nIndex;
    DWORD   dwItemExtent;
    CDC*    pCDC = NULL;

    PALERT_INFO_BLOCK   paibInfo = NULL;

    if (m_szAlertCounterList != NULL) {
        pCDC = m_CounterList.GetDC();
        for (szThisString = m_szAlertCounterList;
            *szThisString != 0 && TRUE == bReturn;
            szThisString += dwThisStringLen +1) {

            dwThisStringLen = lstrlen(szThisString);
            dwBufSize = sizeof (ALERT_INFO_BLOCK) + ((dwThisStringLen + 1) * sizeof (TCHAR));
            MFC_TRY
                paibInfo = (PALERT_INFO_BLOCK) new CHAR[dwBufSize];
            MFC_CATCH_MINIMUM;
            if (paibInfo != NULL) {
                if (MakeInfoFromString(szThisString, paibInfo, &dwBufSize)) {
                    if ( 0 <= paibInfo->dLimit ) {
                        paibInfo->dwFlags |= AIBF_SAVED;
                    }
                    nIndex = m_CounterList.AddString(paibInfo->szCounterPath);
                    if (nIndex != LB_ERR) {

                        m_CounterList.SetItemDataPtr (nIndex, (LPVOID)paibInfo);
                        // update list box extent
                        if ( NULL != pCDC ) {
                            dwItemExtent = (DWORD)(pCDC->GetTextExtent (paibInfo->szCounterPath)).cx;
                            if (dwItemExtent > m_dwMaxHorizListExtent) {
                                m_dwMaxHorizListExtent = dwItemExtent;
                                m_CounterList.SetHorizontalExtent(dwItemExtent);
                            }
                        }
                        paibInfo = NULL;
                    } else {
                        delete paibInfo;
                        bReturn = FALSE;
                    }
                } else {
                    delete paibInfo;
                    bReturn = FALSE;
                } 
            } else {
                bReturn = FALSE;
            }
        }
    }
    if ( NULL != pCDC ) {
        m_CounterList.ReleaseDC(pCDC);
        pCDC = NULL;
    }
   
    // Todo:  Error message on failure

    return bReturn;
}

BOOL CAlertGenProp::LoadListFromDlg ( INT *piInvalidEntry, BOOL bInvalidateOnly )
{
    INT                 nNumItems;
    INT                 nCurSel;
    PALERT_INFO_BLOCK   paibInfo;
    DWORD               dwSizeReqd = 0;
    DWORD               dwSize;
    DWORD               dwSizeLeft = 0;
    LPTSTR              szNextString;
    BOOL                bReturn = TRUE;

    nNumItems = m_CounterList.GetCount();
    if ((nNumItems != LB_ERR) && (nNumItems > 0)) {
        // find size required for buffer
        for (nCurSel = 0; nCurSel < nNumItems; nCurSel++) {
            paibInfo = (PALERT_INFO_BLOCK)m_CounterList.GetItemDataPtr(nCurSel);
            if (paibInfo != NULL) {
                if ((paibInfo->dwFlags & (AIBF_SEEN | AIBF_SAVED)) != 0) {
                    dwSizeReqd += (paibInfo->dwSize - sizeof(ALERT_INFO_BLOCK)) / sizeof (WCHAR);
                    dwSizeReqd += 24;
                } else {
                    if (piInvalidEntry != NULL) {
                        *piInvalidEntry = nCurSel;
                        bReturn = FALSE;
                        break;
                    }
                }
            }
        }
        if ( bReturn && !bInvalidateOnly ) {
            LPTSTR  pszTemp = NULL;

            dwSizeReqd += 1; // add room for the MSZ NULL
            MFC_TRY;
            pszTemp = new WCHAR[dwSizeReqd];
            MFC_CATCH_MINIMUM;

            if ( NULL != pszTemp ) {
                // allocate a block of memory for the list
                if (m_szAlertCounterList != NULL) {
                    delete(m_szAlertCounterList);
                }

                m_cchAlertCounterListSize = 0;
                m_szAlertCounterList = pszTemp;

                // now fill it with the Alert paths
                dwSizeLeft = dwSizeReqd;
                szNextString = m_szAlertCounterList;
                for (nCurSel = 0; nCurSel < nNumItems; nCurSel++) {
                    paibInfo = (PALERT_INFO_BLOCK)m_CounterList.GetItemDataPtr(nCurSel);
                    if (paibInfo != NULL) {
                        dwSize = dwSizeLeft;
                        if (MakeStringFromInfo (paibInfo, szNextString, &dwSize)) {
                            dwSize += 1;    // to include the null
                            dwSizeLeft -= dwSize;
                            m_cchAlertCounterListSize += dwSize;
                            szNextString += dwSize; 
                            ASSERT (m_cchAlertCounterListSize < dwSizeReqd);
                        } else {
                            // ran out of buffer
                            bReturn = FALSE;
                            break;
                        }
                    }
                }
                if (bReturn) {
                    *szNextString++ = 0; // MSZ Null
                    m_cchAlertCounterListSize++;
                    if (piInvalidEntry != NULL) {
                        *piInvalidEntry = -1;
                    }
                }
            } // else error
        }
    } else {
        // no items to return
        bReturn = FALSE;
    }
    return bReturn;
}

BOOL CAlertGenProp::OnInitDialog() 
{
    CComboBox       *pCombo;
    CString         csComboBoxString;
    DWORD           nIndex;
    UINT            nResult;
    LPTSTR          szTmpCtrLst;
    DWORD           dwSize;

    ResourceStateManager    rsm;

    //
    // Here m_pAlertQuery should not be NULL, if it is,
    // There must be something wrong.
    //
    if ( NULL == m_pAlertQuery ) {
        return TRUE;
    }

    m_bCanAccessRemoteWbem = m_pAlertQuery->GetLogService()->CanAccessWbemRemote();
    m_pAlertQuery->SetActivePropertyPage( this );

    // call property page init to init combo members.
    CSmPropertyPage::OnInitDialog();
    SetHelpIds ( (DWORD*)&s_aulHelpIds );

    Initialize( m_pAlertQuery );
    m_strUserDisplay = m_pAlertQuery->m_strUser;
    m_strUserSaved = m_strUserDisplay;

    // Load the shared data to get the sample data unit type.
    m_pAlertQuery->GetPropPageSharedData ( &m_SharedData );
    
    // load combo box    
    pCombo = &m_SampleUnitsCombo;
    pCombo->ResetContent();
    for (nIndex = 0; nIndex < dwTimeUnitComboEntries; nIndex++) {
        csComboBoxString.Empty();
        if (csComboBoxString.LoadString ( TimeUnitCombo[nIndex].nResId)) {
            nResult = pCombo->InsertString (nIndex, (LPCWSTR)csComboBoxString);
            ASSERT (nResult != CB_ERR);
            nResult = pCombo->SetItemData (nIndex, (DWORD)TimeUnitCombo[nIndex].nData);
            ASSERT (nResult != CB_ERR);
            // set selected in combo box here
            if (m_SharedData.stiSampleTime.dwUnitType == (DWORD)(TimeUnitCombo[nIndex].nData)) {
                m_nSampleUnits = nIndex;
                nResult = pCombo->SetCurSel(nIndex);
                ASSERT (nResult != CB_ERR);
            }
        }
    }

    pCombo = &m_OverUnderCombo;
    pCombo->ResetContent();
    for (nIndex = 0; nIndex < dwOverUnderComboEntries; nIndex++) {
        csComboBoxString.Empty();
        if (csComboBoxString.LoadString ( OverUnderCombo[nIndex].nResId)) {
            nResult = pCombo->InsertString (nIndex, (LPCWSTR)csComboBoxString);
            ASSERT (nResult != CB_ERR);
            nResult = pCombo->SetItemData (nIndex, (DWORD)TimeUnitCombo[nIndex].nData);
            ASSERT (nResult != CB_ERR);
        }
    }

    // get data from current alert query
    m_pAlertQuery->GetLogComment( m_strComment );
    szTmpCtrLst = (LPTSTR)m_pAlertQuery->GetCounterList (&dwSize);
    if (szTmpCtrLst != NULL) {
        MFC_TRY;
        m_szAlertCounterList = new WCHAR [dwSize];
        MFC_CATCH_MINIMUM;
        if ( NULL != m_szAlertCounterList ) {
            memcpy (m_szAlertCounterList, szTmpCtrLst, (dwSize * sizeof(WCHAR)));
            m_cchAlertCounterListSize = dwSize;
        }
    }

    // Call UpdateData again, after loading data into members.
    UpdateData ( FALSE );

    // load list box

    LoadDlgFromList();

    // m_CounterList is initialized in UpdateData    
    if (m_CounterList.GetCount() > 0) {
        m_CounterList.SetCurSel (0);
        m_CounterList.SetFocus();
        LoadAlertItemData (0);
    }

    SetButtonState ();

    return FALSE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CAlertGenProp::OnCommentEditChange()
{
    UpdateData( TRUE );    
    SetModifiedPage(TRUE);
}

void CAlertGenProp::OnCommentEditKillFocus()
{
    CString strOldText;
    strOldText = m_strComment;
    UpdateData ( TRUE );
    if ( 0 != strOldText.Compare ( m_strComment ) ) {
        SetModifiedPage(TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\cmponent.h ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation

Module Name:

    cmponent.h

Abstract:

    CComponent handles interactions with the result pane.
	MMC calls the IComponent interfaces.


--*/

#ifndef __COMPONENT_H_
#define __COMPONENT_H_

#include "Globals.h"

#include "smlogres.h"        // Resource symbols
#include "compData.h"
/////////////////////////////////////////////////////////////////////////////
// CComponent

#ifdef UNICODE
#define PROPSHEETPAGE_V3 PROPSHEETPAGEW_V3
#else
#define PROPSHEETPAGE_V3 PROPSHEETPAGEA_V3
#endif

class CSmPropertyPage;
class CSmLogQuery;
class CSmNode;

class ATL_NO_VTABLE CComponent : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CComponent, &CLSID_Component>,
    public IComponent,
    public IExtendContextMenu,               
    public IExtendControlbar,                
    public IExtendPropertySheet              

{
  public:
            CComponent();
    virtual ~CComponent();

DECLARE_REGISTRY_RESOURCEID(IDR_COMPONENT)
DECLARE_NOT_AGGREGATABLE(CComponent)

BEGIN_COM_MAP(CComponent)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)  
    COM_INTERFACE_ENTRY(IExtendControlbar)   
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
END_COM_MAP()

  // IComponent interface methods
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)(MMC_COOKIE cookie);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM*  pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

  // IExtendContextMenu 
    STDMETHOD(AddMenuItems)( LPDATAOBJECT pDataObject,
                             LPCONTEXTMENUCALLBACK pCallbackUnknown,
                             long *pInsertionAllowed
                           );
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);
    
  // IExtendControlBar     
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

  // IExtendPropertySheet
    STDMETHOD(CreatePropertyPages)( LPPROPERTYSHEETCALLBACK lpProvider,
                                    LONG_PTR handle,
                                    LPDATAOBJECT lpIDataObject
                                  );

    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

    // Other public methods        
    
    HRESULT SetIComponentData(CComponentData* pData);

  private:
    enum eToolbarType {
        eLog = 1,
        eAlert = 2
    };

    HRESULT OnPaste(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM Param);
    HRESULT OnQueryPaste(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM Param);
    HRESULT OnShow(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM Param);
    HRESULT OnSelect(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM Param);
    HRESULT OnAddImages(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM Param);
    HRESULT OnRefresh(LPDATAOBJECT pDataObject);
    HRESULT OnDelete(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM Param);
    HRESULT OnDoubleClick(ULONG ulRecNo,LPDATAOBJECT pDataObject);
    HRESULT OnDisplayHelp( LPDATAOBJECT pDataObject );
    HRESULT OnViewChange(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM Param);
    HRESULT StartLogQuery(LPDATAOBJECT pDataObject);
    HRESULT StopLogQuery(LPDATAOBJECT pDataObject, BOOL bWarnOnRestartCancel=TRUE);
    HRESULT SaveLogQueryAs(LPDATAOBJECT pDataObject);
    HRESULT OnPropertyChange( LPARAM Param );
    HRESULT HandleExtToolbars( bool bDeselectAll, LPARAM arg, LPARAM Param );
    HRESULT PopulateResultPane ( MMC_COOKIE cookie );
    HRESULT RefreshResultPane ( MMC_COOKIE cookie );

    HRESULT AddPropertyPage ( LPPROPERTYSHEETCALLBACK, CSmPropertyPage*& );

    HRESULT LoadLogToolbarStrings ( MMCBUTTON * Buttons );
    HRESULT LoadAlertToolbarStrings ( MMCBUTTON * Buttons );

    HRESULT _InvokePropertySheet(ULONG ulRecNo,LPDATAOBJECT pDataObject);
    HRESULT InvokePropertySheet(
                                IPropertySheetProvider *pPrshtProvider,
                                LPCWSTR wszTitle,
                                LONG lCookie,
                                LPDATAOBJECT pDataObject,
                                IExtendPropertySheet *pPrimary,
                                USHORT usStartingPage);


    LPCONSOLE        m_ipConsole;      // MMC interface to console
    IHeaderCtrl*     m_ipHeaderCtrl;   // MMC interface to header control
    IResultData*     m_ipResultData;   // MMC interface to result data
    IConsoleVerb*    m_ipConsoleVerb;  // MMC interface to console verb
    LPIMAGELIST      m_ipImageResult;  // MMC interface to result pane images
    CComponentData*  m_ipCompData;     // Parent scope pane object
    LPTOOLBAR        m_ipToolbarLogger;// Toolbar for result pane view loggers
    LPTOOLBAR        m_ipToolbarAlerts;   // Toolbar for result pane view alerts
    LPTOOLBAR        m_ipToolbarAttached;   // Currently attached toolbar
    LPCONTROLBAR     m_ipControlbar;   // Control bar to hold the tool bars
    CSmNode*         m_pViewedNode;
    HINSTANCE        m_hModule;         // resource handle for strings    
    

    // Store string data (reference) locally until per-line redraw is complete.
    CString          m_strDisplayInfoName;      
    CString          m_strDisplayInfoComment; 
    CString          m_strDisplayInfoLogFileType; 
    CString          m_strDisplayInfoLogFileName; 
    CString          m_strDisplayInfoQueryType; 
    CString          m_strDisplayInfoDesc; 
};

#endif //__COMPONENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\compdata.cpp ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation

Module Name:

    compdata.cpp

Abstract:

    Implementation of the CComponentData class.
    This class is the interface to handle anything to do
    with the scope pane. MMC calls the IComponentData interfaces.
    This class keeps a few pointers to interfaces that MMC
    implements.

--*/

#include "stdafx.h"
#include <shfolder.h>
#include "smcfgmsg.h"
#include "smtprov.h"
#include "smrootnd.h"
#include "ipropbag.h"
#include "smlogqry.h"
#include "cmponent.h"
#include "smcfgmsg.h"
#include "newqdlg.h"
#include "logwarnd.h"
#include "strnoloc.h"

#include "ctrsprop.h"
#include "fileprop.h"
#include "provprop.h"
#include "schdprop.h"
#include "tracprop.h"
#include "AlrtGenP.h"
#include "AlrtActP.h"
//
#include "compdata.h"

USE_HANDLE_MACROS("SMLOGCFG(compdata.cpp)");

GUID g_guidSystemTools = structuuidNodetypeSystemTools;

extern DWORD g_dwRealTimeQuery;

/////////////////////////////////////////////////////////////////////////////
// CComponentData 

CComponentData::CComponentData()
:   m_bIsExtension( FALSE ),
    m_ipConsoleNameSpace ( NULL ),
    m_ipConsole          ( NULL ),
    m_ipResultData       ( NULL ),
    m_ipPrshtProvider     ( NULL ),
    m_ipScopeImage       ( NULL )
{
    m_hModule    = (HINSTANCE)GetModuleHandleW (_CONFIG_DLL_NAME_W_);

}

CComponentData::~CComponentData()
{
    // Make sure the list is empty.
    ASSERT ( m_listpRootNode.IsEmpty() );
}


/////////////////////////////////////////////////////////////////////////////
// IComponentData methods
//

//---------------------------------------------------------------------------
// We get here only once, when the user clicks on the snapin.
//
// This method should not change as we progress through further steps.
// Here we get a chance to get pointer to some interfaces MMC provides.
// We QueryInterface for pointers to the name space and console, which
// we cache in local variables
// The other task to acomplish here is the adding of a bitmap that contains
// the icons to be used in the scope pane.
//
STDMETHODIMP
CComponentData::Initialize (
    LPUNKNOWN pUnknown         // [in] Pointer to the IConsoles IUnknown interface
    )
{
    HRESULT      hr;
    ASSERT( NULL != pUnknown );
    HBITMAP hbmpSNodes16 = NULL;
    HBITMAP hbmpSNodes32 = NULL;
    BOOL bWasReleased;
    
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //  LPIMAGELIST  lpScopeImage;
    
    // MMC should only call ::Initialize once!
    ASSERT( NULL == m_ipConsoleNameSpace );
    
    // Get pointer to name space interface
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (VOID**)(&m_ipConsoleNameSpace));
    ASSERT( S_OK == hr );
    
    // Get pointer to console interface
    hr = pUnknown->QueryInterface(IID_IConsole, (VOID**)(&m_ipConsole));
    ASSERT( S_OK == hr );
    
    // Get pointer to property sheet provider interface
    hr = m_ipConsole->QueryInterface(IID_IPropertySheetProvider, (VOID**)&m_ipPrshtProvider);
    ASSERT( S_OK == hr );

    // Add the images for the scope tree
    hr = m_ipConsole->QueryScopeImageList(&m_ipScopeImage);
    ASSERT( S_OK == hr );
    
    // Load the bitmaps from the dll
    hbmpSNodes16 = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_NODES_16x16));
    ASSERT( NULL != hbmpSNodes16 );
    
    hbmpSNodes32 = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_NODES_32x32));
    ASSERT( NULL != hbmpSNodes32 );
    
    // Set the images
    hr = m_ipScopeImage->ImageListSetStrip( 
        (LONG_PTR *)hbmpSNodes16,
        (LONG_PTR *)hbmpSNodes32,
        0,
        RGB(0,255,0)
        );
    ASSERT( S_OK == hr );

    if ( NULL != hbmpSNodes16 ) {
        bWasReleased = DeleteObject( hbmpSNodes16 );
        ASSERT( bWasReleased );
    }

    if ( NULL != hbmpSNodes32 ) {
        bWasReleased = DeleteObject( hbmpSNodes32 );
        ASSERT( bWasReleased );
    }


    return S_OK;
    
} // end Initialize()


//---------------------------------------------------------------------------
// Release interfaces and clean up objects which allocated memory
//
STDMETHODIMP
CComponentData::Destroy()
{
    CSmRootNode*    pRootNode = NULL;
    POSITION        Pos = m_listpRootNode.GetHeadPosition();

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    while ( Pos != NULL) {
        pRootNode = m_listpRootNode.GetNext( Pos );
        pRootNode->Destroy();
        delete (pRootNode);
    }
    // empty the list now that everything has been closed;
    m_listpRootNode.RemoveAll();    

    // Free interfaces
    if ( NULL != m_ipConsoleNameSpace )
        m_ipConsoleNameSpace->Release();

    if ( NULL != m_ipConsole )
        m_ipConsole->Release();
    
    if ( NULL != m_ipResultData )
        m_ipResultData->Release();
    
    if ( NULL != m_ipScopeImage )
        m_ipScopeImage->Release();
    
    if ( NULL != m_ipPrshtProvider)
        m_ipPrshtProvider->Release();
    
    return S_OK;
    
} // end Destroy()


//---------------------------------------------------------------------------
// Come in here once right after Initialize. MMC wants a pointer to the
// IComponent interface.
//
STDMETHODIMP
CComponentData::CreateComponent (
    LPCOMPONENT* ppComponent     // [out] Pointer to the location that stores
    )                            // the newly created pointer to IComponent
{
    HRESULT hr = E_FAIL;    
    CComObject<CComponent>* pObject;
    
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // MMC asks us for a pointer to the IComponent interface
    //
    // For those getting up to speed with COM...
    // If we had implemented IUnknown with its methods QueryInterface, AddRef,
    // and Release in our CComponent class...
    // The following line would have worked
    //
    // pNewSnapin = new CComponent(this);
    //
    // In this code we will have ATL take care of IUnknown for us and create
    // an object in the following manner...
    
    if ( NULL == ppComponent ) {
        ASSERT ( FALSE );
        hr = E_INVALIDARG;
    } else {
    
        CComObject<CComponent>::CreateInstance( &pObject );

        if ( NULL != pObject ) {
            hr = pObject->SetIComponentData( this );
            
            if ( SUCCEEDED ( hr ) ) {
                hr = pObject->QueryInterface ( 
                                IID_IComponent,
                                reinterpret_cast<void**>(ppComponent) );
            } else {
                pObject->Release();
            }
        }
    }
    return hr;
} // end CreateComponent()


//---------------------------------------------------------------------------
// In this first step, we only implement EXPAND.
// The expand message asks us to populate what is under our root node.
// We just put one item under there.
//
STDMETHODIMP
CComponentData::Notify (
    LPDATAOBJECT     pDataObject,   // [in] Points to the selected data object
    MMC_NOTIFY_TYPE  event,         // [in] Identifies action taken by user.
    LPARAM           arg,           // [in] Depends on the notification type
    LPARAM           param          // [in] Depends on the notification type
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    
    switch (event)
    {
    case MMCN_EXPAND:
        hr = OnExpand( pDataObject, arg, param );
        break;
        
    case MMCN_DELETE:                  // Function not implemented
        LOCALTRACE( L"ComponentData::Notify: MMCN_DELETE unimplemented\n" );
        hr = S_FALSE;
        break;
        
    case MMCN_RENAME:                  // Function not implemented
        LOCALTRACE( L"ComponentData::Notify: MMCN_RENAME unimplemented\n" );
        hr = S_FALSE;   // False signifies Rename not allowed.
        break;
        
    case MMCN_SELECT:                  // Function not implemented
        LOCALTRACE( L"ComponentData::Notify: MMCN_SELECT unimplemented\n" );
        hr = S_FALSE;
        break;
        
    case MMCN_PROPERTY_CHANGE:         // Function not implemented
        LOCALTRACE( L"ComponentData::Notify: MMCN_PROPERTY_CHANGE unimplemented\n" );
        hr = S_FALSE;
        break;
        
    case MMCN_REMOVE_CHILDREN:         // Function not implemented
        hr = OnRemoveChildren( pDataObject, arg, param );
        break;
        
    default:
        LOCALTRACE( L"CComponentData::Notify: unimplemented event %x\n", event );
        hr = S_FALSE;
        break;
    }
    return hr;
    
} // end Notify()


//---------------------------------------------------------------------------
// This is where MMC asks us to provide IDataObjects for every node in the
// scope pane.  We have to QI the object so it gets AddRef'd.  The node
// manager handles deleting the objects.
//
STDMETHODIMP
CComponentData::QueryDataObject (
    LPARAM            mmcCookie,    // [in]  Data object's unique identifier
    DATA_OBJECT_TYPES context,      // [in]  Data object's type
    LPDATAOBJECT*     ppDataObject  // [out] Points to the returned data object
    )
{
    HRESULT hr = S_OK;
    CSmNode* pNode = NULL;
    CComObject<CDataObject>* pDataObj = NULL;
    CString strMessage;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    context;            // to prevent compiler errors in no-debug builds

    ASSERT( CCT_SCOPE      == context  ||      // Must have a context
        CCT_RESULT         == context  ||      // we understand
        CCT_SNAPIN_MANAGER == context
        );

    if ( NULL != ppDataObject 
        && ( CCT_SCOPE == context  
             || CCT_RESULT == context  
             || CCT_SNAPIN_MANAGER == context ) ) {

        CComObject<CDataObject>::CreateInstance( &pDataObj );

        if( NULL == pDataObj ) {            // DataObject was not created
   
            MFC_TRY
                strMessage.LoadString ( IDS_ERRMSG_UNABLEALLOCDATAOBJECT );
        
                ::MessageBox( NULL,
                    (LPCWSTR)strMessage,
                    L"CComponentData::QueryDataObject",
                    MB_OK | MB_ICONERROR
                    );
            MFC_CATCH_HR;

            hr = E_OUTOFMEMORY;
        } else {

            // If the passed-in mmcCookie is non-NULL, then it should be one we 
            // created when we added a node to the scope pane. 
            //
            // Otherwise the mmcCookie refers to the root folder (this snapin's 
            // static folder in the scope pane or snapin manager). 
            //
            // Init the mmCookie, context and type in the data object.
            if( mmcCookie ) {                        
                                            
                pNode = (CSmNode*)mmcCookie;
                if ( NULL != pNode->CastToRootNode() ) {
                    pDataObj->SetData( mmcCookie, CCT_SCOPE, COOKIE_IS_ROOTNODE );
                } else if ( NULL != pNode->CastToCounterLogService() ) {
                    pDataObj->SetData( mmcCookie, CCT_SCOPE, COOKIE_IS_COUNTERMAINNODE );
                } else if ( NULL != pNode->CastToTraceLogService() ) {
                    pDataObj->SetData( mmcCookie, CCT_SCOPE, COOKIE_IS_TRACEMAINNODE );
                } else if ( NULL != pNode->CastToAlertService() ) {
                    pDataObj->SetData( mmcCookie, CCT_SCOPE, COOKIE_IS_ALERTMAINNODE );
                } else {
                    ::MessageBox( NULL,
                        L"Bad mmcCookie",
                        L"CComponentData::QueryDataObject",
                        MB_OK | MB_ICONERROR
                        );
                    hr = E_FAIL;
                }
            } else {
                ASSERT( CCT_RESULT != context );
                // NOTE:  Passed in scope might be either CCT_SNAPIN_MANAGER or CCT_SCOPE
                // This case occcurs when the snapin is not an extension.
                pDataObj->SetData( mmcCookie, CCT_SCOPE, COOKIE_IS_ROOTNODE );
            }
            if ( SUCCEEDED ( hr ) ) {
                hr = pDataObj->QueryInterface( 
                                    IID_IDataObject,
                                    reinterpret_cast<void**>(ppDataObject) );
            } else {
                if ( NULL != pDataObj ) {
                    delete pDataObj;
                }
                *ppDataObject = NULL;
            }
        }
    } else {
        ASSERT ( FALSE );
        hr = E_POINTER;
    }
    return hr;
} // end QueryDataObject()


//---------------------------------------------------------------------------
// This is where we provide strings for nodes in the scope pane.
// MMC handles the root node string.
//
STDMETHODIMP
CComponentData::GetDisplayInfo (
    LPSCOPEDATAITEM pItem )    // [in, out] Points to a SCOPEDATAITEM struct
{
    HRESULT hr = S_OK;
    PSMNODE pTmp = NULL;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ResourceStateManager    rsm;
    
    if ( NULL != pItem ) {
        if( pItem->mask & SDI_STR ) {
            // Note:  Text buffer allocated for each information type, so that
            // the buffer pointer is persistent for a single item (line in the result pane).
    
            // Set the name of the selected node
            pTmp = reinterpret_cast<PSMNODE>(pItem->lParam);
            if ( NULL != pTmp ) {
                m_strDisplayInfoName = pTmp->GetDisplayName();
                pItem->displayname = T2OLE ( m_strDisplayInfoName.GetBuffer( m_strDisplayInfoName.GetLength() ) );
            }
        }

        if( pItem->mask & SDI_IMAGE ) {  // Looking for image
            pTmp = reinterpret_cast<PSMNODE>(pItem->lParam);
            if ( NULL != pTmp ) {
                if ( NULL != pTmp->CastToRootNode() ) {
                    ASSERT((pItem->mask & (SDI_IMAGE | SDI_OPENIMAGE)) == 0);
                    pItem->nImage     = eBmpRootIcon;
                    pItem->nOpenImage = eBmpRootIcon;
                    hr = S_OK;
                } else if ( NULL != pTmp->CastToAlertService() ){   
                    pItem->nImage = eBmpAlertType;
                } else {
                    pItem->nImage = eBmpLogType;
                }
            }
        }
    } else {
        ASSERT ( FALSE );
        hr = E_POINTER;
    }

    return hr;
    
} // end GetDisplayInfo()


//---------------------------------------------------------------------------
//
STDMETHODIMP
CComponentData::CompareObjects (
    LPDATAOBJECT pDataObjectA,    // [in] First data object to compare
    LPDATAOBJECT pDataObjectB )   // [in] Second data object to compare
{
    HRESULT hr = S_OK;
    CDataObject *pdoA = NULL;
    CDataObject *pdoB = NULL;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
            
    // At least one of these data objects is supposed to be ours, so one
    // of the extracted pointers should be non-NULL.
    pdoA = ExtractOwnDataObject( pDataObjectA );
    pdoB = ExtractOwnDataObject( pDataObjectB );
    ASSERT( pdoA || pdoB );              // Assert if we can't get any objects
    
    // If extraction failed for one of them, then that one is foreign and
    // can't be equal to the other one.  (Or else ExtractOwnDataObject
    // returned NULL because it ran out of memory, but the most conservative
    // thing to do in that case is say they're not equal.)
    if( !pdoA || !pdoB ) {
        hr = S_FALSE;
    } else {
        if( pdoA->GetCookieType() != pdoB->GetCookieType() ) {
            // The cookie type could be COOKIE_IS_ROOTNODE or COOKIE_IS_MAINNODE
            // If they differ then the objects refer to different things.
            hr = S_FALSE;
        }
    }
    
    return hr;
    
} // end CompareObjects()


/////////////////////////////////////////////////////////////////////////////
//  Methods needed to support IComponentData
//

//---------------------------------------------------------------------------
// Here is our chance to place things under the root node.
//
HRESULT
CComponentData::OnExpand (
    LPDATAOBJECT pDataObject,      // [in] Points to data object
    LPARAM       arg,              // [in] TRUE is we are expanding
    LPARAM       param )             // [in] Points to the HSCOPEITEM
{
    HRESULT         hr = S_FALSE;
    HRESULT         hrBootState= NOERROR;
    INT             iBootState;
    GUID            guidObjectType;
    CSmRootNode*    pRootNode = NULL;
    CDataObject*    pDO = NULL;
    SCOPEDATAITEM   sdi;
    INT             iResult;
    CString         strTmp;
    CString         strServerName;
    CString         strMessage;
    CString         strSysMessage;
    CString         strTitle;
    CString         strComputerName;
    ResourceStateManager    rsm;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT( NULL != m_ipConsoleNameSpace );  // Make sure we QI'ed for the interface
    ASSERT( NULL != pDataObject );           // Must have valid data object
    
    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        if( TRUE == arg ) {
            hr = ExtractObjectTypeGUID (pDataObject, &guidObjectType);
            ASSERT ( SUCCEEDED (hr) );
            if ( SUCCEEDED ( hr) ) {
                if ( IsMyComputerNodetype (guidObjectType) ) {
                    // Is extension of Computer Management snapin
                    hr = ExtractMachineName (
                            pDataObject,
                            strServerName);
        
                    ASSERT ( SUCCEEDED ( hr ) );
                    if ( SUCCEEDED (hr) ) {
            
                        MFC_TRY
                            pRootNode = new CSmRootNode;
                        MFC_CATCH_HR

                        if ( SUCCEEDED (hr) ) {
                            pRootNode->SetMachineName ( strServerName );
                            //
                            // As an extension snapin, the log nodes should be added
                            // beneath a "Performance Logs and Alerts" node.  Insert that node, 
                            // and remember it as the root of the Performance Logs and Alerts namespace.
                            //
 
                            ZeroMemory(&sdi, sizeof sdi);
                            sdi.mask        =   SDI_STR       | 
                                                SDI_PARAM     | 
                                                SDI_IMAGE     | 
                                                SDI_OPENIMAGE |   // nOpenImage is valid
                                                SDI_PARENT;
                            sdi.relativeID  = (HSCOPEITEM)param;
                            sdi.displayname = MMC_CALLBACK;
                            sdi.nImage      = eBmpRootIcon;
                            sdi.nOpenImage  = eBmpRootIcon;
                            sdi.lParam      = reinterpret_cast<LPARAM>(pRootNode);                
 
                            hr = m_ipConsoleNameSpace->InsertItem( &sdi );
 
                            if (SUCCEEDED(hr)) {
                                // Make this node the the root node 
                                pRootNode->SetScopeItemHandle ( (HSCOPEITEM)sdi.ID );
                                pRootNode->SetParentScopeItemHandle( (HSCOPEITEM)param );
                                pRootNode->SetExtension( TRUE );
                                SetExtension( TRUE );
                                m_listpRootNode.AddTail(pRootNode);
                            } else {
                                hr = E_UNEXPECTED;
                            }
                        } // Allocate CSmRootNode
                    } // ExtractMachineName
                } else { // Not IsMyComputerNodeType
    
                    pDO = ExtractOwnDataObject( pDataObject );
        
                    if( NULL != pDO ) {      
                        // Make sure that what we are placing ourselves under is the root node
                        // or the extension root node!
                        if ( COOKIE_IS_ROOTNODE == pDO->GetCookieType() ) {
                            pRootNode = (CSmRootNode*)pDO->GetCookie();
                            if ( NULL == pRootNode ) {
                                // If root node cookie is null, then the root node was created by 
                                // the snapin manager, and this is a standalone node.
            
                                MFC_TRY
                                    pRootNode = new CSmRootNode;
                                MFC_CATCH_HR

                                    if ( SUCCEEDED ( hr ) ) {
                                    // Cache the root node handle
                                    pRootNode->SetScopeItemHandle ( (HSCOPEITEM)param );
                                    pRootNode->SetExtension( FALSE );
                                    SetExtension( FALSE );
                                    // NOTE:  No way to associate root node data directly with node.
                                    // Node only added once, so no need to check for duplicates.
                                    m_listpRootNode.AddTail(pRootNode);
                                }
                            } else {
                                if ( m_listpRootNode.IsEmpty() ) {
                                    hr = S_FALSE; 
                                }
                            }

                            if ( SUCCEEDED ( hr ) && S_FALSE != hr ) {
                
                                ASSERT ( NULL != pRootNode->CastToRootNode() );
                                ASSERT ( NULL != pRootNode->GetScopeItemHandle() );
                
                                ASSERT( CCT_SCOPE == pDO->GetContext() );    // Scope pane must be current context  
            
                                // For extensions, the root node was created in a previous call to this method.
                                // The root was NOT expanded in that call.
                                // For non-extensions, the root node is expanded in the same call as it is created.
                                if ( !pRootNode->IsExpanded() ) {        
                                    CWaitCursor     WaitCursor;
                                    DWORD dwStatus;
                                    hr = S_OK;

                                    strServerName = pRootNode->GetMachineName();

                                    if ( !pRootNode->GetCounterLogService()->IsOpen() ) {
                                        dwStatus = pRootNode->GetCounterLogService()->Open ( strServerName );

                                        if ( ERROR_SUCCESS == dwStatus ) {

                                            // Place node for counter logs
                                            memset( &sdi, 0, sizeof(SCOPEDATAITEM) );
                                            sdi.mask = SDI_STR       |   // Displayname is valid
                                                       SDI_PARAM     |   // lParam is valid
                                                       SDI_IMAGE     |   // nImage is valid
                                                       SDI_OPENIMAGE |   // nOpenImage is valid
                                                       SDI_CHILDREN  |   // Children count (0 vs. 1) is valid.
                                                       SDI_PARENT;
                                            sdi.relativeID  = pRootNode->GetScopeItemHandle();  // Performance Logs and Alerts root node
                                            sdi.nImage      = eBmpLogType;
                                            sdi.nOpenImage  = sdi.nImage;   // select icon is same as non select
                                            sdi.displayname = MMC_CALLBACK;
                                            sdi.lParam      = reinterpret_cast<LPARAM>(pRootNode->GetCounterLogService());  // The cookie
                                            sdi.cChildren = 0;      // No children in the scope pane.

                                            hr = m_ipConsoleNameSpace->InsertItem( &sdi );
                                        } else {

                                            hr = E_FAIL;
                            
                                            strComputerName = strServerName;
                                            if ( strComputerName.IsEmpty() )
                                                strComputerName.LoadString ( IDS_LOCAL );

                                            if ( SMCFG_NO_READ_ACCESS == dwStatus || SMCFG_NO_INSTALL_ACCESS == dwStatus ) {
                                                FormatSmLogCfgMessage ( 
                                                    strMessage,
                                                    m_hModule, 
                                                    dwStatus, 
                                                    (LPCTSTR)strComputerName);
                                            } else  {
                                                FormatMessage ( 
                                                    FORMAT_MESSAGE_FROM_SYSTEM,
                                                    NULL, 
                                                    dwStatus,
                                                    0,
                                                    strMessage.GetBufferSetLength( MAX_PATH ),
                                                    MAX_PATH,
                                                    NULL );
        
                                                strMessage.ReleaseBuffer();

                                                if ( strMessage.IsEmpty() ) {
                                                    strMessage.Format ( _T("0x%08lX"), dwStatus );   
                                                }
                                            }
                            
                                            strTitle.LoadString ( IDS_PROJNAME );

                                            m_ipConsole->MessageBox( 
                                                (LPCWSTR)strMessage,
                                                (LPCWSTR)strTitle,
                                                MB_OK | MB_ICONWARNING,
                                                &iResult
                                                );
                                        }
                                    }

                                    if ( SUCCEEDED(hr) && !pRootNode->GetTraceLogService()->IsOpen() ) {
                                        hrBootState = NOERROR;

                                        dwStatus = pRootNode->GetTraceLogService()->Open ( strServerName );

                                        hrBootState = pRootNode->GetTraceLogService()->GetProviders()->GetBootState ( iBootState ); 

                                        if ( ERROR_SUCCESS == dwStatus 
                                                && SUCCEEDED ( hrBootState ) 
                                                && 0 == iBootState ) {
                                            // Place node for trace logs
                                            memset( &sdi, 0, sizeof(SCOPEDATAITEM) );
                                            sdi.mask = SDI_STR       |   // Displayname is valid
                                                       SDI_PARAM     |   // lParam is valid
                                                       SDI_IMAGE     |   // nImage is valid
                                                       SDI_OPENIMAGE |   // nOpenImage is valid
                                                       SDI_CHILDREN  |   // Children count (0 vs. 1) is valid.
                                                       SDI_PARENT;
                                            sdi.relativeID  = pRootNode->GetScopeItemHandle();  // Performance Logs and Alerts root node
                                            sdi.nImage      = eBmpLogType;
                                            sdi.nOpenImage  = sdi.nImage;   // select icon is same as non select
                                            sdi.displayname = MMC_CALLBACK;
                                            sdi.lParam      = reinterpret_cast<LPARAM>(pRootNode->GetTraceLogService());  // The cookie
                                            sdi.cChildren = 0;      // No children in the scope pane.
    
                                            hr = m_ipConsoleNameSpace->InsertItem( &sdi );
                                        } else {
                                            strComputerName = strServerName;
                                            if ( strComputerName.IsEmpty() )
                                                strComputerName.LoadString ( IDS_LOCAL );

                                            if ( SMCFG_NO_READ_ACCESS == dwStatus || SMCFG_NO_INSTALL_ACCESS == dwStatus ) {
                                                hr = E_FAIL;
                                                FormatSmLogCfgMessage ( 
                                                    strMessage,
                                                    m_hModule, 
                                                    dwStatus, 
                                                    (LPCTSTR)strComputerName);
                                            } else if ( ERROR_SUCCESS != dwStatus ) {
                                                hr = E_FAIL;
                                                FormatMessage ( 
                                                    FORMAT_MESSAGE_FROM_SYSTEM,
                                                    NULL, 
                                                    dwStatus,
                                                    0,
                                                    strMessage.GetBufferSetLength( MAX_PATH ),
                                                    MAX_PATH,
                                                    NULL );
        
                                                strMessage.ReleaseBuffer();

                                                if ( strMessage.IsEmpty() ) {
                                                    strMessage.Format ( _T("0x%08lX"), dwStatus );   
                                                }
                                            } else if ( FAILED ( hrBootState ) ) {

                                                FormatSmLogCfgMessage ( 
                                                    strMessage,
                                                    m_hModule, 
                                                    SMCFG_UNABLE_OPEN_TRACESVC, 
                                                    (LPCTSTR)strComputerName);

                                                FormatMessage ( 
                                                    FORMAT_MESSAGE_FROM_SYSTEM,
                                                    NULL, 
                                                    hrBootState,
                                                    0,
                                                    strSysMessage.GetBufferSetLength( MAX_PATH ),
                                                    MAX_PATH,
                                                    NULL );
        
                                                strSysMessage.ReleaseBuffer();

                                                if ( strSysMessage.IsEmpty() ) {
                                                    strSysMessage.Format ( _T("0x%08lX"), hrBootState );
                                                }

                                                strMessage += strSysMessage;
                            
                                            } else if ( 0 != iBootState ) {

                                                FormatSmLogCfgMessage ( 
                                                    strMessage,
                                                    m_hModule, 
                                                    SMCFG_SAFE_BOOT_STATE, 
                                                    (LPCTSTR)strComputerName);
                                            }
                            
                                            strTitle.LoadString ( IDS_PROJNAME );

                                            m_ipConsole->MessageBox( 
                                                (LPCWSTR)strMessage,
                                                (LPCWSTR)strTitle,
                                                MB_OK | MB_ICONWARNING,
                                                &iResult
                                                );
                                        }
                                    }

                                    if ( SUCCEEDED(hr) && !pRootNode->GetAlertService()->IsOpen() ) {
                                        dwStatus = pRootNode->GetAlertService()->Open ( strServerName );
                                        if ( ERROR_SUCCESS == dwStatus ) {
                                            // Place node for alerts
                                            memset( &sdi, 0, sizeof(SCOPEDATAITEM) );
                                            sdi.mask = SDI_STR       |   // Displayname is valid
                                                       SDI_PARAM     |   // lParam is valid
                                                       SDI_IMAGE     |   // nImage is valid
                                                       SDI_OPENIMAGE |   // nOpenImage is valid
                                                       SDI_CHILDREN  |   // Children count (0 vs. 1) is valid.
                                                       SDI_PARENT;
                                            sdi.relativeID  = pRootNode->GetScopeItemHandle();  // Performance Logs and Alerts root node
                                            sdi.nImage      = eBmpAlertType;
                                            sdi.nOpenImage  = sdi.nImage;   // select icon is same as non select
                                            sdi.displayname = MMC_CALLBACK;
                                            sdi.lParam      = reinterpret_cast<LPARAM>(pRootNode->GetAlertService());  // The cookie
                                            sdi.cChildren = 0;      // No children in the scope pane.
    
                                            hr = m_ipConsoleNameSpace->InsertItem( &sdi );
                                        } else {

                                            hr = E_FAIL;
                            
                                            strComputerName = strServerName;
                                            if ( strComputerName.IsEmpty() )
                                                strComputerName.LoadString ( IDS_LOCAL );

                                            if ( SMCFG_NO_READ_ACCESS == dwStatus || SMCFG_NO_INSTALL_ACCESS == dwStatus ) {
                                                FormatSmLogCfgMessage ( 
                                                    strMessage,
                                                    m_hModule, 
                                                    dwStatus, 
                                                    (LPCTSTR)strComputerName);
                                            } else  {
                                                FormatMessage ( 
                                                    FORMAT_MESSAGE_FROM_SYSTEM,
                                                    NULL, 
                                                    dwStatus,
                                                    0,
                                                    strMessage.GetBufferSetLength( MAX_PATH ),
                                                    MAX_PATH,
                                                    NULL );
        
                                                strMessage.ReleaseBuffer();

                                                if ( strMessage.IsEmpty() ) {
                                                    strMessage.Format ( _T("0x%08lX"), dwStatus );   
                                                }
                                            }
                                    
                                            strTitle.LoadString ( IDS_PROJNAME );

                                            m_ipConsole->MessageBox( 
                                                (LPCWSTR)strMessage,
                                                (LPCWSTR)strTitle,
                                                MB_OK | MB_ICONWARNING,
                                                &iResult
                                                );
                                        }
                                    }
                
                                    if ( SUCCEEDED( hr ) ) {
                                        pRootNode->SetExpanded( TRUE );
                                        hr = ProcessCommandLine( strServerName );
                                    }
                                }
                            } // Insert other scope nodes
                        } // COOKIE_IS_ROOTNODE
                    } else {
                        // Unknown data object
                        strMessage.LoadString ( IDS_ERRMSG_UNKDATAOBJ );
                        m_ipConsole->MessageBox( 
                            (LPCWSTR)strMessage,
                            L"CComponentData::OnExpand",
                            MB_OK | MB_ICONERROR,
                            &iResult
                            );
                        hr = E_UNEXPECTED;
                    }   // ExtractOwnDataObject
                } // IsMyComputerNodeType
            } // ExtractObjectTypeGUID
        } else { // FALSE == arg
            hr = S_FALSE;
        }
    } // Parameters are valid

    return hr;
    
} // end OnExpand()

//---------------------------------------------------------------------------
// Remove and delete all children under the specified node.
//
HRESULT
CComponentData::OnRemoveChildren (
    LPDATAOBJECT pDataObject,      // [in] Points to data object of node whose children are to be deleted.
    LPARAM       arg,              // [in] HSCOPEITEM of node whose children are to be deleted;
    LPARAM       /* param */       // [in] Not used
    )
{
    HRESULT         hr = S_FALSE;
    HRESULT         hrLocal;
    CSmRootNode*    pRootNode = NULL;
    CSmRootNode*    pTestNode;
    POSITION        Pos = m_listpRootNode.GetHeadPosition();
    HSCOPEITEM      hParent = (HSCOPEITEM)arg;
    LPRESULTDATA    pResultData;
    CDataObject*    pDO = NULL;

    ASSERT ( !m_listpRootNode.IsEmpty() );

    if ( NULL == pDataObject ) {
        hr = E_POINTER;
    } else {

        while ( Pos != NULL) {
            pTestNode = m_listpRootNode.GetNext( Pos );
            // For standalone, the root node's parent handle is NULL.  
            if ( hParent == pTestNode->GetScopeItemHandle() 
                    || ( hParent == pTestNode->GetParentScopeItemHandle() 
                            && pTestNode->IsExtension() ) ) {
                pRootNode = pTestNode;
                break;
            }
        }

        // Optimization - If root node, remove all of the result items here.
        if ( pRootNode ) {
            pResultData = GetResultData ();
            ASSERT (pResultData);
            if ( pResultData ) {
                hrLocal = pResultData->DeleteAllRsltItems ();
            }
        } 
    
        // For standalone, we didn't create the root node, so don't delete it.
        // For extension, the parent of the root node is passed so the root node gets deleted.
        hrLocal = m_ipConsoleNameSpace->DeleteItem ( hParent, FALSE );

        if ( pRootNode ) {
            // Close all queries and the connection to the log service.
            m_listpRootNode.RemoveAt( m_listpRootNode.Find ( pRootNode ) );
            pRootNode->Destroy();
            delete pRootNode;
            hr = S_OK;
        } else {
            // Close all queries and the connection to the log service for this service type.
            pDO = ExtractOwnDataObject( pDataObject );

            if ( NULL != pDO ) {
                if ( NULL != pDO->GetCookie() ) { 

                    if ( COOKIE_IS_COUNTERMAINNODE == pDO->GetCookieType() ) {
                        CSmCounterLogService*   pService = (CSmCounterLogService*)pDO->GetCookie();
                        pService->Close();
                    } else if ( COOKIE_IS_TRACEMAINNODE == pDO->GetCookieType() ) {
                        CSmTraceLogService*   pService = (CSmTraceLogService*)pDO->GetCookie();
                        pService->Close();
                    } else if ( COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() ) {
                        CSmAlertService*   pService = (CSmAlertService*)pDO->GetCookie();
                        pService->Close();
                    } else {
                        ASSERT ( FALSE );
                    }
                }
            } else {
                hr = E_UNEXPECTED;
            }
        }
    }

    return hr;
}

BOOL CComponentData::IsMyComputerNodetype (GUID& refguid)
{
    return (::IsEqualGUID (refguid, g_guidSystemTools));
}

BOOL
CComponentData::IsScopeNode
(
    MMC_COOKIE mmcCookie
)
{
    BOOL bIsScopeNode = FALSE;
    CSmRootNode*    pRootNode = NULL;
    POSITION        Pos = m_listpRootNode.GetHeadPosition();

    while ( Pos != NULL) {
        pRootNode = m_listpRootNode.GetNext( Pos );
        if ( mmcCookie == (MMC_COOKIE)pRootNode ) {
            bIsScopeNode = TRUE;
            break;
        }
        if ( !bIsScopeNode ) {
            bIsScopeNode = IsLogService ( mmcCookie );
        }
    }
    return bIsScopeNode;
}

BOOL
CComponentData::IsLogService (
    MMC_COOKIE mmcCookie )
{
    CSmRootNode*    pRootNode = NULL;
    POSITION        Pos = m_listpRootNode.GetHeadPosition();
    BOOL            bReturn = FALSE;

    while ( Pos != NULL) {
        pRootNode = m_listpRootNode.GetNext( Pos );
        bReturn = pRootNode->IsLogService( mmcCookie );
        if ( bReturn )
            break;
    }

    return bReturn;
}

BOOL
CComponentData::IsAlertService ( MMC_COOKIE mmcCookie)
{
    CSmRootNode*    pRootNode = NULL;
    POSITION        Pos = m_listpRootNode.GetHeadPosition();
    BOOL            bReturn = FALSE;

    while ( Pos != NULL) {
        pRootNode = m_listpRootNode.GetNext( Pos );
        bReturn = pRootNode->IsAlertService( mmcCookie );
        if ( bReturn )
            break;
    }

    return bReturn;
}

BOOL
CComponentData::IsLogQuery ( 
    MMC_COOKIE  mmcCookie )
{
    CSmRootNode*    pRootNode = NULL;
    POSITION        Pos = m_listpRootNode.GetHeadPosition();
    BOOL            bReturn = FALSE;

    while ( Pos != NULL ) {
        pRootNode = m_listpRootNode.GetNext ( Pos );
        bReturn = pRootNode->IsLogQuery ( mmcCookie );
        if ( bReturn )
            break;
    }

    return bReturn;
}

BOOL
CComponentData::IsRunningQuery (
    PSLQUERY pQuery )
{
    return pQuery->IsRunning();
}

///////////////////////////////////////////////////////////////////////////////
/// IExtendPropertySheet

STDMETHODIMP 
CComponentData::QueryPagesFor ( LPDATAOBJECT pDataObject )
{
    HRESULT hr = S_FALSE;
    CDataObject *pDO = NULL;

    if (NULL == pDataObject) {
        ASSERT(FALSE);
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject( pDataObject );

        if ( NULL == pDO ) {
            ASSERT(FALSE);
            hr = E_UNEXPECTED;
        } else {
            if ( NULL != pDO->GetCookie() ) {
                hr = m_ipPrshtProvider->FindPropertySheet((MMC_COOKIE)pDO->GetCookie(), NULL, pDataObject);
            } else {
                hr = S_FALSE;
            }
        }
    }

    return hr;
    
} // CComponentData::QueryPagesFor()

//---------------------------------------------------------------------------
//  Implement some context menu items
//
STDMETHODIMP
CComponentData::AddMenuItems (
    LPDATAOBJECT           pDataObject,         // [in] Points to data object
    LPCONTEXTMENUCALLBACK  pCallbackUnknown,    // [in] Points to callback function
    long*                  pInsertionAllowed )  // [in,out] Insertion flags
{
    HRESULT hr = S_OK;
    BOOL    bIsLogSvc = FALSE;
    CDataObject* pDO = NULL;
    PSLSVC  pLogService;
    static CONTEXTMENUITEM ctxMenu[1];
    CString strTemp1, strTemp2, strTemp3, strTemp4;

    ResourceStateManager    rsm;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else if ( NULL == pCallbackUnknown ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject( pDataObject );
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    // Only add menu items when we are allowed to.

    if ( SUCCEEDED ( hr ) ) {
        if ( ( COOKIE_IS_COUNTERMAINNODE == pDO->GetCookieType() )
                || ( COOKIE_IS_TRACEMAINNODE == pDO->GetCookieType() )
                || ( COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() ) )
        {
            if( CCM_INSERTIONALLOWED_NEW & *pInsertionAllowed ) {
                // Add "New Query..." context menu item
                bIsLogSvc = IsLogService ( pDO->GetCookie() );
                if (bIsLogSvc) {
                    pLogService = (PSLSVC)pDO->GetCookie();

                    ZeroMemory ( &ctxMenu, sizeof ctxMenu );
                
                    MFC_TRY

                        if ( NULL != pLogService->CastToCounterLogService() ) {
                            strTemp1.LoadString( IDS_MMC_MENU_NEW_PERF_LOG );
                            strTemp2.LoadString( IDS_MMC_STATUS_NEW_PERF_LOG );
                            strTemp3.LoadString( IDS_MMC_MENU_PERF_LOG_FROM );
                            strTemp4.LoadString( IDS_MMC_STATUS_PERF_LOG_FROM );
                        } else if ( pLogService->CastToTraceLogService() ) {
                            strTemp1.LoadString( IDS_MMC_MENU_NEW_TRACE_LOG );
                            strTemp2.LoadString( IDS_MMC_STATUS_NEW_TRACE_LOG );
                            strTemp3.LoadString( IDS_MMC_MENU_TRACE_LOG_FROM );
                            strTemp4.LoadString( IDS_MMC_STATUS_TRACE_LOG_FROM );
                        } else if ( pLogService->CastToAlertService() ) {
                            strTemp1.LoadString( IDS_MMC_MENU_NEW_ALERT );
                            strTemp2.LoadString( IDS_MMC_STATUS_NEW_ALERT );
                            strTemp3.LoadString( IDS_MMC_MENU_ALERT_FROM );
                            strTemp4.LoadString( IDS_MMC_STATUS_ALERT_FROM );

                        } else {
                            ::MessageBox( NULL,
                                _T("Bad Cookie"),
                                _T("CComponent::AddMenuItems"),
                                MB_OK | MB_ICONERROR
                                );
                            hr = E_OUTOFMEMORY;
                        }
                    MFC_CATCH_HR_RETURN

                    if ( SUCCEEDED( hr ) ) {
                        // Create new...
                        ctxMenu[0].strName = T2OLE(const_cast<LPTSTR>((LPCTSTR)strTemp1));
                        ctxMenu[0].strStatusBarText = T2OLE(const_cast<LPTSTR>((LPCTSTR)strTemp2));
                        ctxMenu[0].lCommandID        = IDM_NEW_QUERY;
                        ctxMenu[0].lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                        ctxMenu[0].fFlags            = MF_ENABLED;
                        ctxMenu[0].fSpecialFlags     = 0;

                        hr = pCallbackUnknown->AddItem( &ctxMenu[0] );

                        if ( SUCCEEDED(hr) ) {
                            // Create from...
                            ctxMenu[0].strName = T2OLE(const_cast<LPTSTR>((LPCTSTR)strTemp3));
                            ctxMenu[0].strStatusBarText = T2OLE(const_cast<LPTSTR>((LPCTSTR)strTemp4));
                            ctxMenu[0].lCommandID        = IDM_NEW_QUERY_FROM;
                            ctxMenu[0].lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                            ctxMenu[0].fFlags            = MF_ENABLED;
                            ctxMenu[0].fSpecialFlags     = 0;

                            hr = pCallbackUnknown->AddItem( &ctxMenu[0] );
                        }
                    }
                }        
            }
        }
    }
    return hr;
} // end AddMenuItems()

//---------------------------------------------------------------------------
//  Implement the command method so we can handle notifications
//  from our Context menu extensions.  
//
STDMETHODIMP
CComponentData::Command (
    long nCommandID,           // [in] Command to handle
    LPDATAOBJECT pDataObject   // [in] Points to data object, pass through
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;

    switch( nCommandID ) {

    case IDM_NEW_QUERY:
        CreateNewLogQuery( pDataObject );
        break;

    case IDM_NEW_QUERY_FROM:
        CreateLogQueryFrom( pDataObject );
        break;

    default:
        hr = S_FALSE;
    }

    return hr;

} // end Command()

STDMETHODIMP 
CComponentData::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK pCallBack,
    LONG_PTR /* handle */,      // This handle must be saved in the property 
                                // page object to notify the parent when modified
    LPDATAOBJECT pDataObject)
{
    
    if (NULL == pCallBack || NULL == pDataObject)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }
    return S_FALSE;
    
} // CComponentData::CreatePropertyPages()


LPCTSTR
CComponentData::GetConceptsHTMLHelpFileName()
{
    return CGlobalString::m_cszConceptsHTMLHelpFileName;
}

LPCTSTR
CComponentData::GetSnapinHTMLHelpFileName()
{
    return CGlobalString::m_cszSnapinHTMLHelpFileName;
}

LPCTSTR
CComponentData::GetHTMLHelpTopic()
{
    return CGlobalString::m_cszHTMLHelpTopic;
}

const CString&
CComponentData::GetContextHelpFilePath()
{
    LPTSTR lpszBuffer;
    UINT nLen;
    if ( m_strContextHelpFilePath.IsEmpty() ) {
        MFC_TRY
            if ( m_strWindowsDirectory.IsEmpty() ) {
                lpszBuffer = m_strWindowsDirectory.GetBuffer(2*MAX_PATH);
                nLen = ::GetWindowsDirectory(lpszBuffer, 2*MAX_PATH);
                m_strWindowsDirectory.ReleaseBuffer();
            }
            if ( !m_strWindowsDirectory.IsEmpty() ) 
            {
                m_strContextHelpFilePath = m_strWindowsDirectory + CGlobalString::m_cszContextHelpFileName;
            }
        MFC_CATCH_MINIMUM;
    }    
    
    return m_strContextHelpFilePath;
}

// CComponentData::GetHelpTopic()
HRESULT
CComponentData::GetHelpTopic (
    LPOLESTR* lpCompiledHelpFile )                              
{
    HRESULT hr = E_FAIL;
    LPCWSTR lpszHelpFileName;
    CString strHelpFilePath;
    LPTSTR  lpszBuffer;
    UINT    nLen;
    UINT    nBytes;
    
    if ( NULL == lpCompiledHelpFile) {
        hr = E_POINTER;
    } else {
        *lpCompiledHelpFile = NULL;

        MFC_TRY
            lpszHelpFileName = GetSnapinHTMLHelpFileName();

            if ( NULL == lpszHelpFileName) {
                hr = E_UNEXPECTED;
            } else {
                lpszBuffer = strHelpFilePath.GetBuffer(2*MAX_PATH);
                nLen = ::GetWindowsDirectory(lpszBuffer, 2*MAX_PATH);
                if ( 0 == nLen ) {
                    hr = E_UNEXPECTED;
                } else {
                    wcscpy(&lpszBuffer[nLen], lpszHelpFileName);
                    nBytes = (lstrlen(lpszBuffer)+1) * sizeof(WCHAR);
                    *lpCompiledHelpFile = (LPOLESTR)::CoTaskMemAlloc(nBytes);
                    if ( NULL == *lpCompiledHelpFile ) {
                        hr = E_OUTOFMEMORY;
                    } else {
                        memcpy(*lpCompiledHelpFile, (LPCWSTR)strHelpFilePath, nBytes);
                        hr = S_OK;
                    }
                }
                strHelpFilePath.ReleaseBuffer();
            }
        MFC_CATCH_HR
    }
    return hr;
}

LPRESULTDATA 
CComponentData::GetResultData()
{
    if ( !m_ipResultData )
    {
        if ( m_ipConsole )
        {
            HRESULT hResult = m_ipConsole->QueryInterface(IID_IResultData, (void**)&m_ipResultData);
            ASSERT (SUCCEEDED (hResult));
        }
    }
    
    return m_ipResultData;
}

HRESULT
CComponentData::ProcessCommandLine ( CString& rstrMachineName )
{
    HRESULT hr = S_OK;
    LPCWSTR pszNext = NULL;
    LPWSTR* pszArgList = NULL;
    INT     iNumArgs;
    INT     iArgIndex;
    LPWSTR  pszNextArg = NULL;
    LPWSTR  pszThisArg = NULL;
    TCHAR   szTemp[MAX_PATH];
    LPTSTR  pszToken = NULL;
    TCHAR   szFileName[MAX_PATH];
    CString strSettings;
    CString strWmi;

    // Process only for local node.
    if ( rstrMachineName.IsEmpty() ) {
        pszNext = GetCommandLineW();
        pszArgList = CommandLineToArgvW ( pszNext, &iNumArgs );
    }

    if ( NULL != pszArgList ) {

        // This code assumes that UNICODE is defined.  That is, TCHAR is the 
        // same size as WCHAR.
        // Todo:  Define _T constants as L constants
        // Todo:  Filename, etc. as WCHAR
        ASSERT ( sizeof(TCHAR) == sizeof (WCHAR) );
        
        
        for ( iArgIndex = 0; iArgIndex < iNumArgs; iArgIndex++ ) {
            pszNextArg = (LPWSTR)pszArgList[iArgIndex];
            pszThisArg = pszNextArg;

            while (pszThisArg ) {
                if (0 == *pszThisArg) {
                    break;
                }

                if ( *pszThisArg++ == _T('/') ) {  // argument found

                    lstrcpyn ( szTemp, pszThisArg, min(lstrlen(pszThisArg)+1, MAX_PATH ) );
                
                    pszToken = _tcstok ( szTemp, _T("/ =\"") );

                    MFC_TRY
                        strSettings.LoadString( IDS_CMDARG_SYSMONLOG_SETTINGS );
                        strWmi.LoadString(IDS_CMDARG_SYSMONLOG_WMI);
                    MFC_CATCH_MINIMUM;

                    if ( !strSettings.IsEmpty() && !strWmi.IsEmpty() ) {
                        if ( 0 == strSettings.CompareNoCase ( pszToken ) ) {
                    
                            // Strip the initial non-token characters for string comparison.
                            pszThisArg = _tcsspnp ( pszNextArg, _T("/ =\"") );

                            if ( NULL != pszThisArg ) {
                                if ( 0 == strSettings.CompareNoCase ( pszThisArg ) ) {
                                    // Get the next argument (the file name)
                                    iArgIndex++;
                                    pszNextArg = (LPWSTR)pszArgList[iArgIndex];
                                    pszThisArg = pszNextArg;                                                
                                } else {

                                    // File was created by Windows 2000 perfmon5.exe, 
                                    // so file name is part of the arg.
                                    ZeroMemory ( szFileName, sizeof ( szFileName ) );
                                    pszThisArg += strSettings.GetLength();
                                    lstrcpyn ( szFileName, pszThisArg, min(lstrlen(pszThisArg)+1, MAX_PATH ) );                
                                    pszThisArg = _tcstok ( szFileName, _T("=\"") );
                                }
                                hr = LoadFromFile( pszThisArg );
                            }                    
                        } else if ( 0 == strWmi.CompareNoCase ( pszToken ) ) {
                            g_dwRealTimeQuery = DATA_SOURCE_WBEM;
                        }
                    }
                }
            }
        }
    }

    if ( NULL != pszArgList ) {
        GlobalFree ( pszArgList );
    }

    return hr;
}

HRESULT 
CComponentData::LoadFromFile ( LPTSTR  pszFileName )
{
    HRESULT         hr = S_OK;
    TCHAR           szLocalName [MAX_PATH];
    LPTSTR          pFileNameStart;
    HANDLE          hFindFile;
    WIN32_FIND_DATA FindFileInfo;
    INT             iNameOffset;

    lstrcpy ( szLocalName, pszFileName );
    pFileNameStart = ExtractFileName (szLocalName) ;
    iNameOffset = (INT)(pFileNameStart - szLocalName);

    // convert short filename to long NTFS filename if necessary
    hFindFile = FindFirstFile ( szLocalName, &FindFileInfo) ;
    if (hFindFile && hFindFile != INVALID_HANDLE_VALUE) {
       HANDLE hOpenFile;

        // append the file name back to the path name
        lstrcpy (&szLocalName[iNameOffset], FindFileInfo.cFileName) ;
        FindClose (hFindFile) ;
        // Open the file
        hOpenFile = CreateFile (
                        szLocalName, 
                        GENERIC_READ,
                        0,                  // Not shared
                        NULL,               // Security attributes
                        OPEN_EXISTING,     
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

        if ( hOpenFile && hOpenFile != INVALID_HANDLE_VALUE ) {
            DWORD dwFileSize;
            DWORD dwFileSizeHigh;
            LPTSTR pszFirstData = NULL;
            HRESULT hr = S_OK;
        
            // Read the file contents into a memory buffer.
            dwFileSize = GetFileSize ( hOpenFile, &dwFileSizeHigh );

            ASSERT ( 0 == dwFileSizeHigh );

            MFC_TRY
            pszFirstData = new TCHAR[(dwFileSize + sizeof(TCHAR))/sizeof(TCHAR)];
            MFC_CATCH_HR    

            if ( NULL != pszFirstData ) {
                BOOL bAtLeastOneSysmonObjectRead = FALSE;

                if ( FileRead ( hOpenFile, pszFirstData, dwFileSize ) ) {
                    LPTSTR pszCurrentObject = NULL;
                    LPTSTR pszNextObject = NULL;
                
                    pszCurrentObject = pszFirstData;

                    while ( SUCCEEDED ( hr ) && NULL != pszCurrentObject ) {
                    
                        CImpIPropertyBag* pPropBag = NULL;

                        // Write contents to a property bag
                        MFC_TRY
                            pPropBag = new CImpIPropertyBag;
                        MFC_CATCH_HR

                        if ( NULL != pPropBag ) {
                            DWORD dwStatus = pPropBag->LoadData( pszCurrentObject, &pszNextObject );
                            hr = HRESULT_FROM_WIN32( dwStatus );

                            if ( SUCCEEDED ( hr ) ) {
                                PSLSVC  pSvc = NULL;            
                                PSLQUERY    pQuery = NULL;
                                DWORD   dwLogType;
                                LPTSTR  pszQueryName = NULL;
                                DWORD   dwBufSize = 0;
                                CSmRootNode* pRoot = NULL;
                                CString strQueryName;
                                
                                bAtLeastOneSysmonObjectRead = TRUE;
                                
                                // Get root node
                                ASSERT ( !m_listpRootNode.IsEmpty() );
                                    
                                pRoot = m_listpRootNode.GetHead();

                                // Determine log type from property bag.  Default to counter log.
                                hr = CSmLogQuery::DwordFromPropertyBag ( 
                                        pPropBag, 
                                        NULL, 
                                        IDS_HTML_LOG_TYPE, 
                                        SLQ_COUNTER_LOG, 
                                        dwLogType);

                                // Get service pointer and log/alert name based on log type.
                                if ( SLQ_ALERT == dwLogType ) {
                                    pSvc = pRoot->GetAlertService();
                                    
                                    hr = CSmLogQuery::StringFromPropertyBag (
                                            pPropBag,
                                            NULL,
                                            IDS_HTML_ALERT_NAME,
                                            _T(""),
                                            &pszQueryName,
                                            &dwBufSize );

                                    if ( NULL == pszQueryName ) {
                                        hr = CSmLogQuery::StringFromPropertyBag (
                                                pPropBag,
                                                NULL,
                                                IDS_HTML_LOG_NAME,
                                                _T(""),
                                                &pszQueryName,
                                                &dwBufSize );
                                    }
                                } else {
                                    if ( SLQ_TRACE_LOG == dwLogType ) {
                                       pSvc = pRoot->GetTraceLogService();
                                    } else {
                                        // Default to counter log service
                                        pSvc = pRoot->GetCounterLogService();
                                    }

                                    hr = CSmLogQuery::StringFromPropertyBag (
                                            pPropBag,
                                            NULL,
                                            IDS_HTML_LOG_NAME,
                                            _T(""),
                                            &pszQueryName,
                                            &dwBufSize );

                                    if ( NULL == pszQueryName ) {
                                        hr = CSmLogQuery::StringFromPropertyBag (
                                                pPropBag,
                                                NULL,
                                                IDS_HTML_ALERT_NAME,
                                                _T(""),
                                                &pszQueryName,
                                                &dwBufSize );
                                    }
                                }

                                strQueryName = pszQueryName;
                                delete pszQueryName;
                                
                                while ( NULL == pQuery ) {                                    
                                    
                                    if ( !strQueryName.IsEmpty() ) {
                                        pQuery = pSvc->CreateQuery ( strQueryName );
                    
                                        if ( NULL != pQuery ) {
                                            BOOL bRegistryUpdated;
                                            pQuery->LoadFromPropertyBag ( pPropBag, NULL );
                                            dwStatus = pQuery->UpdateService ( bRegistryUpdated );
                                            break;
                                        } else {
                                            dwStatus = GetLastError();
                                        }

                                        if ( ERROR_SUCCESS != dwStatus ) {
                                            INT iResult;
                                            CString strMessage;
                                            CString csTitle;
                                            BOOL bBreakImmediately = TRUE;

                                            if ( SMCFG_NO_MODIFY_ACCESS == dwStatus ) {
                                                CString strMachineName;

                                                strMachineName = pSvc->GetMachineDisplayName ();

                                                FormatSmLogCfgMessage (
                                                    strMessage,
                                                    m_hModule,
                                                    SMCFG_NO_MODIFY_ACCESS,
                                                    (LPCTSTR)strMachineName);

                                            } else if ( SMCFG_DUP_QUERY_NAME == dwStatus ) {
                                                FormatSmLogCfgMessage (
                                                    strMessage,
                                                    m_hModule,
                                                    SMCFG_DUP_QUERY_NAME,
                                                    (LPCTSTR)strQueryName);
                                                bBreakImmediately = FALSE;
                                            } else {
                                                CString strSysMessage;

                                                FormatSmLogCfgMessage (
                                                    strMessage,
                                                    m_hModule,
                                                    SMCFG_SYSTEM_MESSAGE,
                                                    (LPCTSTR)strQueryName);

                                                FormatMessage (
                                                    FORMAT_MESSAGE_FROM_SYSTEM,
                                                    NULL,
                                                    dwStatus,
                                                    0,
                                                    strSysMessage.GetBufferSetLength( MAX_PATH ),
                                                    MAX_PATH,
                                                    NULL );

                                                strSysMessage.ReleaseBuffer();

                                                if ( strSysMessage.IsEmpty() ) {
                                                    strSysMessage.Format ( _T("0x%08lX"), dwStatus );   
                                                }

                                                strMessage += strSysMessage;
                                            }

                                            csTitle.LoadString ( IDS_PROJNAME );

                                            hr = m_ipConsole->MessageBox(
                                                    (LPCWSTR)strMessage,
                                                    (LPCWSTR)csTitle,
                                                    MB_OK | MB_ICONERROR,
                                                    &iResult
                                                    );

                                            if ( bBreakImmediately ) {
                                                break;
                                            }
                                        }
                                    }

                                    if ( NULL == pQuery ) { 
                                        CNewQueryDlg    cNewDlg(NULL, ((SLQ_ALERT == dwLogType) ? FALSE : TRUE));
                                        AFX_MANAGE_STATE(AfxGetStaticModuleState());
                                        
                                        cNewDlg.SetContextHelpFilePath( GetContextHelpFilePath() );
                                        cNewDlg.m_strName = strQueryName;
                                        if ( IDOK == cNewDlg.DoModal() ) {
                                            strQueryName = cNewDlg.m_strName;
                                        } else {
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        pszCurrentObject = pszNextObject;
                        delete pPropBag;
                    } // end while
                }        
                delete pszFirstData;
                // Message to the user if no queries Read.
                if ( !bAtLeastOneSysmonObjectRead ) {
                    CString strMessage;
                    CString strTitle;
                    INT iResult;

                    FormatSmLogCfgMessage ( 
                        strMessage,
                        m_hModule, 
                        SMCFG_NO_HTML_SYSMON_OBJECT );

                    strTitle.LoadString ( IDS_PROJNAME );

                    m_ipConsole->MessageBox ( 
                        strMessage, 
                        strTitle, 
                        MB_OK  | MB_ICONERROR,
                        &iResult );
                }
            } else {
                hr = E_OUTOFMEMORY;
            }

            CloseHandle ( hOpenFile );
        }
    }
    return hr;
}

HRESULT 
CComponentData::InitPropertySheet (
    CSmLogQuery* pQuery,
    MMC_COOKIE mmcCookie,
    LONG_PTR handle,
    CPropertySheet& rcpsMain ) 
{ 
    CCountersProperty   *pPage1 = NULL;
    CFilesProperty      *pPage2 = NULL;
    CScheduleProperty   *pPage3 = NULL;
    CTraceProperty      *pPage4 = NULL;
    CProvidersProperty  *pPage5 = NULL;
    CAlertActionProp    *pPage6 = NULL;
    CAlertGenProp       *pPage7 = NULL;
    HRESULT hr = NOERROR;

    ASSERT ( NULL != pQuery );

    rcpsMain.SetTitle (pQuery->GetLogName());

    MFC_TRY
        if ( SLQ_ALERT == pQuery->GetLogType() ) {
            pPage7 = new CAlertGenProp (mmcCookie, handle);
            pPage6 = new CAlertActionProp (mmcCookie, handle);
            pPage3 = new CScheduleProperty (mmcCookie, handle, NULL);
            if ( NULL != pPage7 ) {
                pPage7->SetContextHelpFilePath( GetContextHelpFilePath() );
                rcpsMain.AddPage (pPage7);
            }
            if ( NULL != pPage6 ) {
                pPage6->SetContextHelpFilePath( GetContextHelpFilePath() );
                rcpsMain.AddPage (pPage6);
            }
            if ( NULL != pPage3 ) {
                pPage3->SetContextHelpFilePath( GetContextHelpFilePath() );
                rcpsMain.AddPage (pPage3);
            }
        } else {
            if ( SLQ_TRACE_LOG == pQuery->GetLogType() ) {
                CWaitCursor     WaitCursor;

                // Connect to the server before creating the dialog 
                // so that the wait cursor can be used consistently.                    
                // Sync the providers here so that the WMI calls are consistently
                // from a single thread.
                ASSERT ( NULL != pQuery->CastToTraceLogQuery() );
                hr = (pQuery->CastToTraceLogQuery())->SyncGenProviders();
                
                if ( SUCCEEDED ( hr ) ) {
                    pPage5 = new CProvidersProperty(mmcCookie, handle);
                    if ( NULL != pPage5 )
                        pPage5->SetContextHelpFilePath( GetContextHelpFilePath() );
                        rcpsMain.AddPage (pPage5);
                } else {
                    CString strMachineName;
                    CString strLogName;

                    pQuery->GetMachineDisplayName( strMachineName );
                    strLogName = pQuery->GetLogName();
                    
                    HandleTraceConnectError ( 
                        hr, 
                        strLogName,
                        strMachineName );
                }
            } else {
                pPage1 = new CCountersProperty ( mmcCookie, handle );
                if ( NULL != pPage1 ) {
                    pPage1->SetContextHelpFilePath( GetContextHelpFilePath() );
                    rcpsMain.AddPage (pPage1);
                }
            }
            if ( SUCCEEDED ( hr ) ) {
                pPage2 = new CFilesProperty(mmcCookie, handle);
                if ( NULL != pPage2 ) {
                    pPage2->SetContextHelpFilePath( GetContextHelpFilePath() );
                    rcpsMain.AddPage (pPage2);
                }

                pPage3 = new CScheduleProperty(mmcCookie, handle, NULL);
                if ( NULL != pPage3 ) {
                    pPage3->SetContextHelpFilePath( GetContextHelpFilePath() );
                    rcpsMain.AddPage (pPage3);
                }
                if ( SLQ_TRACE_LOG == pQuery->GetLogType() ) {
                    pPage4 = new CTraceProperty(mmcCookie, handle);
                    if ( NULL != pPage4 ) {
                        pPage4->SetContextHelpFilePath( GetContextHelpFilePath() );
                        rcpsMain.AddPage (pPage4);
                    }
                }
            }
        }
    MFC_CATCH_HR

    return hr;
} // End InitPropertySheet

void 
CComponentData::HandleTraceConnectError ( 
    HRESULT& rhr, 
    CString& rstrLogName,
    CString& rstrMachineName )
{
    ASSERT ( FAILED ( rhr ) );
    
    if ( FAILED ( rhr ) ) {
        
        CString strMessage;
        CString strSysMessage;
        INT     iResult;

        FormatSmLogCfgMessage ( 
            strMessage,
            m_hModule, 
            SMCFG_UNABLE_OPEN_TRACESVC_DLG, 
            rstrMachineName,
            rstrLogName );

        FormatMessage ( 
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL, 
            rhr,
            0,
            strSysMessage.GetBufferSetLength( MAX_PATH ),
            MAX_PATH,
            NULL );

        strSysMessage.ReleaseBuffer();

        if ( strSysMessage.IsEmpty() ) {
            strSysMessage.Format ( _T("0x%08lX"), rhr );
        }

        strMessage += strSysMessage;

        m_ipConsole->MessageBox( 
            strMessage,
            rstrLogName,
            MB_OK | MB_ICONERROR,
            &iResult);
    }
    return;

}// end HandleTraceConnectError()

HRESULT
CComponentData::NewTypedQuery (
    CSmLogService* pSvc,
    IPropertyBag* pPropBag,
    LPDATAOBJECT pDataObject )  // [in] Points to the data object
{
    HRESULT  hr = S_OK;
    LPTSTR  szQueryName = NULL;
    DWORD   dwBufSize = 0;
    ResourceStateManager    rsm;
    CNewQueryDlg    cNewDlg(NULL, (((CSmNode*)pSvc)->CastToAlertService() ? FALSE : TRUE));
    CThemeContextActivator activator;

    ASSERT ( NULL != pSvc );

    if ( NULL != pPropBag ) {
        if ( NULL != ((CSmNode*)pSvc)->CastToAlertService() ) {
            hr = CSmLogQuery::StringFromPropertyBag (
                    pPropBag,
                    NULL,
                    IDS_HTML_ALERT_NAME,
                    _T(""),
                    &szQueryName,
                    &dwBufSize );

            if ( NULL == szQueryName ) {
                hr = CSmLogQuery::StringFromPropertyBag (
                        pPropBag,
                        NULL,
                        IDS_HTML_LOG_NAME,
                        _T(""),
                        &szQueryName,
                        &dwBufSize );
            }
        } else {
            hr = CSmLogQuery::StringFromPropertyBag (
                    pPropBag,
                    NULL,
                    IDS_HTML_LOG_NAME,
                    _T(""),
                    &szQueryName,
                    &dwBufSize );

            if ( NULL == szQueryName ) {
                hr = CSmLogQuery::StringFromPropertyBag (
                        pPropBag,
                        NULL,
                        IDS_HTML_ALERT_NAME,
                        _T(""),
                        &szQueryName,
                        &dwBufSize );
            }
        }
    }
    cNewDlg.SetContextHelpFilePath( GetContextHelpFilePath() );
    cNewDlg.m_strName = szQueryName;

    // Loop until the user hits Cancel or CreateQuery fails.
       
    while ( IDOK == cNewDlg.DoModal() ) {
        PSLQUERY pQuery;

        pQuery = pSvc->CreateQuery ( cNewDlg.m_strName );

        if ( NULL != pQuery ) {
            MMC_COOKIE  mmcQueryCookie = (MMC_COOKIE)pQuery;
            LONG_PTR    handle = NULL;
            INT         iPageIndex;
            CPropertySheet  cpsMain;

            // If property bag provided, override defaults with the provided properties.
            if ( NULL != pPropBag ) {
                hr = pQuery->LoadFromPropertyBag ( pPropBag, NULL );
            }

            if ( FAILED(hr) ) {
                hr = S_OK;
            }

            // now show property pages to modify the new query

            hr = InitPropertySheet ( pQuery, mmcQueryCookie, handle, cpsMain );

            if ( SUCCEEDED(hr) ) {
                cpsMain.DoModal();
            }

            if ( pQuery->IsFirstModification() ) {
                m_ipConsole->UpdateAllViews ( pDataObject, 0, eSmHintNewQuery );
            } else {
                // Delete query if newly created and OnApply was never called.
                pSvc->DeleteQuery ( pQuery );
            }

            for (iPageIndex = cpsMain.GetPageCount() - 1; iPageIndex >= 0; iPageIndex-- ) {
                delete cpsMain.GetPage( iPageIndex );
            }

            break;
        } else {
            INT iResult;
            CString strMessage;
            CString csTitle;
            DWORD dwStatus;
            BOOL bBreakImmediately = TRUE;

            dwStatus = GetLastError();

            if ( SMCFG_NO_MODIFY_ACCESS == dwStatus ) {
                CString strMachineName;

                strMachineName = pSvc->GetMachineDisplayName ();

                FormatSmLogCfgMessage (
                    strMessage,
                    m_hModule,
                    SMCFG_NO_MODIFY_ACCESS,
                    (LPCTSTR)strMachineName);

            } else if ( SMCFG_DUP_QUERY_NAME == dwStatus ) {
                FormatSmLogCfgMessage (
                    strMessage,
                    m_hModule,
                    SMCFG_DUP_QUERY_NAME,
                    (LPCTSTR)cNewDlg.m_strName);
                bBreakImmediately = FALSE;
            } else {

                FormatMessage (
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    dwStatus,
                    0,
                    strMessage.GetBufferSetLength( MAX_PATH ),
                    MAX_PATH,
                    NULL );

                strMessage.ReleaseBuffer();

                if ( strMessage.IsEmpty() ) {
                    strMessage.Format ( _T("0x%08lX"), dwStatus );   
                }
            }

            csTitle.LoadString ( IDS_PROJNAME );

            hr = m_ipConsole->MessageBox(
                    (LPCWSTR)strMessage,
                    (LPCWSTR)csTitle,
                    MB_OK | MB_ICONERROR,
                    &iResult
                    );

            if ( bBreakImmediately ) {
                break;
            }
        }
    }

    delete szQueryName;
    return hr;
}

HRESULT
CComponentData::CreateNewLogQuery (
    LPDATAOBJECT pDataObject,  // [in] Points to the data object
    IPropertyBag* pPropBag )
{
    HRESULT         hr = S_OK;
    CDataObject*    pDO = NULL;
    MMC_COOKIE      mmcSvcCookie;
    BOOL            bIsLogSvc;
    PSLSVC          pLogService;
    ResourceStateManager    rsm;

    ASSERT( NULL != GetResultData() );

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject( pDataObject );
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }
    
    if ( SUCCEEDED ( hr ) ) {
        // If this is the root node, don't need to do anything
        if( COOKIE_IS_ROOTNODE == pDO->GetCookieType() ) {
            hr = S_FALSE;
        } else {

            // Just make sure we are where we think we are
            ASSERT ( COOKIE_IS_COUNTERMAINNODE == pDO->GetCookieType()
                    || COOKIE_IS_TRACEMAINNODE == pDO->GetCookieType()
                    || COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() );

            mmcSvcCookie = (MMC_COOKIE)pDO->GetCookie();
            bIsLogSvc = IsLogService (mmcSvcCookie);

            if (bIsLogSvc) {        
                pLogService = (PSLSVC)mmcSvcCookie;
                hr = NewTypedQuery ( pLogService, pPropBag, pDataObject );
            }

            hr = S_OK;
        }
    }

    return hr;

} // end CreateNewLogQuery()

HRESULT
CComponentData::CreateLogQueryFrom (
    LPDATAOBJECT pDataObject )  // [in] Points to the data object
{
    HRESULT         hr = S_OK;
    INT_PTR         iPtrResult = IDCANCEL;
    INT             iResult = IDCANCEL;
    CDataObject*    pDO = NULL;
    HWND            hwndMain;
    CString         strFileExtension;
    CString         strFileFilter;
    HANDLE          hOpenFile;
    TCHAR           szInitialDir[MAX_PATH];
    DWORD           dwFileSize;
    DWORD           dwFileSizeHigh;
    LPTSTR          pszData = NULL;
    CString         strMessage;
    CString         strTitle;
    CImpIPropertyBag* pPropBag = NULL;
    DWORD           dwStatus;
    DWORD           dwLogType;
    CLogWarnd       LogWarnd;
    DWORD           dwCookieType;
    ResourceStateManager    rsm;

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject( pDataObject );
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    if ( SUCCEEDED ( hr ) ) {

        if ( IsLogService ( pDO->GetCookie() ) ) {

            // Find file to create from.
            MFC_TRY
                strFileExtension.LoadString ( IDS_HTML_EXTENSION );
                strFileFilter.LoadString ( IDS_HTML_FILE );
            MFC_CATCH_HR

            strFileFilter.Replace ( _T('|'), _T('\0') );

            hr = m_ipConsole->GetMainWindow( &hwndMain );

            if ( SUCCEEDED(hr) ) {

                OPENFILENAME ofn;
                BOOL bResult;
                TCHAR szFileName[MAX_PATH];
                
                ZeroMemory( szFileName, MAX_PATH*sizeof(TCHAR) );
                ZeroMemory( &ofn, sizeof( OPENFILENAME ) );

                ofn.lStructSize = sizeof(OPENFILENAME);
                ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
                ofn.lpstrFile = szFileName;
                ofn.nMaxFile = MAX_PATH;
                ofn.lpstrDefExt = (LPCTSTR)strFileExtension;
                ofn.lpstrFilter = strFileFilter;
                ofn.hwndOwner = hwndMain;
                ofn.hInstance = m_hModule;
                if ( SUCCEEDED ( SHGetFolderPathW ( NULL, CSIDL_PERSONAL, NULL, 0, szInitialDir ) ) ) {
                    ofn.lpstrInitialDir = szInitialDir;
                }

                bResult = GetOpenFileName( &ofn );

                if ( bResult ) {

                    // Open the file to find the query name.
                    hOpenFile =  CreateFile (
                                ofn.lpstrFile,
                                GENERIC_READ,
                                0,              // Not shared
                                NULL,           // Security attributes
                                OPEN_EXISTING,  //
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );

                    if ( hOpenFile && INVALID_HANDLE_VALUE != hOpenFile ) {

                        // Create a property bag and load it.  Use the existing query
                        // name as the default to ask the user for a new query name.
                        // New query name is required if the current name exists in the registry.

                        // Read the file contents into a memory buffer.
                        dwFileSize = GetFileSize ( hOpenFile, &dwFileSizeHigh );

                        ASSERT ( 0 == dwFileSizeHigh );

                        MFC_TRY
                            pszData = new TCHAR[(dwFileSize + sizeof(TCHAR))/sizeof(TCHAR)];
                        MFC_CATCH_HR    

                        if ( NULL != pszData ) {
                            if ( FileRead ( hOpenFile, pszData, dwFileSize ) ) {

                                // Read contents from a property bag
                                MFC_TRY
                                    pPropBag = new CImpIPropertyBag;
                                MFC_CATCH_HR

                                if ( NULL != pPropBag ) {
                                    MFC_TRY
                                        strTitle.LoadString ( IDS_PROJNAME );
                                    MFC_CATCH_HR
                                    
                                    dwStatus = pPropBag->LoadData( pszData );

                                    hr = HRESULT_FROM_WIN32( dwStatus );
                                    if ( SUCCEEDED ( hr ) ) {
                    
                                        //get the log type from the  pPropBag and compare it with service(cookie) type
                                    
                                        // Determine log type from property bag. Default to -1  SMONCTRL_LOG
                                  
                                        hr = CSmLogQuery::DwordFromPropertyBag ( 
                                            pPropBag, 
                                            NULL, 
                                            IDS_HTML_LOG_TYPE, 
                                            SMONCTRL_LOG, //indicates tha it's a smonctrl log
                                            dwLogType);
                                    
                                        if (SUCCEEDED (hr) ){
                                            dwCookieType = (DWORD)pDO->GetCookieType();
                                            switch(dwCookieType){
                                            
                                                case COOKIE_IS_COUNTERMAINNODE:
                                               
                                                    if (dwLogType != SLQ_COUNTER_LOG ){
                                                      //Error
                                                      LogWarnd.m_ErrorMsg = ID_ERROR_COUNTER_LOG;
                                                      hr = S_FALSE;
                                                    }
                                                    break;
                                            
                                                case COOKIE_IS_TRACEMAINNODE:
                                               
                                                    if (dwLogType != SLQ_TRACE_LOG ){
                                                     //Error
                                                        LogWarnd.m_ErrorMsg = ID_ERROR_TRACE_LOG;
                                                        hr = S_FALSE;
                                                    }
                                                    break;
                                            
                                                case COOKIE_IS_ALERTMAINNODE:

                                                   if (dwLogType != SLQ_ALERT){
                                                     //Error
                                                     LogWarnd.m_ErrorMsg = ID_ERROR_ALERT_LOG;
                                                     hr = S_FALSE;
                                                   }
                                                   break;

                                            
                                                case SMONCTRL_LOG:
                                                     //Error
                                                     LogWarnd.m_ErrorMsg = ID_ERROR_SMONCTRL_LOG;
                                                     hr = S_FALSE;

                                                   break;
                                            }
                                            if (hr == S_FALSE){
                                                if(dwLogType == SLQ_TRACE_LOG || LogWarnd.m_ErrorMsg == ID_ERROR_TRACE_LOG ){
                                                    MFC_TRY
                                                        strMessage.LoadString(IDS_ERRMSG_TRACE_LOG);
                                                    MFC_CATCH_HR
                                                    m_ipConsole->MessageBox ( 
                                                                 strMessage, 
                                                                 strTitle, 
                                                                 MB_OK  | MB_ICONERROR,
                                                                 &iResult );
                                            
                                                } else {
                                                    LogWarnd.m_dwLogType = dwLogType;
                                                    MFC_TRY
                                                        LogWarnd.m_strContextHelpFile = GetContextHelpFilePath();
                                                        // TODO:  Handle error
                                                    MFC_CATCH_MINIMUM
                                                    if(!LogTypeCheckNoMore(&LogWarnd)){
                                                        LogWarnd.SetTitleString ( strTitle );
                                                        LogWarnd.DoModal();
                                                    }
                                                    CreateNewLogQuery ( pDataObject, pPropBag );
                                                }
                                            }
                                        }
                                    
                                        if ( S_OK == hr ) {
                                              hr = CreateNewLogQuery ( pDataObject, pPropBag );
                                        }
                                    } else {
                                        FormatSmLogCfgMessage ( 
                                            strMessage,
                                            m_hModule, 
                                            SMCFG_NO_HTML_SYSMON_OBJECT );

                                        m_ipConsole->MessageBox ( 
                                            strMessage, 
                                            strTitle, 
                                            MB_OK  | MB_ICONERROR,
                                            &iResult );
                                    }
                                }
                            }
                            delete pszData;
                        }

                        CloseHandle ( hOpenFile );
                    }
                }
            }
        }
    }
    return hr;
} // End CreateLogQueryFrom

BOOL
CComponentData::LogTypeCheckNoMore (
    CLogWarnd* LogWarnd )
{
    
    BOOL bretVal = FALSE;
    long nErr;
    HKEY hKey;
    DWORD dwWarnFlag;
    DWORD dwDataType;
    DWORD dwDataSize;
    DWORD dwDisposition;
    TCHAR RegValName[MAX_PATH];

    switch (LogWarnd->m_dwLogType){
       case SLQ_COUNTER_LOG:
         _stprintf(RegValName, _T("NoWarnCounterLog"));
         break;
          
       case SLQ_ALERT:
         _stprintf(RegValName, _T("NoWarnAlertLog"));
         break;
    }
    
    // check registry setting to see if we need to pop up warning dialog
    nErr = RegOpenKey( 
                HKEY_CURRENT_USER,
                _T("Software\\Microsoft\\PerformanceLogsAndAlerts"),
                &hKey );

    if( nErr != ERROR_SUCCESS ) {
        nErr = RegCreateKeyEx( 
                    HKEY_CURRENT_USER,
                    _T("Software\\Microsoft\\PerformanceLogsAndAlerts"),
                    0,
                    _T("REG_DWORD"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &dwDisposition );
    }

    dwWarnFlag = 0;
    if( nErr == ERROR_SUCCESS ) {

        dwDataSize = sizeof(DWORD);
        nErr = RegQueryValueExW(
                    hKey,
                    RegValName,
                    NULL,
                    &dwDataType,
                    (LPBYTE) &dwWarnFlag,
                    (LPDWORD) &dwDataSize
                    );
        if (ERROR_SUCCESS == nErr ){       
           LogWarnd->m_hKey = hKey;
        }

        if ( (dwDataType != REG_DWORD) || (dwDataSize != sizeof(DWORD)))
            dwWarnFlag = 0;

        if (dwWarnFlag) 
            bretVal = TRUE;
        
        nErr = RegCloseKey( hKey );
        
        if( ERROR_SUCCESS != nErr ){
//          DisplayError( GetLastError(), _T("Close PerfLog user Key Failed")  );
            bretVal =  FALSE;
        }
    }

    return bretVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\ctrsprop.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    ctrsprop.h

Abstract:

    Header file for the counters general property page

--*/

#ifndef _CTRSPROP_H_
#define _CTRSPROP_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "smproppg.h"   // Base class
#include "smcfghlp.h"
// Dialog controls
#define IDD_COUNTERS_PROP               800

#define IDC_CTRS_FILENAME_CAPTION       801
#define IDC_CTRS_LOG_SCHED_TEXT         802
#define IDC_CTRS_SAMPLE_CAPTION         803
#define IDC_CTRS_SAMPLE_INTERVAL_CAPTION 804
#define IDC_CTRS_SAMPLE_UNITS_CAPTION   805
#define IDC_CTRS_FIRST_HELP_CTRL_ID     806     // First control with Help text.
#define IDC_CTRS_COUNTER_LIST           806
#define IDC_CTRS_ADD_OBJ_BTN	        807
#define IDC_CTRS_ADD_BTN                808
#define IDC_CTRS_REMOVE_BTN             809
#define IDC_CTRS_FILENAME_DISPLAY       810
#define IDC_CTRS_SAMPLE_SPIN            811
#define IDC_CTRS_SAMPLE_UNITS_COMBO     812
#define IDC_CTRS_SAMPLE_EDIT            813

#define PDLCNFIG_LISTBOX_STARS_YES  1

class CSmCounterLogQuery;

/////////////////////////////////////////////////////////////////////////////
// CCountersProperty dialog

class CCountersProperty : public CSmPropertyPage
{
    DECLARE_DYNCREATE(CCountersProperty)

// Construction
public:
            CCountersProperty();
            CCountersProperty(MMC_COOKIE mmcCookie, LONG_PTR hConsole);
    virtual ~CCountersProperty();

public:

// Dialog Data
    //{{AFX_DATA(CCountersProperty)
    enum { IDD = IDD_COUNTERS_PROP };
    int     m_nSampleUnits;
    CString m_strFileNameDisplay;
    CString m_strStartDisplay;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CCountersProperty)
public:
protected:
    virtual void OnFinalRelease();
    virtual BOOL OnInitDialog();
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

public:

    // All of these members are Public to be accessed by the callback routine.
    LPWSTR          m_szCounterListBuffer;
    DWORD           m_dwCounterListBufferSize;
    long            m_lCounterListHasStars;
    DWORD           m_dwMaxHorizListExtent;
    
    
    PDH_BROWSE_DLG_CONFIG   m_dlgConfig;

    CSmCounterLogQuery      *m_pCtrLogQuery;    
// Implementation
protected:

    virtual INT GetFirstHelpCtrlId ( void ) 
    { 
        return IDC_CTRS_FIRST_HELP_CTRL_ID; 
    };  // Subclass must override.

    virtual BOOL    IsValidLocalData ();
    
    // Generated message map functions
    //{{AFX_MSG(CCountersProperty)
    afx_msg void OnCtrsAddBtn();
    afx_msg void OnCtrsAddObjBtn();
    afx_msg void OnCtrsRemoveBtn();
    afx_msg void OnPwdBtn();
    afx_msg void OnDblclkCtrsCounterList();
    afx_msg void OnKillfocusSchedSampleEdit();
    afx_msg void OnDeltaposSchedSampleSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelendokSampleUnitsCombo();
    afx_msg void OnChangeUser();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CCountersProperty)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()

private:


    enum eValueRange {
        eMinSampleInterval = 1,
        eMaxSampleInterval = 999999,
        eHashTableSize = 257
    };

    typedef struct _HASH_ENTRY {
        struct _HASH_ENTRY       * pNext;
        PPDH_COUNTER_PATH_ELEMENTS pCounter;
    } HASH_ENTRY, *PHASH_ENTRY;

    PHASH_ENTRY  m_HashTable[257];
    BOOL  m_fHashTableSetup;

    ULONG HashCounter ( LPTSTR szCounterName );

    void ImplementAdd ( BOOL bShowObjects );
    void UpdateFileNameString ( void );
    void UpdateLogStartString ( void );
    void SetButtonState( void ); 

public:

    DWORD CheckDuplicate( PPDH_COUNTER_PATH_ELEMENTS pCounter);
    BOOL  RemoveCounterFromHashTable( LPTSTR szCounterName, PPDH_COUNTER_PATH_ELEMENTS pCounterPath);
    void  SetupCountersHashTable( void );
    void  ClearCountersHashTable ( void );
    PPDH_COUNTER_PATH_ELEMENTS InsertCounterToHashTable ( LPTSTR szCounterName );

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif //  _CTRSPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\compdata.h ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation

Module Name:

    compdata.h

Abstract:

	This class is the interface that handles anything to do with 
	the scope pane. MMC calls the IComponentData interfaces.  

--*/

#ifndef __COMPDATA_H_
#define __COMPDATA_H_

#include "smlogres.h"       // Resource symbols
#include "smlogcfg.h"       // For CLSID_ComponentData
#include "Globals.h"
#include "common.h"
#include "smctrsv.h"
#include "smtracsv.h"
#include "smalrtsv.h"
#include "shfusion.h"

// result pane column indices

#define ROOT_COL_QUERY_NAME         0
#define ROOT_COL_QUERY_NAME_SIZE    80

#define ROOT_COL_COMMENT            1
#define ROOT_COL_COMMENT_SIZE       166
#define ROOT_COL_ALERT_COMMENT_XTRA 195

#define ROOT_COL_LOG_TYPE           2
#define ROOT_COL_LOG_TYPE_SIZE      75

#define ROOT_COL_LOG_NAME           3
#define ROOT_COL_LOG_NAME_SIZE      120

#define MAIN_COL_NAME               0
#define MAIN_COL_NAME_SIZE          120

#define MAIN_COL_DESC               1
#define MAIN_COL_DESC_SIZE          321

#define EXTENSION_COL_NAME          0
#define EXTENSION_COL_TYPE          1
#define EXTENSION_COL_DESC          2

class CSmLogQuery;
class CSmRootNode;
class CLogWarnd;

class ATL_NO_VTABLE CComponentData : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IComponentData,
    public IExtendContextMenu,
    public IExtendPropertySheet,
    public ISnapinHelp
    // *** CComObjectRoot is from framewrk\stdcdata.h
  //public CComObjectRoot
{
  public:
            CComponentData();
    virtual ~CComponentData();

//DECLARE_REGISTRY_RESOURCEID(IDR_COMPONENTDATA)
//DECLARE_NOT_AGGREGATABLE(CComponentData)

    enum eBitmapIndex {
        eBmpQueryStarted = 0,
        eBmpQueryStopped = 1,
        eBmpLogType = 2,
        eBmpRootIcon = 3,
        eBmpAlertType = 4
    };

    enum eUpdateHint {
        eSmHintNewQuery = 1,
        eSmHintStartQuery = 2,
        eSmHintStopQuery = 3,
        eSmHintModifyQuery = 4
    };

    enum eNodeType {
        eCounterLog = SLQ_COUNTER_LOG,
        eTraceLog = SLQ_TRACE_LOG,
        eAlert = SLQ_ALERT,
        eMonitor = SLQ_LAST_LOG_TYPE + 1
    };

BEGIN_COM_MAP(CComponentData)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

  // IComponentData methods
  public:
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);
    STDMETHOD(GetDisplayInfo)(LPSCOPEDATAITEM pItem);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT * ppDataObject);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(CreateComponent)(LPCOMPONENT * ppComponent);
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(Destroy)();

// IExtendPropertySheet methods
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK pCall, LONG_PTR handle, LPDATAOBJECT pDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject);

// ISnapinHelp interface members
    STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);

// IExtendContextMenu 
    STDMETHOD(AddMenuItems)( LPDATAOBJECT pDataObject,
                             LPCONTEXTMENUCALLBACK pCallbackUnknown,
                             long *pInsertionAllowed
                           );
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);
    
// other helper methods
  public:
            BOOL    IsLogService(MMC_COOKIE mmcCookie);
            BOOL    IsScopeNode(MMC_COOKIE mmcCookie);
            BOOL    IsAlertService (MMC_COOKIE mmcCookie);

            BOOL    IsLogQuery(MMC_COOKIE mmcCookie);
            BOOL    IsRunningQuery( CSmLogQuery* pQuery);

            LPCTSTR GetConceptsHTMLHelpFileName ( void );
            LPCTSTR GetSnapinHTMLHelpFileName ( void );
            LPCTSTR GetHTMLHelpTopic ( void );            
            const CString& GetContextHelpFilePath ( void );
            IPropertySheetProvider * GetPropSheetProvider();
            BOOL    LogTypeCheckNoMore (CLogWarnd* LogWarnd);

            // *** NOTE: Use of extension subclass not implemented.
            BOOL    IsExtension(){ return m_bIsExtension; };

            void    HandleTraceConnectError( HRESULT&, CString&, CString& );

            HRESULT CreateNewLogQuery( LPDATAOBJECT pDataObject, IPropertyBag* pPropBag = NULL);
            HRESULT CreateLogQueryFrom(LPDATAOBJECT pDataObject);

//  Methods to support IComponentData
  private:
            HRESULT OnExpand(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
            HRESULT OnRemoveChildren(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param );
            
            HRESULT ProcessCommandLine ( CString& rstrMachineName );
            HRESULT LoadFromFile ( LPTSTR  pszFileName );

            LPRESULTDATA    GetResultData ( void );

            void    SetExtension( BOOL bExt ){ m_bIsExtension = bExt; };
            BOOL    IsMyComputerNodetype (GUID& refguid);

            HRESULT InitPropertySheet ( CSmLogQuery*, MMC_COOKIE, LONG_PTR, CPropertySheet& );
            HRESULT NewTypedQuery( CSmLogService* pSvc, IPropertyBag* pPropBag ,LPDATAOBJECT pDataObject);
        
    CString             m_strServerNamePersist; 

    // *** override not implemented
    BOOL                m_fAllowOverrideMachineName;        // TRUE => Allow the machine name to be overriden by the command line
    LPCONSOLENAMESPACE  m_ipConsoleNameSpace;  // Pointer name space interface
    LPCONSOLE           m_ipConsole;           // Pointer to the console interface
    LPRESULTDATA        m_ipResultData;        // Pointer to the result data interface

    LPIMAGELIST         m_ipScopeImage;        // Caching the image list
    HINSTANCE           m_hModule;             // for load string operations
    IPropertySheetProvider    *m_ipPrshtProvider;// from MMC 

    // list of root nodes 
    CTypedPtrList<CPtrList, CSmRootNode*> m_listpRootNode;     

    CString                 m_strDisplayInfoName; 

    BOOL                    m_bIsExtension;

    CString                 m_strWindowsDirectory;
    CString                 m_strContextHelpFilePath;

};

//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::GetPropSheetProvider
//
//  Synopsis:   Access function for saved MMC IPropertySheetProvider
//              interface.
//
//  History:    05-28-1999   a-akamal
//
//---------------------------------------------------------------------------

inline IPropertySheetProvider *
CComponentData::GetPropSheetProvider()
{
    return m_ipPrshtProvider;
}

/////////////////////////////////////////////////////////////////////
class CSmLogSnapin: public CComponentData,
    public CComCoClass<CSmLogSnapin, &CLSID_ComponentData>
{
public:
    CSmLogSnapin() : CComponentData () {};
    virtual ~CSmLogSnapin() {};

DECLARE_REGISTRY_RESOURCEID(IDR_COMPONENTDATA)
DECLARE_NOT_AGGREGATABLE(CSmLogSnapin)

    virtual BOOL IsExtension() { return FALSE; }

// IPersistStream or IPersistStorage
    STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID)
    {
        *pClassID = CLSID_ComponentData;
        return S_OK;
    }
};

/////////////////////////////////////////////////////////////////////
class CSmLogExtension: public CComponentData,
    public CComCoClass<CSmLogExtension, &CLSID_ComponentData>
{
public:
            CSmLogExtension() : CComponentData () {};
    virtual ~CSmLogExtension() {};

DECLARE_REGISTRY_RESOURCEID(IDR_EXTENSION)
DECLARE_NOT_AGGREGATABLE(CSmLogExtension)

    virtual BOOL IsExtension() { return TRUE; }

// IPersistStream or IPersistStorage
    STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID)
    {
        *pClassID = CLSID_ComponentData;
        return S_OK;
    }
};

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { SHActivateContext (&m_ulActivationCookie); }

    ~CThemeContextActivator()
        { SHDeactivateContext (m_ulActivationCookie); }

private:
    ULONG_PTR m_ulActivationCookie;
};

#endif //__COMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\dataobj.cpp ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation
				
Module Name:

    DATAOBJ.CPP

Abstract:

    Implementation of IDataObject for data communication

--*/

#include "StdAfx.h"
#include "smlogcfg.h"
#include "smnode.h"
#include "dataobj.h"

// MMC uses these to get necessary information from our snapin about
// our nodes.

// Register the clipboard formats
unsigned int CDataObject::s_cfMmcMachineName =
    RegisterClipboardFormat(CF_MMC_SNAPIN_MACHINE_NAME);
unsigned int CDataObject::s_cfDisplayName =
    RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CDataObject::s_cfNodeType =
    RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::s_cfSnapinClsid =
    RegisterClipboardFormat(CCF_SNAPIN_CLASSID);

unsigned int CDataObject::s_cfInternal =
    RegisterClipboardFormat(CF_INTERNAL);

#ifdef _DEBUG                          // For tracking data objects
  static UINT nCount = 0;
  WCHAR wszMsg[64];
#endif

/////////////////////////////////////////////////////////////////////////////
// CDataObject - This class is used to pass data back and forth with MMC. It
//               uses a standard interface, IDataObject to acomplish this.
//               Refer to OLE documentation for a description of clipboard
//               formats and the IdataObject interface.

//---------------------------------------------------------------------------
// Added some code to check on data objects  
CDataObject::CDataObject()
:   m_cRefs(0),
    m_ulCookie(0),
    m_Context(CCT_UNINITIALIZED),
    m_CookieType(COOKIE_IS_ROOTNODE)
{

#ifdef _DEBUG
  swprintf( wszMsg, L"DATAOBJECT Create %u\n", nCount );
  LOCALTRACE( wszMsg );
  nCount++;
#endif

} // end Constructor()

//---------------------------------------------------------------------------
// Added some code to check on data objects  
//
CDataObject::~CDataObject()
{
  if ( ( COOKIE_IS_COUNTERMAINNODE == m_CookieType )
     || ( COOKIE_IS_TRACEMAINNODE == m_CookieType )
     || ( COOKIE_IS_ALERTMAINNODE == m_CookieType ) )
  {
    ASSERT( m_ulCookie );
  }

#ifdef _DEBUG
  swprintf( wszMsg, L"DATAOBJECT Delete %u\n", nCount );
  LOCALTRACE( wszMsg );
  nCount--;
#endif

} // end Destructor()


/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
// 

//---------------------------------------------------------------------------
//  Fill the hGlobal in pmedium with the requested data
//
STDMETHODIMP 
CDataObject::GetDataHere
(
  FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure 
  STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure  
)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  HRESULT hr = DV_E_FORMATETC;         // Unknown format
  const   CLIPFORMAT cf = pFormatEtc->cfFormat;
  IStream *pStream = NULL;

  pMedium->pUnkForRelease = NULL;      // by OLE spec

  do                                   // Write data to the stream based
  {                                    // of the clipformat
    hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
      return hr;                       // Minimal error checking

    if( cf == s_cfDisplayName )
    {
      hr = WriteDisplayName( pStream );
    }
    else if( cf == s_cfInternal)
    {
      hr = WriteInternal (pStream);
    }
    else if( cf == s_cfMmcMachineName)
    {
      hr = WriteMachineName( pStream );
    }
    else if( cf == s_cfNodeType )
    {
      hr = WriteNodeType( pStream );
    }
    else if( cf == s_cfSnapinClsid )
    {
      hr = WriteClsid( pStream );
    }
  } while( 0 );

  pStream->Release();

  return hr;

} // end GetDataHere()


/////////////////////////////////////////////////////////////////////////////
//  Support methods
//

//---------------------------------------------------------------------------
//  Write the appropriate GUID to the stream
//
HRESULT
CDataObject::WriteNodeType
(
  IStream* pStream           // [in] Stream we are writing to
)
{
  const GUID *pGuid = NULL;
    
  switch( m_CookieType )
  {
    case COOKIE_IS_ROOTNODE:
      pGuid = &GUID_RootNode;
      break;

    case COOKIE_IS_COUNTERMAINNODE:
      pGuid = &GUID_CounterMainNode;
      break;

    case COOKIE_IS_TRACEMAINNODE:
      pGuid = &GUID_TraceMainNode;
      break;

    case COOKIE_IS_ALERTMAINNODE:
      pGuid = &GUID_AlertMainNode;
      break;

    default:
     ASSERT( FALSE );
     return E_UNEXPECTED;
  }

  return pStream->Write( (PVOID)pGuid, sizeof(GUID), NULL );

} // end WriteNodeType()


//---------------------------------------------------------------------------
//  Writes the display name to the stream.  This is the name associated 
//  with the root node
// 
HRESULT
CDataObject::WriteDisplayName
(
  IStream* pStream           // [in] Stream we are writing to     
)
{
    CString strName;
    ULONG ulSizeofName;
    ResourceStateManager    rsm;

    if( NULL == m_ulCookie )
    { 
        // Add Local vs machine name when implement machine name override/change.
        // NOTE:  For root node, cookie is either NULL or points to a root node object.
        strName.LoadString( IDS_MMC_DEFAULT_NAME ); 
    } else {
        PSMNODE pTmp = reinterpret_cast<PSMNODE>(m_ulCookie);
//???        strName = *pTmp->GetDisplayName();
        strName = pTmp->GetDisplayName();
    }

    ulSizeofName = strName.GetLength();
    ulSizeofName++;                      // Count null character
    ulSizeofName *= sizeof(WCHAR);

    return pStream->Write((LPCWSTR)strName, ulSizeofName, NULL);

} // end WriteDisplayName()

//---------------------------------------------------------------------------
//  Writes the machine name to the stream.  
// 
HRESULT
CDataObject::WriteMachineName
(
  IStream* pStream           // [in] Stream we are writing to     
)
{
    CString strName;
    ULONG ulSizeOfName;

    if( NULL == m_ulCookie ) {  
        // Cookie is null if not an extension.  In that case, only support
        // local machine.
        strName = L"";  // local
    } else {
        PSMNODE pTmp = reinterpret_cast<PSMNODE>(m_ulCookie);
        strName = pTmp->GetMachineName();
    }

    ulSizeOfName = strName.GetLength();
    ulSizeOfName++;                      // Count null character
    ulSizeOfName *= sizeof(WCHAR);

    return pStream->Write((LPCWSTR)strName, ulSizeOfName, NULL);

} // end WriteMachineName()

//---------------------------------------------------------------------------
//  Writes a pointer to this data object to the stream
//
HRESULT
CDataObject::WriteInternal
(
  IStream* pStream           // [in] Stream we are writing to 
)
{
  CDataObject *pThis = this;
  return pStream->Write( &pThis, sizeof(CDataObject*), NULL );

} // end WriteInternal

//---------------------------------------------------------------------------
//  Writes the Class ID to the stream
//
HRESULT
CDataObject::WriteClsid
(
  IStream* pStream           // [in] Stream we are writing to
)
{
  return pStream->Write( &CLSID_ComponentData,
                         sizeof(CLSID_ComponentData),
                         NULL
                       );
} // end WriteClsid()


//---------------------------------------------------------------------------
//  The cookie is what ever we decide it is going to be.
//  This is being called from QueryDataObject. Refer to that code.
//
VOID 
CDataObject::SetData
(
  MMC_COOKIE         ulCookie, // [in] Unique indentifier
  DATA_OBJECT_TYPES  Context,  // [in] Context of the caller
  COOKIETYPE         Type      // [in] Type of cookie
)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  ASSERT( NULL == m_ulCookie );
  m_ulCookie   = ulCookie;
  m_Context    = Context;
  m_CookieType = Type;

} // end SetData()


/////////////////////////////////////////////////////////////////////////////
// IUnknown implementation
// 


//---------------------------------------------------------------------------
//  Standard implementation
//
STDMETHODIMP
CDataObject::QueryInterface
(
  REFIID  riid,
  LPVOID *ppvObj
)
{
  HRESULT hr = S_OK;

  do
  {
    if( NULL == ppvObj )
    {
      hr = E_INVALIDARG;
      break;
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
      *ppvObj = (IUnknown *)(IDataObject *)this;
    }
    else if (IsEqualIID(riid, IID_IDataObject))
    {
      *ppvObj = (IUnknown *)(IDataObject *)this;
    }
    else
    {
      hr = E_NOINTERFACE;
      *ppvObj = NULL;
      break;
    }

    // If we got this far we are handing out a new interface pointer on 
    // this object, so addref it.  
    AddRef();
  } while (0);

  return hr;

} // end QueryInterface()

//---------------------------------------------------------------------------
//  Standard implementation
//
STDMETHODIMP_(ULONG)
CDataObject::AddRef()
{
  return InterlockedIncrement((LONG*) &m_cRefs);
}

//---------------------------------------------------------------------------
//  Standard implementation
//
STDMETHODIMP_(ULONG)
CDataObject::Release()
{
  ULONG cRefsTemp;
  cRefsTemp = InterlockedDecrement((LONG *)&m_cRefs);

  if( 0 == cRefsTemp )
  {
    delete this;
  }

  return cRefsTemp;

} // end Release()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\dataobj.h ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation

Module Name:

    DataObj.h

Abstract:

    The IDataObject Interface is used to communicate data

--*/

#ifndef __DATAOBJ_H_
#define __DATAOBJ_H_

// Disable 64-bit warnings in atlctl.h
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4510 )
#pragma warning ( disable : 4610 )
#pragma warning ( disable : 4100 )
#include <atlctl.h>
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

/////////////////////////////////////////////////////////////////////////////
// Defines, Types etc...
//

class CComponentData;        // Forward declaration


typedef enum tagCOOKIETYPE
{
  COOKIE_IS_ROOTNODE,
  COOKIE_IS_COUNTERMAINNODE,
  COOKIE_IS_TRACEMAINNODE,
  COOKIE_IS_ALERTMAINNODE,
  COOKIE_IS_MYCOMPUTER,

} COOKIETYPE;


/////////////////////////////////////////////////////////////////////////////
// CDataObject - This class is used to pass data back and forth with MMC. It
//               uses a standard interface, IDataObject to acomplish this.
//                Refer to OLE documentation for a description of clipboard
//               formats and the IDataObject interface.

class CDataObject:
    public IDataObject,
    public CComObjectRoot

{
public:

DECLARE_NOT_AGGREGATABLE(CDataObject)

BEGIN_COM_MAP(CDataObject)
    COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()


            CDataObject();
    virtual ~CDataObject();

    // IUnknown overrides
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

  // IDataObject methods 
  public:
    STDMETHOD(GetDataHere)(FORMATETC *pformatetc, STGMEDIUM *pmedium);

  // The rest are not implemented in this sample    
    STDMETHOD(GetData)(LPFORMATETC /*lpFormatetcIn*/, LPSTGMEDIUM /*lpMedium*/)
    { AFX_MANAGE_STATE(AfxGetStaticModuleState());
      return E_NOTIMPL; 
    };

    STDMETHOD(EnumFormatEtc)(DWORD /*dwDirection*/, LPENUMFORMATETC* /*ppEnumFormatEtc*/)
    { return E_NOTIMPL; };

    STDMETHOD(QueryGetData)(LPFORMATETC /*lpFormatetc*/) 
    { AFX_MANAGE_STATE(AfxGetStaticModuleState());
      return E_NOTIMPL;
    };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC /*lpFormatetcIn*/, LPFORMATETC /*lpFormatetcOut*/)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC/* lpFormatetc */, LPSTGMEDIUM /* lpMedium */, BOOL /* bRelease */)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC /* lpFormatetc */, DWORD /* advf */, 
        LPADVISESINK /* pAdvSink */, LPDWORD /* pdwConnection */)
    { return E_NOTIMPL; };
    
    STDMETHOD(DUnadvise)(DWORD /* dwConnection */)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* /* ppEnumAdvise */)
    { return E_NOTIMPL; };

  // Non-interface member functions
  public:
    DATA_OBJECT_TYPES GetContext()     { return m_Context;    }
    COOKIETYPE        GetCookieType()  { return m_CookieType; } 
    MMC_COOKIE        GetCookie()      { return m_ulCookie;   }

    VOID     SetData(MMC_COOKIE ulCookie, DATA_OBJECT_TYPES Type, COOKIETYPE ct);

  private:
    HRESULT  WriteInternal(IStream *pstm);
    HRESULT  WriteDisplayName(IStream *pstm);
    HRESULT  WriteMachineName(IStream *pstm);
    HRESULT  WriteNodeType(IStream *pstm);
    HRESULT  WriteClsid(IStream *pstm);

    ULONG               m_cRefs;       // Object refcount
    MMC_COOKIE          m_ulCookie;    // What this obj refers to
    DATA_OBJECT_TYPES   m_Context;     // Context in which this was created (Data object type)
    COOKIETYPE          m_CookieType;  // How to interpret m_ulCookie

  public:
    static UINT s_cfMmcMachineName;     // format for machine name when ext. snapin
    static UINT s_cfInternal;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
};

#endif // __DATAOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\ctrsprop.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    ctrsprop.cpp

Abstract:

    Implementation of the counters general property page.

--*/

#include "stdafx.h"
#include <pdh.h>
#include <pdhmsg.h>
#include "smlogs.h"
#include "smcfgmsg.h"
#include "smctrqry.h"
#include "ctrsprop.h"
#include "smlogres.h"
#include <pdhp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("SMLOGCFG(ctrsprop.cpp)");

static ULONG
s_aulHelpIds[] =
{
    IDC_CTRS_COUNTER_LIST,      IDH_CTRS_COUNTER_LIST,
    IDC_CTRS_ADD_BTN,           IDH_CTRS_ADD_BTN,
    IDC_CTRS_ADD_OBJ_BTN,       IDH_CTRS_ADD_OBJ_BTN,
    IDC_CTRS_REMOVE_BTN,        IDH_CTRS_REMOVE_BTN,
    IDC_CTRS_FILENAME_DISPLAY,  IDH_CTRS_FILENAME_DISPLAY,
    IDC_CTRS_SAMPLE_SPIN,       IDH_CTRS_SAMPLE_EDIT,
    IDC_CTRS_SAMPLE_EDIT,       IDH_CTRS_SAMPLE_EDIT,
    IDC_CTRS_SAMPLE_UNITS_COMBO,IDH_CTRS_SAMPLE_UNITS_COMBO,
    IDC_RUNAS_EDIT,             IDH_RUNAS_EDIT,
    IDC_SETPWD_BTN,             IDH_SETPWD_BTN,
    0,0
};

/////////////////////////////////////////////////////////////////////////////
// CCountersProperty property page

IMPLEMENT_DYNCREATE(CCountersProperty, CSmPropertyPage)

CCountersProperty::CCountersProperty(MMC_COOKIE mmcCookie, LONG_PTR hConsole)
:   CSmPropertyPage ( CCountersProperty::IDD, hConsole )
// lCookie is really the pointer to the Log Query object
{
    //::OutputDebugStringA("\nCCountersProperty::CCountersProperty");

    // save pointers from arg list
    m_pCtrLogQuery = reinterpret_cast <CSmCounterLogQuery *>(mmcCookie);

    ZeroMemory ( &m_dlgConfig, sizeof(m_dlgConfig) );
    m_szCounterListBuffer = NULL;
    m_dwCounterListBufferSize = 0;
    m_lCounterListHasStars = 0;
    m_dwMaxHorizListExtent = 0;
    m_fHashTableSetup = FALSE;
    
    //  EnableAutomation();
    //{{AFX_DATA_INIT(CCountersProperty)
    m_nSampleUnits = 0;
    //}}AFX_DATA_INIT
}

CCountersProperty::CCountersProperty() : CSmPropertyPage ( CCountersProperty::IDD )
{
    ASSERT (FALSE); // the constructor w/ args should be used instead
}

CCountersProperty::~CCountersProperty()
{
//    ::OutputDebugStringA("\nCCountersProperty::~CCountersProperty");

    if (m_szCounterListBuffer != NULL) {
        delete (m_szCounterListBuffer);
    }
    ClearCountersHashTable();
}

void CCountersProperty::OnFinalRelease()
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CPropertyPage::OnFinalRelease();
}

void CCountersProperty::DoDataExchange(CDataExchange* pDX)
{
    CString strTemp;
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CCountersProperty)
    DDX_Text(pDX, IDC_CTRS_LOG_SCHED_TEXT, m_strStartDisplay);
    ValidateTextEdit(pDX, IDC_CTRS_SAMPLE_EDIT, 6, &m_SharedData.stiSampleTime.dwValue, eMinSampleInterval, eMaxSampleInterval);
    DDX_CBIndex(pDX, IDC_CTRS_SAMPLE_UNITS_COMBO, m_nSampleUnits);
    DDX_Text(pDX, IDC_RUNAS_EDIT, m_strUserDisplay );
    //}}AFX_DATA_MAP

    if ( pDX->m_bSaveAndValidate ) {
        m_SharedData.stiSampleTime.dwUnitType = 
            (DWORD)((CComboBox *)GetDlgItem(IDC_CTRS_SAMPLE_UNITS_COMBO))->
                    GetItemData(m_nSampleUnits);    
    }
}


BEGIN_MESSAGE_MAP(CCountersProperty, CSmPropertyPage)
    //{{AFX_MSG_MAP(CCountersProperty)
    ON_BN_CLICKED(IDC_CTRS_ADD_BTN, OnCtrsAddBtn)
    ON_BN_CLICKED(IDC_CTRS_ADD_OBJ_BTN, OnCtrsAddObjBtn)
    ON_BN_CLICKED(IDC_CTRS_REMOVE_BTN, OnCtrsRemoveBtn)
    ON_LBN_DBLCLK(IDC_CTRS_COUNTER_LIST, OnDblclkCtrsCounterList)
    ON_EN_CHANGE(IDC_CTRS_SAMPLE_EDIT, OnKillfocusSchedSampleEdit)
    ON_EN_KILLFOCUS(IDC_CTRS_SAMPLE_EDIT, OnKillfocusSchedSampleEdit)
    ON_EN_CHANGE( IDC_RUNAS_EDIT, OnChangeUser )
    ON_NOTIFY(UDN_DELTAPOS, IDC_CTRS_SAMPLE_SPIN, OnDeltaposSchedSampleSpin)
    ON_CBN_SELENDOK(IDC_CTRS_SAMPLE_UNITS_COMBO, OnSelendokSampleUnitsCombo)
    ON_BN_CLICKED(IDC_SETPWD_BTN, OnPwdBtn)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CCountersProperty, CSmPropertyPage)
    //{{AFX_DISPATCH_MAP(CCountersProperty)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_ICountersProperty to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {65154EA9-BDBE-11D1-BF99-00C04F94A83A}
static const IID IID_ICountersProperty =
{ 0x65154ea9, 0xbdbe, 0x11d1, { 0xbf, 0x99, 0x0, 0xc0, 0x4f, 0x94, 0xa8, 0x3a } };

BEGIN_INTERFACE_MAP(CCountersProperty, CSmPropertyPage)
    INTERFACE_PART(CCountersProperty, IID_ICountersProperty, Dispatch)
END_INTERFACE_MAP()



ULONG 
CCountersProperty::HashCounter(
    LPTSTR szCounterName
    )
{
    ULONG       h = 0;
    ULONG       a = 31415;  //a, b, k are primes
    const ULONG k = 16381;
    const ULONG b = 27183;
    LPTSTR szThisChar;

    if (szCounterName) {
        for (szThisChar = szCounterName; * szThisChar; szThisChar ++) {
            h = (a * h + ((ULONG) (* szThisChar))) % k;
            a = a * b % (k - 1);
        }
    }
    return (h % eHashTableSize);
}


//++
// Description:
//    Remove a counter path from hash table. One counter
//    path must exactly match the given one in order to be
//    removed, even it is one with wildcard
//
// Parameters:
//    pszCounterPath - Pointer to counter path to be removed
//
// Return:
//    Return TRUE if the counter path is removed, otherwis return FALSE
//--
BOOL
CCountersProperty::RemoveCounterFromHashTable(
    LPTSTR szCounterName,
    PPDH_COUNTER_PATH_ELEMENTS pCounterPath
    )
{
    ULONG lHashValue;
    PHASH_ENTRY pEntry = NULL;
    PHASH_ENTRY pPrev = NULL;
    BOOL bReturn = FALSE;

    SetLastError(ERROR_SUCCESS);

    if (szCounterName == NULL || pCounterPath == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto ErrorOut;
    }

    lHashValue = HashCounter(szCounterName);
    pEntry = m_HashTable[lHashValue];

    //
    // Check if there is a counter path which is exactly the same
    // as the given one
    //
    while (pEntry) {
        if (pEntry->pCounter == pCounterPath) 
            break;
        pPrev = pEntry;
        pEntry = pEntry->pNext;
    }

    //
    // If we found it, remove it
    //
    if (pEntry) {
        if (pPrev == NULL) {
            m_HashTable[lHashValue] = pEntry->pNext;
        }
        else {
            pPrev->pNext = pEntry->pNext;
        }
        G_FREE(pEntry->pCounter);
        G_FREE(pEntry);
        bReturn = TRUE;
    }

ErrorOut:
    return bReturn;
}


//++
// Description:
//    Insert a counter path into hash table. 
//
// Parameters:
//    pszCounterPath - Pointer to counter path to be inserted
//
// Return:
//    Return the pointer to new inserted PDH_COUNTER_PATH_ELEMENTS structure
//--
PPDH_COUNTER_PATH_ELEMENTS
CCountersProperty::InsertCounterToHashTable(
    LPTSTR pszCounterPath
    )
{
    ULONG       lHashValue;
    PHASH_ENTRY pNewEntry  = NULL;
    PPDH_COUNTER_PATH_ELEMENTS pCounter = NULL;
    PDH_STATUS pdhStatus;

    if (pszCounterPath == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto ErrorOut;
    }

    pdhStatus = AllocInitCounterPath ( pszCounterPath, &pCounter );

    if (pdhStatus != ERROR_SUCCESS) {
        SetLastError( pdhStatus );
        goto ErrorOut;
    }

    //
    // Insert at head of bucket list
    //
    lHashValue = HashCounter(pszCounterPath);

    pNewEntry = (PHASH_ENTRY) G_ALLOC(sizeof(HASH_ENTRY));
    if (pNewEntry == NULL) {
        SetLastError( ERROR_OUTOFMEMORY );
        goto ErrorOut;
    }

    pNewEntry->pCounter = pCounter;
    pNewEntry->pNext = m_HashTable[lHashValue];
    m_HashTable[lHashValue] = pNewEntry;
    return pCounter;

ErrorOut:
    if (pCounter != NULL)
        G_FREE (pCounter);
    return NULL;
}

//++
// Description:
//    Check if the new counter path overlaps with a existing
//    one in logical sense
//
// Parameters:
//    pCounter - Pointer to counter path to be inserted
//
// Return:
//    Return the relation between the new and existing counter
//    paths. Possible relation is as following:
//         ERROR_SUCCESS - The two counter paths are different
//         SMCFG_DUPL_FIRST_IS_WILD - The first counter path has wildcard name
//         SMCFG_DUPL_SECOND_IS_WILD - The second counter path has wildcard name
//         SMCFG_DUPL_SINGLE_PATH - The two counter paths are the same(may 
//                                  contain wildcard)
//--
DWORD 
CCountersProperty::CheckDuplicate( PPDH_COUNTER_PATH_ELEMENTS pCounter)
{
    ULONG       lHashValue;
    PHASH_ENTRY pHead;
    PHASH_ENTRY pEntry;
    DWORD       dwStatus = ERROR_SUCCESS;

    for (lHashValue = 0; lHashValue < eHashTableSize; lHashValue++) {
        pHead = m_HashTable[lHashValue];
        if (pHead == NULL)
            continue;

        pEntry = pHead;
        while (pEntry) {
            dwStatus = CheckDuplicateCounterPaths ( pEntry->pCounter, pCounter );
            if ( dwStatus != ERROR_SUCCESS ) {
                return dwStatus;
            }
            pEntry = pEntry->pNext;
        }
    }
    return dwStatus;
}

//++
// Description:
//    The function inserts all the current counter paths into
//    hash table as a way to accelerate looking.
//
// Parameters:
//    None
//
// Return:
//    None
//--
void 
CCountersProperty::SetupCountersHashTable( void )
{
    INT       iListIndex;   
    INT       iItemCnt;
    TCHAR     szPath[MAX_PATH];
    CListBox* pCounterList;

    //
    // If the hash table is already set up, return
    if (m_fHashTableSetup) {
        return;
    }

    //
    // Initialize the hash table
    //
    memset(&m_HashTable, 0, sizeof(m_HashTable));
    // 
    // Loop throuth all the items in the list box and 
    // put them into hash table.
    //
    pCounterList = (CListBox *)GetDlgItem(IDC_CTRS_COUNTER_LIST);
    if (pCounterList == NULL) {
        return;
    }

    iItemCnt = pCounterList->GetCount();

    if (iItemCnt != LB_ERR) {
        for (iListIndex = 0; iListIndex < iItemCnt; iListIndex++) {
            if (pCounterList->GetText( iListIndex, szPath ) > 0) {
                InsertCounterToHashTable( szPath );
            }
        }
    }
    m_fHashTableSetup = TRUE;
}


//++
// Description:
//    The function clears all the entries in hash table
//    and set hash-table-not-set-up flag
//
// Parameters:
//    None
//
// Return:
//    None
//--
void 
CCountersProperty::ClearCountersHashTable( void )
{
    ULONG       i;
    PHASH_ENTRY pEntry;
    PHASH_ENTRY pNext;

    if (m_fHashTableSetup) {
        for (i = 0; i < eHashTableSize; i ++) {
            pNext = m_HashTable[i];
            while (pNext != NULL) {
                pEntry = pNext;
                pNext  = pEntry->pNext;

                G_FREE(pEntry->pCounter);
                G_FREE(pEntry);
            }
        }
    }
    else {
        memset(&m_HashTable, 0, sizeof(m_HashTable));
    }
    m_fHashTableSetup = FALSE;
}


static 
PDH_FUNCTION
DialogCallBack(CCountersProperty *pDlg)
{
    // add strings in buffer to list box
    LPTSTR      szNewCounterName;
    INT         iListIndex;   
    INT         iItemCnt;   
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwReturnStatus = ERROR_SUCCESS;
    CListBox    *pCounterList;
    DWORD       dwItemExtent;
    DWORD       dwStatus = ERROR_SUCCESS;
    BOOL        bAtLeastOneCounterRemoved = FALSE;
    BOOL        bAtLeastOneCounterNotAdded = FALSE;
    TCHAR       szCounterPath[MAX_PATH + 1];
    PPDH_COUNTER_PATH_ELEMENTS pPathInfoNew = NULL;
    CDC*        pCDC = NULL;
    ResourceStateManager    rsm;
    

#define CTRBUFLIMIT (0x7fffffff)

    if ( PDH_MORE_DATA == pDlg->m_dlgConfig.CallBackStatus ) {
        if ( pDlg->m_dlgConfig.cchReturnPathLength < CTRBUFLIMIT ) {

            pDlg->m_dwCounterListBufferSize *= 2;
            delete pDlg->m_szCounterListBuffer;
            pDlg->m_szCounterListBuffer = NULL;

            try {
                pDlg->m_szCounterListBuffer = new WCHAR[pDlg->m_dwCounterListBufferSize];
        
            } catch ( ... ) {
                pDlg->m_dwCounterListBufferSize = 0;
                pDlg->m_dlgConfig.CallBackStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                dwReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }

            if ( ERROR_SUCCESS == dwReturnStatus ) {
                // clear buffer
                memset (pDlg->m_szCounterListBuffer, 0, pDlg->m_dwCounterListBufferSize);
            
                pDlg->m_dlgConfig.szReturnPathBuffer = pDlg->m_szCounterListBuffer;
                pDlg->m_dlgConfig.cchReturnPathLength = pDlg->m_dwCounterListBufferSize;
                pDlg->m_dlgConfig.CallBackStatus = PDH_RETRY;
                dwReturnStatus = PDH_RETRY;
            }
        } else {
            pDlg->m_dlgConfig.CallBackStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            dwReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    } else if ( ERROR_SUCCESS == pDlg->m_dlgConfig.CallBackStatus ) {

        pCounterList = (CListBox *)pDlg->GetDlgItem(IDC_CTRS_COUNTER_LIST);
    
        pCDC = pCounterList->GetDC();

        for (szNewCounterName = pDlg->m_szCounterListBuffer;
            *szNewCounterName != 0;
            szNewCounterName += (lstrlen(szNewCounterName) + 1)) {

            //
            // Parse new pathname
            //
            pdhStatus = pDlg->AllocInitCounterPath ( szNewCounterName, &pPathInfoNew );
            
            //
            // Check for duplicate
            //
            if (pdhStatus == ERROR_SUCCESS) {
                dwStatus = pDlg->CheckDuplicate( pPathInfoNew);
                if ( ERROR_SUCCESS != dwStatus ) {
                    if ( SMCFG_DUPL_SINGLE_PATH == dwStatus 
                            || SMCFG_DUPL_FIRST_IS_WILD == dwStatus ) {
                        // NOTE:  This includes case where both first
                        // and second are wild.
                        bAtLeastOneCounterNotAdded = TRUE;
                    } else {
                        ASSERT( dwStatus == SMCFG_DUPL_SECOND_IS_WILD);
                    }
                }
            }

            //
            // Check if there is a valid counter to add to the list
            //
            if ( ERROR_SUCCESS == pdhStatus && 
                ( ERROR_SUCCESS == dwStatus || SMCFG_DUPL_SECOND_IS_WILD == dwStatus)) {

                if ( SMCFG_DUPL_SECOND_IS_WILD == dwStatus ) {
                    //
                    // Scan for the duplicated items in the list box and
                    // remove them
                    //
                    iItemCnt = pCounterList->GetCount();

                    for (iListIndex = iItemCnt-1; iListIndex >= 0; iListIndex--) {
                        PPDH_COUNTER_PATH_ELEMENTS pPathInfoExist;

                        if ( 0 < pCounterList->GetText( iListIndex, szCounterPath ) ) {
                            pPathInfoExist = (PPDH_COUNTER_PATH_ELEMENTS) 
                                                         pCounterList->GetItemDataPtr(iListIndex);

                            if (pPathInfoExist == NULL)
                                continue;

                            dwStatus = CheckDuplicateCounterPaths ( pPathInfoExist, pPathInfoNew ); 

                            if (dwStatus != ERROR_SUCCESS ) {
                                ASSERT( dwStatus == SMCFG_DUPL_SECOND_IS_WILD );

                                pDlg->RemoveCounterFromHashTable(szCounterPath, pPathInfoExist);
                                pCounterList->DeleteString(iListIndex);
                            }
                        }
                    }

                    bAtLeastOneCounterRemoved = TRUE;
                }

                //
                // Add new counter name and select the current entry in the list box
                //
                iListIndex = pCounterList->AddString(szNewCounterName);

                if (iListIndex != LB_ERR) {
                    if (pDlg->m_lCounterListHasStars != PDLCNFIG_LISTBOX_STARS_YES) {
                        // save a string compare if this value is already set
                        if (_tcsstr (szNewCounterName, TEXT("*")) == NULL) {
                            pDlg->m_lCounterListHasStars = PDLCNFIG_LISTBOX_STARS_YES;
                        }
                    }

                    if (! bAtLeastOneCounterRemoved) {
                        // update list box extent
                        if ( NULL != pCDC ) {
                            dwItemExtent = (DWORD)(pCDC->GetTextExtent (szNewCounterName)).cx;
                            if (dwItemExtent > pDlg->m_dwMaxHorizListExtent) {
                                pDlg->m_dwMaxHorizListExtent = dwItemExtent;
                                pCounterList->SetHorizontalExtent(dwItemExtent);
                            }
                        }
                    }

                    pCounterList->SetSel (-1, FALSE);    // cancel existing selections
                    pCounterList->SetSel (iListIndex);
                    pCounterList->SetCaretIndex (iListIndex);
                    pCounterList->SetItemDataPtr(iListIndex,
                                           (void*)pDlg->InsertCounterToHashTable(szNewCounterName));
                }
            }
        
            if ( ERROR_SUCCESS != pdhStatus ) {
                // Message box Pdh error message, go on to next 
                CString strMsg;
                CString strPdhMessage;

                FormatSystemMessage ( pdhStatus, strPdhMessage );

                MFC_TRY
                    strMsg.Format ( IDS_CTRS_PDH_ERROR, szNewCounterName );
                    strMsg += strPdhMessage;
                MFC_CATCH_MINIMUM
        
                ::AfxMessageBox( strMsg, MB_OK|MB_ICONERROR, 0 );
            }
            // Go on to next path to add
            dwStatus = ERROR_SUCCESS;
        }

        if (bAtLeastOneCounterRemoved) {
            // 
            // Clear the max extent and recalculate
            //
            pDlg->m_dwMaxHorizListExtent = 0;
            for ( iListIndex = 0; iListIndex < pCounterList->GetCount(); iListIndex++ ) {
 
                pCounterList->GetText(iListIndex, szCounterPath);

                if ( NULL != pCDC ) {
                    dwItemExtent = (DWORD)(pCDC->GetTextExtent(szCounterPath)).cx;
                    if (dwItemExtent > pDlg->m_dwMaxHorizListExtent) {
                        pDlg->m_dwMaxHorizListExtent = dwItemExtent;
                    }
                }
            }
            pCounterList->SetHorizontalExtent(pDlg->m_dwMaxHorizListExtent);
        }

        if ( NULL != pCDC ) {
            pCounterList->ReleaseDC(pCDC);
            pCDC = NULL;
        }

        // Message box re: duplicates not added, or duplicates were removed.
        if ( bAtLeastOneCounterRemoved ) {
            CString strMsg;
        
            strMsg.LoadString ( IDS_CTRS_DUPL_PATH_DELETED );

            ::AfxMessageBox ( strMsg, MB_OK  | MB_ICONWARNING, 0);
        }

        if ( bAtLeastOneCounterNotAdded ) {
            CString strMsg;
            
            strMsg.LoadString ( IDS_CTRS_DUPL_PATH_NOT_ADDED );
            
            ::AfxMessageBox( strMsg, MB_OK|MB_ICONWARNING, 0 );
        }

        // clear buffer
        memset (pDlg->m_szCounterListBuffer, 0, pDlg->m_dwCounterListBufferSize);
        dwReturnStatus = ERROR_SUCCESS;
    } else {
        // Not successful
        dwReturnStatus = pDlg->m_dlgConfig.CallBackStatus; 
    }

    return dwReturnStatus;
}


void CCountersProperty::OnPwdBtn()
{
    CString strTempUser;

    UpdateData(TRUE);

    if (!m_bCanAccessRemoteWbem) {
        ConnectRemoteWbemFail(m_pCtrLogQuery, TRUE);
        return;
    }

    MFC_TRY
        strTempUser = m_strUserDisplay;

        m_strUserDisplay.TrimLeft();
        m_strUserDisplay.TrimRight();

        m_pCtrLogQuery->m_strUser = m_strUserDisplay;

        SetRunAs(m_pCtrLogQuery);

        m_strUserDisplay = m_pCtrLogQuery->m_strUser;

        if ( 0 != strTempUser.CompareNoCase ( m_strUserDisplay ) ) {
            SetDlgItemText ( IDC_RUNAS_EDIT, m_strUserDisplay );
        }
    MFC_CATCH_MINIMUM;
}

BOOL 
CCountersProperty::IsValidLocalData()
{
    BOOL bIsValid = TRUE;
    CListBox * pCounterList = (CListBox *)GetDlgItem(IDC_CTRS_COUNTER_LIST);
    long    lNumCounters;

    ResourceStateManager rsm;

    lNumCounters = pCounterList->GetCount();
    if ( 0 == lNumCounters ) {
        CString strMsg;

        bIsValid = FALSE;
        
        strMsg.LoadString ( IDS_CTRS_REQUIRED );
    
        MessageBox ( strMsg, m_pCtrLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
        GetDlgItem ( IDC_CTRS_ADD_BTN )->SetFocus();    
    }

    if (bIsValid) {
        // Validate sample interval value
        bIsValid = ValidateDWordInterval(IDC_CTRS_SAMPLE_EDIT,
                                         m_pCtrLogQuery->GetLogName(),
                                         (long) m_SharedData.stiSampleTime.dwValue,
                                         eMinSampleInterval,
                                         eMaxSampleInterval);
    }

    if (bIsValid) {
        // Validate sample interval value and unit type
        bIsValid = SampleIntervalIsInRange(                         
                    m_SharedData.stiSampleTime,
                    m_pCtrLogQuery->GetLogName() );

        if ( !bIsValid ) {
            GetDlgItem ( IDC_CTRS_SAMPLE_EDIT )->SetFocus();    
        }
    }

    return bIsValid;
}
/////////////////////////////////////////////////////////////////////////////
// CCountersProperty message handlers

void 
CCountersProperty::OnChangeUser()
{
    //
    // If you can not access remote WBEM, you can not modify RunAs info,
    // changing the user name is not allowed.
    //
    if (m_bCanAccessRemoteWbem) {
        //
        // When the user hits OK in the password dialog,
        // the user name might not have changed.
        //
        UpdateData ( TRUE );

        m_strUserDisplay.TrimLeft();
        m_strUserDisplay.TrimRight();

        if ( 0 != m_strUserSaved.Compare ( m_strUserDisplay ) ) {
            m_pCtrLogQuery->m_fDirtyPassword = PASSWORD_DIRTY;
            SetModifiedPage(TRUE);
        }
        else {
            m_pCtrLogQuery->m_fDirtyPassword &= ~PASSWORD_DIRTY;
        }
        //
        // If default user is typed, never need to set password
        //
        if (m_strUserDisplay.IsEmpty() || m_strUserDisplay.GetAt(0) == L'<') {
            if (m_bPwdButtonEnabled) {
                GetDlgItem(IDC_SETPWD_BTN)->EnableWindow(FALSE);
                m_bPwdButtonEnabled = FALSE;
            }
        }
        else {
            if (!m_bPwdButtonEnabled) {
                GetDlgItem(IDC_SETPWD_BTN)->EnableWindow(TRUE);
                m_bPwdButtonEnabled = TRUE;
            }
        }
    }
    else {
        //
        // We can not modify the RunAs info, then display
        // an error message and retore the original user name in RunAs
        //
        UpdateData(TRUE);
        if (ConnectRemoteWbemFail(m_pCtrLogQuery, FALSE)) {
            GetDlgItem(IDC_RUNAS_EDIT)->SetWindowText(m_strUserSaved);
        }
    }
}

void 
CCountersProperty::OnCtrsAddBtn() 
{
    ImplementAdd( FALSE );
}

void
CCountersProperty::OnCtrsAddObjBtn() 
{
    ImplementAdd( TRUE );
}

void CCountersProperty::OnCtrsRemoveBtn() 
{
    CListBox    *pCounterList;
    LONG        lThisItem;
    BOOL        bDone;
    LONG        lOrigCaret;
    LONG        lItemStatus;
    LONG        lItemCount;
    BOOL        bChanged = FALSE;
    DWORD       dwItemExtent;
    CString     strItemText;
    PPDH_COUNTER_PATH_ELEMENTS pCounter;

    pCounterList = (CListBox *)GetDlgItem(IDC_CTRS_COUNTER_LIST);
    // delete all selected items in the list box and
    // set the cursor to the item above the original caret position
    // or the first or last if that is out of the new range
    lOrigCaret = pCounterList->GetCaretIndex();
    lThisItem = 0;
    bDone = FALSE;
    // clear the max extent
    m_dwMaxHorizListExtent = 0;
    // clear the value and see if any non deleted items have a star, if so
    // then set the flag back
    do {
        lItemStatus = pCounterList->GetSel(lThisItem);
        if (lItemStatus > 0) {
            // then it's selected so delete it
            pCounterList->GetText(lThisItem, strItemText);
            pCounter = (PPDH_COUNTER_PATH_ELEMENTS) pCounterList->GetItemDataPtr(lThisItem);
            if (RemoveCounterFromHashTable(strItemText.GetBuffer(1), pCounter) == FALSE) {
                ClearCountersHashTable ();
            }
            pCounterList->DeleteString(lThisItem);
            bChanged = TRUE;
        } else if (lItemStatus == 0) {
            // get the text length of this item since it will stay
            pCounterList->GetText(lThisItem, strItemText);
            if (m_lCounterListHasStars != PDLCNFIG_LISTBOX_STARS_YES) {
                // save a string compare if this value is already set
                if (_tcsstr (strItemText, TEXT("*")) == NULL) {
                    m_lCounterListHasStars = PDLCNFIG_LISTBOX_STARS_YES;
                }
            }
            dwItemExtent = (DWORD)((pCounterList->GetDC())->GetTextExtent(strItemText)).cx;
            if (dwItemExtent > m_dwMaxHorizListExtent) {
                m_dwMaxHorizListExtent = dwItemExtent;
            }
            // then it's not selected so go to the next one
            lThisItem++;
        } else {
            // we've run out so exit
            bDone = TRUE;
        }
    } while (!bDone);

    // update the text extent of the list box
    pCounterList->SetHorizontalExtent(m_dwMaxHorizListExtent);

    // see how many entries are left and update the
    // caret position and the remove button state
    lItemCount = pCounterList->GetCount();
    if (lItemCount > 0) {
        // the update the caret
        if (lOrigCaret >= lItemCount) {
            lOrigCaret = lItemCount-1;
        } else {
            // caret should be within the list
        }
        pCounterList->SetSel(lOrigCaret);
        pCounterList->SetCaretIndex(lOrigCaret);
    } else {
        // the list is empty so remove caret, selection
        // disable the remove button and activate the
        // add button
        pCounterList->SetSel(-1);
    }

    SetButtonState();
    SetModifiedPage(bChanged);
}

void CCountersProperty::OnDblclkCtrsCounterList() 
{
    ImplementAdd( FALSE );
}

BOOL CCountersProperty::OnSetActive()
{
    BOOL        bReturn;

    bReturn = CSmPropertyPage::OnSetActive();
    
    if (bReturn) {

        ResourceStateManager    rsm;

        m_pCtrLogQuery->GetPropPageSharedData ( &m_SharedData );

        UpdateFileNameString();

        UpdateLogStartString();

        m_strUserDisplay = m_pCtrLogQuery->m_strUser;
        UpdateData(FALSE); //to load the edit & combo box
    }
    
    return bReturn;
}

BOOL CCountersProperty::OnKillActive() 
{
    BOOL bContinue = TRUE;
    ResourceStateManager    rsm;

    bContinue = CPropertyPage::OnKillActive();

    if ( bContinue ) {
        m_pCtrLogQuery->m_strUser = m_strUserDisplay;
        bContinue = IsValidData(m_pCtrLogQuery, VALIDATE_FOCUS);
        if ( bContinue ) {
            m_pCtrLogQuery->SetPropPageSharedData ( &m_SharedData );
            SetIsActive ( FALSE );
        }
    }
    return bContinue;
}

void
CCountersProperty::OnCancel()
{
    m_pCtrLogQuery->SyncPropPageSharedData();  // clear memory shared between property pages.
}

BOOL 
CCountersProperty::OnApply() 
{
    CListBox * pCounterList = (CListBox *)GetDlgItem(IDC_CTRS_COUNTER_LIST);
    long    lThisCounter;
    BOOL    bContinue = TRUE;
    WCHAR   szCounterPath[MAX_PATH];

    ResourceStateManager    rsm;

    bContinue = UpdateData(TRUE);
    
    if ( bContinue ) {
        bContinue = IsValidData(m_pCtrLogQuery, VALIDATE_APPLY );
    }

    if ( bContinue ) {
        bContinue = SampleTimeIsLessThanSessionTime ( m_pCtrLogQuery );
        if ( !bContinue ) {
            GetDlgItem ( IDC_CTRS_SAMPLE_EDIT )->SetFocus();    
        }
    }

    // Write data to the query object.
    if ( bContinue ) {

        ASSERT ( 0 < pCounterList->GetCount() );

        // update the counter MSZ string using the counters from the list box        
        m_pCtrLogQuery->ResetCounterList(); // clear the old counter list
    
        for ( lThisCounter = 0; lThisCounter < pCounterList->GetCount(); lThisCounter++ ) {
            if (pCounterList->GetTextLen(lThisCounter) < MAX_PATH) {
                pCounterList->GetText(lThisCounter, szCounterPath);
                m_pCtrLogQuery->AddCounter(szCounterPath);
            }
        }

        if ( bContinue ) {
        
            // Sample interval
            ASSERT ( SLQ_TT_TTYPE_SAMPLE == m_SharedData.stiSampleTime.wTimeType );
            ASSERT ( SLQ_TT_DTYPE_UNITS == m_SharedData.stiSampleTime.wDataType );

            bContinue = m_pCtrLogQuery->SetLogTime (&m_SharedData.stiSampleTime, (DWORD)m_SharedData.stiSampleTime.wTimeType);

            // Save property page shared data.
            m_pCtrLogQuery->UpdatePropPageSharedData();
            
            if ( bContinue ) { 
                bContinue = UpdateService( m_pCtrLogQuery, TRUE );
            }
        }
    }

    if ( bContinue ) {
        bContinue = Apply(m_pCtrLogQuery); 
    }

    if ( bContinue ){
        bContinue = CPropertyPage::OnApply();
    }

    return bContinue;
}

void 
CCountersProperty::UpdateLogStartString ()
{
    eStartType  eCurrentStartType;
    int     nResId = 0;
    ResourceStateManager    rsm;

    eCurrentStartType = DetermineCurrentStartType();

    if ( eStartManually == eCurrentStartType ) {
        nResId = IDS_LOG_START_MANUALLY;
    } else if ( eStartImmediately == eCurrentStartType ) {
        nResId = IDS_LOG_START_IMMED;
    } else if ( eStartSched == eCurrentStartType ) {
        nResId = IDS_LOG_START_SCHED;
    }
    if ( 0 != nResId ) {
        m_strStartDisplay.LoadString(nResId);
    } else {
        m_strStartDisplay.Empty();
    }

    return;
}


void CCountersProperty::UpdateFileNameString ()
{
    m_strFileNameDisplay.Empty();

    // Todo:  Handle failure status
    // Todo:  Check pointers
    CreateSampleFileName (
        m_pCtrLogQuery->GetLogName(),
        m_pCtrLogQuery->GetLogService()->GetMachineName(),
        m_SharedData.strFolderName, 
        m_SharedData.strFileBaseName,
        m_SharedData.strSqlName,
        m_SharedData.dwSuffix, 
        m_SharedData.dwLogFileType, 
        m_SharedData.dwSerialNumber,
        m_strFileNameDisplay );

    SetDlgItemText( IDC_CTRS_FILENAME_DISPLAY, m_strFileNameDisplay );
    
    // Clear the selection
    ((CEdit*)GetDlgItem( IDC_CTRS_FILENAME_DISPLAY ))->SetSel ( -1, FALSE );

    return;
}

BOOL CCountersProperty::OnInitDialog() 
{
    LPWSTR szCounterName;
    CListBox * pCounterList = (CListBox *)GetDlgItem(IDC_CTRS_COUNTER_LIST);
    CComboBox       *pCombo;
    int             nIndex;
    CString         strComboBoxString;
    int             nResult;
    DWORD           dwItemExtent;
    PPDH_COUNTER_PATH_ELEMENTS pCounterPath;
    CDC*            pCDC = NULL;

    ResourceStateManager rsm;

    //
    // Here m_pCtrLogQuery should not be NULL, if it is,
    // There must be something wrong.
    //
    if ( NULL == m_pCtrLogQuery ) {
        return TRUE;
    }
    m_bCanAccessRemoteWbem = m_pCtrLogQuery->GetLogService()->CanAccessWbemRemote();

MFC_TRY
    m_pCtrLogQuery->SetActivePropertyPage( this );

    //load counter list box from string in counter list
    pCounterList->ResetContent();
    ClearCountersHashTable();
    szCounterName = (LPWSTR)m_pCtrLogQuery->GetFirstCounter();

    pCDC = pCounterList->GetDC();

    while (szCounterName != NULL) {

        nIndex = pCounterList->AddString(szCounterName);
        if (nIndex < 0)
            continue;

        //
        // Insert counter path into hash table
        //

        pCounterPath = InsertCounterToHashTable(szCounterName);
        if (pCounterPath == NULL) {
            pCounterList->DeleteString(nIndex);
            continue;
        }
        
        pCounterList->SetItemDataPtr(nIndex, (void*)pCounterPath); 

        // update list box extent
        if ( NULL != pCDC ) {
            dwItemExtent = (DWORD)(pCDC->GetTextExtent (szCounterName)).cx;
            if (dwItemExtent > m_dwMaxHorizListExtent) {
                m_dwMaxHorizListExtent = dwItemExtent;
            }
        }

        szCounterName = (LPWSTR)m_pCtrLogQuery->GetNextCounter();
    }

    if ( NULL != pCDC ) {
        pCounterList->ReleaseDC(pCDC);
        pCDC = NULL;
    }

    if (m_dwMaxHorizListExtent != 0) {
        pCounterList->SetHorizontalExtent(m_dwMaxHorizListExtent);
    }

    if (pCounterList->GetCount() > 0) {
        // select first entry
        pCounterList->SetSel (0, TRUE);
        pCounterList->SetCaretIndex (0, TRUE);
    }

    // Load the shared data to get the sample unit type selection.
    m_pCtrLogQuery->GetPropPageSharedData ( &m_SharedData );

    // load combo boxes
    pCombo = (CComboBox *)(GetDlgItem(IDC_CTRS_SAMPLE_UNITS_COMBO));
    pCombo->ResetContent();
    for (nIndex = 0; nIndex < (int)dwTimeUnitComboEntries; nIndex++) {
        strComboBoxString.LoadString( TimeUnitCombo[nIndex].nResId );
        nResult = pCombo->InsertString (nIndex, (LPCWSTR)strComboBoxString);
        ASSERT (nResult != CB_ERR);
        nResult = pCombo->SetItemData (nIndex, (DWORD)TimeUnitCombo[nIndex].nData);
        ASSERT (nResult != CB_ERR);
        // set selected in combo box here
        if ( m_SharedData.stiSampleTime.dwUnitType == (DWORD)(TimeUnitCombo[nIndex].nData)) {
            m_nSampleUnits = nIndex;
            nResult = pCombo->SetCurSel(nIndex);
            ASSERT (nResult != CB_ERR);
        }
    }

    CSmPropertyPage::OnInitDialog();
    Initialize( m_pCtrLogQuery );
    m_strUserDisplay = m_pCtrLogQuery->m_strUser;
    m_strUserSaved = m_strUserDisplay;

    if (m_pCtrLogQuery->GetLogService()->IsWindows2000Server()) {
        CWnd* pRunAsStatic;

        //
        // Get the static "Run As" window, you can only call this function
        // when "Run As" really exists
        //
        pRunAsStatic = GetRunAsWindow();
        if (pRunAsStatic) {
            pRunAsStatic->EnableWindow(FALSE);
        }

        GetDlgItem(IDC_RUNAS_EDIT)->EnableWindow(FALSE);
    }
    if ( m_pCtrLogQuery->GetLogService()->IsWindows2000Server() ||
        m_strUserDisplay.IsEmpty() ||
        m_strUserDisplay.GetAt(0) == L'<') {

        GetDlgItem(IDC_SETPWD_BTN)->EnableWindow(FALSE);
        m_bPwdButtonEnabled = FALSE;
    }


    SetHelpIds ( (DWORD*)&s_aulHelpIds );

    SetButtonState();
MFC_CATCH_MINIMUM;
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void 
CCountersProperty::OnDeltaposSchedSampleSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
    OnDeltaposSpin(pNMHDR, pResult, &m_SharedData.stiSampleTime.dwValue, eMinSampleInterval, eMaxSampleInterval);
}

void 
CCountersProperty::OnSelendokSampleUnitsCombo() 
{
    int nSel;
    
    nSel = ((CComboBox *)GetDlgItem(IDC_CTRS_SAMPLE_UNITS_COMBO))->GetCurSel();
    
    if ((nSel != LB_ERR) && (nSel != m_nSampleUnits)) {
        UpdateData ( TRUE );
        SetModifiedPage ( TRUE );
    }
}

void 
CCountersProperty::OnKillfocusSchedSampleEdit() 
{
    DWORD   dwOldValue;
    dwOldValue = m_SharedData.stiSampleTime.dwValue;
    UpdateData ( TRUE );
    if (dwOldValue != m_SharedData.stiSampleTime.dwValue ) {
        SetModifiedPage(TRUE);
    }
}

void CCountersProperty::PostNcDestroy() 
{
//  delete this;      

    if ( NULL != m_pCtrLogQuery ) {
        m_pCtrLogQuery->SetActivePropertyPage( NULL );
    }

    CPropertyPage::PostNcDestroy();
}

//
//  Helper functions.
//
void 
CCountersProperty::ImplementAdd( BOOL bShowObjects ) 
{
    CListBox                *pCounterList;
    LONG                    lBeforeCount;
    LONG                    lAfterCount;
    CString                 strBrowseTitle;

    ResourceStateManager    rsm;

    if (m_szCounterListBuffer == NULL) {
        CString strDefaultPath;
        CString strObjCounter;

        try {
            strObjCounter.LoadString ( IDS_DEFAULT_PATH_OBJ_CTR );
            m_dwCounterListBufferSize = 0x4000;
            m_szCounterListBuffer = new WCHAR[m_dwCounterListBufferSize];
            if ( ((CSmLogService*)m_pCtrLogQuery->GetLogService())->IsLocalMachine() ) {
                strDefaultPath = _T("\\");
            } else {
                strDefaultPath = _T("\\\\");
                strDefaultPath += ((CSmLogService*)m_pCtrLogQuery->GetLogService())->GetMachineName();
            }
            strDefaultPath += strObjCounter;
            lstrcpy ( m_szCounterListBuffer, strDefaultPath);
        } catch ( ... ) {
            m_dwCounterListBufferSize = 0;
            return;
        }
    }

    m_dlgConfig.bIncludeInstanceIndex = 1;
    m_dlgConfig.bSingleCounterPerAdd = 0;
    m_dlgConfig.bSingleCounterPerDialog = 0;
    m_dlgConfig.bLocalCountersOnly = 0;

    // allow wild cards. 
    // the log service should expand them if necessary.
    m_dlgConfig.bWildCardInstances = 1; 

    m_dlgConfig.bHideDetailBox = 1;
    m_dlgConfig.bInitializePath = 1;
    m_dlgConfig.bDisableMachineSelection = 0;
    m_dlgConfig.bIncludeCostlyObjects = 0;
    m_dlgConfig.bReserved = 0;

    m_dlgConfig.hWndOwner = this->m_hWnd;
    m_dlgConfig.szDataSource = NULL;

    m_dlgConfig.szReturnPathBuffer = m_szCounterListBuffer;
    m_dlgConfig.cchReturnPathLength = m_dwCounterListBufferSize;
    m_dlgConfig.pCallBack = (CounterPathCallBack)DialogCallBack;
    m_dlgConfig.dwDefaultDetailLevel = PERF_DETAIL_WIZARD;
    m_dlgConfig.dwCallBackArg = (UINT_PTR)this;
    m_dlgConfig.CallBackStatus = ERROR_SUCCESS;
    m_dlgConfig.bShowObjectBrowser = (bShowObjects ? 1 : 0);

    strBrowseTitle.LoadString (bShowObjects ? IDS_ADD_OBJECTS
                                            : IDS_ADD_COUNTERS);
    m_dlgConfig.szDialogBoxCaption = strBrowseTitle.GetBuffer( strBrowseTitle.GetLength() );

    pCounterList = (CListBox *)GetDlgItem(IDC_CTRS_COUNTER_LIST);
    // get count of items in the list box before calling the browser
    lBeforeCount = pCounterList->GetCount();

    PdhBrowseCounters (&m_dlgConfig);

    strBrowseTitle.ReleaseBuffer();

    // get count of items in the list box After calling the browser
    // to see if the Apply button should enabled
    lAfterCount = pCounterList->GetCount();

    if (lAfterCount > lBeforeCount) 
        SetModifiedPage(TRUE);

    // see if the remove button should be enabled
    SetButtonState();

    delete m_szCounterListBuffer;
    m_szCounterListBuffer = NULL;
    m_dwCounterListBufferSize = 0;
}

void 
CCountersProperty::SetButtonState ()
{
    BOOL bCountersExist;
    CListBox                *pCounterList;

    pCounterList = (CListBox *)GetDlgItem(IDC_CTRS_COUNTER_LIST);
    bCountersExist = ( 0 < pCounterList->GetCount()) ? TRUE : FALSE;

    GetDlgItem(IDC_CTRS_SAMPLE_CAPTION)->EnableWindow(bCountersExist);
    GetDlgItem(IDC_CTRS_SAMPLE_INTERVAL_CAPTION)->EnableWindow(bCountersExist);
    GetDlgItem(IDC_CTRS_SAMPLE_EDIT)->EnableWindow(bCountersExist);
    GetDlgItem(IDC_CTRS_SAMPLE_SPIN)->EnableWindow(bCountersExist);
    GetDlgItem(IDC_CTRS_SAMPLE_UNITS_CAPTION)->EnableWindow(bCountersExist);
    GetDlgItem(IDC_CTRS_SAMPLE_UNITS_COMBO)->EnableWindow(bCountersExist);

    GetDlgItem(IDC_CTRS_REMOVE_BTN)->EnableWindow(bCountersExist);
    if ( bCountersExist ) {
        GetDlgItem(IDC_CTRS_ADD_BTN)->SetFocus();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\dialogs.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    fileprop.cpp

Abstract:

    Implementation of the files property page.

--*/

#include "stdafx.h"
#include "dialogs.h"
#include "smcfghlp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("SMLOGCFG(dialogs.cpp)");

static ULONG
sPASSWORD_aulHelpIds[] =
{
    IDC_USERNAME,    IDH_USERNAME,
    IDC_PASSWORD1,   IDH_CTRS_ENTER_PWD,
    IDC_PASSWORD2,   IDH_CTRS_REENTER_PWD,
    0,0
};

void KillString( CString& str )
{
    LONG nSize = str.GetLength();
    for( LONG i=0;i<nSize;i++ ){
        str.SetAt( i, '*');
    }
}


/////////////////////////////////////////////////////////////////////////////
// CPasswordDlg dialog


CPasswordDlg::CPasswordDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CPasswordDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPasswordDlg)
	m_strUserName = _T("");
	m_strPassword1 = _T("");
	m_strPassword2 = _T("");
	//}}AFX_DATA_INIT
}

CPasswordDlg::~CPasswordDlg()
{
    KillString( m_strPassword1 );
    KillString( m_strPassword2 );
}

void CPasswordDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPasswordDlg)
	DDX_Text(pDX, IDC_USERNAME,  m_strUserName);
	DDX_Text(pDX, IDC_PASSWORD1, m_strPassword1);
	DDX_Text(pDX, IDC_PASSWORD2, m_strPassword2);
	//}}AFX_DATA_MAP
}

BOOL CPasswordDlg::OnInitDialog()
{
    if( m_strUserName.GetLength() ){
        GetDlgItem( IDC_USERNAME )->EnableWindow(FALSE);
        GetDlgItem( IDC_PASSWORD1 )->SetFocus();
    }
    
    CDialog::OnInitDialog();
    return FALSE;
}

void CPasswordDlg::OnOK() 
{
    UpdateData();
    if( m_strPassword1 != m_strPassword2 ){
        CString strMessage;
        CString strTitle;
        strMessage.LoadString ( IDS_BAD_PASSWORD_MATCH );
        strTitle.LoadString( IDS_PASSWORD_TITLE );
        MessageBox ( strMessage, strTitle, MB_OK  | MB_ICONERROR);            
        GetDlgItem( IDC_PASSWORD1 )->SetFocus();
        return;
    }

	CDialog::OnOK();
}

BOOL
CPasswordDlg::OnHelpInfo(HELPINFO * pHelpInfo)
{
    if (pHelpInfo->iCtrlId >= IDC_PWD_FIRST_HELP_CTRL_ID || 
        pHelpInfo->iCtrlId == IDOK ||
        pHelpInfo->iCtrlId== IDCANCEL ) {

        InvokeWinHelp(WM_HELP,
                      NULL,
                      (LPARAM) pHelpInfo,
                      m_strHelpFilePath,
                      sPASSWORD_aulHelpIds);
    }
    return TRUE;
}

DWORD
CPasswordDlg::SetContextHelpFilePath(const CString& rstrPath)
{
    DWORD dwStatus = ERROR_SUCCESS;
    MFC_TRY
        m_strHelpFilePath = rstrPath;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

BEGIN_MESSAGE_MAP(CPasswordDlg, CDialog)
	//{{AFX_MSG_MAP(CPasswordDlg)
     ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\enabldlg.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    enabldlg.cpp

Abstract:

    Implementation of the provider status dialog box.

--*/

#include "stdafx.h"
#include "provprop.h"
#include "smcfgmsg.h"
#include "smlogcfg.h"
#include "enabldlg.h"
#include "smcfghlp.h"
#include "smtprov.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static ULONG
s_aulHelpIds[] =
{
	IDC_PACT_CHECK_SHOW_ENABLED,	IDH_PACT_CHECK_SHOW_ENABLED,
	IDC_PACT_PROVIDERS_LIST,		IDH_PACT_PROVIDERS_LIST,
    0,0
};

/////////////////////////////////////////////////////////////////////////////
// CActiveProviderDlg dialog


CActiveProviderDlg::CActiveProviderDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CActiveProviderDlg::IDD, pParent),
      m_pProvidersPage( NULL ),
      m_iListViewWidth(0)
{
    //{{AFX_DATA_INIT(CActiveProviderDlg)
    
    //}}AFX_DATA_INIT
}


void CActiveProviderDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CActiveProviderDlg)
    DDX_Control(pDX, IDC_PACT_PROVIDERS_LIST, m_Providers);
    DDX_Check(pDX, IDC_PACT_CHECK_SHOW_ENABLED, m_bShowEnabledOnly);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CActiveProviderDlg, CDialog)
    //{{AFX_MSG_MAP(CActiveProviderDlg)
    ON_BN_CLICKED(IDC_PACT_CHECK_SHOW_ENABLED, OnCheckShowEnabled)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CActiveProviderDlg message handlers

BOOL 
CActiveProviderDlg::OnInitDialog() 
{
    RECT    rect;

    m_bShowEnabledOnly = FALSE;

    CDialog::OnInitDialog();    // Calls UpdateDate ( FALSE ) to init the checkbox value.

    // Get the width of the list view control, then delete the default column.
    m_Providers.GetClientRect(&rect);
    m_iListViewWidth = rect.right;    

    UpdateList();   

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void 
CActiveProviderDlg::OnCheckShowEnabled() 
{
    
//    ::SendMessage(m_Providers.m_hWnd, WM_SETREDRAW, TRUE, 0);
    UpdateData(TRUE);
    UpdateList();
    
}

BOOL 
CActiveProviderDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    ASSERT( NULL != m_pProvidersPage );

    if ( pHelpInfo->iCtrlId >= IDC_PACT_FIRST_HELP_CTRL_ID ) {
        InvokeWinHelp(WM_HELP, NULL, (LPARAM)pHelpInfo, m_pProvidersPage->GetContextHelpFilePath(), s_aulHelpIds);
    }
    return TRUE;
}

void 
CActiveProviderDlg::OnContextMenu(CWnd* pWnd, CPoint /* point */) 
{
    ASSERT( NULL != m_pProvidersPage );

    InvokeWinHelp(WM_CONTEXTMENU, (WPARAM)( pWnd->m_hWnd), NULL, m_pProvidersPage->GetContextHelpFilePath(), s_aulHelpIds);

    return;
}

// Helper functions
void CActiveProviderDlg::UpdateList()
{
    LVCOLUMN    lvCol;
    LVITEM      lvItem;
    INT         iGenIndex;
    INT         iAllIndex;
    INT         iEnabledIndex;
    INT         iCount;
    CString     arrstrHeader[2]; 
    CString     strEnabled;
    INT         iColWidth[2];
    CString     strItemText;

    ResourceStateManager    rsm;

    (arrstrHeader[0]).LoadString( IDS_PROV_NAME );
    (arrstrHeader[1]).LoadString( IDS_PROV_STATUS );
    strEnabled.LoadString(IDS_PROV_ENABLED);

    m_Providers.DeleteAllItems();
    m_Providers.DeleteColumn(1);        // Note - Column 1 might not exist.
    m_Providers.DeleteColumn(0);

    lvCol.mask = LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH | LVCF_FMT;
    lvCol.fmt = LVCFMT_LEFT;

    if ( m_bShowEnabledOnly ) {
        iColWidth[0] = m_iListViewWidth;
        iColWidth[1] = 0;
    } else {
        iColWidth[0] = (m_iListViewWidth * 75) / 100;
        iColWidth[1] = (m_iListViewWidth * 25) / 100;
    }

    if ( m_bShowEnabledOnly ) {
        lvCol.iSubItem = 0;
        lvCol.pszText = arrstrHeader[0].GetBufferSetLength( arrstrHeader[0].GetLength());
        lvCol.cx = iColWidth[0];
        m_Providers.InsertColumn(0,&lvCol);
    } else {
        INT iColIndex;
        for (iColIndex = 0 ; iColIndex < 2 ;iColIndex++ ){
            lvCol.iSubItem = 0;
            lvCol.pszText = arrstrHeader[iColIndex].GetBufferSetLength( arrstrHeader[iColIndex].GetLength());
            lvCol.cx = iColWidth[iColIndex];
            m_Providers.InsertColumn(iColIndex,&lvCol);
        }
    }
    
    iEnabledIndex = 0;
    iAllIndex = 0;
    // Add Kernel provider separately.
    if(m_bShowEnabledOnly) { 
        if ( m_pProvidersPage->GetKernelProviderEnabled() ) {
            m_Providers.InsertItem(iEnabledIndex,(LPCTSTR)(m_pProvidersPage->GetKernelProviderDescription()));
        }
    } else {
        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = 0;
        lvItem.iSubItem = 0;    

        m_Providers.InsertItem(iAllIndex++,(LPCTSTR)(m_pProvidersPage->GetKernelProviderDescription()));
    
        // Show status
        if ( m_pProvidersPage->GetKernelProviderEnabled() ) {
            lvItem.pszText = strEnabled.GetBufferSetLength( strEnabled.GetLength() );
            lvItem.iSubItem = 1;
            m_Providers.SetItem(&lvItem);
        }
    }

    // Add general providers
    m_pProvidersPage->GetGenProviderCount( iCount );
    for ( iGenIndex = 0; iGenIndex < iCount ; iGenIndex++ ){
        
        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = iAllIndex;
        lvItem.iSubItem = 0;  
        
        if ( m_pProvidersPage->IsActiveProvider(iGenIndex) ) {
            CString strProviderName;
            
            if(m_bShowEnabledOnly){
                if ( m_pProvidersPage->IsEnabledProvider(iGenIndex) ){
                    m_pProvidersPage->GetProviderDescription ( iGenIndex, strProviderName );
                    m_Providers.InsertItem (iEnabledIndex++,strProviderName );
                }
            } else {
                m_pProvidersPage->GetProviderDescription ( iGenIndex, strProviderName );
                m_Providers.InsertItem (iAllIndex,strProviderName );

                // Show status
                if ( m_pProvidersPage->IsEnabledProvider(iGenIndex) ){
                    lvItem.pszText = strEnabled.GetBufferSetLength( strEnabled.GetLength() );
                    lvItem.iSubItem = 1;
                    m_Providers.SetItem(&lvItem);
                }
            }
        }
    }
}

void    
CActiveProviderDlg::SetProvidersPage( CProvidersProperty* pPage ) 
{ 
    // The providers page is not always the parent, so store a separate pointer
    m_pProvidersPage = pPage; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\filelogs.h ===
#if !defined(AFX_FILELOGS_H_INCLUDED_)
#define AFX_FILELOGS_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FileLogs.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFileLogs dialog

#define IDD_FILE_LOGS_DLG               2000

#define IDC_FILELOG_FIRST_HELP_CTRL_ID  2006

#define IDC_FILES_SIZE_GROUP            2001
#define IDC_FILES_FOLDER_CAPTION        2002
#define IDC_FILES_FILENAME_CAPTION      2003
#define IDC_FILES_SIZE_LIMIT_UNITS      2004
#define IDC_FILES_SIZE_LIMIT_SPIN       2005

#define IDC_FILES_FOLDER_EDIT           2006
#define IDC_FILES_FOLDER_BTN            2007
#define IDC_FILES_FILENAME_EDIT         2008
#define IDC_FILES_SIZE_MAX_BTN          2009
#define IDC_FILES_SIZE_LIMIT_BTN        2010
#define IDC_FILES_SIZE_LIMIT_EDIT       2011


class CFileLogs : public CDialog
{    

public:

    // Construction
	        CFileLogs(CWnd* pParent = NULL);   // standard constructor
    virtual ~CFileLogs(){};

    DWORD SetContextHelpFilePath(const CString& rstrPath);

	//{{AFX_DATA(CFileLogs)
	enum { IDD = IDD_FILE_LOGS_DLG };
	CString	m_strFileBaseName;
	CString	m_strFolderName;
    DWORD   m_dwSerialNumber;
    DWORD   m_dwMaxSize;
	int		m_nFileSizeRdo;
	//}}AFX_DATA

    UINT    m_dwMaxSizeInternal;
    DWORD   m_dwLogFileTypeValue;
    BOOL    m_bAutoNameSuffix;
    DWORD   m_dwFocusControl;
    HINSTANCE m_hModule;
	CSmLogQuery* m_pLogQuery;

private:

	BOOL IsValidLocalData();
    void FileSizeBtn(BOOL bInit);
	void FileSizeBtnEnable();
	void OnDeltaposSpin(NMHDR *pNMHDR, LRESULT *pResult, DWORD *pValue, DWORD dMinValue, DWORD dMaxValue);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFileLogs)
    protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
	//{{AFX_MSG(CFileLogs)
	afx_msg void OnFilesFolderBtn();
	afx_msg void OnChangeFilesFilenameEdit();
	afx_msg void OnChangeFilesFolderEdit();
	afx_msg void OnChangeFilesSizeLimitEdit();
	afx_msg void OnFilesSizeLimitBtn();
	afx_msg void OnDeltaposFilesSizeLimitSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnFilesSizeMaxBtn();
	afx_msg void OnKillfocusFilesFilenameEdit();
	afx_msg void OnKillfocusFilesFolderEdit();
	afx_msg void OnKillfocusFilesSizeLimitEdit();
    afx_msg BOOL OnHelpInfo(HELPINFO *);
    afx_msg void OnContextMenu( CWnd*, CPoint );
	virtual BOOL OnInitDialog();
    virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

    void    ValidateTextEdit(CDataExchange * pDX,
                             int             nIDC,
                             int             nMaxChars,
                             DWORD         * value,
                             DWORD           minValue,
                             DWORD           maxValue);
    
    BOOL    ValidateDWordInterval(int     nIDC,
                                  LPCWSTR strLogName,
                                  long    lValue,
                                  DWORD   minValue,
                                  DWORD   maxValue);

    CString     m_strHelpFilePath;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FILELOGS_H__92E00D45_B61D_4CDF_82E4_96BB52D4D236__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\fileprop.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    fileprop.cpp

Abstract:

    Implementation of the files property page.

--*/

#include "stdafx.h"
#include "smlogs.h"
#include "smcfgmsg.h"
#include "smlogqry.h"
#include "FileLogs.h"
#include "sqlprop.h"
#include "fileprop.h"
#include "globals.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("SMLOGCFG(fileprop.cpp)");

static ULONG
s_aulHelpIds[] =
{
    IDC_FILES_COMMENT_EDIT,     IDH_FILES_COMMENT_EDIT,
    IDC_FILES_LOG_TYPE_COMBO,   IDH_FILES_LOG_TYPE_COMBO,
    IDC_CFG_BTN,                IDH_CFG_BTN,
    IDC_FILES_AUTO_SUFFIX_CHK,  IDH_FILES_AUTO_SUFFIX_CHK,
    IDC_FILES_SUFFIX_COMBO,     IDH_FILES_SUFFIX_COMBO,
    IDC_FILES_FIRST_SERIAL_EDIT,IDH_FILES_FIRST_SERIAL_EDIT,
    IDC_FILES_SAMPLE_DISPLAY,   IDH_FILES_SAMPLE_DISPLAY,
    IDC_FILES_OVERWRITE_CHK,    IDH_FILES_OVERWRITE_CHK,
    0,0
};


/////////////////////////////////////////////////////////////////////////////
// CFilesProperty property page

IMPLEMENT_DYNCREATE(CFilesProperty, CSmPropertyPage)

CFilesProperty::CFilesProperty(MMC_COOKIE   mmcCookie, LONG_PTR hConsole) 
:   CSmPropertyPage ( CFilesProperty::IDD, hConsole )
{
//    ::OutputDebugStringA("\nCFilesProperty::CFilesProperty");

    // save pointers from arg list
    m_pLogQuery = reinterpret_cast <CSmLogQuery *>(mmcCookie);
    m_dwSuffixValue = 0;
    m_dwLogFileTypeValue = 0;
    m_dwAppendMode = 0;
    m_dwMaxSizeInternal = 0;
    m_dwSubDlgFocusCtrl = 0;
//  EnableAutomation();
    //{{AFX_DATA_INIT(CFilesProperty)
    m_iLogFileType = -1;
    m_dwSuffix = -1;
    m_dwSerialNumber = 1;
    m_bAutoNameSuffix = FALSE;
    m_bOverWriteFile  = FALSE;
    //}}AFX_DATA_INIT
}

CFilesProperty::CFilesProperty() : CSmPropertyPage ( CFilesProperty::IDD )
{
    ASSERT (FALSE); // only the constructor with args above should be used

    EnableAutomation();
    m_dwSuffixValue = 0;
    m_dwAppendMode = 0;
    m_dwMaxSizeInternal = 0;
    m_dwSubDlgFocusCtrl = 0;
//  //{{AFX_DATA_INIT(CFilesProperty)
    m_iLogFileType = -1;
    m_dwSuffix = -1;
    m_dwSerialNumber = 1;
    m_bAutoNameSuffix = FALSE;
    m_bOverWriteFile  = FALSE;
//  //}}AFX_DATA_INIT

    // CString variables are empty on construction.
}

CFilesProperty::~CFilesProperty()
{
//    ::OutputDebugStringA("\nCFilesProperty::~CFilesProperty");
}

void CFilesProperty::OnFinalRelease()
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CPropertyPage::OnFinalRelease();
}

void CFilesProperty::DoDataExchange(CDataExchange* pDX)
{
    CString strTemp;

    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFilesProperty)
    DDX_Text(pDX, IDC_FILES_COMMENT_EDIT, m_strCommentText);
    DDV_MaxChars(pDX, m_strCommentText, MAX_PATH);
    DDX_CBIndex(pDX, IDC_FILES_LOG_TYPE_COMBO, m_iLogFileType);
    DDX_CBIndex(pDX, IDC_FILES_SUFFIX_COMBO, m_dwSuffix);
    DDX_Check(pDX, IDC_FILES_AUTO_SUFFIX_CHK, m_bAutoNameSuffix);
    DDX_Check(pDX, IDC_FILES_OVERWRITE_CHK, m_bOverWriteFile);
    ValidateTextEdit(pDX, IDC_FILES_FIRST_SERIAL_EDIT, 6, (DWORD *) & m_dwSerialNumber, eMinFirstSerial, eMaxFirstSerial);
    //}}AFX_DATA_MAP
    
    if ( pDX->m_bSaveAndValidate ) {
        m_dwLogFileTypeValue = (DWORD)((CComboBox *)GetDlgItem(IDC_FILES_LOG_TYPE_COMBO))->GetItemData(m_iLogFileType);    
        if ( m_bAutoNameSuffix ) {
            m_dwSuffixValue = (DWORD)((CComboBox *)GetDlgItem(IDC_FILES_SUFFIX_COMBO))->GetItemData(m_dwSuffix);    
        }
    }
}


BEGIN_MESSAGE_MAP(CFilesProperty, CSmPropertyPage)
    //{{AFX_MSG_MAP(CFilesProperty)
    ON_WM_DESTROY()
    ON_BN_CLICKED(IDC_FILES_AUTO_SUFFIX_CHK, OnAutoSuffixChk)
    ON_BN_CLICKED(IDC_FILES_OVERWRITE_CHK, OnOverWriteChk)
    ON_EN_CHANGE(IDC_FILES_COMMENT_EDIT, OnChangeFilesCommentEdit)
    ON_EN_KILLFOCUS(IDC_FILES_COMMENT_EDIT, OnKillfocusFilesCommentEdit)
    ON_EN_CHANGE(IDC_FILES_FIRST_SERIAL_EDIT, OnChangeFilesFirstSerialEdit)    
    ON_EN_KILLFOCUS(IDC_FILES_FIRST_SERIAL_EDIT, OnKillfocusFirstSerialEdit)
    ON_CBN_SELENDOK(IDC_FILES_LOG_TYPE_COMBO, OnSelendokFilesLogFileTypeCombo)
    ON_CBN_SELENDOK(IDC_FILES_SUFFIX_COMBO, OnSelendokFilesSuffixCombo)
    ON_CBN_KILLFOCUS(IDC_FILES_SUFFIX_COMBO, OnKillfocusFilesSuffixCombo)
    ON_CBN_KILLFOCUS(IDC_FILES_LOG_TYPE_COMBO, OnKillfocusFilesLogFileTypeCombo)
    ON_BN_CLICKED(IDC_CFG_BTN, OnCfgBtn)

    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CFilesProperty, CSmPropertyPage)
    //{{AFX_DISPATCH_MAP(CFilesProperty)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IFilesProperty to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {65154EAB-BDBE-11D1-BF99-00C04F94A83A}
static const IID IID_IFilesProperty =
{ 0x65154eab, 0xbdbe, 0x11d1, { 0xbf, 0x99, 0x0, 0xc0, 0x4f, 0x94, 0xa8, 0x3a } };

BEGIN_INTERFACE_MAP(CFilesProperty, CSmPropertyPage)
    INTERFACE_PART(CFilesProperty, IID_IFilesProperty, Dispatch)
END_INTERFACE_MAP()

void 
CFilesProperty::EnableSerialNumber( void ) 
{
    BOOL bEnable = ( SLF_NAME_NNNNNN == m_dwSuffixValue );
    
    if ( bEnable )
        bEnable = m_bAutoNameSuffix;

    GetDlgItem(IDC_FILES_FIRST_SERIAL_CAPTION)->EnableWindow( bEnable );
    GetDlgItem(IDC_FILES_FIRST_SERIAL_EDIT)->EnableWindow( bEnable );

}

BOOL
CFilesProperty::UpdateSampleFileName( void )
{
    CString     strCompositeName;
    BOOL        bIsValid = TRUE;
    DWORD       dwLocalSuffixValue = SLF_NAME_NONE;

    ResourceStateManager    rsm;
    
    if (m_bAutoNameSuffix) {
        dwLocalSuffixValue = m_dwSuffixValue;
    }

    CreateSampleFileName (
        m_pLogQuery->GetLogName(),
        m_pLogQuery->GetLogService()->GetMachineName(),
        m_strFolderName,   
        m_strFileBaseName, 
        m_strSqlName, 
        dwLocalSuffixValue,
        m_dwLogFileTypeValue,
        m_dwSerialNumber,
        strCompositeName );
    
    m_strSampleFileName = strCompositeName;

    // Or call UpdateData ( FALSE );
    SetDlgItemText (IDC_FILES_SAMPLE_DISPLAY, strCompositeName);

    // Clear the selection
    ((CEdit*)GetDlgItem( IDC_FILES_SAMPLE_DISPLAY ))->SetSel ( -1, FALSE );

    if ( MAX_PATH <= m_strSampleFileName.GetLength() ) {
        bIsValid = FALSE;
    }

    return bIsValid;
}

void 
CFilesProperty::HandleLogTypeChange() 
{
    int nSel;
    
    nSel = ((CComboBox *)GetDlgItem(IDC_FILES_LOG_TYPE_COMBO))->GetCurSel();

    // nSel != m_iLogFileType determines data change.
    if ((nSel != LB_ERR) && (nSel != m_iLogFileType)) {

        UpdateData( TRUE );

        if ( SLF_BIN_FILE != m_dwLogFileTypeValue
                && SLF_SEQ_TRACE_FILE != m_dwLogFileTypeValue ) 
        {
            GetDlgItem(IDC_FILES_OVERWRITE_CHK)->EnableWindow(FALSE);
        } else {
            GetDlgItem(IDC_FILES_OVERWRITE_CHK)->EnableWindow( TRUE );
        }
        OnOverWriteChk();

        EnableSerialNumber();
        UpdateSampleFileName();
        SetModifiedPage(TRUE);
    }
}

BOOL 
CFilesProperty::IsValidLocalData()
{
    BOOL bIsValid = TRUE;
    CString strTest;
    eValueRange eMaxFileSize;

    ResourceStateManager rsm;

    // assumes UpdateData has been called

    if ( !UpdateSampleFileName() ) {
        CString strMessage;
        strMessage.LoadString ( IDS_FILE_ERR_NAMETOOLONG );
        MessageBox ( strMessage, m_pLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);            
        bIsValid = FALSE;
        m_dwSubDlgFocusCtrl = IDC_FILES_FILENAME_EDIT;
        OnCfgBtn();
    }

    if ( bIsValid ) {
        if ( m_strFolderName.IsEmpty() && (SLF_SQL_LOG != m_dwLogFileTypeValue)) {
            CString strMessage;
            strMessage.LoadString ( IDS_FILE_ERR_NOFOLDERNAME );
            MessageBox ( strMessage, m_pLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
            bIsValid = FALSE;
            m_dwSubDlgFocusCtrl = IDC_FILES_FOLDER_EDIT;
            OnCfgBtn();
        }
    }

    if ( bIsValid ) {
        if ( SLF_SQL_LOG != m_dwLogFileTypeValue ) {
            if ( m_strFileBaseName.IsEmpty() && !m_bAutoNameSuffix ) {
                CString strMessage;
                strMessage.LoadString ( IDS_FILE_ERR_NOFILENAME );
                MessageBox ( strMessage, m_pLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
                bIsValid = FALSE;
                m_dwSubDlgFocusCtrl = IDC_FILES_FILENAME_EDIT;
                OnCfgBtn();
            }

            if ( bIsValid ) {
                if ( !FileNameIsValid ( &m_strFileBaseName ) ) {
                    CString strMessage;
                    strMessage.LoadString (IDS_ERRMSG_INVALIDCHAR);
                    MessageBox( strMessage, m_pLogQuery->GetLogName(), MB_OK| MB_ICONERROR );
                    bIsValid = FALSE;
                    m_dwSubDlgFocusCtrl = IDC_FILES_FILENAME_EDIT;
                    OnCfgBtn();
                }
            }
        } else {

            ExtractDSN ( strTest );
            if ( strTest.IsEmpty() ) {
                CString strMessage;
                strMessage.LoadString ( IDS_SQL_ERR_NODSN );
                MessageBox ( strMessage, m_pLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
                bIsValid = FALSE;
                m_dwSubDlgFocusCtrl = IDC_SQL_DSN_COMBO;
                OnCfgBtn();
            }

            if ( bIsValid ) {

                ExtractLogSetName ( strTest );
                if ( strTest.IsEmpty() && !m_bAutoNameSuffix ) {
                    CString strMessage;
                    strMessage.LoadString ( IDS_SQL_ERR_NOLOGSETNAME );
                    MessageBox ( strMessage, m_pLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
                    bIsValid = FALSE;
                    m_dwSubDlgFocusCtrl = IDC_SQL_LOG_SET_EDIT;
                    OnCfgBtn();
                } else if ( !FileNameIsValid ( &strTest ) ){
                    CString strMessage;
                    strMessage.LoadString (IDS_ERRMSG_INVALIDCHAR);
                    MessageBox( strMessage, m_pLogQuery->GetLogName(), MB_OK| MB_ICONERROR );
                    bIsValid = FALSE;
                    m_dwSubDlgFocusCtrl = IDC_SQL_LOG_SET_EDIT;
                    OnCfgBtn();
                }
            }
        }
    }

    // Validate max log file size based on log file type
    if (bIsValid)
    {
        if ( SLQ_DISK_MAX_SIZE != m_dwMaxSizeInternal ) {
            if ( SLF_BIN_FILE == m_dwLogFileTypeValue ) {
                eMaxFileSize = eMaxCtrSeqBinFileLimit;
            } else if ( SLF_SEQ_TRACE_FILE == m_dwLogFileTypeValue ) {
                eMaxFileSize = eMaxTrcSeqBinFileLimit;
            } else if ( SLF_SQL_LOG == m_dwLogFileTypeValue ) {
                eMaxFileSize = eMaxSqlRecordsLimit;
            } else {
                eMaxFileSize = eMaxFileLimit;
            }

            bIsValid = ValidateDWordInterval(IDC_CFG_BTN,
                                             m_pLogQuery->GetLogName(),
                                             (long) m_dwMaxSizeInternal,
                                             eMinFileLimit,
                                             eMaxFileSize); 
            if ( !bIsValid ) {
                if ( SLF_SQL_LOG == m_dwLogFileTypeValue ) {
                    m_dwSubDlgFocusCtrl = IDC_SQL_SIZE_LIMIT_EDIT;
                } else {
                    m_dwSubDlgFocusCtrl = IDC_FILES_SIZE_LIMIT_EDIT;
                }
                OnCfgBtn();
            }

        }
    }

    if (bIsValid)
    {
        bIsValid = ValidateDWordInterval(IDC_FILES_FIRST_SERIAL_EDIT,
                                         m_pLogQuery->GetLogName(),
                                         (long) m_dwSerialNumber,
                                         eMinFirstSerial,
                                         eMaxFirstSerial);
    }

    return bIsValid;
}
/////////////////////////////////////////////////////////////////////////////
// CFilesProperty message handlers

void 
CFilesProperty::OnCancel() 
{
    m_pLogQuery->SyncPropPageSharedData(); // Clear the memory shared between property pages.
}

BOOL 
CFilesProperty::OnApply() 
{
    BOOL bContinue = TRUE;
    
    ResourceStateManager    rsm;
    // load data from dialog
    bContinue = UpdateData (TRUE); 

    if ( bContinue ) {
        bContinue = IsValidData(m_pLogQuery, VALIDATE_APPLY );
    }

    if ( bContinue ) { 
        bContinue = SampleTimeIsLessThanSessionTime ( m_pLogQuery );
    }

    // pass data to the query object
    if ( bContinue ) { 
        bContinue = UpdateSharedData( TRUE );
    }

    if ( bContinue ) {
        m_pLogQuery->SetLogComment(m_strCommentText);
        m_pLogQuery->SetFileNameParts(m_strFolderName, m_strFileBaseName);
        m_pLogQuery->SetSqlName(m_strSqlName);
        if ( TRUE == m_bAutoNameSuffix ) {
            m_pLogQuery->SetFileNameAutoFormat(m_dwSuffixValue);
        } else {
            m_pLogQuery->SetFileNameAutoFormat(SLF_NAME_NONE);
        }

        m_pLogQuery->SetFileSerialNumber( m_dwSerialNumber );
        m_pLogQuery->SetMaxSize(m_dwMaxSizeInternal);

        // Save property page shared data.
        m_pLogQuery->UpdatePropPageSharedData();

        if ( LOWORD(m_dwLogFileTypeValue) == SLF_BIN_FILE 
                || SLF_SEQ_TRACE_FILE == LOWORD(m_dwLogFileTypeValue) ) {
            if ( m_bOverWriteFile ) {
                m_pLogQuery->SetDataStoreAppendMode( SLF_DATA_STORE_OVERWRITE );
            } else {
                m_pLogQuery->SetDataStoreAppendMode( SLF_DATA_STORE_APPEND );
            }
        } else {
            if ( SLF_SQL_LOG == LOWORD(m_dwLogFileTypeValue) ) {
                m_pLogQuery->SetDataStoreAppendMode ( SLF_DATA_STORE_APPEND );
            } else {
                m_pLogQuery->SetDataStoreAppendMode ( SLF_DATA_STORE_OVERWRITE );
            }
        }

        m_pLogQuery->SetLogFileType ( m_dwLogFileTypeValue );

        if ( bContinue ) {
            bContinue = Apply(m_pLogQuery); 
        }

        bContinue = CPropertyPage::OnApply();
        
        // Sync the service with changes.
        if ( bContinue ) {
            
            bContinue = UpdateService( m_pLogQuery, FALSE );

            if ( bContinue ) {
                AFX_MANAGE_STATE(AfxGetStaticModuleState());                
                CWaitCursor     WaitCursor;
                // Service might have changed the serial number, so sync it.
                // Don't sync data that is modified by other pages.
                m_pLogQuery->SyncSerialNumberWithRegistry();
                m_dwSerialNumber = m_pLogQuery->GetFileSerialNumber();   
            }
        }
    }

    return bContinue;
}

BOOL CFilesProperty::OnInitDialog() 
{
    UINT    nIndex;
    CString strComboBoxString;
    CComboBox *pCombo;
    UINT    nResult;
    DWORD   dwEntries;
    PCOMBO_BOX_DATA_MAP pCbData;

    ResourceStateManager    rsm;

    m_strLogName = m_pLogQuery->GetLogName();
    
    m_pLogQuery->GetLogComment ( m_strCommentText );

    // Why get max size internal when it is in the shared data?
    // This should not be a problem, because only this page
    // modifies the value, and GetMaxSize is only called in OnInitDialog.
    m_dwMaxSizeInternal = m_pLogQuery->GetMaxSize();
        
    // load log file type combo box
    
    m_pLogQuery->GetLogFileType ( m_dwLogFileTypeValue );
    m_pLogQuery->GetDataStoreAppendMode ( dwEntries );

    m_bOverWriteFile = ( SLF_DATA_STORE_OVERWRITE == dwEntries );
    
    if ( SLQ_TRACE_LOG == m_pLogQuery->GetLogType() ) {
        dwEntries = dwTraceFileTypeComboEntries;
        pCbData = (PCOMBO_BOX_DATA_MAP)&TraceFileTypeCombo[0];
    } else {
        dwEntries = dwFileTypeComboEntries;
        pCbData = (PCOMBO_BOX_DATA_MAP)&FileTypeCombo[0];
    }
    pCombo = (CComboBox *)GetDlgItem(IDC_FILES_LOG_TYPE_COMBO);
    pCombo->ResetContent();
    for (nIndex = 0; nIndex < dwEntries; nIndex++) {
        strComboBoxString.LoadString( pCbData[nIndex].nResId );
        nResult = pCombo->InsertString (nIndex, (LPCWSTR)strComboBoxString);
        ASSERT (nResult != CB_ERR);
        nResult = pCombo->SetItemData (nIndex, (DWORD)pCbData[nIndex].nData);
        ASSERT (nResult != CB_ERR);
        // set log type in combo box here
        if (m_dwLogFileTypeValue == (int)(pCbData[nIndex].nData)) {
            m_iLogFileType = nIndex;
            nResult = pCombo->SetCurSel(nIndex);
            ASSERT (nResult != CB_ERR);
            if ( SLF_BIN_FILE != m_dwLogFileTypeValue
                    && SLF_SEQ_TRACE_FILE != m_dwLogFileTypeValue )
            {
                GetDlgItem(IDC_FILES_OVERWRITE_CHK)->EnableWindow(FALSE);
            } else {
                GetDlgItem(IDC_FILES_OVERWRITE_CHK)->EnableWindow( TRUE );
            }
        }
    }

    m_pLogQuery->GetFileNameParts ( m_strFolderName, m_strFileBaseName );
    m_pLogQuery->GetSqlName ( m_strSqlName );

    m_dwSerialNumber = m_pLogQuery->GetFileSerialNumber();
    
    // load the filename suffix combo box here
    m_dwSuffixValue = m_pLogQuery->GetFileNameAutoFormat();

    pCombo = (CComboBox *)GetDlgItem(IDC_FILES_SUFFIX_COMBO);
    pCombo->ResetContent();
    for (nIndex = 0; nIndex < dwFileNameSuffixComboEntries; nIndex++) {
        strComboBoxString.LoadString ( FileNameSuffixCombo[nIndex].nResId  );
        nResult = pCombo->InsertString (nIndex, (LPCWSTR)strComboBoxString);
        ASSERT (nResult != CB_ERR);
        pCombo->SetItemData (nIndex, (DWORD)FileNameSuffixCombo[nIndex].nData);
        ASSERT (nResult != CB_ERR);
        // set the correct entry in the combo box here
        if (m_dwSuffixValue == (int)(FileNameSuffixCombo[nIndex].nData)) {
            m_dwSuffix = nIndex;
            nResult = pCombo->SetCurSel(nIndex);
            ASSERT (nResult != CB_ERR);
        }
        if ( SLF_NAME_NNNNNN == (int)(FileNameSuffixCombo[nIndex].nData ) ) {
            m_dwSuffixIndexNNNNNN = nIndex;
        }
    }

    if ( SLF_NAME_NONE == m_dwSuffixValue ) {
        // then the combo box will not have been selected so:
        pCombo->SetCurSel(m_dwSuffixIndexNNNNNN);
        // disable 
        pCombo->EnableWindow(FALSE);
        // and clear the check box
        m_bAutoNameSuffix = FALSE;
    } else {
        m_bAutoNameSuffix = TRUE;
    }

    // set the check box in UpdateData ( FALSE );
    // update the dialog box
    CSmPropertyPage::OnInitDialog();
    SetHelpIds ( (DWORD*)&s_aulHelpIds );

    EnableSerialNumber();
    UpdateSampleFileName();

    SetModifiedPage( FALSE );

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void 
CFilesProperty::OnAutoSuffixChk() 
{
    UpdateData( TRUE );

    // enable the suffix combo window based on the state of the button
    GetDlgItem(IDC_FILES_SUFFIX_COMBO)->EnableWindow (m_bAutoNameSuffix);

    if (m_bAutoNameSuffix) {
        if ( SLF_NAME_NONE == m_dwSuffixValue ) {
            // then initialize a new default
            // select the default serial numbering
            ((CComboBox *)(GetDlgItem(IDC_FILES_SUFFIX_COMBO)))->SetCurSel( m_dwSuffixIndexNNNNNN );
            m_dwSuffixValue = SLF_NAME_NNNNNN;
        }
    } 

    EnableSerialNumber();
    UpdateSampleFileName();
    // This method is only called when the checkbox value has changed.
    SetModifiedPage(TRUE);
}

void
CFilesProperty::OnOverWriteChk()
{
    BOOL    bOldValue;
    bOldValue = m_bOverWriteFile;
    UpdateData(TRUE);
    if (bOldValue != m_bOverWriteFile) {
        SetModifiedPage(TRUE);
    }
}


void CFilesProperty::OnChangeFilesFirstSerialEdit() 
{
    DWORD    dwOldValue;
    dwOldValue = m_dwSerialNumber;
    UpdateData( TRUE );    

    UpdateSampleFileName(); 
    
    if (dwOldValue != m_dwSerialNumber) {
        SetModifiedPage(TRUE);
    }
}

void CFilesProperty::OnChangeFilesCommentEdit() 
{
    CString strOldText;
    strOldText = m_strCommentText;
    UpdateData ( TRUE );
    if ( 0 != strOldText.Compare ( m_strCommentText ) ) {
        SetModifiedPage(TRUE);
    }
}

void CFilesProperty::OnSelendokFilesSuffixCombo() 
{
    int nSel;
    
    nSel = ((CComboBox *)GetDlgItem(IDC_FILES_SUFFIX_COMBO))->GetCurSel();

    // Check of m_dwSuffix ensures that the value has changed.
    if ( LB_ERR != nSel && m_dwSuffix != nSel ) {

        UpdateData ( TRUE );
        EnableSerialNumber();
/*
            if (m_dwLogFileTypeValue == SLF_BIN_FILE) {
                GetDlgItem(IDC_FILES_OVERWRITE_CHK)->EnableWindow(
                            m_dwSuffixValue == SLF_NAME_NNNNNN ? FALSE : TRUE);
            }

            else {
                GetDlgItem(IDC_FILES_OVERWRITE_CHK)->EnableWindow(FALSE);
            }
*/
        UpdateSampleFileName();

        SetModifiedPage(TRUE);
    }
}

void 
CFilesProperty::OnSelendokFilesLogFileTypeCombo() 
{
    HandleLogTypeChange();
    return;
}


void CFilesProperty::OnKillfocusFilesCommentEdit() 
{
    CString strOldText;
    strOldText = m_strCommentText;
    UpdateData ( TRUE );
    if ( 0 != strOldText.Compare ( m_strCommentText ) ) {
        SetModifiedPage(TRUE);
    }
}

void CFilesProperty::OnKillfocusFirstSerialEdit() 
{
    DWORD   dwOldValue;
    dwOldValue = m_dwSerialNumber;
    UpdateData ( TRUE );
    if (dwOldValue != m_dwSerialNumber) {
        SetModifiedPage(TRUE);
    }
}


void CFilesProperty::OnKillfocusFilesSuffixCombo() 
{
    int nSel;
    
    nSel = ((CComboBox *)GetDlgItem(IDC_FILES_SUFFIX_COMBO))->GetCurSel();
    if ((nSel != LB_ERR) && (nSel != m_dwSuffix)) {
        SetModifiedPage(TRUE);
    }
}

void CFilesProperty::OnKillfocusFilesLogFileTypeCombo() 
{
    int nSel;
    
    nSel = ((CComboBox *)GetDlgItem(IDC_FILES_LOG_TYPE_COMBO))->GetCurSel();
    if ((nSel != LB_ERR) && (nSel != m_iLogFileType)) {
        SetModifiedPage(TRUE);
    }
}

void CFilesProperty::PostNcDestroy() 
{
//  delete this;      

    CPropertyPage::PostNcDestroy();
}

BOOL 
CFilesProperty::UpdateSharedData( BOOL bUpdateModel ) 
{
    BOOL  bContinue = TRUE;

    if ( SLQ_AUTO_MODE_SIZE == m_SharedData.stiStopTime.dwAutoMode ) {
        CString strMsg;

        if ( SLF_BIN_CIRC_FILE == m_dwLogFileTypeValue 
                || SLQ_DISK_MAX_SIZE == m_dwMaxSizeInternal ) {
            if ( SLF_BIN_CIRC_FILE == m_dwLogFileTypeValue ) {
                strMsg.LoadString ( IDS_FILE_CIRC_SET_MANUAL_STOP );
            } else {
                ASSERT( SLQ_DISK_MAX_SIZE == m_dwMaxSizeInternal );
                strMsg.LoadString ( IDS_FILE_MAX_SET_MANUAL_STOP );
            }            

            MessageBox( strMsg, m_pLogQuery->GetLogName(), MB_OK  | MB_ICONINFORMATION);

            m_SharedData.stiStopTime.dwAutoMode = SLQ_AUTO_MODE_NONE;

            if ( bUpdateModel ) {
                SLQ_TIME_INFO   slqTime;
                memset (&slqTime, 0, sizeof(slqTime));
        
                slqTime.wTimeType = SLQ_TT_TTYPE_STOP;
                slqTime.wDataType = SLQ_TT_DTYPE_DATETIME;
                slqTime.dwAutoMode = SLQ_AUTO_MODE_NONE; 

                bContinue = m_pLogQuery->SetLogTime ( &slqTime, (DWORD)slqTime.wTimeType );
            }
        }
    }

    m_SharedData.strFileBaseName = m_strFileBaseName;
    m_SharedData.strFolderName = m_strFolderName;
    m_SharedData.strSqlName = m_strSqlName;
    m_SharedData.dwLogFileType = m_dwLogFileTypeValue;
    if ( TRUE == m_bAutoNameSuffix ) {
        m_SharedData.dwSuffix = m_dwSuffixValue;
    } else {
        m_SharedData.dwSuffix = SLF_NAME_NONE;
    }
    m_SharedData.dwSerialNumber = m_dwSerialNumber;
    m_SharedData.dwMaxFileSize = m_dwMaxSizeInternal;

    m_pLogQuery->SetPropPageSharedData ( &m_SharedData );

    return bContinue;
}


BOOL CFilesProperty::OnKillActive() 
{
    BOOL bContinue = TRUE;

    ResourceStateManager    rsm;

    bContinue = CPropertyPage::OnKillActive();
    
    if ( bContinue ) {
        bContinue = IsValidData(m_pLogQuery, VALIDATE_FOCUS );
    }

    if ( bContinue ) {
        m_SharedData.dwLogFileType = m_dwLogFileTypeValue;

        bContinue = UpdateSharedData( FALSE );
    }
    
    if ( bContinue ) {
        SetIsActive ( FALSE );
    }

    return bContinue;
}

BOOL CFilesProperty::OnSetActive() 
{
    BOOL        bReturn;

    bReturn = CSmPropertyPage::OnSetActive();
    if ( bReturn ) {

        m_pLogQuery->GetPropPageSharedData ( &m_SharedData );

        UpdateData( FALSE );
    }
    return bReturn;
}

DWORD
CFilesProperty::ExtractDSN ( CString& rstrDSN )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    INT     iTotalLength;
    INT     iRightLength;

    // Format string:  "SQL:%s!%s"    
    MFC_TRY
        iTotalLength = m_strSqlName.GetLength();
        iRightLength = iTotalLength - m_strSqlName.Find(L"!");

        rstrDSN = m_strSqlName.Mid ( 4, iTotalLength - iRightLength - 4 );
    MFC_CATCH_DWSTATUS;

    return dwStatus;
}

DWORD
CFilesProperty::ExtractLogSetName ( CString& rstrLogSetName )
{
    DWORD   dwStatus = ERROR_SUCCESS;
 
    // Format string:  "SQL:%s!%s"    
    MFC_TRY
        rstrLogSetName = m_strSqlName.Right(m_strSqlName.GetLength() - m_strSqlName.Find(L"!") - 1);
    MFC_CATCH_DWSTATUS;
    
    return dwStatus;
}

void CFilesProperty::OnCfgBtn() 
{
    DWORD       dwStatus = ERROR_SUCCESS;
    CFileLogs   FilelogsDlg;
    CSqlProp    SqlLogDlg; 
    CString     strTempBaseName;
    CString     strTempFolderName;
    CString     strTempSqlName;
    DWORD       dwTempMaxSize;
    
    if ( SLF_SQL_LOG == m_dwLogFileTypeValue ){
        SqlLogDlg.m_pLogQuery = m_pLogQuery;
        SqlLogDlg.m_dwLogFileTypeValue = m_dwLogFileTypeValue;
        SqlLogDlg.m_bAutoNameSuffix = m_bAutoNameSuffix;

        //Extract the DSN and logset name from the formatted Sql Log name
        dwStatus = ExtractDSN ( SqlLogDlg.m_strDSN );
        dwStatus = ExtractLogSetName ( SqlLogDlg.m_strLogSetName );
        
        // Default the log set name to the base file name.
        if (SqlLogDlg.m_strLogSetName.IsEmpty() ) {
            SqlLogDlg.m_strLogSetName = m_strFileBaseName;
        }
       
        // Todo:  Handle bad status
        SqlLogDlg.m_dwFocusControl = m_dwSubDlgFocusCtrl;
        SqlLogDlg.m_dwMaxSizeInternal = m_dwMaxSizeInternal;
        SqlLogDlg.SetContextHelpFilePath(GetContextHelpFilePath());
        
        if ( IDOK == SqlLogDlg.DoModal() ) {

            strTempSqlName = m_strSqlName;
            dwTempMaxSize = m_dwMaxSizeInternal;

            m_strSqlName = SqlLogDlg.m_SqlFormattedLogName;
            m_dwMaxSizeInternal = SqlLogDlg.m_dwMaxSizeInternal;

            if ( 0 != strTempSqlName.CompareNoCase ( m_strSqlName )
                    || m_dwMaxSizeInternal != dwTempMaxSize ) 
            {
                SetModifiedPage(TRUE);
            }
        }
    }else{
        FilelogsDlg.m_pLogQuery = m_pLogQuery;
        FilelogsDlg.m_dwLogFileTypeValue = m_dwLogFileTypeValue;
        FilelogsDlg.m_strFolderName = m_strFolderName;
        FilelogsDlg.m_strFileBaseName = m_strFileBaseName;
        FilelogsDlg.m_dwMaxSizeInternal = m_dwMaxSizeInternal;
        FilelogsDlg.m_bAutoNameSuffix = m_bAutoNameSuffix;
        FilelogsDlg.SetContextHelpFilePath(GetContextHelpFilePath());
    
        FilelogsDlg.m_dwFocusControl = m_dwSubDlgFocusCtrl;

        if ( IDOK ==  FilelogsDlg.DoModal() ) {

            strTempFolderName = m_strFolderName;
            strTempBaseName = m_strFileBaseName;
            dwTempMaxSize = m_dwMaxSizeInternal;

            m_strFolderName = FilelogsDlg.m_strFolderName ;
            m_strFileBaseName = FilelogsDlg.m_strFileBaseName;
            m_dwMaxSizeInternal = FilelogsDlg.m_dwMaxSizeInternal;

            if ( 0 != strTempFolderName.CompareNoCase ( m_strFolderName )
                    || 0 != strTempBaseName.CompareNoCase ( m_strFileBaseName )
                    || m_dwMaxSizeInternal != dwTempMaxSize ) 
            {
                SetModifiedPage(TRUE);
            }
        }
    }
    m_dwSubDlgFocusCtrl = 0;
    UpdateSampleFileName();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\filelogs.cpp ===
// FileLogs.cpp : implementation file
//

#include "stdafx.h"
#include "smlogcfg.h"
#include "fileprop.h"
#include "smlogs.h"
#include "smcfgmsg.h"
#include "smlogqry.h"
#include "fileprop.h" // for eValueRange
#include "FileLogs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("SMLOGCFG(filelogs.cpp)");

static ULONG
s_aulHelpIds[] =
{
    IDC_FILES_FOLDER_EDIT,    IDH_FILES_FOLDER_EDIT,
    IDC_FILES_FOLDER_BTN,     IDH_FILES_FOLDER_BTN,
    IDC_FILES_FILENAME_EDIT,  IDH_FILES_FILENAME_EDIT,
    IDC_FILES_SIZE_MAX_BTN,   IDH_FILES_SIZE_MAX_BTN,
    IDC_FILES_SIZE_LIMIT_EDIT,IDH_FILES_SIZE_LIMIT_EDIT,
    IDC_FILES_SIZE_LIMIT_BTN, IDH_FILES_SIZE_LIMIT_BTN,
    0,0
};

/////////////////////////////////////////////////////////////////////////////
// CFileLogs dialog


CFileLogs::CFileLogs(CWnd* pParent /*=NULL*/)
	: CDialog(CFileLogs::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFileLogs)
	m_strFileBaseName = _T("");
	m_strFolderName = _T("");
	m_nFileSizeRdo = 0;
    m_bAutoNameSuffix = FALSE;
    m_dwMaxSize = 0;
    m_dwFocusControl = 0;
	//}}AFX_DATA_INIT
}


void CFileLogs::DoDataExchange(CDataExchange* pDX)
{
    CFilesProperty::eValueRange eMaxFileSize;

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFileLogs)
	DDX_Text(pDX, IDC_FILES_FILENAME_EDIT, m_strFileBaseName);
    DDV_MaxChars(pDX, m_strFileBaseName, (SLQ_MAX_BASE_NAME_LEN));
	DDX_Text(pDX, IDC_FILES_FOLDER_EDIT, m_strFolderName);
    DDV_MaxChars(pDX, m_strFolderName, (MAX_PATH-1));
	DDX_Radio(pDX, IDC_FILES_SIZE_MAX_BTN, m_nFileSizeRdo);
    if ( SLF_BIN_FILE == m_dwLogFileTypeValue ) {
        eMaxFileSize = CFilesProperty::eMaxCtrSeqBinFileLimit;
    } else if ( SLF_SEQ_TRACE_FILE == m_dwLogFileTypeValue ) {
        eMaxFileSize = CFilesProperty::eMaxTrcSeqBinFileLimit;
    } else {
        eMaxFileSize = CFilesProperty::eMaxFileLimit;
    }
    ValidateTextEdit(pDX, IDC_FILES_SIZE_LIMIT_EDIT, 9, &m_dwMaxSize, CFilesProperty::eMinFileLimit, eMaxFileSize);
	//}}AFX_DATA_MAP
    
    if ( pDX->m_bSaveAndValidate ) {

        if (((CButton *)GetDlgItem(IDC_FILES_SIZE_MAX_BTN))->GetCheck() == 1) {
            m_dwMaxSizeInternal = SLQ_DISK_MAX_SIZE;
        } else {
            m_dwMaxSizeInternal = m_dwMaxSize;
        }    

    }
}


BEGIN_MESSAGE_MAP(CFileLogs, CDialog)
	//{{AFX_MSG_MAP(CFileLogs)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
	ON_BN_CLICKED(IDC_FILES_FOLDER_BTN, OnFilesFolderBtn)
	ON_EN_CHANGE(IDC_FILES_FILENAME_EDIT, OnChangeFilesFilenameEdit)
	ON_EN_CHANGE(IDC_FILES_FOLDER_EDIT, OnChangeFilesFolderEdit)
	ON_EN_CHANGE(IDC_FILES_SIZE_LIMIT_EDIT, OnChangeFilesSizeLimitEdit)
	ON_BN_CLICKED(IDC_FILES_SIZE_LIMIT_BTN, OnFilesSizeLimitBtn)
	ON_NOTIFY(UDN_DELTAPOS, IDC_FILES_SIZE_LIMIT_SPIN, OnDeltaposFilesSizeLimitSpin)
	ON_BN_CLICKED(IDC_FILES_SIZE_MAX_BTN, OnFilesSizeMaxBtn)
	ON_EN_KILLFOCUS(IDC_FILES_FILENAME_EDIT, OnKillfocusFilesFilenameEdit)
	ON_EN_KILLFOCUS(IDC_FILES_FOLDER_EDIT, OnKillfocusFilesFolderEdit)
	ON_EN_KILLFOCUS(IDC_FILES_SIZE_LIMIT_EDIT, OnKillfocusFilesSizeLimitEdit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFileLogs message handlers

int
BrowseCallbackProc(
    HWND    hwnd,
    UINT    uMsg,
    LPARAM  /*lParam*/,
    LPARAM  lpData
   )

/*++

Routine Description:

    Callback function for SHBrowseForFolder

Arguments:

    hwnd - Handle to the browse dialog box
    uMsg - Identifying the reason for the callback
    lParam - Message parameter
    lpData - Application-defined value given in BROWSEINFO.lParam

Return Value:

    0

--*/

{
    if (uMsg == BFFM_INITIALIZED) {

        TCHAR  buffer[MAX_PATH];
        
        CFileLogs* DlgFileLogs = (CFileLogs*) lpData;

        if ( DlgFileLogs->GetDlgItemText (IDC_FILES_FOLDER_EDIT, buffer, MAX_PATH)) {
            SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM) buffer);
        }
    } 
    return 0;
}

void 
CFileLogs::OnFilesFolderBtn() 
{
    HRESULT       hr = NOERROR;
    BROWSEINFO    bi;
    LPMALLOC      pMalloc = NULL;
    LPITEMIDLIST  pidlItem;
    LPITEMIDLIST  pidlRoot = NULL;
    TCHAR         szFolderName[MAX_PATH];
    CString       strTitle;
   

    ResourceStateManager rsm;
    
    m_hModule = (HINSTANCE)GetModuleHandleW (_CONFIG_DLL_NAME_W_);
    
    hr = SHGetSpecialFolderLocation(m_hWnd, CSIDL_DRIVES, &pidlRoot);

    if ( SUCCEEDED ( hr ) ) {
        hr = SHGetMalloc(&pMalloc);
    }

    if ( FAILED ( hr ) || pMalloc == NULL || pidlRoot == NULL) {
        //
        // Something wrong from SHELL api, just return
        //
        return;
    }

    bi.hwndOwner = m_hWnd;
    bi.pidlRoot = (LPCITEMIDLIST)pidlRoot;
    strTitle.LoadString ( IDS_SELECT_FILE_FOLDER );
    bi.lpszTitle = strTitle.GetBuffer ( strTitle.GetLength() );
    bi.pszDisplayName = szFolderName;
    bi.ulFlags = BIF_RETURNONLYFSDIRS |  
                 BIF_NEWDIALOGSTYLE |
                 BIF_RETURNFSANCESTORS |
                 BIF_DONTGOBELOWDOMAIN ;

    bi.lpfn = BrowseCallbackProc;
    bi.lParam = (LPARAM)this;

    pidlItem = SHBrowseForFolder (&bi);
    if ( pidlItem != NULL ) {
        SHGetPathFromIDList(pidlItem, szFolderName);
        SetDlgItemText (IDC_FILES_FOLDER_EDIT, szFolderName);
        
    } // else ignore if they canceled out

    //
    // Free the ITEMIDLIST structure returned from shell
    //
    pMalloc->Free(pidlRoot); 

    if (pidlItem != NULL) {
        pMalloc->Free(pidlItem); 
    }
}


void CFileLogs::OnChangeFilesFilenameEdit() 
{
    CString strOldText;

    // When the user hits OK in the folder browse dialog, 
    // the file name might not have changed.
    strOldText = m_strFileBaseName;
    UpdateData( TRUE );
    if ( 0 != strOldText.Compare ( m_strFileBaseName ) ) {
//        UpdateSampleFileName();     
    }
}

void CFileLogs::OnChangeFilesFolderEdit() 
{
    CString strOldText;

    // When the user hits OK in the folder browse dialog, 
    // the folder name might not have changed.
    strOldText = m_strFolderName;
    UpdateData( TRUE );
    if ( 0 != strOldText.Compare ( m_strFolderName ) ) {
//        UpdateSampleFileName();     
    }
}

void CFileLogs::OnChangeFilesSizeLimitEdit() 
{
    UpdateData( TRUE );    
	
}

void CFileLogs::OnFilesSizeLimitBtn() 
{
    FileSizeBtn(FALSE);  	
}

void CFileLogs::OnDeltaposFilesSizeLimitSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
    CFilesProperty::eValueRange eMaxFileSize;

    if ( SLF_BIN_FILE == m_dwLogFileTypeValue ) {
        eMaxFileSize = CFilesProperty::eMaxCtrSeqBinFileLimit;
    } else if ( SLF_SEQ_TRACE_FILE == m_dwLogFileTypeValue ) {
        eMaxFileSize = CFilesProperty::eMaxTrcSeqBinFileLimit;
    } else {
        eMaxFileSize = CFilesProperty::eMaxFileLimit;
    }
    OnDeltaposSpin(pNMHDR, pResult, & m_dwMaxSize, CFilesProperty::eMinFileLimit, eMaxFileSize);
}

void CFileLogs::OnFilesSizeMaxBtn() 
{
    FileSizeBtn(FALSE);	
}

void CFileLogs::OnKillfocusFilesFilenameEdit() 
{
    CString strOldText;
    strOldText = m_strFileBaseName;
    UpdateData ( TRUE );
}

void CFileLogs::OnKillfocusFilesFolderEdit() 
{
    CString strOldText;
    strOldText = m_strFolderName;
    UpdateData ( TRUE );
}

void CFileLogs::OnKillfocusFilesSizeLimitEdit() 
{
    DWORD   dwOldValue;
    dwOldValue = m_dwMaxSize;
    UpdateData ( TRUE );
}

BOOL CFileLogs::OnInitDialog() 
{
    BOOL bLimitBtnSet;
	BOOL bReturn = TRUE;

    CDialog::OnInitDialog();

    // set the buttons 

    m_nFileSizeRdo = 1;
    if (m_dwMaxSizeInternal == SLQ_DISK_MAX_SIZE) {
        m_nFileSizeRdo = 0;
        m_dwMaxSize = 1; // default
    } else {
        m_nFileSizeRdo = 1;
        m_dwMaxSize = m_dwMaxSizeInternal;
    }
    bLimitBtnSet = (m_nFileSizeRdo == 1);
    GetDlgItem(IDC_FILES_SIZE_LIMIT_EDIT)->EnableWindow(bLimitBtnSet);

    // Disable the file browse button for remote machines
    ASSERT ( NULL != m_pLogQuery );
    if ( NULL != m_pLogQuery ) {
        if ( !m_pLogQuery->GetLogService()->IsLocalMachine() ) {
            GetDlgItem ( IDC_FILES_FOLDER_BTN )->EnableWindow ( FALSE );
        }
    }

    UpdateData(FALSE);

    FileSizeBtnEnable();
    FileSizeBtn(FALSE);
    
    if ( 0 != m_dwFocusControl ) {
        GetDlgItem ( m_dwFocusControl )->SetFocus();  
        bReturn = FALSE;
    }

	return bReturn;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CFileLogs::OnOK() 
{
    // load data from dialog
    if ( UpdateData (TRUE) ) { 
        if ( IsValidLocalData() ) {
            CDialog::OnOK();
        }
    }
}

void 
CFileLogs::OnDeltaposSpin(
    NMHDR   *pNMHDR, 
    LRESULT *pResult, 
    DWORD   *pValue, 
    DWORD   dMinValue, 
    DWORD   dMaxValue)
{
    NM_UPDOWN* pNMUpDown;
    LONG       lValue;
    BOOL       bResult   = TRUE;

    UpdateData(TRUE);

    ASSERT(dMinValue <= dMaxValue);

    if ( NULL != pNMHDR
        && NULL != pResult
        && NULL != pValue ) 
    {
        pNMUpDown = (NM_UPDOWN *) pNMHDR;
        lValue    = (LONG) (*pValue);

        if (lValue == INVALID_DWORD) {
            lValue = (DWORD) dMinValue;
        } else {

            if ( ((lValue >= (LONG) dMinValue + 1) && (pNMUpDown->iDelta > 0))
                || ((lValue <= (LONG) dMaxValue - 1) && (pNMUpDown->iDelta < 0)))
            {
                lValue += (pNMUpDown->iDelta * -1);

                if (lValue > (LONG) dMaxValue) {
                    lValue = (DWORD) dMaxValue;
                } else if (lValue < (LONG) dMinValue) {
                    lValue = (DWORD) dMinValue;
                }
            } else if (lValue > (LONG) dMaxValue) {        
                lValue = (DWORD) dMaxValue;
            } else if (lValue < (LONG) dMinValue) {
                lValue = (DWORD) dMinValue;
            } else {
                bResult = FALSE;
            }
        }

        if (bResult) {
            *pValue = lValue;
            UpdateData(FALSE);
        }
        *pResult = 0;
    } else {
        ASSERT ( FALSE );
    }

    return;
}

void CFileLogs::FileSizeBtnEnable()
{
    if ( ( SLF_BIN_CIRC_FILE == m_dwLogFileTypeValue ) 
        ||( SLF_CIRC_TRACE_FILE == m_dwLogFileTypeValue ) ) {
        ((CButton *)GetDlgItem(IDC_FILES_SIZE_LIMIT_BTN))->SetCheck(1);
        ((CButton *)GetDlgItem(IDC_FILES_SIZE_MAX_BTN))->SetCheck(0);
        GetDlgItem(IDC_FILES_SIZE_MAX_BTN)->EnableWindow ( FALSE );
    } else {
        GetDlgItem(IDC_FILES_SIZE_MAX_BTN)->EnableWindow ( TRUE );
    }

}

void CFileLogs::FileSizeBtn(BOOL bInit)
{
    INT     m_nFileSizeOld;
    
    m_nFileSizeOld = m_nFileSizeRdo;

    UpdateData ( TRUE );
    
    if (bInit || (m_nFileSizeOld != m_nFileSizeRdo)) {
        BOOL    bMaxBtnSet, bLimitBtnSet;
        
        // *** This can be replaced since DDX_Radio implemented.
        // get btn state    
        bMaxBtnSet = ((CButton *)GetDlgItem(IDC_FILES_SIZE_MAX_BTN))->GetCheck() == 1;
        bLimitBtnSet = ((CButton *)GetDlgItem(IDC_FILES_SIZE_LIMIT_BTN))->GetCheck() == 1;
    
        ASSERT (bLimitBtnSet != bMaxBtnSet);

        GetDlgItem(IDC_FILES_SIZE_LIMIT_EDIT)->EnableWindow(bLimitBtnSet);
        GetDlgItem(IDC_FILES_SIZE_LIMIT_SPIN)->EnableWindow(bLimitBtnSet);
        GetDlgItem(IDC_FILES_SIZE_LIMIT_UNITS)->EnableWindow(bLimitBtnSet);
    }
}

BOOL CFileLogs::IsValidLocalData()
{
    BOOL bIsValid = TRUE;
    CFilesProperty::eValueRange eMaxFileSize;
    INT iPrevLength = 0;

    ResourceStateManager    rsm;

    // assumes UpdateData has been called

    // Trim folder name and file name before validation
    iPrevLength = m_strFolderName.GetLength();
    m_strFolderName.TrimLeft();
    m_strFolderName.TrimRight();
    
    if ( iPrevLength != m_strFolderName.GetLength() ) {
        SetDlgItemText ( IDC_FILES_FOLDER_EDIT, m_strFolderName );  
    }

    iPrevLength = m_strFileBaseName.GetLength();
    m_strFileBaseName.TrimRight();

    if ( iPrevLength != m_strFileBaseName.GetLength() ) {
        SetDlgItemText ( IDC_FILES_FILENAME_EDIT, m_strFileBaseName );  
    }

    if ( bIsValid ) {

        if ( m_strFolderName.IsEmpty() ) {
            CString strMessage;
            strMessage.LoadString ( IDS_FILE_ERR_NOFOLDERNAME );
            MessageBox ( strMessage, m_pLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
            (GetDlgItem(IDC_FILES_FOLDER_EDIT))->SetFocus();
            bIsValid = FALSE;
        }
    }
    
    if ( bIsValid ) {

        if ( m_strFileBaseName.IsEmpty() ) {
            if ( !m_bAutoNameSuffix ) {
                CString strMessage;
                strMessage.LoadString ( IDS_FILE_ERR_NOFILENAME );
                MessageBox ( strMessage, m_pLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
                (GetDlgItem(IDC_FILES_FILENAME_EDIT))->SetFocus();
                bIsValid = FALSE;
            }
        } else {
            if ( !FileNameIsValid ( &m_strFileBaseName ) ){
                CString strMessage;
                strMessage.LoadString (IDS_ERRMSG_INVALIDCHAR);
                MessageBox( strMessage, m_pLogQuery->GetLogName(), MB_OK| MB_ICONERROR );
                (GetDlgItem(IDC_FILES_FILENAME_EDIT))->SetFocus();
                bIsValid = FALSE;
            }
        }
    }

    if ( bIsValid ) {
        if ( m_pLogQuery->GetLogService()->IsLocalMachine() ) {

            ProcessDirPath ( m_strFolderName, m_pLogQuery->GetLogName(), this, bIsValid, TRUE );

            if ( !bIsValid ) {
                GetDlgItem(IDC_FILES_FOLDER_EDIT)->SetFocus();
            }
        }
    }

    if (bIsValid)
    {
        if ( SLQ_DISK_MAX_SIZE != m_dwMaxSizeInternal ) {
            if ( SLF_BIN_FILE == m_dwLogFileTypeValue ) {
                eMaxFileSize = CFilesProperty::eMaxCtrSeqBinFileLimit;
            } else if ( SLF_SEQ_TRACE_FILE == m_dwLogFileTypeValue ) {
                eMaxFileSize = CFilesProperty::eMaxTrcSeqBinFileLimit;
            } else {
                eMaxFileSize = CFilesProperty::eMaxFileLimit;
            }
            bIsValid = ValidateDWordInterval(IDC_FILES_SIZE_LIMIT_EDIT,
                                             m_pLogQuery->GetLogName(),
                                             (long) m_dwMaxSizeInternal,
                                             CFilesProperty::eMinFileLimit,
                                             eMaxFileSize);
        }
    }

    return bIsValid;
}


void
CFileLogs::ValidateTextEdit(
    CDataExchange * pDX,
    int             nIDC,
    int             nMaxChars,
    DWORD           * pValue,
    DWORD           /* minValue */,
    DWORD           /* maxValue */)
{
    HWND    hWndCtrl       = pDX->PrepareEditCtrl(nIDC);
    LONG    currentValue   = INVALID_DWORD;
    TCHAR   szT[MAXSTR];
    CString strTemp;

    if ( NULL != pDX && NULL != pValue ) {
        if (pDX->m_bSaveAndValidate)
        {
            * pValue = (DWORD) currentValue;

            ::GetWindowText(hWndCtrl, szT, MAXSTR);

            strTemp = szT;
            DDV_MaxChars(pDX, strTemp, nMaxChars);

            if (szT[0] >= _T('0') && szT[0] <= _T('9'))
            {
                currentValue = _wtol(szT);
                * pValue      = (DWORD) currentValue;
            }
        } else {
            if ( INVALID_DWORD != *pValue ) {
                wsprintf(szT, _T("%lu"), *pValue);
            } else {
                szT[0] = _T('\0');
            }
            GetDlgItem(nIDC)->SetWindowText(szT);
        }
    } else {
        ASSERT ( FALSE );
    }
}

BOOL
CFileLogs::ValidateDWordInterval(int     nIDC,
                                       LPCWSTR strLogName,
                                       long    lValue,
                                       DWORD   minValue,
                                       DWORD   maxValue)
{
    CString strMsg;
    BOOL    bResult =  (lValue >= (long) minValue)
                    && (lValue <= (long) maxValue);

    if (! bResult)
    {
        strMsg.Format ( IDS_ERRMSG_INVALIDDWORD, minValue, maxValue );
        MessageBox(strMsg, strLogName, MB_OK  | MB_ICONERROR);
        GetDlgItem(nIDC)->SetFocus();
        strMsg.Empty();
    }
    return (bResult);
}

BOOL
CFileLogs::OnHelpInfo(HELPINFO * pHelpInfo)
{
    if (pHelpInfo->iCtrlId >= IDC_FILELOG_FIRST_HELP_CTRL_ID || 
        pHelpInfo->iCtrlId == IDOK ||
        pHelpInfo->iCtrlId == IDCANCEL ) {
        InvokeWinHelp(WM_HELP,
                      NULL,
                      (LPARAM) pHelpInfo,
                      m_strHelpFilePath,
                      s_aulHelpIds);
    }
    return TRUE;
}


void 
CFileLogs::OnContextMenu(CWnd* pWnd, CPoint /* point */) 
{
    InvokeWinHelp(WM_CONTEXTMENU, (WPARAM)(pWnd->m_hWnd), NULL, m_strHelpFilePath, s_aulHelpIds);

    return;
}

DWORD
CFileLogs::SetContextHelpFilePath(const CString& rstrPath)
{
    DWORD dwStatus = ERROR_SUCCESS;

    MFC_TRY
        m_strHelpFilePath = rstrPath;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\fileprop.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    fileprop.h

Abstract:

    Header file for the files property page.

--*/

#ifndef _FILEPROP_H_
#define _FILEPROP_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "smlogqry.h"   // For shared property page data structure
#include "smproppg.h"   // Base class
#include "smcfghlp.h"

// Dialog controls
#define IDD_FILES_PROP                  500

#define IDC_FILE_FIRST_HELP_CTRL_ID     507

#define IDC_FILES_LOG_TYPE_CAPTION      501
#define IDC_FILES_NAME_GROUP            502
#define IDC_FILES_COMMENT_CAPTION       503
#define IDC_FILES_SAMPLE_CAPTION        504
#define IDC_FILES_FIRST_SERIAL_CAPTION  505
#define IDC_FILES_SUFFIX_CAPTION        506

#define IDC_FILES_COMMENT_EDIT          507
#define IDC_FILES_LOG_TYPE_COMBO        508
#define IDC_CFG_BTN                     509
#define IDC_FILES_AUTO_SUFFIX_CHK       510
#define IDC_FILES_SUFFIX_COMBO          511
#define IDC_FILES_FIRST_SERIAL_EDIT     512
#define IDC_FILES_SAMPLE_DISPLAY        513
#define IDC_FILES_OVERWRITE_CHK         514

class CSmLogQuery;

/////////////////////////////////////////////////////////////////////////////
// CFilesProperty dialog

class CFilesProperty : public CSmPropertyPage
{
    friend class CFileLogs;
    friend class CSqlProp;

    DECLARE_DYNCREATE(CFilesProperty)

// Construction
public:
            CFilesProperty(MMC_COOKIE   mmcCookie, LONG_PTR hConsole);
            CFilesProperty();
    virtual ~CFilesProperty();

// Dialog Data
    //{{AFX_DATA(CFilesProperty)
	enum { IDD = IDD_FILES_PROP };
    CString m_strCommentText;
    CString m_strLogName;
    int     m_iLogFileType;
    CString m_strSampleFileName;
    int     m_dwSuffix;
    DWORD   m_dwSerialNumber;
    BOOL    m_bAutoNameSuffix;
    BOOL    m_bOverWriteFile;
	//}}AFX_DATA

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CFilesProperty)
    public:
    protected:
    virtual void OnFinalRelease();
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

// Implementation
protected:

    virtual INT GetFirstHelpCtrlId ( void ) { return IDC_FILE_FIRST_HELP_CTRL_ID; };  // Subclass must override.
    virtual BOOL    IsValidLocalData();
    
    // Generated message map functions
    //{{AFX_MSG(CFilesProperty)
    afx_msg void OnAutoSuffixChk();
    afx_msg void OnOverWriteChk();
    afx_msg void OnChangeFilesCommentEdit();
    afx_msg void OnChangeFilesFirstSerialEdit();
    afx_msg void OnKillfocusFilesCommentEdit();
    afx_msg void OnKillfocusFirstSerialEdit();
    afx_msg void OnSelendokFilesLogFileTypeCombo();
    afx_msg void OnSelendokFilesSuffixCombo();
    afx_msg void OnKillfocusFilesSuffixCombo();
    afx_msg void OnKillfocusFilesLogFileTypeCombo();
   	afx_msg void OnCfgBtn();

    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CFilesProperty)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()

private:

    BOOL    UpdateSampleFileName( void );
    void    EnableSerialNumber( void );
    void    HandleLogTypeChange( void );
    BOOL    UpdateSharedData( BOOL bUpdateModel );
    DWORD   ExtractDSN ( CString& rstrDSN );
    DWORD   ExtractLogSetName ( CString& rstrLogSetName );

    enum eValueRange {
        eMinFileLimit = 1,
        eMaxFileLimit = 0x00000400,      // * 0x0100000 = 0x40000000 - for non-binary and circ files
        eMaxCtrSeqBinFileLimit = 0x00000FFF,   // * 0x0100000 = 0xFFFFFFF - for binary files
        eMaxTrcSeqBinFileLimit = 0x30000000,   // 0x30000000 - for trace seq binary files
        eMinSqlRecordsLimit = eMinFileLimit,
        eMaxSqlRecordsLimit = 0x30000000,      // 0x30000000 - for SQL logs 
        eMinFirstSerial = 0,
        eMaxFirstSerial = 999999
    };
    
    CSmLogQuery* m_pLogQuery;
    DWORD       m_dwLogFileTypeValue;
    DWORD       m_dwAppendMode;
    DWORD       m_dwSuffixValue;
    DWORD       m_dwSuffixIndexNNNNNN;
    DWORD       m_dwMaxSizeInternal;

    CString     m_strFileBaseName;
    CString     m_strFolderName;
    CString     m_strSqlName;

    DWORD       m_dwSubDlgFocusCtrl;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _FILEPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\dialogs.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    fileprop.h

Abstract:

    Header file for the files property page.

--*/

#ifndef _DIALOGS_H_08222000_
#define _DIALOGS_H_08222000_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define IDC_PWD_FIRST_HELP_CTRL_ID     2201

#define IDD_PASSWORD_DLG               2200
#define IDC_PASSWORD1                  2201
#define IDC_PASSWORD2                  2202
#define IDC_USERNAME                   2203

void KillString( CString& str );


/////////////////////////////////////////////////////////////////////////////
// CPasswordDlg dialog

class CPasswordDlg : public CDialog
{
// Construction
public:
	CPasswordDlg(CWnd* pParent = NULL);   // standard constructor
    virtual ~CPasswordDlg();

    DWORD SetContextHelpFilePath(const CString& rstrPath);

    // Dialog Data
	//{{AFX_DATA(CPasswordDlg)
	enum { IDD = IDD_PASSWORD_DLG };
    CString m_strUserName;
	CString	m_strPassword1;
	CString	m_strPassword2;
	//}}AFX_DATA
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPasswordDlg)
	protected:
    virtual BOOL OnInitDialog();
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPasswordDlg)
	virtual void OnOK();
    afx_msg BOOL OnHelpInfo(HELPINFO *);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
        CString     m_strHelpFilePath;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _DIALOGS_H_08222000_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\enabldlg.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    enabldlg.h

Abstract:

    Header file for the provider status dialog box.

--*/

#ifndef _ENABLDLG_H_
#define _ENABLDLG_H_


#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Dialog controls
#define IDD_PROVIDERS_ACTIVE_DLG        1300

#define IDC_PACT_FIRST_HELP_CTRL_ID     1301
#define IDC_PACT_PROVIDERS_LIST         1301
#define IDC_PACT_CHECK_SHOW_ENABLED     1302


/////////////////////////////////////////////////////////////////////////////
// CActiveProviderDlg dialog

class CProvidersProperty;

class CActiveProviderDlg : public CDialog
{
// Construction
public:
            CActiveProviderDlg(CWnd* pParent = NULL);   // standard constructor
    virtual ~CActiveProviderDlg() {};

            void    SetProvidersPage( CProvidersProperty* pPage );
            void    UpdateList();

    // Dialog Data
    //{{AFX_DATA(CActiveProviderDlg)
    enum { IDD = IDD_PROVIDERS_ACTIVE_DLG };
    CListCtrl       m_Providers;
    BOOL            m_bShowEnabledOnly;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CActiveProviderDlg)
    protected:
    virtual BOOL OnInitDialog();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CActiveProviderDlg)
    afx_msg void OnCheckShowEnabled();
    afx_msg BOOL OnHelpInfo( HELPINFO* );
    afx_msg void OnContextMenu( CWnd*, CPoint );
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CProvidersProperty* m_pProvidersPage;
    INT                 m_iListViewWidth;


};


#endif // _ENABLDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\makefile.inc ===
!IFNDEF BUILDMSG
BUILDMSG=
!ENDIF

.\smcfgmsg.h .\msg00001.bin .\smcfgmsg.rc : .\smcfgmsg.mc
	mc -v  smcfgmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\globals.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    GLOBALS.CPP

Abstract:

    Utility methods for the Performance Logs and Alerts MMC snap-in.

--*/

#include "stdAfx.h"
#include <pdhmsg.h>         // For CreateSampleFileName
#include <pdhp.h>           // For CreateSampleFileName
#include "smcfgmsg.h"
#include "globals.h"

USE_HANDLE_MACROS("SMLOGCFG(globals.cpp)");

extern "C" {
    WCHAR GUIDSTR_TypeLibrary[] = {_T("{7478EF60-8C46-11d1-8D99-00A0C913CAD4}")};
    WCHAR GUIDSTR_ComponentData[] = {_T("{7478EF61-8C46-11d1-8D99-00A0C913CAD4}")};
    WCHAR GUIDSTR_Component[] = {_T("{7478EF62-8C46-11d1-8D99-00A0C913CAD4}")};
    WCHAR GUIDSTR_RootNode[] = {_T("{7478EF63-8C46-11d1-8D99-00A0C913CAD4}")};
    WCHAR GUIDSTR_MainNode[] = {_T("{7478EF64-8C46-11d1-8D99-00A0C913CAD4}")}; // Obsolete after Beta 3 
    WCHAR GUIDSTR_SnapInExt[] = {_T("{7478EF65-8C46-11d1-8D99-00A0C913CAD4}")};
    WCHAR GUIDSTR_CounterMainNode[] = {_T("{7478EF66-8C46-11d1-8D99-00A0C913CAD4}")};
    WCHAR GUIDSTR_TraceMainNode[] = {_T("{7478EF67-8C46-11d1-8D99-00A0C913CAD4}")};
    WCHAR GUIDSTR_AlertMainNode[] = {_T("{7478EF68-8C46-11d1-8D99-00A0C913CAD4}")};
    WCHAR GUIDSTR_PerformanceAbout[] = {_T("{7478EF69-8C46-11d1-8D99-00A0C913CAD4}")};
};


HINSTANCE g_hinst;           // Global instance handle
CRITICAL_SECTION g_critsectInstallDefaultQueries;


const COMBO_BOX_DATA_MAP TimeUnitCombo[] = 
{
    {SLQ_TT_UTYPE_SECONDS,   IDS_SECONDS},
    {SLQ_TT_UTYPE_MINUTES,   IDS_MINUTES},
    {SLQ_TT_UTYPE_HOURS,     IDS_HOURS},
    {SLQ_TT_UTYPE_DAYS,      IDS_DAYS}
};
const DWORD dwTimeUnitComboEntries = sizeof(TimeUnitCombo)/sizeof(TimeUnitCombo[0]);


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfMmcMachineName clipboard format
// 
CDataObject*
ExtractOwnDataObject
(
 LPDATAOBJECT lpDataObject      // [in] IComponent pointer 
 )
{
    HGLOBAL      hGlobal;
    HRESULT      hr  = S_OK;
    CDataObject* pDO = NULL;
    
    hr = ExtractFromDataObject( lpDataObject,
        CDataObject::s_cfInternal, 
        sizeof(CDataObject **),
        &hGlobal
        );
    
    if( SUCCEEDED(hr) )
    {
        pDO = *(CDataObject **)(hGlobal);
        ASSERT( NULL != pDO );    
       
        VERIFY ( NULL == GlobalFree(hGlobal) ); // Must return NULL
    }
    
    return pDO;
    
} // end ExtractOwnDataObject()

//---------------------------------------------------------------------------
//  Extracts data based on the passed-in clipboard format
//
HRESULT
ExtractFromDataObject
(
 LPDATAOBJECT lpDataObject,   // [in]  Points to data object
 UINT         cfClipFormat,   // [in]  Clipboard format to use
 ULONG        nByteCount,     // [in]  Number of bytes to allocate
 HGLOBAL      *phGlobal       // [out] Points to the data we want 
 )
{
    ASSERT( NULL != lpDataObject );
    
    HRESULT hr = S_OK;
    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { (USHORT)cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    
    *phGlobal = NULL;
    
    do 
    {
        // Allocate memory for the stream
        stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, nByteCount );
        
        if( !stgmedium.hGlobal )
        {
            hr = E_OUTOFMEMORY;
            LOCALTRACE( _T("Out of memory\n") );
            break;
        }
        
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );
        if (FAILED(hr))
        {
            break;       
        }
        
        // stgmedium now has the data we need 
        *phGlobal = stgmedium.hGlobal;
        stgmedium.hGlobal = NULL;
        
    } while (0); 
    
    if (FAILED(hr) && stgmedium.hGlobal)
    {
        VERIFY ( NULL == GlobalFree(stgmedium.hGlobal)); // Must return NULL
    }
    return hr;
    
} // end ExtractFromDataObject()

//---------------------------------------------------------------------------
//
VOID DisplayError( LONG nErrorCode, LPWSTR wszDlgTitle )
{
    LPVOID lpMsgBuf = NULL;
    ::FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        nErrorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
        (LPWSTR)&lpMsgBuf,
        0,
        NULL
        );
    if (lpMsgBuf) {
        ::MessageBox( NULL, (LPWSTR)lpMsgBuf, wszDlgTitle,
                      MB_OK|MB_ICONINFORMATION );
        LocalFree( lpMsgBuf );
    }
    
} // end DisplayError()

VOID DisplayError( LONG nErrorCode, UINT nTitleString )
{
    CString strTitle;
    LPVOID lpMsgBuf = NULL;
    ResourceStateManager    rsm;

    ::FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        nErrorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
        (LPWSTR)&lpMsgBuf,
        0,
        NULL
        );
    strTitle.LoadString ( nTitleString );
    if (lpMsgBuf) {
        ::MessageBox( NULL, (LPWSTR)lpMsgBuf, (LPCWSTR)strTitle,
                      MB_OK|MB_ICONINFORMATION );
        LocalFree( lpMsgBuf );
    }
    
} // end DisplayError()


//---------------------------------------------------------------------------
//  Debug only message box
//
int DebugMsg( LPWSTR wszMsg, LPWSTR wszTitle )
{
    int nRetVal = 0;
    wszMsg;
    wszTitle;
#ifdef _DEBUG
    nRetVal = ::MessageBox( NULL, wszMsg, wszTitle, MB_OK );
#endif
    return nRetVal;
}


//---------------------------------------------------------------------------
//  Extracts data based on the passed-in clipboard format

HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType )
{
    HGLOBAL      hGlobal;
    HRESULT      hr  = S_OK;
    
    hr = ExtractFromDataObject( piDataObject,
        CDataObject::s_cfNodeType, 
        sizeof(GUID),
        &hGlobal
        );
    if( SUCCEEDED(hr) )
    {
        *pguidObjectType = *(GUID*)(hGlobal);
        ASSERT( NULL != pguidObjectType );    
        
        VERIFY ( NULL == GlobalFree(hGlobal) ); // Must return NULL
    }
    
    return hr;
}

HRESULT 
ExtractMachineName( 
                   IDataObject* piDataObject, 
                   CString& rstrMachineName )
{
    
    HRESULT hr = S_OK;
    HGLOBAL hMachineName;
    
    hr = ExtractFromDataObject(piDataObject, 
        CDataObject::s_cfMmcMachineName, 
        sizeof(TCHAR) * (MAX_PATH + 1),
        &hMachineName);
    if( SUCCEEDED(hr) )
    {
        
        LPWSTR pszNewData = reinterpret_cast<LPWSTR>(hMachineName);
        if (NULL == pszNewData)
        {
            ASSERT(FALSE);
            hr = E_UNEXPECTED;
        } else {
            pszNewData[MAX_PATH] = _T('\0'); // just to be safe
            //      USES_CONVERSION;
            //      rstrMachineName = OLE2T(pszNewData);
            
            rstrMachineName = pszNewData;
            
            VERIFY ( NULL == GlobalFree(hMachineName) ); // Must return NULL
        }
    }
    return hr;
}

DWORD __stdcall
CreateSampleFileName ( 
    const   CString&  rstrQueryName, 
    const   CString&  rstrMachineName, 
    const CString&  rstrFolderName,
    const CString&  rstrInputBaseName,
    const CString&  rstrSqlName,
    DWORD    dwSuffixValue,
    DWORD    dwLogFileTypeValue,
    DWORD    dwCurrentSerialNumber,
    CString& rstrReturnName)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    PPDH_PLA_INFO  pInfo = NULL;
    DWORD dwStrBufLen = 0;
    DWORD dwInfoSize = 0;
    DWORD dwFlags = 0;

    rstrReturnName.Empty();

    dwStatus = PdhPlaGetInfo( 
       (LPTSTR)(LPCTSTR)rstrQueryName, 
       (LPTSTR)(LPCTSTR)rstrMachineName, 
       &dwInfoSize, 
       pInfo );
    if( ERROR_SUCCESS == dwStatus && 0 != dwInfoSize ){
        pInfo = (PPDH_PLA_INFO)malloc(dwInfoSize);
        if( NULL != pInfo && (sizeof(PDH_PLA_INFO) <= dwInfoSize) ){
            ZeroMemory( pInfo, dwInfoSize );

            pInfo->dwMask = PLA_INFO_CREATE_FILENAME;

            dwStatus = PdhPlaGetInfo( 
                        (LPTSTR)(LPCTSTR)rstrQueryName, 
                        (LPTSTR)(LPCTSTR)rstrMachineName, 
                        &dwInfoSize, 
                        pInfo );
            
            pInfo->dwMask = PLA_INFO_CREATE_FILENAME;
            
			pInfo->dwFileFormat = dwLogFileTypeValue;
            pInfo->strBaseFileName = (LPTSTR)(LPCTSTR)rstrInputBaseName;
            pInfo->dwAutoNameFormat = dwSuffixValue;
            // PLA_INFO_FLAG_TYPE is counter log vs trace log vs alert
            pInfo->strDefaultDir = (LPTSTR)(LPCTSTR)rstrFolderName;
            pInfo->dwLogFileSerialNumber = dwCurrentSerialNumber;
            pInfo->strSqlName = (LPTSTR)(LPCTSTR)rstrSqlName;
            pInfo->dwLogFileSerialNumber = dwCurrentSerialNumber;

            // Create file name based on passed parameters only.
            dwFlags = PLA_FILENAME_CREATEONLY;      // PLA_FILENAME_CURRENTLOG for latest run log

            dwStatus = PdhPlaGetLogFileName (
                    (LPTSTR)(LPCTSTR)rstrQueryName,
                    (LPTSTR)(LPCTSTR)rstrMachineName, 
                    pInfo,
                    dwFlags,
                    &dwStrBufLen,
                    NULL );

            if ( ERROR_SUCCESS == dwStatus || PDH_INSUFFICIENT_BUFFER == dwStatus ) {
                dwStatus = PdhPlaGetLogFileName (
                        (LPTSTR)(LPCTSTR)rstrQueryName, 
                        (LPTSTR)(LPCTSTR)rstrMachineName, 
                        pInfo,
                        dwFlags,
                        &dwStrBufLen,
                        rstrReturnName.GetBufferSetLength ( dwStrBufLen ) );
                rstrReturnName.ReleaseBuffer();
            }
        }
    }

    if ( NULL != pInfo ) { 
        free( pInfo );
    }
    return dwStatus;
}


DWORD __stdcall
IsDirPathValid (    
    CString&  rstrPath,
    BOOL bLastNameIsDirectory,
    BOOL bCreateMissingDirs,
    BOOL& rbIsValid )
/*++

Routine Description:

    Creates the directory specified in szPath and any other "higher"
        directories in the specified path that don't exist.

Arguments:

    IN  CString rstrPath
        directory path to create (assumed to be a DOS path, not a UNC)

    IN  BOOL bLastNameIsDirectory
        TRUE when the last name in the path is a Directory and not a File
        FALSE if the last name is a file

    IN  BOOL bCreateMissingDirs
        TRUE will create any dirs in the path that are not found
        FALSE will only test for existence and not create any
            missing dirs.

    OUT BOOL rbIsValid
        TRUE    if the directory path now exists
        FALSE   if error (GetLastError to find out why)

Return Value:

    DWSTATUS
--*/
{
    CString  strLocalPath;
    LPTSTR   szLocalPath;
    LPTSTR   szEnd;
    LPSECURITY_ATTRIBUTES   lpSA = NULL;
    DWORD       dwAttr;
    TCHAR    cBackslash = TEXT('\\');
    DWORD   dwStatus = ERROR_SUCCESS;

    rbIsValid = FALSE;

    szLocalPath = strLocalPath.GetBufferSetLength ( MAX_PATH );
    
    if ( NULL == szLocalPath ) {
        dwStatus = ERROR_OUTOFMEMORY;
    } else {

        if (GetFullPathName (
                rstrPath,
                MAX_PATH,
                szLocalPath,
                NULL) > 0) {

            szEnd = &szLocalPath[3];

            if (*szEnd != 0) {
                // then there are sub dirs to create
                while (*szEnd != 0) {
                    // go to next backslash
                    while ((*szEnd != cBackslash) && (*szEnd != 0)) szEnd++;
                    if (*szEnd == cBackslash) {
                        // terminate path here and create directory
                        *szEnd = 0;
                        if (bCreateMissingDirs) {
                            if (!CreateDirectory (szLocalPath, lpSA)) {
                                // see what the error was and "adjust" it if necessary
                                dwStatus = GetLastError();
                                if ( ERROR_ALREADY_EXISTS == dwStatus ) {
                                    // this is OK
                                    dwStatus = ERROR_SUCCESS;
                                    rbIsValid = TRUE;
                                } else {
                                    rbIsValid = FALSE;
                                }
                            } else {
                                // directory created successfully so update count
                                rbIsValid = TRUE;
                            }
                        } else {
                            if ((dwAttr = GetFileAttributes(szLocalPath)) != 0xFFFFFFFF) {
                                // make sure it's a dir
                                if ((dwAttr & FILE_ATTRIBUTE_DIRECTORY) ==
                                    FILE_ATTRIBUTE_DIRECTORY) {
                                    rbIsValid = TRUE;
                                } else {
                                    // if any dirs fail, then clear the return value
                                    rbIsValid = FALSE;
                                }
                            } else {
                                // if any dirs fail, then clear the return value
                                rbIsValid = FALSE;
                            }
                        }
                        // replace backslash and go to next dir
                        *szEnd++ = cBackslash;
                    }
                }
                // create last dir in path now if it's a dir name and not a filename
                if (bLastNameIsDirectory) {
                    if (bCreateMissingDirs) {
                        if (!CreateDirectory (szLocalPath, lpSA)) {
                            // see what the error was and "adjust" it if necessary
                            dwStatus = GetLastError();
                            if ( ERROR_ALREADY_EXISTS == dwStatus ) {
                                // this is OK
                                dwStatus = ERROR_SUCCESS;
                                rbIsValid = TRUE;
                            } else {
                                rbIsValid = FALSE;
                            }
                        } else {
                            // directory created successfully
                            rbIsValid = TRUE;
                        }
                    } else {
                        if ((dwAttr = GetFileAttributes(szLocalPath)) != 0xFFFFFFFF) {
                            // make sure it's a dir
                            if ((dwAttr & FILE_ATTRIBUTE_DIRECTORY) ==
                                FILE_ATTRIBUTE_DIRECTORY) {
                                rbIsValid = TRUE;
                            } else {
                                // if any dirs fail, then clear the return value
                                rbIsValid = FALSE;
                            }
                        } else {
                            // if any dirs fail, then clear the return value
                            rbIsValid = FALSE;
                        }
                    }
                }
            } else {
                // else this is a root dir only so return success.
                dwStatus = ERROR_SUCCESS;
                rbIsValid = TRUE;
            }
        }
        strLocalPath.ReleaseBuffer();
    }
        
    return dwStatus;
}

DWORD __stdcall
ProcessDirPath (    
            CString&  rstrPath,
    const   CString&  rstrLogName,
            CWnd* pwndParent,
            BOOL& rbIsValid,
            BOOL  bOnFilesPage )
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD cchLen = 0;
    CString strExpanded;
    LPWSTR  szExpanded;
    DWORD   cchExpandedLen;
    ResourceStateManager    rsm;

    // Parse all environment symbols    
    cchLen = ExpandEnvironmentStrings ( rstrPath, NULL, 0 );

    if ( 0 < cchLen ) {

        MFC_TRY
            //
            // CString size does not include NULL.
            // cchLen includes NULL.  Include NULL count for safety.
            //
            szExpanded = strExpanded.GetBuffer ( cchLen );
        MFC_CATCH_DWSTATUS;

        if ( ERROR_SUCCESS == dwStatus ) {
            cchExpandedLen = ExpandEnvironmentStrings (
                        rstrPath, 
                        szExpanded,
                        cchLen);
            
            if ( 0 == cchExpandedLen ) {
                dwStatus = GetLastError();
            }
        }
        strExpanded.ReleaseBuffer();

    } else {
        dwStatus = GetLastError();
    }
    
    dwStatus = IsDirPathValid (strExpanded, TRUE, FALSE, rbIsValid);
    
    if ( ERROR_SUCCESS != dwStatus ) {
        rbIsValid = FALSE;
    } else {
        if ( !rbIsValid ) {        
            INT nMbReturn;
            CString strMessage;
            
            strMessage.Format ( IDS_FILE_DIR_NOT_FOUND, rstrPath );
            nMbReturn = pwndParent->MessageBox ( strMessage, rstrLogName, MB_YESNO | MB_ICONWARNING );
            if (nMbReturn == IDYES) {
                // create the dir(s)
                dwStatus = IsDirPathValid (strExpanded, TRUE, TRUE, rbIsValid);
                if (ERROR_SUCCESS != dwStatus || !rbIsValid ) {
                    // unable to create the dir, display message
                    if ( bOnFilesPage ) {
                        strMessage.Format ( IDS_FILE_DIR_NOT_MADE, rstrPath );
                    } else {
                        strMessage.Format ( IDS_DIR_NOT_MADE, rstrPath );
                    }
                    nMbReturn = pwndParent->MessageBox ( strMessage, rstrLogName, MB_OK  | MB_ICONERROR);
                    rbIsValid = FALSE;
                }
            } else if ( IDNO == nMbReturn ) {
                // then abort and return to the dialog
                if ( bOnFilesPage ) {
                    strMessage.LoadString ( IDS_FILE_DIR_CREATE_CANCEL );
                } else {
                    strMessage.LoadString ( IDS_DIR_CREATE_CANCEL );
                }
                nMbReturn = pwndParent->MessageBox ( strMessage, rstrLogName, MB_OK  | MB_ICONINFORMATION);
                rbIsValid = FALSE;
            } 
        } // else the path is OK
    }

    return dwStatus;
}

DWORD __stdcall
IsCommandFilePathValid (    
    CString&  rstrPath )
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    ResourceStateManager rsm;

    if ( !rstrPath.IsEmpty() ) {
    
        HANDLE hOpenFile;

        hOpenFile =  CreateFile (
                        rstrPath,
                        GENERIC_READ,
                        0,              // Not shared
                        NULL,           // Security attributes
                        OPEN_EXISTING,  //
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

        if ( ( NULL == hOpenFile ) 
                || INVALID_HANDLE_VALUE == hOpenFile ) {
            dwStatus = SMCFG_NO_COMMAND_FILE_FOUND;
        } else {
            CloseHandle(hOpenFile);
        }
    } else {
        dwStatus = SMCFG_NO_COMMAND_FILE_FOUND;
    }
    return dwStatus;
}

INT __stdcall
BrowseCommandFilename ( 
    CWnd* pwndParent,
    CString&  rstrFilename )
{
    INT iReturn  = IDCANCEL;
    OPENFILENAME    ofn;
    CString         strInitialDir;
    WCHAR           szFileName[MAX_PATH];
    WCHAR           szDrive[MAX_PATH];
    WCHAR           szDir[MAX_PATH];
    WCHAR           szExt[MAX_PATH];
    WCHAR           szFileFilter[MAX_PATH];
    LPWSTR          szNextFilter;
    CString         strTemp;

    ResourceStateManager    rsm;

    _wsplitpath((LPCWSTR)rstrFilename,
        szDrive, szDir, szFileName, szExt);

    strInitialDir = szDrive;
    strInitialDir += szDir;

    lstrcat (szFileName, szExt);

    ZeroMemory( &ofn, sizeof( OPENFILENAME ) );

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = pwndParent->m_hWnd;
    ofn.hInstance = GetModuleHandle(NULL);
    // load the file filter MSZ
    szNextFilter = &szFileFilter[0];
    strTemp.LoadString ( IDS_BROWSE_CMD_FILE_FILTER1 );
    lstrcpyW (szNextFilter, (LPCWSTR)strTemp);
    szNextFilter += strTemp.GetLength();
    *szNextFilter++ = 0;
    strTemp.LoadString ( IDS_BROWSE_CMD_FILE_FILTER2 );
    lstrcpyW (szNextFilter, (LPCWSTR)strTemp);
    szNextFilter += strTemp.GetLength();
    *szNextFilter++ = 0;
    strTemp.LoadString ( IDS_BROWSE_CMD_FILE_FILTER3 );
    lstrcpyW (szNextFilter, (LPCWSTR)strTemp);
    szNextFilter += strTemp.GetLength();
    *szNextFilter++ = 0;
    strTemp.LoadString ( IDS_BROWSE_CMD_FILE_FILTER4 );
    lstrcpyW (szNextFilter, (LPCWSTR)strTemp);
    szNextFilter += strTemp.GetLength();
    *szNextFilter++ = 0;
    *szNextFilter++ = 0; // msz terminator
    ofn.lpstrFilter = szFileFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1; // nFilterIndex is 1-based
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = (LPCTSTR)strInitialDir;
    strTemp.LoadString( IDS_BROWSE_CMD_FILE_CAPTION );
    ofn.lpstrTitle = (LPCWSTR)strTemp;
    ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = NULL;
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    iReturn = GetOpenFileName (&ofn);

    if ( IDOK == iReturn ) {
        // Update the fields with the new information
        rstrFilename = szFileName;
    } // else ignore if they canceled out

    return iReturn;
}

DWORD __stdcall 
FormatSmLogCfgMessage ( 
    CString& rstrMessage,
    HINSTANCE hResourceHandle,
    UINT uiMessageId,
    ... )
{
    DWORD dwStatus = ERROR_SUCCESS;
    LPTSTR lpszTemp = NULL;


    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, uiMessageId);

    dwStatus = ::FormatMessage ( 
                    FORMAT_MESSAGE_FROM_HMODULE 
                        | FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_MAX_WIDTH_MASK, 
                    hResourceHandle,
                    uiMessageId,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (LPTSTR)&lpszTemp,
                    0,
                    &argList );

    if ( 0 != dwStatus && NULL != lpszTemp ) {
        rstrMessage.GetBufferSetLength( lstrlen (lpszTemp) + 1 );
        rstrMessage.ReleaseBuffer();
        rstrMessage = lpszTemp;
    } else {
        dwStatus = GetLastError();
    }

    if ( NULL != lpszTemp ) {
        LocalFree( lpszTemp);
        lpszTemp = NULL;
    }

    va_end(argList);

    return dwStatus;
}

BOOL __stdcall 
FileRead (
    HANDLE hFile,
    void* lpMemory,
    DWORD nAmtToRead)
{  
    BOOL           bSuccess ;
    DWORD          nAmtRead ;

    bSuccess = ReadFile (hFile, lpMemory, nAmtToRead, &nAmtRead, NULL) ;
    return (bSuccess && (nAmtRead == nAmtToRead)) ;
}  // FileRead


BOOL __stdcall
FileWrite (
    HANDLE hFile,
    void* lpMemory,
    DWORD nAmtToWrite)
{  
   BOOL           bSuccess = FALSE;
   DWORD          nAmtWritten  = 0;
   DWORD          dwFileSizeLow, dwFileSizeHigh;
   LONGLONG       llResultSize;
    
   dwFileSizeLow = GetFileSize (hFile, &dwFileSizeHigh);
   // limit file size to 2GB

   if (dwFileSizeHigh > 0) {
      SetLastError (ERROR_WRITE_FAULT);
      bSuccess = FALSE;
   } else {
      // note that the error return of this function is 0xFFFFFFFF
      // since that is > the file size limit, this will be interpreted
      // as an error (a size error) so it's accounted for in the following
      // test.
      llResultSize = dwFileSizeLow + nAmtToWrite;
      if (llResultSize >= 0x80000000) {
          SetLastError (ERROR_WRITE_FAULT);
          bSuccess = FALSE;
      } else {
          // write buffer to file
          bSuccess = WriteFile (hFile, lpMemory, nAmtToWrite, &nAmtWritten, NULL) ;
          if (bSuccess) bSuccess = (nAmtWritten == nAmtToWrite ? TRUE : FALSE);
      }
   }

   return (bSuccess) ;
}  // FileWrite


static 
DWORD _stdcall
CheckDuplicateInstances (
    PDH_COUNTER_PATH_ELEMENTS* pFirst,
    PDH_COUNTER_PATH_ELEMENTS* pSecond )
{
    DWORD dwStatus = ERROR_SUCCESS;

    ASSERT ( 0 == lstrcmpi ( pFirst->szMachineName, pSecond->szMachineName ) ); 
    ASSERT ( 0 == lstrcmpi ( pFirst->szObjectName, pSecond->szObjectName ) );

    if ( 0 == lstrcmpi ( pFirst->szInstanceName, pSecond->szInstanceName ) ) { 
        if ( 0 == lstrcmpi ( pFirst->szParentInstance, pSecond->szParentInstance ) ) { 
            if ( pFirst->dwInstanceIndex == pSecond->dwInstanceIndex ) { 
                dwStatus = SMCFG_DUPL_SINGLE_PATH;
            }
        }
    } else if ( 0 == lstrcmpi ( pFirst->szInstanceName, _T("*") ) ) {
        dwStatus = SMCFG_DUPL_FIRST_IS_WILD;
    } else if ( 0 == lstrcmpi ( pSecond->szInstanceName, _T("*") ) ) {
        dwStatus = SMCFG_DUPL_SECOND_IS_WILD;
    }

    return dwStatus;
}

//++
// Description:
//     The function checks the relation between two counter paths
//
// Parameter:
//     pFirst - First counter path
//     pSecond - Second counter path
//
// Return:
//     ERROR_SUCCESS - The two counter paths are different
//     SMCFG_DUPL_FIRST_IS_WILD - The first counter path has wildcard name
//     SMCFG_DUPL_SECOND_IS_WILD - The second counter path has wildcard name
//     SMCFG_DUPL_SINGLE_PATH - The two counter paths are the same(may include 
//                              wildcard name) 
//     
//--
DWORD _stdcall
CheckDuplicateCounterPaths (
    PDH_COUNTER_PATH_ELEMENTS* pFirst,
    PDH_COUNTER_PATH_ELEMENTS* pSecond )
{
    DWORD dwStatus = ERROR_SUCCESS;

    if ( 0 == lstrcmpi ( pFirst->szMachineName, pSecond->szMachineName ) ) { 
        if ( 0 == lstrcmpi ( pFirst->szObjectName, pSecond->szObjectName ) ) { 
            if ( 0 == lstrcmpi ( pFirst->szCounterName, pSecond->szCounterName ) ) { 
                dwStatus = CheckDuplicateInstances ( pFirst, pSecond );
            } else if ( 0 == lstrcmpi ( pFirst->szCounterName, _T("*") ) 
                    || 0 == lstrcmpi ( pSecond->szCounterName, _T("*") ) ) {

                // Wildcard counter.
                BOOL bIsDuplicate = ( ERROR_SUCCESS != CheckDuplicateInstances ( pFirst, pSecond ) );

                if ( bIsDuplicate ) {
                    if ( 0 == lstrcmpi ( pFirst->szCounterName, _T("*") ) ) {
                        dwStatus = SMCFG_DUPL_FIRST_IS_WILD;
                    } else if ( 0 == lstrcmpi ( pSecond->szCounterName, _T("*") ) ) {
                        dwStatus = SMCFG_DUPL_SECOND_IS_WILD;
                    }
                }
            }
        }
    }

    return dwStatus;
};

// This routine extracts the filename portion from a given full-path filename
LPTSTR _stdcall 
ExtractFileName (LPTSTR pFileSpec)
{
   LPTSTR   pFileName = NULL ;
   TCHAR    DIRECTORY_DELIMITER1 = TEXT('\\') ;
   TCHAR    DIRECTORY_DELIMITER2 = TEXT(':') ;

   if (pFileSpec)
      {
      pFileName = pFileSpec + lstrlen (pFileSpec) ;

      while (*pFileName != DIRECTORY_DELIMITER1 &&
         *pFileName != DIRECTORY_DELIMITER2)
         {
         if (pFileName == pFileSpec)
            {
            // done when no directory delimiter is found
            break ;
            }
         pFileName-- ;
         }

      if (*pFileName == DIRECTORY_DELIMITER1 ||
         *pFileName == DIRECTORY_DELIMITER2)
         {
         // directory delimiter found, point the
         // filename right after it
         pFileName++ ;
         }
      }
   return pFileName ;
}  // ExtractFileName

//+--------------------------------------------------------------------------
//
//  Function:   InvokeWinHelp
//
//  Synopsis:   Helper (ahem) function to invoke winhelp.
//
//  Arguments:  [message]                 - WM_CONTEXTMENU or WM_HELP
//              [wParam]                  - depends on [message]
//              [wszHelpFileName]         - filename with or without path
//              [adwControlIdToHelpIdMap] - see WinHelp API
//
//  History:    06-10-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
InvokeWinHelp(
            UINT message,
            WPARAM wParam,
            LPARAM lParam,
    const   CString& rstrHelpFileName,
            DWORD adwControlIdToHelpIdMap[])
{
    
    //TRACE_FUNCTION(InvokeWinHelp);

    ASSERT ( !rstrHelpFileName.IsEmpty() );
    ASSERT ( adwControlIdToHelpIdMap );

    switch (message)
    {
        case WM_CONTEXTMENU:                // Right mouse click - "What's This" context menu
        {
            ASSERT ( wParam );

            if ( 0 != GetDlgCtrlID ( (HWND) wParam ) ) {
                WinHelp(
                    (HWND) wParam,
                    rstrHelpFileName,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)adwControlIdToHelpIdMap);
            }
        }
        break;

    case WM_HELP:                           // Help from the "?" dialog
    {
        const LPHELPINFO pHelpInfo = (LPHELPINFO) lParam;

        if (pHelpInfo ) {
            if ( pHelpInfo->iContextType == HELPINFO_WINDOW ) {
                WinHelp(
                    (HWND) pHelpInfo->hItemHandle,
                    rstrHelpFileName,
                    HELP_WM_HELP,
                    (DWORD_PTR) adwControlIdToHelpIdMap);
            }
        }
        break;
    }

    default:
        //Dbg(DEB_ERROR, "Unexpected message %uL\n", message);
        break;
    }
}

BOOL
FileNameIsValid ( CString* pstrFileName )
{
    CString strfname;
    CString strModName;
    
    TCHAR BufferSrc[MAX_PATH];
    LPTSTR Src;
    BOOL bRetVal = TRUE;
    strfname = *pstrFileName;  

    swprintf (BufferSrc,_T("%ws"), *pstrFileName);
    Src = BufferSrc;
    while(*Src != '\0'){
        if (*Src == '?' ||
            *Src == '\\' ||
            *Src == '*' ||
            *Src == '|' ||
            *Src == '<' ||
            *Src == '>' ||
            *Src == '/' ||
            *Src == ':' ||
            *Src == '\"'
            ){
            bRetVal = FALSE;
            break;
        }
        Src++;
    } 

    return bRetVal;
}

DWORD
FormatSystemMessage (
    DWORD       dwMessageId,
    CString&    rstrSystemMessage )
{
    DWORD dwStatus = ERROR_SUCCESS;
    HINSTANCE hPdh = NULL;
    DWORD dwFlags = 0; 
    LPTSTR  pszMessage = NULL;
    DWORD   dwChars;

    rstrSystemMessage.Empty();

    dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM;

    hPdh = LoadLibrary( _T("PDH.DLL") );

    if ( NULL != hPdh ) {
        dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
    }

    dwChars = FormatMessage ( 
                     dwFlags,
                     hPdh,
                     dwMessageId,
                     MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                     (LPTSTR)&pszMessage,
                     0,
                     NULL );
    if ( NULL != hPdh ) {
        FreeLibrary( hPdh );
    }

    if ( 0 == dwChars ) {
        dwStatus = GetLastError();
    }

    MFC_TRY
        if ( NULL != pszMessage ) {
            if ( _T('\0') != pszMessage[0] ) {
                rstrSystemMessage = pszMessage;
            }
        }
    MFC_CATCH_DWSTATUS

    if ( rstrSystemMessage.IsEmpty() ) {
        MFC_TRY
            rstrSystemMessage.Format ( _T("0x%08lX"), dwMessageId );
        MFC_CATCH_DWSTATUS
    }

    LocalFree ( pszMessage );

    return dwStatus;
}

ResourceStateManager::ResourceStateManager ()
:   m_hResInstance ( NULL )
{ 
    AFX_MODULE_STATE* pModuleState;
    HINSTANCE hNewResourceHandle;
    pModuleState = AfxGetModuleState();

    if ( NULL != pModuleState ) {
        m_hResInstance = pModuleState->m_hCurrentResourceHandle; 
    
        hNewResourceHandle = (HINSTANCE)GetModuleHandleW (_CONFIG_DLL_NAME_W_);
        pModuleState->m_hCurrentResourceHandle = hNewResourceHandle; 
    }
}

ResourceStateManager::~ResourceStateManager ()
{ 
    AFX_MODULE_STATE* pModuleState;

    pModuleState = AfxGetModuleState();
    if ( NULL != pModuleState ) {
        pModuleState->m_hCurrentResourceHandle = m_hResInstance; 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\ipropbag.h ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    ipropbag.h

Abstract:

    Header file for the private IPropertyBag interface.

--*/

#ifndef _IPROPBAG_H_
#define _IPROPBAG_H_

// Disable 64-bit warnings in atlctl.h
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4510 )
#pragma warning ( disable : 4610 )
#pragma warning ( disable : 4100 )
#include <atlctl.h>
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif
        
// Property Bag Class
class CImpIPropertyBag: 
	public IPropertyBag,
	public CComObjectRoot

{

    public:
DECLARE_NOT_AGGREGATABLE(CImpIPropertyBag)

BEGIN_COM_MAP(CImpIPropertyBag)
    COM_INTERFACE_ENTRY(IPropertyBag)
END_COM_MAP()
        
                CImpIPropertyBag();
        virtual ~CImpIPropertyBag(void);

        //IUnknown overrides
        STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG, AddRef) ();
        STDMETHOD_(ULONG, Release) ();

        //IConnectionPoint methods
        STDMETHOD(Read)(LPCOLESTR, VARIANT*, IErrorLog* );
        STDMETHOD(Write)(LPCOLESTR, VARIANT* );

        //Members not exposed by IPropertyBag
        LPTSTR  GetData ( void );
        DWORD   LoadData ( LPTSTR pszData, LPTSTR* ppszNextData = NULL );

    private:

        typedef struct _param_data {
            _param_data*    pNextParam; 
            TCHAR           pszPropertyName[MAX_PATH];
            VARIANT         vValue;
        } PARAM_DATA, *PPARAM_DATA;

        enum eConstants {
            eDefaultBufferLength = 8192
        };

        PPARAM_DATA FindProperty ( LPCTSTR pszPropName );
        void        DataListAddHead ( PPARAM_DATA );
        PPARAM_DATA DataListRemoveHead ( void );

        ULONG           m_cRef;        //Object reference count
        LPUNKNOWN       m_pUnkOuter;   //Controlling unknown
        LPTSTR          m_pszData;
        DWORD           m_dwCurrentDataLength;
        PPARAM_DATA     m_plistData;
        HINSTANCE       m_hModule;
};

typedef CImpIPropertyBag *PCImpIPropertyBag;

#endif // _IPROPBAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\logwarnd.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

     Logwarnd.cpp

Abstract:

    Implementation of the Log Type mismatch warning dialog.

--*/

#include "stdafx.h"
#include "smlogcfg.h"
#include "smtraceq.h"
#include "provprop.h"
#include "logwarnd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static ULONG
s_aulHelpIds[] =
{
    IDC_LWARN_CHECK_NO_MORE_LOG_TYPE,  IDH_CHECK_NO_MORE,
    0,0
};

/////////////////////////////////////////////////////////////////////////////
// CLogwarnd dialog


CLogWarnd::CLogWarnd(CWnd* pParent /*=NULL*/)
:   CDialog(CLogWarnd::IDD, pParent)
{
    //{{AFX_DATA_INIT(CLogWarnd)
    m_CheckNoMore = FALSE;
    m_ErrorMsg = 0 ;
    m_dwLogType = 0L;
    //}}AFX_DATA_INIT
}


void CLogWarnd::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CLogWarnd)
    DDX_Check(pDX, IDC_LWARN_CHECK_NO_MORE_LOG_TYPE, m_CheckNoMore);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLogWarnd, CDialog)
    //{{AFX_MSG_MAP(CLogWarnd)
        ON_BN_CLICKED(IDC_LWARN_CHECK_NO_MORE_LOG_TYPE,OnCheckNoMoreLogType)
        ON_WM_HELPINFO()
        ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLogWarnd message handlers
void
CLogWarnd::OnOK()
{
   
    UpdateData(TRUE);
    
    if (m_CheckNoMore)	{
        long nErr;
        HKEY hKey;
        DWORD dwWarnFlag;
        DWORD dwDataSize;
        DWORD dwDisposition;
        TCHAR RegValName[MAX_PATH];

        hKey = m_hKey;

        dwWarnFlag = m_CheckNoMore;
        
        switch (m_dwLogType){
          case SLQ_COUNTER_LOG:
             _stprintf(RegValName, _T("NoWarnCounterLog"));
             break;
          
          case SLQ_ALERT:
             _stprintf(RegValName, _T("NoWarnAlertLog"));
             break;
        }

        nErr = RegCreateKeyEx( HKEY_CURRENT_USER,
                               _T("Software\\Microsoft\\PerformanceLogsAndAlerts"),
                               0,
                               _T("REG_DWORD"),
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKey,
                               &dwDisposition);
        
        if( nErr == ERROR_SUCCESS ) {
            dwDataSize = sizeof(DWORD);
            nErr = RegSetValueEx(hKey,
                          RegValName,
                          NULL,
                          REG_DWORD,
                          (LPBYTE) &dwWarnFlag,
                          dwDataSize
                          );

           if( ERROR_SUCCESS != nErr )
               DisplayError( GetLastError(), _T("Close PerfLog User Key failed")  );

       }
    }
    CDialog::OnOK();
}

BOOL 
CLogWarnd::OnInitDialog() 
{
    CString cstrMessage , cstrWrongLog;

    SetWindowText ( m_strTitle );

    switch (m_dwLogType){
       case SLQ_COUNTER_LOG:
          cstrWrongLog.LoadString(IDS_COUNTER_LOG) ;
          break;
       case SLQ_ALERT:
          cstrWrongLog.LoadString(IDS_ALERT_LOG);
          break;
       case SMONCTRL_LOG:
          cstrWrongLog.LoadString( IDS_SMCTRL_LOG );
          break;
       default:
          cstrWrongLog.Format(L"");
          break;
    }

    
    switch(m_ErrorMsg){
        case ID_ERROR_COUNTER_LOG:
         cstrMessage.Format(IDS_ERRMSG_COUNTER_LOG,cstrWrongLog );
         break;

        case ID_ERROR_ALERT_LOG:
          cstrMessage.Format(IDS_ERRMSG_ALERT_LOG,cstrWrongLog);
         break;

        case ID_ERROR_TRACE_LOG:
          cstrMessage.Format(IDS_ERRMSG_TRACE_LOG,cstrWrongLog);    
         break;

        case ID_ERROR_SMONCTRL_LOG:
         cstrMessage.Format(IDS_ERRMSG_SMCTRL_LOG,cstrWrongLog);
         break;

    }
    
    ::SetWindowText((GetDlgItem(IDC_LWARN_MSG_WARN))->m_hWnd, cstrMessage);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}
VOID
CLogWarnd::OnCheckNoMoreLogType()
{
}
BOOL 
CLogWarnd::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    
    if ( pHelpInfo->iCtrlId >= IDC_LWARN_FIRST_HELP_CTRL_ID ) {
        InvokeWinHelp(WM_HELP, NULL, (LPARAM)pHelpInfo, m_strContextHelpFile, s_aulHelpIds);
    }

    return TRUE;
}

void 
CLogWarnd::OnContextMenu(CWnd* pWnd, CPoint /* point */) 
{
    InvokeWinHelp(WM_CONTEXTMENU, (WPARAM)(pWnd->m_hWnd), NULL, m_strContextHelpFile, s_aulHelpIds);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\newqdlg.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    newqdlg.cpp

Abstract:

    Implementation of the new log/alert creation dialog box.

--*/

#include "stdafx.h"
#include "smlogcfg.h"
#include "smcfghlp.h"
#include "NewQDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("SMLOGCFG(newqdlg.cpp)");

static ULONG
s_aulHelpIds[] =
{
    IDC_NEWQ_NAME_EDIT,     IDH_NEWQ_NAME_EDIT,
    0,0
};

/////////////////////////////////////////////////////////////////////////////
// CNewQueryDlg dialog

void CNewQueryDlg::InitAfxData ()
{
    //{{AFX_DATA_INIT(CNewQueryDlg)
    m_strName = _T("");
    //}}AFX_DATA_INIT
}

CNewQueryDlg::CNewQueryDlg(CWnd* pParent /*=NULL*/, BOOL bLogQuery)
    : CDialog(CNewQueryDlg::IDD, pParent)
{
    EnableAutomation();
    InitAfxData ();
    m_bLogQuery = bLogQuery;
}

void CNewQueryDlg::OnFinalRelease()
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CDialog::OnFinalRelease();
}

void CNewQueryDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNewQueryDlg)
    DDX_Text(pDX, IDC_NEWQ_NAME_EDIT, m_strName);
    DDV_MaxChars(pDX, m_strName, (SLQ_MAX_LOG_NAME_LEN));
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewQueryDlg, CDialog)
    //{{AFX_MSG_MAP(CNewQueryDlg)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CNewQueryDlg, CDialog)
    //{{AFX_DISPATCH_MAP(CNewQueryDlg)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_INewQueryDlg to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {4D4C90C3-C5A3-11D1-BF9B-00C04F94A83A}
static const IID IID_INewQueryDlg =
{ 0x4d4c90c3, 0xc5a3, 0x11d1, { 0xbf, 0x9b, 0x0, 0xc0, 0x4f, 0x94, 0xa8, 0x3a } };

BEGIN_INTERFACE_MAP(CNewQueryDlg, CDialog)
    INTERFACE_PART(CNewQueryDlg, IID_INewQueryDlg, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewQueryDlg message handlers

BOOL CNewQueryDlg::OnInitDialog() 
{
    CDialog::OnInitDialog();

    ResourceStateManager    rsm;
    
    if (!m_bLogQuery) {
        CString     csCaption;
        csCaption.LoadString (IDS_CREATE_NEW_ALERT);
        SetWindowText (csCaption);
    }

    // set the focus to the name edit
    GetDlgItem(IDC_NEWQ_NAME_EDIT)->SetFocus();
    SendDlgItemMessage(IDC_NEWQ_NAME_EDIT,EM_SETSEL,0,-1);
    return FALSE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void 
CNewQueryDlg::OnOK() 
{
    INT iPrevLength = 0;
    ResourceStateManager rsm;

    if ( UpdateData (TRUE) ) {
    
        iPrevLength = m_strName.GetLength();
        m_strName.TrimLeft();
        m_strName.TrimRight();

        if ( iPrevLength != m_strName.GetLength() ) {
            SetDlgItemText ( IDC_NEWQ_NAME_EDIT, m_strName );
        }

        if (m_strName.GetLength() == 0) {
            // need a name
            MessageBeep(MB_ICONEXCLAMATION);
            (GetDlgItem(IDC_NEWQ_NAME_EDIT))->SetFocus();
        } else {
            if ( !FileNameIsValid ( &m_strName ) ) {
                CString cstrTitle,cstrMsg;

                cstrTitle.LoadString(IDS_PROJNAME);  
                cstrMsg.LoadString (IDS_ERRMSG_INVALIDCHAR);
                MessageBox(
                   cstrMsg,
                   cstrTitle,
                   MB_OK| MB_ICONERROR);
                (GetDlgItem(IDC_NEWQ_NAME_EDIT))->SetFocus();

            } else {
                CDialog::OnOK();
            }
        }
    }
}

BOOL 
CNewQueryDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if ( pHelpInfo->iCtrlId >= IDC_NEWQ_FIRST_HELP_CTRL_ID ||
         pHelpInfo->iCtrlId == IDOK ||
         pHelpInfo->iCtrlId == IDCANCEL ) {
        
        InvokeWinHelp(WM_HELP, NULL, (LPARAM)pHelpInfo, m_strHelpFilePath, s_aulHelpIds);
    }
    return TRUE;
}

void 
CNewQueryDlg::OnContextMenu(CWnd* pWnd, CPoint /* point */) 
{
    InvokeWinHelp(WM_CONTEXTMENU, (WPARAM)(pWnd->m_hWnd), NULL, m_strHelpFilePath, s_aulHelpIds);

    return;
}

DWORD 
CNewQueryDlg::SetContextHelpFilePath( const CString& rstrPath )
{
    DWORD dwStatus = ERROR_SUCCESS;

    MFC_TRY
        m_strHelpFilePath = rstrPath; 
    MFC_CATCH_DWSTATUS

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\ipropbag.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    ipropbag.cpp

Abstract:

	Implementation of the private IPropertyBag interface used by
	the Performance Logs and Alerts MMC snap-in.

--*/

#include "stdafx.h"
#include "smcfgmsg.h"
#include "ipropbag.h"

USE_HANDLE_MACROS("SMLOGCFG(ipropbag.cpp)");

/*
 * CImpIPropertyBag interface implementation
 */

/*
 * CImpIPropertyBag::CImpIPropertyBag
 *
 * Purpose:
 *  Constructor.
 *
 * Return Value:
 */

CImpIPropertyBag::CImpIPropertyBag ()
:   m_cRef ( 0 ),
    m_pszData ( NULL ),
    m_dwCurrentDataLength ( 0 ),
    m_plistData ( NULL )
{
    m_hModule = (HINSTANCE)GetModuleHandleW (_CONFIG_DLL_NAME_W_);  
    return; 
}

/*
 * CImpIPropertyBag::~CImpIPropertyBag
 *
 * Purpose:
 *  Destructor.
 *
 * Return Value:
 */

CImpIPropertyBag::~CImpIPropertyBag ( void ) 
{   
    if ( NULL != m_pszData ) {
        delete m_pszData;
    }

    while ( NULL != m_plistData ) {
        PPARAM_DATA pData = DataListRemoveHead();
        VariantClear ( &pData->vValue ); 
        delete pData;
    }

    return; 
}


/*
 * CImpIPropertyBag::Read
 *
 * Purpose:
 *
 *  This function is called to read a property from the property bag.
 *
 * Parameters:
 *  pszPropName     Pointer to name of property to be read
 *  pVar            Pointer to the VARIANT to receive the property value
 *  pIErrorLog      Pointer to the caller's error log
 */

STDMETHODIMP 
CImpIPropertyBag::Read (
    LPCOLESTR pszPropName,  //Pointer to the property to be read
    VARIANT* pVar,          //Pointer to the VARIANT to receive the 
                            //property value
    IErrorLog* pIErrorLog ) //Pointer to the caller's error log    // can be null
{
    HRESULT     hr = S_OK;
    PPARAM_DATA pData;

    if (NULL==pszPropName)
        return ResultFromScode(E_POINTER);

    if (NULL==pVar)
        return ResultFromScode(E_POINTER);

    // Currently don't handle error log.
    ASSERT ( NULL == pIErrorLog );
    pIErrorLog;                             // Avoid compiler warning

    //Read the specified data into the passed variant.
    pData = FindProperty ( pszPropName );

    if ( NULL != pData ) {
        //VARTYPE vtTarget = vValue.vt;
        hr = VariantChangeType ( pVar, &pData->vValue, NULL, pVar->vt );
    } else {
        hr = E_INVALIDARG;
    }

    return hr;
}

/*
 * CImpIPropertyBag::Write
 *
 * Purpose:
 *
 *  This function is called to write a property to the property bag.
 *
 * Parameters:
 *  pszPropName     Pointer to name of property to be written
 *  pVar            Pointer to the VARIANT containing the property value
 */

STDMETHODIMP 
CImpIPropertyBag::Write (
    LPCOLESTR pszPropName,  //Pointer to the property to be written
    VARIANT* pVar )         //Pointer to the VARIANT containing the  
                            //property value and type
{
    HRESULT     hr = S_OK;
    VARIANT     vValueBstr;
    DWORD       dwNameLength;
    DWORD       dwDataLength;
    DWORD       dwDelimiterLength;
    CString     strParamTag;
    CString     strValueTag;
    CString     strEolTag;
    LPTSTR      pszNewBuffer = NULL;

    ResourceStateManager    rsm;

    if ( NULL != pszPropName && NULL != pVar ) {

        VariantInit ( &vValueBstr );

        hr = VariantChangeType ( &vValueBstr, pVar, NULL, VT_BSTR );

        if ( SUCCEEDED ( hr ) ) {

            MFC_TRY
    
                strParamTag.LoadString(IDS_HTML_PARAM_TAG);
                strValueTag.LoadString(IDS_HTML_VALUE_TAG);
                strEolTag.LoadString(IDS_HTML_VALUE_EOL_TAG);

                dwDelimiterLength = strParamTag.GetLength() + strValueTag.GetLength() + strEolTag.GetLength();
                dwNameLength = lstrlen ( pszPropName );
                dwDataLength = lstrlen ( W2T ( vValueBstr.bstrVal ) );

                // Include 1 for the ending NULL character in the length check.
                if ( m_dwCurrentDataLength 
                    < lstrlen ( m_pszData ) + dwNameLength + dwDataLength + dwDelimiterLength + 1 ) { 

                    m_dwCurrentDataLength += eDefaultBufferLength;

                    pszNewBuffer = new TCHAR[m_dwCurrentDataLength];
        
                    lstrcpy ( pszNewBuffer, L"");

                    if ( NULL != m_pszData ) {
                        lstrcpy ( pszNewBuffer, m_pszData );
                        delete m_pszData;
                    }
                    m_pszData = pszNewBuffer;
                    pszNewBuffer = NULL;
                }

                // Build the new string and add it to the current data.

                lstrcat ( m_pszData, strParamTag.GetBufferSetLength(strParamTag.GetLength()) );
                lstrcat ( m_pszData, pszPropName );
                lstrcat ( m_pszData, strValueTag.GetBufferSetLength(strValueTag.GetLength()) );
                lstrcat ( m_pszData, W2T(vValueBstr.bstrVal) );
                lstrcat ( m_pszData, strEolTag.GetBufferSetLength(strEolTag.GetLength()) );

            MFC_CATCH_HR_RETURN;

            if ( NULL != pszNewBuffer ) {
                delete pszNewBuffer;
            }
        }
    } else {
        hr = E_POINTER;
    }
    
    return hr;
}

/*
 * CImpIPropertyBag::GetData
 *
 * Purpose:
 *  Return pointer to the data buffer.
 *
 * Return Value:
 *  Pointer to the data buffer.
 */

LPTSTR
CImpIPropertyBag::GetData ( void ) 
{   
    return m_pszData;
}

/*
 * CImpIPropertyBag::LoadData
 *
 * Purpose:
 *  Load data from the supplied buffer into internal data structures.
 *  Return pointer to the next object, or NULL if no more objects.
 *
 * Return Value:
 *  Status.
 */

DWORD
CImpIPropertyBag::LoadData ( LPTSTR pszData, LPTSTR* ppszNextData ) 
{   
    DWORD   dwStatus = ERROR_SUCCESS;
    BOOL    bUnicode = TRUE;
    LPWSTR  pszDataW = NULL;
    LPWSTR  pszDataAllocW = NULL;
    LPWSTR  pszCurrentPos = NULL;        
    WCHAR   szGuid[uiSmLogGuidStringBufLen];
    WCHAR   szParamSearchTag[MAX_PATH];
    WCHAR   szValueSearchTag[MAX_PATH];
    WCHAR   szEooSearchTag[MAX_PATH];
    INT     iLength;

    USES_CONVERSION;

    szGuid[0] = L'\0';
    szParamSearchTag[0] = L'\0';
    szValueSearchTag[0] = L'\0';
    szEooSearchTag[0] = L'\0';
    
    if ( NULL != pszData ) {
        
        // Unicode search:  Begin the search after the first instance 
        // of the System Monitor class id.

        iLength = ::LoadString ( m_hModule, IDS_HTML_OBJECT_CLASSID, szGuid, uiSmLogGuidStringBufLen );
        if ( 0 < iLength ) {
            ::LoadString ( m_hModule, IDS_HTML_PARAM_SEARCH_TAG, szParamSearchTag, MAX_PATH );
        }
        if ( 0 < iLength ) {
            ::LoadString ( m_hModule, IDS_HTML_VALUE_SEARCH_TAG, szValueSearchTag, MAX_PATH );
        }
        if ( 0 < iLength ) {
            ::LoadString ( m_hModule, IDS_HTML_OBJECT_FOOTER, szEooSearchTag, MAX_PATH );
        }

        ASSERT ( sizeof(TCHAR) == sizeof(WCHAR) );

        if ( 0 < iLength ) {
            pszCurrentPos = wcsstr(pszData, szGuid );
        } else {
            dwStatus = ERROR_OUTOFMEMORY;
        }

        if ( NULL != pszCurrentPos ) {
            pszDataW = pszData;
            bUnicode = TRUE;
        } else {
            // Check for ANSI version:
            LPSTR   pszGuidA = NULL;
            LPSTR   pszCurrentPosA = NULL;
            LPSTR   pszDataA = (CHAR*) pszData;
             
            pszGuidA = W2A( szGuid );
            pszCurrentPosA = strstr ( pszDataA, pszGuidA );

            if ( NULL != pszCurrentPosA ) {
                pszDataAllocW = A2W ( pszDataA );
                pszDataW = pszDataAllocW;
                bUnicode = FALSE;
                pszCurrentPos = wcsstr(pszDataW, szGuid );
            }
        }
        
        if ( NULL != pszCurrentPos ) {
            WCHAR   szQuote[2];
            LPWSTR  pszEoo;

            wcscpy ( szQuote, L"\"" );

            // End of object is the first object footer tag after the first sysmon
            // class id found. If multiple objects in the data block, only parse the first sysmon.
            pszEoo = wcsstr(pszCurrentPos, szEooSearchTag);

            if ( NULL != pszEoo ) {            
                // Find first parameter tag.
                pszCurrentPos = wcsstr(pszCurrentPos, szParamSearchTag );

                while ( NULL != pszCurrentPos && pszCurrentPos < pszEoo ) {

                    LPWSTR      pszNextPos;
                    INT         lStrLength;
                    PPARAM_DATA pParamData;
                    LPWSTR      pszTemp;

                    // Store parameter/property name.
                    // Find one past first quote.
                    pszCurrentPos = wcsstr(pszCurrentPos, szQuote ) + 1;

                    // The param name is between first and second quote.
                    pszNextPos = wcsstr(pszCurrentPos, szQuote );

                    lStrLength = ( (INT)((UINT_PTR)pszNextPos - (UINT_PTR)pszCurrentPos) ) / sizeof ( WCHAR ) ;

                    try {
                        pParamData = new PARAM_DATA;

                        pParamData->pNextParam = NULL;
                        VariantInit ( &pParamData->vValue );
                        pParamData->vValue.vt = VT_BSTR;
                    } catch ( ... ) {
                        dwStatus = ERROR_OUTOFMEMORY;
                        break;
                    }

                    wcsncpy ( pParamData->pszPropertyName, pszCurrentPos, lStrLength );
                    pParamData->pszPropertyName[lStrLength] = TEXT ('\0');

                    // Find value tag and store parameter/property value.
                    // Find value tag
                    pszCurrentPos = wcsstr ( pszCurrentPos, szValueSearchTag );
                    // Find one past first quote
                    pszCurrentPos = wcsstr ( pszCurrentPos, szQuote ) + 1;
                    // The value is between first and second quote.
                    pszNextPos = wcsstr ( pszCurrentPos, szQuote );
                                
                    lStrLength = ( (INT)((UINT_PTR)pszNextPos - (UINT_PTR)pszCurrentPos) ) / sizeof ( WCHAR );

                    try {
                        pszTemp = new WCHAR[lStrLength+1];
                        wcsncpy ( pszTemp, pszCurrentPos, lStrLength );
                        pszTemp[lStrLength] = TEXT('\0');

                        pParamData->vValue.bstrVal = 
                                    SysAllocString ( pszTemp );

                        delete pszTemp;
                        DataListAddHead ( pParamData );

                        // Find next parameter/property tag.
                        pszCurrentPos = wcsstr(pszCurrentPos, szParamSearchTag );
                    } catch ( ... ) {
                        delete pParamData;
                        dwStatus = ERROR_OUTOFMEMORY;
                        break;
                    }
                } // While parameter tags exist for a single object.

                if ( NULL != ppszNextData ) {
                    LPWSTR pszNextEoo = NULL;
                    
                    pszEoo += lstrlenW ( szEooSearchTag );

                    pszNextEoo = wcsstr(pszEoo, szEooSearchTag);
                
                    // Successful. Return pointer to end of the current object, or NULL if all 
                    // objects have been processed.
                    if ( NULL != pszNextEoo ) {
                        if ( bUnicode ) {
                            *ppszNextData = pszEoo;
                        } else {
                            INT lStrLength;
                            lStrLength = ( (INT)((UINT_PTR)pszEoo - (UINT_PTR)pszDataW) ) / sizeof ( WCHAR ) ;
                           
                            *(CHAR**)ppszNextData = (CHAR*)pszData + lStrLength;
                        }
                    } else {
                        *ppszNextData = NULL;
                    }
                }                    
            } else {
                if ( NULL != ppszNextData ) {
                    *ppszNextData = NULL;
                }
                dwStatus = SMCFG_NO_HTML_SYSMON_OBJECT;
            }
        } else {
            if ( NULL != ppszNextData ) {
                *ppszNextData = NULL;
            }
            dwStatus = SMCFG_NO_HTML_SYSMON_OBJECT;
        }
    } else {
        if ( NULL != ppszNextData ) {
            *ppszNextData = NULL;
        }
        dwStatus = SMCFG_NO_HTML_SYSMON_OBJECT;
    }

    return dwStatus;
}

void
CImpIPropertyBag::DataListAddHead ( PPARAM_DATA pData ) 
{
    pData->pNextParam = m_plistData;
    m_plistData = pData;
    return;
}

CImpIPropertyBag::PPARAM_DATA
CImpIPropertyBag::DataListRemoveHead ( ) 
{
    PPARAM_DATA pReturnData;

    pReturnData = m_plistData;
    
    if ( NULL != m_plistData )
        m_plistData = m_plistData->pNextParam;
    
    return pReturnData;
}


CImpIPropertyBag::PPARAM_DATA
CImpIPropertyBag::FindProperty ( LPCTSTR pszPropName ) 
{
    PPARAM_DATA pReturnData;

    pReturnData = m_plistData;
    
    while ( NULL != pReturnData ) {
        if ( 0 == lstrcmpi ( pszPropName, pReturnData->pszPropertyName ) )
            break;
        pReturnData = pReturnData->pNextParam;
    }

    return pReturnData;
}

/////////////////////////////////////////////////////////////////////////////
// IUnknown implementation
// 


//---------------------------------------------------------------------------
//  Standard implementation
//
STDMETHODIMP
CImpIPropertyBag::QueryInterface
(
  REFIID  riid,
  LPVOID *ppvObj
)
{
  HRESULT hr = S_OK;

  do
  {
    if( NULL == ppvObj )
    {
      hr = E_INVALIDARG;
      break;
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
      *ppvObj = (IUnknown *)(IDataObject *)this;
    }
    else if (IsEqualIID(riid, IID_IDataObject))
    {
      *ppvObj = (IUnknown *)(IPropertyBag *)this;
    }
    else
    {
      hr = E_NOINTERFACE;
      *ppvObj = NULL;
      break;
    }

    // If we got this far we are handing out a new interface pointer on 
    // this object, so addref it.  
    AddRef();
  } while (0);

  return hr;

} // end QueryInterface()

//---------------------------------------------------------------------------
//  Standard implementation
//
STDMETHODIMP_(ULONG)
CImpIPropertyBag::AddRef()
{
  return InterlockedIncrement((LONG*) &m_cRef);
}

//---------------------------------------------------------------------------
//  Standard implementation
//
STDMETHODIMP_(ULONG)
CImpIPropertyBag::Release()
{
  ULONG cRefTemp;
  cRefTemp = InterlockedDecrement((LONG *)&m_cRef);

  if( 0 == cRefTemp )
  {
    delete this;
  }

  return cRefTemp;

} // end Release()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\globals.h ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation

Module Name:

    GLOBALS.H

Abstract:

    Utility functions and global variables for the Performance Logs and
	Alerts MMC snap-in.

--*/

#ifndef __GLOBALS_H_
#define __GLOBALS_H_

#include <pdh.h>
#include "DataObj.h"
#include "common.h"
#include <compuuid.h>   // for MyComputer guids

// global strings that don't need to be localized
const LPWSTR    szEmptyString = _T("");

extern HINSTANCE g_hinst;
extern CRITICAL_SECTION g_critsectInstallDefaultQueries;

//---------------------------------------------------------------------------
//  Property change stuff
//
#define PROPCHANGE_ATTRIBUTE   1
#define PROPCHANGE_FILENAME    2
#define PROPCHANGE_COMMENT     3
#define PROPCHANGE_TIMESTAMP   4

//#define __SHOW_TRACES
#ifdef __SHOW_TRACES
#undef __SHOW_TRACES
#endif

#ifdef __SHOW_TRACES
#define LOCALTRACE  ATLTRACE
#else
#define LOCALTRACE    
#endif

typedef struct tag_PROPCHANGE_DATA
{
  ULONG    fAttr2Change;         // Which attribute we're changing
  ULONG    nDataLength;          // Length of the new data
  VOID*    pData2Change;         // The new data

}PROPCHANGE_DATA;  


//---------------------------------------------------------------------------
//  Menu IDs
//
#define IDM_NEW_QUERY           40001
#define IDM_NEW_QUERY_FROM      40002
#define IDM_START_QUERY         40003
#define IDM_STOP_QUERY          40004
#define IDM_SAVE_QUERY_AS       40005

// Custom clipboard formats
#define CF_MMC_SNAPIN_MACHINE_NAME  _T("MMC_SNAPIN_MACHINE_NAME")
#define CF_INTERNAL             _T("SYSMON_LOG_INTERNAL_DATA")

#define MEM_UNINITIALIZED    -1

// Constants
const UINT uiSmLogGuidStringBufLen = 39;

// Generated with uuidgen. Each node must have a GUID associated with it.
const GUID GUID_SnapInExt = /* {7478EF65-8C46-11d1-8D99-00A0C913CAD4} */
{
    0x7478eF65,
    0x8c46,
    0x11d1,
    { 0x8d, 0x99, 0x0, 0xa0, 0xc9, 0x13, 0xca, 0xd4 }
};

// This one is for the main root node.
const GUID GUID_RootNode = /* {7478EF63-8C46-11d1-8D99-00A0C913CAD4} */
{ 
    0x7478ef63, 
    0x8c46, 
    0x11d1, 
    { 0x8d, 0x99, 0x0, 0xa0, 0xc9, 0x13, 0xca, 0xd4 } 
};

// These are the children nodes of the main root node
const GUID GUID_CounterMainNode = /* {7478EF66-8C46-11d1-8D99-00A0C913CAD4} */
{ 
    0x7478ef66, 
    0x8c46, 
    0x11d1, 
    { 0x8d, 0x99, 0x0, 0xa0, 0xc9, 0x13, 0xca, 0xd4 } 
};

const GUID GUID_TraceMainNode = /* {7478EF67-8C46-11d1-8D99-00A0C913CAD4} */
{ 
    0x7478ef67, 
    0x8c46, 
    0x11d1, 
    { 0x8d, 0x99, 0x0, 0xa0, 0xc9, 0x13, 0xca, 0xd4 } 
};

const GUID GUID_AlertMainNode = /* {7478EF68-8C46-11d1-8D99-00A0C913CAD4} */
{ 
    0x7478ef68, 
    0x8c46, 
    0x11d1, 
    { 0x8d, 0x99, 0x0, 0xa0, 0xc9, 0x13, 0xca, 0xd4 } 
};

// Obsolete after Beta 3:
const GUID GUID_MainNode = /* {7478EF64-8C46-11d1-8D99-00A0C913CAD4} */
{ 
    0x7478ef64, 
    0x8c46, 
    0x11d1, 
    { 0x8d, 0x99, 0x0, 0xa0, 0xc9, 0x13, 0xca, 0xd4 } 
};


extern "C" {
extern WCHAR GUIDSTR_TypeLibrary[];
extern WCHAR GUIDSTR_ComponentData[];
extern WCHAR GUIDSTR_Component[];
extern WCHAR GUIDSTR_RootNode[];
extern WCHAR GUIDSTR_MainNode[];    // Obsolete after Beta 3
extern WCHAR GUIDSTR_SnapInExt[];
extern WCHAR GUIDSTR_CounterMainNode[];
extern WCHAR GUIDSTR_TraceMainNode[];
extern WCHAR GUIDSTR_AlertMainNode[];
extern WCHAR GUIDSTR_PerformanceAbout[];
};


extern "C" {
    typedef struct _COMBO_BOX_DATA_MAP {
        UINT    nData;
        UINT    nResId;
    } COMBO_BOX_DATA_MAP, *PCOMBO_BOX_DATA_MAP;
}

extern const COMBO_BOX_DATA_MAP TimeUnitCombo[];
extern const DWORD dwTimeUnitComboEntries;

//---------------------------------------------------------------------------
// Global function defines
//
#define MsgBox(wszMsg, wszTitle) ::MessageBox(NULL, wszMsg, wszTitle, MB_OK)

int DebugMsg( LPWSTR wszMsg, LPWSTR wszTitle ); 

DWORD __stdcall CreateSampleFileName (
                    const   CString&  rstrQueryName, 
                    const   CString&  rstrMachineName, 
                    const   CString&  rstrFolderName, 
                    const   CString&  rstrInputBaseName,
                    const   CString&  rstrSqlName,
                            DWORD   dwSuffixFormat, 
                            DWORD   dwLogFileTypeValue,
                            DWORD   dwCurrentSerialNumber,
                            CString&  rstrReturnName );

DWORD __stdcall IsDirPathValid (
                    CString&  csPath,
                    BOOL bLastNameIsDirectory,
                    BOOL bCreateMissingDirs,
                    BOOL& rbIsValid);

DWORD __stdcall ProcessDirPath (
                            CString&  rstrPath,
                    const   CString&  rstrLogName,
                            CWnd*   pwndParent,
                            BOOL&   rbIsValid,
                            BOOL    bOnFilesPage);

INT __stdcall   BrowseCommandFilename ( CWnd* pwndParent, CString&  rstrFilename );

DWORD __stdcall FormatSmLogCfgMessage ( CString& rstrMessage,HINSTANCE hResourceHandle, UINT uiMessageId, ... );

BOOL _stdcall   FileRead ( HANDLE hFile, void* lpMemory, DWORD nAmtToRead );

BOOL _stdcall   FileWrite ( HANDLE hFile, void* lpMemory, DWORD nAmtToWrite );

// Pdh counter paths - return status

#define SMCFG_DUPL_NONE             ERROR_SUCCESS
#define SMCFG_DUPL_SINGLE_PATH      ((DWORD)0x00000001)
#define SMCFG_DUPL_FIRST_IS_WILD    ((DWORD)0x00000002)
#define SMCFG_DUPL_SECOND_IS_WILD   ((DWORD)0x00000003)

DWORD _stdcall
CheckDuplicateCounterPaths (
    PDH_COUNTER_PATH_ELEMENTS* pFirst,
    PDH_COUNTER_PATH_ELEMENTS* pSecond );

LPTSTR _stdcall
ExtractFileName ( LPTSTR pFileSpec );

//---------------------------------------------------------------------------
template<class TYPE>
inline void SAFE_RELEASE( TYPE*& pObj )
{
  if( NULL != pObj ) 
  { 
    pObj->Release(); 
    pObj = NULL; 
  } 
  else 
  { 
    LOCALTRACE( _T("Release called on NULL interface ptr\n") ); 
  }
} // end SAFE_RELEASE()


/////////////////////////////////////////////////////////////////////////////
//  We need a few functions to help work with dataobjects and
//  clipboard formats
//
HRESULT ExtractFromDataObject(LPDATAOBJECT lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);

CDataObject* ExtractOwnDataObject(LPDATAOBJECT lpDataObject);

VOID DisplayError( LONG nErrorCode, LPWSTR wszDlgTitle );
VOID DisplayError( LONG nErrorCode, UINT nTitleString );

HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType );
HRESULT ExtractMachineName( IDataObject* piDataObject, CString& rstrMachineName );

class ResourceStateManager 
{
public:
    ResourceStateManager(); 
    
    ~ResourceStateManager();

private:
    HINSTANCE m_hResInstance;

};

static const COMBO_BOX_DATA_MAP FileNameSuffixCombo[] = 
{
    {SLF_NAME_NNNNNN,       IDS_FS_NNNNNN},
    {SLF_NAME_MMDDHH,       IDS_FS_MMDDHH},
    {SLF_NAME_MMDDHHMM,     IDS_FS_MMDDHHMM},
    {SLF_NAME_YYYYDDD,      IDS_FS_YYYYDDD},
    {SLF_NAME_YYYYMM,       IDS_FS_YYYYMM},
    {SLF_NAME_YYYYMMDD,     IDS_FS_YYYYMMDD},
    {SLF_NAME_YYYYMMDDHH,   IDS_FS_YYYYMMDDHH}
};
static const DWORD dwFileNameSuffixComboEntries = sizeof(FileNameSuffixCombo)/sizeof(FileNameSuffixCombo[0]);

static const COMBO_BOX_DATA_MAP FileTypeCombo[] = 
{
    {SLF_CSV_FILE,      IDS_FT_CSV},
    {SLF_TSV_FILE,      IDS_FT_TSV},
    {SLF_BIN_FILE,      IDS_FT_BINARY},
    {SLF_BIN_CIRC_FILE, IDS_FT_BINARY_CIRCULAR},
    {SLF_SQL_LOG,       IDS_FT_SQL}
};
static const DWORD dwFileTypeComboEntries = sizeof(FileTypeCombo)/sizeof(FileTypeCombo[0]);

static const COMBO_BOX_DATA_MAP TraceFileTypeCombo[] = 
{
    {SLF_CIRC_TRACE_FILE,    IDS_FT_CIRCULAR_TRACE},
    {SLF_SEQ_TRACE_FILE,     IDS_FT_SEQUENTIAL_TRACE}
};
static const DWORD dwTraceFileTypeComboEntries = sizeof(TraceFileTypeCombo)/sizeof(TraceFileTypeCombo[0]);


/////////////////////////////////////////////////////////////////////////////
//  We need a few functions to help work with dataobjects and
//  clipboard formats
//

// Exception handling macros from snapin\corecopy\macros.h



//____________________________________________________________________________
//
//  Macro:      EXCEPTION HANDLING MACROS
//
//  Purpose:    Provide standard macros for exception-handling in
//              OLE servers.
//
//  History:    7/23/1996   JonN    Created
//
//  Notes:      Declare USE_HANDLE_MACROS("Component name") in each source
//              file before these are used.
//
//              These macros can only be used in function calls which return
//              type HRESULT.
//
//              Bracket routines which can generate exceptions
//              with STANDARD_TRY and STANDARD_CATCH.
//
//              Where these routines are COM methods requiring MFC
//              support, use MFC_TRY and MFC_CATCH instead.
//____________________________________________________________________________
//

#define USE_HANDLE_MACROS(component)                                        \
    static TCHAR* You_forgot_to_declare_USE_HANDLE_MACROS = _T(component);

#define STANDARD_TRY                                                        \
    try {

#define MFC_TRY                                                             \
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));                           \
    STANDARD_TRY

//
// CODEWORK don't quite have ENDMETHOD_READBLOCK working yet
//
#ifdef DEBUG
#define ENDMETHOD_STRING                                                    \
    "%s: The unexpected error can be identified as \"%s\" context %n\n"
#define ENDMETHOD_READBLOCK                                                 \
    {                                                                       \
        TCHAR szError[MAX_PATH];                                            \
        UINT nHelpContext = 0;                                              \
        if ( e->GetErrorMessage( szError, MAX_PATH, &nHelpContext ) )       \
        {                                                                   \
            TRACE( ENDMETHOD_STRING,                                        \
                You_forgot_to_declare_USE_HANDLE_MACROS,                    \
                szError,                                                    \
                nHelpContext );                                             \
        }                                                                   \
    }
#else
#define ENDMETHOD_READBLOCK
#endif


#define ERRSTRING_MEMORY       _T("%s: An out-of-memory error occurred\n")
#define ERRSTRING_FILE         _T("%s: File error 0x%lx occurred on file \"%s\"\n")
#define ERRSTRING_OLE          _T("%s: OLE error 0x%lx occurred\n")
#define ERRSTRING_UNEXPECTED   _T("%s: An unexpected error occurred\n")
#define BADPARM_STRING         _T("%s: Bad string parameter\n")
#define BADPARM_POINTER        _T("%s: Bad pointer parameter\n")

#define TRACEERR(s) TRACE( s, You_forgot_to_declare_USE_HANDLE_MACROS )
#define TRACEERR1(s,a) TRACE( s, You_forgot_to_declare_USE_HANDLE_MACROS,a )
#define TRACEERR2(s,a,b) TRACE( s, You_forgot_to_declare_USE_HANDLE_MACROS,a,b )

// Note that it is important to use "e->Delete();" and not "delete e;"
#define STANDARD_CATCH                                                      \
    }                                                                       \
    catch (CMemoryException* e)                                             \
    {                                                                       \
        TRACEERR( ERRSTRING_MEMORY );                                       \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
        return E_OUTOFMEMORY;                                               \
    }                                                                       \
    catch (COleException* e)                                                \
    {                                                                       \
        HRESULT hr = (HRESULT)e->Process(e);                                \
        TRACEERR1( ERRSTRING_OLE, hr );                                     \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
        ASSERT( FAILED(hr) );                                               \
        return hr;                                                          \
    }                                                                       \
    catch (CFileException* e)                                               \
    {                                                                       \
        HRESULT hr = (HRESULT)e->m_lOsError;                                \
        TRACEERR2( ERRSTRING_FILE, hr, e->m_strFileName );                  \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
        ASSERT( FAILED(hr) );                                               \
        return hr;                                                          \
    }                                                                       \
    catch (CException* e)                                                   \
    {                                                                       \
        TRACEERR( ERRSTRING_UNEXPECTED );                                   \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
        return E_UNEXPECTED;                                                \
    }

#define MFC_CATCH_HR_RETURN                                                 \
    STANDARD_CATCH

#define MFC_CATCH_HR                                                        \
    }                                                                       \
    catch (CMemoryException* e)                                             \
    {                                                                       \
        TRACEERR( ERRSTRING_MEMORY );                                       \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
        hr = E_OUTOFMEMORY;                                               \
    }                                                                       \
    catch (COleException* e)                                                \
    {                                                                       \
        hr = (HRESULT)e->Process(e);                                \
        TRACEERR1( ERRSTRING_OLE, hr );                                     \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
        ASSERT( FAILED(hr) );                                               \
    }                                                                       \
    catch (CFileException* e)                                               \
    {                                                                       \
        hr = (HRESULT)e->m_lOsError;                                        \
        TRACEERR2( ERRSTRING_FILE, hr, e->m_strFileName );                  \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
        ASSERT( FAILED(hr) );                                               \
    }                                                                       \
    catch (CException* e)                                                   \
    {                                                                       \
        TRACEERR( ERRSTRING_UNEXPECTED );                                   \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
        hr = E_UNEXPECTED;                                                  \
    }

#define MFC_CATCH_DWSTATUS                                                  \
    }                                                                       \
    catch (CMemoryException* e)                                             \
    {                                                                       \
        dwStatus = ERROR_OUTOFMEMORY;                                       \
        TRACEERR( ERRSTRING_MEMORY );                                       \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
    }                                                                       \
    catch (COleException* e)                                                \
    {                                                                       \
        dwStatus = e->Process(e);                                           \
        TRACEERR1( ERRSTRING_OLE, dwStatus );                               \
        ASSERT( ERROR_SUCCESS != dwStatus );                                \
        e->Delete();                                                        \
    }                                                                       \
    catch (CFileException* e)                                               \
    {                                                                       \
        dwStatus = e->m_lOsError;                                           \
        TRACEERR2( ERRSTRING_FILE, dwStatus, e->m_strFileName );            \
        ASSERT( ERROR_SUCCESS != dwStatus );                                \
        e->Delete();                                                        \
    }                                                                       \
    catch (CException* e)                                                   \
    {                                                                       \
        dwStatus = GetLastError();                                          \
        TRACEERR( ERRSTRING_UNEXPECTED );                                   \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
    }

#define MFC_CATCH_MINIMUM                                                   \
    }                                                                       \
    catch ( ... )                                                           \
    {                                                                       \
        TRACEERR( ERRSTRING_MEMORY );                                       \
    }                                                                       \

VOID
InvokeWinHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    const CString& rstrHelpFileName,
    DWORD   adwControlIdToHelpIdMap[]);

DWORD __stdcall
IsCommandFilePathValid (    
    CString&  rstrPath );

BOOL
FileNameIsValid(
    CString* pstrFileName );

DWORD _stdcall
FormatSystemMessage (
    DWORD       dwMessageId,
    CString&    rstrSystemMessage );

#endif // __GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\logwarnd.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

     LogWarnd.h

Abstract:

    Class definition for the expensive trace data warning dialog.

--*/

#ifndef _LOGWARND_H_
#define _LOGWARND_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Dialog controls
#define IDD_LOGTYPEWARN                     1400

#define IDC_LWARN_MSG_WARN                  1401
#define IDC_LWARN_FIRST_HELP_CTRL_ID        1402
#define IDC_LWARN_CHECK_NO_MORE_LOG_TYPE    1402

#define SMONCTRL_LOG                    10
#define ID_ERROR_COUNTER_LOG            0
#define ID_ERROR_TRACE_LOG              1
#define ID_ERROR_ALERT_LOG              2
#define ID_ERROR_SMONCTRL_LOG           3
#define ID_ERROR_UNKNOWN_LOG            4

/////////////////////////////////////////////////////////////////////////////
// CLogWarnd dialog
    
class CLogWarnd: public CDialog
{
// Construction
public:
                    CLogWarnd(CWnd* pParent = NULL);   // standard constructor
    virtual         ~CLogWarnd(){};

    void    SetTitleString ( CString& strTitle ) { m_strTitle = strTitle; };

// Dialog Data
    //{{AFX_DATA(CLogWarnd)
    enum { IDD = IDD_LOGTYPEWARN };
    BOOL    m_CheckNoMore;
    INT m_ErrorMsg;
    DWORD   m_dwLogType;
    HKEY    m_hKey;
    CString m_strContextHelpFile;
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLogWarnd)
    protected:
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CLogWarnd)
    afx_msg void OnCheckNoMoreLogType();
    afx_msg BOOL OnHelpInfo( HELPINFO* );
    afx_msg void OnContextMenu( CWnd*, CPoint );

    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CString m_strTitle;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // _LOGWARND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\newqdlg.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    newqdlg.h

Abstract:

    Header file for the create new query dialog.

--*/

#ifndef _NEWQDLG_H_
#define _NEWQDLG_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
                         
// Dialog controls
#define IDD_NEWQUERY                    900

#define IDC_NEWQ_FIRST_HELP_CTRL_ID     901
#define IDC_NEWQ_NAME_EDIT              901

/////////////////////////////////////////////////////////////////////////////
// CNewQueryDlg dialog

class CNewQueryDlg : public CDialog
{
// Construction
public:
    CNewQueryDlg(CWnd* pParent = NULL, BOOL bLogQuery = TRUE);   // alternate constructor

// Dialog Data
    void InitAfxData ( void );
    DWORD SetContextHelpFilePath( const CString& rstrPath );    

    //{{AFX_DATA(CNewQueryDlg)
    enum { IDD = IDD_NEWQUERY };
    CString m_strName;
    //}}AFX_DATA
    BOOL    m_bLogQuery; //if false then it's an alert query

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CNewQueryDlg)
    public:
    virtual void OnFinalRelease();
    protected:
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CNewQueryDlg)
    afx_msg BOOL OnHelpInfo( HELPINFO* );
    afx_msg void OnContextMenu( CWnd*, CPoint );
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CNewQueryDlg)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()

private:

    CString     m_strHelpFilePath;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _NEWQDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\provdlg.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    provdlg.cpp

Abstract:

    Implementation of the add providers dialog box.

--*/

#include "stdafx.h"
#include "provprop.h"
#include "smcfghlp.h"
#include "provdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static ULONG
s_aulHelpIds[] =
{
	IDC_PADD_PROVIDER_CAPTION,	IDH_PADD_PROVIDER_LIST,
	IDC_PADD_PROVIDER_LIST,	    IDH_PADD_PROVIDER_LIST,
    0,0
};

/////////////////////////////////////////////////////////////////////////////
// CProviderListDlg dialog


CProviderListDlg::CProviderListDlg(CWnd* pParent)
 : CDialog(CProviderListDlg::IDD, pParent),
      m_pProvidersPage ( NULL ),
      m_dwMaxHorizListExtent ( 0 )
{
//    EnableAutomation();

    //{{AFX_DATA_INIT(CProviderListDlg)
    //}}AFX_DATA_INIT
}

CProviderListDlg::~CProviderListDlg()
{
}

void CProviderListDlg::OnFinalRelease()
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CDialog::OnFinalRelease();
}

void CProviderListDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CProviderListDlg)
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CProviderListDlg, CDialog)
    //{{AFX_MSG_MAP(CProviderListDlg)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProviderListDlg message handlers

BOOL CProviderListDlg::OnInitDialog() 
{
    DWORD dwStatus;
    ResourceStateManager rsm;

    dwStatus = InitProviderListBox();

    CDialog::OnInitDialog();
    // set focus to the provider list box
    GetDlgItem(IDC_PADD_PROVIDER_LIST)->SetFocus();
    
    return FALSE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CProviderListDlg::OnOK() 
{
    CListBox * plbUnusedProviders = (CListBox *)GetDlgItem(IDC_PADD_PROVIDER_LIST);
    long    lNumProviders;
    INT iSelCount;

    UpdateData (TRUE);

    // update the provider array based on list box contents.
    
    iSelCount = plbUnusedProviders->GetSelCount();
    
    if ( 0 != iSelCount && LB_ERR != iSelCount ) {
 
        lNumProviders = plbUnusedProviders->GetCount();
        if (lNumProviders != LB_ERR) {
            long    lThisProvider;
            INT     iProvIndex;
            DWORD   dwStatus;

            // The Providers array has not changed since initialization, so no need to reload it here.

            lThisProvider = 0;
            while (lThisProvider < lNumProviders) {
                if ( 0 != plbUnusedProviders->GetSel( lThisProvider ) ) {
                    // Selected, so set the state to InQuery.
                    iProvIndex = (INT)plbUnusedProviders->GetItemData( lThisProvider );
                    m_arrProviders[iProvIndex] = CSmTraceLogQuery::eInQuery;
                }
                lThisProvider++; 
            }
            // Update the property page.
            ASSERT ( NULL != m_pProvidersPage );
            dwStatus = m_pProvidersPage->SetInQueryProviders ( m_arrProviders );
        }
    }
    
    CDialog::OnOK();
}

BOOL 
CProviderListDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    ASSERT( NULL != m_pProvidersPage );

    if ( pHelpInfo->iCtrlId >= IDC_PADD_FIRST_HELP_CTRL_ID ||
         pHelpInfo->iCtrlId == IDOK ||
         pHelpInfo->iCtrlId == IDCANCEL
        ) {
        InvokeWinHelp(WM_HELP, NULL, (LPARAM)pHelpInfo, m_pProvidersPage->GetContextHelpFilePath(), s_aulHelpIds);
    }

    return TRUE;
}

void 
CProviderListDlg::OnContextMenu(CWnd* pWnd, CPoint /* point */) 
{
    ASSERT( NULL != m_pProvidersPage );

    InvokeWinHelp(WM_CONTEXTMENU, (WPARAM)(pWnd->m_hWnd), NULL, m_pProvidersPage->GetContextHelpFilePath(), s_aulHelpIds);

    return;
}

//
// Helper functions
//

DWORD
CProviderListDlg::InitProviderListBox( void ) 
{
    DWORD dwStatus = ERROR_SUCCESS;
    CString	strProviderName;
    INT iProvIndex;
    DWORD   dwItemExtent;
    CListBox * plbUnusedProviders = (CListBox *)GetDlgItem(IDC_PADD_PROVIDER_LIST);

    ASSERT( NULL != m_pProvidersPage );

    //load counter list box from string in counter list
    plbUnusedProviders->ResetContent();

    dwStatus = m_pProvidersPage->GetInQueryProviders ( m_arrProviders );

    // List unused providers
    for ( iProvIndex = 0; iProvIndex < m_arrProviders.GetSize(); iProvIndex++ ) {
        if ( ( CSmTraceLogQuery::eNotInQuery == m_arrProviders[iProvIndex] )
            && ( m_pProvidersPage->IsActiveProvider ( iProvIndex ) ) ) {
            INT iAddIndex;
            m_pProvidersPage->GetProviderDescription( iProvIndex, strProviderName );
            iAddIndex = plbUnusedProviders->AddString ( strProviderName );
            plbUnusedProviders->SetItemData ( iAddIndex, ( DWORD ) iProvIndex );

            // update list box extent
            dwItemExtent = (DWORD)((plbUnusedProviders->GetDC())->GetTextExtent (strProviderName)).cx;
            if (dwItemExtent > m_dwMaxHorizListExtent) {
                m_dwMaxHorizListExtent = dwItemExtent;
                plbUnusedProviders->SetHorizontalExtent(dwItemExtent);
            }
        }
    }

    return dwStatus;
}

void    
CProviderListDlg::SetProvidersPage( CProvidersProperty* pPage ) 
{ 
    // The providers page is not always the parent, so store a separate pointer
    m_pProvidersPage = pPage; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\smonlog\smlogcfg\provprop.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    provprop.cpp

Abstract:

    Implementation of the trace providers general property page.

--*/

#include "stdafx.h"
#include <pdh.h>        // For xxx_TIME_VALUE
#include "smlogs.h"
#include "smcfgmsg.h"
#include "provdlg.h"
#include "warndlg.h"
#include "enabldlg.h"
#include "provprop.h"
#include <pdhp.h>
#include "dialogs.h"
#include "smlogres.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("SMLOGCFG(provprop.cpp)");

static ULONG
s_aulHelpIds[] =
{
    IDC_PROV_FILENAME_DISPLAY,      IDH_PROV_FILENAME_DISPLAY,
    IDC_PROV_PROVIDER_LIST,         IDH_PROV_PROVIDER_LIST,
    IDC_PROV_ADD_BTN,               IDH_PROV_ADD_BTN,
    IDC_PROV_REMOVE_BTN,            IDH_PROV_REMOVE_BTN,
    IDC_PROV_KERNEL_BTN,            IDH_PROV_KERNEL_BTN,
    IDC_PROV_OTHER_BTN,             IDH_PROV_OTHER_BTN,
    IDC_PROV_K_PROCESS_CHK,         IDH_PROV_K_PROCESS_CHK,
    IDC_PROV_K_THREAD_CHK,          IDH_PROV_K_THREAD_CHK,
    IDC_PROV_K_DISK_IO_CHK,         IDH_PROV_K_DISK_IO_CHK,
    IDC_PROV_K_NETWORK_CHK,         IDH_PROV_K_NETWORK_CHK,
    IDC_PROV_K_SOFT_PF_CHK,         IDH_PROV_K_SOFT_PF_CHK,
    IDC_PROV_K_FILE_IO_CHK,         IDH_PROV_K_FILE_IO_CHK,
    IDC_PROV_SHOW_PROVIDERS_BTN,    IDH_PROV_SHOW_PROVIDERS_BTN,
    IDC_RUNAS_EDIT,                 IDH_RUNAS_EDIT,
    IDC_SETPWD_BTN,                 IDH_SETPWD_BTN,
    0,0
};

/////////////////////////////////////////////////////////////////////////////
// CProvidersProperty property page

IMPLEMENT_DYNCREATE(CProvidersProperty, CSmPropertyPage)

CProvidersProperty::CProvidersProperty(MMC_COOKIE   lCookie, LONG_PTR hConsole)
:   CSmPropertyPage ( CProvidersProperty::IDD, hConsole )
// lCookie is really the pointer to the Log Query object
{
//    ::OutputDebugStringA("\nCProvidersProperty::CProvidersProperty");

    // save pointers from arg list
    m_pTraceLogQuery = reinterpret_cast <CSmTraceLogQuery *>(lCookie);

    m_dwMaxHorizListExtent = 0;
    m_dwTraceMode = eTraceModeApplication;

//  EnableAutomation();
    //{{AFX_DATA_INIT(CProvidersProperty)
    m_bNonsystemProvidersExist = TRUE;
    m_bEnableProcessTrace = FALSE;
    m_bEnableThreadTrace = FALSE;
    m_bEnableDiskIoTrace = FALSE;
    m_bEnableNetworkTcpipTrace = FALSE;
    m_bEnableMemMgmtTrace = FALSE;
    m_bEnableFileIoTrace = FALSE;
    //}}AFX_DATA_INIT
}

CProvidersProperty::CProvidersProperty() : CSmPropertyPage(CProvidersProperty::IDD)
{
    ASSERT (FALSE); // the constructor w/ args should be used instead

    EnableAutomation();
    //{{AFX_DATA_INIT(CProvidersProperty)
    m_bNonsystemProvidersExist = TRUE;
    m_bEnableProcessTrace = FALSE;
    m_bEnableThreadTrace = FALSE;
    m_bEnableDiskIoTrace = FALSE;
    m_bEnableNetworkTcpipTrace = FALSE;
    m_bEnableMemMgmtTrace = FALSE;
    m_bEnableFileIoTrace = FALSE;
    //}}AFX_DATA_INIT
    m_pTraceLogQuery = NULL;
}

CProvidersProperty::~CProvidersProperty()
{
//    ::OutputDebugStringA("\nCProvidersProperty::~CProvidersProperty");
}

void CProvidersProperty::OnFinalRelease()
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CPropertyPage::OnFinalRelease();
}

void CProvidersProperty::DoDataExchange(CDataExchange* pDX)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    DoProvidersDataExchange ( pDX );
    TraceModeRadioExchange ( pDX );

    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CProvidersProperty)
    DDX_Text(pDX, IDC_PROV_LOG_SCHED_TEXT, m_strStartText);
    DDX_Text(pDX, IDC_RUNAS_EDIT, m_strUserDisplay );
    DDX_Check(pDX, IDC_PROV_K_PROCESS_CHK, m_bEnableProcessTrace);
    DDX_Check(pDX, IDC_PROV_K_THREAD_CHK,  m_bEnableThreadTrace);
    DDX_Check(pDX, IDC_PROV_K_DISK_IO_CHK, m_bEnableDiskIoTrace);
    DDX_Check(pDX, IDC_PROV_K_NETWORK_CHK, m_bEnableNetworkTcpipTrace);
    DDX_Check(pDX, IDC_PROV_K_SOFT_PF_CHK, m_bEnableMemMgmtTrace);
    DDX_Check(pDX, IDC_PROV_K_FILE_IO_CHK, m_bEnableFileIoTrace);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CProvidersProperty, CSmPropertyPage)
    //{{AFX_MSG_MAP(CProvidersProperty)
    ON_BN_CLICKED(IDC_PROV_KERNEL_BTN, OnProvTraceModeRdo)
    ON_BN_CLICKED(IDC_PROV_OTHER_BTN, OnProvTraceModeRdo)
    ON_BN_CLICKED(IDC_PROV_SHOW_PROVIDERS_BTN, OnProvShowProvBtn)
    ON_BN_CLICKED(IDC_PROV_ADD_BTN, OnProvAddBtn)
    ON_BN_CLICKED(IDC_PROV_REMOVE_BTN, OnProvRemoveBtn)
    ON_LBN_DBLCLK(IDC_PROV_PROVIDER_LIST, OnDblclkProvProviderList)
    ON_LBN_SELCANCEL(IDC_PROV_PROVIDER_LIST, OnSelcancelProvProviderList)
    ON_LBN_SELCHANGE(IDC_PROV_PROVIDER_LIST, OnSelchangeProvProviderList)
    ON_BN_CLICKED(IDC_PROV_K_PROCESS_CHK, OnProvKernelEnableCheck)
    ON_BN_CLICKED(IDC_PROV_K_THREAD_CHK, OnProvKernelEnableCheck)
    ON_EN_CHANGE( IDC_RUNAS_EDIT, OnChangeUser )
    ON_BN_CLICKED(IDC_PROV_K_DISK_IO_CHK, OnProvKernelEnableCheck)
    ON_BN_CLICKED(IDC_PROV_K_NETWORK_CHK, OnProvKernelEnableCheck)
    ON_BN_CLICKED(IDC_PROV_K_FILE_IO_CHK, OnProvKernelEnableCheck)
    ON_BN_CLICKED(IDC_PROV_K_SOFT_PF_CHK, OnProvKernelEnableCheck)
    ON_BN_CLICKED(IDC_SETPWD_BTN, OnPwdBtn)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CProvidersProperty, CSmPropertyPage)
    //{{AFX_DISPATCH_MAP(CProvidersProperty)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IProvidersProperty to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {65154EA9-BDBE-11D1-BF99-00C04F94A83A}
static const IID IID_IProvidersProperty =
{ 0x65154ea9, 0xbdbe, 0x11d1, { 0xbf, 0x99, 0x0, 0xc0, 0x4f, 0x94, 0xa8, 0x3a } };

BEGIN_INTERFACE_MAP(CProvidersProperty, CSmPropertyPage)
    INTERFACE_PART(CProvidersProperty, IID_IProvidersProperty, Dispatch)
END_INTERFACE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CProvidersProperty message handlers

void 
CProvid